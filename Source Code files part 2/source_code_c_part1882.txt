NG cpNewFirstVisible;

	if(_fNoUpdateView)
		return fReturn;

	AssertSz(_ped->_fInPlaceActive, "CDisplayML::UpdateView(...) called when inactive");

	if(rtp.GetCp() > _cpCalcMax || _fNeedRecalc)
	{
		// We haven't even calc'ed this far, so don't bother with updating
		// here.  Background recalc will eventually catch up to us.
		return TRUE;
	}

	AssertSz(rtp.GetCp() <= _cpCalcMax, "CDisplayML::UpdateView(...) - rtp > _cpCaclMax");

	_ped->TxGetClientRect(&rcClient);
	GetViewRect(rcView, &rcClient);

	if(psel && !psel->PuttingChar())
		psel->ClearCchPending();

	DeferUpdateScrollBar();

	// In general, background recalc should not start until both the scroll 
	// position is beyond the visible view and the cp is beyond the first visible 
	// character. However, for the recalc we will only wait on the height. 
	// Later calls to WaitForRecalc will wait on cpFirstVisible if that is 
	// necessary.
	_yWait = _yScroll + _yHeightView;
	_cpWait = -1;

	if(!RecalcLines(rtp, cchOld, cchNew, FALSE, TRUE, &led))
	{
		// We're in trouble now, the recalc failed. Let's try to get
		// out of this with our head still mostly attached
		InitVars();
		fRecalcVisible = TRUE;
		fReturn = FALSE;
		_ped->TxInvalidateRect (NULL, FALSE);
		fNeedViewChange = TRUE;
		goto Exit;
	}

	if(!_ped->GetTextLength())
	{
		if(LineCount())					// There are currently elements in
			Clear(AF_DELETEMEM);		//  line array, so zap them

		// This is an empty control so create one empty line
		CreateEmptyLine();
	}

	if(_xWidth <= _xWidthView)
    {
		// x scroll range is smaller than the view width, force x scrolling position = 0
		// we have to redraw all when this means scrolling back to home.
		// Problem lines are lines with trailing spaces crossing _xWidthView. UpdateCaret forces redraw
		// only when such lines are growing, misses shrinking.
		
		if (_xScroll != 0)
			{
			_ped->TxInvalidateRect(NULL, FALSE);			//REVIEW: find a smaller rectange?
			}
			
		_xScroll = 0;

    }

	if(led._yFirst >= _yScroll + _yHeightView)
	{
		// Update is after view: don't do anything
		fRecalcVisible = FALSE;
		AssertNr(VerifyFirstVisible());
		goto finish;
	}
	else if(led._yMatchNew <= _yScroll + _dyFirstVisible &&
			led._yMatchOld <= _yScroll + _dyFirstVisible &&
			_yScroll < _yHeight)
	{
		if (_yHeight != 0)
		{
			// Update is entirely before view: just update scroll position
			// but don't touch the screen
			_yScroll += led._yMatchNew - led._yMatchOld;
			_iliFirstVisible += led._iliMatchNew - led._iliMatchOld;
			_iliFirstVisible = max(_iliFirstVisible, 0);

			_cpFirstVisible += led._cpMatchNew - led._cpMatchOld;
			_cpFirstVisible = min(_ped->GetTextLength(), _cpFirstVisible);
			_cpFirstVisible = max(0, _cpFirstVisible);
			fRecalcVisible = FALSE;
		}
		else
		{
			// Odd outline case. Height of control can be recalc'd to zero due 
			// when outline mode collapses all lines to 0. Example of how to 
			// do this is tell outline to collapse to heading 1 and there is none.
			_yScroll = 0;
			_iliFirstVisible = 0;
			_cpFirstVisible = 0;
		}

		AssertNr(VerifyFirstVisible());
	}
	else
	{
		// Update overlaps visible view
		RECT rc = rcClient;
        RECT rcUpdate;

		// Do we need to resync the first visible?  Note that this if check
		// is mostly an optmization; we could decide to _always_ recompute
		// this _iliFirstVisible if we wanted to.
		if ( cpStartOfUpdate <= _cpFirstVisible || 
			led._iliMatchOld <= _iliFirstVisible ||
			led._iliMatchNew <= _iliFirstVisible ||
			led._iliFirst <= _iliFirstVisible )
		{
			// Edit overlaps the first visible. We try to maintain
			// approximately the same place in the file visible.
			cpNewFirstVisible = _cpFirstVisible;

			if(_iliFirstVisible - 1 == led._iliFirst)
			{
				// Edit occurred on line before visible view. Most likely
				// this means that the first character got pulled back to
				// the previous line so we want that line to be visible.
				cpNewFirstVisible = led._cpFirst;
			}

			// Change first visible entries because CLinePtr::RpSetCp() and
			// YPosFromLine() use them, but they're not valid
			_dyFirstVisible = 0;
			_cpFirstVisible = 0;
			_iliFirstVisible = 0;
			_yScroll = 0;

			// With certain formatting changes, it's possible for 
			// cpNewFirstVisible to be less that what's been calculated so far 
			// in RecalcLines above. Wait for things to catch up.

			WaitForRecalc(cpNewFirstVisible, -1);

			// TODO: make following more efficient (work around rp.CalculateCp()
			// all the way from zero)
			// Recompute scrolling position and first visible values after edit
		    CLinePtr rp(this);
   			rp.RpSetCp(cpNewFirstVisible, FALSE);
   			_yScroll = YposFromLine(rp);
   			_cpFirstVisible = rp.CalculateCp() - rp.RpGetIch();
   			_iliFirstVisible = rp;
		}
		AssertNr(VerifyFirstVisible());

		// Is there a match in the display area? - this can only happen if the
		// old match is on the screen and the new match will be on the screen
		if (led._yMatchOld < yScrollOld + _yHeightView &&
			led._yMatchNew < _yScroll + _yHeightView)
		{
			// We have a match inside visible view
			// Scroll the part that is below the old y pos of the match
			// or invalidate if the new y of the match is now below the view
			rc.top = rcView.top + (INT) (led._yMatchOld - yScrollOld);
			if(rc.top < rc.bottom)
			{
				// Calculate difference between new and old screen positions
				const INT dy = (INT) ((led._yMatchNew - _yScroll)) 
					- (led._yMatchOld - yScrollOld);

				if(dy)
				{
					if(!IsTransparent())
					{
    					_ped->TxScrollWindowEx(0, dy, &rc, &rcView, NULL, &rcUpdate, 0);
		    			_ped->TxInvalidateRect(&rcUpdate, FALSE);
						fNeedViewChange = TRUE;

    					if(dy < 0)
	    				{
		    				rc.top = rc.bottom + dy;
			    			_ped->TxInvalidateRect(&rc, FALSE);
							fNeedViewChange = TRUE;
				    	}
    				}
                    else
                    {
						// Adjust rect since we don't scroll in transparent
						// mode
						RECT	rcInvalidate = rc;
   						rcInvalidate.top += dy;

                        _ped->TxInvalidateRect(&rcInvalidate, FALSE);
						fNeedViewChange = TRUE;
                    }
				}
			}
			else
			{
				rc.top = rcView.top + led._yMatchNew - _yScroll;
				_ped->TxInvalidateRect(&rc, FALSE);
				fNeedViewChange = TRUE;
			}

			// Since we found that the new match falls on the screen, we can
			// safely set the bottom to the new match since this is the most
			// that can have changed.
			rc.bottom = rcView.top 
				+ (INT) (max(led._yMatchNew, led._yMatchOld) - _yScroll);
		}

		rc.top = rcView.top + (INT) (led._yFirst - _yScroll);

		// Set first line edited to be rendered using off-screen bitmap
		if (led._iliFirst < Count() && !IsTransparent() &&
			!(Elem(led._iliFirst)->_bFlags & fliUseOffScreenDC))
		{	
			Elem(led._iliFirst)->_bFlags |= (fliOffScreenOnce |	fliUseOffScreenDC);
		}
		
		// Invalidate part of update that is above match (if any)
		_ped->TxInvalidateRect (&rc, FALSE);
		fNeedViewChange = TRUE;
	}

finish:
	if(fRecalcVisible)
	{
		fReturn = WaitForRecalcView();
		if(!fReturn) 
			return FALSE;
	}
	if(fNeedViewChange)
		_ped->GetHost()->TxViewChange(FALSE);

	CheckView();

	// We only need to resize if size needed to display object has changed
	if (yHeightOld != _yHeight || yScrollHeightOld != GetMaxYScroll() ||
		xWidthOld  != _xWidth)
	{
		if(FAILED(RequestResize()))
			_ped->GetCallMgr()->SetOutOfMemory();
	}
	if(DoDeferredUpdateScrollBar())
	{
		if(FAILED(RequestResize()))
			_ped->GetCallMgr()->SetOutOfMemory();
		DoDeferredUpdateScrollBar();
	}

Exit:
	return fReturn;
}

void CDisplayML::InitVars()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::InitVars");

	_yScroll = _xScroll = 0;
	_iliFirstVisible = 0;
	_cpFirstVisible = _cpMin = 0;
	_dyFirstVisible = 0;
}

/*
 *	CDisplayML::GetCliVisible(pcpMostVisible)
 *
 *	@mfunc	
 *		Get count of visible lines and update _cpMostVisible for PageDown()
 *
 *	@rdesc
 *		count of visible lines
 */
LONG CDisplayML::GetCliVisible(
	LONG* pcpMostVisible, 				//@parm Returns cpMostVisible
	BOOL fLastCharOfLastVisible) const 	//@parm Want cp of last visible char
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::GetCliVisible");

	LONG cli	 = 0;							// Initialize count
	LONG ili	 = _iliFirstVisible;			// Start with 1st visible line
	LONG yHeight = _dyFirstVisible;
    LONG cp;
	LONG cchWhite = 0;

	for(cp = _cpFirstVisible;
		yHeight < _yHeightView && ili < Count();
		cli++, ili++)
	{
		const CLine* pli = Elem(ili);
		yHeight	+= pli->GetHeight();

		if (fLastCharOfLastVisible)
		{
			if (yHeight > _yHeightView)
			{
				// Back up cp to last visible character
				cp -= cchWhite;
				break;
			}

			// Save last lines white space to adjust cp if
			// this is the last fully displayed line.
			cchWhite = pli->_cchWhite;
		}
		cp += pli->_cch;
	}

    if(pcpMostVisible)
        *pcpMostVisible = cp;

	return cli;
}

//==================================  Inversion (selection)  ============================

/*
 *	CDisplayML::InvertRange(cp, cch)
 *
 *	@mfunc
 *		Invert a given range on screen (for selection)
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplayML::InvertRange (
	LONG cp,					//@parm Active end of range to invert
	LONG cch,					//@parm Signed length of range
	SELDISPLAYACTION selAction)	//@parm Describes what we are doing to the selection
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::InvertRange");

	LONG	 cpMost;
	RECT	 rc;
	RECT     rcView;
	CLinePtr rp(this);
	CRchTxtPtr  rtp(_ped);
	LONG	 y;
	LONG	 cpActive = _ped->GetSel()->GetCp();

    AssertSz(_ped->_fInPlaceActive,
    	"CDisplayML::InvertRange() called when not in-place active");

	if(cch < 0)						// Define cpMost, set cp = cpMin,
	{								//  and cch = |cch|
		cpMost = cp - cch;
		cch = -cch;
	}
	else
	{
		cpMost = cp;
		cp -= cch;
	}

#ifdef LINESERVICES
	if (g_pols)
		g_pols->DestroyLine(this);
#endif

	// If an object is being inverted, and nothing else is being inverted,
	// delegate to the ObjectMgr.  If fIgnoreObj is TRUE we highlight normally
	if (cch == 1 && _ped->GetObjectCount() &&
		(selAction == selSetNormal || selAction == selSetHiLite))
	{
		CObjectMgr* pobjmgr = _ped->GetObjectMgr();

		rtp.SetCp(cp);
		if(rtp.GetChar() == WCH_EMBEDDING)
		{
			if(pobjmgr)
				pobjmgr->HandleSingleSelect(_ped, cp, selAction == selSetHiLite);
			return TRUE;
		}
	}

	// If display is frozen, just update recalc region and move on.
	if(_padc)
	{
		AssertSz(cp >= 0, "CDisplayML::InvertRange: range (cp) goes below"
				"zero!!" );
		// Make sure these values are bounded.
		if(cp > _ped->GetTextLength())	// Don't bother updating region;
			return TRUE;				//  it's out of bounds

		if(cp + cch > _ped->GetTextLength())
			cch -= cp + cch - _ped->GetTextLength();

		_padc->UpdateRecalcRegion(cp, cch, cch);
		return TRUE;
	}

	if(!WaitForRecalcView())			// Ensure all visible lines are
		return FALSE;					//  recalc'd

	GetViewRect(rcView);				// Get view rectangle
	
	// Compute first line to invert and where to start on it
	if(cp >= _cpFirstVisible)
	{
		POINT pt;
		rtp.SetCp(cp);
		if(PointFromTp(rtp, NULL, FALSE, pt, &rp, TA_TOP) < 0)
			return FALSE;

		rc.left = pt.x;
		rc.top = pt.y;
	}
	else
	{
		cp = _cpFirstVisible;
		rp = _iliFirstVisible;
		rc.left = -1;
		rc.top = rcView.top + _dyFirstVisible;
	}				

	// Loop on all lines of range
	while (cp < cpMost && rc.top < rcView.bottom && rp.IsValid())
	{
		// Calculate rc.bottom first because rc.top takes into account
		// the dy of the first visible on the first loop.
		y = rc.top;
		y += rp->GetHeight();
		rc.bottom = min(y, rcView.bottom);
        rc.top = max(rc.top, rcView.top);

		if(rc.left == -1)
			rc.left = rp->_xLeft - _xScroll + rcView.left;

		//If we are inverting the active end of the selection, draw it offscreen
		//to minimize flicker.
		if (IN_RANGE(cp - rp.RpGetIch(), cpActive, cp - rp.RpGetIch() + rp->_cch) && 
			!IsTransparent() && !(rp->_bFlags & fliUseOffScreenDC))
		{	
			rp->_bFlags |= (fliOffScreenOnce | fliUseOffScreenDC);
		}

		cp += rp->_cch - rp.RpGetIch();

        rc.left = rcView.left;
        rc.right = rcView.right;

	    _ped->TxInvalidateRect(&rc, TRUE);
		rc.top = rc.bottom;
		if(!rp.NextRun())
			break;
	}
	_ped->TxUpdateWindow();				// Make sure window gets repainted
	return TRUE;
}


//===================================  Scrolling  =============================

/*
 *	CDisplay::GetYScroll()
 *
 *	@mfunc
 *		Returns vertical scrolling position
 */
LONG CDisplayML::GetYScroll() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::GetYScroll");

    return _yScroll;
}

/*
 *	CDisplay::VScroll(wCode, yPos)
 *
 *	@mfunc
 *		Scroll the view vertically in response to a scrollbar event
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		LRESULT formatted for WM_VSCROLL message		
 */
LRESULT CDisplayML::VScroll(
	WORD wCode,		//@parm Scrollbar event code
	LONG yPos)		//@parm Thumb position (yPos <lt> 0 for EM_SCROLL behavior)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::VScroll");

	LONG		cliVisible;
	LONG		dy = 0;
	BOOL		fTracking = FALSE;
	LONG		i;
	const LONG	ili = _iliFirstVisible;
	CLine *		pli = NULL;
	INT			yHeightSys = GetYHeightSys();
	LONG		yScroll = _yScroll;
    
    AssertSz(_ped->_fInPlaceActive, "CDisplay::VScroll() called when not in-place");

	if(yPos)
	{
		// Convert this from 16-bit to 32-bit if necessary.
		yPos = ConvertScrollToYPos(yPos);
	}

	yPos = min(yPos, _yHeight);

	switch(wCode)
	{
	case SB_BOTTOM:
		if(yPos < 0)
			return FALSE;
		WaitForRecalc(_ped->GetTextLength(), -1);
		yScroll = _yHeight;
		break;

	case SB_LINEDOWN:
		cliVisible = GetCliVisible();
		if(_iliFirstVisible + cliVisible < Count()
			&& 0 == _dyFirstVisible)
		{
			i = _iliFirstVisible + cliVisible;
			pli = Elem(i);
			if(IsInOutlineView())
			{	// Scan for uncollapsed line
				for(; pli->_fCollapsed && i < Count();
					pli++, i++);
			}
			if(i < Count())
				dy = pli->_yHeight;
		}
		else if(cliVisible > 1)
		{
			pli = Elem(_iliFirstVisible);
			dy = _dyFirstVisible;
			// TODO: scan until find uncollapsed line
			dy += pli->_yHeight;
		}
		else
			dy = _yHeight - _yScroll;

		if(dy >= _yHeightView)
			dy = yHeightSys;

		// Nothing to scroll, early exit
		if ( !dy )
			return MAKELRESULT(0, TRUE); 

		yScroll += dy;
		break;

	case SB_LINEUP:
		if(_iliFirstVisible > 0)
		{
			pli = Elem(_iliFirstVisible - 1);
			// TODO: scan until find uncollapsed line
			dy = pli->_yHeight;
		}
		else if(yScroll > 0)
			dy = min(yScroll, yHeightSys);

		if(dy > _yHeightView)
			dy = yHeightSys;
		yScroll -= dy;
		break;

	case SB_PAGEDOWN:
		cliVisible = GetCliVisible();
		yScroll += _yHeightView;
		if(yScroll < _yHeight && cliVisible > 0)
		{
			// TODO: Scan until find uncollapsed line
			dy = Elem(_iliFirstVisible + cliVisible - 1)->_yHeight;
			if(dy >= _yHeightView)
				dy = yHeightSys;

			else if(dy > _yHeightView - dy)
			{
				// Go at least a line if line is very big
				dy = _yHeightView - dy;
			}
			yScroll -= dy;
		}
		break;

	case SB_PAGEUP:
		cliVisible = GetCliVisible();
		yScroll -= _yHeightView;

		if (yScroll < 0)
		{
			// Scroll position can't be negative and we don't
			// need to back up to be sure we display a full line.
			yScroll = 0;
		}
		else if(cliVisible > 0)
		{
			// TODO: Scan until find uncollapsed line
			dy = Elem(_iliFirstVisible)->_yHeight;
			if(dy >= _yHeightView)
				dy = yHeightSys;

			else if(dy > _yHeightView - dy)
			{
				// Go at least a line if line is very big
				dy = _yHeightView - dy;
			}

			yScroll += dy;
		}
		break;

	case SB_THUMBTRACK:
	case SB_THUMBPOSITION:

		if(yPos < 0)
			return FALSE;

		yScroll = yPos;
		fTracking = TRUE;
		break;

	case SB_TOP:
		if(yPos < 0)
			return FALSE;
		yScroll = 0;
		break;

	case SB_ENDSCROLL:
		UpdateScrollBar(SB_VERT);
		return MAKELRESULT(0, TRUE);

	default:
		return FALSE;
	}
    
	ScrollView(_xScroll, min(yScroll, max(_yHeight - _yHeightView, 0)), fTracking, TRUE);

	// Force position update if we just finished a track
	if(wCode == SB_THUMBPOSITION)
		UpdateScrollBar(SB_VERT);

	// Return how many lines we scrolled
	return MAKELRESULT((WORD) (_iliFirstVisible - ili), TRUE);
}

/*
 *	CDisplay::LineScroll(cli, cch)
 *
 *	@mfunc
 *		Scroll view vertically in response to a scrollbar event
 */
void CDisplayML::LineScroll(
	LONG cli,		//@parm Count of lines to scroll vertically
	LONG cch)		//@parm Count of characters to scroll horizontally
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::LineScroll");
	
	//Make sure the line to scroll to is valid
	if (cli + _iliFirstVisible >= Count())
	{
        // change line count enough to display the last line
		cli = Count() - _iliFirstVisible;
	}

    // Get the absolute yScroll position by adding the difference of the line
    // we want to go to and the current _yScroll position
	LONG dyScroll = CalcYLineScrollDelta(cli, FALSE);
	if(dyScroll < 0 || _yHeight - (_yScroll + dyScroll) > _yHeightView - dyScroll)
		ScrollView(_xScroll, _yScroll + dyScroll, FALSE, FALSE);
}

/*
 *	CDisplayML::FractionalScrollView (yDelta)
 *
 *	@mfunc
 *		Allow view to be scrolled by fractional lines.
 */
void CDisplayML::FractionalScrollView ( LONG yDelta )
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::FractionalScrollView");

	if ( yDelta)
		ScrollView(_xScroll, min(yDelta + _yScroll, max(_yHeight - _yHeightView, 0)), FALSE, TRUE);
}

/*
 *	CDisplayML::ScrollToLineStart(iDirection)
 *
 *	@mfunc
 *		If the view is scrolled so that only a partial line is at the
 *		top, then scroll the view so that the entire view is at the top.
 */
void CDisplayML::ScrollToLineStart(
	LONG iDirection)	//@parm the direction in which to scroll (negative
						// means down the screen
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::ScrollToLineStart");

	// This code originally lined things up on a line. However, it doesn't work
	// very well with big objects especially at the end of the document. I am
	// leaving the call here in case we discover problems later. (a-rsail).

#if 0
	// If _dyFirstVisible is zero, then we're aligned on a line, so
	// nothing more to do.

	if(_dyFirstVisible)
	{
		LONG yScroll = _yScroll + _dyFirstVisible;

		if(iDirection <= 0) 
		{
			yScroll += Elem(_iliFirstVisible)->_yHeight;
		}

		ScrollView(_xScroll, yScroll, FALSE, TRUE);
	}
#endif // 0
}

/*
 *	CDisplayML::CalcYLineScrollDelta (cli, fFractionalFirst)
 *
 *	@mfunc
 *		Given a count of lines, positive or negative, calc the number
 *		of vertical units necessary to scroll the view to the start of
 *		the current line + the given count of lines.
 */
LONG CDisplayML::CalcYLineScrollDelta (
	LONG cli,
	BOOL fFractionalFirst )
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::CalcYLineScrollDelta");

	LONG yScroll = 0;

	if(fFractionalFirst && _dyFirstVisible)	// Scroll partial for 1st.
	{
		Assert(_dyFirstVisible <= 0);		// get jonmat
		if(cli < 0)
		{
			cli++;
			yScroll = _dyFirstVisible;
		}
		else
		{
			cli--;
			yScroll = Elem(_iliFirstVisible)->_yHeight + _dyFirstVisible;
		}
	}

	if(cli > 0)
	{
		// Scrolling down
		cli = min(cli, Count() - _iliFirstVisible - 1);

		if (!fFractionalFirst && (0 == cli))
		{
			// If we are scrolling down and on the last line but we haven't scrolled to
			// the very bottom, then do so now.
			AssertSz(0 == yScroll, 
				"CDisplayML::CalcYLineScrollDelta last line & scroll");
			yScroll = _yHeight - _yScroll;

			// Limit scroll length to approximately 3 lines.
			yScroll = min(yScroll, 3 * GetYHeightSys());
		}
	}
	else if(cli < 0)
	{
		// Scrolling up
		cli = max(cli, -_iliFirstVisible);

		// At the top.
		if (!fFractionalFirst && (0 == cli))
		{
			// Make sure that we scroll back so first visible is 0.
			yScroll = _dyFirstVisible;

			// Limit scroll length to approximately 3 lines.
			yScroll = max(yScroll, -3 * GetYHeightSys());
		}
	}

	if(cli)
		yScroll += YposFromLine(_iliFirstVisible + cli) - YposFromLine(_iliFirstVisible);
	return yScroll;
}

/*
 *	CDisplayML::ScrollView(xScroll, yScroll, fTracking, fFractionalScroll)
 *
 *	@mfunc
 *		Scroll view to new x and y position
 *
 *	@devnote 
 *		This method tries to adjust the y scroll pos before
 *		scrolling to display complete line at top. x scroll 
 *		pos is adjusted to avoid scrolling all text off the 
 *		view rectangle.
 *
 *		Must be able to handle yScroll <gt> pdp->yHeight and yScroll <lt> 0
 *
 *	@rdesc
 *		TRUE if actual scrolling occurred, 
 *		FALSE if no change
 */
BOOL CDisplayML::ScrollView (
	LONG xScroll,		//@parm New x scroll position
	LONG yScroll,		//@parm New y scroll position
	BOOL fTracking,		//@parm TRUE indicates we are tracking scrollbar thumb
	BOOL fFractionalScroll)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::ScrollView");
						//		(don't update the scrollbar pos)
	BOOL fTryAgain = TRUE;
	RECT rcUpdate;      // ??? we may want use a region here but ScrollView is 
                        // rarely called with both a xScroll and yScroll value.
	LONG xWidthMax;
	LONG dx = 0;
	LONG dy = 0;
    RECT rcView;
	CTxtSelection *psel = _ped->GetSelNC();
	COleObject *pipo;
	BOOL fRestoreCaret = FALSE;


    AssertSz(_ped->_fInPlaceActive, "CDisplayML::ScrollView() called when not in-place");
    GetViewRect(rcView);
    
	if(xScroll == -1)
        xScroll = _xScroll;
	if(yScroll == -1)
        yScroll = _yScroll;
	
	// Determine vertical scrolling pos
	while(1)
	{
		BOOL fNothingBig = TRUE;
		LONG yFirst;
		LONG dyFirst;
		LONG cpFirst;
		LONG iliFirst;
		LONG yHeight;
		LONG iliT;

		yScroll = min(yScroll, GetMaxYScroll());
		yScroll = max(0, yScroll);
		dy = 0;

		// Ensure all visible lines are recalced
		if(!WaitForRecalcView())
			return FALSE;

		// Compute new first visible line
		iliFirst = LineFromYpos(yScroll, &yFirst, &cpFirst);

		if(cpFirst < 0)
		{
			// FUTURE (alexgo) this is pretty bogus, we should try to do
			// better in the next rel.

			TRACEERRORSZ("Display calc hosed, trying again");
			InitVars();
			_fNeedRecalc = TRUE;
			return FALSE;
		}

		if(iliFirst < 0)
		{
			// No line at _yScroll, use last line instead
			iliFirst = max(0, Count() - 1);
			cpFirst = _ped->GetTextLength() - Elem(iliFirst)->_cch;
			yScroll = _yHeight - Elem(iliFirst)->_yHeight;
			yFirst = _yScroll;
		}
		dyFirst = yFirst - yScroll;
		
		// Figure whether there is a big line
		// (more that a third of the view rect)
		for(iliT = iliFirst, yHeight = dyFirst;
			yHeight < _yHeightView && iliT < Count();
			iliT++)
		{
			const CLine* pli = Elem(iliT);
			if(pli->_yHeight >= _yHeightView / 3)
				fNothingBig = FALSE;
			yHeight += pli->_yHeight;
		}

		// If no big line and first pass, try to adjust 
		// scrolling pos to show complete line at top
		if(!fFractionalScroll && fTryAgain && fNothingBig && dyFirst != 0)
		{
			fTryAgain = FALSE;		// prevent any infinite loop

			Assert(dyFirst < 0);

			Tracef(TRCSEVINFO, "adjusting scroll for partial line at %d", dyFirst);
			// partial line visible at top, try to get a complete line showing
			yScroll += dyFirst;

			LONG yHeightLine = Elem(iliFirst)->_yHeight;

			// Adjust the height of the scroll by the height of the first 
			// visible line if we are scrolling down or if we are using the 
			// thumb (tracking) and we are on the last page of the view.
			if ((fTracking && yScroll + _yHeightView + yHeightLine > _yHeight)
				|| (!fTracking && _yScroll <= yScroll))
			{
				// Scrolling down so move down a little more
				yScroll += yHeightLine;
			}
		}
		else
		{
			dy = 0;
			if(yScroll != _yScroll)
			{
				_iliFirstVisible = iliFirst;
				_dyFirstVisible = dyFirst;
				_cpFirstVisible = cpFirst;
				dy = _yScroll - yScroll;
				_yScroll = yScroll;

				AssertSz(_yScroll >= 0, "CDisplayML::ScrollView _yScroll < 0");
				AssertNr(VerifyFirstVisible());
				if(!WaitForRecalcView())
			        return FALSE;
			}
			break;
		}
	}
	CheckView();

	// Determine horizontal scrolling pos.
	
	xWidthMax = _xWidth;

	// REVIEW (Victork) Restricting the range of the scroll is not really needed and could even be bad (bug 6104)
	
	xScroll = min(xScroll, xWidthMax);
	xScroll = max(0, xScroll);

	dx = _xScroll - xScroll;
	if(dx)
		_xScroll = xScroll;

	// Now perform the actual scrolling
	if(IsMain() && (dy || dx))
	{
		// Scroll only if scrolling < view dimensions and we are in-place
		if(IsActive() && !IsTransparent() && 
		    dy < _yHeightView && dx < _xWidthView)
		{
			// FUTURE: (ricksa/alexgo): we may be able to get rid of 
			// some of these ShowCaret calls; they look bogus.
			if (psel && psel->IsCaretShown())
			{
				_ped->TxShowCaret(FALSE);
				fRestoreCaret = TRUE;
			}
			_ped->TxScrollWindowEx((INT) dx, (INT) dy, NULL, &rcView,
				NULL, &rcUpdate, 0);

			_ped->TxInvalidateRect(&rcUpdate, FALSE);

			if(fRestoreCaret)
				_ped->TxShowCaret(FALSE);
		}
		else
			_ped->TxInvalidateRect(&rcView, FALSE);

		if(psel)
			psel->UpdateCaret(FALSE);

		if(!fTracking && dy)
		{
			UpdateScrollBar(SB_VERT);
			_ped->SendScrollEvent(EN_VSCROLL);
		}
		if(!fTracking && dx)
		{
			UpdateScrollBar(SB_HORZ);
			_ped->SendScrollEvent(EN_HSCROLL);
		}
						
		_ped->TxUpdateWindow();

		// FUTURE: since we're now repositioning in place active 
		// objects every time we draw, this call seems to be 
		// superfluous (AndreiB)

		// Tell object subsystem to reposition any in place objects
		if(_ped->GetObjectCount())
		{
			pipo = _ped->GetObjectMgr()->GetInPlaceActiveObject();
			if(pipo)
				pipo->OnReposition( dx, dy );
		}
	}
	return dy || dx;
}

/*
 *	CDisplayML::GetScrollRange(nBar)
 *
 *	@mfunc
 *		Returns the max part of a scrollbar range for scrollbar <p nBar>
 *
 *	@rdesc
 *		LONG max part of scrollbar range
 */
LONG CDisplayML::GetScrollRange(
	INT nBar) const		//@parm Scroll bar to interrogate (SB_VERT or SB_HORZ)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::GetScrollRange");

    Assert( IsMain() );

	LONG lRange = 0;
    
    if(nBar == SB_VERT && _fVScrollEnabled)
    {
	    if(_ped->TxGetScrollBars() & WS_VSCROLL)
			lRange = GetMaxYScroll();
    }
	else if((_ped->TxGetScrollBars() & WS_HSCROLL) && _fHScrollEnabled)
	{
		// Scroll range is maximum width plus room for the caret.
		lRange = max(0, _xWidth + dxCaret);
    }
	// Since thumb messages are limited to 16-bit, limit range to 16-bit
	lRange = min(lRange, _UI16_MAX);
	return lRange;
}

/*
 *	CDisplayML::UpdateScrollBar(nBar, fUpdateRange)
 *
 *	@mfunc
 *		Update either the horizontal or the vertical scrollbar and
 *		figure whether the scrollbar should be visible or not.
 *
 *	@rdesc
 *		BOOL
 */
BOOL CDisplayML::UpdateScrollBar(
	INT nBar,				//@parm Which scroll bar : SB_HORZ, SB_VERT
	BOOL fUpdateRange)		//@parm Should the range be recomputed and updated
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::UpdateScrollBar");

	// Note: In the old days we didn't allow autosize & scroll bars, so to keep
	// forms working, we need this special logic with respect to autosize.
	if (!IsActive() || _fInRecalcScrollBars ||
		!_ped->fInOurHost() && _ped->TxGetAutoSize())
	{
		// No scroll bars unless we are inplace active and we are not in the
		// process of updating scroll bars already.
		return TRUE;
	}

	const DWORD dwScrollBars = _ped->TxGetScrollBars();
	const BOOL fHide = !(dwScrollBars & ES_DISABLENOSCROLL);
	BOOL fReturn = FALSE;
	BOOL fEnabled = TRUE;
	BOOL fEnabledOld;
	LONG lScroll;
	CTxtSelection *psel = _ped->GetSelNC();
	BOOL fShowCaret = FALSE;

	// Get scrolling position
	if(nBar == SB_VERT)
	{
		if(!(dwScrollBars & WS_VSCROLL))
			return FALSE;

		fEnabledOld = _fVScrollEnabled;
        if(GetMaxYScroll() <= _yHeightView)
            fEnabled = FALSE;
    }
	else
	{
		if(!(dwScrollBars & WS_HSCROLL))
		{
			// Even if we don't have scrollbars, we may allow horizontal
			// scrolling.
			if(!_fHScrollEnabled && _xWidth > _xWidthView)
				_fHScrollEnabled = !!(dwScrollBars & ES_AUTOHSCROLL);

			return FALSE;
		}

		fEnabledOld = _fHScrollEnabled;
        if(_xWidth <= _xWidthView)
            fEnabled = FALSE;
	}

	// Don't allow ourselves to be re-entered.
	// Be sure to turn this to FALSE on exit
	_fInRecalcScrollBars = TRUE;

	// !s beforehand because all true values aren't necessarily equal
	if(!fEnabled != !fEnabledOld)
	{
		if(_fDeferUpdateScrollBar)
			_fUpdateScrollBarDeferred = TRUE;
		else
		{
			if (nBar == SB_HORZ)
				_fHScrollEnabled = fEnabled;
			else
				_fVScrollEnabled = fEnabled;
		}

		if(!_fDeferUpdateScrollBar)
		{
    		if(!fHide)
			{
				// Don't hide scrollbar, just disable
    			_ped->TxEnableScrollBar(nBar, fEnabled ? ESB_ENABLE_BOTH : ESB_DISABLE_BOTH);

				if (!fEnabled)
				{
					// The scroll bar is disabled. Therefore, all the text fits
					// on the screen so make sure the drawing reflects this.
					_yScroll = 0;
					_dyFirstVisible = 0;
					_cpFirstVisible = 0;
					_iliFirstVisible = 0;
					_ped->TxInvalidateRect(NULL, FALSE);
				}
			}
    		else 
    		{
    			fReturn = TRUE;
    			// Make sure to hide caret before showing scrollbar
    			if(psel)
    				fShowCaret = psel->ShowCaret(FALSE);

    			// Hide or show scroll bar
    			_ped->TxShowScrollBar(nBar, fEnabled);
				// The scroll bar affects the window which in turn affects the 
				// display. Therefore, if word wrap, repaint
				_ped->TxInvalidateRect(NULL, TRUE);
				// Needed for bug fix #5521
				_ped->TxUpdateWindow();

    			if(fShowCaret)
    				psel->ShowCaret(TRUE);
            }
		}
	}
	
	// Set scrollbar range and thumb position
	if(fEnabled)
	{
        if(fUpdateRange && !_fDeferUpdateScrollBar)
			_ped->TxSetScrollRange(nBar, 0, GetScrollRange(nBar), FALSE);
        
		if(_fDeferUpdateScrollBar)
			_fUpdateScrollBarDeferred = TRUE;
		else
		{
			lScroll = (nBar == SB_VERT)
				? ConvertYPosToScrollPos(_yScroll)
				: ConvertXPosToScrollPos(_xScroll);

			_ped->TxSetScrollPos(nBar, lScroll, TRUE);
		}
	}
	_fInRecalcScrollBars = FALSE;
	return fReturn;
}

/*
 *	CDisplayML::GetNaturalSize(hdcDraw, hicTarget, dwMode, pwidth, pheight)
 *
 *	@mfunc
 *		Recalculate display to input width & height for TXTNS_FITTOCONTENT.
 *
 *	@rdesc
 *		S_OK - Call completed successfully <nl>
 */
HRESULT	CDisplayML::GetNaturalSize(
	HDC hdcDraw,		//@parm DC for drawing
	HDC hicTarget,		//@parm DC for information
	DWORD dwMode,		//@parm Type of natural size required
	LONG *pwidth,		//@parm Width in device units to use for fitting 
	LONG *pheight)		//@parm Height in device units to use for fitting
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::GetNaturalSize");

	HRESULT hr = S_OK;

	// Set the height temporarily so the zoom factor will work out
	LONG yOrigHeightClient = SetClientHeight(*pheight);

	// Adjust height and width by view inset
	LONG widthView  = *pwidth;
	LONG heightView = *pheight;
	GetViewDim(widthView, heightView);

	// Store adjustment so we can restore it to height & width
	LONG widthAdj  = *pwidth  - widthView;
	LONG heightAdj = *pheight - heightView;
 	
	// Init measurer at cp = 0
	CMeasurer me(this);
	CLine liNew;
	LONG xWidth = 0, lineWidth;
	LONG yHeight = 0;
   	LONG cchText = _ped->GetTextLength();
	BOOL fFirstInPara = TRUE;

	LONG xWidthMax = GetWordWrap() ? widthView : -1;

	// The following loop generates new lines
	do 
	{	// Stuff text into new line
		UINT uiFlags = 0;

		// If word wrap is turned on, then we want to break on
		// words, otherwise, measure white space, etc.		
		if(GetWordWrap())
			uiFlags =  MEASURE_BREAKATWORD;

		if(fFirstInPara)
			uiFlags |= MEASURE_FIRSTINPARA;
	
		if(!liNew.Measure(me, -1, xWidthMax, uiFlags))
		{
			hr = E_FAIL;
			goto exit;
		}
		fFirstInPara = liNew._bFlags & fliHasEOP;

		// Keep track of width of widest line
		lineWidth = liNew._xWidth + liNew._xLineOverhang;
		xWidth = max(xWidth, lineWidth);
		yHeight += liNew._yHeight;		// Bump height

	} while (me.GetCp() < cchText);

	// Add caret size to width to guarantee that text fits. We don't
	// want to word break because the caret won't fit when the caller
	// tries a window this size.
	xWidth += dxCaret;

	*pwidth = xWidth;
	*pheight = yHeight;

	// Restore insets so output reflects true client rect needed
	*pwidth += widthAdj;
	*pheight += heightAdj;
		
exit:
	SetClientHeight(yOrigHeightClient);
	return hr;
}

/*
 *	CDisplayML::Clone()
 *
 *	@mfunc
 *		Make a copy of this object
 *
 *	@rdesc
 *		NULL - failed
 *		CDisplay *
 *
 *	@devnote
 *		Caller of this routine is the owner of the new display object.
 */
CDisplay *CDisplayML::Clone() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::Clone");

	CDisplayML *pdp = new CDisplayML(_ped);

	if(pdp)
	{
		// Initialize our base class
		if(pdp->CDisplay::Init())
		{
			pdp->InitFromDisplay(this);
			pdp->_xScroll = _xScroll;
			pdp->_fVScrollEnabled = _fVScrollEnabled;
			pdp->_fHScrollEnabled = _fHScrollEnabled;
			pdp->_fWordWrap = _fWordWrap;
			pdp->_cpFirstVisible = _cpFirstVisible;
			pdp->_iliFirstVisible = _iliFirstVisible;
			pdp->_yScroll = _yScroll;
			pdp->ResetDrawInfo(this);

			if(_pddTarget)
			{
				// Create a duplicate target device for this object
				pdp->SetMainTargetDC(_pddTarget->GetDC(), _xWidthMax);
			}

			// This can't be the active view since it is a clone
			// of some view.
			pdp->SetActiveFlag(FALSE);
		}
	}
	return pdp;
}

void CDisplayML::DeferUpdateScrollBar()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::DeferUpdateScrollBar");

	_fDeferUpdateScrollBar = TRUE;
	_fUpdateScrollBarDeferred = FALSE;
}

BOOL CDisplayML::DoDeferredUpdateScrollBar()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::DoDeferredUpdateScrollBar");

	_fDeferUpdateScrollBar = FALSE;
	if(!_fUpdateScrollBarDeferred)
		return FALSE;

	_fUpdateScrollBarDeferred = FALSE;
	BOOL fHorizontalUpdated = UpdateScrollBar(SB_HORZ, TRUE);
    
	return UpdateScrollBar(SB_VERT, TRUE) || fHorizontalUpdated;
}

LONG CDisplayML::GetMaxPixelWidth(void) const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::GetMaxPixelWidth");

	return _xWidthMax ? LXtoDX(_xWidthMax) : GetViewWidth();
}

/*
 *	CDisplayML::GetMaxXScroll()
 *
 *	@mfunc
 *		Get the maximum x scroll value
 *
 *	@rdesc
 *		Maximum x scroll value
 *
 */
LONG CDisplayML::GetMaxXScroll() const
{
	return _xWidth + dxCaret;
}

/*
 *	CDisplayML::CreateEmptyLine()
 *
 *	@mfunc
 *		Create an empty line
 *
 *	@rdesc
 *		TRUE - iff successful
 */
BOOL CDisplayML::CreateEmptyLine()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::CreateEmptyLine");

	// Make sure that this is being called appropriately
	AssertSz(_ped->GetTextLength() == 0,
		"CDisplayML::CreateEmptyLine called inappropriately");

	CMeasurer me(this);					// Create a measurer
	CLine *	  pliNew = Add(1, NULL);	// Add one new line

	if(!pliNew)
	{
		_ped->GetCallMgr()->SetOutOfMemory();
		TRACEWARNSZ("CDisplayML::CreateEmptyLine unable to add CLine to CLineArray");
		return FALSE;
	}

	// Measure the empty line
	if(!pliNew->Measure(me, -1, -1, MEASURE_BREAKATWORD | MEASURE_FIRSTINPARA))
	{
		Assert(FALSE);
		return FALSE;
	}
	return TRUE;
}

/*
 *	CDisplayML::AdjustToDisplayLastLine()
 *
 *	@mfunc
 *		Calculate the yscroll necessary to get the last line to display
 *
 *	@rdesc
 *		Updated yScroll
 *
 */
LONG CDisplayML::AdjustToDisplayLastLine(
	LONG yBase,			//@parm actual yScroll to display
	LONG yScroll)		//@parm proposed amount to scroll
{
	LONG iliFirst;
	LONG yFirst;

	if(yBase >= _yHeight)
	{
		// Want last line to be entirely displayed.
		// Compute new first visible line
		iliFirst = LineFromYpos(yScroll, &yFirst, NULL);

		// Is top line partial?
		if(yScroll != yFirst)
		{
			// Yes - bump scroll to the next line so the ScrollView
			// won't bump the scroll back to display the entire 
			// partial line since we want the bottom to display.
			yScroll = YposFromLine(iliFirst + 1);
		}
	}
	return yScroll;
}

/*
 *	CDisplayML::GetResizeHeight()
 *
 *	@mfunc
 *		Calculates height to return for a request resize
 *
 *	@rdesc
 *		Updated yScroll
 */
LONG CDisplayML::GetResizeHeight() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::GetResizeHeight");

    return CalcScrollHeight(_yHeight);
}

void CDisplayML::RebindFirstVisible()
{
	LONG cp = _cpFirstVisible;

	// Change first visible entries because CLinePtr::RpSetCp() and
	// YPosFromLine() use them, but they're not valid
	_dyFirstVisible = 0;
	_cpFirstVisible = 0;
	_iliFirstVisible = 0;
	_yScroll = 0;

	// Recompute scrolling position and first visible values after edit
    // force _yScroll = 0 if y scroll range is smaller than the view height
    if(_yHeight > _yHeightView)
    {   	
    	CLinePtr rp(this);
   		rp.RpSetCp(cp, FALSE);
   		_yScroll = YposFromLine(rp);
		// TODO: make following more efficient (work around rp.CalculateCp()
		// all the way from zero)
		// We use rp.GetCp() instead of cp, because cp could now be
		// woefully out of date.  RpSetCp will set us to the closest
		// available cp.
   		_cpFirstVisible = rp.CalculateCp() - rp.RpGetIch();
   		_iliFirstVisible = rp;
	}
}


// ================================  DEBUG methods  ============================================

#ifdef DEBUG
/*
 *	CDisplayML::CheckLineArray()
 *
 *	@mfunc	
 *		DEBUG routine that Asserts unless:
 *			1) sum of all line counts equals count of characters in story
 *			2) sum of all line heights equals height of display galley
 */
void CDisplayML::CheckLineArray() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::CheckLineArray");

	LONG ili = Count();

	// If we are marked as needing a recalc or if we are in the process of a
	// background recalc, we cannot verify the line array 
	if(!_fRecalcDone || _fNeedRecalc || !ili)
		return;

	LONG cchText = _ped->GetTextLength();

	if (!cchText)
		return;

	LONG cp = 0;
	BOOL fFirstInPara;
	BOOL fPrevLineEOP = TRUE;
	LONG yHeight = 0;
	CLine const *pli = Elem(0);
	CRchTxtPtr rtp(_ped);

	while(ili--)
	{
		fFirstInPara = (pli->_bFlags & fliFirstInPara) != 0;
		AssertSz(!(fPrevLineEOP	^ fFirstInPara),
			"CDisplayML::CheckLineArray: Invalid first/prev flags");

		AssertSz(pli->_cch,
			"CDisplayML::CheckLineArray: cch == 0");

		yHeight += pli->GetHeight();
		cp		+= pli->_cch;
		fPrevLineEOP = (pli->_bFlags & fliHasEOP) != 0;
		pli++;
	}

	if((cp != cchText) && (cp != _cpCalcMax))
	{
		Tracef(TRCSEVINFO, "sigma (*this)[]._cch = %ld, cchText = %ld", cp, cchText);
		AssertSz(FALSE,
			"CDisplayML::CheckLineArray: sigma(*this)[]._cch != cchText");
	}

	if(yHeight != _yHeight)
	{
		Tracef(TRCSEVINFO, "sigma (*this)[]._yHeight = %ld, _yHeight = %ld", yHeight, _yHeight);
		AssertSz(FALSE,
			"CDisplayML::CheckLineArray: sigma(*this)[]._yHeight != _yHeight");
	}
}

void CDisplayML::DumpLines(
	LONG iliFirst,
	LONG cli)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::DumpLines");

	LONG cch;
	LONG ili;
	TCHAR rgch[512];

	if(Count() == 1)
		wcscpy(rgch, TEXT("1 line"));
	else
		wsprintf(rgch, TEXT("%d lines"), Count());
	
#ifdef UNICODE
    // TraceTag needs to take UNICODE...
#else
	TRACEINFOSZ(TRCSEVINFO, rgch);
#endif

	if(cli < 0)
		cli = Count();
	else
		cli = min(cli, Count());
	if(iliFirst < 0)
		iliFirst = Count() - cli;
	else
		cli = min(cli, Count() - iliFirst);

	for(ili = iliFirst; cli > 0; ili++, cli--)
	{
		const CLine * const pli = Elem(ili);

		wsprintf(rgch, TEXT("Line %d (%ldc%ldw%ldh%x): \""), ili, pli->_cch, 
			pli->_xWidth + pli->_xLineOverhang, pli->_yHeight, pli->_bFlags);
		cch = wcslen(rgch);
		cch += GetLineText(ili, rgch + cch, CchOfCb(sizeof(rgch)) - cch - 4);
		rgch[cch++] = TEXT('\"');
		rgch[cch] = TEXT('\0');
#ifdef UNICODE
        // TraceTag needs to take UNICODE...
#else
    	TRACEINFOSZ(TRCSEVINFO, rgch);
#endif
	}
}

/*
 *	CDisplayML::CheckView()
 *
 *	@mfunc	
 *		DEBUG routine that checks coherence between _iliFirstVisible,
 *		_cpFirstVisible, and _dyFirstVisible
 */
void CDisplayML::CheckView()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::CheckView");

	LONG yHeight;
	VerifyFirstVisible(&yHeight);

	if(yHeight != _yScroll + _dyFirstVisible)
	{
		Tracef(TRCSEVINFO, "sigma CLine._yHeight = %ld, CDisplay.yFirstLine = %ld", yHeight, _yScroll + _dyFirstVisible);
		AssertSz(FALSE, "CLine._yHeight != VIEW.yFirstLine");
	}
}

/*
 *	CDisplayML::VerifyFirstVisible(pHeight)
 *
 *	@mfunc
 *		DEBUG routine that checks coherence between _iliFirstVisible
 *		and _cpFirstVisible
 *
 *	@rdesc	TRUE if things are hunky dory; FALSE otherwise
 */
BOOL CDisplayML::VerifyFirstVisible(
	LONG *pHeight)
{
	LONG	cchSum;
	LONG	ili = _iliFirstVisible;
	CLine const *pli = Elem(0);
	LONG	yHeight;

	for(cchSum = yHeight = 0; ili--; pli++)
	{
		cchSum  += pli->_cch;
		yHeight += pli->GetHeight();
	}

	if(pHeight)
		*pHeight = yHeight;

	if(cchSum != _cpFirstVisible)
	{
		Tracef(TRCSEVINFO, "sigma CLine._cch = %ld, CDisplay.cpFirstVisible = %ld", cchSum, _cpMin);
		AssertSz(FALSE, "sigma CLine._cch != VIEW.cpMin");

		return FALSE;
	}
	return TRUE;
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\dispsl.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	DISPSL.CPP -- CDisplaySL class |
 *
 *		This is the Single-line display engine.  See disp.c for the base class
 *		methods and dispml.c for the Multi-line display engine.
 *	
 *	Owner:<nl>
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_dispsl.h"
#include "_measure.h"
#include "_select.h"
#include "_render.h"
#include "_font.h"
#include "_dfreeze.h"

ASSERTDATA

const LONG CALC_XSCROLL_FROM_FIRST_VISIBLE = -2;

/*
 *	CDisplaySL::CDisplaySL
 *
 *	Purpose	
 *		Constructor
 */
CDisplaySL::CDisplaySL ( CTxtEdit* ped )
  : CDisplay( ped )
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::CDisplaySL");

	Assert(!_fMultiLine);
}

/*
 *	CDisplaySL::Init()
 *
 *	@mfunc	
 *		Init this display for the screen
 *
 *	@rdesc
 *		TRUE iff initialization succeeded
 */
BOOL CDisplaySL::Init()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::Init");

	// Initialize our base class
	if(!CDisplay::Init())
		return FALSE;

    SetWordWrap(FALSE);
    return TRUE;
}

/*
 *	CDisplaySL::InitVars()
 *
 */
void CDisplaySL::InitVars()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::InitVars");

    _xScroll = 0;
	SetCpFirstVisible(0);
}

/*
 *	CDisplaySL::RecalcView(fUpdateScrollBars)
 *
 *	@mfunc
 *		Recalc all lines breaks and update first visible line
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplaySL::RecalcView(
	BOOL fUpdateScrollBars, RECT* prc)		//@param TRUE - update scroll bars
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::RecalcView");
	LONG xWidthOld = _xWidth + _xLineOverhang;

    if(!RecalcLine())
        return FALSE;

    if(_fViewChanged)
    {
		if(IsActive() || _xWidth + _xLineOverhang <= GetViewWidth())
		{
			_xScroll = 0;
			SetCpFirstVisible(0);
		}
		else if(CALC_XSCROLL_FROM_FIRST_VISIBLE == _xScroll)
		{
			// In this case we want to set our xScroll by a visible. The
			// only way to get here is if the active view has been cloned
			// for displaying an inactive view.
 			_xScroll = 0;				// Assume that first visible is 0
			if(GetFirstVisibleCp())		// Check first visible
			{
				CMeasurer me(this);		// Start at cp 0
				me.NewLine(*this);		// Measure from there to where we are
		
				// Scroll is length to character
				_xScroll = CLine::XposFromCch(me, GetFirstVisibleCp(), TA_TOP);
			}
		}
		if(fUpdateScrollBars)
       		UpdateScrollBar(SB_HORZ, TRUE);

		_fViewChanged = FALSE;
    }

	// We only resize if width of single line control has changed.
	if(_xWidth + _xLineOverhang != xWidthOld)
	{
		if (FAILED(RequestResize()))
			_ped->GetCallMgr()->SetOutOfMemory();
		else if (prc && _ped->_fInOurHost) /*bug fix# 5830, forms3 relies on old behavior*/
			_ped->TxGetClientRect(prc);
	}

    return TRUE;
}

/*
 *	CDisplaySL::RecalcLine()
 *
 *	@mfunc
 *		Recalculate a line
 *
 *	@rdesc
 *		TRUE if success <nl>
 *		FALSE if failure <nl>
 */
BOOL CDisplaySL::RecalcLine()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::RecalcLine");

    Assert( _ped );

	// Create a measurer starting at cp = 0
	CMeasurer me(this);

	LONG xWidthOld = CLine::_xWidth + CLine::_xLineOverhang;
	BOOL fMeasured = CLine::Measure(me, -1, -1, MEASURE_FIRSTINPARA);

	if(!fMeasured)
	{
		Assert(FALSE);						// Should succeed
	    InitVars();
	    return FALSE;
	}

	_fNeedRecalc = FALSE;
	_fRecalcDone = TRUE;

	if(_fViewChanged || xWidthOld != (CLine::_xWidth + CLine::_xLineOverhang))
		_fViewChanged = TRUE;

	_fLineRecalcErr = FALSE;
	return fMeasured;
}

/*
 *	CDisplaySL::Render(rcView, rcRender)
 *
 *	@mfunc	
 *		Renders this line
 */
void CDisplaySL::Render(
	const RECT &rcView,		//@parm View RECT
	const RECT &rcRender)	//@parm RECT to render (must be contained in
							//		client rect)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::Render");
    POINT	pt;
	LONG	yHeightBitmap = 0;

	_fRectInvalid = FALSE;

	CRenderer re(this);

	if(!IsMetafile() && !IsTransparent() && (_bFlags & fliUseOffScreenDC))
		yHeightBitmap = _yHeight;

    if(!re.StartRender(rcView, rcRender, yHeightBitmap))
        return;

    // Set renderer at top/left of view rect
    pt.x = rcView.left - _xScroll;
    pt.y = rcView.top;
    re.SetCurPoint(pt);

    // Renderer is set at cp = 0 at the moment
	CLine::Render(re);

	if(_bFlags & fliOffScreenOnce)
		_bFlags &= ~(fliUseOffScreenDC | fliOffScreenOnce);
 
    // If line metrics are not yet up to date, get them from renderer
    if(_xWidth == -1)
    {
        _xWidth			= re._li._xWidth;
		_xLineOverhang	= re._li._xLineOverhang;
        _yHeight		= re._li._yHeight;
        _yDescent		= re._li._yDescent;
    }
    re.EndRender();
}

/*
 *	CDisplaySL::WaitForRecalcIli(ili)
 *
 *	@mfunc
 *		Wait until line array is recalculated up to line <p ili>
 *
 *	@rdesc
 *		Returns TRUE if lines were recalc'd up to ili (TRUE if ili == 0)
 */
BOOL CDisplaySL::WaitForRecalcIli (
	LONG ili)		//@parm Line index to recalculate line array up to
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::WaitForRecalcIli");

    return ili == 0;
}

/*
 *	CDisplaySL::GetScrollRange(nBar)
 *
 *	@mfunc
 *		Returns the max part of a scrollbar range for scrollbar <p nBar>
 *
 *	@rdesc
 *		LONG max part of scrollbar range
 */
LONG CDisplaySL::GetScrollRange(
	INT nBar) const		//@parm Scroll bar to interrogate (SB_VERT or SB_HORZ)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetScrollRange");

    Assert( IsMain() );

	LONG lRange = 0;
    
    if(nBar != SB_VERT && _fHScrollEnabled)
    {
	    if(_ped->TxGetScrollBars() & WS_HSCROLL)
		{
			lRange = max(0, _xWidth + dxCaret);
			lRange = min(lRange, _UI16_MAX);
		}
    }
	return lRange;
}

/*
 *	CDisplaySL::UpdateScrollBar(nBar, fUpdateRange)
 *
 *	@mfunc
 *		Update horizontal scroll bar
 *		Also figure whether the scroll bar should be visible or not
 *
 *	@rdesc
 *		BOOL
 */
BOOL CDisplaySL::UpdateScrollBar (
	INT	 nBar,				//@parm Which scrollbar: SB_HORZ or SB_VERT
	BOOL fUpdateRange)		//@parm Should range be recomputed and updated
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::UpdateScrollBar");

	// Note: In the old days we didn't allow autosize & scroll bars, so to keep
	// forms working, we need this special logic with respect to autosize.
	if (!IsActive() || SB_VERT == nBar ||
		!_ped->fInOurHost() && _ped->TxGetAutoSize())
	{
		// Scroll bars are only updated on active views.
		return FALSE;
	}

	const DWORD dwScrollBars = _ped->TxGetScrollBars();
	const BOOL fHide = !(dwScrollBars & ES_DISABLENOSCROLL);
	BOOL fReturn = FALSE;
	BOOL fEnabled = TRUE;
	BOOL fEnabledOld = FALSE;
	LONG lScroll = 0;
	CTxtSelection *psel = _ped->GetSelNC();

	// Get scrolling position
	if(nBar == SB_HORZ)
	{
		if(!(dwScrollBars & WS_HSCROLL))
		{
			// even if we don't have scrollbars, we may allow horizontal
			// scrolling.

			if(!_fHScrollEnabled)
				_fHScrollEnabled = !!(dwScrollBars & ES_AUTOHSCROLL);
			return FALSE;
		}

		fEnabledOld = _fHScrollEnabled;
		lScroll = ConvertXPosToScrollPos(_xScroll);

        if(_xWidth <= _xWidthView)
            fEnabled = FALSE;
	}

	// !s beforehand because all true values aren't necessarily equal
	if(!fEnabled != !fEnabledOld)
	{
		if(_fDeferUpdateScrollBar)
			_fUpdateScrollBarDeferred = TRUE;
		else
		{
			if (nBar == SB_HORZ)
				_fHScrollEnabled = fEnabled;
			else
				_fVScrollEnabled = fEnabled;
		}

		if(!_fDeferUpdateScrollBar)
		{
    		if(!fHide)					// Don't hide scrollbar, just disable
    			_ped->TxEnableScrollBar(nBar, fEnabled ? ESB_ENABLE_BOTH : ESB_DISABLE_BOTH);
    		else 
    		{
    			fReturn = TRUE;
    			// Make sure to hide caret before showing scrollbar
    			if(psel)
    				psel->ShowCaret(FALSE);

    			// Hide or show scroll bar
    			_ped->TxShowScrollBar(nBar, fEnabled);

    			if(psel)
    				psel->ShowCaret(TRUE);
            }
		}
	}
	
	// Set scrollbar range and thumb position
	if(fEnabled)
	{
        if(fUpdateRange)
        {
			if(!_fDeferUpdateScrollBar)
				_ped->TxSetScrollRange(nBar, 0, GetScrollRange(nBar), FALSE);
        }
        
		if(_fDeferUpdateScrollBar)
			_fUpdateScrollBarDeferred = TRUE;
		else
			_ped->TxSetScrollPos(nBar, lScroll, TRUE);
	}
	else if (!_fDeferUpdateScrollBar)
	{
		// This turns off the scroll bar and only needs to happen when a change 
		// occurs so we can count on the change in state check above to set
		// _fUpdateScrollBarDeferred.
		if (!fEnabled && fEnabledOld)
			_ped->TxSetScrollRange(nBar, 0, 0, FALSE);
	}
	return fReturn;
}

BOOL CDisplaySL::IsMain() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::IsMain");

    return TRUE;
}

LONG CDisplaySL::GetMaxWidth() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetMaxWidth");

    return 0;
}

LONG CDisplaySL::GetMaxPixelWidth() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetMaxPixelWidth");

    return GetViewWidth();
}

LONG CDisplaySL::GetMaxHeight() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetMaxHeight");

    return 0;
}

LONG CDisplaySL::GetWidth() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetWidth");

    return CLine::_xWidth + CLine::_xLineOverhang;
}

LONG CDisplaySL::GetHeight() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetHeight");

    return CLine::_yHeight;
}

LONG CDisplaySL::GetResizeHeight() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetResizeHeight");

    return CLine::_yHeight;
}

LONG CDisplaySL::LineCount() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::LineCount");

    return 1; 
}

/*
 *	CDisplaySL::GetCliVisible()
 *
 *	@mfunc
 *		Get count of visible lines and update GetCp()MostVisible for PageDown()
 *
 *	@rdesc
 *		count of visible lines
 */
LONG CDisplaySL::GetCliVisible (
	LONG* pcpMostVisible,				//@parm Returns cpMostVisible
	BOOL fLastCharOfLastVisible) const 	//@parm Want cp of last visible char
										// (ignored here).
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetCliVisible");

    if (pcpMostVisible)
        *pcpMostVisible = CLine::_cch;
    
    return 1;
}

LONG CDisplaySL::GetFirstVisibleLine() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetFirstVisibleLine");

    return 0;
}

/*
 *	CDisplaySL::GetLineText(ili, pchBuff, cchMost)
 *
 *	@mfunc
 *		Copy given line of this display into a character buffer
 *
 *	@rdesc
 *		number of character copied
 */
LONG CDisplaySL::GetLineText (
	LONG	ili,		//@parm Line to get text of
	TCHAR *	pchBuff,	//@parm Buffer to stuff text into
	LONG	cchMost)	//@parm Length of buffer
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetLineText");

    if(ili == 0)
    {
        cchMost = min(cchMost, _ped->GetTextLength());
        if(cchMost > 0)
        {
            CTxtPtr tp(_ped, 0);
            return tp.GetText( cchMost, pchBuff );
        }
    }
    return 0;
}

/*
 *	CDisplaySL::CpFromLine(ili, pyHeight)
 *
 *	@mfunc
 *		Computes cp at start of given line 
 *		(and top of line position relative to this display)
 *
 *	@rdesc
 *		cp of given line; here always 0
 */
LONG CDisplaySL::CpFromLine (
	LONG ili,		//@parm Line we're interested in (if <lt> 0 means caret line)
	LONG *pyLine)	//@parm Returns top of line relative to display 
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::CpFromLine");
					//  	(NULL if don't want that info)
    Assert( ili == 0 );
    
    if(pyLine)
        *pyLine = 0;
    
    return 0;
}

/*
 *	CDisplaySL::LineFromCp(cp, fAtEnd)
 *
 *	@mfunc
 *		Computes line containing given cp.
 *
 *	@rdesc
 *		index of line found; here returns 0 always
 */
LONG CDisplaySL::LineFromCp(
	LONG cp,		//@parm cp to look for
	BOOL fAtEnd)	//@parm If true, return previous line for ambiguous cp
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::LineFromCp");

    return 0;
}

/*
 *	CDisplaySL::CpFromPoint(pt, prcClient, ptp, prp, fAllowEOL, pHit, pdispdim)
 *
 *	@mfunc
 *		Determine cp at given point
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		Computed cp, -1 if failed
 */
LONG CDisplaySL::CpFromPoint(
	POINT		pt,			//@parm Point to compute cp at (client coords)
	const RECT *prcClient,	//@parm Client rectangle (can be NULL if active).
	CRchTxtPtr * const ptp,	//@parm Returns text pointer at cp (may be NULL)
	CLinePtr * const prp,	//@parm Returns line pointer at cp (may be NULL)
	BOOL		fAllowEOL,	//@parm Click at EOL returns cp after CRLF
	HITTEST *	phit,		//@parm Out parm for hit-test value
	CDispDim *	pdispdim,	//@parm Out parm for display dimensions
	LONG	   *pcpActual)	//@parm Out cp that pt is above
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::CpFromPoint");

    RECT  rcView;
	LONG cp = 0;
	LONG cch = 0;

	HITTEST		hit = HT_Nothing;

    GetViewRect(rcView, prcClient);

	if (pt.y >= rcView.top && pt.y <= rcView.bottom)
	{

		// Create measurer at cp(0)
		CMeasurer me(this);

		// Get character in the line
		pt.x += _xScroll - rcView.left;		// Transform to galley coordinates
		pt.y -= rcView.top;
		cch = CLine::CchFromXpos(me, pt, pdispdim, &hit, pcpActual);

		// Don't allow click at EOL to select EOL marker and take into account
		// single line edits as well
		if(!fAllowEOL && cch == CLine::_cch && CLine::_cchEOP)
			me._rpTX.BackupCpCRLF();

		cp = me.GetCp();
	}

	if (phit)
		*phit = hit;
    if(ptp)
        ptp->SetCp(cp);
    if(prp)
        prp->RpSet(0, cch);
 
 	return cp;   
}

/*
 *	CDisplaySL::PointFromTp(tp, fAtEnd, pt, prp, taMode, pdx)
 *
 *	@mfunc
 *		Determine coordinates at given tp
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		line index at cp, -1 if error
 */
LONG CDisplaySL::PointFromTp(
	const CRchTxtPtr &rtp,	//@parm Text ptr to get coordinates at
	const RECT *prcClient,	//@parm Client rectangle (can be NULL if active).
	BOOL		fAtEnd,		//@parm Return end of previous line for ambiguous cp
	POINT &		pt,			//@parm Returns point at cp in client coords
	CLinePtr * const prp,	//@parm Returns line pointer at tp (may be null)
	UINT		taMode,		//@parm Text Align mode: top, baseline, bottom
	CDispDim *	pdispdim)	//@parm Out parm for display dimensions
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::PointFromTp");

	LONG	 dy = 0;
    RECT	 rcView;
    CLinePtr rp(this);

    if(!rp.RpSetCp(rtp.GetCp(), fAtEnd))
        return -1;

    AssertSz(_ped->_fInPlaceActive || prcClient, 
		"CDisplaySL::PointFromTp() called with invalid client rect");

    GetViewRect(rcView, prcClient);

    pt.x = rcView.left - _xScroll;
    pt.y = rcView.top;

    CMeasurer me(this, rtp);
    me.Advance(-rp.RpGetIch());		// Backup to start of line      
    me.NewLine(*rp);				// Measure from there to where we are

	pt.x += CLine::XposFromCch(me, rp.RpGetIch(), taMode, pdispdim, &dy);
	pt.y += dy;

    if(prp)
        *prp = rp;
    return rp;
}

/*
 *	CDisplaySL::UpdateView(&tpFirst, cchOld, cchNew)
 *
 *	@mfunc
 *		Update visible part of display (the "view" on the screen).
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplaySL::UpdateView(
	const CRchTxtPtr &tpFirst,	//@parm Text ptr where change happened
	LONG cchOld,				//@parm Count of chars deleted
	LONG cchNew)				//@parm Count of chars inserted
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::UpdateView");

    BOOL fUpdateScrollBarHorz = FALSE;
    BOOL fReturn = TRUE;
    RECT rcView;
	CTxtSelection *psel = _ped->GetSelNC();
	LONG xWidthOld = _xWidth + _xLineOverhang;
	BOOL fScrollChanged = FALSE;
	RECT rcClient;
	RECT rc;
	LONG yHeightOld = _yHeight;
                                                              
    if (_fNoUpdateView)
        return fReturn;

	AssertSz(_ped->_fInPlaceActive, "CDisplaySL::UpdateView(...) called when inactive");

    _ped->TxGetClientRect(&rcClient);

    GetViewRect(rcView, &rcClient);
    
    if(psel && !psel->PuttingChar())
        psel->ClearCchPending();

    if(!RecalcLine())
    {
        // We're in trouble now, the recalc failed. Let's try to get
		// out of this with our head still mostly attached
        fReturn = FALSE;
    }

	// An update has occurred. If it isn't already off screen make it
	// off screen so that there is no flicker.
	if(!(_bFlags & fliUseOffScreenDC))
		_bFlags |= (fliUseOffScreenDC | fliOffScreenOnce);

    if(_xWidth <= _xWidthView)
    {
        // x scroll range is smaller than the view width
        // force x scrolling position = 0
        _xScroll = 0;
		SetCpFirstVisible(0);
		_fViewChanged = TRUE;
        fUpdateScrollBarHorz = TRUE;
    }

	_fRectInvalid = TRUE;

	// Only resize a Single Line edit control if the width changes
	if(_xWidth + _xLineOverhang != xWidthOld)
	{
		if(FAILED(RequestResize()))
			_ped->GetCallMgr()->SetOutOfMemory();
	}

	// If view changed, update scroll bars
    if(_fViewChanged)
	{
		_fViewChanged = FALSE;
        fScrollChanged = UpdateScrollBar(SB_HORZ);
	}

	if(!fScrollChanged)
	{
		// Scroll bar state did not change so we need to update screen
		// Build an invalidation rectangle. 
		rc = rcClient;
		if(yHeightOld == _yHeight)
		{
			// Height of control did not change so we can minimize the update 
			// rectangle to the height of the control.
			rc.bottom = rcView.top + _yHeight;
		}

		// Tell display to update when it gets a chance
		_ped->TxInvalidateRect(&rc, FALSE);
	}
    return fReturn;
}


/*
 *	CDisplaySL::ScrollView(xScroll, yScroll, fTracking, fFractionalScroll)
 *
 *	@mfunc
 *		Scroll view to new x and y position
 *
 *	@devnote
 *		This method tries to adjust the y scroll pos before
 *		scrolling to display complete line at top. x scroll 
 *		pos is adjusted to avoid scrolling all text off the 
 *		view rectangle.
 *
 *		Must be able to handle yScroll <gt> pdp->yHeight and yScroll <lt> 0
 *
 *	@rdesc
 *		TRUE if actual scrolling occurred, 
 *		FALSE if no change
 */
BOOL CDisplaySL::ScrollView (
	LONG xScroll,		//@parm New x scroll position
	LONG yScroll,		//@parm New y scroll position
	BOOL fTracking,		//@parm TRUE indicates we are tracking scrollbar thumb
	BOOL fFractionalScroll)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::ScrollView");
						//		(don't update the scrollbar pos)
	RECT rcUpdate;      // ??? we may want use a region here but ScrollView is 
                        // rarely called with both a xScroll and yScroll value.
	LONG xWidthMax;
	LONG dx = 0;
    RECT rcView;
	CTxtSelection *psel = _ped->GetSelNC();
	COleObject *pipo;

    AssertSz(_ped->_fInPlaceActive, "CDisplaySL::ScrollView() called when not in-place");
	
	if(xScroll == -1)
		return FALSE;

    GetViewRect(rcView);
	
	// Determine horizontal scrolling pos.
	xWidthMax = _xWidth;
	xScroll = min(xScroll, xWidthMax);
	xScroll = max(0, xScroll);

	dx = _xScroll - xScroll;
	if(dx)
    {
		_xScroll = xScroll;

		// Calculate new first visible
		CMeasurer me(this);				// Create measurer at cp(0)
		POINT pt = {xScroll, 0};
		CDispDim dispdim;
		HITTEST Hit;
		LONG	cpActual;
		CLine::CchFromXpos(me, pt, &dispdim, &Hit, &cpActual);
		
		SetCpFirstVisible(cpActual);	// Save character position
    }

	AssertSz(IsMain(), "CDisplaySL::ScrollView non-main SL control");

	// Now perform the actual scrolling
	if(dx)
	{
		if(!_fRectInvalid)
		{
			// Scroll only if scrolling < view dimensions and we are in-place
			// Note that we only scroll the active view and we can be in-place
			// active and have multiple inactive views.
			if(IsActive() && !IsTransparent() && dx < _xWidthView)
			{
				if(psel)
					psel->ShowCaret(FALSE);

				_ped->TxScrollWindowEx((INT) dx, 0, NULL, &rcView,
						NULL, &rcUpdate, 0);

				_ped->TxInvalidateRect(&rcUpdate, FALSE);
				if(psel)
					psel->ShowCaret(TRUE);
			}
			else
				_ped->TxInvalidateRect(&rcView, FALSE);
		}

		if(psel)
			psel->UpdateCaret(FALSE);

		if(!fTracking && dx)
		{		
			_ped->SendScrollEvent(EN_HSCROLL);
			UpdateScrollBar(SB_HORZ);
		}
				
		_ped->TxUpdateWindow();

		// FUTURE: since we're now repositioning in place active 
		// objects every time we draw, this call seems to be 
		// superfluous (AndreiB)

		// Tell object subsystem to reposition any in place objects
		if(_ped->GetObjectCount())
		{
			pipo = _ped->GetObjectMgr()->GetInPlaceActiveObject();
			if(pipo)
				pipo->OnReposition(dx, 0);
		}
	}
	return dx;
}

/*
 *	CDisplaySL::InvertRange(cp, cch, selAction)
 *
 *	@mfunc
 *		Invert a given range on screen (for selection)
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplaySL::InvertRange (
	LONG	cp,					//@parm Active end of range to invert
	LONG	cch,				//@parm Signed length of range
	SELDISPLAYACTION selAction)	//@parm What we are doing to the selection
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::InvertRange");

	RECT     rcView;
	RECT	 rc;

	if(cch < 0)						//make cch negative, make cp the minimum
		cch = -cch;
	else
		cp -= cch;

#ifdef LINESERVICES
	if (g_pols)
		g_pols->DestroyLine(this);
#endif

	// If display is frozen, just update recalc region and move on.
	if(_padc)
	{
		AssertSz(cp >= 0, "CDisplayML::InvertRange: range (cp) goes below"
				"zero!!" );
		// Make sure these values are bounded.
		if(cp > _ped->GetTextLength())	// Don't bother updating region;
			return TRUE;				//  it's out of bounds

		if(cp + cch > _ped->GetTextLength())
			cch -= cp + cch - _ped->GetTextLength();

		_padc->UpdateRecalcRegion(cp, cch, cch);
		return TRUE;
	}

	// Ensure all visible lines are recalced
	if(!WaitForRecalcView())
		return FALSE;

	//REVIEW (keithcu) CDisplayML::InvertRange() has a different order WRT
	//frozen displays and OLE objects.
	
	// If an object is being inverted, and that is all that
	// is being inverted, delegate to the ObjectMgr.
	if (cch == 1 && _ped->GetObjectCount() &&
		(selAction == selSetNormal || selAction == selSetHiLite) )
	{
		CObjectMgr* pobjmgr = _ped->GetObjectMgr();
		CTxtPtr		tp(_ped, cp);

		if(tp.GetChar() == WCH_EMBEDDING && pobjmgr)
			pobjmgr->HandleSingleSelect(_ped, cp, selAction == selSetHiLite);
	}

	// Get view rectangle
    AssertSz(_ped->_fInPlaceActive,
		"CDisplaySL::InvertRange() called when not in-place active");

	_ped->TxGetClientRect(&rc);
    GetViewRect(rcView, &rc);
	_ped->TxInvalidateRect(NULL, FALSE);
	return TRUE;
}

/*
 *	CDisplaySL::InitLinePtr (&lp)
 *
 *	@mfunc
 *		Initialize a CLinePtr properly
 */
void CDisplaySL::InitLinePtr (
	CLinePtr & lp )		//@parm Ptr to line to initialize
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::InitLinePtr");

    lp.Init(*this);
}

/*
 *	CDisplaySL::GetNaturalSize(hdcDraw, hicTarget, dwMode, pwidth, pheight)
 *
 *	@mfunc
 *		Recalculate display to input width & height
 *
 *	@rdesc
 *		S_OK - Call completed successfully <nl>
 */
HRESULT	CDisplaySL::GetNaturalSize(
	HDC	  hdcDraw,		//@parm DC for drawing
	HDC	  hicTarget,	//@parm DC for information
	DWORD dwMode,		//@parm Type of natural size required
	LONG *pwidth,		//@parm Input/output width parm 
	LONG *pheight)		//@parm	Input/output height parm
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetNaturalSize");

	// Assume this won't work
	HRESULT hr = E_FAIL;

	// Set height temporarily so zoom factor will work out
	LONG yOrigHeightClient = SetClientHeight(*pheight);

	// Adjust height and width by view inset
	LONG widthView  = *pwidth;
	LONG heightView = *pheight;
	GetViewDim(widthView, heightView);

	// Store adjustment so we can restore it to height & width
	LONG widthAdj  = *pwidth  - widthView;
	LONG heightAdj = *pheight - heightView;

	// Recalculate size needed
   	// Create a measurer starting at cp = 0
	CMeasurer me(this);
	CLine	  liNew;

	if(liNew.Measure(me, -1, -1, MEASURE_FIRSTINPARA))
	{
		*pwidth  = liNew._xWidth + liNew._xLineOverhang;
		*pheight = liNew._yHeight;
		hr = S_OK;
	}	

	// Restore insets so output reflects true client rect needed
	*pwidth  += widthAdj + dxCaret;
	*pheight += heightAdj;

	// Restore client height to match current cache
	SetClientHeight(yOrigHeightClient);
    return hr;
}

/*
 *	CDisplaySL::GetWordWrap()
 *
 *	@mfunc
 *		Gets the wrap flag  
 *
 *	@rdesc
 *		TRUE - Word wrap
 *		FALSE - No word Word wrap
 *
 *	@devnote
 *		Single line controls cannot word wrap.
 */
BOOL CDisplaySL::GetWordWrap() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetNoWrap");

	return FALSE;
}

/*
 *	CDisplaySL::Clone()
 *
 *	@mfunc
 *		Make a copy of this object
 *
 *	@rdesc
 *		NULL - failed
 *		CDisplay *
 */
CDisplay *CDisplaySL::Clone() const
{
	CDisplaySL *pdp = new CDisplaySL(_ped);
	if(pdp)
	{
		// Initialize our base class
		if(pdp->CDisplay::Init())
		{
			pdp->InitFromDisplay(this);

			// Setting scroll to 0 means use the first visible character
			pdp->_xScroll = CALC_XSCROLL_FROM_FIRST_VISIBLE;
			pdp->_fVScrollEnabled = _fVScrollEnabled;
			pdp->_fWordWrap = _fWordWrap;
			pdp->ResetDrawInfo(this);
			pdp->SetCpFirstVisible(GetFirstVisibleCp());

			// This can't be active view since it is a clone of some view
			pdp->SetActiveFlag(FALSE);
		}
	}
	return pdp;
}

/*
 *	CDisplaySL::GetMaxXScroll()
 *
 *	@mfunc
 *		Get the maximum x scroll value
 *
 *	@rdesc
 *		Maximum x scroll value
 *
 */
LONG CDisplaySL::GetMaxXScroll() const
{
	return _xWidth + dxCaret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\drawdata.h ===
class CDrawData 
{
public:

						CDrawData(

						~CDrawData(

	HDC					GetDC();

	HDC					GetTargetDevice();

	DWORD				GetDrawAspect();

	LONG				GetLindex();

	const DVTARGETDEVICE *GetTargetDeviceDesc();

	void				Push(CDrawData *pdd);

	CDrawData *			Pop();

private:

	DWORD 				_dwDrawAspect;

	LONG  				_lindex;

	const DVTARGETDEVICE *_ptd;

	HDC 				_hdcDraw;

	HDC 				_hicTargetDev;

	CDrawData *			_pddNext;
};

inline void CDrawData::Push(CDrawData *pdd)
{
	_pddNext = pdd;
}

inline CDrawData *CDrawData::Pop()
{
	return _pNext;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\dxfrobj.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	- DXFROBJ.C |
 *
 *		implementation of a generic IDataObject data transfer object.
 *		This object is suitable for use in OLE clipboard and drag drop
 *		operations
 *
 *	Author: <nl>
 *		alexgo (4/25/95)
 *
 *	Revisions: <nl>
 *		murrays (7/13/95) auto-doc'd and added cf_RTF
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_edit.h"
#include "_dxfrobj.h"
#include "_range.h"
#include "hash.h"

#define NUMOBJCOPIEDFORWAITCURSOR	1
#ifdef PEGASUS
#define NUMCHARCOPIEDFORWAITCURSOR	4096
#else
#define NUMCHARCOPIEDFORWAITCURSOR	16384
#endif

//
//	Common Data types
//

// If you change g_rgFETC[], change g_rgDOI[] and enum FETCINDEX and CFETC in
// _dxfrobj.h accordingly, and register nonstandard clipboard formats in
// RegisterFETCs(). Order entries in order of most desirable to least, e.g.,
// RTF in front of plain text.

//REVIEW (keithcu) All but the first column is const--separate into 2 data structures?
FORMATETC g_rgFETC[] =
{
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},	// CF_RTFUTF8
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},	// cf_RTF
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}, // RTF with NCRs for nonASCII
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_ISTORAGE},// EmbObject
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_ISTORAGE},// EmbSource
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},	// ObjDesc
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},	// LnkSource
	{CF_METAFILEPICT,	NULL, DVASPECT_CONTENT, -1, TYMED_MFPICT},
	{CF_DIB,			NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
	{CF_BITMAP,			NULL, DVASPECT_CONTENT, -1, TYMED_GDI},
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}, // RTF with no objs
	{CF_UNICODETEXT,	NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
	{CF_TEXT,			NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},	// Filename
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},	// CF_RTFASTEXT
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_ISTORAGE},// Text with objs
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_ISTORAGE} // Richedit
};

// Keep in sync with above and with FETCINDEX and CFETC
const DWORD g_rgDOI[] =
{
	DOI_CANPASTERICH,						// RTF in UTF8 encoding
	DOI_CANPASTERICH,						// RTF
	DOI_CANPASTERICH,						// RTF with NCRs for nonASCII
	DOI_CANPASTEOLE,						// Embedded Object
	DOI_CANPASTEOLE,						// Embed Source
	DOI_NONE,								// Object Descriptor
	DOI_CANPASTEOLE,						// Link Source
	DOI_CANPASTEOLE,						// Metafile
	DOI_CANPASTEOLE,						// DIB
	DOI_CANPASTEOLE,						// Bitmap
	DOI_CANPASTERICH,						// RTF with no objects
	DOI_CANPASTEPLAIN,						// Unicode plain text
	DOI_CANPASTEPLAIN,						// ANSI plain text
	DOI_CANPASTEOLE,						// Filename
	DOI_CANPASTEPLAIN,						// Pastes RTF as text
	DOI_CANPASTERICH,						// Richedit Text
	DOI_CANPASTERICH						// RichEdit Text w/formatting
};

/*
 *	RegisterFETCs()
 *
 *	@func
 *		Register nonstandard format ETCs.  Called when DLL is loaded
 */
void RegisterFETCs()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "RegisterFETCs");

#ifdef RTF_HASHCACHE
	HashKeyword_Init();			// Init rtf control keyword hash table.
#endif
#ifndef MACPORT
	g_rgFETC[iRtfFETC].cfFormat	// Note: cfFormats are WORDs
			= (WORD)RegisterClipboardFormatA("Rich Text Format");

	g_rgFETC[iRtfUtf8].cfFormat
			= (WORD)RegisterClipboardFormatA("RTF in UTF8");

	g_rgFETC[iRtfNCRforNonASCII].cfFormat
			= (WORD)RegisterClipboardFormatA("RTF with NCRs for nonASCII");

	g_rgFETC[iRtfAsTextFETC].cfFormat
			= (WORD)RegisterClipboardFormatA("RTF As Text");

	g_rgFETC[iRichEdit].cfFormat
			= (WORD)RegisterClipboardFormatA("RICHEDIT");

	g_rgFETC[iObtDesc].cfFormat
			= (WORD)RegisterClipboardFormatA(CF_OBJECTDESCRIPTOR);

	g_rgFETC[iEmbObj].cfFormat
			= (WORD)RegisterClipboardFormatA(CF_EMBEDDEDOBJECT);

	g_rgFETC[iEmbSrc].cfFormat
			= (WORD)RegisterClipboardFormatA(CF_EMBEDSOURCE);

	g_rgFETC[iLnkSrc].cfFormat
			= (WORD)RegisterClipboardFormatA(CF_LINKSOURCE);

	g_rgFETC[iRtfNoObjs].cfFormat
			= (WORD)RegisterClipboardFormatA("Rich Text Format Without Objects");

	g_rgFETC[iTxtObj].cfFormat
			= (WORD)RegisterClipboardFormatA("RichEdit Text and Objects");

	g_rgFETC[iFilename].cfFormat
			= (WORD)RegisterClipboardFormatA(CF_FILENAME);
#else
    // MacPort:  Should we even bother to register the clipboard formats if we
    //           are not going to use WLM clipboard???
	if(!g_rgFETC[iRtfFETC].cfFormat)
    {
		g_rgFETC[iRtfFETC].cfFormat = RegisterClipboardFormatA("RTF ");
		g_rgFETC[iRtfFETC].cfFormat = 'RTF ';
    }

	if(!g_rgFETC[iRtfAsTextFETC].cfFormat)
    {
		g_rgFETC[iRtfAsTextFETC].cfFormat = RegisterClipboardFormatA("RTFT");
		g_rgFETC[iRtfAsTextFETC].cfFormat = 'RTFT';
    }

	if(!g_rgFETC[iRichEdit].cfFormat)
    {
		g_rgFETC[iRichEdit].cfFormat = RegisterClipboardFormatA("RTE ");
		g_rgFETC[iRichEdit].cfFormat = 'RTE ';
    }

	if(!g_rgFETC[iObtDesc].cfFormat)
    {
		g_rgFETC[iObtDesc].cfFormat = RegisterClipboardFormatA(CF_OBJECTDESCRIPTOR);
		g_rgFETC[iObtDesc].cfFormat = cfObjectDescriptor;
    }

	if(!g_rgFETC[iEmbObj].cfFormat)
    {
		g_rgFETC[iEmbObj].cfFormat = RegisterClipboardFormatA(CF_EMBEDDEDOBJECT);
		g_rgFETC[iEmbObj].cfFormat =  cfEmbeddedObject;
    }

	if(!g_rgFETC[iEmbSrc].cfFormat)
    {
		g_rgFETC[iEmbSrc].cfFormat = RegisterClipboardFormatA(CF_EMBEDSOURCE);
		g_rgFETC[iEmbSrc].cfFormat = cfEmbedSource;
    }

	if(!g_rgFETC[iLnkSrc].cfFormat)
    {
		g_rgFETC[iLnkSrc].cfFormat = RegisterClipboardFormatA(CF_LINKSOURCE);
		g_rgFETC[iLnkSrc].cfFormat = cfLinkSource;
    }

	if(!g_rgFETC[iRtfNoObjs].cfFormat)
    {
		g_rgFETC[iRtfNoObjs].cfFormat = RegisterClipboardFormatA("RwoO");
		g_rgFETC[iRtfNoObjs].cfFormat = 'RwoO';
    }

	if(!g_rgFETC[iTxtObj].cfFormat)
    {
		g_rgFETC[iTxtObj].cfFormat = RegisterClipboardFormatA("RTnO");
		g_rgFETC[iTxtObj].cfFormat = 'RTnO';
    }

	if(!g_rgFETC[iFilename].cfFormat)
    {
		g_rgFETC[iFilename].cfFormat = RegisterClipboardFormatA(CF_FILENAME);
		g_rgFETC[iFilename].cfFormat = cfFileName;
    }

	if(!g_rgFETC[iRtfUtf8].cfFormat)
    {
		g_rgFETC[iRtfUtf8].cfFormat = RegisterClipboardFormatA("UTF8 RTF");
		g_rgFETC[iRtfUtf8].cfFormat = 'UTF8 RTF';
    }
#endif
}


//
//	CDataTransferObj PUBLIC methods
//

/*
 *	CDataTransferObj::QueryInterface (riid, ppv)
 *
 *	@mfunc
 *		 QueryInterface for CDataTransferObj
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CDataTransferObj::QueryInterface (
	REFIID riid,			// @parm Reference to requested interface ID
	void ** ppv)			// @parm out parm for interface ptr
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::QueryInterface");

	if(!ppv)
		return E_INVALIDARG;

	*ppv = NULL;

	if(IsZombie())							// Check for range zombie
		return CO_E_RELEASED;

    HRESULT		hresult = E_NOINTERFACE;

	if( IsEqualIID(riid, IID_IUnknown) ||
		IsEqualIID(riid, IID_IDataObject) ||
		IsEqualIID(riid, IID_IRichEditDO) )
	{
		*ppv = this;
		AddRef();
		hresult = NOERROR;
	}

	return hresult;
}

/*
 *	CDataTransferObj::AddRef()
 *
 *	@mfunc
 *		IUnknown method
 *
 *	@rdesc
 *		ULONG - incremented reference count
 */
STDMETHODIMP_(ULONG) CDataTransferObj::AddRef()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::AddRef");

	return ++_crefs;
}

/*
 *	CDataTransferObj::Release()
 *
 *	@mfunc
 *		IUnknown method
 *
 *	@rdesc
 *		ULONG - decremented reference count
 */
STDMETHODIMP_(ULONG) CDataTransferObj::Release()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::Release");

	_crefs--;

	if( _crefs == 0 )
	{
		GlobalFree(_hPlainText);
		GlobalFree(_hRtfText);
		GlobalFree(_hRtfUtf8);
		GlobalFree(_hRtfNCRforNonASCII);
		delete this;
		return 0;
	}

	return _crefs;
}

/*
 *	CDataTransferObj::DAdvise (pFormatetc, advf, pAdvSink, pdwConnection)
 *
 *	@mfunc
 *		establish an advisory connection
 *
 *	@rdesc
 *		HRESULT = OLE_E_ADVISENOTSUPPORTED
 *
 *	@devnote
 *		this is a data transfer object, thus the data is a "snapshot" and
 *		cannot change -- no advises are supported.
 */
STDMETHODIMP CDataTransferObj::DAdvise(
	FORMATETC * pFormatetc,
	DWORD advf,
	IAdviseSink *pAdvSink,
	DWORD *pdwConnection)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::DAdvise");

	return OLE_E_ADVISENOTSUPPORTED;
}

/*
 *	CDataTransferObj::DUnadvise (dwConnection)
 *
 *	@mfunc
 *		destroy an advisory connection
 *
 *	@rdesc
 *		HRESULT = OLE_E_ADVISENOTSUPPORTED
 *
 *	@devnote
 *		this is a data transfer object, thus the data is a "snapshot" and
 *		cannot change -- no advises are supported.
 */
STDMETHODIMP CDataTransferObj::DUnadvise(
	DWORD dwConnection)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::DUnadvise");

	return OLE_E_ADVISENOTSUPPORTED;
}

/*
 *	CDataTransferObj::EnumDAdvise (ppenumAdvise)
 *
 *	@mfunc
 *		enumerate advisory connections
 *
 *	@rdesc
 *		HRESULT = OLE_E_ADVISENOTSUPPORTED
 *
 *	@devnote
 *		this is a data transfer object, thus the data is a "snapshot" and
 *		cannot change -- no advises are supported.
 */
STDMETHODIMP CDataTransferObj::EnumDAdvise(
	IEnumSTATDATA ** ppenumAdvise)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::EnumDAdvise");

	return OLE_E_ADVISENOTSUPPORTED;
}

/*
 *	CDataTransferObj::EnumFormatEtc (dwDirection, ppenumFormatEtc)
 *
 *	@mfunc
 *		returns an enumerator which lists all of the available formats in
 *		this data transfer object
 *
 *	@rdesc
 *		HRESULT
 *
 *	@devnote
 *		we have no 'set' formats for this object
 */
STDMETHODIMP CDataTransferObj::EnumFormatEtc(
	DWORD dwDirection,					// @parm DATADIR_GET/SET
	IEnumFORMATETC **ppenumFormatEtc)	// @parm out parm for enum FETC interface
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::EnumFormatEtc");

	if(!ppenumFormatEtc)
		return E_INVALIDARG;

	*ppenumFormatEtc = NULL;

	if(IsZombie())							// Check for range zombie
		return CO_E_RELEASED;

	HRESULT hr = NOERROR;


	#ifdef DEBUG
	if (dwDirection == DATADIR_SET && !_ped->Get10Mode())
	{
		Tracef(TRCSEVNONE, "RichEdit 2.0 EnumFormatEtc called with DATADIR_SET");
	}
	#endif

	//Need riched10 compatibility hack to ignore dwDirection
	if(dwDirection == DATADIR_GET || _ped->Get10Mode())
		hr = CEnumFormatEtc::Create(_prgFormats, _cTotal, ppenumFormatEtc);

	return hr;
}

/*
 *	CDataTransferObj::GetCanonicalFormatEtc( pformatetc, pformatetcOut)
 *
 *	@mfunc
 *		from the given formatetc, return a more standard (or canonical)
 *		format.
 *
 *	@rdesc
 *		HRESULT = E_NOTIMPL
 *
 *	@devnote
 *		(alexgo): we may need to write this routine if we ever do anything
 *		snazzy with printers
 */
STDMETHODIMP CDataTransferObj::GetCanonicalFormatEtc(
	FORMATETC *pformatetc,
	FORMATETC *pformatetcOut)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::GetCanonicalFormatEtc");

	return E_NOTIMPL;
}

/*
 *	CDataTransferObj::GetData (pformatetcIn, pmedium)
 *
 *	@mfunc
 *		retrieves data of the specified format
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CDataTransferObj::GetData(
	FORMATETC *pformatetcIn, 
	STGMEDIUM *pmedium )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::GetData");

	FillMemory(pmedium, '\0', sizeof(STGMEDIUM));
	pmedium->tymed	 = TYMED_NULL;

	if(IsZombie())							// Check for range zombie
		return CO_E_RELEASED;

	CLIPFORMAT	cf = pformatetcIn->cfFormat;
	HRESULT		hr = E_OUTOFMEMORY;                     // Default not enuf RAM

	// now handle 'native' richedit formats.
	if( cf && pformatetcIn->tymed & TYMED_HGLOBAL )
	{
		if( cf == CF_UNICODETEXT )
			pmedium->hGlobal = DuplicateHGlobal(TextToHglobal(_hPlainText, tPlain));

		else if(cf == CF_TEXT)
			pmedium->hGlobal = TextHGlobalWtoA(TextToHglobal(_hPlainText, tPlain));

		else if(cf == cf_RTF || cf == cf_RTFASTEXT || cf == cf_RTFNOOBJS)
			pmedium->hGlobal = DuplicateHGlobal(TextToHglobal(_hRtfText, tRtf));

		else if(cf == cf_RTFUTF8)
			pmedium->hGlobal = DuplicateHGlobal(TextToHglobal(_hRtfUtf8, tRtfUtf8));

		else if(cf == cf_RTFNCRFORNONASCII)
			pmedium->hGlobal = DuplicateHGlobal(TextToHglobal(_hRtfNCRforNonASCII, tRtfNCRforNonASCII));
			
		else
		    hr = DV_E_FORMATETC;
		
        if (hr == E_OUTOFMEMORY)
        {
    		if( pmedium->hGlobal )						// Succeeded
    		{
    			pmedium->tymed	 = TYMED_HGLOBAL;
    			hr = NOERROR;
    		}
    		return hr;
    	}
	}
	
	if ((cf == cf_EMBEDDEDOBJECT ||
		 cf == cf_EMBEDSOURCE) &&
		(pformatetcIn->tymed & TYMED_ISTORAGE))
	{
        _pObjStg = GetDataForEmbeddedObject( _pOleObj, pmedium->pstg );
		pmedium->tymed = TYMED_ISTORAGE;
		if (NULL == pmedium->pstg)
			pmedium->pstg = _pObjStg;
		hr = _pObjStg != NULL ? NOERROR : hr;
		return hr;
	} 

	// Go through richedit's formats and see if there are any matches
	if( cf == cf_OBJECTDESCRIPTOR &&
			 (pformatetcIn->tymed & TYMED_HGLOBAL) &&
			 _hObjDesc)
	{    
		pmedium->hGlobal = DuplicateHGlobal(_hObjDesc);
		pmedium->tymed = TYMED_HGLOBAL;
		return NOERROR;
	}

    // First propogate the message to the object and see if it handles the format
    if (_pOleObj)
    {
        // Include the formats supported by the object
        IDataObject * pdataobj = NULL;
        if (FAILED(_pOleObj->GetClipboardData(0, &pdataobj)) || pdataobj == NULL)    	        	            
            _pOleObj->QueryInterface(IID_IDataObject, (void**) &pdataobj);
            
        if (pdataobj)
        {
            hr = pdataobj->GetData(pformatetcIn, pmedium);
            pdataobj->Release();

            if (SUCCEEDED(hr))
            {
                if ((cf == cf_EMBEDDEDOBJECT || cf == cf_EMBEDSOURCE) && _pOleObj)
                {
                    OleSaveSiteFlags(pmedium->pstg, _dwFlags, _dwUser, _dvaspect);
                }
                return S_OK;
            }
        }
    }          

	if( cf == CF_METAFILEPICT )
	{
		pmedium->hMetaFilePict = OleDuplicateData(_hMFPict, CF_METAFILEPICT, 0);
		pmedium->tymed = TYMED_MFPICT;
		return NOERROR;
	}

	if( cf == CF_DIB )
	{
		if( _ped->HasObjects() && _cch == 1 )
		{
			COleObject *pobj = _ped->_pobjmgr->GetObjectFromCp(_cpMin);
			if (pobj)
			{
				HGLOBAL hdib = pobj->GetHdata();
				if (hdib)
				{
					pmedium->hGlobal = DuplicateHGlobal(hdib);
					pmedium->tymed = TYMED_HGLOBAL;
				}
			}
		}
		return NOERROR;
	}

	return DV_E_FORMATETC;
}

/*
 *	CDataTransferObj::GetDataForEmbeddedObject (pformatetc, lpstgdest)
 *
 *	@mfunc
 *		retrieves data for embedded object
 *
 *	@rdesc
 *		LPSTORAGE
 *
 */
LPSTORAGE CDataTransferObj::GetDataForEmbeddedObject(
	LPOLEOBJECT	 pOleObj,
	LPSTORAGE	 lpstgdest)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::GetDataForEmbeddedObject");
	
	HRESULT			 hr, hr1;
	LPPERSISTSTORAGE pperstg;

	if (_pObjStg != NULL && lpstgdest != NULL)
	{
		// We saved the data previously. Copy it to destination.
		hr = _pObjStg->CopyTo(0, NULL, NULL, lpstgdest);
		if (hr == NOERROR)
		{
			lpstgdest->Commit(STGC_DEFAULT);
			return _pObjStg;
		}
		return NULL;
	}

	if (_pObjStg != NULL && lpstgdest == NULL)
	{
		// We saved the data previously.  Return a reference
		_pObjStg->AddRef();
		return _pObjStg;
	}

	// We don't have a saved copy.  Create One.
	hr = pOleObj->QueryInterface( IID_IPersistStorage, (void **) &pperstg );
	if (hr != NOERROR)
		return NULL;

	if (lpstgdest == NULL)
	{
		// It is null.  We have to create our own.
		LPLOCKBYTES lpLockBytes = NULL;
		hr = CreateILockBytesOnHGlobal(NULL, TRUE, // delete on release
									   (LPLOCKBYTES *)&lpLockBytes);
		if (hr != NOERROR)
		{
			pperstg->Release();
			return NULL;
		}
		hr = StgCreateDocfileOnILockBytes(
			lpLockBytes,
			STGM_READWRITE | STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
			0,	// reserved
			&lpstgdest
		);
		lpLockBytes->Release();
		if (hr != NOERROR)
		{
			pperstg->Release();
			return NULL;
		}
		_pObjStg = lpstgdest;
	}
	else
	{
		// Force the data to be saved
		_pObjStg = GetDataForEmbeddedObject( _pOleObj, NULL );
		pperstg->Release();
		return GetDataForEmbeddedObject( _pOleObj, lpstgdest );
	}

    // OLE2NOTE: even if OleSave returns an error you should still call 
    // SaveCompleted.
    hr = OleSave( pperstg, lpstgdest, FALSE /* fSameAsLoad */ );
 	hr1 = pperstg->SaveCompleted(NULL);
	if (hr != NOERROR || hr1 != NOERROR)			// Should we use SUCCEED macros ????
		lpstgdest = NULL;

	pperstg->Release();
	return _pObjStg;
}

/*
 *	CDataTransferObj::GetDataorObjectDescriptor (pformatetc, pmedium)
 *
 *	@mfunc
 *		retrieves data for embedded object descriptor
 *
 *	@rdesc
 *		HRESULT
 */
HGLOBAL CDataTransferObj::GetDataForObjectDescriptor(
	LPOLEOBJECT	 pOleObj,
	DWORD		 dwAspect,
	SIZEL*       psizel)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::GetDataForObjectDescriptor");

	POINTL ptl = {0};
	SIZEL sizel = {0};
	if (psizel)
	{
	    sizel.cx = psizel->cx;
	    sizel.cy = psizel->cy;
	}

	if (_hObjDesc == NULL)
	{
		_hObjDesc = OleGetObjectDescriptorDataFromOleObject(
			pOleObj,
			dwAspect,
			ptl,
			&sizel
		);
	}
	return _hObjDesc;
}

/*
 *	CDataTransferObj::GetDataHere (pformatetc, pmedium)
 *
 *	@mfunc
 *		retrieves data of the specified format into the given medium
 *
 *	@rdesc
 *		HRESULT = E_NOTIMPL
 *
 *	@devnote (alexgo): technically, we're supposed to support transfers
 *		into hglobals, but I'd rather not at the moment.
 */
STDMETHODIMP CDataTransferObj::GetDataHere(
	FORMATETC *pformatetc, 
	STGMEDIUM *pmedium)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::GetDataHere");

	CLIPFORMAT	cf = pformatetc->cfFormat;
	HRESULT		hr = DV_E_FORMATETC;

	if(IsZombie())							// Check for range zombie
		return CO_E_RELEASED;
	
	if( (cf == cf_EMBEDDEDOBJECT ||
		 cf == cf_EMBEDSOURCE) &&
		(pformatetc->tymed & TYMED_ISTORAGE))
	{
		// For some reason the NT4.0 and Win95 Shell
		//          ask for the EMBEDSOURCE format.
        _pObjStg = GetDataForEmbeddedObject( _pOleObj, pmedium->pstg );
		pmedium->tymed = TYMED_ISTORAGE;
		if (NULL == pmedium->pstg)
			pmedium->pstg = _pObjStg;
		hr = pmedium->pstg != NULL ? NOERROR : hr;
		return hr;
	}
	
	if( cf == cf_OBJECTDESCRIPTOR &&
			 (pformatetc->tymed & TYMED_HGLOBAL) &&
			 _hObjDesc)
	{
		pmedium->hGlobal = DuplicateHGlobal(_hObjDesc);
		pmedium->tymed = TYMED_HGLOBAL;
		return NOERROR;
	}

	// First propogate the message to the object and see if it handles the format
	if (_pOleObj)
	{
        // Include the formats supported by the object
        IDataObject * pdataobj = NULL;
        if (FAILED(_pOleObj->GetClipboardData(0, &pdataobj)) || pdataobj == NULL)    	        	            
            _pOleObj->QueryInterface(IID_IDataObject, (void**) &pdataobj);
            
        if (pdataobj)
        {
            hr = pdataobj->GetData(pformatetc, pmedium);
            pdataobj->Release();
            if (hr == S_OK)
            {
                if ((cf == cf_EMBEDDEDOBJECT || cf == cf_EMBEDSOURCE) && _pOleObj)
                {
                    OleSaveSiteFlags(pmedium->pstg, _dwFlags, _dwUser, _dvaspect);
                }
                return S_OK;
            }            
        }        
	}
	return E_NOTIMPL;
}

/*
 *	CDataTransferObj::QueryGetData (pformatetc)
 *
 *	@mfunc
 *		Queries whether the given format is available in this data object
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CDataTransferObj::QueryGetData(
	FORMATETC *pformatetc )		// @parm FETC to look for
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::QueryGetData");

	if(IsZombie())							// Check for range zombie
		return CO_E_RELEASED;

	DWORD	cFETC = _cTotal;

	while (cFETC--)				// Maybe faster to search from start
	{
		if( pformatetc->cfFormat == _prgFormats[cFETC].cfFormat && 
			(pformatetc->tymed & _prgFormats[cFETC].tymed) )
		{
			return NOERROR;
		}
	}

	return DV_E_FORMATETC;
}

/*
 *	CDataTransferObj::SetData (pformatetc, pmedium, fRelease)
 *
 *	@mfunc
 *		allows data to be set into this data object
 *
 *	@rdesc
 *		HRESULT = E_FAIL
 *
 *	@devnote
 *		as we are a data transfer object with a "snapshot" of data,
 *		we do not allow it to be replaced
 */
STDMETHODIMP CDataTransferObj::SetData(
	FORMATETC *pformatetc,
	STGMEDIUM *pmedium,
	BOOL fRelease)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::SetData");

	return E_FAIL;
}


/*
 *	CDataTransferObj::OnPreReplaceRange (cp, cchDel, cchNew, cpFormatMin,
 *										 cpFormatMax)
 *
 *	@mfunc	implementation of ITxNotify::OnPreReplaceRange
 *			called before changes are made to the backing store
 */
void CDataTransferObj::OnPreReplaceRange(
	LONG cp, 			//@parm cp of the changes
	LONG cchDel,		//@parm #of chars deleted
	LONG cchNew,		//@parm # of chars added
	LONG cpFormatMin, 	//@parm min cp of formatting changes
	LONG cpFormatMax)	//@parm max cp of formatting changes
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::OnPreReplaceRange");

	if(CONVERT_TO_PLAIN != cp && CP_INFINITE != cp)
	{
		if(cp > _cpMin + _cch)
			return;							// Change beyond our extent

		if(cp + cchDel < _cpMin)
		{
			_cpMin += (cchNew - cchDel);	// Change before our extent
			return;
		}
	}

	// FUTURE (murrays): save only one master format (UTF8 RTF or better
	// CTxtStory) and generate individual ones in GetData and GetDataHere.
	_hPlainText = TextToHglobal(_hPlainText, tPlain);
	_hRtfText	= TextToHglobal(_hRtfText,	 tRtf);
	if(_ped->GetCharFlags() & ~(fLATIN1 | fSYMBOL))
		_hRtfUtf8 = TextToHglobal(_hRtfUtf8, tRtfUtf8);
}

/*
 *	CDataTransferObj::OnPostReplaceRange(cp, cchDel, cchNew, cpFormatMin,
 *										 cpFormatMax)
 *	@mfunc	implementation of ITxNotify::OnPostReplaceRange
 *			called after changes are made to the backing store
 *
 *	@comm	we use this method to keep our cp's up-to-date
 */
void CDataTransferObj::OnPostReplaceRange(
	LONG cp, 			//@parm cp of the changes
	LONG cchDel,		//@parm #of chars deleted
	LONG cchNew,		//@parm # of chars added
	LONG cpFormatMin, 	//@parm min cp of formatting changes
	LONG cpFormatMax)	//@parm max cp of formatting changes
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::OnPostReplaceRange");

	// Nothing to do
	return;
}

/*
 *	CDataTransferObj::Zombie ()
 *
 *	@mfunc
 *		Turn this object into a zombie
 */
void CDataTransferObj::Zombie ()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CDataTransferObj::Zombie");

	_ped = NULL;
}

/*
 *	CDataTransferObj::Create(ped, prg, lStreamFormat)
 *
 *	@mfunc
 *		static function to create CDataTransferObj. Used to force users
 *		not to create this object on the stack, which would break OLE's
 *		liveness rules.
 *
 *	@rdesc
 *		new CDataTransferObj *
 */
CDataTransferObj *CDataTransferObj::Create(
	CTxtEdit *ped,			// @parm ped to which this DataObject belongs
	CTxtRange *prg,			// @parm range for the data object
	LONG lStreamFormat)		// @parm stream format to use in Rtf conversion
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::Create");

	Assert(CFETC == ARRAY_SIZE(g_rgFETC) && CFETC == ARRAY_SIZE(g_rgDOI));

	LONG			ch;
	CNotifyMgr *	pnm;
	CDataTransferObj *pdo = new CDataTransferObj(ped);

	if( !pdo )
	{
		ped->GetCallMgr()->SetOutOfMemory();
		return NULL;
	}

	LONG cpMin, cpMost;
	pdo->_cch = prg->GetRange(cpMin, cpMost);
	pdo->_cpMin = cpMin;

	pdo->_lStreamFormat = lStreamFormat;

	pnm = ped->GetNotifyMgr();
	if(pnm)
		pnm->Add( (ITxNotify *) pdo );

	//Set the object count.
	pdo->_cObjs = 0;
	if( ped->HasObjects() )
		pdo->_cObjs = ped->_pobjmgr->CountObjectsInRange(cpMin, cpMost);

	int cTotal = !ped->IsRich() ? 2 :
					(ped->GetCharFlags() & ~(fLATIN1 | fSYMBOL)) ? 7 : 5;


   	int cExtraFmtEtc = 0;
	COleObject *pobj = NULL;
	FORMATETC rgfetc[255];
	BOOL bValidOleObj = FALSE;

	// We only support 2 formats in the play text case
    if ( !ped->IsRich() )
    {        
        pdo->_cTotal = cTotal;
        pdo->_prgFormats = new FORMATETC[cTotal];
        if (!pdo->_prgFormats)
            goto ErrorExit;
            
		// Plain-text case
		pdo->_prgFormats[0] = g_rgFETC[iAnsiFETC];
		pdo->_prgFormats[1] = g_rgFETC[iUnicodeFETC];
		return pdo;
	}

    // We need to count the number of supported formats
	if (ped->HasObjects() && pdo->_cch == 1 && prg->GetChar(&ch) == NOERROR && ch == WCH_EMBEDDING)
	{
	    pobj = ped->_pobjmgr->GetObjectFromCp(pdo->_cpMin);
	    pdo->_dwFlags = pobj->GetFlags();
        pdo->_dwUser = pobj->GetUser();
        pdo->_dvaspect =pobj->GetAspect();
	    IUnknown * punk = pobj->GetIUnknown();

	    //  We want to query IOleObject on which formats it supports.  And add that to the
	    // FORMATETC array.
	    if (punk &&	punk->QueryInterface(IID_IOleObject,(void **) &pdo->_pOleObj) == NOERROR)
	   	{
	   	    bValidOleObj = TRUE;
	   	    
	        // Include the formats supported by the object
			IDataObject * pdataobj = NULL;
	        if (FAILED(pdo->_pOleObj->GetClipboardData(0, &pdataobj)) || pdataobj == NULL)    	        	            
                pdo->_pOleObj->QueryInterface(IID_IDataObject, (void**) &pdataobj);

            if (pdataobj)
            {
	            IEnumFORMATETC *pifetc = NULL;

	            // 1.0 didn't check the return value of EnumFormatEtc.  This is important because ccMail 
	            // will return an OLE error although it actually succeeds in setting the formatetc
	            if ((SUCCEEDED(pdataobj->EnumFormatEtc( DATADIR_GET, &pifetc)) || ped->Get10Mode()) && pifetc)
	            {
	                AssertSz(pifetc, "IEnumFormatEtc is NULL");
	                
	                // Copy the formats which are supported by the object
	                while((pifetc->Next(1, &rgfetc[cExtraFmtEtc], NULL)) == S_OK && cExtraFmtEtc < 255)
	                    cExtraFmtEtc++;	                
	                pifetc->Release();
	            }
	            pdataobj->Release();
            }
	    }
	}

    pdo->_cTotal = cTotal + cExtraFmtEtc;
	pdo->_prgFormats = new FORMATETC[pdo->_cTotal];
	if (!pdo->_prgFormats) 
	    goto ErrorExit;

    if (pobj)
    {
    	// copy over formats supported by the object itself
    	if (cExtraFmtEtc)
    	    memcpy(pdo->_prgFormats, rgfetc, cExtraFmtEtc * sizeof(FORMATETC));

        // copy formats supported by Richedit as a container
    	// Have an OLE object: offer all OLE formats plus RTF
    	pdo->_prgFormats[cExtraFmtEtc++] = g_rgFETC[iEmbObj];	// EmbeddedObject
    	pdo->_prgFormats[cExtraFmtEtc++] = g_rgFETC[iObtDesc];	// ObjectDescriptor
    	pdo->_prgFormats[cExtraFmtEtc++] = g_rgFETC[iMfPict];	// Metafile
    	pdo->_prgFormats[cExtraFmtEtc++] = g_rgFETC[iRtfFETC];	// RTF 
    	pdo->_prgFormats[cExtraFmtEtc++] = g_rgFETC[iRtfNoObjs];	// RTF with no objects
	}
	else
	{
        // Regular rich-text case
    	pdo->_prgFormats[0] = g_rgFETC[iRtfFETC];		// RTF
    	pdo->_prgFormats[1] = g_rgFETC[iRtfNoObjs];		// RTF with no objects
    	pdo->_prgFormats[2] = g_rgFETC[iRtfAsTextFETC];	// RTF as Text
    	pdo->_prgFormats[3] = g_rgFETC[iAnsiFETC];		// ANSI plain text
    	pdo->_prgFormats[4] = g_rgFETC[iUnicodeFETC];	// Unicode plain text
    	cExtraFmtEtc = 5;
	}


	// We only offer up the six formats that we know how to handle in GetData.
	// The actual values differ somewhat from regular rich text and text
	// with embedded objects
    if (cTotal == 7)
    {
        pdo->_prgFormats[cExtraFmtEtc++] = g_rgFETC[iRtfUtf8];	// RTF in UTF-8
        pdo->_prgFormats[cExtraFmtEtc++] = g_rgFETC[iRtfNCRforNonASCII];
    }

    // Get the embedded object formats now
    if (bValidOleObj)
    {
        SIZEL sizel;
        pobj->GetSizel(sizel);        
        pdo->_hObjDesc = pdo->GetDataForObjectDescriptor( pdo->_pOleObj, pobj->GetDvaspect(), &sizel);
		pdo->_pObjStg = pdo->GetDataForEmbeddedObject( pdo->_pOleObj, NULL );
		pdo->_hMFPict = (HMETAFILE) OleStdGetMetafilePictFromOleObject(	pdo->_pOleObj, 
		                                pobj->GetDvaspect(), NULL, NULL);
    }

    return pdo;

ErrorExit:	
    
	pdo->_cTotal = 0;
	pdo->Release();
	ped->GetCallMgr()->SetOutOfMemory();
	return NULL;
}

/*
 *	CDataTransferObj::TextToHglobal(hText, tKind)
 *
 *	@mfunc
 *		Instantiates text on demand for the data object.
 *
 *	@rdesc
 *		HGLOBAL
 */
HGLOBAL CDataTransferObj::TextToHglobal(
	HGLOBAL &hText,
	TEXTKIND tKind)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::PlainTextToHglobal");

	if (hText == NULL)
	{
		CTxtRange rg(_ped, _cpMin, -_cch);
		if (tKind == tPlain)
		{
			hText = _ped->GetDTE()->UnicodePlainTextFromRange(&rg);
		}
		else if(_ped->IsRich())
		{
			LONG lStreamFormat = _lStreamFormat;
			if(tKind == tRtfUtf8)
				lStreamFormat = LOWORD(lStreamFormat) | SF_USECODEPAGE | (CP_UTF8 << 16);

			else if(tKind == tRtfNCRforNonASCII)
				lStreamFormat |= SF_NCRFORNONASCII;

			hText = _ped->GetDTE()->RtfFromRange(&rg, lStreamFormat);
		}
	}
	return hText;	
}

//
//	CDataTransferObj PRIVATE methods
//

/*
 *	CDataTransferObj::CDataTransferObj()
 *
 *	@mfunc
 *		Private constructor
 */

CDataTransferObj::CDataTransferObj( CTxtEdit *ped )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::CDataTransferObj");

	_ped = ped;
	_crefs = 1;
	_cTotal = CFETC;
	_prgFormats = g_rgFETC;
	_cch = 0;
	_cObjs = 0;
}

/*
 *	CDataTransferObj::~CDataTransferObj
 *
 *	@mfunc
 *		Private destructor
 */
CDataTransferObj::~CDataTransferObj()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::~CDataTransferObj");

	// No need to monitor notifications any more
	CNotifyMgr *pnm;

	if(_ped)
	{
		pnm = _ped->GetNotifyMgr();
		if(pnm)
			pnm->Remove( (ITxNotify *)this );
	}

	if( _prgFormats && _prgFormats != g_rgFETC)
		delete _prgFormats;

	if (_pOleObj)
		_pOleObj->Release();

	if (_pObjStg)
		_pObjStg->Release();

#ifndef NOMETAFILES
	if (_hMFPict)
		(void) DeleteMetaFile(_hMFPict);
#endif

	GlobalFree(_hObjDesc);
}		

//
//	CEnumFormatEtc PUBLIC methods
//

/*
 *	CEnumFormatEtc::QueryInterface (riid, ppvObj)
 *
 *	@mfunc
 *		IUnknown method
 *
 *	@rdesc
 *		HRESULT
 */

STDMETHODIMP CEnumFormatEtc::QueryInterface(
	REFIID riid,			// @parm Reference to requested interface ID
	void ** ppv)			// @parm out parm for interface ptr
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::QueryInterface");

    HRESULT		hresult = E_NOINTERFACE;

	*ppv = NULL;

    if( IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IEnumFORMATETC) )
    {
        *ppv = this;
        AddRef();
        hresult = NOERROR;
    }
    return hresult;
}

/*
 *	CEnumFormatEtc::AddRef()
 *
 *	@mfunc
 *		IUnknown method
 *
 *	@rdesc
 *		ULONG - incremented reference count
 */

STDMETHODIMP_(ULONG) CEnumFormatEtc::AddRef( )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::AddRef");

 	return ++_crefs;
}

/*
 *	CEnumFormatEtc::Release()
 *
 *	@mfunc
 *		IUnknown method
 *
 *	@rdesc
 *		ULONG - decremented reference count
 */

STDMETHODIMP_(ULONG) CEnumFormatEtc::Release( )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::Release");

	_crefs--;

	if( _crefs == 0 )
	{
		delete this;
		return 0;
	}

	return _crefs;
}

/*
 *	CEnumFormatEtc::Next (celt, rgelt, pceltFetched)
 *
 *	@mfunc
 *		fetches the next [celt] elements in our formatetc collection
 *
 *	@rdesc
 *		HRESULT
 */

STDMETHODIMP CEnumFormatEtc::Next( ULONG celt, FORMATETC *rgelt,
        ULONG *pceltFetched)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::Next");

    HRESULT		hresult = NOERROR;
    ULONG		cFetched;

	if( pceltFetched == NULL && celt != 1 )
    {
        // the spec says that if pceltFetched == NULL, then
        // the count of elements to fetch must be 1
        return E_INVALIDARG;
    }

    // we can only grab as many elements as there are left

    if( celt > _cTotal - _iCurrent )
    {
        cFetched = _cTotal - _iCurrent;
        hresult = S_FALSE;
    }
    else
        cFetched = celt;

    // Only copy if we have elements to copy

    if( cFetched > 0 )
    {
        memcpy( rgelt, _prgFormats + _iCurrent,
            cFetched * sizeof(FORMATETC) );
    }

    _iCurrent += cFetched;

    if( pceltFetched )
        *pceltFetched = cFetched;

    return hresult;
}

/*
 *	CEnumFormatEtc::Skip
 *
 *	@mfunc
 *		skips the next [celt] formats
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CEnumFormatEtc::Skip( ULONG celt )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::Skip");

    HRESULT		hresult = NOERROR;

    _iCurrent += celt;

    if( _iCurrent > _cTotal )
    {
        // whoops, skipped too far ahead.  Set us to the max limit.
        _iCurrent = _cTotal;
        hresult = S_FALSE;
    }

    return hresult;
}

/*
 *	CEnumFormatEtc::Reset
 *
 *	@mfunc
 *		resets the seek pointer to zero
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CEnumFormatEtc::Reset( void )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::Reset");

    _iCurrent = 0;

    return NOERROR;
}

/*
 *	CEnumFormatEtc::Clone
 *
 *	@mfunc
 *		clones the enumerator
 *
 *	@rdesc
 *		HRESULT
 */

STDMETHODIMP CEnumFormatEtc::Clone( IEnumFORMATETC **ppIEnum )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::Clone");
	
    return CEnumFormatEtc::Create(_prgFormats, _cTotal, ppIEnum);
}

/*
 *	CEnumFormatEtc::Create (prgFormats, cTotal, hr)
 *
 *	@mfunc
 *		creates a new format enumerator
 *
 *	@rdesc
 *		HRESULT
 *
 *	@devnote
 *		*copies* the formats passed in.  We do this as it simplifies
 *		memory management under OLE object liveness rules
 */

HRESULT CEnumFormatEtc::Create( FORMATETC *prgFormats, ULONG cTotal, 
	IEnumFORMATETC **ppenum )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::Create");

	CEnumFormatEtc *penum = new CEnumFormatEtc();

	if(penum)
	{
  		// _iCurrent, _crefs are set in the constructor

		if( cTotal > 0 )
		{
			penum->_prgFormats = new FORMATETC[cTotal];
			if( penum->_prgFormats )
			{
				penum->_cTotal = cTotal;
				memcpy(penum->_prgFormats, prgFormats, 
						cTotal * sizeof(FORMATETC));
				*ppenum = penum;
				return NOERROR;
			}	
		}

		delete penum;
	}
	return E_OUTOFMEMORY;
}

//
// CEnumFormatEtc PRIVATE methods
//

/*
 *	CEnumFormatEtc::CEnumFormatEtc()
 *
 *	@mfunc
 *		Private constructor
 */

CEnumFormatEtc::CEnumFormatEtc()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::CEnumFormatEtc");

	_cTotal = 0;
	_crefs	= 1;
	_prgFormats = NULL;
	_iCurrent = 0;
}

/*
 *	CEnumFormatEtc::~CEnumFormatEtc()
 *
 *	@mfunc
 *		Private destructor
 */

CEnumFormatEtc::~CEnumFormatEtc( void )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::~CEnumFormatEtc");

    if( _prgFormats )
        delete _prgFormats;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\edit.cpp ===
/*
 *  @doc INTERNAL
 *
 *  @module EDIT.C - main part of CTxtEdit |
 *
 *      See also textserv.cpp (ITextServices and SendMessage interfaces)
 *      and tomDoc.cpp (ITextDocument interface)
 *
 *  Authors: <nl>
 *      Original RichEdit code: David R. Fulmer <nl>
 *      Christian Fortini, Murray Sargent, Alex Gounares, Rick Sailor,
 *      Jon Matousek
 *
 *  History: <nl>
 *      12/28/95 jonmat-Added support of Magellan mouse and smooth scrolling.
 *
 *  @devnote
 *      Be sure to set tabs at every four (4) columns.  In fact, don't even
 *      think of doing anything else!
 *
 *  Copyright (c) 1995-1998 Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_edit.h"
#include "_dispprt.h"
#include "_dispml.h"
#include "_dispsl.h"
#include "_select.h"
#include "_text.h"
#include "_runptr.h"
#include "_font.h"
#include "_measure.h"
#include "_render.h"
#include "_m_undo.h"
#include "_antievt.h"
#include "_rtext.h"

#include "_uspi.h"
#include "_urlsup.h"

#ifdef LINESERVICES
#include "_ols.h"
#endif

#include "_txtbrk.h"
#include "_clasfyc.h"

#define CONTROL(_ch) (_ch - 'A' + 1)

ASSERTDATA

// This is not public because we don't really want folks using it.
// ITextServices is a private interface.
EXTERN_C const IID IID_ITextServices = { // 8d33f740-cf58-11ce-a89d-00aa006cadc5
    0x8d33f740,
    0xcf58,
    0x11ce,
    {0xa8, 0x9d, 0x00, 0xaa, 0x00, 0x6c, 0xad, 0xc5}
  };

// {13E670F4-1A5A-11cf-ABEB-00AA00B65EA1}
EXTERN_C const GUID IID_ITextHost =
{ 0x13e670f4, 0x1a5a, 0x11cf, { 0xab, 0xeb, 0x0, 0xaa, 0x0, 0xb6, 0x5e, 0xa1 } };

// {13E670F5-1A5A-11cf-ABEB-00AA00B65EA1}
EXTERN_C const GUID IID_ITextHost2 =
{ 0x13e670f5, 0x1a5a, 0x11cf, { 0xab, 0xeb, 0x0, 0xaa, 0x0, 0xb6, 0x5e, 0xa1 } };

// this is used internally do tell if a data object is one of our own.
EXTERN_C const GUID IID_IRichEditDO =
{ /* 21bc3b20-e5d5-11cf-93e1-00aa00b65ea1 */
    0x21bc3b20,
    0xe5d5,
    0x11cf,
    {0x93, 0xe1, 0x00, 0xaa, 0x00, 0xb6, 0x5e, 0xa1}
};

// Static data members
DWORD CTxtEdit::_dwTickDblClick;    // time of last double-click
POINT CTxtEdit::_ptDblClick;        // position of last double-click

//HCURSOR CTxtEdit::_hcurCross = 0; // We don't implement outline drag move
HCURSOR CTxtEdit::_hcurArrow = 0;
HCURSOR CTxtEdit::_hcurHand = 0;
HCURSOR CTxtEdit::_hcurIBeam = 0;
HCURSOR CTxtEdit::_hcurItalic = 0;
HCURSOR CTxtEdit::_hcurSelBar = 0;

const TCHAR szCRLF[]= TEXT("\r\n");
const TCHAR szCR[]  = TEXT("\r");

WORD    g_wFlags = 0;                   // Keyboard controlled flags

/*
 *  GetKbdFlags(vkey, dwFlags)
 *
 *  @func
 *      return bit mask (RSHIFT, LSHIFT, RCTRL, LCTRL, RALT, or LALT)
 *      corresponding to vkey = VK_SHIFT, VK_CONTROL, or VK_MENU and
 *      dwFlags
 *
 *  @rdesc
 *      Bit mask corresponding to vkey and dwFlags
 */
DWORD GetKbdFlags(
    WORD    vkey,       //@parm Virtual key code
    DWORD   dwFlags)    //@parm lparam of WM_KEYDOWN msg
{
    if(vkey == VK_SHIFT)
        return (LOBYTE(HIWORD(dwFlags)) == 0x36) ? RSHIFT : LSHIFT;

    if(vkey == VK_CONTROL)
        return (HIWORD(dwFlags) & KF_EXTENDED) ? RCTRL : LCTRL;

    Assert(vkey == VK_MENU);

    return (HIWORD(dwFlags) & KF_EXTENDED) ? RALT : LALT;
}

///////////////// CTxtEdit Creation, Initialization, Destruction ///////////////////////////////////////

/*
 *  CTxtEdit::CTxtEdit()
 *
 *  @mfunc
 *      constructor
 */
CTxtEdit::CTxtEdit(
    ITextHost2 *phost,
    IUnknown * punk)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::CTxtEdit");

    _unk.Init();
    _punk = (punk) ? punk : &_unk;
    _ldte.Init(this);
    _phost    = phost;
    _cpAccelerator = -1;                    // Default to no accelerator

    // Initialize _iCF and _iPF to something bogus
    Set_iCF(-1);
    Set_iPF(-1);

    // Initialize local maximum text size to window default
    _cchTextMost = cInitTextMax;

    // This actually counts the number of active ped
    W32->AddRef();
}

/*
 *  CTxtEdit::~CTxtEdit()
 *
 *  @mfunc
 *      Destructor
 */
CTxtEdit::~CTxtEdit ()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::~CTxtEdit");

    Assert(!_fMButtonCapture);              // Need to properly transition
                                            //  Magellan mouse if asserts!
    _fSelfDestruct = TRUE;                  // Tell the Call Mgr not to
                                            //  call this any more
    // Flush clipboard first
    _ldte.FlushClipboard();

    if(_pDocInfo)                           // Do this before closing
    {                                       //  down internal structures
        CloseFile(TRUE);                    // Close any open file
        delete _pDocInfo;                   // Delete document info
        _pDocInfo = NULL;
    }

    if(_pdetecturl)
        delete _pdetecturl;

    if (_pbrk)
        delete _pbrk;

    if(_pobjmgr)
        delete _pobjmgr;

    // Release our reference to selection object
    if(_psel)
        _psel->Release();

    // Delete undo and redo managers
    if(_pundo)
        _pundo->Destroy();

    // Release message filter.
    // Note that the attached message filter must have released this document
    // Otherwise we will never get here.
    if (_pMsgFilter)
        _pMsgFilter->Release();

    if(_predo)
        _predo->Destroy();

    ReleaseFormats(Get_iCF(), Get_iPF());   // Release default formats

    delete _pdp;                            // Delete displays
    delete _pdpPrinter;
    _pdp = NULL;                            // Break any further attempts to
                                            //  use display

    if (_fHost2)
    {
        // We are in a windows host - need to deal with the shutdown
        // problem where the window can be destroyed before text
        // services is.
        if (!_fReleaseHost)
        {
            ((ITextHost2*)_phost)->TxFreeTextServicesNotification();
        }
        else
        {
            // Had to keep host alive so tell it we are done with it.
            _phost->Release();
        }
    }

    W32->Release();
}

/*
 *  CTxtEdit::Init (prcClient)
 *
 *  @mfunc
 *      Initializes this CTxtEdit. Called by CreateTextServices()
 *
 *  @rdesc
 *      Return TRUE if successful
 */

BOOL CTxtEdit::Init (
    const RECT *prcClient)      //@parm Client RECT
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::Init");

    CCharFormat         CF;
    DWORD               dwBits = 0;
    DWORD               dwMask;
    LONG                iCF, iPF;
    CParaFormat         PF;
    CCallMgr            callmgr(this);

    static BOOL fOnce = FALSE;
    if (!fOnce)
    {
        CLock lock;
        fOnce = TRUE;
        _fnpPropChg[ 0] = &CTxtEdit::OnRichEditChange;          // TXTBIT_RICHTEXT
        _fnpPropChg[ 1] = &CTxtEdit::OnTxMultiLineChange;       // TXTBIT_MULTILINE
        _fnpPropChg[ 2] = &CTxtEdit::OnTxReadOnlyChange;        // TXTBIT_READONLY
        _fnpPropChg[ 3] = &CTxtEdit::OnShowAccelerator;         // TXTBIT_SHOWACCELERATOR
        _fnpPropChg[ 4] = &CTxtEdit::OnUsePassword;             // TXTBIT_USEPASSWORD
        _fnpPropChg[ 5] = &CTxtEdit::OnTxHideSelectionChange;   // TXTBIT_HIDESELECTION
        _fnpPropChg[ 6] = &CTxtEdit::OnSaveSelection;           // TXTBIT_SAVESELECTION
        _fnpPropChg[ 7] = &CTxtEdit::OnAutoWordSel;             // TXTBIT_AUTOWORDSEL
        _fnpPropChg[ 8] = &CTxtEdit::OnTxVerticalChange;        // TXTBIT_VERTICAL
        _fnpPropChg[ 9] = &CTxtEdit::NeedViewUpdate;            // TXTBIT_SELECTIONBAR
        _fnpPropChg[10] = &CTxtEdit::OnWordWrapChange;          // TXTBIT_WORDWRAP
        _fnpPropChg[11] = &CTxtEdit::OnAllowBeep;               // TXTBIT_ALLOWBEEP
        _fnpPropChg[12] = &CTxtEdit::OnDisableDrag;             // TXTBIT_DISABLEDRAG
        _fnpPropChg[13] = &CTxtEdit::NeedViewUpdate;            // TXTBIT_VIEWINSETCHANGE
        _fnpPropChg[14] = &CTxtEdit::OnTxBackStyleChange;       // TXTBIT_BACKSTYLECHANGE
        _fnpPropChg[15] = &CTxtEdit::OnMaxLengthChange;         // TXTBIT_MAXLENGTHCHANGE
        _fnpPropChg[16] = &CTxtEdit::OnScrollChange;            // TXTBIT_SCROLLBARCHANGE
        _fnpPropChg[17] = &CTxtEdit::OnCharFormatChange;        // TXTBIT_CHARFORMATCHANGE
        _fnpPropChg[18] = &CTxtEdit::OnParaFormatChange;        // TXTBIT_PARAFORMATCHANGE
        _fnpPropChg[19] = &CTxtEdit::NeedViewUpdate;            // TXTBIT_EXTENTCHANGE
        _fnpPropChg[20] = &CTxtEdit::OnClientRectChange;        // TXTBIT_CLIENTRECTCHANGE
    }

    // Set up default CCharFormat and CParaFormat
    if (TxGetDefaultCharFormat(&CF, dwMask) != NOERROR ||
        TxGetDefaultParaFormat(&PF)         != NOERROR ||
        FAILED(GetCharFormatCache()->Cache(&CF, &iCF)) ||
        FAILED(GetParaFormatCache()->Cache(&PF, &iPF)))
    {
        return FALSE;
    }

    GetTabsCache()->Release(PF._iTabs);
    Set_iCF(iCF);                               // Save format indices
    Set_iPF(iPF);

    // Load mouse cursors (but only for first instance)
    if(!_hcurArrow)
    {
        _hcurArrow = LoadCursor(0, IDC_ARROW);
        if(!_hcurHand)
        {
            if (dwMajorVersion < 5)
                _hcurHand   = LoadCursor(hinstRE, MAKEINTRESOURCE(CUR_HAND));
            else
                _hcurHand   = LoadCursor(0, IDC_HAND);
        }
        if(!_hcurIBeam)                         // Load cursor
            _hcurIBeam  = LoadCursor(0, IDC_IBEAM);
        if(!_hcurItalic)
            _hcurItalic = LoadCursor(hinstRE, MAKEINTRESOURCE(CUR_ITALIC));
        if(!_hcurSelBar)
            _hcurSelBar = LoadCursor(hinstRE, MAKEINTRESOURCE(CUR_SELBAR));
    }

#ifdef DEBUG
    // The host is going to do some checking on richtext vs. plain text.
    _fRich = TRUE;
#endif // DEBUG

    if(_phost->TxGetPropertyBits (TXTBITS |     // Get host state flags
        TXTBIT_MULTILINE | TXTBIT_SHOWACCELERATOR,  //  that we cache or need
        &dwBits) != NOERROR)                        //  for display setup
    {
        return FALSE;
    }                                               // Cache bits defined by
    _dwFlags = dwBits & TXTBITS;                    //  TXTBITS mask

    if ((dwBits & TXTBIT_SHOWACCELERATOR) &&        // They want accelerator,
        FAILED(UpdateAccelerator()))                //  so let's get it
    {
        return FALSE;
    }

    _fTransparent = TxGetBackStyle() == TXTBACK_TRANSPARENT;
    if(dwBits & TXTBIT_MULTILINE)                   // Create and initialize
        _pdp = new CDisplayML(this);                //  display
    else
        _pdp = new CDisplaySL(this);
    Assert(_pdp);

    if(!_pdp || !_pdp->Init())
        return FALSE;

    _fUseUndo  = TRUE;
    _fAutoFont = TRUE;
    _fDualFont = TRUE;
    _f10DeferChangeNotify = 0;

    // Set whether we are in our host or not
    ITextHost2 *phost2;
    if(_phost->QueryInterface(IID_ITextHost2, (void **)&phost2) == NOERROR)
    {
        // We assume that ITextHost2 means this is our host
        phost2->Release();
        _fHost2 = TRUE;
    }
    else                                // Get maximum from our host
        _phost->TxGetMaxLength(&_cchTextMost);

    // Add EOP iff Rich Text
    if(IsRich())
    {
        // We should _not_ be in 10 compatibility mode yet.
        // If we transition into 1.0 mode, we'll add a CRLF
        // at the end of the document.
        SetRichDocEndEOP(0);
    }

    // Allow for win.ini control over use of line services
    if (W32->fUseLs())
    {
        OnSetTypographyOptions(TO_ADVANCEDTYPOGRAPHY, TO_ADVANCEDTYPOGRAPHY);
    }

    if (W32->GetDigitSubstitutionMode() != DIGITS_NOTIMPL)
        OrCharFlags(fDIGITSHAPE);       // digit substitution presents

    // Initialize the BiDi property
    // It is set to true if OS is BiDi (the system default LCID is a BiDi language)
    // or if the current keyboard code page is a BiDi code page
    // or if system.ini says we should do it.
    if (W32->OnBiDiOS() ||
        W32->IsBiDiCodePage(GetKeyboardCodePage(0xFFFFFFFF)) ||
        W32->fUseBiDi())
        OrCharFlags(fBIDI);

    _fAutoKeyboard = IsBiDi() && IsBiDiKbdInstalled();
    return TRUE;
}


///////////////////////////// CTxtEdit IUnknown ////////////////////////////////

/*
 *  CTxtEdit::QueryInterface (riid, ppv)
 *
 *  @mfunc
 *      IUnknown method
 *
 *  @rdesc
 *      HRESULT = (if success) ? NOERROR : E_NOINTERFACE
 *
 *  @devnote
 *      This interface is aggregated. See textserv.cpp for discussion.
 */
HRESULT CTxtEdit::QueryInterface(
    REFIID riid,
    void **ppv)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::QueryInterface");

    return _punk->QueryInterface(riid, ppv);
}

/*
 *  CTxtEdit::AddRef()
 *
 *  @mfunc
 *      IUnknown method
 *
 *  @rdesc
 *      ULONG - incremented reference count
 */
ULONG CTxtEdit::AddRef(void)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::AddRef");

    return _punk->AddRef();
}

/*
 *  CTxtEdit::Release()
 *
 *  @mfunc
 *      IUnknown method
 *
 *  @rdesc
 *      ULONG - decremented reference count
 */
ULONG CTxtEdit::Release(void)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::Release");

    return _punk->Release();
}

////////////////////////// Undo Management  //////////////////////////////

/*
 *  CTxtEdit::CreateUndoMgr (dwLim, flags)
 *
 *  @mfunc
 *      Creates an undo stack
 *
 *  @rdesc
 *      Ptr to new IUndoMgr
 */
IUndoMgr *CTxtEdit::CreateUndoMgr(
    DWORD   dwLim,          //@parm Size limit
    USFlags flags)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::CreateUndoMgr");

    IUndoMgr *pmgr = NULL;

    if(_fUseUndo)
    {
        pmgr = new CUndoStack(this, dwLim, flags);
        if(!pmgr)
            return NULL;

        if(!pmgr->GetUndoLimit())
        {
            // The undo stack failed to initialize properly (probably
            // lack of memory). Trash it and return NULL.
            pmgr->Destroy();
            return NULL;
        }
        // We may be asked to create a new undo/redo manager
        // before we are completely done with initialization.
        // We need to clean up memory we have already allocated.
        if(flags & US_REDO)
        {
            if(_predo)
                _predo->Destroy();
            _predo = pmgr;
        }
        else
        {
            if(_pundo)
                _pundo->Destroy();
            _pundo = pmgr;
        }
    }
    return pmgr;
}

/*
 *  CTxtEdit::HandleUndoLimit (dwLim)
 *
 *  @mfunc
 *      Handles the EM_SETUNDOLIMIT message
 *
 *  @rdesc
 *      Actual limit to which things were set.
 */
LRESULT CTxtEdit::HandleSetUndoLimit(
    LONG Count)         //@parm Requested limit size
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::HandleSetUndoLimit");

    if (Count == tomSuspend ||              // This option really just
        Count == tomResume)                 //  suspends undo, i.e.,
    {                                       //  doesn't discard existing
        _fUseUndo = (Count == tomResume);   //  antievents
        return _pundo ? _pundo->GetUndoLimit() : 0;
    }

    if(Count < 0)
        Count = DEFAULT_UNDO_SIZE;

    if(!Count)
    {
        _fUseUndo = FALSE;
        if(_pundo)
        {
            _pundo->Destroy();
            _pundo = NULL;
        }
        if(_predo)
        {
            _predo->Destroy();
            _predo = NULL;
        }
    }
    else if(!_pundo)
    {
        _fUseUndo = TRUE;
        // Don't worry about return value; if it's NULL, we're
        // in the same boat as if the API wasn't called (so later
        // on, we might try to allocate the default).
        CreateUndoMgr(Count, US_UNDO);
    }
    else
    {
        Count = _pundo->SetUndoLimit(Count);

        // Setting the undo limit on the undo stack will return to
        // us the actual amount set.  Try to set the redo stack to
        // the same size.  If it can't go that big, too bad.
        if(_predo)
            _predo->SetUndoLimit(Count);
    }
    return Count;
}

/*
 *  CTxtEdit::HandleSetTextMode(mode)
 *
 *  @mfunc  handles setting the text mode
 *
 *  @rdesc  LRESULT; 0 (NOERROR) on success, OLE failure code on failure.
 *
 *  @devnote    the text mode does not have to be fully specified; it
 *          is sufficient to merely specify the specific desired behavior.
 *
 *          Note that the edit control must be completely empty for this
 *          routine to work.
 */
LRESULT CTxtEdit::HandleSetTextMode(
    DWORD mode)         //@parm the desired mode
{
    LRESULT lres = 0;

    // First off, we must be completely empty
    if (GetAdjustedTextLength() ||
        _pundo && _pundo->CanUndo() ||
        _predo && _predo->CanUndo())
    {
        return E_UNEXPECTED;
    }

    // These bits are considered one at a time; thus the absence of
    // any bits does _NOT_ imply any change in behavior.

    // TM_RICHTEXT && TM_PLAINTEXT are mutually exclusive; they cannot
    // be both set.  Same goes for TM_SINGLELEVELUNDO / TM_MULTILEVELUNDO
    // and TM_SINGLECODEPAGE / TM_MULTICODEPAGE
    if((mode & (TM_RICHTEXT | TM_PLAINTEXT)) == (TM_RICHTEXT | TM_PLAINTEXT) ||
       (mode & (TM_SINGLELEVELUNDO | TM_MULTILEVELUNDO)) ==
            (TM_SINGLELEVELUNDO | TM_MULTILEVELUNDO) ||
       (mode & (TM_SINGLECODEPAGE | TM_MULTICODEPAGE)) ==
            (TM_SINGLECODEPAGE | TM_MULTICODEPAGE))
    {
        lres = E_INVALIDARG;
    }
    else if((mode & TM_PLAINTEXT) && IsRich())
        lres = OnRichEditChange(FALSE);

    else if((mode & TM_RICHTEXT) && !IsRich())
        lres = OnRichEditChange(TRUE);

    if(!lres)
    {
        if(mode & TM_SINGLELEVELUNDO)
        {
            if(!_pundo)
                CreateUndoMgr(1, US_UNDO);

            if(_pundo)
            {
                // We can 'Enable' single level mode as many times
                // as we want, so no need to check for it before hand.
                lres = ((CUndoStack *)_pundo)->EnableSingleLevelMode();
            }
            else
                lres = E_OUTOFMEMORY;
        }
        else if(mode & TM_MULTILEVELUNDO)
        {
            // If there's no undo stack, no need to do anything,
            // we're already in multi-level mode
            if(_pundo && ((CUndoStack *)_pundo)->GetSingleLevelMode())
                ((CUndoStack *)_pundo)->DisableSingleLevelMode();
        }

        if(mode & TM_SINGLECODEPAGE)
            _fSingleCodePage = TRUE;

        else if(mode & TM_MULTICODEPAGE)
            _fSingleCodePage = FALSE;
    }

    // We don't want this marked modified after this operation to make us
    // work better in dialog boxes.
    _fModified = FALSE;

    return lres;
}


////////////////////////// Uniscribe Interface //////////////////////////////

/*
 *  GetUniscribe()
 *
 *  @mfunc
 *      returns a pointer to the Uniscribe interface object
 *
 *  @rdesc
 *      Ptr to Uniscribe interface
 */
extern BOOL g_fNoUniscribe;
CUniscribe* GetUniscribe()
{
    if (g_pusp)
        return g_pusp;

    if (g_fNoUniscribe)
        return NULL;

    //Attempt to create the Uniscribe object, but make sure the
    //OS is valid and that we can load the uniscribe DLL.
    int cScripts;
    //Find out if OS is valid, or if delay-load fails
    if (!IsSupportedOS() || FAILED(ScriptGetProperties(NULL, &cScripts)))
    {
        g_fNoUniscribe = TRUE;
        return NULL;
    }

    if (!g_pusp)
        g_pusp = new CUniscribe();

    AssertSz(g_pusp, "GetUniscribe(): Create Uniscribe object failed");
    return g_pusp;
}


////////////////////////// Notification Manager //////////////////////////////

/*
 *  CTxtEdit::GetNotifyMgr()
 *
 *  @mfunc
 *      returns a pointer to the notification manager (creating it if necessary)
 *
 *  @rdesc
 *      Ptr to notification manager
 */
CNotifyMgr *CTxtEdit::GetNotifyMgr()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetNotifyMgr");

    return &_nm;
}


////////////////////////// Object Manager ///////////////////////////////////

/*
 *  CTxtEdit::GetObjectMgr()
 *
 *  @mfunc
 *      returns a pointer to the object manager (creating if necessary)
 *
 *  @rdesc
 *      pointer to the object manager
 */
CObjectMgr *CTxtEdit::GetObjectMgr()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetObjectMgr");

    if(!_pobjmgr)
        _pobjmgr = new CObjectMgr();

    return _pobjmgr;
}


////////////////////////////// Properties - Selection ////////////////////////////////


LONG CTxtEdit::GetSelMin() const
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetSelMin");

    return _psel ? _psel->GetCpMin() : 0;
}

LONG CTxtEdit::GetSelMost() const
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetSelMost");

    return _psel ? _psel->GetCpMost() : 0;
}


////////////////////////////// Properties - Text //////////////////////////////////////

LONG CTxtEdit::GetTextRange(
    LONG    cpFirst,
    LONG    cch,
    TCHAR * pch)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetTextRange");

#ifdef DEBUG
    const LONG cchAsk = cch;
#endif
    CTxtPtr tp(this, cpFirst);
    LONG    cchAdj = GetAdjustedTextLength();

    if(--cch < 0 || cpFirst > cchAdj)
        return 0;

    cch = min(cch, cchAdj - cpFirst);
    if(cch > 0)
    {
        cch = tp.GetText(cch, pch);
        Assert(cch >= 0);
    }
    pch[cch] = TEXT('\0');

#ifdef DEBUG
    if(cch != cchAsk - 1)
        Tracef(TRCSEVINFO, "CTxtEdit::GetTextRange: only got %ld out of %ld", cch, cchAsk - 1);
#endif

    return cch;
}

/*
 *  CTxtEdit::GetTextEx (pgt, pch)
 *
 *  @mfunc
 *      Grabs text according to various params
 *
 *  @rdesc
 *      Count of bytes gotten
 */
LONG CTxtEdit::GetTextEx(
    GETTEXTEX *pgt,     //@parm Info on what to get
    TCHAR *    pch)     //@parm Where to put the text
{
    LONG    cb;
    LONG    cch;
    LONG    cchGet = GetAdjustedTextLength();
    TCHAR * pchUse = pch;
    CTxtPtr tp(this, 0);
    CTempWcharBuf twcb;

    if(pgt->flags & GT_SELECTION)           // Get selected text
    {
        LONG cpMin, cpMost;
        cch = GetSel()->GetRange(cpMin, cpMost);
        cchGet = min(cch, cchGet - cpMin);  // Don't include final EOP
        tp.SetCp(cpMin);
    }

    if(pgt->codepage == (unsigned)-1)   // Use default codepage
        pgt->codepage = GetDefaultCodePage(EM_GETTEXTEX);

    if(pgt->cb == (unsigned)-1)         // Client says its buffer is big enuf
    {
        pgt->cb = cchGet + 1;
        if(W32->IsFECodePage(pgt->codepage) || pgt->codepage == 1200)
            pgt->cb += cchGet;
        else if(pgt->codepage == CP_UTF8 && (_dwCharFlags & ~fASCII))
            pgt->cb *= (_dwCharFlags & fABOVEX7FF) ? 3 : 2;
    }

    // Allocate a big buffer; make sure that we have
    // enough room for lots of CRLFs if necessary
    if(pgt->flags & GT_USECRLF)
        cchGet *= 2;

    if(pgt->codepage != 1200)
    {
        // If UNICODE, copy straight to client's buffer;
        // else, copy to temp buffer and translate cases first
        pchUse = twcb.GetBuf(cchGet + 1);
        if (pch)
            *((char *) pch) = '\0';         // In case something fails
    }
    else                        // Be sure to leave room for NULL terminator
        cchGet = min(UINT(pgt->cb/2 - 1), (UINT)cchGet);

    // Now grab the text.
    if(pgt->flags & GT_USECRLF)
        cch = tp.GetPlainText(cchGet, pchUse, tomForward, FALSE);
    else
        cch = tp.GetText(cchGet, pchUse);

    pchUse[cch] = L'\0';

    // If we're just doing UNICODE, return number of chars written
    if(pgt->codepage == 1200)
        return cch;

    // Oops, gotta translate to ANSI.
    cb = WideCharToMultiByte(pgt->codepage, 0, pchUse, cch + 1, (char *)pch,
            pgt->cb, pgt->lpDefaultChar, pgt->lpUsedDefChar);

    // Don't count NULL terminator for compatibility with WM_GETTEXT.
    return (cb) ? cb - 1 : 0;
}

/*
 *  CTxtEdit::GetTextLengthEx (pgtl)
 *
 *  @mfunc
 *      Calculates text length in various ways.
 *
 *  @rdesc
 *      Text length calculated in various ways
 *
 *  @comm
 *      This function returns an API cp that may differ from the
 *      corresponding internal Unicode cp.
 */
LONG CTxtEdit::GetTextLengthEx(
    GETTEXTLENGTHEX *pgtl)  //@parm Info describing how to calculate length
{
    LONG    cchUnicode = GetAdjustedTextLength();
    LONG    cEOP = 0;
    DWORD   dwFlags = pgtl->flags;
    GETTEXTEX gt;

    if(pgtl->codepage == (unsigned)-1)
        pgtl->codepage = GetDefaultCodePage(EM_GETTEXTLENGTHEX);

    // Make sure the flags are defined appropriately
    if ((dwFlags & GTL_CLOSE)    && (dwFlags & GTL_PRECISE) ||
        (dwFlags & GTL_NUMCHARS) && (dwFlags & GTL_NUMBYTES))
    {
        TRACEWARNSZ("Invalid flags for EM_GETTEXTLENGTHEX");
        return E_INVALIDARG;
    }

    // Note in the following if statement, the second part of the
    // and clause will always be TRUE. At some point in the future
    // fUseCRLF and Get10Mode may become independent, in which case
    // the code below will automatically work without change.
	// NEW: 1.0 mode gets text as is, so don't add count for CRs.
	// (RichEdit 1.0 only inserts Enters as CRLFs; it doesn't "cleanse"
	// other text insertion strings)
	if((dwFlags & GTL_USECRLF) && !fUseCRLF() && !Get10Mode())
	{
		// Important facts for 1.0 mode (REMARK: this is out of date):
        //
        // (1) 1.0 mode implies that the text is stored with fUseCRLF true.
        // fUseCRLF means that the EOP mark can either be a CR or a
        // CRLF - see CTxtRange::CleanseAndReplaceRange for details.
        //
        // (2) 1.0 mode has an invariant that the count of text returned
        // by this call should be enough to hold all the text returned by
        // WM_GETTEXT.
        //
        // (3) The WM_GETEXT call for 1.0 mode will return a buffer in
        // which all EOPs that consist of a CR are replaced by CRLF.
        //
        // Therefore, for 1.0 mode, we must count all EOPs that consist
        // of only a CR and add addition return character to count the
        // LF that will be added into any WM_GETEXT buffer.

        // For 2.0 mode, the code is much easier, just count up all
        // CRs and bump count of each one by 1.

        CTxtPtr tp(this, 0);
        LONG    Results;

        while(tp.FindEOP(tomForward, &Results))
        {
            // If EOP consists of 1 char, add 1 since is returned by a CRLF.
            // If it consists of 2 chars, add 0, since it's a CRLF and is
            // returned as such.
            if(tp.GetCp() > cchUnicode)     // Don't add correction for
                break;                      //  final CR (if any)
            Results &= 3;
            if(Results)
                cEOP += 2 - Results;

            AssertSz(IN_RANGE(1, Results, 2) || !Results && tp.GetCp() == cchUnicode,
                "CTxtEdit::GetTextLengthEx: CRCRLF found in backing store");
        }
        cchUnicode += cEOP;
    }

	// If we're just looking for the number of characters or if it's an
	// 8-bit codepage in RE 1.0 mode, we've already got the count.
	if ((dwFlags & GTL_NUMCHARS) || !dwFlags ||
		Get10Mode() && Is8BitCodePage(pgtl->codepage))
	{
        return cchUnicode;
	}

    // Hmm, they're looking for number of bytes, but don't care about
    // precision, just multiply by two.  If neither PRECISE or CLOSE is
	// specified, default to CLOSE. Note if the codepage is UNICODE and
	// asking for number of bytes, we also just multiply by 2.
    if((dwFlags & GTL_CLOSE) || !(dwFlags & GTL_PRECISE) ||
        pgtl->codepage == 1200)
    {
        return cchUnicode *2;
    }

	// In order to get a precise answer, we need to convert (which is slow!).
    gt.cb = 0;
    gt.flags = (pgtl->flags & GT_USECRLF);
    gt.codepage = pgtl->codepage;
    gt.lpDefaultChar = NULL;
    gt.lpUsedDefChar = NULL;

    return GetTextEx(&gt, NULL);
}

/*
 *  CTxtEdit::GetDefaultCodePage (msg)
 *
 *  @mfunc
 *      Return codepage to use for converting the text in RichEdit20A text
 *      messages.
 *
 *  @rdesc
 *      Codepage to use for converting the text in RichEdit20A text messages.
 */
LONG CTxtEdit::GetDefaultCodePage(
    UINT msg)
{
    LONG CodePage = GetACP();

    // FUTURE: For backward compatibility in Office97, We always use ACP for all these
    // languages. Need review in the future when the world all moves to Unicode.
    if (W32->IsBiDiCodePage(CodePage) || CodePage == CP_THAI || CodePage == CP_VIETNAMESE ||
        W32->IsFECodePage(CodePage) || _fSingleCodePage || msg == EM_GETCHARFORMAT ||
        msg == EM_SETCHARFORMAT)
    {
        return CodePage;
    }

    if(Get10Mode())
        return GetCodePage(GetCharFormat(-1)->_bCharSet);

    return GetKeyboardCodePage();
}

//////////////////////////////  Properties - Formats  //////////////////////////////////

/*
 *  CTxtEdit::HandleStyle (pCFTarget, pCF, dwMask, dwMask2)
 *
 *  @mfunc
 *      If pCF specifies a style choice, initialize pCFTarget with the
 *      appropriate style, apply pCF, and return NOERROR.  Else return
 *      S_FALSE or an error
 *
 *  @rdesc
 *      HRESULT = (pCF specifies a style choice) ? NOERROR : S_FALSE or error code
 */
HRESULT CTxtEdit::HandleStyle(
    CCharFormat *pCFTarget,     //@parm Target CF to receive CF style content
    const CCharFormat *pCF,     //@parm Source CF that may specify a style
    DWORD        dwMask,        //@parm CHARFORMAT2 mask
    DWORD        dwMask2)       //@parm Second mask
{
    if(pCF->fSetStyle(dwMask, dwMask2))
    {
        // FUTURE: generalize to use client style if specified
        *pCFTarget = *GetCharFormat(-1);
        pCFTarget->ApplyDefaultStyle(pCF->_sStyle);
        return pCFTarget->Apply(pCF, dwMask, dwMask2);
    }
    return S_FALSE;
}

/*
 *  CTxtEdit::HandleStyle (pPFTarget, pPF)
 *
 *  @mfunc
 *      If pPF specifies a style choice, initialize pPFTarget with the
 *      appropriate style, apply pPF, and return NOERROR.  Else return
 *      S_FALSE or an error
 *
 *  @rdesc
 *      HRESULT = (pPF specifies a style choice) ? NOERROR : S_FALSE or error code
 */
HRESULT CTxtEdit::HandleStyle(
    CParaFormat *pPFTarget,     //@parm Target PF to receive PF style content
    const CParaFormat *pPF,     //@parm Source PF that may specify a style
    DWORD       dwMask)         //@parm Mask to use in setting CParaFormat
{
    if(pPF->fSetStyle(dwMask))
    {
        // FUTURE: generalize to use client style if specified
        *pPFTarget = *GetParaFormat(-1);
        pPFTarget->ApplyDefaultStyle(pPF->_sStyle);
        return pPFTarget->Apply(pPF, dwMask);
    }
    return S_FALSE;
}

//////////////////////////// Mouse Commands /////////////////////////////////


HRESULT CTxtEdit::OnTxLButtonDblClk(
    INT     x,          //@parm Mouse x coordinate
    INT     y,          //@parm Mouse y coordinate
    DWORD   dwFlags)    //@parm Mouse message wparam
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxLButtonDblClk");

    BOOL            fEnterParaSelMode = FALSE;
    HITTEST         Hit;
    CTxtSelection * psel = GetSel();
    const POINT     pt = {x, y};

    AssertSz(psel, "CTxtEdit::OnTxLButtonDblClk() - No selection object !");

    if (StopMagellanScroll())
        return S_OK;

    _dwTickDblClick = GetTickCount();
    _ptDblClick.x = x;
    _ptDblClick.y = y;

    TxUpdateWindow();       // Repaint window to show any exposed portions

    if(!_fFocus)
    {
        TxSetFocus();                   // Create and display caret
        return S_OK;
    }

    // Find out what the cursor is pointing at
    _pdp->CpFromPoint(pt, NULL, NULL, NULL, FALSE, &Hit);

    if(Hit == HT_Nothing)
        return S_OK;

    if(Hit == HT_OutlineSymbol)
    {
        CTxtRange rg(*psel);
        rg.ExpandOutline(0, FALSE);
        return S_OK;
    }

    if(Hit == HT_LeftOfText)
        fEnterParaSelMode = TRUE;

    _fWantDrag = FALSE;                 // just to be safe

    // If we are over a link, let the client have a chance to process
    // the message
    if(Hit == HT_Link && HandleLinkNotification(WM_LBUTTONDBLCLK, (WPARAM)dwFlags,
            MAKELPARAM(x, y)))
    {
        return S_OK;
    }

    if(dwFlags & MK_CONTROL)
        return S_OK;

    // Mark mouse down
    _fMouseDown = TRUE;

    if(_pobjmgr && _pobjmgr->HandleDoubleClick(this, pt, dwFlags))
    {
        // The object subsystem handled everything
        _fMouseDown = FALSE;
        return S_OK;
    }

    // Update the selection
    if(fEnterParaSelMode)
        psel->SelectUnit(pt, tomParagraph);
    else
        psel->SelectWord(pt);

    return S_OK;
}

HRESULT CTxtEdit::OnTxLButtonDown(
    INT     x,          //@parm Mouse x coordinate
    INT     y,          //@parm Mouse y coordinate
    DWORD   dwFlags)    //@parm Mouse message wparam
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxLButtonDown");

    BOOL        fEnterLineSelMode = FALSE;
    BOOL        fShift = dwFlags & MK_SHIFT;
    HITTEST     Hit;
    const POINT pt = {x, y};
    COleObject *pobj;
    BOOL        fMustThaw = FALSE;

    const BOOL fTripleClick = GetTickCount() < _dwTickDblClick + W32->GetDCT() &&
                abs(x - _ptDblClick.x) <= W32->GetCxDoubleClk() &&
                abs(y - _ptDblClick.y) <= W32->GetCyDoubleClk();

    if (StopMagellanScroll())
        return S_OK;

    // If click isn't inside view, just activate, don't select

    if(!_fFocus)                    // Sets focus if not already
    {
        // We may be removing an existing selection, so freeze
        // display to avoid flicker
        _pdp->Freeze();
        fMustThaw = TRUE;
        TxSetFocus();               // creates and displays caret
    }

    // Grab selection object
    CTxtSelection * const psel = GetSel();
    AssertSz(psel,"CTxtEdit::OnTxLButtonDown - No selection object !");

    // Find out what cursor is pointing at
    _pdp->CpFromPoint(pt, NULL, NULL, NULL, FALSE, &Hit);

    if(Hit == HT_LeftOfText)
    {
        // Shift click in sel bar treated as normal click
        if(!fShift)
        {
            // Control selbar click and triple selbar click
            // are select all
            if((dwFlags & MK_CONTROL) || fTripleClick)
            {
                psel->SelectAll();
                goto cancel_modes;
            }
            fEnterLineSelMode = TRUE;
            if(!GetAdjustedTextLength() && !_pdp->IsMultiLine())
            {
                const CParaFormat *pPF = psel->GetPF();
                // Can't see selected para mark when flushed right, so
                // leave selection as an insertion point
                if(pPF->_bAlignment == PFA_RIGHT && !pPF->IsRtlPara())
                    fEnterLineSelMode = FALSE;
            }
        }
    }
    else if(Hit == HT_Nothing)
        goto cancel_modes;

    else if(!fShift)
        psel->CancelModes();

    // Let client have a chance to handle this message if we are over a link
    if(Hit == HT_Link && HandleLinkNotification(WM_LBUTTONDOWN, (WPARAM)dwFlags,
            MAKELPARAM(x, y)))
    {
        goto cancel_modes;
    }

    _fMouseDown = TRUE;                     // Flag mouse down
    if(!fShift && _pobjmgr)
    {
        // Deactivate anybody active, etc.
        ClickStatus status = _pobjmgr->HandleClick(this, pt);
        if(status == CLICK_OBJSELECTED)
        {
            // The object subsystem will handle resizing.
            // if not a resize we will signal start of drag
            pobj = _pobjmgr->GetSingleSelect();

            // Because HandleClick returned true, pobj better be non-null.
            Assert(pobj);

            if (!pobj->HandleResize(pt))
                _fWantDrag = !_fDisableDrag;

            goto cancel_modes;
        }
        else if(status == CLICK_OBJDEACTIVATED)
            goto cancel_modes;
    }

    _fCapture = TRUE;                       // Capture the mouse
    TxSetCapture(TRUE);

    // Check for start of drag and drop
    if(!fTripleClick && !fShift && psel->PointInSel(pt, NULL, Hit)
        && !_fDisableDrag)
    {
        // Assume we want a drag. If we don't CmdLeftUp() needs
        //  this to be set anyway to change the selection
        _fWantDrag = TRUE;

        goto cancel_modes;
    }

    if(fShift)                              // Extend selection from current
    {                                       //  active end to click
        psel->InitClickForAutWordSel(pt);
        psel->ExtendSelection(pt);
    }
    else if(fEnterLineSelMode)              // Line selection mode: select line
        psel->SelectUnit(pt, tomLine);
    else if(fTripleClick || Hit == HT_OutlineSymbol) // paragraph selection mode
        psel->SelectUnit(pt, tomParagraph);
    else
    {
        if (Get10Mode())
            _f10DeferChangeNotify = 1;
        psel->SetCaret(pt);
        _mousePt = pt;
    }

    if(fMustThaw)
        _pdp->Thaw();

    return S_OK;

cancel_modes:
    psel->CancelModes();

    if(_fWantDrag)
    {
        TxSetTimer(RETID_DRAGDROP, W32->GetDragDelay());
        _mousePt = pt;
        _bMouseFlags = (BYTE)dwFlags;
        _fDragged = FALSE;
    }

    if(fMustThaw)
        _pdp->Thaw();

    return S_OK;
}

HRESULT CTxtEdit::OnTxLButtonUp(
    INT     x,              //@parm Mouse x coordinate
    INT     y,              //@parm Mouse y coordinate
    DWORD   dwFlags,        //@parm Mouse message wparam
    int     ffOptions)      //@parm Mouse options, see _edit.h for details
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxLButtonUp");

    CheckRemoveContinuousScroll();

    // Remove capture before test for mouse down since we wait till
    // we get the mouse button up message to release capture since Forms
    // wants it that way.
    if(_fCapture && (ffOptions & LB_RELEASECAPTURE))
    {
        TxSetCapture(FALSE);
        _fCapture = FALSE;
    }

    // we were delaying selection change.  So send it now...
    if (DelayChangeNotification() && (ffOptions & LB_FLUSHNOTIFY))
    {
        AssertSz(Get10Mode(), "Flag should only be set in 10 mode");
        _f10DeferChangeNotify = 0;
        GetCallMgr()->SetSelectionChanged();
    }

    if(!_fMouseDown)
    {
        // We noticed the mouse was no longer down earlier so we don't
        // need to do anything.
        return S_OK;
    }

    const BOOL fSetSel = !!_fWantDrag;
    const POINT pt = {x, y};

    // Cancel Auto Word Sel if on
    CTxtSelection * const psel = GetSel();
    AssertSz(psel,"CTxtEdit::OnLeftUp() - No selection object !");

    psel->CancelModes(TRUE);

    // Reset flags
    _fMouseDown = FALSE;
    _fWantDrag = FALSE;
    _fDragged = FALSE;
    TxKillTimer(RETID_DRAGDROP);
    if(IsInOutlineView())
        psel->Update(FALSE);

    // Let the client handle this message if we are over a
    // link area
    if(HandleLinkNotification(WM_LBUTTONUP, (WPARAM)dwFlags,
            MAKELPARAM(x, y)))
    {
        return NOERROR;
    }

    // If we were in drag & drop, put caret under mouse
    if(fSetSel)
    {
        CObjectMgr* pobjmgr = GetObjectMgr();

        // If we were on an object, don't deselect it by setting the caret
        if(pobjmgr && !pobjmgr->GetSingleSelect())
        {
            psel->SetCaret(pt, TRUE);
            if(!_fFocus)
                TxSetFocus();       // create and display caret
        }
    }
    return S_OK;
}

HRESULT CTxtEdit::OnTxRButtonUp(
    INT     x,          //@parm Mouse x coordinate
    INT     y,          //@parm Mouse y coordinate
    DWORD   dwFlags,    //@parm Mouse message wparam
    int     ffOptions)  //@parm option flag
{
    const POINT pt = {x, y};
    CTxtSelection * psel;
    SELCHANGE selchg;
    HMENU hmenu = NULL;
    IOleObject * poo = NULL;
    COleObject * pobj = NULL;
    IUnknown * pUnk = NULL;
    IRichEditOleCallback * precall = NULL;

    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxRButtonUp");

    // make sure we have the focus
    if(!_fFocus)
        TxSetFocus();

    if(_fWantDrag)
    {
        _fDragged = FALSE;
        _fWantDrag = FALSE;
        TxKillTimer(RETID_DRAGDROP);
    }

    // Grab selection object
    psel = GetSel();
    psel->SetSelectionInfo(&selchg);

    //We need a pointer to the first object, if any, in the selection.
    if(_pobjmgr)
    {
        //If the point is in the selection we need to find out if there
        //are any objects in the selection.  If the point is not in a
        //selection but it is on an object, we need to select the object.
        if(psel->PointInSel(pt, NULL) || (ffOptions & RB_FORCEINSEL))
        {
            pobj = _pobjmgr->GetFirstObjectInRange(selchg.chrg.cpMin,
                selchg.chrg.cpMost);
        }
        else
        {
            //Select the object
            if(_pobjmgr->HandleClick(this, pt) == CLICK_OBJSELECTED)
            {
                pobj = _pobjmgr->GetSingleSelect();
                // Because HandleClick returned true, pobj better be non-null.
                Assert(pobj!=NULL);
                //Refresh our information about the selection
                psel = GetSel();
                psel->SetSelectionInfo(&selchg);
            }
        }
        precall = _pobjmgr->GetRECallback();
    }

    if(pobj)
        pUnk = pobj->GetIUnknown();

    if(pUnk)
        pUnk->QueryInterface(IID_IOleObject, (void **)&poo);

    if(precall)
        precall->GetContextMenu(selchg.seltyp, poo, &selchg.chrg, &hmenu);

    if(hmenu)
    {
        HWND hwnd, hwndParent;
        POINT ptscr;

        if(TxGetWindow(&hwnd) == NOERROR)
        {
            if(!(ffOptions & RB_NOSELCHECK) && !psel->PointInSel(pt, NULL) &&
                !psel->GetCch() && !(ffOptions & RB_FORCEINSEL))
                psel->SetCaret(pt);
            ptscr.x = pt.x;
            ptscr.y = pt.y;
            ClientToScreen(hwnd, &ptscr);

            hwndParent = GetParent(hwnd);
            if(!hwndParent)
                hwndParent = hwnd;

            TrackPopupMenu(hmenu, TPM_LEFTALIGN | TPM_RIGHTBUTTON,
                ptscr.x, ptscr.y, 0, hwndParent, NULL);
        }
        DestroyMenu(hmenu);
    }

    if(poo)
        poo->Release();

    return precall ? S_OK : S_FALSE;
}

HRESULT CTxtEdit::OnTxRButtonDown(
    INT     x,          //@parm Mouse x coordinate
    INT     y,          //@parm Mouse y coordinate
    DWORD   dwFlags)    //@parm Mouse message wparam
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxRButtonDown");

    if (StopMagellanScroll())
        return S_OK;

    CTxtSelection *psel = GetSel();
    const POINT pt = {x, y};

    psel->CancelModes();

    if(psel->PointInSel(pt, NULL) && !_fDisableDrag)
    {
        _fWantDrag = TRUE;

        TxSetTimer(RETID_DRAGDROP, W32->GetDragDelay());
        _mousePt = pt;
        _bMouseFlags = (BYTE)dwFlags;
        _fDragged = FALSE;
        return S_OK;
    }
    return S_FALSE;
}

HRESULT CTxtEdit::OnTxMouseMove(
    INT     x,          //@parm Mouse x coordinate
    INT     y,          //@parm Mouse y coordinate
    DWORD   dwFlags,    //@parm Mouse message wparam
    IUndoBuilder *publdr)
{
    int     dx, dy;
    BOOL    fLButtonDown = FALSE;
    BOOL    fRButtonDown = FALSE;
    DWORD   vkLButton, vkRButton;

    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxMouseMove");

    CTxtSelection * const psel = GetSel();

    if(!_fFocus)
        return S_OK;

    if(_fWantDrag || _fCapture)
    {
        LONG nDragMinDist = W32->GetDragMinDist() + 3;
        dx = _mousePt.x > x ? _mousePt.x - x : x - _mousePt.x;
        dy = _mousePt.y > y ? _mousePt.y - y : y - _mousePt.y;
        if(dx < nDragMinDist && dy < nDragMinDist)
        {
            _bMouseFlags = (BYTE)dwFlags;
            return S_OK;
        }
        _fDragged = _fWantDrag;
    }

    _mousePt.x = x;                                 // Remember for scrolling
    _mousePt.y = y;                                 //  speed, and dir calc.

    // RichEdit 1.0 allows the client to process mouse moves itself if
    // we are over a link (but _not_ doing drag drop).
    if(HandleLinkNotification(WM_MOUSEMOVE, 0, MAKELPARAM(x, y)))
        return NOERROR;

    // If we think the mouse is down and it really is then do special
    // processing.
    if(GetSystemMetrics(SM_SWAPBUTTON))
    {
        vkLButton = VK_RBUTTON;
        vkRButton = VK_LBUTTON;
    }
    else
    {
        vkLButton = VK_LBUTTON;
        vkRButton = VK_RBUTTON;
    }

    fLButtonDown = (GetAsyncKeyState(vkLButton) < 0);
    if(!fLButtonDown)
        fRButtonDown = (GetAsyncKeyState(vkRButton) < 0);

    if(fLButtonDown || fRButtonDown)
    {
        if(_fWantDrag
            && !_fUsePassword
            && !IsProtected(_fReadOnly ? WM_COPY : WM_CUT, dwFlags,
                    MAKELONG(x,y)))
        {
            TxKillTimer(RETID_DRAGDROP);
            _ldte.StartDrag(psel, publdr);
            // the mouse button may still be down, but drag drop is over
            // so we need to _think_ of it as up.
            _fMouseDown = FALSE;

            // similarly, OLE should have nuked the capture for us, but
            // just in case something failed, release the capture.
            TxSetCapture(FALSE);
            _fCapture = FALSE;
        }
        else if(_fMouseDown)
        {
            POINT   pt = _mousePt;

            // We think mouse is down and it is
            if(_ldte.fInDrag())
            {
                // Only do drag scrolling if a drag operation is in progress.
                _pdp->DragScroll(&pt);
            }

            AssertSz(psel,"CTxtEdit::OnMouseMove: No selection object !");
            psel->ExtendSelection(pt);              // Extend the selection

            CheckInstallContinuousScroll ();
        }
    }
    else if (!(GetAsyncKeyState(VK_MBUTTON) < 0) && !mouse.IsAutoScrolling())
    {
        // Make sure we aren't autoscrolling via intellimouse

        if(_fMButtonCapture)
            OnTxMButtonUp (x, y, dwFlags);

        if(_fMouseDown)
        {
            // Although we thought the mouse was down, at this moment it
            // clearly is not. Therefore, we pretend we got a mouse up
            // message and clear our state to get ourselves back in sync
            // with what is really happening.
            OnTxLButtonUp(x, y, dwFlags, LB_RELEASECAPTURE);
        }

    }

    // Either a drag was started or the mouse button was not down. In either
    // case, we want no longer to start a drag so we set the flag to false.
    _fWantDrag = FALSE;
    return S_OK;
}

/*
 *  OnTxMButtonDown (x, y, dwFlags)
 *
 *  @mfunc
 *      The user pressed the middle mouse button, setup to do
 *      continuous scrolls, which may in turn initiate a timer
 *      for smooth scrolling.
 *
 *  @rdesc
 *      HRESULT = S_OK
 */
HRESULT CTxtEdit::OnTxMButtonDown (
    INT     x,          //@parm Mouse x coordinate
    INT     y,          //@parm Mouse y coordinate
    DWORD   dwFlags)    //@parm Mouse message wparam
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxMButtonDown");

#if !defined(NOMAGELLAN)
    POINT   mDownPt = {x,y};

    if(!_fFocus)
        TxSetFocus();

    if(!StopMagellanScroll() && mouse.MagellanStartMButtonScroll(*this, mDownPt))
    {
        TxSetCapture(TRUE);

        _fCapture           = TRUE;                         // Capture the mouse
        _fMouseDown         = TRUE;
        _fMButtonCapture    = TRUE;
    }
#endif

    return S_OK;
}

/*
 *  CTxtEdit::OnTxMButtonUp (x, y, dwFlags)
 *
 *  @mfunc
 *      Remove timers and capture assoicated with a MButtonDown
 *      message.
 *
 *  @rdesc
 *      HRESULT = S_OK
 */
HRESULT CTxtEdit::OnTxMButtonUp (
    INT     x,          //@parm Mouse x coordinate
    INT     y,          //@parm Mouse y coordinate
    DWORD   dwFlags)    //@parm Mouse message wparam
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxMButtonUp");

#if !defined(NOMAGELLAN)
    if (mouse.ContinueMButtonScroll(x, y))
        return S_OK;

    StopMagellanScroll();

#else

    if(_fCapture)
        TxSetCapture(FALSE);

    _fCapture           = FALSE;
    _fMouseDown         = FALSE;
    _fMButtonCapture    = FALSE;

#endif

    return S_OK;
}


/*
 *  CTxtEdit::StopMagellanScroll()
 *
 *  @mfunc
 *      Stops the intellimouse autoscrolling and returns
 *      us back into a normal state
 *
 *  BOOL = TRUE if auto scrolling was turned off : FALSE
 *          Autoscrolling was never turned on
 */
 BOOL CTxtEdit::StopMagellanScroll ()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::StopMagellanScroll");

#if !defined(NOMAGELLAN)
    if (!mouse.IsAutoScrolling())
        return FALSE;

    mouse.MagellanEndMButtonScroll(*this);

    if(_fCapture)
        TxSetCapture(FALSE);

    _fCapture           = FALSE;
    _fMouseDown         = FALSE;
    _fMButtonCapture    = FALSE;
    return TRUE;
#else
    return FALSE;
#endif
}


/*
 *  CTxtEdit::CheckInstallContinuousScroll ()
 *
 *  @mfunc
 *      There are no events that inform the app on a regular
 *      basis that a mouse button is down. This timer notifies
 *      the app that the button is still down, so that scrolling can
 *      continue.
 */
void CTxtEdit::CheckInstallContinuousScroll ()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::CheckInstallContinuousScroll");

    if(!_fContinuousScroll && TxSetTimer(RETID_AUTOSCROLL, cmsecScrollInterval))
        _fContinuousScroll = TRUE;
}

/*
 *  CTxtEdit::CheckRemoveContinuousScroll ()
 *
 *  @mfunc
 *      The middle mouse button, or drag button, is up
 *      remove the continuous scroll timer.
 */
void CTxtEdit::CheckRemoveContinuousScroll ()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::CheckRemoveContinuousScroll");

    if(_fContinuousScroll)
    {
        TxKillTimer(RETID_AUTOSCROLL);
        _fContinuousScroll = FALSE;
    }
}

/*
 *  OnTxTimer(idTimer)
 *
 *  @mfunc
 *      Handle timers for doing background recalc and scrolling.
 *
 *  @rdesc
 *      HRESULT = (idTimer valid) ? S_OK : S_FALSE
 */
HRESULT CTxtEdit::OnTxTimer(
    UINT idTimer)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxTimer");

    switch (idTimer)
    {
        case RETID_BGND_RECALC:
            _pdp->StepBackgroundRecalc();
            break;

#if !defined(NOMAGELLAN)
        case RETID_MAGELLANTRACK:
            mouse.TrackUpdateMagellanMButtonDown(*this, _mousePt);
            break;
#endif
        case RETID_AUTOSCROLL:                      // Continuous scrolling.
            OnTxMouseMove(_mousePt.x, _mousePt.y,   // Do a select drag scroll.
                          0, NULL);
            break;

#if !defined(NOMAGELLAN)
        case RETID_SMOOTHSCROLL:                    // Smooth scrolling
            if(_fMButtonCapture)                    // HACK, only 1 timer!
            {                                       // delivered on Win95
                                                    // when things get busy.
                mouse.TrackUpdateMagellanMButtonDown(*this, _mousePt);
            }
            if(_pdp->IsSmoothVScolling())           // Test only because of
                _pdp->SmoothVScrollUpdate();        //  above HACK!!
        break;
#endif
        case RETID_DRAGDROP:
            TxKillTimer(RETID_DRAGDROP);
            if (_fWantDrag && _fDragged && !_fUsePassword &&
                !IsProtected(_fReadOnly ? WM_COPY : WM_CUT,
                             _bMouseFlags, MAKELONG(_mousePt.x,_mousePt.y)))
            {
                IUndoBuilder *  publdr;
                CGenUndoBuilder undobldr(this, UB_AUTOCOMMIT, &publdr);
                _ldte.StartDrag(GetSel(), publdr);
                _fWantDrag = FALSE;
                _fDragged = FALSE;
                TxSetCapture(FALSE);
                _fCapture = FALSE;
            }
            break;

        default:
            return S_FALSE;
    }
    return S_OK;
}


/////////////////////////// Keyboard Commands ////////////////////////////////

/*
 *  CTxtEdit::OnTxKeyDown(vkey, dwFlags, publdr)
 *
 *  @mfunc
 *      Handle WM_KEYDOWN message
 *
 *  @rdesc
 *      HRESULT with the following values:
 *
 *      S_OK                if key was understood and consumed
 *      S_MSG_KEY_IGNORED   if key was understood, but not consumed
 *      S_FALSE             if key was not understood or just looked at
 *                                  and in any event not consumed
 */
HRESULT CTxtEdit::OnTxKeyDown(
    WORD          vkey,     //@parm Virtual key code
    DWORD         dwFlags,  //@parm lparam of WM_KEYDOWN msg
    IUndoBuilder *publdr)   //@parm Undobuilder to receive antievents
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxKeyDown");

    if(IN_RANGE(VK_SHIFT, vkey, VK_MENU))
    {
        SetKeyboardFlag(GetKbdFlags(vkey, dwFlags));
        return S_FALSE;
    }

    BOOL  fAlt   = GetKeyboardFlag(ALT, VK_MENU);
    BOOL  fCtrl  = GetKeyboardFlag(CTRL, VK_CONTROL);
    BOOL  fShift = GetKeyboardFlag(SHIFT, VK_SHIFT);

    BOOL  fRet   = FALSE;           // Converted to HRESULT on return
    LONG  nDeadKey = 0;

    if(fCtrl & fShift)                      // Signal NonCtrl/Shift keydown
        SetKeyboardFlag(LETAFTERSHIFT);     //  while Ctrl&Shift are down

    // Handle Hebrew caps and LRM/RLM
    if (IsBiDi())
    {
        if (W32->IsBiDiCodePage(GetKeyboardCodePage(0xFFFFFFFF)))
        {
            _fHbrCaps = FALSE;
            if(IsRich() && W32->UsingHebrewKeyboard())
            {
                WORD wCapital = GetKeyState(VK_CAPITAL);
                _fHbrCaps = ((wCapital & 1) ^ fShift) &&
                            !(wCapital & 0x0080) &&
                            IN_RANGE('A', vkey, 'Z');
                if(_fHbrCaps)
                    W32->ActivateKeyboard(ANSI_INDEX);
            }
        }

        if(vkey == VK_BACK && fShift && W32->OnWin9x())
        {
            // Shift+Backspace generates a LRM | RLM on a BiDi keyboard.
            // Consequently, we must eat the Backspace lest it delete text.
            W32->_fLRMorRLM = 1;
            return S_OK;
        }
    }

    // If dragging or Alt key down, just look for ESCAPE. Note: if Alt key is
    // down, we should never come here (would generate WM_SYSKEYDOWN message).
    if(_fMouseDown)
    {
        if(vkey == VK_ESCAPE)
        {
            // Turn-off autoscroll.
            if (StopMagellanScroll())
                return S_OK;

            POINT pt;
            // Cancel drag select or drag & drop
            GetCursorPos(&pt);
            OnTxLButtonUp(pt.x, pt.y, 0, LB_RELEASECAPTURE | LB_FLUSHNOTIFY);
            return S_OK;
        }
        return OnTxSpecialKeyDown(vkey, dwFlags, publdr);
    }

    CTxtSelection * const psel = GetSel();
    AssertSz(psel,"CTxtEdit::OnKeyDown() - No selection object !");

    if(fCtrl)
    {
        if(OnTxSpecialKeyDown(vkey, dwFlags, publdr) == S_OK)
            return S_OK;

        if(fAlt)                        // This following code doesn't handle
            return S_FALSE;             //  use Ctrl+Alt, which happens for
                                        //  AltGr codes (no WM_SYSKEYDOWN)

        // Shift must not be pressed for these.
        if(!fShift)
        {
            switch(vkey)
            {
            case 'E':
            case 'J':
            case 'R':
            case 'L':
            {
                CParaFormat PF;
                if (vkey == 'E')
                    PF._bAlignment = PFA_CENTER;
                else if (vkey == 'J')
                    PF._bAlignment = PFA_FULL_INTERWORD;
                else if (vkey == 'R')
                    PF._bAlignment = PFA_RIGHT;
                else
                    PF._bAlignment = PFA_LEFT;

                psel->SetParaFormat(&PF, publdr, PFM_ALIGNMENT);
                break;
            }
            case '1':
            case '2':
            case '5':
            {
                CParaFormat PF;
                PF._bLineSpacingRule = tomLineSpaceMultiple;
                PF._dyLineSpacing = (vkey - '0') * 20;
                if (vkey == '5')
                    PF._dyLineSpacing = 30;

                psel->SetParaFormat(&PF, publdr, PFM_LINESPACING);
                break;
            }
            default:
                break;
            }
        }

        switch(vkey)
        {
        case VK_TAB:
            return OnTxChar(VK_TAB, dwFlags, publdr);

        case VK_CLEAR:
        case VK_NUMPAD5:
        case 'A':                       // Ctrl-A => pselect all
            psel->SelectAll();
            break;

        //Toggle Subscript
        case 187: // =
        {
            ITextFont *pfont;
            psel->GetFont(&pfont);
            if (pfont)
            {
                pfont->SetSubscript(tomToggle);
                pfont->Release();
            }
        }
        break;

        case 'C':                       // Ctrl-C => copy
CtrlC:      CutOrCopySelection(WM_COPY, 0, 0, NULL);
            break;

        case 'V':                       // Ctrl-V => paste
CtrlV:      if(IsntProtectedOrReadOnly(WM_PASTE, 0, 0))
            {
                PasteDataObjectToRange(NULL, (CTxtRange *)psel, 0, NULL,
                    publdr, PDOR_NONE);
            }
            break;

        case 'X':                       // Ctrl-X => cut
CtrlX:      CutOrCopySelection(WM_CUT, 0, 0, publdr);
            break;

        case 'Z':                       // Ctrl-Z => undo
            if (_pundo && !_fReadOnly && _fUseUndo)
                PopAndExecuteAntiEvent(_pundo, 0);
            break;

        case 'Y':                       // Ctrl-Y => redo
            if(_predo && !_fReadOnly && _fUseUndo)
                PopAndExecuteAntiEvent(_predo, 0);
            break;

#ifdef DEBUG
            void RicheditDebugCentral(void);
        case 191:
            RicheditDebugCentral();
            break;
#endif

#if defined(DOGFOOD)
        case '1':                       // Shift+Ctrl+1 => start Aimm
            // Activate AIMM by posting a message to RE (Shift+Ctrl+; for now)
            if (fShift && _fInOurHost)
            {
                HWND    hWnd;

                TxGetWindow( &hWnd );

                if (hWnd)
                    PostMessage(hWnd, EM_SETEDITSTYLE, SES_USEAIMM, SES_USEAIMM);
            }
            break;
#endif

        case VK_CONTROL:
            goto cont;

// English keyboard defines
#define VK_APOSTROPHE   0xDE
#define VK_GRAVE        0xC0
#define VK_SEMICOLON    0xBA
#define VK_COMMA        0xBC

        case VK_APOSTROPHE:
            if(fShift)
                g_wFlags ^= KF_SMARTQUOTES;
            else
                nDeadKey = ACCENT_ACUTE;
            break;

        case VK_GRAVE:
            nDeadKey = fShift ? ACCENT_TILDE : ACCENT_GRAVE;
            break;

        case VK_SEMICOLON:
            nDeadKey = ACCENT_UMLAUT;
            break;

        case '6':
            if(!fShift)
                goto cont;
            nDeadKey = ACCENT_CARET;
            break;

        case VK_COMMA:
            nDeadKey = ACCENT_CEDILLA;
            break;

        default:
            goto cont;
        }
        if(nDeadKey)
        {
            // Since deadkey choices vary a bit according to keyboard, we
            // only enable them for English. French, German, Italian, and
            // Spanish keyboards already have a fair amount of accent
            // capability.
            if(PRIMARYLANGID(GetKeyboardLayout(0)) == LANG_ENGLISH)
                SetDeadKey((WORD)nDeadKey);
            else goto cont;
        }
        return S_OK;
    }

cont:
    psel->SetExtend(fShift);

    switch(vkey)
    {
    case VK_BACK:
    case VK_F16:
        if(_fReadOnly)
        {
            Beep();
            fRet = TRUE;
        }
        else if(IsntProtectedOrReadOnly(WM_KEYDOWN, VK_BACK, dwFlags))
        {
            fRet = psel->Backspace(fCtrl, publdr);
        }
        break;

    case VK_INSERT:                             // Ins
        if(fShift)                              // Shift-Ins
            goto CtrlV;                         // Alias for Ctrl-V
        if(fCtrl)                               // Ctrl-Ins
            goto CtrlC;                         // Alias for Ctrl-C

        if(!_fReadOnly)                         // Ins
            _fOverstrike = !_fOverstrike;       // Toggle Ins/Ovr
        fRet = TRUE;
        break;

    case VK_LEFT:                               // Left arrow
    case VK_RIGHT:                              // Right arrow
        fRet = (vkey == VK_LEFT) ^ (psel->GetPF()->IsRtlPara() != 0)
             ? psel->Left (fCtrl)
             : psel->Right(fCtrl);
        break;

    case VK_UP:                                 // Up arrow
        fRet = psel->Up(fCtrl);
        break;

    case VK_DOWN:                               // Down arrow
        fRet = psel->Down(fCtrl);
        break;

    case VK_HOME:                               // Home
        fRet = psel->Home(fCtrl);
        break;

    case VK_END:                                // End
        fRet = psel->End(fCtrl);
        break;

    case VK_PRIOR:                              // PgUp
        // If SystemEditMode and control is single-line, do nothing
        if(!_fSystemEditMode || _pdp->IsMultiLine())
            fRet = psel->PageUp(fCtrl);
        break;

    case VK_NEXT:                               // PgDn
        // If SystemEditMode and control is single-line, do nothing
        if(!_fSystemEditMode || _pdp->IsMultiLine())
            fRet = psel->PageDown(fCtrl);
        break;

    case VK_DELETE:                             // Del
        if(fShift)                              // Shift-Del
            goto CtrlX;                         // Alias for Ctrl-X

        if(IsntProtectedOrReadOnly(WM_KEYDOWN, VK_DELETE, dwFlags))
            psel->Delete(fCtrl, publdr);
        fRet = TRUE;
        break;

    case CONTROL('J'):                          // Ctrl-Return gives Ctrl-J
    case VK_RETURN:                             //  (LF), treat it as return
        // If we are in 1.0 mode we need to handle <CR>'s on WM_CHAR
        if (!Get10Mode())
        {
            if(!_pdp->IsMultiLine())
            {
                Beep();
                return S_FALSE;
            }
            TxSetCursor(0, NULL);

            if(IsntProtectedOrReadOnly(WM_CHAR, VK_RETURN, dwFlags))
                psel->InsertEOP(publdr, (fShift && IsRich() ? VT : 0));

            fRet = TRUE;
        }
        break;

    default:
        return S_FALSE;
    }

    return fRet ? S_OK : S_MSG_KEY_IGNORED;
}

/*
 *  CTxtEdit::CutOrCopySelection(msg, wparam, lparam, publdr)
 *
 *  @mfunc
 *      Handle WM_COPY message and its keyboard hotkey aliases
 *
 *  @rdesc
 *      HRESULT
 */
HRESULT CTxtEdit::CutOrCopySelection(
    UINT   msg,             //@parm Message (WM_CUT or WM_COPY)
    WPARAM wparam,          //@parm Message wparam for protection check
    LPARAM lparam,          //@parm Message lparam for protection check
    IUndoBuilder *publdr)   //@parm Undobuilder to receive antievents
{
    Assert(msg == WM_CUT || msg == WM_COPY);

    if(!_fUsePassword && IsntProtectedOrReadOnly(msg, wparam, lparam))
    {
        CTxtSelection *psel = GetSel();
        psel->CheckTableSelection();
        return msg == WM_COPY
               ? _ldte.CopyRangeToClipboard((CTxtRange *)psel)
               : _ldte.CutRangeToClipboard((CTxtRange *)psel, publdr);
    }
    return NOERROR;
}

#define ENGLISH_UK	 MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_UK)
#define ENGLISH_EIRE MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_EIRE)

/*
 *  CTxtEdit::OnTxSpecialKeyDown(vkey, dwFlags, publdr)
 *
 *  @mfunc
 *      Handle WM_KEYDOWN message for outline mode
 *
 *  @rdesc
 *      HRESULT with the following values:
 *
 *      S_OK                if key was understood and consumed
 *      S_MSG_KEY_IGNORED   if key was understood, but not consumed
 *      S_FALSE             if key was not understood (and not consumed)
 */
HRESULT CTxtEdit::OnTxSpecialKeyDown(
    WORD          vkey,             //@parm Virtual key code
    DWORD         dwFlags,          //@parm lparam of WM_KEYDOWN msg
    IUndoBuilder *publdr)           //@parm Undobuilder to receive antievents
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxSpecialKeyDown");

    HRESULT hr = S_FALSE;                   // Key not understood yet
    DWORD   dwKbdFlags = GetKeyboardFlags();
    BOOL    fUpdateFormat = TRUE;

    if(!(dwKbdFlags & (CTRL | ALT)))        // All hot keys here have at
        return S_FALSE;                     //  least Ctrl or Alt

    CTxtSelection * const psel = GetSel();
    if(dwKbdFlags & ALT && dwKbdFlags & CTRL)
    {
        // AltGr generates LCTRL | RALT, so don't match hot keys with
        // that combination
        if(dwKbdFlags & LCTRL && dwKbdFlags & RALT)
            return S_FALSE;

//#if 0
        // First they say they want it, then they don't. Leave it ifdef'd out
        // for a bit in case they want it again
        if(vkey == 'E')
        {
			LANGID lid = LANGIDFROMLCID(GetKeyboardLayout(0));
			static const LANGID rgLangID[] =
			{
				ENGLISH_UK, ENGLISH_EIRE, LANG_POLISH, LANG_PORTUGUESE,
				LANG_HUNGARIAN, LANG_VIETNAMESE
			};
			for(LONG i = ARRAY_SIZE(rgLangID); i--; )
			{
				// Don't insert Euro if lid matches any LIDs or PLIDs in rgLangID
				if(lid == rgLangID[i] || PRIMARYLANGID(lid) == rgLangID[i])
					return S_FALSE;
			}
            if(psel->PutChar(EURO, _fOverstrike, publdr))
			{
				SetKeyboardFlag(HOTEURO);		// Setup flag to eat the next WM_CHAR w/ EURO
                hr = S_OK;
			}
        }
        else
//#endif
        if(dwKbdFlags & SHIFT)
            switch(vkey)
            {
#ifdef ENABLE_OUTLINEVIEW
            // FUTURE: OutlineView hot keys postponed (see below)
            case 'N':                       // Alt-Ctrl-N => Normal View
                hr = SetViewKind(VM_NORMAL);
                break;
            case 'O':                       // Alt-Ctrl-O => Outline View
                hr = SetViewKind(VM_OUTLINE);
                break;
#endif
            case VK_F12:                    // Alt-Ctrl-F12 (in case Alt-X taken)
                hr = psel->HexToUnicode(publdr);
                break;

    #if defined(DEBUG)
            case VK_F11:                    // Alt-Ctrl-F11
                if (W32->fDebugFont())
                    psel->DebugFont();
                break;
    #endif
            }
        return hr;
    }

    AssertSz(psel, "CTxtEdit::OnTxSpecialKeyDown() - No selection object !");
    CTxtRange rg(*psel);

    if(!IsRich() || !_pdp->IsMultiLine() || !(dwKbdFlags & SHIFT))
        return S_FALSE;

    if(dwKbdFlags & ALT)                            // Alt+Shift hot keys
    {
        // NB: Alt and Shift-Alt with _graphics_ characters generate a
        // WM_SYSCHAR, which see

#ifdef ENABLE_OUTLINEVIEW
        // FUTURE: These are Outline related hot keys.  We will postpone these features
        // since we have several bugs related to these hot keys
        // Bug 5687, 5689, & 5691
        switch(vkey)
        {
        case VK_LEFT:                               // Left arrow
        case VK_RIGHT:                              // Right arrow
            hr = rg.Promote(vkey == VK_LEFT ? 1 : -1, publdr);
            psel->Update_iFormat(-1);
            psel->Update(FALSE);
            break;

        case VK_UP:                                 // Up arrow
        case VK_DOWN:                               // Down arrow
            hr = MoveSelection(vkey == VK_UP ? -1 : 1, publdr);
            psel->Update(TRUE);
            break;
        }
#endif
        return hr;
    }

    Assert(dwKbdFlags & CTRL && dwKbdFlags & SHIFT);

    // Ctrl+Shift hot keys
    switch(vkey)
    {

#ifdef ENABLE_OUTLINEVIEW
    // FUTUTRE: These are Outline related hot keys.  We will postpone these features
    // since we have several bugs related to these hot keys
    // Bug 5687, 5689, & 5691
    case 'N':                       // Demote to Body
        hr = rg.Promote(0, publdr);
        break;
#endif

    //Toggle superscript
    case 187: // =
    {
        ITextFont *pfont;
        psel->GetFont(&pfont);
        if (pfont)
        {
            pfont->SetSuperscript(tomToggle);
            pfont->Release();
            hr = S_OK;
            fUpdateFormat = FALSE;
        }
        break;
    }

    case 'A':
    {
        ITextFont *pfont;
        psel->GetFont(&pfont);
        if (pfont)
        {
            pfont->SetAllCaps(tomToggle);
            pfont->Release();
            hr = S_OK;
            fUpdateFormat = FALSE;
        }
        break;
    }

    case 'L':                       // Fiddle bullet style
    {
        CParaFormat PF;
        DWORD dwMask = PFM_NUMBERING | PFM_OFFSET;

        PF._wNumbering = psel->GetPF()->_wNumbering + 1;
        PF._wNumbering %= tomListNumberAsUCRoman + 1;
        PF._dxOffset = 0;
        if(PF._wNumbering)
        {
            dwMask |= PFM_NUMBERINGSTYLE | PFM_NUMBERINGSTART;
            PF._wNumberingStyle = PFNS_PERIOD;
            PF._wNumberingStart = 1;
            PF._dxOffset = 360;
        }
        hr = psel->SetParaFormat(&PF, publdr, dwMask);
        break;
    }
#define VK_RANGLE   190
#define VK_LANGLE   188

    case VK_RANGLE:                 // '>' on US keyboards
    case VK_LANGLE:                 // '<' on US keyboards
        hr = OnSetFontSize(vkey == VK_RANGLE ? 1 : -1, publdr)
           ? S_OK : S_FALSE;
        fUpdateFormat = (hr == S_FALSE);
        break;
    }

    if(hr != S_FALSE)
    {
        if (fUpdateFormat)
            psel->Update_iFormat(-1);
        psel->Update(FALSE);
    }
    return hr;
}

/*
 *  CTxtEdit::OnTxChar (vkey, dwFlags, publdr)
 *
 *  @mfunc
 *      Handle WM_CHAR message
 *
 *  @rdesc
 *      HRESULT with the following values:
 *
 *      S_OK                if key was understood and consumed
 *      S_MSG_KEY_IGNORED   if key was understood, but not consumed
 *      S_FALSE             if key was not understood (and not consumed)
 */
HRESULT CTxtEdit::OnTxChar(
    WORD          vkey,     //@parm Translated key code
    DWORD         dwFlags,  //@parm lparam of WM_KEYDOWN msg
    IUndoBuilder *publdr)   //@parm Undobuilder to receive antievents
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxChar");

    // Reset Alt key state if needed
    if (!(HIWORD(dwFlags) & KF_ALTDOWN))
        ResetKeyboardFlag(ALT);

    DWORD dwFlagsPutChar = _fOverstrike | KBD_CHAR;
    if(GetKeyboardFlags() & ALTNUMPAD)
    {
        DWORD Number = GetKeyPadNumber();
        if(Number >= 256 || vkey >= 256)
            vkey = Number;
        ResetKeyboardFlag(ALTNUMPAD | ALT0);
        dwFlagsPutChar &= ~KBD_CHAR;        // Need font binding
    }

    if (_fMouseDown || vkey == VK_ESCAPE || // Ctrl-Backspace generates VK_F16
        vkey == VK_BACK || vkey==VK_F16)    // Eat it since we process it
    {                                       //  in WM_KEYDOWN
        return S_OK;
    }

    CTxtSelection * const psel = GetSel();
    AssertSz(psel,
        "CTxtEdit::OnChar() - No selection object !");
    psel->SetExtend(FALSE);                 // Shift doesn't mean extend for
                                            //  WM_CHAR
    if(_fReadOnly && vkey != 3)             // Don't allow input if read only,
    {                                       //  but allow copy (Ctrl-C)
        if(vkey >= ' ')
            Beep();
        return S_MSG_KEY_IGNORED;
    }

    if(vkey >= ' ' || vkey == VK_TAB)
    {
        TxSetCursor(0, NULL);
        if(IsntProtectedOrReadOnly(WM_CHAR, vkey, dwFlags))
        {
            LONG nDeadKey = GetDeadKey();
            if(nDeadKey)
            {
                LONG ch       = vkey | 0x20;        // Convert to lower case
                BOOL fShift   = vkey != ch;         //  (if ASCII letter)
                //                             a   b    c   d    e   f  g  h    i   j
                const static WORD chOff[] = {0xDF, 0, 0xE7, 0, 0xE7, 0, 0, 0, 0xEB, 0,
                //                      k  l  m    n     o   p  q  r  s  t    u
                                        0, 0, 0, 0xF1, 0xF1, 0, 0, 0, 0, 0, 0xF8};
                SetDeadKey(0);
                if(!IN_RANGE('a', ch, 'u'))         // Not relevant ASCII
                    return S_OK;                    //  letter

                vkey = chOff[ch - 'a'];             // Translate to base char
                if(!vkey)                           // No accents available
                    return S_OK;                    //  in current approach

                if(ch == 'n')
                {
                    if(nDeadKey != ACCENT_TILDE)
                        return S_OK;
                }
                else if(nDeadKey == ACCENT_CEDILLA)
                {
                    if(ch != 'c')
                        return S_OK;
                }
                else                                // aeiou
                {
                    vkey += (WORD)nDeadKey;
                    if (nDeadKey >= ACCENT_TILDE && // eiu with ~ or :
                        (vkey == 0xF0 || vkey & 8))
                    {
                        if(nDeadKey != ACCENT_UMLAUT)// Only have umlauts
                            return S_OK;
                        vkey--;
                    }
                }
                if(fShift)
                    vkey &= ~0x20;
            }

            // need to check if character is LRM | RLM character, if so
            // then convert vkey
            if (W32->_fLRMorRLM && IsBiDi() && IN_RANGE(0xFD, vkey, 0xFE))
            {
                vkey = LTRMARK + (vkey - 0xFD);
            }

            psel->PutChar((TCHAR)vkey, dwFlagsPutChar, publdr);
        }
    }
    else if (Get10Mode() && (vkey == VK_RETURN || vkey == CONTROL('J')))
    {
        // 1.0 handled <CR> on WM_CHAR

        // Just make sure we are entering text into a multiline control
        DWORD dwStyle;
        GetHost()->TxGetPropertyBits(TXTBIT_MULTILINE, &dwStyle);
        if(dwStyle & TXTBIT_MULTILINE)
        {
            TxSetCursor(0, NULL);
            if(IsntProtectedOrReadOnly(WM_CHAR, VK_RETURN, dwFlags))
                psel->InsertEOP(publdr);
        }
    }

    if(_fHbrCaps)
    {
         W32->ActivateKeyboard(HEBREW_INDEX);
         _fHbrCaps = FALSE;
    }
    return S_OK;
}

/*
 *  CTxtEdit::OnTxSysChar (vkey, dwFlags, publdr)
 *
 *  @mfunc
 *      Handle WM_SYSCHAR message
 *
 *  @rdesc
 *      HRESULT with the following values:
 *
 *      S_OK                if key was understood and consumed
 *      S_MSG_KEY_IGNORED   if key was understood, but not consumed
 *      S_FALSE             if key was not understood (and not consumed)
 */
HRESULT CTxtEdit::OnTxSysChar(
    WORD          vkey,     //@parm Translated key code
    DWORD         dwFlags,  //@parm lparam of WM_KEYDOWN msg
    IUndoBuilder *publdr)   //@parm Undobuilder to receive antievents
{
    if(!(HIWORD(dwFlags) & KF_ALTDOWN))
        return S_FALSE;

    BOOL    fWholeDoc = TRUE;
    HRESULT hr = S_FALSE;
    int     level = 0;
    CTxtSelection * const psel = GetSel();

    switch(vkey)
    {
    case VK_BACK:
        return S_OK;

    case 'x':
        hr = psel->HexToUnicode(publdr);
        break;

    case 'X':
        hr = psel->UnicodeToHex(publdr);
        break;

    case '+':
    case '-':
        level = vkey == VK_ADD ? 1 : -1;
        fWholeDoc = FALSE;
        /* Fall through */
    case 'A':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
        {
            CTxtRange rg(*psel);
            if(!level)
                level = vkey == 'A' ? 9 : vkey - '0';
            return rg.ExpandOutline(level, fWholeDoc);
        }
    }
    return hr;
}

HRESULT CTxtEdit::OnTxSysKeyDown(
    WORD          vkey,             //@parm Virtual key code
    DWORD         dwFlags,          //@parm lparam of WM_KEYDOWN msg
    IUndoBuilder *publdr)           //@parm Undobuilder to receive antievents
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxSysKeyDown");


    if(IN_RANGE(VK_SHIFT, vkey, VK_MENU))
    {
        SetKeyboardFlag(GetKbdFlags(vkey, dwFlags));
        SetKeyPadNumber(0);             // Init keypad number to 0
        return S_FALSE;
    }

    if (StopMagellanScroll())
        return S_FALSE;

    HRESULT hr = OnTxSpecialKeyDown(vkey, dwFlags, publdr);
    if(hr != S_FALSE)
        return hr;

    if(vkey == VK_BACK && (HIWORD(dwFlags) & KF_ALTDOWN))
    {
        if(_pundo && _pundo->CanUndo() && _fUseUndo)
        {
            if(PopAndExecuteAntiEvent(_pundo, 0) != NOERROR)
                hr = S_MSG_KEY_IGNORED;
        }
        else
            Beep();
    }
    else if(vkey == VK_F10 &&                   // F10
            !(HIWORD(dwFlags) & KF_REPEAT) &&   // Key previously up
            (GetKeyboardFlags() & SHIFT))       // Shift is down
    {
        HandleKbdContextMenu();
    }

    return hr;
}

/////////////////////////////// Other system events //////////////////////////////

HRESULT CTxtEdit::OnContextMenu(LPARAM lparam)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnContextMenu");

    POINT pt;

    pt.x = LOWORD(lparam);
    pt.y = HIWORD(lparam);

    if(TxScreenToClient(&pt))
        return OnTxRButtonUp(pt.x, pt.y, 0, RB_NOSELCHECK);

    return S_FALSE;
}

/*
 *  CTxtEdit::HandleKbdContextMenu ()
 *
 *  @mfunc  decides where to put the context menu on the basis of where the
 *          the selection is.  Useful for shift-F10 and VK_APPS, where
 *          we aren't given a location.
 */
void CTxtEdit::HandleKbdContextMenu()
{
    POINT   pt;
    RECT    rc;
    const CTxtSelection * const psel = GetSel();
    int RbOption = RB_DEFAULT;

    // Figure out where selection ends and put context menu near it
    if(_pdp->PointFromTp(*psel, NULL, FALSE, pt, NULL, TA_TOP) < 0)
        return;

    // Due to various factors, the result of PointFromTp doesn't land
    // in the selection in PointInSel. Therefore, we send in an override
    // here if the selection is non-degenerate and to force the result
    // and thus have the correct context menu appear.

    LONG cpMin;
    LONG cpMost;
    psel->GetRange(cpMin, cpMost);

    if (cpMin != cpMost)
    {
        RbOption = RB_FORCEINSEL;
    }

    // Make sure point is still within bounds of edit control
    _pdp->GetViewRect(rc);

    if (pt.x < rc.left)
        pt.x = rc.left;
    if (pt.x > rc.right - 2)
        pt.x = rc.right - 2;
    if (pt.y < rc.top)
        pt.y = rc.top;
    if (pt.y > rc.bottom - 2)
        pt.y = rc.bottom - 2;

    OnTxRButtonUp(pt.x, pt.y, 0, RbOption);
}


/////////////////////////////// Format Range Commands //////////////////////////////

/*
 *  CTxtEdit::OnFormatRange (pfr, prtcon, hdcMeasure,
 *                           xMeasurePerInch, yMeasurePerInch)
 *  @mfunc
 *      Format the range given by pfr
 *
 *  @comm
 *      This function inputs API cp's that may differ from the
 *      corresponding internal Unicode cp's.
 */
LRESULT CTxtEdit::OnFormatRange(
    FORMATRANGE * pfr,
    SPrintControl prtcon,
    BOOL          fSetupDC)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnFormatRange");

    LONG cpMin  = 0;
    LONG cpMost = 0;

    if(pfr)
    {
        cpMin  = GetCpFromAcp(pfr->chrg.cpMin);
        cpMost = GetCpFromAcp(pfr->chrg.cpMost);
    }
    // Even if there is 0 text, we want to print the control so that it will
    // fill the control with background color.
    // Use Adjusted Text Length.  Embedded objects using RichEdit will get the empty
    // document they expect and will create a default size document.
    if(!pfr || cpMin >= GetAdjustedTextLength() &&
        !prtcon._fPrintFromDraw)
    {   // We're done formatting, get rid of our printer's display context.
        delete _pdpPrinter;
        _pdpPrinter = NULL;

        return GetAcpFromCp(GetAdjustedTextLength());
    }

    LONG cpReturn = -1;
    BOOL fSetDCWorked = FALSE;


    // Fix MFC Print preview in mirrored control
    //
    // MFC CPreviewView sends us a mirrored rendering DC. We need to disable
    // this mirroring effect so our internal state remains consistent with user
    // action. We also need to disable mirrored window mode in CPreviewView
    // window. [wchao - 4/9/1999]
    //

    HDC  hdcLocal = pfr->hdc;
    DWORD dwLayout = GetLayout(hdcLocal);

    if (dwLayout & LAYOUT_RTL)
    {
        HWND hwndView = WindowFromDC(hdcLocal);

        if (hwndView)
        {
            DWORD   dwExStyleView = GetWindowLong(hwndView, GWL_EXSTYLE);

            if (dwExStyleView & WS_EX_LAYOUTRTL)
                SetWindowLong(hwndView, GWL_EXSTYLE, dwExStyleView & ~WS_EX_LAYOUTRTL);
        }

        SetLayout(hdcLocal, 0);
    }

    // First time in with this printer, set up a new display context.
    // IMPORTANT: proper completion of the printing process is required
    // to dispose of this context and begin a new context.
    // This is implicitly done by printing the last character, or
    // sending an EM_FORMATRANGE message with pfr equal to NULL.
    if(!_pdpPrinter)
    {
        _pdpPrinter = new CDisplayPrinter (this, hdcLocal,
                pfr->rc.right  - pfr->rc.left,  // x width  max
                pfr->rc.bottom - pfr->rc.top,   // y height max
                prtcon);

        _pdpPrinter->Init();

        _pdpPrinter->SetWordWrap(TRUE);
        // Future: (ricksa) This is a really yucky way to pass the draw info
        // to the printer but it was quick. We want to make this better.
        _pdpPrinter->ResetDrawInfo(_pdp);

        // Set temporary zoom factor (if there is one).
        _pdpPrinter->SetTempZoomDenominator(_pdp->GetTempZoomDenominator());
    }
    else
        _pdpPrinter->SetPrintDimensions(&pfr->rc);

	LONG dxpInch = 0, dypInch = 0;
    // We set the DC everytime because it could have changed.
    if(GetDeviceCaps(hdcLocal, TECHNOLOGY) != DT_METAFILE)
    {
        // This is not a metafile so do the normal thing
        fSetDCWorked = _pdpPrinter->SetDC(hdcLocal);
    }
    else
    {
        //Forms^3 draws using screen resolution, while OLE specifies HIMETRIC
        dxpInch = fInOurHost() ? 2540 : W32->GetXPerInchScreenDC();
        dypInch = fInOurHost() ? 2540 : W32->GetYPerInchScreenDC();

        if (!fSetupDC)
        {
            RECT rc;
            rc.left = MulDiv(pfr->rcPage.left, dxpInch, LX_PER_INCH);
            rc.right = MulDiv(pfr->rcPage.right, dxpInch, LX_PER_INCH);
            rc.top = MulDiv(pfr->rcPage.top, dypInch, LY_PER_INCH);
            rc.bottom = MulDiv(pfr->rcPage.bottom, dypInch, LY_PER_INCH);

            SetWindowOrgEx(hdcLocal, rc.left, rc.top, NULL);
            SetWindowExtEx(hdcLocal, rc.right, rc.bottom, NULL);
        }

        _pdpPrinter->SetMetafileDC(hdcLocal, dxpInch, dypInch);
        fSetDCWorked = TRUE;
    }

    if(fSetDCWorked)
    {
		//It is illogical to have the target device be the screen and the presentation
		//device be a HIMETRIC metafile.
		LONG dxpInchT = -1, dypInchT = -1;
		if (dxpInch && GetDeviceCaps(pfr->hdcTarget, TECHNOLOGY) == DT_RASDISPLAY)
		{
			dxpInchT = dxpInch;
			dypInchT = dypInch;
		}

        // We set this every time because it could have changed.
        if(_pdpPrinter->SetTargetDC(pfr->hdcTarget, dxpInchT, dypInchT))
        {

            // Format another, single page worth of text.
            cpReturn = _pdpPrinter->FormatRange(cpMin, cpMost, prtcon._fDoPrint);
            if(!prtcon._fPrintFromDraw)
            {
                // After formatting, we know where the bottom is. But we only
                // want to set this if we are writing a page rather than
                // displaying a control on the printer.
                pfr->rc.bottom = INT (pfr->rc.top + _pdpPrinter->DYtoLY(_pdpPrinter->GetHeight()));
            }

            // Remember this in case the host wishes to do its own banding.
            _pdpPrinter->SetPrintView(pfr->rc); // we need to save this for OnDisplayBand.
            _pdpPrinter->SetPrintPage(pfr->rcPage);

            // If we're asked to render, then render the entire page in one go.
            if(prtcon._fDoPrint && (cpReturn > 0 || prtcon._fPrintFromDraw))
            {
                OnDisplayBand(&pfr->rc, prtcon._fPrintFromDraw);

                // Note: we can no longer call OnDisplayBand without reformating.
                _pdpPrinter->Clear(AF_DELETEMEM);
            }
        }
    }

    return cpReturn > 0 ? GetAcpFromCp(cpReturn) : cpReturn;
}

BOOL CTxtEdit::OnDisplayBand(
    const RECT *prc,
    BOOL        fPrintFromDraw)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnDisplayBand");

    HDC     hdcPrinter;
    RECT    rc, rcPrint;

    // Make sure OnFormatRange was called and that it actually rendered something.
    if(!_pdpPrinter || !_pdpPrinter->Count())
        return FALSE;

    // Review (murrays): shouldn't the following use LRtoDR()? I.e.,
    // _pdpPrinter->LRtoDR(rc, *prc);
    // Proportionally map to printers extents.
    rc.left     = (INT) _pdpPrinter->LXtoDX(prc->left);
    rc.right    = (INT) _pdpPrinter->LXtoDX(prc->right);
    rc.top      = (INT) _pdpPrinter->LYtoDY(prc->top);
    rc.bottom   = (INT) _pdpPrinter->LYtoDY(prc->bottom);

    rcPrint         = _pdpPrinter->GetPrintView();
    rcPrint.left    = (INT) _pdpPrinter->LXtoDX(rcPrint.left);
    rcPrint.right   = (INT) _pdpPrinter->LXtoDX(rcPrint.right);
    rcPrint.top     = (INT) _pdpPrinter->LYtoDY(rcPrint.top);
    rcPrint.bottom  = (INT) _pdpPrinter->LYtoDY(rcPrint.bottom);

    // Get printer DC because we use it below.
    hdcPrinter = _pdpPrinter->GetDC();

    if(fPrintFromDraw)
    {
        // We need to take view inset into account
        _pdpPrinter->GetViewRect(rcPrint, &rcPrint);
    }

    // Render this band (if there's something to render)
    if(rc.top < rc.bottom)
        _pdpPrinter->Render(rcPrint, rc);

    return TRUE;
}

//////////////////////////////// Protected ranges //////////////////////////////////
/*
 *  CTxtEdit::IsProtected (msg, wparam, lparam)
 *
 *  @mfunc
 *      Find out if selection is protected
 *
 *  @rdesc
 *      TRUE iff 1) control is read-only or 2) selection is protected and
 *      parent query says to protect
 */
BOOL CTxtEdit::IsProtected(
    UINT    msg,        //@parm Message id
    WPARAM  wparam,     //@parm WPARAM from window's message
    LPARAM  lparam)     //@parm LPARAM from window's message
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::IsProtected");

    LONG iDirection = 0;
    CTxtSelection *psel = GetSel();

    if(!psel)
        return FALSE;

    // There are a few special cases to consider, namely backspacing
    // into a protected range, deleting into a protected range, and type
    // with overstrike into a protected range.
    if(msg == WM_KEYDOWN && (wparam == VK_BACK || wparam == VK_F16))
    {
        // Check for format behind selection, if we are trying to
        // backspace an insertion point.
        iDirection = -1;
    }
    else if(msg == WM_KEYDOWN && wparam == VK_DELETE ||
        _fOverstrike && msg == WM_CHAR)
    {
        iDirection = 1;
    }

    // HACK ALERT: we don't do fIsDBCS protection checking for EM_REPLACESEL,
    // EM_SETCHARFORMAT, or EM_SETPARAFORMAT.  Outlook uses these APIs
    // extensively and DBCS protection checking messes them up. N.B. the
    // following if statement assumes that IsProtected returns a tri-value.
    int iProt = psel->IsProtected(iDirection);
    if (iProt == CTxtRange::PROTECTED_YES && msg != EM_REPLACESEL &&
        msg != EM_SETCHARFORMAT && msg != EM_SETPARAFORMAT ||
        iProt == CTxtRange::PROTECTED_ASK && _dwEventMask & ENM_PROTECTED &&
        QueryUseProtection(psel, msg, wparam, lparam))
    {
        return TRUE;
    }
    return FALSE;
}

/*
 *  CTxtEdit::IsntProtectedOrReadOnly (msg, wparam, lparam)
 *
 *  @mfunc
 *      Find out if selection isn't protected or read only. If it is,
 *      ring bell.  For msg = WM_COPY, only protection is checked.
 *
 *  @rdesc
 *      TRUE iff 1) control isn't read-only and 2) selection either isn't
 *      protected or parent query says not to protect
 *
 *  @devnote    This function is useful for UI operations (like typing).
 */
BOOL CTxtEdit::IsntProtectedOrReadOnly(
    UINT   msg,     //@parm Message
    WPARAM wparam,  //@parm Corresponding wparam
    LPARAM lparam)  //@parm Corresponding lparam
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::IsProtectedOrReadOnly");

    if (!IsProtected(msg, wparam, lparam) &&
        (msg == WM_COPY || !_fReadOnly))    // WM_COPY only cares about
    {                                       //  protection
        return TRUE;
    }
    Beep();
    return FALSE;
}

/*
 *  CTxtEdit::IsProtectedRange (msg, wparam, lparam, prg)
 *
 *  @mfunc
 *      Find out if range prg is protected
 *
 *  @rdesc
 *      TRUE iff control is read-only or range is protected and parent
 *      query says to protect
 */
BOOL CTxtEdit::IsProtectedRange(
    UINT        msg,        //@parm Message id
    WPARAM      wparam,     //@parm WPARAM from window's message
    LPARAM      lparam,     //@parm LPARAM from window's message
    CTxtRange * prg)        //@parm Range to examine
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::IsProtectedRange");

    int iProt = prg->IsProtected(0);

    if (iProt == CTxtRange::PROTECTED_YES ||
        (iProt == CTxtRange::PROTECTED_ASK &&
         (_dwEventMask & ENM_PROTECTED) &&
         QueryUseProtection(prg, msg, wparam, lparam)))
    // N.B.  the preceding if statement assumes that IsProtected returns a tri-value
    {
        return TRUE;
    }
    return FALSE;
}

/*
 *  RegisterTypeLibrary
 *
 *  @mfunc
 *      Auxiliary function to ensure the type library is registered if Idispatch is used.
 */
void RegisterTypeLibrary( void )
{
    HRESULT  hRes = NOERROR;
    WCHAR    szModulePath[MAX_PATH];
    ITypeLib *pTypeLib = NULL;

    // Obtain the path to this module's executable file
    W32->GetModuleFileName( hinstRE, szModulePath, MAX_PATH );

    // Load and register the type library resource
    if (LoadRegTypeLib(LIBID_tom, 1, 0, LANG_NEUTRAL, &pTypeLib) != NOERROR)
    {
        hRes = W32->LoadTypeLibEx(szModulePath, REGKIND_REGISTER, &pTypeLib);
    }

    if(SUCCEEDED(hRes) && pTypeLib)
    {
        pTypeLib->Release();
    }
}

/////////////////////////////// Private IUnknown //////////////////////////////

HRESULT __stdcall CTxtEdit::CUnknown::QueryInterface(
    REFIID riid,
    void **ppvObj)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::CUnknown::QueryInterface");

    CTxtEdit *ped = (CTxtEdit *)GETPPARENT(this, CTxtEdit, _unk);
    *ppvObj = NULL;

    if(IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ITextServices))
        *ppvObj = (ITextServices *)ped;

    else if(IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IDispatch *)ped;
        RegisterTypeLibrary();
    }

    else if(IsEqualIID(riid, IID_ITextDocument))
    {
        *ppvObj = (ITextDocument *)ped;
        RegisterTypeLibrary();
    }

    else if(IsEqualIID(riid, IID_ITextDocument2))
        *ppvObj = (ITextDocument2 *)ped;

    else if(IsEqualIID(riid, IID_IRichEditOle))
        *ppvObj = (IRichEditOle *)ped;

    else if(IsEqualIID(riid, IID_IRichEditOleCallback))
    {
        // NB!! Returning this pointer in our QI is
        // phenomenally bogus; it breaks fundamental COM
        // identity rules (granted, not many understand them!).
        // Anyway, RichEdit 1.0 did this, so we better.
        TRACEWARNSZ("Returning IRichEditOleCallback interface, COM "
            "identity rules broken!");

        *ppvObj = ped->GetRECallback();
    }

    if(*ppvObj)
    {
        ((IUnknown *) *ppvObj)->AddRef();
        return S_OK;
    }
    return E_NOINTERFACE;
}

ULONG __stdcall CTxtEdit::CUnknown::AddRef()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::CUnknown::AddRef");

    return ++_cRefs;
}

ULONG __stdcall CTxtEdit::CUnknown::Release()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::CUnknown::Release");

    // the call manager will take care of deleting our instance if appropriate.
    CTxtEdit *ped = GETPPARENT(this, CTxtEdit, _unk);
    CCallMgr callmgr(ped);

    ULONG culRefs = --_cRefs;

    if(culRefs == 0)
    {
        // Even though we don't delete ourselves now, dump the callback
        // if we have it.  This make implementation a bit easier on clients.

        if(ped->_pobjmgr)
            ped->_pobjmgr->SetRECallback(NULL);

        // Make sure our timers are gone
        ped->TxKillTimer(RETID_AUTOSCROLL);
        ped->TxKillTimer(RETID_DRAGDROP);
        ped->TxKillTimer(RETID_BGND_RECALC);
        ped->TxKillTimer(RETID_SMOOTHSCROLL);
        ped->TxKillTimer(RETID_MAGELLANTRACK);
    }
    return culRefs;
}

/*
 *  ValidateTextRange(pstrg)
 *
 *  @func
 *    Makes sure that an input text range structure makes sense.
 *
 *  @rdesc
 *    Size of the buffer required to accept copy of data or -1 if all the
 *    data in the control is requested.
 *
 *  @comm
 *    This is used both in this file and in the RichEditANSIWndProc
 */
LONG ValidateTextRange(
    TEXTRANGE *pstrg)       //@parm pointer to a text range structure
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "ValidateTextRange");

    // Validate that the input structure makes sense. In the first
    // place it must be big enough. Secondly, the values must sense.
    // Remember that if the cpMost field is -1 and the cpMin field
    // is 0 this means that the call wants the entire buffer.
    if (IsBadReadPtr(pstrg, sizeof(TEXTRANGE))  ||
        ((pstrg->chrg.cpMost < 1 || pstrg->chrg.cpMin < 0 ||
          pstrg->chrg.cpMost <= pstrg->chrg.cpMin) &&
         !(pstrg->chrg.cpMost == -1 && !pstrg->chrg.cpMin)))
    {
        // This isn't valid so tell the caller we didn't copy any data
        return 0;
    }
    // Calculate size of buffer that we need on return
    return pstrg->chrg.cpMost - pstrg->chrg.cpMin;
}


////////////////////////////////////  Selection  /////////////////////////////////////

CTxtSelection * CTxtEdit::GetSel()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetSel");

    if(!_psel)
    {
        // There is no selection object available so create it.
        _psel = new CTxtSelection(_pdp);
        if(_psel)
            _psel->AddRef();                    // Set reference count = 1
    }

    // It is caller's responsiblity to notice that an error occurred
    // in allocation of selection object.
    return _psel;
}

void CTxtEdit::DiscardSelection()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::DiscardSelection");

    if(_psel)
    {
        _psel->Release();
        if(_psel)
        {
            // The text services reference is not the last reference to the
            // selection. We could keep track of the fact that text services
            // has released its reference and when text services gets a
            // reference again, do the AddRef there so that if the last
            // reference went away while we were still inactive, the selection
            // object would go away. However, it is seriously doubtful that
            // such a case will be very common. Therefore, just do the simplest
            // thing and put our reference back.
            _psel->AddRef();
        }
    }
}

void CTxtEdit::GetSelRangeForRender(
    LONG *pcpSelMin,
    LONG *pcpSelMost)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetSelRangeForRender");

    // If we have no selection or we are not active and the selection
    // has been requested to be hidden, there is no selection so we
    // just return 0's.
    if(!_psel || (!_fInPlaceActive && _fHideSelection))
    {
        *pcpSelMin = 0;
        *pcpSelMost = 0;
        return;
    }

    // Otherwise return the state of the current selection.
    *pcpSelMin  = _psel->GetScrSelMin();
    *pcpSelMost = _psel->GetScrSelMost();
}

LRESULT CTxtEdit::OnGetSelText(
    TCHAR *psz)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnGetSelText");

    LONG cpMin  = GetSelMin();                  // length + 1 for the null
    LONG cpMost = GetSelMost();
    return GetTextRange(cpMin, cpMost - cpMin + 1, psz);
}

/*
 *  CTxtEdit::OnExGetSel (pcrSel)
 *
 *  @mfunc
 *      Get the current selection acpMin, acpMost packaged in a CHARRANGE.
 *
 *  @comm
 *      This function outputs API cp's that may differ from the
 *      corresponding internal Unicode cp's.
 */
void CTxtEdit::OnExGetSel(
    CHARRANGE *pcrSel)  //@parm Output parm to receive acpMin, acpMost
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnExGetSel");

    pcrSel->cpMin  = GetAcpFromCp(GetSelMin());
    pcrSel->cpMost = GetAcpFromCp(GetSelMost());
}

/*
 *  CTxtEdit::OnGetSel (pacpMin, pacpMost)
 *
 *  @mfunc
 *      Get the current selection acpMin, acpMost.
 *
 *  @rdesc
 *      LRESULT = acpMost > 65535L ? -1 : MAKELRESULT(acpMin, acpMost)
 *
 *  @comm
 *      This function outputs API cp's that may differ from the
 *      corresponding internal Unicode cp's.
 */
LRESULT CTxtEdit::OnGetSel(
    LONG *pacpMin,      //@parm Output parm to receive acpMin
    LONG *pacpMost)     //@parm Output parm to receive acpMost
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnGetSel");

    CHARRANGE crSel;

    OnExGetSel(&crSel);
    if(pacpMin)
        *pacpMin = crSel.cpMin;
    if(pacpMost)
        *pacpMost = crSel.cpMost;

    return (crSel.cpMost > 65535l)  ? (LRESULT) -1
                : MAKELRESULT((WORD) crSel.cpMin, (WORD) crSel.cpMost);
}

/*
 *  CTxtEdit::OnSetSel (acpMin, acpMost)
 *
 *  @mfunc
 *      Implements the EM_SETSEL message
 *
 *  Algorithm:
 *      There are three basic cases to handle
 *
 *      cpMin < 0,  cpMost ???      -- Collapse selection to insertion point
 *                                     at text end if cpMost < 0 and else at
 *                                     selection active end
 *      cpMin >= 0, cpMost < 0      -- select from cpMin to text end with
 *                                     active end at text end
 *
 *      cpMin >= 0, cpMost >= 0     -- Treat as cpMin, cpMost with active
 *                                     end at cpMost
 *
 *  @comm
 *      This function inputs API cp's that may differ from the
 *      corresponding internal Unicode cp's.
 */
LRESULT CTxtEdit::OnSetSel(
    LONG acpMin,        //@parm Input acpMin
    LONG acpMost)       //@parm Input acpMost
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnSetSel");

    // Since this is only called from the window proc, we are always active
    Assert(GetSel());

    CTxtSelection * const psel = GetSel();
    LONG cpMin, cpMost;

    if(acpMin < 0)
        cpMin = cpMost = (acpMost < 0) ? tomForward : psel->GetCp();
    else
    {
        cpMin  = GetCpFromAcp(acpMin);
        cpMost = (acpMost < 0) ? tomForward : GetCpFromAcp(acpMost);
    }
    if(Get10Mode() && cpMost < cpMin)   // In 10 mode, ensure
    {                                   //  cpMost >= cpMin.  In
        cpMin ^= cpMost;                //  SetSelection, we set active
        cpMost ^= cpMin;                //  end to cpMost, which can be
        cpMin ^= cpMost;                //  smaller than cpMin, in spite
    }                                   //  of its name.
    psel->SetSelection(cpMin, cpMost);
    return psel->GetCpMost();
}

///////////////////////////////  DROP FILES support  //////////////////////////////////////
#ifndef NODROPFILES

LRESULT CTxtEdit::InsertFromFile (
    LPCTSTR lpFile)
{
    REOBJECT        reobj;
    LPRICHEDITOLECALLBACK const precall = GetRECallback();
    HRESULT         hr = NOERROR;

    if(!precall)
        return E_NOINTERFACE;

    ZeroMemory(&reobj, sizeof(REOBJECT));
    reobj.cbStruct = sizeof(REOBJECT);

    // Get storage for the object from client
    hr = precall->GetNewStorage(&reobj.pstg);
    if(hr)
    {
        TRACEERRORSZ("GetNewStorage() failed.");
        goto err;
    }

    // Create an object site for new object
    hr = GetClientSite(&reobj.polesite);
    if(!reobj.polesite)
    {
        TRACEERRORSZ("GetClientSite() failed.");
        goto err;
    }

    hr = OleCreateLinkToFile(lpFile, IID_IOleObject, OLERENDER_DRAW,
                NULL, NULL, reobj.pstg, (LPVOID*)&reobj.poleobj);
    if(hr)
    {
        TRACEERRORSZ("Failure creating link object.");
        goto err;
    }

    reobj.cp = REO_CP_SELECTION;
    reobj.dvaspect = DVASPECT_CONTENT;

    //Get object clsid
    hr = reobj.poleobj->GetUserClassID(&reobj.clsid);
    if(hr)
    {
        TRACEERRORSZ("GetUserClassID() failed.");
        goto err;
    }

    // Let client know what we're up to
    hr = precall->QueryInsertObject(&reobj.clsid, reobj.pstg,
            REO_CP_SELECTION);
    if(hr != NOERROR)
    {
        TRACEERRORSZ("QueryInsertObject() failed.");
        goto err;
    }

    hr = reobj.poleobj->SetClientSite(reobj.polesite);
    if(hr)
    {
        TRACEERRORSZ("SetClientSite() failed.");
        goto err;
    }

    if(hr = InsertObject(&reobj))
    {
        TRACEERRORSZ("InsertObject() failed.");
    }

err:
    if(reobj.poleobj)
        reobj.poleobj->Release();

    if(reobj.polesite)
        reobj.polesite->Release();

    if(reobj.pstg)
        reobj.pstg->Release();

    return hr;
}

typedef void (WINAPI*DRAGFINISH)(HDROP);
typedef UINT (WINAPI*DRAGQUERYFILEA)(HDROP, UINT, LPSTR, UINT);
typedef UINT (WINAPI*DRAGQUERYFILEW)(HDROP, UINT, LPTSTR, UINT);
typedef BOOL (WINAPI*DRAGQUERYPOINT)(HDROP, LPPOINT);

LRESULT CTxtEdit::OnDropFiles(
    HANDLE hDropFiles)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnDropFiles");

    UINT    cFiles;
    UINT    iFile;
    char    szFile[MAX_PATH];
    WCHAR   wFile[MAX_PATH];
    POINT   ptDrop;
    CTxtSelection * const psel = GetSel();
    HMODULE     hDLL = NULL;
    DRAGFINISH      fnDragFinish;
    DRAGQUERYFILEA  fnDragQueryFileA;
    DRAGQUERYFILEW  fnDragQueryFileW;
    DRAGQUERYPOINT  fnDragQueryPoint;

    if (_fReadOnly)
        return 0;

    AssertSz((hDropFiles != NULL), "CTxtEdit::OnDropFiles invalid hDropFiles");

    // dynamic load Shell32

    hDLL = LoadLibrary (TEXT("Shell32.DLL"));
    if(hDLL)
    {
        fnDragFinish = (DRAGFINISH)GetProcAddress (hDLL, "DragFinish");
        fnDragQueryFileA = (DRAGQUERYFILEA)GetProcAddress (hDLL, "DragQueryFileA");
        fnDragQueryFileW = (DRAGQUERYFILEW)GetProcAddress (hDLL, "DragQueryFileW");
        fnDragQueryPoint = (DRAGQUERYPOINT)GetProcAddress (hDLL, "DragQueryPoint");
    }
    else
        return 0;

    if(!fnDragFinish || !fnDragQueryFileA || !fnDragQueryFileW || !fnDragQueryPoint)
    {
        AssertSz(FALSE, "Shell32 GetProcAddress failed");
        goto EXIT0;
    }

    (*fnDragQueryPoint) ((HDROP)hDropFiles, &ptDrop);
    if(W32->OnWin9x())
        cFiles = (*fnDragQueryFileA) ((HDROP)hDropFiles, (UINT)-1, NULL, 0);
    else
        cFiles = (*fnDragQueryFileW) ((HDROP)hDropFiles, (UINT)-1, NULL, 0);

    if(cFiles)
    {
        LONG        cp = 0;
        POINT       ptl = ptDrop;
        CRchTxtPtr  rtp(this);
        const CCharFormat   *pCF;

        if(_pdp->CpFromPoint(ptl, NULL, &rtp, NULL, FALSE) >= 0)
        {
            cp = rtp.GetCp();
            pCF = rtp.GetCF();
        }
        else
        {
            LONG iCF = psel->Get_iCF();
            cp = psel->GetCp();
            pCF = GetCharFormat(iCF);
            ReleaseFormats(iCF, -1);
        }

        // Notify user for dropfile
        if(_dwEventMask & ENM_DROPFILES)
        {
            ENDROPFILES endropfiles;

            endropfiles.hDrop = hDropFiles;
            endropfiles.cp = Get10Mode() ? GetAcpFromCp(cp) : cp;
            endropfiles.fProtected = !!(pCF->_dwEffects & CFE_PROTECTED);

            if(TxNotify(EN_DROPFILES, &endropfiles))
                goto EXIT;                  // Ignore drop file

            cp = Get10Mode() ? GetCpFromAcp(endropfiles.cp) : endropfiles.cp;   // Allow callback to update cp
        }
        psel->SetCp(cp);
    }

    for (iFile = 0;  iFile < cFiles; iFile++)
    {
        if(W32->OnWin9x())
        {
            (*fnDragQueryFileA) ((HDROP)hDropFiles, iFile, szFile, MAX_PATH);
            MultiByteToWideChar(CP_ACP, 0, szFile, -1,
                            wFile, MAX_PATH);
        }
        else
            (*fnDragQueryFileW) ((HDROP)hDropFiles, iFile, wFile, MAX_PATH);

        InsertFromFile (wFile);
    }

EXIT:
    (*fnDragFinish) ((HDROP)hDropFiles);

EXIT0:
    FreeLibrary (hDLL);
    return 0;
}

#else // NODROPFILES

LRESULT CTxtEdit::OnDropFiles(HANDLE hDropFiles)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnDropFiles");

    return 0;
}

#endif  // NODROPFILES


///////////////////////////////  Exposable methods  //////////////////////////////////////

/*
 *  CTxtEdit::TxCharFromPos (ppt, plres)
 *
 *  @mfunc
 *      Get the acp at the point *ppt.
 *
 *  @rdesc
 *      HRESULT = !fInplaceActive() ? OLE_E_INVALIDRECTS_OK :
 *                (CpFromPoint succeeded) ? S_OK : E_FAIL
 *  @comm
 *      This function outputs an API cp that may differ from the
 *      corresponding internal Unicode cp.
 */
HRESULT CTxtEdit::TxCharFromPos(
    LPPOINT  ppt,   //@parm Point to find the acp for
    LRESULT *plres) //@parm Output parm to receive the acp
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxCharFromPos");

    if(!fInplaceActive())
    {
        // We have no valid display rectangle if this object is not active
        *plres = -1;
        return OLE_E_INVALIDRECT;
    }
    *plres = _pdp->CpFromPoint(*ppt, NULL, NULL, NULL, FALSE);
    if(*plres == -1)
        return E_FAIL;

    *plres = GetAcpFromCp(*plres);
    return S_OK;
}

/*
 *  CTxtEdit::TxPosFromChar (acp, ppt)
 *
 *  @mfunc
 *      Get the point at acp.
 *
 *  @rdesc
 *      HRESULT = !fInplaceActive() ? OLE_E_INVALIDRECTS_OK :
 *                (PointFromTp succeeded) ? S_OK : E_FAIL
 *  @comm
 *      This function inputs an API cp that may differ from the
 *      corresponding internal Unicode cp.
 */
HRESULT CTxtEdit::TxPosFromChar(
    LONG    acp,        //@parm Input cp to get the point for
    POINT * ppt)        //@parm Output parm to receive the point
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxPosFromChar");

    if(!fInplaceActive())
        return OLE_E_INVALIDRECT;

    CRchTxtPtr rtp(this, GetCpFromAcp(acp));

    if(_pdp->PointFromTp(rtp, NULL, FALSE, *ppt, NULL, TA_TOP) < 0)
        return E_FAIL;

    return S_OK;
}

/*
 *  CTxtEdit::TxFindWordBreak (nFunction, acp, plres)
 *
 *  @mfunc
 *      Find word break or classify character at acp.
 *
 *  @rdesc
 *      HRESULT = plRet ? S_OK : E_INVALIDARG
 *
 *  @comm
 *      This function inputs and exports API cp's and cch's that may differ
 *      from the internal Unicode cp's and cch's.
 */
HRESULT CTxtEdit::TxFindWordBreak(
    INT      nFunction, //@parm Word break function
    LONG     acp,       //@parm Input cp
    LRESULT *plres)     //@parm cch moved to reach break
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxFindWordBreak");

    CTxtPtr tp(this, GetCpFromAcp(acp));        // This validates cp
    LONG    cpSave = tp.GetCp();                // Save starting value

    if(!plres)
        return E_INVALIDARG;

    *plres = tp.FindWordBreak(nFunction);

    // WB_CLASSIFY and WB_ISDELIMITER return values; others return offsets
    // this function returns values, so it converts when necessary
    if(nFunction != WB_CLASSIFY && nFunction != WB_ISDELIMITER)
        *plres = GetAcpFromCp(LONG(*plres + cpSave));

    return S_OK;
}

/*
 *  INT CTxtEdit::TxWordBreakProc (pch, ich, cb, action)
 *
 *  @func
 *      Default word break proc used in conjunction with FindWordBreak. ich
 *      is character offset (start position) in the buffer pch, which is cb
 *      bytes in length.  Possible action values are:
 *
 *  WB_CLASSIFY
 *      Returns char class and word break flags of char at start position.
 *
 *  WB_ISDELIMITER
 *      Returns TRUE iff char at start position is a delimeter.
 *
 *  WB_LEFT
 *      Finds nearest word beginning before start position using word breaks.
 *
 *  WB_LEFTBREAK
 *      Finds nearest word end before start position using word breaks.
 *      Used by CMeasurer::Measure()
 *
 *  WB_MOVEWORDLEFT
 *      Finds nearest word beginning before start position using class
 *      differences. This value is used during CTRL+LEFT key processing.
 *
 *  WB_MOVEWORDRIGHT
 *      Finds nearest word beginning after start position using class
 *      differences. This value is used during CTRL+RIGHT key processing.
 *
 *  WB_RIGHT
 *      Finds nearest word beginning after start position using word breaks.
 *      Used by CMeasurer::Measure()
 *
 *  WB_RIGHTBREAK
 *      Finds nearest word end after start position using word breaks.
 *
 *  @rdesc
 *      Character offset from start of buffer (pch) of the word break
 */
INT CTxtEdit::TxWordBreakProc(
    TCHAR * pch,        //@parm Char buffer
    INT     ich,        //@parm Char offset of _cp in buffer
    INT     cb,         //@parm Count of bytes in buffer
    INT     action,     //@parm Type of breaking action
    LONG    cpStart,    //@parm cp for first character in pch
    LONG    cp)         //@parm cp associated to ich
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxWordBreakProc");

    if (_pfnWB)
    {
        // Client overrode the wordbreak proc, delegate the call to it.
        if (!Get10Mode())
        {
            Assert(!_fExWordBreakProc);
            return _pfnWB(pch, ich, cb, action);
        }
        else
        {
            int ret = 0;
            char sz[256];
            char* pach = sz;
            if (cb >= 255)
                pach = new char [cb + 1];

            // this indicates if we have to adjust the pach because the api's for
            // EDITWORDBREAKPROCEX and EDITWORDBREAKPROC are different when looking to the left
            BOOL fAdjustPtr = _fExWordBreakProc && (action == WB_LEFT || action == WB_MOVEWORDLEFT || action == WB_LEFTBREAK);

            // RichEdit 1.0, create a buffer, translate ich and WCTMB
            // pch into the buffer.  Need codepage to use. Then get translate
            // return value. Translations are like GetCachFromCch() and
            // GetCchFromCach()
            if (_fExWordBreakProc)
            {
                Assert(ich == 0 || ich == 1 || ich == CchOfCb(cb));

                // We need to adjust the cp to the starting point of the buffer
                if (!fAdjustPtr)
                {
                    cpStart += ich;
                    pch += ich;
                    cb -= (2 * ich);
                }

                // initialize string w/ zero's so we can determine the length of the string for later
                memset(pach, 0, cb + 1);
            }

            int nLen = CchOfCb(cb);
            CRchTxtPtr rtp(this, cpStart);
            BYTE bCharSet = rtp.GetCF()->_bCharSet;
            if (WideCharToMultiByte(GetCodePage(bCharSet), 0, pch, nLen, pach, cb + 1, NULL, NULL))
            {
                // Documentation stipulates we need to point to the end of the string
                if (fAdjustPtr)
                    pach += strlen(pach);

                if (_fExWordBreakProc)
                    ret = ((EDITWORDBREAKPROCEX)_pfnWB)(pach, nLen, bCharSet, action);
                else
                {
                    ret = ((EDITWORDBREAKPROCA)_pfnWB)(pach, rtp.GetCachFromCch(ich), nLen, action);

                    // need to reset cp position because GetCachFromCch potentially moves the cp
                    if (ich)
                        rtp.SetCp(cpStart);
                }

                // For WB_ISDELIMITER and WB_CLASSIFY don't need to convert back
                // to ich because return value represents a BOOL
                if (action != WB_ISDELIMITER && action != WB_CLASSIFY)
                    ret = rtp.GetCchFromCach(ret);
            }

            // Delete any allocated memory
            if (pach != sz)
                delete [] pach;
            return ret;
        }
    }

    LONG    cchBuff = CchOfCb(cb);
    LONG    cch = cchBuff - ich;
    TCHAR   ch;
    WORD    cType3[MAX_CLASSIFY_CHARS];
    INT     kinsokuClassifications[MAX_CLASSIFY_CHARS];
    WORD *  pcType3;
    INT  *  pKinsoku1, *pKinsoku2;
    WORD *  pwRes;
    WORD    startType3 = 0;
    WORD    wb = 0;
    WORD    wClassifyData[MAX_CLASSIFY_CHARS];  // For batch classifying

    Assert(cchBuff < MAX_CLASSIFY_CHARS);
    Assert(ich >= 0 && ich < cchBuff);


    // Single character actions
    if ( action == WB_CLASSIFY )
    {
        // 1.0 COMPATABILITY - 1.0 returned 0 for apostrohpe's
        TCHAR ch = pch[ich];
        if (Get10Mode() && ( ch ==  0x0027 /*APOSTRPHE*/ ||
            ch == 0xFF07 /*FULLWIDTH APOSTROPHE*/))
        {
            return 0;
        }
        return ClassifyChar(ch);
    }

    if ( action == WB_ISDELIMITER )
        return !!(ClassifyChar(pch[ich]) & WBF_BREAKLINE);

    // Batch classify buffer for whitespace and kinsoku classes
    BatchClassify(pch, cchBuff, cType3, kinsokuClassifications, wClassifyData);

    if (_pbrk && cp > -1)
    {
		cp -= ich;

        for (LONG cbrk = cchBuff-1; cbrk >= 0; --cbrk)
        {
            if (cp + cbrk >= 0 && _pbrk->CanBreakCp(BRK_WORD, cp + cbrk))
            {
                // Mimic class open/close in Kinsoku classification.
                kinsokuClassifications[cbrk] = brkclsOpen;
                if (cbrk > 0)
				{
                    kinsokuClassifications[cbrk-1] = brkclsClose;
                    wClassifyData[cbrk-1] |= WBF_WORDBREAKAFTER;
				}
            }
        }
    }

    // Setup pointers
    pKinsoku2 = kinsokuClassifications + ich;       // Ptr to current  kinsoku
    pKinsoku1 = pKinsoku2 - 1;                      // Ptr to previous kinsoku

    if(!(action & 1))                               // WB_(MOVE)LEFTxxx
    {
        ich--;
        Assert(ich >= 0);
    }
    pwRes    = &wClassifyData[ich];
    pcType3  = &cType3[ich];                        // for ideographics

    switch(action)
    {
    case WB_LEFT:
        for(; ich >= 0 && *pwRes & WBF_BREAKLINE;   // Skip preceding line
            ich--, pwRes--)                         //  break chars
                ;                                   // Empty loop. Then fall
                                                    //  thru to WB_LEFTBREAK
    case WB_LEFTBREAK:
        for(; ich >= 0 && !CanBreak(*pKinsoku1, *pKinsoku2);
            ich--, pwRes--, pKinsoku1--, pKinsoku2--)
                ;                                   // Empty loop
        if(action == WB_LEFTBREAK)                  // Skip preceding line
        {                                           //  break chars
            for(; ich >= 0 && *pwRes & WBF_BREAKLINE;
                ich--, pwRes--)
                    ;                               // Empty loop
        }
        return ich + 1;

    case WB_MOVEWORDLEFT:
        for(; ich >= 0 && (*pwRes & WBF_CLASS) == 2;// Skip preceding blank
            ich--, pwRes--, pcType3--)              //  chars
                ;
        if(ich >= 0)                                // Save starting wRes and
        {                                           //  startType3
            wb = *pwRes--;                          // Really type1
            startType3 = *pcType3--;                // type3
            ich--;
        }
        // Skip to beginning of current word
        while(ich >= 0 && (*pwRes & WBF_CLASS) != 3 &&
            !(*pwRes & WBF_WORDBREAKAFTER) &&
            (IsSameClass(*pwRes, wb, *pcType3, startType3) ||
            !wb && ich && ((ch = pch[ich]) == '\'' || ch == RQUOTE)))
        {
            ich--, pwRes--, pcType3--;
        }
        return ich + 1;


    case WB_RIGHTBREAK:
        for(; cch > 0 && *pwRes & WBF_BREAKLINE;    // Skip any leading line
            cch--, pwRes++)                         //  break chars
                ;                                   // Empty loop
                                                    // Fall thru to WB_RIGHT
    case WB_RIGHT:
        // Skip to end of current word
        for(; cch > 0 && !CanBreak(*pKinsoku1, *pKinsoku2);
            cch--, pKinsoku1++, pKinsoku2++, pwRes++)
                ;
        if(action != WB_RIGHTBREAK)                 // Skip trailing line
        {                                           //  break chars
            for(; cch > 0 && *pwRes & WBF_BREAKLINE;
                cch--, pwRes++)
                    ;
        }
        return cchBuff - cch;

    case WB_MOVEWORDRIGHT:
        if(cch <= 0)                                // Nothing to do
            return ich;

        wb = *pwRes;                                // Save start wRes
        startType3 = *pcType3;                      //  and startType3

        // Skip to end of word
        if (startType3 & C3_IDEOGRAPH ||            // If ideographic or
            (*pwRes & WBF_CLASS) == 3)              //  tab/cell, just
        {
            cch--, pwRes++;                         //  skip one char
        }
        else while(cch > 0 &&
            !(*pwRes & WBF_WORDBREAKAFTER) &&
            (IsSameClass(*pwRes, wb, *pcType3, startType3) || !wb &&
             ((ch = pch[cchBuff - cch]) == '\'' || ch == RQUOTE)))
        {
            cch--, pwRes++, pcType3++;
        }

        for(; cch > 0 &&
            ((*pwRes & WBF_CLASS) == 2              // Skip trailing blank
            || (*pwRes & WBF_WORDBREAKAFTER)); 		// Skip Thai break after
            cch--, pwRes++)                         //  chars
                    ;
        return cchBuff - cch;
    }

    TRACEERRSZSC("CTxtEdit::TxWordBreakProc: unknown action", action);
    return ich;
}


/*
 *  CTxtEdit::TxFindText (flags, cpMin, cpMost, pch, pcpRet)
 *
 *  @mfunc
 *      Find text in direction specified by flags starting at cpMin if
 *      forward search (flags & FR_DOWN nonzero) and cpMost if backward
 *      search.
 *
 *  @rdesc
 *      HRESULT (success) ? NOERROR : S_FALSE
 *
 *  @comm
 *      Caller is responsible for setting cpMin to the appropriate end of
 *      the selection depending on which way the search is proceding.
 */
HRESULT CTxtEdit::TxFindText(
    DWORD       flags,   //@parm Specify FR_DOWN, FR_MATCHCASE, FR_WHOLEWORD
    LONG        cpStart, //@parm Find start cp
    LONG        cpLimit, //@parm Find limit cp
    const WCHAR*pch,     //@parm Null terminated string to search for
    LONG *      pcpMin,  //@parm Out parm to receive start of matched string
    LONG *      pcpMost) //@parm Out parm to receive end of matched string
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxFindText");

    if(Get10Mode())                         // RichEdit 1.0 only searches
    {
        flags |= FR_DOWN;                   //  forward
        if (cpLimit < -1)
            cpLimit = -1;
    }

    DWORD       cchText = GetTextLength();
    LONG        cchToFind;
    const BOOL  fSetCur = (cchText >= 4096);
    HCURSOR     hcur = NULL;                // Init to keep compiler happy

    Assert(pcpMin && pcpMost);

    // Validate parameters
    if(!pch || !(cchToFind = wcslen(pch)) || cpStart < 0 || cpLimit < -1)
        return E_INVALIDARG;                // Nothing to search for

    CTxtPtr tp(this, cpStart);

    if(fSetCur)                             // In case this takes a while...
        hcur = TxSetCursor(LoadCursor(0, IDC_WAIT), NULL);

    *pcpMin  = tp.FindText(cpLimit, flags, pch, cchToFind);
    *pcpMost = tp.GetCp();

    if(fSetCur)
        TxSetCursor(hcur, NULL);

    return *pcpMin >= 0 ? NOERROR : S_FALSE;;
}

/*
 *  CTxtEdit::TxGetLineCount (plres)
 *
 *  @mfunc
 *      Get the line count.
 *
 *  @rdesc
 *      HRESULT = !fInplaceActive() ? OLE_E_INVALIDRECTS_OK :
 *                (WaitForRecalc succeeded) ? S_OK : E_FAIL
 */
HRESULT CTxtEdit::TxGetLineCount(
    LRESULT *plres)     //@parm Output parm to receive line count
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetLineCount");

    AssertSz(plres, "CTxtEdit::TxGetLineCount invalid pcli");

    if(!fInplaceActive())
        return OLE_E_INVALIDRECT;

    if(!_pdp->WaitForRecalc(GetTextLength(), -1))
        return E_FAIL;

    *plres = _pdp->LineCount();
    Assert(*plres > 0);

    return S_OK;
}

/*
 *  CTxtEdit::TxLineFromCp (acp, plres)
 *
 *  @mfunc
 *      Get the line containing acp.
 *
 *  @rdesc
 *      HRESULT = !fInplaceActive() ? OLE_E_INVALIDRECTS_OK :
 *                (LineFromCp succeeded) ? S_OK : E_FAIL
 *  @comm
 *      This function inputs an API cp that may differ from the
 *      corresponding internal Unicode cp.
 */
HRESULT CTxtEdit::TxLineFromCp(
    LONG     acp,       //@parm Input cp
    LRESULT *plres)     //@parm Ouput parm to receive line number
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxLineFromCp");

    BOOL    fAtEnd = FALSE;
    LONG    cp = 0;

    AssertSz(plres, "CTxtEdit::TxLineFromCp invalid plres");

    if(!fInplaceActive())
    {
        AssertSz(*plres == 0,
            "CTxtEdit::TxLineFromCp error return lres not correct");
        return OLE_E_INVALIDRECT;
    }

    if(acp < 0)                                 // Validate cp
    {
        if(_psel)
        {
            cp = _psel->GetCpMin();
            fAtEnd = !_psel->GetCch() && _psel->CaretNotAtBOL();
        }
    }
    else
    {
        LONG cchText = GetTextLength();
        cp = GetCpFromAcp(acp);
        cp = min(cp, cchText);
    }

    *plres = _pdp->LineFromCp(cp, fAtEnd);

    HRESULT hr = *plres < 0 ? E_FAIL : S_OK;

    // Old messages expect 0 as a result of this call if there is an error.
    if(*plres == -1)
        *plres = 0;

    return hr;
}

/*
 *  CTxtEdit::TxLineLength (acp, plres)
 *
 *  @mfunc
 *      Get the line containing acp.
 *
 *  @rdesc
 *      HRESULT = !fInplaceActive() ? OLE_E_INVALIDRECTS_OK :
 *                (GetSel() succeeded) ? S_OK : E_FAIL
 *  @comm
 *      This function inputs an API cp and outputs an API cch that
 *      may differ from the corresponding internal Unicode cp and cch.
 */
HRESULT CTxtEdit::TxLineLength(
    LONG     acp,       //@parm Input cp
    LRESULT *plres)     //@parm Output parm to receive line length
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxLineLength");

    LONG cch = 0;
    LONG cp;

    AssertSz(plres,
            "CTxtEdit::TxLineLength Invalid plres parameter");

    if(!fInplaceActive())
        return OLE_E_INVALIDRECT;

    if(acp < 0)
    {
        if(!_psel)
            return E_FAIL;
        cch = _psel->LineLength(&cp);
    }
    else
    {
        cp = GetCpFromAcp(acp);
        if(cp <= GetAdjustedTextLength())
        {
            CLinePtr rp(_pdp);
            rp.RpSetCp(cp, FALSE);
            cp -= rp.GetIch();              // Goto start of line
            cch = rp.GetAdjustedLineLength();
        }
    }
    if(fCpMap())                            // Can be time consuming, so
    {                                       //  don't do it unless asked
        CRchTxtPtr rtp(this, cp);           //  for
        cch = rtp.GetCachFromCch(cch);
    }
    *plres = cch;
    return S_OK;
}

/*
 *  CTxtEdit::TxLineIndex (acp, plres)
 *
 *  @mfunc
 *      Get the line containing acp.
 *
 *  @rdesc
 *      HRESULT = !fInplaceActive() ? OLE_E_INVALIDRECTS_OK :
 *                (LineCount() && WaitForRecalcIli succeeded) ? S_OK : E_FAIL
 *  @comm
 *      This function outputs an API cp that may differ from the
 *      corresponding internal Unicode cp.
 */
HRESULT CTxtEdit::TxLineIndex(
    LONG     ili,       //@parm Line # to find acp for
    LRESULT *plres)     //@parm Output parm to receive acp
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxLineIndex");

    HRESULT hr;
    AssertSz(plres, "CTxtEdit::TxLineIndex invalid plres");

    *plres = -1;
    if(!fInplaceActive())
        return OLE_E_INVALIDRECT;

    if(ili == -1)
    {
        // Fetch line from the current cp.
        LRESULT lres;                   // For 64-bit compatibility
        hr = TxLineFromCp(-1, &lres);
        if(hr != NOERROR)
            return hr;
        ili = (LONG)lres;
    }

    // ili is a zero-based *index*, whereas count returns the total # of lines.
    // Therefore, we use >= for our comparisions.
    if(ili >= _pdp->LineCount() && !_pdp->WaitForRecalcIli(ili))
        return E_FAIL;

    *plres = GetAcpFromCp(_pdp->CpFromLine(ili, NULL));

    return S_OK;
}

///////////////////////////////////  Miscellaneous messages  ////////////////////////////////////

/*
 *  CTxtEdit::OnFindText (msg, flags, pftex)
 *
 *  @mfunc
 *      Find text.
 *
 *  @rdesc
 *      LRESULT = succeeded ? acpmin : -1
 *
 *  @comm
 *      This function inputs and exports API cp's that may differ
 *      from the internal Unicode cp's.
 */
LRESULT CTxtEdit::OnFindText(
    UINT        msg,
    DWORD       flags,
    FINDTEXTEX *pftex)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnFindText");

    LONG cpMin, cpMost;

    if(TxFindText(flags,
                  GetCpFromAcp(pftex->chrg.cpMin),
                  GetCpFromAcp(pftex->chrg.cpMost),
                  pftex->lpstrText, &cpMin, &cpMost) != S_OK)
    {
        if(msg == EM_FINDTEXTEX || msg == EM_FINDTEXTEXW)
        {
            pftex->chrgText.cpMin  = -1;
            pftex->chrgText.cpMost = -1;
        }
        return -1;
    }

    LONG acpMin  = GetAcpFromCp(cpMin);
    if(msg == EM_FINDTEXTEX || msg == EM_FINDTEXTEXW)   // We send a message
    {                                                   //  back to change
        pftex->chrgText.cpMin  = acpMin;                //  selection to this
        pftex->chrgText.cpMost = GetAcpFromCp(cpMost);
    }
    return (LRESULT)acpMin;
}

LRESULT CTxtEdit::OnGetWordBreakProc()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnGetWordBreakProc");

    return (LRESULT) _pfnWB;
}

// For plain-text instances, OnGetCharFormat(), OnGetParaFormat(),
// OnSetCharFormat(), and OnSetParaFormat() apply to whole story

LRESULT CTxtEdit::OnGetCharFormat(
    CHARFORMAT2 *pCF2,
    DWORD        dwFlags)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnGetCharFormat");

    UINT cb = pCF2->cbSize;
    UINT CodePage = 1200;

    if(!IsValidCharFormatW(pCF2))
    {
        if(!IsValidCharFormatA((CHARFORMATA *)pCF2))
            return 0;
        CodePage = GetDefaultCodePage(EM_GETCHARFORMAT);
    }

    if(cb == sizeof(CHARFORMATW) || cb == sizeof(CHARFORMATA))
        dwFlags |= CFM2_CHARFORMAT;             // Tell callees that only
                                                //  CHARFORMAT parms needed
    CCharFormat CF;
    DWORD dwMask = CFM_ALL2;

    if(dwFlags & SCF_SELECTION)
        dwMask = GetSel()->GetCharFormat(&CF, dwFlags);
    else
        CF = *GetCharFormat(-1);

    if(dwFlags & CFM2_CHARFORMAT)               // Maintain CHARFORMAT
    {                                           //  compatibility
        CF._dwEffects &= CFM_EFFECTS;
        dwMask        &= CFM_ALL;
    }

    CF.Get(pCF2, CodePage);
    pCF2->dwMask = dwMask;
    return (LRESULT)dwMask;
}

LRESULT CTxtEdit::OnGetParaFormat(
    PARAFORMAT2 *pPF2,
    DWORD        dwFlags)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnGetParaFormat");

    if(!IsValidParaFormat(pPF2))
        return 0;

    if(pPF2->cbSize == sizeof(PARAFORMAT))  // Tell callees that only
        dwFlags |= PFM_PARAFORMAT;          //  PARAFORMAT parms needed

    CParaFormat PF;
    DWORD       dwMask = GetSel()->GetParaFormat(&PF, dwFlags);

    if(dwFlags & PFM_PARAFORMAT)
        dwMask &= PFM_ALL;

    PF.Get(pPF2);
    pPF2->dwMask = dwMask;
    return (LRESULT)dwMask;
}

/*
 *  CTxtEdit::OnSetFontSize(yPoint, publdr)
 *
 *  @mfunc
 *      Set new font height by adding yPoint to current height
 *      and rounding according to the table in cfpf.cpp
 *
 *  @rdesc
 *      LRESULT nonzero if success
 */
LRESULT CTxtEdit::OnSetFontSize(
    LONG yPoint,
    IUndoBuilder *publdr)   //@parm Undobuilder to receive antievents
{
    // TODO: ? Return nonzero if we set a new font size for some text.

    CCharFormat CF;
    CF._yHeight = (SHORT)yPoint;

    return OnSetCharFormat(SCF_SELECTION, &CF, publdr, CFM_SIZE,
                           CFM2_CHARFORMAT | CFM2_USABLEFONT);
}

/*
 *  CTxtEdit::OnSetFont(hfont)
 *
 *  @mfunc
 *      Set new default font from hfont
 *
 *  @rdesc
 *      LRESULT nonzero if success
 */
LRESULT CTxtEdit::OnSetFont(
    HFONT hfont)            //@parm Handle of font to use for default
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnSetFont");

    CCharFormat CF;
    if(FAILED(CF.InitDefault(hfont)))
        return 0;

    DWORD dwMask2 = CFM2_CHARFORMAT;
    WPARAM wparam = SCF_ALL;

    if(!GetAdjustedTextLength())
    {
        dwMask2 = CFM2_CHARFORMAT | CFM2_NOCHARSETCHECK;
        wparam = 0;
    }

    return !FAILED(OnSetCharFormat(wparam, &CF, NULL, CFM_ALL, dwMask2));
}

/*
 *  CTxtEdit::OnSetCharFormat(wparam, pCF, publdr, dwMask, dwMask2)
 *
 *  @mfunc
 *      Set new default CCharFormat
 *
 *  @rdesc
 *      LRESULT nonzero if success
 */
LRESULT CTxtEdit::OnSetCharFormat(
    WPARAM        wparam,   //@parm Selection flag
    CCharFormat * pCF,      //@parm CCharFormat to apply
    IUndoBuilder *publdr,   //@parm Undobuilder to receive antievents
    DWORD         dwMask,   //@parm CHARFORMAT2 mask
    DWORD         dwMask2)  //@parm Second mask
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnSetCharFormat");

    // This says that if there's a selection that's protected and the
    // parent window wants protection notifications and doesn't want
    // changes with a protected selection, then return 0.  This is more
    // stringent than RE 2.0, but it's more like 1.0.
    if (_psel && _psel->IsProtected(0) == CTxtRange::PROTECTED_ASK &&
        _dwEventMask & ENM_PROTECTED)
    {
        CHARFORMAT CF0;                 // Selection is protected, client
                                        //  wants protect notifications
        CF0.cbSize = sizeof(CHARFORMAT);//  and protected mask is on
        CF0.dwEffects = pCF->_dwEffects;// Concoct CHARFORMAT for query
        CF0.dwMask = dwMask;            // Maybe need more fields...
        if(QueryUseProtection(_psel, EM_SETCHARFORMAT, wparam, (LPARAM)&CF0))
            return 0;                   // No deal
    }

    BOOL fRet = TRUE;

    AssertSz(!_fSelChangeCharFormat || IsRich(),
        "Inconsistent _fSelChangeCharFormat flag");

    if ((wparam & SCF_ALL) ||
        !_fSelChangeCharFormat && _story.GetCFRuns() && !(wparam & SCF_SELECTION))
    {
        CTxtRange rg(this, 0, -GetTextLength());

        if(publdr)
            publdr->StopGroupTyping();

        if ((dwMask & (CFM_CHARSET | CFM_FACE)) == (CFM_CHARSET | CFM_FACE))
        {
            if(GetAdjustedTextLength())
            {
                dwMask2 |= CFM2_MATCHFONT;
                if (_fAutoFontSizeAdjust)
                {
                    dwMask2 |= CFM2_ADJUSTFONTSIZE;
                    if (fUseUIFont())
                        dwMask2 |= CFM2_UIFONT;
                }
            }
            else
                dwMask2 |= CFM2_NOCHARSETCHECK;
        }

        fRet = (rg.SetCharFormat(pCF, 0, publdr, dwMask, dwMask2) == NOERROR);

        // If we have an insertion point, apply format to it as well
        if (_psel && !_psel->GetCch() &&
            _psel->SetCharFormat(pCF, wparam, publdr, dwMask, dwMask2) != NOERROR)
        {
            fRet = FALSE;
        }
    }
    else if(wparam & SCF_SELECTION)
    {
        // Change selection character format unless protected
        if(!_psel || !IsRich())
            return 0;

        return _psel->SetCharFormat(pCF, wparam, publdr, dwMask, dwMask2)
                == NOERROR;
    }

    // Change default character format
    CCharFormat        CF;                  // Local CF to party on
    LONG               iCF;                 // Possible new CF index
    const CCharFormat *pCF1;                // Ptr to current default CF
    ICharFormatCache  *pICFCache = GetCharFormatCache();

    if(FAILED(pICFCache->Deref(Get_iCF(), &pCF1)))  // Get ptr to current
    {                                       //  default CCharFormat
        fRet = FALSE;
        goto Update;
    }
    CF = *pCF1;                             // Copy current default CF
    CF.Apply(pCF, dwMask, dwMask2);         // Modify copy
    if(FAILED(pICFCache->Cache(&CF, &iCF))) // Cache modified copy
    {
        fRet = FALSE;
        goto Update;
    }

#ifdef LINESERVICES
    if (g_pols)
        g_pols->DestroyLine(NULL);
#endif

    pICFCache->Release(Get_iCF());          // Release _iCF regardless
    Set_iCF(iCF);                           //  of whether _iCF = iCF,
                                            //  i.e., only 1 ref count
    if(_psel && !_psel->GetCch() && _psel->Get_iFormat() == -1)
        _psel->UpdateCaret(FALSE);

    if ((dwMask & (CFM_CHARSET | CFM_FACE)) == CFM_FACE &&
        !GetFontName(pCF->_iFont)[0] && GetFontName(CF._iFont)[0] &&
        IsBiDiCharSet(CF._bCharSet))
    {
        // Client requested font/charset be chosen for it according to thread
        // locale. If BiDi, then also set RTL para default
        CParaFormat PF;
        PF._wEffects = PFE_RTLPARA;
        OnSetParaFormat(SPF_SETDEFAULT, &PF, publdr, PFM_RTLPARA | PFM_PARAFORMAT);
    }

Update:
    // FUTURE (alexgo): this may be unnecessary if the display handles
    // updating more automatically.
    _pdp->UpdateView();
    return fRet;
}

/*
 *  CTxtEdit::OnSetParaFormat(wparam, pPF, publdr, dwMask)
 *
 *  @mfunc
 *      Set new default CParaFormat
 *
 *  @rdesc
 *      LRESULT nonzero if success
 */
LRESULT CTxtEdit::OnSetParaFormat(
    WPARAM       wparam,    //@parm wparam passed thru to IsProtected()
    CParaFormat *pPF,       //@parm CParaFormat to use
    IUndoBuilder *publdr,   //@parm Undobuilder to receive antievents
    DWORD        dwMask)    //@parm Mask to use
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnSetParaFormat");

    // If we're using context direction in the control, then we disallow
    // the paragraph direction property and the alignment property (unless
    // it's for center alignment).
    if(IsStrongContext(_nContextDir) || IsStrongContext(_nContextAlign))
    {
        Assert(!IsRich());
        if(dwMask & (PFM_RTLPARA | PFM_ALIGNMENT))
        {
            if (IsStrongContext(_nContextAlign) &&
                (pPF->_bAlignment == PFA_LEFT || pPF->_bAlignment == PFA_RIGHT))
            {
                dwMask &= ~PFM_ALIGNMENT;
            }
            if(IsStrongContext(_nContextDir))
                dwMask &= ~PFM_RTLPARA;
        }
    }
    BOOL fMatchKbdToPara = FALSE;

    if(dwMask & PFM_RTLPARA)
    {
        // In plain text allow DIR changes to change DIR and ALIGNMENT
        if(!IsRich())
        {
            // Clear all para masks, except for DIR and ALIGN
            dwMask &= (PFM_RTLPARA | PFM_ALIGNMENT);
            wparam |= SPF_SETDEFAULT;
        }
        if(_psel && _fFocus)
            fMatchKbdToPara = TRUE;
    }
    if(!(wparam & SPF_SETDEFAULT))
    {
        // If DEFAULT flag is specified, don't change selection
        if(!_psel || IsProtected(EM_SETPARAFORMAT, wparam, (LPARAM)pPF))
            return 0;

        LRESULT lres = NOERROR == (pPF->fSetStyle(dwMask)
             ? _psel->SetParaStyle(pPF, publdr, dwMask)
             : _psel->SetParaFormat(pPF, publdr, dwMask));

        // This is a bit funky, but basically, if the text is empty
        // then we also need to set the default paragraph format
        // (done in the code below).  Thus, if we hit a failure or
        // if the document is not empty, go ahead and return.
        // Otherwise, fall through to the default case.
        if(!lres || GetAdjustedTextLength())
        {
            if(fMatchKbdToPara)
                _psel->MatchKeyboardToPara();
            return lres;
        }
    }

    // No text in document or (wparam & SPF_SETDEFAULT): set default format

    LONG               iPF;                     // Possible new PF index
    CParaFormat        PF = *GetParaFormat(-1); // Local PF to party on
    IParaFormatCache  *pPFCache = GetParaFormatCache();

	PF.Apply(pPF, dwMask);						// Modify copy
	if(FAILED(pPFCache->Cache(&PF, &iPF)))		// Cache modified copy
		return 0;
	pPFCache->Release(Get_iPF());				// Release _iPF regardless of
	Set_iPF(iPF);								// Update default format index
	
	if(PF.IsRtlPara())		
		OrCharFlags(fBIDI, publdr);				// BiDi in backing store

	if(!IsRich() && dwMask & PFM_RTLPARA)		// Changing plain-text default PF
	{
		ItemizeDoc(publdr);						// causing re-itemize the whole doc.

        // (#6503) We cant undo the -1 format change in plaintext and that causes
        // many problems when we undo ReplaceRange event happening before the paragraph
        // switches. We better abandon the whole stack for now. (wchao)
        // -FUTURE- We should create an antievent for -1 PF change.
        ClearUndo(publdr);
    }
    _pdp->UpdateView();
    if (_psel)
        _psel->UpdateCaret(!Get10Mode() || _psel->IsCaretInView());
    if(fMatchKbdToPara)
        _psel->MatchKeyboardToPara();
    return TRUE;
}


////////////////////////////////  System notifications  ////////////////////////////////

LRESULT CTxtEdit::OnSetFocus()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnSetFocus");

    _fFocus = TRUE;

    // Update our idea of the current keyboard layout
    W32->RefreshKeyboardLayout();

    InitKeyboardFlags();

    if(!_psel)
        return 0;

    // _fMouseDown may sometimes be true.
    // This can happen when somebody steals our focus when we were doing
    // something with the mouse down--like processing a click. Thus, we'll
    // never get the MouseUpMessage.
    if(_fMouseDown)
    {
        TRACEWARNSZ("Getting the focus, yet we think the mouse is down");
    }
    _fMouseDown = FALSE;

    // BUG FIX #5369
    // Special case where we don't have a selection (or a caret). We need
    // to display something on focus so display a caret
    _psel->UpdateCaret(_fScrollCaretOnFocus, _psel->GetCch() == 0);
    _fScrollCaretOnFocus = FALSE;

    _psel->ShowSelection(TRUE);

    // if there is an in-place active object, we need to set the focus to
    // it. (in addition to the work that we do; this maintains compatibility
    // with RichEdit 1.0).
    if(_pobjmgr)
    {
        COleObject *pobj = _pobjmgr->GetInPlaceActiveObject();
        if(pobj)
        {
            IOleInPlaceObject *pipobj;

            if(pobj->GetIUnknown()->QueryInterface(IID_IOleInPlaceObject,
                    (void **)&pipobj) == NOERROR)
            {
                HWND hwnd;
                pipobj->GetWindow(&hwnd);

                if(hwnd)
                    SetFocus(hwnd);
                pipobj->Release();
            }
        }
    }

    TxNotify(EN_SETFOCUS, NULL);
    return 0;
}

LRESULT CTxtEdit::OnKillFocus()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnKillFocus");

    StopMagellanScroll();

    if(_pundo)
        _pundo->StopGroupTyping();

    if(_psel)
    {
        // Scroll back to beginning if necessary
        if (_fScrollCPOnKillFocus)
        {
            bool fHideSelectionLocal = _fHideSelection;

            // cannot hide Selection so cp=0 will be scroll into view.
            _fHideSelection = 0;
            OnSetSel(0, 0);
            _fHideSelection = fHideSelectionLocal;
        }

        _psel->DeleteCaretBitmap(TRUE); // Delete caret bitmap if one exists
        if(_fHideSelection)
            _psel->ShowSelection(FALSE);
    }

    _fFocus = FALSE;
    DestroyCaret();
    TxNotify(EN_KILLFOCUS, NULL);

    _fScrollCaretOnFocus = FALSE;       // Just to be safe, clear this
    return 0;
}


#if defined(DEBUG)
void CTxtEdit::OnDumpPed()
{
#ifndef NOPEDDUMP
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnDumpPed");

    char sz[256];
    CTxtSelection * const psel = GetSel();
    SELCHANGE selchg;

    psel->SetSelectionInfo(&selchg);

    wsprintfA(sz,
        "cchText = %ld      cchTextMost = %ld\r\n"
        "cpSelActive = %ld      cchSel = %ld\r\n"
        "wSelType = %x      # lines = %ld\r\n"
        "SysDefLCID = %lx   UserDefLCID = %lx",
        GetTextLength(),    TxGetMaxLength(),
        psel->GetCp(),  psel->GetCch(),
        selchg.seltyp,  _pdp->LineCount(),
        GetSystemDefaultLCID(), GetUserDefaultLCID()
    );
    Tracef(TRCSEVINFO, "%s", sz);
    MessageBoxA(0, sz, "ED", MB_OK);
#endif                  // NOPEDDUMP
}
#endif                  // DEBUG


///////////////////////////// Scrolling Commands //////////////////////////////////////

HRESULT CTxtEdit::TxHScroll(
    WORD wCode,
    int xPos)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxHScroll");

    if(!fInplaceActive())
        return OLE_E_INVALIDRECT;

    _pdp->HScroll(wCode, xPos);
    return S_OK;
}

LRESULT CTxtEdit::TxVScroll(
    WORD wCode,
    int yPos)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxVScroll");

    return _pdp->VScroll(wCode, yPos);
}

HRESULT CTxtEdit::TxLineScroll(
    LONG cli,
    LONG cch)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxLineScroll");

    // Currently cch does nothing in the following call, so we ignore
    // its translation from cach to cch (need to instantiate an rtp
    // for the current line
    _pdp->LineScroll(cli, cch);
    return S_OK;
}

void CTxtEdit::OnScrollCaret()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnScrollCaret");

    if(_psel)
	{
		_psel->SetForceScrollCaret(TRUE);
        _psel->UpdateCaret(TRUE);
		_psel->SetForceScrollCaret(FALSE);
	}
}


///////////////////////////////// Editing messages /////////////////////////////////

void CTxtEdit::OnClear(
    IUndoBuilder *publdr)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnClear");

    if(!_psel || TxGetReadOnly())
    {
        Beep();
        return;
    }

    if(_psel->GetCch() && !IsProtected(WM_CLEAR, 0, 0))
    {
        _psel->StopGroupTyping();
        _psel->ReplaceRange(0, NULL, publdr, SELRR_REMEMBERRANGE);
    }
}

void CTxtEdit::Beep()
{
    if(_fAllowBeep)
        MessageBeep(0);
}


///////////////////////////////////  Miscellaneous  ///////////////////////////////////////////

/*
 *  CTxtEdit::ItemizeDoc(publdr, cchRange)
 *
 *  @mfunc
 *      Helper routine to itemize the cchRange size of document content
 *      called by various clients outside CTxtRange.
 */
void CTxtEdit::ItemizeDoc(
    IUndoBuilder *  publdr,
    LONG            cchRange)
{
    // If cchRange = -1, itemize the whole doc
    if (cchRange == -1)
        cchRange = GetTextLength();

	// We wouldnt itemize if the doc only contains a single EOP
	// because we dont want Check_rpPF being called when the -1
	// PF format hasnt been properly established.
	// This is kind of hack, should be removed in the future.
	//
    if(cchRange && GetAdjustedTextLength())
    {                                       // Only itemize if more than
        CTxtRange rg(this, 0, -cchRange);   //  final EOP
        rg.ItemizeRuns(publdr);
    }

#if 0
	// =FUTURE=
	//		Once we open SPF_SETDEFAULT to public. We shall incorporate this code.
	// Basically, one can change the default paragraph reading order at runtime. All
	// PF runs referencing to -1 PF format then need to be reassigned a new paragraph
	// level value and reitemized.(6-10-99, wchao)
	//
    if(cchRange > 0)
    {
        CTxtRange rg(this, 0, -cchRange);

		// -1 PF format may have changed.
		// We shall make sure that the level of each PF run match the reading order
		// before start itemization.
		//
		if (rg.Check_rpPF())
		{
			LONG	cchLeft = cchRange;
			LONG	cchAdvance = 0;
			LONG	cch;

			while (cchLeft > 0)
			{
				rg._rpPF.GetRun(0)->_level._value = rg.IsParaRTL() ? 1 : 0;

				cch = rg._rpPF.GetCchLeft();

				if (!rg._rpPF.NextRun())
					break;		// no more run

				cchAdvance += cch;
				cchLeft -= cch;
			}

			Assert (cchAdvance + cchLeft == cchRange);

			rg._rpPF.AdvanceCp(-cchAdvance);	// fly back to cp = 0
		}

		// Now we rerun itemization
        rg.ItemizeRuns(publdr);
    }
#endif
}

/*
 *  CTxtEdit::OrCharFlags(dwFlags, publdr)
 *
 *  @mfunc
 *      Or in new char flags and activate LineServices and Uniscribe
 *      if complex script chars occur.
 */
void CTxtEdit::OrCharFlags(
    DWORD dwFlags,
    IUndoBuilder* publdr)
{
    // REVIEW: Should we send a notification for LS turn on?
    // Convert dwFlags to new on flags
    dwFlags &= dwFlags ^ _dwCharFlags;
    if(dwFlags)
    {
        _dwCharFlags |= dwFlags;            // Update flags

        dwFlags &= fCOMPLEX_SCRIPT;

        if(dwFlags && (_dwCharFlags & fCOMPLEX_SCRIPT) == dwFlags)
        {
            // REVIEW: Need to check if Uniscribe and LineServices are available...
            OnSetTypographyOptions(TO_ADVANCEDTYPOGRAPHY, TO_ADVANCEDTYPOGRAPHY);
            ItemizeDoc();

            // FUTURE: (#6838) We cant undo operations before the first itemization.
            ClearUndo(publdr);
            _fAutoKeyboard = IsBiDi();
        }

        UINT    brk = 0;

        if (dwFlags & fNEEDWORDBREAK)
            brk += BRK_WORD;
        if (dwFlags & fNEEDCHARBREAK)
            brk += BRK_CLUSTER;
        if (brk)
        {
            CUniscribe* pusp = Getusp();

            if (!_pbrk && pusp && pusp->IsValid())
            {
                // First time detecting the script that needs word/cluster-breaker
                // (such as Thai, Indic, Lao etc.)
                _pbrk = new CTxtBreaker(this);
                Assert(_pbrk);
            }

            if (_pbrk && _pbrk->AddBreaker(brk))
            {
                // Sync up the breaking array(s)
                _pbrk->Refresh();
            }
        }
    }
}

/*
 *  CTxtEdit::OnSetTypographyOptions(wparam, lparam)
 *
 *  @mfunc
 *      If CTxtEdit isn't a password or accelerator control and wparam
 *      differs from _bTypography, update the latter and the view.
 *
 *  @rdesc
 *      HRESULT = S_OK
 */
HRESULT CTxtEdit::OnSetTypographyOptions(
    WPARAM wparam,      //@parm Typography flags
    LPARAM lparam)      //@parm Typography mask
{
    // Currently only TO_SIMPLELINEBREAK and TO_ADVANCEDTYPOGRAPHY are defined
    if(wparam & ~(TO_SIMPLELINEBREAK | TO_ADVANCEDTYPOGRAPHY))
        return E_INVALIDARG;

    DWORD dwTypography = _bTypography & ~lparam;    // Kill current flag values
    dwTypography |= wparam & lparam;                // Or in new values

    if(_cpAccelerator == -1 && _bTypography != (BYTE)dwTypography)
    {
        _bTypography = (BYTE)dwTypography;
        _pdp->InvalidateRecalc();
        TxInvalidateRect(NULL, FALSE);
    }
    return S_OK;
}

void CTxtEdit::TxGetViewInset(
    LPRECT prc,
    CDisplay *pdp) const
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetViewInset");

    // Get inset, which is in HIMETRIC
    RECT rcHiMetricViewInset;

    if(SUCCEEDED(_phost->TxGetViewInset(&rcHiMetricViewInset)))
    {
        LONG vileft   = rcHiMetricViewInset.left;
        LONG vitop    = rcHiMetricViewInset.top;
        LONG viright  = rcHiMetricViewInset.right;
        LONG vibottom = rcHiMetricViewInset.bottom;

        if(!pdp)                        // If no display is specified,
            pdp = _pdp;                 //  use main display

        AssertSz(pdp->IsValid(), "CTxtEdit::TxGetViewInset Device not valid");

        // Convert HIMETRIC to pixels
        prc->left   = vileft   ? pdp->HimetricXtoDX( vileft ) : 0;
        prc->top    = vitop    ? pdp->HimetricYtoDY(rcHiMetricViewInset.top) : 0;
        prc->right  = viright  ? pdp->HimetricXtoDX(rcHiMetricViewInset.right) : 0;
        prc->bottom = vibottom ? pdp->HimetricYtoDY(rcHiMetricViewInset.bottom) : 0;
    }
    else
    {
        // The call to the host failed. While this is highly improbable, we do
        // want to something reasonably sensible. Therefore, we will just pretend
        // there is no inset and continue.
        ZeroMemory(prc, sizeof(RECT));
    }
}

#if 0
// Interchange horizontal and vertical commands
WORD wConvScroll(WORD wparam)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "wConvScroll");

    switch(wparam)
    {
        case SB_BOTTOM:
            return SB_TOP;

        case SB_LINEDOWN:
            return SB_LINEUP;

        case SB_LINEUP:
            return SB_LINEDOWN;

        case SB_PAGEDOWN:
            return SB_PAGEUP;

        case SB_PAGEUP:
            return SB_PAGEDOWN;

        case SB_TOP:
            return SB_BOTTOM;

        default:
            return wparam;
    }
}
#endif

//
//  helper functions. FUTURE (alexgo) maybe we should get rid of
//  some of these
//

/*  FUTURE (murrays): Unless they are called a lot, the TxGetBit routines
    might be done more compactly as:

BOOL CTxtEdit::TxGetBit(
    DWORD dwMask)
{
    DWORD dwBits = 0;
    _phost->TxGetPropertyBits(dwMask, &dwBits);
    return dwBits != 0;
}

e.g., instead of TxGetSelectionBar(), we use TxGetBit(TXTBIT_SELECTIONBAR).
If they are called a lot (like TxGetSelectionBar()), the bits should probably
be cached, since that saves a bunch of cache misses incurred in going over to
the host.

*/

BOOL CTxtEdit::IsLeftScrollbar() const
{
    if(!_fHost2)
        return FALSE;

    DWORD dwStyle, dwExStyle;

    _phost->TxGetWindowStyles(&dwStyle, &dwExStyle);
    return dwExStyle & WS_EX_LEFTSCROLLBAR;
}

TXTBACKSTYLE CTxtEdit::TxGetBackStyle() const
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetBackStyle");

    TXTBACKSTYLE style = TXTBACK_OPAQUE;
    _phost->TxGetBackStyle(&style);
    return style;
}

BOOL CTxtEdit::TxGetAutoSize() const
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetAutoSize");

    return (_dwEventMask & ENM_REQUESTRESIZE);
}

BOOL CTxtEdit::TxGetAutoWordSel() const
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetAutoWordSel");

    DWORD dwBits = 0;
    _phost->TxGetPropertyBits(TXTBIT_AUTOWORDSEL, &dwBits);
    return dwBits != 0;
}

DWORD CTxtEdit::TxGetMaxLength() const
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetMaxLength");

    // Keep this a DWORD in case client uses a cpMost of 0xFFFFFFFF, which is
    // admittedly a little large, at least for 32-bit address spaces!
    // tomForward would be a more reasonable max length, altho it's also
    // probably larger than possible in a 32-bit address space.
    return _cchTextMost;
}

/*
 *  CTxtEdit::TxSetMaxToMaxText(LONG cExtra)
 *
 *  @mfunc
 *      Set new maximum text length based on length of text and possibly extra chars
 *      to accomodate.
 *
 */
void CTxtEdit::TxSetMaxToMaxText(LONG cExtra)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxSetMaxToMaxText");

    // See if we need to update the text max
    LONG cchRealLen = GetAdjustedTextLength() + cExtra;

    if(_fInOurHost && _cchTextMost < (DWORD)cchRealLen)
        _cchTextMost = cchRealLen;
}

TCHAR CTxtEdit::TxGetPasswordChar() const
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetPasswordChar");

    if(_fUsePassword)
    {
        TCHAR ch = L'*';
        _phost->TxGetPasswordChar(&ch);

        // We don't allow these characters as password chars
        if(ch < 32 || ch == WCH_EMBEDDING)
            return L'*';
        return ch;
    }
    return 0;
}

DWORD CTxtEdit::TxGetScrollBars() const
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetScrollBars");

    DWORD dwScroll;
    _phost->TxGetScrollBars(&dwScroll);
    return dwScroll;
}

LONG CTxtEdit::TxGetSelectionBarWidth() const
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetSelectionBarWidth");

    LONG lSelBarWidth;
    _phost->TxGetSelectionBarWidth(&lSelBarWidth);
    return lSelBarWidth;
}

BOOL CTxtEdit::TxGetWordWrap() const
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetWordWrap");

    DWORD dwBits = 0;
    _phost->TxGetPropertyBits(TXTBIT_WORDWRAP, &dwBits);
    return dwBits != 0;
}

BOOL CTxtEdit::TxGetSaveSelection() const
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetSaveSelection");

    DWORD dwBits = 0;
    _phost->TxGetPropertyBits(TXTBIT_SAVESELECTION, &dwBits);
    return dwBits != 0;
}

/*
 *  CTxtEdit::ClearUndo()
 *
 *  @mfunc  Clear all undo buffers
 */
void CTxtEdit::ClearUndo(
    IUndoBuilder *publdr)   //@parm the current undo context (may be NULL)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::ClearUndo");

    if(_pundo)
        _pundo->ClearAll();

    if(_predo)
        _predo->ClearAll();

    if(publdr)
        publdr->Discard();
}

/////////////////////////////// ITextHost2 Extensions //////////////////////////////

/*
 *  CTxtEdit::TxIsDoubleClickPending ()
 *
 *  @mfunc  calls host via ITextHost2 to find out if double click is pending.
 *
 *  @rdesc  TRUE/FALSE
 */
BOOL CTxtEdit::TxIsDoubleClickPending()
{
    return _fHost2 ? _phost->TxIsDoubleClickPending() : FALSE;
}

/*
 *  CTxtEdit::TxGetWindow(phwnd)
 *
 *  @mfunc  calls host via ITextHost2 to get current window for this edit
 *          instance.  This is very helpful for OLE object support
 *
 *  @rdesc  HRESULT
 */
HRESULT CTxtEdit::TxGetWindow(
    HWND *phwnd)
{
    return _fHost2 ? _phost->TxGetWindow(phwnd) : E_NOINTERFACE;
}

/*
 *  CTxtEdit::TxSetForegroundWindow ()
 *
 *  @mfunc  calls host via ITextHost2 to make our window the foreground
 *          window. Used to support drag/drop.
 *
 *  @rdesc  HRESULT
 */
HRESULT CTxtEdit::TxSetForegroundWindow()
{
    return _fHost2 ? _phost->TxSetForegroundWindow() : E_NOINTERFACE;
}

/*
 *  CTxtEdit::TxGetPalette()
 *
 *  @mfunc  calls host via ITextHost2 to get current palette
 *
 *  @rdesc  HPALETTE
 */
HPALETTE CTxtEdit::TxGetPalette()
{
    return _fHost2 ? _phost->TxGetPalette() : NULL;
}

/*
 *  CTxtEdit::TxGetFEFlags(pFEFlags)
 *
 *  @mfunc  calls host via ITextHost2 to get current FE settings
 *
 *  @rdesc  HRESULT
 */
HRESULT CTxtEdit::TxGetFEFlags(
    LONG *pFEFlags)
{
    *pFEFlags = 0;                      // In case no ITextHost2 methods

    HRESULT hResult = _fHost2 ? _phost->TxGetFEFlags(pFEFlags) : E_NOINTERFACE;

    if (hResult == NOERROR && Get10Mode())
        *pFEFlags |= tomRE10Mode;

    return hResult;
}

//
//  Event Notification methods
//

/*
 *  CTxtEdit::TxNotify(iNotify, pv)
 *
 *  @mfunc  This function checks bit masks and sends notifications to the
 *          host.
 *
 *  @devnote    Callers should check to see if a special purpose notification
 *          method has already been provided.
 *
 *  @rdesc  S_OK, S_FALSE, or some error
 */
HRESULT CTxtEdit::TxNotify(
    DWORD iNotify,      //@parm Notification to send
    void *pv)           //@parm Data associated with notification
{
    // First, disallow notifications that we handle elsewhere
    Assert(iNotify != EN_SELCHANGE);    //see SetSelectionChanged
    Assert(iNotify != EN_ERRSPACE);     //see SetOutOfMemory
    Assert(iNotify != EN_CHANGE);       //see SetChangedEvent
    Assert(iNotify != EN_HSCROLL);      //see SendScrollEvent
    Assert(iNotify != EN_VSCROLL);      //see SendScrollEvent
    Assert(iNotify != EN_MAXTEXT);      //see SetMaxText
    Assert(iNotify != EN_MSGFILTER);    //this is handled specially
                                        // in TxSendMessage

    // Switch on the event to check masks.

    DWORD dwMask;
    switch(iNotify)
    {
        case EN_DROPFILES:
            dwMask = ENM_DROPFILES;
            goto Notify;

        case EN_PROTECTED:
            dwMask = ENM_PROTECTED;
            goto Notify;

        case EN_REQUESTRESIZE:
            dwMask = ENM_REQUESTRESIZE;
            goto Notify;

        case EN_PARAGRAPHEXPANDED:
            dwMask = ENM_PARAGRAPHEXPANDED;
            goto Notify;

        case EN_IMECHANGE:
            if (!Get10Mode())
                return S_FALSE;
            dwMask = ENM_IMECHANGE;
            goto Notify;

        case EN_UPDATE:
            if (!Get10Mode())
                break;
            dwMask = ENM_UPDATE;
            //FALL THROUGH CASE

        Notify:
            if(!(_dwEventMask & dwMask))
                return NOERROR;



    }

    return _phost->TxNotify(iNotify, pv);
}

/*
 *  CTxtEdit::SendScrollEvent(iNotify)
 *
 *  @mfunc  Sends scroll event if appropriate
 *
 *  @comm   Scroll events must be sent before any view updates have
 *          been requested and only if ENM_SCROLL is set.
 */
void CTxtEdit::SendScrollEvent(
    DWORD iNotify)      //@parm Notification to send
{
    Assert(iNotify == EN_HSCROLL || iNotify == EN_VSCROLL);

    // FUTURE (alexgo/ricksa).  The display code can't really
    // handle this assert yet.  Basically, we're trying to
    // say that scrollbar notifications have to happen
    // _before_ the window is updated.  When we do the
    // display rewrite, try to handle this better.

    // Assert(_fUpdateRequested == FALSE);

    if(_dwEventMask & ENM_SCROLL)
        _phost->TxNotify(iNotify, NULL);
}

/*
 *  CTxtEdit::HandleLinkNotification (msg, wparam, lparam, pfInLink)
 *
 *  @mfunc  Handles sending EN_LINK notifications.
 *
 *  @rdesc  TRUE if the EN_LINK message was sent and
 *          processed successfully.  Typically, that means the
 *          caller should stop whatever processing it was doing.
 */
BOOL CTxtEdit::HandleLinkNotification(
    UINT    msg,        //@parm msg prompting the link notification
    WPARAM  wparam,     //@parm wparam of the message
    LPARAM  lparam,     //@parm lparam of the message
    BOOL *  pfInLink)   //@parm if non-NULL, indicate if over a link
{
    if(pfInLink)
        *pfInLink = FALSE;

    if(!(_dwEventMask & ENM_LINK) || !_fInPlaceActive)
        return FALSE;

    HITTEST Hit;
    POINT   pt = {LOWORD(lparam), HIWORD(lparam)};

    if(msg == WM_SETCURSOR)
    {
        GetCursorPos(&pt);
        if(!_phost->TxScreenToClient(&pt))
            return FALSE;
    }

    LONG cp = _pdp->CpFromPoint(pt, NULL, NULL, NULL, FALSE, &Hit);

    if(Hit != HT_Link)                  // Not a hyperlink
        return FALSE;

    LONG      cpMin, cpMost;            // It's a hyperlink
    ENLINK    enlink;
    CTxtRange rg(this, cp, 0);

    ZeroMemory(&enlink, sizeof(enlink));
    if (fInOurHost())
    {
        GetWindow((LONG *) &enlink.nmhdr.hwndFrom);
        enlink.nmhdr.idFrom = GetWindowLong(enlink.nmhdr.hwndFrom, GWL_ID);
    }
    enlink.nmhdr.code = EN_LINK;

    if(pfInLink)
        *pfInLink = TRUE;
    rg.Expander(tomLink, TRUE, NULL, &cpMin, &cpMost);

    // Fill in ENLINK data structure for our EN_LINK
    // callback asking client what we should do
    enlink.msg = msg;
    enlink.wParam = wparam;
    enlink.lParam = lparam;
    enlink.chrg.cpMin  = GetAcpFromCp(cpMin);
    enlink.chrg.cpMost = GetAcpFromCp(cpMost);

    return _phost->TxNotify(EN_LINK, &enlink) == S_FALSE;
}

/*
 *  CTxtEdit::QueryUseProtection(prg, msg, wparam, lparam)
 *
 *  @mfunc  sends EN_PROTECTED to the host, asking if we should continue
 *  to honor the protection on a given range of characters
 *
 *  @rdesc  TRUE if protection should be honored, FALSE otherwise
 */
BOOL CTxtEdit::QueryUseProtection(
    CTxtRange *prg,     //@parm range to check for
    UINT    msg,        //@parm msg used
    WPARAM  wparam,     //@parm wparam of the msg
    LPARAM  lparam)     //@parm lparam of the msg
{
    LONG        cpMin, cpMost;
    ENPROTECTED enp;
    BOOL        fRet = FALSE;
    CCallMgr *  pcallmgr = GetCallMgr();

    Assert(_dwEventMask & ENM_PROTECTED);

    if( pcallmgr->GetInProtected() ||
        _fSuppressNotify)       // Don't ask host if we don't want to send notification
        return FALSE;

    pcallmgr->SetInProtected(TRUE);

    ZeroMemory(&enp, sizeof(ENPROTECTED));

    prg->GetRange(cpMin, cpMost);

    enp.msg = msg;
    enp.wParam = wparam;
    enp.lParam = lparam;
    enp.chrg.cpMin  = GetAcpFromCp(cpMin);
    enp.chrg.cpMost = GetAcpFromCp(cpMost);

    if(_phost->TxNotify(EN_PROTECTED, &enp) == S_FALSE)
        fRet = TRUE;

    pcallmgr->SetInProtected(FALSE);

    return fRet;
}


#ifdef DEBUG
//This is a debug api used to dump the document runs.
//If a pointer to the ped is passed, it is saved and
//used.  If NULL is passed, the previously saved ped
//pointer is used.  This allows the "context" to be
//setup by a function that has access to the ped and
//DumpDoc can be called lower down in a function that
//does not have access to the ped.
extern "C" {
void DumpStory(void *ped)
{
    static CTxtEdit *pedSave = (CTxtEdit *)ped;
    if(pedSave)
    {
        CTxtStory * pStory = pedSave->GetTxtStory();
        if(pStory)
            pStory->DbgDumpStory();

        CObjectMgr * pobjmgr = pedSave->GetObjectMgr();
        if(pobjmgr)
            pobjmgr->DbgDump();
    }
}
}
#endif

/*
 *  CTxtEdit::TxGetDefaultCharFormat (pCF)
 *
 *  @mfunc  helper function to retrieve character formats from the
 *          host.  Does relevant argument checking
 *
 *  @rdesc  HRESULT
 */
HRESULT CTxtEdit::TxGetDefaultCharFormat(
    CCharFormat *pCF,       //@parm Character format to fill in
    DWORD &      dwMask)    //@parm Mask supplied by host or default
{
    HRESULT hr = pCF->InitDefault(0);
    dwMask = CFM_ALL2;

    const CHARFORMAT2 *pCF2 = NULL;

    if (_phost->TxGetCharFormat((const CHARFORMAT **)&pCF2) != NOERROR ||
        !IsValidCharFormatW(pCF2))
    {
        return hr;
    }

    dwMask  = pCF2->dwMask;
    DWORD dwMask2 = 0;
    if(pCF2->cbSize == sizeof(CHARFORMAT))
    {
        // Suppress CHARFORMAT2 specifications (except for Forms^3 disabled)
        dwMask  &= fInOurHost() ? CFM_ALL : (CFM_ALL | CFM_DISABLED);
        dwMask2 = CFM2_CHARFORMAT;
    }

    CCharFormat CF;                         // Transfer external CHARFORMAT(2)
    CF.Set(pCF2, 1200);                     //  parms to internal CCharFormat
    return pCF->Apply(&CF, dwMask, dwMask2);
}

/*
 *  CTxtEdit::TxGetDefaultParaFormat (pPF)
 *
 *  @mfunc  helper function to retrieve  paragraph formats.  Does
 *          the relevant argument checking.
 *
 *  @rdesc  HRESULT
 */
HRESULT CTxtEdit::TxGetDefaultParaFormat(
    CParaFormat *pPF)       //@parm Paragraph format to fill in
{
    HRESULT hr = pPF->InitDefault(0);

    const PARAFORMAT2 *pPF2 = NULL;

    if (_phost->TxGetParaFormat((const PARAFORMAT **)&pPF2) != NOERROR ||
        !IsValidParaFormat(pPF2))
    {
        return hr;
    }

    DWORD dwMask  = pPF2->dwMask;
    if(pPF2->cbSize == sizeof(PARAFORMAT))  // Suppress all but PARAFORMAT
    {                                       //  specifications
        dwMask &= PFM_ALL;
        dwMask |= PFM_PARAFORMAT;           // Tell Apply() that PARAFORMAT
    }                                       //  was used

    CParaFormat PF;                         // Transfer external PARAFORMAT(2)
    PF.Set(pPF2);                           //  parms to internal CParaFormat
    return pPF->Apply(&PF, dwMask);         // Apply parms identified by dwMask
}


/*
 *  CTxtEdit::SetContextDirection(fUseKbd)
 *
 *  @mfunc
 *      Determine the paragraph direction and/or alignment based on the context
 *      rules (direction/alignment follows first strong character in the
 *      control) and apply this direction and/or alignment to the default
 *      format.
 *
 *  @comment
 *      Context direction only works for plain text controls. Note that
 *      this routine only switches the default CParaFormat to RTL para if it
 *      finds an RTL char. IsBiDi() will automatically be TRUE for this case,
 *      since each char is checked before entering the backing store.
 */
void CTxtEdit::SetContextDirection(
    BOOL fUseKbd)       //@parm Use keyboard to set context when CTX_NEUTRAL
{
    // It turns out that Forms^3 can send EM_SETBIDIOPTIONS even for non BiDi controls.
    // AssertSz(IsBiDi(), "CTxtEdit::SetContextDirection called for nonBiDi control");
    if(IsRich() || !IsBiDi() || _nContextDir == CTX_NONE && _nContextAlign == CTX_NONE)
        return;

    LONG    cch = GetTextLength();
    CTxtPtr tp(this, 0);
    TCHAR   ch = tp.GetChar();
    WORD    ctx = CTX_NEUTRAL;
    BOOL    fChanged = FALSE;

    // Find first strongly directional character
    while (cch && !IsStrongDirectional(MECharClass(ch)))
    {
        ch = tp.NextChar();
        cch--;
    }

    // Set new context based on first strong character
    if(cch)
        ctx = IsRTL(MECharClass(ch)) ? CTX_RTL : CTX_LTR;

    // Has context direction or alignment changed?
    if (_nContextDir   != CTX_NONE && _nContextDir   != ctx ||
        _nContextAlign != CTX_NONE && _nContextAlign != ctx)
    {
        // Start with current default CParaFormat
        CParaFormat PF = *GetParaFormat(-1);

        // If direction has changed...
        if(_nContextDir != CTX_NONE && _nContextDir != ctx)
        {
            if(ctx == CTX_LTR || ctx == CTX_RTL || fUseKbd)
            {
                if (ctx == CTX_RTL ||
                    ctx == CTX_NEUTRAL && W32->IsBiDiLcid(LOWORD(GetKeyboardLayout(0))))
                {
                    PF._wEffects |= PFE_RTLPARA;
                }
                else
                {
                    Assert(ctx == CTX_LTR || ctx == CTX_NEUTRAL);
                    PF._wEffects &= ~PFE_RTLPARA;
                }
                fChanged = TRUE;
            }
            _nContextDir = ctx;
        }

        // If the alignment has changed...
        if(_nContextAlign != CTX_NONE && _nContextAlign != ctx)
        {
            if(PF._bAlignment != PFA_CENTER)
            {
                if(ctx == CTX_LTR || ctx == CTX_RTL || fUseKbd)
                {
                    if (ctx == CTX_RTL ||
                        ctx == CTX_NEUTRAL && W32->IsBiDiLcid(LOWORD(GetKeyboardLayout(0))))
                    {
                        PF._bAlignment = PFA_RIGHT;
                    }
                    else
                    {
                        Assert(ctx == CTX_LTR || ctx == CTX_NEUTRAL);
                        PF._bAlignment = PFA_LEFT;
                    }
                }
            }
            _nContextAlign = ctx;
        }

        // Modify default CParaFormat
        IParaFormatCache *pPFCache = GetParaFormatCache();
        LONG iPF;

        if(SUCCEEDED(pPFCache->Cache(&PF, &iPF)))
        {
            pPFCache->Release(Get_iPF());   // Release _iPF regardless of
            Set_iPF(iPF);                   // Update default format index

            if (fChanged)
                ItemizeDoc(NULL);

            // Refresh display
            Assert(_pdp);
            if(!_pdp->IsPrinter())
            {
                _pdp->InvalidateRecalc();
                TxInvalidateRect(NULL, FALSE);
            }
        }
    }

    // Reset the first strong cp.
    _cpFirstStrong = tp.GetCp();

    Assert(_nContextDir != CTX_NONE || _nContextAlign != CTX_NONE);
}

/*
 *  CTxtEdit::GetAdjustedTextLength ()
 *
 *  @mfunc
 *      retrieve text length adjusted for the default end-of-document marker
 *
 *  @rdesc
 *      Text length without final EOP
 *
 *  @devnote
 *      For Word and RichEdit compatibility, we insert a CR or CRLF at the
 *      end of every new rich-text control.  This routine calculates the
 *      length of the document _without_ this final EOD marker.
 *
 *      For 1.0 compatibility, we insert a CRLF.  However, TOM (and Word)
 *      requires that we use a CR, from 2.0 on, we do that instead.
 */
LONG CTxtEdit::GetAdjustedTextLength()
{
    LONG cchAdjText = GetTextLength();

    Assert(!Get10Mode() || IsRich());       // No RE10 plain-text controls

    if(IsRich())
        cchAdjText -= fUseCRLF() ? 2 : 1;   // Subtract cch of final EOP

    return cchAdjText;
}

/*
 *  CTxtEdit::Set10Mode()
 *
 *  @mfunc
 *      Turns on the 1.0 compatibility mode bit.  If the control is
 *      rich text, it already has a default 'CR' at the end, which
 *      needs to turn into a CRLF for compatibility with RichEdit 1.0.
 *
 *  @devnote
 *      This function should only be called _immediately_ after
 *      creation of text services and before all other work.  There
 *      are Asserts to help ensure this.  Remark (murrays): why not
 *      allow the change provided the control is empty except for the
 *      final CR?
 *
 *      FUTURE: we might want to split _f10Mode into three flags:
 *      1) _fMapCps     // API cp's are MBCS and need conversion to Unicode
 *      2) _fCRLF       // Use CRLFs for EOPs instead of CRs
 *      3) _f10Mode     // All other RE 1.0 compatibility things
 *
 *      Category 3 includes 1) automatically using FR_DOWN in searches,
 *      2) ignoring direction in CDataTransferObj::EnumFormatEtc(),
 *      3) not resetting _fModified when switching to a new doc,
 */
void CTxtEdit::Set10Mode()
{
    CCallMgr    callmgr(this);
    _f10Mode = TRUE;

    // Make sure nothing important has happened to the control.
    // If these values are non-NULL, then somebody is probably trying
    // to put us into 1.0 mode after we've already done work as
    // a 2.0 control.
    Assert(GetTextLength() == cchCR);
    Assert(_psel == NULL);
    Assert(_fModified == NULL);

    SetRichDocEndEOP(cchCR);

    if(!_pundo)
        CreateUndoMgr(1, US_UNDO);

    if(_pundo)
        ((CUndoStack *)_pundo)->EnableSingleLevelMode();

    // Turn off dual font
    _fDualFont = FALSE;

    // Turn on auto sizing for NTFE systems
    if (OnWinNTFE())
        _fAutoFontSizeAdjust = TRUE;
}

/*
 *  CTxtEdit::SetRichDocEndEOP(cchToReplace)
 *
 *  @mfunc  Place automatic EOP at end of a rich text document.
 */
void CTxtEdit::SetRichDocEndEOP(
    LONG cchToReplace)
{
    CRchTxtPtr rtp(this, 0);

    // Assume this is a 2.0 Doc
    LONG cchEOP = cchCR;
    const WCHAR *pszEOP = szCR;

    if(_f10Mode)
    {
        // Reset update values for a 1.0 doc
        cchEOP = cchCRLF;
        pszEOP = szCRLF;
    }

    rtp.ReplaceRange(cchToReplace, cchEOP, pszEOP, NULL, -1);

    _fModified = FALSE;
    _fSaved = TRUE;
    GetCallMgr()->ClearChangeEvent();
}

/*
 *  CTxtEdit::PopAndExecuteAntiEvent(pundomgr, void *pAE)
 *
 *  @mfunc  Freeze display and execute anti-event
 *
 *  @rdesc  HRESULT from IUndoMgr::PopAndExecuteAntiEvent
 */
HRESULT CTxtEdit::PopAndExecuteAntiEvent(
    IUndoMgr *pundomgr, //@parm Undo manager to direct call to
    void  *pAE)         //@parm AntiEvent for undo manager
{
    HRESULT hr;
    // Let stack based classes clean up before restoring selection
    {
        CFreezeDisplay fd(_pdp);
        CSelPhaseAdjuster   selpa(this);

        hr = pundomgr->PopAndExecuteAntiEvent(pAE);
    }

    if(_psel)
    {
        // Once undo/redo has been executed, flush insertion point formatting
        _psel->Update_iFormat(-1);
        _psel->Update(TRUE);
    }
    return hr;
}

/*
 *  CTxtEdit::PasteDataObjectToRange(pdo, prg, cf, rps, publdr, dwFlags)
 *
 *  @mfunc  Freeze display and paste object
 *
 *  @rdesc  HRESULT from IDataTransferEngine::PasteDataObjectToRange
 */
HRESULT CTxtEdit::PasteDataObjectToRange(
    IDataObject *   pdo,
    CTxtRange *     prg,
    CLIPFORMAT      cf,
    REPASTESPECIAL *rps,
    IUndoBuilder *  publdr,
    DWORD           dwFlags)
{
    HRESULT hr = _ldte.PasteDataObjectToRange(pdo, prg, cf, rps, publdr,
        dwFlags);

    if(_psel)
        _psel->Update(TRUE);           // now update the caret

    return hr;
}

/*
 *  GetECDefaultHeightAndWidth (pts, hdc, lZoomNumerator, lZoomDenominator,
 *                  yPixelsPerInch, pxAveWidth, pxOverhang, pxUnderhang)
 *
 *  @mfunc  Helper for host to get ave char width and height for default
 *          character set for the control.
 *
 *  @rdesc  Height of default character set
 *
 *  @devnote:
 *          This really only s/b called by the window's host.
 */
LONG GetECDefaultHeightAndWidth(
    ITextServices *pts,         //@parm ITextServices to conver to CTxtEdit.
    HDC hdc,                    //@parm DC to use for retrieving the font.
    LONG lZoomNumerator,        //@parm Zoom numerator
    LONG lZoomDenominator,      //@parm Zoom denominator
    LONG yPixelsPerInch,        //@parm Pixels per inch for hdc
    LONG *pxAveWidth,           //@parm Optional ave width of character
    LONG *pxOverhang,           //@parm Optional overhang
    LONG *pxUnderhang)          //@parm Optional underhang
{
    CLock lock;                 // Uses global (shared) FontCache
    // Convert the text-edit ptr
    CTxtEdit *ped = (CTxtEdit *) pts;

    // Get the CCcs that has all the information we need
    yPixelsPerInch = MulDiv(yPixelsPerInch, lZoomNumerator, lZoomDenominator);
    CCcs *pccs = fc().GetCcs(ped->GetCharFormat(-1), yPixelsPerInch);

    if(!pccs)
        return 0;

    if(pxAveWidth)
        *pxAveWidth = pccs->_xAveCharWidth;

    if(pxOverhang)
        *pxOverhang = pccs->_xOverhang;     // Return overhang

    if(pxUnderhang)
        *pxUnderhang = pccs->_xUnderhang;   // Return underhang

    SHORT   yAdjustFE = pccs->AdjustFEHeight(!ped->fUseUIFont() && ped->_pdp->IsMultiLine());
    LONG yHeight = pccs->_yHeight + (yAdjustFE << 1);

    pccs->Release();                        // Release the CCcs
    return yHeight;
}

/*
 *  CTxtEdit::TxScrollWindowEx (dx, dy, lprcScroll, lprcClip, hrgnUpdate,
 *                                  lprcUpdate, fuScroll)
 *  @mfunc
 *      Request Text Host to scroll the content of the specified client area
 *
 *  @comm
 *      This method is only valid when the control is in-place active;
 *      calls while inactive may fail.
 */
void CTxtEdit::TxScrollWindowEx (
    INT     dx,             //@parm Amount of horizontal scrolling
    INT     dy,             //@parm Amount of vertical scrolling
    LPCRECT lprcScroll,     //@parm Scroll rectangle
    LPCRECT lprcClip,       //@parm Clip rectangle
    HRGN    hrgnUpdate,     //@parm Handle of update region
    LPRECT  lprcUpdate,     //@parm Update rectangle
    UINT    fuScroll)       //@parm Scrolling flags
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEEXTERN, "CTxtEdit::TxScrollWindowEx");

    if(_fInPlaceActive)
    {
#if !defined(NOMAGELLAN)
        CMagellanBMPStateWrap bmpOff(*this, NULL);
#endif

        _phost->TxScrollWindowEx(dx, dy, lprcScroll, lprcClip,
                        hrgnUpdate, lprcUpdate, fuScroll);

        // Tell all objects that they may need to update their position
        // RECTs if scrolling occurred.

        if(_pobjmgr)
        {
            RECT rcClient;

            if(!lprcScroll)
            {
                TxGetClientRect(&rcClient);
                lprcScroll = &rcClient;
            }
            _pobjmgr->ScrollObjects(dx, dy, lprcScroll);
        }
    }
}

/*
 *  CTxtEdit::GetAcpFromCp (cp)
 *
 *  @mfunc
 *      Get API cp (acp) from Unicode cp in this text instance. The API cp
 *      may be Unicode, in which case it equals cp, or MBCS, in which case
 *      it's greater than cp if any Unicode characters preceding cp convert
 *      to double-byte characters.  An MBCS cp is the BYTE index of a character
 *      relative to the start of the story, while a Unicode cp is the character
 *      index.  The values are the same if all charsets are represented by
 *      SBCS charsets, e.g., ASCII.  If all characters are represented by
 *      double-byte characters, then acp = 2*cp.
 *
 *  @rdesc
 *      MBCS Acp from Unicode cp in this text instance
 *
 *  @devnote
 *      This could be made more efficient by having the selection maintain
 *      the acp that corresponds to its _rpTX._cp, provided RE 1.0 mode is
 *      active.  Alternatively CTxtEdit could have a _prg that tracks this
 *      value, but at a higher cost (17 DWORDs instead of 1 per instance).
 *
 *      FUTURE: we might want to have a conversion-mode state instead of just
 *      _f10Mode, since some people might want to know use MBCS cp's even in
 *      RE 3.0.  If so, use the corresponding new state flag instead of
 *      Get10Mode() in the following.
 */
LONG CTxtEdit::GetAcpFromCp(
    LONG cp,                //@parm Unicode cp to convert to MBCS cp
    BOOL fPrecise)          //@parm fPrecise flag to get byte count for MBCS
{
    if(!(IsFE() && (fCpMap() || fPrecise))) // RE 2.0 and higher use char-count
        return cp;                          //  cp's, while RE 1.0 uses byte
                                            //  counts
                                            //  bPrecise is for Ansi Apps that want byte counts
                                            //  (e.g. Outlook Subject line)

    CRchTxtPtr rtp(this);                   // Start at cp = 0
    return rtp.GetCachFromCch(cp);
}

LONG CTxtEdit::GetCpFromAcp(
    LONG acp,               //@parm MBCS cp to convert to Unicode cp
    BOOL fPrecise)          //@parm fPrecise flag to get Unicode cp for MBCS
{
    if( acp == -1 || !(IsFE() && (fCpMap() || fPrecise)))
        return acp;

    CRchTxtPtr rtp(this);                   // Start at cp = 0
    return rtp.GetCchFromCach(acp);
}


/*
 *  CTxtEdit::GetViewKind (plres)
 *
 *  @mfunc
 *      get view mode
 *
 *  @rdesc
 *      HRESULT = (plres) ? NOERROR : E_INVALIDARG
 *
 *  @devnote
 *      This could be a TOM property method (along with SetViewMode())
 */
HRESULT CTxtEdit::GetViewKind(
    LRESULT *plres)     //@parm Out parm to receive view mode
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetViewKind");

    if(!plres)
        return E_INVALIDARG;

    *plres = IsInOutlineView() ? VM_OUTLINE : VM_NORMAL;
    return NOERROR;
}

/*
 *  CTxtEdit::SetViewKind (Value)
 *
 *  @mfunc
 *      Turn outline mode on or off
 *
 *  @rdesc
 *      HRESULT = IsRich() ? NOERROR : S_FALSE
 *
 *  @devnote
 *      This could be a TOM property method (along with GetViewMode())
 */
HRESULT CTxtEdit::SetViewKind(
    long Value)     //@parm Turn outline mode on/off for Value nonzero/zero
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::SetViewKind");

    if(!IsRich() || !_pdp->IsMultiLine())
        return S_FALSE;

    Value = (Value == VM_OUTLINE);          // Convert to 1/0
    if(_fOutlineView != Value)
    {
        HCURSOR hcur = TxSetCursor(LoadCursor(0, IDC_WAIT), NULL);
        CTxtSelection *psel = GetSel();

        _fOutlineView = (WORD)Value;
        if(!GetAdjustedTextLength())        // No text in control: in outline
        {                                   //  view, use Heading 1; in normal
            CParaFormat PF;                 //  view, use Normal style
            PF._sStyle = (SHORT)(IsInOutlineView()
                      ? STYLE_HEADING_1 : STYLE_NORMAL);
            psel->SetParaStyle(&PF, NULL, PFM_STYLE);
        }
        else
        {
            // There is text. Make sure there is paragraph formatting.
            _psel->Check_rpPF();
        }

        psel->CheckIfSelHasEOP(-1, 0);
        _pdp->UpdateView();
        psel->Update(TRUE);
        TxSetCursor(hcur, NULL);
    }
    return NOERROR;
}

/*
 *  CTxtEdit::GetViewScale (pValue)
 *
 *  @mfunc
 *      get view zoom scale in percent
 *
 *  @rdesc
 *      HRESULT = (pValue) ? NOERROR : E_INVALIDARG
 *
 *  @devnote
 *      This could be a TOM property method (along with SetViewScale())
 */
HRESULT CTxtEdit::GetViewScale(
    long *pValue)       //@parm Get % zoom factor
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetViewScale");

    if(!pValue)
        return E_INVALIDARG;

    *pValue = 100;
    if(GetZoomNumerator() && GetZoomDenominator())
        *pValue = (100*GetZoomNumerator())/GetZoomDenominator();

    return NOERROR;
}

/*
 *  CTxtEdit::SetViewScale (Value)
 *
 *  @mfunc
 *      Set zoom numerator equal to the scale percentage Value and
 *      zoom denominator equal to 100
 *
 *  @rdesc
 *      NOERROR
 *
 *  @devnote
 *      This could be a TOM property method (along with GetViewScale())
 */
HRESULT CTxtEdit::SetViewScale(
    long Value)     //@parm Set view scale factor
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::SetViewScale");

    if((unsigned)Value > 2000)
        return E_INVALIDARG;

    SetZoomNumerator(Value);
    SetZoomDenominator(100);
    return NOERROR;
}

/*
 *  CTxtEdit::UpdateOutline()
 *
 *  @mfunc
 *      Update selection and screen after ExpandOutline() operation
 *
 *  @comm
 *      This method is only valid when the control is in-place active;
 *      calls while inactive may fail.
 */
HRESULT CTxtEdit::UpdateOutline()
{
    Assert(IsInOutlineView());

    GetSel()->Update(FALSE);
    TxInvalidateRect(NULL, TRUE);
    return NOERROR;
}

/*
 *  CTxtEdit::MoveSelection(lparam, publdr)
 *
 *  @mfunc
 *      Move selected text up/down by the number of paragraphs given by
 *      LOWORD(lparam).
 *
 *  @rdesc
 *      TRUE iff movement occurred
 */
HRESULT CTxtEdit::MoveSelection (
    LPARAM lparam,          //@parm # paragraphs to move by
    IUndoBuilder *publdr)   //@parm undo builder to receive antievents
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtRange::MoveSelection");

    CFreezeDisplay  fd(_pdp);
    CTxtSelection * psel = GetSel();
    LONG            cch;
    LONG            cchSel = psel->GetCch();
    LONG            cpMin, cpMost;
    LONG            cpSel = psel->GetCp();
    IDataObject *   pdo = NULL;
    CTxtRange       rg(*psel);
    LONG            cpNext = 0;
    LONG            cpCur = 0;
    BOOL            fDeleteCR = FALSE;

    if(publdr)
        publdr->StopGroupTyping();

    rg.Expander(tomParagraph, TRUE, NULL, &cpMin, &cpMost);
    CPFRunPtr rp(rg);
    cch = rp.FindExpanded();            // Include subordinate paras
    if(cch < 0)
        cch = tomForward;
    rg.SetExtend(TRUE);
    rg.Advance(cch);
    cpMost = rg.GetCpMost();

    if(lparam > 0 && cpMost == GetTextLength())
    {
        Beep();                         // Already at end
        return S_FALSE;
    }

    HRESULT hr = _ldte.RangeToDataObject(&rg, SF_RTF, &pdo);
    if(hr != NOERROR)
        goto error;

    if(lparam > 0)
        psel->EndOf(tomParagraph, FALSE, NULL);
    else
        psel->StartOf(tomParagraph, FALSE, NULL);

    cpCur = psel->GetCp();
    hr = psel->Move(tomParagraph, lparam, NULL);
    if(psel->GetCp() == cpCur)
    {
        psel->Set(cpSel, cchSel);
        Beep();
        goto error;
    }

    // Since psel->Move() calls psel->Update(), the selection is forced
    // to be in noncollapsed text. Going backward, this might leave the
    // selection just before the EOP of a paragraph, instead of being at the
    // start of the paragraph where it should be.  Going forward it may have
    // tried to reach the EOD, but was adjusted backward. This case gets
    // a bit awkward...
    if(psel->GetCp() < cpCur)                   // Going backward: be sure
        psel->StartOf(tomParagraph, FALSE, NULL);//  end up at start of para

    else if(!psel->_rpTX.IsAfterEOP())          // Going forward and sel
    {                                           //  adjusted backward
        psel->SetExtend(FALSE);
        psel->Advance(tomForward);              // Go to final CR, insert a CR
        CTxtRange rgDel(*psel);                 //  use psel because UI
        rgDel.ReplaceRange(1, szCR, publdr, SELRR_REMEMBERRANGE);
        psel->Advance(1);
        fDeleteCR = TRUE;                       // Remember to delete it
    }

    cpCur = psel->GetCp();
    hr = _ldte.PasteDataObjectToRange(pdo, psel, 0, NULL,
                                      publdr, PDOR_NONE);
    if(hr != NOERROR)
        goto error;

    if(fDeleteCR)                               // Delete CR (final CR becomes
    {                                           //  CR for this para). Don't
        CTxtRange rgDel(*psel);                 //  use psel because UI
        Assert(rgDel._rpTX.IsAfterEOP());       //  restricts it's ability to
        rgDel.Delete(tomCharacter, -1, &cch);   //  delete
    }

    cpNext = psel->GetCp();
    psel->Set(cpCur, 0);
    psel->CheckOutlineLevel(publdr);
    psel->Set(cpNext, 0);
    psel->CheckOutlineLevel(publdr);

    // Now set selection anti-events. If selection preceded paste point,
    // subtract its length from redo position, since selection will get
    // deleted if we are doing a DRAGMOVE within this instance.
    cch = cpMost - cpMin;                       // cch of rg
    if(cpSel < cpCur)
        cpNext -= cch;

    psel->Set(psel->GetCp() + fDeleteCR, cch);  // Include final CR

    // rg.ReplaceRange won't delete final CR, so remember if it's included
    fDeleteCR = rg.GetCpMost() == GetTextLength();
    rg.ReplaceRange(0, NULL, publdr, SELRR_REMEMBERRANGE);

    if(fDeleteCR)                               // Needed to delete final CR
        rg.DeleteTerminatingEOP(publdr);        // Delete one immediately
                                                //  before it instead
    rg.CheckOutlineLevel(publdr);
    if(publdr)
    {
        HandleSelectionAEInfo(this, publdr, cpSel, cchSel, cpNext, cch,
                              SELAE_FORCEREPLACE);
    }
    hr = NOERROR;

error:
    if(pdo)
        pdo->Release();
    return hr;
}

/*
 *  CTxtEdit::SetReleaseHost
 *
 *  @mfunc  Handles notification that edit control must keep its
 *          reference to the host alive.
 *
 *  @rdesc  None.
 */
void CTxtEdit::SetReleaseHost()
{
    _phost->AddRef();
    _fReleaseHost = TRUE;
}

#if !defined(NOMAGELLAN)
/*
 *  CTxtEdit::HandleMouseWheel(wparam, lparam)
 *
 *  @mfunc  Handles scrolling as a result of rotating a mouse roller wheel.
 *
 *  @rdesc  LRESULT
 */
LRESULT CTxtEdit::HandleMouseWheel(
    WPARAM wparam,
    LPARAM lparam)
{
    // This bit of global state is OK
    static LONG gcWheelDelta = 0;
    short zdelta = (short)HIWORD(wparam);
    BOOL fScrollByPages = FALSE;

    // Cancel middle mouse scrolling if it's going.
    OnTxMButtonUp(0, 0, 0);

    // Handle zoom or data zoom
    if((wparam & MK_CONTROL) == MK_CONTROL)
    {
        // bug fix 5760
        // prevent zooming if control is NOT rich or
        // is a single line control
        if (!_pdp->IsMultiLine())
            return 0;

        LONG lViewScale;
        GetViewScale(&lViewScale);
        lViewScale += (zdelta/WHEEL_DELTA) * 10;    // 10% per click
        if(lViewScale <= 500 && lViewScale >= 10)   // Word's limits
        {
            SetViewScale(lViewScale);
            _pdp->UpdateView();
        }
        return 0;
    }

    if(wparam & (MK_SHIFT | MK_CONTROL))
        return 0;

    gcWheelDelta += zdelta;

    if(abs(gcWheelDelta) >= WHEEL_DELTA)
    {
        LONG cLineScroll = W32->GetRollerLineScrollCount();
        if(cLineScroll != -1)
            cLineScroll *= abs(gcWheelDelta)/WHEEL_DELTA;

        gcWheelDelta %= WHEEL_DELTA;

        // -1 means scroll by pages; so simply call page up/down.
        if(cLineScroll == -1)
        {
            fScrollByPages = TRUE;
            if(_pdp)
                _pdp->VScroll(zdelta < 0 ? SB_PAGEDOWN : SB_PAGEUP, 0);
        }
        else
        {
            mouse.MagellanRollScroll(_pdp, zdelta, cLineScroll,
                SMOOTH_ROLL_NUM, SMOOTH_ROLL_DENOM, TRUE);
        }

        // notify through the messagefilter that we scrolled
        if(_dwEventMask & ENM_SCROLLEVENTS)
        {
            MSGFILTER msgfltr;
            ZeroMemory(&msgfltr, sizeof(MSGFILTER));
            msgfltr.msg    = WM_VSCROLL;
            msgfltr.wParam = fScrollByPages ?
                                (zdelta < 0 ? SB_PAGEDOWN: SB_PAGEUP):
                                (zdelta < 0 ? SB_LINEDOWN: SB_LINEUP);

            // We don't check the result of this call --
            // it's not a message we received and we're not going to
            // process it any further
            _phost->TxNotify(EN_MSGFILTER, &msgfltr);
        }
        return TRUE;
    }
    return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\format.cpp ===
/*
 *	@doc	INTERNAL
 *	
 *	@module - FORMAT.C
 *		CCharFormatArray and CParaFormatArray classes |
 *	
 *	Authors:
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_format.h"


ASSERTDATA

// ===============================  CFixArrayBase  =================================


CFixArrayBase::CFixArrayBase(
	LONG cbElem)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFixArrayBase::CFixArrayBase");
	
	_prgel = NULL; 
	_cel = 0; 
	_ielFirstFree = 0; 
	_cbElem = cbElem + sizeof(LONG_PTR);		// Use LONG_PTR to get proper alignment on Win64
}

/*
 *	CFixArrayBase::Add()
 *
 *	@mfunc	
 *		Return index of new element, reallocing if necessary
 *
 *	@rdesc
 *		Index of new element.
 *
 *	@comm
 *		Free elements are maintained in place as a linked list indexed
 *		by a chain of ref-count entries with their sign bits set and the
 *		rest of the entry giving the index of the next element on the
 *		free list.  The list is terminated by a 0 entry. This approach
 *		enables element 0 to be on the free list.
 */
LONG CFixArrayBase::Add()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFixArrayBase::Add");

	char *pel;
	LONG iel, ielRet;

	if(_ielFirstFree)					// Return first element of free list
	{
		ielRet = _ielFirstFree & ~FLBIT;
		_ielFirstFree = RefCount(ielRet);
	}
	else								// All lower positions taken: need 
	{									//  to add another celGrow elements
		pel = (char*)PvReAlloc(_prgel, (_cel + celGrow) * _cbElem);
		if(!pel)
			return -1;

		// Clear out the *end* of the newly allocated memory
		ZeroMemory(pel + _cel*_cbElem, celGrow*_cbElem);

		_prgel = pel;

		ielRet = _cel;					// Return first one added 
		iel = _cel + 1;
		_cel += celGrow;

		// Add elements _cel+1 thru _cel+celGrow-1 to free list. The last
		// of these retains a 0, stored by fZeroFill in Alloc
		_ielFirstFree = iel | FLBIT;

		for(pel = (char *)&RefCount(iel);
			++iel < _cel;
			pel += _cbElem)
		{
			*(INT *)pel = iel | FLBIT;
		}
	}		
	return ielRet;
}

void CFixArrayBase::Free(
	LONG iel)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFixArrayBase::Free(iel)");

	// Simply add it to free list
	RefCount(iel) = _ielFirstFree;
	_ielFirstFree = iel | FLBIT;
}

void CFixArrayBase::Free()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFixArrayBase::Free()");

#ifdef DEBUG
	// Only do this validation if all the ped's are gone. Visual basic shutsdown apps
	// without freeing all the resources so this safety check is necessary.
	if (0 == W32->GetRefs())
	{
		// Display MessageBox if any CCharFormats, CParaFormats, or CTabs have
		// reference counts > 0.  This only happens if an error has occurred.
		BOOL fComplained = FALSE;
		for(LONG iel = 0; iel < Count(); iel++)
		{
			while(RefCount(iel) > 0)
			{
				if (!fComplained)
				{
					fComplained = TRUE;
					AssertSz(FALSE, _cbElem == sizeof(CCharFormat) + sizeof(LONG_PTR) ? "CCharFormat not free" :
								 _cbElem == sizeof(CParaFormat) + sizeof(LONG_PTR) ? "CParaFormat not free" :
									 "CTabs not free");
				}

				Release(iel);
			}
		}
	}
#endif
	FreePv(_prgel);
	_prgel = NULL;
	_cel = 0;
	_ielFirstFree = 0;
}

HRESULT CFixArrayBase::Deref(
	LONG iel,
	const void **ppel) const
{
	Assert(ppel);
	AssertSz(iel >= 0,
		"CFixArrayBase::Deref: bad element index" );
	AssertSz(*(LONG *)(_prgel + (iel + 1) * _cbElem - 4) > 0,
		"CFixArrayBase::Deref: element index has bad ref count");

	if(!ppel)
		return E_INVALIDARG;

	*ppel = Elem(iel);
	return S_OK;
}

/*
 *	CFixArrayBase::RefCount(iel)
 *
 *	@mfunc
 *		The reference count for an element is stored as a LONG immediately
 *		following the element in the CFixArray. If the element isn't used
 *		i.e., is free, then the reference count is used as a link to the
 *		next free element.  The last free element in this list has a 0
 *		"reference count", which terminates the list.
 *
 *		The ref count follows the element instead of preceding it because
 *		this allows Elem(iel) to avoid an extra addition.  Elem() is used
 *		widely in the code.
 *
 *	@rdesc
 *		Ptr to reference count
 */
LONG & CFixArrayBase::RefCount(
	LONG iel)
{
	Assert(iel < Count());
	return (LONG &)(*(_prgel + (iel + 1) * _cbElem - 4));
}

LONG CFixArrayBase::Release(
	LONG iel)
{
	LONG  cRef = -1;

	if(iel >= 0)							// Ignore default iel
	{
		CLock lock;
		CheckFreeChain();
		AssertSz(RefCount(iel) > 0, "CFixArrayBase::Release(): already free");

		cRef = --RefCount(iel); 
		if(!cRef)							// Entry no longer referenced
			Free(iel);						// Add it to the free chain
	}
	return cRef;
}

LONG CFixArrayBase::AddRef(
	LONG iel)
{
	LONG  cRef = -1;

	if(iel >= 0)
	{
		CLock lock;
		CheckFreeChain();
    	AssertSz(RefCount(iel) > 0, "CFixArrayBase::AddRef(): add ref to free elem");
		cRef = ++RefCount(iel);
	}
	return cRef;
}

LONG CFixArrayBase::Find(
	const void *pel)
{
	CheckFreeChain();
	
	for(LONG iel = 0; iel < Count(); iel++)
	{
		// RefCount < 0 means entry not in use and is index of next free entry.
		// RefCount = 0 marks last free element in list.  _cbElem = sizeof(ELEM)
		// plus sizeof(RefCount), which is a LONG.
		if (RefCount(iel) > 0 &&
			!CompareMemory(Elem(iel), pel, _cbElem - sizeof(LONG_PTR)))
		{
			return iel;
		}
	}
	return -1;
}

HRESULT CFixArrayBase::Cache(
	const void *pel,
	LONG *		piel)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormatArray::Cache");

	CLock	lock;
	LONG	iel = Find(pel);

	if(iel >= 0)
		RefCount(iel)++;
	else
	{	
		iel = Add();
		if(iel < 0)
			return E_OUTOFMEMORY;
		CopyMemory(Elem(iel), pel, _cbElem - sizeof(LONG_PTR));
		RefCount(iel) = 1;
	}

	CheckFreeChain();
	
	if(piel)
		*piel = iel;
	
	return S_OK;
}

#ifdef DEBUG

void CFixArrayBase::CheckFreeChainFn(
	LPSTR	szFile,
	INT		nLine)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFixArrayBase::CheckFreeChainFn");

	LONG cel = 0;
	LONG iel = _ielFirstFree;
	LONG ielT;

	while(iel)
	{
		Assert(iel < 0);
		ielT = RefCount(iel & ~FLBIT);

		if((LONG)(ielT & ~FLBIT) > _cel)
			Tracef(TRCSEVERR, "AttCheckFreeChainCF(): elem %ld points to out of range elem %ld", iel, ielT);

		iel = ielT;
		if(++cel > _cel)
		{
			AssertSzFn("CFixArrayBase::CheckFreeChain() - CF free chain seems to contain an infinite loop", szFile, nLine);
			return;
		}
	}
}

#endif


// ===========================  CCharFormatArray  ===========================================

HRESULT CCharFormatArray::Deref(
	LONG iCF,
	const CCharFormat **ppCF) const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormatArray::Deref");

	return CFixArrayBase::Deref(iCF, (const void **)ppCF);
}

LONG CCharFormatArray::Release(
	LONG iCF)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormatArray::ReleaseFormat");

	return CFixArrayBase::Release(iCF);
}

LONG CCharFormatArray::AddRef(
	LONG iCF)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormatArray::AddRefFormat");

	return CFixArrayBase::AddRef(iCF);
}

void CCharFormatArray::Destroy()
{
	delete this;
}

LONG CCharFormatArray::Find(
	const CCharFormat *pCF)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormatArray::Find");

	LONG iCF;

	#define QUICKCRCSEARCHSIZE	15	// Must be 2^n - 1 for quick MOD
									//  operation, it is a simple hash.
 	static struct {
		BYTE	bCRC;
		LONG	iCF;
	} quickCrcSearch[QUICKCRCSEARCHSIZE+1];
 	BYTE	bCRC;
	WORD	hashKey;

	CheckFreeChain();

	// Check our cache before going sequential
	bCRC = (BYTE)pCF->_iFont;
	hashKey = (WORD)(bCRC & QUICKCRCSEARCHSIZE);
	if(bCRC == quickCrcSearch[hashKey].bCRC)
	{
		iCF = quickCrcSearch[hashKey].iCF - 1;
		if (iCF >= 0 && iCF < Count() && RefCount(iCF) > 0 &&
			!CompareMemory(Elem(iCF), pCF, sizeof(CCharFormat)))
		{
			return iCF;
		}
	}

	for(iCF = 0; iCF < Count(); iCF++)
	{
		if(RefCount(iCF) > 0 && !CompareMemory(Elem(iCF), pCF, sizeof(CCharFormat)))
		{
			quickCrcSearch[hashKey].bCRC = bCRC;
			quickCrcSearch[hashKey].iCF = iCF + 1;
			return iCF;
		}
	}
	return -1;
}

HRESULT CCharFormatArray::Cache(
	const CCharFormat *pCF,
	LONG* piCF)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormatArray::Cache");

	CLock lock;
	LONG  iCF = Find(pCF);

	if(iCF >= 0)
		RefCount(iCF)++;
	else
	{
		iCF = Add();
		if(iCF < 0)
			return E_OUTOFMEMORY;
		*Elem(iCF) = *pCF;			// Set entry iCF to *pCF
		RefCount(iCF) = 1;
	}					 

	CheckFreeChain();
	
	if(piCF)
		*piCF = iCF;

	return S_OK;
}


// ===============================  CParaFormatArray  ===========================================

HRESULT CParaFormatArray::Deref(
	LONG iPF,
	const CParaFormat **ppPF) const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormatArray::Deref");

	return CFixArrayBase::Deref(iPF, (const void **)ppPF);
}

LONG CParaFormatArray::Release(
	LONG iPF)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormatArray::ReleaseFormat");

	CLock lock;
	LONG  cRef = CFixArrayBase::Release(iPF);

#ifdef TABS
	if(!cRef)
		GetTabsCache()->Release(Elem(iPF)->_iTabs);
#endif
	return cRef;
}

LONG CParaFormatArray::AddRef(
	LONG iPF)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormatArray::AddRefFormat");

	return CFixArrayBase::AddRef(iPF);
}

void CParaFormatArray::Destroy()
{
	delete this;
}

HRESULT CParaFormatArray::Cache(
	const CParaFormat *pPF,
	LONG *piPF)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormatArray::Cache");

	HRESULT hr = CFixArrayBase::Cache((const void *)pPF, piPF);
#ifdef TABS
	if(hr == NOERROR && RefCount(*piPF) == 1)
		GetTabsCache()->AddRef(pPF->_iTabs);
#endif
	return hr;
}


// ===============================  CTabsArray  ===========================================

CTabsArray::~CTabsArray()
{
	for(LONG iTabs = 0; iTabs < Count(); iTabs++)
	{
		// It shouldn't be necessary to release any tabs, since when all
		// controls are gone, no reference counts should be > 0.
		while(RefCount(iTabs) > 0)
		{
#ifdef DEBUG
			// Only do this validation if all the ped's are gone. Visual basic shutsdown apps
			// without freeing all the resources so this safety check is necessary.
			AssertSz(0 != W32->GetRefs(), "CTabs not free");
#endif
			Release(iTabs);
		}
	}
}

const LONG *CTabsArray::Deref(
	LONG iTabs) const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTabsArray::Deref");

	return iTabs >= 0 ? Elem(iTabs)->_prgxTabs : NULL;
}

LONG CTabsArray::Release(
	LONG iTabs)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTabsArray::Release");

	LONG cRef = CFixArrayBase::Release(iTabs);
	if(!cRef)
		FreePv(Elem(iTabs)->_prgxTabs);
	return cRef;
}

LONG CTabsArray::AddRef(
	LONG iTabs)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTabsArray::AddRef");

	return CFixArrayBase::AddRef(iTabs);
}

LONG CTabsArray::Find(
	const LONG *prgxTabs,
	LONG		cTab)
{
	CheckFreeChain();

	CTabs *pTab;
	
	for(LONG iel = 0; iel < Count(); iel++)
	{
		// RefCount < 0 means entry not in use and is index of next free entry.
		// RefCount = 0 marks last free element in list.  _cbElem = sizeof(ELEM)
		// plus sizeof(RefCount), which is a LONG.
		if(RefCount(iel) > 0)
		{
			pTab = Elem(iel);
			if (pTab->_cTab == cTab &&
				!CompareMemory(pTab->_prgxTabs, prgxTabs, cTab*sizeof(LONG)))
			{
				return iel;
			}
		}
	}
	return -1;
}

LONG CTabsArray::Cache(
	const LONG *prgxTabs,
	LONG		cTab)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTabsArray::Cache");

	if(!cTab)
		return -1;						// No tabs defined: use default

	CLock	lock;
	LONG	iTabs = Find(prgxTabs, cTab);

	if(iTabs >= 0)
		RefCount(iTabs)++;
	else
	{
		iTabs = Add();
		if(iTabs < 0)					// Out of memory: use default
			return -1;

		CTabs *pTabs = Elem(iTabs);
		LONG   cb = sizeof(LONG)*cTab;

		pTabs->_prgxTabs = (LONG *)PvAlloc(cb, GMEM_FIXED);
		if(!pTabs->_prgxTabs)
			return -1;					// Out of memory: use default
		CopyMemory(pTabs->_prgxTabs, prgxTabs, cb);
		pTabs->_cTab = cTab;
		RefCount(iTabs) = 1;
	}					 
	return iTabs;
}


// ==================================  Factories  ===========================================

static ICharFormatCache *pCFCache = NULL;		// CCharFormat cache
static IParaFormatCache *pPFCache = NULL;	 	// CParaFormat cache
static CTabsArray *	   pTabsCache = NULL;	 	// CTabs cache

ICharFormatCache *GetCharFormatCache()
{
	return pCFCache;
}

IParaFormatCache *GetParaFormatCache()
{
	return pPFCache;
}

CTabsArray *GetTabsCache()
{
	return pTabsCache;
}

HRESULT CreateFormatCaches()					// Called by DllMain()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CreateFormatCaches");
	CLock	lock;

	pCFCache = new CCharFormatArray();
	if(!pCFCache)
		return E_OUTOFMEMORY;
     
    pPFCache = new CParaFormatArray();
	if(!pPFCache)
	{
		delete pCFCache;
		return E_OUTOFMEMORY;
	}

    pTabsCache = new CTabsArray();
	if(!pTabsCache)
	{
		delete pCFCache;
		delete pPFCache;
		return E_OUTOFMEMORY;
	}
	return S_OK;
}

HRESULT DestroyFormatCaches()					// Called by DllMain()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "DeleteFormatCaches");

	if (pCFCache)
		pCFCache->Destroy();
	if (pPFCache)
		pPFCache->Destroy();
	if (pTabsCache)
		delete pTabsCache;
	return NOERROR;
}

/*
 *	ReleaseFormats(iCF, iPF)
 *
 *	@mfunc
 *		Release char and para formats corresponding to the indices <p iCF>
 *		and <p iPF>, respectively
 */
void ReleaseFormats (
	LONG iCF,			//@parm CCharFormat index for releasing
	LONG iPF)			//@parm CParaFormat index for releasing
{
	AssertSz(pCFCache && pPFCache,
		"ReleaseFormats: uninitialized format caches");
	if (iCF != -1)
		pCFCache->Release(iCF);
	if (iPF != -1)
		pPFCache->Release(iPF);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\hash.h ===
#ifndef _HASH_H
#define _HASH_H

#include "tokens.h"

#define		HASHSIZE 	257	// DO NOT CHANGE!
						// this prime has been chosen because
						// there is a fast MOD257
						// if you use the % operator the thing
						// slows down to just about what a binary search is.

#define			MOD257(k) ((k) - ((k) & ~255) - ((k) >> 8) )	// MOD 257
#define			MOD257_1(k) ((k) & 255)	// MOD (257 - 1)

extern BOOL		_rtfHashInited;
VOID			HashKeyword_Init( );

VOID			HashKeyword_Insert ( const KEYWORD *token );
const KEYWORD	*HashKeyword_Fetch ( const CHAR *szKeyword );

#endif	// _HASH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\font.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module FONT.CPP -- font cache |
 *
 *		Includes font cache, char width cache;
 *		create logical font if not in cache, look up
 *		character widths on an as needed basis (this
 *		has been abstracted away into a separate class
 *		so that different char width caching algos can
 *		be tried.) <nl>
 *		
 *	Owner: <nl>
 *		RichEdit 1.0 code: David R. Fulmer
 *		Christian Fortini (initial conversion to C++)
 *		Jon Matousek <nl>
 *
 *	History: <nl>
 *		7/26/95		jonmat	cleanup and reorganization, factored out
 *					char width caching code into a separate class.
 *
 *	Copyright (c) 1995-1998 Microsoft Corporation. All rights reserved.
 */								

#include "_common.h"
#include "_font.h"
#include "_rtfconv.h"	// Needed for GetCodePage
#include "_uspi.h"

#define CLIP_DFA_OVERRIDE   0x40	//  Used to disable Korea & Taiwan font association
#define FF_BIDI		7

ASSERTDATA

// Corresponds to yHeightCharPtsMost in richedit.h
#define yHeightCharMost 32760

// NOTE: this is global across all instances in the same process.
static CFontCache *g_fc;

static FONTINFO *g_pFontInfo = NULL;
static LONG g_cFontInfo = 0;
static LONG g_cFontInfoMax = 0;

//Fonts automatically added to our font table
const WCHAR *szArial			= L"Arial";				// IFONT_ARIAL
const WCHAR *szTimesNewRoman	= L"Times New Roman";	// IFONT_TIMESNEWROMAN
const WCHAR *szSymbol			= L"Symbol";			// IFONT_SYMBOL
const WCHAR *szSystem			= L"System";			// IFONT_SYSTEM
const int cfontsDflt = 4;

//Other fonts that we do use, but aren't automatically added to our font table
const WCHAR *szMicrosSansSerif	= L"Microsoft Sans Serif";
const WCHAR *szMSSansSerif		= L"MS Sans Serif";
const WCHAR *szMangal			= L"Mangal";
const WCHAR *szLatha			= L"Latha";
const WCHAR *szCordiaNew		= L"Cordia New";
const WCHAR *szTahoma			= L"Tahoma";
const WCHAR *szArialUnicode		= L"Arial Unicode MS";
const WCHAR *szWingdings		= L"Wingdings";

#define szFontOfChoice szArial

/*
 *	GetFontNameIndex(pFontName)
 *
 *	@func
 *		return index into global pszFontName table for fontname pFontName.
 *		If fontname isn't in table, add it and return index.
 *
 *	@rdesc
 *		fontname index corresponding to pFontName
 *
 *	@devnote
 *		This uses a linear search, so the most common font names should be
 *		up front. Internally, we use the fontname indices, so the search
 *		isn't done that often.  Note also that the fontname table only grows,
 *		but this is probably OK for most clients.  Else we need ref counting...
 */
SHORT GetFontNameIndex(
	const WCHAR *pFontName)
{
	CLock Lock;					// Wonder how much this slows things down...

	for(LONG i = 0; i < g_cFontInfo; i++)
	{
		// A hash could speed this up if perf turns out poor
		if(!wcscmp(pFontName, g_pFontInfo[i].szFontName))
			return i;
	}

	if(g_cFontInfo + 1 >= g_cFontInfoMax)
	{
		// Note that PvReAlloc() reverts to PvAlloc() if g_pFontInfo is NULL
		FONTINFO *pFI = (FONTINFO *)PvReAlloc((LPVOID)g_pFontInfo,
									sizeof(FONTINFO) * (8 + g_cFontInfo));
		if(!pFI)
			return IFONT_ARIAL;					// Out of memory...

		// Initialize the structure
		ZeroMemory (&pFI[g_cFontInfo], 8 * sizeof(FONTINFO));

												//  attempts to fill them in
		if(!g_cFontInfoMax)						// First allocation
		{
			Assert(IFONT_ARIAL  == 0 && IFONT_TMSNEWRMN == 1 &&
				   IFONT_SYMBOL == 2 && IFONT_SYSTEM == 3);

			pFI[IFONT_ARIAL].szFontName		= szArial;
			pFI[IFONT_TMSNEWRMN].szFontName = szTimesNewRoman;
			pFI[IFONT_SYMBOL].szFontName	= szSymbol;
			pFI[IFONT_SYSTEM].szFontName	= szSystem;
			g_cFontInfo			 = cfontsDflt;
		}
		g_pFontInfo = pFI;
		g_cFontInfoMax += 8;
	}											

	LONG	cb = (wcslen(pFontName) + 1)*sizeof(WCHAR);
	WCHAR *	pch = (WCHAR *)PvAlloc(cb, GMEM_MOVEABLE);

	if(!pch)
		return IFONT_ARIAL;					// Out of memory...

	g_pFontInfo[g_cFontInfo].szFontName = pch;
	CopyMemory((void *)pch, pFontName, cb);
	return g_cFontInfo++;
}

/*
 *	GetFontName(iFont)
 *
 *	@func
 *		return fontname given by g_pFontInfo[iFont].szFontName.
 *
 *	@rdesc
 *		fontname corresponding to fontname index iFont
 */
const WCHAR *GetFontName(
	LONG iFont)
{
	return (iFont < g_cFontInfo) ? g_pFontInfo[iFont].szFontName : NULL;
}

/*
 *	SetFontLegitimateSize(iFont, fUIFont, iSize)
 *
 *	@func
 *		Set the legitimate size (readable smallest size to use) of a given font
 */
BOOL SetFontLegitimateSize(
	LONG 	iFont,
	BOOL	fUIFont,
	BYTE	bSize,
	int		cpg)
{
	if (iFont < g_cFontInfo)
	{
		// Far East wanted to do it per codepage.
		//
		// FUTURE: Bear in mind that this approach is bug-prone. Once there's
		// any new FE font created with different metric from the existing one.
		// Font scaling will not perform well or even broken for such font [wchao].

		g_pFontInfo[iFont].ff.fScaleByCpg = W32->IsFECodePage(cpg);

		if (fUIFont)
		{
			if (!g_pFontInfo[iFont].bSizeUI)
				g_pFontInfo[iFont].bSizeUI = bSize;
			else
				// more than one legit size were updated per font,
				// We fallback to the codepage-driven approach.
				g_pFontInfo[iFont].ff.fScaleByCpg = g_pFontInfo[iFont].bSizeUI != bSize;
		}
		else
		{
			if (!g_pFontInfo[iFont].bSizeNonUI)
				g_pFontInfo[iFont].bSizeNonUI = bSize;
			else
				g_pFontInfo[iFont].ff.fScaleByCpg = g_pFontInfo[iFont].bSizeNonUI != bSize;
		}
		return TRUE;
	}
	return FALSE;
}

BYTE GetFontLegitimateSize(
	LONG	iFont,
	BOOL	fUIFont,
	int		cpg)			// requested size for given codepage
{
	SHORT	iDefFont;
	BYTE	bDefPaf;
	BYTE	yHeight = 0;

	if (iFont < g_cFontInfo && !g_pFontInfo[iFont].ff.fScaleByCpg)
		yHeight = fUIFont ? g_pFontInfo[iFont].bSizeUI : g_pFontInfo[iFont].bSizeNonUI;

	if (!yHeight && fc().GetInfoFlags(iFont).fNonBiDiAscii)
	{
		// non-BiDi ASCII font uses table font (of the same charset) legitimate height

		DWORD	dwSig = GetFontSignatureFromFace(iFont) & ~((fASCII | fFE) >> 8);
		int 	cpg = GetCodePage(GetFirstAvailCharSet(dwSig));
		
		W32->GetPreferredFontInfo(cpg, fUIFont ? true : false, iDefFont, yHeight, bDefPaf);
		SetFontLegitimateSize(iFont, fUIFont ? true : false, yHeight ? yHeight : fUIFont ? 8 : 10, cpg);
	}

	if (!yHeight)
	{
		if (fc().GetInfoFlags(iFont).fThaiDTP)
		{
			cpg = THAI_INDEX;
			fUIFont = FALSE;
		}
		W32->GetPreferredFontInfo(cpg, fUIFont ? true : false, iDefFont, yHeight, bDefPaf);
	}

	return yHeight ? yHeight : fUIFont ? 8 : 10;
}

/*
 *	GetTextCharsetInfoPri(hdc, pFontSig, dwFlags)
 *
 *	@func
 *		Wrapper to GDI's GetTextCharsetInfo. This to handle BiDi old-style fonts
 */
UINT GetTextCharsetInfoPri(
	HDC				hdc,
	FONTSIGNATURE*	pFontSig,
	DWORD			dwFlags)
{
	OUTLINETEXTMETRICA 	otm;
	INT					uCharSet = -1;

	if (pFontSig && GetOutlineTextMetricsA(hdc, sizeof(OUTLINETEXTMETRICA), &otm))
	{
		ZeroMemory (pFontSig, sizeof(FONTSIGNATURE));

		switch (otm.otmfsSelection & 0xFF00)
		{
			case 0xB200:	// Arabic Simplified
			case 0xB300:	// Arabic Traditional
			case 0xB400:	// Arabic Old UDF
				uCharSet = ARABIC_CHARSET; break;
			case 0xB100:	// Hebrew Old style
				uCharSet = HEBREW_CHARSET;
		}
	}
	if (uCharSet == -1)
		uCharSet = GetTextCharsetInfo(hdc, pFontSig, dwFlags);

	if (uCharSet == DEFAULT_CHARSET)
		uCharSet = ANSI_CHARSET;	// never return ambiguous

	return (UINT)uCharSet;
}


/*
 *	GetFontSignatureFromFace(iFont, DWORD* pdwFontSig)
 *
 *	@func
 *		Giving font signature matching the index of given facename.
 *	    This signature may not match the one in Cccs since this is the
 *		signature of the font of given facename. The Cccs one is
 *		per GDI realization.
 *
 *	@rdesc
 *		- font signature if pdwFontSig is NULL.
 *		- If pdwFontSig != NULL. It's a boolean.
 *			ZERO means returned signature is not sensible by following reasons
 *			 1. Bad facename (junk like "!@#$" or name that doesnt exist in the system)
 *			 2. Given face doesnt support even one valid ANSI codepage (symbol fonts i.e, Marlett)
 */
DWORD GetFontSignatureFromFace(
	int 		iFont,
	DWORD*		pdwFontSig)
{
	Assert((unsigned)iFont < (unsigned)g_cFontInfo);

	DWORD 			dwFontSig = g_pFontInfo[iFont].dwFontSig;
	FONTINFO_FLAGS	ff;

	ff.wFlags = g_pFontInfo[iFont].ff.wFlags;

	if(!ff.fCached)
	{
		LOGFONT	lf;
		HDC	  	hdc = GetDC(NULL);
		WCHAR*	pwchTag = lf.lfFaceName;
		int		i = 0;

		ZeroMemory(&lf, sizeof(LOGFONT));
	
		wcscpy(lf.lfFaceName, GetFontName(iFont));

		// exclude Win95's tag name e.g. "Arial(Greek)"
		while (pwchTag[i] && pwchTag[i] != '(')
			i++;
		if(pwchTag[i] && i > 0)
		{
			while (i > 0 && pwchTag[i-1] == 0x20)
				i--;
			pwchTag[i] = 0;
		}

		lf.lfCharSet = DEFAULT_CHARSET;
	
		// obtain a charset supported by given facename
		// to force GDI gives facename priority over charset.
		W32->GetFacePriCharSet(hdc, &lf);	
	
		HFONT hfont = CreateFontIndirect(&lf);
		if(hfont)
		{
			HFONT hfontOld = SelectFont(hdc, hfont);
			WCHAR szNewFaceName[LF_FACESIZE];
	
			GetTextFace(hdc, LF_FACESIZE, szNewFaceName);
	
			if(!wcsicmp(szNewFaceName, lf.lfFaceName) ||		// Got it
				((GetCharFlags(szNewFaceName[0]) & fFE) &&		// or Get back FE font name for English name
				 (GetCharFlags(lf.lfFaceName[0]) & fASCII)))	//	because NT5 supports dual font names.
			{
				CHARSETINFO csi;
	
				// Try to get FONTSIGNATURE data
				UINT 	uCharSet = GetTextCharsetInfoPri(hdc, &(csi.fs), 0);
				DWORD	dwUsb0 = W32->OnWin9x() ? 0 : csi.fs.fsUsb[0];

				if ((csi.fs.fsCsb[0] | dwUsb0) ||
					TranslateCharsetInfo((DWORD *)(DWORD_PTR)uCharSet, &csi, TCI_SRCCHARSET))
				{
					CUniscribe* 	pusp;
					SCRIPT_CACHE	sc = NULL;
					WORD			wGlyph;
	
					dwFontSig = csi.fs.fsCsb[0];

					// Also look at Unicode subrange if available
					// FUTURE: we may want to drive Unicode ranges with a
					// table approach, i.e., use for loop shifting dwUsb0 right
					// to convert each bit into an index into a table of BYTEs
					// that return the appropriate script index for rgCpgCharSet:
					//
					//	for(LONG i = 0; dwUsb0; dwUsb0 >>= 1, i++)
					//	{
					//		static const BYTE iScript[32] = {...};
					//		if(dwUsb0 & 1)
					//			dwFontSig |= W32->GetFontSigFromScript(iScript[i]);
					//	}
					if (dwUsb0 & 0x00008000)
						dwFontSig |= fDEVANAGARI >> 8;
					if (dwUsb0 & 0x00100000)
						dwFontSig |= fTAMIL >> 8;
					if (dwUsb0 & 0x00000400)
						dwFontSig |= fARMENIAN >> 8;
					if (dwUsb0 & 0x04000000)
						dwFontSig |= fGEORGIAN >> 8;

					if((dwFontSig & fCOMPLEX_SCRIPT >> 8) && !(dwFontSig & fHILATIN1 >> 8)
						&& (pusp = GetUniscribe()))
					{
						// signature says no Latin-1 support

						// Search for the 'a' and '0' glyph in the font to determine if the font
						// supports ASCII or European Digit. This is necessary to overcome
						// the font having incomplete font signature.
						//
						if (ScriptGetCMap(hdc, &sc, L"a", 1, 0, &wGlyph) == S_OK)
							dwFontSig |= fASCIIUPR >> 8;

						if (ScriptGetCMap(hdc, &sc, L"0", 1, 0, &wGlyph) == S_OK)
							dwFontSig |= fBELOWX40 >> 8;

						if (!IsBiDiCharSet(uCharSet) &&
							(dwFontSig & (fASCII >> 8)) == fASCII >> 8)
							ff.fNonBiDiAscii = 1;		// non-BiDi ASCII font

						ScriptFreeCache(&sc);
					}

					if (dwFontSig & fHILATIN1 >> 8)
						dwFontSig |= fASCII >> 8;	// fLATIN1 has 3 bits

					// HACK for symbol font. We assign 0x04000(fSYMBOL >> 8) for Symbol font signature.
					if (uCharSet == SYMBOL_CHARSET && !(dwFontSig & 0x3fffffff))
						dwFontSig |= fSYMBOL >> 8;
				}
			}
			else
			{
				ff.fBadFaceName = TRUE;
			}

			TEXTMETRIC tm;

			GetTextMetrics(hdc, &tm);
			ff.fTrueType = tm.tmPitchAndFamily & TMPF_TRUETYPE ? 1 : 0;
			ff.fBitmap = tm.tmPitchAndFamily & (TMPF_TRUETYPE | TMPF_VECTOR | TMPF_DEVICE) ? 0 : 1;

			if (!ff.fBadFaceName && dwFontSig & (fTHAI >> 8))
			{
				// Some heuristic test on Thai fonts.
				// Most Thai fonts will fall to this category currently except for
				// Tahoma and Microsoft Sans Serif.
				ff.fThaiDTP = tm.tmDescent && tm.tmAscent/tm.tmDescent < 3;
			}

			SelectObject(hdc, hfontOld);
			SideAssert(DeleteObject(hfont));
		}
		ReleaseDC(NULL, hdc);
	
		// Cache code pages supported by this font
		ff.fCached = TRUE;
		g_pFontInfo[iFont].dwFontSig = dwFontSig;
		g_pFontInfo[iFont].ff.wFlags = ff.wFlags;
	}

	if (!pdwFontSig)
		return dwFontSig;

	*pdwFontSig = dwFontSig;

	// Exclude bit 30-31 (as system reserved - NT masks 31 as symbol codepage)
	// 22-29 are reserved for alternate ANSI/OEM, as of now we use 21, 22 for Devanagari and Tamil
	return (DWORD)((dwFontSig & 0x3fffffff) && !ff.fBadFaceName);
}

/*
 *	FreeFontNames()
 *
 *	@func
 *		Free fontnames given by g_pFontInfo[i].szFontName allocated by
 *		GetFontNameIndex() as well as g_pFontInfo itself.
 */
void FreeFontNames()
{
	for(LONG i = cfontsDflt; i < g_cFontInfo; i++)
		FreePv((LPVOID)g_pFontInfo[i].szFontName);
	FreePv(g_pFontInfo);
	g_pFontInfo = NULL;
}

SHORT	g_iFontJapanese;
SHORT	g_iFontHangul;
SHORT	g_iFontBig5;
SHORT	g_iFontGB2312;

/*
 *	InitFontCache()
 *	
 *	@func
 *		Initializes font cache.
 *
 *	@devnote
 *		This is exists so reinit.cpp doesn't have to know all about the
 *		font cache.
 */
void InitFontCache()
{
	g_fc = new CFontCache;
	g_fc->Init();
}

/*
 *	FreeFontCache()
 *	
 *	@mfunc
 *		Frees font cache.
 *
 *	@devnote
 *		This is exists so reinit.cpp doesn't have to know all about the
 *		font cache.
 */
void FreeFontCache()
{
	delete g_fc;
	g_fc = NULL;
	FreeFontNames();
}

/*
 *	CFontCache & fc()
 *	
 *	@func
 *		initialize the global g_fc.
 *	@comm
 *		current #defined to store 16 logical fonts and
 *		respective character widths.
 *		
 */
CFontCache & fc()
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "fc");
    return *g_fc;
}

FONTINFO_FLAGS CFontCache::GetInfoFlags(int ifont)
{
	if (!g_pFontInfo[ifont].ff.fCached)
		GetFontSignatureFromFace(ifont);

	return g_pFontInfo[ifont].ff;
}


// ===================================  CFontCache  ====================================
/*
 *	CFontCache::Init()
 *	
 *	@mfunc
 *		Initializes font cache.
 *
 *	@devnote
 *		This is not a constructor because something bad seems to happen
 *		if we try to construct a global object.
 */
void CFontCache::Init()
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CFontCache::CFontCache");

	_dwAgeNext = 0;
}

/*
 *	CFontCache::MakeHashKey(pCF)
 *	
 *	@mfunc
 *		Build a hash key for quick searches for a CCcs matching
 *		the pCF.
 *		Format:
 *		iFont : 14
 *		Bold/Italic : 2
 *      Height : 16
 *
 */
CCSHASHKEY CFontCache::MakeHashKey(const CCharFormat *pCF)
{
	CCSHASHKEY ccshashkey;
	ccshashkey = pCF->_iFont | ((pCF->_dwEffects & 3) << 14);
	ccshashkey |= pCF->_yHeight << 16;
	return ccshashkey;
}

/*
 *	CFontCache::GetCcs(pCF, dypInch, yPixelsPerInch)
 *	
 *	@mfunc
 *		Search the font cache for a matching logical font and return it.
 *		If a match is not found in the cache,  create one.
 *
 *	@rdesc
 *		A logical font matching the given CHARFORMAT info.
 *
 *	@devnote
 *		The calling chain must be protected by a CLock, since this present
 *		routine access the global (shared) FontCache facility.
 */
CCcs* CFontCache::GetCcs(
	const CCharFormat *const pCF,	//@parm description of desired logical font
	const LONG dypInch,				//@parm Y pixels per inch
	HDC hdc,						//@parm HDC font is to be created for
	BOOL fForceTrueType)			//@parm Force a TrueType font to be used
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CFontCache::GetCcs");
									//  display font
	const CCcs * const	pccsMost = &_rgccs[FONTCACHESIZE - 1];
	CCcs *				pccs;
    CCSHASHKEY			ccshashkey;
	int					iccsHash;

	CCharFormat CF = *pCF;

	if (fForceTrueType)
	{
		//On Win '9x Thai/Vietnamese, you cannot force truetype fonts! Therefore,
		//we will force Tahoma if the font doesn't support the right charset.
		if (W32->OnWin9x())
		{
			UINT acp = GetACP();
			if (acp == 1258 || acp == 874)
			{
				DWORD fontsig = GetFontSignatureFromFace(CF._iFont);
				if (CF._bCharSet == THAI_CHARSET && ((fontsig & fTHAI >> 8) == 0) ||
					CF._bCharSet == VIETNAMESE_CHARSET && ((fontsig & fVIETNAMESE >> 8) == 0) ||
					!g_fc->GetInfoFlags(pCF->_iFont).fTrueType)
				{
					CF._iFont = GetFontNameIndex(szTahoma);
				}
			}
		}
		else if (!g_fc->GetInfoFlags(pCF->_iFont).fTrueType)
			CF._dwEffects |= CFE_TRUETYPEONLY;
	}

	if (hdc == NULL)
		hdc = W32->GetScreenDC();

	// Change CF._yHeight in the case of sub/superscript
	if(CF._dwEffects & (CFE_SUPERSCRIPT | CFE_SUBSCRIPT))
		 CF._yHeight = 2*CF._yHeight/3;

	//Convert CCharFormat into logical units (round)
	CF._yHeight = (CF._yHeight * dypInch + LY_PER_INCH / 2) / LY_PER_INCH;
	if (CF._yHeight == 0)
		CF._yHeight = 1;

	ccshashkey = MakeHashKey(&CF);

	// Check our hash before going sequential.
	iccsHash = ccshashkey % CCSHASHSEARCHSIZE;
	if(ccshashkey == quickHashSearch[iccsHash].ccshashkey)
	{
		pccs = quickHashSearch[iccsHash].pccs;
		if(pccs && pccs->_fValid)
		{
	        if(pccs->Compare(&CF, hdc))
                goto matched;
		}
	}
	else	//Setup this hash hint for next time
		quickHashSearch[iccsHash].ccshashkey = ccshashkey;


	// Sequentially search ccs for same character format
	for(pccs = &_rgccs[0]; pccs <= pccsMost; pccs++)
	{
		if(pccs->_ccshashkey == ccshashkey && pccs->_fValid)
		{
	        if(!pccs->Compare(&CF, hdc))
                continue;

			quickHashSearch[iccsHash].pccs = pccs;

		matched:
			//$ FUTURE: make this work even with wrap around of dwAgeNext
			// Mark as most recently used if it isn't already in use.
			if(pccs->_dwAge != _dwAgeNext - 1)
				pccs->_dwAge = _dwAgeNext++;
			pccs->_cRefs++;		// bump up ref. count
			return pccs;
		}
	}

	// We did not find a match: init a new font cache.
	pccs = GrabInitNewCcs(&CF, hdc);
	quickHashSearch[iccsHash].pccs = pccs;
	pccs->_ccshashkey = ccshashkey;
	pccs->_fForceTrueType = (CF._dwEffects & CFE_TRUETYPEONLY) ? TRUE : FALSE;
	return pccs;
}

/*
 *	CFontCache::GrabInitNewCcs(pCF)
 *	
 *	@mfunc
 *		create a logical font and store it in our cache.
 *
 *	@rdesc
 *		New CCcs created
 */
CCcs* CFontCache::GrabInitNewCcs(
	const CCharFormat * const pCF,	//@parm description of desired logical font
	HDC	hdc)
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CFontCache::GrabInitNewCcs");

	DWORD				dwAgeOldest = 0xffffffff;
	CCcs *				pccs;
	const CCcs * const	pccsMost = &_rgccs[FONTCACHESIZE - 1];
	CCcs *				pccsOldest = NULL;

	// Look for unused entry and oldest in use entry
	for(pccs = &_rgccs[0]; pccs <= pccsMost && pccs->_fValid; pccs++)
		if(pccs->_cRefs == 0 && pccs->_dwAge < dwAgeOldest)
		{
			dwAgeOldest = pccs->_dwAge;
			pccsOldest = pccs;
		}

	if(pccs > pccsMost)		// Didn't find an unused entry, use oldest entry
	{
		pccs = pccsOldest;
		if(!pccs)
		{
			AssertSz(FALSE, "CFontCache::GrabInitNewCcs oldest entry is NULL");
			return NULL;
		}
	}
	// Initialize new CCcs
	pccs->_hdc = hdc;
	if(!pccs->Init(pCF))
		return NULL;

	pccs->_cRefs++;
	return pccs;
}

// =============================  CCcs  class  ===================================================
/*
 *	BOOL CCcs::Init()
 *	
 *	@mfunc
 *		Init one font cache object. The global font cache stores
 *		individual CCcs objects.
 */
BOOL CCcs::Init (
	const CCharFormat * const pCF)	//@parm description of desired logical font
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CCcs::Init");

	if(_fValid)
		Free();				// recycle already in-use fonts.

	if(MakeFont(pCF))
	{
		_iFont = pCF->_iFont;
		_dwAge = g_fc->_dwAgeNext++;
		_fValid = TRUE;			// successfully created a new font cache.
	}
	return _fValid;
}

/*
 *	void CCcs::Free()
 *	
 *	@mfunc
 *		Free any dynamic memory allocated by an individual font's cache.
 */
void CCcs::Free()
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CCcs::Free");

	Assert(_fValid);

	_widths.Free();

	if(_hfont)
		DestroyFont();

	if (_sc && g_pusp)
		ScriptFreeCache(&_sc);

	_fValid = FALSE;
	_cRefs = 0;
}

/*
 *	CCcs::BestCharSet(bCharSet, bCharSetDefault)
 *
 *	@mfunc
 *		This function returns the best charset that the currently selected font
 *		is capable of rendering. If the currently selected font cannot support
 *		the requested charset, then the function returns bCharSetDefault, which
 *		is generally taken from the charformat.
 *		
 *	@rdesc
 *		The closest charset to bCharSet that can be rendered by the current
 *		font.
 *
 *	@devnote
 *		Currently this function is only used with plain text, however I don't
 *		believe there is any special reason it couldn't be used to improve
 *		rendering of rich text as well.
 */
BYTE CCcs::BestCharSet(BYTE bCharSet, BYTE bCharSetDefault, int fFontMatching)
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CCcs::BestCharSet");

	// Does desired charset match currently selected charset or is it
	// supported by the currently selected font?
	if((bCharSet != _bCharSet || !bCharSet) &&
		(fFontMatching == MATCH_CURRENT_CHARSET || !(_dwFontSig & GetFontSig(bCharSet))))
	{
		// If desired charset is not selected and we can't switch to it,
		// switch to fallback charset (probably from backing store).
		return bCharSetDefault;
	}

	// We already match desired charset, or it is supported by the font.
	// Either way, we can just return the requested charset.
	return bCharSet;
}


/* 	
 *	CCcs::FillWidth (ch, dxp)
 *
 *	@mfunc
 *		Fill in this CCcs with metrics info for given device
 *
 *	@rdesc
 *		TRUE if OK, FALSE if failed
 */
BOOL CCcs::FillWidth(
	WCHAR ch, 		//@parm WCHAR character we need a width for.
	LONG &dxp)	//@parm the width of the character
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CCcs::FillWidths");
	AssertSz(_hfont, "CCcs::Fill - CCcs has no font");

	HFONT hfontOld = SelectFont(_hdc, _hfont);
	BOOL fRes = _widths.FillWidth(_hdc, ch, _xOverhangAdjust, dxp, _wCodePage, _xAveCharWidth);

	SelectFont(_hdc, hfontOld);
	return fRes;
}

/* 	
 *	BOOL CCcs::MakeFont(pCF)
 *
 *	@mfunc
 *		Wrapper, setup for CreateFontIndirect() to create the font to be
 *		selected into the HDC.
 *
 *	@devnote The pCF here is in logical units
 *
 *	@rdesc
 *		TRUE if OK, FALSE if allocation failure
 */
BOOL CCcs::MakeFont(
	const CCharFormat * const pCF)	//@parm description of desired logical font
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CCcs::MakeFont");
	LOGFONT	lf;
	ZeroMemory(&lf, sizeof(lf));

	_bCMDefault = pCF->_dwEffects & CFE_RUNISDBCS ? CVT_LOWBYTE : CVT_NONE;

	_yHeightRequest = pCF->_yHeight;
	_bCharSetRequest = pCF->_bCharSet;

	lf.lfHeight = -_yHeightRequest;

	if(pCF->_wWeight)
		_weight = pCF->_wWeight;
	else
		_weight	= (pCF->_dwEffects & CFE_BOLD) ? FW_BOLD : FW_NORMAL;

	lf.lfWeight	 = _weight;
	lf.lfItalic	 = _fItalic = (pCF->_dwEffects & CFE_ITALIC) != 0;
	lf.lfCharSet = _bCMDefault == CVT_LOWBYTE ? ANSI_CHARSET : GetGdiCharSet(pCF->_bCharSet);

	lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
	if (pCF->_dwEffects & CFE_TRUETYPEONLY)
	{
		lf.lfOutPrecision = OUT_TT_ONLY_PRECIS;
		if (!W32->OnWin9x() && g_fc->GetInfoFlags(pCF->_iFont).fTrueType)
			lf.lfOutPrecision = OUT_SCREEN_OUTLINE_PRECIS;
	}
	lf.lfClipPrecision	= CLIP_DEFAULT_PRECIS | CLIP_DFA_OVERRIDE;

	lf.lfPitchAndFamily = _bPitchAndFamily = pCF->_bPitchAndFamily;

	// If family is virtual BiDi family (FF_BIDI), replace by FF_ROMAN
	if((lf.lfPitchAndFamily & 0xF0) == (FF_BIDI << 4))
		lf.lfPitchAndFamily = (FF_ROMAN << 4) | (lf.lfPitchAndFamily & 0xF);

	// If the run is DBCS, that means the font's codepage is not available in
	// this system.  Use the English ANSI codepage instead so we will display
	// ANSI characters correctly.  NOTE: _wCodePage is only used for Win95.
	_wCodePage = (WORD)GetCodePage(lf.lfCharSet);

	wcscpy(lf.lfFaceName, GetFontName(pCF->_iFont));

	// In BiDi system, always create ANSI bitmap font with system charset
	BYTE 	bSysCharSet = W32->GetSysCharSet();

	if (IsBiDiCharSet(bSysCharSet) && lf.lfCharSet == ANSI_CHARSET &&
		fc().GetInfoFlags(pCF->_iFont).fBitmap &&
		!fc().GetInfoFlags(pCF->_iFont).fBadFaceName)
		lf.lfCharSet = bSysCharSet;

	// Reader! A bundle of spagghetti code lies ahead of you!
	// But go on boldly, for these spagghetti are seasoned with
	// lots of comments, and ... good luck to you...

	HFONT	hfontOriginalCharset = NULL;
	BYTE	bOriginalCharset = lf.lfCharSet;
	WCHAR	szNewFaceName[LF_FACESIZE];

	GetFontWithMetrics(&lf, szNewFaceName);

	if(0 != wcsicmp(szNewFaceName, lf.lfFaceName))					
	{
		BOOL fCorrectFont = FALSE;

		if(lf.lfCharSet == SYMBOL_CHARSET)					
		{
			// #1. if the face changed, and the specified charset was SYMBOL,
			//     but the face name exists and suports ANSI, we give preference
			//     to the face name

			lf.lfCharSet = ANSI_CHARSET;

			hfontOriginalCharset = _hfont;
			GetFontWithMetrics(&lf, szNewFaceName);

			if(0 == wcsicmp(szNewFaceName, lf.lfFaceName))
				// That's right, ANSI is the asnwer
				fCorrectFont = TRUE;
			else
				// No, fall back by default; the charset we got was right
				lf.lfCharSet = bOriginalCharset;
		}
		else if(lf.lfCharSet == DEFAULT_CHARSET && _bCharSet == DEFAULT_CHARSET)
		{
			// #2. If we got the "default" font back, we don't know what it means
			// (could be anything) so we veryfy that this guy's not SYMBOL
			// (symbol is never default, but the OS could be lying to us!!!)
			// we would like to veryfy more like whether it actually gave us
			// Japanese instead of ANSI and labeled it "default"...
			// but SYMBOL is the least we can do

			lf.lfCharSet = SYMBOL_CHARSET;
			wcscpy(lf.lfFaceName, szNewFaceName);

			hfontOriginalCharset = _hfont;
			GetFontWithMetrics(&lf, szNewFaceName);

			if(0 == wcsicmp(szNewFaceName, lf.lfFaceName))
				// That's right, it IS symbol!
				// 'correct' the font to the 'true' one,
				//  and we'll get fMappedToSymbol
				fCorrectFont = TRUE;
				
			// Always restore the charset name, we didn't want to
			// question the original choice of charset here
			lf.lfCharSet = bOriginalCharset;
		}
		else if(lf.lfCharSet == ARABIC_CHARSET || lf.lfCharSet == HEBREW_CHARSET)
		{
			DestroyFont();
			wcscpy(lf.lfFaceName, szNewFaceName);
			GetFontWithMetrics(&lf, szNewFaceName);
			fCorrectFont = TRUE;
		}
		else if(_bConvertMode != CVT_LOWBYTE && IsFECharSet(lf.lfCharSet)
			&& !OnWinNTFE() && !W32->OnWin9xFE())
		{
			const WCHAR *pch = NULL;
			if(_bCharSet != lf.lfCharSet && W32->OnWin9x())
			{
				// On Win95 when rendering to PS driver, we'll get something
				// other than what we asked. So try a known font we got from GDI
				switch (lf.lfCharSet)
				{
					case CHINESEBIG5_CHARSET:
						pch = GetFontName(g_iFontBig5);
						break;

					case SHIFTJIS_CHARSET:
						pch = GetFontName(g_iFontJapanese);
						break;

					case HANGEUL_CHARSET:
						pch = GetFontName(g_iFontHangul);
						break;

					case GB2312_CHARSET:
						pch = GetFontName(g_iFontGB2312);
						break;
				}
			}
			else							// FE Font (from Lang pack)
				pch = szNewFaceName;		//  on a nonFEsystem

			if(pch)
				wcscpy(lf.lfFaceName, pch);
			hfontOriginalCharset = _hfont;		

			GetFontWithMetrics(&lf, szNewFaceName);

			if(0 == wcsicmp(szNewFaceName, lf.lfFaceName))
			{
				// That's right, it IS the FE font we want!
				// 'correct' the font to the 'true' one.
				fCorrectFont = TRUE;
				if(W32->OnWin9x())
				{
					// Save up the GDI font names for later printing use
					switch(lf.lfCharSet)
					{
						case CHINESEBIG5_CHARSET:
							g_iFontBig5 = GetFontNameIndex(lf.lfFaceName);
							break;

						case SHIFTJIS_CHARSET:
							g_iFontJapanese = GetFontNameIndex(lf.lfFaceName);
							break;

						case HANGEUL_CHARSET:
							g_iFontHangul = GetFontNameIndex(lf.lfFaceName);
							break;

						case GB2312_CHARSET:
							g_iFontGB2312 = GetFontNameIndex(lf.lfFaceName);
							break;
					}
				}
			}
		}

		if(hfontOriginalCharset)
		{
			// Either keep old font or new one		
			if(fCorrectFont)
			{
				SideAssert(DeleteObject(hfontOriginalCharset));
			}
			else
			{
				// Fall back to original font
				DestroyFont();
				_hfont = hfontOriginalCharset;
				GetMetrics();
			}
			hfontOriginalCharset = NULL;
		}
	}

RetryCreateFont:
	{
		// Could be that we just plain simply get mapped to symbol.
		// Avoid it
		BOOL fMappedToSymbol =	(_bCharSet == SYMBOL_CHARSET &&
								 lf.lfCharSet != SYMBOL_CHARSET);

		BOOL fChangedCharset = (_bCharSet != lf.lfCharSet &&
								lf.lfCharSet != DEFAULT_CHARSET);

		if(fChangedCharset || fMappedToSymbol)
		{
			// Here, the system did not preserve the font language or mapped
			// our non-symbol font onto a symbol font, which will look awful
			// when displayed.  Giving us a symbol font when we asked for a
			// non-symbol font (default can never be symbol) is very bizarre
			// and means that either the font name is not known or the system
			// has gone complete nuts. The charset language takes priority
			// over the font name.  Hence, I would argue that nothing can be
			// done to save the situation at this point, and we have to
			// delete the font name and retry.

			if (fChangedCharset && lf.lfCharSet == THAI_CHARSET && _bCharSet == ANSI_CHARSET)
			{
				// We have charset substitution entries in Thai platforms that
				// will substitute all the core fonts with THAI_CHARSET to
				// ANSI_CHARSET. This is because we dont have Thai in such fonts.
				// Here we'll internally substitute the core font to Thai default
				// font so it matches its underlying THAI_CHARSET request (wchao).

				SHORT	iDefFont;
				BYTE	yDefHeight;
				BYTE	bDefPaf;

				W32->GetPreferredFontInfo(874, TRUE, iDefFont, (BYTE&)yDefHeight, bDefPaf);

				const WCHAR* szThaiDefault = GetFontName(iDefFont);

				if (szThaiDefault)
				{
					DestroyFont();
					wcscpy(lf.lfFaceName, szThaiDefault);
					GetFontWithMetrics(&lf, szNewFaceName);

					goto GetOutOfHere;
				}
			}

			if(!wcsicmp(lf.lfFaceName, szFontOfChoice))
			{
				// We've been here already; no font with an appropriate
				// charset is on the system. Try getting the ANSI one for
				// the original font name. Next time around, we'll null
				// out the name as well!!
				if (lf.lfCharSet == ANSI_CHARSET)
				{
					TRACEINFOSZ("Asking for ANSI ARIAL and not getting it?!");

					// Those Win95 guys have definitely outbugged me
					goto GetOutOfHere;
				}

				DestroyFont();
				wcscpy(lf.lfFaceName, GetFontName(pCF->_iFont));
				lf.lfCharSet = ANSI_CHARSET;
			}
			else
			{
				DestroyFont();
				wcscpy(lf.lfFaceName, szFontOfChoice);
			}
			GetFontWithMetrics(&lf, szNewFaceName);
			goto RetryCreateFont;
		}
    }

GetOutOfHere:
	if (hfontOriginalCharset)
		SideAssert(DeleteObject(hfontOriginalCharset));

	// If we're really really stuck, just get the system font and hope for the best.
	if(!_hfont)
		_hfont = W32->GetSystemFont();

	Assert(_hfont);
	// Cache essential FONTSIGNATURE and GetFontLanguageInfo() information
	_dwFontSig	= 0;

	if(_hfont)
	{
		CHARSETINFO csi;
		HFONT hfontOld = SelectFont(_hdc, _hfont);
		UINT		uCharSet;

		// Try to get FONTSIGNATURE data
		uCharSet = GetTextCharsetInfo(_hdc, &(csi.fs), 0);
		if(!(csi.fs.fsCsb[0] | csi.fs.fsCsb[1] | csi.fs.fsUsb[0]))
		{
			// We should only get here if the font is non-TrueType; See
			// GetTextCharsetInfo() for details. In this case we use
			// TranslateCharsetInfo() to fill in the data for us.
			TranslateCharsetInfo((DWORD *)(DWORD_PTR)uCharSet, &csi, TCI_SRCCHARSET);
		}

		// Cache ANSI code pages supported by this font
		_dwFontSig = csi.fs.fsCsb[0];
		SelectFont(_hdc, hfontOld);
	}

	return TRUE;
}

/*
 *	HFONT CCcs::GetFontWithMetrics (szNewFaceName)
 *	
 *	@mfunc
 *		Get metrics used by the measurer and renderer and the new face name.
 *
 *	@rdesc
 *		HFONT if successful
 */
HFONT CCcs::GetFontWithMetrics (LOGFONT *plf,
	WCHAR* szNewFaceName)
{
	_hfont = CreateFontIndirect(plf);

    if(_hfont)
		GetMetrics(szNewFaceName);

	return (_hfont);
}

/*
 *	CCcs::GetOffset(pCF, lZoomNumerator, lZoomDenominator, pyOffset, pyAdjust);
 *	
 *	@mfunc
 *		Return the offset information for
 *
 *	@rdesc
 *		void
 *
 *	@comm
 *		Return the offset value (used in line height calculations)
 *		and the amount to raise	or lower the text because of superscript
 *		or subscript considerations.
 */
void CCcs::GetOffset(const CCharFormat * const pCF, LONG dypInch,
					 LONG *pyOffset, LONG *pyAdjust)
{
	*pyOffset = 0;
	*pyAdjust = 0;

	if (pCF->_yOffset)
		*pyOffset = MulDiv(pCF->_yOffset, dypInch, LY_PER_INCH);

	if (pCF->_dwEffects & CFE_SUPERSCRIPT)
		*pyAdjust = _yOffsetSuperscript;
	else if (pCF->_dwEffects & CFE_SUBSCRIPT)
		*pyAdjust = _yOffsetSubscript;
}

/*
 *	BOOL CCcs::GetMetrics()
 *	
 *	@mfunc
 *		Get metrics used by the measurer and renderer.
 *
 *	@rdesc
 *		TRUE if successful
 *
 *	@comm
 *		These are in logical coordinates which are dependent
 *		on the mapping mode and font selected into the hdc.
 */
BOOL CCcs::GetMetrics(WCHAR *szNewFaceName)
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CCcs::GetMetrics");

	HFONT		hfontOld;
	BOOL		fRes = TRUE;
	TEXTMETRIC	tm;

	if (szNewFaceName)
		*szNewFaceName = 0;

	AssertSz(_hfont, "No font has been created.");

	hfontOld = SelectFont(_hdc, _hfont);

    if(!hfontOld)
    {
        DestroyFont();
        return FALSE;
    }

	if (szNewFaceName)
		GetTextFace(_hdc, LF_FACESIZE, szNewFaceName);

	if(!GetTextMetrics(_hdc, &tm))
	{
		SelectFont(_hdc, hfontOld);
    	DestroyFont();
		return FALSE;
	}

	// the metrics, in logical units, dependent on the map mode and font.
	_yHeight		= (SHORT) tm.tmHeight;
	_yDescent		= (SHORT) tm.tmDescent;
	_xAveCharWidth	= (SHORT) tm.tmAveCharWidth;
	_xOverhangAdjust= (SHORT) tm.tmOverhang;

	//FUTURE (keithcu) Get these metrics from the font.
	//FUTURE (keithcu) The height of the line if the font is superscript
	//should be the NORMAL height of the text.
	_yOffsetSuperscript = _yHeight * 2 / 5;
	_yOffsetSubscript = -_yDescent * 3 / 5;

	_xOverhang = 0;
	_xUnderhang	= 0;
	if(_fItalic)
	{
		_xOverhang =  SHORT((tm.tmAscent + 1) >> 2);
		_xUnderhang =  SHORT((tm.tmDescent + 1) >> 2);
	}

	// if fix pitch, the tm bit is clear
	_fFixPitchFont = !(TMPF_FIXED_PITCH & tm.tmPitchAndFamily);

	_bCharSet = tm.tmCharSet;
	_fFECharSet = IsFECharSet(_bCharSet);

	// Use convert-mode proposed by CF, for which we are creating the font and
	// then tweak as necessary below.
	_bConvertMode = _bCMDefault;

	// If SYMBOL_CHARSET is used, use the A APIs with the low bytes of the
	// characters in the run
	if(_bCharSet == SYMBOL_CHARSET)
		_bConvertMode = CVT_LOWBYTE;

	else if (_bConvertMode == CVT_NONE)
		_bConvertMode = W32->DetermineConvertMode(_hdc, tm.tmCharSet );

	W32->CalcUnderlineInfo(_hdc, this, &tm);

	SelectFont(_hdc, hfontOld);
	return fRes;
}

/* 	
 *	CCcs::DestroyFont()
 *
 *	@mfunc
 *		Destroy font handle for this CCcs
 */
void CCcs::DestroyFont()
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CCcs::DestroyFont");

	// clear out any old font
	if(_hfont)
	{
		SideAssert(DeleteObject(_hfont));
		_hfont = 0;
	}
}

/*
 *	CCcs::Compare (pCF,	lfHeight)
 *
 *	@mfunc
 *		Compares this font cache with the font properties of a
 *      given CHARFORMAT

 *	@devnote The pCF size here is in logical units
 *
 *	@rdesc
 *		FALSE iff did not match exactly.
 */
BOOL CCcs::Compare (
	const CCharFormat * const pCF,	//@parm Description of desired font
	HDC	hdc)
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CCcs::Compare");

	BOOL result =
		_iFont			== pCF->_iFont &&
		_yHeightRequest	== pCF->_yHeight &&
		(_bCharSetRequest == pCF->_bCharSet || _bCharSet == pCF->_bCharSet) &&
        _weight			== pCF->_wWeight &&
		_fForceTrueType == ((pCF->_dwEffects & CFE_TRUETYPEONLY) ? TRUE : FALSE) &&
	    _fItalic		== ((pCF->_dwEffects & CFE_ITALIC) != 0) &&
		_hdc			== hdc &&
        _bPitchAndFamily == pCF->_bPitchAndFamily &&
		(!(pCF->_dwEffects & CFE_RUNISDBCS) || _bConvertMode == CVT_LOWBYTE);

	return result;
}

// =========================  WidthCache by jonmat  =========================
/*
 *	CWidthCache::CheckWidth(ch, dxp)
 *	
 *	@mfunc
 *		check to see if we have a width for a WCHAR character.
 *
 *	@comm
 *		Used prior to calling FillWidth(). Since FillWidth
 *		may require selecting the map mode and font in the HDC,
 *		checking here first saves time.
 *
 *	@comm
 *		Statistics are maintained to determine when to
 *		expand the cache. The determination is made after a constant
 *		number of calls in order to make calculations faster.
 *
 *	@rdesc
 *		returns TRUE if we have the width of the given WCHAR.
 */
BOOL CWidthCache::CheckWidth (
	const WCHAR ch,	//@parm char, can be Unicode, to check width for.
	LONG &dxp)	//@parm Width of character
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CWidthCache::CheckWidth");
	BOOL	fExist;

	//30,000 FE characters all have the same width
	if (FLookasideCharacter(ch))
	{
		FetchLookasideWidth(ch, dxp);
		return dxp != 0;
	}

	const	CacheEntry * pWidthData = GetEntry ( ch );

	fExist = (ch == pWidthData->ch		// Have we fetched the width?
				&& pWidthData->width);	//  only because we may have ch == 0.

	dxp = fExist ? pWidthData->width : 0;

	if(!_fMaxPerformance)			//  if we have not grown to the max...
	{
		_accesses++;
		if(!fExist)						// Only interesting on collision.
		{
			if(0 == pWidthData->width)	// Test width not ch, 0 is valid ch.
			{
				_cacheUsed++;		// Used another entry.
				AssertSz( _cacheUsed <= _cacheSize+1, "huh?");
			}
			else
				_collisions++;		// We had a collision.

			if(_accesses >= PERFCHECKEPOCH)
				CheckPerformance();	// After some history, tune cache.
		}
	}
#ifdef DEBUG							// Continue to monitor performance
	else
	{
		_accesses++;
		if(!fExist)						// Only interesting on collision.
		{
			if(0 == pWidthData->width)	// Test width not ch, 0 is valid ch.
			{
				_cacheUsed++;		// Used another entry.
				AssertSz( _cacheUsed <= _cacheSize+1, "huh?");
			}
			else
				_collisions++;		// We had a collision.
		}

		if(_accesses > PERFCHECKEPOCH)
		{
			_accesses = 0;
			_collisions = 0;
		}
	}
#endif

	return fExist;
}

/*
 *	CWidthCache::CheckPerformance()
 *	
 *	@mfunc
 *		check performance and increase cache size if deemed necessary.
 *
 *	@devnote
 *		To calculate 25% collision rate, we make use of the fact that
 *		we are only called once every 64 accesses. The inequality is
 *		100 * collisions / accesses >= 25. By converting from 100ths to
 *		8ths, the ineqaulity becomes (collisions << 3) / accesses >= 2.
 *		Substituting 64 for accesses, this becomes (collisions >> 3) >= 2.
 */
void CWidthCache::CheckPerformance()
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CWidthCache::CheckPerformance");

	if(_fMaxPerformance)				// Exit if already grown to our max.
		return;

	// Grow the cache when cacheSize > 0 && 75% utilized or approx 25%
	// collision rate
	if (_cacheSize > DEFAULTCACHESIZE &&
		 (_cacheSize >> 1) + (_cacheSize >> 2) < _cacheUsed ||
		(_collisions >> COLLISION_SHIFT) >= 2)
	{
		GrowCache( &_pWidthCache, &_cacheSize, &_cacheUsed );
	}
	_collisions	= 0;				// This prevents wraps but makes
	_accesses	= 0;				//  calc a local rate, not global.
										
	if(_cacheSize >= maxCacheSize)// Note if we've max'ed out
		_fMaxPerformance = TRUE;

	AssertSz( _cacheSize <= maxCacheSize, "max must be 2^n-1");
	AssertSz( _cacheUsed <= _cacheSize+1, "huh?");
}

/*
 *	CWidthCache::GrowCache(ppWidthCache, pCacheSize, pCacheUsed)
 *	
 *	@mfunc
 *		Exponentially expand the size of the cache.
 *
 *	@comm
 *		The cache size must be of the form 2^n as we use a
 *		logical & to get the hash MOD by storing 2^n-1 as
 *		the size and using this as the modulo.
 *
 *	@rdesc
 *		Returns TRUE if we were able to allocate the new cache.
 *		All in params are also out params.
 *		
 */
BOOL CWidthCache::GrowCache(
	CacheEntry **ppWidthCache,	//@parm cache
	INT *		pCacheSize,		//@parm cache's respective size.
	INT *		pCacheUsed)		//@parm cache's respective utilization.
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CWidthCache::GrowCache");

	CacheEntry		*pNewWidthCache, *pOldWidthCache, *pWidthData;
	INT 			j, newCacheSize, newCacheUsed;
	WCHAR			ch;
	
	j = *pCacheSize;						// Allocate cache of 2^n.
	newCacheSize = max ( INITIALCACHESIZE, (j << 1) + 1);
	pNewWidthCache = (CacheEntry *)
			PvAlloc( sizeof(CacheEntry) * (newCacheSize + 1 ), GMEM_ZEROINIT);

	if(pNewWidthCache)
	{
		newCacheUsed = 0;
		*pCacheSize = newCacheSize;			// Update out params.
		pOldWidthCache = *ppWidthCache;
		*ppWidthCache = pNewWidthCache;
		for (; j >= 0; j--)					// Move old cache info to new.
		{
			ch = pOldWidthCache[j].ch;
			if ( ch )
			{
				pWidthData			= &pNewWidthCache [ch & newCacheSize];
				if ( 0 == pWidthData->ch )
					newCacheUsed++;			// Used another entry.
				pWidthData->ch		= ch;
				pWidthData->width	= pOldWidthCache[j].width;
			}
		}
		*pCacheUsed = newCacheUsed;			// Update out param.
											// Free old cache.
		if (pOldWidthCache < &_defaultWidthCache[0] ||
			pOldWidthCache >= &_defaultWidthCache[DEFAULTCACHESIZE+1])
		{
			FreePv(pOldWidthCache);
		}
	}
	return NULL != pNewWidthCache;
}

/*
 *	CWidthCache::FillWidth(hdc, ch, xOverhang, dxp)
 *	
 *	@mfunc
 *		Call GetCharWidth() to obtain the width of the given char.
 *
 *	@comm
 *		The HDC must be setup with the mapping mode and proper font
 *		selected *before* calling this routine.
 *
 *	@rdesc
 *		Returns TRUE if we were able to obtain the widths.
 */
BOOL CWidthCache::FillWidth(
	HDC			hdc,		//@parm Current HDC we want font info for.
	const WCHAR	ch,			//@parm Char to obtain width for.
	const SHORT xOverhang,	//@parm Equivalent to GetTextMetrics() tmOverhang.
	LONG &		dxp,	//@parm Width of character
	UINT		uiCodePage,	//@parm code page for text	
	INT			iDefWidth)	//@parm Default width to use if font calc's zero
							//width. (Handles Win95 problem).
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CWidthCache::FillWidth");

	if (FLookasideCharacter(ch))
	{
		SHORT *pdxp = IN_RANGE(0xAC00, ch, 0xD79F) ? &_dxpHangul : &_dxpHan;
		W32->REGetCharWidth(hdc, ch, pdxp, uiCodePage, xOverhang, iDefWidth);
		dxp = *pdxp;
		return TRUE;
	}

	CacheEntry * pWidthData = GetEntry (ch);
	W32->REGetCharWidth(hdc, ch, &pWidthData->width, uiCodePage, xOverhang, iDefWidth);
	pWidthData->ch = ch;

	dxp = pWidthData->width;
	return TRUE;
}


/*
 *	CWidthCache::Free()
 *	
 *	@mfunc
 *		Free any dynamic memory allocated by the width cache and prepare
 *		it to be recycled.
 */
void CWidthCache::Free()
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CWidthCache::Free");

	_fMaxPerformance = FALSE;
	_dxpHangul = _dxpHan = 0;
	_cacheSize		= DEFAULTCACHESIZE;
	_cacheUsed		= 0;
	_collisions		= 0;
	_accesses		= 0;
	if(_pWidthCache != &_defaultWidthCache[0])
	{
		FreePv(_pWidthCache);
		_pWidthCache = &_defaultWidthCache[0];
	}	
	ZeroMemory(_pWidthCache, sizeof(CacheEntry)*(DEFAULTCACHESIZE + 1));
}

/*
 *	CWidthCache::CWidthCache()
 *	
 *	@mfunc
 *		Point the caches to the defaults.
 */
CWidthCache::CWidthCache()
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CWidthCache::CWidthCache");

	_pWidthCache = &_defaultWidthCache[0];
}

/*
 *	CWidthCache::~CWidthCache()
 *	
 *	@mfunc
 *		Free any allocated caches.
 */
CWidthCache::~CWidthCache()
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CWidthCache::~CWidthCache");

	if (_pWidthCache != &_defaultWidthCache[0])
		FreePv(_pWidthCache);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\frunptr.cpp ===
/*
 *  @doc    INTERNAL
 *
 *  @module FRUNPTR.C -- FormatRunPtr methods |
 *
 *      common code to handle character and paragraph format runs
 *  
 *  Original Authors: <nl>
 *      Original RichEdit 1.0 code: David R. Fulmer <nl>
 *      Christian Fortini <nl>
 *      Murray Sargent <nl>
 *
 *  History:
 *      6/25/95     alexgo  convert to use Auto-Doc and simplified backing
 *      store model
 *
 *  @devnote
 *      BOR and EOR mean Beginning Of Run and End Of Run, respectively
 *
 *  Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_edit.h"
#include "_frunptr.h"
#include "_rtext.h"
#include "_font.h"

ASSERTDATA

//
//  Invariant stuff
//
#define DEBUG_CLASSNAME CFormatRunPtr

#include "_invar.h"

#ifdef DEBUG
/*
 *  CFormatRunPtr::Invariant
 *
 *  @mfunc  Invariant for format run pointers
 *
 *  @rdesc  BOOL
 */
BOOL CFormatRunPtr::Invariant() const
{
    if(IsValid())
    {
        CFormatRun *prun = GetRun(0);
        if(prun && _iRun)
        {
            Assert(prun->_cch > 0);
        }
    }
    else
    {
        Assert(_ich == 0);
    }
    return CRunPtrBase::Invariant();
}
#endif

/*
 *  CFormatRunPtr::InitRuns(ich, cch, iFormat, ppfrs)
 *
 *  @mfunc
 *      Setup this format run ptr for rich-text operation, namely,
 *      allocate CArray<lt>CFormatRun<gt> if not allocated, assign it to this
 *      run ptr's _pRuns, add initial run if no runs are present, and store
 *      initial cch and ich
 *  
 *  @rdesc
 *      TRUE if succeeds
 */
BOOL CFormatRunPtr::InitRuns(
    LONG ich,               //@parm # chars in initial run
    LONG cch,               //@parm char offset in initial run
    CFormatRuns **ppfrs)    //@parm ptr to CFormatRuns ptr
{
    TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFormatRunPtr::InitRuns");

    _TEST_INVARIANT_

    AssertSz( ppfrs,
        "FRP::InitRuns: illegal ptr to runs");
    AssertSz( !IsValid(),
        "FRP::InitRuns: ptr already valid");

    if(!*ppfrs)                                 // Allocate format runs
    {
        _pRuns = (CRunArray *) new CFormatRuns();
        if(!_pRuns)
            goto NoRAM;
        *ppfrs = (CFormatRuns *)_pRuns;
    }
    else                                        // Format runs already alloc'd
        _pRuns = (CRunArray *)*ppfrs;           // Cache ptr to runs

    if(!Count())                                // No runs yet, so add one
    {
        CFormatRun *pRun= Add(1, NULL);
        if(!pRun)
            goto NoRAM;

#ifdef DEBUG
        PvSet(*(void**)_pRuns);
#endif
        _ich            = ich;

        ZeroMemory(pRun, sizeof(*pRun));
        pRun->_cch      = cch;                  // Define its _cch
        pRun->_iFormat  = -1;                   //  and _iFormat
    }
    else
        BindToCp(ich);                          // Format runs are in place

    return TRUE;

NoRAM:
    TRACEERRSZSC("CFormatRunPtr::InitRuns: Out Of RAM", E_OUTOFMEMORY);
    return FALSE;
}


/*
 *  CFormatRunPtr::Delete(cch, pf, cchMove)
 *  
 *  @mfunc
 *      Delete/modify runs starting at this run ptr up to cch chars. <nl>
 *      There are 7 possibilities: <nl>
 *      1.  cch comes out of this run with count left over, i.e.,
 *          cch <lt>= (*this)->_cch - _ich && (*this)->_cch > cch
 *          (simple: no runs deleted/merged, just subtract cch) <nl>
 *      2.  cch comes out of this run and empties run and doc
 *          (simple: no runs left to delete/merge) <nl>
 *      3.  cch comes out of this run and empties run, which is last
 *          (need to delete run, no merge possibility) <nl>
 *      4.  cch comes out of this run and empties run, which is first
 *          (need to delete run, no merge possibility) <nl>
 *      5.  cch exceeds count available in this run and this run is last
 *          (simple: treat as 3.)  <nl>
 *      6.  cch comes out of this run and empties run with runs before
 *          and after (need to delete run; merge possibility) <nl>
 *      7.  cch comes partly out of this run and partly out of later run(s)
 *          (may need to delete and merge) <nl>
 *
 *  @comm
 *      PARAFORMATs have two special cases that use the cchMove argument set
 *      up in CRchTxtPtr::ReplaceRange().
 */
void CFormatRunPtr::Delete(
    LONG          cch,          //@parm # chars to modify format runs for
    IFormatCache *pf,           //@parm IFormatCache ptr for ReleaseFormat
    LONG          cchMove)      //@parm cch to move between runs (always 0 for CF)
{
    TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFormatRunPtr::Delete");

    _TEST_INVARIANT_

    // We should not have any boundary cases for empty or NULL pointers.
    // (i.e. if there's no text, then nobody should be calling delete).

    Assert(IsValid());

    LONG            cchEnd = 0;             // Probably unnecessary: see below
    LONG            cRun = 1;
    BOOL            fLast = (_iRun == Count() - 1);
    LONG            ifmtEnd, ifmtStart;
    CFormatRun *    pRun = Elem(_iRun);
    CFormatRun *    pRunRp;
    LONG            cchChunk = pRun->_cch - _ich;
    CFormatRunPtr   rp(*this);              // Clone this run ptr
    CBiDiLevel      levelStart = {0,0};
    CBiDiLevel      levelEnd = {0,0};

    rp.AdjustBackward();                    // If at BOR, move to prev EOR
    ifmtStart = rp.GetRun(0)->_iFormat;     // to get start format
    levelStart = rp.GetRun(0)->_level;      // and level
    rp = *this;                             // In case RpAdjustCp() backed up

// Process deletes confined to this run first, since their logic tends to
// clutter up other cases

    AssertSz(cch >= 0, "FRP::Delete: cch < 0");

    if(fLast)                               // Handle oversized cch on last
        cch = min(cch, cchChunk);           //  run here

    if(cch <= cchChunk)                     // cch comes out of this run
    {
        pRun->_cch -= cch;
        Assert(pRun->_cch >= 0);
        if(cchMove)                         // If nonzero here, we are
        {                                   //  deleting EOP at end of run
            rp.AdjustForward();             // Adjust rp to beginning of
            goto move;                      //  next run and go move cchMove
        }                                   //  chars back into this run
        if(pRun->_cch)                      // Something left in run: done
            return;
                                            // Note: _ich = 0
        if(!_iRun || fLast)                 // This run is either first
        {                                   //  or last
            AdjustBackward();               // If last, go to prev EOR
            if(_ich)                        // This run is empty so delete
                cRun++;                     // Compensate for cRun-- coming up
            ifmtStart = -2;                 // No runs eligible for merging
        }                                   //  so use unmatchable ifmtStart
        rp.NextRun();                       // Set up to get next _iFormat
    }       
    else
    {
        rp.AdvanceCp(cch);                  // Move clone to end of delete
        pRunRp = rp.GetRun(0);
        cRun = rp._iRun - _iRun             // If at EOR, then need to add
             + (rp._ich == pRunRp->_cch);   //  one more run to delete
        pRun->_cch = _ich;                  // Shorten this run to _ich chars
        pRunRp->_cch -= rp._ich;            // Shorten last run by rp._ich
        rp._ich = 0;

        Assert(pRunRp->_cch >= 0);
        AssertSz(cRun > 0, "FRP: bogus runptr");

        if(!_iRun)                          // First run?
            ifmtStart = -2;                 // Then we cannot merge runs so
    }                                       //  set to unmergable format

    ifmtEnd = -3;                           // Default invalid format at end
    if(rp.IsValid())
    {
        // FUTURE (murrays): probably rp is always valid here now and
        // pRun->_cch is nonzero
        pRun = rp.GetRun(0);
        if (pRun->_cch)                     // run not empty
        {
            ifmtEnd = pRun->_iFormat;       // Remember end format and count
            levelEnd = pRun->_level;
            cchEnd  = pRun->_cch;           //  in case of merge
        }
        else if(rp._iRun != rp.Count() - 1) // run not last
        {
            pRun = rp.GetRun(1);
            ifmtEnd = pRun->_iFormat;       // Remember end format and count
            levelEnd = pRun->_level;
            cchEnd  = pRun->_cch;           //  in case of merge
        }
    }

    rp = *this;                             // Default to delete this run
    if(_ich)                                // There are chars in this run
    {
        if(cchMove + _ich == 0)             // Need to combine all chars of
        {                                   //  this run with run after del,
            pf->AddRef(ifmtEnd);            //  so setup merge below using
            ifmtStart = ifmtEnd;            //  ifmtEnd. This run then takes
            pf->Release(GetRun(0)->_iFormat);
            GetRun(0)->_iFormat = ifmtEnd;  //  place of run after del.
            GetRun(0)->_level = levelEnd;
            cchMove = 0;                    // cchMove all accounted for
        }
        rp.NextRun();                       // Don't delete this run; start
        cRun--;                             //  with next one
    }

    AdjustBackward();                       // If !_ich, go to prev EOR

    if(ifmtEnd >=0 &&                       // Same formats: merge runs
       ifmtEnd == ifmtStart &&
       levelStart == levelEnd)
    {
        GetRun(0)->_cch += cchEnd;          // Add last-run cch to this one's
        Assert(GetRun(0)->_cch >= 0);
        cRun++;                             // Setup to eat last run
    }

    if(cRun > 0)                            // There are run(s) to delete
    {
        rp.Remove(cRun, pf);
        if(!Count())                        // If no more runs, keep this rp
            _ich = _iRun = 0;               //  valid by pointing at cp = 0
    }

move:
    if(cchMove)                             // Need to move some cch between
    {                                       //  this run and next (See
        GetRun(0)->_cch += cchMove;         //  CRchTxtPtr::ReplaceRange())
        rp.GetRun(0)->_cch -= cchMove;

        Assert(GetRun(0)->_cch >= 0);
        Assert(rp.GetRun(0)->_cch >= 0);
        Assert(_iRun < rp._iRun);

        if(!rp.GetRun(0)->_cch)             // If all chars moved out of rp's
            rp.Remove(1, pf);               //  run, delete it

        if(cchMove < 0)                     // Moved -cchMove chars from this
        {                                   //  run to next
            if(!GetRun(0)->_cch)
                Remove(1, pf);
            else
                _iRun++;                    // Keep this run ptr in sync with

            _ich = -cchMove;                //  cp (can't use NextRun() due
        }                                   //  to Invariants)
    }
    AdjustForward();                        // Don't leave ptr at EOR unless
}                                           //  there are no more runs

/*
 *  CFormatRunPtr::InsertFormat(cch, ifmt, pf)
 *  
 *  @mfunc
 *      Insert cch chars with format ifmt into format runs starting at
 *      this run ptr    
 *
 *  @rdesc
 *      count of characters added
 *
 *  @devnote    
 *      It is the caller's responsibility to ensure that we are in the
 *      "normal" or "empty" state.  A format run pointer doesn't know about
 *      CTxtStory, so it can't create the run array without outside help.
 */
LONG CFormatRunPtr::InsertFormat(
    LONG cch,               //@parm # chars to insert
    LONG ifmt,              //@parm format to use
    IFormatCache *pf)       //@parm pointer to IFormatCache to AddRefFormat
{
    TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFormatRunPtr::InsertFormat");

    LONG        cRun;
    CFormatRun *pRun;
    CFormatRun *pRunPrev;
    LONG        cchRun;                     // Current-run length,
    LONG        ich;                        //  offset, and
    LONG        iFormat;                    //  format

    _TEST_INVARIANT_

    Assert(_pRuns);
    if(!IsValid())
    {       
        // Empty run case (occurs when inserting after all text is deleted)
        pRun = Add(1, NULL);
        goto StoreNewRunData;               // (located at end of function)
    }

    // Go to previous run if at a boundary case
    AdjustBackward();
    pRun    = Elem(_iRun);                  // Try other cases
    cchRun  = pRun->_cch;
    iFormat = pRun->_iFormat;
    ich     = _ich;                         

    // Same run case.  Note that there is an additional boundary case; if we
    // are the _end_ of one run, then the next run may have the necessary
    // format.
    if(ifmt == iFormat)                     // IP already has correct fmt
    {
        pRun->_cch  += cch;
        _ich        += cch;                 // Inc offset to keep in sync
        return cch;
    }
    if(_ich == pRun->_cch && _iRun < _pRuns->Count() - 1)
    {
        AdjustForward();
        pRun = Elem(_iRun);

        Assert(pRun);

        if(pRun->_iFormat == ifmt)
        {
            pRun->_cch += cch;
            _ich += cch;
            return cch;
        }
        AdjustBackward();
    }

    // Prior run case (needed when formatting change occurs on line break
    //      and caret is at beginning of new line)
    if(!ich && _iRun > 0 )                  // IP at start of run
    {
        pRunPrev = GetPtr(pRun, -1);
        if( ifmt == pRunPrev->_iFormat)     // Prev run has same format:
        {                                   //  add count to prev run and
            pRunPrev->_cch += cch;
            return cch;
        }
    }

    // Create new run[s] cases.  There is a special case for a format
    // run of zero length: just re-use it.
    if(!pRun->_cch)
    {
        // This assert has been toned down to ignore a plain text control
        // being forced into IME Rich Composition.
        AssertSz( /* FALSE */ pRun->_iFormat == -1 && Count() == 1,
            "CFormatRunPtr::InsertFormat: 0-length run");
        pf->Release(pRun->_iFormat);
    }
    else                                    // Need to create 1 or 2 new
    {                                       //  runs for insertion
        cRun = 1;                           // Default 1 new run
        if(ich && ich < cchRun)             // Not at beginning or end of
            cRun++;                         //  run, so need two new runs

        // The following insert call adds one or two runs at the current
        // position. If the new run is inserted at the beginning or end
        // of the current run, the latter needs no change; however, if
        // the new run splits the current run in two, both pieces have
        // to be updated (cRun == 2 case).

        pRun = Insert(cRun);                // Insert cRun run(s)
        if(!pRun)                           // Out of RAM. Can't insert
        {                                   //  new format, but can keep
            _ich += cch;                    //  run ptr and format runs
            GetRun(0)->_cch += cch;         //  valid.  Note: doesn't
            return cch;                     //  signal any error; no access
        }                                   //  to _ped->_fErrSpace

        if(ich)                             // Not at beginning of run,
        {
            pRunPrev = pRun;                // Previous run is current run
            IncPtr(pRun);                   // New run is next run
            VALIDATE_PTR(pRun);
            pRun->_cch = cch;               // Keep NextRun() invariant happy
            NextRun();                      // Point this runptr at it too
            if(cRun == 2)                   // Are splitting current run
            {                               // _iFormat's are already set
                AssertSz(pRunPrev->_iFormat == iFormat,
                    "CFormatRunPtr::InsertFormat: bad format inserted");
                pRunPrev->_cch = ich;       // Divide up original cch
                GetPtr(pRun, 1)->_cch       //  accordingly
                    = cchRun - ich;
                pf->AddRef(iFormat);        // Addref iFormat for extra run
            }
        }
    }

StoreNewRunData:
    pf->AddRef(ifmt);                       // Addref ifmt
    ZeroMemory(pRun, sizeof(*pRun));
    pRun->_iFormat  = ifmt;                 // Store insert format and count
    pRun->_cch      = cch;                  //  of new run
    _ich            = cch;                  // cp goes at end of insertion

    return cch;
}

/*
 *  CFormatRunPtr::MergeRuns(iRun, pf)
 *  
 *  @mfunc
 *      Merge adjacent runs that have the same format between this run
 *      <md CFormatRunPtr::_iRun> and that for <p iRun>     
 *
 *  @comm
 *      Changes this run ptr
 */
void CFormatRunPtr::MergeRuns(
    LONG iRun,              //@parm last run to check (can preceed or follow
                            // <md CFormatRunPtr::_iRun>)
    IFormatCache *pf)       //@parm pointer to IFormatCache to ReleaseFormat
{
    TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFormatRunPtr::MergeRuns");

    LONG    cch;
    LONG    cRuns       = iRun - _iRun;
    LONG    iDirection  = 1;                // Default going forward
    CFormatRun *pRun;

    _TEST_INVARIANT_

    if(cRuns < 0)
    {
        cRuns = -cRuns;
        iDirection = -1;
    }
    if(!IsValid())                          // Allow starting run to be
    {                                       //  invalid
        Assert(FALSE);                      // I think this is old...
        ChgRun(iDirection);                 
    }

    while(cRuns--)
    {
        if(!GetRun(0)->_cch && !_iRun && _iRun < Count() - 1)
        {
            if(iDirection > 0)
                PrevRun();
            Remove(1, pf);
            continue;
        }

        pRun = GetRun(0);                   // Save the current run

        if(!ChgRun(iDirection))             // Go to next (or prev) run
            return;                         // No more runs to check

        if(pRun->SameFormat(GetRun(0)))
        {                                   // Like formatted runs
            if(iDirection > 0)              // Point at the first of the
                PrevRun();                  //  two runs
            cch = GetRun(0)->_cch;          // Save its count
            Remove(1, pf);                  // Remove it
            GetRun(0)->_cch += cch;         // Add its count to the other's,
        }                                   //  i.e., they're merged
    }
}

/*
 *  CFormatRunPtr::Remove(cRun, flag, pf)
 *  
 *  @mfunc
 *      Remove cRun runs starting at _iRun
 */
void CFormatRunPtr::Remove(
    LONG          cRun,
    IFormatCache *pf)
{
    CFormatRun *pRun = GetRun(0);           // Point at run(s) to delete

    for(LONG j = 0; j < cRun; j++, IncPtr(pRun))
        pf->Release(pRun->_iFormat);        // Decrement run reference count

    CRunPtr<CFormatRun>::Remove(cRun);
}

/*
 *  CFormatRunPtr::SetFormat(ifmt, cch, pf, pLevel)
 *  
 *  @mfunc
 *      Set format for up to cch chars of this run to ifmt, splitting run
 *      as needed, and returning the character count actually processed
 *
 *  @rdesc
 *      character count of run chunk processed, CP_INFINITE on failure
 *      this points at next run
 *
 *  Comments:
 *      Changes this run ptr.  cch must be >= 0.
 *
 *      Note 1) for the first run in a series, _ich may not = 0, and 2) cch
 *      may be <lt>, =, or <gt> the count remaining in the run. The algorithm
 *      doesn't split runs when the format doesn't change.
 */
LONG CFormatRunPtr::SetFormat(
    LONG            ifmt,   //@parm format index to use
    LONG            cch,    //@parm character count of remaining format range
    IFormatCache *  pf,     //@parm pointer to IFormatCache to
    CBiDiLevel*     pLevel) //@parm pointer to BiDi level structure
{
    TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFormatRunPtr::SetFormat");
                            //      AddRefFormat/ReleaseFormat
    LONG            cchChunk;
    LONG            iFormat;
    CFormatRun *    pRun;
    CFormatRun *    pChgRun;    // run that was reformatted
    CBiDiLevel      level;

    _TEST_INVARIANT_

    if(!IsValid())
        return 0;

    pRun        = GetRun(0);                // pRun points at current run in
    cchChunk    = pRun->_cch - _ich;        //  this function
    iFormat     = pRun->_iFormat;
    level       = pRun->_level;
    pChgRun     = pRun;

    AssertSz(cch, "Have to have characters to format!");
    AssertSz(pRun->_cch, "uh-oh, empty format run detected");

    if(ifmt != iFormat || (pLevel && level != *pLevel)) // New and current formats differ
    {
        AssertSz(cchChunk, "Caller did not call AdjustForward");

        if(_ich)                            // Not at either end of run: need
        {                                   //  to split into two runs of
            if(!(pRun = Insert(1)))         //  counts _ich and _pRun->_cch
            {                               //  - _ich, respectively
                return CP_INFINITE;         // Out of RAM: do nothing; just
            }                               //  keep current format
            pRun->_cch      = _ich;
            pRun->_iFormat  = iFormat;      // New run has same format
            pRun->_level    = level;        // and same level
            pf->AddRef(iFormat);            // Increment format ref count
            NextRun();                      // Go to second (original) run
            IncPtr(pRun);                   // Point pRun at current run
            pRun->_cch = cchChunk;          // Note: IncPtr is a bit more
            pChgRun = pRun;
        }                                   //  efficient than GetRun, but
                                            //  trickier to code right
        if(cch < cchChunk)                  // cch doesn't cover whole run:
        {                                   //  need to split into two runs
            if(!(pRun = Insert(1)))
            {
                // Out of RAM, so formatting's wrong, oh well.  We actually
                // "processed" all of the characters, so return that (though
                // the tail end formatting isn't split out right)
                return cch;
            }
            pRun->_cch = cch;               // New run gets the cch
            pRun->_iFormat = ifmt;          //  and the new format
            pChgRun = pRun;
            IncPtr(pRun);                   // Point pRun at current run
            pRun->_cch = cchChunk - cch;    // Set leftover count
        }
        else                                // cch as big or bigger than
        {                                   //  current run
            pf->Release(iFormat);           // Free run's current format
            pRun->_iFormat = ifmt;          // Change it to new format      
            pChgRun = pRun;
        }                                   // May get merged later
        pf->AddRef(ifmt);                   // Increment new format ref count
    }
    else if( cchChunk == 0 )
    {
        pRun->_cch += cch;
        cchChunk = cch;
    }

    // record embedding level to changed run
    if (pLevel)
        pChgRun->_level = *pLevel;

    cch = min(cch, cchChunk);
    AdvanceCp(cch);
    AdjustForward();
    return cch;
}

/*
 *  CFormatRunPtr::GetFormat()
 *
 *  @mfunc
 *      return format index at current run pointer position
 *
 *  @rdesc
 *      current format index
 */
short CFormatRunPtr::GetFormat() const
{
    TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFormatRunPtr::GetFormat");
    _TEST_INVARIANT_

    return IsValid() ? GetRun(0)->_iFormat : -1;
}


/*
 *  CFormatRunPtr::SplitFormat(IFormatCache*)
 *
 *  @mfunc
 *      Split a format run
 *
 *  @rdesc
 *      If succeeded the run pointer moves to the next splitted run
 */
void CFormatRunPtr::SplitFormat(IFormatCache* pf)
{
    if (!_ich || _ich == GetRun(0)->_cch)
        return;

    CFormatRun*     pRun = GetRun(0);
    LONG            iFormat = pRun->_iFormat;
    LONG            cch = pRun->_cch - _ich;
    CBiDiLevel      level = pRun->_level;

    if (pRun = Insert(1))
    {
        pRun->_cch = _ich;
        pRun->_iFormat = iFormat;
        pRun->_level = level;
        pf->AddRef(iFormat);
        NextRun();
        IncPtr(pRun);
        pRun->_cch = cch;
    }
}


/*
 *  CFormatRunPtr::SetLevel(level)
 *
 *  @mfunc
 *      Set run's embedding level
 */
void CFormatRunPtr::SetLevel (CBiDiLevel& level)
{
    if (!IsValid())
    {
        Assert(FALSE);
        return;
    }

    CFormatRun* pRun = GetRun(0);

    if (pRun)
        pRun->_level = level;
}

BYTE CFormatRunPtr::GetLevel (CBiDiLevel* pLevel)
{
    CFormatRun* pRun;

    if (!IsValid() || !(pRun = GetRun(0)))
    {
        Assert(FALSE);

        if (pLevel)
        {
            pLevel->_value = 0;
            pLevel->_fStart = FALSE;
        }
        return 0;
    }

    if (pLevel)
        *pLevel = pRun->_level;

    return pRun->_level._value;
}

/*
 *  CFormatRunPtr::AdjustFormatting(cch, pf)
 *  
 *  @mfunc
 *      Use the same format index for the cch chars at this run ptr
 *      as that immediately preceeding it (if on run edge).
 *
 *  @devnote
 *      This runptr ends up pointing at what was the preceeding run,
 *      since the current run has been moved into the preceeding run.
 *
 *      FUTURE: might be better to take the cch equal to chars in
 *      the following run.
 */ 
void CFormatRunPtr::AdjustFormatting(
    LONG          cch,      //@parm Count of chars to extend formatting
    IFormatCache *pf)       //@parm Format cache ptr for AddRef/Release
{
    if(!IsValid())
        return;                         // Nothing to merge

    CFormatRunPtr rp(*this);
    CBiDiLevel    level;
                                        // Move this run ptr to end of
    AdjustBackward();                   //  preceeding run (if at run edge)
    rp.AdjustForward();                 //  (merge may delete run at entry)
    if(_iRun != rp._iRun)               // On a format edge: copy previous
    {                                   //  format index over
        GetLevel(&level);
        rp.SetFormat(GetFormat(), cch, pf, &level); // Format cch chars at this
        rp.MergeRuns(_iRun, pf);            //  runptr
    }
}


///////////////////////////// CCFRunPtr ///////////////////////////////

CCFRunPtr::CCFRunPtr(const CRchTxtPtr &rtp)
        : CFormatRunPtr(rtp._rpCF)
{
    _ped = rtp.GetPed();
}

CCFRunPtr::CCFRunPtr(const CFormatRunPtr &rp, CTxtEdit *ped)
        : CFormatRunPtr(rp)
{
    _ped = ped;
}

/*
 *  CCFRunPtr::IsMask(dwMask, MaskOp)
 *  
 *  @mfunc
 *      return TRUE according to the mask operation MaskOp operating on
 *      _dwEffects.
 *
 *  @rdesc
 *      TRUE if bits in CCharFormat::dwEffects correspond to those in dwMask
 */
BOOL CCFRunPtr::IsMask(
    DWORD   dwMask,     //@parm Bit mask to use on dwEffects
    MASKOP  MaskOp)     //@parm Logic operation for bits
{
    DWORD dwEffects = _ped->GetCharFormat(GetFormat())->_dwEffects;

    if(MaskOp == MO_EXACT)              // Bit masks must be identical
        return dwEffects == dwMask;

    dwEffects &= dwMask;
    if(MaskOp == MO_OR)                 // TRUE if one or more effect bits
        return dwEffects != 0;          //  identified by mask are on

    if(MaskOp == MO_AND)                // TRUE if all effect bits
        return dwEffects == dwMask;     //  identified by mask are on

    AssertSz(FALSE, "CCFRunPtr::IsMask: illegal mask operation");
    return FALSE;
}

/*
 *  CCFRunPtr::IsInHidden()
 *  
 *  @mfunc
 *      return TRUE if CCharFormat for this run ptr has CFE_HIDDEN bit set
 *
 *  @rdesc
 *      TRUE if CCharFormat for this run ptr has CFE_HIDDEN bit set
 */
BOOL CCFRunPtr::IsInHidden()
{
    AdjustForward();
    BOOL fHidden = IsHidden();
    if(_ich)
        return fHidden;

    AdjustBackward();
    return fHidden && IsHidden();
}

/*
 *  CCFRunPtr::FindUnhidden()
 *  
 *  @mfunc
 *      Find nearest expanded CF going forward. If none, find nearest going
 *      backward.  If none, go to start of document
 *  
 *  @rdesc
 *      cch to nearest expanded CF as explained in function description
 *
 *  @devnote
 *      changes this run ptr
 */
LONG CCFRunPtr::FindUnhidden()
{
    LONG cch = FindUnhiddenForward();

    if(IsHidden())
        cch = FindUnhiddenBackward();

    return cch;
}

/*
 *  CCFRunPtr::FindUnhiddenForward()
 *  
 *  @mfunc
 *      Find nearest expanded CF going forward.  If none, go to EOD
 *  
 *  @rdesc
 *      cch to nearest expanded CF going forward
 *
 *  @devnote
 *      changes this run ptr
 */
LONG CCFRunPtr::FindUnhiddenForward()
{
    LONG cch = 0;

    AdjustForward();
    while(IsHidden())
    {
        cch += GetCchLeft();
        if(!NextRun())
            break;
    }
    return cch;
}

/*
 *  CCFRunPtr::MatchFormatSignature
 *  
 *  @mfunc
 *      Match the current format's font signature with the script (index to codepage).
 *      It takes care single-codepage fonts which implicitly supports ASCII range.
 *
 *  @rdesc
 *      return how font matched
 */

inline int CCFRunPtr::MatchFormatSignature (
    const CCharFormat*  pCF,
    int                 iScript,
    int                 iMatchCurrent,
    DWORD*              pdwFontSig)
{
    DWORD   dwFontSig = 0;

    if (GetFontSignatureFromFace(pCF->_iFont, &dwFontSig) != 0)
    {
        if (pdwFontSig)
            *pdwFontSig = dwFontSig;

        if (iMatchCurrent & MATCH_ASCII && fc().GetInfoFlags(pCF->_iFont).fNonBiDiAscii)
            return MATCH_ASCII;

        if (W32->GetFontSigFromScript(iScript) & ~(fASCII >> 8) & dwFontSig)
            return MATCH_FONT_SIG;
    }
    return 0;
}

/*
 *  CCFRunPtr::GetPreferredFontInfo( cpg, bCharSet, iFont, yHeight, bPitchAndFamily,
 *                                  iFormat, iMatchCurrent )
 *  
 *  @mfunc
 *      Find the preferred font for the given code page around the range.
 *
 *  @rdesc
 *      boolean true if suitable font found, false otherwise.
 */
bool CCFRunPtr::GetPreferredFontInfo(
    int    cpg,
    BYTE&  bRetCharSet,
    SHORT& iFont,
    SHORT& yHeight,             // return in twips
    BYTE&  bPitchAndFamily,
    int    iFormat,
    int    iMatchCurrent)
{
    int                i, iScript;
    bool               fr = false;
    static int const   MAX_FONTSEARCH = 256;
    const CCharFormat *pCF;
    const CCharFormat *pCFCurrent;
    const CCharFormat *pCFPrevious = NULL;
    int                iMatch = 0;          // how signature match?
    DWORD              dwCurrentFontSig = 0;
    SHORT              yNewHeight = 0;
    BYTE               bCharSet = GetCharSet(cpg, &iScript);
    bool               fUseUIFont = _ped->fUseUIFont() || _ped->Get10Mode();

    Assert(!(iMatchCurrent & MATCH_ASCII) || bCharSet == ANSI_CHARSET);

    if(_ped->fUseUIFont())
        pCFCurrent = _ped->GetCharFormat(-1);   // Plain text or UI font specified
    else
        pCFCurrent = _ped->GetCharFormat(iFormat != -1 ? iFormat : GetFormat());

    if ((iMatchCurrent & MATCH_FONT_SIG) &&
        (iMatch = MatchFormatSignature(pCFCurrent, iScript, iMatchCurrent, &dwCurrentFontSig)) != 0)
    {
        pCF = pCFCurrent;                   // Setup to use it
    }
    else
    {
        // Try searching backwards
        if (IsValid())                      // If doc has CF runs
            AdjustBackward();
        i = MAX_FONTSEARCH;                 // Don't be searching for years
        pCF = _ped->GetCharFormat(GetFormat());
        while (i--)
        {
            if (bCharSet == pCF->_bCharSet) // Equal charset ids?
            {
                pCFPrevious = pCF;
                break;
            }
            if (!PrevRun())                 // Done searching?
                break;
            pCF = _ped->GetCharFormat(GetFormat());
        }
        pCF = pCFPrevious;
    }

    // Try match charset if requested
    if(!pCF && iMatchCurrent == MATCH_CURRENT_CHARSET)
    {
        CCcs* pccs = fc().GetCcs(pCFCurrent, W32->GetYPerInchScreenDC());
        if (pccs)
        {
            if (pccs->BestCharSet(bCharSet, 1, MATCH_CURRENT_CHARSET) != 1)
                pCF = pCFCurrent;           // Current font can do it
            pccs->Release();
        }
    }

    // Try default document format
    if (!pCF)
    {
        pCF = _ped->GetCharFormat(-1);
        if (bCharSet != pCF->_bCharSet) // Diff charset ids?
            pCF = NULL;
    }

    yHeight = pCFCurrent->_yHeight;     // assume current height

    if (!pCF)
    {
        // Default to table if no match.
        
        fr = W32->GetPreferredFontInfo(
            cpg, fUseUIFont, iFont, (BYTE&)yNewHeight, bPitchAndFamily );

        if (!_ped->_fAutoFontSizeAdjust && (cpg == CP_THAI || cpg == THAI_INDEX))
            // Kick in font size adjusting in first bind to Thai.
            _ped->_fAutoFontSizeAdjust = TRUE;
    }

    if (pCF)
    {
        // Found previous or current font
        iFont = pCF->_iFont;
        bPitchAndFamily = pCF->_bPitchAndFamily;

        if (pCF == pCFCurrent && (iMatchCurrent & MATCH_FONT_SIG) &&
            (IsFECharSet(pCF->_bCharSet) && W32->IsFECodePageFont(dwCurrentFontSig) ||
             iMatch == MATCH_ASCII && bCharSet == ANSI_CHARSET))
        {
            // The current font matches the requested signature.
            // If it's a FarEast or ASCII font. We leave the charset intact.
            bRetCharSet = pCF->_bCharSet;
            return true;
        }
    }

    if (_ped->_fAutoFontSizeAdjust && iFont != pCFCurrent->_iFont)
    {
        if (IsValid())
        {
            // If the last run format is available. We will scale the size relative to it.

            AdjustBackward();
            if (GetIch() > 0)
            {
                pCFCurrent = _ped->GetCharFormat(GetFormat());
                yHeight = pCFCurrent->_yHeight;
            }
            AdjustForward();
        }

        if (iFont != pCFCurrent->_iFont)
        {
            // Scale the height relative to the preceding format

            if (pCF)
                yNewHeight = GetFontLegitimateSize(iFont, fUseUIFont, cpg);
    
            if (yNewHeight)
            {
                // Get legitimate size of the current font
                SHORT   yDefHeight = GetFontLegitimateSize(pCFCurrent->_iFont, fUseUIFont, GetCodePage(pCFCurrent->_bCharSet));
    
                // Calculate the new height relative to the current height
                if (yDefHeight)
                {
                    if (fUseUIFont)
                    {
                        // For UIFont, we only convert from one preferred size to another preferred size.
                        if (pCFCurrent->_yHeight / TWIPS_PER_POINT == yDefHeight)
                            yHeight = yNewHeight * TWIPS_PER_POINT;
                    }
                    else
                        yHeight = (SHORT)MulDiv(pCFCurrent->_yHeight, yNewHeight, yDefHeight);
                }
            }
        }
    }

    if (!yHeight)
        yHeight = (SHORT)MulDiv(pCFCurrent->_yHeight, yNewHeight, 10);

    return pCF || fr;
}

/*
 *  CCFRunPtr::FindUnhiddenBackward()
 *  
 *  @mfunc
 *      Find nearest expanded CF going backward.  If none, go to BOD
 *  
 *  @rdesc
 *      cch to nearest expanded CF going backward
 *
 *  @devnote
 *      changes this run ptr
 */
LONG CCFRunPtr::FindUnhiddenBackward()
{
    LONG cch = 0;

    AdjustBackward();
    while(IsHidden())
    {
        cch -= GetIch();
        if(!_iRun)
            break;
        _ich = 0;
        AdjustBackward();
    }
    return cch;
}

///////////////////////////// CPFRunPtr ///////////////////////////////

CPFRunPtr::CPFRunPtr(const CRchTxtPtr &rtp)
        : CFormatRunPtr(rtp._rpPF)
{
    _ped = rtp.GetPed();
}

/*
 *  CPFRunPtr::FindHeading(cch, lHeading)
 *  
 *  @mfunc
 *      Find heading with number lHeading (e.g., = 1 for Heading 1) or above
 *      in a range starting at this PFrun pointer.  If successful, this run
 *      ptr points at the matching run; else it remains unchanged.
 *  
 *  @rdesc
 *      cch to matching heading or tomBackward if not found
 *
 *  @devnote
 *      changes this run ptr
 */
LONG CPFRunPtr::FindHeading(
    LONG    cch,        //@parm Max cch to move
    LONG&   lHeading)   //@parm Lowest lHeading to match
{
    LONG    cchSave  = cch;
    LONG    ichSave  = _ich;
    LONG    iRunSave = _iRun;
    LONG    OutlineLevel;

    Assert((unsigned)lHeading <= NHSTYLES);

    if(!IsValid())
        return tomBackward;

    while(TRUE)
    {
        OutlineLevel = GetOutlineLevel();

        if (!(OutlineLevel & 1) &&
            (!lHeading || (lHeading - 1)*2 >= OutlineLevel))
        {
            lHeading = OutlineLevel/2 + 1;  // Return heading # found
            return cchSave - cch;           // Return how far away it was
        }

        if(cch >= 0)
        {
            cch -= GetCchLeft();
            if(cch <= 0 || !NextRun())
                break;
        }           
        else
        {
            cch += GetIch();
            if(cch > 0 || !_iRun)
                break;
            AdjustBackward();
        }
    }

    _ich  = ichSave;
    _iRun = iRunSave;
    return tomBackward;                     // Didn't find desired heading
}

/*
 *  CPFRunPtr::IsCollapsed()
 *  
 *  @mfunc
 *      return TRUE if CParaFormat for this run ptr has PFE_COLLAPSED bit set
 *
 *  @rdesc
 *      TRUE if CParaFormat for this run ptr has PFE_COLLAPSED bit set
 */
BOOL CPFRunPtr::IsCollapsed()
{
    return (_ped->GetParaFormat(GetFormat())->_wEffects & PFE_COLLAPSED) != 0;
}

/*
 *  CPFRunPtr::InTable()
 *  
 *  @mfunc
 *      return TRUE if CParaFormat for this run ptr has PFE_TABLE bit set
 *
 *  @rdesc
 *      TRUE if CParaFormat for this run ptr has PFE_TABLE bit set
 */
BOOL CPFRunPtr::InTable()
{
    return (_ped->GetParaFormat(GetFormat())->_wEffects & PFE_TABLE) != 0;
}

/*
 *  CPFRunPtr::FindExpanded()
 *  
 *  @mfunc
 *      Find nearest expanded PF going forward. If none, find nearest going
 *      backward.  If none, go to start of document
 *  
 *  @rdesc
 *      cch to nearest expanded PF as explained in function description
 *
 *  @devnote
 *      advances this run ptr the amount returned (cch)
 */
LONG CPFRunPtr::FindExpanded()
{
    LONG cch, cchRun;

    for(cch = 0; IsCollapsed(); cch += cchRun)  // Try to find expanded PF
    {                                           //  run going forward
        cchRun = GetCchLeft();
        if(!NextRun())                          // Aren't any
        {
            AdvanceCp(-cch);                    // Go back to starting point
            return FindExpandedBackward();      // Try to find expanded PF
        }                                       //  run going backward
    }
    return cch;
}

/*
 *  CPFRunPtr::FindExpandedForward()
 *  
 *  @mfunc
 *      Find nearest expanded PF going forward.  If none, go to EOD
 *  
 *  @rdesc
 *      cch to nearest expanded PF going forward
 *
 *  @devnote
 *      advances this run ptr the amount returned (cch)
 */
LONG CPFRunPtr::FindExpandedForward()
{
    LONG cch = 0;

    while(IsCollapsed())
    {
        LONG cchLeft = GetCchLeft();
        _ich += cchLeft;                        // Update _ich in case
        cch  += cchLeft;                        //  if(!NextRun()) breaks
        if(!NextRun())
            break;
    }
    return cch;
}

/*
 *  CPFRunPtr::FindExpandedBackward()
 *  
 *  @mfunc
 *      Find nearest expanded PF going backward.  If none, go to BOD
 *  
 *  @rdesc
 *      cch to nearest expanded PF going backward
 *
 *  @devnote
 *      advances this run ptr the amount returned (cch)
 */
LONG CPFRunPtr::FindExpandedBackward()
{
    LONG cch = 0;

    while(IsCollapsed())
    {
        cch -= GetIch();
        _ich = 0;
        if(!_iRun)
            break;
        AdjustBackward();
    }
    return cch;
}

/*
 *  CPFRunPtr::GetOutlineLevel()
 *  
 *  @mfunc
 *      Find outline level this rp is pointing at
 *  
 *  @rdesc
 *      Outline level this rp is pointing at
 */
LONG CPFRunPtr::GetOutlineLevel()
{
    const CParaFormat *pPF = _ped->GetParaFormat(GetFormat());
    LONG OutlineLevel = pPF->_bOutlineLevel;

    AssertSz(IsHeadingStyle(pPF->_sStyle) ^ (OutlineLevel & 1),
        "CPFRunPtr::GetOutlineLevel: sStyle/bOutlineLevel mismatch");

    return OutlineLevel;
}

/*
 *  CPFRunPtr::GetStyle()
 *  
 *  @mfunc
 *      Find style this rp is pointing at
 *  
 *  @rdesc
 *      Style this rp is pointing at
 */
LONG CPFRunPtr::GetStyle()
{
    const CParaFormat *pPF = _ped->GetParaFormat(GetFormat());
    LONG Style = pPF->_sStyle;

    AssertSz(IsHeadingStyle(Style) ^ (pPF->_bOutlineLevel & 1),
        "CPFRunPtr::GetStyle: sStyle/bOutlineLevel mismatch");

    return Style;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\host.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	HOST.C	-- Text Host for CreateWindow() Rich Edit Control |
 *		Implements CTxtWinHost message and ITextHost interfaces
 *		
 *	Original Author: <nl>
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 *
 *	History: <nl>
 *		8/1/95   ricksa  Documented and brought to new ITextHost definition
 *		10/28/95 murrays cleaned up and moved default char/paraformat cache
 *						 cache code into text services
 *
 *	Set tabs every four (4) columns
 *
 *	Copyright (c) 1995-1998 Microsoft Corporation. All rights reserved.
 */
#include "_common.h"
#include "_host.h"
#include "imm.h"
#include "_format.h"
#include "_edit.h"
#include "_cfpf.h"

ASSERTDATA

//////////////////////////// System Window Procs ////////////////////////////
LRESULT CreateAnsiWindow(
	HWND hwnd,
	UINT msg,
	CREATESTRUCTA *pcsa,
	BOOL fIs10)
{
	AssertSz((WM_CREATE == msg) || (WM_NCCREATE == msg),
		"CreateAnsiWindow called with invalid message!");

	CTxtWinHost *phost = (CTxtWinHost *) GetWindowLongPtr(hwnd, ibPed);

	// The only thing we need to convert are the strings,
	// so just do a structure copy and replace the strings.
	CREATESTRUCTW csw = *(CREATESTRUCTW *)pcsa;
	CStrInW strinwName(pcsa->lpszName, GetKeyboardCodePage());
	CStrInW strinwClass(pcsa->lpszClass, CP_ACP);

	csw.lpszName = (WCHAR *)strinwName;
	csw.lpszClass = (WCHAR *)strinwClass;

	if (!phost)
	{
		// No host yet so create it
		phost = CTxtWinHost::OnNCCreate(hwnd, &csw, TRUE, fIs10);
	}

	if (WM_NCCREATE == msg)
	{
		return phost != NULL;
	}

	if (NULL == phost)
	{
		// For WM_CREATE -1 indicates failure
		return -1;
	}

	// Do the stuff specific to create
	return phost->OnCreate(&csw);
		
}

CTxtWinHost *g_phostdel = NULL;

void DeleteDanglingHosts()
{
	CLock lock;
	CTxtWinHost *phostdel = g_phostdel;
	while(phostdel)
	{
		CTxtWinHost *phost = phostdel;
		phostdel = phostdel->_pnextdel;
		CTxtWinHost::OnNCDestroy(phost);
	}
	g_phostdel = NULL;
}

extern "C" LRESULT CALLBACK RichEdit10ANSIWndProc(
	HWND hwnd,
	UINT msg,
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGINPARAM(TRCSUBSYSHOST, TRCSCOPEINTERN, "RichEdit10ANSIWndProc", msg);

	if ((WM_CREATE == msg) || (WM_NCCREATE == msg))
	{
		return CreateAnsiWindow(hwnd, msg, (CREATESTRUCTA *) lparam, TRUE);
	}

    // ignore WM_DESTROY and wait for WM_NCDESTROY
	if (WM_DESTROY == msg)
	{
		CLock lock;
		CTxtWinHost *phost = (CTxtWinHost *) GetWindowLongPtr(hwnd, ibPed);
		phost->_pnextdel = g_phostdel;
		g_phostdel = phost;
		return 0;
	}

	if (WM_NCDESTROY == msg)
	    msg = WM_DESTROY;

	return W32->ANSIWndProc( hwnd, msg, wparam, lparam, TRUE);
}

LRESULT CALLBACK RichEditANSIWndProc(
	HWND hwnd,
	UINT msg,
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGINPARAM(TRCSUBSYSHOST, TRCSCOPEINTERN, "RichEditANSIWndProc", msg);

	if ((WM_CREATE == msg) || (WM_NCCREATE == msg))
	{
		return CreateAnsiWindow(hwnd, msg, (CREATESTRUCTA *) lparam, FALSE);
	}

	return W32->ANSIWndProc( hwnd, msg, wparam, lparam, FALSE);

}

/*
 *	RichEditWndProc (hwnd, msg, wparam, lparam)
 *
 *	@mfunc
 *		Handle window messages pertinent to the host and pass others on to
 *		text services.
 *
 *	#rdesc
 *		LRESULT = (code processed) ? 0 : 1
 */
LRESULT CALLBACK RichEditWndProc(
	HWND hwnd,
	UINT msg,
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "RichEditWndProc");

	LRESULT lres = 0;
	HRESULT hr;
	SETTEXTEX st;

	CTxtWinHost *phost = hwnd ? (CTxtWinHost *) GetWindowLongPtr(hwnd, ibPed) : NULL;

	#ifdef DEBUG
	Tracef(TRCSEVINFO, "hwnd %lx, msg %lx, wparam %lx, lparam %lx", hwnd, msg, wparam, lparam);
	#endif	// DEBUG

	switch(msg)
	{
	case WM_NCCREATE:
		return CTxtWinHost::OnNCCreate(hwnd, (CREATESTRUCT *)lparam, FALSE, FALSE) != NULL;

	case WM_CREATE:
		// We may be on a system with no WM_NCCREATE (e.g. WinCE)
		if (!phost)
		{
			phost = CTxtWinHost::OnNCCreate(hwnd, (CREATESTRUCT *) lparam, FALSE, FALSE);
		}

		break;

	case WM_DESTROY:
		if(phost)
		{
			CLock lock;
			CTxtWinHost *phostdel = g_phostdel;
			if (phostdel == phost)
				g_phostdel = phost->_pnextdel;
			else
			{
				while (phostdel)
				{
					if (phostdel->_pnextdel == phost)
					{
						phostdel->_pnextdel = phost->_pnextdel;
						break;
					}
					phostdel = phostdel->_pnextdel;
				}
			}

			CTxtWinHost::OnNCDestroy(phost);
		}
		return 0;
	}

	if (!phost)
		return ::DefWindowProc(hwnd, msg, wparam, lparam);

	// In certain out-of-memory situations, clients may try to re-enter us
	// with calls.  Just bail on the call if we don't have a text services
	// pointer.
	if(!phost->_pserv)
		return 0;

	// stabilize ourselves
	phost->AddRef();

	// Handle mouse/keyboard/scroll message-filter notifications
	if(phost->_fKeyMaskSet || phost->_fMouseMaskSet || phost->_fScrollMaskSet)
	{
		// We may need to fire a MSGFILTER notification.  In the tests
		// below, we check to see if mouse, keyboard, or scroll events
		// are hit and enabled for notifications.  If so, we fire the
		// msgfilter notification.  The list of events was generated
		// from	RichEdit 1.0 sources. The code gets all keyboard and
		// mouse actions, whereas the RichEdit 1.0 code only got
		// WM_KEYDOWN, WM_KEYUP, WM_CHAR, WM_SYSKEYDOWN, WM_SYSKEYUP,
		// WM_MOUSEACTIVATE, WM_LBUTTONDOWN, WM_LBUTTONUP, WM_MOUSEMOVE,
		// WM_RBUTTONDBLCLK, WM_RBUTTONDOWN, WM_RBUTTONUP. Note that the
		// following code doesn't send a notification for AltGr characters
		// (LeftCtrl+RightAlt+vkey), since some hosts misinterpret these
		// characters as hot keys.
		if (phost->_fKeyMaskSet && IN_RANGE(WM_KEYFIRST, msg, WM_KEYLAST) &&
				(msg != WM_KEYDOWN ||
				 (GetKeyboardFlags() & (ALT | CTRL)) != (LCTRL | RALT)) || // AltGr
			phost->_fMouseMaskSet && (msg == WM_MOUSEACTIVATE ||
							IN_RANGE(WM_MOUSEFIRST, msg, WM_MOUSELAST)) ||
			phost->_fScrollMaskSet && IN_RANGE(WM_HSCROLL, msg, WM_VSCROLL))
		{
			MSGFILTER msgfltr;

			ZeroMemory(&msgfltr.nmhdr, sizeof(NMHDR));
			msgfltr.msg = msg;
			msgfltr.wParam = wparam;
			msgfltr.lParam = lparam;

			// The MSDN document on MSGFILTER is wrong, if the
			// send message returns 0 (NOERROR via TxNotify in this
			// case), it means process the event.  Otherwise, return.
			//
			// The documentation states the reverse.
			//
			if(phost->TxNotify(EN_MSGFILTER, &msgfltr) == NOERROR)
			{
				// Since client is allowed to modify the contents of
				// msgfltr, we must use the returned values.
				msg	   = msgfltr.msg;
				wparam = msgfltr.wParam;
				lparam = msgfltr.lParam;
			}
			else
			{
				lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
				goto Exit;
			}
		}
	}

	switch(msg)
	{
    case EM_SETEVENTMASK:
		phost->_fKeyMaskSet = !!(lparam & ENM_KEYEVENTS);
		phost->_fMouseMaskSet = !!(lparam & ENM_MOUSEEVENTS);
		phost->_fScrollMaskSet = !!(lparam & ENM_SCROLLEVENTS);
		goto serv;

	case EM_SETSEL:

		// When we are in a dialog box that is empty, EM_SETSEL will not select
		// the final always existing EOP if the control is rich.
		if (phost->_fUseSpecialSetSel &&
			((CTxtEdit *)phost->_pserv)->GetAdjustedTextLength() == 0 &&
			wparam != -1)
		{
			lparam = 0;
			wparam = 0;
		}
		goto serv;

	case WM_CREATE:
		{
			//bug fix #5386
			//need to convert ANSI -> UNICODE for Win9x systems which didn't go through
			//the ANSI wndProc
			if (W32->OnWin9x() && !phost->_fANSIwindow)
			{
				CREATESTRUCT cs = *(CREATESTRUCT*)lparam;
				CStrInW strinwName(((CREATESTRUCTA*)lparam)->lpszName, GetKeyboardCodePage());
				CStrInW strinwClass(((CREATESTRUCTA*)lparam)->lpszClass, CP_ACP);

				cs.lpszName = (WCHAR*)strinwName;
				cs.lpszClass = (WCHAR*)strinwClass;
				
				lres = phost->OnCreate(&cs);
			}
			else
				lres = phost->OnCreate((CREATESTRUCT*)lparam);			
		}
		break;
	
	case WM_KEYDOWN:		
		lres = phost->OnKeyDown((WORD) wparam, (DWORD) lparam);
		if(lres)							// Didn't process code:
			goto serv;						//  give it to text services
		
		break;		

	case WM_GETTEXT:
		GETTEXTEX gt;
		if (W32->OnWin9x() || phost->_fANSIwindow)
			W32->AnsiFilter( msg, wparam, lparam, (void *) &gt );
		goto serv;

	case WM_COPYDATA:
		PCOPYDATASTRUCT pcds;
		pcds = (PCOPYDATASTRUCT) lparam;
		if (HIWORD(pcds->dwData) == 1200 &&		// Unicode code page
			LOWORD(pcds->dwData) == WM_SETTEXT)	// Only message we know about
		{
			st.flags = ST_CHECKPROTECTION;
			st.codepage = 1200;
			msg = EM_SETTEXTEX;
			wparam = (WPARAM) &st;
			lparam = (LPARAM) pcds->lpData;
			goto serv;
		}
		else
			lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		break;

	case WM_GETTEXTLENGTH:
		GETTEXTLENGTHEX gtl;
		if (W32->OnWin9x() || phost->_fANSIwindow)
			W32->AnsiFilter( msg, wparam, lparam, (void *) &gtl );
		goto serv;

	case WM_CHAR:
		if(GetKeyboardFlags() & ALTNUMPAD)	// Handle Alt+0ddd in CTxtEdit
			goto serv;						//  so that other hosts also work

		else if (W32->OnWin9x() || phost->_fANSIwindow)
		{
			CW32System::WM_CHAR_INFO wmci;
			wmci._fAccumulate = phost->_fAccumulateDBC != 0;
			W32->AnsiFilter( msg, wparam, lparam, (void *) &wmci, 
				((CTxtEdit *)phost->_pserv)->Get10Mode() );
			if (wmci._fLeadByte)
			{
				phost->_fAccumulateDBC = TRUE;
				phost->_chLeadByte = wparam << 8;
				goto Exit;					// Wait for trail byte
			}
			else if (wmci._fTrailByte)
			{
				wparam = phost->_chLeadByte | wparam;
				phost->_fAccumulateDBC = FALSE;
				phost->_chLeadByte = 0;
				msg = WM_IME_CHAR;
				goto serv;
			}
			else if (wmci._fIMEChar)
			{
				msg = WM_IME_CHAR;
				goto serv;
			}
		}

		lres = phost->OnChar((WORD) wparam, (DWORD) lparam);
		if(lres)							// Didn't process code:
			goto serv;						//  give it to text services
		break;

	case WM_ENABLE:
		if(!wparam ^ phost->_fDisabled)
		{
			// Stated of window changed so invalidate it so it will
			// get redrawn.
			InvalidateRect(phost->_hwnd, NULL, TRUE);
			phost->SetScrollBarsForWmEnable(wparam);
		}
		phost->_fDisabled = !wparam;				// Set disabled flag
		lres = 0;							// Return value for message
											// Fall thru to WM_SYSCOLORCHANGE?
	case WM_SYSCOLORCHANGE:
		phost->OnSysColorChange();
		goto serv;							// Notify text services that
											//  system colors have changed
	case WM_GETDLGCODE:
		lres = phost->OnGetDlgCode(wparam, lparam);
		break;

	case EM_GETOPTIONS:
		lres = phost->OnGetOptions();
		break;

	case EM_GETPASSWORDCHAR:
		lres = phost->_chPassword;
		break;

	case EM_GETRECT:
		phost->OnGetRect((LPRECT)lparam);
		break;

	case EM_HIDESELECTION:
		if(lparam)
		{
			DWORD dwPropertyBits = 0;

			phost->_dwStyle |= ES_NOHIDESEL;
			if(wparam)
			{
				phost->_dwStyle &= ~ES_NOHIDESEL;
				dwPropertyBits = TXTBIT_HIDESELECTION;
			}

			// Notify text services of change in status.
			phost->_pserv->OnTxPropertyBitsChange(TXTBIT_HIDESELECTION,
				dwPropertyBits);
		}
		goto serv;

	case EM_SETBKGNDCOLOR:
		lres = (LRESULT) phost->_crBackground;
		phost->_fNotSysBkgnd = !wparam;
		phost->_crBackground = (COLORREF) lparam;

		if(wparam)
			phost->_crBackground = GetSysColor(COLOR_WINDOW);

		if(lres != (LRESULT) phost->_crBackground)
		{
			// Notify text services that color has changed
			LRESULT	lres1 = 0;
			phost->_pserv->TxSendMessage(WM_SYSCOLORCHANGE, 0, 0, &lres1);
			phost->TxInvalidateRect(NULL, TRUE);
		}
		break;

    case WM_STYLECHANGING:
		// Just pass this one to the default window proc
		lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		break;

	case WM_STYLECHANGED:
		//
		// For now, we only interested in GWL_EXSTYLE Transparent mode changed.
		// This is to fix Bug 753 since Window95 is not passing us
		// the WS_EX_TRANSPARENT.
		//
		lres = 1;
		if(GWL_EXSTYLE == wparam)
		{
			LPSTYLESTRUCT lpss = (LPSTYLESTRUCT) lparam;
			if(phost->IsTransparentMode() != (BOOL)(lpss->styleNew & WS_EX_TRANSPARENT))
			{
				phost->_dwExStyle = lpss->styleNew;
				((CTxtEdit *)phost->_pserv)->OnTxBackStyleChange(TRUE);

				// Return 0 to indicate we have handled this message
				lres = 0;
			}
		}
		break;

	case EM_SHOWSCROLLBAR:
		{
			Assert(wparam == SB_VERT || wparam == SB_HORZ);
			DWORD dwBit = wparam == SB_VERT ? WS_VSCROLL : WS_HSCROLL;

			phost->_dwStyle |= dwBit;
			if(!lparam)
				phost->_dwStyle &= ~dwBit;

			phost->TxShowScrollBar((int) wparam, lparam);
			if (lparam)
			    phost->TxSetScrollRange((int) wparam, 0, 0, TRUE);
		}
		break;

	case EM_SETOPTIONS:
		phost->OnSetOptions((WORD) wparam, (DWORD) lparam);
		lres = (phost->_dwStyle & ECO_STYLES);
		if(phost->_fEnableAutoWordSel)
			lres |= ECO_AUTOWORDSELECTION;
		break;

	case EM_SETPASSWORDCHAR:
		if(phost->_chPassword != (TCHAR)wparam)
		{
			phost->_chPassword = (TCHAR)wparam;
			phost->_pserv->OnTxPropertyBitsChange(TXTBIT_USEPASSWORD,
				phost->_chPassword ? TXTBIT_USEPASSWORD : 0);
		}
		break;

	case EM_SETREADONLY:
		phost->OnSetReadOnly(BOOL(wparam));
		lres = 1;
		break;

	case EM_SETRECTNP:
	case EM_SETRECT:
		phost->OnSetRect((LPRECT)lparam, wparam == 1, msg == EM_SETRECT);
		break;
		
	case WM_SIZE:
		phost->_pserv->TxSendMessage(msg, wparam, lparam, &lres);
		lres = phost->OnSize(hwnd, wparam, (int)LOWORD(lparam), (int)HIWORD(lparam));
		break;

	case WM_WINDOWPOSCHANGING:
		lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		// richedit 1.0 didn't cause InvalidateRect which OnSunkenWindowPosChanging will do
		if(phost->TxGetEffects() == TXTEFFECT_SUNKEN && !((CTxtEdit *)phost->_pserv)->Get10Mode())
			phost->OnSunkenWindowPosChanging(hwnd, (WINDOWPOS *) lparam);
		break;

	case WM_SETCURSOR:
		//			Only set cursor when over us rather than a child; this
		//			helps prevent us from fighting it out with an inplace child
		if((HWND)wparam == hwnd)
		{
			if(!(lres = ::DefWindowProc(hwnd, msg, wparam, lparam)))
			{
				POINT pt;
				GetCursorPos(&pt);
				::ScreenToClient(hwnd, &pt);
				phost->_pserv->OnTxSetCursor(
					DVASPECT_CONTENT,	
					-1,
					NULL,
					NULL,
					NULL,
					NULL,
					NULL,			// Client rect - no redraw
					pt.x,
					pt.y);
				lres = TRUE;
			}
		}
		break;

	case WM_SHOWWINDOW:
		hr = phost->OnTxVisibleChange((BOOL)wparam);
		break;

	case WM_NCPAINT:
		lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		if(phost->TxGetEffects() == TXTEFFECT_SUNKEN && dwMajorVersion < VERS4)
		{
			HDC hdc = GetDC(hwnd);
			if(hdc)
			{
				phost->DrawSunkenBorder(hwnd, hdc);
				ReleaseDC(hwnd, hdc);
			}
		}
		break;

	case WM_PRINTCLIENT:
	case WM_PAINT:
		{
			PAINTSTRUCT ps;
			HPALETTE hpalOld = NULL;
			HDC hdc = BeginPaint(hwnd, &ps);
			RECT rcClient;

			// Set up the palette for drawing our data
			if(phost->_hpal)
			{
				hpalOld = SelectPalette(hdc, phost->_hpal, TRUE);
				RealizePalette(hdc);
			}

			// Since we are using the CS_PARENTDC style, make sure
			// the clip region is limited to our client window.
			GetClientRect(hwnd, &rcClient);
			SaveDC(hdc);
			IntersectClipRect(hdc, rcClient.left, rcClient.top, rcClient.right,
				rcClient.bottom);

#if 0		// Useful for debugging
			TCHAR rgch[512];
			wsprintf(rgch, TEXT("Paint : (%d, %d, %d, %d)\n"),
							rcClient.left,
							rcClient.top,
							rcClient.right,
							rcClient.bottom);
			OutputDebugString(rgch);
#endif

			phost->_pserv->TxDraw(
				DVASPECT_CONTENT,  		// Draw Aspect
				-1,						// Lindex
				NULL,					// Info for drawing optimazation
				NULL,					// target device information
				hdc,					// Draw device HDC
				NULL, 				   	// Target device HDC
				(const RECTL *) &rcClient,// Bounding client rectangle
				NULL,	                // Clipping rectangle for metafiles
				&ps.rcPaint,			// Update rectangle
				NULL, 	   				// Call back function
				NULL,					// Call back parameter
				TXTVIEW_ACTIVE);		// What view - the active one!

			// Restore palette if there is one
#ifndef PEGASUS
			if(hpalOld)
				SelectPalette(hdc, hpalOld, TRUE);
#endif

			if(phost->TxGetEffects() == TXTEFFECT_SUNKEN && dwMajorVersion < VERS4)
				phost->DrawSunkenBorder(hwnd, hdc);

			RestoreDC(hdc, -1);
			EndPaint(hwnd, &ps);
		}
		break;

	case EM_SETMARGINS:

		phost->OnSetMargins(wparam, LOWORD(lparam), HIWORD(lparam));
		break;

	case EM_SETPALETTE:

		// Application is setting a palette for us to use.
		phost->_hpal = (HPALETTE) wparam;

		// Invalidate the window & repaint to reflect the new palette.
		InvalidateRect(hwnd, NULL, FALSE);
		break;

	default:
serv:
		hr = phost->_pserv->TxSendMessage(msg, wparam, lparam, &lres);
		if(hr == S_FALSE)
		{			
			// Message was not processed by text services so send it
			// to the default window proc.
			lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		}
	}

Exit:
	phost->Release();
	return lres;
}
												
static BOOL GetIconic(
	HWND hwnd)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "GetIconic");

	while(hwnd)
	{
		if(IsIconic(hwnd))
			return TRUE;
		hwnd = GetParent(hwnd);
	}
	return FALSE;
}

//////////////// CTxtWinHost Creation/Initialization/Destruction ///////////////////////

/*
 *	CTxtWinHost::OnNCCreate (hwnd, pcs)
 *
 *	@mfunc
 *		Static global method to handle WM_NCCREATE message (see remain.c)
 */
CTxtWinHost *CTxtWinHost::OnNCCreate(
	HWND hwnd,
	const CREATESTRUCT *pcs,
	BOOL fIsAnsi,
	BOOL fIs10Mode)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnNCCreate");

#if defined DEBUG && !defined(PEGASUS)
	GdiSetBatchLimit(1);
#endif

	CTxtWinHost *phost = new CTxtWinHost();

	if(!phost)
		return 0;

	CREATESTRUCT cs = *pcs;			// prefer C++ compiler not to modify constant

	//bug fix #5386
	// Window wasn't created with the Richedit20A window class
	// and we are under Win9x, need to convert string to UNICODE
	CStrInW strinwName(((LPSTR)pcs->lpszName), GetKeyboardCodePage());
	CStrInW strinwClass(((LPSTR)pcs->lpszClass), CP_ACP);
	if (!fIsAnsi && W32->OnWin9x())
	{
		cs.lpszName = (WCHAR *)strinwName;
		cs.lpszClass = (WCHAR *)strinwClass;
	}

	// Stores phost in associated window data
	if(!phost->Init(hwnd, (const CREATESTRUCT*)&cs, fIsAnsi, fIs10Mode))
	{
		phost->Shutdown();
		delete phost;
		phost = NULL;
	}
	return phost;
}

/*
 *	CTxtWinHost::OnNCDestroy (phost)
 *
 *	@mfunc
 *		Static global method to handle WM_CREATE message
 *
 *	@devnote
 *		phost ptr is stored in window data (GetWindowLong())
 */
void CTxtWinHost::OnNCDestroy(
	CTxtWinHost *phost)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnNCDestroy");

	phost->Shutdown();
	phost->Release();
}

/*
 *	CTxtWinHost::CTxtWinHost()
 *
 *	@mfunc
 *		constructor
 */
CTxtWinHost::CTxtWinHost()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::CTxtWinHost");

#ifndef NOACCESSIBILITY
    _pTypeInfo = NULL;
#endif

	_fRegisteredForDrop = FALSE;
	_crefs = 1;	
	if(!_fNotSysBkgnd)
		_crBackground = GetSysColor(COLOR_WINDOW);
}

/*
 *	CTxtWinHost::~CTxtWinHost()
 *
 *	@mfunc
 *		destructor
 */
CTxtWinHost::~CTxtWinHost()
{
	AssertSz(_pserv == NULL,
		"CTxtWinHost::~CTxtWinHost - shutdown not called till destructor");

	if(_pserv)
		Shutdown();
}

/*
 *	CTxtWinHost::Shutdown()
 *
 *	@mfunc	Shut down this object, but doesn't delete memory
 */
void CTxtWinHost::Shutdown()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::Shutdown");
	ITextServices *pserv;
	
	HostRevokeDragDrop();					// Revoke our drop target
	
	if(_pserv)
	{
		// Guarantee that no recursive callbacks can happen during shutdown.
		pserv = _pserv;
		_pserv = NULL;

		pserv->OnTxInPlaceDeactivate();
		pserv->Release();

		// Host release was not the final release so notify
		// text services that they need to keep their reference
		// to the host valid.
		if (!_fTextServiceFree)
		{
			((CTxtEdit *)pserv)->SetReleaseHost();

		}
	}


	ImmTerminate();						// Terminate only useful on Mac.
	if(_hwnd)
		SetWindowLongPtr(_hwnd, ibPed, 0);
}

/*
 *	CTxtWinHost::Init (hwnd, pcs)
 *
 *	@mfunc
 *		Initialize this CTxtWinHost
 */
BOOL CTxtWinHost::Init(
	HWND hwnd,					//@parm Window handle for this control
	const CREATESTRUCT *pcs,	//@parm Corresponding CREATESTRUCT
	BOOL fIsAnsi,				//@parm is ansi window
	BOOL fIs10Mode)				//@parm is 1.0 mode window
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::Init");

	AssertSz(!fIs10Mode || (fIsAnsi && fIs10Mode),
		"CTxtWinHost::Init input flags are out of sync!");

	if(!pcs->lpszClass)
		return FALSE;

	// Set pointer back to CTxtWinHost from the window
	if(hwnd)
		SetWindowLongPtr(hwnd, ibPed, (INT_PTR)this);
		
	_hwnd = hwnd;

	// Here we want to keep track of the "RichEdit20A"window class
	// The RICHEDIT window class is handled by a wrapper dll.
	// If the class name is "RICHEDIT", then we need to turn on the
	// RichEdit 1.0 compatibility bit.  IsAnsiWindowClass tests that class as well.
	_fANSIwindow = fIsAnsi;

 	// Edit controls created without a window are multiline by default
	// so that paragraph formats can be
	_dwStyle = ES_MULTILINE;
	_fHidden = TRUE;
	
	if(pcs)
	{
		_hwndParent = pcs->hwndParent;
		_dwExStyle	= pcs->dwExStyle;
		_dwStyle	= pcs->style;

		if (!fIs10Mode)
		{
			// Only set this for 2.0 windows
			// According to the edit control documentation WS_HSCROLL implies that
			// ES_AUTOSCROLL is set and WS_VSCROLL implies that ES_AUTOVSCROLL is
			// set. Here, we make this so.
			if(_dwStyle & WS_HSCROLL)
				_dwStyle |= ES_AUTOHSCROLL;

			// handle default disabled
			if(_dwStyle & WS_DISABLED)
				_fDisabled = TRUE;
		}
		else
		{
		if (GetBkMode(GetDC(hwnd)) == TRANSPARENT)
			{
			_dwExStyle |= WS_EX_TRANSPARENT;
			}
		else
			{
			_dwExStyle &= ~WS_EX_TRANSPARENT;
			}
		}

		if(_dwStyle & WS_VSCROLL)
			_dwStyle |= ES_AUTOVSCROLL;

		_fBorder = !!(_dwStyle & WS_BORDER);

		if((_dwStyle & ES_SUNKEN) || (_dwExStyle & WS_EX_CLIENTEDGE))
			_fBorder = TRUE;

		// handle default passwords
		if(_dwStyle & ES_PASSWORD)
			_chPassword = TEXT('*');

		// On Win95 ES_SUNKEN and WS_BORDER get mapped to WS_EX_CLIENTEDGE
		if(_fBorder && dwMajorVersion >= VERS4)
        {
			_dwExStyle |= WS_EX_CLIENTEDGE;
			SetWindowLong(_hwnd, GWL_EXSTYLE, _dwExStyle);
        }

		// Process some flags for mirrored control
		if (_dwExStyle & WS_EX_LAYOUTRTL)
		{
			// Swap whatever RTL params we have
			_dwStyle = (_dwStyle & ~ES_RIGHT) | (_dwStyle & ES_RIGHT ^ ES_RIGHT);
			_dwExStyle = (_dwExStyle & ~WS_EX_RTLREADING) | (_dwExStyle & WS_EX_RTLREADING ^ WS_EX_RTLREADING);
			_dwExStyle = (_dwExStyle & ~WS_EX_LEFTSCROLLBAR) |
						 (_dwStyle & ES_RIGHT ? WS_EX_LEFTSCROLLBAR : 0);
	
			// Disable mirroring layout to avoid GDI mirroring mapping mode
			_dwExStyle &= ~WS_EX_LAYOUTRTL;
	
			SetWindowLong(_hwnd, GWL_STYLE, _dwStyle);
			SetWindowLong(_hwnd, GWL_EXSTYLE, _dwExStyle);
		}
	}

	// Create Text Services component
	// Watch out for sys param and sys font initialization!!  see below.
	if(FAILED(CreateTextServices()))
		return FALSE;

	_xInset = (char)W32->GetCxBorder();
	_yInset = (char)W32->GetCyBorder();

	if (!_fBorder)
	{
		_xInset += _xInset;
		_yInset += _yInset;
	}

	// At this point the border flag is set and so is the pixels per inch
	// so we can initalize the inset.
	// This must be done after CreatingTextServices so sys params are valid
	SetDefaultInset();

	// Set alignment and paragraph direction
	PARAFORMAT PF2;
	
	PF2.dwMask = 0;

	BOOL fRCAlign = _dwStyle & (ES_RIGHT | ES_CENTER) || _dwExStyle & WS_EX_RIGHT;
	if(fRCAlign)
	{
		PF2.dwMask |= PFM_ALIGNMENT;
		PF2.wAlignment = (WORD)(_dwStyle & ES_CENTER ? PFA_CENTER : PFA_RIGHT);	// right or center-aligned
	}

	if(_dwExStyle & WS_EX_RTLREADING)
	{
		PF2.dwMask |= PFM_RTLPARA;
		PF2.wEffects = PFE_RTLPARA;		// RTL reading order
	}

	if (PF2.dwMask)
	{
		PF2.cbSize = sizeof(PARAFORMAT2);
		//  tell text services
		_pserv->TxSendMessage(EM_SETPARAFORMAT, SPF_SETDEFAULT, (LPARAM)&PF2, NULL);
	}

	if (fIs10Mode)
	{
		 ((CTxtEdit *)_pserv)->Set10Mode();
		 // Remove the WS_VSCROLL and WS_HSCROLL initially
        if (_hwnd && !(_dwStyle & ES_DISABLENOSCROLL))
        {
            SetScrollRange(_hwnd, SB_VERT, 0, 0, TRUE);
    		SetScrollRange(_hwnd, SB_HORZ, 0, 0, TRUE);
            DWORD dwStyle = _dwStyle & ~(WS_VSCROLL | WS_HSCROLL);
            SetWindowLong(_hwnd, GWL_STYLE, dwStyle);

            // bug fix:
            // On some systems, ie Digital PII-266, we don't get a WM_PAINT message
            // when we change the window style.  So force a WM_PAINT into the message queue
            InvalidateRect(_hwnd, NULL, TRUE);
        }
    }

	// Set window text
	if(pcs && pcs->lpszName)
	{
		if(FAILED(_pserv->TxSetText((TCHAR *)pcs->lpszName)))
		{
			SafeReleaseAndNULL((IUnknown **)&_pserv);
			return FALSE;
		}
	}

	if(_dwStyle & ES_LOWERCASE)
		_pserv->TxSendMessage(EM_SETEDITSTYLE, SES_LOWERCASE,
							  SES_LOWERCASE | SES_UPPERCASE, NULL);

	if(!ImmInitialize())			// Mac Only
	{
		#if defined(DEBUG) && defined(MACPORT)
		OutputDebugString(TEXT("Could not register Imm ImmInitializeForMac.\r\n"));
		#endif	// DEBUG
	}

	return TRUE;
}

HRESULT CTxtWinHost::CreateTextServices()
{
	IUnknown *pUnk;
	HRESULT	  hr = ::CreateTextServices(NULL, this, &pUnk);

	if(hr != NOERROR)
		return hr;

	// Get text services interface
	hr = pUnk->QueryInterface(IID_ITextServices, (void **)&_pserv);

	// Regardless of whether the previous call succeeded or failed, we are
	// done with the private interface.
	pUnk->Release();

	if(hr == NOERROR)
	{
		((CTxtEdit *)_pserv)->_fInOurHost = TRUE;
		// FE extended styles might set the fFE bit
		if(_dwExStyle & (WS_EX_RIGHT | WS_EX_RTLREADING | WS_EX_LEFTSCROLLBAR))
			_pserv->TxSendMessage(EM_SETEDITSTYLE, SES_BIDI, SES_BIDI, NULL);
	}

	return hr;
}

/*
 *	CTxtWinHost::OnCreate (pcs)
 *
 *	@mfunc
 *		Handle WM_CREATE message
 *
 *	@rdesc
 *		LRESULT = -1 if failed to in-place activate; else 0
 */
LRESULT CTxtWinHost::OnCreate(
	const CREATESTRUCT *pcs)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnCreate");

	RECT rcClient;

	// sometimes, these values are -1 (from windows itself); just treat them
	// as zero in that case
	LONG cy = (pcs->cy < 0) ? 0 : pcs->cy;
	LONG cx = (pcs->cx < 0) ? 0 : pcs->cx;

	rcClient.top = pcs->y;
	rcClient.bottom = rcClient.top + cy;
	rcClient.left = pcs->x;
	rcClient.right = rcClient.left + cx;
	
	// Notify Text Services that we are in place active
	if(FAILED(_pserv->OnTxInPlaceActivate(&rcClient)))
		return -1;

	DWORD dwStyle = GetWindowLong(_hwnd, GWL_STYLE);
	
	// Hide all scrollbars to start	
	if(_hwnd && !(dwStyle & ES_DISABLENOSCROLL) && !((CTxtEdit *)_pserv)->Get10Mode())
	{
		SetScrollRange(_hwnd, SB_VERT, 0, 0, TRUE);
		SetScrollRange(_hwnd, SB_HORZ, 0, 0, TRUE);

		dwStyle &= ~(WS_VSCROLL | WS_HSCROLL);
		SetWindowLong(_hwnd, GWL_STYLE, dwStyle);		
	}

	if(!(dwStyle & (ES_READONLY | ES_NOOLEDRAGDROP)))
	{
		// This isn't a read only window or a no drop window,
		// so we need a drop target.
		HostRegisterDragDrop();
	}

	_usIMEMode = 0;	
	if(dwStyle & ES_NOIME)
	{
		_usIMEMode = ES_NOIME;
		// Tell textservices to turnoff ime
		_pserv->TxSendMessage(EM_SETEDITSTYLE, SES_NOIME, SES_NOIME, NULL);	
	}
	else if(dwStyle & ES_SELFIME)
		_usIMEMode = ES_SELFIME;

	return 0;
}


/////////////////////////////////  IUnknown ////////////////////////////////

HRESULT CTxtWinHost::QueryInterface(REFIID riid, void **ppv)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::QueryInterface");

  	if(IsEqualIID(riid, IID_IUnknown))
		*ppv = (IUnknown *)(ITextHost2*)this;

	else if(IsEqualIID(riid, IID_ITextHost) )
		*ppv = (ITextHost *)(CTxtWinHost*)this;

	else if(IsEqualIID(riid, IID_ITextHost2) )
		*ppv = (ITextHost2 *)(CTxtWinHost*)this;

	else
		*ppv = NULL;

	if(*ppv)
	{
		AddRef();
		return NOERROR;
	}
	return E_NOINTERFACE;
}

ULONG CTxtWinHost::AddRef(void)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::AddRef");

	return ++_crefs;
}

ULONG CTxtWinHost::Release(void)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::Release");

	--_crefs;

	if(!_crefs)
	{
#ifndef NOACCESSIBILITY
        if(_pTypeInfo)
        {
            _pTypeInfo->Release();
            _pTypeInfo = NULL;
        }
#endif
		delete this;
		return 0;
	}
	return _crefs;
}


//////////////////////////////// Activation ////////////////////////////////

//////////////////////////////// Properties ////////////////////////////////


TXTEFFECT CTxtWinHost::TxGetEffects() const
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::TxGetEffects");

	if((_dwStyle & ES_SUNKEN) || (_dwExStyle & WS_EX_CLIENTEDGE))
		return TXTEFFECT_SUNKEN;

	return TXTEFFECT_NONE;
}

///////////////////////////////  Keyboard Messages  //////////////////////////////////

/*
 *	CTxtWinHost::OnKeyDown (vkey, dwFlags)
 *
 *	@mfunc
 *		Handle WM_KEYDOWN messages that need to send a message to the parent
 *		window (may happen when control is in a dialog box)
 *
 *	#rdesc
 *		LRESULT = (code processed) ? 0 : 1
 */
LRESULT CTxtWinHost::OnKeyDown(
	WORD	vkey,			//@parm WM_KEYDOWN wparam (virtual key code)
	DWORD	dwFlags)		//@parm WM_KEYDOWN flags
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnKeyDown");

	if(!_fInDialogBox) 					// Not in a dialog box
		return 1;						// Signal key-down msg not processed

	DWORD dwKeyFlags = GetKeyboardFlags();

	switch(vkey)
	{
	case VK_ESCAPE:
		PostMessage(_hwndParent, WM_CLOSE, 0, 0);
		return 0;
	
	case VK_RETURN:
		if(!(dwKeyFlags & CTRL) && !(_dwStyle & ES_WANTRETURN))
		{
			// Send to default button
			HWND	hwndT;
			LRESULT id = SendMessage(_hwndParent, DM_GETDEFID, 0, 0);

			if(LOWORD(id) && (hwndT = GetDlgItem(_hwndParent, LOWORD(id))))
			{
				SendMessage(_hwndParent, WM_NEXTDLGCTL, (WPARAM) hwndT, (LPARAM) 1);
				if(GetFocus() != _hwnd)
					PostMessage(hwndT, WM_KEYDOWN, (WPARAM) VK_RETURN, 0);
			}
			return 0;
		}
		break;

	case VK_TAB:
		if(!(dwKeyFlags & CTRL))
		{
			SendMessage(_hwndParent, WM_NEXTDLGCTL,
								!!(dwKeyFlags & SHIFT), 0);
			return 0;
		}
		break;
	}

	return 1;
}

/*
 *	CTxtWinHost::OnChar (vkey, dwFlags)
 *
 *	@mfunc
 *		Eat some WM_CHAR messages for a control in a dialog box
 *
 *	#rdesc
 *		LRESULT = (code processed) ? 0 : 1
 */
LRESULT CTxtWinHost::OnChar(
	WORD	vkey,			//@parm WM_CHAR wparam (translated key code)
	DWORD	dwFlags)		//@parm WM_CHAR flags
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnChar");

	if(!_fInDialogBox || (GetKeyboardFlags() & CTRL))
		return 1;
	
	switch(vkey)
	{
	case 'J' - 0x40:					// Ctrl-Return generates Ctrl-J (LF):
	case VK_RETURN:						//  treat it as an ordinary return
		// We need to filter-out cases where we don't want to insert <cr> in
		// 1.0 mode here since the info isn't available within the ped
		if (((CTxtEdit*)_pserv)->Get10Mode())
		{
			if (_fInDialogBox && dwFlags != MK_CONTROL && !(_dwStyle & ES_WANTRETURN))
				return 0;
				
			if (!(_dwStyle & ES_MULTILINE))
			{
				//richedit beeps in this case
				((CTxtEdit*)_pserv)->Beep();
				return 0;
			}
		}
		else if (!(_dwStyle & ES_WANTRETURN))
			return 0;					// Signal char processed (eaten)		
		break;

	case VK_TAB:
		return 0;
	}
	
	return 1;							// Signal char not processed
}


/////////////////////////////////  View rectangle //////////////////////////////////////

void CTxtWinHost::OnGetRect(
	LPRECT prc)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnGetRect");

	RECT rcInset;
	LONG lSelBarWidth = 0;

	if(_fEmSetRectCalled)
	{
		// Get the selection bar width and add it back to the view inset so
		// we return the rectangle that the application set.
		TxGetSelectionBarWidth(&lSelBarWidth);
	}

	// Get view inset (in HIMETRIC)
	TxGetViewInset(&rcInset);

	// Get client rect in pixels
	TxGetClientRect(prc);

	// Modify the client rect by the inset converted to pixels
	prc->left	+= W32->HimetricXtoDX(rcInset.left + lSelBarWidth, W32->GetXPerInchScreenDC());
	prc->top	+= W32->HimetricYtoDY(rcInset.top, W32->GetYPerInchScreenDC());
	prc->right	-= W32->HimetricXtoDX(rcInset.right, W32->GetXPerInchScreenDC());
	prc->bottom -= W32->HimetricYtoDY(rcInset.bottom, W32->GetYPerInchScreenDC());
}

void CTxtWinHost::OnSetRect(
	LPRECT prc,				//@parm Desired formatting RECT
	BOOL fNewBehavior,		//@parm If TRUE, prc is inset RECT directly
	BOOL fRedraw)			//@parm If TRUE, redraw after setting RECT
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnSetRect");

	RECT rcClient;
	LONG lSelBarWidth;
	
	// Assuming this is not set to the default, turn on special EM_SETRECT
	// processing. The important part of this is that we subtract the selection
	// bar from the view inset because the EM_SETRECT rectangle does not
	// include the selection bar.
	_fEmSetRectCalled = TRUE;

	if(!prc)
	{
		// We are back to the default so turn off special EM_SETRECT procesing.
		_fEmSetRectCalled = FALSE;
		SetDefaultInset();
	}
	else	
	{
		// For screen display, the following intersects new view RECT
		// with adjusted client area RECT
		TxGetClientRect(&rcClient);

		// Adjust client rect. Factors in space for borders
		if(_fBorder)
		{																					
			rcClient.top		+= _yInset;
			rcClient.bottom 	-= _yInset - 1;
			rcClient.left		+= _xInset;
			rcClient.right		-= _xInset;
		}
	
		if(!fNewBehavior)
		{
			// Intersect new view rectangle with adjusted client area rectangle
			if(!IntersectRect(&_rcViewInset, &rcClient, prc))
				_rcViewInset = rcClient;
		}
		else
			_rcViewInset = *prc;

		// Get selection bar width
		TxGetSelectionBarWidth(&lSelBarWidth);

		// Compute inset in pixels and convert to HIMETRIC.
		_rcViewInset.left = W32->DXtoHimetricX(_rcViewInset.left - rcClient.left, W32->GetXPerInchScreenDC())
			- lSelBarWidth;
		_rcViewInset.top = W32->DYtoHimetricY(_rcViewInset.top - rcClient.top, W32->GetYPerInchScreenDC());
		_rcViewInset.right = W32->DXtoHimetricX(rcClient.right
			- _rcViewInset.right, W32->GetXPerInchScreenDC());
		_rcViewInset.bottom = W32->DYtoHimetricY(rcClient.bottom
			- _rcViewInset.bottom, W32->GetYPerInchScreenDC());
	}
	if(fRedraw)
	{
		_pserv->OnTxPropertyBitsChange(TXTBIT_VIEWINSETCHANGE,
			TXTBIT_VIEWINSETCHANGE);
	}
}


///////////////////////////////  System notifications  //////////////////////////////////

void CTxtWinHost::OnSysColorChange()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnSysColorChange");

	if(!_fNotSysBkgnd)
		_crBackground = GetSysColor(COLOR_WINDOW);
	TxInvalidateRect(NULL, TRUE);
}

/*
 *	CTxtWinHost::OnGetDlgCode (wparam, lparam)
 *
 *	@mfunc
 *		Handle some WM_GETDLGCODE messages
 *
 *	#rdesc
 *		LRESULT = dialog code
 */
LRESULT CTxtWinHost::OnGetDlgCode(
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnGetDlgCode");

	LRESULT lres = DLGC_WANTCHARS | DLGC_WANTARROWS | DLGC_WANTTAB;

	if(_dwStyle & ES_MULTILINE)
		lres |= DLGC_WANTALLKEYS;

	if(!(_dwStyle & ES_SAVESEL))
		lres |= DLGC_HASSETSEL;

	// HACK: If we get one of these messages then we turn on the special
	// EM_SETSEL behavior. The problem is that _fInDialogBox gets turned
	// on after the EM_SETSEL has occurred.
	_fUseSpecialSetSel = TRUE;

	/*
	** -------------------------------------------- JEFFBOG HACK ----
	** Only set Dialog Box Flag if GETDLGCODE message is generated by
	** IsDialogMessage -- if so, the lParam will be a pointer to the
	** message structure passed to IsDialogMessage; otherwise, lParam
	** will be NULL.  Reason for the HACK alert:  the wParam & lParam
	** for GETDLGCODE is still not clearly defined and may end up
	** changing in a way that would throw this off
	** -------------------------------------------- JEFFBOG HACK ----
	 */
	if(lparam)
		_fInDialogBox = TRUE;

	/*
	** If this is a WM_SYSCHAR message generated by the UNDO keystroke
	** we want this message so we can EAT IT in remain.c, case WM_SYSCHAR:
	 */
	if (lparam &&
		(((LPMSG)lparam)->message == WM_SYSCHAR)  &&
		(((LPMSG)lparam)->lParam & SYS_ALTERNATE) &&	
		wparam == VK_BACK)
	{
		lres |= DLGC_WANTMESSAGE;
	}

	return lres;
}


/////////////////////////////////  Other messages  //////////////////////////////////////

LRESULT CTxtWinHost::OnGetOptions() const
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnGetOptions");

	LRESULT lres = (_dwStyle & ECO_STYLES);

	if(_fEnableAutoWordSel)
		lres |= ECO_AUTOWORDSELECTION;
	
	return lres;
}

void CTxtWinHost::OnSetOptions(
	WORD  wOp,
	DWORD eco)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnSetOptions");

	DWORD		dwChangeMask = 0;
	DWORD		dwProp = 0;
	DWORD		dwStyle;
	DWORD		dwStyleNew = _dwStyle;
	const BOOL	fAutoWordSel = !!(eco & ECO_AUTOWORDSELECTION);		
	BOOL		bNeedToTurnOffIME = FALSE;

	// We keep track of the bits changed and then if any have changed we
	// query for all of our property bits and then send them. This simplifies
	// the code because we don't have to set all the bits specially. If the
	// code is changed to make the properties more in line with the new
	// model, we want to look at this code again.

	// Single line controls can't have a selection bar or do vertical writing
	if(!(_dwStyle & ES_MULTILINE))
		eco &= ~ECO_SELECTIONBAR;

	Assert((DWORD)fAutoWordSel <= 1);			// Make sure that BOOL is 1/0
	dwStyle = (eco & ECO_STYLES);

	switch(wOp)
	{
	case ECOOP_SET:
		dwStyleNew			= (dwStyleNew & ~ECO_STYLES) | dwStyle;
		_fEnableAutoWordSel = fAutoWordSel;
		break;

	case ECOOP_OR:
		dwStyleNew |= dwStyle;					// Setting a :1 flag = TRUE
		if(fAutoWordSel)						//  or FALSE is 1 instruction
			_fEnableAutoWordSel = TRUE;			// Setting it to a BOOL
		break;									//  averages 9 instructions!

	case ECOOP_AND:
		dwStyleNew &= (dwStyle | ~ECO_STYLES);
		if(!fAutoWordSel)
			_fEnableAutoWordSel = FALSE;
		break;

	case ECOOP_XOR:
		dwStyleNew ^= dwStyle;
		if(fAutoWordSel)
			_fEnableAutoWordSel ^= 1;
		break;
	}

	if(_fEnableAutoWordSel != (unsigned)fAutoWordSel)
		dwChangeMask |= TXTBIT_AUTOWORDSEL;

	if(dwStyleNew != _dwStyle)
	{
		DWORD dwChange = dwStyleNew ^ _dwStyle;

		AssertSz(!(dwChange & ~ECO_STYLES), "non-eco style changed");
		_dwStyle = dwStyleNew;
		SetWindowLong(_hwnd, GWL_STYLE, dwStyleNew);

		if(dwChange & ES_NOHIDESEL)	
			dwChangeMask |= TXTBIT_HIDESELECTION;

		// These two local variables to use to keep track of
		// previous setting of ES_READONLY
		BOOL bReadOnly = (_dwStyle & ES_READONLY);

		if(dwChange & ES_READONLY)
		{
			dwChangeMask |= TXTBIT_READONLY;

			// Change drop target state as appropriate.
			if(dwStyleNew & ES_READONLY)
				HostRevokeDragDrop();

			else
				HostRegisterDragDrop();
			
			bReadOnly = (dwStyleNew & ES_READONLY);
		}

		if(dwChange & ES_VERTICAL)
			dwChangeMask |= TXTBIT_VERTICAL;

		if(dwChange & ES_NOIME)
		{
			_usIMEMode = (dwStyleNew & ES_NOIME) ? ES_NOIME : 0;
			bNeedToTurnOffIME = (_usIMEMode ==ES_NOIME);
		}
		else if(dwChange & ES_SELFIME)
			_usIMEMode = (dwStyleNew & ES_SELFIME) ? ES_SELFIME : 0;
		
		// No action required for ES_WANTRETURN nor for ES_SAVESEL
		// Do this last
		if(dwChange & ES_SELECTIONBAR)
			dwChangeMask |= TXTBIT_SELBARCHANGE;
	}

	if (dwChangeMask)
	{
		TxGetPropertyBits(dwChangeMask, &dwProp);
		_pserv->OnTxPropertyBitsChange(dwChangeMask, dwProp);
	}

	if (bNeedToTurnOffIME)
		// Tell textservices to turnoff ime
		_pserv->TxSendMessage(EM_SETEDITSTYLE, SES_NOIME, SES_NOIME, NULL);	
}

void CTxtWinHost::OnSetReadOnly(
	BOOL fReadOnly)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnSetReadOnly");

	DWORD dwT = GetWindowLong(_hwnd, GWL_STYLE);
	DWORD dwUpdatedBits = 0;

	if(fReadOnly)
	{
		dwT |= ES_READONLY;
		_dwStyle |= ES_READONLY;

		// Turn off Drag Drop
		HostRevokeDragDrop();
		dwUpdatedBits |= TXTBIT_READONLY;
	}
	else
	{
		dwT		 &= ~ES_READONLY;
		_dwStyle &= ~ES_READONLY;

		// Turn drag drop back on
		HostRegisterDragDrop();	
	}

	_pserv->OnTxPropertyBitsChange(TXTBIT_READONLY, dwUpdatedBits);

	SetWindowLong(_hwnd, GWL_STYLE, dwT);
}


////////////////////////////////////  Helpers  /////////////////////////////////////////

void CTxtWinHost::SetDefaultInset()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::SetDefaultInset");

	// Generate default view rect from client rect
	if(_fBorder)
	{
		// Factors in space for borders
  		_rcViewInset.top	= W32->DYtoHimetricY(_yInset, W32->GetYPerInchScreenDC());
   		_rcViewInset.bottom	= W32->DYtoHimetricY(_yInset - 1, W32->GetYPerInchScreenDC());
   		_rcViewInset.left	= W32->DXtoHimetricX(_xInset, W32->GetXPerInchScreenDC());
   		_rcViewInset.right	= W32->DXtoHimetricX(_xInset, W32->GetXPerInchScreenDC());
	}
	else
	{
		// Default the top and bottom inset to 0 and the left and right
		// to the size of the border.
		_rcViewInset.top = 0;
		_rcViewInset.bottom = 0;
		_rcViewInset.left = W32->DXtoHimetricX(W32->GetCxBorder(), W32->GetXPerInchScreenDC());
		_rcViewInset.right = W32->DXtoHimetricX(W32->GetCxBorder(), W32->GetXPerInchScreenDC());
	}
}


/////////////////////////////////  Far East Support  //////////////////////////////////////

//#ifdef WIN95_IME
HIMC CTxtWinHost::TxImmGetContext()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::TxImmGetContext");

	HIMC himc;

	Assert(_hwnd);
	himc = ImmGetContext(_hwnd);
	return himc;
}

void CTxtWinHost::TxImmReleaseContext(
	HIMC himc)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::TxImmReleaseContext");

	Assert(_hwnd);
	ImmReleaseContext(_hwnd, himc);
}

//#endif

void CTxtWinHost::HostRevokeDragDrop()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::HostRevokeDragDrop");

	if(_fRegisteredForDrop)
	{
		// Note that if the revoke fails we want to know about this in debug
		// builds so we can fix any problems. In retail, we can't really do
		// so we just ignore it.
#ifdef DEBUG
		HRESULT hr =
#endif // DEBUG

			RevokeDragDrop(_hwnd);

#ifdef DEBUG
		TESTANDTRACEHR(hr);
#endif // DEBUG

		_fRegisteredForDrop = FALSE;
	}
}

void CTxtWinHost::HostRegisterDragDrop()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::RegisterDragDrop");

	IDropTarget *pdt;

	if(!_fRegisteredForDrop && _pserv->TxGetDropTarget(&pdt) == NOERROR)
	{
		// The most likely reason for RegisterDragDrop to fail is some kind of
		// bug in our program.

		HRESULT hr = RegisterDragDrop(_hwnd, pdt);

		if(hr == NOERROR)
			_fRegisteredForDrop = TRUE;

#ifndef PEGASUS
		pdt->Release();
#endif
	}
}


static void DrawRectFn(
	HDC hdc,
	RECT *prc,
	INT icrTL,
	INT icrBR,
	BOOL fBot,
	BOOL fRght)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "DrawRectFn");

	COLORREF cr = GetSysColor(icrTL);
	COLORREF crSave = SetBkColor(hdc, cr);
	RECT rc = *prc;

	// top
	rc.bottom = rc.top + 1;
	ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);

	// left
	rc.bottom = prc->bottom;
	rc.right = rc.left + 1;
	ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);

	if(icrTL != icrBR)
	{
		cr = GetSysColor(icrBR);
		SetBkColor(hdc, cr);
	}

	// right
	rc.right = prc->right;
	rc.left = rc.right - 1;
	if(!fBot)
		rc.bottom -= W32->GetCyHScroll();
	if(fRght)
		ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);

	// bottom
	if(fBot)
	{
		rc.left = prc->left;
		rc.top = rc.bottom - 1;
		if(!fRght)
			rc.right -= W32->GetCxVScroll();
		ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
	}
	SetBkColor(hdc, crSave);
}

#define cmultBorder 1

void CTxtWinHost::OnSunkenWindowPosChanging(
	HWND hwnd,
	WINDOWPOS *pwndpos)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnSunkenWindowPosChanging");

	if(IsWindowVisible(hwnd))
	{
		RECT rc;
		HWND hwndParent;

		GetWindowRect(hwnd, &rc);
		InflateRect(&rc, W32->GetCxBorder() * cmultBorder, W32->GetCyBorder() * cmultBorder);
		hwndParent = GetParent(hwnd);
		MapWindowPoints(HWND_DESKTOP, hwndParent, (POINT *) &rc, 2);
		InvalidateRect(hwndParent, &rc, FALSE);
	}
}

void CTxtWinHost::DrawSunkenBorder(
	HWND hwnd,
	HDC hdc)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::DrawSunkenBorder");
	BOOL fVScroll = (_dwStyle & WS_VSCROLL);
	BOOL fHScroll = (_dwStyle & WS_HSCROLL);

	RECT rc;
	RECT rcParent;
	HWND hwndParent;

	// if we're not visible, don't do anything.
	if(!IsWindowVisible(hwnd))
		return;

	GetWindowRect(hwnd, &rc);
	hwndParent = GetParent(hwnd);
	rcParent = rc;
	MapWindowPoints(HWND_DESKTOP, hwndParent, (POINT *)&rcParent, 2);
	InflateRect(&rcParent, W32->GetCxBorder(), W32->GetCyBorder());
	OffsetRect(&rc, -rc.left, -rc.top);

	if(_pserv)
	{
		// If we have a text control then get whether it thinks there are
		// scroll bars.
		_pserv->TxGetHScroll(NULL, NULL, NULL, NULL, &fHScroll);
		_pserv->TxGetVScroll(NULL, NULL, NULL, NULL, &fVScroll);
	}


	// Draw inner rect
	DrawRectFn(hdc, &rc, icr3DDarkShadow, COLOR_BTNFACE,
		!fHScroll, !fVScroll);

	// Draw outer rect
	hwndParent = GetParent(hwnd);
	hdc = GetDC(hwndParent);
	DrawRectFn(hdc, &rcParent, COLOR_BTNSHADOW, COLOR_BTNHIGHLIGHT,
		TRUE, TRUE);
	ReleaseDC(hwndParent, hdc);
}

LRESULT CTxtWinHost::OnSize(
	HWND hwnd,
	WORD fwSizeType,
	int  nWidth,
	int  nHeight)
{	
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnSize");

	BOOL fIconic = GetIconic(hwnd);
	DWORD dw = TXTBIT_CLIENTRECTCHANGE;
	if(_sWidth != nWidth && !fIconic && !_fIconic)
	{
		_sWidth = (short)nWidth;				// Be sure to update _sWidth
		dw = TXTBIT_EXTENTCHANGE;
	}

	if(!_fVisible)
	{
		if(!fIconic)
			_fResized = TRUE;
	}
	else if(!fIconic)
	{
		// We use this property because this will force a recalc.
		// We don't actually recalc on a client rect change because
		// most of the time it is pointless. We force one here because
		// some applications use size changes to calculate the optimal
		// size of the window.
		_pserv->OnTxPropertyBitsChange(dw, dw);

		if(_fIconic)
		{
			TRACEINFOSZ("Restoring from iconic");
			InvalidateRect(hwnd, NULL, FALSE);
		}
			
		// Draw borders
		if(TxGetEffects() == TXTEFFECT_SUNKEN && dwMajorVersion < VERS4)
			DrawSunkenBorder(hwnd, NULL);
	}
	_fIconic = fIconic;						// Update _fIconic
	return 0;
}

HRESULT CTxtWinHost::OnTxVisibleChange(
	BOOL fVisible)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnTxVisibleChange");

	_fVisible = fVisible;

	if(!_fVisible && _fResized)
	{
		RECT rc;
		// Control was resized while hidden, need to really resize now
		TxGetClientRect(&rc);
		_fResized = FALSE;
		_pserv->OnTxPropertyBitsChange(TXTBIT_CLIENTRECTCHANGE,
				TXTBIT_CLIENTRECTCHANGE);
	}
	return S_OK;
}


//////////////////////////// ITextHost Interface  ////////////////////////////

// @doc EXTERNAL
/*
 *	CTxtWinHost::TxGetDC()
 *
 *	@mfunc
 *		Abstracts GetDC so Text Services does not need a window handle.
 *
 *	@rdesc
 *		A DC or NULL in the event of an error.
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
HDC CTxtWinHost::TxGetDC()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetDC");

	Assert(_hwnd);
	return ::GetDC(_hwnd);
}

/*
 *	CTxtWinHost::TxReleaseDC (hdc)
 *
 *	@mfunc
 *		Release DC gotten by TxGetDC.
 *
 *	@rdesc	
 *		1 - HDC was released. <nl>
 *		0 - HDC was not released. <nl>
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
int CTxtWinHost::TxReleaseDC(
	HDC hdc)				//@parm	DC to release
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxReleaseDC");

	Assert(_hwnd);
	return ::ReleaseDC (_hwnd, hdc);
}

/*
 *	CTxtWinHost::TxShowScrollBar (fnBar, fShow)
 *
 *	@mfunc
 *		Shows or Hides scroll bar in Text Host window
 *
 *	@rdesc
 *		TRUE on success, FALSE otherwise
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
BOOL CTxtWinHost::TxShowScrollBar(
	INT  fnBar, 		//@parm	Specifies scroll bar(s) to be shown or hidden
	BOOL fShow)			//@parm	Specifies whether scroll bar is shown or hidden
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxShowScrollBar");

	Assert(_hwnd);
	LONG nMax;

	if(fnBar == SB_HORZ)
		_pserv->TxGetHScroll(NULL, &nMax, NULL, NULL, NULL);
	else
		_pserv->TxGetVScroll(NULL, &nMax, NULL, NULL, NULL);

	return W32->ShowScrollBar(_hwnd, fnBar, fShow, nMax);
}

/*
 *	CTxtWinHost::TxEnableScrollBar (fuSBFlags, fuArrowflags)
 *
 *	@mfunc
 *		Enables or disables one or both scroll bar arrows
 *		in Text Host window.
 *
 *	@rdesc
 *		If the arrows are enabled or disabled as specified, the return
 *		value is TRUE. If the arrows are already in the requested state or an
 *		error occurs, the return value is FALSE.
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.	
 */
BOOL CTxtWinHost::TxEnableScrollBar (
	INT fuSBFlags, 		//@parm Specifies scroll bar type	
	INT fuArrowflags)	//@parm	Specifies whether and which scroll bar arrows
						//		are enabled or disabled
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxEnableScrollBar");

	Assert(_hwnd);
	return W32->EnableScrollBar(_hwnd, fuSBFlags, fuArrowflags);
}

/*
 *	CTxtWinHost::TxSetScrollRange (fnBar, nMinPos, nMaxPos, fRedraw)
 *
 *	@mfunc
 *		Sets the minimum and maximum position values for the specified
 *		scroll bar in the text host window.
 *
 *	@rdesc
 *		If the arrows are enabled or disabled as specified, the return value
 *		is TRUE. If the arrows are already in the requested state or an error
 *		occurs, the return value is FALSE.
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
BOOL CTxtWinHost::TxSetScrollRange(
	INT	 fnBar, 		//@parm	Scroll bar flag
	LONG nMinPos, 		//@parm	Minimum scrolling position
	INT  nMaxPos, 		//@parm	Maximum scrolling position
	BOOL fRedraw)		//@parm	Specifies whether scroll bar should be redrawn
{						//		to reflect change
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxSetScrollRange");

	Assert(_hwnd);

	if(NULL == _pserv)
	{
		// We are initializing so do this instead of callback
		return ::SetScrollRange(_hwnd, fnBar, nMinPos, nMaxPos, fRedraw);
	}
	SetScrollInfo(fnBar, fRedraw);
	return TRUE;
}

/*
 *	CTxtWinHost::TxSetScrollPos (fnBar, nPos, fRedraw)
 *
 *	@mfunc
 *		Tells Text host to set the position of the scroll box (thumb) in the
 *		specified scroll bar and, if requested, redraws the scroll bar to
 *		reflect the new position of the scroll box.
 *
 *	@rdesc
 *		TRUE on success; FALSE otherwise.
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
BOOL CTxtWinHost::TxSetScrollPos (
	INT		fnBar, 		//@parm	Scroll bar flag
	INT		nPos, 		//@parm	New position in scroll box
	BOOL	fRedraw)	//@parm	Redraw flag
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxSetScrollPos");

	Assert(_hwnd);

	if(NULL == _pserv)
	{
		// We are initializing so do this instead of callback
		return ::SetScrollPos(_hwnd, fnBar, nPos, fRedraw);
	}
	SetScrollInfo(fnBar, fRedraw);
	return TRUE;
}

/*
 *	CTxtWinHost::TxInvalidateRect (prc, fMode)
 *
 *	@mfunc
 *		Adds a rectangle to the Text Host window's update region
 *
 *	@comm
 *		This function may be called while inactive; however the host
 *		implementation is free to invalidate an area greater than
 *		the requested rect.
 */
void CTxtWinHost::TxInvalidateRect(
	LPCRECT	prc, 		//@parm	Address of rectangle coordinates
	BOOL	fMode)		//@parm	Erase background flag
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxInvalidateRect");

	Assert(_hwnd);

	if(!_fVisible)
	{
		// There doesn't seem to be a deterministic way to determine whether
		// our window is visible or not via message notifications. Therefore,
		// we check this each time incase it might have changed.
		_fVisible = IsWindowVisible(_hwnd);

		if(_fVisible)
			OnTxVisibleChange(TRUE);
	}

	// Don't bother with invalidating rect if we aren't visible
	if(_fVisible)
	{
		if(IsTransparentMode())
		{
			RECT	rcParent;
			HWND	hParent = ::GetParent (_hwnd);
		
			Assert(hParent);

	 		// For transparent mode, we need to invalidate the parent
			// so it will paint the background.
			if(prc)
				rcParent = *prc;
			else
				TxGetClientRect(&rcParent);	

			::MapWindowPoints(_hwnd, hParent, (LPPOINT)&rcParent, 2);
			::InvalidateRect(hParent, &rcParent, fMode);
//			::HideCaret(_hwnd);
		}
		::InvalidateRect(_hwnd, prc, fMode);
	}
}

/*
 *	CTxtWinHost::TxViewChange (fUpdate)
 *
 *	@mfunc
 *		Notify Text Host that update region should be repainted.
 *	
 *	@comm
 *		It is the responsibility of the text services to call
 *		TxViewChanged every time it decides that it's visual representation
 *		has changed, regardless of whether the control is active or
 *		not. If the control is active, the text services has the additional
 *		responsibility of making sure the controls window is updated.
 *		It can do this in a number of ways: 1) get a DC for the control's
 *		window and start blasting pixels (TxGetDC and TxReleaseDC), 2)
 *		invalidate the control's window (TxInvalidate), or 3) scroll
 *		the control's window (TxScrollWindowEx).
 *
 *		Text services can choose to call TxViewChange after it has
 *		performed any operations to update the active view and pass a
 *		true along with the call.  By passing true, the text host
 *		calls UpdateWindow to make sure any unpainted areas of the
 *		active control are repainted.
 */
void CTxtWinHost::TxViewChange(
	BOOL fUpdate)		//@parm TRUE = call update window
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxViewChange");

	Assert(_hwnd);

	// Don't bother with paint since we aren't visible
	if(_fVisible)
	{
		// For updates requests that are FALSE, we will let the next WM_PAINT
		// message pick up the draw.
		if(fUpdate)
		{
			if(IsTransparentMode())
			{
				HWND	hParent = GetParent (_hwnd);
				Assert(hParent);

	 			// For transparent mode, we need to update the parent first
				// before we can update ourself.  Otherwise, what we painted will
				// be erased by the parent's background later.
				::UpdateWindow (hParent);
			}
			::UpdateWindow (_hwnd);
		}
	}
}

/*
 *	CTxtWinHost::TxCreateCaret (hbmp, xWidth, yHeight)
 *
 *	@mfunc
 *		Create new shape for Text Host's caret
 *
 *	@rdesc
 *		TRUE on success, FALSE otherwise.
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
BOOL CTxtWinHost::TxCreateCaret(
	HBITMAP hbmp, 		//@parm Handle of bitmap for caret shape	
	INT xWidth, 		//@parm	Caret width
	INT yHeight)		//@parm	Caret height
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxCreateCaret");

	Assert(_hwnd);
	return ::CreateCaret (_hwnd, hbmp, xWidth, yHeight);
}

/*
 *	CTxtWinHost::TxShowCaret (fShow)
 *
 *	@mfunc
 *		Make caret visible/invisible at caret position in Text Host window.
 *
 *	@rdesc	
 *		TRUE - call succeeded <nl>
 *		FALSE - call failed <nl>
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
BOOL CTxtWinHost::TxShowCaret(
	BOOL fShow)			//@parm Flag whether caret is visible
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxShowCaret");

	return fShow ? ::ShowCaret(_hwnd)  :  ::HideCaret(_hwnd);
}

/*
 *	CTxtWinHost::TxSetCaretPos (x, y)
 *
 *	@mfunc
 *		Move caret position to specified coordinates in Text Host window.
 *
 *	@rdesc	
 *		TRUE - call succeeded <nl>
 *		FALSE - call failed <nl>
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
BOOL CTxtWinHost::TxSetCaretPos(
	INT x, 				//@parm	Horizontal position (in client coordinates)
	INT y)				//@parm	Vertical position (in client coordinates)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxSetCaretPos");

	return ::SetCaretPos(x, y);
}

/*
 *	CTxtWinHost::TxSetTimer (idTimer, uTimeout)
 *
 *	@mfunc
 *		Request Text Host to creates a timer with specified time out.
 *
 *	@rdesc	
 *		TRUE - call succeeded <nl>
 *		FALSE - call failed <nl>
 */
BOOL CTxtWinHost::TxSetTimer(
	UINT idTimer, 		//@parm Timer identifier	
	UINT uTimeout)		//@parm	Timeout in msec
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxSetTimer");

	Assert(_hwnd);	
	return ::SetTimer(_hwnd, idTimer, uTimeout, NULL);
}

/*
 *	CTxtWinHost::TxKillTimer (idTimer)
 *
 *	@mfunc
 *		Destroy specified timer
 *
 *	@rdesc	
 *		TRUE - call succeeded <nl>
 *		FALSE - call failed <nl>
 *
 *	@comm
 *		This method may be called at any time irrespective of active versus
 *		inactive state.
 */
void CTxtWinHost::TxKillTimer(
	UINT idTimer)		//@parm	id of timer
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxKillTimer");

	Assert(_hwnd);			
	::KillTimer(_hwnd, idTimer);
}

/*
 *	CTxtWinHost::TxScrollWindowEx (dx, dy, lprcScroll, lprcClip, hrgnUpdate,
 *									lprcUpdate, fuScroll)
 *	@mfunc
 *		Request Text Host to scroll the content of the specified client area
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
void CTxtWinHost::TxScrollWindowEx (
	INT		dx, 			//@parm	Amount of horizontal scrolling
	INT		dy, 			//@parm	Amount of vertical scrolling
	LPCRECT lprcScroll, 	//@parm	Scroll rectangle
	LPCRECT lprcClip,		//@parm	Clip rectangle
	HRGN	hrgnUpdate, 	//@parm	Handle of update region
	LPRECT	lprcUpdate,		//@parm	Update rectangle
	UINT	fuScroll)		//@parm	Scrolling flags
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxScrollWindowEx");

	Assert(_hwnd);
	::ScrollWindowEx(_hwnd, dx, dy, lprcScroll, lprcClip, hrgnUpdate, lprcUpdate, fuScroll);
}

/*
 *	CTxtWinHost::TxSetCapture (fCapture)
 *
 *	@mfunc
 *		Set mouse capture in Text Host's window.
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may do nothing.
 */
void CTxtWinHost::TxSetCapture(
	BOOL fCapture)		//@parm	Whether to get or release capture
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxSetCapture");

	Assert(_hwnd);
	if (fCapture)
		::SetCapture(_hwnd);
	else
		::ReleaseCapture();
}

/*
 *	CTxtWinHost::TxSetFocus ()
 *
 *	@mfunc
 *		Set focus in text host window.
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
void CTxtWinHost::TxSetFocus()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxSetFocus");

	Assert(_hwnd);
	::SetFocus(_hwnd);
}

/*
 *	CTxtWinHost::TxSetCursor (hcur, fText)
 *
 *	@mfunc
 *		Establish a new cursor shape in the Text Host's window.
 *
 *	@comm
 *		This method may be called at any time, irrespective of
 *		active vs. inactive state.
 *
 *		ITextHost::TxSetCursor should be called back by the Text Services
 *		to actually set the mouse cursor. If the fText parameter is TRUE,
 *		Text Services is trying to set the "text" cursor (cursor over text
 *		that is not selected, currently an IBEAM). In that case, the host
 *		can set it to whatever the control MousePointer property is. This is
 *		required by VB compatibility since, via the MousePointer property,
 *		the VB programmer has control over the shape of the mouse cursor,
 *		whenever it would normally be set to an IBEAM.
 */
void CTxtWinHost::TxSetCursor(
	HCURSOR hcur,		//@parm	Handle to cursor
	BOOL	fText)		//@parm Indicates caller wants to set text cursor
						//		(IBeam) if true.
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxSetCursor");

	::SetCursor(hcur);
}

/*
 *	CTxtWinHost::TxScreenToClient (lppt)
 *
 *	@mfunc
 *		Convert screen coordinates to Text Host window coordinates.
 *
 *	@rdesc	
 *		TRUE - call succeeded <nl>
 *		FALSE - call failed <nl>
 */
BOOL CTxtWinHost::TxScreenToClient(
	LPPOINT lppt)		//@parm	Coordinates for point
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxScreenToClient");

	Assert(_hwnd);
	return ::ScreenToClient(_hwnd, lppt);	
}

/*
 *	CTxtWinHost::TxClientToScreen (lppt)
 *
 *	@mfunc
 *		Convert Text Host coordinates to screen coordinates
 *
 *	@rdesc	
 *		TRUE - call succeeded <nl>
 *		FALSE - call failed <nl>
 *
 *	@comm
 *		This call is valid at any time, although it is allowed to
 *		fail.  In general, if text services has coordinates it needs
 *		to translate from client coordinates (e.g. for TOM's
 *		PointFromRange method) the text services will actually be
 *		visible.
 *
 *		However, if no conversion is possible, then the method will fail.
 */
BOOL CTxtWinHost::TxClientToScreen(
	LPPOINT lppt)		//@parm	Client coordinates to convert.
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxClientToScreen");

	Assert(_hwnd);
	return ::ClientToScreen(_hwnd, lppt);
}

/*
 *	CTxtWinHost::TxActivate (plOldState)
 *
 *	@mfunc
 *		Notify Text Host that control is active
 *
 *	@rdesc	
 *		S_OK 	- call succeeded. <nl>
 *		E_FAIL	- activation is not possible at this time
 *
 *	@comm
 *		It is legal for the host to refuse an activation request;
 *		the control may be minimized and thus invisible, for instance.
 *
 *		The caller should be able to gracefully handle failure to activate.
 *
 *		Calling this method more than once does not cumulate; only
 *		once TxDeactivate call is necessary to deactive.
 *
 *		This function returns an opaque handle in <p plOldState>. The caller
 *		(Text Services) should hang onto this handle and return it in a
 *		subsequent call to TxDeactivate.
 */
HRESULT CTxtWinHost::TxActivate(
	LONG *plOldState)	//@parm Where to put previous activation state
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxActivate");

	return S_OK;
}

/*
 *	CTxtWinHost::TxDeactivate (lNewState)
 *
 *	@mfunc
 *		Notify Text Host that control is now inactive
 *
 *	@rdesc	
 *		S_OK - call succeeded. <nl>
 *		E_FAIL				   <nl>
 *
 *	@comm
 *		Calling this method more than once does not cumulate
 */
HRESULT CTxtWinHost::TxDeactivate(
	LONG lNewState)		//@parm	New state (typically value returned by
						//		TxActivate
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxDeactivate");

	return S_OK;
}
	
/*
 *	CTxtWinHost::TxGetClientRect (prc)
 *
 *	@mfunc
 *		Retrive client coordinates of Text Host's client area.
 *
 *	@rdesc
 *		HRESULT = (success) ? S_OK : E_FAIL
 */
HRESULT CTxtWinHost::TxGetClientRect(
	LPRECT prc)		//@parm	Where to put client coordinates
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetClientRect");

	Assert(_hwnd && prc);
	return ::GetClientRect(_hwnd, prc) ? S_OK : E_FAIL;
}

/*
 *	CTxtWinHost::TxGetViewInset	(prc)
 *
 *	@mfunc
 *		Get inset for Text Host window.  Inset is the "white space"
 *		around text.
 *
 *	@rdesc
 *		HRESULT = NOERROR
 *
 *	@comm
 *		The Inset rectangle is not strictly a rectangle.  The top, bottom,
 *		left, and right fields of the rect structure indicate how far in
 *		each direction drawing should be inset. Inset sizes are in client
 *		coordinates.
 */
HRESULT CTxtWinHost::TxGetViewInset(
	LPRECT prc)			//@parm Where to put inset rectangle	
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetViewInset");

	Assert(prc);

	*prc = _rcViewInset;
	return NOERROR;	
}

/*
 *	CTxtWinHost::TxGetCharFormat (ppCF)
 *
 *	@mfunc
 *		Get Text Host's default character format
 *
 *	@rdesc
 *		HRESULT = E_NOTIMPL (not needed in simple Windows host, since text
 *		services provides desired default)
 *
 *	@comm
 *		The callee retains ownwership of the charformat returned.  However,
 *		the pointer returned must remain valid until the callee notifies
 *		Text Services via OnTxPropertyBitsChange that the default character
 *		format has changed.
 */
HRESULT CTxtWinHost::TxGetCharFormat(
	const CHARFORMAT **ppCF) 		//@parm	Where to put ptr to default
									//		character format
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetCharFormat");

	return E_NOTIMPL;
}

/*
 *	CTxtWinHost::TxGetParaFormat (ppPF)
 *
 *	@mfunc
 *		Get Text Host default paragraph format
 *
 *	@rdesc
 *		HRESULT = E_NOTIMPL (not needed in simple Windows host, since text
 *		services provides desired default)
 *
 *	@comm
 *		The host object (callee) retains ownership of the PARAFORMAT returned.
 *		However, the pointer returned must remain valid until the host notifies
 *		Text Services (the caller) via OnTxPropertyBitsChange that the default
 *		paragraph format has changed.
 */
HRESULT CTxtWinHost::TxGetParaFormat(
	const PARAFORMAT **ppPF) 	//@parm Where to put ptr to default
								//		paragraph format
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetParaFormat");

	return E_NOTIMPL;
}

/*
 *	CTxtWinHost::TxGetSysColor (nIndex)
 *
 *	@mfunc
 *		Get specified color identifer from Text Host.
 *
 *	@rdesc
 *		Color identifier
 *
 *	@comm
 *		Note that the color returned may be *different* than the
 *		color that would be returned from a call to GetSysColor.
 *		This allows hosts to override default system behavior.
 *
 *		Needless to say, hosts should be very careful about overriding
 *		normal system behavior as it could result in inconsistent UI
 *		(particularly with respect to Accessibility	options).
 */
COLORREF CTxtWinHost::TxGetSysColor(
	int nIndex)			//@parm Color to get, same parameter as
						//		GetSysColor Win32 API
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetSysColor");

	if (!_fDisabled ||
		nIndex != COLOR_WINDOW && nIndex != COLOR_WINDOWTEXT)
	{
		// This window is not disabled or the color is not interesting
		// in the disabled case.
		return (nIndex == COLOR_WINDOW && _fNotSysBkgnd)
			? _crBackground : GetSysColor(nIndex);
	}

	// Disabled case
	if (COLOR_WINDOWTEXT == nIndex)
	{
		// Color of text for disabled window
		return GetSysColor(COLOR_GRAYTEXT);
	}

	// Background color for disabled window
	return GetSysColor(COLOR_3DFACE);
	
}

/*
 *	CTxtWinHost::TxGetBackStyle	(pstyle)
 *
 *	@mfunc
 *		Get Text Host background style.
 *
 *	@rdesc
 *		HRESULT = S_OK
 *
 *	@xref	<e TXTBACKSTYLE>
 */
HRESULT CTxtWinHost::TxGetBackStyle(
	TXTBACKSTYLE *pstyle)  //@parm Where to put background style
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetBackStyle");

	*pstyle = (_dwExStyle & WS_EX_TRANSPARENT)
			? TXTBACK_TRANSPARENT : TXTBACK_OPAQUE;
	return NOERROR;
}

/*
 *	CTxtWinHost::TxGetMaxLength	(pLength)
 *
 *	@mfunc
 *		Get Text Host's maximum allowed length.
 *
 *	@rdesc
 *		HRESULT = S_OK	
 *
 *	@comm
 *		This method parallels the EM_LIMITTEXT message.
 *		If INFINITE (0xFFFFFFFF) is returned, then text services
 *		will use as much memory as needed to store any given text.
 *
 *		If the limit returned is less than the number of characters
 *		currently in the text engine, no data is lost.  Instead,
 *		no edits will be allowed to the text *other* than deletion
 *		until the text is reduced to below the limit.
 */
HRESULT CTxtWinHost::TxGetMaxLength(
	DWORD *pLength) 	//@parm Maximum allowed length, in number of
						//		characters
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetMaxLength");
	AssertSz(FALSE, "CTxtWinHost::TxGetMaxLength why is this being called?");
	return NOERROR;
}

/*
 *	CTxtWinHost::TxGetScrollBars (pdwScrollBar)
 *
 *	@mfunc
 *		Get Text Host's scroll bars supported.
 *
 *	@rdesc
 *		HRESULT = S_OK
 *
 *	@comm
 *		<p pdwScrollBar> is filled with a boolean combination of the
 *		window styles related to scroll bars.  Specifically, these are:
 *
 *			WS_VSCROLL	<nl>
 *			WS_HSCROLL	<nl>
 *			ES_AUTOVSCROLL	<nl>
 *			ES_AUTOHSCROLL	<nl>
 *			ES_DISABLENOSCROLL	<nl>
 */
HRESULT CTxtWinHost::TxGetScrollBars(
	DWORD *pdwScrollBar) 	//@parm Where to put scrollbar information
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetScrollBars");

	*pdwScrollBar =  _dwStyle & (WS_VSCROLL | WS_HSCROLL | ES_AUTOVSCROLL |
						ES_AUTOHSCROLL | ES_DISABLENOSCROLL);
	return NOERROR;
}

/*
 *	CTxtWinHost::TxGetPasswordChar (pch)
 *
 *	@mfunc
 *		Get Text Host's password character.
 *
 *	@rdesc
 *		HRESULT = (password character not enabled) ? S_FALSE : S_OK
 *
 *	@comm
 *		The password char will only be shown if the TXTBIT_USEPASSWORD bit
 *		is enabled in TextServices.  If the password character changes,
 *		re-enable the TXTBIT_USEPASSWORD bit via
 *		ITextServices::OnTxPropertyBitsChange.
 */
HRESULT CTxtWinHost::TxGetPasswordChar(
	TCHAR *pch)		//@parm Where to put password character
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetPasswordChar");

	*pch = _chPassword;
	return NOERROR;
}

/*
 *	CTxtWinHost::TxGetAcceleratorPos (pcp)
 *
 *	@mfunc
 *		Get special character to use for underlining accelerator character.
 *
 *	@rdesc
 *		Via <p pcp>, returns character position at which underlining
 *		should occur.  -1 indicates that no character should be underlined.
 *		Return value is an HRESULT (usually S_OK).
 *
 *	@comm
 *		Accelerators allow keyboard shortcuts to various UI elements (like
 *		buttons.  Typically, the shortcut character is underlined.
 *
 *		This function tells Text Services which character is the accelerator
 *		and thus should be underlined.  Note that Text Services will *not*
 *		process accelerators; that is the responsiblity of the host.
 *
 *		This method will typically only be called if the TXTBIT_SHOWACCELERATOR
 *		bit is set in text services.
 *
 *		Note that *any* change to the text in text services will result in the
 *		invalidation of the accelerator underlining.  In this case, it is the
 *		host's responsibility to recompute the appropriate character position
 *		and inform text services that a new accelerator is available.
 */
HRESULT CTxtWinHost::TxGetAcceleratorPos(
	LONG *pcp) 		//@parm Out parm to receive cp of character to underline
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetAcceleratorPos");

	*pcp = -1;
	return S_OK;
} 										

/*
 *	CTxtWinHost::OnTxCharFormatChange
 *
 *	@mfunc
 *		Set default character format for the Text Host.
 *
 *	@rdesc
 *		S_OK - call succeeded.	<nl>
 *		E_INVALIDARG			<nl>
 *		E_FAIL					<nl>
 */
HRESULT CTxtWinHost::OnTxCharFormatChange(
	const CHARFORMAT *pcf) //@parm New default character format	
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::OnTxCharFormatChange");

	return S_OK;
}

/*
 *	CTxtWinHost::OnTxParaFormatChange
 *
 *	@mfunc
 *		Set default paragraph format for the Text Host.
 *
 *	@rdesc
 *		S_OK - call succeeded.	<nl>
 *		E_INVALIDARG			<nl>
 *		E_FAIL					<nl>
 */
HRESULT CTxtWinHost::OnTxParaFormatChange(
	const PARAFORMAT *ppf) //@parm New default paragraph format	
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::OnTxParaFormatChange");

	return S_OK;
}

/*
 *	CTxtWinHost::TxGetPropertyBits (dwMask, dwBits)
 *
 *	@mfunc
 *		Get the bit property settings for Text Host.
 *
 *	@rdesc
 *		S_OK
 *
 *	@comm
 *		This call is valid at any time, for any combination of
 *		requested property bits.  <p dwMask> may be used by the
 *		caller to request specific properties.	
 */
HRESULT CTxtWinHost::TxGetPropertyBits(
	DWORD dwMask,		//@parm	Mask of bit properties to get
	DWORD *pdwBits)		//@parm Where to put bit values
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetPropertyBits");

// FUTURE: Obvious optimization is to save bits in host the same way that
// they are returned and just return them instead of this mess.

	// Note: this RichEdit host never sets TXTBIT_SHOWACCELERATOR or
	// TXTBIT_SAVESELECTION. They are currently only used by Forms^3 host.
	// This host is always rich text.

	DWORD dwProperties = TXTBIT_RICHTEXT | TXTBIT_ALLOWBEEP;

#ifdef DEBUG
	// make sure that TS doesn't think it's plain text mode when
	// we return TXTBIT_RICHTEXT
	if((dwMask & TXTBIT_RICHTEXT) && _pserv)
	{
		DWORD mode;
		mode = _pserv->TxSendMessage(EM_GETTEXTMODE, 0, 0, NULL);
		Assert(mode == TM_RICHTEXT);
	}
#endif // DEBUG

	if(_dwStyle & ES_MULTILINE)
		dwProperties |= TXTBIT_MULTILINE;

	if(_dwStyle & ES_READONLY)
		dwProperties |= TXTBIT_READONLY;

	if(_dwStyle & ES_PASSWORD)
		dwProperties |= TXTBIT_USEPASSWORD;

	if(!(_dwStyle & ES_NOHIDESEL))
		dwProperties |= TXTBIT_HIDESELECTION;

	if(_fEnableAutoWordSel)
		dwProperties |= TXTBIT_AUTOWORDSEL;

	if(!(_dwStyle & ES_AUTOHSCROLL))
		dwProperties |= TXTBIT_WORDWRAP;

	if(_dwStyle & ES_NOOLEDRAGDROP)
		dwProperties |= TXTBIT_DISABLEDRAG;

	*pdwBits = dwProperties & dwMask;
	return NOERROR;
}

/*
 *	CTxtWinHost::TxNotify (iNotify,	pv)
 *
 *	@mfunc
 *		Notify Text Host of various events.  Note that there are
 *		two basic categories of events, "direct" events and
 *		"delayed" events.  Direct events are sent immediately as
 *		they need some processing: EN_PROTECTED is a canonical
 *		example.  Delayed events are sent after all processing
 *		has occurred; the control is thus in a "stable" state.
 *		EN_CHANGE, EN_ERRSPACE, EN_SELCHANGED are examples
 *		of delayed notifications.
 *
 *
 *	@rdesc	
 *		S_OK - call succeeded <nl>
 *		S_FALSE	-- success, but do some different action
 *		depending on the event type (see below).
 *
 *	@comm
 *		The notification events are the same as the notification
 *		messages sent to the parent window of a richedit window.
 *		The firing of events may be controlled with a mask set via
 *		the EM_SETEVENTMASK message.
 *
 *		In general, is legal to make any calls to text services while
 *		processing this method; however, implementors are cautioned
 *		to avoid excessive recursion.
 *
 *		Here is the complete list of notifications that may be
 *		sent and a brief description of each:
 *
 *		<p EN_CHANGE>		Sent when some data in the edit control
 *		changes (such as text or formatting).  Controlled by the
 *		ENM_CHANGE event mask.  This notification is sent _after_
 *		any screen updates have been requested.
 *
 *		<p EN_CORRECTTEXT>	PenWin only; currently unused.
 *
 *		<p EN_DROPFILES>	If the client registered the edit
 *		control via DragAcceptFiles, this event will be sent when
 *		a WM_DROPFILES or DragEnter(CF_HDROP) message is received.
 *		If S_FALSE is returned, the drop will be ignored, otherwise,
 *		the drop will be processed.  The ENM_DROPFILES mask
 *		controls this event notification.
 *
 *		<p EN_ERRSPACE>		Sent when the edit control cannot
 *		allocate enough memory.  No additional data is sent and
 *		there is no mask for this event.
 *
 *		<p EN_HSCROLL>		Sent when the user clicks on an edit
 *		control's horizontal scroll bar, but before the screen
 *		is updated.  No additional data is sent.  The ENM_SCROLL
 *		mask controls this event.
 *
 *		<p EN_IMECHANGE>	unused
 *
 *		<p EN_KILLFOCUS>	Sent when the edit control looses focus.
 *		No additional data is sent and there is no mask.
 *
 *		<p EN_MAXTEXT>	Sent when the current text insertion
 *		has exceeded the specified number of characters for the
 *		edit control.  The text insertion has been truncated.
 *		There is no mask for this event.
 *
 *		<p EN_MSGFILTER>	NB!!! THIS MESSAGE IS NOT SENT TO
 *		TxNotify, but is included here for completeness.  With
 *		ITextServices::TxSendMessage, client have complete
 *		flexibility in filtering all window messages.
 *	
 *		Sent on a keyboard or mouse event
 *		in the control.  A MSGFILTER data structure is sent,
 *		containing the msg, wparam and lparam.  If S_FALSE is
 *		returned from this notification, the msg is processed by
 *		TextServices, otherwise, the message is ignored.  Note
 *		that in this case, the callee has the opportunity to modify
 *		the msg, wparam, and lparam before TextServices continues
 *		processing.  The ENM_KEYEVENTS and ENM_MOUSEEVENTS masks
 *		control this event for the respective event types.
 *
 *		<p EN_OLEOPFAILED> 	Sent when an OLE call fails.  The
 *		ENOLEOPFAILED struct is passed with the index of the object
 *		and the error code.  Mask value is nothing.
 *		
 *		<p EN_PROTECTED>	Sent when the user is taking an
 *		action that would change a protected range of text.  An
 *		ENPROTECTED data structure is sent, indicating the range
 *		of text affected and the window message (if any) affecting
 *		the change.  If S_FALSE is returned, the edit will fail.
 *		The ENM_PROTECTED mask controls this event.
 *
 *		<p EN_REQUESTRESIZE>	Sent when a control's contents are
 *		either smaller or larger than the control's window size.
 *		The client is responsible for resizing the control.  A
 *		REQRESIZE structure is sent, indicating the new size of
 *		the control.  NB!  Only the size is indicated in this
 *		structure; it is the host's responsibility to do any
 *		translation necessary to generate a new client rectangle.
 *		The ENM_REQUESTRESIZE mask controls this event.
 *
 *		<p EN_SAVECLIPBOARD> Sent when an edit control is being
 *		destroyed, the callee should indicate whether or not
 *		OleFlushClipboard should be called.  Data indicating the
 *		number of characters and objects to be flushed is sent
 *		in the ENSAVECLIPBOARD data structure.
 *		Mask value is nothing.
 *
 *		<p EN_SELCHANGE>	Sent when the current selection has
 *		changed.  A SELCHANGE data structure is also sent, which
 *		indicates the new selection range at the type of data
 *		the selection is currently over.  Controlled via the
 *		ENM_SELCHANGE mask.
 *
 *		<p EN_SETFOCUS>	Sent when the edit control receives the
 *		keyboard focus.  No extra data is sent; there is no mask.
 *
 *		<p EN_STOPNOUNDO>	Sent when an action occurs for which
 *		the control cannot allocate enough memory to maintain the
 *		undo state.  If S_FALSE is returned, the action will be
 *		stopped; otherwise, the action will continue.
 *
 *		<p EN_UPDATE>	Sent before an edit control requests a
 *		redraw of altered data or text.  No additional data is
 *		sent.  This event is controlled via the ENM_UPDATE mask.
 *
 *		<p EN_VSCROLL>	Sent when the user clicks an edit control's
 *		vertical scrollbar bar before the screen is updated.
 *		Controlled via the ENM_SCROLL mask; no extra data is sent.
 *
 *		<p EN_LINK>		Sent when a mouse event (or WM_SETCURSOR) happens
 *		over a range of text that has the EN_LINK mask bit set.
 *		An ENLINK data structure will be sent with relevant info.
 */
HRESULT CTxtWinHost::TxNotify(
	DWORD iNotify,		//@parm	Event to notify host of.  One of the
						//		EN_XXX values from Win32, e.g., EN_CHANGE
	void *pv)			//@parm In-only parameter with extra data.  Type
						//		dependent on <p iNotify>
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxNotify");

	HRESULT		hr = NOERROR;
	LONG		nId;
	NMHDR *		phdr;
	REQRESIZE *	preq;
	RECT		rcOld;

	// We assume here that TextServices has already masked out notifications,
	// so if we get one here, it should be sent
	if(_hwndParent)
	{
		nId = GetWindowLong(_hwnd, GWL_ID);
		// First, handle WM_NOTIFY style notifications
		switch(iNotify)
		{
		case EN_REQUESTRESIZE:
			// Need to map new size into correct rectangle
			Assert(pv);
			GetWindowRect(_hwnd, &rcOld);
			MapWindowPoints(HWND_DESKTOP, _hwndParent, (POINT *) &rcOld, 2);
			
			preq = (REQRESIZE *)pv;
			preq->rc.top	= rcOld.top;
			preq->rc.left	= rcOld.left;
			preq->rc.right	+= rcOld.left;
			preq->rc.bottom += rcOld.top;

			// FALL-THROUGH!!
					
		case EN_DROPFILES:
		case EN_MSGFILTER:
		case EN_OLEOPFAILED:
		case EN_PROTECTED:
		case EN_SAVECLIPBOARD:
		case EN_SELCHANGE:
		case EN_STOPNOUNDO:
		case EN_LINK:
		case EN_OBJECTPOSITIONS:
		case EN_DRAGDROPDONE:
	
			if(pv)						// Fill out NMHDR portion of pv
			{
				phdr = (NMHDR *)pv;
  				phdr->hwndFrom = _hwnd;
				phdr->idFrom = nId;
				phdr->code = iNotify;
			}

			if(SendMessage(_hwndParent, WM_NOTIFY, (WPARAM) nId, (LPARAM) pv))
				hr = S_FALSE;
			break;

		default:
			SendMessage(_hwndParent, WM_COMMAND,
					GET_WM_COMMAND_MPS(nId, _hwnd, iNotify));
		}
	}

	return hr;
}

/*
 *	CTxtWinHost::TxGetExtent (lpExtent)
 *
 *	@mfunc
 *		Return native size of the control in HIMETRIC
 *
 *	@rdesc
 *		S_OK	<nl>
 *		some failure code <nl>
 *
 *	@comm
 *		This method is used by Text Services to implement zooming.
 *		Text Services would derive the zoom factor from the ratio between
 *		the himetric and device pixel extent of the client rectangle.
 *	
 *		[vertical zoom factor] = [pixel height of the client rect] * 2540
 *		/ [himetric vertical extent] * [pixel per vertical inch (from DC)]
 *	
 *		If the vertical and horizontal zoom factors are not the same, Text
 *		Services could ignore the horizontal zoom factor and assume it is
 *		the same as the vertical one.
 */
HRESULT CTxtWinHost::TxGetExtent(
	LPSIZEL lpExtent) 	//@parm  Extent in himetric
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetExtent");

	AssertSz(lpExtent, "CTxtWinHost::TxGetExtent Invalid lpExtent");

	// We could implement the TxGetExtent in the following way. However, the
	// call to this in ITextServices is implemented in such a way that it
	// does something sensible in the face of an error in this call. That
	// something sensible is that it sets the extent equal to the current
	// client rectangle which is what the following does in a rather convoluted
	// manner. Therefore, we dump the following and just return an error.


#if 0
	// The window's host extent is always the same as the client
	// rectangle.
	RECT rc;
	HRESULT hr = TxGetClientRect(&rc);

	// Get our client rectangle
	if(SUCCEEDED(hr))
	{
		// Calculate the length & convert to himetric
		lpExtent->cx = DXtoHimetricX(rc.right - rc.left, W32->GetXPerInchScreenDC());
		lpExtent->cy = DYtoHimetricY(rc.bottom - rc.top, W32->GetYPerInchScreenDC());
	}

	return hr;
#endif // 0

	return E_NOTIMPL;
}

/*
 *	CTxtWinHost::TxGetSelectionBarWidth (lSelBarWidth)
 *
 *	@mfunc
 *		Returns size of selection bar in HIMETRIC
 *
 *	@rdesc
 *		S_OK	<nl>
 */
HRESULT	CTxtWinHost::TxGetSelectionBarWidth (
	LONG *lSelBarWidth)		//@parm  Where to return selection bar width
							// in HIMETRIC
{
	*lSelBarWidth = (_dwStyle & ES_SELECTIONBAR) ? W32->GetDxSelBar() : 0;
	return S_OK;
}

//
//	ITextHost2 methods
//

/*
 *	CTxtWinHost::TxIsDoubleClickPending
 *
 *	@mfunc	Look into the message queue for this hwnd and see if a
 *			double click is pending.  This enables TextServices to
 *			effeciently transition between two inplace active objects.
 *
 *	@rdesc	BOOL
 */
BOOL CTxtWinHost::TxIsDoubleClickPending()
{
	MSG msg;

	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN,
			"CTxtWinHost::TxIsDoubleClickPending");

	if(PeekMessage(&msg, _hwnd, WM_LBUTTONDBLCLK, WM_LBUTTONDBLCLK,
			PM_NOREMOVE | PM_NOYIELD))
	{
		return TRUE;
	}
	return FALSE;
}

/*
 *	CTxtWinHost::TxGetWindow
 *
 *	@mfunc	Fetches the window associated with this control (or
 *			set of controls potentially).  Useful for answering
 *			IOleWindow::GetWindow.
 *
 *	@rdesc	HRESULT
 */
HRESULT CTxtWinHost::TxGetWindow(HWND *phwnd)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::GetWindow");
	
	*phwnd = _hwnd;
	return NOERROR;
}	


/*
 *	CTxtWinHost::SetForegroundWindow
 *
 *	@mfunc	Sets window to foreground window & gives the focus
 *
 *	@rdesc	NOERROR - succeeded
 *			E_FAIL - failed.
 */
HRESULT CTxtWinHost::TxSetForegroundWindow()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN,
		"CTxtWinHost::SetForegroundWindow");

	if(!SetForegroundWindow(_hwnd))
		SetFocus(_hwnd);

	return NOERROR;
}	


/*
 *	CTxtWinHost::TxGetPalette
 *
 *	@mfunc	Returns application specific palette if there is one
 *
 *	@rdesc	~NULL - there was one
 *			NULL - use default palette
 */
HPALETTE CTxtWinHost::TxGetPalette()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN,
		"CTxtWinHost::TxGetPalette");

	return _hpal;
}	


/*
 *	CTxtWinHost::TxGetFEFlags
 *
 *	@mfunc	return FE settings
 *
 *	@rdesc	NOERROR - succeeded
 *			E_FAIL - failed.
 */
HRESULT CTxtWinHost::TxGetFEFlags(LONG *pFEFlags)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN,
		"CTxtWinHost::TxGetFEFlags");

	if (!pFEFlags)
		return E_INVALIDARG;
	*pFEFlags = 0;

	if (_usIMEMode == ES_NOIME)
		*pFEFlags |= ES_NOIME;
	if (_usIMEMode == ES_SELFIME)
		*pFEFlags |= ES_SELFIME;

	return NOERROR;
}


// Helper function in edit.cpp
LONG GetECDefaultHeightAndWidth(
	ITextServices *pts,
	HDC hdc,
	LONG lZoomNumerator,
	LONG lZoomDenominator,
	LONG yPixelsPerInch,
	LONG *pxAveWidth,
	LONG *pxOverhang,
	LONG *pxUnderhang);


/*
 *	CTxtWinHost::OnSetMargins
 *
 *	@mfunc	Handle EM_SETMARGINS message
 *
 *	@rdesc	None.
 */
void CTxtWinHost::OnSetMargins(
	DWORD fwMargin,		//@parm Type of requested operation
	DWORD xLeft,		//@parm Where to put left margin
	DWORD xRight)		//@parm Where to put right margin
{
	LONG xLeftMargin = -1;
	LONG xRightMargin = -1;
	HDC hdc;

	if(EC_USEFONTINFO == fwMargin)
	{
		// Get the DC since it is needed for the call
		hdc = GetDC(_hwnd);

		// Multiline behaves differently than single line
		if (_dwStyle & ES_MULTILINE)
		{
			// Multiline - over/underhange controls margin
			GetECDefaultHeightAndWidth(_pserv, hdc, 1, 1,
				W32->GetYPerInchScreenDC(), NULL,
				&xLeftMargin, &xRightMargin);
		}
		else
		{
			// Single line edit controls set the margins to
			// the average character width on both left and
			// right.
			GetECDefaultHeightAndWidth(_pserv, hdc, 1, 1,
				W32->GetYPerInchScreenDC(), &xLeftMargin, NULL, NULL);

			xRightMargin = xLeftMargin;
		}
		ReleaseDC(_hwnd, hdc);
	}
	else
	{
		// The request is for setting exact pixels.
		if(EC_LEFTMARGIN & fwMargin)
			xLeftMargin = xLeft;

		if(EC_RIGHTMARGIN & fwMargin)
			xRightMargin = xRight;
	}

	// Set left margin if so requested
	if (xLeftMargin != -1)
		_rcViewInset.left =	W32->DXtoHimetricX(xLeftMargin, W32->GetXPerInchScreenDC());

	// Set right margin if so requested
	if (xRightMargin != -1)
		_rcViewInset.right = W32->DXtoHimetricX(xRightMargin, W32->GetXPerInchScreenDC());

	if (xLeftMargin != -1 || xRightMargin != -1)
		_pserv->OnTxPropertyBitsChange(TXTBIT_VIEWINSETCHANGE, TXTBIT_VIEWINSETCHANGE);
}

/*
 *	CTxtWinHost::SetScrollInfo
 *
 *	@mfunc	Set scrolling information for the scroll bar.
 */
void CTxtWinHost::SetScrollInfo(
	INT fnBar,			//@parm	Specifies scroll bar to be updated
	BOOL fRedraw)		//@parm whether redraw is necessary
{
	// Set up the basic structure for the call
	SCROLLINFO si;
	si.cbSize = sizeof(SCROLLINFO);
	si.fMask = SIF_ALL;

	AssertSz(_pserv != NULL,
		"CTxtWinHost::SetScrollInfo called with NULL _pserv");

	// Call back to the control to get the parameters
	if(fnBar == SB_HORZ)
	{
		_pserv->TxGetHScroll((LONG *) &si.nMin, (LONG *) &si.nMax,
			(LONG *) &si.nPos, (LONG *) &si.nPage, NULL);
	}
	else
	{
		_pserv->TxGetVScroll((LONG *) &si.nMin,
			(LONG *) &si.nMax, (LONG *) &si.nPos, (LONG *) &si.nPage, NULL);
	}

	// Do the call
	::SetScrollInfo(_hwnd, fnBar, &si, fRedraw);
}

/*
 *	CTxtWinHost::SetScrollBarsForWmEnable
 *
 *	@mfunc	Enable/Disable scroll bars
 *
 *	@rdesc	None.
 */
void CTxtWinHost::SetScrollBarsForWmEnable(
	BOOL fEnable)		//@parm Whether scrollbars s/b enabled or disabled.
{
	if(!_pserv)						// If no edit object,
		return;						//  no scrollbars

	BOOL fHoriz = FALSE;
	BOOL fVert = FALSE;
	UINT wArrows = fEnable ? ESB_ENABLE_BOTH : ESB_DISABLE_BOTH;

	_pserv->TxGetHScroll(NULL, NULL, NULL, NULL, &fHoriz);
	_pserv->TxGetVScroll(NULL, NULL, NULL, NULL, &fVert);

	if(fHoriz)						// There is a horizontal scroll bar
		W32->EnableScrollBar(_hwnd, SB_HORZ, wArrows);

	if(fVert)						// There is a vertical scroll bar
		W32->EnableScrollBar(_hwnd, SB_VERT, wArrows);
}

/*
 *	CTxtWinHost::SetScrollBarsForWmEnable
 *
 *	@mfunc	Notification that Text Services is released.
 *
 *	@rdesc	None.
 */
void CTxtWinHost::TxFreeTextServicesNotification()
{
	_fTextServiceFree = TRUE;
}

/*
 *	CTxtWinHost::TxGetEditStyle
 *
 *	@mfunc	Get Edit Style flags
 *
 *	@rdesc	NOERROR is data available.
 */
HRESULT CTxtWinHost::TxGetEditStyle(
	DWORD dwItem,
	DWORD *pdwData)
{
	if (!pdwData)
		return E_INVALIDARG;
	
	*pdwData = 0;

	if (dwItem & TXES_ISDIALOG && _fInDialogBox)
		*pdwData |= TXES_ISDIALOG;

	return NOERROR;
}

/*
 *	CTxtWinHost::TxGetWindowStyles
 *
 *	@mfunc	Return window style bits
 *
 *	@rdesc	NOERROR is data available.
 */
HRESULT CTxtWinHost::TxGetWindowStyles(DWORD *pdwStyle, DWORD *pdwExStyle)
{
	if (!pdwStyle || !pdwExStyle)
		return E_INVALIDARG;

	*pdwStyle = _dwStyle;
	*pdwExStyle = _dwExStyle;

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\hash.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module HASH.C -- RTF control word cache |
 *		#ifdef'ed with RTF_HASHCACHE
 *		
 *	Owner: <nl>
 *		Jon Matousek <nl>
 *
 *	History: <nl>
 *		8/15/95		jonmat first hash-cache for RTF using Brent's Method.
 */
#include "_common.h"

#ifdef RTF_HASHCACHE
					 
#include "hash.h"

ASSERTDATA

extern KEYWORD		rgKeyword[];			// All of the RTF control words.

#define MAX_INAME	3

typedef struct {
	const KEYWORD	*token;
	BOOL			passBit;
} HashEntry;

static HashEntry	*(hashtbl[HASHSIZE]);
static HashEntry	*storage;				// Dynamically alloc for cKeywords.

BOOL				_rtfHashInited = FALSE;

static INT			HashKeyword_Key( const CHAR *szKeyword );

/*
 *	HashKeyword_Insert()
 *	
 *	@func
 *		Insert a KEYWORD into the RTF hash table.
 *	@comm
 *		This function uses the the % for MOD
 *		in order to validate MOD257.
 */
VOID HashKeyword_Insert (
	const KEYWORD *token )//@parm pointer to KEYWORD token to insert.
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "HashKeyword_Insert");

	INT			index, step, position,
				cost, source, sink, index1,
				step1, temp;
	
	BOOL		tmpPassBit;	
	
	static INT	totalKeys = 0;

	CHAR 		*szKeyword;
	
	HashEntry	*np;
	
	AssertSz ( _rtfHashInited, "forgot to call HashKeyword_Init()");
	AssertSz ( totalKeys <= HASHSIZE * 0.7, "prime not large enough to hold total keys");
	
	szKeyword = token->szKeyword;
	
	np = &storage[totalKeys++];
	np->token = token;

	index = HashKeyword_Key(szKeyword) % HASHSIZE;  // Get keys.
	step = 1 + (HashKeyword_Key(szKeyword) % (HASHSIZE-1));

	position = 1;
	cost = HASHSIZE;								// The max collisions for any.
	while(hashtbl[index]!=NULL)						// Find empty slot.
	{
		position++;									// How many collisions.

		// For the keyword stored here, calc # times before it is found.
		temp=1;
		step1= 1+(HashKeyword_Key(hashtbl[index]->token->szKeyword) % (HASHSIZE-1));
		index1= (index+step1)%HASHSIZE;
		while(hashtbl[index1] !=NULL)
		{
			index1=(index1+step1)%HASHSIZE;
			temp++;
		}
		
		// Incremental cost computation, minimizes average # of collisions
		//  for both keywords.
		if (cost>position+temp)
		{
			source=index;
			sink=index1;
			cost=position+temp;
		}
		
		// There will be something stored beyound here, set the passBit.
		hashtbl[index]->passBit=1;

		// Next index to search for empty slot.
		index=(index+step)%HASHSIZE;

	}
	
	if (position<=cost)
	{
		source=sink=index;
		cost=position;
	}
	hashtbl[sink] = hashtbl[source];
	hashtbl[source] = np;
	if (hashtbl[sink] && hashtbl[source])	// jOn hack, we didn't really
	{										//  want to swap pass bits.
		tmpPassBit = hashtbl[sink]->passBit;
		hashtbl[sink]->passBit = hashtbl[source]->passBit;
		hashtbl[source]->passBit = tmpPassBit;
	}

}

/*
 *	static HashKeyword_Key()
 *	
 *	@func
 *		Calculate the hash key.
 *	@comm
 *		Just add up the first few characters.
 *	@rdesc
 *		The hash Key for calculating the index and step.
 */
static INT HashKeyword_Key(
	const CHAR *szKeyword ) //@parm C string to create hash key for.
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "HashKeyword_Key");

	INT i, tot = 0;
	
	/* Just add up first few characters. */
	for (i = 0; i < MAX_INAME && *szKeyword; szKeyword++, i++)
			tot += (UCHAR) *szKeyword;
	return tot;
}	

/*
 *	HashKeyword_Fetch()
 *	
 *	@func
 *		Look up a KEYWORD with the given szKeyword.
 *	@devnote
 *		We have a hash table of size 257. This allows for
 *		the use of very fast routines to calculate a MOD 257.
 *		This gives us a significant increase in performance
 *		over a binary search.
 *	@rdesc
 *		A pointer to the KEYWORD, or NULL if not found.
 */
const KEYWORD *HashKeyword_Fetch (
	const CHAR *szKeyword ) //@parm C string to search for.
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "HashKeyword_Fetch");

	INT 		index, step;
	
	HashEntry *	hashTblPtr;

	BYTE *		pchCandidate;
	BYTE *		pchKeyword;
	
	INT			nComp;

	CHAR		firstChar;

	INT			hashKey;

	AssertSz( HASHSIZE == 257, "Remove custom MOD257.");
	
	firstChar = *szKeyword;
	hashKey = HashKeyword_Key(szKeyword);	// For calc'ing 'index' and 'step'
	
	//index = hashKey%HASHSIZE;				// First entry to search.
	index = MOD257(hashKey);				// This formula gives us 18% perf.

	hashTblPtr = hashtbl[index];			// Get first entry.
	if ( hashTblPtr != NULL )				// Something there?
	{
											// Compare 2 C strings.								
		pchCandidate = (BYTE *)hashTblPtr->token->szKeyword;
		if ( firstChar == *pchCandidate )
		{
			pchKeyword	 = (BYTE *)szKeyword;
			while (!(nComp = *pchKeyword - *pchCandidate)	// Be sure to match
				&& *pchKeyword)								//  terminating 0's
			{
				pchKeyword++;
				pchCandidate++;
			}
											// Matched?
			if ( 0 == nComp )
				return hashTblPtr->token;
		}
		
		if ( hashTblPtr->passBit==1 )		// passBit=>another entry to test
		{

			// step = 1+(hashKey%(HASHSIZE-1));// Calc 'step'
			step = 1 + MOD257_1(hashKey);

											// Get second entry to check.
			index += step;
			index = MOD257(index);
			hashTblPtr = hashtbl[index];

			while (hashTblPtr != NULL )		// While something there.
			{
											// Compare 2 C strings.								
				pchCandidate = (BYTE *)hashTblPtr->token->szKeyword;
				if ( firstChar == *pchCandidate )
				{
					pchKeyword	 = (BYTE *)szKeyword;
					while (!(nComp = *pchKeyword - *pchCandidate)
						&& *pchKeyword)
					{
						pchKeyword++;
						pchCandidate++;
					}
											// Matched?
					if ( 0 == nComp )
						return hashTblPtr->token;
				}

				if ( !hashTblPtr->passBit )// Done searching?
					break;
											// Get next entry.
				index += step;
				index = MOD257(index);
				hashTblPtr = hashtbl[index];
			}
		}
	}
	
	return NULL;
}

/*
 *	HashKeyword_Init()
 *	
 *	@func
 *		Load up and init the hash table with RTF control words.
 *	@devnote
 *		_rtfHashInited will be FALSE if anything here fails.
 */
VOID HashKeyword_Init( )
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "HashKeyword_Init");

	extern SHORT cKeywords;			// How many RTF keywords we currently recognize.

	INT i;

	AssertSz( _rtfHashInited == FALSE, "Only need to init this once.");

									// Create enough storage for cKeywords
	storage = (HashEntry *) PvAlloc( sizeof(HashEntry) * cKeywords, fZeroFill );

									// Load in all of the RTF control words.
	if ( storage )
	{
		_rtfHashInited = TRUE;

		for (i = 0; i < cKeywords; i++ )
		{
			HashKeyword_Insert(&rgKeyword[i]);
		}
#ifdef DEBUG						// Make sure we can fetch all these keywords.
		for (i = 0; i < cKeywords; i++ )
		{
			AssertSz ( &rgKeyword[i] == HashKeyword_Fetch ( rgKeyword[i].szKeyword ),
				"Keyword Hash is not working.");
		}
#endif
	}
}

#endif	// RTF_HASHCACHE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\iaccess.cpp ===
/*
 *	IACCESS.CPP 
 *
 *  Purpose:
 *      Implemenation of IAccessibility for listbox and combobox
 *		
 *	Original Author: 
 *		Jerry Kim
 *
 *	History: <nl>
 *		01/04/99 - v-jerrki Created
 *
 *	Set tabs every four (4) columns
 *
 *	Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_host.h"
#include "_cbhost.h"

#ifndef NOACCESSIBILITY

extern LRESULT CALLBACK RichListBoxWndProc(HWND, UINT, WPARAM, LPARAM);

#define InitPv(pv)              *pv = NULL
#define InitPlong(plong)        *plong = 0
#define InitPvar(pvar)           pvar->vt = VT_EMPTY
#define ValidateFlags(flags, valid)         (!((flags) & ~(valid)))
#define InitAccLocation(px, py, pcx, pcy)   {InitPlong(px); InitPlong(py); InitPlong(pcx); InitPlong(pcy);}

#ifdef _WIN64
#define HwndFromHWNDID(lId)         (HWND)((DWORD_PTR)(lId) & ~0x80000000)
#else
#define HwndFromHWNDID(lId)         (HWND)((lId) & ~0x80000000)
#endif // _WIN64

// this is for ClickOnTheRect
typedef struct tagMOUSEINFO
{
    int MouseThresh1;
    int MouseThresh2;
    int MouseSpeed;
}
MOUSEINFO, FAR* LPMOUSEINFO;

#define IsHWNDID(lId)               ((lId) & 0x80000000)

//////////////////////// Accessibility Utility Functions ///////////////////////////

namespace MSAA
{

// --------------------------------------------------------------------------
//
//  InitTypeInfo()
//
//  This initializes our type info when we need it for IDispatch junk.
//
// --------------------------------------------------------------------------
HRESULT InitTypeInfo(ITypeInfo** ppiTypeInfo)
{
    Assert(ppiTypeInfo);

    if (*ppiTypeInfo)
        return S_OK;

    // Try getting the typelib from the registry
    ITypeLib    *piTypeLib;    
    HRESULT hr = LoadRegTypeLib(LIBID_Accessibility, 1, 0, 0, &piTypeLib);

    if (FAILED(hr))
        hr = LoadTypeLib(OLESTR("OLEACC.DLL"), &piTypeLib);

    if (SUCCEEDED(hr))
    {
        hr = piTypeLib->GetTypeInfoOfGuid(IID_IAccessible, ppiTypeInfo);
        piTypeLib->Release();

        if (!SUCCEEDED(hr))
            *ppiTypeInfo = NULL;
    }
    return(hr);
}


// --------------------------------------------------------------------------
//
//  ValidateChild()
//
// --------------------------------------------------------------------------
BOOL ValidateChild(VARIANT *pvar, int ctChild)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "ValidateChild");
    
    // Missing parameter, a la VBA
TryAgain:
    switch (pvar->vt)
    {
        case VT_VARIANT | VT_BYREF:
            W32->VariantCopy(pvar, pvar->pvarVal);
            goto TryAgain;

        case VT_ERROR:
            if (pvar->scode != DISP_E_PARAMNOTFOUND)
                return(FALSE);
            // FALL THRU

        case VT_EMPTY:
            pvar->vt = VT_I4;
            pvar->lVal = 0;
            break;

        case VT_I4:
            if ((pvar->lVal < 0) || (pvar->lVal > ctChild))
                return(FALSE);
            break;

        default:
            return(FALSE);
    }

    return(TRUE);
}


// --------------------------------------------------------------------------
//
//  ValidateSelFlags()
//
//  Validates selection flags.
// this makes sure the only bits set are in the valid range and that you don't
// have any invalid combinations.
// Invalid combinations are
// ADDSELECTION and REMOVESELECTION
// ADDSELECTION and TAKESELECTION
// REMOVESELECTION and TAKESELECTION
// EXTENDSELECTION and TAKESELECTION
//
// --------------------------------------------------------------------------
BOOL ValidateSelFlags(long flags)
{
    if (!ValidateFlags((flags), SELFLAG_VALID))
        return (FALSE);

    if ((flags & SELFLAG_ADDSELECTION) && 
        (flags & SELFLAG_REMOVESELECTION))
        return FALSE;

    if ((flags & SELFLAG_ADDSELECTION) && 
        (flags & SELFLAG_TAKESELECTION))
        return FALSE;

    if ((flags & SELFLAG_REMOVESELECTION) && 
        (flags & SELFLAG_TAKESELECTION))
        return FALSE;

    if ((flags & SELFLAG_EXTENDSELECTION) && 
        (flags & SELFLAG_TAKESELECTION))
        return FALSE;

    return TRUE;
}

// --------------------------------------------------------------------------
//
//  GetStringResource(UINT id, WCHAR* psz, int nSize)
//
//  Gets the string resource for a given id and puts it in the passed buffer
//
// --------------------------------------------------------------------------
HRESULT GetStringResource(UINT id, BSTR* pbstr)
{
    
    WCHAR sz[MAX_PATH] = L"\0";

    if (!pbstr)
        return S_FALSE;

/*     
    // UNDONE:
    //  Need a workaround for this localization issue

    if (Win9x())
    {
        if (!LoadStringA(hinstResDll, id, sz, MAX_PATH))
            return(E_OUTOFMEMORY);

        // On Win9x we get ansi so convert it
        int cchUText = MultiByteToWideChar(CP_ACP, 0, (LPCSTR)sz, -1, NULL, 0) + 1;
        *pbstr = SysAllocStringLen(NULL, cchUText);
        MultiByteToWideChar(CP_ACP, 0, (LPCSTR)psz, -1, *pbstr, cchUText);
    }
    else
    {
        if (!LoadStringW(hinstResDll, id, sz, MAX_PATH))
            return(E_OUTOFMEMORY);    
        *pbstr = SysAllocString(sz);
    }
*/

#define STR_DOUBLE_CLICK            1
#define STR_DROPDOWN_HIDE           2
#define STR_DROPDOWN_SHOW           3
#define STR_ALT                     4
#define STR_COMBOBOX_LIST_SHORTCUT  5

    switch (id)
    {
        case STR_DOUBLE_CLICK:
            //"Double Click"
            wcscpy(sz, L"Double Click");
            break;
            
        case STR_DROPDOWN_HIDE:
            //"Hide"
            wcscpy(sz, L"Hide");
            break;
            
        case STR_DROPDOWN_SHOW:
            //"Show"
            wcscpy(sz, L"Show");
            break;

        case STR_ALT:
            //"Alt+"
            wcscpy(sz, L"Alt+");
            break;
            
        case STR_COMBOBOX_LIST_SHORTCUT:
            //"Alt+Down Arrow"
            wcscpy(sz, L"Alt+Down Arrow");
            break;

        default:
            AssertSz(FALSE, "id not found!!");
    }

    *pbstr = SysAllocString(sz);
    if (!*pbstr)
        return(E_OUTOFMEMORY);
        
    return(S_OK);
}


// --------------------------------------------------------------------------
//
//  HWND GetAncestor(HWND hwnd, UINT gaFlags)
//
//  This gets the ancestor window where
//      GA_PARENT   gets the "real" parent window
//      GA_ROOT     gets the "real" top level parent window (not inc. owner)r
//
//      * The _real_ parent.  This does NOT include the owner, unlike
//          GetParent().  Stops at a top level window unless we start with
//          the desktop.  In which case, we return the desktop.
//      * The _real_ root, caused by walking up the chain getting the
//          ancestor.
//
//  NOTE:
//      User32.exe provides a undocumented function similar to this but
//  it doesn't exist in NT4.  Also, GA_ROOT works differently on Win98 so
//  I copied this over from msaa
// --------------------------------------------------------------------------
HWND GetAncestor(HWND hwnd, UINT gaFlags)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "GetAncestor");
    
    HWND hwndDesktop = GetDesktopWindow();
    if (hwnd == hwndDesktop || !::IsWindow(hwnd))
        return(NULL);
        
    DWORD dwStyle = GetWindowLong (hwnd, GWL_STYLE);

    HWND	hwndParent;
    switch (gaFlags)
    {
        case GA_PARENT:
            if (dwStyle & WS_CHILD)
                hwndParent = GetParent(hwnd);
            else
                hwndParent = GetWindow(hwnd, GW_OWNER);
    		hwnd = hwndParent;
            break;
            
        case GA_ROOT:
            if (dwStyle & WS_CHILD)
                hwndParent = GetParent(hwnd);
            else
                hwndParent = GetWindow(hwnd, GW_OWNER);
            while (hwndParent != hwndDesktop && hwndParent != NULL)
            {
                hwnd = hwndParent;
                dwStyle = GetWindowLong(hwnd, GWL_STYLE);
                if (dwStyle & WS_CHILD)
                    hwndParent = GetParent(hwnd);
                else
                    hwndParent = GetWindow(hwnd, GW_OWNER);
            }
            break;

        default:
            AssertSz(FALSE, "Invalid flag");
    }    
    return(hwnd);
}


// --------------------------------------------------------------------------
//
//  GetTextString(HWND hwnd, BSTR* bstr)
//
//  Parameters: hwnd of the window to get the text from
//
// --------------------------------------------------------------------------
HRESULT GetTextString(HWND hwnd, BSTR* pbstr)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "GetTextString");
    
    WCHAR   sz[MAX_PATH + 1];
    WCHAR   *psz = sz;

    int cchText = SendMessage(hwnd, WM_GETTEXTLENGTH, 0, 0);

    // allocate memory from heap if stack buffer is insufficient
    if (cchText >= MAX_PATH)
        psz = new WCHAR[cchText + 1];

    if (!psz)
        return E_OUTOFMEMORY;

    // retrieve text
    HRESULT hres = S_OK;
    SendMessage(hwnd, WM_GETTEXT, cchText + 1, (LPARAM)psz);

    if (!*psz)
        *pbstr = NULL;
    else
    {
        *pbstr = SysAllocString(psz);
        if (!*pbstr)
            hres = E_OUTOFMEMORY;
    }
    
    // free memory if memory was allocated from heap
    if (psz != sz)
        delete [] psz;

    return hres;
}


// --------------------------------------------------------------------------
//
//  HRESULT GetLabelString(HWND hwnd, BSTR* pbstr)
//
//  This walks backwards among peer windows to find a static field.  It stops
//  if it gets to the front or hits a group/tabstop, just like the dialog 
//  manager does.
//
//  RETURN:
//   HRESULT ? S_OK on success : S_FALSE or COM error on failure
// --------------------------------------------------------------------------
HRESULT GetLabelString(HWND hwnd, BSTR* pbstr)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "GetLabelString");
    
    HWND hwndLabel = hwnd;
    while (hwndLabel = ::GetWindow(hwndLabel, GW_HWNDPREV))
    {
        LONG lStyle = GetWindowLong(hwndLabel, GWL_STYLE);

        // Skip if invisible
        if (!(lStyle & WS_VISIBLE))
            continue;

        // Is this a static dude?
        LRESULT lResult = SendMessage(hwndLabel, WM_GETDLGCODE, 0, 0L);
        if (lResult & DLGC_STATIC)
        {
            // Great, we've found our label.
            return GetTextString(hwndLabel, pbstr);
        }

        // Is this a tabstop or group?  If so, bail out now.
        if (lStyle & (WS_GROUP | WS_TABSTOP))
            break;
    }

    return S_FALSE;
}


// --------------------------------------------------------------------------
//
//  HRESULT StripMnemonic(BSTR bstrSrc, WCHAR** pchAmp, BOOL bStopOnAmp)
//
//  This removes the mnemonic prefix.  However, if we see '&&', we keep
//  one '&'.
//
// --------------------------------------------------------------------------
HRESULT StripMnemonic(BSTR bstrSrc, WCHAR** pchAmp, BOOL bStopOnAmp)
{   
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "StripMnemonic");
    
    const WCHAR amp = L'&';
    
    if (pchAmp)
        pchAmp = NULL;
    
    WCHAR *psz = (WCHAR*)bstrSrc;
    while (*psz)
    {
        if (*psz == amp)
        {
            if (*(psz + 1) == amp)
                psz++;
            else
            {
                if (pchAmp)
                    *pchAmp = psz;
                break;
            }
        }
        psz++;
    }

    // Start moving all the character up 1 position
    if (!bStopOnAmp)    
        while (*psz)
            *psz = *++psz;

    return(S_OK);
}


// --------------------------------------------------------------------------
//
//  HRESULT GetWindowName(HWND hwnd, BSTR* pbstrName)
//
// --------------------------------------------------------------------------
HRESULT GetWindowName(HWND hwnd, BSTR* pbstrName)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "GetWindowName");
        
    // If use a label, do that instead
    if (S_OK != GetLabelString(hwnd, pbstrName) || !*pbstrName)
        return S_FALSE;

    // Strip out the mnemonic.
    return StripMnemonic(*pbstrName, NULL, FALSE);
}


// --------------------------------------------------------------------------
//
//  HRESULT GetWindowShortcut(HWND hwnd, BSTR* pbstrShortcut)
//
// --------------------------------------------------------------------------
HRESULT GetWindowShortcut(HWND hwnd, BSTR* pbstrShortcut)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "GetWindowShortcut");
    
    if (S_OK != GetLabelString(hwnd, pbstrShortcut) || !*pbstrShortcut)
        return S_FALSE;

    WCHAR *pch;
    StripMnemonic(*pbstrShortcut, &pch, TRUE);

    // Is there a mnemonic?
    if (pch)
    {   
        // Get a localized "Alt+" string
        BSTR pbstrAlt = NULL;
        HRESULT hr = GetStringResource(STR_ALT, &pbstrAlt);
        if (hr != S_OK || !pbstrAlt)
            return hr;
            
        // Make a string of the form "Alt+ch".
        WCHAR   szKey[MAX_PATH];
        wcsncpy (szKey, pbstrAlt, MAX_PATH);
        WCHAR   *pchTemp = szKey + wcslen(szKey);

        // Copy shortcut character
        *pchTemp = *pch;
        *(++pchTemp) = L'\0';

        // Release allocated string allocate space for new string
        SysFreeString(pbstrAlt);
        *pbstrShortcut = SysAllocString(pchTemp);
        return (*pbstrShortcut ? S_OK : E_OUTOFMEMORY);
    }

    return(S_FALSE);
}

// --------------------------------------------------------------------------
//
//  GetWindowObject()
//
//  Gets an immediate child object.
//
// --------------------------------------------------------------------------
HRESULT GetWindowObject(HWND hwndChild, VARIANT * pvar)
{
    pvar->vt = VT_EMPTY;
    IDispatch * pdispChild = NULL;
    HRESULT hr = W32->AccessibleObjectFromWindow(hwndChild, OBJID_WINDOW, IID_IDispatch,
        (void **)&pdispChild);

    if (!SUCCEEDED(hr))
        return(hr);
    if (!pdispChild)
        return(E_FAIL);

    pvar->vt = VT_DISPATCH;
    pvar->pdispVal = pdispChild;

    return(S_OK);
}

} //namespace


//////////////////////// ListBox CListBoxSelection Methods ///////////////////////////

// --------------------------------------------------------------------------
//
//  CListBoxSelection::CListBoxSelection()
//
//  We AddRef() once plistFrom so that it won't go away out from us.  When
//  we are destroyed, we will Release() it.
//
// --------------------------------------------------------------------------
CListBoxSelection::CListBoxSelection(int iChildCur, int cSelected, LPINT lpSelection)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CListBoxSelection::CListBoxSelection");
    
    _idChildCur = iChildCur;

    _cRef = 1;
    _piSel = new int[cSelected];
    if (!_piSel)
        _cSel = 0;
    else
    {
        _cSel = cSelected;
        memcpy(_piSel, lpSelection, cSelected*sizeof(int));
    }
}


// --------------------------------------------------------------------------
//
//  CListBoxSelection::~CListBoxSelection()
//
// --------------------------------------------------------------------------
CListBoxSelection::~CListBoxSelection()
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CListBoxSelection::~CListBoxSelection");
    
    // Free item memory
    if (_piSel)
    {
        delete [] _piSel;
        _piSel = NULL;
    }
}


// --------------------------------------------------------------------------
//
//  CListBoxSelection::QueryInterface()
//
//  We only respond to IUnknown and IEnumVARIANT!  It is the responsibility
//  of the caller to loop through the items using IEnumVARIANT interfaces,
//  and get the child IDs to then pass to the parent object (or call 
//  directly if VT_DISPATCH--not in this case they aren't though).
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBoxSelection::QueryInterface(REFIID riid, void** ppunk)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CListBoxSelection::QueryInterface");
    
    *ppunk = NULL;

    if ((riid == IID_IUnknown) || (riid == IID_IEnumVARIANT))
    {
        *ppunk = this;
    }
    else
        return(E_NOINTERFACE);

    ((LPUNKNOWN) *ppunk)->AddRef();
    return(S_OK);
}


// --------------------------------------------------------------------------
//
//  CListBoxSelection::AddRef()
//
// --------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CListBoxSelection::AddRef(void)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CListBoxSelection::AddRef");
    
    return(++_cRef);
}


// --------------------------------------------------------------------------
//
//  CListBoxSelection::Release()
//
// --------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CListBoxSelection::Release(void)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CListBoxSelection::Release");
    
    if ((--_cRef) == 0)
    {
        delete this;
        return 0;
    }

    return(_cRef);
}


// --------------------------------------------------------------------------
//
//  CListBoxSelection::Next()
//
//  This returns a VT_I4 which is the child ID for the parent listbox that
//  returned this object for the selection collection.  The caller turns
//  around and passes this variant to the listbox object to get acc info
//  about it.
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBoxSelection::Next(ULONG celt, VARIANT* rgvar, ULONG *pceltFetched)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CListBoxSelection::Next");
    
    // Can be NULL
    if (pceltFetched)
        *pceltFetched = 0;

    // reset temporary variable to beginning
    VARIANT *pvar = rgvar;
    long cFetched = 0;
    long iCur = _idChildCur;

    // Loop through our items
    while ((cFetched < (long)celt) && (iCur < _cSel))
    {
        VariantInit(pvar);
        pvar->vt = VT_I4;
        pvar->lVal = _piSel[iCur] + 1;

        cFetched++;
        iCur++;
        pvar++;
    }

    // Initialize the variant after the last valid one just
    // in case the client is looping based on invalid variants
    if ((ULONG)cFetched < celt)
        VariantInit(pvar);

    // Advance the current position
    _idChildCur = iCur;

    // Fill in the number fetched
    if (pceltFetched)
        *pceltFetched = cFetched;

    // Return S_FALSE if we grabbed fewer items than requested
    return((cFetched < (long)celt) ? S_FALSE : S_OK);
}


// --------------------------------------------------------------------------
//
//  CListBoxSelection::Skip()
//
// -------------------------------------------------------------------------
STDMETHODIMP CListBoxSelection::Skip(ULONG celt)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CListBoxSelection::Skip");
    
    _idChildCur += celt;
    if (_idChildCur > _cSel)
        _idChildCur = _cSel;

    // We return S_FALSE if at the end.
    return((_idChildCur >= _cSel) ? S_FALSE : S_OK);
}


// --------------------------------------------------------------------------
//
//  CListBoxSelection::Reset()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBoxSelection::Reset(void)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CListBoxSelection::Reset");
    
    _idChildCur = 0;
    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CListBoxSelection::Clone()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBoxSelection::Clone(IEnumVARIANT **ppenum)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CListBoxSelection::Clone");
    
    InitPv(ppenum);
    CListBoxSelection * plistselnew = new CListBoxSelection(_idChildCur, _cSel, _piSel);
    if (!plistselnew)
        return(E_OUTOFMEMORY);

    return(plistselnew->QueryInterface(IID_IEnumVARIANT, (void**)ppenum));
}

//////////////////////// ListBox IAccessible Methods //////////////////////////////
/*
 *	CLstBxWinHost::InitTypeInfo()
 *
 *	@mfunc
 *		Retrieves type library
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise.
 */
HRESULT CLstBxWinHost::InitTypeInfo()
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::InitTypeInfo");
    return MSAA::InitTypeInfo(&_pTypeInfo);
}


/*
 *	CLstBxWinHost::get_accName(VARIANT varChild, BSTR *pbstrName)
 *
 *	@mfunc
 *		SELF ? label of control : item text 
 *
 *	@rdesc
 *		HRESULT = S_FALSE.
 */
STDMETHODIMP CLstBxWinHost::get_accName(VARIANT varChild, BSTR *pbstrName)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::get_accName");
    
    InitPv(pbstrName);

    // Validate parameters
    if (!MSAA::ValidateChild(&varChild, GetCount()))
        return(E_INVALIDARG);

    if (varChild.lVal == CHILDID_SELF)
    {
        if (_fLstType == kCombo)
            return  _pcbHost->get_accName(varChild, pbstrName);
        else
            return(MSAA::GetWindowName(_hwnd, pbstrName));
    }
    else
    {
        // Get the item text.
        LRESULT lres = RichListBoxWndProc(_hwnd, LB_GETTEXTLEN, varChild.lVal-1, 0);

        // First Check for error
        if (lres == LB_ERR)
            return S_FALSE;
       
        if (lres > 0)
        {
            // allocate some buffer
            *pbstrName = SysAllocStringLen(NULL, lres + 1);
            if (!*pbstrName)
                return E_OUTOFMEMORY;
                
            RichListBoxWndProc(_hwnd, LB_GETTEXT, varChild.lVal-1, (LPARAM)*pbstrName);
        }
    }
    return(S_OK);
}


/*
 *	CLstBxWinHost::get_accRole(VARIANT varChild, VARIANT *pvarRole)
 *
 *	@mfunc
 *		Retrieves the object's Role property. 
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise.
 */
STDMETHODIMP CLstBxWinHost::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::get_accRole");
    
    InitPvar(pvarRole);

    // Validate parameters
    if (!MSAA::ValidateChild(&varChild, GetCount()))
        return E_INVALIDARG;

    pvarRole->vt = VT_I4;

    if (varChild.lVal)
        pvarRole->lVal = ROLE_SYSTEM_LISTITEM;
    else
        pvarRole->lVal = ROLE_SYSTEM_LIST;

    return S_OK;
}


/*
 *	CLstBxWinHost::get_accState(VARIANT varChild, VARIANT *pvarState)
 *
 *	@mfunc
 *		Retrieves the current state of the object or child item.  
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise.
 */
STDMETHODIMP CLstBxWinHost::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::get_accState");
    
    // Validate parameters
    if (!MSAA::ValidateChild(&varChild, GetCount()))
        return E_INVALIDARG;

    InitPvar(pvarState);
    if (varChild.lVal == CHILDID_SELF)
    {
        pvarState->vt = VT_I4;
        pvarState->lVal = 0;

        if (!IsWindowVisible(_hwnd))
            pvarState->lVal |= STATE_SYSTEM_INVISIBLE;

        if (!IsWindowEnabled(_hwnd))
            pvarState->lVal |= STATE_SYSTEM_UNAVAILABLE;

        if (_fFocus)
            pvarState->lVal |= STATE_SYSTEM_FOCUSED;

        if (::GetForegroundWindow() == MSAA::GetAncestor(_hwnd, GA_ROOT))
            pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;

        return S_OK;
    }


    --varChild.lVal;

    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

    // Is this item selected?
    if (IsSelected(varChild.lVal))
        pvarState->lVal |= STATE_SYSTEM_SELECTED;

    // Does it have the focus?  Remember that we decremented the lVal so it
    // is zero-based like listbox indeces.
    if (_fFocus)
    {
        pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;

        if (varChild.lVal == GetCursor())
            pvarState->lVal |= STATE_SYSTEM_FOCUSED;            
    }

    // Is the listbox read-only?
    long lStyle = GetWindowLong(_hwnd, GWL_STYLE);

    if (lStyle & LBS_NOSEL)
        pvarState->lVal |= STATE_SYSTEM_READONLY;
    else
    {
        pvarState->lVal |= STATE_SYSTEM_SELECTABLE;

        // Is the listbox multiple and/or extended sel?  NOTE:  We have
        // no way to implement accSelect() EXTENDSELECTION so don't.
        if (lStyle & LBS_MULTIPLESEL)
            pvarState->lVal |= STATE_SYSTEM_MULTISELECTABLE;
    }

    // Is the item in view?
    //
	// SMD 09/16/97 Offscreen things are things never on the screen,
	// and that doesn't apply to this. Changed from OFFSCREEN to
	// INVISIBLE.
	RECT    rcItem;
    if (!RichListBoxWndProc(_hwnd, LB_GETITEMRECT, varChild.lVal, (LPARAM)&rcItem))
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;

    return S_OK;
}

/*
 *	CLstBxWinHost::get_accKeyboardShortcut(VARIANT varChild, BSTR *pszShortcut)
 *
 *	@mfunc
 *		Retrieves an object's KeyboardShortcut property.  
 *
 *	@rdesc
 *		Returns S_OK if successful or one of the following values or a standard COM 
 *  error code otherwise.
 */
STDMETHODIMP CLstBxWinHost::get_accKeyboardShortcut(VARIANT varChild, BSTR *pszShortcut)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::get_accKeyboardShortcut");
    
    // Validate
    if (!MSAA::ValidateChild(&varChild, GetCount()))
        return(E_INVALIDARG);

    if ((varChild.lVal == 0) && _fLstType != kCombo)
    {
        InitPv(pszShortcut);
        return(MSAA::GetWindowShortcut(_hwnd, pszShortcut));
    }
    return(DISP_E_MEMBERNOTFOUND);
}


/*
 *	CLstBxWinHost::get_accFocus(VARIANT *pvarChild)
 *
 *	@mfunc
 *		Retrieves the child object that currently has the keyboard focus.  
 *
 *	@rdesc
 *		Returns S_OK if successful or one of the following values or a standard COM 
 *  error code otherwise.
 */
STDMETHODIMP CLstBxWinHost::get_accFocus(VARIANT *pvarChild)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::get_accFocus");
    
    InitPvar(pvarChild);

    // Are we the focus?
    if (_fFocus)
    {
        pvarChild->vt = VT_I4;
        if (GetCursor() >= 0)
            pvarChild->lVal = GetCursor() + 1;
        else
            pvarChild->lVal = 0;
        return S_OK;
    }
    else
        return S_FALSE;
}


/*
 *	CLstBxWinHost::get_accSelection(VARIANT *pvarSelection)
 *
 *	@mfunc
 *		Retrieves the selected children of this object. 
 *
 *	@rdesc
 *		Returns S_OK if successful or one of the following values or a standard COM 
 *  error code otherwise.
 */
STDMETHODIMP CLstBxWinHost::get_accSelection(VARIANT *pvarSelection)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::get_accSelection");

    InitPvar(pvarSelection);

    int cSel = RichListBoxWndProc(_hwnd, LB_GETSELCOUNT, 0, 0);
    
    if (cSel <= 1)
    {
        // cSelected is -1, 0, or 1.  
        //      -1 means this is a single sel listbox.  
        //      0 or 1 means this is multisel
        if (GetCursor() < 0)
            return S_FALSE;
            
        pvarSelection->vt = VT_I4;
        pvarSelection->lVal = GetCursor() + 1;
        return(S_OK);
    }

    // Allocate memory for the list of item IDs
    int * plbs = new int[cSel];
    if (!plbs)
        return(E_OUTOFMEMORY);
    
    // Multiple items; must make a collection
    // Get the list of selected item IDs
    int j = 0;
    for (long i = 0; i < GetCount(); i++)
    {
		if (IsSelected(i) == TRUE)
		    plbs[j++] = i;
	}
			
    CListBoxSelection *plbsel = new CListBoxSelection(0, cSel, plbs);
    delete [] plbs;

    // check if memory allocation failed
    if (!plbsel)
        return(E_OUTOFMEMORY);
        
    pvarSelection->vt = VT_UNKNOWN;
    return plbsel->QueryInterface(IID_IUnknown, (void**)&(pvarSelection->punkVal));
}


/*
 *	CLstBxWinHost::get_accDefaultAction(VARIANT varChild, BSTR *pszDefAction)
 *
 *	@mfunc
 *		Retrieves a string containing a localized sentence that describes the object's default action. 
 *
 *	@rdesc
 *		Returns S_OK if successful or one of the following values or a standard COM 
 *  error code otherwise.
 */
STDMETHODIMP CLstBxWinHost::get_accDefaultAction(VARIANT varChild, BSTR *pszDefAction)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::get_accDefaultAction");
    
    InitPv(pszDefAction);

    // Validate.
    if (!MSAA::ValidateChild(&varChild, GetCount()))
        return(E_INVALIDARG);

    if (varChild.lVal)
        return (MSAA::GetStringResource(STR_DOUBLE_CLICK, pszDefAction));

    return(DISP_E_MEMBERNOTFOUND);
}


/*
 *	CLstBxWinHost::accLocation(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild)
 *
 *	@mfunc
 *		Retrieves the object's current screen location (if the object was placed on 
 *  the screen) and optionally, the child element. 
 *
 *	@rdesc
 *		Returns S_OK if successful or one of the following values or a standard COM 
 *  error code otherwise.
 */
STDMETHODIMP CLstBxWinHost::accLocation(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::accLocation");
    
    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    // Validate params
    if (!MSAA::ValidateChild(&varChild, GetCount()))
        return E_INVALIDARG;

    RECT    rc;
    if (!varChild.lVal)
        GetClientRect(_hwnd, &rc);
    else if (!RichListBoxWndProc(_hwnd, LB_GETITEMRECT, varChild.lVal-1, (LPARAM)&rc))
        return S_OK;

    // Convert coordinates to screen coordinates
    *pcxWidth = rc.right - rc.left;
    *pcyHeight = rc.bottom - rc.top;    
    
    ClientToScreen(_hwnd, (LPPOINT)&rc);
    *pxLeft = rc.left;
    *pyTop = rc.top;

    return S_OK;
}

/*
 *	CLstBxWinHost::accHitTest(long xLeft, long yTop, VARIANT *pvarHit)
 *
 *	@mfunc
 *		Retrieves the child object at a given point on the screen. 
 *
 *	@rdesc
 *		Returns S_OK if successful or one of the following values or a standard COM 
 *  error code otherwise.
 */
STDMETHODIMP CLstBxWinHost::accHitTest(long xLeft, long yTop, VARIANT *pvarHit)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::accHitTest");
    
    InitPvar(pvarHit);

    // Is the point in our client area?
    POINT   pt = {xLeft, yTop};
    ScreenToClient(_hwnd, &pt);

    RECT    rc;
    GetClientRect(_hwnd, &rc);

    if (!PtInRect(&rc, pt))
        return(S_FALSE);

    // What item is here?
    long l = GetItemFromPoint(&pt);
    pvarHit->vt = VT_I4;
    pvarHit->lVal = (l >= 0) ? l + 1 : 0;
    
    return(S_OK);
}


/*
 *	CLstBxWinHost::accDoDefaultAction(VARIANT varChild)
 *
 *	@mfunc
 *		Performs the object's default action. 
 *
 *	@rdesc
 *		Returns S_OK if successful or one of the following values or a standard COM 
 *  error code otherwise.
 */
STDMETHODIMP CLstBxWinHost::accDoDefaultAction(VARIANT varChild)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::accDoDefaultAction");
    
    // Validate
    if (!MSAA::ValidateChild(&varChild, GetCount()))
        return(E_INVALIDARG);

    if (varChild.lVal)
    {        
        // this will check if WindowFromPoint at the click point is the same
	    // as m_hwnd, and if not, it won't click. Cool!
	    
        RECT	rcLoc;
	    HRESULT hr = accLocation(&rcLoc.left, &rcLoc.top, &rcLoc.right, &rcLoc.bottom, varChild);
	    if (!SUCCEEDED (hr))
		    return (hr);

        // Find Center of rect
        POINT ptClick;
    	ptClick.x = rcLoc.left + (rcLoc.right/2);
    	ptClick.y = rcLoc.top + (rcLoc.bottom/2);

    	// check if hwnd at point is same as hwnd to check
    	if (WindowFromPoint(ptClick) != _hwnd)
    		return DISP_E_MEMBERNOTFOUND;

        W32->BlockInput(TRUE);
        
        // Get current cursor pos.
        POINT ptCursor;
        DWORD dwMouseDown, dwMouseUp;
        GetCursorPos(&ptCursor);
    	if (GetSystemMetrics(SM_SWAPBUTTON))
    	{
    		dwMouseDown = MOUSEEVENTF_RIGHTDOWN;
    		dwMouseUp = MOUSEEVENTF_RIGHTUP;
    	}
    	else
    	{
    		dwMouseDown = MOUSEEVENTF_LEFTDOWN;
    		dwMouseUp = MOUSEEVENTF_LEFTUP;
    	}

        // Get delta to move to center of rectangle from current
        // cursor location.
        ptCursor.x = ptClick.x - ptCursor.x;
        ptCursor.y = ptClick.y - ptCursor.y;

        // NOTE:  For relative moves, USER actually multiplies the
        // coords by any acceleration.  But accounting for it is too
        // hard and wrap around stuff is weird.  So, temporarily turn
        // acceleration off; then turn it back on after playback.

        // Save mouse acceleration info
        MOUSEINFO	miSave, miNew;
        if (!SystemParametersInfo(SPI_GETMOUSE, 0, &miSave, 0))
        {
            W32->BlockInput(FALSE);
            return (DISP_E_MEMBERNOTFOUND);
        }

        if (miSave.MouseSpeed)
        {
            miNew.MouseThresh1 = 0;
            miNew.MouseThresh2 = 0;
            miNew.MouseSpeed = 0;

            if (!SystemParametersInfo(SPI_SETMOUSE, 0, &miNew, 0))
            {
                W32->BlockInput(FALSE);
                return (DISP_E_MEMBERNOTFOUND);
            }
        }

        // Get # of buttons
        int nButtons = GetSystemMetrics(SM_CMOUSEBUTTONS);

        // mouse move to center of start button
        INPUT		rgInput[6];
        rgInput[0].type = INPUT_MOUSE;
        rgInput[0].mi.dwFlags = MOUSEEVENTF_MOVE;
        rgInput[0].mi.dwExtraInfo = 0;
        rgInput[0].mi.dx = ptCursor.x;
        rgInput[0].mi.dy = ptCursor.y;
        rgInput[0].mi.mouseData = nButtons;

        int i = 1;

        // MSAA's order of double click is 
        // WM_LBUTTONDOWN
        // WM_LBUTTONUP
        // WM_LBUTTONDOWN
        // WM_LBUTTONUP
        while (i <= 4)
        {
            if (i % 2)
                rgInput[i].mi.dwFlags = dwMouseDown;
            else
                rgInput[i].mi.dwFlags = dwMouseUp;
                
            rgInput[i].type = INPUT_MOUSE;
            rgInput[i].mi.dwExtraInfo = 0;
            rgInput[i].mi.dx = 0;
            rgInput[i].mi.dy = 0;
            rgInput[i].mi.mouseData = nButtons;

            i++;
        }
        
    	// move mouse back to starting location
        rgInput[i].type = INPUT_MOUSE;
        rgInput[i].mi.dwFlags = MOUSEEVENTF_MOVE;
        rgInput[i].mi.dwExtraInfo = 0;
        rgInput[i].mi.dx = -ptCursor.x;
        rgInput[i].mi.dy = -ptCursor.y;
        rgInput[i].mi.mouseData = nButtons;

        i++;
        if (!W32->SendInput(i, rgInput, sizeof(INPUT)))
            MessageBeep(0);

        // Restore Mouse Acceleration
        if (miSave.MouseSpeed)
            SystemParametersInfo(SPI_SETMOUSE, 0, &miSave, 0);

        W32->BlockInput (FALSE);
	    return (S_OK);
    }
    return(DISP_E_MEMBERNOTFOUND);
}


/*
 *	CLstBxWinHost::accSelect(long selFlags, VARIANT varChild)
 *
 *	@mfunc
 *		Modifies the selection or moves the keyboard focus according to the specified flags.  
 *
 *	@rdesc
 *		Returns S_OK if successful or one of the following values or a standard COM 
 *  error code otherwise.
 */
STDMETHODIMP CLstBxWinHost::accSelect(long selFlags, VARIANT varChild)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::accSelect");
    
    // Validate parameters
    if (!MSAA::ValidateChild(&varChild, GetCount()) || !MSAA::ValidateSelFlags(selFlags))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(S_FALSE);

    varChild.lVal--;

    long lStyle = GetWindowLong(_hwnd, GWL_STYLE);
    if (lStyle & LBS_NOSEL)
        return DISP_E_MEMBERNOTFOUND;

    if (!IsSingleSelection())
    {
        // get the focused item here in case we change it. 
        int nFocusedItem = GetCursor();

	    if (selFlags & SELFLAG_TAKEFOCUS) 
        {
            if (!_fFocus)
                return(S_FALSE);

            RichListBoxWndProc (_hwnd, LB_SETCARETINDEX, varChild.lVal, 0);
        }

        // reset and select requested item
	    if (selFlags & SELFLAG_TAKESELECTION)
	    {
	        // deselect the whole range of items
            RichListBoxWndProc(_hwnd, LB_SETSEL, FALSE, -1);
            // Select this one
            RichListBoxWndProc(_hwnd, LB_SETSEL, TRUE, varChild.lVal);
        }

        if (selFlags & SELFLAG_EXTENDSELECTION)
        {
            if ((selFlags & SELFLAG_ADDSELECTION) || (selFlags & SELFLAG_REMOVESELECTION))
                RichListBoxWndProc (_hwnd, LB_SELITEMRANGE, (selFlags & SELFLAG_ADDSELECTION), 
                             MAKELPARAM(nFocusedItem, varChild.lVal));
            else
            {
                BOOL bSelected = RichListBoxWndProc (_hwnd, LB_GETSEL, nFocusedItem, 0);
                RichListBoxWndProc (_hwnd, LB_SELITEMRANGE, bSelected, MAKELPARAM(nFocusedItem,varChild.lVal));
            }
        }
        else // not extending, check add/remove
        {
            if ((selFlags & SELFLAG_ADDSELECTION) || (selFlags & SELFLAG_REMOVESELECTION))
                RichListBoxWndProc(_hwnd, LB_SETSEL, (selFlags & SELFLAG_ADDSELECTION), varChild.lVal);
        }
        // set focus to where it was before if SELFLAG_TAKEFOCUS not set
        if ((selFlags & SELFLAG_TAKEFOCUS) == 0)
            RichListBoxWndProc (_hwnd, LB_SETCARETINDEX, nFocusedItem, 0);
    }
    else // listbox is single select
    {
        if (selFlags & (SELFLAG_ADDSELECTION | SELFLAG_REMOVESELECTION | SELFLAG_EXTENDSELECTION))
            return (E_INVALIDARG);

        // single select listboxes do not allow you to set the
        // focus independently of the selection, so we send a 
        // LB_SETCURSEL for both TAKESELECTION and TAKEFOCUS
	    if ((selFlags & SELFLAG_TAKESELECTION) || (selFlags & SELFLAG_TAKEFOCUS))
            RichListBoxWndProc(_hwnd, LB_SETCURSEL, varChild.lVal, 0);
    } // end if listbox is single select
	
    return(S_OK);
}


/*
 *	CLstBxWinHost::accNavigate(long dwNavDir, VARIANT varStart, VARIANT *pvarEnd)
 *
 *	@mfunc
 *		Retrieves the next or previous sibling or child object in a specified direction.  
 *
 *	@rdesc
 *		Returns S_OK if successful or one of the following values or a standard COM 
 *  error code otherwise.
 */
STDMETHODIMP CLstBxWinHost::accNavigate(long dwNavDir, VARIANT varStart, VARIANT *pvarEnd)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::accNavigate");

    InitPvar(pvarEnd);

    // Validate parameters
    if (!MSAA::ValidateChild(&varStart, GetCount()))
        return(E_INVALIDARG);

    // Is this something for the client (or combobox) to handle?
    long lEnd = 0;
    if (dwNavDir == NAVDIR_FIRSTCHILD)
    {
        lEnd = GetCount() ? 1 : 0;
    }
    else if (dwNavDir == NAVDIR_LASTCHILD)
        lEnd = GetCount();
    else if (varStart.lVal == CHILDID_SELF)
    {   
        // NOTE:
        // MSAA tries to make a distinction for controls by implementing 2 different types of
        // interfaces for controls.
        // OBJID_WINDOW - will include the windows border along with the client.  This control
        //              should be perceived from a dialog or some window containers perspective.
        //              Where the control is just an abstract entity contained in the window container
        // OBJID_CLIENT - only includes the client area.  This interface is only concerned with 
        //              the control itself and disregards the outside world
        IAccessible* poleacc = NULL;
        HRESULT hr = W32->AccessibleObjectFromWindow(_hwnd, OBJID_WINDOW, IID_IAccessible, (void**)&poleacc);
        if (!SUCCEEDED(hr))
            return(hr);

        // Ask it to navigate
        VARIANT varStart;
        VariantInit(&varStart);
        varStart.vt = VT_I4;
        varStart.lVal = OBJID_CLIENT;

        hr = poleacc->accNavigate(dwNavDir, varStart, pvarEnd);

        // Release our parent
        poleacc->Release();
        return(hr);
    }
    else
    {
        //long lT = varStart.lVal - 1;
        switch (dwNavDir)
        {
            // We're a single column list box only so ignore
            // these flags
            //case NAVDIR_RIGHT:
            //case NAVDIR_LEFT:
            //    break;

            case NAVDIR_PREVIOUS:
            case NAVDIR_UP:
                // Are we in the top-most row?
                lEnd = varStart.lVal - 1;
                break;

            case NAVDIR_NEXT:
            case NAVDIR_DOWN:
                lEnd = varStart.lVal + 1;
                if (lEnd > GetCount())
                    lEnd = 0;
                break;
        }
    }

    if (lEnd)
    {
        pvarEnd->vt = VT_I4;
        pvarEnd->lVal = lEnd;
    }

    return(lEnd ? S_OK : S_FALSE);
}


/*
 *	CLstBxWinHost::get_accParent(IDispatch **ppdispParent)
 *
 *	@mfunc
 *		Retrieves the IDispatch interface of the current object's parent. 
 *  Return S_FALSE and set the variable at ppdispParent to NULL. 
 *
 *	@rdesc
 *		HRESULT = S_FALSE.
 */
STDMETHODIMP CLstBxWinHost::get_accParent(IDispatch **ppdispParent)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::get_accParent");

    AssertSz(ppdispParent != NULL, "null pointer");
    if (ppdispParent == NULL)
        return S_FALSE;
        
    InitPv(ppdispParent);
    HWND hwnd;
    if (_fLstType != kCombo)
    {
        hwnd = MSAA::GetAncestor(_hwnd, GA_PARENT);
        AssertSz(hwnd, "Invalid Hwnd");
        if (!hwnd)
            return S_FALSE;
    }
    else
    {
        if (_pcbHost)
        {
            hwnd = _pcbHost->_hwnd;
            Assert(hwnd);
        }
        else
            return S_FALSE;
        
    }

    HRESULT hr = W32->AccessibleObjectFromWindow(hwnd, OBJID_CLIENT, IID_IDispatch,
                                          (void **)ppdispParent);

#ifdef DEBUG
    if (FAILED(hr))
        Assert(FALSE);
#endif
    return hr;
}


/*
 *	CLstBxWinHost::get_accChildCount(long *pcCount)
 *
 *	@mfunc
 *		Retrieves the number of children belonging to the current object. 
 *
 *	@rdesc
 *		HRESULT = S_FALSE.
 */
STDMETHODIMP CLstBxWinHost::get_accChildCount(long *pcCount)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::get_accChildCount");

    *pcCount = GetCount();
    return(S_OK);
}


//////////////////////// Combobox IAccessible Methods ////////////////////////////// 
// COMBOBOXES
#define INDEX_COMBOBOX                  0
#define INDEX_COMBOBOX_ITEM             1
#define INDEX_COMBOBOX_BUTTON           2
#define INDEX_COMBOBOX_LIST             3

#define CCHILDREN_COMBOBOX              3

/*
 *	CCmbBxWinHost::InitTypeInfo()
 *
 *	@mfunc
 *		Retrieves type library
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise.
 */
HRESULT CCmbBxWinHost::InitTypeInfo()
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::InitTypeInfo");
    return MSAA::InitTypeInfo(&_pTypeInfo);
}

/*
 *	CCmbBxWinHost::get_accName(VARIANT varChild, BSTR *pszName)
 *
 *	@mfunc
 *		Retrieves the Name property for this object. 
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::get_accName(VARIANT varChild, BSTR *pszName)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accName");
    
    // Validate
    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    // The name of the combobox, the edit inside of it, and the dropdown
    // are all the same.  The name of the button is Drop down/Pop up
    InitPv(pszName);
    if (varChild.lVal != INDEX_COMBOBOX_BUTTON)
        return(MSAA::GetWindowName(_hwnd, pszName));
    else
    {
        if (IsWindowVisible(_hwndList))
            return (MSAA::GetStringResource(STR_DROPDOWN_HIDE, pszName));
        else
            return(MSAA::GetStringResource(STR_DROPDOWN_SHOW, pszName));
    }
}

/*
 *	CCmbBxWinHost::get_accValue(VARIANT varChild, BSTR *pszValue)
 *
 *	@mfunc
 *		Retrieves the object's Value property.  
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::get_accValue(VARIANT varChild, BSTR *pszValue)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accValue");
    
    // Validate
    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    switch (varChild.lVal)
    {
        case INDEX_COMBOBOX:
        case INDEX_COMBOBOX_ITEM:
            InitPv(pszValue);
            LRESULT lres;
            _pserv->TxSendMessage(WM_GETTEXTLENGTH, 0, 0, &lres);

            // If windows text length is 0 then MSAA searches
            // for the label associated with the control
            if (lres <= 0)
                return MSAA::GetLabelString(_hwnd, pszValue);
                
            GETTEXTEX gt;
            memset(&gt, 0, sizeof(GETTEXTEX));
            gt.cb = (lres + 1) * sizeof(WCHAR);
            gt.codepage = 1200;
            gt.flags = GT_DEFAULT;

            *pszValue = SysAllocStringLen(NULL, lres + 1);
            if (!*pszValue)
                return E_OUTOFMEMORY;
                
            _pserv->TxSendMessage(EM_GETTEXTEX, (WPARAM)&gt, (LPARAM)*pszValue, &lres);
            return S_OK;
    }
    return DISP_E_MEMBERNOTFOUND;
}


/*
 *	CCmbBxWinHost::get_accRole(VARIANT varChild, VARIANT *pvarRole)
 *
 *	@mfunc
 *		Retrieves the object's Role property.   
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accRole");
    
    // Validate--this does NOT accept a child ID.
    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;
    
    switch (varChild.lVal)
    {
        case INDEX_COMBOBOX:
            pvarRole->lVal = ROLE_SYSTEM_COMBOBOX;
            break;

        case INDEX_COMBOBOX_ITEM:
            if (_cbType == kDropDown)
                pvarRole->lVal = ROLE_SYSTEM_TEXT;
            else
                pvarRole->lVal = ROLE_SYSTEM_STATICTEXT;
            break;

        case INDEX_COMBOBOX_BUTTON:
            pvarRole->lVal = ROLE_SYSTEM_PUSHBUTTON;
            break;

        case INDEX_COMBOBOX_LIST:
            pvarRole->lVal = ROLE_SYSTEM_LIST;
            break;

        default:
            AssertSz(FALSE, "Invalid ChildID for child of combo box" );
    }

    return(S_OK);
}


/*
 *	CCmbBxWinHost::get_accState(VARIANT varChild, VARIANT *pvarState)
 *
 *	@mfunc
 *		Retrieves the current state of the object or child item.    
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accState");
    
    // Validate--this does NOT accept a child ID.
    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    VARIANT var;
    HRESULT hr;
    IAccessible* poleacc;
    InitPvar(pvarState);
    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

    HWND hwndActive = GetForegroundWindow();
    switch (varChild.lVal)
    {
        case INDEX_COMBOBOX_BUTTON:
            if (_fMousedown)
                pvarState->lVal |= STATE_SYSTEM_PRESSED;
            break;

        case INDEX_COMBOBOX_ITEM:
            if (_cbType == kDropDownList)
            {              
                if (hwndActive == MSAA::GetAncestor(_hwnd, GA_ROOT))
                    pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;
                if (_fFocus)
                    pvarState->lVal |= STATE_SYSTEM_FOCUSED;
                break;
            }
            
            // FALL THROUGH CASE
            
        case INDEX_COMBOBOX:
            if (!(_dwStyle & WS_VISIBLE))
                pvarState->lVal |= STATE_SYSTEM_INVISIBLE;

            if (_dwStyle & WS_DISABLED)
                pvarState->lVal |= STATE_SYSTEM_UNAVAILABLE;

            if (_fFocus)
                pvarState->lVal |= STATE_SYSTEM_FOCUSED;

            if (hwndActive == MSAA::GetAncestor(_hwnd, GA_ROOT))
                pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;
            break;            

        case INDEX_COMBOBOX_LIST:
            {

                // First we incorporate the state of the window in general
                //
                VariantInit(&var);
                if (FAILED(hr = MSAA::GetWindowObject(_hwndList, &var)))
                    return(hr);

                Assert(var.vt == VT_DISPATCH);

                // Get the child acc object
                poleacc = NULL;
                hr = var.pdispVal->QueryInterface(IID_IAccessible,
                    (void**)&poleacc);
                var.pdispVal->Release();

                if (FAILED(hr))
                {
                    Assert(FALSE);
                    return(hr);
                }

                // Ask the child its state
                VariantInit(&var);
                hr = poleacc->get_accState(var, pvarState);
                poleacc->Release();
                if (FAILED(hr))
                {
                    Assert(FALSE);
                    return(hr);
                }

                // The listbox is always going to be floating
                //
                pvarState->lVal |= STATE_SYSTEM_FLOATING;

                if (_plbHost->_fDisabled)
                    pvarState->lVal |= STATE_SYSTEM_UNAVAILABLE;
                else
                    pvarState->lVal &= ~STATE_SYSTEM_UNAVAILABLE;

                if (_fListVisible)
                    pvarState->lVal &= ~STATE_SYSTEM_INVISIBLE;
                else
                    pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
                    
                break;
            }
    }

    return(S_OK);
}


/*
 *	CCmbBxWinHost::get_accKeyboardShortcut(VARIANT varChild, BSTR *pszShortcut)
 *
 *	@mfunc
 *		Retrieves an object's KeyboardShortcut property.    
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::get_accKeyboardShortcut(VARIANT varChild, BSTR *pszShortcut)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accKeyboardShortcut");
    
    // Shortcut for combo is label's hotkey.
    // Shortcut for dropdown (if button) is Alt+F4.
    // CWO, 12/5/96, Alt+F4? F4, by itself brings down the combo box,
    //                       but we add "Alt" to the string.  Bad!  Now use 
    //                       down arrow and add Alt to it via HrMakeShortcut()
    //                       As documented in the UI style guide.
    //
    // As always, shortcuts only apply if the container has "focus".  In other
    // words, the hotkey for the combo does nothing if the parent dialog
    // isn't active.  And the hotkey for the dropdown does nothing if the
    // combobox/edit isn't focused.
  

    // Validate parameters
    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    InitPv(pszShortcut);
    if (varChild.lVal == INDEX_COMBOBOX)
    {
        return(MSAA::GetWindowShortcut(_hwnd, pszShortcut));
    }
    else if (varChild.lVal == INDEX_COMBOBOX_BUTTON)
    {
        return(MSAA::GetStringResource(STR_COMBOBOX_LIST_SHORTCUT, pszShortcut));
    }
    return DISP_E_MEMBERNOTFOUND;
}


/*
 *	CCmbBxWinHost::get_accFocus(VARIANT *pvarFocus)
 *
 *	@mfunc
 *		Retrieves the child object that currently has the keyboard focus.  
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::get_accFocus(VARIANT *pvarFocus)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accFocus");
    
    InitPvar(pvarFocus);
    // Is the current focus a child of us?
    if (_fFocus)
    {
        pvarFocus->vt = VT_I4;
        pvarFocus->lVal = 0;
    }
    else 
    {
        // NOTE:
        //  We differ here in we don't get the foreground thread's focus window.  Instead,
        //  we just get the current threads focus window
        HWND hwnd = GetFocus();
        if (IsChild(_hwnd, hwnd))            
            return(MSAA::GetWindowObject(hwnd, pvarFocus));
    }

    return(S_OK);
}


/*
 *	CCmbBxWinHost::get_accDefaultAction(VARIANT varChild, BSTR *pszDefaultAction)
 *
 *	@mfunc
 *		Retrieves a string containing a localized sentence that describes the object's
 *  default action.   
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::get_accDefaultAction(VARIANT varChild, BSTR *pszDefaultAction)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accDefaultAction");
    
    // Validate parameters
    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    if ((varChild.lVal != INDEX_COMBOBOX_BUTTON)/* || _fHasButton*/)
        return DISP_E_MEMBERNOTFOUND;

    // Default action of button is to press it.  If pressed already, pressing
    // it will pop dropdown back up.  If not pressed, pressing it will pop
    // dropdown down.
    InitPv(pszDefaultAction);

    if (IsWindowVisible(_hwndList))
        return(MSAA::GetStringResource(STR_DROPDOWN_HIDE, pszDefaultAction));
    else
        return(MSAA::GetStringResource(STR_DROPDOWN_SHOW, pszDefaultAction));
}


/*
 *	CCmbBxWinHost::accSelect(long flagsSel, VARIANT varChild)
 *	@mfunc
 *		Modifies the selection or moves the keyboard focus according to the specified 
 *  flags.   
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::accSelect(long flagsSel, VARIANT varChild)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::accSelect");
    
    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX) || !MSAA::ValidateSelFlags(flagsSel))
        return(E_INVALIDARG);

    return(S_FALSE);
}


/*
 *	CCmbBxWinHost::accLocation(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild)
 *	@mfunc
 *		Retrieves the object's current screen location (if the object was placed on 
 *   the screen) and optionally, the child element.    
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::accLocation(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::accLocation");
    
    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    // Validate
    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    RECT rc;
    HWND hwnd = _hwnd;
    switch (varChild.lVal)
    {        
        case INDEX_COMBOBOX_BUTTON:
            //if (!m_fHasButton)
            //    return(S_FALSE);
            rc = _rcButton;
            *pcxWidth = rc.right - rc.left;
            *pcyHeight = rc.bottom - rc.top;
            ClientToScreen(_hwnd, (LPPOINT)&rc);
            break;

        case INDEX_COMBOBOX_ITEM:
            //  Need to verify this is the currently selected item.
            //  if no item is selected then pass the rect of the first item in the list
            _plbHost->LbGetItemRect((_plbHost->GetCursor() < 0) ? 0 : _plbHost->GetCursor(), &rc);
            
            *pcxWidth = rc.right - rc.left;
            *pcyHeight = rc.bottom - rc.top;   
            ClientToScreen(_hwndList, (LPPOINT)&rc);
            break;

        case INDEX_COMBOBOX_LIST:
            hwnd = _hwndList;
            // fall through!!!
            
        case 0: //default window
            GetWindowRect(hwnd, &rc);
            // copy over dimensions            
            *pcxWidth = rc.right - rc.left;
            *pcyHeight = rc.bottom - rc.top;
            break;

        default:
            AssertSz(FALSE, "Invalid ChildID for child of combo box" );
            return (S_OK);
    }
    
    *pxLeft = rc.left;
    *pyTop = rc.top;
    return(S_OK);
}


/*
 *	CCmbBxWinHost::accNavigate(long dwNav, VARIANT varStart, VARIANT* pvarEnd)
 *
 *	@mfunc
 *		Retrieves the next or previous sibling or child object in a specified 
 *  direction.   
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::accNavigate(long dwNav, VARIANT varStart, VARIANT* pvarEnd)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::accNavigate");


    InitPvar(pvarEnd);

    // Validate parameters
    if (!MSAA::ValidateChild(&varStart, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    long lEnd = 0;
    if (dwNav == NAVDIR_FIRSTCHILD)
    {
        lEnd =  INDEX_COMBOBOX_ITEM;
        goto GetTheChild;
    }
    else if (dwNav == NAVDIR_LASTCHILD)
    {
        dwNav = NAVDIR_PREVIOUS;
        varStart.lVal = CCHILDREN_COMBOBOX + 1;
    }
    else if (!varStart.lVal)
    {
        // NOTE:
        // MSAA tries to make a distinction for controls by implementing 2 different types of
        // interfaces for controls.
        // OBJID_WINDOW - will include the windows border along with the client.  This control
        //              should be perceived from a dialog or some window containers perspective.
        //              Where the control is just an abstract entity contained in the window container
        // OBJID_CLIENT - only includes the client area.  This interface is only concerned with 
        //              the control itself and disregards the outside world
        IAccessible* poleacc = NULL;
        HRESULT hr = W32->AccessibleObjectFromWindow(_hwnd, OBJID_WINDOW, IID_IAccessible, (void**)&poleacc);
        if (!SUCCEEDED(hr))
            return(hr);

        // Ask it to navigate
        VARIANT varStart;
        VariantInit(&varStart);
        varStart.vt = VT_I4;
        varStart.lVal = OBJID_CLIENT;

        hr = poleacc->accNavigate(dwNav, varStart, pvarEnd);

        // Release our parent
        poleacc->Release();
        return(hr);
    }

    // Map HWNDID to normal ID.  We work with both (it is easier).
    if (IsHWNDID(varStart.lVal))
    {
        HWND hWndTemp = HwndFromHWNDID(varStart.lVal);

        if (hWndTemp == _hwnd)
            varStart.lVal = INDEX_COMBOBOX_ITEM;
        else if (hWndTemp == _hwndList)
            varStart.lVal = INDEX_COMBOBOX_LIST;
        else
            // Don't know what the heck this is
            return(S_FALSE);
    }

    switch (dwNav)
    {
        case NAVDIR_UP:
            if (varStart.lVal == INDEX_COMBOBOX_LIST)
                lEnd = INDEX_COMBOBOX_ITEM;
            break;

        case NAVDIR_DOWN:
            if ((varStart.lVal != INDEX_COMBOBOX_LIST) && _fListVisible)
                lEnd = INDEX_COMBOBOX_LIST;
            break;

        case NAVDIR_LEFT:
            if (varStart.lVal == INDEX_COMBOBOX_BUTTON)
                lEnd = INDEX_COMBOBOX_ITEM;
            break;

        case NAVDIR_RIGHT:
            if ((varStart.lVal == INDEX_COMBOBOX_ITEM)/* && !(cbi.stateButton & STATE_SYSTEM_INVISIBLE)*/)
               lEnd = INDEX_COMBOBOX_BUTTON;
            break;

        case NAVDIR_PREVIOUS:
            lEnd = varStart.lVal - 1;
            if ((lEnd == INDEX_COMBOBOX_LIST) && !_fListVisible)
                --lEnd;
            break;

        case NAVDIR_NEXT:
            lEnd = varStart.lVal + 1;
            if (lEnd > CCHILDREN_COMBOBOX || ((lEnd == INDEX_COMBOBOX_LIST) && !_fListVisible))
                lEnd = 0;
            break;
    }

GetTheChild:
    if (lEnd)
    {
        // NOTE:
        // MSAA tries to make a distinction for controls by implementing 2 different types of
        // interfaces for controls.
        // OBJID_WINDOW - will include the windows border along with the client.  This control
        //              should be perceived from a dialog or some window containers perspective.
        //              Where the control is just an abstract entity contained in the window container
        // OBJID_CLIENT - only includes the client area.  This interface is only concerned with 
        //              the control itself and disregards the outside world
        if ((lEnd == INDEX_COMBOBOX_ITEM)/* && cbi.hwndItem*/)
            return(MSAA::GetWindowObject(_hwnd, pvarEnd));
        else if ((lEnd == INDEX_COMBOBOX_LIST)/* && cbi.hwndList*/)
            return(MSAA::GetWindowObject(_hwndList, pvarEnd));

        pvarEnd->vt = VT_I4;
        pvarEnd->lVal = lEnd;
        return(S_OK);
    }

    return(S_FALSE);
}


/*
 *	CCmbBxWinHost::accHitTest(long xLeft, long yTop, VARIANT *pvarEnd)
 *
 *	@mfunc
 *		Retrieves the child object at a given point on the screen.    
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::accHitTest(long xLeft, long yTop, VARIANT *pvarEnd)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::accHitTest");
    
    POINT   pt;
    RECT    rc;

    InitPvar(pvarEnd);

    pt.x = xLeft;
    pt.y = yTop;

    // Check list first, in case it is a dropdown.
    GetWindowRect(_hwndList, &rc);
    if (_fListVisible && PtInRect(&rc, pt))
        return(MSAA::GetWindowObject(_hwndList, pvarEnd));
    else
    {
        ScreenToClient(_hwnd, &pt);
        GetClientRect(_hwnd, &rc);        

        if (PtInRect(&_rcButton, pt))
        {
            pvarEnd->vt = VT_I4;
            pvarEnd->lVal = INDEX_COMBOBOX_BUTTON;
        }
        else
        {
            if (!PtInRect(&rc, pt))
                return(S_FALSE);
            pvarEnd->vt = VT_I4;
            pvarEnd->lVal = 0;
        }
    }

    return(S_OK);
}


/*
 *	CCmbBxWinHost::accDoDefaultAction(VARIANT varChild)
 *
 *	@mfunc
 *		Performs the object's default action.   
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::accDoDefaultAction(VARIANT varChild)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::accDoDefaultAction");
    
    // Validate
    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    if ((varChild.lVal == INDEX_COMBOBOX_BUTTON)/* && m_fHasButton*/)
    {
        if (_fListVisible)
            PostMessage(_hwnd, WM_KEYDOWN, VK_RETURN, 0);
        else
            PostMessage(_hwnd, CB_SHOWDROPDOWN, TRUE, 0);

        return(S_OK);
    }
    return DISP_E_MEMBERNOTFOUND;
}


/*
 *	CCmbBxWinHost::get_accSelection(VARIANT *pvarChildren)
 *
 *	@mfunc
 *		Retrieves the selected children of this object.   
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::get_accSelection(VARIANT *pvarChildren)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accSelection");
    
    InitPvar(pvarChildren);
    return(S_FALSE);
}


/*
 *	CCmbBxWinHost::get_accParent(IDispatch **ppdispParent)
 *
 *	@mfunc
 *		Retrieves the IDispatch interface of the current object's parent. 
 *  Return S_FALSE and set the variable at ppdispParent to NULL. 
 *
 *	@rdesc
 *		HRESULT = S_FALSE.
 */
STDMETHODIMP CCmbBxWinHost::get_accParent(IDispatch **ppdispParent)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accParent");
    
    InitPv(ppdispParent);

    if (_hwnd)
    {
        HWND hwnd = MSAA::GetAncestor(_hwnd, GA_PARENT);
        if (hwnd)
            return W32->AccessibleObjectFromWindow(hwnd, OBJID_WINDOW,
                    IID_IDispatch, (void **)ppdispParent);
    }
    
    return(S_FALSE);
}


/*
 *	CCmbBxWinHost::get_accChildCount(long *pcountChildren)
 *
 *	@mfunc
 *		Retrieves the number of children belonging to the current object. 
 *
 *	@rdesc
 *		HRESULT = S_FALSE.
 */
STDMETHODIMP CCmbBxWinHost::get_accChildCount(long *pcountChildren)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accChildCount");
    if (pcountChildren)
        *pcountChildren = CCHILDREN_COMBOBOX;
    return S_OK;
}


/*
 *	CCmbBxWinHost::get_accChild(VARIANT varChild, IDispatch **ppdispChild)
 *
 *	@mfunc
 *		Retrieves the number of children belonging to the current object. 
 *
 *	@rdesc
 *		HRESULT = S_FALSE.
 */
STDMETHODIMP CCmbBxWinHost::get_accChild(VARIANT varChild, IDispatch **ppdispChild)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accChild");
    
    // Validate
    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    InitPv(ppdispChild);
    HWND hwndChild = NULL;
    switch (varChild.lVal)
    {
        case INDEX_COMBOBOX:
            return E_INVALIDARG;

        //case INDEX_COMBOBOX_ITEM:
        //   hwndChild = _hwnd;
        //   break;

        case INDEX_COMBOBOX_LIST:
            hwndChild = _hwndList;
            break;
    }

    if (!hwndChild)
        return(S_FALSE);
    else
        return(W32->AccessibleObjectFromWindow(hwndChild, OBJID_WINDOW, IID_IDispatch, (void**)ppdispChild));
}


//////////////////////// CTxtWinHost IDispatch Methods ///////////////////////////
// --------------------------------------------------------------------------
//
//  CTxtWinHost::GetTypeInfoCount()
//
//  This hands off to our typelib for IAccessible().  Note that
//  we only implement one type of object for now.  BOGUS!  What about IText?
//
// --------------------------------------------------------------------------
STDMETHODIMP CTxtWinHost::GetTypeInfoCount(UINT * pctInfo)
{
    HRESULT hr = InitTypeInfo();
    if (SUCCEEDED(hr))
    {
        InitPv(pctInfo);
        *pctInfo = 1;
    }
    return(hr);
}



// --------------------------------------------------------------------------
//
//  CTxtWinHost::GetTypeInfo()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTxtWinHost::GetTypeInfo(UINT itInfo, LCID lcid,
    ITypeInfo ** ppITypeInfo)
{
    HRESULT hr = InitTypeInfo();
    if (SUCCEEDED(hr))
    {
        if (ppITypeInfo == NULL)
            return(E_POINTER);

        InitPv(ppITypeInfo);

        if (itInfo != 0)
            return(TYPE_E_ELEMENTNOTFOUND);
        _pTypeInfo->AddRef();
        *ppITypeInfo = _pTypeInfo;
    }
    return(hr);
}



// --------------------------------------------------------------------------
//
//  CTxtWinHost::GetIDsOfNames()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTxtWinHost::GetIDsOfNames(REFIID riid,
    OLECHAR** rgszNames, UINT cNames, LCID lcid, DISPID* rgDispID)
{
    HRESULT hr = InitTypeInfo();
    if (!SUCCEEDED(hr))
        return(hr);

    return(_pTypeInfo->GetIDsOfNames(rgszNames, cNames, rgDispID));
}



// --------------------------------------------------------------------------
//
//  CTxtWinHost::Invoke()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTxtWinHost::Invoke(DISPID dispID, REFIID riid,
    LCID lcid, WORD wFlags, DISPPARAMS * pDispParams,
    VARIANT* pvarResult, EXCEPINFO* pExcepInfo, UINT* puArgErr)
{
    HRESULT hr = InitTypeInfo();
    if (!SUCCEEDED(hr))
        return(hr);

    return(_pTypeInfo->Invoke((IAccessible *)this, dispID, wFlags,
        pDispParams, pvarResult, pExcepInfo, puArgErr));
}



#endif // NOACCESSIBILITY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\lbhost.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	LBHOST.CPP -- Text Host for CreateWindow() Rich Edit 
 *		List Box Control | 
 *		Implements CLstBxWinHost message
 *		
 *	Original Author: 
 *		Jerry Kim
 *
 *	History: <nl>
 *		12/15/97 - v-jerrki Created
 *
 *	Set tabs every four (4) columns
 *
 *	Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */
#include "_common.h"
#include "_host.h"
#include "imm.h"
#include "_format.h"
#include "_edit.h"
#include "_cfpf.h"
#include "_cbhost.h"

ASSERTDATA

#ifdef DEBUG
const UINT db_rgLBUnsupportedStyle[] = {
	LBS_MULTICOLUMN,
	LBS_NODATA,			
	LBS_NOREDRAW,
	LBS_NOSEL,
	LBS_OWNERDRAWVARIABLE,
	LBS_WANTKEYBOARDINPUT,
	0
};

const UINT db_rgLBUnsupportedMsg[] = {		
	LB_GETHORIZONTALEXTENT,
	LB_GETLOCALE,
	LB_SETLOCALE,
	LB_GETHORIZONTALEXTENT,
	LB_INITSTORAGE,
	LB_ITEMFROMPOINT,
	LB_SETANCHORINDEX,
	LB_SETHORIZONTALEXTENT,
	LB_SETCOLUMNWIDTH,
	LB_ADDFILE,
	LB_DIR,
	EM_GETLIMITTEXT,
	EM_POSFROMCHAR,
	EM_CHARFROMPOS,
	EM_SCROLLCARET,
	EM_CANPASTE,
	EM_DISPLAYBAND,
	EM_EXGETSEL,
	EM_EXLIMITTEXT,
	EM_EXLINEFROMCHAR,
	EM_EXSETSEL,
	EM_FINDTEXT,
	EM_FORMATRANGE,
	EM_GETEVENTMASK,
	EM_GETOLEINTERFACE,
	EM_GETPARAFORMAT,
	EM_GETSELTEXT, 
	EM_HIDESELECTION,
	EM_PASTESPECIAL,
	EM_REQUESTRESIZE,
	EM_SELECTIONTYPE,
	EM_SETBKGNDCOLOR,
	EM_SETEVENTMASK,
	EM_SETOLECALLBACK,
	EM_SETTARGETDEVICE,
	EM_STREAMIN,
	EM_STREAMOUT,
	EM_GETTEXTRANGE,
	EM_FINDWORDBREAK,
	EM_SETOPTIONS,
	EM_GETOPTIONS,
	EM_FINDTEXTEX,
#ifdef _WIN32
	EM_GETWORDBREAKPROCEX,
	EM_SETWORDBREAKPROCEX,
#endif

	/* Richedit v2.0 messages */
	EM_SETUNDOLIMIT,
	EM_REDO,
	EM_CANREDO,
	EM_GETUNDONAME,
	EM_GETREDONAME,
	EM_STOPGROUPTYPING,
	EM_SETTEXTMODE,
	EM_GETTEXTMODE,
	EM_AUTOURLDETECT,
	EM_GETAUTOURLDETECT,
	EM_GETTEXTEX,
	EM_GETTEXTLENGTHEX,
	EM_SHOWSCROLLBAR,	
	/* Far East specific messages */
	EM_SETPUNCTUATION,
	EM_GETPUNCTUATION,
	EM_SETWORDWRAPMODE,
	EM_GETWORDWRAPMODE,
	EM_SETIMECOLOR,
	EM_GETIMECOLOR,
	EM_SETIMEOPTIONS,
	EM_GETIMEOPTIONS,
	EM_CONVPOSITION,
	EM_SETLANGOPTIONS,
	EM_GETLANGOPTIONS,
	EM_GETIMECOMPMODE,
	EM_FINDTEXTW,
	EM_FINDTEXTEXW,

	/* RE3.0 FE messages */
	EM_RECONVERSION,
	EM_SETIMEMODEBIAS,
	EM_GETIMEMODEBIAS,
	/* Extended edit style specific messages */
	0
};

// Checks if the style is in the passed in array
BOOL LBCheckStyle(UINT msg, const UINT* rg)
{
	for (int i = 0; rg[i]; i++)
		if (rg[i] & msg)
		{
			AssertSz(FALSE, "Unsupported style recieved");
			return TRUE;
		}
	return FALSE;
}

// Checks if the msg is in the passed in array
BOOL LBCheckMessage(UINT msg, const UINT* rg)
{
	for (int i = 0; rg[i]; i++)
		if (rg[i] == msg)
		{
			AssertSz(FALSE, "Unsupported message recieved");
			return TRUE;
		}
	return FALSE;
}

#define CHECKSTYLE(msg) if (LBCheckStyle(msg, db_rgLBUnsupportedStyle)) Assert(FALSE && "Unsupported Style")
#define CHECKMESSAGE(msg) if (LBCheckMessage(msg, db_rgLBUnsupportedMsg)) Assert(FALSE && "Unsupported Message")
#else
#define CHECKSTYLE(msg)	
#define CHECKMESSAGE(msg)
#endif

// internal listbox messages
#define LB_KEYDOWN WM_USER+1

// UNDONE:
//	Should this go into _w32sys.h??
#ifndef CSTR_LESS_THAN
// 
//  Compare String Return Values. 
// 
#define CSTR_LESS_THAN            1           // string 1 less than string 2 
#define CSTR_EQUAL                2           // string 1 equal to string 2 
#define CSTR_GREATER_THAN         3           // string 1 greater than string 
#endif


// UNDONE : LOCALIZATION
// these vary by country!  For US they are VK_OEM_2 VK_OEM_5.
//       Change lboxctl2.c MapVirtualKey to character - and fix the spelling?
#define VERKEY_SLASH     0xBF   /* Vertual key for '/' character */
#define VERKEY_BACKSLASH 0xDC   /* Vertual key for '\' character */

// Used for Listbox notifications
#define LBNOTIFY_CANCEL 	1
#define LBNOTIFY_SELCHANGE 	2
#define LBNOTIFY_DBLCLK		4

// Used for LBSetSelection
#define LBSEL_SELECT	1
#define LBSEL_NEWANCHOR	2
#define LBSEL_NEWCURSOR	4
#define LBSEL_RESET		8
#define LBSEL_HIGHLIGHTONLY 16

#define LBSEL_DEFAULT (LBSEL_SELECT | LBSEL_NEWANCHOR | LBSEL_NEWCURSOR | LBSEL_RESET)

// Used for keyboard and mouse messages
#define LBKEY_NONE 0
#define LBKEY_SHIFT	1
#define LBKEY_CONTROL 2
#define LBKEY_SHIFTCONTROL 3

extern const TCHAR szCR[];

// Timer id when mouse is captured
#define ID_LB_CAPTURE	28988
#define ID_LB_CAPTURE_DEFAULT 250

// Timer id when type search is required
#define ID_LB_SEARCH	28989
#define ID_LB_SEARCH_DEFAULT 750	//.75 seconds is the value for winnt

// Size of allocated string
#define LBSEARCH_MAXSIZE 256

// Helper function in edit.cpp
LONG GetECDefaultHeightAndWidth(
	ITextServices *pts,
	HDC hdc,
	LONG lZoomNumerator,
	LONG lZoomDenominator,
	LONG yPixelsPerInch,
	LONG *pxAveWidth,
	LONG *pxOverhang,
	LONG *pxUnderhang);

// helper function for compare string.  This function checks for null strings
// because CStrIn doesn't like initializing string with zero length
int CompareStringWrapper( 
	LCID  Locale,			// locale identifier 
	DWORD  dwCmpFlags,		// comparison-style options 
	LPCWSTR  lpString1,		// pointer to first string 
	int  cch1,			// size, in bytes or characters, of first string 
	LPCWSTR  lpString2,		// pointer to second string 
	int  cch2 			// size, in bytes or characters, of second string  
)
{
	// check if one of the 2 strings is 0-length if so then
	// no need to proceed the one with the 0-length is the less
	if (!cch1 || !cch2)
	{
		if (cch1 < cch2)
			return CSTR_LESS_THAN;
		else if (cch1 > cch2)
			return CSTR_GREATER_THAN;
		return CSTR_EQUAL;
	}
	return CompareString(Locale, dwCmpFlags, lpString1, cch1, lpString2, cch2);	
}

template<class CLbData> CLbData
CDynamicArray<CLbData>::_sDummy = {0, 0};

//////////////////////////// System Window Procs ////////////////////////////
/*
 *	RichListBoxWndProc (hwnd, msg, wparam, lparam)
 *
 *	@mfunc
 *		Handle window messages pertinent to the host and pass others on to
 *		text services. 
 *	#rdesc
 *		LRESULT = (code processed) ? 0 : 1
 */
LRESULT CALLBACK RichListBoxWndProc(
	HWND hwnd,
	UINT msg,
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "RichListBoxWndProc");

	LRESULT	lres = 0;
	HRESULT hr;
	CLstBxWinHost *phost = (CLstBxWinHost *) GetWindowLongPtr(hwnd, ibPed);

	#ifdef DEBUG
	Tracef(TRCSEVINFO, "hwnd %lx, msg %lx, wparam %lx, lparam %lx", hwnd, msg, wparam, lparam);
	#endif	// DEBUG

	switch(msg)
	{
	case WM_NCCREATE:
		return CLstBxWinHost::OnNCCreate(hwnd, (CREATESTRUCT *)lparam);

	case WM_CREATE:
		// We may be on a system with no WM_NCCREATE (e.g. WINCE)
		if (!phost)
		{
			(void) CLstBxWinHost::OnNCCreate(hwnd, (CREATESTRUCT *) lparam);
			phost = (CLstBxWinHost *) GetWindowLongPtr(hwnd, ibPed);
		}
		break;

	case WM_DESTROY:
		if(phost)
			CLstBxWinHost::OnNCDestroy(phost);
		return 0;
	}

	if (!phost)
		return ::DefWindowProc(hwnd, msg, wparam, lparam);

	// in certain out-of-memory situations, clients may try to re-enter us 
	// with calls.  Just bail on the call if we don't have a text services
	// pointer.
	if(!phost->_pserv)
		return 0;

	// stabilize ourselves
	phost->AddRef();

	CHECKMESSAGE(msg);

	long nTemp = 0;
	switch(msg)
	{
	///////////////////////Painting. Messages///////////////////////////////
	case WM_NCPAINT:
		lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		phost->OnSysColorChange();
		if(phost->TxGetEffects() == TXTEFFECT_SUNKEN && dwMajorVersion < VERS4 &&
			phost->_fLstType != CLstBxWinHost::kCombo)
		{
			HDC hdc = GetDC(hwnd);
			if(hdc)
			{
				phost->DrawSunkenBorder(hwnd, hdc);
				ReleaseDC(hwnd, hdc);
			}
		}
		break;

	case WM_PRINTCLIENT:
	case WM_PAINT:
		{
			PAINTSTRUCT ps;
			RECT rc;
 			HPALETTE hpalOld = NULL;
			HDC hdc = BeginPaint(hwnd, &ps);
			RECT rcClient;			
			
			// Since we are using the CS_PARENTDC style, make sure
			// the clip region is limited to our client window.
			GetClientRect(hwnd, &rcClient);

			// Set up the palette for drawing our data
			if(phost->_hpal)
			{
				hpalOld = SelectPalette(hdc, phost->_hpal, TRUE);
				RealizePalette(hdc);
			}

			SaveDC(hdc);
			IntersectClipRect(hdc, rcClient.left, rcClient.top, rcClient.right,
				rcClient.bottom);
				
			if (!phost->_fOwnerDraw)
			{	
				

				phost->_pserv->TxDraw(
					DVASPECT_CONTENT,  		// Draw Aspect
					-1,						// Lindex
					NULL,					// Info for drawing optimazation
					NULL,					// target device information
					hdc,					// Draw device HDC
					NULL, 				   	// Target device HDC
					(const RECTL *) &rcClient,// Bounding client rectangle
					NULL, 					// Clipping rectangle for metafiles
					&ps.rcPaint,			// Update rectangle
					NULL, 	   				// Call back function
					NULL,					// Call back parameter
					TXTVIEW_ACTIVE);		// What view - the active one!

				// Restore palette if there is one
#ifndef PEGASUS
				if(hpalOld)
					SelectPalette(hdc, hpalOld, TRUE);
#endif
				if(phost->TxGetEffects() == TXTEFFECT_SUNKEN && dwMajorVersion < VERS4 &&
					phost->_fLstType != CLstBxWinHost::kCombo)
					phost->DrawSunkenBorder(hwnd, hdc);
			}
			else
			{
				// Owner draw
				int nViewsize = phost->GetViewSize();
				int nCount = phost->GetCount();
				int nTopidx = phost->GetTopIndex();
				
				// notify each visible item and then the one which has the focus
				int nBottom = min(nCount, nTopidx + nViewsize);
				if (nBottom >= nCount || !phost->IsItemViewable(nBottom))
					nBottom--;
				for (int i = nTopidx; i <= nBottom; i++) 
				{
					// get Rect of region and see if it intersects
			    	phost->LbGetItemRect(i, &rc);
			    	if (IntersectRect(&rc, &rc, &ps.rcPaint))
			    	{
						//first erase the background and notify parent to draw
						FillRect(hdc, &rc, (HBRUSH)(COLOR_WINDOW + 1));
			    		phost->LbDrawItemNotify(hdc, i, ODA_DRAWENTIRE, phost->IsSelected(i) ? ODS_SELECTED : 0);
			    	}
			    }

				// Now draw onto the area where drawing may not have been done or erased
				int nDiff = nCount - nTopidx;
				if (nDiff < nViewsize || 
					(phost->_fNoIntegralHeight && nDiff == nViewsize))
				{
					rc = rcClient;
					if (nDiff < 0)
						nDiff *= -1;  // lets be positive

					rc.top = nDiff * phost->GetItemHeight();
					if (IntersectRect(&rc, &rc, &ps.rcPaint))
						FillRect(hdc, &rc, (HBRUSH)(COLOR_WINDOW + 1));
				}
		    
#ifndef PEGASUS
				if(hpalOld)
					SelectPalette(hdc, hpalOld, TRUE);
#endif
			}
			RestoreDC(hdc, -1);

			// Check if we need to draw the focus rect by checking if the focus rect intersects
			// the painting rect
			phost->LbGetItemRect(phost->GetCursor(), &rc);

			// NOTE: Bug #5431
			// This bug could be fixed by replacing the hDC to NULL
			// The hdc can be clipped from BeginPaint API.  So just pass in NULL
			// when drawing focus rect
			phost->SetCursor(hdc, phost->GetCursor(), FALSE);			
			EndPaint(hwnd, &ps);
		}
		break;

	/////////////////////////Mouse Messages/////////////////////////////////
	case WM_RBUTTONDOWN:
	case WM_RBUTTONDBLCLK:
	case WM_MBUTTONDBLCLK:
	case WM_MBUTTONDOWN:
		break;

	case WM_LBUTTONDBLCLK:
		phost->_fDblClick = 1;
		/* Fall through case */
	case WM_LBUTTONDOWN:
		if (!phost->_fFocus)
			SetFocus(hwnd);
		phost->OnLButtonDown(wparam, lparam);
		break;
		
	case WM_MOUSEMOVE:
		if (!phost->GetCapture())
			break;
		phost->OnMouseMove(wparam, lparam);
		break;
		
	case WM_LBUTTONUP:	
		if (!phost->GetCapture())
			break;
		phost->OnLButtonUp(wparam, lparam, LBN_SELCHANGE);
		break;

	case WM_MOUSEWHEEL:
		if (wparam & (MK_SHIFT | MK_CONTROL))
			goto defwndproc;

		lres = phost->OnMouseWheel(wparam, lparam);
		break;

	///////////////////////KeyBoard Messages////////////////////////////////
	case WM_KEYDOWN:
		phost->OnKeyDown(LOWORD(wparam), lparam, 0);
		break;

	case WM_CHAR:
		if (W32->OnWin9x() || phost->_fANSIwindow)
		{
			CW32System::WM_CHAR_INFO wmci;
			wmci._fAccumulate = phost->_fAccumulateDBC != 0;
			W32->AnsiFilter( msg, wparam, lparam, (void *) &wmci );
			if (wmci._fLeadByte)
			{
				phost->_fAccumulateDBC = TRUE;
				phost->_chLeadByte = wparam << 8;
				goto Exit;					// Wait for trail byte
			}
			else if (wmci._fTrailByte)
			{
				// UNDONE:
				// Need to see what we should do in WM_IME_CHAR
				wparam = phost->_chLeadByte | wparam;
				phost->_fAccumulateDBC = FALSE;
				phost->_chLeadByte = 0;
				msg = WM_IME_CHAR;
				goto serv;
			}
			else if (wmci._fIMEChar)
			{
				msg = WM_IME_CHAR;
				goto serv;
			}
			else if (wmci._fIMEChar)
			{
				msg = WM_IME_CHAR;
				goto serv;
			}
		}
		
		phost->OnChar(LOWORD(wparam), lparam);
		break;
		
	case WM_TIMER:
		if (phost->OnTimer(wparam, lparam))
			goto serv;			
		break;		

	case LBCB_TRACKING:
		phost->OnCBTracking(wparam, lparam);
		break;

	//UNDONE:
	//	Messages should be ordered from most often called --> least often called
	//		
	case LB_GETITEMRECT:
		Assert(lparam);
		lres = -1;
		if (((wparam < (unsigned)phost->GetCount()) && 
			phost->IsItemViewable((long)wparam)) || wparam == (unsigned int)-1 ||
			wparam == 0 && phost->GetCount() == 0)
			lres = phost->LbGetItemRect(wparam, (RECT*)lparam);
		break;
	
	///////////////////////ListBox Messages/////////////////////////////////
	case LB_GETITEMDATA:
		if ((unsigned)phost->GetCount() <= wparam) 
			lres = LB_ERR;
		else
			lres = phost->GetData(wparam);
		break;
		
	case LB_SETITEMDATA:
		lres = LB_ERR;
		if ((int)wparam >= -1 && (int)wparam < phost->GetCount())
		{
			// if index is -1 this means all the dataItems are set
			// to the value
			lres = 1;
			if (wparam == -1)
				phost->LbSetItemData(0, phost->GetCount() - 1, lparam);
			else
				phost->LbSetItemData(wparam, wparam, lparam);
		}
		break;
	
	case LB_GETSELCOUNT:
		if (lparam != NULL || wparam != 0)
		{
			lres = LB_ERR;
			break;
		}
		wparam = phost->GetCount();
		// FALL through case
		
	case LB_GETSELITEMS:
		// retrieves all the selected items in the list
		lres = LB_ERR;
		if (!phost->IsSingleSelection())
		{
			int j = 0;
			int nMin = min(phost->GetCount(), (int)wparam);
			for (int i = 0; i < nMin; i++)
				if (phost->IsSelected(i))
				{
					if (lparam)
						((int*)lparam)[j] = i;
					j++;
				}
			lres = j;
		}
		break;
		
	case LB_GETSEL:
		// return the select state of the passed in index
		lres = LB_ERR;
		if ((int)wparam >= 0 && (int)wparam < phost->GetCount())
			lres = phost->IsSelected((long)wparam);		
		break;
		
	case LB_GETCURSEL:
		// Get the current selection
		lres = LB_ERR;
		if (!phost->IsSingleSelection())
			lres = phost->GetCursor();
		else		
		{
			if (phost->IsSelected(phost->GetCursor()))
				lres = phost->GetCursor();				
		}
		break;
		
	case LB_GETTEXTLEN:
		// Retieves the text at the requested index
		lres = LB_ERR;
		if (wparam < (unsigned)phost->GetCount())
			lres = phost->GetString(wparam, (PWCHAR)NULL);
		break;

	case LB_GETTEXT:			
		// Retieves the text at the requested index
		lres = LB_ERR;
		if ((int)lparam != NULL && (int)wparam >= 0 && (int)wparam < phost->GetCount())
			lres = phost->GetString(wparam, (PWCHAR)lparam);
		break;
		
	case LB_RESETCONTENT:
		// Reset the contents
		lres = phost->LbDeleteString(0, phost->GetCount() - 1);
		break;
		
	case LB_DELETESTRING:
		// Delete requested item
		lres = phost->LbDeleteString(wparam, wparam);
		break;
		
	case LB_ADDSTRING:
		lres = phost->LbInsertString((phost->_fSort) ? -2 : -1, (LPCTSTR)lparam);
		break;
		
	case LB_INSERTSTRING:
		lres = LB_ERR;
		if (wparam <= (unsigned long)phost->GetCount() || (signed int)wparam == -1 || wparam == 0)
			lres = phost->LbInsertString(wparam, (LPCTSTR)lparam);
		break;		

	case LB_GETCOUNT:
		// retrieve the count
		lres = phost->GetCount();
		break;
		
	case LB_GETTOPINDEX:
		// Just return the top index
		lres = phost->GetTopIndex();
		break;

	case LB_GETCARETINDEX:
		lres = phost->GetCursor();
		break;

	case LB_GETANCHORINDEX:
		lres = phost->GetAnchor();
		break;
		
	case LB_FINDSTRINGEXACT:
		// For NT compatibility
		wparam++;
		
		// Find and select the item matching the string text
		if ((int)wparam >= phost->GetCount() || (int)wparam < 0)
			wparam = 0;

		lres = phost->LbFindString(wparam, (LPCTSTR)lparam, TRUE);
		if (0 <= lres)
			break;
				
		lres = LB_ERR;
		break;
		
	case LB_FINDSTRING:	
		// For NT compatibility
		wparam++;
		
		// Find and select the item matching the string text
		if (wparam >= (unsigned)phost->GetCount())
			wparam = 0;

		lres = phost->LbFindString(wparam, (LPCTSTR)lparam, FALSE);
		if (0 > lres)
			lres = LB_ERR;
		break;
	
	case LB_SELECTSTRING:
		if (phost->IsSingleSelection())
		{			
			// For NT compatibility
			wparam++;
			
			// Find and select the item matching the string text
			if ((int)wparam >= phost->GetCount() || (int)wparam < 0)
				wparam = 0;

			lres = phost->LbFindString(wparam, (LPCTSTR)lparam, FALSE);
			if (0 <= lres)
			{
				// bug fix #5260 - need to move to selected item first
				// Unselect last item and select new one
				Assert(lres >= 0 && lres < phost->GetCount());
				if (phost->LbShowIndex(lres, FALSE) && phost->LbSetSelection(lres, lres, LBSEL_DEFAULT, lres, lres))
				{
#ifndef NOACCESSIBILITY
					phost->_dwWinEvent = EVENT_OBJECT_FOCUS;
					phost->_fNotifyWinEvt = TRUE;
					phost->TxNotify(phost->_dwWinEvent, NULL);

					phost->_dwWinEvent = EVENT_OBJECT_SELECTION;
					phost->_fNotifyWinEvt = TRUE;
					phost->TxNotify(phost->_dwWinEvent, NULL);
#endif	
					break;
				}
			}						
		}
		// If failed then let it fall through to the LB_ERR
		lres = LB_ERR;
		break;
		
	case LB_SETSEL:
		// We only update the GetAnchor() and _nCursor if we are selecting an item
		if (!phost->IsSingleSelection())
		{
			// We need to return zero to mimic system listbox
			if (!phost->GetCount())
				break;

			//bug fix #4265
			int nStart = lparam;
			int nEnd = lparam;
			int nAnCur = lparam;
			if (lparam == (unsigned long)-1)
			{
				nAnCur = phost->GetCursor();
				nStart = 0;
				nEnd = phost->GetCount() - 1;
			}
			if (phost->LbSetSelection(nStart, nEnd, (BOOL)wparam ? 
				LBSEL_SELECT | LBSEL_NEWANCHOR | LBSEL_NEWCURSOR : 0, nAnCur, nAnCur))
			{
#ifndef NOACCESSIBILITY
				if (lparam == (unsigned long)-1)
				{
					phost->_dwWinEvent = EVENT_OBJECT_SELECTIONWITHIN;
				}
				else if (wparam)
				{
					phost->_dwWinEvent = EVENT_OBJECT_FOCUS;
					phost->_fNotifyWinEvt = TRUE;
					phost->TxNotify(phost->_dwWinEvent, NULL);
					phost->_dwWinEvent = EVENT_OBJECT_SELECTION;
				}
				else
				{
					phost->_nAccessibleIdx = lparam + 1;
					phost->_dwWinEvent = EVENT_OBJECT_SELECTIONREMOVE;
				}
				phost->_fNotifyWinEvt = TRUE;
				phost->TxNotify(phost->_dwWinEvent, NULL);
#endif
				break;
			}
		}

		// We only get here if error occurs or list box is a singel sel Listbox
		lres = LB_ERR;
		break;

	case LB_SELITEMRANGEEX:
		// For this message we need to munge the messages a little bit so it
		// conforms with LB_SETITEMRANGE
		if ((int)lparam > (int)wparam)
		{
			nTemp = MAKELONG(wparam, lparam);
			wparam = 1;
			lparam = nTemp;
		}
		else
		{
			nTemp = MAKELONG(lparam, wparam);
			wparam = 0;
			lparam = nTemp;			
		}	
		/* Fall through case */

	case LB_SELITEMRANGE:				
		// We have to make sure the range is valid
		if (LOWORD(lparam) >= phost->GetCount())
		{
			if (HIWORD(lparam) >= phost->GetCount())
				//nothing to do so exit without error
				break;
			lparam = MAKELONG(HIWORD(lparam), phost->GetCount() - 1);
		}
		else if (HIWORD(lparam) > LOWORD(lparam))
		{
			// NT swaps the start and end value if start > end
			lparam = MAKELONG(LOWORD(lparam), HIWORD(lparam) < phost->GetCount() ? 
				HIWORD(lparam) : phost->GetCount()-1);
		}

		// Item range messages do not effect the GetAnchor() nor the _nCursor
		if (!phost->IsSingleSelection() && phost->LbSetSelection(HIWORD(lparam), 
				LOWORD(lparam), LBSEL_RESET | ((wparam) ? LBSEL_SELECT : 0), 0, 0))
		{
#ifndef NOACCESSIBILITY
			phost->_dwWinEvent = EVENT_OBJECT_SELECTIONWITHIN;
			phost->_fNotifyWinEvt = TRUE;
			phost->TxNotify(phost->_dwWinEvent, NULL);
#endif		
			break;
		}

		// We only get here if error occurs or list box is a singel sel Listbox
		lres = LB_ERR;
		break;

	case LB_SETCURSEL:
		// Only single selection list box can call this!!
		if (phost->IsSingleSelection())
		{
			// -1 should return LB_ERR and turn off any selection

			// special flag indicating no items should be selected
			if (wparam == (unsigned)-1)
			{	
				// turn-off any selections
				int nCurrentCursor = phost->GetCursor();
				phost->LbSetSelection(phost->GetCursor(), phost->GetCursor(), LBSEL_RESET, 0, 0);
				phost->SetCursor(NULL, -1, phost->_fFocus);
#ifndef NOACCESSIBILITY
				if (nCurrentCursor != -1)
				{
					phost->_dwWinEvent = EVENT_OBJECT_FOCUS;
					phost->_nAccessibleIdx = nCurrentCursor + 1;
					phost->_fNotifyWinEvt = TRUE;
					phost->TxNotify(phost->_dwWinEvent, NULL);
					phost->_dwWinEvent = EVENT_OBJECT_SELECTIONREMOVE;
					phost->_nAccessibleIdx = nCurrentCursor + 1;
					phost->_fNotifyWinEvt = TRUE;
					phost->TxNotify(phost->_dwWinEvent, NULL);
				}
#endif
			}
			else if (wparam < (unsigned)(phost->GetCount()))
			{
				if ((int)wparam == phost->GetCursor() && phost->IsSelected((int)wparam) && 
				    phost->IsItemViewable((signed)wparam) ||
					phost->LbShowIndex(wparam, FALSE) /* bug fix #5260 - need to move to selected item first */
					&& phost->LbSetSelection(wparam, wparam, LBSEL_DEFAULT, wparam, wparam))
				{
					lres = (unsigned)wparam;
#ifndef NOACCESSIBILITY
					phost->_dwWinEvent = EVENT_OBJECT_FOCUS;
					phost->_fNotifyWinEvt = TRUE;
					phost->TxNotify(phost->_dwWinEvent, NULL);
					phost->_dwWinEvent = EVENT_OBJECT_SELECTION;
					phost->_fNotifyWinEvt = TRUE;
					phost->TxNotify(phost->_dwWinEvent, NULL);
#endif
					break;
				}
			}
		}
		// If failed then let it fall through to the LB_ERR
		lres = LB_ERR;
		break;

	case LB_SETTOPINDEX:
		// Set the top index
		if ((!phost->GetCount() && !wparam) || phost->LbSetTopIndex(wparam) >= 0)
			break;

		// We get here if something went wrong
		lres = LB_ERR;
		break;

	case LB_SETITEMHEIGHT:
		if (!phost->LbSetItemHeight(LOWORD(lparam)))
			lres = LB_ERR;
		break;	

	case LB_GETITEMHEIGHT:
		lres = LB_ERR;
		if ((unsigned)phost->GetCount() > wparam || wparam == 0 || wparam == (unsigned)-1)
			lres = phost->GetItemHeight();
		break;

	case LB_SETCARETINDEX:
        if (((phost->GetCursor() == -1) || (!phost->IsSingleSelection()) &&
                    (phost->GetCount() > (INT)wparam)))
        {
            /*
             * Set's the Cursor to the wParam
             * if lParam, then don't scroll if partially visible
             * else scroll into view if not fully visible
             */
            if (!phost->IsItemViewable(wparam) || lparam)
            {
                phost->LbShowIndex(wparam, FALSE);
                phost->SetCursor(NULL, wparam, TRUE);
            }
            lres = 0;            
        } 
        else        
            return LB_ERR;            
        break;

	case EM_SETTEXTEX:
		lres = LB_ERR;
		if (lparam)
			lres = phost->LbBatchInsert((WCHAR*)lparam);	
		break;

	////////////////////////Windows Messages////////////////////////////////
	case WM_VSCROLL:
		phost->OnVScroll(wparam, lparam);
		break;

	case WM_CAPTURECHANGED:
		lres = phost->OnCaptureChanged(wparam, lparam);
		if (!lres)
			break;
		goto serv;

	case WM_KILLFOCUS:
		lres = 1;
		phost->_fFocus = 0;
		phost->SetCursor(NULL, phost->GetCursor(), TRUE);	// force the removal of focus rect
		phost->InitSearch();
		phost->InitWheelDelta();
		if (phost->_fLstType == CLstBxWinHost::kCombo)
			phost->OnCBTracking(LBCBM_END, 0);	//this will internally release the mouse capture
			phost->TxNotify(LBN_KILLFOCUS, NULL);
		break;
		
	case WM_SETFOCUS:
		lres = 1;
		phost->_fFocus = 1;
		phost->SetCursor(NULL, (phost->GetCursor() < 0) ? -2 : phost->GetCursor(), 
			FALSE);  // force the displaying of the focus rect
		phost->TxNotify(LBN_SETFOCUS, NULL);
		break;

	case WM_SETCURSOR:
		lres = phost->OnSetCursor();
		if (lres)
			break;
		goto serv;

	case WM_CREATE:
		lres = phost->OnCreate((CREATESTRUCT*)lparam);
		break;
			   
    case WM_GETDLGCODE:	
		phost->_fInDialogBox = TRUE;
		lres |= DLGC_WANTARROWS | DLGC_WANTCHARS;
        break;

	////////////////////////System setting messages/////////////////////
	case WM_SETTINGCHANGE:
	case WM_SYSCOLORCHANGE:
		phost->OnSysColorChange();
		//	Need to update the edit controls colors!!!!
		goto serv;							// Notify text services that
											//  system colors have changed
											
	case EM_SETPALETTE:
		// Application is setting a palette for us to use.
		phost->_hpal = (HPALETTE) wparam;

		// Invalidate the window & repaint to reflect the new palette.
		InvalidateRect(hwnd, NULL, FALSE);
		break;

	/////////////////////////Misc. Messages/////////////////////////////////
	case WM_ENABLE:
		if(!wparam ^ phost->_fDisabled)
		{
			// Stated of window changed so invalidate it so it will
			// get redrawn.
			InvalidateRect(phost->_hwnd, NULL, TRUE);
			phost->SetScrollBarsForWmEnable(wparam);
		}
		phost->_fDisabled = !wparam;				// Set disabled flag		
											// Fall thru to WM_SYSCOLORCHANGE?

    case WM_STYLECHANGING:
		// Just pass this one to the default window proc
		goto defwndproc;
		break;

	case WM_STYLECHANGED:
		// FUTURE:
		//	We should support style changes after the control has been created
		//  to be more compatible with the system controls
		//
		// For now, we only interested in GWL_EXSTYLE Transparent mode changed.
		// This is to fix Bug 753 since Window95 is not passing us
		// the WS_EX_TRANSPARENT.
		// 
		lres = 1;
		if(GWL_EXSTYLE == wparam)
		{
			LPSTYLESTRUCT lpss = (LPSTYLESTRUCT) lparam;
			if(phost->IsTransparentMode() != (BOOL)(lpss->styleNew & WS_EX_TRANSPARENT))
			{
				phost->_dwExStyle = lpss->styleNew;
				((CTxtEdit *)phost->_pserv)->OnTxBackStyleChange(TRUE);

				// Return 0 to indicate we have handled this message
				lres = 0;
			}
		}
		break;

	case WM_SIZE:
		// Check if we have to recalculate the height of the listbox
		// Note if window is resized we will receive another WM_SIZE message
		// upon which the RecalcHeight will fail and we will proceed
		// normally
		if (phost->RecalcHeight(LOWORD(lparam), HIWORD(lparam)))
			break;
		phost->_pserv->TxSendMessage(msg, wparam, lparam, &lres);
		lres = phost->OnSize(hwnd, wparam, (int)LOWORD(lparam), (int)HIWORD(lparam));
		break;

	case WM_WINDOWPOSCHANGING:
		lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		if(phost->TxGetEffects() == TXTEFFECT_SUNKEN)
			phost->OnSunkenWindowPosChanging(hwnd, (WINDOWPOS *) lparam);
		break;

	case WM_SHOWWINDOW:
		if ((phost->GetViewSize() == 0 || phost->_fLstType == CLstBxWinHost::kCombo) && wparam == 1)
		{
			// we need to do this because if we are part of a combo box
			// we won't get the size message because listbox may not be visible at time of sizing
			RECT rc;
			GetClientRect(hwnd, &rc);
			phost->_fVisible = 1;
			phost->RecalcHeight(rc.right, rc.bottom);
			
			//Since we may not get the WM_SIZE message for combo boxes we need to
			// do this in WM_SHOWWINDOW: bug fix #4080
			if (phost->_fLstType == CLstBxWinHost::kCombo)
			{
				phost->_pserv->TxSendMessage(WM_SIZE, SIZE_RESTORED, MAKELONG(rc.right, rc.bottom), NULL);
				phost->OnSize(hwnd, SIZE_RESTORED, rc.right, rc.bottom);
			}
		}

		hr = phost->OnTxVisibleChange((BOOL)wparam);
		break;

	case LB_SETTABSTOPS:
		msg = EM_SETTABSTOPS;
		goto serv;

	case WM_ERASEBKGND:
		lres = 1;
		break;

	case EM_SETPARAFORMAT:
		wparam = SPF_SETDEFAULT;
		goto serv;
		
	case EM_SETCHARFORMAT:
		wparam = SCF_ALL;	//wparam for this message should always be SCF_ALL
		goto serv;

	case WM_GETTEXT:
		GETTEXTEX gt;
		if (W32->OnWin9x() || phost->_fANSIwindow)
			W32->AnsiFilter( msg, wparam, lparam, (void *) &gt );
		goto serv;

	case WM_GETTEXTLENGTH:
		GETTEXTLENGTHEX gtl;
		if (W32->OnWin9x() || phost->_fANSIwindow)
			W32->AnsiFilter( msg, wparam, lparam, (void *) &gtl );
		goto serv;

#ifndef NOACCESSIBILITY
	case WM_GETOBJECT:	
		IUnknown* punk;
		phost->QueryInterface(IID_IUnknown, (void**)&punk);
		Assert(punk);
		lres = W32->LResultFromObject(IID_IUnknown, wparam, (LPUNKNOWN)punk);
		AssertSz(!FAILED((HRESULT)lres), "WM_GETOBJECT message FAILED\n");
		punk->Release();
		break;
#endif		

	default:
serv:
		hr = phost->_pserv->TxSendMessage(msg, wparam, lparam, &lres);
		if(hr == S_FALSE)
		{			
defwndproc:
			// Message was not processed by text services so send it
			// to the default window proc.
		lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		}
	}

	// Special border processing. The inset changes based on the size of the
	// defautl character set. So if we got a message that changes the default
	// character set, we need to update the inset.
	if ((msg == WM_SETFONT && wparam) || msg == EM_SETCHARFORMAT)
	{
		// need to recalculate the height of each item
		phost->ResizeInset();

		// need to resize the window to update internal window variables
		RECT rc;
		GetClientRect(phost->_hwnd, &rc);
		phost->RecalcHeight(rc.right, rc.bottom);		
	}
Exit:
	phost->Release();
	return lres;
}
												 

//////////////// CTxtWinHost Creation/Initialization/Destruction ///////////////////////
#ifndef NOACCESSIBILITY
/*
 *	CLstBxWinHost::OnNCCreate (hwnd, pcs)
 *
 *	@mfunc
 *		
 */
HRESULT CLstBxWinHost::QueryInterface(REFIID riid, void **ppv)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::QueryInterface");

  	if(riid == IID_IAccessible)
		*ppv = (IAccessible*)this;
    else if (riid == IID_IDispatch)
		*ppv = (IDispatch*)(IAccessible*)this;
    else if (IsEqualIID(riid, IID_IUnknown))
		*ppv = (IUnknown*)(IAccessible*)this;
    else
        return CTxtWinHost::QueryInterface(riid, ppv);

	AddRef();		
	return NOERROR;
        
}
#endif

/*
 *	CLstBxWinHost::OnNCCreate (hwnd, pcs)
 *
 *	@mfunc
 *		Static global method to handle WM_NCCREATE message (see remain.c)
 */
LRESULT CLstBxWinHost::OnNCCreate(
	HWND hwnd,
	const CREATESTRUCT *pcs)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnNCCreate");

#if defined DEBUG && !defined(PEGASUS) 
	GdiSetBatchLimit(1);
#endif

	CLstBxWinHost *phost = new CLstBxWinHost();
	Assert(phost);
	if(!phost)
		return 0;
	
	if(!phost->Init(hwnd, pcs))					// Stores phost in associated
	{											//  window data
		Assert(FALSE);
		phost->Shutdown();
		delete phost;
		return FALSE;
	}
	return TRUE;
}

/*
 *	CLstBxWinHost::OnNCDestroy (phost)
 *
 *	@mfunc
 *		Static global method to handle WM_CREATE message
 *
 *	@devnote
 *		phost ptr is stored in window data (GetWindowLong())
 */
void CLstBxWinHost::OnNCDestroy(
	CLstBxWinHost *phost)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnNCDestroy");

	// We need to send WM_DELETEITEM messages for owner draw list boxes
	if (phost->_fOwnerDraw && phost->_nCount)
	{
		phost->LbDeleteItemNotify(0, phost->_nCount - 1);		
	}
	if (phost->_pwszSearch)
		delete phost->_pwszSearch;

	// set the combobox's listbox hwnd pointer to null so combo box won't try 
	// to delete the window twice
	if (phost->_pcbHost)
	{
		phost->_pcbHost->_hwndList = NULL;
		phost->_pcbHost->Release();
	}
	
	phost->Shutdown();
	phost->Release();
}

/*
 *	CLstBxWinHost::CLstBxWinHost()
 *
 *	@mfunc
 *		constructor
 */
CLstBxWinHost::CLstBxWinHost() : CTxtWinHost(), _nCount(0), _fSingleSel(0), _nidxSearch(0), 
	_pwszSearch(NULL), _pcbHost(NULL)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::CTxtWinHost");
#ifndef NOACCESSIBILITY
	_dwWinEvent = 0;				// Win Event code (ACCESSIBILITY use)
	_nAccessibleIdx = -1;			// Index (ACCESSIBILITY use)
#endif
}

/*
 *	CLstBxWinHost::~CLstBxWinHost()
 *
 *	@mfunc
 *		destructor
 */
CLstBxWinHost::~CLstBxWinHost()
{
}

/*
 *	CLstBxWinHost::Init (hwnd, pcs)
 *
 *	@mfunc
 *		Initialize this CLstBxWinHost
 */
BOOL CLstBxWinHost::Init(
	HWND hwnd,					//@parm Window handle for this control
	const CREATESTRUCT *pcs)	//@parm Corresponding CREATESTRUCT
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::Init");

	if(!pcs->lpszClass)
		return FALSE;
		
	// Set pointer back to CLstBxWinHost from the window
	if(hwnd)
		SetWindowLongPtr(hwnd, ibPed, (INT_PTR)this);
		
	_hwnd = hwnd;
	_fHidden = TRUE;
	
	if(pcs)
	{
		_hwndParent = pcs->hwndParent;
		_dwExStyle	= pcs->dwExStyle;
		_dwStyle	= pcs->style;

		CHECKSTYLE(_dwStyle);
		
		//	Internally WinNT defines a LBS_COMBOBOX to determine
		//	if the list box is part of a combo box.  So we will use
		//	the same flag and value!!
		if (_dwStyle & LBS_COMBOBOX)
		{
			AssertSz(pcs->hMenu == (HMENU)CB_LISTBOXID && pcs->lpCreateParams,
				"invalid combo box parameters");
			if (pcs->hMenu != (HMENU)CB_LISTBOXID || !pcs->lpCreateParams)
				return -1;
				
			_pcbHost = (CCmbBxWinHost*) pcs->lpCreateParams;
			_pcbHost->AddRef();
			_fLstType = kCombo;
			_fSingleSel = 1;
		}
		else
		{
			//	NOTE:
			//	  The order in which we check the style flags immulate
			//	WinNT's order.  So please verify with NT order before
			//	reaaranging order.

			//	determine the type of list box
			//if (_dwStyle & LBS_NOSEL)			//Not implemented but may be in the future
			//	_fLstType = kNoSel;
			//else
			_fSingleSel = 0;
			if (_dwStyle & LBS_EXTENDEDSEL)
				_fLstType = kExtended;
			else if (_dwStyle & LBS_MULTIPLESEL)
				_fLstType = kMultiple;
			else
			{
				_fLstType = kSingle;
				_fSingleSel = 1;
			}
		}

		_fNotify = ((_dwStyle & LBS_NOTIFY) != 0);

		if (!(_dwStyle & LBS_HASSTRINGS))
		{
			_dwStyle |= LBS_HASSTRINGS;
			SetWindowLong(_hwnd, GWL_STYLE, _dwStyle);
		}


		_fDisableScroll = 0;
		if (_dwStyle & LBS_DISABLENOSCROLL)
		{
			_fDisableScroll = 1;

			// WARNING!!!
			// ES_DISABLENOSCROLL is equivalent to LBS_NODATA
			// Since we don'w support LBS_NODATA this should be 
			// fine.  But in the event we do want to support this 
			// in the future we will have to override the
			// TxGetScrollBars member function and return the 
			// proper window style

			// set the equivalent ES style
			_dwStyle |= ES_DISABLENOSCROLL;
		}			

		_fNoIntegralHeight = ((_dwStyle & LBS_NOINTEGRALHEIGHT) != 0);
		_fOwnerDraw = ((_dwStyle & LBS_OWNERDRAWFIXED) != 0);
		_fSort = ((_dwStyle & LBS_SORT) != 0);
				
		//	We should always have verticle scroll & never horizontal scroll
		//_dwStyle |= ES_AUTOVSCROLL;
		_dwStyle &= ~(WS_HSCROLL);
				
		_fBorder = !!(_dwStyle & WS_BORDER);
		if(_dwExStyle & WS_EX_CLIENTEDGE)
			_fBorder = TRUE;

		// handle default disabled
		if(_dwStyle & WS_DISABLED)
			_fDisabled = TRUE;
	}

	// Create Text Services component
	if(FAILED(CreateTextServices()))
		return FALSE;

	_yInset = 0;
	_xInset = 0; //_xWidthSys / 2;

	// Shut-off the undo stack since listbox don't have undo's
	((CTxtEdit*)_pserv)->HandleSetUndoLimit(0);

	// Set alignment
	PARAFORMAT PF2;	
	PF2.dwMask = 0;

	if(_dwExStyle & WS_EX_RIGHT)
	{
		PF2.dwMask |= PFM_ALIGNMENT;
		PF2.wAlignment = PFA_RIGHT;	// right or center-aligned
	}
	
	if(_dwExStyle & WS_EX_RTLREADING)
	{
		PF2.dwMask |= PFM_RTLPARA;
		PF2.wEffects = PFE_RTLPARA;		// RTL reading order
	}

	if (PF2.dwMask)
	{
		PF2.cbSize = sizeof(PARAFORMAT2);
		//  tell text services
		_pserv->TxSendMessage(EM_SETPARAFORMAT, SPF_SETDEFAULT, (LPARAM)&PF2, NULL);
	}

	// Tell textservices to select the entire background
	_pserv->TxSendMessage(EM_SETEDITSTYLE, SES_EXTENDBACKCOLOR, SES_EXTENDBACKCOLOR, NULL);

	// disable ime for listbox
	_pserv->TxSendMessage(EM_SETEDITSTYLE, 0, SES_NOIME, NULL);

	// Tell textservices to turn-on auto font sizing
	_pserv->TxSendMessage(EM_SETLANGOPTIONS, 0, IMF_AUTOFONT | IMF_AUTOFONTSIZEADJUST | IMF_UIFONTS, NULL);

	// NOTE: 
	// It is important we call this after
	// ITextServices is created because this function relies on certain
	// variable initialization to be performed on the creation by ITextServices
	// At this point the border flag is set and so is the pixels per inch
	// so we can initalize the inset.  
	_rcViewInset.left = 0;
	_rcViewInset.bottom = 0;
	_rcViewInset.right = 0;
	_rcViewInset.top = 0;
	
	return TRUE;
}

/*
 *	CLstBxWinHost::OnCreate (pcs)
 *
 *	@mfunc
 *		Handle WM_CREATE message
 *
 *	@rdesc
 *		LRESULT = -1 if failed to in-place activate; else 0
 */
LRESULT CLstBxWinHost::OnCreate(
	const CREATESTRUCT *pcs)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnCreate");

	RECT rcClient;

	// sometimes, these values are -1 (from windows itself); just treat them
	// as zero in that case
	LONG cy = (pcs->cy < 0) ? 0 : pcs->cy;
	LONG cx = (pcs->cx < 0) ? 0 : pcs->cx;

	rcClient.top = pcs->y;
	rcClient.bottom = rcClient.top + cy;
	rcClient.left = pcs->x;
	rcClient.right = rcClient.left + cx;

	DWORD dwStyle = GetWindowLong(_hwnd, GWL_STYLE);
	
	// init variables
	UpdateSysColors();
	_idCtrl = (UINT)(DWORD_PTR)pcs->hMenu;
	_fKeyMaskSet = 0;
	_fMouseMaskSet = 0;
	_fScrollMaskSet = 0;
	_nAnchor = _nCursor = -1;
	_nOldCursor = -1;
	_fMouseDown = 0;
	_nTopIdx = 0;
	_fSearching = 0;
	_nyFont = _nyItem = 1;
	_fNoResize = 1;
	_stvidx = -1;	
	InitWheelDelta();

	// Hide all scrollbars to start unless the disable scroll flag
	// is set
	if(_hwnd && !_fDisableScroll)
	{
		SetScrollRange(_hwnd, SB_VERT, 0, 0, TRUE);
		SetScrollRange(_hwnd, SB_HORZ, 0, 0, TRUE);

		dwStyle &= ~(WS_VSCROLL | WS_HSCROLL);
		SetWindowLong(_hwnd, GWL_STYLE, dwStyle);
	}
	
	// Notify Text Services that we are in place active
	if(FAILED(_pserv->OnTxInPlaceActivate(&rcClient)))
		return -1;	

	// Initially the font height is the item height	
	ResizeInset();
	Assert(_yInset == 0); // _yInset should be zero since listbox's doesn't have yinsets

	//We never want to display the selection or caret so tell textservice this
	_pserv->TxSendMessage(EM_HIDESELECTION, TRUE, FALSE, NULL);

	//Set the indents to 2 pixels like system listboxes	
	SetListIndent(2);
		
	_fNoResize = 0;
	_usIMEMode = ES_NOIME;
	return 0;
}

/*
 *	CLstBxWinHost::SetListIndent(int)
 *
 *	@mfunc
 *		Sets the left indent of a paragraph to the equivalent point value of nLeft, nLeft is
 *	given in device-coordinate pixels.
 *
 *	#rdesc
 *		BOOL = Successful ? TRUE : FALSE
 */
BOOL CLstBxWinHost::SetListIndent(int nLeft)
{	
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::SetListIndent");

	LRESULT lres;
	PARAFORMAT2 pf2;

	// tranlate the nLeft pixel value to point value
	long npt = MulDiv(nLeft, 1440, W32->GetXPerInchScreenDC());

	//format message struct
	pf2.cbSize = sizeof(PARAFORMAT2);
	pf2.dwMask = PFM_STARTINDENT;
	pf2.dxStartIndent = npt;

	// indent first line
	_pserv->TxSendMessage(EM_SETPARAFORMAT, SPF_SETDEFAULT, (LPARAM)&pf2, &lres);

	return lres;
}

///////////////////////////////  Helper Functions  ////////////////////////////////// 
/*
 *	CLstBxWinHost::FindString(long, LPCTSTR, BOOL)
 *
 *	@mfunc
 *		This function checks a given index matches the search string
 *
 *	#rdesc
 *		BOOL = Match ? TRUE : FALSE
 */
BOOL CLstBxWinHost::FindString(long idx, LPCTSTR szSearch, BOOL bExact)
{	
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::FindString");

	Assert(_nCount);	

	// allocate string buffer into stack
	WCHAR sz[1024];
	WCHAR *psz = sz;
	
	if ( (wcslen(szSearch) + 3 /* 2 paragraphs and a NULL*/) > 1024)
		psz = new WCHAR[wcslen(szSearch) + 3 /* 2 paragraphs and a NULL*/];
	Assert(psz);

	if (psz == NULL)
	{
		TxNotify((unsigned long)LBN_ERRSPACE, NULL);
		return FALSE;
	}

	// format the string the way we need it
	wcscpy(psz, szSearch);
	if (bExact)
		wcscat(psz, szCR);		
	BOOL bMatch = FALSE;	
	ITextRange *pRange = NULL;
	BSTR bstrQuery = SysAllocString(psz);
	if (!bstrQuery)
		goto CleanExit;

	if (psz != sz)
		delete [] psz;
	
	// Set starting position for the search
	long cp, cp2;
	if (!GetRange(idx, idx, &pRange))
	{
		SysFreeString(bstrQuery);
		return FALSE;
	}
	
	CHECKNOERROR(pRange->GetStart(&cp));
	CHECKNOERROR(pRange->FindTextStart(bstrQuery, 0, FR_MATCHALEFHAMZA | FR_MATCHKASHIDA | FR_MATCHDIAC, NULL));
	CHECKNOERROR(pRange->GetStart(&cp2));
	bMatch = (cp == cp2);

CleanExit:
	if (bstrQuery)
		SysFreeString(bstrQuery);
	if (pRange)
		pRange->Release();
	return bMatch;	
}

/*
 *	CLstBxWinHost::MouseMoveHelper(int)
 *
 *	@mfunc
 *		Helper function for the OnMouseMove function.  Performs
 *		the correct type of selection given an index to select
 *
 *	#rdesc
 *		void
 */
void CLstBxWinHost::MouseMoveHelper(int idx, BOOL bSelect)
{	
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::MouseMoveHelper");

	int ff = LBSEL_RESET | LBSEL_NEWCURSOR;
	if (bSelect)
		ff |= LBSEL_SELECT;
		
	switch (_fLstType)
	{
	case kSingle:
	case kCombo:
	case kExtended:										// perform the extended selection		
		if (LbSetSelection(_fLstType == kExtended ? _nAnchor : idx, idx, ff, idx, 0))
		{
#ifndef NOACCESSIBILITY
			_dwWinEvent = EVENT_OBJECT_FOCUS;
			_fNotifyWinEvt = TRUE;
			TxNotify(_dwWinEvent, NULL);

			if (_fLstType == kCombo)
			{
				_dwWinEvent = bSelect ? EVENT_OBJECT_SELECTION : EVENT_OBJECT_SELECTIONREMOVE;
				_fNotifyWinEvt = TRUE;
				TxNotify(_dwWinEvent, NULL);
			}
#endif
		}

		break;			

	case kMultiple:
		// Just change the cursor position
		SetCursor(NULL, idx, TRUE);
#ifndef NOACCESSIBILITY
			_dwWinEvent = EVENT_OBJECT_FOCUS;
			_fNotifyWinEvt = TRUE;
			TxNotify(_dwWinEvent, NULL);
#endif
		break;	
	}
}
	
/*
 *	CLstBxWinHost::ResizeInset
 *
 *	@mfunc	Recalculates rectangle for a font change.
 *
 *	@rdesc	None.
 */
void CLstBxWinHost::ResizeInset()
{
	// Create a DC
	HDC hdc = GetDC(_hwnd);
	// Get the inset information
	LONG xAveCharWidth = 0;
	LONG yCharHeight = GetECDefaultHeightAndWidth(_pserv, hdc, 1, 1,
		W32->GetYPerInchScreenDC(), &xAveCharWidth, NULL, NULL);

	ReleaseDC(_hwnd, hdc);

	// update our internal font and item height information with the new font
	if (_nyItem == _nyFont)
	{
		// We need to set the new font height before calling set item height
		// so set item height will set exact height rather than space after
		// for the default paragraph
		_nyFont = yCharHeight;
		SetItemsHeight(yCharHeight, TRUE);
	}
	else		
		_nyFont = yCharHeight;
}


/*
 *	CLstBxWinHost::RecalcHeight(int, int)
 *
 *	@mfunc
 *		Resized the height so no partial text will be displayed
 *
 *	#rdesc
 *		BOOL = window has been resized ? TRUE : FALSE
 */
BOOL CLstBxWinHost::RecalcHeight(int nWidth, int nHeight)
{	
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::RecalcHeight");

	// NOTE: We should also exit if nWidth == 0 but PPT does some
	// sizing tests which we cause it to fail because before we
	// just exited when nWidth was 0. (bug fix #4196)
	// Check if any resizing should be done in the first place
	if (_fNoResize || !nHeight || IsIconic(_hwnd))
		return FALSE;
  	
	// get # of viewable items
	Assert(_yInset == 0);
	_nViewSize = max(1, (nHeight / max(_nyItem, 1)));
	
   	// Calculate the viewport
   	_rcViewport.left = 0;//(_fBorder) ? _xInset : 0;
   	_rcViewport.bottom = nHeight;
	_rcViewport.right = nWidth;
   	_rcViewport.top	= 0;
   	
	// bug fix don't do anything if the height is smaller then our font height
	if (nHeight <= _nyItem)
		return FALSE;

	if (_nyItem && (nHeight % _nyItem) && !_fNoIntegralHeight)
	{   	
		// we need to get the window rect before we can call SetWindowPos because
		// we have to include the scrollbar if the scrollbar is visible
		RECT rc;
		::GetWindowRect(_hwnd, &rc);

		// instead of worrying about the dimensions of the client edge and stuff we
		// figure-out the difference between the window size and the client size and add
		// that to the end of calculating the new height
		int nDiff = max(rc.bottom - rc.top - nHeight, 0);

		nHeight = (_nViewSize * _nyItem) + nDiff;
	
		// Resize the window
		SetWindowPos(_hwnd, HWND_TOP, 0, 0, rc.right - rc.left, nHeight,
			SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOSENDCHANGING);
		return TRUE;
	}
	else
	{
	    // bug fix #6011
	    // we need to force the display to update the width since it doesn't do it on
	    // WM_SIZE
	    _sWidth = nWidth;
	    _pserv->OnTxPropertyBitsChange(TXTBIT_EXTENTCHANGE, TXTBIT_EXTENTCHANGE);

        // We may need to adjust the top index if suddenly the viewsize becomes larger
        // and causes empty space to be displayed at the bottom
        int idx = GetTopIndex();
	    if ((GetCount() - max(0, idx)) < _nViewSize)
	        idx = GetCount() - _nViewSize;
		
		//bug fix #4374
		// We need to make sure our internal state is in sync so update the top index
		// based on the new _nViewSize		
		SetTopViewableItem(max(0, idx));
	}
	return FALSE;	
}

/*
 *	CLstBxWinHost::SortInsertList(WCHAR* pszDst, WCHAR* pszSrc)
 *
 *	@mfunc
 *		inserts a list of strings rather than one at a time with addstring
 *
 *	#rdesc
 *		int = amount of strings inserted;
 */
 int CLstBxWinHost::SortInsertList(WCHAR* pszDst, WCHAR* pszSrc)
 {
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::SortInsertList");
	 
 	Assert(pszSrc != NULL);
 	Assert(pszDst != NULL); 	
 	const int ARRAY_DEFAULT = 256;
 	
 	//calculate the amount of strings to be inserted
 	CHARSORTINFO rg[ARRAY_DEFAULT];
 	int nMax = ARRAY_DEFAULT;
 	int nLen = wcslen(pszSrc);
 	CHARSORTINFO* prg = rg;
 	memset(rg, 0, sizeof(rg));
 	
 	//insert first item in list to head or array
 	prg[0].str = pszSrc;
 	int i = 1;

 	// go through store strings into array and replace <CR> with NULL
 	WCHAR* psz = nLen + pszSrc - 1;	//start at end of list 	

	int nSz = 0;
	while (psz >= pszSrc)
	{		
	 	if (*psz == *szCR)
	 	{
	 		// Check if we need to allocate memory since we hit the maximum amount
	 		// allowed in array
	 		if (i == nMax)
	 		{
	 			int nSize = nMax + ARRAY_DEFAULT;
	 			CHARSORTINFO* prgTemp = new CHARSORTINFO[nSize];

	 			// Check if memory allocation failed
	 			Assert(prgTemp);
	 			if (!prgTemp)
	 			{
	 				if (prg != rg)
	 					delete [] prg;
	 					
	 				TxNotify((unsigned long)LBN_ERRSPACE, NULL);
	 				return LB_ERR;
	 			}

				// copy memory from 1 array to the next
				memcpy(prgTemp, prg, sizeof(CHARSORTINFO) * nMax);

	 			// delete any previously allocated memory
	 			if (prg != rg)
	 				delete [] prg;

				// set pointers and max to new values
	 			prg = prgTemp;
	 			nMax = nSize;
	 		}
	 		
	 		// record position of string into array
		 	prg[i].str = psz + 1;
		 	prg[i].sz = nSz;
		 	i++;
		 	nSz = 0;
		}
		else
			nSz++;
			
		psz--;		
	}
	prg[0].sz = nSz;	// update the size of first index since we didn't do it before
	
	i--; // set i to last valid index

 	//now sort the array of items
 	QSort(prg, 0, i);

	//create string list with the newly sorted list
	WCHAR* pszOut = pszDst;
	for (int j = 0; j <= i; j++)
	{
		memcpy(pszOut, (prg + j)->str, (prg + j)->sz * sizeof(WCHAR));
		pszOut = pszOut + (prg + j)->sz;
		*pszOut++ = L'\r';
 	}
	*(--pszOut) = L'\0';

	// delete any previously allocated memory
	if (prg != rg)
	 	delete [] prg;

	return ++i;
 } 


/*
 *	CLstBxWinHost::QSort(CHARSORTINFO rg[], int nStart, int nEnd)
 *
 *	@mfunc
 *		recursively quick sorts a given list of strings
 *
 *	#rdesc
 *		int = SHOULD ALWAYS RETURN TRUE;
 */
int CLstBxWinHost::QSort(CHARSORTINFO rg[], int nStart, int nEnd)
{	
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::QSort");
	
	// it's important these values are what they are since we use < and >
	Assert(CSTR_LESS_THAN == 1);
	Assert(CSTR_EQUAL == 2);
	Assert(CSTR_GREATER_THAN == 3);

	if (nStart >= nEnd)
		return TRUE;

	// for statisical efficiency lets use the item in the middle of the array for 
	// the sentinal	
	int mid = (nStart + nEnd) / 2;
	CHARSORTINFO tmp = rg[mid];
	rg[mid] = rg[nEnd];
	rg[nEnd] = tmp;


	int x = nStart;
	int y = nEnd - 1;

	WCHAR* psz = rg[nEnd].str;
	int nSz = rg[nEnd].sz;	
	for(;;)
	{	
		while ((x < nEnd) && CompareStringWrapper(LOCALE_USER_DEFAULT, NORM_IGNORECASE, rg[x].str, rg[x].sz, 
			   psz, nSz) == CSTR_LESS_THAN)
			   x++;

		while ((y > x) && CompareStringWrapper(LOCALE_USER_DEFAULT, NORM_IGNORECASE, rg[y].str, rg[y].sz, 
			   psz, nSz) == CSTR_GREATER_THAN)
			   y--;

		// swap elements
		if (x >= y)
			break;

		//if we got here then we need to swap the indexes
		tmp = rg[x];
		rg[x] = rg[y];
		rg[y] = tmp;

		// move to next index
		x++;
		y--;
	}
	tmp = rg[x];
	rg[x] = rg[nEnd];
	rg[nEnd] = tmp;

	QSort(rg, nStart, x - 1);
	QSort(rg, x + 1, nEnd);

	return TRUE;
}

/*
 *	CLstBxWinHost::CompareIndex(LPCTSTR, int)
 *
 *	@mfunc
 *		Recursive function which returns the insertion index of a sorted list
 *
 *	#rdesc
 *		int = position to insert string
 */
int CLstBxWinHost::CompareIndex(LPCTSTR szInsert, int nIndex)
{	
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::CompareIndex");
	Assert(0 <= nIndex && nIndex < _nCount);
	
	// Get the string at a given index
	// compare the string verses the index
	ITextRange* pRange;
	if (!GetRange(nIndex, nIndex, &pRange))
		return -1;

	// Exclude the paragraph character at the end
	long lcid;
	if (NOERROR != pRange->MoveEnd(tomCharacter, -1, NULL))
	{
		pRange->Release();
		return -1;
	}

	// we need to get the locale for the comparison
	// we will just use the locale of the string we want to compare with
	ITextFont* pFont;
	if (NOERROR != pRange->GetFont(&pFont))
	{
		pRange->Release();
		return -1;
	}
	
	// UNDONE:
	//	move the lcid stuff to be part of the initialization
	BSTR bstr;
	int nRet;
	CHECKNOERROR(pFont->GetLanguageID(&lcid));
	CHECKNOERROR(pRange->GetText(&bstr));
	
	if (!bstr)
		nRet = CSTR_GREATER_THAN;
	else if (!szInsert || !*szInsert)
	    nRet = CSTR_LESS_THAN;
	else
	{
		nRet = CompareString(lcid, NORM_IGNORECASE, szInsert, wcslen(szInsert), 
								bstr, wcslen(bstr));
 		SysFreeString(bstr);
	}
 	pFont->Release();
 	pRange->Release();
 	return nRet;

CleanExit:
 	Assert(FALSE);
 	pFont->Release();
 	pRange->Release();
 	return -1;
}

/*
 *	CLstBxWinHost::GetSortedPosition(LPCTSTR, int, int)
 *
 *	@mfunc
 *		Recursive function which returns the insertion index of a sorted list
 *
 *	#rdesc
 *		int = position to insert string
 */
int CLstBxWinHost::GetSortedPosition(LPCTSTR szInsert, int nStart, int nEnd)
{	
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::GetSortedPosition");

	Assert(nStart <= nEnd);
	
	// Start at the middle of the list
	int nBisect = (nStart + nEnd) / 2;
	int fResult = CompareIndex(szInsert, nBisect);
	if (fResult == CSTR_LESS_THAN)
	{
		if (nStart == nBisect)
			return nBisect;
		else
			return GetSortedPosition(szInsert, nStart, nBisect - 1); // [nStart, nBisect)
	}
	else if (fResult == CSTR_GREATER_THAN)
	{
		if (nEnd == nBisect)
			return nBisect + 1;
		else
			return GetSortedPosition(szInsert, nBisect + 1, nEnd);   // (nBisect, nStart]
	}
	else /*fResult == 0 (found match)*/
		return nBisect;
}

/*
 *	CLstBxWinHost::SetScrollInfo
 *
 *	@mfunc	Set scrolling information for the scroll bar.
 */
void CLstBxWinHost::SetScrollInfo(
	INT fnBar,			//@parm	Specifies scroll bar to be updated
	BOOL fRedraw)		//@parm whether redraw is necessary
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::SetScrollInfo");

	Assert(_pserv);

	// Call back to the control to get the parameters	
	if(fnBar == SB_VERT)
	{
		// Bug Fix #4913
		// if the scrollbar is disabled and count is less than the view size
		// then there is nothing to do so just exit out		
		if (GetCount() <= _nViewSize)
		{
			if (_fDisableScroll)
			{
				// Since listboxes changes height according to its content textservice
				// might of turned-on the scrollbar during an insert string.  Make sure
				// the scrollbar is disabled
				TxEnableScrollBar(SB_VERT, ESB_DISABLE_BOTH);
			}
			else
				TxShowScrollBar(SB_VERT, FALSE);
			return;
		}
		else
			TxEnableScrollBar(SB_VERT, ESB_ENABLE_BOTH);

		// Set up the basic structure for the call
		SCROLLINFO si;
		si.cbSize = sizeof(SCROLLINFO);
		si.fMask = SIF_ALL;
		RECT rc;
		TxGetClientRect(&rc);
		
		// For owner draw cases we have to set the scroll positioning
		// ourselves		
		if (_fOwnerDraw)
		{
			Assert(GetCount() >= 0);

			// We don't do anything here if 
			// 1) item height is smaller than font height 
			// 2) count is less than _nViewSize
			if ((_nyItem < _nyFont) && GetCount() <= _nViewSize)
			{
				if (!_fDisableScroll)
					TxShowScrollBar(SB_VERT, FALSE);				
				return;
			}
		
			si.nMin = 0;
			si.nMax = _nyItem * GetCount();
			si.nPos = _nyItem * max(GetTopIndex(), 0);
			
		}
		else
			_pserv->TxGetVScroll((LONG *) &si.nMin, (LONG *) &si.nMax, 
				(LONG *) &si.nPos, (LONG *) &si.nPage, NULL);
		
		// need to take care of cases where items are partially exposed
		if (si.nMax)
		{			
			si.nPage = rc.bottom;	//our scrollbar range is based on pixels so just use the 
									//height of the window for the page size
			si.nMax += (rc.bottom % _nyItem);

			// We need to decrement the max by one so maximum scroll pos will match
			// what the listbox should be the maximum value
			si.nMax--;
		}
			
		// Do the call
		::SetScrollInfo(_hwnd, fnBar, &si, fRedraw);
	}	
}

/* 
 *	CLstBxWinHost::TxGetScrollBars (pdwScrollBar)
 *
 *	@mfunc
 *		Get Text Host's scroll bars supported.
 *
 *	@rdesc
 *		HRESULT = S_OK
 *
 *	@comm
 *		<p pdwScrollBar> is filled with a boolean combination of the 
 *		window styles related to scroll bars.  Specifically, these are:
 *
 *			WS_VSCROLL	<nl>
 *			WS_HSCROLL	<nl>
 *			ES_AUTOVSCROLL	<nl>
 *			ES_AUTOHSCROLL	<nl>
 *			ES_DISABLENOSCROLL	<nl>
 */
HRESULT CLstBxWinHost::TxGetScrollBars(
	DWORD *pdwScrollBar) 	//@parm Where to put scrollbar information
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CLstBxWinHost::TxGetScrollBars");

	*pdwScrollBar =  _dwStyle & (WS_VSCROLL | ((_fDisableScroll) ?  ES_DISABLENOSCROLL : 0));
	return NOERROR;
}

/*
 *	CLstBxWinHost::TxGetEffects()
 *
 *	@mfunc
 *		Indicates if a sunken window effect should be drawn
 *
 *	#rdesc
 *		HRESULT = (_fBorder) ? TXTEFFECT_SUNKEN : TXTEFFECT_NONE
 */
TXTEFFECT CLstBxWinHost::TxGetEffects() const
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::TxGetEffects");

	return (_fBorder) ? TXTEFFECT_SUNKEN : TXTEFFECT_NONE;
}

/* 
 *	CLstBxWinHost::TxNotify (iNotify,	pv)
 *
 *	@mfunc
 *		Notify Text Host of various events.  Note that there are
 *		two basic categories of events, "direct" events and 
 *		"delayed" events.  All listbox notifications are post-action
 *
 *
 *	@rdesc	
 *		S_OK - call succeeded <nl>
 *		S_FALSE	-- success, but do some different action
 *		depending on the event type (see below).
 *
 *	@comm
 *		The notification events are the same as the notification
 *		messages sent to the parent window of a listbox window.
 *
 *		<LBN_DBLCLK> user double-clicks an item in teh list box
 *
 *		<LBN_ERRSPCAE> The list box cannot allocate enough memory to 
 *		fulfill a request
 *
 *		<LBN_KILLFOCUS> The list box loses the keyboard focus
 *
 *		<LBN_CANCEL> The user cancels te selection of an item in the list
 *		box
 *
 *		<LBN_SELCHANGE> The selection in a list box is about to change
 *
 *		<LBN_SETFOCUS> The list box receives the keyboard focus
 *
 */
HRESULT CLstBxWinHost::TxNotify(
	DWORD iNotify,		//@parm	Event to notify host of.  One of the
						//		EN_XXX values from Win32, e.g., EN_CHANGE
	void *pv)			//@parm In-only parameter with extra data.  Type
						//		dependent on <p iNotify>
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CLstBxWinHost::TxNotify");

	HRESULT	hr = NOERROR;
	
	// Filter-out all the messages except Listbox notification messages

	// If _fNotifyWinEvt is true, we only need to do NotifyWinEvent
	if (_fNotify && !_fNotifyWinEvt)		// Notify parent?
	{
		Assert(_hwndParent);
		switch (iNotify)
		{		
			case LBN_DBLCLK:
			case LBN_ERRSPACE:
			case LBN_KILLFOCUS:
			case LBN_SELCANCEL:
			case LBN_SELCHANGE:
			case LBN_SETFOCUS:
				hr = SendMessage(_hwndParent, WM_COMMAND, 
							GET_WM_COMMAND_MPS(_idCtrl, _hwnd, iNotify));						
		}
	}

	_fNotifyWinEvt = 0;

#ifndef NOACCESSIBILITY
	DWORD	dwLocalWinEvent = _dwWinEvent;
	int		nLocalIdx = _nAccessibleIdx;
	_dwWinEvent = 0;
	if (nLocalIdx == -1)
		nLocalIdx = _nCursor+1;
	_nAccessibleIdx = -1;
	if (iNotify == LBN_SELCHANGE || dwLocalWinEvent)
		W32->NotifyWinEvent(dwLocalWinEvent ? dwLocalWinEvent : EVENT_OBJECT_SELECTION, _hwnd, _idCtrl, nLocalIdx);

#endif
	return hr;
}


/*
 *	CLstBxWinHost::TxGetPropertyBits(DWORD, DWORD *)
 *
 *	@mfunc
 *		returns the proper style.  This is a way to fool the edit 
 *		control to behave the way we want it to
 *
 *	#rdesc
 *		HRESULT = always NOERROR
 */
 HRESULT CLstBxWinHost::TxGetPropertyBits(DWORD dwMask, DWORD *pdwBits)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::TxGetPropertyBits");

	// Note: the rich edit host will never set TXTBIT_SHOWACCELERATOR or
	// TXTBIT_SAVESELECTION. Those are currently only used by forms^3 host.

	// This host is always rich text.
	*pdwBits = (TXTBIT_RICHTEXT | TXTBIT_MULTILINE | TXTBIT_HIDESELECTION | 
				TXTBIT_DISABLEDRAG | TXTBIT_USECURRENTBKG) & dwMask;
	
	return NOERROR;
}

/* 
 *	CLstBxWinHost::TxShowScrollBar (fnBar, fShow)
 *
 *	@mfunc
 *		Shows or Hides scroll bar in Text Host window 
 *
 *	@rdesc
 *		TRUE on success, FALSE otherwise
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
BOOL CLstBxWinHost::TxShowScrollBar(
	INT  fnBar, 		//@parm	Specifies scroll bar(s) to be shown or hidden
	BOOL fShow)			//@parm	Specifies whether scroll bar is shown or hidden
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CLstBxWinHost::TxShowScrollBar");

	// There maybe cases where the item height is smaller than the font size
	// which means the notifications from ITextServices is wrong because
	// it uses the wrong line height.  We will use the following case
	// 1a) if _nyItem >= _nyFont OR
	// 1b) if window style is LBS_DISABLESCROLL OR
	// 1c) We are showing the scrollbar w/ current count greater than viewsize OR
	// 1d) We are hiding the scrollbar w/ current count <= viewsize
	Assert(fShow == TRUE || fShow == FALSE);
	if (_nyItem >= _nyFont || _fDisableScroll || fShow == (GetCount() > _nViewSize))
		return CTxtWinHost::TxShowScrollBar(fnBar, fShow);
	return FALSE;
}

/* 
 *	CLstBxWinHost::TxEnableScrollBar (fuSBFlags, fuArrowflags)
 *
 *	@mfunc
 *		Enables or disables one or both scroll bar arrows 
 *		in Text Host window.
 *
 *	@rdesc
 *		If the arrows are enabled or disabled as specified, the return 
 *		value is TRUE. If the arrows are already in the requested state or an 
 *		error occurs, the return value is FALSE. 
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.	
 */
BOOL CLstBxWinHost::TxEnableScrollBar (
	INT fuSBFlags, 		//@parm Specifies scroll bar type	
	INT fuArrowflags)	//@parm	Specifies whether and which scroll bar arrows
						//		are enabled or disabled
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CLstBxWinHost::TxEnableScrollBar");

	// There may be cases where the item height is smaller than the font size
	// which means the notifications from ITextServices is wrong.  We have to perform
	// some manual checking for owner draw listboxes. The following cases will be valid
	// 1. If the listbox is NOT owner draw
	// 2. If the message is to disable the control
	// 3. If the count is greater than the viewsize
	if (!_fOwnerDraw || ESB_ENABLE_BOTH != fuArrowflags || GetCount() > _nViewSize)
		return CTxtWinHost::TxEnableScrollBar(fuSBFlags, fuArrowflags);
	return FALSE;
}


/*
 *	CLstBxWinHost::SetItemsHeight(int, BOOL)
 *
 *	@mfunc
 *		Sets the items height for all items
 *
 *	#rdesc
 *		int = number of paragraphs whose fontsize has been changed
 */
 int CLstBxWinHost::SetItemsHeight(int nHeight, BOOL bUseExact)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::SetItemsHeight");
	
 	// Calculate the new size in points
 	long nptNew = MulDiv(nHeight, 1440, W32->GetYPerInchScreenDC());
 	long nptMin = MulDiv(_nyFont, 1440, W32->GetYPerInchScreenDC());

	// NOTE:
	// This diverges from what the system list box does but there isn't a way
	// to set the height of a item to smaller than what the richedit will allow and
	// is not ownerdraw.  If it is owner draw make sure our height is not zero
	if (((nptNew < nptMin && !_fOwnerDraw) || nHeight <= 0) && !bUseExact)
		nptNew = nptMin;

	// Start setting the new height
	Freeze();
	long nPt;
	PARAFORMAT2 pf2;
	pf2.cbSize = sizeof(PARAFORMAT2);

	if (bUseExact)
	{
		pf2.dwMask = PFM_LINESPACING;
		pf2.bLineSpacingRule = 4;
		pf2.dyLineSpacing = nPt = nptNew;
	}
	else
	{		
		pf2.dwMask = PFM_SPACEAFTER;
		pf2.dySpaceAfter = max(nptNew - nptMin, 0);
		nPt = pf2.dySpaceAfter + nptMin;
	}

	// Set the default paragraph format
	LRESULT lr;
	_pserv->TxSendMessage(EM_SETPARAFORMAT, SPF_SETDEFAULT, (WPARAM)&pf2, &lr);
	
	// set the item height
	if (lr)
		_nyItem = (_fOwnerDraw && nHeight > 0) ? nHeight : 
					MulDiv(nPt, W32->GetYPerInchScreenDC(), 1440);

	Unfreeze();
	return lr;
 }

/*
 *	CLstBxWinHost::UpdateSysColors()
 *
 *	@mfunc
 *		update the system colors in the event they changed or for initialization
 *		purposes
 *
 *	#rdesc
 *		<none>
 */
 void CLstBxWinHost::UpdateSysColors()
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::UpdateSysColors");

 	// Update the system colors
 	_crDefBack = ::GetSysColor(COLOR_WINDOW);
 	_crSelBack = ::GetSysColor(COLOR_HIGHLIGHT);
 	_crDefFore = ::GetSysColor(COLOR_WINDOWTEXT);
 	_crSelFore = ::GetSysColor(COLOR_HIGHLIGHTTEXT); 	
 }
 
/*
 *	CLstBxWinHost::UpdateViewArea()
 *
 *	@mfunc
 *		Gets the height of each item and keeps an internal record of it
 *
 *	#rdesc
 *		<none>
 */
 void CLstBxWinHost::UpdateViewArea()
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::UpdateViewArea");

 	Assert(_pserv);

	_nyItem = 1;	// set to default value for right now
	
 	//Set the range to the first item
	ITextRange* pRange;
	if (NOERROR != ((CTxtEdit*)_pserv)->Range(0, 0, &pRange))
		return;
	Assert(pRange);
	
	// get rect of window
	TxGetClientRect(&_rcViewport);

	// calculate the height of each item
	long x;
	CHECKNOERROR(pRange->GetPoint(tomStart | TA_BOTTOM | TA_LEFT, &x, &_nyItem));

	_nyItem -= _rcViewport.top;		
	
 CleanExit:
 	pRange->Release();	
 	return;
 }


/*
 *	CLstBxWinHost::SetCursor(HDC, int, BOOL)
 *
 *	@mfunc
 *		Sets the cursor position, if it's valid and draws the focus rectangle if
 *		the control has focus.  The BOOL is used to determine if the previous
 *		cursor drawing needs to be removed
 *
 *	#rdesc
 *		<none>
 */
 void CLstBxWinHost::SetCursor(HDC hdc, int idx, BOOL bErase)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::SetCursor");
 	
 	Assert(idx >= -2 && idx < _nCount);
	
	// Get the hdc if it wasn't passed in
	BOOL bReleaseDC = (hdc == NULL);
 	if (bReleaseDC)
 		hdc = TxGetDC();
	Assert(hdc);
	
	RECT rc;
	// don't draw outside the client rect draw the rectangle
	TxGetClientRect(&rc);
	IntersectClipRect(hdc, rc.left, rc.top, rc.right, rc.bottom);
	
 	// Check if we have to remove the previous position
 	if ((idx != _nCursor && _fFocus && idx >= -1) || bErase)
 	{	
 		if (_fOwnerDraw)
 			LbDrawItemNotify(hdc, _nCursor, ODA_FOCUS, (IsSelected(max(_nCursor, 0)) ? ODS_SELECTED : 0));
 		else if (IsItemViewable(max(0, _nCursor)))
		{
	 		LbGetItemRect(max(_nCursor, 0), &rc);
	 		::DrawFocusRect(hdc, &rc);
	 	}
 	}

	// special flag meaning to set the cursor to the top index
	// if there are items in the listbox
	if (idx == -2)
	{
		if (GetCount())
		{
			idx = max(_nCursor, 0);
			if (!IsItemViewable(idx))
				idx = GetTopIndex();
		}
		else
			idx = -1;
	}

	_nCursor = idx;

	// Only draw the focus rect if the cursor item is
	// visible in the list box
	if (_fFocus)
	{
		if (_fOwnerDraw)
 			LbDrawItemNotify(hdc, max(0, _nCursor), ODA_FOCUS, ODS_FOCUS | (IsSelected(max(0, _nCursor)) ? ODS_SELECTED : 0));
 		else if (IsItemViewable(max(0, idx)))
		{
			// Now draw the rectangle
	 		LbGetItemRect(max(0,_nCursor), &rc);
	 		::DrawFocusRect(hdc, &rc);
	 	}
	}
	
 	if (bReleaseDC)
 		TxReleaseDC(hdc);
 }

/*
 *	CLstBxWinHost::InitSearch()
 *
 *	@mfunc
 *		Sets the array to its initial state
 *
 *	#rdesc
 *		<none>
 */
 void CLstBxWinHost::InitSearch()
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::InitSearch");

	_fSearching = 0;
 	_nidxSearch = 0;
 	if (_pwszSearch)
 		*_pwszSearch = 0;
 }
 
/*
 *	CLstBxWinHost::PointInRect(const POINT*)
 *
 *	@mfunc
 *		Determines if the given point is inside the listbox windows rect
 *		The point parameter should be in client coordinates.
 *
 *	#rdesc
 *		BOOL = inside listbox window rectangle ? TRUE : FALSE
 */
 BOOL CLstBxWinHost::PointInRect(const POINT * ppt)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::PointInRect");
 	Assert(ppt);
 	
 	RECT rc;
	::GetClientRect(_hwnd, &rc);
	return PtInRect(&rc, *ppt);
 }

/*
 *	CLstBxWinHost::GetItemFromPoint(POINT*)
 *
 *	@mfunc
 *		Retrieves the nearest viewable item from a passed in point.
 *		The point should be in client coordinates.
 *
 *	#rdesc
 *		int = item which is closest to the given in point, -1 if there 
 *			  are no items in the list box
 */
 int CLstBxWinHost::GetItemFromPoint(const POINT * ppt)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::GetItemFromPoint");

	// perform error checking first
	if (_nCount == 0)
		return -1;

	int y = (signed short)ppt->y;

 	// make sure y is in a valid range
 	if (y < _rcViewport.top)
 		y = 0;
 	else if (y > _rcViewport.bottom)
 		y = _rcViewport.bottom - 1;

	//need to factor in the possibility an item may not fit entirely into the window view
	Assert(_nyItem);
	int idx = GetTopIndex() + (int)(max(0,(y - 1)) / max(1,_nyItem));

	Assert(IsItemViewable(idx));
 	return (idx < _nCount ? idx : _nCount - 1);
 }
 
/*
 *	CLstBxWinHost::ResetContent()
 *
 *	@mfunc
 *		Deselects all the items in the list box
 *
 *	#rdesc
 *		BOOL = If everything went fine ? TRUE : FALSE
 */
 BOOL CLstBxWinHost::ResetContent()
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::ResetContent");

	Assert(_fOwnerDraw == 0);
	
	// lets try to be smart about reseting the colors by only select a range
	// from the first selection found to the last selection found

	int nStart = _nCount - 1;
	int nEnd = -1;
 	for (int i = 0; i < _nCount; i++)
 	{
		if (_rgData[i]._fSelected)
		{
			_rgData[i]._fSelected = 0;

			if (nStart > i)
				nStart = i;
			if (nEnd < i)
				nEnd = i;
		}
 		
 	}

	Assert(nStart <= nEnd || ((nStart == _nCount - 1) && (nEnd == -1)));
	if (nStart > nEnd)
		return TRUE;

 	return (_nCount > 0) ? SetColors((unsigned)tomAutoColor, (unsigned)tomAutoColor, nStart, nEnd) : FALSE;
 }
 
/*
 *	CLstBxWinHost::GetString(long, PWCHAR)
 *
 *	@mfunc
 *		Retrieve the string at the requested index.  PWSTR can be null
 *		if only the text length is requires
 *
 *	#rdesc
 *		long = successful ? length of string : -1
 */
 long CLstBxWinHost::GetString(long nIdx, PWCHAR szOut)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::GetString");

 	Assert(0 <= nIdx && nIdx < _nCount);
 	if (nIdx < 0 || _nCount <= nIdx)
 		return -1;

	long l = -1;
	long lStart;
	long lEnd;
 	ITextRange* pRange;
 	BSTR bstr;
 	if (!GetRange(nIdx, nIdx, &pRange))
 		return -1;
 		
 	// Need to move one character to the left to unselect the paragraph marker.
 	Assert(pRange);
 	CHECKNOERROR(pRange->MoveEnd(tomCharacter, -1, &lEnd));
	CHECKNOERROR(pRange->GetStart(&lStart));
	CHECKNOERROR(pRange->GetEnd(&lEnd));

	// Get the string
	if (szOut)
	{
		if (_dwStyle & LBS_HASSTRINGS)
		{
			CHECKNOERROR(pRange->GetText(&bstr));
			if (bstr)
			{
				wcscpy(szOut, bstr);
				SysFreeString(bstr);
			}
			else
				wcscpy(szOut, L"");	// we got an empty string!
		}
		else
			(*(long*)szOut) = GetData(nIdx);
	}
	l = lEnd - lStart;

CleanExit:
 	pRange->Release();
 	return l;
 }
 
/*
 *	CLstBxWinHost::InsertString(long, LPCTSTR)
 *
 *	@mfunc
 *		Insert the string at the requested location.  If the
 *		requested index is larger than _nCount then the function
 *		will fail.  The string is inserted with CR appended to
 *		to the front and back of the string
 *
 *	#rdesc
 *		BOOL = successfully inserted ? TRUE : FALSE
 */
 BOOL CLstBxWinHost::InsertString(long nIdx, LPCTSTR szInsert)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::InsertString");

	Assert(szInsert);
	Assert(0 <= nIdx && nIdx <= _nCount);

	// allocate string buffer into stack
	WCHAR sz[1024];
	WCHAR *psz = sz;
	
	if ( (wcslen(szInsert) + 3 /* 2 paragraphs and a NULL*/) > 1024)
		psz = new WCHAR[wcslen(szInsert) + 3 /* 2 paragraphs and a NULL*/];
	Assert(psz);
	
	if (psz == NULL)
	{
		TxNotify((unsigned long)LBN_ERRSPACE, NULL);
		return FALSE;
	}
	
	*psz = NULL;
	if (nIdx == _nCount && _nCount)
		wcscpy(psz, szCR);

	// copy string and add <CR> at the end
	wcscat(psz, szInsert);

	// don't add the carriage return if the entry point is the end
	if (nIdx < _nCount)
		wcscat(psz, szCR);			
	
 	BOOL bRet = FALSE;
 	ITextRange * pRange = NULL;
	int fFocus = _fFocus;
	long idx = nIdx;
	BSTR bstr = SysAllocString(psz);
	if (!bstr)
		goto CleanExit;
	Assert(bstr);

	if (psz != sz)
		delete [] psz;
	
 	// Set the range to the point where we want to insert the string 	
	
	// make sure the requested range is a valid one
	if (nIdx == _nCount)
		idx = max(idx - 1, 0);

 	if (!GetRange(idx, idx, &pRange))
 	{
 		SysFreeString(bstr);
 		return FALSE;
 	}

 	// Collapse the range to the start if insertion is in the middle or top
	// of list, collapse range to the end if we are inserting at the end of the list
	CHECKNOERROR(pRange->Collapse((idx == nIdx)));

	// Need to assume the item was successfully added because during SetText TxEnable(show)Scrollbar
	// gets called which looks at the count to determine if we should display the scroll bar
	_nCount++;

	//bug fix #5411
	// Check if we have focus, if so we need to remove the focus rect first and update the cursor positions	
	_fFocus = 0;
	SetCursor(NULL, (idx > GetCursor() || GetCursor() < 0) ? GetCursor() : GetCursor() + 1, fFocus);
	_fFocus = fFocus;


	//For ownerdraw cases where the item height is less than the font we need to manually
	//enable the scrollbar if we need the scrollbar and the scrollbar is disabled.
	if ((_nyItem < _nyFont) && (_fDisableScroll) && (_nCount - 1 == _nViewSize))
		TxEnableScrollBar(SB_VERT, ESB_ENABLE_BOTH);

#ifdef _DEBUG
	if (bstr && wcslen(bstr))
		Assert(FALSE);
#endif

	if (NOERROR != (pRange->SetText(bstr)))	
	{
		_nCount--;
		
		//Unsuccessful in adding the string so disable the scrollbar if we enabled it
		if ((_nyItem < _nyFont) && (_fDisableScroll) && (_nCount == _nViewSize))
			TxEnableScrollBar(SB_VERT, ESB_DISABLE_BOTH);
			
		TxNotify((unsigned long)LBN_ERRSPACE, NULL);
		goto CleanExit;
	} 

	//We need to update the top index after a string is inserted
	if (idx < GetTopIndex())
		_nTopIdx++;
		
	bRet = TRUE;
 	
CleanExit:
	if (bstr)
 		SysFreeString(bstr);
	if (pRange)
 		pRange->Release();
 	return bRet;
 }

/*
 *	BOOL CLstBxWinHost::RemoveString(long, long)
 *
 *	@mfunc
 *		Prevents TOM from drawing
 *
 *	#rdesc
 *		BOOL = Successful ? TRUE : FALSE
 */
BOOL CLstBxWinHost::RemoveString(long nStart, long nEnd)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::RemoveString");

	Assert(nStart <= nEnd);
	Assert(nStart < _nCount && nEnd < _nCount);

	// Remove item from richedit
	Freeze();
	ITextRange* pRange;
	if (!GetRange(nStart, nEnd, &pRange))
	{
		Unfreeze();
		return FALSE;
	}
	long l;
	
	// Since we can't erase the last paragraph marker we will erase
	// the paragraph marker before the item if it's not the first item
	HRESULT hr;
	if (nStart != 0)
	{
		hr = pRange->MoveStart(tomCharacter, -1, &l);
		Assert(hr == NOERROR);
		hr = pRange->MoveEnd(tomCharacter, -1, &l);
		Assert(hr == NOERROR);
	}

	if (NOERROR != pRange->Delete(tomCharacter, 0, &l) && _nCount > 1)
	{
		Unfreeze();
		pRange->Release();
		return FALSE;
	}
	pRange->Release();
	int nOldCt = _nCount;
	_nCount -= (nEnd - nStart) + 1;

	// Because we delete the paragraph preceeding the item
	// rather than following the item we need to update 
	// the paragraph which followed the item. bug fix #4074	
	long nFmtPara = max(nStart -1, 0);
	if (!_fOwnerDraw && (IsSelected(nEnd) != IsSelected(nFmtPara) || _nCount == 0))
	{		
		DWORD dwFore = (unsigned)tomAutoColor;
		DWORD dwBack = (unsigned)tomAutoColor;		
		if (IsSelected(nFmtPara) && _nCount)
		{
			dwFore = _crSelFore;
			dwBack = _crSelBack;		
		}
		SetColors(dwFore, dwBack, nFmtPara, nFmtPara);
	}

	// update our internal listbox records	
	int j = nEnd + 1;
	for(int i = nStart; j < nOldCt; i++, j++)
	{
		_rgData[i]._fSelected = _rgData.Get(j)._fSelected;
		_rgData[i]._dwData = _rgData.Get(j)._dwData;		
	}

	//bug fix #5397 
	//we need to reset the internal array containing information
	//about previous items
	while (--j >= _nCount)
	{
		_rgData[j]._fSelected = 0;
		_rgData[j]._dwData = 0;
	}
		
	if (_nCount > 0)
	{
		// update the cursor			
		if (nStart <= _nCursor)
			_nCursor--;
		_nCursor = min(_nCursor, _nCount - 1);

		if (_fLstType == kExtended)
		{
			if (_nCursor < 0)
			{
				_nOldCursor = min(_nAnchor, _nCount - 1);
				_nAnchor = -1;
			}
			else if (_nAnchor >= 0)
			{
				if (nStart <= _nAnchor && _nAnchor <= nEnd)
				{
					// Store the old anchor for future use
					_nOldCursor = min(_nAnchor, _nCount - 1);
					_nAnchor = -1;
				}
			}
		}

		if (_fOwnerDraw)
		{
			RECT rcStart;
			RECT rcEnd;
			LbGetItemRect(nStart, &rcStart);
			LbGetItemRect(nEnd, &rcEnd);
			rcStart.bottom = rcEnd.bottom;
			if (IntersectRect(&rcStart, &rcStart, &_rcViewport))
			{
				// the list will get bumped up so we need to redraw
				// everything from the top to the bottom
				rcStart.bottom = _rcViewport.bottom;
				::InvalidateRect(_hwnd, &rcStart, TRUE);				
			}
		}
	}
	else
	{
		SetTopViewableItem(0);
		_nAnchor = -1;
		_nCursor = -1;
	}

	//For ownerdraw cases where the item height is less than the font we need to manually
	//enable the scrollbar if we need the scrollbar and the scrollbar is disabled.
	if ((_nyItem < _nyFont) && (_fDisableScroll) && 
		(_nCount <= _nViewSize) && (nOldCt > _nViewSize))
		TxEnableScrollBar(SB_VERT, ESB_DISABLE_BOTH);
	
	LbDeleteItemNotify(nStart, nEnd);
	Assert(GetTopIndex() >= 0);
	if (_nCount)
		LbShowIndex(min(GetTopIndex(), _nCount - 1), FALSE);
	Unfreeze();
	return TRUE;
}
 
/*
 *	inline CLstBxWinHost::Freeze()
 *
 *	@mfunc
 *		Prevents TOM from drawing
 *
 *	#rdesc
 *		<none>
 */
void CLstBxWinHost::Freeze()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::Freeze");
	long l;
	((CTxtEdit*)_pserv)->Freeze(&l);
}

/*
 *	inline CLstBxWinHost::FreezeCount()
 *
 *	@mfunc
 *		Returns the current freeze count
 *
 *	#rdesc
 *		<none>
 */
short CLstBxWinHost::FreezeCount() const
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::GetFreezeCount");
	return ((CTxtEdit*)_pserv)->GetFreezeCount();
}

/*
 *	inline CLstBxWinHost::Unfreeze()
 *
 *	@mfunc
 *		Allows TOM to update itself
 *
 *	#rdesc
 *		<none>
 */
void CLstBxWinHost::Unfreeze()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::Unfreeze");
	long l;
	((CTxtEdit*)_pserv)->Unfreeze(&l);

    // HACK ALERT!
    // When ITextRange::ScrollIntoView starts caching the scroll position
    // in cases where the display is frozen the following code can be removed
    
    // We could have failed in ITextRange::ScrollIntoView
    // Check if we did and try calling it again
	if (!l && _stvidx >= 0)
	{
	    ScrollToView(_stvidx);
	    _stvidx = -1;
	}
}

/*
 *	CLstBxWinHost::ScrollToView(long)
 *
 *	@mfunc
 *		Sets the given index to be at the top of 
 *		the viewable window space
 *
 *	#rdesc
 *		BOOL = if function succeeded ? TRUE : FALSE
 */
BOOL CLstBxWinHost::ScrollToView(long nTop)
{
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::SetTopViewableItem");

	//Get the range which contains the item desired
	BOOL bVal = FALSE;
	ITextRange* pRange = NULL;
	
	if (!GetRange(nTop, nTop, &pRange))
	    return bVal;
    Assert(pRange);	 

    CHECKNOERROR(pRange->Collapse(1));
	CHECKNOERROR(pRange->ScrollIntoView(tomStart + /* TA_STARTOFLINE */ 32768));
	bVal = TRUE;

CleanExit:
	pRange->Release();

    // HACK ALERT!
    // When ITextRange::ScrollIntoView starts caching the scroll position
    // in cases where the display is frozen the following code can be removed
    
	//if we failed record the index we failed to scroll to	
	if (!bVal && FreezeCount())
	    _stvidx = nTop;
	return bVal;	
}

/*
 *	CLstBxWinHost::SetTopViewableItem(long)
 *
 *	@mfunc
 *		Sets the given index to be at the top of 
 *		the viewable window space
 *
 *	#rdesc
 *		BOOL = if function succeeded ? TRUE : FALSE
 */
 BOOL CLstBxWinHost::SetTopViewableItem(long nTop)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::SetTopViewableItem");

	// if we don't have any items in the list box then just set the topindex to 
	// zero
	if (_nCount == 0)
	{
		Assert(nTop == 0);
		_nTopIdx = 0;
		return TRUE;
	}
	
	// don't do anything if the requested top index is greater
	// then the amount of items in the list box
 	Assert(nTop < _nCount);
 	if (nTop >= _nCount)
 		return FALSE;

	// Don't do this if it's ownerdraw
	if (!_fOwnerDraw)
	{
		// Since we erase and draw the focus rect here
		// cache the focus rect info and don't bother with the
		// focus rect stuff until later
		int fFocus = _fFocus;
		_fFocus = 0;
		if (fFocus && IsItemViewable(GetCursor()))
			SetCursor(NULL, GetCursor(), TRUE);
		
	 	//Get the range which contains the item desired
		long nOldIdx = _nTopIdx;
		_nTopIdx = nTop;
	 	if (!ScrollToView(nTop))
		{
            // HACK ALERT!
            // When ITextRange::ScrollIntoView starts caching the scroll position
            // in cases where the display is frozen the following code can be removed            
            if (_stvidx >= 0)
                return TRUE;

            // Something went wrong and we weren't able to display the index requested
            // reset top index
			_nTopIdx = nOldIdx;		
		}

		// Note:
		//	If the cursor was not viewable then we don't attempt
		// to display the focus rect because we never erased it 
		_fFocus = fFocus;
		if (_fFocus & IsItemViewable(GetCursor()))
		{
			// Now we need to redraw the focus rect which we erased
			SetCursor(NULL, GetCursor(), FALSE);
		}
	}
	else
	{				
		int dy = (_nTopIdx - nTop) * _nyItem;
		RECT rc;
		TxGetClientRect(&rc);
		_nTopIdx = nTop;
		TxScrollWindowEx(0, dy, NULL, &rc, NULL, NULL, 
				SW_INVALIDATE | SW_ERASE | SW_SCROLLCHILDREN);
		SetScrollInfo(SB_VERT, TRUE); // we update the scrollbar manually if we are in ownerdraw mode
		UpdateWindow(_hwnd);
 	}
		
	return TRUE;
 }
 
/*
 *	CLstBxWinHost::GetRange(long, long, ITextRange**)
 *
 *	@mfunc
 *		Sets the range given the top and bottom index
 *		by storing the range into ITextRange
 *
 *	#rdesc
 *		BOOL = if function succeeded ? TRUE : FALSE
 */
BOOL CLstBxWinHost::GetRange(long nTop, long nBottom, ITextRange** ppRange)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::GetRange");

	// do some error checking
	if (nTop < 0 || nTop > _nCount || nBottom < 0 || nBottom > _nCount)
		return FALSE;
		
	Assert(ppRange);
	if (NOERROR != ((CTxtEdit*)_pserv)->Range(0, 0, ppRange))
	{
		Assert(FALSE);
		return FALSE;
	}
	Assert(*ppRange);

	// convert index to a 1-based index
	nTop++;
	nBottom++;
	long l;
	CHECKNOERROR((*ppRange)->SetIndex(tomParagraph, nTop, 1));
	if (nBottom > nTop)
	{
		CHECKNOERROR((*ppRange)->MoveEnd(tomParagraph, nBottom - nTop, &l));
	}

	return TRUE;
CleanExit:
	Assert(FALSE);
	(*ppRange)->Release();
	*ppRange = NULL;
	return FALSE;
}

/*
 *	CLstBxWinHost::SetColors(DWORD, DWORD, long, long)
 *
 *	@mfunc
 *		Sets the background color for the givin range of paragraphs.  This
 *		only operates in terms of paragraphs.
 *
 *	#rdesc
 *		BOOL = if function succeeded in changing different color
 */
BOOL CLstBxWinHost::SetColors(DWORD dwFgColor, DWORD dwBgColor, long nParaStart, long nParaEnd)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::SetColors");

	Assert(_fOwnerDraw == 0);
	
	//Get the range of the index
	ITextRange* pRange;
	if (!GetRange(nParaStart, nParaEnd, &pRange))
		return FALSE;

	BOOL bRet = FALSE;	
	ITextFont* pFont;
	
#ifdef DEBUG	
	// Check if the background and foreground really is different
	// for debugging purposes
	CHECKNOERROR(pRange->GetFont(&pFont));
	Assert(pFont);
	if (nParaStart == nParaEnd && _fLstType != kCombo)
	{
		long lColor;
		CHECKNOERROR(pFont->GetBackColor(&lColor));
		Assert((DWORD)lColor != dwBgColor || _nCount == 0);
		CHECKNOERROR(pFont->GetForeColor(&lColor));
		Assert((DWORD)lColor != dwFgColor || _nCount == 0);
	}
	pFont->Release();
#endif //_DEBUG

	// Set the background and forground color
	if (NOERROR != pRange->GetFont(&pFont))
	{
		pRange->Release();
		return FALSE;
	}	
	
	Assert(pFont);
	CHECKNOERROR(pFont->SetBackColor(dwBgColor));
	CHECKNOERROR(pFont->SetForeColor(dwFgColor));

	bRet = TRUE;
CleanExit:
	// Release pointers
	pFont->Release();
	pRange->Release();
	return bRet;

}

/////////////////////////////  Message Map Functions  ////////////////////////////////
/*
 *	void CLstBxWinHost::OnSetCursor()
 *
 *	@mfunc
 *		Handles the WM_SETCURSOR message.
 *
 *	#rdesc
 *		LRESULT = return value after message is processed
 */
 LRESULT CLstBxWinHost::OnSetCursor()
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnSetCursor");

	// Just make sure the cursor is an arrow if it's over us
	TxSetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW)), NULL);
	return 1;
 }

/*
 *	void CLstBxWinHost::OnSysColorChange()
 *
 *	@mfunc
 *		Handles the WM_SYSCOLORCHANGE message.
 *
 *	#rdesc
 *		LRESULT = return value after message is processed
 */
 void CLstBxWinHost::OnSysColorChange()
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnSysColorChange");

	if (!_fOwnerDraw)
	{
	 	// set the new colors
 		COLORREF crDefBack = _crDefBack;
 		COLORREF crDefFore = _crDefFore;
 		COLORREF crSelBack = _crSelBack;
 		COLORREF crSelFore = _crSelFore;
 		
 		// update colors
 		UpdateSysColors();

		// optimization check; don't do anything if there are no elements
		if (_nCount <= 0)
			return;

	 	// Only update the list box if colors changed
	 	if (crDefBack != _crDefBack || crDefFore != _crDefFore ||
	 		crSelBack != _crSelBack || crSelFore != _crSelFore)
	 	{
	 		//Bug fix #4847
	 		// notify parent first
 			CTxtWinHost::OnSysColorChange();
 			
			int nStart = 0;
			int nEnd = 0;
			BOOL bSelection = _rgData.Get(0)._fSelected;

	 		for (int i = 1; i < _nCount; i++)
	 		{
				if (_rgData.Get(i)._fSelected != (unsigned)bSelection)
				{
					// Update the colors only for selections
					if (bSelection)
						SetColors(_crSelFore, _crSelBack, nStart, nStart + nEnd);

					// Update our cache to reflect the value of our current index
					bSelection = _rgData.Get(i)._fSelected;
					nStart = i;
					nEnd = 0;
				}
				else
					nEnd++;
	 		}

			// there was some left over so change the color for these
			if (bSelection)
				SetColors(_crSelFore, _crSelBack, nStart, nStart + nEnd);
	 	}
	 }
 }
 
/*
 *	LRESULT CLstBxWinHost::OnChar(WORD, DWORD)
 *
 *	@mfunc
 *		Handles the WM_CHAR message.
 *
 *	#rdesc
 *		LRESULT = return value after message is processed
 */
 LRESULT CLstBxWinHost::OnChar(WORD vKey, DWORD lparam)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnChar");

 	// don't do anything if list box is empty or in the middle of
 	// a mouse down
 	if (_fMouseDown || _nCount == 0)
 		return 0;

 	BOOL fControl = (GetKeyState(VK_CONTROL) < 0);

	int nSel = -1;
 	switch (vKey)
 	{
 	case VK_ESCAPE:
 		InitSearch();
 		return 0;
 		
 	case VK_BACK:
 		if (_pwszSearch && _nidxSearch)
 		{
 			if (_nidxSearch > 0)
 				_nidxSearch--;
 			_pwszSearch[_nidxSearch] = NULL;
 			break;	// we break out of case because we still want to perform the search
 		}
 		return 0;		
 	
 	case VK_SPACE:
 		if (_fLstType == kMultiple)
 			return 0;
 		/* Fall through case */
 		
 	default:
 		// convert CTRL+char to char
 		if (fControl && vKey < 0x20)
 			vKey += 0x40;

		// don't go beyond the search array size
 		if (_nidxSearch >= LBSEARCH_MAXSIZE)
 		{
 			((CTxtEdit*)_pserv)->Beep();
 			return 0;
 		}

		// allocate string if not already allocated
		if (_pwszSearch == NULL)
			_pwszSearch = new WCHAR[LBSEARCH_MAXSIZE];

		// error checking
		if (_pwszSearch == NULL)
		{
			((CTxtEdit*)_pserv)->Beep();
			Assert(FALSE && "Unable to allocate search string");
			return 0;
		}		

		// put the input character into string array
 		_pwszSearch[_nidxSearch++] = (WCHAR)vKey;
 		_pwszSearch[_nidxSearch] = NULL;
 	}

	if (_fSort)
	{		
		nSel = (_fSearching) ? _nCursor + 1 : 0;

		// Start the search for a string
 		TxSetTimer(ID_LB_SEARCH, ID_LB_SEARCH_DEFAULT);
		_fSearching = 1;
	}
	else
	{
		_nidxSearch = 0;
		nSel = _nCursor + 1;
	}

	// Make sure our index isn't more than the items we have
	if (nSel >= _nCount)
		nSel = 0;

	int nRes = LbFindString(nSel, _pwszSearch, FALSE);
	if (nRes < 0)
	{
		if (_pwszSearch)
		{
			if (_nidxSearch > 0)
				_nidxSearch--;
			if (_nidxSearch == 1 && _pwszSearch[0] == _pwszSearch[1])
			{
				_pwszSearch[1] = NULL;
				nRes = LbFindString(nSel, _pwszSearch, FALSE);
			}
		}
	}

	// If a matching string is found then select it
	if (nRes >= 0)
		OnKeyDown(nRes, 0, 1);

	//	If Hi-Ansi need to send a wm_syskeyup message to ITextServices to 
	// stabalize the state
	if (0x80 <= vKey && vKey <= 0xFF && !HIWORD(GetKeyState(VK_MENU)))
	{
		LRESULT lres;
		_pserv->TxSendMessage(WM_SYSKEYUP, VK_MENU, 0xC0000000, &lres);
	}	
	
 	return 0;
 }

 
/*
 *	LRESULT CLstBxWinHost::OnKeyDown(WPARAM, LPARAM, INT)
 *
 *	@mfunc
 *		Handles the WM_KEYDOWN message.  The BOOL ff is used as a flag for calls
 *	made internally and not responsive to the WM_KEYDOWN message.  Since this
 *	function is used for other things, ie helper to dealing with the WM_CHAR message.
 *
 *	#rdesc
 *		LRESULT = return value after message is processed
 */
 LRESULT CLstBxWinHost::OnKeyDown(WPARAM vKey, LPARAM lparam, int ff)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnKeyDown");

    // Ignore keyboard input if we are in the middle of a mouse down deal or
    // if there are no items in the listbox. Note that we let F4's go
    // through for combo boxes so that the use can pop up and down empty
    // combo boxes.
 	if (_fMouseDown || (_nCount == 0 && vKey != VK_F4))
 		return 1;

	// Check if the shift key is down for Extended listbox style only
 	int ffShift = 0;
 	if (_fLstType == kExtended)
 		ffShift = HIWORD(GetKeyState(VK_SHIFT));

 	// Special case!
 	// Check if this function is called as a helper
 	int nSel = (ff) ? vKey : -1;

#if 0 	
 	if (_fNotify && ff == 0)
 	{
 		// NOTE: LBS_WANTKEYBOARDINPUT
 		//  To support LBS_WANTKEYBOARDINPUT the following comment has to be done
	 	//	Need to send parentwindow the keydown message
 		// According to documenation we notify the parent the key was pressed
 		// if the parent returns -2 then we don't do anything and immediately exit out
 		// if the parent returns >=0 then we just jump to that index else
 		// we just continue with the default procedure.
 	}
#endif

	TxKillTimer(ID_LB_CAPTURE);
 	if (nSel < 0)
 	{
 		// Need to set the selection so find the new selection
 		// based on the virtual key pressed
 		switch (vKey)
 		{
 		// UNDONE: Later, not language independent!!!
 		// Need to find-out how NT5.0 determines the slash issue??
 		
 		case VERKEY_BACKSLASH:
 			// Deselect everything if we are in extended mode
 			if (HIWORD(GetKeyState(VK_CONTROL)) && _fLstType == kExtended)
 			{
 				// NOTE:
 				//	Winnt loses the anchor and performing a shift+<vkey> 
 				//  doesn't select any items.  Instead, it just moves the
 				//  cursor w/o selecting the current cursor
 				_nAnchor = -1;
 				LbSetSelection(_nCursor, _nCursor, LBSEL_RESET | LBSEL_SELECT, 0, 0); 
 				TxNotify(LBN_SELCHANGE, NULL);
 			} 			
 			return 1;

 		case VK_DIVIDE:
 		case VERKEY_SLASH:
 			// Select everything if we are in extended mode
 			if (HIWORD(GetKeyState(VK_CONTROL)) && _fLstType == kExtended)
 			{
 				// NOTE:
 				//  Winnt behaves as we expect.  In other words the anchor
 				//  isn't changed and neither is the cursor
 				LbSetSelection(0, _nCount - 1, LBSEL_SELECT, 0, 0);
 				TxNotify(LBN_SELCHANGE, NULL);
 			}
 			return 1;
 		
 		case VK_SPACE:
 			// just get out if there is nothing to select
 			if (_nCursor < 0 && !GetCount())
 				return 1;
 			// Just select current item
 			nSel = _nCursor;
 			break;
 			
 		case VK_PRIOR:
 			// move the cursor up enough so the current item which the cursor
 			// is pointing to is at the bottom and the new cursor position is at the top
 			nSel = _nCursor - _nViewSize + 1;
 			if (nSel < 0)
 				nSel = 0;
 			break;
 			
 		case VK_NEXT:
 			// move the cursor down enough so the current item which the cursor
 			// is point is at the top and the new cursor position is at the bottom
 			nSel = _nCursor + _nViewSize - 1;
 			if (nSel >= _nCount)
 				nSel = _nCount - 1;
 			break; 			

 		case VK_HOME:
 			// move to the top of the list
 			nSel = 0;
 			break;
 			
 		case VK_END:
 			// move to the bottom of the list
 			nSel = _nCount - 1;
 			break;

 		case VK_LEFT:
 		case VK_UP:
 			nSel = (_nCursor > 0) ? _nCursor - 1 : 0;
 			break;

 		case VK_RIGHT:
 		case VK_DOWN:
 			nSel = (_nCursor < _nCount - 1) ? _nCursor + 1 : _nCount - 1;
 			break;

 		case VK_RETURN:
 		case VK_F4:
 		case VK_ESCAPE:
 			if (_fLstType == kCombo)
 			{
	 			Assert(_pcbHost);
	 			int nCursor = (vKey == VK_RETURN) ? GetCursor() : _nOldCursor;
	 			_pcbHost->SetSelectionInfo(vKey == VK_RETURN, nCursor);
	 			LbSetSelection(nCursor, nCursor, LBSEL_RESET | 
	 				((nCursor == -1) ? 0 : LBSEL_NEWCURSOR | LBSEL_SELECT), nCursor, nCursor);
				OnCBTracking(LBCBM_END, 0); // we need to do this because we may have some extra messages
											// in our message queue which can change the selections
	 			::SendMessage(_hwndParent, LBCB_TRACKING, 0, 0);
	 		}
 			// NOTE:
 			//	We differ from Winnt here in that we expect the
 			// combobox window handler to do all the positioning and 
 			// showing of the list box.  So when we get this message
 			// and we are part of a combobox we should notify the 
 			// combobox and in turn the combobox should immediately close us.
 			//return 1;

 		//case VK_F8: // not suppported 

 		// We need to return this to pserv to process these keys
		/*
		case VK_MENU:
 		case VK_CONTROL:
 		case VK_SHIFT:
 			return 1;
 		*/
 		
 		default:
 			return 1; 		
 		}
 	}

 	// There can be cases where nSel = -1; _nCursor = -1 && _nViewSize = 1
 	// make sure the selection index is valid
 	if (nSel < 0)
 	    nSel = 0;

 	// Should the cursor be set at the top or bottom of the list box??
 	BOOL bTop = (_nCursor > nSel) ? TRUE : FALSE;
 	Freeze();
 	if (_fLstType == kMultiple)
 	{
		if (vKey == VK_SPACE)
		{
			BOOL fSel = IsSelected(nSel);
			if (LbSetSelection(nSel, nSel, LBSEL_NEWCURSOR | (IsSelected(nSel) ? 0 : LBSEL_SELECT), nSel, 0))
			{
#ifndef NOACCESSIBILITY
				_dwWinEvent = EVENT_OBJECT_FOCUS;
				_fNotifyWinEvt = TRUE;
				TxNotify(_dwWinEvent, NULL);
				if (fSel)
					_dwWinEvent = EVENT_OBJECT_SELECTIONREMOVE;
#endif
			}
		}
		else
		{
			SetCursor(NULL, nSel, TRUE);
#ifndef NOACCESSIBILITY
			_dwWinEvent = EVENT_OBJECT_FOCUS;
#endif
		}
	}
 	else
 	{ 	
	 	if (ffShift && _fLstType == kExtended)
	 	{	 		
	 		// Set the anchor if it already isn't set
	 		_nOldCursor = -1;
			if (_nAnchor < 0)
				_nAnchor = nSel;
	
			LbSetSelection(_nAnchor, nSel, LBSEL_RESET | LBSEL_SELECT | LBSEL_NEWCURSOR, nSel, 0);
	 	}
	 	else
	 	{
	 		// if the selected item is already selected then
	 		// just exit out
	 		if (_nCursor == nSel && IsSelected(_nCursor))
	 		{
	 		    Unfreeze();
	 			return 1;
	 		}

	 		LbSetSelection(nSel, nSel, LBSEL_DEFAULT, nSel, nSel);
	 	}
	}
	// LbShowIndex eventually calls ScrollToView which fails if display is frozen
	Unfreeze();
	
	// Make sure the selection is visible
	LbShowIndex(nSel, bTop);
	

	// key presses qualify as ok selections so we have to update the old cursor position		
	TxNotify(LBN_SELCHANGE, NULL);

	_nOldCursor = _nCursor;
	return 1;
 }
 
/*
 *	LRESULT CLstBxWinHost::OnTimer(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Handles the WM_TIMER message
 *
 *	#rdesc
 *		LRESULT = return value after message is processed
 */
 LRESULT CLstBxWinHost::OnTimer(WPARAM wparam, LPARAM lparam)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnTimer");

	// Check which timer we have
	switch (wparam)
	{
	case ID_LB_CAPTURE:
		// for mouse movements let mousemove handler deal with it
		if (_fCapture)
		{
			POINT pt;
			::GetCursorPos(&pt);
			// Must convert to client coordinates to mimic the mousemove call
			TxScreenToClient(&pt);
			OnMouseMove(0, MAKELONG(pt.x, pt.y));
		}
		break;

	case ID_LB_SEARCH:
		// for type search.  If we get here means > 2 seconds elapsed before last
		// character was typed in so reset type search and kill the timer
		InitSearch();
		TxKillTimer(ID_LB_SEARCH);
		break;

	default:
		return 1;	
	}
	return 0;
 }
 
/*
 *	LRESULT CLstBxWinHost::OnVScroll(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Handles the WM_VSCROLL message
 *
 *	#rdesc
 *		LRESULT = return value after message is processed
 */
 LRESULT CLstBxWinHost::OnVScroll(WPARAM wparam, LPARAM lparam)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnVScroll");

	if (_nCount <= _nViewSize)
		return 0;

	int nCmd = LOWORD(wparam);
	int nIdx = 0;
	switch (nCmd)
	{
	case SB_TOP:
		nIdx = 0;
		break;
		
	case SB_BOTTOM:
		nIdx = _nCount - _nViewSize;
		if (nIdx < 0)
			nIdx = 0;
		break;
	
	case SB_LINEDOWN:
		nIdx = GetTopIndex() + 1;
		break;		
		
	case SB_LINEUP:
		nIdx = GetTopIndex() - 1;
		if (nIdx < 0)
			nIdx = 0;
		break;
		
	case SB_PAGEDOWN:
		nIdx = GetTopIndex() + _nViewSize;
		if (nIdx > (_nCount - _nViewSize))
			nIdx = _nCount - _nViewSize;
		break;
		
	case SB_PAGEUP:
		nIdx = GetTopIndex() - _nViewSize;
		if (nIdx < 0)
			nIdx = 0;
		break;

	case SB_THUMBPOSITION:
	case SB_THUMBTRACK:
		// NOTE:
		//	if the list box is expected to hold more that 0xffff items
		//  then we need to modify this code to call GetScrollInfo.		
		nIdx =  HIWORD(wparam) / _nyItem;
		break;

		// Don't need to do anything for this case
	case SB_ENDSCROLL:
		return 0;	
	}
		
	LbSetTopIndex(nIdx);
 	return 0;
 }


 /*
 *	LRESULT CLstBxWinHost::OnCaptureChanged(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Handles the WM_CAPTURECHANGED message
 *
 *	#rdesc
 *		LRESULT = return value after message is processed
 */
 LRESULT CLstBxWinHost::OnCaptureChanged(WPARAM wparam, LPARAM lparam)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnCaptureChanged");
	
	if (_fCapture)
	{
		POINT pt;
		::GetCursorPos(&pt);
		::ScreenToClient(_hwnd, &pt);

		// prevent us from trying to release capture since we don't have
		// it anyways by set flag and killing timer
		_fCapture = 0;
		TxKillTimer(ID_LB_CAPTURE);		
		OnLButtonUp(0, MAKELONG(pt.y, pt.x), LBN_SELCANCEL);
	}
	return 0;
 }

//FUTURE:
// Do we need to support ReadModeHelper? 

/*
 *	LRESULT CLstBxWinHost::OnMouseWheel(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Handles the WM_MOUSEWHEEL message
 *
 *	#rdesc
 *		LRESULT = return value after message is processed
 */
 LRESULT CLstBxWinHost::OnMouseWheel(WPARAM wparam, LPARAM lparam)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnMouseWheel");

	// we don't to any zooms or anything of the sort
	if ((wparam & MK_CONTROL) == MK_CONTROL)
		return 1;

	// Check if the scroll is ok w/ the listbox requirements
    LRESULT lReturn = 1;
    short delta = (short)(HIWORD(wparam));
   	_cWheelDelta -= delta;   	
    if ((abs(_cWheelDelta) >= WHEEL_DELTA) && (_nCount > _nViewSize) && (_dwStyle & WS_VSCROLL )) 
    {
		// shut-off timer for right now
		TxKillTimer(ID_LB_CAPTURE);

		Assert(delta != 0);
        	
		int nlines = W32->GetRollerLineScrollCount();
		if (nlines == -1)
		{
			OnVScroll(MAKELONG((delta < 0) ? SB_PAGEUP : SB_PAGEDOWN, 0), 0);
		}
		else
		{
			//Calculate the number of lines to scroll
			nlines *= _cWheelDelta/WHEEL_DELTA;

			//Perform some bounds checking
			nlines = min(_nViewSize - 1, nlines);
	        int nIdx = max(0, nlines + GetTopIndex());
	        nIdx = min(nIdx, _nCount - _nViewSize);        	
	        if (nIdx != GetTopIndex()) 
	        {
	        	// Scroll bar is based in pixels so figure-out the pixel value
	            OnVScroll(MAKELONG(SB_THUMBPOSITION, nIdx * _nyItem), 0);
	        }
		}		
        OnVScroll(MAKELONG(SB_ENDSCROLL, 0), 0);
        _cWheelDelta %= WHEEL_DELTA;
    }
    return lReturn;
 }

/*
 *	LRESULT CLstBxWinHost::OnLButtonUp(WPARAM, LPARAM, int)
 *
 *	@mfunc
 *		Handles the WM_LBUTTONUP and WM_CAPTURECHANGED message
 *
 *	#rdesc
 *		LRESULT = return value after message is processed
 */
 LRESULT CLstBxWinHost::OnLButtonUp(WPARAM wparam, LPARAM lparam, int ff)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnLButtonUp");

	// if mouse wasn't down then exit out
	if (!_fMouseDown)
		return 0;
	_fMouseDown = 0;

	POINT pt;
	POINTSTOPOINT(pt, lparam);
 	if (_fLstType == kCombo)
 	{
 		Assert(_fCapture);
 		// Check if user clicked outside the list box
 		// if so this signifies the user cancelled and we
 		// should send a message to the parentwindow
		if (!PointInRect(&pt))
 		{	
			//User didn't click in listbox so reselect old item
			LbSetSelection(_nOldCursor, _nOldCursor, LBSEL_DEFAULT, _nOldCursor, _nOldCursor);
			ff = 0;
 		}
 		else
			ff = LBN_SELCHANGE;	//item changed so notify parent
 		
 		_pcbHost->SetSelectionInfo(ff == LBN_SELCHANGE, GetCursor());
		OnCBTracking(LBCBM_END, 0);
		::PostMessage(_hwndParent, LBCB_TRACKING, LBCBM_END, 0);
 	}
 	else
 	{
 		// Kill any initializations done by mouse down... 
		_fMouseDown = 0;
		_nOldCursor = -1;
	}
	
 	if (_fCapture)
 	{
 		TxKillTimer(ID_LB_CAPTURE);
		_fCapture = 0;
 		TxSetCapture(FALSE); 	
 	}

	if (ff)
	{
#ifndef NOACCESSIBILITY
		if (ff == LBN_SELCHANGE)
		{
			_dwWinEvent = EVENT_OBJECT_FOCUS;
			_fNotifyWinEvt = TRUE;
			TxNotify(_dwWinEvent, NULL);
			if (!IsSelected(_nCursor))
			{
				_dwWinEvent = EVENT_OBJECT_SELECTIONREMOVE;
			}
		}
#endif
		// Send notification if a notification exists
		TxNotify(ff, NULL);
	}
	return 1;
 }

/*
 *	LRESULT CLstBxWinHost::OnMouseMove(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Handles the WM_MOUSEMOVE message and possibly the
 *		WM_TIMER message for tracking mouse movements
 *
 *	#rdesc
 *		LRESULT = return value after message is processed
 */
 LRESULT CLstBxWinHost::OnMouseMove(WPARAM wparam, LPARAM lparam)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnMouseMove");

	// bug fix #4998
 	// Check if previous mouse position is the same as current, if it is
 	// then this is probably a bogus message from PPT.
	POINT pt;
	POINTSTOPOINT(pt, lparam);
 	if (_nPrevMousePos == lparam && PtInRect(&_rcViewport, pt))
 		return 0;
 	_nPrevMousePos = lparam;
 	
 	// This routine will only start the autoscrolling of the listbox
 	// The autoscrolling is done using a timer where the and the elapsed
 	// time is determined by how far the mouse is from the top and bottom
 	// of the listbox.  The farther from the listbox the faster the timer
 	// will be.  This function relies on the timer to scroll and select
 	// items.	
	// We get here if mouse cursor is in the list box.
	int idx = GetItemFromPoint(&pt);

 	// We only do the following if mouse is down	
 	if (_fMouseDown)
 	{ 	
	 	int y = (short)pt.y;
		if (y < 0 || y > _rcViewport.bottom - 1)
		{	
		 	// calculate the new timer settings		 	
		 	int dist = y < 0 ? -y : (y - _rcViewport.bottom + 1);
		 	int nTimer = ID_LB_CAPTURE_DEFAULT - (int)((WORD)dist << 4);
				
			// Scroll up or down depending on the mouse pos relative
			// to the list box
			idx = (y <= 0) ? max(0, idx - 1) : min(_nCount - 1, idx + 1);
			if (idx >= 0 && idx < _nCount)
			{	
				// The ordering of this is VERY important to prevent screen
				// flashing...
				if (idx != _nCursor)
					MouseMoveHelper(idx, (_fLstType == kCombo) ? FALSE : TRUE);
				OnVScroll(MAKELONG((y < 0) ? SB_LINEUP : SB_LINEDOWN, 0), 0);
			}
			// reset timer
			TxSetTimer(ID_LB_CAPTURE, (5 > nTimer) ? 5 : nTimer);
			return 0;
		}
		// Don't select if we are part of a combo box and mouse is outside client area
		else if (_fLstType == kCombo && (pt.x < 0 || pt.x > _rcViewport.right - 1))
			return 0;
	}
	else if (!PointInRect(&pt))
	{
		return 0;		
	}
	
	if (idx != _nCursor || (_fLstType == kCombo && idx >= 0 && !IsSelected(idx)))
	{			
		// Prevent flashing by not redrawing if index
		// didn't change
		Assert(idx >= 0);
		MouseMoveHelper(idx, TRUE);
	}
	return 0;
 }
 
/*
 *	LRESULT CLstBxWinHost::OnLButtonDown(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Handles the WM_LBUTTONDOWN message
 *
 *	#rdesc
 *		LRESULT = return value after message is processed
 */
LRESULT CLstBxWinHost::OnLButtonDown(WPARAM wparam, LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnLButtonDown");
	
	POINT pt;
	POINTSTOPOINT(pt, lparam);

	if (_fCapture)
	{
		// Need to check if the listbox is part of a combobox, if so
		// then we need to notify the parent class.
		if (_fLstType == kCombo)
		{
			// Need to perform the following
			// - check if click is within client area of combo box if not then
			//		behave as if user cancelled
			if (!PointInRect(&pt))
			{
				// reset our double click flag because we could be double clicking on the scrollbar
				_fDblClick = 0;
				
				// check if the scroll bar was clicked
				// mouse message won't get posted unless we release it 
				// for a short while
				TxClientToScreen(&pt);				

				// check if user clicked on the scrollbar
				if (HTVSCROLL == SendMessage(_hwnd, WM_NCHITTEST, 0, MAKELONG(pt.x, pt.y)))
				{
					if (_fCapture)
					{
						_fCapture = 0;
						TxSetCapture(FALSE);
					}

					SendMessage(_hwnd, WM_NCLBUTTONDOWN, HTVSCROLL, MAKELONG(pt.x, pt.y));

					TxSetCapture(TRUE);
					_fCapture = 1;
				}
				else
				{
					// if user didn't click the scrollbar then notify parent and stop
					// tracking else just get out
					Assert(_pcbHost);
					_pcbHost->SetSelectionInfo(FALSE, _nOldCursor);
					LbSetSelection(_nOldCursor, _nOldCursor, LBSEL_RESET | 
						((_nOldCursor == -1) ? 0 : LBSEL_NEWCURSOR | LBSEL_SELECT), 
						_nOldCursor, _nOldCursor);
					OnCBTracking(LBCBM_END, 0);
					SendMessage(_hwndParent, LBCB_TRACKING, 0, 0);
				}				
				return 0;
			}
		}
	}	
	
	int idx = GetItemFromPoint(&pt);
	if (idx <= -1)
	{
		_fDblClick = 0;
		return 0;
	}

	_fMouseDown = 1;

	// if the message was a double click message than don't need to go
	// any further just fake a mouseup message to get back to a normal
	// state	
	if (_fDblClick)
	{
		_fDblClick = 0;
		OnLButtonUp(wparam, lparam, LBN_DBLCLK);
		return 0;
	}
		
	// Set the timer in case the user scrolls outside the listbox
	if (!_fCapture)
	{
		TxSetCapture(TRUE);
		_fCapture = 1;
		TxSetTimer(ID_LB_CAPTURE, ID_LB_CAPTURE_DEFAULT);	
	}

	int ffVirtKey = LBKEY_NONE;
	if (_fLstType == kExtended)
	{
		if (HIWORD(GetKeyState(VK_SHIFT)))
			ffVirtKey |= LBKEY_SHIFT;
		if (HIWORD(GetKeyState(VK_CONTROL)))
			ffVirtKey |= LBKEY_CONTROL;
	}

	int ff = 0;
	int i = 0;
	int nStart = idx;
	int nEnd = idx;
	int nAnchor = _nAnchor;
	switch (ffVirtKey)
	{	
	case LBKEY_NONE:
		// This case accounts for listbox styles with kSingle, kMultiple, and 
		// kExtended w/ no keys pressed
		if (_fLstType == kMultiple)
		{
			ff = (IsSelected(idx) ? 0 : LBSEL_SELECT) | LBSEL_NEWANCHOR | LBSEL_NEWCURSOR;			
		}
		else
		{
			// keep a copy of the old cursor position around for combo cancells			
			ff = LBSEL_DEFAULT;
		}
		nAnchor = idx;
		break;
		
	case LBKEY_SHIFT:		
		// Now select all the items between the anchor and the current selection
		// The problem is LbSetSelection expects the first index to be less then
		// or equal to the second index so we have to manage the Anchor and index
		// ourselves..				
		ff = LBSEL_SELECT | LBSEL_RESET | LBSEL_NEWCURSOR;
		i = !(IsSelected(_nAnchor));
		if (_nAnchor == -1)
		{
			ff |= LBSEL_NEWANCHOR;
			nAnchor = idx;
		}
		else if (_nAnchor > idx)
		{
			nEnd = _nAnchor - i;			
		}
		else if (_nAnchor < idx)
		{
			nEnd = _nAnchor + i;
		}
		else if (i) // _nAnchor == idx && idx IS selected
		{
			ff = LBSEL_RESET;
			nStart = 0;
			nEnd = 0;
		}
		break;
		
	case LBKEY_CONTROL:
		// Toggle the selected item and set the new anchor and cursor
		// positions
		ff = LBSEL_NEWCURSOR | LBSEL_NEWANCHOR | (IsSelected(idx) ? 0 : LBSEL_SELECT);
		nAnchor = idx;
		break;
		
	case LBKEY_SHIFTCONTROL:
		// De-select any items between the cursor and the anchor (excluding the anchor)
		// and select or de-select the new items between the anchor and the cursor

		// Set the anchor if it already isn't set
		if (_nAnchor == -1)
			_nAnchor = (_nOldCursor >= 0) ? _nOldCursor : idx;
			
		// Just deselect all items between the cursor and the anchor
		if (_nCursor != _nAnchor)
		{
			// remove selection from old cursor position to the current anchor position
			LbSetSelection(_nCursor, (_nCursor > _nAnchor) ? _nAnchor + 1 : _nAnchor - 1, 0, 0, 0);
		}

		// Check if we used a temporary anchor if so then set the anchor to
		// idx because we don't want the temporary anchor to be the actual anchor
		if (_nOldCursor >= 0)
		{
			_nOldCursor = -1;
			_nAnchor = idx;
		}

		// Set the state of all items between the new Cursor (idx) and 
		// the anchor to the state of the anchor
		ff = LBSEL_NEWCURSOR | (IsSelected(_nAnchor) ? LBSEL_SELECT : 0);
		nEnd = _nAnchor;
		break;
	default:
		Assert(FALSE && "Should not be here!!");		
	}

	if (LbSetSelection(nStart, nEnd, ff, idx, nAnchor))
	{
#ifndef NOACCESSIBILITY
		_dwWinEvent = EVENT_OBJECT_FOCUS;
		_fNotifyWinEvt = TRUE;
		TxNotify(_dwWinEvent, NULL);
#endif
	}

	return 0;
}

///////////////////////////  ComboBox Helper Functions  ////////////////////////////// 
/*
 * void CLstBxWinHost::OnCBTracking(WPARAM, LPARAM)
 *
 * @mfunc
 * 	This should be only called by the combo box.  This is a general message used
 *  to determine the state the listbox should be in
 * #rdesc
 *	void
 */
void CLstBxWinHost::OnCBTracking(WPARAM wparam, LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnCBTracking");

	Assert(_pcbHost);
	Assert(_hwndParent);

	switch (wparam)
	{
	// lparam = Set focus to listbox
	case LBCBM_PREPARE:
		Assert(IsWindowVisible(_hwnd));
		_fMouseDown = FALSE;		
		if (lparam & LBCBM_PREPARE_SAVECURSOR)
			_nOldCursor = GetCursor();
		if (lparam & LBCBM_PREPARE_SETFOCUS)
		{
			_fFocus = 1;
			TxSetFocus();
		}
		InitWheelDelta();
		break;

	// lparam = mouse is down
	case LBCBM_START:
		Assert(IsWindowVisible(_hwnd));
		_fMouseDown = !!lparam;
		TxSetCapture(TRUE);
		_fCapture = 1;
		break;		

	// lparam = Keep capture
	case LBCBM_END:
		TxKillTimer(ID_LB_CAPTURE);
		_fFocus = 0;
		if (_fCapture)
		{			
			_fCapture = FALSE;
			TxSetCapture(FALSE);
		}
		break;
	default:
		AssertSz(FALSE, "ALERT: Custom message being used by someone else");
	}	

}


///////////////////////////////  ListBox Functions  ////////////////////////////////// 
/*
 * void CLstBxWinHost::LbDeleteItemNotify(int, int)
 *
 * @mfunc
 * Sends message to the parent an item has been deleted.  This function should be
 *	called whenever the LB_DELETESTRING message is recieved or if the listbox is
 *	being destroyed and the listbox is owner draw
 *
 * #rdesc
 *	void
 */
void CLstBxWinHost::LbDeleteItemNotify(int nStart, int nEnd)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbDeleteItemNotify");
	
	// Initialize structure
	UINT ctlType;		
	DELETEITEMSTRUCT ds;
	switch (_fLstType)
	{
		case kSingle:
		case kMultiple:
		case kExtended:
			ctlType = ODT_LISTBOX;
			break;
		default:
			ctlType = ODT_COMBOBOX;
	}
	
	for(long i = nStart; i <= nEnd; i++)
	{		
		// We do this just in case the user decides to change
		// the structure
		ds.CtlType = ctlType;
		ds.CtlID = _idCtrl;
		ds.hwndItem = _hwnd;
		ds.itemData = GetData(i);
		ds.itemID = i;
		::SendMessage(_hwndParent, WM_DELETEITEM, _idCtrl, (LPARAM)&ds);
	}
}


/*
 * void CLstBxWinHost::LbDrawItemNotify(HDC, int, UINT, UINT)
 *
 * @mfunc
 * This fills the draw item struct with some constant data for the given
 * item.  The caller will only have to modify a small part of this data
 * for specific needs.
 *
 * #rdesc
 *	void
 */
void CLstBxWinHost::LbDrawItemNotify(HDC hdc, int nIdx, UINT itemAction, UINT itemState)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbDrawItemNotify");
	
	// Only send the message if the item is viewable
	if (!IsItemViewable(nIdx))
		return;
		
    //Fill the DRAWITEMSTRUCT with the unchanging constants
	DRAWITEMSTRUCT dis;
    dis.CtlType = ODT_LISTBOX;
    dis.CtlID = _idCtrl;

    // Use -1 if an invalid item number is being used.  This is so that the app
    // can detect if it should draw the caret (which indicates the lb has the
    // focus) in an empty listbox
    dis.itemID = (UINT)(nIdx < _nCount ? nIdx : -1);
    dis.itemAction = itemAction;
    dis.hwndItem = _hwnd;
    dis.hDC = hdc;
    dis.itemState = itemState |
            (UINT)(_fDisabled ? ODS_DISABLED : 0);

    // Set the app supplied data
    if (_nCount == 0) 
    {
        // If no items, just use 0 for data.  This is so that we
        // can display a caret when there are no items in the listbox.
        dis.itemData = 0L;
    } 
    else 
    {
    	Assert(nIdx < _nCount);
        dis.itemData = GetData(nIdx);
    }

	LbGetItemRect(nIdx, &(dis.rcItem));

    /*
     * Set the window origin to the horizontal scroll position.  This is so that
     * text can always be drawn at 0,0 and the view region will only start at
     * the horizontal scroll offset. We pass this as wparam
     */
    SendMessage(_hwndParent, WM_DRAWITEM, _idCtrl, (LPARAM)&dis);
}

/*
 *	BOOL CLstBxWinHost::LbSetItemHeight(int)
 *
 *	@mfunc
 *		Sets the height of the items within the given range [0, _nCount -1]
 *
 *	#rdesc
 *		BOOL = Successful ? TRUE : FALSE
 */
BOOL CLstBxWinHost::LbSetItemHeight(int nHeight)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbSetItemHeight");

	// Set the height of the items if there are between [1,255] : bug fix #4783
	if (nHeight < 256 && nHeight > 0)
	{
		if (SetItemsHeight(nHeight, FALSE))
		{
			//bug fix #4214
			//need to recalculate how many items are viewable, IN ITS ENTIRETY, 
			//using the current window size
			RECT rc;
			TxGetClientRect(&rc);
			_nViewSize = max(rc.bottom / max(_nyItem, 1), 1);		
			return TRUE;
		}
	}
	return FALSE;
}

/*
 *	BOOL CLstBxWinHost::LbGetItemRect(int, RECT*)
 *
 *	@mfunc
 *		Returns the rectangle coordinates of a requested index
 *		The coordinates will be in client coordinates
 *
 *	#rdesc
 *		BOOL = Successful ? TRUE : FALSE
 */
BOOL CLstBxWinHost::LbGetItemRect(int idx, RECT* prc)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbGetItemRect");

	Assert(prc);
	Assert(idx >= -1);

#ifdef _DEBUG
	if (_nCount > 0)
		Assert(idx < _nCount);
	else
		Assert(idx == _nCount);
#endif //_DEBUG

	if (idx == -1)
		idx = 0;

	TxGetClientRect(prc);
	prc->top = (idx - GetTopIndex()) * _nyItem + _rcViewport.top;
	prc->left = 0; 
	prc->bottom = prc->top + _nyItem;

	return TRUE;
}

	
/*
 *	BOOL CLstBxWinHost::LbSetItemData(long, long, long)
 *
 *	@mfunc
 *		Given a range [nStart,nEnd] the data for these items
 *		will be set to nValue
 *	#rdesc
 *		void
 */
void CLstBxWinHost::LbSetItemData(long nStart, long nEnd, long nValue)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbSetItemData");
	
	Assert(nStart >= 0 && nStart < _nCount);
	Assert(nEnd >= 0 && nEnd < _nCount);
	Assert(nStart <= nEnd);
	
	int nMin = min(nEnd + 1, _nCount);
	for (int i = nStart; i < nMin; i++)
		_rgData[i]._dwData = nValue;
}

/*
 *	long CLstBxWinHost::LbDeleteString(long, long)
 *
 *	@mfunc
 *		Delete the string at the requested range.
 *	#rdesc
 *		long = # of items in the list box.  If failed -1
 */
 long CLstBxWinHost::LbDeleteString(long nStart, long nEnd)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbDeleteString");
 	
 	if ((nStart > nEnd) || (nStart < 0) || (nEnd >= _nCount))
		return -1;

	if (!RemoveString(nStart, nEnd))
		return -1;

	// set the top index to fill the window
	LbSetTopIndex(max(nStart -1, 0));

#ifndef NOACCESSIBILITY
		_dwWinEvent = EVENT_OBJECT_DESTROY;
		_fNotifyWinEvt = TRUE;
		TxNotify(_dwWinEvent, NULL);
#endif
		
	return _nCount;
 }
 
/*
 *	CLstBxWinHost::LbInsertString(long, LPCTSTR)
 *
 *	@mfunc
 *		Insert the string at the requested index.  If long >= 0 then the
 *	string insertion is at the requested index. If long == -2 insertion
 *	is at the position which the string would be alphabetically in order.
 *	If long == -1 then string is added to the bottom of the list
 *
 *	#rdesc
 *		long = If inserted, the index (paragraph) which the string
 *			was inserted.  If not inserted returns -1;
 */
long CLstBxWinHost::LbInsertString(long nIdx, LPCTSTR szText)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbInsertString");

	Assert(nIdx >= -2);
	Assert(szText);
	
	if (nIdx == -2)
	{
		if (_nCount > 0)
			nIdx = GetSortedPosition(szText, 0, _nCount - 1);
		else
			nIdx = 0; //nothing inside listbox
	}
	else if (nIdx == -1)
		nIdx = GetCount();	// Insert string to the bottom of list if -1

	if (InsertString(nIdx, szText))
	{
		// If the index was previously selected unselect the newly 
		// added item
		for (int i = _nCount - 1; i > nIdx; i--)
		{
			_rgData[i]._fSelected = _rgData.Get(i - 1)._fSelected;

			// bug fix #4916
			_rgData[i]._dwData = _rgData.Get(i - 1)._dwData;
		}
		_rgData[nIdx]._fSelected = 0;
		_rgData[nIdx]._dwData = 0;		// Need to Initialize data back to zero

		if (!_fOwnerDraw)
		{
			// if we inserted at the middle or top then check 1 index down to see if the item
			// was selected, if we inserted at the bottom then check 1 index up to see if the item
			// was selected.  If the item was selected we need to change the colors to default
			// because we inherit the color properties from the range which we inserted into
			if (_nCount > 1)
			{
				if (((nIdx < _nCount - 1) && _rgData.Get(nIdx + 1)._fSelected) ||
					(nIdx == (_nCount - 1) && _rgData.Get(nIdx - 1)._fSelected))
					SetColors((unsigned)tomAutoColor, (unsigned)tomAutoColor, nIdx, nIdx);
			}
		}
		else
		{					
			// Force redraw of items if owner draw and new item is viewable
			if (IsItemViewable(nIdx))
			{
				RECT rc;
				LbGetItemRect(nIdx, &rc);
				rc.bottom = _rcViewport.bottom;
				InvalidateRect(_hwnd, &rc, TRUE);
			}
		}
#ifndef NOACCESSIBILITY
		_dwWinEvent = EVENT_OBJECT_CREATE;
		_fNotifyWinEvt = TRUE;
		_nAccessibleIdx = nIdx + 1;
		TxNotify(_dwWinEvent, NULL);
#endif
		return nIdx;
	}
	else
	{
		TxNotify((unsigned long)LBN_ERRSPACE, NULL);
		return -1;
	}
}
 
/*
 *	CLstBxWinHost::LbFindString(long, LPCTSTR, BOOL)
 *
 *	@mfunc
 *		Searches the story for a given string.  The
 *		starting position will be determined by the index nStart.
 *		This routine expects the units to be in tomParagraph.
 *		If bExact is TRUE then the paragraph must match the BSTR.
 *
 *	#rdesc
 *		long = If found, the index (paragraph) which the string
 *			was found in.  If not found returns -1;
 */
long CLstBxWinHost::LbFindString(long nStart, LPCTSTR szSearch, BOOL bExact)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbFindString");

	Assert(szSearch);
	Assert(nStart <= _nCount);
	
	int nSize = wcslen(szSearch);
	// If string is empty and not finding exact match then just return -1 like
	// the system control.  We don't have to worry about the exact match case
	// because it will work properly
	if (nStart >= _nCount || (nSize == 0 && !bExact))
		return -1;

	// allocate string buffer into stack
	WCHAR sz[1024];
	WCHAR *psz = sz;
	
	if ((nSize + 3) > 1024)
		psz = new WCHAR[nSize + 3 /* 2 paragraphs and a NULL*/];
	Assert(psz);

	if (psz == NULL)
	{
		TxNotify((unsigned long)LBN_ERRSPACE, NULL);
		return FALSE;
	}

	// format the string the way we need it
	wcscpy(psz, szCR);
	wcscat(psz, szSearch);
	if (bExact)
		wcscat(psz, szCR);		
	long lRet = -1;
	long l, cp;
	ITextRange *pRange = NULL;
	BSTR bstrQuery = SysAllocString(psz);
	if(!bstrQuery)
		goto CleanExit;
	if (psz != sz)
		delete [] psz;
	
	// Set starting position for the search
	if (!GetRange(nStart, _nCount - 1, &pRange))
	{
		SysFreeString(bstrQuery);
		return lRet;
	}
	
	CHECKNOERROR(pRange->GetStart(&cp));
	if (cp > 0)
	{
		// We need to use the paragraph marker from the previous
		// paragraph when searching for a string
		CHECKNOERROR(pRange->SetStart(--cp));	
	}
	else
	{
		// Special case:
		// Check if the first item matchs
		if (FindString(0, szSearch, bExact))
		{
			lRet = 0;
			goto CleanExit;
		}
	}

	if (NOERROR != pRange->FindTextStart(bstrQuery, 0, FR_MATCHALEFHAMZA | FR_MATCHKASHIDA | FR_MATCHDIAC, &l))
	{
		// Didn't find the string...
		if (nStart > 0)
		{
			if (!FindString(0, szSearch, bExact))
			{
				// Start the search from top of list to the point where
				// we last started the search			
				CHECKNOERROR(pRange->SetRange(0, ++cp));
				CHECKNOERROR(pRange->FindTextStart(bstrQuery, 0, 0, &l));
			}
			else
			{
				// First item was a match
				lRet = 0;
				goto CleanExit;
			}
		}
		else
			goto CleanExit;
	}

	// If we got down here then we have a match.
	// Get the index and convert to listbox index
	CHECKNOERROR(pRange->MoveStart(tomCharacter, 1, &l));
	CHECKNOERROR(pRange->GetIndex(tomParagraph, &lRet));
	lRet--;	// index is 1 based so we need to changed it to zero based

CleanExit:
	if (bstrQuery)
		SysFreeString(bstrQuery);
	if (pRange)
		pRange->Release();
	return lRet;
 }
 
/*
 *	CLstBxWinHost::LbShowIndex(int, BOOL)
 *
 *	@mfunc
 *		Makes sure the requested index is within the viewable space.
 *		In cases where the item is not in the viewable space bTop is
 *		used to determine the requested item should be at the top
 *		of the list else list box will scrolled enough to display the
 *		item.
 *		NOTE:
 *			There can be situations where bTop will fail.  These 
 *		situations occurr of the top index requested prevents the list
 *		box from being completely filled with items.  For more info
 *		read the comments for LBSetTopIndex.
 *
 *	#rdesc
 *		BOOL = Successfully displays the item ? TRUE : FALSE
 */
 BOOL CLstBxWinHost::LbShowIndex(long nIdx, BOOL bTop)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbShowIndex");

	// Make sure the requested item is within valid bounds
	Assert(nIdx >= 0 && nIdx < _nCount);
	
	int delta = nIdx - GetTopIndex();

	// If item is already visible then just return TRUE
	if (0 <= delta && delta < _nViewSize)
		return TRUE;

	if ((delta) >= _nViewSize && !bTop && _nViewSize)
	{
		nIdx = nIdx - _nViewSize + 1;
	}

	return (LbSetTopIndex(nIdx) < 0) ? FALSE : TRUE;
 }

/*
 *	CLstBxWinHost::LbSetTopIndex(long)
 *
 *	@mfunc
 *		Tries to make the requested item the top index in the list box.
 *		If making the requested item the top index prevents the list box
 *		from using the viewable region to its fullest then and alternative
 *		top index will be used which will display the requested index
 *		but NOT as the top index.  This ensures conformancy with the system
 *		list box and makes full use of the dislayable region.
 *
 *	#rdesc
 *		long = returns the new top index if successful.  If failed returns -1
 */
 long CLstBxWinHost::LbSetTopIndex(long nIdx)
 {
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbSetTopIndex");
		
	// Make sure the requested item is within valid bounds
 	if (nIdx < 0 || nIdx >= _nCount)
 		return -1;
		
	// Always try to display a full list of items in the list box
	// This may mean we have to adjust the requested top index if
	// the requested top index will leave blanks at the end of the
	// viewable space
	if (_nCount - _nViewSize < nIdx)
		nIdx = max(0, _nCount - _nViewSize);

	// Just check to make sure we not already at the top 
	if (GetTopIndex() == nIdx)
		return nIdx;

	if (!SetTopViewableItem(nIdx))
		nIdx = -1;

	return nIdx;
 }

/*
 *	CLstBxWinHost::LbBatchInsert(WCHAR* psz)
 *
 *	@mfunc
 *		Inserts the given list of items into listbox.  The listbox is reset prior to adding
 *	the items into the listbox
 *
 *	#rdesc
 *		int = # of items in the listbox if successful else LB_ERR
 */
int CLstBxWinHost::LbBatchInsert(WCHAR* psz)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbBatchInsert");

	// make sure we get some sort of string
	if (!psz)
		return LB_ERR;
		
	WCHAR* pszOut = psz;
	LRESULT nRet = LB_ERR;
	BSTR bstr = NULL;
	ITextRange* pRange = NULL;
	int nCount = 0;
	
	if (_fSort)
	{
		pszOut = new WCHAR[wcslen(psz) + 1];
		Assert(pszOut);

		if (!pszOut)
		{
			TxNotify((unsigned long)LBN_ERRSPACE, NULL);
			return LB_ERR;
		}

		nCount = SortInsertList(pszOut, psz);
		if (nCount == LB_ERR)
			goto CleanExit;
	}
	else
	{
		//bug fix #5130 we need to know how much we are going to insert
		//prior to inserting because we may be getting showscrollbar message
		//during insertion
		WCHAR* pszTemp = psz;
		while(*pszTemp)
		{
			if (*pszTemp == L'\r')
				nCount++;
			pszTemp++;
		}
		nCount++;
	}

	//clear listbox and insert new list into listbox
	LbDeleteString(0, GetCount() - 1);

	bstr = SysAllocString(pszOut);
	if(!bstr)
		goto CleanExit;
	
	// Insert string into list	
	CHECKNOERROR(((CTxtEdit*)_pserv)->Range(0, 0, &pRange));

	//bug fix #5130
	// preset our _nCount for scrollbar purposes
	_nCount = nCount;	
	CHECKNOERROR(pRange->SetText(bstr));

#ifdef DEBUG
    // We can't trust the code below because ITextServices performs a background recalc
    // and so returns the incorrect line count
	// update our count
	// I'm leaving it here for debugging purposes of ITextServices
	_pserv->TxSendMessage(EM_GETLINECOUNT, 0, 0, &nRet);
	AssertSz(_nCount == nRet, "Textserv line count doesn't match listbox interal line count");
#endif
    nRet = nCount;

CleanExit:
	if (pszOut != psz)
		delete [] pszOut;

	if (bstr)
		SysFreeString(bstr);

	if (pRange)
		pRange->Release();
	return nRet;
}


 

/*
 *	CLstBxWinHost::LbSetSelection(long, long, int)
 *
 *	@mfunc
 *		Given the range of nStart to nEnd set the selection state of each item
 *		This function will also update the anchor and cursor position
 *		if requested.
 *
 *	#rdesc
 *		BOOL = If everything went fine ? TRUE : FALSE
 */
BOOL CLstBxWinHost::LbSetSelection(long nStart, long nEnd, int ffFlags, long nCursor, long nAnchor)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbSetSelection");

	if (!_fOwnerDraw)
	{
		Freeze();
	
		// de-select all items
		if ((ffFlags & LBSEL_RESET))
		{
			if (!ResetContent())
			{
				Unfreeze();
				return FALSE;
			}

			// Reset, check if anything else needs to be done
			// else just exit out
			if (ffFlags == LBSEL_RESET)
			{
				Unfreeze();
				return TRUE;
			}
		}
	}
	
	// NOTE:
	//	This should be one big critical section because we rely on certain
	// member variables not changing during the process of this function

	// Check if we are changing the selection and if we have focus
	// if we do then we first need to xor out the focus rect from
	// old cursor
	RECT rc;
	HDC hdc;
	hdc = TxGetDC();
	Assert(hdc);
	// don't draw outside the client rect draw the rectangle
	TxGetClientRect(&rc);
	IntersectClipRect(hdc, rc.left, rc.top, rc.right, rc.bottom);

	if ((ffFlags & LBSEL_NEWCURSOR) && _fFocus)
	{
 		// If owner draw notify parentwindow
 		if (_fOwnerDraw)
 			LbDrawItemNotify(hdc, max(_nCursor, 0), ODA_FOCUS, IsSelected(_nCursor) ? ODS_SELECTED : 0);				
 		else
 		{
 			LbGetItemRect(_nCursor, &rc);
 			::DrawFocusRect(hdc, &rc);
 		}
	}
		
	//	check if all item should be selected
	if (nStart == -1 && nEnd == 0)
	{
		nStart = 0;
		nEnd = _nCount - 1;
	}
	else if (nStart > nEnd)	
	{
		// reshuffle so nStart is <= nEnd;
		long temp = nEnd;
		nEnd = nStart;
		nStart = temp;
	}

	// Check for invalid values
	if (nStart < -1 || nEnd >= _nCount)
	{
		if (!_fOwnerDraw)
			Unfreeze();

		// mimic system listbox behaviour
		if (nEnd >= _nCount)
			return FALSE;
		else
			return TRUE;
	}

	// Prepare the state we want to be in
	unsigned int bState;	
	DWORD dwFore;
	DWORD dwBack;
	if (ffFlags & LBSEL_SELECT)
	{
		bState = ODS_SELECTED;	//NOTE ODS_SELECTED must equal 1
		dwFore = _crSelFore;
		dwBack = _crSelBack;

		if (_fSingleSel)
			nEnd = nStart;
	}
	else 
	{
		bState = 0;
		dwFore = (unsigned)tomAutoColor;
		dwBack = (unsigned)tomAutoColor;
	}

	// A little optimization check
	// Checks to see if the state is really being changed if not then don't bother
	// calling SetColor, works only when nStart == nEnd;
	// The list box will not change the background color if nSame is true
	int nSame = (nStart == nEnd && nStart != -1) ? (_rgData.Get(nStart)._fSelected == bState) : FALSE;

	BOOL bRet = TRUE;
	if (_fOwnerDraw)
	{
		if (ffFlags & LBSEL_RESET || !bState)
		{
			// There are cases where we don't necessarily reset all the items
			// in the list but rather the range which was given.  The following
			// takes care of this case
			int ff = ffFlags & LBSEL_RESET;
			int i = (ff) ? 0 : nStart;
			int nStop = (ff) ? _nCount : nEnd + 1;
		 	for (; i < nStop; i++)
		 	{
		 		// Don't unselect an item which is going to be
		 		// selected in the next for loop
		 		if (!bState || (i < nStart || i > nEnd) &&
		 			(_rgData.Get(i)._fSelected != 0))
		 		{
		 			// Only send a unselect message if the item
		 			// is viewable
		 			_rgData[i]._fSelected = 0;
			 		if (IsItemViewable(i))
			 			LbDrawItemNotify(hdc, i, ODA_SELECT, 0);			 		
			 	}
		 	}
		}

		if (bState)
		{
			// We need to loop through and notify the parent
			// The item has been deselected or selected
			for (int i = max(0, nStart); i <= nEnd; i++)
			{		
				if (_rgData.Get(i)._fSelected != 1)
				{
					_rgData[i]._fSelected = 1;
					if (IsItemViewable(i))
						LbDrawItemNotify(hdc, i, ODA_SELECT, ODS_SELECTED);					
				}
			}
		}
		
	}
	else if (!nSame)
	{
		// Update our internal records	
		for (int i = max(0, nStart); i <= nEnd; i++)
			_rgData[i]._fSelected = bState;	
		bRet = SetColors(dwFore, dwBack, nStart, nEnd);
	}

    // Update the cursor and anchor positions
	if (ffFlags & LBSEL_NEWANCHOR)
		_nAnchor = nAnchor;

	// Update the cursor position
	if (ffFlags & LBSEL_NEWCURSOR)
		_nCursor = nCursor;

	// Draw the focus rect
	if (_fFocus)
	{
		if (_fOwnerDraw)
 			LbDrawItemNotify(hdc, _nCursor, ODA_FOCUS, ODS_FOCUS | 
 				(IsSelected(_nCursor) ? ODS_SELECTED : 0));	
 		else
 		{
			LbGetItemRect(_nCursor, &rc);
	 		::DrawFocusRect(hdc, &rc);
	 	} 		
	}

	TxReleaseDC(hdc);
		
	// This will automatically update the window
	if (!_fOwnerDraw)
	{
		Unfreeze();
		// We need to do this because we are making so many changes
		// ITextServices might get confused
		ScrollToView(GetTopIndex());		
	}
	
	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\ime.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module ime.cpp -- support for Win95 IME API |
 *	
 *		Most everything to do with FE composition string editing passes
 *		through here.
 *	
 *	Authors: <nl>
 *		Jon Matousek <nl>
 *		Hon Wah Chan <nl>
 *		Justin Voskuhl <nl>
 * 
 *	History: <nl>
 *		10/18/1995		jonmat	Cleaned up level 2 code and converted it into
 *								a class hierarchy supporting level 3.
 *
 *	Copyright (c) 1995-1997 Microsoft Corporation. All rights reserved.
 */				
#include "_common.h"
#include "_cmsgflt.h"				 
#include "_ime.h"
#include "imeapp.h"

#define HAVE_COMPOSITION_STRING() ( 0 != (lparam & (GCS_COMPSTR | GCS_COMPATTR)))
#define CLEANUP_COMPOSITION_STRING() ( 0 == lparam )
#define HAVE_RESULT_STRING() ( 0 != (lparam & GCS_RESULTSTR))

ASSERTDATA

/*
 *	HRESULT StartCompositionGlue (CTextMsgFilter &TextMsgFilter)
 *	
 *	@func
 *		Initiates an IME composition string edit.
 *	@comm
 *		Called from the message loop to handle WM_IME_STARTCOMPOSITION.
 *		This is a glue routine into the IME object hierarchy.
 *
 *	@devnote
 *		We decide if we are going to do a level 2 or level 3 IME
 *		composition string edit. Currently, the only reason to 
 *		create a level 2 IME is if the IME has a special UI, or it is
 *		a "near caret" IME, such as the ones found in PRC and Taiwan.
 *		Near caret simply means that a very small window opens up
 *		near the caret, but not on or at the caret.
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT StartCompositionGlue (
	CTextMsgFilter &TextMsgFilter)				// @parm containing message filter.

{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "StartCompositionGlue");

	if(TextMsgFilter.IsIMEComposition() && TextMsgFilter._ime->IsTerminated())
	{
		delete TextMsgFilter._ime;
		TextMsgFilter._ime = NULL;
	}

	if(!TextMsgFilter.IsIMEComposition())
	{
		if(TextMsgFilter._pTextSel->CanEdit(NULL) == NOERROR &&
			!(TextMsgFilter._lFEFlags & ES_NOIME))
		{
			// Hold notification if needed
			if (!(TextMsgFilter._fIMEAlwaysNotify))
				TextMsgFilter._pTextDoc->SetNotificationMode(tomFalse);	
	
			// If a special UI, or IME is "near caret", then drop into lev. 2 mode.
			DWORD imeProperties = ImmGetProperty(GetKeyboardLayout(0x0FFFFFFFF), IGP_PROPERTY, TextMsgFilter._fUsingAIMM);
			
			// use Unicode if not running under Win95
			TextMsgFilter._fUnicodeIME =
				(imeProperties & IME_PROP_UNICODE) && !W32->OnWin95();

			if ((imeProperties & IME_PROP_SPECIAL_UI) ||
				!(imeProperties & IME_PROP_AT_CARET))
			{
				TextMsgFilter._ime = new CIme_Lev2(TextMsgFilter);		// level 2 IME.
			}
			else
				TextMsgFilter._ime = new CIme_Lev3(TextMsgFilter);		// level 3 IME->TrueInline.
		}
		else													// Protect or read-only or NOIME:
			TextMsgFilter._ime = new CIme_Protected;			// Ignore all ime input
	}
	else
	{
		// Ignore further StartCompositionMsg.
		// Hanin 5.1 CHT symbol could cause multiple StartCompoisitonMsg.
		return S_OK;								
	}

	if(TextMsgFilter.IsIMEComposition())					
	{
		long		lSelFlags;
		HRESULT		hResult;
		
		hResult = TextMsgFilter._pTextSel->GetFlags(&lSelFlags);
		if (hResult == NOERROR)
		{
			TextMsgFilter._fOvertypeMode = !!(lSelFlags & tomSelOvertype);		
			if (TextMsgFilter._fOvertypeMode)
				TextMsgFilter._pTextSel->SetFlags(lSelFlags & ~tomSelOvertype);	// Turn off overtype mode
		}
		
		TextMsgFilter._pTextDoc->IMEInProgress(tomTrue);				// Inform client IME compostion in progress

		return TextMsgFilter._ime->StartComposition(TextMsgFilter);		// Make the method call.
	}
	else
		TextMsgFilter._pTextDoc->SetNotificationMode(tomTrue);

	
	return S_FALSE;
}

/*
 *	HRESULT CompositionStringGlue (const LPARAM lparam, CTextMsgFilter &TextMsgFilter)
 *	
 *	@func
 *		Handle all intermediary and final composition strings.
 *
 *	@comm
 *		Called from the message loop to handle WM_IME_COMPOSITION.
 *		This is a glue routine into the IME object hierarchy.
 *		We may be called independently of a WM_IME_STARTCOMPOSITION
 *		message, in which case we return S_FALSE to allow the
 *		DefWindowProc to return WM_IME_CHAR messages.
 *
 *	@devnote
 *		Side Effect: the _ime object may be deleted if composition
 *		string processing is finished.
 *		
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT CompositionStringGlue (
	const LPARAM lparam,		// @parm associated with message.
	CTextMsgFilter &TextMsgFilter)				// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CompositionStringGlue");

	HRESULT hr = S_FALSE;

	if(TextMsgFilter.IsIMEComposition())						// A priori fHaveIMMProcs.
	{
		TextMsgFilter._ime->_compMessageRefCount++;			// For proper deletion.
													// Make the method call.
		hr = TextMsgFilter._ime->CompositionString(lparam, TextMsgFilter);

		TextMsgFilter._ime->_compMessageRefCount--;			// For proper deletion.
		Assert (TextMsgFilter._ime->_compMessageRefCount >= 0);

		CheckDestroyIME (TextMsgFilter);						// Finished processing?
	}
	else // even when not in composition mode, we may receive a result string.
	{
	
		DWORD imeProperties = ImmGetProperty(GetKeyboardLayout(0x0FFFFFFFF), IGP_PROPERTY, TextMsgFilter._fUsingAIMM);
		long		lSelFlags;
		HRESULT		hResult;
		long		cpMin, cpMax;

		TextMsgFilter._pTextDoc->IMEInProgress(tomTrue);				// Inform client IME compostion in progress

		hResult = TextMsgFilter._pTextSel->GetFlags(&lSelFlags);
		if (hResult == NOERROR)
		{
			TextMsgFilter._fOvertypeMode = !!(lSelFlags & tomSelOvertype);		
			if (TextMsgFilter._fOvertypeMode)
				TextMsgFilter._pTextSel->SetFlags(lSelFlags & ~tomSelOvertype);	// Turn off overtype mode
		}

		// use Unicode if not running under Win95
		TextMsgFilter._fUnicodeIME =
			(imeProperties & IME_PROP_UNICODE) && !W32->OnWin95();
		
		TextMsgFilter._pTextSel->GetStart(&cpMin);
		TextMsgFilter._pTextSel->GetEnd(&cpMax);
		
		if (cpMin != cpMax)			
			TextMsgFilter._pTextSel->SetText(NULL);							// Delete current selection

		CIme::CheckKeyboardFontMatching (cpMin, TextMsgFilter, NULL);
		hr = CIme::CheckInsertResultString(lparam, TextMsgFilter);

		if(TextMsgFilter._fOvertypeMode)
			TextMsgFilter._pTextSel->SetFlags(lSelFlags | tomSelOvertype);	// Turn on overtype mode

		TextMsgFilter._pTextDoc->IMEInProgress(tomFalse);					// Inform client IME compostion is done
	}

	return hr;
}

/*
 *	HRESULT EndCompositionGlue (CTextMsgFilter &TextMsgFilter, BOOL fForceDelete)
 *
 *	@func
 *		Composition string processing is about to end.
 *
 *	@comm
 *		Called from the message loop to handle WM_IME_ENDCOMPOSITION.
 *		This is a glue routine into the IME object hierarchy.
 *
 *	@devnote
 *		The only time we have to handle WM_IME_ENDCOMPOSITION is when the
 *		user changes input method during typing.  For such case, we will get
 *		a WM_IME_ENDCOMPOSITION message without getting a WM_IME_COMPOSITION
 *		message with GCS_RESULTSTR later.  So, we will call CompositionStringGlue
 *		with GCS_RESULTSTR to let CompositionString to get rid of the string. 
 *		
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT EndCompositionGlue (
	CTextMsgFilter &TextMsgFilter,				// @parm the containing message filter.
	BOOL fForceDelete)							// @parm forec to terminate
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "EndCompositionGlue");

	if(TextMsgFilter.IsIMEComposition())
	{
		// ignore the EndComposition message if necessary.  We may 
		// get this from 3rd party IME - EGBRIGDE after we have received
		// both result and composition strings.  
		if ( !(TextMsgFilter._ime->_fIgnoreEndComposition) )
		{
			// Set this flag. If we are still in composition mode, then
			// let the CompositionStringGlue() to destroy the ime object.
			TextMsgFilter._ime->_fDestroy = TRUE;

			if (!fForceDelete)				
				CompositionStringGlue(GCS_COMPSTR , TextMsgFilter);	// Remove any remaining composition string.

			// Finished with IME, destroy it.
			CheckDestroyIME(TextMsgFilter);

			// Turn on undo
			TextMsgFilter._pTextDoc->Undo(tomResume, NULL);

			// Inform client IME compostion is done
			TextMsgFilter._pTextDoc->IMEInProgress(tomFalse);				
		}
		else
		{
			// reset this so we will handle next EndComp msg
			TextMsgFilter._ime->_fIgnoreEndComposition = FALSE;
		}

		if(!TextMsgFilter.IsIMEComposition() && TextMsgFilter._fOvertypeMode)
		{
			long		lSelFlags;
			HRESULT		hResult;
			ITextSelection	*pLocalTextSel = TextMsgFilter._pTextSel;
			BOOL		fRelease = FALSE;

			if (!pLocalTextSel)
			{
				// Get the selection
				TextMsgFilter._pTextDoc->GetSelectionEx(&pLocalTextSel);
				fRelease = TRUE;
			}

			if (pLocalTextSel)
			{
				hResult = pLocalTextSel->GetFlags(&lSelFlags);
				if (hResult == NOERROR)
					pLocalTextSel->SetFlags(lSelFlags | tomSelOvertype);	// Turn on overtype mode

				if (fRelease)
					pLocalTextSel->Release();
			}
		}
	}
	return S_FALSE;
}

/*
 *	HIMC LocalGetImmContext ( CTextMsgFilter &TextMsgFilter )
 *
 *	@func
 *		Get Imm Context from host 
 *
 */
HIMC LocalGetImmContext(
	CTextMsgFilter &TextMsgFilter)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "IMEMessage");
	
	HIMC		hIMC = NULL;							// Host's IME context.
	HRESULT		hResult;

	hResult = TextMsgFilter._pTextDoc->GetImmContext((long *)&hIMC);

	if (hResult != NOERROR)
		hIMC = ImmGetContext(TextMsgFilter._hwnd);		// Get host's IME context.

	return hIMC;	
}

/*
 *	void LocalReleaseImmContext ( CTextMsgFilter &TextMsgFilter, HIMC hIMC )
 *
 *	@func
 *		call host to Release Imm Context
 *
 */
void LocalReleaseImmContext(
	CTextMsgFilter &TextMsgFilter, 
	HIMC hIMC )
{
	HRESULT		hResult;

	hResult = TextMsgFilter._pTextDoc->ReleaseImmContext((long)hIMC);

	if (hResult != NOERROR)
		ImmReleaseContext(TextMsgFilter._hwnd, hIMC);
}

/*
 *	long IMEShareToTomUL ( UINT ulID )
 *
 *	@func
 *		Convert IMEShare underline to Tom underline.
 *
 *	@rdesc
 *		Tom underline value
 */
long IMEShareToTomUL ( 
	UINT ulID )
{
	long lTomUnderline;

	switch (ulID)
	{
		case IMESTY_UL_NONE:
			lTomUnderline = tomNone;
			break;

		case IMESTY_UL_DOTTED:
			lTomUnderline = tomDotted;
			break;

		case IMESTY_UL_THICK:
		case IMESTY_UL_THICKLOWER:
			lTomUnderline = tomThick;
			break;

		case IMESTY_UL_DITHLOWER:
		case IMESTY_UL_THICKDITHLOWER:
			lTomUnderline = tomWave;
			break;

		// case IMESTY_UL_SINGLE:
		// case IMESTY_UL_LOWER:
		default:
			lTomUnderline = tomSingle;
			break;
	}

	return lTomUnderline;
}

/*
 *	void IMEMessage (CTextMsgFilter &TextMsgFilter , UINT uMsg, BOOL bPostMessage)
 *
 *	@func
 *		Either post or send message to IME 
 *
 */
BOOL IMEMessage(
	CTextMsgFilter &TextMsgFilter,
	UINT uMsg,
	WPARAM	wParam,
	LPARAM	lParam,
	BOOL bPostMessage)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "IMEMessage");
	
	HIMC	hIMC;									// Host's IME context.
	HWND	hwndIME;
	BOOL	retCode = FALSE;
	HWND	hHostWnd = TextMsgFilter._hwnd;
	long	hWnd;

	if (!hHostWnd)									// Windowless mode...
	{		
		if (TextMsgFilter._pTextDoc->GetWindow(&hWnd) != S_OK || !hWnd)
			return FALSE;
		hHostWnd = (HWND)(DWORD_PTR)hWnd;
	}

	hIMC = LocalGetImmContext(TextMsgFilter);		// Get host's IME context.

	if(hIMC)
	{
		hwndIME = ImmGetDefaultIMEWnd(hHostWnd, TextMsgFilter._fUsingAIMM);
		LocalReleaseImmContext(TextMsgFilter, hIMC);

		// check if we want to send or post message
		if (hwndIME)
		{
			if (bPostMessage)
				retCode = PostMessage(hwndIME, uMsg, wParam, lParam);
			else
				retCode = SendMessage(hwndIME, uMsg, wParam, lParam);
		}
	}

	return retCode;
}


/*
 *	void CheckDestroyIME (CTextMsgFilter &TextMsgFilter)
 *
 *	@func
 *		Check for IME and see detroy if it needs it..
 *
 */
void CheckDestroyIME (
	CTextMsgFilter &TextMsgFilter)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CheckDestroyIME");
	
	if(TextMsgFilter.IsIMEComposition() && TextMsgFilter._ime->_fDestroy)
	{
		if(0 == TextMsgFilter._ime->_compMessageRefCount)
		{
			if (TextMsgFilter._uKeyBoardCodePage == CP_KOREAN)	
			{
				TextMsgFilter._pTextDoc->SetCaretType(tomNormalCaret);		// Reset Block caret mode	
				TextMsgFilter._fHangulToHanja = FALSE;					// Reset korean conversion mode
			}

		 	delete TextMsgFilter._ime;									// All done with object.
			TextMsgFilter._ime = NULL;

			TextMsgFilter._pTextDoc->SetNotificationMode(tomTrue);		// Turn on Notification
		}
	}
}

/*
 *	void PostIMECharGlue (CTextMsgFilter &TextMsgFilter)
 *
 *	@func
 *		Called after processing a single WM_IME_CHAR in order to
 *		update the position of the IME's composition window. This
 *		is glue code to call the CIME virtual equivalent.
 */
void PostIMECharGlue (
	CTextMsgFilter &TextMsgFilter)				// @parm containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "PostIMECharGlue");

	if(TextMsgFilter.IsIMEComposition())
		TextMsgFilter._ime->PostIMEChar(TextMsgFilter);
}

/*
 *	BOOL	IMEMouseCheck(CTextMsgFilter &TextMsgFilter, UINT *pmsg, 
 *				WPARAM *pwparam, LPARAM *plparam, LRESULT *plres)
 *
 *	@func
 *		Called when receiving a mouse event.  Need to pass this event
 *		to MSIME98 for composition handling
 *
 */
HRESULT IMEMouseCheck(
	CTextMsgFilter &TextMsgFilter,	// @parm MsgFilter
	UINT *pmsg,						// @parm the message 
	WPARAM *pwparam,				// @parm WParam
	LPARAM *plparam,				// @parm LParam
	LRESULT *plres)					// @parm Lresult			
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "IMEMouseCheck");

	BOOL retCode = FALSE;
	if(TextMsgFilter.IsIMEComposition())
	{
		retCode = TextMsgFilter._ime->IMEMouseOperation(TextMsgFilter, *pmsg);

		if ( retCode == FALSE && WM_MOUSEMOVE != *pmsg )
			TextMsgFilter._ime->TerminateIMEComposition(TextMsgFilter, CIme::TERMINATE_NORMAL);
	}

	return retCode ? S_OK : S_FALSE;
}

/*
 *	HRESULT IMENotifyGlue (const WPARAM wparam, const LPARAM lparam,
 *				CTextMsgFilter &TextMsgFilter)
 *
 *	@func
 *		IME is going to change some state.
 *
 *	@comm
 *		Currently we are interested in knowing when the candidate
 *		window is about to be opened.
 *		
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT IMENotifyGlue (
	const WPARAM wparam,		// @parm associated with message.
	const LPARAM lparam,		// @parm associated with message.
	CTextMsgFilter &TextMsgFilter)				// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "IMENotifyGlue");

	if (TextMsgFilter._fRE10Mode &&
		(wparam == IMN_SETCONVERSIONMODE ||
		wparam == IMN_SETSENTENCEMODE ||
		wparam == IMN_SETOPENSTATUS))
	{
		TextMsgFilter._pTextDoc->Notify(EN_IMECHANGE);			
	}
	else if(TextMsgFilter.IsIMEComposition())						// A priori fHaveIMMProcs.
		return TextMsgFilter._ime->IMENotify(wparam, lparam, TextMsgFilter, FALSE);// Make the method call
	
	return S_FALSE;
}

/*
 *	void IMECompositionFull (&TextMsgFilter)
 *
 *	@func
 *		Current IME Composition window is full.
 *
 *	@comm
 *		Called from the message loop to handle WM_IME_COMPOSITIONFULL.
 *		This message applied to Level 2 only.  We will use the default 
 *		IME Composition window.
 */
void IMECompositionFull (
	CTextMsgFilter &TextMsgFilter)				// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "IMECompositionFull");

	if(TextMsgFilter.IsIMEComposition())
	{
		HIMC 				hIMC	= LocalGetImmContext(TextMsgFilter);
		COMPOSITIONFORM		cf;

		if(hIMC)
		{																									 
			// No room for text input in the current level 2 IME window, 
			// fall back to use the default IME window for input.
			cf.dwStyle = CFS_DEFAULT;
			ImmSetCompositionWindow(hIMC, &cf, TextMsgFilter._fUsingAIMM);	// Set composition window.
			LocalReleaseImmContext(TextMsgFilter, hIMC);			// Done with IME context.
		}
 	}
}

/*
 *	LRESULT OnGetIMECompositionMode (CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Returns whether or not IME composition is being handled by RE,
 *		and if so, what level of processing.
 *		
 *	@rdesc
 *		One of ICM_NOTOPEN, ICM_LEVEL2_5, ICM_LEVEL2_SUI, ICM_LEVEL2, ICM_LEVEL3.
 */
LRESULT OnGetIMECompositionMode (
	CTextMsgFilter &TextMsgFilter)	  	// @parm containing message filter.
{
	LRESULT lres = ICM_NOTOPEN;

	if(TextMsgFilter.IsIMEComposition())
	{
		if(IME_LEVEL_2 == TextMsgFilter._ime->_imeLevel)
		{
			DWORD imeProperties;

			imeProperties = ImmGetProperty(GetKeyboardLayout(0x0FFFFFFFF), IGP_PROPERTY, TextMsgFilter._fUsingAIMM);
			if(imeProperties & IME_PROP_AT_CARET)
				lres = ICM_LEVEL2_5;				// level 2.5.
			else if	(imeProperties & IME_PROP_SPECIAL_UI)
				lres = ICM_LEVEL2_SUI;				// special UI.
			else
				lres = ICM_LEVEL2;					// stock level 2.
		}
		else if(IME_LEVEL_3 == TextMsgFilter._ime->_imeLevel) 
			lres = ICM_LEVEL3;
	}

	return lres;
}


/*
 *	void CIme::CheckKeyboardFontMatching (long cp, CTextMsgFilter &TextMsgFilter, ITextFont	*pTextFont)
 *	
 *	@mfunc
 *		Setup current font to matches the keyboard Codepage.
 *
 *	@comm
 *		Called from CIme_Lev2::CIme_Lev2 and CompositionStringGlue
 *
 *	@devnote
 *		We need to switch to a preferred font for the keyboard during IME input.
 *		Otherwise, we will display garbage.
 *		
 */
void CIme::CheckKeyboardFontMatching (
	long cp,
	CTextMsgFilter &TextMsgFilter, 
	ITextFont	*pTextFont)
{
	long	lPitchAndFamily;
	HRESULT	hResult;
	BSTR	bstr = NULL;
	long	lValue;
	long	lNewFontSize=0;
	float	nFontSize;
	ITextFont *pLocalFont = NULL;


	if (!pTextFont)
	{	
		// No font supplied, get current font from selection
		hResult = TextMsgFilter._pTextSel->GetFont(&pLocalFont);			
		
		if (hResult != S_OK || !pLocalFont)		// Can't get font, forget it
			return;			

		pTextFont = pLocalFont;
	}

	// Check if current font matches the keyboard
	lValue = tomCharset;
	hResult = pTextFont->GetLanguageID(&lValue);

	if (hResult == S_OK)
		if ((BYTE)(lValue) == (BYTE)GetCharSet(TextMsgFilter._uKeyBoardCodePage))
			goto Exit;								// Current font is fine

	hResult = pTextFont->GetSize(&nFontSize);

	if (hResult != S_OK)
		goto Exit;

	hResult = TextMsgFilter._pTextDoc->GetPreferredFont(cp, 
		TextMsgFilter._uKeyBoardCodePage, tomMatchFontCharset, 
		GetCodePage((BYTE)(lValue)), (long)nFontSize,
		&bstr, &lPitchAndFamily, &lNewFontSize);

	if (hResult == S_OK)
	{			
		if (bstr)
			pTextFont->SetName(bstr);

		// Set the font charset and Pitch&Family by overloading the SetLanguageID i/f			
		lValue = tomCharset + (((BYTE)lPitchAndFamily) << 8) + 
			(BYTE)GetCharSet(TextMsgFilter._uKeyBoardCodePage);

		pTextFont->SetLanguageID(lValue);				
		
		if (lNewFontSize)
			pTextFont->SetSize((float)lNewFontSize);
	}

Exit:
	if (pLocalFont)
			pLocalFont->Release();
	
	if (bstr)
		SysFreeString(bstr);
}

/*
 *	INT CIme::GetCompositionStringInfo(HIMC hIMC, DWORD dwIndex,
 *			  WCHAR *szCompStr, INT cchMax, BYTE *attrib, INT cbAttrib
 *			  LONG cchAttrib, UINT kbCodePage, BOOL bUnicodeIME)
 *
 *	@mfunc
 *		For WM_IME_COMPOSITION string processing to get the requested
 *		composition string, by type, and convert it to Unicode.
 *
 *	@devnote
 *		We must use ImmGetCompositionStringA because W is not supported
 *		on Win95.
 *		
 *	@rdesc
 *		INT-cch of the Unicode composition string.
 *		Out param in szCompStr.
 */
INT CIme::GetCompositionStringInfo(
	HIMC hIMC,			// @parm IME context provided by host.
	DWORD dwIndex,		// @parm The type of composition string.
	WCHAR *szCompStr,	// @parm Out param, unicode result string.
	INT cchMax,			// @parm The cch for the Out param.
	BYTE *attrib,		// @parm Out param, If attribute info is needed.
	INT cbMax,			// @parm The cb of the attribute info.
	LONG *cpCursor,		// @parm Out param, returns the CP of cusor.
	LONG *cchAttrib,	// @parm how many attributes returned.
	UINT kbCodePage,	// @parm codepage
	BOOL bUnicodeIME,	// @parm Unciode IME
	BOOL bUsingAimm)	// @parm Using Aimm
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme::GetCompositionStringInfo");

	BYTE	compStr[256], attribInfo[256];
	INT		i, j, iMax, cchCompStr=0, cbAttrib, cursor;
	INT		cchAnsiCompStr=0;

	Assert(hIMC && szCompStr);

	if(cpCursor)									// Init cursor out param.
		*cpCursor = -1;
	if(cchAttrib)
		*cchAttrib = 0;
	
													// Get composition string.
	if (bUnicodeIME)
		cchCompStr = ImmGetCompositionStringW(hIMC, dwIndex, szCompStr, cchMax, bUsingAimm )/sizeof(WCHAR);
	else
		cchAnsiCompStr = ImmGetCompositionStringA(hIMC, dwIndex, compStr, 255, bUsingAimm);

	if(cchAnsiCompStr > 0 || cchCompStr > 0)		// If valid data.
	{
		if (!bUnicodeIME)
		{
			Assert(cchAnsiCompStr >> 1 < cchMax - 1);		// Convert to Unicode.
			cchCompStr = UnicodeFromMbcs(szCompStr, cchMax,
					(CHAR *) compStr, cchAnsiCompStr, kbCodePage);
		}

		if(attrib || cpCursor)						// Need cursor or attribs?
		{			
			if (bUnicodeIME)
			{										// Get Unicode Cursor cp.
				cursor = ImmGetCompositionStringW(hIMC, GCS_CURSORPOS, NULL, 0, bUsingAimm);
													// Get Unicode attributes.
				cbAttrib = ImmGetCompositionStringW(hIMC, GCS_COMPATTR,
								attribInfo, 255, bUsingAimm);

				iMax = max(cursor, cbAttrib);
				iMax = min(iMax, cchCompStr);
			}
			else
			{										// Get DBCS Cursor cp.
				cursor = ImmGetCompositionStringA(hIMC, GCS_CURSORPOS, NULL, 0, bUsingAimm);
													// Get DBCS attributes.
				cbAttrib = ImmGetCompositionStringA(hIMC, GCS_COMPATTR,
								attribInfo, 255, bUsingAimm);

				iMax = max(cursor, cbAttrib);
				iMax = min(iMax, cchAnsiCompStr);
			}

			if(NULL == attrib)
				cbMax = cbAttrib;

			for(i = 0, j = 0; i <= iMax && j < cbMax; i++, j++)
			{
				if(cursor == i)
					cursor = j;

				if(!bUnicodeIME && GetTrailBytesCount(compStr[i], kbCodePage))
					i++;

				if(attrib && i < cbAttrib)
					*attrib++ = attribInfo[i];
			}
													// attrib cch==unicode cch
			Assert(0 >= cbAttrib || j-1 == cchCompStr);

			if(cursor >= 0 && cpCursor)				// If client needs cursor
				*cpCursor = cursor;					//  or cchAttrib.
			if(cbAttrib >= 0 && cchAttrib)
				*cchAttrib = j-1;
		}
	}
	else
	{
		if(cpCursor)			
			*cpCursor = 0;
		cchCompStr = 0;
	}
	return cchCompStr;
}

/*
 *	void CIme::SetCompositionFont (CTextMsgFilter &TextMsgFilter, ITextFont *pTextFont)
 *
 *	@mfunc
 *		Important for level 2 IME so that the composition window
 *		has the correct font. The lfw to lfa copy is due to the fact that
 *		Win95 does not support the W)ide call.
 *		It is also important for both level 2 and level 3 IME so that
 *		the candidate list window has the proper. font.
 */
void CIme::SetCompositionFont (
	CTextMsgFilter &TextMsgFilter,		// @parm the containing message filter.
	ITextFont *pTextFont) 		 		// @parm ITextFont for setting lfa.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme::SetCompositionFont");
	
	HIMC 		hIMC;
	LOGFONTA	lfa;

	if (pTextFont)
	{
		hIMC = LocalGetImmContext(TextMsgFilter);
		if (hIMC)
		{
			// Build the LOGFONT based on pTextFont
			float	FontSize;
			long	lValue;
			BSTR	bstr;

			memset (&lfa, 0, sizeof(lfa));

			if (pTextFont->GetSize(&FontSize) == NOERROR)			
				lfa.lfHeight = (LONG) FontSize;			
			
			if (pTextFont->GetBold(&lValue) == NOERROR && lValue == tomTrue)
				lfa.lfWeight = FW_BOLD;

			if (pTextFont->GetItalic(&lValue) == NOERROR && lValue == tomTrue)
				lfa.lfItalic = TRUE;

			lfa.lfCharSet = (BYTE)GetCharSet(TextMsgFilter._uKeyBoardCodePage);

			lValue = tomCharset;
			if (pTextFont->GetLanguageID(&lValue) == NOERROR && 
				lfa.lfCharSet == (BYTE)lValue)
				lfa.lfPitchAndFamily = (BYTE)(lValue >> 8);

			if (pTextFont->GetName(&bstr) == NOERROR)
			{
				MbcsFromUnicode(lfa.lfFaceName, sizeof(lfa.lfFaceName), bstr,
					-1, CP_ACP, UN_NOOBJECTS);	

				SysFreeString(bstr);
			}

			ImmSetCompositionFontA( hIMC, &lfa, TextMsgFilter._fUsingAIMM );

			LocalReleaseImmContext(TextMsgFilter, hIMC);			// Done with IME context.		
		}
	}
}

/*
 *	void CIme::SetCompositionForm (CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Important for level 2 IME so that the composition window
 *		is positioned correctly. 
 *
 *	@comm
 *		We go through a lot of work to get the correct height. This requires
 *		getting information from the font cache and the selection.
 */
void CIme::SetCompositionForm (
	CTextMsgFilter &TextMsgFilter)	   	// @parm the containing text edit.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme::SetCompositionForm");

	HIMC 				hIMC;
	COMPOSITIONFORM		cf;

	if(IME_LEVEL_2 == GetIMELevel())
	{
		hIMC = LocalGetImmContext(TextMsgFilter);					// Get IME context.
		
		if(hIMC)
		{				
			// get the location of cpMin
			cf.ptCurrentPos.x = cf.ptCurrentPos.y = 0;
			TextMsgFilter._pTextSel->GetPoint( tomStart+tomClientCoord+TA_BOTTOM+TA_LEFT,
				&(cf.ptCurrentPos.x), &(cf.ptCurrentPos.y) );			
			
			// Set-up bounding rect. for the IME (lev 2) composition window, causing
			// composition text to be wrapped within it.
			cf.dwStyle = CFS_RECT;
			TextMsgFilter._pTextDoc->GetClientRect(tomIncludeInset+tomClientCoord,
				&(cf.rcArea.left), &(cf.rcArea.top),
				&(cf.rcArea.right), &(cf.rcArea.bottom));		 

			// Make sure the starting point is not
			// outside the rcArea.  This happens when
			// there is no text on the current line and the user 
			// has selected a large font size.
			if(cf.ptCurrentPos.y < cf.rcArea.top)
				cf.ptCurrentPos.y = cf.rcArea.top;
			else if(cf.ptCurrentPos.y > cf.rcArea.bottom)
				cf.ptCurrentPos.y = cf.rcArea.bottom; 

			if(cf.ptCurrentPos.x < cf.rcArea.left)
				cf.ptCurrentPos.x = cf.rcArea.left;
			else if(cf.ptCurrentPos.x > cf.rcArea.right)
				cf.ptCurrentPos.x = cf.rcArea.right;

			ImmSetCompositionWindow(hIMC, &cf, TextMsgFilter._fUsingAIMM);	// Set composition window.

			LocalReleaseImmContext(TextMsgFilter, hIMC);				// Done with IME context.
		}
	}
}



/*
 *
 *	CIme::TerminateIMEComposition (CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc	Terminate the IME Composition mode using CPS_COMPLETE
 *	@comm	The IME will generate WM_IME_COMPOSITION with the result string
 * 
 */
void CIme::TerminateIMEComposition(
	CTextMsgFilter &TextMsgFilter, 			// @parm the containing message filter.
	TerminateMode mode)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme::TerminateIMEComposition");
	DWORD dwTerminateMethod;

	HIMC hIMC = LocalGetImmContext(TextMsgFilter);

	if(TextMsgFilter.IsIMEComposition() && TextMsgFilter._ime->IsTerminated())
	{
		// Turn if off now
		EndCompositionGlue(TextMsgFilter, TRUE);
		return;
	}

	_fIMETerminated = TRUE;

	if (mode == TERMINATE_FORCECANCEL)
		TextMsgFilter._pTextDoc->IMEInProgress(tomFalse);		// Inform client IME compostion is done

	dwTerminateMethod = CPS_COMPLETE;
	if (IME_LEVEL_2 == GetIMELevel()  ||	// force cancel for near-caret IME
		mode == TERMINATE_FORCECANCEL ||	// caller wants force cancel
		TextMsgFilter._fIMECancelComplete)				// Client wants force cancel
	{
		dwTerminateMethod = CPS_CANCEL;
	}
	
	// force the IME to terminate the current session
	if(hIMC)
	{
		BOOL retCode;

		retCode = ImmNotifyIME(hIMC, NI_COMPOSITIONSTR, 
			dwTerminateMethod, 0, TextMsgFilter._fUsingAIMM);
		
		if(!retCode && !TextMsgFilter._fIMECancelComplete)
		{
			// CPS_COMPLETE fail, try CPS_CANCEL.  This happen with some ime which do not support
			// CPS_COMPLETE option (e.g. ABC IME version 4 with Win95 simplified Chinese)
			retCode = ImmNotifyIME(hIMC, NI_COMPOSITIONSTR, CPS_CANCEL, 0, TextMsgFilter._fUsingAIMM);

		}

		LocalReleaseImmContext(TextMsgFilter, hIMC);
	}
	else
	{
		// for some reason, we didn't have a context, yet we thought we were still in IME
		// compostition mode.  Just force a shutdown here.
		EndCompositionGlue(TextMsgFilter, TRUE);
	}
}


/*
 *	CIme_Lev2::CIme_Lev2()
 *
 *	@mfunc
 *		CIme_Lev2 Constructor/Destructor.
 *
 *	@comm
 *		Needed to make sure _iFormatSave was handled properly.
 *
 */
CIme_Lev2::CIme_Lev2(	
	CTextMsgFilter &TextMsgFilter)		// @parm the containing message filter.
{
	long		cpMin, cpMax, cpLoc;
	HRESULT		hResult;
	ITextFont	*pCurrentFont = NULL;

	_pTextFont = NULL;
	_cIgnoreIMECharMsg = 0;

	// setup base Font format for later use during composition
	hResult	= TextMsgFilter._pTextSel->GetStart(&cpMin);
	cpLoc = cpMin;	

	if (TextMsgFilter._fHangulToHanja)
		cpMax = cpMin + 1;				// Select the Hangul character
	else
		hResult	= TextMsgFilter._pTextSel->GetEnd(&cpMax);

	_fSkipFirstOvertype = FALSE;
	if (cpMax != cpMin)
	{
		// selection case, get format for at cpMin
		ITextRange *pTextRange;
		HRESULT		hResult;
				
		hResult = TextMsgFilter._pTextDoc->Range(cpMin, cpMin+1, &pTextRange);
		Assert (pTextRange != NULL);
		
		if (hResult == NOERROR && pTextRange)
		{
			pTextRange->GetFont(&pCurrentFont);
			Assert(pCurrentFont != NULL);		
			pTextRange->Release();
			cpLoc = cpMin+1;
		}	

		if (!TextMsgFilter._fHangulToHanja)
			_fSkipFirstOvertype = TRUE;			// For Korean Overtype support
	}
	
	if (!pCurrentFont)
		TextMsgFilter._pTextSel->GetFont(&pCurrentFont);

	Assert(pCurrentFont != NULL);

	pCurrentFont->GetDuplicate(&_pTextFont);		// duplicate the base format for later use
	pCurrentFont->Release();
	Assert(_pTextFont != NULL);
	
	// setup font to match current keyboard
	CIme::CheckKeyboardFontMatching (cpLoc, TextMsgFilter, _pTextFont);

	_fIgnoreEndComposition = FALSE;
	
	_fIMETerminated = FALSE;
}

CIme_Lev2::~CIme_Lev2()
{
	if ( _pTextFont )
		_pTextFont->Release();
}

/*
 *	HRESULT CIme_Lev2::StartComposition(CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Begin IME Level 2 composition string processing.		
 *
 *	@comm
 *		Set the font, and location of the composition window which includes
 *		a bounding rect and the start position of the cursor. Also, reset
 *		the candidate window to allow the IME to set its position.
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT CIme_Lev2::StartComposition(
	CTextMsgFilter &TextMsgFilter)		// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev2::StartComposition");

	_imeLevel = IME_LEVEL_2;

	SetCompositionFont(TextMsgFilter, _pTextFont);	// Set font, & comp window.
	SetCompositionForm(TextMsgFilter);

	return S_FALSE;									// Allow DefWindowProc
}													//  processing.

/*
 *	HRESULT CIme_Lev2::CompositionString(const LPARAM lparam, CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Handle Level 2 WM_IME_COMPOSITION messages.
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing.  
 *		
 *		Side effect: 
 *			The Host needs to mask out the lparam before calling DefWindowProc to
 *			prevent unnessary WM_IME_CHAR messages.
 */
HRESULT CIme_Lev2::CompositionString (
	const LPARAM lparam,		// @parm associated with message.
	CTextMsgFilter &TextMsgFilter)				// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev2::CompositionString");

	_cIgnoreIMECharMsg = 0;
	if(HAVE_RESULT_STRING())
	{
		if (_pTextFont)
		{
			// setup the font before insert final string
			ITextFont *pFETextFont=NULL;

			_pTextFont->GetDuplicate(&pFETextFont);
			Assert(pFETextFont != NULL);

			TextMsgFilter._pTextSel->SetFont(pFETextFont);
			pFETextFont->Release();
		}

		TextMsgFilter._pTextDoc->SetNotificationMode(tomTrue);

		CheckInsertResultString(lparam, TextMsgFilter, &_cIgnoreIMECharMsg);
		SetCompositionForm(TextMsgFilter);			// Move Composition window.
		
	}

	// Always return S_FALSE so the DefWindowProc will handle the rest.
	// Host has to mask out the ResultString bit to avoid WM_IME_CHAR coming in.
	return S_FALSE;																	
}

/*
 *	HRESULT CIme::CheckInsertResultString (const LPARAM lparam, CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		handle inserting of GCS_RESULTSTR text, the final composed text.
 *
 *	@comm
 *		When the final composition string arrives we grab it and set it into the text.
 *
 *	@devnote
 *		A GCS_RESULTSTR message can arrive and the IME will *still* be in
 *		composition string mode. This occurs because the IME's internal
 *		buffers overflowed and it needs to convert the beginning of the buffer
 *		to clear out some room.	When this happens we need to insert the
 *		converted text as normal, but remain in composition processing mode.
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT CIme::CheckInsertResultString (
	const LPARAM lparam,			// @parm associated with message.
	CTextMsgFilter &TextMsgFilter,	// @parm the containing message filter.
	short	*pcch)					// @parm number of character read
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CheckInsertResultString");

	HRESULT			hr = S_FALSE;
	HIMC 			hIMC;
	INT				cch;
	WCHAR			szCompStr[256];

	if(CLEANUP_COMPOSITION_STRING() || HAVE_RESULT_STRING())	// If result string..
	{
		hIMC = LocalGetImmContext(TextMsgFilter);				// Get host's IME context.

		cch = 0;
		if(hIMC)												// Get result string.
		{
			cch = GetCompositionStringInfo(hIMC, GCS_RESULTSTR, 
							szCompStr,
							sizeof(szCompStr)/sizeof(szCompStr[0]),
							NULL, 0, NULL, NULL, TextMsgFilter._uKeyBoardCodePage, 
							TextMsgFilter._fUnicodeIME, TextMsgFilter._fUsingAIMM);

			if (pcch)
				*pcch = (short)cch;

			cch = min (cch, 255);
			szCompStr[cch] = L'\0';
			LocalReleaseImmContext(TextMsgFilter, hIMC);		// Done with IME context.
		}
			
		// Don't need to replace range when there isn't any text. Otherwise, the character format is
		// reset to previous run.
		if(cch)
		{
			BSTR bstr = SysAllocString(szCompStr);
			if (!bstr)
				return E_OUTOFMEMORY;
			TextMsgFilter._pTextSel->TypeText(bstr);
			SysFreeString(bstr);
		}
		hr = S_OK;												// Don't want WM_IME_CHARs.
		
	}

	return hr;
}

/*
 *	HRESULT CIme_Lev2::IMENotify(const WPARAM wparam, const LPARAM lparam,
 *					CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Handle Level 2 WM_IME_NOTIFY messages.
 *
 *	@comm
 *		Currently we are only interested in knowing when to reset
 *		the candidate window's position.
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT CIme_Lev2::IMENotify(
	const WPARAM wparam,			// @parm associated with message.
	const LPARAM lparam,			// @parm associated with message.
	CTextMsgFilter &TextMsgFilter,	// @parm the containing message filter.
	BOOL fIgnore)					// @parm Level3 Chinese Composition window only
{
 	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev2::IMENotify");

	if(IMN_OPENCANDIDATE == wparam)
	{
		Assert (0 != lparam);

		HIMC			hIMC;							// Host's IME context.

		INT				index;							// Candidate window index.
		CANDIDATEFORM	cdCandForm;

		hIMC = LocalGetImmContext(TextMsgFilter);				// Get host's IME context.

		if(hIMC)
		{
													// Convert bitID to INDEX.
			for (index = 0; index < 32; index++)	//  because API.
			{
				if((1 << index) & lparam)
					break;
			}
			Assert (((1 << index) & lparam) == lparam);	// Only 1 set?
			Assert (index < 32);						
													// Reset to CFS_DEFAULT
			if(ImmGetCandidateWindow(hIMC, index, &cdCandForm, TextMsgFilter._fUsingAIMM)
					&& CFS_DEFAULT != cdCandForm.dwStyle)
			{
				cdCandForm.dwStyle = CFS_DEFAULT;
				ImmSetCandidateWindow(hIMC, &cdCandForm, TextMsgFilter._fUsingAIMM);
			}

			LocalReleaseImmContext(TextMsgFilter, hIMC);			// Done with IME context.
		}
	}	

	return S_FALSE;									// Allow DefWindowProc
}													//  processing.

/*
 *	void CIme_Lev2::PostIMEChar (CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Called after processing a single WM_IME_CHAR in order to
 *		update the position of the IME's composition window.		
 *
 */
void CIme_Lev2::PostIMEChar (
	CTextMsgFilter &TextMsgFilter)				// @parm the containing message filter.
{
 	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev2::PostIMEChar");

	SetCompositionForm(TextMsgFilter);						// Move Composition window.
}

/*
 *	CIme_Lev3::CIme_Lev3()
 *
 *	@mfunc
 *		CIme_Lev3 Constructor/Destructor.
 *
 */
CIme_Lev3::CIme_Lev3(	
	CTextMsgFilter &TextMsgFilter) : CIme_Lev2 ( TextMsgFilter )
{
	_sIMESuportMouse = 0;		// initial to 0 so we will check mouse operation if need
	_wParamBefore = 0;
	_fUpdateWindow = FALSE;
}

/*
 *	HRESULT CIme_Lev3::StartComposition(CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Begin IME Level 3 composition string processing.		
 *
 *	@comm
 *		For rudimentary processing, remember the start and
 *		length of the selection. Set the font in case the
 *		candidate window actually uses this information.
 *
 *	@rdesc
 *		This is a rudimentary solution for remembering were
 *		the composition is in the text. There needs to be work
 *		to replace this with a composition "range".
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT CIme_Lev3::StartComposition(
	CTextMsgFilter &TextMsgFilter)			// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev3::StartComposition");
	long	cpMin;
	TextMsgFilter._pTextSel->GetStart(&cpMin);

	_ichStart = cpMin;
	_cchCompStr		= 0;
	_imeLevel		= IME_LEVEL_3;

	SetCompositionFont (TextMsgFilter, _pTextFont);	

	// Delete current selection
	TextMsgFilter._pTextSel->SetText(NULL);
	
	// turn off undo
	TextMsgFilter._pTextDoc->Undo(tomSuspend, NULL);

	if (_pTextFont)
	{
		_pTextFont->GetForeColor(&_crTextColor);
		_pTextFont->GetBackColor(&_crBkColor);
	}

	return S_OK;									// No DefWindowProc
}													//  processing.

/*
 *	HRESULT CIme_Lev3::CompositionString(const LPARAM lparam, CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Handle Level 3 WM_IME_COMPOSITION messages.
 *
 *	@comm
 *		Display all of the intermediary composition text as well as the final
 *		reading.
 *
 *	@devnote
 *		This is a rudimentary solution for replacing text in the backing store.
 *		Work is left to do with the undo list, underlining, and hiliting with
 *		colors and the selection.	
 *		
 *	@devnote
 *		A GCS_RESULTSTR message can arrive and the IME will *still* be in
 *		composition string mode. This occurs because the IME's internal
 *		buffers overflowed and it needs to convert the beginning of the buffer
 *		to clear out some room.	When this happens we need to insert the
 *		converted text as normal, but remain in composition processing mode.
 *
 *		Another reason, GCS_RESULTSTR can occur while in composition mode
 *		for Korean because there is only 1 correct choice and no additional 
 *		user intervention is necessary, meaning that the converted string can
 *		be sent as the result before composition mode is finished.
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT CIme_Lev3::CompositionString(
	const LPARAM lparam,		// @parm associated with message.
	CTextMsgFilter &TextMsgFilter)				// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev3::CompositionString");
	
	long	cpMin;
	
	_fIgnoreEndComposition = FALSE;

	if (_fUpdateWindow)
	{
		TextMsgFilter._pTextDoc->UpdateWindow();
		_fUpdateWindow = FALSE;
	}

 	if(CLEANUP_COMPOSITION_STRING() || HAVE_RESULT_STRING())	// Any final readings?
	{
		long	lCount;

		if (!CLEANUP_COMPOSITION_STRING())
			TextMsgFilter._pTextDoc->Freeze(&lCount);				// Turn off display

		if (_cchCompStr)
		{		
			ITextRange *pTextRange = NULL;

			// Create a range to delete composition text
			TextMsgFilter._pTextDoc->Range(_ichStart, _ichStart + _cchCompStr, &pTextRange);
			Assert (pTextRange != NULL);

			// delete composition text
			pTextRange->SetText(NULL);
			pTextRange->Release();
			_cchCompStr	= 0;							//  be in composition mode.
		};

		// setup the font before insert final string
		ITextFont *pFETextFont;

		_pTextFont->GetDuplicate(&pFETextFont);
		Assert(pFETextFont != NULL);

		TextMsgFilter._pTextSel->SetFont(pFETextFont);
		pFETextFont->Release();

		// turn on undo
		TextMsgFilter._pTextDoc->Undo(tomResume, NULL);

		// Turn on Notification again
		TextMsgFilter._pTextDoc->SetNotificationMode(tomTrue);

		// get final string
		CheckInsertResultString(lparam, TextMsgFilter);
		
		if (!CLEANUP_COMPOSITION_STRING())
			TextMsgFilter._pTextDoc->Unfreeze(&lCount);				// Turn on display

		// Reset as we may still in Composition
		TextMsgFilter._pTextSel->GetStart(&cpMin);	
		_ichStart = cpMin;

		// turn off undo for Korean IME since we will get Composition string message
		// again without getting EndComposition
		if (TextMsgFilter._uKeyBoardCodePage == CP_KOREAN)
		{
			TextMsgFilter._pTextDoc->Undo(tomSuspend, NULL);							
		}
	}

	if(HAVE_COMPOSITION_STRING())						// In composition mode?
	{
		HIMC	hIMC;
		INT		cchOld = _cchCompStr;
		LONG	cpCursor = 0, cchAttrib = 0;
		LONG	i, j;				// For applying attrib effects.
		WCHAR	szCompStr[256];
		BYTE	startAttrib, attrib[256];
		BSTR	bstr = NULL;
		ITextRange *pTextRange = NULL;
		long	cpMax;
		long	lCount;

		_cchCompStr = 0;

		hIMC = LocalGetImmContext(TextMsgFilter);			// Get host's IME context.

		if(hIMC)								// Get composition string.
		{
			_cchCompStr = GetCompositionStringInfo(hIMC, GCS_COMPSTR, 
					szCompStr, sizeof(szCompStr)/sizeof(szCompStr[0]),
					attrib, sizeof(attrib)/sizeof(attrib[0]), 
					&cpCursor, &cchAttrib, TextMsgFilter._uKeyBoardCodePage, TextMsgFilter._fUnicodeIME, TextMsgFilter._fUsingAIMM);
			_cchCompStr = min (_cchCompStr, 255);
			szCompStr[_cchCompStr] = L'\0';
			LocalReleaseImmContext(TextMsgFilter, hIMC);		// Done with IME context.
		}

		// any new composition string?
		if(_cchCompStr)
		{
			long	cchExced = 0;
			if (TextMsgFilter._pTextDoc->CheckTextLimit(_cchCompStr-cchOld, &cchExced) == NOERROR &&
				cchExced > 0)
			{
				// We reach text limit, beep...
				TextMsgFilter._pTextDoc->SysBeep();

				if (_cchCompStr > cchExced)
					_cchCompStr -= cchExced;
				else
					_cchCompStr = 0;

				szCompStr[_cchCompStr] = L'\0';

				if (!_cchCompStr && TextMsgFilter._uKeyBoardCodePage == CP_KOREAN)				
					TextMsgFilter._pTextDoc->SetCaretType(tomNormalCaret);		// Turn off Block caret mode
			}

			bstr = SysAllocString(szCompStr);
			if (!bstr)
				return E_OUTOFMEMORY;
		
			if (HAVE_RESULT_STRING())
			{
				// ignore next end composition
				_fIgnoreEndComposition = TRUE;

				// turn off undo
				TextMsgFilter._pTextDoc->Undo(tomSuspend, NULL);

				// Hold notification if needed
				if (!(TextMsgFilter._fIMEAlwaysNotify))
					TextMsgFilter._pTextDoc->SetNotificationMode(tomFalse);

				// Get the new format that may have changed by apps (e.g. Outlook)
				_pTextFont->Release();

				ITextFont	*pCurrentFont = NULL;
				TextMsgFilter._pTextSel->GetFont(&pCurrentFont);

				Assert(pCurrentFont != NULL);

				pCurrentFont->GetDuplicate(&_pTextFont);		// duplicate the base format for later use
				pCurrentFont->Release();
				Assert(_pTextFont != NULL);
				CIme::CheckKeyboardFontMatching (_ichStart, TextMsgFilter, _pTextFont);
			}			
		}
		
		if (cchOld || _cchCompStr)
		{
			bool	fFreezeDisplay = false;

			// Hold notification if needed
			if (!(TextMsgFilter._fIMEAlwaysNotify))
				TextMsgFilter._pTextDoc->SetNotificationMode(tomFalse);

			// We only support overtype mode in Korean IME
			if (!cchOld && TextMsgFilter._uKeyBoardCodePage == CP_KOREAN && 
				TextMsgFilter._fOvertypeMode && !_fSkipFirstOvertype)
			{				
				long		cCurrentChar;	
				HRESULT		hResult;

				// Create a range using the next character
				hResult	= TextMsgFilter._pTextDoc->Range(_ichStart, _ichStart+1, &pTextRange);
				Assert (pTextRange != NULL);

				// Check if it is par character. If so, we don't want to 
				// delete it.
				hResult	= pTextRange->GetChar(&cCurrentChar);
				if (hResult == NOERROR)
				{
					if (cCurrentChar != (long)'\r' && cCurrentChar != (long)'\n')
					{			
						TextMsgFilter._pTextDoc->Undo(tomResume, NULL);		// Turn on undo
						pTextRange->SetText(NULL);							// Delete the character
						TextMsgFilter._pTextDoc->Undo(tomSuspend, NULL);	// Turn off undo
					}
					else
					{
						// Unselect the par character
						hResult	= pTextRange->SetRange(_ichStart, _ichStart);
					}
				}
			}	
			else
			{
				// Create a range using the preivous composition text and delete the text
				TextMsgFilter._pTextDoc->Range(_ichStart, _ichStart+cchOld, &pTextRange);
				Assert (pTextRange != NULL);
				if (cchOld)
				{
					if (cpCursor)
					{
						TextMsgFilter._pTextDoc->Freeze(&lCount);	// Turn off display
						fFreezeDisplay = true;
					}
					pTextRange->SetText(NULL);
				}
			}
			
			_fSkipFirstOvertype = FALSE;
			
			if (cpCursor && !fFreezeDisplay)
				TextMsgFilter._pTextDoc->Freeze(&lCount);			// Turn off display
			
			// Make sure the composition string is formatted with the base font
			ITextFont *pFETextFont;
			HRESULT		hResult;

			hResult = _pTextFont->GetDuplicate(&pFETextFont);
			Assert(pFETextFont != NULL);

			if (!(hResult != NOERROR || pFETextFont == NULL))
			{
				if (TextMsgFilter._fHangulToHanja)
					// Hangul to Hanja mode, setup font for selection to 
					// handle the Hanja character the come in after the end composition
					// message
					TextMsgFilter._pTextSel->SetFont(pFETextFont);
				else
					pTextRange->SetFont(pFETextFont);				
			}

			pTextRange->SetText(bstr);								// Replace with the new text			
			if (pFETextFont)
				pFETextFont->Release();

			// update how many composition characters have been added
			pTextRange->GetEnd(&cpMax); 
			_cchCompStr = cpMax - _ichStart;
			
			if (TextMsgFilter._uKeyBoardCodePage == CP_KOREAN)
			{
				// no formatting for Korean
				POINT		ptBottomPos;

				if (cpCursor)
					TextMsgFilter._pTextDoc->Unfreeze(&lCount);			// Turn on display
			
				if (pTextRange->GetPoint( tomEnd+TA_BOTTOM+TA_RIGHT,
					&(ptBottomPos.x), &(ptBottomPos.y) ) != NOERROR)
					pTextRange->ScrollIntoView(tomEnd);
				
				// Setup Block caret mode
				TextMsgFilter._pTextDoc->SetCaretType(_cchCompStr ? tomKoreanBlockCaret : tomNormalCaret);
				
			}
			else if (_cchCompStr && _cchCompStr <= cchAttrib)
			{				
				for ( i = 0; i < _cchCompStr; )			// Parse the attributes...
				{										//  to apply styles.					
					ITextFont *pFETextFont;
					HRESULT		hResult;

					hResult = _pTextFont->GetDuplicate(&pFETextFont);
					Assert(pFETextFont != NULL);

					if (hResult != NOERROR || pFETextFont == NULL)
						break;
					
					// Rsest the clone font so we will only apply effects returned
					// from SetCompositionStyle
					pFETextFont->Reset(tomUndefined);

					startAttrib = attrib[i];			// Get attrib's run length.
					for ( j = i+1; j < _cchCompStr; j++ )			
					{
						if ( startAttrib != attrib[j] )	// Same run until diff.
							break; 
					}

					SetCompositionStyle(TextMsgFilter, startAttrib, pFETextFont);

					// Apply FE clause's style
					pTextRange->SetRange(_ichStart+i, _ichStart+j);
					pTextRange->SetFont(pFETextFont);
					pFETextFont->Release();

					i = j;
				}
			}

			pTextRange->Release();
		}
		else if (TextMsgFilter._uKeyBoardCodePage == CP_KOREAN)
			TextMsgFilter._pTextDoc->Update(tomTrue);		// Force an Update

		// setup caret pos
		if ( !(TextMsgFilter._uKeyBoardCodePage == CP_KOREAN))
		{
			if ( cpCursor > 0 )
			{
				cpCursor = min(cpCursor, _cchCompStr) + _ichStart;
				TextMsgFilter._pTextSel->SetRange(cpCursor, cpCursor);
			}
			else if ( cpCursor == 0 )
			{
				POINT		ptTopPos;
				HRESULT		hResult;

				// make sure the beginning is in view
				hResult	= TextMsgFilter._pTextDoc->Range(_ichStart, _ichStart+1, &pTextRange);
				Assert (pTextRange != NULL);
				
				if (hResult == NO_ERROR)
				{
					if (pTextRange->GetPoint( tomStart+TA_TOP+TA_LEFT,
						&(ptTopPos.x), &(ptTopPos.y) ) != NOERROR)
						pTextRange->ScrollIntoView(tomStart);
					pTextRange->Release();
				}
			}

			if (cpCursor)
				TextMsgFilter._pTextDoc->Unfreeze(&lCount);			// Turn on display
		}

		if (bstr)	
			SysFreeString(bstr);	
		
		// setup composition window for Chinese in-caret IME
		if (TextMsgFilter._uKeyBoardCodePage == CP_CHINESE_TRAD || 
			TextMsgFilter._uKeyBoardCodePage == CP_CHINESE_SIM)
			IMENotify ( IMN_OPENCANDIDATE, 0x01, TextMsgFilter, TRUE );
	}

	return S_OK;									// No DefWindowProc
}													//  processing.

/*
 *	void CIme_Lev3::SetCompositionStyle (CTextMsgFilter &TextMsgFilter, CCharFormat &CF)
 *
 *	@mfunc
 *		Set up a composition clause's character formmatting.
 *
 *	@comm
 *		If we loaded Office's IMEShare.dll, then we ask it what the formatting
 *		should be, otherwise we use our own, hardwired default formatting.
 *
 *	@devnote
 *		Note the use of pointers to functions when dealing with IMEShare funcs.
 *		This is because we dynamically load the IMEShare.dll.
 *
 */
void CIme_Lev3::SetCompositionStyle (
	CTextMsgFilter &TextMsgFilter,
	UINT attribute,
	ITextFont *pTextFont)
{

	const IMESTYLE	*pIMEStyle;
	UINT			ulID;
	COLORREF		crText = UINTIMEBOGUS;
	COLORREF		crBackground = UINTIMEBOGUS;
	COLORREF		crUl;

	if (TextMsgFilter._fRE10Mode)
	{
		if (attribute > ATTR_TARGET_NOTCONVERTED)
			attribute = ATTR_CONVERTED;

		// IME input for 1.0 mode, need to use IME Color
		if (TextMsgFilter._crComp[attribute].dwEffects & CFE_BOLD)
			pTextFont->SetBold(tomTrue);
		
		if(TextMsgFilter._crComp[attribute].dwEffects & CFE_ITALIC)
			pTextFont->SetItalic(tomTrue);

		if(TextMsgFilter._crComp[attribute].dwEffects & CFE_STRIKEOUT)
			pTextFont->SetStrikeThrough(tomTrue);
					
		if(TextMsgFilter._crComp[attribute].dwEffects & CFE_UNDERLINE)
			pTextFont->SetUnderline(tomSingle);

		pTextFont->SetForeColor(TextMsgFilter._crComp[attribute].crText);
				
		pTextFont->SetBackColor(TextMsgFilter._crComp[attribute].crBackground);			
	}
	else if (W32->HaveIMEShare())
	{
		CIMEShare *pIMEShare;
		if (W32->getIMEShareObject(&pIMEShare))
		{
			// IMEShare 98 interface
			if (pIMEShare->DwGetIMEStyle(attribute, IdstyIMEShareFBold))
				pTextFont->SetBold(tomTrue);
			
			if(pIMEShare->DwGetIMEStyle(attribute, IdstyIMEShareFItalic))
				pTextFont->SetItalic(tomTrue);

			if(pIMEShare->DwGetIMEStyle(attribute, IdstyIMEShareFUl))
			{
				ulID = pIMEShare->DwGetIMEStyle(attribute, IdstyIMEShareUKul);
				if(UINTIMEBOGUS != ulID)
				{
					long	lUnderlineCrIdx = 0;

					// get color for underline
					
					crUl = GetIMEShareColor(pIMEShare, attribute, IdstyIMEShareSubUl);
					
					if(UINTIMEBOGUS != crUl)
					{
						// NOTE:- attribute is 0 based and index for EffectColor is 1 based,
						// so, need to add 1 to attribute

						HRESULT hResult = TextMsgFilter._pTextDoc->SetEffectColor(attribute+1, crUl);
						
						// setup the high nibble for color index
						if (hResult == NOERROR)
							lUnderlineCrIdx = (attribute+1) << 4;
					}

					pTextFont->SetUnderline(IMEShareToTomUL(ulID) + lUnderlineCrIdx);					
				}
			}

			crText = GetIMEShareColor(pIMEShare, attribute, IdstyIMEShareSubText);
		
			crBackground = GetIMEShareColor(pIMEShare, attribute, IdstyIMEShareSubBack);

			
			// ignore case where text color is same as background color
			if (crText != crBackground)
			{
				if(UINTIMEBOGUS != crText)
					pTextFont->SetForeColor(crText);
				
				if(UINTIMEBOGUS != crBackground)
					pTextFont->SetBackColor(crBackground);		
			}
		}
		else
		{
			// IMEShare 96 interface
			pIMEStyle = PIMEStyleFromAttr(attribute);
			if(NULL == pIMEStyle)
				goto defaultStyle;		

			if(FBoldIMEStyle(pIMEStyle))
				pTextFont->SetBold(tomTrue);

			if(FItalicIMEStyle(pIMEStyle))
				pTextFont->SetItalic(tomTrue);

			if(FUlIMEStyle(pIMEStyle))
			{			
				ulID = IdUlIMEStyle (pIMEStyle);
				if(UINTIMEBOGUS != ulID)
					pTextFont->SetUnderline(IMEShareToTomUL(ulID));
			}

			crText = RGBFromIMEColorStyle(PColorStyleTextFromIMEStyle(pIMEStyle));
			if(UINTIMEBOGUS != crText)
				pTextFont->SetForeColor(crText);
			
			crBackground = RGBFromIMEColorStyle(PColorStyleBackFromIMEStyle(pIMEStyle));
			if(UINTIMEBOGUS != crBackground)
				pTextFont->SetBackColor(crBackground);
		}
	}
	else // default styles when no IMEShare.dll exist.
	{
defaultStyle:
		switch(attribute)
		{										// Apply underline style.
			case ATTR_INPUT:
			case ATTR_CONVERTED:
				pTextFont->SetUnderline(tomDotted);
				break;

			case ATTR_TARGET_NOTCONVERTED:
				pTextFont->SetUnderline(tomSingle);
				break;

			case ATTR_TARGET_CONVERTED:			// Target *is* selection.			
			{
				pTextFont->SetForeColor(::GetSysColor(COLOR_HIGHLIGHTTEXT));
				pTextFont->SetBackColor(::GetSysColor(COLOR_HIGHLIGHT));
			}
			break;
		}
	}
}
/*
 *	COLORREF CIme_Lev3::GetIMEShareColor (CIMEShare *pIMEShare, DWORD dwAttribute, DWORD dwProperty)
 *
 *	@mfunc
 *		Get the IME share color for the given dwAttribute and property
 *
 *
 *	@rdesc
 *		COLORREF of the color
 *
 */
COLORREF CIme_Lev3::GetIMEShareColor(
	CIMEShare *pIMEShare,
	DWORD dwAttribute,
	DWORD dwProperty)
{	
	if (pIMEShare->DwGetIMEStyle(dwAttribute,IdstyIMEShareFSpecCol | dwProperty))
	{
		if (pIMEShare->DwGetIMEStyle(dwAttribute,IdstyIMEShareFSpecColText | dwProperty))
			return (COLORREF) _crTextColor;
		else
			return (COLORREF) _crBkColor;
	}
	else
		return (COLORREF) (pIMEShare->DwGetIMEStyle(dwAttribute, 
				IdstyIMEShareRGBCol | dwProperty));
}

/*
 *	HRESULT CIme_Lev3::IMENotify(const WPARAM wparam, const LPARAM lparam,
 *					CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Handle Level 3 WM_IME_NOTIFY messages.
 *
 *	@comm
 *		Currently we are only interested in knowing when to update
 *		the n window's position.
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT CIme_Lev3::IMENotify(
	const WPARAM wparam,			// @parm associated with message.
	const LPARAM lparam,			// @parm associated with message.
	CTextMsgFilter &TextMsgFilter,	// @parm the containing message filter.
	BOOL fCCompWindow)				// @parm Level3 Chinese Composition window
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev3::IMENotify");

	if(IMN_OPENCANDIDATE == wparam || IMN_CLOSECANDIDATE == wparam )
	{
		Assert (0 != lparam);

		INT				index;							// Candidate window index.
		CANDIDATEFORM	cdCandForm;
		POINT			ptCaret;
		HIMC			hIMC = LocalGetImmContext(TextMsgFilter);	// Get host's IME context.

		if(hIMC)
		{
			for (index = 0; index < 32; index++)	// Convert bitID to INDEX
			{										//  because API
				if((1 << index) & lparam)
					break;
			}
			Assert(((1 << index) & lparam) == lparam);	// Only 1 set?
			Assert(index < 32);

			if(IMN_OPENCANDIDATE == wparam && !(TextMsgFilter._uKeyBoardCodePage == CP_KOREAN))	// Set candidate to caret.
			{
				HRESULT	hResult;
				POINT	ptCurrentBottomPos;
				GetCaretPos(&ptCaret);			// Start at caret.

				ptCaret.x = max(0, ptCaret.x);
				ptCaret.y = max(0, ptCaret.y);
					
				cdCandForm.dwStyle = CFS_CANDIDATEPOS;
				
				if ( !fCCompWindow )			// Not positioning the Chinese composition
				{								//	Window.
					hResult = TextMsgFilter._pTextSel->GetPoint( tomStart+tomClientCoord+TA_BOTTOM+TA_LEFT,
							&(ptCurrentBottomPos.x), &(ptCurrentBottomPos.y) );

					if (hResult != NOERROR)
					{
						RECT	rcArea;

						// GetPoint fails, use application rect in screen coordinates
						hResult = TextMsgFilter._pTextDoc->GetClientRect(tomIncludeInset+tomClientCoord,
									&(rcArea.left), &(rcArea.top),
									&(rcArea.right), &(rcArea.bottom));
						ptCurrentBottomPos.y = rcArea.bottom;
					}

					if (hResult == NOERROR)
					{
						if (TextMsgFilter._uKeyBoardCodePage == CP_JAPAN)
						{
							// Change style to CFS_EXCLUDE, this is to
							// prevent the candidate window from covering
							// the current selection.
							cdCandForm.dwStyle = CFS_EXCLUDE;
							cdCandForm.rcArea.left = ptCaret.x;					

							// FUTURE: for verticle text, need to adjust
							// the rcArea to include the character width.
							cdCandForm.rcArea.right = 
								cdCandForm.rcArea.left + 2;
							cdCandForm.rcArea.top = ptCaret.y;
							ptCaret.y = ptCurrentBottomPos.y + 4;
							cdCandForm.rcArea.bottom = ptCaret.y;
						}
						else
							ptCaret.y = ptCurrentBottomPos.y + 4;
					}
				}

				// Most IMEs will have only 1, #0, candidate window. However, some IMEs
				//  may want to have a window organized alphabetically, by stroke, and
				//  by radical.
				cdCandForm.dwIndex = index;				
				cdCandForm.ptCurrentPos = ptCaret;
				ImmSetCandidateWindow(hIMC, &cdCandForm, TextMsgFilter._fUsingAIMM);
			}
			else									// Reset back to CFS_DEFAULT.
			{
				if(ImmGetCandidateWindow(hIMC, index, &cdCandForm, TextMsgFilter._fUsingAIMM)
						&& CFS_DEFAULT != cdCandForm.dwStyle)
				{
					cdCandForm.dwStyle = CFS_DEFAULT;
					ImmSetCandidateWindow(hIMC, &cdCandForm, TextMsgFilter._fUsingAIMM);
				}				
			}

			LocalReleaseImmContext(TextMsgFilter, hIMC);			// Done with IME context.
			
			if (TextMsgFilter._fHangulToHanja == TRUE  &&
				IMN_CLOSECANDIDATE == wparam &&					 
				OnWinNTFE())
			{
				// By pass NT4.0 Kor Bug where we didn't get a EndComposition message
				// when user toggle the VK_HANJA key to terminate the conversion.
				TerminateIMEComposition(TextMsgFilter, CIme::TERMINATE_NORMAL);
			}

			if (IMN_CLOSECANDIDATE == wparam && CP_JAPAN == TextMsgFilter._uKeyBoardCodePage)
				_fUpdateWindow = TRUE;			
		}
	}	

	return S_FALSE;									// Allow DefWindowProc
}													//  processing.

/*
 *
 *	CIme_Lev3::IMEMouseOperation (CTextMsgFilter &TextMsgFilter, UINT msg)
 *
 *	@mfunc	if current IME support Mouse operation, need to pass
 *		mouse events to IME for processing
 *
 *	@rdesc
 *		BOOL-TRUE if IME handled the mouse events
 *
 */
BOOL CIme_Lev3::IMEMouseOperation(
	CTextMsgFilter &TextMsgFilter, 			// @parm the containing message filter.
	UINT		msg)						// @parm message id
	
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev3::IMEMouseOperation");
	
	BOOL	bRetCode = FALSE;
	BOOL	fButtonPressed = FALSE;
	WORD	wButtons = 0;
	POINT	ptCursor;
	WPARAM	wParamIME;

	HWND	hHostWnd = TextMsgFilter._hwnd;
	long	hWnd;

	if (!hHostWnd)									// Windowless mode...
	{		
		if (TextMsgFilter._pTextDoc->GetWindow(&hWnd) != S_OK || !hWnd)
			return FALSE;

		hHostWnd = (HWND)(DWORD_PTR)hWnd;
	}

	if (IMESupportMouse(TextMsgFilter))
	{
		switch (msg)
		{
			case WM_LBUTTONDOWN:
			case WM_RBUTTONDOWN:
			case WM_MBUTTONDOWN:
				fButtonPressed = TRUE;
				//fall through.
			case WM_SETCURSOR:
			case WM_MOUSEMOVE:
			case WM_LBUTTONUP:
			case WM_LBUTTONDBLCLK:
			case WM_RBUTTONUP:
			case WM_RBUTTONDBLCLK:
			case WM_MBUTTONUP:
			case WM_MBUTTONDBLCLK:
				if (GetKeyState(VK_LBUTTON) & 0x80)
					wButtons |= IMEMOUSE_LDOWN;
				if (GetKeyState(VK_MBUTTON) & 0x80)
					wButtons |= IMEMOUSE_MDOWN;
				if (GetKeyState(VK_RBUTTON) & 0x80)
					wButtons |= IMEMOUSE_RDOWN;
				break;

			default:
				return FALSE;
		}
	
		// change in button since last message?
		if ((wButtons != LOBYTE(LOWORD(_wParamBefore))) && GetCapture() == hHostWnd)
		{
			fButtonPressed = FALSE;
			wButtons = 0;
			ReleaseCapture();
		}
		
		if (GetCursorPos(&ptCursor))
		{
			ITextRange *pTextRange;
			HRESULT		hResult;
			long		ichCursor;

			// get cp at current Cursor position
			hResult = TextMsgFilter._pTextDoc->RangeFromPoint(ptCursor.x, ptCursor.y,
				&pTextRange);

			if (hResult != NOERROR)			
				return FALSE;

			hResult = pTextRange->GetStart(&ichCursor);
			pTextRange->Release();
			if (hResult != NOERROR)
				return FALSE;
			
			// click within composition text?
			if (_ichStart <= ichCursor && ichCursor <= _ichStart + _cchCompStr)
			{
				wParamIME = MAKEWPARAM(wButtons, ichCursor - _ichStart);
				fButtonPressed &= (_wParamBefore & 0xff) == 0;

				if (_wParamBefore != wParamIME || msg == WM_MOUSEMOVE && !fButtonPressed)
				{
					HIMC hIMC = LocalGetImmContext(TextMsgFilter);

					_wParamBefore = wParamIME;
					if (hIMC)
					{
						bRetCode = SendMessage(_hwndIME, MSIMEMouseMsg, _wParamBefore, hIMC);
						LocalReleaseImmContext(TextMsgFilter, hIMC);
					}
				}
				else
					// no change from last time, no need to send message to IME
					bRetCode = TRUE;

				if (bRetCode && fButtonPressed && GetCapture() != hHostWnd)
					SetCapture(hHostWnd);
			}
			else if (GetCapture() == hHostWnd)		//We don't want to determine while dragging...
				return TRUE;
		}
	}

	return bRetCode;
}

/*
 *
 *	CIme_Lev3::IMESupportMouse (CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc	check if current IME supports Mouse events.  This should be
 *			a feature for IME Level 3.
 * 
 *	@comm	_sIMESupportMouse is a flag with the following values:
 *				== 0	if we haven't checked IME mouse support
 *				== -1	if we have checked and IME doesn't support mouse events
 *				== 1	if we have checked and IME supports mouse events and we have
 *						retrieved the IME hWnd
 */
BOOL CIme_Lev3::IMESupportMouse(
	CTextMsgFilter &TextMsgFilter) 			// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev3::IMESupportMouse");
	HIMC	hIMC;									// Host's IME context.
	HWND	hHostWnd;
	long	hWnd;

	if (!MSIMEMouseMsg || _sIMESuportMouse == -1)
		return FALSE;								// No mouse operation support

	if (_sIMESuportMouse == 1)
		return TRUE;								// IME supports mouse operation

	hHostWnd = TextMsgFilter._hwnd;
	
	if (!hHostWnd)									// Windowless mode...
	{		
		if (TextMsgFilter._pTextDoc->GetWindow(&hWnd) != S_OK || !hWnd)
			return FALSE;
		
		hHostWnd = (HWND)(DWORD_PTR)hWnd;
	}

	// Check if this IME supports mouse operation
	hIMC = LocalGetImmContext(TextMsgFilter);		// Get host's IME context.

	_sIMESuportMouse = -1;							// Init. to no support
	if(hIMC)
	{
		_hwndIME = ImmGetDefaultIMEWnd(hHostWnd, TextMsgFilter._fUsingAIMM);
		LocalReleaseImmContext(TextMsgFilter, hIMC);

		// SendMessage returns TRUE if IME supports mouse operation
		if (_hwndIME && SendMessage(_hwndIME, MSIMEMouseMsg, (WPARAM)IMEMOUSE_VERSION, hIMC) )
			_sIMESuportMouse = 1;
	}

	return (_sIMESuportMouse == 1);
}

/*
 *	BOOL IMEHangeulToHanja (&TextMsgFilter)
 *	
 *	@func
 *		Initiates an IME composition string edit to convert Korean Hanguel to Hanja.
 *	@comm
 *		Called from the message loop to handle VK_KANJI_KEY.
 *
 *	@devnote
 *		We decide if we need to do a conversion by checking:
 *		- the Fonot is a Korean font,
 *		- the character is a valid SBC or DBC,
 *		- ImmEscape accepts the character and bring up a candidate window
 *
 *	@rdesc
 *		BOOL - FALSE for no conversion. TRUE if OK.
 */
BOOL IMEHangeulToHanja (
	CTextMsgFilter &TextMsgFilter)				// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "IMEHangeulToHanja");

	if(!TextMsgFilter.IsIMEComposition())
	{
		if(TextMsgFilter._pTextSel->CanEdit(NULL) == NOERROR)
		{
			WCHAR		szCurrentChar;
			long		cCurrentChar;	
			HRESULT		hResult;
			HKL			hKL = GetKeyboardLayout(0x0FFFFFFFF);
			HIMC		hIMC;	

			if (!hKL)
				goto Exit;
			
			hIMC = LocalGetImmContext(TextMsgFilter);
			if (!hIMC)
				goto Exit;

			// Collapse to cpMin
			hResult	= TextMsgFilter._pTextSel->Collapse(tomStart);

			// get the current character
			hResult	= TextMsgFilter._pTextSel->GetChar(&cCurrentChar);

			if (hResult != NOERROR)
				goto Exit;

			szCurrentChar = (WCHAR)cCurrentChar;
			
			// Check if the IME has a conversion for this Hangeul character.					
			if (ImmEscape(hKL, hIMC, IME_ESC_HANJA_MODE, (LPVOID)&szCurrentChar, TextMsgFilter._fUsingAIMM) != FALSE)
			{
				ITextRange *pTextRange;
				POINT		ptMiddlePos;
				LONG		cpCurrent;

				hResult = TextMsgFilter._pTextSel->GetStart(&cpCurrent);
				if (hResult == S_OK)
				{
					hResult = TextMsgFilter._pTextDoc->Range(cpCurrent, cpCurrent+1, &pTextRange);
					if (hResult == S_OK && pTextRange)
					{
						// Check if the character is in view
						if (pTextRange->GetPoint( tomEnd+TA_BASELINE+TA_LEFT,
							&(ptMiddlePos.x), &(ptMiddlePos.y) ) != NOERROR)
							pTextRange->ScrollIntoView(tomEnd);
						pTextRange->Release();
					}
				}

				TextMsgFilter._fHangulToHanja = TRUE;

				TextMsgFilter._ime = new CIme_HangeulToHanja(TextMsgFilter);

				if(TextMsgFilter.IsIMEComposition())
				{
					// start IME composition for the conversion
					LocalReleaseImmContext(TextMsgFilter, hIMC);
					return TextMsgFilter._ime->StartComposition(TextMsgFilter);
				}
				else
					TextMsgFilter._fHangulToHanja = FALSE;				
			}

			LocalReleaseImmContext(TextMsgFilter, hIMC);
		}
	}

Exit:
	return S_FALSE;
}

/*
 *	CIme_HangeulToHanja::CIme_HangeulToHanja()
 *
 *	@mfunc
 *		CIme_HangeulToHanja Constructor.
 *
 *
 */
 CIme_HangeulToHanja::CIme_HangeulToHanja(CTextMsgFilter &TextMsgFilter)	:
	CIme_Lev3(TextMsgFilter)
{
}

/*
 *	HRESULT CIme_HangeulToHanja::StartComposition(CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Begin CIme_HangeulToHanja composition string processing.		
 *
 *	@comm
 *		Call Level3::StartComposition.  Then setup the Korean block
 *		caret for the Hanguel character.
 *
 *	@rdesc
 *		Need to adjust _ichStart and _cchCompStr to make the Hanguel character
 *		"become" a composition character.
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT CIme_HangeulToHanja::StartComposition(
	CTextMsgFilter &TextMsgFilter )				// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_HangeulToHanja::StartComposition");
	HRESULT				hr;

	hr = CIme_Lev3::StartComposition(TextMsgFilter);
	
	// initialize to 1 so Composition string will get rid of the selected Hangeul
	_cchCompStr		= 1;

	// turn on undo
	TextMsgFilter._pTextDoc->Undo(tomResume, NULL);

	// Setup Block caret mode
	TextMsgFilter._pTextDoc->SetCaretType(tomKoreanBlockCaret);

	return hr;
}

/*
 *	HRESULT CIme_HangeulToHanja::CompositionString(const LPARAM lparam, CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Handle CIme_HangeulToHanja WM_IME_COMPOSITION messages.
 *
 *	@comm
 *		call CIme_Lev3::CompositionString to get rid of the selected Hanguel character,
 *		then setup the format for the next Composition message.
 *
 *	@devnote
 *		When the next Composition message comes in and that we are no longer in IME,
 *		the new character will use the format as set here.
 */
HRESULT CIme_HangeulToHanja::CompositionString(
	const LPARAM lparam,		// @parm associated with message
	CTextMsgFilter &TextMsgFilter)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_HangeulToHanja::CompositionString");

	CIme_Lev3::CompositionString(lparam, TextMsgFilter);

	return S_OK;
}
/*
 *	HRESULT CIme_Protected::CompositionString(const LPARAM lparam, CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Handle CIme_Protected WM_IME_COMPOSITION messages.
 *
 *	@comm
 *		Just throw away the result string since we are
 *	in read-only or protected mode
 *
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 *
 */
HRESULT CIme_Protected::CompositionString (
	const LPARAM lparam,		// @parm associated with message.
	CTextMsgFilter &TextMsgFilter)				// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Protected::CompositionString");

	if(CLEANUP_COMPOSITION_STRING() || HAVE_RESULT_STRING()) // If result string..
	{
		LONG	cch = 0;
		HIMC	hIMC = LocalGetImmContext(TextMsgFilter);		// Get host's IME context.
		WCHAR	szCompStr[256];

		if(hIMC)									// Get result string.
		{
			cch = GetCompositionStringInfo(hIMC, GCS_RESULTSTR, 
							szCompStr, sizeof(szCompStr)/sizeof(szCompStr[0]),
							NULL, 0, NULL, NULL, TextMsgFilter._uKeyBoardCodePage, FALSE, TextMsgFilter._fUsingAIMM);
			LocalReleaseImmContext(TextMsgFilter, hIMC);			// Done with IME context.
		}
		return NOERROR;								// Don't want WM_IME_CHARs.
	}

	// Terminate composition to force a end composition message
	TerminateIMEComposition(TextMsgFilter, CIme::TERMINATE_FORCECANCEL);
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\magellan.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module magellan.cpp -- Handle magellan mouse. |
 *	
 *		For REC 2, Magellan mouse can roll scroll and mButtonDown drag scroll.
 *
 *	Owner: <nl>
 *		Jon Matousek - 1996
 *
 *	Copyright (c) 1995-1996 Microsoft Corporation. All rights reserved.
 */								 

#include "_common.h"

#if !defined(NOMAGELLAN)

#include "_edit.h"
#include "_disp.h"
#include "_magelln.h"

ASSERTDATA

/*
 *	CMagellan::MagellanStartMButtonScroll
 *
 *	@mfunc
 *		Called when we get an mButtonDown message. Initiates tracking
 *		of the mouse which in turn will scroll at various speeds based
 *		on how far the user moves the mouse from the mDownPt.
 *
 *	@rdesc
 *		TRUE if the caller should capture the mouse.
 *
 */
BOOL CMagellan::MagellanStartMButtonScroll( CTxtEdit &ed, POINT mDownPt )
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CMagellan::MagellanStartMButtonScroll");

	RECT	rc;
	BOOL	fCapture = FALSE;
	CDisplay *pdp;

	pdp = ed._pdp;
	if ( pdp)
	{
		pdp->GetViewRect(rc);						// skip scroll bars, etc.
		if ( PtInRect(&rc, mDownPt) && !_fMButtonScroll )
		{
			fCapture				= TRUE;
			_ID_currMDownBMP		= 0;
			_fMButtonScroll			= TRUE;			// Now tracking...
			_zMouseScrollStartPt	= mDownPt;
			_fLastScrollWasRoll		= FALSE;		// Differentiate type.

			CheckInstallMagellanTrackTimer ( ed );	// Fire up timer...
		}
	}
	return fCapture;
}

/*
 *	CMagellan::MagellanEndMButtonScroll
 *
 *	@mfunc
 *		Finished tracking mButtonDown magellan scroll, finish up state.
 *
 */
VOID CMagellan::MagellanEndMButtonScroll( CTxtEdit &ed )
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CMagellan::MagellanEndMButtonScroll");

	CDisplay *pdp;


	_fMButtonScroll = FALSE;
	CheckRemoveMagellanUpdaterTimer ( ed );			// Remove timer...

	pdp = ed._pdp;
	if ( pdp )
	{
		pdp->FinishSmoothVScroll();			// So smooth scroll stops.
		InvertMagellanDownBMP(pdp, FALSE, NULL);	// Turn it off.
	}

	if ( _MagellanMDownBMP )						// Release bitmap.
	{
		DeleteObject( _MagellanMDownBMP );
		_MagellanMDownBMP = NULL;
		_ID_currMDownBMP = 0;
	}
}

/*
 *	CMagellan::MagellanRollScroll
 *
 *	@mfunc
 *		Handle the Magellan WM_MOUSEROLLER message. This routine has global, internal
 *		state that allows the number of lines scrolled to increase if the user continues
 *		to roll the wheel in rapid succession.
 *
 */
VOID CMagellan::MagellanRollScroll ( CDisplay *pdp, int direction, WORD cLines, 
			int speedNum, int speedDenom, BOOL fAdditive )
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CMagellan::MagellanRollScroll");

	static DWORD	lastFastRollTime;
	static int		lastDirection;
	static INT		cFastRolls;
	DWORD			tickCount = GetTickCount();

	if ( !_fMButtonScroll && pdp )
	{
														// start/continue fast
		if ( tickCount - lastFastRollTime <	FAST_ROLL_SCROLL_TRANSITION_TICKS			
			|| ((lastDirection ^ (direction < 0 ? -1 : 1)) == 0	// or, same sign
					&& _fLastScrollWasRoll				// and in slow.
					&& pdp->IsSmoothVScolling() ))
		{
			cFastRolls++;
			if ( cFastRolls > FASTER_ROLL2_COUNT )		// make faster.
				cLines <<= 1;
			else if ( cFastRolls > FASTER_ROLL1_COUNT )	// make fast
				cLines += 1;
			speedNum = cLines;							// Cancel smooth
														// effect.
			lastFastRollTime = tickCount;
		}
		else
		{
			cFastRolls = 0;
		}												// Do the scroll.
		pdp->SmoothVScroll( direction, cLines, speedNum, speedDenom, TRUE);

		_fLastScrollWasRoll = TRUE;
		lastDirection = (direction < 0) ? -1 : 1;
	}
}

/*
 *	CMagellan::CheckInstallMagellanTrackTimer
 *
 *	@mfunc
 *		Install a timing task that will allow TrackUpdateMagellanMButtonDown
 *		To be periodically called.
 *
 *	@devnote
 *		The CTxtEdit class handles all WM_TIMER dispatches, so there's glue there
 *		to call our magellan routine.
 *
 */
VOID CMagellan::CheckInstallMagellanTrackTimer ( CTxtEdit &ed )
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CMagellan::CheckInstallMagellanTrackTimer");

	ed.TxSetTimer(RETID_MAGELLANTRACK, cmsecScrollInterval);
}

/*
 *	CMagellan::CheckRemoveMagellanUpdaterTimer
 *
 *	@mfunc
 *		Remove the timing task that dispatches to TrackUpdateMagellanMButtonDown.
 *
 */
VOID CMagellan::CheckRemoveMagellanUpdaterTimer ( CTxtEdit &ed )
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CMagellan::CheckRemoveMagellanUpdaterTimer");

	ed.TxKillTimer(RETID_MAGELLANTRACK);
}

/*
 *	CMagellan::TrackUpdateMagellanMButtonDown
 *
 *	@mfunc
 *		After mButtonDown capture, a periodic WM_TIMER calls this from OnTxTimer(). The cursor
 *		is tracked to determine direction, speed, and in dead zone (not moving).
 *		Movement is dispacted to CDisplay. The cursor is set to the appropriate
 *		direction cusor, and the mButtonDown point BMP is drawn.
 */
VOID CMagellan::TrackUpdateMagellanMButtonDown ( CTxtEdit &ed, POINT mousePt )
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CMagellan::TrackUpdateMagellanMButtonDown");

	RECT	deadZone, rcClient;
	WORD	wide, tall, xInset, yInset;
	POINT	pt, center;

	LONG	xDiff, yDiff, inflate, target;

	SHORT	IDC_mScrollCursor, IDC_mDeadScrollCursor;

	BOOL	fDoHScroll, fDoVScroll;
	BOOL	fFastScroll = FALSE;

	CDisplay *pdp;

	pdp = ed._pdp;

	Assert ( _fMButtonScroll );
	Assert ( pdp );
													// Calc dead zone rect.
	deadZone.top = deadZone.bottom = _zMouseScrollStartPt.y;
	deadZone.left = deadZone.right = _zMouseScrollStartPt.x;
	inflate = pdp->LYtoDY(DEAD_ZONE_TWIPS);
	InflateRect(&deadZone, inflate, inflate);

	
	//
	//	Calculate direction to scroll and what cusor to display. 
	//
	//	By numbering a compass like the following, we can easily calc the index into
	//	the scrollCursors array to get the proper cursor:
	//
	//							North = 1
	//					NW = 7				NE = 4
	//				West = 6					East = 3
	//					SW = 8				SE = 5
	//							South = 2
	//
	IDC_mScrollCursor = 0;
	IDC_mDeadScrollCursor = 0;
	fDoVScroll = FALSE;
	fDoHScroll = FALSE;
	if ( pdp->IsVScrollEnabled() )					// Can scroll vertically?
	{
		IDC_mDeadScrollCursor = 1;
		if ( mousePt.y < deadZone.top || mousePt.y > deadZone.bottom )
		{
			fDoVScroll = TRUE;
			IDC_mScrollCursor = ( mousePt.y < _zMouseScrollStartPt.y )	? 1 : 2;
		}
	}

	// FUTURE (alexgo): allow magellan scrolling even for single line
	// controls with no scrollbar.  For now, however, that change is too
	// risky, so we look explicity for a scrollbar.
	if( pdp->IsHScrollEnabled() && ed.TxGetScrollBars() & WS_HSCROLL )	// Can scroll horizontally?
	{
		IDC_mDeadScrollCursor |= 2;
		if ( mousePt.x < deadZone.left || mousePt.x > deadZone.right )
		{
			fDoHScroll = TRUE;
			IDC_mScrollCursor += ( mousePt.x < _zMouseScrollStartPt.x ) ? 6 : 3;
		}
	}

	SHORT scrollCursors[] = {						// Cursor for various
		0,											//  directions.

		IDC_SCROLLNORTH,
		IDC_SCROLLSOUTH,
		IDC_SCROLLEAST,
		IDC_SCROLLNE,
		IDC_SCROLLSE,
		IDC_SCROLLWEST,
		IDC_SCROLLNW,
		IDC_SCROLLSW
	};
	IDC_mScrollCursor = scrollCursors[IDC_mScrollCursor];

	SHORT mDownBMPs[] = {							// mButtonDown origin BMPs.
		0,

		IDB_1DVSCROL,
		IDB_1DHSCROL,
		IDB_2DSCROL
	};

													// BMAP-mButtonDown for UI
	if ( mDownBMPs[IDC_mDeadScrollCursor] != _ID_currMDownBMP )
	{
		if ( _MagellanMDownBMP )					// Undraw old BMP.
		{
			InvertMagellanDownBMP( pdp, FALSE, NULL );

			DeleteObject ( _MagellanMDownBMP );
			_MagellanMDownBMP = NULL;
		}
													// Draw new BMP.
		_ID_currMDownBMP = mDownBMPs[IDC_mDeadScrollCursor];
		_MagellanMDownBMP = LoadBitmap ( hinstRE, MAKEINTRESOURCE ( _ID_currMDownBMP ) );
		InvertMagellanDownBMP( pdp, TRUE, NULL );
	}

													// Moved out of dead zone?
	if ( fDoVScroll || fDoHScroll )					//  time to scroll...
	{									

													// Prepare data for
													//  scrolling routines.

		ed.TxGetClientRect(&rcClient);				// Get our client rect.
		wide = rcClient.right - rcClient.left;
		tall = rcClient.bottom - rcClient.top;

													// Calc center of rcClient.
		center.x = rcClient.left + (wide >> 1);
		center.y = rcClient.top + (tall >> 1);

		xInset = (wide >> 1) - 2;					// Get inset to center
		yInset = (tall >> 1) - 2;					//  about rcClient.

													// Map origin to rcClient.
		xDiff = mousePt.x - _zMouseScrollStartPt.x;
		yDiff = mousePt.y - _zMouseScrollStartPt.y;
		pt.x = center.x + xDiff;
		pt.y = center.y + yDiff;
													// Determine scroll speed.
		target = (tall * 2) / 5;					// target is 40% of screen
													// height.  Past that, we
													// scroll page at a time.

		yDiff = abs(yDiff);

		if ( yDiff >= target )						// Fast scroll?
		{
			fFastScroll = TRUE;
													// Stop mutually exclusive
			pdp->CheckRemoveSmoothVScroll();		//  scroll type.

													// Fast line scroll.
			if ( fDoVScroll )						// Vertically a page at a time.
			{
				pdp->VScroll( ( _zMouseScrollStartPt.y - mousePt.y < 0 ) ? SB_PAGEDOWN : SB_PAGEUP, 0 );
			}

			if ( fDoHScroll )						
			{										
				pt.y = center.y;					// Prevent y dir scrolling.
													// Do x dir scroll.
				pdp->AutoScroll( pt, xInset, 0 );
			}
		}
		else										// Smooth scroll.
		{
													// Start, or continue
													//  smooth vertical scrolling.

			// This formula is a bit magical, but here goes.  What
			// we want is the sub-linear part of an exponential function.
			// In other words, smallish distances should produce pixel
			// by pixel scrolling.  At 40% of the screen height, however,
			// we should be srolling by a page at a time (tall # of pixels).
			//
			// So the formula we use is (x^2)/tall, where x is yDiff scaled
			// to be in units of tall (i.e. 5yDiff/2).   The final 10* 
			// multiplier is to shift all the values leftward so we can
			// do this in integer arithmetic.
			LONG num = MulDiv(10*25*yDiff/4, yDiff, tall);

			if( !num )
			{
				num = 1;
			}

			if ( fDoVScroll )
			{
				pdp->SmoothVScroll ( _zMouseScrollStartPt.y - mousePt.y,
									0, num, 10*tall, FALSE );
			}
			
													// x direction scrolling?
			if ( fDoHScroll )						
			{										
				pt.y = center.y;					// Prevent y dir scrolling.
													// Do x dir scroll.
				pdp->AutoScroll( pt, xInset, 0 );
			}
		}

		// notify through the messagefilter that we scrolled
		if ((ed._dwEventMask & ENM_SCROLLEVENTS) && (fDoHScroll || fDoVScroll))
		{
			MSGFILTER msgfltr;
			ZeroMemory(&msgfltr, sizeof(MSGFILTER));
			if (fDoHScroll)
			{
				msgfltr.msg = WM_HSCROLL;
				msgfltr.wParam = fFastScroll ?
									(xDiff > 0 ? SB_PAGERIGHT: SB_PAGELEFT):
									(xDiff > 0 ? SB_LINERIGHT: SB_LINELEFT);
			}
			else
			{
				msgfltr.msg = WM_VSCROLL;
				msgfltr.wParam = fFastScroll ?
									(yDiff > 0 ? SB_PAGEDOWN: SB_PAGEUP):
									(yDiff > 0 ? SB_LINEDOWN: SB_LINEUP);
			}

			msgfltr.lParam = NULL;
			
			// we don't check the result of this call --
			// it's not a message we received and we're not going to
			// process it any further
			ed._phost->TxNotify(EN_MSGFILTER, &msgfltr);			
		}


	}
	else
	{												// No scroll in dead zone.

		SHORT noScrollCursors[] = {
			  0,
			  IDC_NOSCROLLV,
			  IDC_NOSCROLLH,
			  IDC_NOSCROLLVH
		};											// Set dead-zone cursor.
		IDC_mScrollCursor = noScrollCursors[IDC_mDeadScrollCursor];

		pdp->FinishSmoothVScroll();			// Finish up last line.
	}
													// Set magellan cursor.
	ed._phost->TxSetCursor(IDC_mScrollCursor ? 
		LoadCursor(hinstRE, MAKEINTRESOURCE(IDC_mScrollCursor)) : 
		ed._hcurArrow, FALSE);
}



/*
 *	BOOL CMagellan::InvertMagellanDownBMP
 *
 *	@mfunc
 *		Magellan mouse UI requires that the mouse down point draw
 *		and maintain a bitmap in order to help the user control scroll speed.
 *
 *	@devnote
 *		This routine is designed to be nested. It also handles WM_PAINT updates
 *		when the repaintDC is passed in. Because there is no support for multiple
 *		cursors in the operating system, all WM_PAINT and ScrollWindow redraws
 *		must temporarily turn off the BMP and then redraw it. This gives the
 *		BMAP a flicker.
 *
 *	@rdesc
 *		TRUE if the bitmap was previously drawn.
 */
BOOL CMagellan::InvertMagellanDownBMP( CDisplay *pdp, BOOL fTurnOn, HDC repaintDC )
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CMagellan::InvertMagellanDownBMP");

	BOOL	fOldState = _fMagellanBitMapOn;

	Assert (pdp);

	if ( fOldState != fTurnOn )
	{
		if ( _MagellanMDownBMP )
		{
			BITMAP	bm;
			HDC		hdcMem, screenDC;
			POINT	ptSize, ptOrg;

			screenDC = (repaintDC != NULL) ? repaintDC : pdp->GetDC();
			if ( screenDC )
			{
				hdcMem = CreateCompatibleDC ( screenDC );
				if ( hdcMem )
				{
					SelectObject ( hdcMem, _MagellanMDownBMP );
					SetMapMode ( hdcMem, GetMapMode (screenDC) );

					if ( GetObjectA( _MagellanMDownBMP, sizeof(BITMAP), (LPVOID) &bm) )
					{
						ptSize.x = bm.bmWidth;
						ptSize.y = bm.bmHeight;
						DPtoLP ( screenDC, &ptSize, 1 );
						ptOrg.x = 0;
						ptOrg.y = 0;
						DPtoLP( hdcMem, &ptOrg, 1 );

						BitBlt( screenDC,
							_zMouseScrollStartPt.x - (ptSize.x >> 1) - 1,
							_zMouseScrollStartPt.y - (ptSize.y >> 1) + 1,
							ptSize.x, ptSize.y,
							hdcMem, ptOrg.x, ptOrg.y, 0x00990066 /* NOTXOR */ );
							

						_fMagellanBitMapOn = !fOldState;
					}
					DeleteDC( hdcMem );
				}
				if ( repaintDC == NULL ) pdp->ReleaseDC( screenDC );
			}
		}
	}

	return fOldState;
}

////////////////////////// 	CMagellanBMPStateWrap class.

/*
 *	CMagellanBMPStateWrap:: CMagellanBMPStateWrap
 *
 *	@mfunc
 *		Handles the state of whether to redraw the Magellan BMP as well as
 *		repaints due to WM_PAINT.
 *
 *	@devnote
 *		This class is akin to smart pointer wrapper class idioms, in that
 *		no matter how a routine exits the correct state of whether the
 *		BMP is drawn will be maintined.
 */
CMagellanBMPStateWrap:: CMagellanBMPStateWrap(CTxtEdit &ed, HDC repaintDC)
	: _ed(ed), _repaintDC(repaintDC)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CMagellanBMPStateWrap:: CMagellanBMPStateWrap");

	BOOL fRepaint;

	fRepaint = repaintDC != NULL && _ed.mouse._fMagellanBitMapOn != 0;
	_fMagellanState = fRepaint || _ed.mouse.InvertMagellanDownBMP(_ed._pdp, FALSE, NULL);
	_ed.mouse._fMagellanBitMapOn = FALSE;
}

CMagellanBMPStateWrap::~CMagellanBMPStateWrap()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CMagellanBMPStateWrap::~CMagellanBMPStateWrap");

	_ed.mouse.InvertMagellanDownBMP(_ed._pdp, _fMagellanState, _repaintDC);
}



#endif // !defined(NOMAGELLAN)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\makefile.inc ===
$(O)\w32sys.obj : w32sys.cpp
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P)
<<NOKEEP
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo$(MAKEDIR)\$@ $(USECXX_FLAG) $(MAKEDIR)\w32sys.cpp
$(NP_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\ldte.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	LDTE.C - RichEdit Light Data Transfer Engine |
 *
 *		This file contains data transfer code using IDataObject
 *
 *	Author: <nl>
 *		alexgo (4/25/95)
 *
 *	Revisions: <nl>
 *		murrays (7/6/95) auto-doc'd and added RTF support
 *
 *	FUTURE (AlexGo): <nl>
 *		Maybe merge this class with CTxtRange to make more efficient use of
 *		the this ptr.  All but two methods use a CTxtRange and one of these
 *		could be global.  The two are:
 *
 *		GetDropTarget( IDropTarget **ppDropTarget )
 *		GetDataObjectInfo(IDataObject *pdo, DWORD *pDOIFlags) // Can be global
 *
 *		In general, a range can spawn data objects, which need to have a clone
 *		of the range in case the range is moved around.  The contained range
 *		is used for delayed rendering.  A prenotification is sent to the data
 *		object just before the data object's data is to be changed.  The data
 *		object then renders the data in its contained range, whereupon the
 *		object becomes independent of the range and destroys the range.
 *
 *	@devnote
 *		We use the word ANSI in a general way to mean any multibyte character
 *		system as distinguished from 16-bit Unicode.  Technically, ANSI refers
 *		to a specific single-byte character system (SBCS).  We translate
 *		between "ANSI" and Unicode text using the Win32
 *		MultiByteToWideChar() and WideCharToMultiByte() APIs.
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_range.h"
#include "_ldte.h"
#include "_m_undo.h"
#include "_antievt.h"
#include "_edit.h"
#include "_disp.h"
#include "_select.h"
#include "_dragdrp.h"
#include "_dxfrobj.h"
#include "_rtfwrit.h"
#include "_rtfread.h"
#include "_urlsup.h"

ASSERTDATA


//Local Prototypes
DWORD CALLBACK WriteHGlobal(WRITEHGLOBAL *pwhg, LPBYTE pbBuff, LONG cb, LONG *pcb);

#define	SFF_ADJUSTENDEOP	0x80000000
//
// LOCAL METHODS
//

/*
 *	ReadHGlobal(dwCookie, pbBuff, cb, pcb)
 *
 *	@func
 *		EDITSTREAM callback for reading from an hglobal
 *
 *	@rdesc
 *		es.dwError
 */
DWORD CALLBACK ReadHGlobal(
	DWORD_PTR	dwCookie,		// @parm dwCookie
	LPBYTE	pbBuff,				// @parm Buffer to fill
	LONG	cb,					// @parm Buffer length
	LONG *	pcb)				// @parm Out parm for # bytes stored
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "ReadHGlobal");

	READHGLOBAL * const prhg = (READHGLOBAL *)dwCookie;

	cb = min(cb, prhg->cbLeft);
	CopyMemory(pbBuff, prhg->ptext, cb);
	prhg->cbLeft -= cb;
	prhg->ptext  += cb;

	if(pcb)
		*pcb = cb;
	return NOERROR;	
}

/*
 *	WriteHGlobal(pwhg, pbBuff, cb, pcb)
 *
 *	@func
 *		EDITSTREAM callback for writing ASCII to an hglobal
 *
 *	@rdesc
 *		error (E_OUTOFMEMORY or NOERROR)
 */
DWORD CALLBACK WriteHGlobal(
	DWORD_PTR	dwCookie,		// @parm dwCookie
	LPBYTE	pbBuff,				// @parm Buffer to write from
	LONG	cb,					// @parm Buffer length
	LONG *	pcb)				// @parm Out parm for # bytes written
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "WriteHGlobal");

	WRITEHGLOBAL * const pwhg = (WRITEHGLOBAL *)dwCookie;

	HGLOBAL		hglobal = pwhg->hglobal;
	LPSTR		pstr;

	if(pwhg->cch + cb > pwhg->cb)			// Less than requested cb in
	{										//  current Alloc
		ULONG cbNewSize = GROW_BUFFER(pwhg->cb, cb);
		hglobal = GlobalReAlloc(hglobal, cbNewSize, GMEM_MOVEABLE);
		if(!hglobal)	
			return (DWORD)E_OUTOFMEMORY;
		pwhg->hglobal = hglobal;			// May be superfluous...
		pwhg->cb = cbNewSize;
	}
	pstr = (LPSTR)GlobalLock(hglobal);
	if(!pstr)
		return (DWORD)E_OUTOFMEMORY;

	CopyMemory(pstr + pwhg->cch, pbBuff, cb);
	GlobalUnlock(hglobal);
	pwhg->cch += cb;
	if(pcb)
		*pcb = cb;
	return NOERROR;	
}


//
// PUBLIC METHODS
//

/*
 *	GetCharFlags(ch, bDefaultCharset)
 *
 *	@func
 *		Return flags set if ch is in first 256 Unicodes, complex-script,
 *		BiDi (RTL), FE.  Also flags identifying which charset is likely.
 *		These flags correspond to those in the font signature.
 *
 *	@rdesc
 *		Flags saying if ch is complex-script, BiDi (RTL), or FE
 *
 *		=FUTURE= should be constructed as a 2-level lookup.
 */
DWORD GetCharFlags(
	DWORD	ch,
	BYTE	bDefaultCharset)
{
	if(ch < 0x100)						// Latin1: divide into 3 bits
		return	ch > 0x7F ? fHILATIN1 :
				ch < 0x40 ? fBELOWX40 : fASCIIUPR;

	if(ch < 0x590)
	{
		if(ch >= 0x530)
			return fARMENIAN;

		if(ch >= 0x400)
			return fCYRILLIC;

		if(ch >= 0x370)
			return fGREEK;

		if(ch >= 0x300)					// Combining diacritical marks
			return fCOMBINING;			

		return (ch < 0x250) ? fLATIN2 : fOTHER;
	}
	// Complex scripts start at 0x590 with Hebrew (aside from combining)
	if(ch <= 0x10FF)					// Complex scripts end at 0x10FF
	{									//  (at least in Feb, 1998)
		if(ch < 0x900)
		{
			return	fBIDI |
					(ch < 0x600 ? fHEBREW :
					 ch < 0x700 ? fARABIC : 0);
		}
		if(ch < 0xE00)
		{
			return	(ch < 0x980 ? fDEVANAGARI :
					 ch < 0xB80 ? 0 :
					 ch < 0xC00 ? fTAMIL : 0);
		}
		if(ch < 0xF00)
			return ch < 0xE80 ? fTHAI : 0;

		return ch >= 0x10A0 ? fGEORGIAN : fOTHER;
	}
	if(ch < 0x3100)
	{
		if(ch > 0x3040)
			return fKANA;

		if(ch >= 0x3000)
			goto CLASSIFY_CHINESE;

		if(IN_RANGE(RTLMARK, ch, 0x202E) && (ch == RTLMARK ||
			IN_RANGE(0x202A, ch, 0x202E)))
		{
			return fBIDI;
		}

		if(ch <= 0x11FF)						// Hangul Jamo
			return fHANGUL;

		if(ch == EURO || ch == 0x2122)			// Euro or TM
			return fHILATIN1;

		if(ch == 0x20AA)						// Hebrew currency sign
			return fBIDI | fHEBREW;

		if (W32->IsFESystem() || IsFECharSet(bDefaultCharset))
			goto CLASSIFY_CHINESE;

		if (IN_RANGE(0x200b, ch, 0x200d))		// ZWSP, ZWNJ, ZWJ
			return fUNIC_CTRL;

		if (ch == 0x2016 || ch == 0x2236)
		{
			// Some hack to make Word2000 happy
			WCHAR	wch = ch;

			if (VerifyFEString(CP_CHINESE_TRAD, &wch, 1, TRUE) == CP_CHINESE_TRAD)
				return fBIG5;	
			
			if (VerifyFEString(CP_CHINESE_SIM, &wch, 1, TRUE) == CP_CHINESE_SIM)
				return fCHINESE;
		}

		return fOTHER;
	}
	if(ch < 0xD800)
	{		
		if (ch < 0x3400)
		{
			if (IN_RANGE(0x3130, ch, 0x318F) ||	// Hangul Compatibility Jamo
				IN_RANGE(0x3200, ch, 0x321F) ||	// Parenthesized Hangul
				IN_RANGE(0x3260, ch, 0x327F))	// Circled Hangul
				return fHANGUL;				

			if (IN_RANGE(0x032D0, ch, 0x337F))	// Circled & Squared Katakana words
				return fKANA;

			goto CLASSIFY_CHINESE;
		}
						
		if (ch < 0xAC00)
			goto CLASSIFY_CHINESE;

		return fHANGUL;
	}

	if (ch < 0xE000)
		return fSURROGATE;			// Surrogate

	if(ch < 0xF900)					// Private Use Area
	{
		if(IN_RANGE(0xF000, ch, 0xF0FF))
			return fSYMBOL;

		if (W32->IsFESystem())
			goto CLASSIFY_USER;

		return fOTHER;
	}

	if(ch < 0xFF00)
	{
		if(IN_RANGE(0xFE30, ch, 0xFE4F))		// CJK Vertical variants
			goto CLASSIFY_CHINESE;	

		if(IN_RANGE(0xF900, ch, 0xFAFF))		// CJK characters
			goto CLASSIFY_CHINESE;	

		return fOTHER;
	}

	if(IN_RANGE(0xFF00, ch, 0xFFEF))		
	{										
		if (ch < 0xFF60 || ch >= 0xFFE0 ||		// Fullwidth ASCII or Fullwidth symbols
			ch == 0xFF64)						// special case Half-width ideographic comma
			goto CLASSIFY_CHINESE;		
							
		return ch < 0xFFA0 ? fKANA : fHANGUL;	// Halfwidth Katakana/Hangul		
	}
	return fOTHER;

CLASSIFY_CHINESE:
	if (bDefaultCharset)
	{
		switch (bDefaultCharset)
		{
			case SHIFTJIS_CHARSET:
				return fKANA;

			case HANGEUL_CHARSET:
				return fHANGUL;

			case CHINESEBIG5_CHARSET:
				return fBIG5;

			case GB2312_CHARSET:
				return fCHINESE;
		}
	}

CLASSIFY_USER:
	switch (W32->GetFEFontInfo())
	{
		case CP_JAPAN:
			return fKANA;

		case CP_KOREAN:
			return fHANGUL;

		case CP_CHINESE_TRAD:
			return fBIG5;

		default:
		// case CP_CHINESE_SIM:
			return fCHINESE;

	}
}

/*
 *	CLightDTEngine::CLightDTEngine()
 *
 *	@mfunc
 *		Constructor for Light Data Transfer Engine
 */
CLightDTEngine::CLightDTEngine()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::CLightDTEngine");

	_ped = NULL;
	_pdt = NULL;
	_pdo = NULL;
	_fUseLimit = FALSE;
	_fOleless = FALSE;
}

/*
 *	CLightDTEngine::~CLightDTEngine
 *
 *	@mfunc
 *		Handles all necessary clean up for the object..
 */
CLightDTEngine::~CLightDTEngine()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::~CLightDTEngine");

	if( _pdt )
	{
		_pdt->Zombie();
		_pdt->Release();
		_pdt = NULL;
	}
	Assert(_pdo == NULL);
}

/*
 *	CLightDTEngine::Destroy()
 *
 *	@mfunc
 *		Deletes this instance
 */
void CLightDTEngine::Destroy()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::Destroy");

	delete this;
}

/*
 *	CLightDTEngine::CopyRangeToClipboard ( prg )
 *
 *	@mfunc
 *		Copy the text of the range prg to the clipboard using Win32 APIs
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT CLightDTEngine::CopyRangeToClipboard(
	CTxtRange *prg )				// @parm range to copy to clipboard
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::CopyRangeToClipboard");

	HRESULT hresult = E_FAIL;
	IDataObject *pdo = NULL;
	IRichEditOleCallback * precall = _ped->GetRECallback();
	BOOL fSingleObject;
	CHARRANGE chrg;

	prg->GetRange(chrg.cpMin, chrg.cpMost);

	if (chrg.cpMin >= chrg.cpMost)
	{
		// We can't copy an insertion point to the clipboard so we are done.
		return NOERROR;
	}

	fSingleObject = chrg.cpMost - chrg.cpMin == 1 &&
		_ped->HasObjects() &&
		_ped->_pobjmgr->CountObjectsInRange(chrg.cpMin, chrg.cpMost);
	if(precall)
	{
		// Give the callback a chance to give us it's own IDataObject
		hresult = precall->GetClipboardData(&chrg, RECO_COPY, &pdo);
	}

	// If we didn't get an IDataObject from the callback, build our own
	if(hresult != NOERROR)
	{
		// If the range is empty, don't bother creating it.  Just
		// leave the clipboard alone and return
		if( prg->GetCch() == 0 )
		{
			_ped->Beep();
			return NOERROR;
		}

		hresult = RangeToDataObject(prg, SF_TEXT | SF_RTF, &pdo);
	}

	// NB: it's important to check both hresult && pdo; it is legal for
	// our client to say "yep, I handled the copy, but there was nothing
	// to copy".
	if( hresult == NOERROR && pdo )
	{
		hresult = OleSetClipboard(pdo);
		if( hresult != NOERROR )
		{
			HWND hwnd;
			_fOleless = TRUE;
			// Ole less clipboard support
			if (_ped->TxGetWindow(&hwnd) == NOERROR &&
				::OpenClipboard(hwnd) &&
				::EmptyClipboard()
			)
			{
				::SetClipboardData(cf_RTF, NULL);

				::SetClipboardData(CF_UNICODETEXT, NULL);
				if(_ped->GetCharFlags() & ~(fLATIN1 | fSYMBOL))
				{
					::SetClipboardData(cf_RTFUTF8, NULL);
					::SetClipboardData(cf_RTFNCRFORNONASCII, NULL);
				}
				::SetClipboardData(CF_TEXT, NULL);

				if (fSingleObject)
					::SetClipboardData(CF_DIB, NULL);
				::CloseClipboard();
				hresult = NOERROR;				// To cause replace range to happen
			}
		}
        if(_pdo)
			_pdo->Release();
		_pdo = pdo;
	}
	return hresult;
}

/*
 *	CLightDTEngine::CutRangeToClipboard( prg, publdr );
 *	
 *	@mfunc
 *		Cut text of the range prg to the clipboard
 *
 *	@devnote
 *		If publdr is non-NULL, anti-events for the cut operation should be
 *		stuffed into this collection
 *
 *	@rdesc
 *		HRESULT from CopyRangeToClipboard()
 *
 *	@devnote
 *		First copy the text to the clipboard, then delete it from the range
 */
HRESULT CLightDTEngine::CutRangeToClipboard(
	CTxtRange *	  prg,			// @parm Range to cut to clipboard
	IUndoBuilder *publdr )		// @parm Undo builder to receive antievents
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::CutRangeToClipboard");

	Assert(!_ped->TxGetReadOnly());

	prg->AdjustEndEOP(NONEWCHARS);				// Don't include trailing EOP
												//  in some selection cases
	HRESULT hr = CopyRangeToClipboard(prg);

	if( publdr )
	{
		publdr->SetNameID(UID_CUT);
		publdr->StopGroupTyping();
	}

	if(hr == NOERROR)							// Delete contents of range
		prg->Delete(publdr, SELRR_REMEMBERRANGE);	

	return hr;
}


/*
 *	CLightDTEngine::FlushClipboard()
 *
 *	@mfunc	flushes the clipboard (if needed).  Typically called during
 *			shutdown.
 *
 *	@rdesc	void
 */
void CLightDTEngine::FlushClipboard()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::FlushClipboard");
	ENSAVECLIPBOARD ens;

	if( _pdo )
	{
		if( OleIsCurrentClipboard(_pdo) == NOERROR )
		{
			CDataTransferObj *pdo = NULL;

			// check to see if we have to flush the clipboard.
			ZeroMemory(&ens, sizeof(ENSAVECLIPBOARD));

			// check to make sure the object is one of ours before accessing
			// the memory.  EVIL HACK ALERT.  'nuff said.

			if( _pdo->QueryInterface(IID_IRichEditDO, (void **)&pdo )
				== NOERROR && pdo  )
			{
				ens.cObjectCount = pdo->_cObjs;
				ens.cch = pdo->_cch;
				pdo->Release();
			}

			if( _ped->TxNotify(EN_SAVECLIPBOARD, &ens) == NOERROR )
				OleFlushClipboard();

			else
				OleSetClipboard(NULL);
		}
		_pdo->Release();
		_pdo = NULL;
	}
}

/*
 *	CLightDTEngine::CanPaste(pdo, cf, flags)
 *
 *	@mfunc
 *		Determines if clipboard format cf is one we can paste.
 *
 *	@rdesc
 *		BOOL - true if we can paste cf into range prg OR DF_CLIENTCONTROL
 *		if the client is going to handle this one.
 *
 *	@devnote
 *		we check the clipboard ourselves if cf is 0. Primarily, this
 *		is for backwards compatibility with Richedit1.0's EM_CANPASTE
 *		message.
 *
 */
DWORD CLightDTEngine::CanPaste(
	IDataObject *pdo,	// @parm Data object to check; if NULL use clipboard
	CLIPFORMAT cf, 		// @parm clipboard format to query about; if 0, use
						//		 best available.
	DWORD flags)		// @parm flags
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::CanPaste");

	IRichEditOleCallback *precall = _ped->GetRECallback();
	CLIPFORMAT	cf0 = cf;
	DWORD		cFETC = CFETC;
	HRESULT		hr = NOERROR;
	DWORD		ret = FALSE;

#ifndef MACPORT								
	if( pdo == NULL && precall )
#else
	if( pdo == NULL)
#endif
	{
		// don't worry about errors
		OleGetClipboard(&pdo);
	}
	else if( pdo )
	{
		// So we can make just one 'Release' call below
		pdo->AddRef();
	}
	
	if( precall && pdo )
	{
		hr = precall->QueryAcceptData(pdo, &cf, flags, 0, NULL);

		if( SUCCEEDED(hr) && (hr != S_OK && hr != DATA_S_SAMEFORMATETC ) )
		{
			ret = DF_CLIENTCONTROL;
			goto Exit;
		}
		else if( FAILED(hr) && hr != E_NOTIMPL )
			goto Exit;

		else if(SUCCEEDED(hr))
		{
			// We should go on and check ourselves unless the client
			// modified the format when it shouldn't have
			if(cf0 && cf0 != cf)
				goto Exit;
		}

		// otherwise, continue with our normal checks
	}

    if(_ped->TxGetReadOnly())		    // Can't paste if read only
		goto Exit;

	while(cFETC--)						// Does cf = format we can paste or
	{									//  is selection left up to us?
		cf0 = g_rgFETC[cFETC].cfFormat;
	    if( cf == cf0 || !cf )
		{
			// Either we hit the format requested, or no format
			// was requested.  Now see if the format matches what
			// we could handle in principle.  There are three
			// basic categories:
			//		1. we are rich text and have an OLE callback;
			//		then we can handle pretty much everything.
			//		2. we are rich text but have no OLE callback.
			//		then we can handle anything but OLE specific
			//		formats.
			//		3. we are plain text only.  Then we can only
			//		handle plain text formats.

			if( (_ped->_fRich || (g_rgDOI[cFETC] & DOI_CANPASTEPLAIN)) &&
				(precall || !(g_rgDOI[cFETC] & DOI_CANPASTEOLE)))
			{
				// once we get this far, make sure the data format
				// is actually available.
				if( (pdo && pdo->QueryGetData(&g_rgFETC[cFETC]) == NOERROR ) ||
					(!pdo && IsClipboardFormatAvailable(cf0)) )
				{
					ret = TRUE;			// Return arbitrary non zero value.
					break;
				}
			}
		}
    }	

Exit:
	if(pdo)
		pdo->Release();

	return ret;
}

/*
 *	CLightDTEngine::RangeToDataObject (prg, lStreamFormat, ppdo)
 *
 *	@mfunc
 *		Create data object (with no OLE-formats) for the range prg
 *
 *	@rdesc
 *		HRESULT	= !ppdo ? E_INVALIDARG :
 *				  pdo ? NOERROR : E_OUTOFMEMORY
 */
HRESULT CLightDTEngine::RangeToDataObject(
	CTxtRange *		prg,			// @parm Range to get DataObject for
	LONG			lStreamFormat,	// @parm stream format to use for loading
	IDataObject **	ppdo)			// @parm Out parm for DataObject
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::RangeToDataObject");

	if(!ppdo)
		return E_INVALIDARG;

	CDataTransferObj *pdo = CDataTransferObj::Create(_ped, prg, lStreamFormat);

	*ppdo = pdo;
	return pdo ? NOERROR : E_OUTOFMEMORY;
}

/*
 *	CLightDTEngine::RenderClipboardFormat(wFmt)
 *
 *	@mfunc
 *		Renders current clipboard data object in specified format. (Ole less transfer)
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT CLightDTEngine::RenderClipboardFormat(
	WPARAM wFmt)
{
	HRESULT hr = S_OK;
	if(_fOleless &&
		(wFmt == cf_RTF || wFmt == CF_UNICODETEXT || wFmt == CF_DIB || wFmt == CF_TEXT))
	{
		Assert(_pdo);
		STGMEDIUM med;
		DWORD iFETC = iUnicodeFETC;
		if (wFmt == cf_RTF)
			iFETC = iRtfFETC;
		else if (wFmt == CF_DIB)
			iFETC = iDIB;
		else if (wFmt == CF_TEXT)
			iFETC = iAnsiFETC;
		med.tymed = TYMED_HGLOBAL;
		med.pUnkForRelease = NULL;
		med.hGlobal = NULL;
		hr = _pdo->GetData(&g_rgFETC[iFETC], &med);
		hr = hr || ::SetClipboardData(wFmt, med.hGlobal) == NULL;
	}
	return hr;		// Pretend we did the right thing.
}

/*
 *	CLightDTEngine::RenderAllClipboardFormats()
 *
 *	@mfunc
 *		Renders current clipboard data object (text and RTF). (Ole less transfer)
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT CLightDTEngine::RenderAllClipboardFormats()
{
	HRESULT hr;
	if(_fOleless)
	{
		HWND howner = ::GetClipboardOwner();
		HWND hwnd;
		if (howner &&
			_ped->TxGetWindow(&hwnd) == NOERROR &&
			howner == hwnd &&
			::OpenClipboard(hwnd))
		{
			::EmptyClipboard();
			hr = RenderClipboardFormat(cf_RTF);
			hr = hr || RenderClipboardFormat(CF_UNICODETEXT);
			hr = hr || RenderClipboardFormat(CF_DIB);
			hr = hr || RenderClipboardFormat(CF_TEXT);
			::CloseClipboard();
			return hr;
		}
	}
	return S_OK;		// Pretend we did the right thing.
}

/*
 *	CLightDTEngine::DestroyClipboard()
 *
 *	@mfunc
 *		Destroys the clipboard data object
 *
 *	@rdesc
 *		HRESULT
 *
 */
HRESULT CLightDTEngine::DestroyClipboard()
{
	// Nothing to do.  This should work together with our Flush clipboard logic
	return S_OK;
}

/*
 *	CLightDTEngine::HGlobalToRange(dwFormatIndex, hGlobal, ptext, prg, publdr)
 *
 *	@mfunc
 *		Copies the contents of the given string (ptext) to the given range.
 *		The global memory handle may or may not point to the string depending
 *		on the format
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT CLightDTEngine::HGlobalToRange(
	DWORD		dwFormatIndex,
	HGLOBAL		hGlobal,
	LPTSTR		ptext,
	CTxtRange *	prg,
	IUndoBuilder *publdr)
{
	READHGLOBAL	rhg;
	EDITSTREAM	es;	
	HCURSOR		hcur = NULL;

	// If RTF, wrap EDITSTREAM around hGlobal & delegate to LoadFromEs()
	if (dwFormatIndex == iRtfNoObjs || dwFormatIndex == iRtfFETC ||
		dwFormatIndex == iRtfUtf8 || dwFormatIndex == iRtfNCRforNonASCII)
	{
		Assert(hGlobal != NULL);
		rhg.ptext		= (LPSTR)ptext;			// Start at beginning
		rhg.cbLeft		= GlobalSize(hGlobal);	//  with full length
		es.dwCookie		= (DWORD_PTR)&rhg;		// The read "this" ptr
		es.dwError		= NOERROR;				// No errors yet
		es.pfnCallback	= ReadHGlobal;			// The read method
		// Want wait cursor to display sooner
		bool fSetCursor = rhg.cbLeft > NUMPASTECHARSWAITCURSOR;
		if (fSetCursor)
			hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
		LoadFromEs(prg, SFF_SELECTION | SF_RTF, &es, TRUE, publdr);
		if (fSetCursor)
			SetCursor(hcur);
		return es.dwError;
	}

	Assert( dwFormatIndex == iRtfAsTextFETC ||
			dwFormatIndex == iAnsiFETC ||
			dwFormatIndex == iUnicodeFETC );

	LONG 	cchMove, cchNew;

	cchNew = prg->CleanseAndReplaceRange(-1, ptext, TRUE, publdr, NULL, &cchMove, RR_ITMZ_NONE);

	if(prg->GetCch() && prg->IsSel())
		return E_FAIL;						// Paste failed due to UI rules

	if(_ped->IsRich() && !_ped->Get10Mode())// If rich text,
		prg->DeleteTerminatingEOP(publdr);	//  if new text ends with EOP,

	prg->ItemizeReplaceRange(cchNew, cchMove, publdr, TRUE);		// itemize w/ UnicodeBidi
											//  select and delete that EOP
	return NOERROR;							//  to agree with Word
}

/*
 *	CLightDTEngine::DIBToRange(hGlobal, prg, publdr)
 *
 *	@mfunc
 *		Inserts dib data from the clipboard into range in the control
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT CLightDTEngine::DIBToRange(
	HGLOBAL			hGlobal,
	CTxtRange *		prg,	
	IUndoBuilder *	publdr)
{
	HRESULT         hresult = DV_E_FORMATETC;
	REOBJECT        reobj = { 0 };
	LPBITMAPINFO	pbmi = (LPBITMAPINFO) GlobalLock(hGlobal);
	WCHAR           ch = WCH_EMBEDDING;

	reobj.clsid = CLSID_StaticDib;
	reobj.sizel.cx =
		(LONG) _ped->_pdp->DXtoHimetricX( pbmi->bmiHeader.biWidth );
	reobj.sizel.cy =
		(LONG) _ped->_pdp->DYtoHimetricY( pbmi->bmiHeader.biHeight );
	_ped->GetClientSite(&reobj.polesite);

	COleObject *pobj = (COleObject *)reobj.polesite;
	COleObject::ImageInfo *pimageinfo = new COleObject::ImageInfo;
	pobj->SetHdata(hGlobal);
	pimageinfo->xScale = 100;
	pimageinfo->yScale = 100;
	pimageinfo->xExtGoal = reobj.sizel.cx;
	pimageinfo->yExtGoal = reobj.sizel.cy;
	pimageinfo->cBytesPerLine = 0;
	pobj->SetImageInfo(pimageinfo);
	
	// FUTURE: Why are we not testing for NULL earlier before we assign it to pobj? v-honwch
	// Also, do we need to release interfaces inside reobj (poleobj, polesite, pstg) before exit?
	if (!reobj.polesite )
		return hresult;

	// Put object into the edit control
	reobj.cbStruct = sizeof(REOBJECT);
	reobj.cp = prg->GetCp();
	reobj.dvaspect = DVASPECT_CONTENT;
	reobj.dwFlags = REO_RESIZABLE;

	// Since we are loading an object, it shouldn't be blank
	reobj.dwFlags &= ~REO_BLANK;

	prg->Set_iCF(-1);	
	prg->ReplaceRange(1, &ch, publdr, SELRR_IGNORE);
	hresult = _ped->GetObjectMgr()->InsertObject(reobj.cp, &reobj, NULL);

	return hresult;
}

/*
 *	CLightDTEngine::PasteDataObjectToRange (pdo, prg, cf, rps, pubdlr, dwFlags)
 *
 *	@mfunc
 *		Inserts data from the data object pdo into the range prg. If the
 *		clipboard format cf is not NULL, that format is used; else the highest
 *		priority clipboard format is used.  In either case, any text that
 *		already existed in the range is replaced.  If pdo is NULL, the
 *		clipboard is used.
 *
 *	@rdesc
 *		HRESULT
 *
 */
HRESULT CLightDTEngine::PasteDataObjectToRange(
	IDataObject *	pdo,		// @parm Data object to paste
	CTxtRange *		prg,		// @parm Range into which to paste
	CLIPFORMAT		cf,			// @parm ClipBoard format to paste
	REPASTESPECIAL *rps,		// @parm Special paste info
	IUndoBuilder *	publdr,		// @parm Undo builder to receive antievents
	DWORD			dwFlags)	// @parm DWORD packed flags
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::PasteDataObjectToRange");

	if(prg->GetPF()->InTable())
	{
		if(prg->GetPrevChar() == CELL && prg->_rpTX.GetChar() == CR)
		{
			if(prg->IsSel())
			{
				_ped->Beep();
				return E_FAIL;
			}
			prg->SetExtend(FALSE);		// Illegal paste point
			prg->Advance(-1);			
		}
		if(prg->IsSel())
		{
			if(prg->fHasCell())			// Can only paste inside single cell
				return E_FAIL;
		}
		else if(prg->GetCch())			// Would use _fSelHasCell, but isn't
			return E_FAIL;				//  maintained unless _fSel is TRUE
	}

	BOOL		f10Mode = _ped->Get10Mode();
	HGLOBAL		hGlobal = NULL;
	HRESULT		hresult = DV_E_FORMATETC;
	HGLOBAL		hUnicode = NULL;
	DWORD		i;
	STGMEDIUM	medium = {0, NULL};
	IDataObject *pdoSave = pdo;
	FORMATETC *	pfetc = g_rgFETC;
	LPTSTR		ptext = NULL;
	LPRICHEDITOLECALLBACK const precall = _ped->GetRECallback();
	BOOL		fThawDisplay = FALSE;
	BOOL        bFormatFound = FALSE;   // flag which determines if a matching cf format
	                                    // was found in g_rgFETC (1.0 compatibility)


	if(!pdo)								// No data object: use clipboard
	{
		hresult = OleGetClipboard(&pdo);
		if(FAILED(hresult))
		{
			// Ooops.  No Ole clipboard support
			// Need to use direct clipboard access
			HWND howner = ::GetClipboardOwner();
			HWND hwnd;
			if (howner &&
				_ped->TxGetWindow(&hwnd) == NOERROR &&
				howner == hwnd)
			{
				// We are cut/pasting within the same richedit instance
				// Use our cached clipboard data object
				pdo = _pdo;
				if(!pdo)		// Some failure
				{
					_ped->Beep();
					return hresult;
				}
				pdo->AddRef();
			}
			else
			{
				// Oh Oh We need to transfer from clipboard without data object
				// Data must be coming from another window instance
				if (_ped->TxGetWindow(&hwnd) == NOERROR &&
					::OpenClipboard(hwnd)
				)
				{
					HGLOBAL		hUnicode = NULL;

					DWORD dwFmt = iRtfUtf8;				// Try for UTF8 RTF
					_ped->_pdp->Freeze();
					if(!f10Mode)
					{
						hGlobal = ::GetClipboardData(cf_RTFUTF8);
						if (hGlobal == NULL)				// Wasn't there, so
						{									//  try for RTF
							hGlobal = ::GetClipboardData(cf_RTFNCRFORNONASCII);
							dwFmt = iRtfNCRforNonASCII;
						}
					}
					if (hGlobal == NULL)				// Wasn't there, so
					{									//  try for RTF
						hGlobal = ::GetClipboardData(cf_RTF);
						dwFmt = iRtfFETC;
					}
					if (hGlobal == NULL && !f10Mode)	// Wasn't there either
					{									//  so try for plain
						hGlobal = ::GetClipboardData(CF_UNICODETEXT);
						dwFmt = iUnicodeFETC;
					}
					if (hGlobal == NULL)				// Wasn't there either
					{									//  so try for plain text
						hGlobal = ::GetClipboardData(CF_TEXT);
						dwFmt = iAnsiFETC;
					}
					if (hGlobal)
					{
						if (dwFmt == iAnsiFETC)
						{
							// Convert Ansi plain text to Unicode
							hUnicode = TextHGlobalAtoW(hGlobal);
							if (hUnicode)
								ptext = (LPTSTR)GlobalLock(hUnicode);
						}
						else
							ptext = (LPTSTR)GlobalLock(hGlobal);

						if (ptext)
							hresult = HGlobalToRange(dwFmt, hGlobal, ptext, prg, publdr);
						else
							hresult = E_OUTOFMEMORY;

						if (hUnicode)
						{
							// Free plain text buffer
							GlobalUnlock(hUnicode);
							GlobalFree(hUnicode);
						}
						else
							GlobalUnlock(hGlobal);
					}
					else								// hGlobal == NULL Try for bitmaps
					{
						hGlobal = ::GetClipboardData(CF_DIB);
						if (hGlobal)
							hresult =  DIBToRange(hGlobal, prg, publdr);
					}
					_ped->_pdp->Thaw();
					::CloseClipboard();
				}
				if (FAILED(hresult))
					_ped->Beep();
				return hresult;
			}
		}
	}

	// Paste an object uses the limit text calculation
	_fUseLimit = TRUE;

	//Call QueryAcceptData unless caller has specified otherwise
	if(!(dwFlags & PDOR_NOQUERY) && precall)
	{
		CLIPFORMAT cfReq = cf;
		HGLOBAL hmeta = NULL;

		if(rps)
			hmeta = (HGLOBAL)((rps->dwAspect == DVASPECT_ICON) ? rps->dwParam : NULL);

		// Ask callback if it likes the data object and cfReq.

		hresult = precall->QueryAcceptData(
			pdo,
			&cfReq,
			(dwFlags & PDOR_DROP) ? RECO_DROP : RECO_PASTE,
			TRUE,
			hmeta);

		if(hresult == DATA_S_SAMEFORMATETC)
		{
			// Allow callback to return DATA_S_SAMEFORMATETC if it only
			// wants cf as passed in - we don't really care because
			// any non-zero CLIPFORMAT causes us to only accept that format.
			hresult = S_OK;
		}

		if(hresult == S_OK || hresult == E_NOTIMPL)
		{
			// Callback either liked it or didn't implement the method.
			// It may have changed the format while it was at it.
			// Treat a change of cf to zero as acceptance of the original.
			// In any event, we will try to handle it.

			// If a specific CLIPFORMAT was originally requested and the
			// callback changed it, don't accept it.
			if(cfReq && cf && (cf != cfReq))
			{
				hresult = DV_E_FORMATETC;
				goto Exit;
			}

			// If a specific CLIPFORMAT was originally requested and the
			// callback either left it alone or changed it to zero,
			// make sure we use the original.  If no CLIPFORMAT was
			// originally requested, make sure we use what came back
			// from the callback.
			if(!cf)
				cf = cfReq;
		}
		else
		{
			// Some success other than S_OK && DATA_S_SAMEFORMATETC.
			// The callback has handled the paste.  OR some error
			// was returned.
			goto Exit;
		}
	}

	// Even if the rich edit client wants CF_TEXT
	// If the data object supports CF_UNICODETEXT, we should prefer it.
	// as long as we are not in 1.0 mode
	if(cf == CF_TEXT && !f10Mode)
	{
		FORMATETC fetc = {CF_UNICODETEXT, NULL, 0, -1, TYMED_NULL};
		
		if(pdo->QueryGetData(&fetc) == S_OK)
			cf = CF_UNICODETEXT;
	}

	if (_ped->TxGetReadOnly())			// Should check for range protection
	{
		hresult = E_ACCESSDENIED;
		goto Exit;
	}

	// At this point we freeze the display
	fThawDisplay = TRUE;
	_ped->_pdp->Freeze();

	if( publdr )
	{
		publdr->StopGroupTyping();
		publdr->SetNameID(UID_PASTE);
	}

    for( i = 0; i < CFETC; i++, pfetc++ )
	{
		// Make sure the format is either 1.) a plain text format
		// if we are in plain text mode or 2.) a rich text format
		// or 3.) matches the requested format.

		if( cf && cf != pfetc->cfFormat )
			continue;

		if( _ped->IsRich() || (g_rgDOI[i] & DOI_CANPASTEPLAIN) )
		{
			// Make sure format is available
			if( pdo->QueryGetData(pfetc) != NOERROR )
			    continue;			

			// If we have a format that uses an hGlobal get and lock it
			if (i == iRtfFETC  || i == iRtfAsTextFETC ||
				i == iAnsiFETC || i == iRtfNoObjs	  ||
				!f10Mode && (i == iUnicodeFETC || i == iRtfUtf8 || i == iRtfNCRforNonASCII))
			{
				if( pdo->GetData(pfetc, &medium) != NOERROR )
					continue;

                hGlobal = medium.hGlobal;
				ptext = (LPTSTR)GlobalLock(hGlobal);
				if( !ptext )
				{
					ReleaseStgMedium(&medium);

					hresult = E_OUTOFMEMORY;
					goto Exit;
				}

				// 1.0 COMPATBILITY HACK ALERT!  RichEdit 1.0 has a bit of
				// "error recovery" for parsing rtf files; if they aren't
				// valid rtf, it treats them as just plain text.
				// Unfortunately, apps like Exchange depend on this behavior,
				// i.e., they give RichEdit plain text data, but call it rich
				// text anyway.  Accordingly, we emulate 1.0 behavior here by
				// checking for an rtf signature.
				if ((i == iRtfFETC || i == iRtfNoObjs || i == iRtfUtf8) &&
					!IsRTF((char *)ptext))
				{
					i = iAnsiFETC;			// Not RTF, make it ANSI text
				}
			}			
			else if (f10Mode && (i == iUnicodeFETC || i == iRtfUtf8))
			{
				// This else handles the case where we want to keep searching
				// for a goood format.  i.e. Unicode in 10 Mode
				continue;
			}

			// Don't delete trail EOP in some cases
			prg->AdjustEndEOP(NONEWCHARS);
			
			// Found a format we want.
			bFormatFound = TRUE;

			switch(i)									
			{											
			case iRtfNoObjs:							
			case iRtfFETC:								
			case iRtfUtf8:								
			case iRtfNCRforNonASCII:								
				hresult = HGlobalToRange(i, hGlobal, ptext, prg, publdr);
				break;
	
			case iRtfAsTextFETC:
			case iAnsiFETC:								// ANSI plain text		
				hUnicode = TextHGlobalAtoW(hGlobal);
				ptext	 = (LPTSTR)GlobalLock(hUnicode);
				if(!ptext)
				{
					hresult = E_OUTOFMEMORY;			// Unless out of RAM,
					break;								//  fall thru to
				}										//  Unicode case
														
			case iUnicodeFETC:							// Unicode plain text
				// Ok to pass in NULL for hglobal since argument won't be used
				hresult = HGlobalToRange(i, NULL, ptext, prg, publdr);
				if(hUnicode)							// For iAnsiFETC case
				{
					GlobalUnlock(hUnicode);
					GlobalFree(hUnicode);
				}			
				break;

			case iObtDesc:	 // Object Descriptor
				continue;	 // To search for a good format.
				             // the object descriptor hints will be used
				             // when the format is found.

			case iEmbObj:	 // Embedded Object
			case iEmbSrc:	 // Embed Source
			case iLnkSrc:	 // Link Source
			case iMfPict:	 // Metafile
			case iDIB:		 // DIB
			case iBitmap:	 // Bitmap
			case iFilename:	 // Filename
				hresult = CreateOleObjFromDataObj(pdo, prg, rps, i, publdr);
				break;

			// COMPATIBILITY ISSUE (v-richa) iTxtObj is needed by Exchange and
			// as a flag for Wordpad.  iRichEdit doesn't seem to be needed by
			// anyone but might consider implementing as a flag.
			case iRichEdit:	 // RichEdit
			case iTxtObj:	 // Text with Objects
				break;
			default:
				// Ooops didn't find a format after all
				bFormatFound = FALSE;
				break;
			}

			//If we used the hGlobal unlock it and free it.
			if(hGlobal)
			{
				GlobalUnlock(hGlobal);
				ReleaseStgMedium(&medium);
			}
			break;							//Break out of for loop
		}
	}

    // richedit 1.0 returned an error if an unsupported FORMATETC was
    // found.  This behaviour is expected by ccMail so it can handle the
    // format itself
	if (!bFormatFound && f10Mode)
	    hresult = DV_E_FORMATETC;

Exit:
	if (fThawDisplay)
		_ped->_pdp->Thaw();

	if(!pdoSave)							// Release data object
		pdo->Release();						//  used for clipboard

	return hresult;						
}	

/*
 *	CLightDTEngine::GetDropTarget (ppDropTarget)
 *
 *	@mfunc
 *		creates an OLE drop target
 *
 *	@rdesc
 *		HRESULT
 *
 *	@devnote	The caller is responsible for AddRef'ing this object
 *				if appropriate.
 */
HRESULT CLightDTEngine::GetDropTarget(
	IDropTarget **ppDropTarget)		// @parm outparm for drop target
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::GetDropTarget");

	if(!_pdt)
	{
		_pdt = new CDropTarget(_ped);
		// the AddRef done by the constructor will be
		// undone by the destructor of this object
	}

	if(ppDropTarget)
		*ppDropTarget = _pdt;

	return _pdt ? NOERROR : E_OUTOFMEMORY;
}

/*
 *	CLightDTEngine::StartDrag (psel, publdr)
 *
 *	@mfunc
 *		starts the main drag drop loop
 *
 */	
HRESULT CLightDTEngine::StartDrag(
	CTxtSelection *psel,		// @parm Selection to drag from
	IUndoBuilder *publdr)		// @parm undo builder to receive antievents
{
#ifndef PEGASUS
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::StartDrag");

	LONG			cch, cch1;
	LONG			cp1, cpMin, cpMost;
	DWORD			dwEffect = 0;
	HRESULT			hr;
	IDataObject *	pdo = NULL;
	IDropSource *	pds;
	IRichEditOleCallback * precall = _ped->GetRECallback();

	// If we're doing drag drop's, we should have our own drop target
	// It's possible that _pdt will be NULL at this point--some clients
	// will delay instantiation of our drop target until a drop target
	// in the parent window decides that ours is needed.  However, since
	// we need it just to initiate drag drop, go ahead and create one
	// here.

	if( _pdt == NULL )
	{
		hr = GetDropTarget(NULL);
		if(hr != NOERROR)
			return hr;
	}

	psel->CheckTableSelection();

	if(precall)
	{
		CHARRANGE chrg;

		// give the callback a chance to give us its own IDataObject
		psel->GetRange(chrg.cpMin, chrg.cpMost);
		hr = precall->GetClipboardData(&chrg, RECO_COPY, &pdo);
	}
	else
	{
		// we need to build our own data object.
		hr = S_FALSE;
	}

	// If we didn't get an IDataObject from the callback, build our own
	if(hr != NOERROR || pdo == NULL)
	{										// Don't include trailing EOP
		psel->AdjustEndEOP(NONEWCHARS);		//  in some selection cases
		hr = RangeToDataObject(psel, SF_TEXT | SF_RTF, &pdo);
		if(hr != NOERROR)
			return hr;
	}

	cch = psel->GetRange(cpMin, cpMost);	// NB: prg is the selection
	cp1 = psel->GetCp();					// Save active end and signed
	cch1 = psel->GetCch();					//  length for Undo antievent
	CTxtRange rg(_ped, cpMost, cch);		// Use range copy to float over
											// mods made to backing store
	// The floating range that we just created on the stack needs to
	// think that it's protected, so it won't change size.
	rg.SetDragProtection(TRUE);

	pds = new CDropSource();
	if(pds == NULL)
	{
		pdo->Release();
		return E_OUTOFMEMORY;
	}

	// Cache some info with our own drop target
	_pdt->SetDragInfo(publdr, cpMin, cpMost);


	// Set allowable effects
	dwEffect = DROPEFFECT_COPY;
	if(!_ped->TxGetReadOnly())
		dwEffect |= DROPEFFECT_MOVE;
	
	// Let the client decide what it wants.
	if(precall)
		hr = precall->GetDragDropEffect(TRUE, 0, &dwEffect);

	if(!FAILED(hr) || hr == E_NOTIMPL)
	{
		// Start drag-drop operation
		psel->AddRef();					// Stabilize Selection around DoDragDrop
		hr = DoDragDrop(pdo, pds, dwEffect, &dwEffect);
		psel->Release();
	}

	// Clear drop target
	_pdt->SetDragInfo(NULL, -1, -1);

	// Handle 'move' operations	
	if( hr == DRAGDROP_S_DROP && (dwEffect & DROPEFFECT_MOVE) )
	{
		// We're going to delete the dragged range, so turn off protection.
		rg.SetDragProtection(FALSE);
		if( publdr )
		{
			LONG cpNext, cchNext;

			if(_ped->GetCallMgr()->GetChangeEvent() )
			{
				cpNext = cchNext = -1;
			}
			else
			{
				cpNext = rg.GetCpMin();
				cchNext = 0;
			}

			HandleSelectionAEInfo(_ped, publdr, cp1, cch1, cpNext, cchNext,
								  SELAE_FORCEREPLACE);
		}
		
		// Delete the data that was moved.  The selection will float
		// to the new correct location.
		rg.Delete(publdr, SELRR_IGNORE);

		// The update that happens implicitly by the update of the range may
		// have the effect of scrolling the window. This in turn may have the
		// effect in the drag drop case of scrolling non-inverted text into
		// the place where the selection was. The logic in the selection
		// assumes that the selection is inverted and so reinverts it to turn
		// off the selection. Of course, it is obvious what happens in the
		// case where non-inverted text is scrolled into the selection area.
		// To simplify the processing here, we just say the whole window is
		// invalid so we are guaranteed to get the right painting for the
		// selection.
		// FUTURE: (ricksa) This solution does have the disadvantage of causing
		// a flash during drag and drop. We probably want to come back and
		// investigate a better way to update the screen.
		_ped->TxInvalidateRect(NULL, FALSE);

		// Display is updated via notification from the range

		// Update the caret
		psel->Update(TRUE);
	}
	else if( hr == DRAGDROP_S_DROP && _ped->GetCallMgr()->GetChangeEvent() &&
		(dwEffect & DROPEFFECT_COPY) && publdr)
	{
		// if we copied to ourselves, we want to restore the selection to
		// the original drag origin on undo
		HandleSelectionAEInfo(_ped, publdr, cp1, cch1, -1, -1,
				SELAE_FORCEREPLACE);
	}

	if(SUCCEEDED(hr))
		hr = NOERROR;

	pdo->Release();
	pds->Release();

	// we do this last since we may have re-used some 'paste' code which
	// will stomp the undo name to be UID_PASTE.
	if( publdr )
		publdr->SetNameID(UID_DRAGDROP);

	if(_ped->GetEventMask() & ENM_DRAGDROPDONE)
	{
		NMHDR	hdr;
		ZeroMemory(&hdr, sizeof(NMHDR));
		_ped->TxNotify(EN_DRAGDROPDONE, &hdr);
	}

	return hr;
#else
	return 0;
#endif
}

/*
 *	CLightDTEngine::LoadFromEs (prg, lStreamFormat, pes, fTestLimit, publdr)
 *
 *	@mfunc
 *		Load data from the stream pes into the range prg according to the
 *		format lStreamFormat
 *
 *	@rdesc
 *		LONG -- count of characters read
 */
LONG CLightDTEngine::LoadFromEs(
	CTxtRange *	prg,			// @parm range to load into
	LONG		lStreamFormat,	// @parm stream format to use for loading
	EDITSTREAM *pes,			// @parm edit stream to load from
	BOOL		fTestLimit,		// @parm Whether to test text limit
	IUndoBuilder *publdr)		// @parm undo builder to receive antievents
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::LoadFromEs");

#ifdef DEBUG
	// FUTURE: Currently freezing the display prior to loading text
	// is simply an optimization. This may become a requirement in the
	// future. If this does become a requirement then we'll want to
	// exit with an error.
	if( !_ped->_pdp->IsFrozen() )
	{
		TRACEWARNSZ("CLightDTEngine::LoadFromEs	display not frozen");
	}
#endif // DEBUG

	LONG		cch = 0;				// Default no chars read
	IAntiEvent *pae = NULL;

	if(publdr)
		publdr->StopGroupTyping();

	// Other components, such as the display and backing store, will
	// be able to make optimizations if they know that we are streaming
	// in text or RTF data.

	if(lStreamFormat & SF_RTF)						// RTF case must precede
	{												//  TEXT case (see SF_x
		if(!_ped->IsRich())							//  values)
			return 0;

		LONG cpMin, cpMost;

		// Here we do something a bit unusual for performance reasons.
		// Instead of letting the rtf reader generate its own undo actions,
		// we take care of it ourselves.  Instead of generating actions
		// for each little operation, we simply generate a "big" anti-event
		// for the whole shebang

		// There is a subtlty w.r.t. to paragraph format runs.  By inserting
		// text with para formatting, it's possible that we will modify the
		// para formatting of the _current_ paragraph.  Thus, it's necessary
		// to remember what the formatting currently is for undo.  Note that
		// it may actually not be changed; but we go ahead and generate an
		// anti-event anyways.  Note that we only need to do this if cpMin is
		// the middle of a paragraph
		
		CTxtPtr tp(prg->_rpTX);
		if(prg->GetCch() > 0)
			tp.AdvanceCp(-prg->GetCch());
		
		if(publdr && !tp.IsAfterEOP())
		{
			tp.FindEOP(tomBackward);
			cpMin = tp.GetCp();
			tp.FindEOP(tomForward);
			cpMost = tp.GetCp();
			
			// We must be in rich text mode, so we must be able to always
			// find a paragraph.
			Assert(cpMost > cpMin);

			if (prg->_rpPF.IsValid())
			{
				CFormatRunPtr rpPF(prg->_rpPF);
				rpPF.AdvanceCp(cpMin - prg->GetCp());
					
				pae = gAEDispenser.CreateReplaceFormattingAE( _ped, rpPF,
							cpMost - cpMin, GetParaFormatCache(), ParaFormat);
				if(pae)
					publdr->AddAntiEvent(pae);
			}

			// Also create the charformat anti-event for the current paragraph
			// to preserve BiDi level. We cannot check fBiDi here since we may be running
			// on US platform inserting a BiDi rtf.
			if (prg->_rpCF.IsValid())
			{
				CFormatRunPtr rpCF(prg->_rpCF);
				rpCF.AdvanceCp(cpMin - prg->GetCp());
				
				pae = gAEDispenser.CreateReplaceFormattingAE( _ped, rpCF,
							cpMost - cpMin, GetCharFormatCache(), CharFormat);
				if(pae)
					publdr->AddAntiEvent(pae);
			}
		}

		// First, clear range
		if(prg->GetCch())
		{
			prg->ReplaceRange(0, NULL, publdr, SELRR_REMEMBERRANGE);

			if (prg->GetCch() != 0)
			{
				// Text deletion failed because range didn't collapse. Our work
				// here is done.
				return 0;
			}
		}

		Assert(prg->GetCch() == 0);

		cpMin = prg->GetCp();
		_ped->SetStreaming(TRUE);
		CRTFRead rtfRead(prg, pes, lStreamFormat);

		cch	= rtfRead.ReadRtf();

		cpMost = prg->GetCp();
		Assert(pes->dwError != 0 || cpMost >= cpMin);

		// If nothing changed, get rid of any anti-events (like the formatting
		// one) that we may have "speculatively" added

		if(publdr && !_ped->GetCallMgr()->GetChangeEvent())
			publdr->Discard();

		if(publdr && cpMost > cpMin)
		{
			// If some text was added, create an anti-event for
			// it and add it in.

			AssertSz(_ped->GetCallMgr()->GetChangeEvent(),
				"Something changed, but nobody set the change flag");

			pae = gAEDispenser.CreateReplaceRangeAE(_ped, cpMin, cpMost, 0,
						NULL, NULL, NULL);

			HandleSelectionAEInfo(_ped, publdr, -1, -1, cpMost, 0,
						SELAE_FORCEREPLACE);
			if(pae)
				publdr->AddAntiEvent(pae);
		}
	}
	else if(lStreamFormat & SF_TEXT)
	{
		_ped->SetStreaming(TRUE);
		cch = ReadPlainText(prg, pes, fTestLimit, publdr, lStreamFormat);
	}
	_ped->SetStreaming(FALSE);

	// Before updating the selection, try the auto-URL detect.  This makes
	// two cases better: 1. a long drag drop is now faster and 2. the
	// selection _iFormat will now be udpated correctly for cases of
	// copy/paste of a URL.

	if(_ped->GetDetectURL())
		_ped->GetDetectURL()->ScanAndUpdate(publdr);

	// The caret belongs in one of two places:
	//		1. if we loaded into a selection, at the end of the new text
	//		2. otherwise, we loaded an entire document, set it to cp 0
	//
	// ReadPlainText() and ReadRtf() set prg to an insertion point
	// at the end, so if we loaded a whole document, reset it.
	CTxtSelection *psel = _ped->GetSelNC();
	if(psel)
	{
		if(!(lStreamFormat & SFF_SELECTION))
		{
			psel->Set(0,0);
			psel->Update(FALSE);
		}
		psel->Update_iFormat(-1);
	}

	if (!fTestLimit)
	{
		// If we don't limit the text then we adjust the text limit
		// if we have exceeded it.
		_ped->TxSetMaxToMaxText();
	}
	return cch;
}

/*
 *	CLightDTEngine::SaveToEs (prg, lStreamFormat, pes)
 *
 *	@mfunc
 *		save data into the given stream
 *
 *	@rdesc
 *		LONG -- count of characters written
 */
LONG CLightDTEngine::SaveToEs(
	CTxtRange *	prg,			// @parm range to drag from
	LONG		lStreamFormat,	// @parm stream format to use for saving
	EDITSTREAM *pes )			// @parm edit stream to save to
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::SaveToEs");

	LONG cch = 0;								// Default no chars written

	if(lStreamFormat & SF_RTF)					// Be sure to check for SF_RTF
	{											//  before checking for SF_TEXT
		CRTFWrite rtfWrite( prg, pes, lStreamFormat );
	
		cch = rtfWrite.WriteRtf();
	}
	else if(lStreamFormat & (SF_TEXT | SF_TEXTIZED))
		cch = WritePlainText(prg, pes, lStreamFormat);
	else
	{
		Assert(FALSE);
	}
	return cch;
}

/*
 *	CLightDTEngine::UnicodePlainTextFromRange (prg)
 *
 *	@mfunc
 *		Fetch plain text from a range and put it in an hglobal
 *
 *	@rdesc
 *		an allocated HGLOBAL.
 *
 *	@devnote
 *		FUTURE: Export bullets as does Word for plain text
 */
HGLOBAL CLightDTEngine::UnicodePlainTextFromRange(
	CTxtRange *prg)				// @parm range to get text from
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::UnicodePlainTextFromRange");

	LONG	cpMin, cpMost;
	LONG	cch = prg->GetRange(cpMin, cpMost);
	LONG	cchT = 2*(cch + 1);
	HGLOBAL	hText;
	TCHAR *	pText;
	CTxtPtr tp(_ped, cpMin);

	hText = GlobalAlloc(GMEM_FIXED,						// Allocate 2* in
						cchT * sizeof(TCHAR) );			//  case all CRs
	if(!hText)
		return NULL;

	pText = (TCHAR *)GlobalLock(hText);
	if(!pText)
		return NULL;

	if(cch)
	{
		cch = tp.GetPlainText(cchT, pText, cpMost, FALSE);
		AssertSz(cch <= cchT,
			"CLightDTEngine::UnicodePlainTextFromRange: got too much text");
	}

	*(pText + cch) = '\0';
	
	GlobalUnlock(hText);

	HGLOBAL	hTemp = GlobalReAlloc(hText, 2*(cch + 1), GMEM_MOVEABLE);

	if(!hTemp)
		GlobalFree(hText);

	return hTemp;
}

/*
 *	CLightDTEngine::AnsiPlainTextFromRange (prg)
 *
 *	@mfunc
 *		Retrieve an ANSI copy of the text in the range prg
 *
 *	@rdesc
 *		HRESULT
 */
HGLOBAL CLightDTEngine::AnsiPlainTextFromRange(
	CTxtRange *prg)				// @parm range to get text from
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::AnsiPlainTextFromRange");

	HGLOBAL hUnicode;
	HGLOBAL hAnsi;

	// FUTURE (alexgo): if we implement the option to store text as 8-bit
	// chars, then we can make this routine more efficient

	hUnicode = UnicodePlainTextFromRange(prg);
	hAnsi = TextHGlobalWtoA(hUnicode);

	GlobalFree(hUnicode);
	return hAnsi;
}

/*
 *	CLightDTEngine::RtfFromRange (prg, lStreamFormat)
 *
 *	@mfunc
 *		Fetch RTF text from a range and put it in an hglobal
 *
 *	@rdesc
 *		an allocated HGLOBAL.
 */
HGLOBAL CLightDTEngine::RtfFromRange(
	CTxtRange *	prg,			// @parm Range to get RTF from
	LONG 		lStreamFormat)	// @parm stream format to use for loading
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::RtfFromRange");

	WRITEHGLOBAL whg;
	EDITSTREAM	 es = {(DWORD_PTR)&whg, NOERROR, WriteHGlobal};
	DWORD		 cb	= 2*abs(prg->GetCch()) + 100;	// Rough estimate

	whg.cb			= cb;
	whg.hglobal		= GlobalAlloc(GMEM_FIXED, cb);
	if(!whg.hglobal)
		return NULL;		
	whg.cch			= 0;					// Nothing written yet
	SaveToEs(prg, lStreamFormat & ~SF_TEXT, &es);
	if(es.dwError)
	{
		GlobalFree(whg.hglobal);
		return NULL;
	}
	
	HGLOBAL	hTemp = GlobalReAlloc(whg.hglobal, whg.cch, GMEM_MOVEABLE);
	
	if (!hTemp)		
		GlobalFree(whg.hglobal);			// Fail ReAlloc...

	return hTemp;
}


//
// PROTECTED METHODS
//

#define READSIZE 	4096 - 2
#define WRITESIZE	2048

/*
 *	CLightDTEngine::ReadPlainText (prg, pes, publdr, lStreamFormat)
 *
 *	@mfunc
 *		Replaces contents of the range prg with the data given in the edit
 *		stream pes. Handles multibyte sequences that overlap stream buffers.
 *
 *	@rdesc
 *		Count of bytes read (to be compatible with RichEdit 1.0)
 *
 *	@devnote
 *		prg is modified; at the return of the call, it will be a degenerate
 *		range at the end of the read in text.
 *
 *		Three kinds of multibyte/char sequences can overlap stream buffers:
 *		DBCS, UTF-8, and CRLF/CRCRLF combinations. DBCS and UTF-8 streams are
 *		converted by MultiByteToWideChar(), which cannot convert a lead byte
 *		(DBCS and UTF-8) that occurs at the end of the buffer, since the
 *		corresponding trail byte(s) will be in the next buffer.  Similarly,
 *		in RichEdit 2.0 mode, we convert CRLFs to CRs and CRCRLFs to blanks,
 *		so one or two CRs at the end of the buffer require knowledge of the
 *		following char to determine if they are part of a CRLF or CRCRLF.
 *
 *		To handle these overlapped buffer cases, we move the ambiguous chars
 *		to the start of the next buffer, rather than keeping them as part of
 *		the current buffer.  At the start of the buffer, the extra char(s)
 *		needed for translation follow immediately.
 */
LONG CLightDTEngine::ReadPlainText(
	CTxtRange *	  prg, 			// @parm range to read to
	EDITSTREAM *  pes,			// @parm edit stream to read from
	BOOL		  fTestLimit,	// @parm whether limit testing is needed
	IUndoBuilder *publdr,		// @parm undo builder to receive antievents
	LONG		  lStreamFormat)// @parm Stream format
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::ReadPlainText");

	CTxtEdit *ped = _ped;
	LONG	  cbRead;
	LONG 	  cbReadTotal = 0;	// No bytes read yet
	LONG	  cchConv;
	LONG	  cchMove = 0;
	LONG	  cCR = 0;			// Count of CRs from preceding buffer
	LONG	  cCRPrev = 0;		// Count used while calc'ing new cCR
	LONG	  cpMin;
	BOOL	  fContinue = TRUE;	// Keep reading so long as TRUE
	BYTE *	  pb;				// Byte ptr to szBuf or wszBuf
	CCallMgr *pCallMgr = ped->GetCallMgr();
	TCHAR *	  pch;				// Ptr to wszBuf
	UINT	  uCpg = GetStreamCodePage(lStreamFormat);
	CFreezeDisplay	fd(ped->_pdp);

	// Just put a big buffer on the stack.  Thankfully, we only
	// run on 32bit OS's.  4K is a good read size for NT file caching.
	char 	szBuf[READSIZE];
	WCHAR	wszBuf[READSIZE+2];	// Allow for moving end CRs to start

	// Empty the range
	if(prg->GetCch())
		prg->ReplaceRange(0, NULL, publdr, SELRR_REMEMBERRANGE, &cchMove);			

	cpMin = prg->GetCp();							// Save initial cp for
													//  BreakRuns() at end
	pb = (uCpg == 1200) ? (BYTE *)(wszBuf + 2)		// Setup Unicode or MBCS
						: (BYTE *)szBuf;
	LONG j = 0;										// Haven't read anything,
													//  so no lead byte left
	while(fContinue)								//  from previous read
	{
		LONG jPrev = j;								// Save byte(s) left over
		LONG cbSkip = 0;							//  from previous read

		pes->dwError = (*pes->pfnCallback)(			// Read next bufferful,
				pes->dwCookie, pb + j, 				//  bypassing any lead
				READSIZE - j, &cbRead);				//  bytes

		if(pes->dwError || !cbRead && !cCR)
			break;									// Error or done

		if(!cbReadTotal && cbRead >= 3 && W32->IsUTF8BOM(pb))
		{
			uCpg = CP_UTF8;
			cbSkip = 3;								// Bypass 3 bytes
		}
		// Adjust cbRead with previous leading byte(s)
		cbRead += j;
		j = 0;										
		
		cchConv = cbRead/2;							// Default Unicode cch
		if(uCpg != 1200 && cbRead)					// Multibyte of some kind
		{
			Assert(pb == (BYTE *)szBuf && !j);		// Just in case...

			// Check if last byte is a leading byte
			if(uCpg == CP_UTF8)
			{
				// Note: Unlike UTF-8, UTF-7 can be in the middle of a long
				// sequence, so it can't be converted effectively in chunks
				// and we don't handle it
				LONG cb = cbRead - 1;
				BYTE b;
				BYTE bLeadMax = 0xDF;

				// Find UTF-8 lead byte
				while((b = (BYTE)szBuf[cb - j]) >= 0x80)
				{
					j++;
					if(b >= 0xC0)					// Break on UTF-8 lead
					{								//  byte
						if(j > 1 && (b <= bLeadMax || b >= 0xF8))
							j = 0;					// Full UTF-8 char or
						break;						//  illegal sequence
					}
					if(j > 1)
					{
						if(j == 5)					// Illegal UTF-8
						{
							j = 0;
							break;
						}
						*(char *)&bLeadMax >>= 1;
					}
				}
			}
			else
			{
				LONG temp = cbRead - 1;

				// GetTrailBytesCount() can return 1 for some trail bytes
				// esp. for GBX.  So, we need to keep on checking until
				// we hit a non-lead byte character.  Then, based on
				// how many bytes we went back, we can determine if the
				// last byte is really a Lead byte.
				while (temp && GetTrailBytesCount((BYTE)szBuf[temp], uCpg))
					temp--;

				if(temp && ((cbRead-1-temp) & 1))
					j = 1;
			}

			// We don't want to pass the lead byte or partial UTF-8 to
			// MultiByteToWideChar() because it will return bad char.
		    cchConv = MBTWC(uCpg, 0, szBuf + cbSkip, cbRead - j - cbSkip,
							&wszBuf[2], READSIZE, NULL);

			for(LONG i = j; i; i--)					// Copy down partial
				szBuf[j - i] = szBuf[cbRead - i];	//  multibyte sequence
		}
		cbReadTotal += cbRead - j - jPrev;

		// Cleanse (CRLFs -> CRs, etc.), limit, and insert the data. Have
		// to handle CRLFs and CRCRLFs that overlap two successive buffers.
		Assert(cCR <= 2);
		pch = &wszBuf[2 - cCR];						// Include CRs from prev

		if(!ped->_pdp->IsMultiLine())				// Single-line control
		{
			Assert(!cCR);
		}
		else
		{								
			wszBuf[0] = wszBuf[1] = CR;				// Store CRs for cchCR > 0
			cCRPrev = cCR;							// Save prev cchCR
			cCR = 0;								// Default no CR this buf

			Assert(ARRAY_SIZE(wszBuf) >= cchConv + 2);

			// Need to +2 since we are moving data into wszBuf[2]
			if(cchConv && wszBuf[cchConv + 2 - 1] == CR)
			{										// There's at least one
				cCR++;								// Set it up for next buf
				if (cchConv > 1 &&					//  in case CR of CRLF
					wszBuf[cchConv + 2 - 2] == CR)	// Got 2nd CR; might be
				{									//  first CR of CRCRLF so
					cCR++;							//  setup for next buffer
				}
			}										
			cchConv += cCRPrev - cCR;				// Add in count from prev
		}											//  next
		Assert(!prg->GetCch());						// Range is IP
		prg->CleanseAndReplaceRange(cchConv, pch, fTestLimit, publdr, pch, NULL, RR_ITMZ_NONE);

		if(pCallMgr->GetMaxText() || pCallMgr->GetOutOfMemory())
		{
			// Out of memory or reached the max size of our text control.
			// In either case, return STG_E_MEDIUMFULL (for compatibility
			// with RichEdit 1.0)
			pes->dwError = (DWORD)STG_E_MEDIUMFULL;
			break;
		}
	}
	prg->ItemizeReplaceRange(prg->GetCp() - cpMin, cchMove, publdr, TRUE);

	return cbReadTotal;
}

/*
 *	CLightDTEngine::WritePlainText (prg, pes, lStreamFormat)
 *
 *	@mfunc
 *		Writes plain text from the range into the given edit stream
 *
 *	@rdesc
 *		Count of bytes written
 */
LONG CLightDTEngine::WritePlainText(
	CTxtRange *	prg,			// @parm range to write from
	EDITSTREAM *pes,			// @parm edit stream to write to
	LONG		lStreamFormat)	// @parm Stream format
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::WritePlainText");

	LONG		cbConverted;		// Bytes for output stream
	LONG		cbWrite;			// Incremental byte count
	LONG		cbWriteTotal = 0;	// No chars written yet
	LONG		cpMin, cpMost;
	LONG		cch = prg->GetRange(cpMin, cpMost);
	BOOL		fAdjustCRLF = TRUE;	// Adjust first time through loop
	BOOL		fTextize = lStreamFormat & SF_TEXTIZED;
	LPBYTE		pb;					// Byte ptr to szBuf or wszBuf
	COleObject *pobj;				// Ptr to embedded object
	CTxtPtr		tp(_ped, cpMin);	// tp to walk prg with
	UINT		uCpg = GetStreamCodePage(lStreamFormat);

	// DBCS has up to 2 times as many chars as WCHARs. UTF-8 has 3 BYTES for
	// all codes above 0x7ff. UTF-7 has even more due to shift in/out codes.
	// We don't support UTF-7, since can't use WCTMB with UTF-7 chunks

	char		szBuf[3*WRITESIZE];	// Factor of 2 works with DBCS, 3 with UTF-8
	WCHAR		wszBuf[WRITESIZE];

	pes->dwError = NOERROR;							// No error yet

	pb = (uCpg == 1200) ? (BYTE *)wszBuf			// Setup Unicode or MBCS
						: (BYTE *)szBuf;

	LONG cchText = _ped->GetAdjustedTextLength();
	cpMost = min(cpMost, cchText);					// Don't write final CR
	while(tp.GetCp() < cpMost)
	{
		if (fTextize && tp.GetChar() == WCH_EMBEDDING)
		{
			Assert(_ped->GetObjectCount());

			pobj = _ped->GetObjectMgr()->GetObjectFromCp(tp.GetCp());
			tp.AdvanceCp(1);						// Advance past object
			if(pobj)
			{
				cbWriteTotal += pobj->WriteTextInfoToEditStream(pes);
				continue;							// If no object at cp,
			}										//  just ignore char
		}											
		cch	= tp.GetPlainText(WRITESIZE, wszBuf, cpMost, fTextize, fAdjustCRLF);
		if(!cch)
			break;									// No more to do
		fAdjustCRLF = FALSE;						// Already adjusted 

		cbConverted = 2*cch;						// Default Unicode byte ct
		if(uCpg != 1200)							// Multibyte of some kind
		{
			cbConverted = MbcsFromUnicode(szBuf, 3*WRITESIZE, wszBuf, cch, uCpg,
								UN_CONVERT_WCH_EMBEDDING);

			// FUTURE: report some kind of error if default char used,
			// i.e., data lost in conversion
		
			// Did the conversion completely fail? As a fallback, we might try
			// the system code page, or just plain ANSI...
		
			if (!cbConverted)
			{
				uCpg = GetLocaleCodePage();
				cbConverted = MbcsFromUnicode(szBuf, 3*WRITESIZE, wszBuf, cch, uCpg,
												UN_CONVERT_WCH_EMBEDDING);
			}

			if (!cbConverted)
			{
				uCpg = CP_ACP;
				cbConverted = MbcsFromUnicode(szBuf, 3*WRITESIZE, wszBuf, cch, uCpg,
												UN_CONVERT_WCH_EMBEDDING);
			}
		}

		pes->dwError = (*pes->pfnCallback)(pes->dwCookie, pb,
							cbConverted,  &cbWrite);
		if(!pes->dwError && cbConverted != cbWrite)	// Error or ran out of
			pes->dwError = (DWORD)STG_E_MEDIUMFULL;	//  target storage

		if(pes->dwError)
			break;
		cbWriteTotal += cbWrite;
	}

	AssertSz(tp.GetCp() >= cpMost,
		"CLightDTEngine::WritePlainText: not all text written");

	return cbWriteTotal;
}

/*
 *	CLightDTEngine::GetStreamCodePage (lStreamFormat)
 *
 *	@mfunc
 *		Returns code page given by lStreamFormat or CTxtEdit::_pDocInfo
 *
 *	@rdesc
 *		HRESULT
 */
LONG CLightDTEngine::GetStreamCodePage(
	LONG lStreamFormat)
{
	// FUTURE: support 1201, i.e., big-endian Unicode?
	if(lStreamFormat & SF_UNICODE)
		return 1200;

	if(lStreamFormat & SF_USECODEPAGE)
		return HIWORD(lStreamFormat);

	if (W32->IsFESystem())
		return GetACP();

	return CP_ACP;
}

/*
 *	CLightDTEngine::CreateOleObjFromDataObj ( pdo, prg, rps, iformatetc, pubdlr )
 *
 *	@mfunc
 *		Creates an ole object based on the data object pdo, and
 *		pastes the object into the range prg. Any text that already
 *		existed in the range is replaced.
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT CLightDTEngine::CreateOleObjFromDataObj(
	IDataObject *	pdo,		// @parm Data object from which to create
	CTxtRange *		prg,		// @parm Range in which to place
	REPASTESPECIAL *rps,		// @parm Special paste info
	INT				iformatetc,	// @parm Index in g_rgFETC
	IUndoBuilder *	publdr)		// @parm Undo builder to receive antievents
{
#ifndef PEGASUS
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::CreateOleObjFromDataObj");

	HRESULT			hr = NOERROR;
	REOBJECT		reobj;
	SIZEL			sizel;
	FORMATETC		formatetc;
	DWORD			dwDrawAspect = 0;
	HGLOBAL			hMetaPict = NULL;
	LPRICHEDITOLECALLBACK const precall = _ped->GetRECallback();
	LPOBJECTDESCRIPTOR lpod = NULL;
	STGMEDIUM		medObjDesc;
	BOOL			fStatic = (iformatetc == iMfPict || iformatetc == iDIB ||
							   iformatetc == iBitmap);
	BOOL			fFilename = (iformatetc == iFilename);
    DUAL_FORMATETC	tmpFormatEtc;

	if(!precall)
		return E_NOINTERFACE;

	ZeroMemory(&medObjDesc, sizeof(STGMEDIUM));
	ZeroMemory(&sizel, sizeof(SIZEL));
	ZeroMemory(&reobj, sizeof(REOBJECT));

	if(fStatic)
		dwDrawAspect = DVASPECT_CONTENT;

	if(fFilename)
		dwDrawAspect = DVASPECT_ICON;

	if(rps && !dwDrawAspect)
	{
		dwDrawAspect = rps->dwAspect;
		if(rps->dwAspect == DVASPECT_ICON)
			hMetaPict = (HGLOBAL)rps->dwParam;
	}

	// If no aspect was specified, pick up the object descriptor hints
	if(!dwDrawAspect)
	{
		// Define ObjectDescriptor data
		formatetc.cfFormat = cf_OBJECTDESCRIPTOR;
		formatetc.ptd = NULL;
		formatetc.dwAspect = DVASPECT_CONTENT;
		formatetc.lindex = -1;
		formatetc.tymed = TYMED_HGLOBAL;

		if(pdo->GetData(&formatetc, &medObjDesc) == NOERROR)
		{
			HANDLE	hGlobal = medObjDesc.hGlobal;

			lpod = (LPOBJECTDESCRIPTOR)GlobalLock(hGlobal);
			if(lpod)
			{
				dwDrawAspect = lpod->dwDrawAspect;
			}
			GlobalUnlock(hGlobal);
			ReleaseStgMedium(&medObjDesc);
		}
	}

	if(!dwDrawAspect)
		dwDrawAspect = DVASPECT_CONTENT;

	if(fStatic)
	{
		reobj.clsid	= ((iformatetc == iMfPict) ?
			CLSID_StaticMetafile : CLSID_StaticDib);
	}

	// COMPATIBILITY ISSUE: Compatibility Issue from Richedit 1.0 - Raid 16456:
	// Don't call GetData(CF_EMBEDSOURCE)
	// on 32-bit Excel. Also clsidPictPub.
	//	if(iformatetc == iformatetcEmbSrc && (ObFIsExcel(&clsid) ||
	//		IsEqualCLSID(&clsid, &clsidPictPub)))
	//	else
	//		ObGetStgFromDataObj(pdataobj, &medEmbed, iformatetc);

	// Get storage for the object from the application
	hr = precall->GetNewStorage(&reobj.pstg);
	if(hr)
	{
		TRACEERRORSZ("GetNewStorage() failed.");
		goto err;
	}

	// Create an object site for the new object
	hr = _ped->GetClientSite(&reobj.polesite);
	if(!reobj.polesite)
	{
		TRACEERRORSZ("GetClientSite() failed.");
		goto err;
	}


	ZeroMemory(&tmpFormatEtc, sizeof(DUAL_FORMATETC));
	tmpFormatEtc.ptd = NULL;
	tmpFormatEtc.dwAspect = dwDrawAspect;
	tmpFormatEtc.lindex = -1;

	//Create the object
	if(fStatic)
	{
		hr = OleCreateStaticFromData(pdo, IID_IOleObject, OLERENDER_DRAW,
				&tmpFormatEtc, NULL, reobj.pstg, (LPVOID*)&reobj.poleobj);
	}
	else if(iformatetc == iLnkSrc || (_ped->Get10Mode() && iformatetc == iFilename))
	{
		hr = OleCreateLinkFromData(pdo, IID_IOleObject, OLERENDER_DRAW,
				&tmpFormatEtc, NULL, reobj.pstg, (LPVOID*)&reobj.poleobj);
	}
	else
	{
		hr = OleCreateFromData(pdo, IID_IOleObject, OLERENDER_DRAW,
				&tmpFormatEtc, NULL, reobj.pstg, (LPVOID*)&reobj.poleobj);
	}

	if(hr)
	{
		TRACEERRORSZ("Failure creating object.");
		goto err;
	}


	//Get the clsid of the object.
	if(!fStatic)
	{
		hr = reobj.poleobj->GetUserClassID(&reobj.clsid);
		if(hr)
		{
			TRACEERRORSZ("GetUserClassID() failed.");
			goto err;
		}
	}

	//Deal with iconic aspect if specified.
	if(hMetaPict)
	{
		BOOL fUpdate;

		hr = OleStdSwitchDisplayAspect(reobj.poleobj, &dwDrawAspect,
										DVASPECT_ICON, hMetaPict, FALSE,
										FALSE, NULL, &fUpdate);
		if(hr)
		{
			TRACEERRORSZ("OleStdSwitchDisplayAspect() failed.");
			goto err;
		}

		// If we successully changed the aspect, recompute the size.
		hr = reobj.poleobj->GetExtent(dwDrawAspect, &sizel);

		if(hr)
		{
			TRACEERRORSZ("GetExtent() failed.");
			goto err;
		}
	}

	// Try to retrieve the previous saved RichEdit site flags.
	if( ObjectReadSiteFlags(&reobj) != NOERROR )
	{
		// Set default for site flags
		reobj.dwFlags = REO_RESIZABLE;
	}

	// First, clear the range
	prg->Delete(publdr, SELRR_REMEMBERRANGE);

	reobj.cbStruct = sizeof(REOBJECT);
	reobj.cp = prg->GetCp();
	reobj.dvaspect = dwDrawAspect;
	reobj.sizel = sizel;

	//COMPATIBILITY ISSUE: from Richedit 1.0 - don't Set the Extent,
	//instead Get the Extent below in ObFAddObjectSite
	//hr = reobj.poleobj->SetExtent(dwDrawAspect, &sizel);

	hr = reobj.poleobj->SetClientSite(reobj.polesite);
	if(hr)
	{
		TRACEERRORSZ("SetClientSite() failed.");
		goto err;
	}

	if(hr = _ped->InsertObject(&reobj))
	{
		TRACEERRORSZ("InsertObject() failed.");
	}

err:
	if(reobj.poleobj)
		reobj.poleobj->Release();

	if(reobj.polesite)
		reobj.polesite->Release();

	if(reobj.pstg)
		reobj.pstg->Release();

	return hr;
#else
	return 0;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\measure.cpp ===
/*
 *	@doc
 *
 *	@module - MEASURE.CPP	  |
 *	
 *		CMeasurer class
 *	
 *	Authors:
 *		Original RichEdit code: David R. Fulmer <nl>
 *		Christian Fortini, Murray Sargent, Rick Sailor
 *
 *	Copyright (c) 1995-1998 Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_measure.h"
#include "_font.h"
#include "_disp.h"
#include "_edit.h"
#include "_frunptr.h"
#include "_objmgr.h"
#include "_coleobj.h"

ASSERTDATA

// Note we set this maximum length as appropriate for Win95 since Win95 GDI can 
// only handle 16 bit values. We don't special case this so that both NT and
// Win95 will behave the same way. 
// Note that the following obscure constant was empirically determined on Win95.
const LONG lMaximumWidth = (3 * SHRT_MAX) / 4;

void CMeasurer::Init(const CDisplay *pdp)
{
	CTxtEdit *	ped = GetPed();

	_pdp = pdp;
	_pddReference = pdp;
	_pccs = NULL;
	_pPF = NULL;
	_chPassword = ped->TxGetPasswordChar();
	_wNumber = 0;
	_fRenderer = FALSE;
	_fGlyphing = _fFallback = _fTarget = FALSE;
	_fAdjustFELineHt = !fUseUIFont() && pdp->IsMultiLine();

	if(pdp->GetWordWrap())
	{
		const CDevDesc *pddTarget = pdp->GetTargetDev();
		if(pddTarget)
			_pddReference = pddTarget;
	}

	_dypInch = pdp->GetDypInch();
	_dxpInch = pdp->GetDxpInch();
	_dtPres = GetDeviceCaps(_pdp->_hdc, TECHNOLOGY);

	if (pdp->IsMain())
	{
		_dypInch = MulDiv(_dypInch, pdp->GetZoomNumerator(), pdp->GetZoomDenominator());
		_dxpInch = MulDiv(_dxpInch, pdp->GetZoomNumerator(), pdp->GetZoomDenominator());
	}
	if (pdp->SameDevice(_pddReference))
	{
		_dyrInch = _dypInch;
		_dxrInch = _dxpInch;
		_dtRef = _dtPres;
	}
	else
	{
		_dyrInch = _pddReference->GetDypInch();
		_dxrInch = _pddReference->GetDxpInch();
		_dtRef = GetDeviceCaps(_pddReference->_hdc, TECHNOLOGY);
	}
}

CMeasurer::CMeasurer (const CDisplay* const pdp) : CRchTxtPtr (pdp->GetPed())	
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::CMeasurer");
	Init(pdp);
}

CMeasurer::CMeasurer (const CDisplay* const pdp, const CRchTxtPtr &tp) : CRchTxtPtr (tp)	
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::CMeasurer");
	Init(pdp);
}

CMeasurer::~CMeasurer()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::~CMeasurer");

	if(_pccs)
		_pccs->Release();
}

/*
 *	CMeasurer::SetGlyphing(fGlyphing)
 *
 *	@mfunc
 *	A state flag inside the measurer to record whether or not you
 *  are in the process of doing glyphing. If we are in a situation
 *	where the _pddReference is a printer device, then we need to
 *	throw away the _pccs.
 */
void CMeasurer::SetGlyphing(
	BOOL fGlyphing)		//@parm Currently doing glyphing
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::SetGlyphing");
	Assert(fGlyphing == TRUE || fGlyphing == FALSE);

	if (fGlyphing != _fGlyphing)
	{
		if (_dtRef == DT_RASPRINTER)
		{
			if (_pccs)
				_pccs->Release();
			_pccs = NULL;
		}
		_fGlyphing = fGlyphing;
	}
}

/*
 *	CMeasurer::SetUseTargetDevice(fUseTargetDevice)
 *
 *	@mfunc
 *		Sets whether you want to use the target device or not
 *		for getting metrics
 *		FUTURE (keithcu) Make this a parameter
 */
void CMeasurer::SetUseTargetDevice(
	BOOL fUseTargetDevice)		//@parm Use target device metrics?
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::SetUseTargetDevice");
	Assert(fUseTargetDevice == TRUE || fUseTargetDevice == FALSE);

	if (fUseTargetDevice != _fTarget)
	{
		if (_dypInch != _dyrInch && _dxpInch != _dxrInch)
		{
			if (_pccs)
				_pccs->Release();
			_pccs = NULL;
		}
		_fTarget = fUseTargetDevice;
	}
}


/*
 *	CMeasurer::NewLine (fFirstInPara)
 *
 *	@mfunc
 *		Initialize this measurer at the start of a new line
 */
void CMeasurer::NewLine(
	BOOL fFirstInPara)		//@parm Flag for setting up _bFlags
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::NewLine");

	_li.Init();							// Zero all members
	if(fFirstInPara)
		_li._bFlags = fliFirstInPara;	// Need to know if first in para
}

/*
 *	CMeasurer::NewLine(&li)
 *
 *	@mfunc
 *		Initialize this measurer at the start of a given line
 */
void CMeasurer::NewLine(
	const CLine &li)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::NewLine");

	_li				= li;
	_li._cch		= 0;
	_li._cchWhite	= 0;
	_li._xWidth		= 0;

	// Can't calculate xLeft till we get an HDC
	_li._xLeft	= 0;
	_wNumber	= _li._bNumber;
}

/*
 *	CMeasurer::MaxWidth()
 *
 *	@mfunc
 *		Get maximum width for line
 *
 *	@rdesc
 *		Maximum width for a line
 */
LONG CMeasurer::MaxWidth()
{
	LONG xWidth = lMaximumWidth;

	if(_pdp->GetWordWrap())
	{
		// Only main display has a caret 
		LONG xCaret = (_pdp->IsMain() && !GetPed()->TxGetReadOnly()) 
			? dxCaret : 0;

		// Calculate display width
		LONG xDispWidth = _pdp->GetMaxPixelWidth();

		if(!_pdp->SameDevice(_pddReference) && _fTarget)
		{
			// xWidthMax is calculated to the size of the screen DC. If
			// there is a target device with different characteristics
			// we need to convert the width to the target device's width
			xDispWidth = _pddReference->ConvertXToDev(xDispWidth, _pdp);
		}
		xWidth = xDispWidth - MeasureRightIndent() - _li._xLeft - xCaret;
	}
	return (xWidth > 0) ? xWidth : 0;
}

/*
 *	CMeasurer::MeasureText (cch)
 *
 *	@mfunc
 *		Measure a stretch of text from current running position.
 *
 *	@rdesc
 *		width of text (in device units), < 0 if failed
 */
LONG CMeasurer::MeasureText(
	LONG cch)		//@parm Number of characters to measure
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::MeasureText");

	if(Measure(0x7fffffff, cch, 0) == MRET_FAILED)
		return -1;

	return min(_li._xWidth, MaxWidth());
}

/*
 *	CMeasurer::MeasureLine (cchMax, xWidthMax, uiFlags, pliTarget)
 *
 *	@mfunc
 *		Measure a line of text from current cp and determine line break.
 *		On return *this contains line metrics for _pddReference device.
 *
 *	@rdesc
 *		TRUE if success, FALSE if failed
 */
BOOL CMeasurer::MeasureLine(
	LONG cchMax, 		//@parm Max chars to process (-1 if no limit)
	LONG xWidthMax,		//@parm max width to process (-1 uses CDisplay width)
	UINT uiFlags,  		//@parm Flags controlling the process (see Measure())
	CLine *pliTarget)	//@parm Returns target-device line metrics (optional)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::MeasureLine");

	// This state must be preserved across the two possible line width
	// calculations so we save it here.
	BYTE bNumberSave = _li._bNumber;

	const CDevDesc *pddTarget = NULL;

	if(_pdp->GetWordWrap())
	{
		// Target devices are only interesting if word wrap is on because the 
		// only really interesting thing a target device can tell us is where
		// the word breaks will occur.
		pddTarget = _pdp->GetTargetDev();
		if(pddTarget)
			SetUseTargetDevice(TRUE);
	}

	// Compute line break
	LONG lRet = Measure(xWidthMax, cchMax, uiFlags);

	// Stop here if failed
	if(lRet == MRET_FAILED)
		return FALSE;

	// Return target metrics if requested
	if(pliTarget)
		*pliTarget = _li;

	if(pddTarget)
	{
		// We just use this flag as an easy way to get the recomputation to occur.
		lRet = MRET_NOWIDTH;
	}

	SetUseTargetDevice(FALSE);

	// Recompute metrics on rendering device
	if(lRet == MRET_NOWIDTH)
	{
		long cch = _li._cch;
		Advance(-cch);				// move back to BOL
		NewLine(uiFlags & MEASURE_FIRSTINPARA);

		// Restore the line number 
		_li._bNumber = bNumberSave;
	
		lRet = Measure(0x7fffffff, cch, uiFlags);
		if(lRet)
		{
			Assert(lRet != MRET_NOWIDTH);
			return FALSE;
		}
	}
	
	// Now that we know the line width, compute line shift due
	// to alignment, and add it to the left position 
	_li._xLeft += MeasureLineShift();
	
	return TRUE;
}

/*
 *	CMeasurer::RecalcLineHeight ()
 *
 *	@mfunc
 *		Reset height of line we are measuring if new run of text is taller
 *		than current maximum in line.
 */
void CMeasurer::RecalcLineHeight(
	CCcs *pccs, const CCharFormat * const pCF)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::RecalcLineHeight");

	// Compute line height
	LONG yOffset, yAdjust;
	pccs->GetOffset(pCF, _fTarget ? _dyrInch : _dypInch, &yOffset, &yAdjust);

	LONG yHeight = pccs->_yHeight;
	LONG yDescent = pccs->_yDescent;

	SHORT	yFEAdjust = pccs->AdjustFEHeight(fAdjustFELineHt());
	
	if (yFEAdjust)
	{
		yHeight += (yFEAdjust << 1);
		yDescent += yFEAdjust;
	}

	LONG yAscent = yHeight - yDescent;

	LONG yAboveBase = max(yAscent,  yAscent + yOffset);
	LONG yBelowBase = max(yDescent, yDescent - yOffset);

	_li._yHeight  = (SHORT)(max(yAboveBase, _li._yHeight - _li._yDescent) +
					   max(yBelowBase, _li._yDescent));
	_li._yDescent = (SHORT)max(yBelowBase, _li._yDescent);
}

/*
 *	CMeasurer::Measure (xWidthMax, cchMax, uiFlags)
 *
 *	@mfunc
 *		Measure given amount of text, start at current running position
 *		and storing # chars measured in _cch. 
 *		Can optionally determine line break based on a xWidthMax and 
 *		break out at that point.
 *
 *	@rdesc
 *		0 success
 *		MRET_FAILED	 if failed 
 *		MRET_NOWIDTH if second pass is needed to compute correct width
 *
 *	@devnote
 *		The uiFlags parameter has the following meanings:
 *			MEASURE_FIRSTINPARA		this is first line of paragraph
 *			MEASURE_BREAKATWORD		break out on a word break
 *			MEASURE_BREAKATWIDTH	break closest possible to xWidthMax
 *
 *		The calling chain must be protected by a CLock, since this present
 *		routine access the global (shared) FontCache facility.
 */
LONG CMeasurer::Measure(
	LONG xWidthMax,			//@parm Max width of line (-1 uses CDisplay width)
	LONG cchMax,			//@parm Max chars to process (-1 if no limit)
	UINT uiFlags)			//@parm Flags controlling the process (see above)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::Measure");

	LONG		cch;				// cchChunk count down
	LONG		cchChunk;			// cch of cst-format contiguous run
	LONG		cchNonWhite;		// cch of last nonwhite char in line
	LONG		cchText = GetTextLength();
	unsigned	ch;					// Temporary char
	BOOL		fFirstInPara = uiFlags & MEASURE_FIRSTINPARA;
	BOOL        fLastChObj = FALSE;
	LONG		lRet = 0;
	const WCHAR*pch;
	CTxtEdit *	ped = GetPed();
	COleObject *pobj;
	LONG		xCaret = dxCaret;
	LONG		xAdd = 0;			// Character width
	LONG		xSoftHyphen = 0;	// Most recent soft hyphen width
	LONG		xWidthNonWhite;		// xWidth for last nonwhite char in line
	LONG		xWidthMaxOverhang;	// Max xWidth with current run's overhang
									//  taken into consideration.
	// This variable is used to keep track of whether there is a height change
	// so that we know whether we need to recalc the line in certain line break cases.
	BOOL		fHeightChange = FALSE;

	const INT	MAX_SAVED_WIDTHS = 31;	// power of 2 - 1
	INT			i, index, iSavedWidths = 0;
	struct {
		SHORT	width;
		SHORT	xLineOverhang;
		SHORT	yHeight;
		SHORT	yDescent;
	} savedWidths[MAX_SAVED_WIDTHS+1];

	_pPF = GetPF();							// Be sure current CParaFormat
											//  ptr is up to date
	BOOL fInTable	= _pPF->InTable();

	// If line spacing or space before/after, measure from beginning of line
	if (_li._cch && (_pPF->_bLineSpacingRule || _pPF->_dySpaceBefore ||
		_pPF->_dySpaceAfter || fInTable))					
	{										
		 Advance(-_li._cch);
		 NewLine(fFirstInPara);
	}

	// Init fliFirstInPara flag for new line
	if(fFirstInPara)
	{
		_li._bFlags |= fliFirstInPara;

		if(IsInOutlineView() && IsHeadingStyle(_pPF->_sStyle))
			_li._yHeight = (short)max(_li._yHeight, BITMAP_HEIGHT_HEADING + 1);
	}

	AssertSz(!_pPF->IsListNumbered() && !_wNumber ||
			 (uiFlags & MEASURE_BREAKBEFOREWIDTH) || !_pdp->IsMultiLine() ||
			 _wNumber > 20 || _wNumber == (i = GetParaNumber()),
		"CMeasurer::Measure: incorrect list number");
	_li._xLeft = MeasureLeftIndent();		// Set left indent

	// Compute width to break out at
	if(xWidthMax < 0)
	{					
		xWidthMax = MaxWidth();				// MaxWidth includes caret size
		xCaret = 0;
	}
	else
	{							  
		// (AndreiB) xWidthMax that's coming down to us is always calculated
		// with respect to the screen DC. The only scenario it comes into play
		// however is in TxGetNaturalSize, which may output a slightly
		// different result because of that.
		if(!_pdp->SameDevice(_pddReference) && _fTarget)
		{
			// xWidthMax is calculated to the size of the screen DC. If
			// there is a target device with different characteristics
			// we need to convert the width to the target device's width
			xWidthMax = _pddReference->ConvertXToDev(xWidthMax, _pdp);
		}
	}

	// For overhang support, we test against this adjusted widthMax.
	xWidthMaxOverhang = xWidthMax;

	// Are we ignoring the offset of the characters for the measure?
	if(!(uiFlags & MEASURE_IGNOREOFFSET))
	{
		// No - then take it from the max
		xWidthMaxOverhang -= (_li._xLineOverhang + xCaret);
	}

	// Compute max count of characters to process
	cch = cchText - GetCp();
	if(cchMax < 0 || cchMax > cch)
		cchMax = cch;

	cchNonWhite		= _li._cch;						// Default nonwhite parms
	xWidthNonWhite	= _li._xWidth;

	for( ; cchMax > 0;							// Measure up to cchMax
		cchMax -= cchChunk, Advance(cchChunk))	//  chars
	{
		pch = GetPch(cch);
		cch = min(cch, cchMax);					// Compute constant-format
		cchChunk = GetCchLeftRunCF();
		cch = min(cch, cchChunk);				// Counter for next while
		cchChunk = cch;							// Save chunk size

		const CCharFormat *pCF = GetCF();
		DWORD dwEffects = pCF->_dwEffects;

		if(dwEffects & CFE_HIDDEN)				// Ignore hidden text
		{
			_li._cch += cchChunk;
			continue;
		}

		if(!Check_pccs())						// Be sure _pccs is current
			return MRET_FAILED;

		xWidthMaxOverhang = xWidthMax;			// Overhang reduces max.

		// Are we ignoring offset of characters for the measure?
		if(!(uiFlags & MEASURE_IGNOREOFFSET))
		{
			// No - then take it from the max
			xWidthMaxOverhang -= (_pccs->_xOverhang + xCaret);
		}

		// Adjust line height for new format run

		if(cch > 0 && *pch && (IsRich() || ped->HasObjects()))
		{
			// Note: the EOP only contributes to the height calculation for the
			// line if there are no non-white space characters on the line or 
			// the paragraph is a bullet paragraph. The bullet paragraph 
			// contribution to the line height is done in AdjustLineHeight.

			// REVIEW (Victork) 
			// Another, similar topic is height of spaces.
			// They doesn't (normally) influence line height in LS, 
			// they do in CMeasurer::Measure code. 
			// Proposed ways to solve it:
			//		- have fSpacesOnly flag in run
			//		- move current (line height) logic down after next character-scanning loop


			if(!cchNonWhite || *pch != CR && *pch != LF)
			{
				// Determine if the current run is the tallest text on this
				// line and if so, increase the height of the line.
				LONG yHeightOld = _li._yHeight;
				RecalcLineHeight(_pccs, pCF);

				// Test for a change in line height. This only happens when
				// this is not the first character in the line and (surprise)
				// the height changes.
				if (yHeightOld && yHeightOld != _li._yHeight)
					fHeightChange = TRUE;
			}
		}

		while(cch > 0)
		{											// Process next char
			xAdd = 0;								// Default zero width
			ch = *pch;
			if(_chPassword && !IN_RANGE(LF, ch, CR))
				ch = _chPassword;

#ifdef UNICODE_SURROGATES
			if (IN_RANGE(0xD800, ch, 0xDFFF) && cch > 1 &&
				IN_RANGE(0xDC00, *(pch+1), 0xDFFF))	// Unicode extended char
			{
				// Convert to multiplane char (nibble 4 may be nonzero).
				// _pccs->Include(ch, xAdd) will project it down into plane 0
				// since it truncates to 16-bits. The currently selected font
				// should be correct for the plane given by (nibble 4) + 1.
				ch = WCHAR((ch << 10) | (*pch & 0x3FF));
				_li._bFlags |= fliHasSurrogates;	// Warn renderer
			}
			else									// AllCaps not supported
#endif												//  for surrogates

			if(dwEffects & CFE_ALLCAPS)
				ch = (WCHAR)CharUpper((WCHAR *)(DWORD_PTR)ch);	// See SDK to understand
													//  weird casts here
			if(ch == WCH_EMBEDDING)
			{
				_li._bFlags |= fliHasOle;
				pobj = ped->GetObjectMgr()->GetObjectFromCp
								(GetCp() + cchChunk - cch);
				if(pobj)
				{
					LONG yAscent, yDescent;
					pobj->MeasureObj(_fTarget ? _dyrInch : _dypInch, 
									 _fTarget ? _dxrInch : _dxpInch,
									 xAdd, yAscent, yDescent, _li._yDescent);

					// Only update height for line if the object is going
					// to be on this line.
					if(!_li._cch || _li._xWidth + xAdd <= xWidthMaxOverhang)
					{
						if (yAscent > _li._yHeight - _li._yDescent)
							_li._yHeight = yAscent + _li._yDescent;
					}
				}
				if(_li._xWidth + xAdd > xWidthMaxOverhang)
					fLastChObj = TRUE;
			}
			// The following if succeeds if ch isn't a CELL, BS, TAB, LF,
			// VT, FF, or CR
			else if(!IN_RANGE(CELL, ch, CR))		// Not TAB or EOP
			{
				// Get char width if not Unicode low surrogate	
				if (
#ifdef UNICODE_SURROGATES
					!IN_RANGE(0xDC00, ch, 0xDFFF) &&
#endif
					!IN_RANGE(0x300, ch, 0x36F) &&
					!_pccs->Include(ch, xAdd))
				{
					AssertSz(FALSE, "CMeasurer::Measure char not in font");
					return MRET_FAILED;
				}
				if(ch == SOFTHYPHEN)
				{
					_li._bFlags |= fliHasTabs;		// Setup RenderChunk()

					// get the width of hyphen instead
					if (!_pccs->Include('-', xAdd))
					{
						AssertSz(FALSE, "CMeasurer::Measure char not in font");
						return MRET_FAILED;
					}
					
					if(_li._xWidth + xAdd < xWidthMaxOverhang || !_li._cch)
					{
						xSoftHyphen = xAdd;			// Save soft hyphen width
						xAdd = 0;					// Use 0 unless at EOL
					}
				}
				else if (ch == EURO)
					_li._bFlags |= fliHasSpecialChars;
			}
			else if(ch == TAB || ch == CELL)		
			{
				_li._bFlags |= fliHasTabs;
				xAdd = MeasureTab(ch);
			}
			else if(ch == FF && ped->Get10Mode())	// RichEdit 1.0 treats
				_pccs->Include(ch, xAdd);			//  FFs as normal chars

			else									// Done with line
				goto eop;							// Go process EOP chars

			index = iSavedWidths++ & MAX_SAVED_WIDTHS;
			savedWidths[index].width		 = (SHORT)xAdd;
			savedWidths[index].xLineOverhang = _li._xLineOverhang;
			savedWidths[index].yHeight		 = _li._yHeight;
			savedWidths[index].yDescent		 = _li._yDescent;
			_li._xWidth += xAdd;

			if(_li._xWidth > xWidthMaxOverhang &&
				(uiFlags & MEASURE_BREAKBEFOREWIDTH || _li._cch > 0))
				goto overflow;

			_li._cch++;
			pch++;
			cch--;
			if(ch != TEXT(' ') /*&& ch != TAB*/)	// If not whitespace char,
			{
				cchNonWhite		= _li._cch;			//  update nonwhitespace
				xWidthNonWhite	= _li._xWidth;		//  count and width
			}
		}											// while(cch > 0)
	}												// for(;cchMax > 0;...)
	goto eol;										// All text exhausted 


// End Of Paragraph	char encountered (CR, LF, VT, or FF, but mostly CR)
eop:
	Advance(cchChunk - cch);				// Position tp at EOP
	cch = AdvanceCRLF();					// Bypass possibly multibyte EOP
	_li._cchEOP = (BYTE)cch;				// Store EOP cch
	_li._cch   += cch;						// Increment line count
	if(ch == CR || ped->fUseCRLF() && ch == LF)
		_li._bFlags |= fliHasEOP;
	
	AssertSz(ped->fUseCRLF() || cch == 1,
		"CMeasurer::Measure: EOP isn't a single char");
	AssertSz(_pdp->IsMultiLine() || GetCp() == cchText,
		"CMeasurer::Measure: EOP in single-line control");

eol:										// End of current line
	if(uiFlags & MEASURE_BREAKATWORD)		// Compute count of whitespace
	{										//  chars at EOL
		_li._cchWhite = (SHORT)(_li._cch - cchNonWhite);
		_li._xWidth = xWidthNonWhite;
	}
	goto done;

overflow:									// Went past max width for line
	_li._xWidth -= xAdd;
	--iSavedWidths;
	_li._xLineOverhang = savedWidths[iSavedWidths & MAX_SAVED_WIDTHS].xLineOverhang;
	Advance(cchChunk - cch);				// Position *this at overflow
											//  position
	if(uiFlags & MEASURE_BREAKATWORD)		// If required, adjust break on
	{										//  word boundary
		// We should not have the EOP flag set here.  The case to watch out
		// for is when we reuse a line that used to have an EOP.  It is the
		// responsibility of the measurer to clear this flag as appropriate.
	
		Assert(_li._cchEOP == 0);
		_li._cchEOP = 0;						// Just in case

		if(ch == TAB || ch == CELL)
		{
			// If the last character measured is a tab,	leave it on the
			// next line to allow tabbing off the end of line as in Word
			goto done;
		}

		LONG cpStop = GetCp();					// Remember current cp

		cch = -FindWordBreak(WB_LEFTBREAK, _li._cch+1);

		if(cch == 0 && fLastChObj)				// If preceding char is an
			goto done;							//  object,	put current char
												//  on next line
		Assert(cch >= 0);
		if(cch + 1 < _li._cch)					// Break char not at BOL
		{
			ch = _rpTX.GetPrevChar();
			if (ch == TAB || ch == CELL)		// If break char is a TAB,
			{									//  put it on the next line
				cch++;							//  as in Word
				Advance(-1);					
			}
			else if(ch == SOFTHYPHEN)
				_li._xWidth += xSoftHyphen;
			_li._cch -= cch;
		}
		else if(cch == _li._cch && cch > 1 &&
			_rpTX.GetChar() == ' ')				// Blanks all the way back to
		{										//  BOL. Bypass first blank
			Advance(1);
			cch--;
			_li._cch = 1;
		}
		else									// Advance forward to end of
			SetCp(cpStop);						//  measurement

		Assert(_li._cch > 0);

		// Now search at start of word to figure how many white chars at EOL
		if(GetCp() < cchText)
		{
			pch = GetPch(cch);
			cch = 0;
			if(ped->TxWordBreakProc((WCHAR *)pch, 0, sizeof(WCHAR), WB_ISDELIMITER, GetCp()))
			{
				cch = FindWordBreak(WB_RIGHT);
				Assert(cch >= 0);
			}

			_li._cchWhite = (SHORT)cch;
			_li._cch += cch;

			ch = GetChar();
			if(IsASCIIEOP(ch))					// skip *only* 1 EOP -jOn
			{
				if(ch == CR)
					_li._bFlags |= fliHasEOP;
				_li._cchEOP = (BYTE)AdvanceCRLF();
				_li._cch += _li._cchEOP;
				goto done;
			}
		}

		i = cpStop - GetCp();
		if(i)
		{
			if(i > 0)
				i += _li._cchWhite;
			if(i > 0 && i < iSavedWidths && i < MAX_SAVED_WIDTHS)
			{
				while (i-- > 0)
				{
					iSavedWidths = (iSavedWidths - 1) & MAX_SAVED_WIDTHS;
					_li._xWidth -= savedWidths[iSavedWidths].width;
				}
				iSavedWidths = (iSavedWidths - 1) & MAX_SAVED_WIDTHS;
				_li._xLineOverhang = savedWidths[iSavedWidths].xLineOverhang;
				_li._yHeight	   = savedWidths[iSavedWidths].yHeight;
				_li._yDescent	   = savedWidths[iSavedWidths].yDescent;
			}
			else
			{
				// Need to recompute width from scratch.
				_li._xWidth = -1;
				lRet = MRET_NOWIDTH;
			}
		}
		else
		{
			// i == 0 means that we are breaking on the first letter in a word.
			// Therefore, we want to set the width to the total non-white space
			// calculated so far because that does not include the size of the
			// character that caused the break nor any of the white space 
			// preceeding the character that caused the break.
			if(!fHeightChange)
				_li._xWidth = xWidthNonWhite;
			else
			{
				// Need to recompute from scratch so that we can get the 
				// correct height for the control
				_li._xWidth = -1;
				lRet = MRET_NOWIDTH;
			}
		}
	}

done:
	_xAddLast = xAdd;
	if(!_li._yHeight)						// If no height yet, use
		CheckLineHeight();					//  default height

	AdjustLineHeight();
	return lRet;
}

/*
 *	CMeasurer::GetCcsFontFallback
 *
 *	@mfunc
 *		Create the fallback font cache for given CF
 */
CCcs* CMeasurer::GetCcsFontFallback (const CCharFormat *pCF)
{
	CCharFormat	CF = *pCF;
	CCcs*		pccs = NULL;
	SHORT		iDefHeight;

	bool	fr = W32->GetPreferredFontInfo(GetCodePage(CF._bCharSet), 
									GetPed()->fUseUIFont() ? true : false, CF._iFont, 
									(BYTE&)iDefHeight, CF._bPitchAndFamily);
	if (fr)
		pccs = GetCcs(&CF);		// create fallback font cache entry

	return pccs;
}

/*
 * 	CMeasurer::ApplyFontCache (fFallback)
 *
 *	@mfunc
 *		Apply a new font cache on the fly (leave backing store intact)
 */
CCcs* CMeasurer::ApplyFontCache (
	BOOL	fFallback)
{
	if (_fFallback ^ fFallback)
	{
		CCcs*	pccs = fFallback ? GetCcsFontFallback(GetCF()) : GetCcs(GetCF());
		
		if (pccs)
		{
			if (_pccs)
				_pccs->Release();
			_pccs = pccs;
	
			_fFallback = fFallback;
		}
	}
	return _pccs;
}

/*
 *	CMeasurer::GetCcs
 *
 *	@mfunc
 *		Wrapper around font cache's GetCCcs function
 *	We use a NULL DC unless the device is a printer.
 */
CCcs* CMeasurer::GetCcs(const CCharFormat *pCF)
{
	HDC hdc = NULL;

	if (_fTarget)
	{
		if (_pddReference->_hdc && _dtRef == DT_RASPRINTER)
			hdc = _pddReference->_hdc;
	}
	else if (_pdp->_hdc && _dtPres == DT_RASPRINTER)
		hdc = _pdp->_hdc;

	return fc().GetCcs(pCF, _fTarget ? _dyrInch : _dypInch, hdc, 
					   _fGlyphing && _dtRef == DT_RASPRINTER);
}

/*
 *	CMeasurer::CheckLineHeight()
 *
 *	@mfunc
 *		If no height yet, use default height
 */
void CMeasurer::CheckLineHeight()
{
	CCcs *pccs = GetCcs(GetPed()->GetCharFormat(-1));
	_li._yHeight  = pccs->_yHeight;
	_li._yDescent = pccs->_yDescent;

	SHORT	yFEAdjust = pccs->AdjustFEHeight(fAdjustFELineHt());

	if (yFEAdjust)
	{
		_li._yHeight += (yFEAdjust << 1);
		_li._yDescent += yFEAdjust;
	}
	pccs->Release();
}

/*
 *	CMeasurer::Check_pccs()
 *
 *	@mfunc
 *		Check if new character format run or whether we don't yet have a font
 *
 *	@rdesc
 *		Current CCcs *
 *
 *	@devnote
 *		The calling chain must be protected by a CLock, since this present
 *		routine access the global (shared) FontCache facility.
 */
CCcs *CMeasurer::Check_pccs(
	BOOL fBullet)
{
	if(fBullet)
	{
		if(_pccs)							// Release old Format cache
			_pccs->Release();

		_pccs = GetCcsBullet(NULL);
		_iFormat = -10;						// Be sure to reset font next time
		return _pccs;
	}

	const CCharFormat *pCF = GetCF();

	if(FormatIsChanged())
	{
		// New CF run or format for this line not yet initialized
		ResetCachediFormat();
		if(_pccs)							// Release old Format cache
			_pccs->Release();
			
		_pccs = GetCcs(pCF);
		_fFallback = 0;

		if(!_pccs)
		{
			//FUTURE (keithcu) If this fails, just dig up the first pccs you can find
			AssertSz(FALSE, "CMeasurer::Measure could not get _pccs");
			return NULL;
		}
	}

	// NOTE: Drawing with a dotted pen on the screen and in a
	// compatible bitmap does not seem to match on some hardware.
	// If at some future point we do a better job of drawing the
	// dotted underline, this statement block can be removed.
	if(CFU_UNDERLINEDOTTED == pCF->_bUnderlineType)
	{
		// We draw all dotted underline lines off screen to get
		// a consistent display of the dotted line.
		_li._bFlags |= fliUseOffScreenDC;
	}

	_li._xLineOverhang = _pccs->_xOverhang;
	return _pccs;
}

/*
 *	CMeasurer::AdjustLineHeight()
 *
 *	@mfunc
 *		Adjust for space before/after and line spacing rules.
 *		No effect for plain text.
 *
 *	@future
 *		Base multiple line height calculations on largest font height rather
 *		than on line height (_yHeight), since the latter may be unduly large
 *		due to embedded objects.  Word does this correctly.
 */
void CMeasurer::AdjustLineHeight()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::AdjustLineHeight");

	if(!IsRich() || IsInOutlineView())			// Plain text and outline mode
		return;									//  don't use special line
												//  spacings
	const CParaFormat * pPF = _pPF;
	DWORD	dwRule	  = pPF->_bLineSpacingRule;
	LONG	dyAfter	  = 0;						// Default no space after
	LONG	dyBefore  = 0;						// Default no space before
	LONG	dySpacing = pPF->_dyLineSpacing;
	LONG	yHeight	  = LYtoDY(dySpacing);
	LONG	yAscent = _li._yHeight - _li._yDescent;

	if(_li._bFlags & fliFirstInPara)
		dyBefore = LYtoDY(pPF->_dySpaceBefore);	// Space before paragraph

	AssertSz(dyBefore >= 0, "CMeasurer::AdjustLineHeight - bogus value for dyBefore");

	if(yHeight < 0)								// Negative heights mean use
		_li._yHeight = (SHORT)(-yHeight);		//  the magnitude exactly

	else if(dwRule)								// Line spacing rule is active
	{
		switch (dwRule)
		{
		case tomLineSpace1pt5:
			dyAfter = _li._yHeight >> 1;		// Half-line space after
			break;								//  (per line)
	
		case tomLineSpaceDouble:
			dyAfter = _li._yHeight;				// Full-line space after
			break;								//  (per line)
	
		case tomLineSpaceAtLeast:
			if(_li._yHeight >= yHeight)
				break;
												// Fall thru to space exactly
		case tomLineSpaceExactly:
			_li._yHeight = (SHORT)max(yHeight, 1);
			break;
	
		case tomLineSpaceMultiple:				// Multiple-line space after
			// Prevent dyAfter from being negative because dySpacing is small - a-rsail
			if (dySpacing < 20)
				dySpacing = 20;

			dyAfter = (_li._yHeight*dySpacing)/20 // (20 units per line)
						- _li._yHeight;
		}
	}

	if(_li._bFlags & fliHasEOP)	
		dyAfter += LYtoDY(pPF->_dySpaceAfter);	// Space after paragraph end
												// Add in space before/after

	if (dyAfter < 0)
	{
		// Overflow - since we forced dySpacing to 20 above, the
		// only reason for a negative is overflow. In case of overflow,
		// we simply force the value to the max and then fix the
		// other resulting overflows.
		dyAfter = LONG_MAX;
	}

	AssertSz((dyBefore >= 0), "CMeasurer::AdjustLineHeight - invalid before");

	_li._yHeight  = (SHORT)(_li._yHeight + dyBefore + dyAfter);	

	if (_li._yHeight < 0)
	{
		// Overflow!
		// The reason for the -2 is then we don't have to worry about
		// overflow in the table check.
		_li._yHeight = SHRT_MAX - 2;
	}

	_li._yDescent = (SHORT)(_li._yDescent + dyAfter);

	if (_li._yDescent < 0)
	{
		// Overflow in descent
		AssertSz(_li._yHeight == SHRT_MAX - 2, "Descent overflowed when height didn't");

		// Allow old ascent
		_li._yDescent = SHRT_MAX - 2 - yAscent;

		AssertSz(_li._yDescent >= 0, "descent adjustment < 0");		
	}

	if(_pPF->InTable())
	{
		_li._yHeight++;
		if(!_li._fNextInTable)
		{
			_li._yHeight++;
			_li._yDescent++;
		}
	}

	AssertSz((_li._yHeight >= 0) && (_li._yDescent >= 0),
		"CMeasurer::AdjustLineHeight - invalid line heights");
}

/*
 *	CMeasurer::MeasureLeftIndent()
 *
 *	@mfunc
 *		Compute and return left indent of line in device units
 *
 *	@rdesc
 *		Left indent of line in device units
 *
 *	@comm
 *		Plain text is sensitive to StartIndent and RightIndent settings,
 *		but usually these are zero for plain text. 
 */
LONG CMeasurer::MeasureLeftIndent()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::MeasureLeftIndent");

	AssertSz(_pPF != NULL, "CMeasurer::MeasureLeftIndent _pPF not set!");

	LONG xLeft = _pPF->_dxStartIndent;				// Use logical units
													//  up to return
	if(IsRich())
	{
		LONG dxOffset = _pPF->_dxOffset;
		BOOL fFirstInPara = _li._bFlags & fliFirstInPara;

		if(IsInOutlineView())
		{
			xLeft = lDefaultTab/2 * (_pPF->_bOutlineLevel + 1);
			if(!fFirstInPara)
				dxOffset = 0;
		}
		if(fFirstInPara)
		{
			if(_pPF->_wNumbering && !_pPF->IsNumberSuppressed())// Add offset to text
			{											//  on first line	 
				LONG dx = DXtoLX(MeasureBullet());	// Use max of bullet
				dx = max(dx, _pPF->_wNumberingTab);		//  width, numbering tab,
				dxOffset = max(dxOffset, dx);			//  and para offset
			}
			else if(_pPF->InTable())					// For tables, need to
				xLeft += dxOffset;						//  add in trgaph twice
														//  since dxStartIndent
			else										//  subtracts one
				dxOffset = 0;
		}
		xLeft += dxOffset;								
	}
	// FUTURE: tables extending to the left of the left margin will be clipped
	// accordingly on the left. We could move the table to the right, but
	// then we need to move tabs to the right as well (include out parm with
	// amount of negative left indent.  Ideally we may want to enable a horiz
	// scroll bar able to shift to the left of the left margin for this case
	// as in Word.
	if(!_pPF->InTable() && xLeft <= 0)
		return 0;
	return LXtoDX(xLeft);
}

/*
 *	CMeasurer::HitTest(x)
 *
 *	@mfunc
 *		Return HITTEST for displacement x in this line. Can't be specific
 *		about text area (_xLeft to _xLeft + _xWidth), since need to measure
 *		to get appropriate cp (done elsewhere)
 *
 *	@rdesc
 *		HITTEST for a displacement x in this line
 */
HITTEST CMeasurer::HitTest(
	LONG x)			//@parm Displacement to test hit
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::HitTest");

	UpdatePF();
	LONG u = UFromX(x);

	if(u < 0)
		return HT_LeftOfText;

	if(u > _li._xLeft + _li._xWidth)
		return HT_RightOfText;

	if(u >= _li._xLeft)							// Caller can refine this
		return HT_Text;							//  with CLine::CchFromXpos()

	if(IsRich() && (_li._bFlags & fliFirstInPara))
	{
		_pPF = GetPF();
	
		LONG dx;
	
		if(_pPF->_wNumbering)
		{
			// Doesn't handle case where Bullet is wider than following dx
			dx = LXtoDX(max(_pPF->_dxOffset, _pPF->_wNumberingTab));
			if(u >= _li._xLeft - dx)
				return HT_BulletArea;
		}
		if(IsInOutlineView())
		{
			dx = LXtoDX(lDefaultTab/2 * _pPF->_bOutlineLevel);
			if(u >= dx && u < dx + (_pPF->_bOutlineLevel & 1
				? LXtoDX(lDefaultTab/2) : _pdp->Zoom(BITMAP_WIDTH_HEADING)))
			{
				return HT_OutlineSymbol;
			}
		}
	}
	return HT_LeftOfText;
}

/*
 *	CMeasurer::MeasureRightIndent()
 *
 *	@mfunc
 *		Compute and return right indent of line in device units
 *
 *	@rdesc
 *		right indent of line in device units
 *
 *	@comm
 *		Plain text is sensitive to StartIndent and RightIndent settings,
 *		but usually these are zero for plain text. 
 */
LONG CMeasurer::MeasureRightIndent()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::MeasureRightIndent");

	return LXtoDX(max(_pPF->_dxRightIndent, 0));
}

/*
 *	CMeasurer::MeasureTab()
 *
 *	@mfunc
 *		Computes and returns the width from the current position to the
 *		next tab stop (in device units).
 */
LONG CMeasurer::MeasureTab(unsigned ch)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::MeasureTab");

	LONG			xCur = _li._xWidth + MeasureLeftIndent();
	const CParaFormat *	pPF = _pPF;
 	LONG			cTab = pPF->_bTabCount;
	LONG			dxDefaultTab = lDefaultTab;
	LONG			dxIndent = LXtoDX(pPF->_dxStartIndent + pPF->_dxOffset);
	LONG			dxOffset = pPF->_dxOffset;
	LONG			dxOutline = 0;
	BOOL			fInTable = pPF->InTable();
	LONG			h = 0;
	LONG			xT;
	LONG			xTab;

	AssertSz(cTab >= 0 || cTab <= MAX_TAB_STOPS,
		"CMeasurer::MeasureTab: illegal tab count");

	if(fInTable)
	{
		h = LXtoDX(dxOffset);
		dxOffset = 0;
	}

	if(IsInOutlineView())
		dxOutline = lDefaultTab/2 * (pPF->_bOutlineLevel + 1);

	if(cTab && (!fInTable || ch == CELL))		// Use default TAB for TAB in
	{											//  table
		const LONG *pl = pPF->GetTabs();
		for(xTab = 0; cTab--; pl++)				// Try explicit tab stops 1st
		{
			xT = GetTabPos(*pl) + dxOutline;	// (2 most significant nibbles
			xT = LXtoDX(xT);					//  are for type/style)

			if(xT > MaxWidth())					// Ignore tabs wider than display
				break;

			if(xT + h > xCur)					// Allow text in table cell to
			{									//  move into cell gap (h > 0)									
				if(dxOffset > 0 && xT < dxIndent)// Explicit tab in a hanging
					return xT - xCur;			//  indent takes precedence
				xTab = xT;
				break;
			}
		}
		if(dxOffset > 0 && xCur < dxIndent)		// If no tab before hanging
			return dxIndent - xCur;				//  indent, tab to indent

		if(xTab)								// Else use tab position
		{
			if(fInTable)
			{
				xTab += h;
				if(cTab)						// Don't include cell gap in
					xTab += h;					//  last cell
				if(IsInOutlineView() && cTab < pPF->_bTabCount)
					xTab += h;
			}
			return xTab - xCur;
		}
	}

	dxDefaultTab = GetTabPos(GetPed()->GetDefaultTab());
	AssertSz(dxDefaultTab > 0, "CMeasurer::MeasureTab: Default tab is bad");

	dxDefaultTab = LXtoDX(dxDefaultTab);
	dxDefaultTab = max(dxDefaultTab, 1);		// Don't ever divide by 0
	return dxDefaultTab - xCur%dxDefaultTab;	// Round up to nearest
}

/*
 *	CMeasurer::MeasureLineShift ()
 *
 *	@mfunc
 *		Computes and returns the line x shift due to alignment
 *
 *	@comm
 *		Plain text is sensitive to StartIndent and RightIndent settings,
 *		but usually these are zero for plain text. 
 */
LONG CMeasurer::MeasureLineShift()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::MeasureLineShift");

	WORD wAlignment = _pPF->_bAlignment;
	LONG xShift;

	if (IsInOutlineView() ||
		(wAlignment != PFA_RIGHT && wAlignment != PFA_CENTER))
	{
		return 0;
	}

	// Normal view with center or flush-right para. Move right accordingly

	xShift = _pdp->GetMaxPixelWidth() - _li._xLeft - MeasureRightIndent() - 
							dxCaret - _li._xLineOverhang - _li._xWidth;

	xShift = max(xShift, 0);			// Don't allow alignment to go < 0
										// Can happen with a target device
	if(wAlignment == PFA_CENTER)
		xShift /= 2;

	return xShift;
}

/*
 *	CMeasurer::MeasureBullet()
 *
 *	@mfunc
 *		Computes bullet/numbering dimensions
 *
 *	@rdesc
 *		return bullet/numbering string width
 */
LONG CMeasurer::MeasureBullet()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::MeasureBullet");

	CCharFormat CF;
	CCcs *pccs = GetCcsBullet(&CF);
	LONG xWidth = 0;

	if(pccs)
	{										
		WCHAR szBullet[CCHMAXNUMTOSTR];
		GetBullet(szBullet, pccs, &xWidth);
		RecalcLineHeight(pccs, &CF);
		pccs->Release();
	}
	return xWidth;
}

/*
 *	CMeasurer::GetBullet(pch, pccs, pxWidth)
 *
 *	@mfunc
 *		Computes bullet/numbering string, string length, and width
 *
 *	@rdesc
 *		return bullet/numbering string length
 */
LONG CMeasurer::GetBullet(
	WCHAR *pch,			//@parm Bullet string to receive bullet text
	CCcs  *pccs,		//@parm CCcs to use
	LONG  *pxWidth)		//@parm Out parm for bullet width
{
	Assert(pccs && pch);

	LONG cch = _pPF->NumToStr(pch, _li._bNumber);
	LONG dx;
	LONG i;
	LONG xWidth = 0;

	pch[cch++] = ' ';					// Ensure a little extra space
	for(i = cch; i--; xWidth += dx)
	{
		if(!pccs->Include(*pch++, dx))
		{
			TRACEERRSZSC("CMeasurer::GetBullet(): Error filling CCcs", E_FAIL);
		}
	}
	xWidth += pccs->_xUnderhang + pccs->_xOverhang;
	if(pxWidth)
		*pxWidth = xWidth;

	return cch;
}

/*
 *	CMeasurer::GetCcsBullet(pCFRet)
 *
 *	@mfunc
 *		Get CCcs for numbering/bullet font. If bullet is suppressed because
 *		this isn't the beginning of a paragraph (e.g., previous character is
 *		VT or if GetCcs() fails, it returns NULL.
 *
 *	@rdesc
 *		ptr to bullet CCcs, or NULL (GetCcs() failed or not start of para)
 *
 *	@devnote
 *		The calling chain must be protected by a CLock, since this present
 *		routine access the global (shared) FontCache facility.
 */
CCcs * CMeasurer::GetCcsBullet(
	CCharFormat *pCFRet)	//@parm option character format to return
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::GetCcsBullet");

	if(!(_li._bFlags & fliFirstInPara))
		return NULL;					// Number/bullet suppressed

	CCharFormat			CF;
	CCcs *			    pccs;
	const CCharFormat *	pCF;
	CCharFormat *		pCFUsed = pCFRet ? pCFRet : &CF;

	// Bullet CF is given by that for EOP in bullet's paragraph.

	CTxtPtr		  tp(_rpTX);
	CFormatRunPtr rpCF(_rpCF);
	rpCF.AdvanceCp(tp.FindEOP(tomForward));
	rpCF.AdjustBackward();
	pCF = GetPed()->GetCharFormat(rpCF.GetFormat());

	// Construct bullet (or numbering) CCharFormat
	*pCFUsed = *pCF;
	if(_pPF->_wNumbering == PFN_BULLET)			// Traditional bullet uses
	{											//  Symbol font bullet, but...
		pCFUsed->_bCharSet		  = SYMBOL_CHARSET,
		pCFUsed->_bPitchAndFamily = FF_DONTCARE;
		pCFUsed->_iFont			  = IFONT_SYMBOL;
	}

	// Since we always cook up bullet character format, no need to cache it
	pccs = GetCcs(pCFUsed);

#if DEBUG
	if(!pccs)
	{
		TRACEERRSZSC("CMeasurer::GetCcsBullet(): no CCcs", E_FAIL);
	}
#endif // DEBUG

	return pccs;
}

/*
 *	CMeasurer::SetNumber(wNumber)
 *
 *	@mfunc
 *		Store number if numbered paragraph
 */
void CMeasurer::SetNumber(
	WORD wNumber)
{
	_pPF = GetPF();
	if(!_pPF->IsListNumbered())
		wNumber = 0;

	else if (!wNumber)
		wNumber = 1;

	_wNumber = wNumber;
}

/*
 *	CMeasurer::DXtoLX(x), LXtoDX(x), LYtoDY(y)
 *
 *	@mfunc
 *		Functions that convert from file to pixel coordinates
 *
 *	@rdesc
 *		Scaled coordinate
 */
LONG CMeasurer::DXtoLX(LONG x)
{
	return MulDiv(x, LX_PER_INCH, _fTarget ? _dxrInch : _dxpInch);
}

LONG CMeasurer::LXtoDX(LONG x)
{
	return MulDiv(x, _fTarget ? _dxrInch : _dxpInch, LX_PER_INCH);
}

LONG CMeasurer::LYtoDY(LONG y)
{
	return MulDiv(y, _fTarget ? _dyrInch : _dypInch, LX_PER_INCH);
}

LONG CMeasurer::XFromU(LONG u)
{
#ifdef LINESERVICES
	if (_pPF->IsRtlPara())
	{
		LONG xCaret = _pdp->IsMain() ? dxCaret : 0, xWidth;

		if (_pdp->GetMaxWidth())
			xWidth = LXtoDX(_pdp->GetMaxWidth());
		else
			xWidth = max(0, _pdp->GetMaxPixelWidth());

		if(!_pdp->GetWordWrap())
		{
			xWidth = max(xWidth, _pdp->GetViewWidth());
			xWidth = max(xWidth, _pdp->GetWidth());
		}

		xWidth -= xCaret;

		POINT ptStart = {xWidth, 0};
		POINTUV pointuv = {u, 0};
		POINT	pt;

		LsPointXYFromPointUV(&ptStart, lstflowWS, &pointuv, &pt);
		return pt.x;
	}
	else
#endif
		return u;
}

LONG CMeasurer::UFromX(LONG x)
{
#ifdef LINESERVICES
	if (_pPF->IsRtlPara())
		return XFromU(x);
	else
#endif
		return x;
}

/*
 *	CMeasurer::GetPols(pme)
 *
 *	@mfunc
 *		Get ptr to LineServices object. If LineServices not enabled,
 *		return NULL.  If pme is nonNULL, use it as COls::_pme.
 *
 *	@rdesc
 *		POLS
 */
#ifdef LINESERVICES
extern BOOL g_fNoLS;

COls *CMeasurer::GetPols(
	CMeasurer **ppme)
{
	CTxtEdit *ped = GetPed();

	if(ppme)								// Default no previous measurer
		*ppme = NULL;

	if(g_fNoLS || !ped->fUseLineServices())			// Not using LineServices
		return NULL;

	if(!g_pols)								// Starting up LS:
		g_pols = new COls();				//  create new COls

	if(g_pols)								// Have the COls
	{
		if(ppme)
			*ppme = g_pols->_pme;			// Return current g_pols->_pme

		if(g_pols->Init(this) != NOERROR)	// Switch to new one
		{
			delete g_pols;
			g_pols = NULL;
		}
		UpdatePF();
	}
	return g_pols;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\line.cpp ===
/*
 *	LINE.CPP
 *	
 *	Purpose:
 *		CLine class
 *	
 *	Authors:
 *		RichEdit 1.0 code: David R. Fulmer
 *		Christian Fortini (initial conversion to C++)
 *		Murray Sargent
 *
 *	Copyright (c) 1995-1998 Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_line.h"
#include "_measure.h"
#include "_render.h"
#include "_disp.h"
#include "_edit.h"

ASSERTDATA

/*
 *	CLine::Measure(&me, cchMax, xWidth, uiFlags, pliTarget)
 *
 *	@mfunc
 *		Computes line break (based on target device) and fills
 *		in this CLine with resulting metrics on rendering device
 *
 *	@rdesc 
 *		TRUE if OK
 *
 *	@devnote
 *		me is moved past line (to beginning of next line).  Note: CLock is
 *		needed in the main four routines (Measure, MeasureText, CchFromXPos,
 *		and RenderLine), since they use the global (shared) fc().GetCcs()
 *		facility and may use the LineServices global g_plsc and g_pols.
 */
BOOL CLine::Measure(
	CMeasurer& me,			//@parm Measurer pointing at text to measure
	LONG	   cchMax,		//@parm Max cch to measure
    LONG	   xWidth,		//@parm Width of line in device units
	UINT	   uiFlags,		//@parm Flags
	CLine *	   pliTarget)	//@parm Returns target-device line metrics (optional)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLine::Measure");

	CLock	lock;
	BOOL	fFirstInPara = uiFlags & MEASURE_FIRSTINPARA;
	BOOL	fMultiLine = me.GetPdp()->IsMultiLine();
	BOOL	fRet;

	if(fMultiLine && fFirstInPara && me.GetPrevChar() == VT)
	{
		fFirstInPara = FALSE;
		uiFlags &= ~MEASURE_FIRSTINPARA;
	}

	if(!(uiFlags & MEASURE_DONTINIT))
		me.NewLine(fFirstInPara);

	else if(fFirstInPara)
		me._li._bFlags |= fliFirstInPara;

	BYTE bNumber = me._wNumber < 256	// Store current para # offset
				 ? me._wNumber : 255;
	me._li._bNumber = bNumber;
	
#ifdef LINESERVICES
	CMeasurer *pmeSave;
	COls *	   pols = me.GetPols(&pmeSave);	// Try for LineServices object
	if(pols)								// Got it: use LineServices
	{
		fRet = pols->MeasureLine(xWidth, pliTarget);
		pols->SetMeasurer(pmeSave);			// Restore previous pme
	}
	else									// LineServices not active
#endif
		fRet = me.MeasureLine(cchMax, xWidth, uiFlags, pliTarget);

	if(!fRet)
		return FALSE;

	*this = me._li;							// Copy over line info

	if(!fMultiLine)							// Single-line controls can't
		return TRUE;						//  have paragraph numbering

	if(me.IsInOutlineView())
	{
		if(IsHeadingStyle(me._pPF->_sStyle))	// Store heading number if relevant
			_nHeading = (BYTE)(-me._pPF->_sStyle - 1);

		if(me._pPF->_wEffects & PFE_COLLAPSED)	// Cache collapsed bit
			_fCollapsed = TRUE;
	}

	_bNumber = bNumber;
	
	if(_bFlags & fliHasEOP)					// Check for new para number
	{
		const CParaFormat *pPF = me.GetPF();

		me._wNumber	  = (WORD)pPF->UpdateNumber(me._wNumber, me._pPF);
		_fNextInTable = pPF->InTable() && me.GetCp() < me.GetTextLength();
	}
	return TRUE;
}
	
/*
 *	CLine::Render(&re)
 *
 *	@mfunc
 *		Render visible part of this line
 *
 *	@rdesc
 *		TRUE iff successful
 *
 *	@devnote
 *		re is moved past line (to beginning of next line).
 *		FUTURE: the RenderLine functions return success/failure.
 *		Could do something on failure, e.g., be specific and fire
 *		appropriate notifications like out of memory.
 */
BOOL CLine::Render(
	CRenderer& re)			//@parm Renderer to use
{
	if(_fCollapsed)						// Line is collapsed in Outline view
	{
		re.Advance(_cch);				// Bypass line
		return TRUE;
	}

	BOOL	fRet;
	CLock	lock;
	POINT	pt = re.GetCurPoint();

#ifdef LINESERVICES
	CMeasurer *pmeSave;
	COls *pols = re.GetPols(&pmeSave);	// Try for LineServices object
	if(pols)
	{
		fRet = pols->RenderLine(*this);
		pols->SetMeasurer(pmeSave);		// Restore previous pme
	}
	else
#endif
		fRet = re.RenderLine(*this);

	pt.y += GetHeight();				// Advance to next line	position
	re.SetCurPoint(pt);
	return fRet;
}

/*
 *	CLine::CchFromXPos(&me, x, pdispdim, pHit)
 *
 *	@mfunc
 *		Computes cch corresponding to x position in a line.
 *		Used for hit testing.
 *
 *	@rdesc 
 *		cch found up to the x coordinate x	
 *
 *	@devnote
 *		me is moved to the cp at the cch offset returned
 */
LONG CLine::CchFromXpos(
	CMeasurer& me,		//@parm Measurer position at start of line
	POINT	 pt,		//@parm pt.x is x coord to search for
	CDispDim*pdispdim,	//@parm Returns display dimensions
	HITTEST *phit,		//@parm Returns hit type at x	
	LONG	*pcpActual) const //@parm actual CP above with display dimensions
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLine::CchFromXpos");
	
#ifdef Boustrophedon
	//if(_pPF->_wEffects & PFE_BOUSTROPHEDON)
	{
		RECT rcView;
		me.GetPed()->_pdp->GetViewRect(rcView, NULL);
		pt.x = rcView.right - pt.x;
	}
#endif
	CLock		lock;
	const BOOL	fFirst = _bFlags & fliFirstInPara;
	*phit =		HT_Text;
	LONG		cpActual = me.GetCp();
	CDispDim	dispdim;
	
	me._li = *this;
	me._li._cch = 0;					// Default zero count

	*phit = me.HitTest(pt.x);

	if(*phit == HT_Text || *phit == HT_RightOfText) // To right of left margin
	{
		me.NewLine(fFirst);

#ifdef LINESERVICES
		CMeasurer *pmeSave;
		COls *pols = me.GetPols(&pmeSave);// Try for LineServices object
		if(pols)						// Got it: use LineServices
		{
			pols->CchFromXpos(pt, &dispdim, &cpActual);
			pols->SetMeasurer(pmeSave);		// Restore previous pme
		}
		else
#endif
			if(me.Measure(pt.x - _xLeft, _cch,
						  MEASURE_BREAKBEFOREWIDTH | MEASURE_IGNOREOFFSET 
						  | (fFirst ? MEASURE_FIRSTINPARA : 0)) >= 0)
			{
				LONG xWidthBefore = me._li._xWidth;
				cpActual = me.GetCp();
				if (me._li._cch < _cch)
				{
					dispdim.dx = me._xAddLast;
					if (pt.x - _xLeft > xWidthBefore + dispdim.dx / 2)
					{
						me.Advance(1);
						me._li._cch++;
						me._li._xWidth += dispdim.dx;
					}
				}
			}

		me._rpCF.AdjustBackward();
		DWORD dwEffects = me.GetCF()->_dwEffects;
		if(dwEffects & CFE_LINK)
			*phit = HT_Link;
		else if(dwEffects & CFE_ITALIC)
			*phit = HT_Italic;

#ifdef UNICODE_SURROGATES
		// Until we support UTF-16 surrogate characters, don't allow hit in
		// middle of a surrogate pair
		if(IN_RANGE(0xDC00, me.GetChar(), 0xDFFF))
		{										
			me.Advance(1);						
			me._li._cch++;							
		}											
#endif
	}

	if (pdispdim)
		*pdispdim = dispdim;
	if (pcpActual)
		*pcpActual = cpActual;

	return me._li._cch;
}

/*
 *	CLine::XposFromCch(&me, cch, taMode, pdispdim, pdy)
 *
 *	@mfunc
 *		Measures cch characters starting from this text ptr, returning
 *		the width measured and setting yOffset = y offset relative to
 *		top of line and dx = halfwidth of character at me.GetCp() + cch.
 *		Used for caret placement and object location. pdx returns offset
 *		into the last char measured (at me.GetCp + cch) if taMode includes
 *		TA_CENTER (dx = half the last char width) or TA_RIGHT (dx = whole
 *		char width). pdy returns the vertical offset relative to the top
 *		of the line if taMode includes TA_BASELINE or TA_BOTTOM.
 *
 *	@rdesc 
 *		width of measured text
 *
 *	@devnote
 *		me may be moved.  
 */
LONG CLine::XposFromCch(
	CMeasurer&	me,			//@parm Measurer pointing at text to measure
	LONG		cch,		//@parm Max cch to measure
	UINT		taMode,		//@parm Text-align mode
	CDispDim *	pdispdim,	//@parm display dimensions
	LONG *		pdy) const	//@parm dy offset due to taMode
{
	CLock	lock;
	LONG	xWidth;
	BOOL	fPols = FALSE;
	CDispDim dispdim;
	LONG	dy = 0;

#ifdef LINESERVICES
	CMeasurer *pmeSave;
	COls *pols = me.GetPols(&pmeSave);	// Try for LineServices object
	if(pols)
	{									// Got it: use LineServices
		if(cch)							
			taMode &= ~TA_STARTOFLINE;	// Not start of line
		if(cch != _cch)
			taMode &= ~TA_ENDOFLINE;	// Not end of line

		xWidth = pols->MeasureText(cch, taMode, &dispdim);
		pols->SetMeasurer(pmeSave);		// Restore previous pme
		fPols = TRUE;
	}
	else
#endif
		xWidth = me.MeasureText(cch) + _xLeft;

	if(taMode != TA_TOP)
	{
		// Check for vertical calculation request
		if(taMode & TA_BASELINE)			// Matches TA_BOTTOM and
		{									//  TA_BASELINE
			if(!_fCollapsed)
			{
				dy = _yHeight;
				AssertSz(_yHeight != -1, "control has no height; used to use default CHARFORMAT");
				if((taMode & TA_BASELINE) == TA_BASELINE)
					dy -= _yDescent;		// Need "== TA_BASELINE" to
			}								//  distinguish from TA_BOTTOM
		}
		// Check for horizontal calculation request
		if(taMode & TA_CENTER && !fPols)	// If align to center or right of
		{
			if (cch == 0)
				dispdim.dx = me.MeasureText(1) + _xLeft - xWidth;
			else
				dispdim.dx = me._xAddLast;		//  char, get char width
		}
	}

	if (!fPols)
	{
		if((taMode & TA_CENTER) == TA_CENTER)
			xWidth += dispdim.dx / 2;
		else if (taMode & TA_RIGHT)
			xWidth += dispdim.dx;
	}

	if (pdispdim)
		*pdispdim = dispdim;
	if (pdy)
		*pdy = dy;

	return xWidth;
}
	
/*
 *	CLine::GetHeight()
 *
 *	@mfunc
 *		Get line height unless in outline mode and collasped, in
 *		which case get 0.
 *
 *	@rdesc
 *		Line height (_yHeight), unless in outline mode and collapsed,
 *		in which case 0.
 */
LONG CLine::GetHeight() const
{
	return _fCollapsed ? 0 : _yHeight;
}

BOOL CLine::IsEqual(CLine& li)
{
	// CF - I dont know which one is faster
	// MS3 - CompareMemory is certainly smaller
	// return !CompareMemory (this, pli, sizeof(CLine) - 4);
	return _xLeft == li._xLeft &&
		   _xWidth == li._xWidth && 
		   _yHeight == li._yHeight &&
		   _yDescent == li._yDescent &&
			_cch == li._cch &&
		   _cchWhite == li._cchWhite;	
}


// =====================  CLinePtr: Line Run Pointer  ==========================


CLinePtr::CLinePtr(CDisplay *pdp)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::CLinePtr");

	_pdp = pdp;
	_pLine = NULL;
	_pdp->InitLinePtr(* this);
}

void CLinePtr::Init (CLine & line)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::Init");

	_pRuns = 0;
	_pLine = &line;
	_iRun = 0;
	_ich = 0;
}

void CLinePtr::Init (CLineArray & line_arr)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::Init");

	_pRuns = (CRunArray *) & line_arr;
	_iRun = 0;
	_ich = 0;
}

void CLinePtr::RpSet(LONG iRun, LONG ich)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::RpSet");

	// See if this is a multi-line ptr
    if(_pRuns)
        CRunPtr<CLine>::SetRun(iRun, ich);
    else
    {
        // single line, just reinit and set _ich
        AssertSz(iRun == 0, "CLinePtr::RpSet() - single line and iRun != 0");
	    _pdp->InitLinePtr(* this);		//  to line 0
	    _ich = ich;
    }
}

// Move runptr by a certain number of cch/runs

BOOL CLinePtr::RpAdvanceCp(LONG cch)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::RpAdvanceCp");

	// See if this is a multi-line ptr

	if(_pRuns)
		return (cch == CRunPtr<CLine>::AdvanceCp(cch));

	return RpAdvanceCpSL(cch);
}
	
BOOL CLinePtr::operator --(int)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::operator --");

	return _pRuns ? PrevRun() : OperatorPostDeltaSL(-1);
}

BOOL CLinePtr::operator ++(int)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::operator ++");

	return _pRuns ? NextRun() : OperatorPostDeltaSL(+1);
}

/*
 *	CLinePtr::RpAdvanceCpSL(cch)
 *
 *	@mfunc
 *		move this line pointer forward or backward on the line
 *
 *	@rdesc
 *		TRUE iff could advance cch chars within current line
 */
BOOL CLinePtr::RpAdvanceCpSL(
	LONG cch)	 //@parm signed count of chars to advance by
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::RpAdvanceCpSL");

	Assert(!_pRuns);
	
	if(!_pLine)
		return FALSE;

	_ich += cch;

	if(_ich < 0)
	{
		_ich = 0;
		return FALSE;
	}

	if(_ich > _pLine->_cch)
	{
		_ich = _pLine->_cch;
		return FALSE;
	}

	return TRUE;
}

/*
 *	CLinePtr::OperatorPostDeltaSL(Delta)
 *
 *	Purpose:
 *		Implement line-ptr ++ and -- operators for single-line case
 *
 *	Arguments:
 *		Delta	1 for ++ and -1 for --
 *
 *	Return:
 *		TRUE iff this line ptr is valid
 */
BOOL CLinePtr::OperatorPostDeltaSL(LONG Delta)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::OperatorPostDeltaSL");

	AssertSz(_iRun <= 1 && !_pRuns,
		"LP::++: inconsistent line ptr");

	if(_iRun == -Delta)						// Operation validates an
	{										//  invalid line ptr by moving
		_pdp->InitLinePtr(* this);			//  to line 0
		return TRUE;
	}
	
	_iRun = Delta;							// Operation invalidates this line
	_ich = 0;								//  ptr (if it wasn't already)

	return FALSE;
}

CLine *	CLinePtr::operator ->() const		
{
	return _pRuns ? (CLine *)_pRuns->Elem(_iRun) : _pLine;
}

CLine * CLinePtr::GetLine() const
{	
    return _pRuns ? (CLine *)_pRuns->Elem(_iRun) : _pLine;
}

CLine &	CLinePtr::operator *() const      
{	
    return *(_pRuns ? (CLine *)_pRuns->Elem(_iRun) : _pLine);
}

CLine & CLinePtr::operator [](LONG dRun)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::operator []");

	if(_pRuns)
		return *(CLine *)CRunPtr<CLine>::GetRun(dRun);

	AssertSz(dRun + _iRun == 0 ,
		"LP::[]: inconsistent line ptr");

	return  *(CLine *)CRunPtr<CLine>::GetRun(_iRun);
}

BOOL CLinePtr::IsValid() 
{ 
	return !_pRuns ? _pLine != NULL : CRunPtrBase::IsValid(); 
}

/*
 *	CLinePtr::RpSetCp(cp, fAtEnd)
 *
 *	Purpose	
 *		Set this line ptr to cp allowing for ambigous cp and taking advantage
 *		of _cpFirstVisible and _iliFirstVisible
 *
 *	Arguments:
 *		cp		position to set this line ptr to
 *		fAtEnd	if ambiguous cp:
 *				if fAtEnd = TRUE, set this line ptr to end of prev line;
 *				else set to start of line (same cp, hence ambiguous)
 *	Return:
 *		TRUE iff able to set to cp
 */
BOOL CLinePtr::RpSetCp(
	LONG cp,
	BOOL fAtEnd)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::RpSetCp");

	_ich = 0;
	if(!_pRuns)
	{
		// This is a single line so just go straight to the single
		// line advance logic. It is important to note that the
		// first visible character is irrelevent to the cp advance
		// for single line displays.
		return RpAdvanceCpSL(cp);
	}

	BOOL fRet;
	LONG cpFirstVisible = _pdp->GetFirstVisibleCp();

	if(cp > cpFirstVisible / 2)
	{											// cpFirstVisible closer than 0
		_iRun = _pdp->GetFirstVisibleLine();
		fRet = RpAdvanceCp(cp - cpFirstVisible);
	}
	else
		fRet = (cp == CRunPtr<CLine>::BindToCp(cp));	// Start from 0

	if(fAtEnd)									// Ambiguous-cp caret position
		AdjustBackward();						//  belongs at prev EOL

	return fRet;
}

/*
 *	CLinePtr::FindParagraph(fForward)
 *
 *	@mfunc	
 *		Move this line ptr to paragraph (fForward) ? end : start,
 *		and return change in cp
 *
 *	@rdesc
 *		change in cp
 */
LONG CLinePtr::FindParagraph(
	BOOL fForward)		//@parm TRUE move to para end; else to para start
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::FindParagraph");

	LONG	cch;
	CLine *	pLine = GetLine();

	if(!fForward)							// Go to para start
	{
		cch = 0;							// Default already at para start
		if (RpGetIch() != pLine->_cch ||
			!(pLine->_bFlags & fliHasEOP))	// It isn't at para start
		{
			cch = -RpGetIch();				// Go to start of current line
			while(!(pLine->_bFlags & fliFirstInPara) && (*this) > 0)
			{
				(*this)--;					// Go to start of prev line
				pLine = GetLine();
				cch -= pLine->_cch;			// Subtract # chars in line
			}
			_ich = 0;						// Leave *this at para start
		}
	}
	else									// Go to para end
	{
		cch = GetCchLeft();					// Go to end of current line

		while(((*this) < _pdp->LineCount() - 1 ||
				_pdp->WaitForRecalcIli((LONG)*this + 1))
			  && !((*this)->_bFlags & fliHasEOP))
		{
			(*this)++;						// Go to start of next line
			cch += (*this)->_cch;			// Add # chars in line
		}
		_ich = (*this)->_cch;				// Leave *this at para end
	}
	return cch;
}

/*
 *	CLinePtr::GetAdjustedLineLength
 *
 *	@mfunc	returns the length of the line _without_ EOP markers
 *
 *	@rdesc	LONG; the length of the line
 */
LONG CLinePtr::GetAdjustedLineLength()
{
	CLine * pline = GetLine();

	return pline->_cch - pline->_cchEOP;
}

/*
 *	CLinePtr::GetCchLeft()
 *
 *	@mfunc
 *		Calculate length of text left in run starting at the current cp.
 *		Complements GetIch(), which	is length of text up to this cp. 
 *
 *	@rdesc
 *		length of text so calculated
 */
LONG CLinePtr::GetCchLeft() const
{
	return _pRuns ? CRunPtrBase::GetCchLeft() : _pLine->_cch - _ich;
}

/*
 *	CLinePtr::GetNumber()
 *
 *	@mfunc
 *		Get paragraph number 
 *
 *	@rdesc
 *		paragraph number
 */
WORD CLinePtr::GetNumber()
{
	if(!IsValid())
		return 0;

	_pLine = GetLine();
	if(!_iRun && _pLine->_bNumber > 1)
		_pLine->_bNumber = 1;

	return _pLine->_bNumber;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\notmgr.cpp ===
/*
 *	NOTMGR.C
 *
 *	Purpose:
 *		Notification Manager implemenation
 *
 *	Author:
 *		AlexGo	6/5/95
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_notmgr.h"

ASSERTDATA

/*
 *	CNotifyMgr::CNotifyMgr ()
 */
CNotifyMgr::CNotifyMgr()
{
	TRACEBEGIN(TRCSUBSYSNOTM, TRCSCOPEINTERN, "CNotifyMgr::CNotifyMgr");

	_pitnlist = NULL;
}

/*
 *	CNotifyMgr::~CNotifyMgr ()
 *
 */
CNotifyMgr::~CNotifyMgr()
{
	TRACEBEGIN(TRCSUBSYSNOTM, TRCSCOPEINTERN, "CNotifyMgr::~CNotifyMgr");

	ITxNotify *plist;

	for( plist = _pitnlist; plist != NULL; plist = plist->_pnext )
	{
		plist->Zombie();
	}

	TRACEERRSZSC("CNotifyMgr::~CNotifyMgr(): zombie(s) exist", _pitnlist != 0);
}

/*
 *	CNotifyMgr::Add (pITN)
 *
 *	@mfunc
 *		Adds a notification sink to the list
 *
 *	Algorithm:
 *		puts the entry at the *front* of the notification list, so
 *		that high frequency entries (like ranges and text pointers
 *		existing on the stack) can be added and removed efficiently
 */
void CNotifyMgr::Add(
	ITxNotify *pITN )
{
	TRACEBEGIN(TRCSUBSYSNOTM, TRCSCOPEINTERN, "CNotifyMgr::Add");

		pITN->_pnext = _pitnlist;
		_pitnlist = pITN;
}

/*
 *	CNotifyMgr::Remove (pITN)
 *
 *	@mfunc
 *		removes a notification sink from the list
 */
void CNotifyMgr::Remove(
	ITxNotify *pITN )
{
	TRACEBEGIN(TRCSUBSYSNOTM, TRCSCOPEINTERN, "CNotifyMgr::Remove");

	ITxNotify *plist = _pitnlist;
	ITxNotify **ppprev = &_pitnlist;

	while(plist)
	{
		if( plist == pITN )
		{
			*ppprev = plist->_pnext;
			break;
		}
		ppprev = &(plist->_pnext);
		plist = plist->_pnext;
	}
}

/*
 *	CNotifyMgr::NotifyPreReplaceRange (pITNignore, cp, cchDel, cchNew)
 *
 *	@mfunc
 *		send an OnReplaceRange notification to all sinks (except pITNignore)
 */
void CNotifyMgr::NotifyPreReplaceRange(
	ITxNotify *	pITNignore,	//@parm Notification sink to ignore
	LONG		cp, 		//@parm cp where ReplaceRange starts ("cpMin")
	LONG		cchDel,		//@parm Count of chars after cp that are deleted
	LONG		cchNew,		//@parm Count of chars inserted after cp
	LONG		cpFormatMin,//@parm cpMin  for a formatting change
	LONG		cpFormatMax)//@parm cpMost for a formatting change
{
	TRACEBEGIN(TRCSUBSYSNOTM, TRCSCOPEINTERN, "CNotifyMgr::NotifyPreReplaceRange");

	ITxNotify *plist;

	for( plist = _pitnlist; plist != NULL; plist = plist->_pnext )
	{
		if( plist != pITNignore )
		{
			plist->OnPreReplaceRange( cp, cchDel, cchNew, cpFormatMin, 
				cpFormatMax );
		}
	}
}

/*
 *	CNotifyMgr::NotifyPostReplaceRange (pITNignore, cp, cchDel, cchNew)
 *
 *	@mfunc
 *		send an OnReplaceRange notification to all sinks (except pITNignore)
 *
 *	@comm
 *		pITNignore typically is the TxtPtr/etc that is actually making the
 *		ReplaceRange modification
 */
void CNotifyMgr::NotifyPostReplaceRange(
	ITxNotify *	pITNignore,	//@parm Notification sink to ignore
	LONG		cp, 		//@parm cp where ReplaceRange starts ("cpMin")
	LONG		cchDel,		//@parm Count of chars after cp that are deleted
	LONG		cchNew,		//@parm Count of chars inserted after cp
	LONG		cpFormatMin,//@parm cpMin  for a formatting change
	LONG		cpFormatMax)//@parm cpMost for a formatting change
{
	TRACEBEGIN(TRCSUBSYSNOTM, TRCSCOPEINTERN, "CNotifyMgr::NotifyPostReplaceRange");

	ITxNotify *plist;

	for( plist = _pitnlist; plist != NULL; plist = plist->_pnext )
	{
		if( plist != pITNignore )
		{
			plist->OnPostReplaceRange( cp, cchDel, cchNew, cpFormatMin,
				cpFormatMax );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\m_undo.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module	M_UNDO.C	|
 *
 *	Purpose:
 *		Implementation of the global mutli-undo stack
 *
 * 	Author:
 *		alexgo  3/25/95
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_m_undo.h"
#include "_edit.h"
#include "_disp.h"
#include "_urlsup.h"
#include "_antievt.h"

ASSERTDATA

//
// PUBLIC METHODS
//

/*
 *	CUndoStack::CUndoStack (ped, rdwLim, flags)
 *
 *	@mfunc	Constructor
 */
CUndoStack::CUndoStack(
	CTxtEdit *ped,		//@parm	CTxtEdit parent
	DWORD & rdwLim,		//@parm Initial limit
	USFlags	flags)		//@parm Flags for this undo stack
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::CUndoStack");

	_ped = ped;

	_prgActions = NULL;
	_index = 0;
	_dwLim = 0;

	// We should be creating an undo stack if there's nothing to put in it!
	Assert(rdwLim);
	SetUndoLimit(rdwLim);

	if(flags & US_REDO)
		_fRedo = TRUE;
}

/*
 *	CUndoStack::~CUndoStack()
 *
 *	@mfunc Destructor
 *
 *	@comm
 *		deletes any remaining anti-events.  The anti event dispenser
 *		should *not* clean up because of this!!
 */
CUndoStack::~CUndoStack()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::~CUndoStack");

	// Clear out any remaining antievents
	ClearAll();

	delete _prgActions;
}

/*
 *	CUndoStack::Destroy ()
 *
 *	@mfunc
 *		deletes this instance
 */
void CUndoStack::Destroy()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::Destroy");

	delete this;
}

/*
 * 	CUndoStack::SetUndoLimit (dwLim)
 *
 *	@mfunc
 *		allows the undo stack to be enlarged or reduced
 *
 *	@rdesc
 *		the size to which the stack is actually set.
 *
 *	@comm
 *		the algorithm we use is the following:	 <nl>
 *			try to allocate space for the requested size.
 *			if there's not enough memory then we try to recover
 *			with the largest block possible.
 *
 *			if the requested size is bigger than the default,
 *			and the current size is less than the default, go 
 *			ahead and try to allocate the default.
 *
 *			if that fails then just stick with the existing stack
 */
DWORD CUndoStack::SetUndoLimit(
	DWORD dwLim)			//@parm	New undo limit.  May not be zero
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::SetUndoLimit");

	UndoAction *prgnew = NULL;

	// if the undo limit is zero, we should get rid of the entire
	// undo stack instead.

	Assert(dwLim);

	if(_fSingleLevelMode)
	{
		// if fSingleLevelMode is on, we can't be the redo stack
		Assert(_fRedo == FALSE);

		if(dwLim != 1)
		{
			TRACEERRORSZ("Trying to grow/shrink the undo buffer while in"
				"single level mode");
			
			dwLim = 1;
		}
	}

	prgnew = new UndoAction[dwLim];
	if(prgnew)
		TransferToNewBuffer(prgnew, dwLim);

	else if(dwLim > DEFAULT_UNDO_SIZE && _dwLim < DEFAULT_UNDO_SIZE)
	{
		// We are trying to grow past the default but failed.  So
		// try to allocate the default
		prgnew = new UndoAction[DEFAULT_UNDO_SIZE];

		if(prgnew)
			TransferToNewBuffer(prgnew, DEFAULT_UNDO_SIZE);
	}
	
	// In either success or failure, _dwLim will be set correctly.	
	return _dwLim;
}

/*
 *	CUndoStack::GetUndoLimit() 
 *
 *	@mfunc
 *		gets the current limit size
 *
 *	@rdesc	
 *		the current undo limit
 */
DWORD CUndoStack::GetUndoLimit()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::GetUndoLimit");

	return _dwLim;
}

/*
 *	CUndoStack::PushAntiEvent (idName, pae)
 *
 *	@mfunc
 *		adds an undoable event to the event stack
 *
 *	@rdesc	HRESULT
 *
 *	@comm
 *	Algorithm:
 *
 *		if merging is set, then we to merge the given anti-event
 *		list *into* the current list (assuming it's a typing
 *		undo action).
 */
HRESULT CUndoStack::PushAntiEvent(
	UNDONAMEID idName,		//@parm	Name for this AE collection
	IAntiEvent *pae)		//@parm AE collection
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::PushAntiEvent");

	// _index should be at next available position
	if(!_fMerge)
	{
		// clear out any existing event	
		if(_prgActions[_index].pae != NULL)
		{
			DestroyAEList(_prgActions[_index].pae);
			_prgActions[_index].pae = NULL;
		}

		if(_fRedo)
			_ped->GetCallMgr()->SetNewRedo();
		else
			_ped->GetCallMgr()->SetNewUndo();
	}

	if(_fMerge)
	{
		IAntiEvent *paetemp = pae, *paeNext;
		DWORD i = GetPrev();

		// If these asserts fail, then somebody did not call 
		// StopGroupTyping
		Assert(_prgActions[i].id == idName);
		Assert(idName == UID_TYPING);

		// Put existing anti-event chain onto *end* of current one
		while((paeNext = paetemp->GetNext()) != NULL)
			paetemp = paeNext;

		paetemp->SetNext(_prgActions[i].pae);
		_index = i;
	}
	else if(_fGroupTyping)
	{
		// In this case, we are *starting* a group typing session.
		// Any subsequent push'es of anti events should be merged
		_fMerge = TRUE;
	}

	_prgActions[_index].pae = pae;
	_prgActions[_index].id = idName;
	
	Next();
	return NOERROR;
}

/*
 *	CUndoStack::PopAndExecuteAntiEvent(void *pAE)
 *
 *	@mfunc
 *		Undo!  Takes the most recent anti-event and executes it
 *
 *	@rdesc	HRESULT from invoking the anti-events (AEs)
 */
HRESULT CUndoStack::PopAndExecuteAntiEvent(
	void *pAE)		//@parm if non-NULL, undo up to this point.
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::PopAndExecuteAntiEvent");

	HRESULT hresult = NOERROR;
	IAntiEvent *pae, *paeDoTo;
	DWORD i, j;
	CCallMgr *pcallmgr = _ped->GetCallMgr();

	// we need to check to see if there are any non-empty undo builders
	// higher on the stack.  In this case, we have been re-entered
	if(pcallmgr->IsReEntered())
	{
		IUndoBuilder *publdr;

		// there are two cases to handle: we are invoking redo or we
		// are invoking undo.  If we are invoking undo and there are 
		// existing undo actions in the undo builder, then simply commit
		// those actions and undo them.  We can assert in this case
		// that the redo stack is empty.
		//
		// In the second case if we are invoking redo while there are
		// undo actions in progress, simply cancel the call.  When the
		// undo actions are added, they will clear the redo stack.
		// 
		// We never need to check for a redo builder as that _only_
		// gets created in this routine and it's use is carefully guarded.


		publdr = (CGenUndoBuilder *)pcallmgr->GetComponent(COMP_UNDOBUILDER);

		
		// Commit the anti-events to this undo stack, so that we will simply
		// undo them first.
		if(publdr)
		{			
			TRACEWARNSZ("Undo/Redo Invoked with uncommitted anti-events");
			TRACEWARNSZ("		Recovering....");

			if(_fRedo)
			{
				// if we are the redo stack, simply fail the redo call
				return NOERROR;
			}
			else
			{
				// just commit the anti-events and the routine below
				// will take of the rest.
				publdr->Done();
			}
		}
	}

	// If we are in single level mode, check to see if our current buffer is
	// empty.  If so, simply delegate to the redo stack if it exists.  We only
	// support this mode for dwDoToCookies being NULL.  Note that we can't call
	// CanUndo here as it will consider the redo stack as well

	if(_fSingleLevelMode && !_prgActions[GetPrev()].pae)
	{
		Assert(_fRedo == FALSE);
		Assert(pAE == 0);

		if(_ped->GetRedoMgr())
			return _ped->GetRedoMgr()->PopAndExecuteAntiEvent(0);

		// Nothing to redo && nothing to do here; don't bother continuing	
		return NOERROR;
	}

	// this next bit of logic is tricky.  What is says is create
	// an undo builder for the stack *opposite* of the current one
	// (namely, undo actions go on the redo stack and vice versa).
	// Also, if we are the redo stack, then we don't want to flush
	// the redo stack as anti-events are added to the undo stack.

	CGenUndoBuilder undobldr(_ped, 
					(!_fRedo ? UB_REDO : UB_DONTFLUSHREDO) | UB_AUTOCOMMIT);
					
	// obviously, we can't be grouping typing if we're undoing!
	StopGroupTyping();

	// _index by default points to the next available slot
	// so we need to back up to the previous one.
	Prev();

	// Do some verification on the cookie--make sure it's one of ours
	paeDoTo = (IAntiEvent *)pAE;
	if(paeDoTo)
	{
		for(i = 0, j = _index; i < _dwLim; i++)
		{
			if(IsCookieInList(_prgActions[j].pae, (IAntiEvent *)paeDoTo))
			{
				paeDoTo = _prgActions[j].pae;
				break;
			}
			// Go backwards through ring buffer; typically
			// paeDoTo will be "close" to the top
			
			if(!j)
				j = _dwLim - 1;
			else
				j--;
		}
		
		if(i == _dwLim)
		{
			TRACEERRORSZ("Invalid Cookie passed into Undo; cookie ignored");
			hresult = E_INVALIDARG;
			paeDoTo = NULL;
		}
	}
	else
	{
		paeDoTo = _prgActions[_index].pae;
	}

	undobldr.SetNameID(_prgActions[_index].id);

	while(paeDoTo)
	{
		CUndoStackGuard guard(_ped);

		pae = _prgActions[_index].pae;
		Assert(pae);

		// Fixup our state _before_ calling Undo, so 
		// that we can handle being re-entered.
		_prgActions[_index].pae = NULL;

		hresult = guard.SafeUndo(pae, &undobldr);

		DestroyAEList(pae);

		if(pae == paeDoTo || guard.WasReEntered())
			paeDoTo = NULL;
		Prev();
	}

	// Put _index at the next unused slot
	Next();
	return hresult;
}

/* 
 *	CUndoStack::GetNameIDFromTopAE(dwAECookie)
 *
 *	@mfunc
 *		retrieves the name of the most recent undo-able operation
 *
 *	@rdesc	the name ID of the most recent collection of anti-events
 */
UNDONAMEID CUndoStack::GetNameIDFromAE(
	void *pAE)		//@parm Anti-event whose name is desired;
					//		0 for the top
{
	IAntiEvent *pae = (IAntiEvent *)pAE;
	DWORD	i, j = GetPrev();	// _index by default points to next 
								// available slot

	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::GetNameIDFromTopAE");

	if(pae == NULL)
		pae = _prgActions[j].pae;

	if(_fSingleLevelMode && !pae)
	{
		// if fSingleLevelMode is on, we can't be the redo stack
		Assert(_fRedo == FALSE);

		// if pae is NULL, our answer may be on the redo stack.  Note that
		// we if somebody tries to pass in a cookie while in SingleLevelMode,
		// they won't be able to get actions off the redo stack.
		if(_ped->GetRedoMgr())
			return _ped->GetRedoMgr()->GetNameIDFromAE(0);
	}		

	for(i = 0; i < _dwLim; i++)
	{
		if(_prgActions[j].pae == pae)
			return _prgActions[j].id;

		if(j == 0)
			j = _dwLim - 1;
		else
			j--;
	}
	return UID_UNKNOWN;
}

/*
 *	CUndoStack::GetMergeAntiEvent ()
 *
 *	@mfunc	If we are in merge typing mode, then return the topmost
 *			anti-event
 *
 *	@rdesc	NULL or the current AntiEvent if in merge mode
 */
IAntiEvent *CUndoStack::GetMergeAntiEvent()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::GetMergeAntiEvent");

	if(_fMerge)
	{
		DWORD i = GetPrev();			// _index by default points to
										//  next available slot
		Assert(_prgActions[i].pae);		// Can't be in merge anti event mode
										// if no anti-event to merge with!!
		return _prgActions[i].pae;
	}
	return NULL;
}

/*
 *	CUndoStack::GetTopAECookie()
 *
 *	@mfunc	Returns a cookie to the topmost anti-event.
 *
 *	@rdesc	A cookie value.  Note that this cookie is just the anti-event
 *			pointer, but clients shouldn't really know that.
 */		
void* CUndoStack::GetTopAECookie()
{
 	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::GetTopAECookie");

	DWORD i = GetPrev();

	return _prgActions[i].pae;
}

/*
 *	CUndoStack::ClearAll ()
 *
 *	@mfunc
 *		removes any anti-events that are currently in the undo stack
 */
void CUndoStack::ClearAll()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::ClearAll");

 	for(DWORD i = 0; i < _dwLim; i++)
	{
		if(_prgActions[i].pae)
		{
			DestroyAEList(_prgActions[i].pae);
			_prgActions[i].pae = NULL;
		}
	}

	// Just in case we've been grouping typing; clear the state.
	StopGroupTyping();
}

/*
 *	CUndoStack::CanUndo()
 *
 *	@mfunc
 *		indicates whether or not can undo operation can be performed
 *		(in other words, are there any anti-events in our buffer)
 *
 *	@rdesc
 *		TRUE	-- anti-events exist 	<nl>
 *		FALSE 	-- no anti-events		<nl>
 */
BOOL CUndoStack::CanUndo()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::CanUndo");

	DWORD i = GetPrev();		// _index by default points to 
								//  next available slot
	if(_prgActions[i].pae)
		return TRUE;

	if(_fSingleLevelMode)
	{
		// If fSingleLevelMode is on, we can't be the redo stack
		Assert(_fRedo == FALSE);

		// If we are in single level mode, we are the undo stack.
		// Check to see if the redo stack can do something here.
		if(_ped->GetRedoMgr())
			return _ped->GetRedoMgr()->CanUndo();
	}
	return FALSE;
}

/*
 *	CUndoStack::StartGroupTyping ()
 *
 *	@mfunc
 *		TOGGLES the group typing flag on.  If fGroupTyping is set, then
 *		all *typing* events will be merged together
 *
 *	@comm
 *	Algorithm:
 *
 *		There are three interesting states:	<nl>
 *			-no group merge; every action just gets pushed onto the stack <nl>
 *			-group merge started; the first action is pushed onto the stack<nl>
 *			-group merge in progress; every action (as long as it's "typing")
 *			is merged into the prior state	<nl>
 *
 *		See the state diagram in the implemenation doc for more details
 */
void CUndoStack::StartGroupTyping()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::StartGroupTyping");

	if(_fGroupTyping)
		_fMerge = TRUE;
	else
	{
		Assert(_fMerge == FALSE);
		_fGroupTyping = TRUE;
	}
}

/*
 *	CUndoStack::StopGroupTyping	()
 *
 *	@mfunc
 *		TOGGLES the group typing flag off.  If fGroupTyping is not set,
 *		then no merging of typing anti-events will be done
 */
void CUndoStack::StopGroupTyping()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::StopGroupTyping");

	_fGroupTyping = FALSE;
	_fMerge = FALSE;
}

/*
 *	CUndoStack::EnableSingleLevelMode()
 *
 *	@mfunc	Turns on single level undo mode; in this mode, we behave just like
 *			RichEdit 1.0 w.r.t. to Undo.
 *
 *	@rdesc
 *			HRESULT
 *
 *	@comm	This special mode means that undo is 1 level deep and everything 
 *			is accessed via UNDO messages.  Thus, instead of redo to undo an 
 *			undo action, you simply use another undo message. 
 *
 *	@devnote	This call is _ONLY_ allowed for the UndoStack; the redo 
 *			stack simply tags along.  Note that caller is responsible for
 *			ensuring that we are in an empty state.
 */
HRESULT CUndoStack::EnableSingleLevelMode()
{
	Assert(_ped->GetRedoMgr() == NULL || 
		_ped->GetRedoMgr()->CanUndo() == FALSE);
	Assert(CanUndo() == FALSE);
	Assert(_fRedo == FALSE);

	_fSingleLevelMode = TRUE;

	// For single level undo mode, it is very important to get
	// just 1 entry in the undo stack.  If we can't do that,
	// then we better just fail.
	if(SetUndoLimit(1) != 1)
	{
		_fSingleLevelMode = FALSE;
		return E_OUTOFMEMORY;
	}

	if(_ped->GetRedoMgr())
	{
		// doesn't matter if the redo manager fails to reset
		_ped->GetRedoMgr()->SetUndoLimit(1);
	}

	return NOERROR;
}

/*
 *	CUndoStack::DisableSingleLevelMode()
 *
 *	@mfunc	This turns off the 1.0 undo compatibility mode and restores us to 
 *			the RichEdit 2.0 default undo state
 */
void CUndoStack::DisableSingleLevelMode()
{
	Assert(_ped->GetRedoMgr() == NULL || 
		_ped->GetRedoMgr()->CanUndo() == FALSE);
	Assert(CanUndo() == FALSE);
	Assert(_fRedo == FALSE);

	_fSingleLevelMode = FALSE;

	// we don't care about failures here; multi-level undo mode
	// can handle any sized undo stack
	SetUndoLimit(DEFAULT_UNDO_SIZE);

	if(_ped->GetRedoMgr())
	{
		// doesn't matter if the redo manager can't grow back in
		// size; it just means that we won't have full redo capability.
		_ped->GetRedoMgr()->SetUndoLimit(DEFAULT_UNDO_SIZE);
	}
}

//
// PRIVATE METHODS
//

/*
 *	CUndoStack::Next()
 *
 *	@mfunc
 *		sets _index to the next available slot
 */
void CUndoStack::Next()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::Next");

	_index++;
	
	if(_index == _dwLim)
		_index = 0;
}

/*
 *	CUndoStack::Prev()
 *
 *	@mfunc
 *		sets _index to the previous slot
 */
void CUndoStack::Prev()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::Prev");

	_index = GetPrev();
}

/*
 *	CUndoStack::GetPrev()
 *
 *	@mfunc
 *		figures out what the index to the previous slot
 *		*should* be (but does not set it)
 *
 *	@rdesc	the index of what the previous slot would be
 */
DWORD CUndoStack::GetPrev()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::GetPrev");

	DWORD i = _index;

	if(i == 0)
		i = _dwLim - 1;
	else
		i--;

	return i;
}

/*
 *	CUndoStack::IsCookieInList (pae, paeCookie)
 *
 *	@mfunc	
 *		determines whether or not the given DoTo cookie is in
 *		the list of anti-events.
 *
 *	@rdesc	TRUE/FALSE
 */
BOOL CUndoStack::IsCookieInList(
	IAntiEvent *pae,		//@parm	List to check
	IAntiEvent *paeCookie)	//@parm Cookie to check
{
	while(pae)
	{
		if(pae == paeCookie)
			return TRUE;

		pae = pae->GetNext();
	}
	return FALSE;
}

/*
 *	CUndoStack::TransferToNewBuffer
 *
 *	@mfunc	
 *		transfers existing anti-events to the given buffer and
 *		swaps this undo stack to use the new buffer
 *
 *	@comm	The algorithm is very straightforward; go backwards in
 *			the ring buffer copying antievents over until either there
 *			are no more anti-events or the new buffer is full.  Discard
 *			any remaining anti-events.
 */
void CUndoStack::TransferToNewBuffer(UndoAction *prgnew, DWORD dwLimNew)
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::TransferToNewBuffer");

	DWORD 	iOld = 0, 
			iNew = 0,
			iCopyStart = 0;

	// First clear new buffer.
	FillMemory(prgnew, 0, dwLimNew * sizeof(UndoAction));

	// If there is nothing to copy, don't bother
	if(!_prgActions || !_prgActions[GetPrev()].pae)
		goto SetState;

	// This is a bit counter-intuitive, but since the stack is really
	// a ring buffer, go *forwards* until you hit a non-NULL slot.
	// This will be the _end_ of the existing antievents.
	//
	// However, we need to make sure that if dwLimNew is 
	// _smaller_ than _dwLim we only copy the final dwLimNew
	// anti-events.  We'll set iCopyStart to indicate when
	// we can start copying stuff.

	if(dwLimNew < _dwLim)
		iCopyStart = _dwLim - dwLimNew;

	for(; iOld < _dwLim; iOld++, Next())
	{
		if(!_prgActions[_index].pae)
			continue;

		if(iOld >= iCopyStart)
		{
			Assert(iNew < dwLimNew);
			// copy anti-events over 
			prgnew[iNew] = _prgActions[_index];
			iNew++;
		}
		else
		{
			// otherwise, get rid of them
			DestroyAEList(_prgActions[_index].pae);
			_prgActions[_index].pae = NULL;
		}
	}

SetState:
	
	//we start at index iNew
	_index = (iNew == dwLimNew) ? 0 : iNew;
	Assert(iNew <= dwLimNew);

	_dwLim = dwLimNew;
	
	if(_prgActions)
		delete _prgActions;

	_prgActions = prgnew;
}	

//
//	CGenUndoBuilder implementation
//

//
//	Public methods
//

/*
 *	CGenUndoBuilder::CGenUndoBuilder (ped, flags, ppubldr
 *
 *	@mfunc	Constructor
 *
 *	@comm
 *		This is a *PUBLIC* constructor
 */
CGenUndoBuilder::CGenUndoBuilder(
	CTxtEdit *		ped,		//@parm	Edit context
	DWORD			flags,		//@parm flags (usually UB_AUTOCOMMIT)
	IUndoBuilder **	ppubldr)	//@parm Ptr to undobldr interface
{
	// set everthing to NULL because instances can go on the stack
	_publdrPrev = NULL;
	// _pundo  is set below
	_idName = UID_UNKNOWN;
	_pfirstae = NULL;
	_fAutoCommit = FALSE;
	_fStartGroupTyping = FALSE;
	_fRedo = FALSE;
	_fDontFlushRedo = FALSE;
	_fInactive = FALSE;

	CompName	name = COMP_UNDOBUILDER;

	_ped 			= ped;

	if(flags & UB_AUTOCOMMIT)
		_fAutoCommit = TRUE;

	if(flags & UB_REDO)
	{
		_fRedo = TRUE;
		name = COMP_REDOBUILDER;
		_pundo = ped->GetRedoMgr();
	}
	else
		_pundo = ped->GetUndoMgr();

	// If undo is on, set *ppubldr to be this undo builder; else NULL
	// TODO: do we need to link in inactive undo builders?
	if(ppubldr)
	{
		if(!ped->_fUseUndo)				// Undo is disabled or suspended
		{								// Still have undobldrs since stack
			*ppubldr = NULL;			//  alloc is efficient. Flag this
			_fInactive = TRUE;			//  one as inactive
			return;
		}
		*ppubldr = this;
	}

	if(flags & UB_DONTFLUSHREDO)
		_fDontFlushRedo = TRUE;

	// Now link ourselves to any undobuilders that are higher up on
	// the stack.  Note that is is legal for multiple undo builders
	// to live within the same call context.

	_publdrPrev = (CGenUndoBuilder *)_ped->GetCallMgr()->GetComponent(name);

	// If we are in the middle of an undo, then we'll have two undo stacks
	// active, the undo stack and the redo stack.  Don't like the two
	// together.
	if(_fDontFlushRedo)
		_publdrPrev = NULL;

	_ped->GetCallMgr()->RegisterComponent((IReEntrantComponent *)this,
							name);
}

/*
 *	CGenUndoBuilder::~CGenUndoBuilder()
 *
 *	@mfunc	Destructor
 *
 *	@comm
 *		This is a *PUBLIC* destructor
 *
 *	Algorithm:
 *		If this builder hasn't been committed to an undo stack
 *		via ::Done, then we must be sure to free up any resources
 *		(antievents) we may be hanging onto
 */
CGenUndoBuilder::~CGenUndoBuilder()
{
	if(!_fInactive)
		_ped->GetCallMgr()->RevokeComponent((IReEntrantComponent *)this);

	if(_fAutoCommit)
	{
		Done();
		return;
	}

	// Free resources
	if(_pfirstae)
		DestroyAEList(_pfirstae);
}

/*
 *	CGenUndoBuilder::SetNameID (idName)
 *
 *	@mfunc
 *		Allows a name to be assigned to this anti-event collection.
 *		The ID should be an index that can be used to retrieve a
 *		language specific string (like "Paste").  This string is
 *		typically composed into undo menu items (i.e. "Undo Paste").
 */

void CGenUndoBuilder::SetNameID(
	UNDONAMEID idName)			//@parm	the name ID for this undo operation
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CGenUndoBuilder::SetNameID");

	// Don't delegate to the higher undobuilder, even if it exists. The
	// original name should win in re-entrancy cases.
	_idName = idName;
}

/*
 *	CGenUndoBuilder::AddAntiEvent (pae)
 *
 *	@mfunc
 *		Adds an anti-event to the end of the list
 *
 *	@rdesc 	NOERROR
 */
HRESULT CGenUndoBuilder::AddAntiEvent(
	IAntiEvent *pae)		//@parm	anti-event to add
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CGenUndoBuilder::AddAntiEvent");

	if(_publdrPrev)
		return _publdrPrev->AddAntiEvent(pae);

	pae->SetNext(_pfirstae);
	_pfirstae = pae;

	return NOERROR;
}

/*
 *	CGenUndoBuilder::GetTopAntiEvent
 *
 *	@mfunc	Gets the top anti-event for this context.
 *
 *	@comm	The current context can be either the current
 *			operation *or* to a previous operation if we are in
 *			merge typing mode.
 *
 *	@rdesc	top anti-event
 */
IAntiEvent *CGenUndoBuilder::GetTopAntiEvent()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CGenUndoBuilder::GetTopAntiEvent");

	if(_publdrPrev)
	{
		Assert(_pfirstae == NULL);
		return _publdrPrev->GetTopAntiEvent();
	}

	if(!_pfirstae && _pundo)
		return _pundo->GetMergeAntiEvent();

	return _pfirstae;
}

/*
 *	CGenUndoBuilder::Done ()
 *
 *	@mfunc
 *		puts the combined anti-events (if any) into the undo stack
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT CGenUndoBuilder::Done()
{
	HRESULT		hr = NOERROR;
	DWORD		dwLim = DEFAULT_UNDO_SIZE;
	IUndoMgr *	predo;
	IAntiEvent *paetemp;

	if(_publdrPrev)
	{
		Assert(_pfirstae == NULL);
		return NOERROR;
	}

	if(_ped->GetDetectURL())
		_ped->GetDetectURL()->ScanAndUpdate(_pundo ? this : NULL);

	// If nothing changed, discard any selection anti-events
	// or other no-op actions.
	if(!_ped->GetCallMgr()->GetChangeEvent())
	{
		Discard();
		return NOERROR;
	}

	if(_pfirstae)
	{
		if(!_pundo)
		{
			// yikes!  There is no undo stack; better create one.

			// if we are a redo guy, we should create a redo
			// stack the size of the undo stack

			if(_fRedo)
			{
				Assert(_ped->GetUndoMgr());

				dwLim = _ped->GetUndoMgr()->GetUndoLimit();
			}

			_pundo = _ped->CreateUndoMgr(dwLim,	_fRedo ? US_REDO : US_UNDO);

			// FUTURE:  A NULL ptr returned from CreateUndoMgr means either
			// 	we are out of memory, or the undo limit is set to 0.  For the
			// 	latter case, we have collected AE's to push onto a non-existent
			// 	undo stack.  It may be more efficient to not generate
			// 	the AE's at all when the undo limit is 0.

			if(!_pundo)
				goto CleanUp;
		}

		// We may need to flush the redo stack if we are adding
		// more anti-events to the undo stack *AND* we haven't been
		// told not to flush the redo stack.  The only time we won't
		// flush the redo stack is if it's the redo stack itself
		// adding anti-events to undo.

		if(!_fRedo)
		{
			// If our destination is the undo stack, then check
			// to see if we should flush
			if(!_fDontFlushRedo)
			{
				predo = _ped->GetRedoMgr();
				if(predo)
					predo->ClearAll();
			}
		}
#ifdef DEBUG
		else
		{
			Assert(!_fDontFlushRedo);
		}

#endif // DEBUG

		// If we should enter into the group typing state, inform
		// the undo manager.  Note that we only do this *iff* 
		// there is actually some anti-event to put in the undo
		// manager.  This makes the undo manager easier to implement
		if(_fStartGroupTyping)
			_pundo->StartGroupTyping();
		
		hr = _pundo->PushAntiEvent(_idName, _pfirstae);

		// The change event flag should be set if we're adding
		// undo items!   If this test is true, it probably means
		// the somebody earlier in the call stack sent change
		// notifiations (either via SendAllNotifications or
		// the CAutonotify class) _before_ this undo context
		// was committed _or_ it means that we were re-entered
		// in some way that was not handled properly.
		//
		// Needless to say, this is not an ideal state.

CleanUp:
		Assert(_ped->GetCallMgr()->GetChangeEvent());

		paetemp = _pfirstae;
		_pfirstae = NULL;
		
		CommitAEList(paetemp, _ped);

		if(!_pundo || hr != NOERROR)
		{
			// Either we failed to add the AE's to the undo stack
			// or the undo limit is 0 in which case there won't be
			// an undo stack to push the AE's onto.
			DestroyAEList(paetemp);
		}
	}
	return hr;
}

/*
 *	CGenUndoBuilder::Discard ()
 *
 *	@mfunc
 *		Gets rid of any anti-events that we may be hanging onto without
 *		executing or committing them.  Typically used for recovering
 *		from certain failure or re-entrancy scenarios.  Note that
 *		an _entire_ anti-event chain will be removed in this fashion.
 */
void CGenUndoBuilder::Discard()
{
	if(_pfirstae)
	{
		DestroyAEList(_pfirstae);
		_pfirstae = NULL;
	}
	else if(_publdrPrev)
		_publdrPrev->Discard();
}

/*
 *	CGenUndoBuilder::StartGroupTyping ()
 *
 *	@mfunc
 *		hangs onto the the fact that group typing should start.
 *		We'll forward the the state transition to the undo manager
 *		only if an anti-event is actually added to the undo manager.
 *
 *	@devnote
 *		group typing is disabled for redo stacks.
 */
void CGenUndoBuilder::StartGroupTyping()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CGenUndoBuilder::StartGroupTyping");

	_fStartGroupTyping = TRUE;
}

/*
 *	CGenUndoBuilder::StopGroupTyping ()
 *
 *	@mfunc
 *		forwards a stop grouped typing to the undo manager
 */

void CGenUndoBuilder::StopGroupTyping()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CGenUndoBuilder::StopGroupTyping");

	if(_pundo)
		_pundo->StopGroupTyping();
}

//
//	CUndoStackGuard IMPLEMENTATION
//

/*
 *	CUndoStackGuard::CUndoStackGuard(ped)
 *
 *	@mfunc	Constructor.  Registers this object with the call manager
 */
CUndoStackGuard::CUndoStackGuard(
	CTxtEdit *ped)			//@parm the edit context
{
	_ped = ped;
	_fReEntered = FALSE;
	_hr = NOERROR;
	ped->GetCallMgr()->RegisterComponent(this, COMP_UNDOGUARD);
}

/*
 *	CUndoStackGuard::~CUndoStackGuard()
 *
 *	@mfunc	Destructor.  Revokes the registration of this object
 *			with the call manager
 */
CUndoStackGuard::~CUndoStackGuard()
{
	_ped->GetCallMgr()->RevokeComponent(this);
}

/*
 *	CUndoStackGuard::SafeUndo
 *
 *	@mfunc	Loops through the given list of anti-events, invoking
 *			undo on each.  
 *
 *	@rdesc	HRESULT, from the undo actions
 *
 *	@devnote	This routine is coded so that OnEnterContext can pick up
 *			and continue the undo operation should we become re-entered
 */
HRESULT CUndoStackGuard::SafeUndo(
	IAntiEvent *pae,		//@parm the start of the anti-event list
	IUndoBuilder *publdr)	//@parm the undo builder to use
{
	_publdr = publdr;

	while(pae)
	{
		_paeNext = pae->GetNext();
		HRESULT hr = pae->Undo(_ped, publdr);

		// save the first returned error.
		if(hr != NOERROR && _hr == NOERROR)
			_hr = hr;

		pae = (IAntiEvent *)_paeNext;
	}

	return _hr;
}

/*
 *	CUndoStackGuard::OnEnterContext
 *
 *	@mfunc	Handle re-entrancy during undo operations.
 *
 *	@devnote If this method is called, it's pretty serious.  In general,
 *			we shoud never be re-entered while processing undo stuff.
 *			However, to ensure that, block the incoming call and process
 *			the remaining actions.
 */
void CUndoStackGuard::OnEnterContext()
{
	TRACEWARNSZ("ReEntered while processing undo.  Blocking call and");
	TRACEWARNSZ("	attempting to recover.");

	_fReEntered = TRUE;
	SafeUndo((IAntiEvent *)_paeNext, _publdr);
}	

//
//	PUBLIC helper functions
//

/*
 *	@func	DestroyAEList | Destroys a list of anti-events
 */
void DestroyAEList(
	IAntiEvent *pae)	//@parm the anti-event from which to start
{
	IAntiEvent *pnext;

	while(pae)
	{
		pnext = pae->GetNext();
		pae->Destroy();
		pae = pnext;
	}
}

/*
 *	@func CommitAEList | Calls OnCommit to the given list of anti-events
 */
void CommitAEList(
	IAntiEvent *pae,	//@parm the anti-event from which to start
	CTxtEdit *ped)		//@parm the edit context
{
	IAntiEvent *pnext;

	while(pae)
	{
		pnext = pae->GetNext();
		pae->OnCommit(ped);
		pae = pnext;
	}
}

/*
 *	@func	HandleSelectionAEInfo | Tries to merge the given info with 
 *			the existing undo context; if that fails, then it allocates 
 *			a new selection anti-event to handle the info
 */
HRESULT HandleSelectionAEInfo(
	CTxtEdit *ped,			//@parm the edit context
	IUndoBuilder *publdr,	//@parm the undo context
	LONG cp,				//@parm the cp to use for the sel ae
	LONG cch,				//@parm the signed selection extension
	LONG cpNext,			//@parm the cp to use for the AE of the AE
	LONG cchNext,			//@parm the cch to use for the AE of the AE
	SELAE flags)			//@parm controls how to intepret the info
{
	IAntiEvent *pae;

	Assert(publdr);

	pae = publdr->GetTopAntiEvent();

	// First see if we can merge the selection info into any existing
	// anti-events.  Note that the selection anti-event may be anywhere
	// in the list, so go through them all
	if(pae)
	{
		SelRange sr;

		sr.cp		= cp;
		sr.cch		= cch;
		sr.cpNext	= cpNext;
		sr.cchNext	= cchNext;
		sr.flags	= flags;

		while(pae)
		{
			if(pae->MergeData(MD_SELECTIONRANGE, (void *)&sr) == NOERROR)
				break;
			pae = pae->GetNext();
		}
	
		if(pae)
			return NOERROR;
	}

	// Oops; can't do a merge.  Go ahead and create a new anti-event.

	Assert(!pae);

	pae = gAEDispenser.CreateSelectionAE(ped, cp, cch, cpNext, cchNext);

	if(pae)
	{
		publdr->AddAntiEvent(pae);
		return NOERROR;
	}

	return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\object.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module	object.cpp	IRichEditOle implementation |
 *
 *	Author: alexgo 8/15/95
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_edit.h"
#include "_objmgr.h"
#include "_coleobj.h"
#include "_rtext.h"
#include "_select.h"
#include "_m_undo.h"


// 	IUnknown is implemented elsewhere

/*
 *	CTxtEdit::GetClientSite
 *
 *	@mfunc	returns the client site 
 */
STDMETHODIMP CTxtEdit::GetClientSite(
	LPOLECLIENTSITE FAR * lplpolesite)		//@parm where to return 
											//the client site
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::GetClientSite");

	if(!lplpolesite)
		return E_INVALIDARG;

	COleObject *pobj = new COleObject(this);
	// should start with a ref count of 1.
	if(pobj)
	{
		*lplpolesite = (IOleClientSite *)pobj;
		return NOERROR;
	}
	*lplpolesite = NULL;
	return E_OUTOFMEMORY;
}

/* 
 *	CTxtEdit::GetObjectCount
 *
 *	@mfunc	return the number of objects in this edit instance
 */
STDMETHODIMP_(LONG) CTxtEdit::GetObjectCount()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::GetObjectCount");
	
	return _pobjmgr ? _pobjmgr->GetObjectCount() : 0;
}

/*
 *	CTxtEdit::GetLinkCount
 *
 *	@mfunc	return the number of likns in this edit instance
 */
STDMETHODIMP_(LONG) CTxtEdit::GetLinkCount()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::GetLinkCount");

	CObjectMgr *pobjmgr = GetObjectMgr();
	return pobjmgr ? pobjmgr->GetLinkCount() : 0;
}

/*
 *	CTxtEdit::GetObject(iob, preobj, dwFlags)
 *
 *	@mfunc	returns an object structure for the indicated object
 */
STDMETHODIMP CTxtEdit::GetObject(
	LONG iob, 					//@parm index of the object
	REOBJECT * preobj,			//@parm where to put object info
	DWORD dwFlags)				//@parm flags
{
	COleObject *pobj = NULL;
	CCallMgr callmgr(this);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::GetObject");
	if(!preobj || preobj->cbStruct != sizeof(REOBJECT))
		return E_INVALIDARG;

	CObjectMgr *pobjmgr = GetObjectMgr();
	if(!pobjmgr)
		return E_OUTOFMEMORY;

	// There are three cases of intestest; get the object at
	// an index, at a given cp, or at the selection.

	if(iob == REO_IOB_USE_CP || iob == REO_IOB_SELECTION)
	{
		if((Get10Mode() && preobj->cp == REO_CP_SELECTION) || iob == REO_IOB_SELECTION)
		{
			// Use selection cp
			CTxtSelection *psel = GetSel();
			if(psel)
				pobj = pobjmgr->GetObjectFromCp(psel->GetCpMin());
		}
		else
			pobj = pobjmgr->GetObjectFromCp(Get10Mode() ? GetCpFromAcp(preobj->cp): preobj->cp);
	}
	else if (iob >= 0)
		pobj = pobjmgr->GetObjectFromIndex(iob);

	if(pobj)
	{
		HRESULT hResult = pobj->GetObjectData(preobj, dwFlags);

		if (Get10Mode())
			preobj->cp = GetAcpFromCp(preobj->cp);

		return hResult;
	}

	// This return code is a bit of stretch, but basially 
	return E_INVALIDARG;
}

/*
 *	CTxtEdit::InsertObject
 *
 *	@mfunc	inserts a new object
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CTxtEdit::InsertObject(
	REOBJECT * preobj)		//@parm object info
{
	CCallMgr		callmgr(this);
	WCHAR 			ch = WCH_EMBEDDING;
	CRchTxtPtr		rtp(this, 0);
	IUndoBuilder *	publdr;
	CGenUndoBuilder undobldr(this, UB_AUTOCOMMIT, &publdr);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::InsertObject");

	// Do some boundary case checking

	if(!preobj)
		return E_INVALIDARG;

	CTxtSelection *psel = GetSel();
	if(!psel)
		return E_OUTOFMEMORY;

	// If the insertion of this character would cause
	// us to exceed the text limit, fail
	if((DWORD)(GetAdjustedTextLength() + 1) > TxGetMaxLength())
	{
		// If we're not replacing a selection (or the
		// selection is degenerate, then we will have  exceeded
		// our limit
		if(preobj->cp != REO_CP_SELECTION || psel->GetCch() == 0)
		{
			GetCallMgr()->SetMaxText();
			return E_OUTOFMEMORY;
		}
	}
	
	CObjectMgr *pobjmgr = GetObjectMgr();
	if(pobjmgr)
	{
		LONG cch = 0;
		LONG cp;
		LONG cpFormat;

		undobldr.StopGroupTyping();

		if(preobj->cp == REO_CP_SELECTION)
		{
			LONG cpMost;
			psel->AdjustEndEOP(NEWCHARS);
			cch = psel->GetRange(cp, cpMost);

			// Get cp of active end of selection from which we
			// will obtain CF for object.
			cpFormat = psel->GetCp();
			if(publdr)
			{
				HandleSelectionAEInfo(this, publdr, cpFormat, cch, 
						cp + 1, 0, SELAE_FORCEREPLACE);
			}
		}
		else
			cpFormat = cp = Get10Mode() ? GetCpFromAcp(preobj->cp): preobj->cp;
		
		// Get format for ReplaceRange:  for cp semantics, use format
		// at the cp; for selection semantics, use the format at the active
		// end of the selection.
		CTxtRange rgFormat(this, cpFormat, 0);
		LONG	  iFormat = rgFormat.Get_iCF();
		ReleaseFormats(iFormat, -1);

		rtp.SetCp(cp);

		if (rtp.ReplaceRange(cch, 1, &ch, publdr, iFormat) != 1)
		{
			return E_FAIL;
		}
		
		HRESULT		hr = pobjmgr->InsertObject(cp, preobj, publdr);
		COleObject *pobj = (COleObject *)(preobj->polesite);

		pobj->EnableGuardPosRect();
		CNotifyMgr *pnm = GetNotifyMgr();		// Get notification mgr
		if(pnm)									// Notify interested parties
			pnm->NotifyPostReplaceRange(NULL, CP_INFINITE, 0, 0, cp, cp + 1);

		pobj->DisableGuardPosRect();

		// Don't want object selected
		psel->SetSelection(cp + 1, cp + 1);

		TxUpdateWindow();
		return hr;
	}
	return E_OUTOFMEMORY;		
}

/*
 *	CTxtEdit::ConvertObject(iob, rclsidNew, lpstrUserTypeNew)
 *
 *	@mfunc	Converts the specified object to the specified class.  Does reload
 *		the object but does NOT force an update (caller must do this).
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
STDMETHODIMP CTxtEdit::ConvertObject(
	LONG iob, 					//@parm index of the object
	REFCLSID rclsidNew,			//@parm the destination clsid
	LPCSTR lpstrUserTypeNew)	//@parm the new user type name
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::ConvertObject");
	CCallMgr callmgr(this);

	// If iob was invalid return
	COleObject * pobj = ObjectFromIOB(iob);
	if(!pobj)
		return E_INVALIDARG;

	//Delegate to the object.
	return pobj->Convert(rclsidNew, lpstrUserTypeNew);
}

/*
 *	CTxtEdit::ActivateAs(rclsid, rclsidAs)
 *
 *	@mfunc	Handles a request by the user to activate all objects of a
 *		particular class as objects of another class.
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
STDMETHODIMP CTxtEdit::ActivateAs(
	REFCLSID rclsid, 			//@parm clsid which we're going to change
	REFCLSID rclsidAs)			//@parm clsid to activate as
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::ActivateAs");
	CCallMgr callmgr(this);

	CObjectMgr * pobjmgr = GetObjectMgr();
	if(!pobjmgr)
		return E_OUTOFMEMORY;

	return pobjmgr->ActivateObjectsAs(rclsid, rclsidAs);
}

/* 
 *	CTxtEdit::SetHostNames(lpstrContainerApp, lpstrContainerDoc)
 *
 *	@mfunc	Sets the host names for this instance
 */
STDMETHODIMP CTxtEdit::SetHostNames(
	LPCSTR lpstrContainerApp, 	//@parm App name
	LPCSTR lpstrContainerDoc)	//@parm	Container Object (doc) name
{
	CCallMgr callmgr(this);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::SetHostNames");
	
 	WCHAR *pwsContainerApp = W32->ConvertToWideChar(lpstrContainerApp);
	WCHAR *pwsContainerDoc = W32->ConvertToWideChar(lpstrContainerDoc);

	CObjectMgr *pobjmgr = GetObjectMgr();
	if(pobjmgr && pwsContainerApp && pwsContainerDoc)
	{
		HRESULT hr = pobjmgr->SetHostNames(pwsContainerApp, pwsContainerDoc);
		delete pwsContainerApp;
		delete pwsContainerDoc;
		return hr;
	}
	return E_OUTOFMEMORY;
}

/*
 *	CTxtEdit::SetLinkAvailable(iob, fAvailable)
 *
 *	@mfunc
 *		Allows client to tell us whether the link is available or not.
 */
STDMETHODIMP CTxtEdit::SetLinkAvailable(
	LONG iob, 					//@parm index of the object
	BOOL fAvailable)			//@parm if TRUE, make object linkable
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::SetLinkAvailable");

	COleObject * pobj = ObjectFromIOB(iob);

	// If iob was invalid, return
	if (!pobj)
		return E_INVALIDARG;

	// Delegate this to the object.
	return pobj->SetLinkAvailable(fAvailable);
}

/*
 *	CTxtEdit::SetDvaspect(iob, dvaspect)
 *
 *	@mfunc	Allows client to tell us which aspect to use and force us
 *		to recompute positioning and redraw.
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
STDMETHODIMP CTxtEdit::SetDvaspect(
	LONG iob, 					//@parm index of the object
	DWORD dvaspect)				//@parm	the aspect to use
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::SetDvaspect");
	CCallMgr callmgr(this);
	COleObject * pobj = ObjectFromIOB(iob);

	// If iob was invalid, return
	if (!pobj)
		return E_INVALIDARG;

	// Delegate this to the object.
	pobj->SetDvaspect(dvaspect);
	return NOERROR;
}

/*
 *	CTxtEdit::HandsOffStorage(iob)
 *
 *	@mfunc	see IPersistStorage::HandsOffStorage
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
STDMETHODIMP CTxtEdit::HandsOffStorage(
	LONG iob)					//@parm index of the object
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::HandsOffStorage");
	CCallMgr callmgr(this);

	COleObject * pobj = ObjectFromIOB(iob);

	// If iob was invalid, return
	if (!pobj)
		return E_INVALIDARG;

	// Delegate this to the object.
	pobj->HandsOffStorage();
	return NOERROR;
}

/*
 *	CTxtEdit::SaveCompleted(iob, lpstg)
 *
 *	@mfunc	see IPersistStorage::SaveCompleted
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
STDMETHODIMP CTxtEdit::SaveCompleted(
	LONG iob, 					//@parm index of the object
	LPSTORAGE lpstg)			//@parm new storage
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::SaveCompleted");
	CCallMgr callmgr(this);

	COleObject * pobj = ObjectFromIOB(iob);

	// If iob was invalid, return
	if (!pobj)
		return E_INVALIDARG;

	// Delegate this to the object.
	pobj->SaveCompleted(lpstg);
	return NOERROR;
}

/*
 *	CTxtEdit::InPlaceDeactivate()
 *
 *	@mfunc	Deactivate 
 */
STDMETHODIMP CTxtEdit::InPlaceDeactivate()
{
	COleObject *pobj;
	HRESULT hr = NOERROR;
	CCallMgr callmgr(this);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::InPlaceDeactivate");
	
	CObjectMgr *pobjmgr = GetObjectMgr();
	if(pobjmgr)
	{
		pobj = pobjmgr->GetInPlaceActiveObject();
		if(pobj)
			hr = pobj->DeActivateObj();
	}

	return hr;
}

/*
 *	CTxtEdit::ContextSensitiveHelp(fEnterMode)
 *
 *	@mfunc enter/leave ContextSensitiveHelp mode
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
STDMETHODIMP CTxtEdit::ContextSensitiveHelp(
	BOOL fEnterMode)			//@parm enter/exit mode
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::ContextSensitiveHelp");

	HRESULT hr = NOERROR;
	CCallMgr callmgr(this);

	CObjectMgr * pobjmgr = GetObjectMgr();
	if(!pobjmgr)
		return E_OUTOFMEMORY;

	// If the mode changes
	if(pobjmgr->GetHelpMode() != fEnterMode)
	{
		pobjmgr->SetHelpMode(fEnterMode);
		COleObject * pobj = pobjmgr->GetInPlaceActiveObject();
		if(pobj)
		{
			IOleWindow *pow;
			hr = pobj->GetIUnknown()->QueryInterface(IID_IOleWindow,
				(void **)&pow);
			if(hr == NOERROR)
			{
				hr = pow->ContextSensitiveHelp(fEnterMode);
				pow->Release();
			}
		}
	}
	return hr;
}

/*
 *	CTxtEdit::GetClipboardData(lpchrg, reco, lplpdataobj)
 *
 *	@mfunc	return an data transfer object for the indicated
 *	range
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
STDMETHODIMP CTxtEdit::GetClipboardData(
	CHARRANGE *lpchrg, 			//@parm the range of text to use
	DWORD reco,					//@parm operation the data is for
	LPDATAOBJECT *lplpdataobj)	//@parm where to put the data object
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::GetClipboardData");

	CCallMgr callmgr(this);
	HRESULT hr;
	LONG cpMin, cpMost;
	CLightDTEngine * pldte = GetDTE();

	//Make sure cpMin and cpMost are within the current text limits.
	//Interpret neg. value for cpMin as the beginning of the text,
	//and neg. value for cpMax as the end of the text.  If a char range
	//is not given use the current selection.
	if(lpchrg)
	{
		LONG cchText = GetTextLength();
		cpMin = min(cchText, max(0, lpchrg->cpMin));
		cpMost = lpchrg->cpMost;
		if(lpchrg->cpMost < 0 || lpchrg->cpMost > cchText)
			cpMost = cchText;
	}
	else
	{
		CTxtSelection * psel = GetSel();
		psel->GetRange(cpMin, cpMost);
	}

	//Make sure this is a valid range.
	if(cpMin >= cpMost)
	{
		*lplpdataobj = NULL;
		return cpMin == cpMost
					? NOERROR
					: ResultFromScode(E_INVALIDARG);
	}

	CTxtRange rg(this, cpMin, cpMin-cpMost);

	//We don't use reco for anything.
	hr = pldte->RangeToDataObject(&rg, SF_RTF, lplpdataobj);

#ifdef DEBUG
	if(hr != NOERROR)
		TRACEERRSZSC("GetClipboardData", E_OUTOFMEMORY);
#endif

	return hr;
}

/*
 *	CTxtEdit::ImportDataObject(lpdataobj, cf, hMetaPict)
 *
 *	@mfunc	morally equivalent to paste, but with a data object
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
STDMETHODIMP CTxtEdit::ImportDataObject(
	LPDATAOBJECT lpdataobj,		//@parm Data object to use
	CLIPFORMAT	 cf, 			//@parm Clibpoard format to use
	HGLOBAL		 hMetaPict)		//@parm Metafile to use
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::ImportDataObject");

	CCallMgr		callmgr(this);
	IUndoBuilder *	publdr;
	REPASTESPECIAL	rps = {DVASPECT_CONTENT, NULL};
	CGenUndoBuilder undobldr(this, UB_AUTOCOMMIT, &publdr);

	if(hMetaPict)
	{
		rps.dwAspect = DVASPECT_ICON;
		rps.dwParam = (DWORD_PTR) hMetaPict;
	}

	return PasteDataObjectToRange(lpdataobj, GetSel(), cf,
								  &rps, publdr, PDOR_NOQUERY);
}

/*
 *	CTxtEdit::ObjectFromIOB(iob)
 *
 *	@mfunc	Gets an object based on an IOB type index.
 *
 *	@rdesc:
 *		pointer to COleObject or NULL if none.
 */
COleObject * CTxtEdit::ObjectFromIOB(
	LONG iob)
{
	CObjectMgr * pobjmgr = GetObjectMgr();
	if(!pobjmgr)
		return NULL;

	COleObject * pobj = NULL;

	// Figure out the index of the selection
	if (iob == REO_IOB_SELECTION)
	{
		CTxtSelection * psel = GetSel();

		pobj = pobjmgr->GetFirstObjectInRange(psel->GetCpMin(),
			psel->GetCpMost());
	}
	else
	{
		// Make sure the IOB is in range
		if(0 <= iob && iob < GetObjectCount())
			pobj = pobjmgr->GetObjectFromIndex(iob);
	}
	return pobj;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\olsole.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	OLSOLE.CPP -- OlsOle LineServices object class
 *	
 *	Author:
 *		Murray Sargent (with lots of help from RickSa's ols code)
 *
 *	Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_font.h"
#include "_edit.h"
#include "_disp.h"
#include "_ols.h"
#include "_render.h"
extern "C" {
#include "objdim.h"
#include "pobjdim.h"
#include "plsdnode.h"
#include "dispi.h"
#include "pdispi.h"
#include "fmti.h"
#include "lsdnset.h"
#include "lsdnfin.h"
#include "brko.h"
#include "pbrko.h"
#include "locchnk.h"
#include "lsqout.h"
#include "lsqin.h"
#include "lsimeth.h"
}

#ifdef LINESERVICES

/*
 *	OlsOleCreateILSObj(pols, plsc, pclscbk, dword, ppilsobj)
 *
 *	@func
 *		Create LS Ole object handler. We don't have any need for
 *		this, so just set it to 0.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleCreateILSObj(
	POLS	 pols,		//[IN]: COls * 
	PLSC	 plsc,  	//[IN]: LineServices context
	PCLSCBK,
	DWORD,
	PILSOBJ *ppilsobj)	//[OUT]: ptr to ilsobj
{
	*ppilsobj = 0;
	return lserrNone;
}

/*
 *	OlsOleDestroyILSObj(pilsobj)
 *
 *	@func
 *		Destroy LS Ole handler object. Nothing to do, since we don't
 *		use the ILSObj.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleDestroyILSObj(
	PILSOBJ pilsobj)
{
	return lserrNone;
}

/*
 *	OlsOleSetDoc(pilsobj, pclsdocinf)
 *
 *	@func
 *		Set doc info. Nothing to do for Ole objects
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleSetDoc(
	PILSOBJ, 
	PCLSDOCINF)
{
	// Ole objects don't care about this
	return lserrNone;
}

/*
 *	OlsOleCreateLNObj(pilsobj, pplnobj)
 *
 *	@func
 *		Create the line object. Nothing needed in addition to the ped,
 *		so just return the ped as the LN object.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleCreateLNObj(
	PCILSOBJ pilsobj, 
	PLNOBJ * pplnobj)
{
	*pplnobj = (PLNOBJ)g_pols->_pme->GetPed();			// Just the ped
	return lserrNone;
}

/*
 *	OlsOleDestroyLNObj(plnobj)
 *
 *	@func
 *		Destroy LN object. Nothing to do, since ped is destroyed
 *		elsewhere
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleDestroyLNObj(
	PLNOBJ plnobj)
{
	return lserrNone;
}

/*
 *	OlsOleFmt(plnobj, pcfmtin, pfmres)
 *
 *	@func
 *		Compute dimensions of a particular Ole object
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleFmt(
	PLNOBJ	plnobj, 
	PCFMTIN pcfmtin, 
	FMTRES *pfmres)
{
	const LONG		cp = pcfmtin->lsfrun.plsrun->_cp; //Cannot trust LS cps
	LONG			dup = 0;
	LSERR			lserr;
	OBJDIM			objdim;
	CTxtEdit *		ped  = (CTxtEdit *)plnobj;
	COleObject *	pobj = ped->GetObjectMgr()->GetObjectFromCp(cp);
	Assert(pobj);

	ZeroMemory(&objdim, sizeof(objdim));

	pobj->MeasureObj(g_pols->_pme->GetDyrInch(), g_pols->_pme->GetDxrInch(),
					 objdim.dur, objdim.heightsRef.dvAscent,
					 objdim.heightsRef.dvDescent, pcfmtin->lstxmRef.dvDescent);
	
	pobj->MeasureObj(g_pols->_pme->GetDypInch(), g_pols->_pme->GetDxpInch(),
					 dup, objdim.heightsPres.dvAscent,
					 objdim.heightsPres.dvDescent, pcfmtin->lstxmPres.dvDescent);

	pobj->_plsdnTop = pcfmtin->plsdnTop;

	lserr = g_plsc->dnFinishRegular(1, pcfmtin->lsfrun.plsrun, pcfmtin->lsfrun.plschp, (PDOBJ)pobj, &objdim);
	if(lserrNone == lserr) 
	{
		lserr = g_plsc->dnSetRigidDup(pcfmtin->plsdnTop, dup);
		if(lserrNone == lserr) 
		{
			*pfmres = fmtrCompletedRun;

			if (pcfmtin->lsfgi.urPen + objdim.dur > pcfmtin->lsfgi.urColumnMax 
				&& !pcfmtin->lsfgi.fFirstOnLine)
			{
				*pfmres = fmtrExceededMargin;
			}
		}
	}
	return lserr;
}


/*
 *	OlsOleTruncateChunk(plocchnk, posichnk)
 *
 *	@func
 *		Truncate chunk plocchnk at the point posichnk
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleTruncateChunk(
	PCLOCCHNK plocchnk,		// (IN): locchnk to truncate
	PPOSICHNK posichnk)		// (OUT): truncation point
{
	LSERR			lserr;
	OBJDIM			objdim;
	PLSCHNK 		plschnk = plocchnk->plschnk;
	COleObject *	pobj;
	long			ur	 = plocchnk->lsfgi.urPen;
	long			urColumnMax = plocchnk->lsfgi.urColumnMax;

	for(DWORD i = 0; ur <= urColumnMax; i++)
	{
		AssertSz(i < plocchnk->clschnk,	"OlsOleTruncateChunk: exceeded group of chunks");

		pobj = (COleObject *)plschnk[i].pdobj;
		Assert(pobj);

		lserr = g_plsc->dnQueryObjDimRange(pobj->_plsdnTop, pobj->_plsdnTop, &objdim);
		if(lserr != lserrNone)
			return lserr;

		ur += objdim.dur;
	}
	posichnk->ichnk = i - 1;
	posichnk->dcp	= 1;
	return lserrNone;
}
/*
 *	OlsOleFindPrevBreakChunk(plocchnk, pposichnk, brkcond, pbrkout)
 *
 *	@func
 *		Find previous break in chunk
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleFindPrevBreakChunk(
	PCLOCCHNK	plocchnk, 
	PCPOSICHNK	pposichnk, 
	BRKCOND		brkcond,	//(IN): recommendation about break after chunk
	PBRKOUT		pbrkout)
{
	ZeroMemory(pbrkout, sizeof(*pbrkout));

	if (pposichnk->ichnk == ichnkOutside && (brkcond == brkcondPlease || brkcond == brkcondCan))
		{
		pbrkout->fSuccessful = fTrue;
		pbrkout->posichnk.ichnk = plocchnk->clschnk - 1;
		pbrkout->posichnk.dcp = plocchnk->plschnk[plocchnk->clschnk - 1].dcp;
		COleObject *pobj = (COleObject *)plocchnk->plschnk[plocchnk->clschnk - 1].pdobj;
		Assert(pobj);

		g_plsc->dnQueryObjDimRange(pobj->_plsdnTop, pobj->_plsdnTop, &pbrkout->objdim);
	}
	else
		pbrkout->brkcond = brkcondPlease;

	return lserrNone;
}


/*
 *	OlsOleForceBreakChunk(plocchnk, pposichnk, pbrkout)
 *
 *	@func
 *		Called when forced to break a line.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleForceBreakChunk(
	PCLOCCHNK	plocchnk, 
	PCPOSICHNK	pposichnk, 
	PBRKOUT		pbrkout)
{
	ZeroMemory(pbrkout, sizeof(*pbrkout));
	pbrkout->fSuccessful = fTrue;

	if (plocchnk->lsfgi.fFirstOnLine && pposichnk->ichnk == 0 || pposichnk->ichnk == ichnkOutside)
		{
		pbrkout->posichnk.dcp = 1;
		COleObject *pobj = (COleObject *)plocchnk->plschnk[0].pdobj;
		Assert(pobj);

		g_plsc->dnQueryObjDimRange(pobj->_plsdnTop, pobj->_plsdnTop, &pbrkout->objdim);
		}
	else
		{
		pbrkout->posichnk.ichnk = pposichnk->ichnk;
		pbrkout->posichnk.dcp = 0;
		}

	return lserrNone;
}

/*
 *	OlsOleSetBreak(pdobj, brkkind, nBreakRecord, rgBreakRecord, nActualBreakRecord)
 *
 *	@func
 *		Set break
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleSetBreak(
	 PDOBJ pdobj,				// (IN): dobj which is broken
	 BRKKIND  brkkind,			// (IN): Previous/Next/Force/Imposed was chosen
	 DWORD	nBreakRecord,		// (IN): size of array
	 BREAKREC* rgBreakRecord,	// (OUT): array of break records
	 DWORD* nActualBreakRecord)	// (OUT): actual number of used elements in array
{
	return lserrNone;
}

LSERR WINAPI OlsOleGetSpecialEffectsInside(
	PDOBJ pdobj,			// (IN): dobj
	UINT *pEffectsFlags)	// (OUT): Special effects for this object
{
	*pEffectsFlags = 0;
	return lserrNone;
}

LSERR WINAPI OlsOleCalcPresentation(
	PDOBJ,					// (IN): dobj
	long,					// (IN): dup of dobj
	LSKJUST,				// (IN): LSKJUST
	BOOL fLastVisibleOnLine)// (IN): this object is last visible object on line
{
	return lserrNone;
}

/*
 *	OlsOleQueryPointPcp(pdobj, ppointuvQuery, plsqin, plsqout)
 *
 *	@func
 *		Query Ole object PointFromCp.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleQueryPointPcp(
	PDOBJ	  pdobj,			//(IN): dobj to query
	PCPOINTUV ppointuvQuery,	//(IN): query point (uQuery,vQuery)
    PCLSQIN	  plsqin,			//(IN): query input
    PLSQOUT	  plsqout)			//(OUT): query output
{
	ZeroMemory(plsqout, sizeof(LSQOUT));

	plsqout->heightsPresObj = plsqin->heightsPresRun;
	plsqout->dupObj = plsqin->dupRun;
	return lserrNone;
}
	
/*
 *	OlsOleQueryCpPpoint(pdobj, dcp, plsqin, plsqout)
 *
 *	@func
 *		Query Ole object CpFromPoint.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleQueryCpPpoint(
	PDOBJ	pdobj,		//(IN): dobj to query
	LSDCP	dcp,		//(IN):  dcp for query
    PCLSQIN	plsqin,		//(IN): query input
    PLSQOUT	plsqout)	//(OUT): query output
{
	ZeroMemory(plsqout, sizeof(LSQOUT));

	plsqout->heightsPresObj = plsqin->heightsPresRun;
	plsqout->dupObj = plsqin->dupRun;
	return lserrNone;
}

/*
 *	OlsOleDisplay(pdobj, pcdispin)
 *
 *	@func
 *		Display object
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleDisplay(
	PDOBJ	 pdobj,			//(IN): dobj to query
	PCDISPIN pcdispin)		//(IN): display info
{
	POINT pt, ptCur;
	COleObject *pobj = (COleObject *)pdobj;
	Assert(pobj);

	CRenderer  *pre = g_pols->GetRenderer();
	const CDisplay *pdp = pre->GetPdp();
	
	ptCur = pre->GetCurPoint();
	pt.x = pcdispin->ptPen.x;
	pt.y = ptCur.y;

	if (pcdispin->lstflow == lstflowWS)
		pt.x -= pcdispin->dup - 1;

	pre->SetCurPoint(pt);
	pre->SetClipLeftRight(pcdispin->dup);
	RECT rc = pre->GetClipRect();

	pre->SetSelected(pcdispin->plsrun->IsSelected());

	pre->Check_pccs();
	pre->SetFontAndColor(pcdispin->plsrun->_pCF);

	// Draw it!
	HDC hdc = pre->GetDC();
	pobj->DrawObj(pdp, pre->GetDypInch(), pre->GetDxpInch(), hdc, pdp->IsMetafile(), &pt, &rc, pcdispin->ptPen.y - pt.y, pre->GetLine()._yDescent);

	return lserrNone;
}

/*
 *	OlsOleDistroyDObj(pdobj)
 *
 *	@func
 *		Destroy object: nothing to do since object is destroyed elsewhere
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleDestroyDObj(
	PDOBJ pdobj)
{
	return lserrNone;
}


extern const LSIMETHODS vlsimethodsOle =
{
	OlsOleCreateILSObj,
	OlsOleDestroyILSObj,
    OlsOleSetDoc,
    OlsOleCreateLNObj,
    OlsOleDestroyLNObj,
	OlsOleFmt,
	0,//OlsOleFmtResume
	0,//OlsOleGetModWidthPrecedingChar
	0,//OlsOleGetModWidthFollowingChar
    OlsOleTruncateChunk,
    OlsOleFindPrevBreakChunk,
    0,//OlsOleFindNextBreakChunk
    OlsOleForceBreakChunk,
    OlsOleSetBreak,
	OlsOleGetSpecialEffectsInside,
	0,//OlsOleFExpandWithPrecedingChar
	0,//OlsOleFExpandWithFollowingChar
	OlsOleCalcPresentation,
	OlsOleQueryPointPcp,
	OlsOleQueryCpPpoint,
	0,//pfnEnum
    OlsOleDisplay,
    OlsOleDestroyDObj
};
#endif		// LINESERVICES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\osdc.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	OSDC.CPP -- Off Screen DC class |
 *
 *		This contains method used to implement the off screen
 *		DC class
 *	
 *	Owner:<nl>
 *		Rick Sailor
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */
#include	"_common.h"
#include	"_osdc.h"

ASSERTDATA

/*
 *	COffScreenDC::Init(hdc, xWidth, yHeight, crBackground)
 *
 *	@mfunc	
 *		Initialize off screen DC with compatible bitmap
 *
 *	@rdesc
 *		HDC created
 */
HDC	COffScreenDC::Init(
	HDC		 hdc,			//@parm DC to be compatible with
	LONG	 xWidth,		//@parm Width of compatible bitmap
	LONG	 yHeight,		//@parm Height of compatible bitmap
	COLORREF crBackground)	//@parm Default background for bitmap
{
	HDC hdcRet	= NULL;					// HDC to return to caller
	_hbmpOld	= NULL;					// Assume failure
	_hbmp		= NULL;
	_hpalOld	= NULL;

	// Create memory DC
	_hdc = CreateCompatibleDC(hdc);
	if(_hdc)
	{
		// Create bitmap based on size of client rectangle
		_hbmp = CreateCompatibleBitmap(hdc, xWidth, yHeight);
		if(_hbmp)
		{
			// Select bitmap into hdc
			_hbmpOld = (HBITMAP)SelectObject(_hdc, _hbmp);
			if(_hbmpOld && SetBkColor(_hdc, crBackground) != CLR_INVALID)
				hdcRet = _hdc;
		}
	}
	if(!hdcRet)
		FreeData();

	return hdcRet;
}

/*
 *	COffScreenDC::SelectPalette(hpal)
 *
 *	@mfunc	
 *		Set a new palette into the hdc
 */
void COffScreenDC::SelectPalette(
	HPALETTE hpal)			//@parm Handle to palette to set
{
#ifndef PEGASUS
	if(hpal)
	{
		_hpalOld = ::SelectPalette(_hdc, hpal, TRUE);
		RealizePalette(_hdc);
	}
#endif
}

/*
 *	COffScreenDC::FreeData()
 *
 *	@mfunc	
 *		Free resources associated with bitmap
 */
void COffScreenDC::FreeData()
{
	if(_hdc)
	{
#ifndef PEGASUS
		if(_hpalOld)
			::SelectPalette(_hdc, _hpalOld, TRUE);
#endif
		if(_hbmpOld)
			SelectObject(_hdc, _hbmpOld);

		if(_hbmp)
			DeleteObject(_hbmp);

		DeleteDC(_hdc);
	}
}

/*
 *	COffScreenDC::Realloc(xWidth, yHeight)
 *
 *	@mfunc	
 *		Reallocate bitmap
 *
 *	@rdesc
 *		TRUE - succeeded 
 *		FALSE - failed
 */
BOOL COffScreenDC::Realloc(
	LONG xWidth,			//@parm Width of new bitmap
	LONG yHeight)			//@parm Height of new bitmap
{
	// Create bitmap based on size of client rectangle
	HBITMAP hbmpNew = CreateCompatibleBitmap(_hdc, xWidth, yHeight);

	if(!hbmpNew)
	{
		AssertSz(FALSE,
			"COffScreenDC::Realloc CreateCompatibleBitmap failed"); 
		return FALSE;
	}

	// Select out old bitmap
#if defined(DEBUG) || defined(_RELEASE_ASSERTS_)
	HBITMAP hbmpDebug = (HBITMAP) 
#endif // DEBUG

	SelectObject(_hdc, hbmpNew);

	AssertSz(hbmpDebug == _hbmp, 
		"COffScreenDC::Realloc different bitmap"); 

	// Delete old bitmap
	DeleteObject(_hbmp);

	AssertSz(hbmpDebug == _hbmp, 
		"COffScreenDC::Realloc Delete old bitmap failed"); 

	// Put in new bitmap
	_hbmp = hbmpNew;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\objmgr.cpp ===
/*
 *  @doc    INTERNAL
 *
 *  @module objmgr.cpp.  Object manager implementation | manages a
 *          collection of OLE embedded objects 
 *
 *  Author: alexgo 11/5/95
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_objmgr.h"
#include "_edit.h"
#include "_disp.h"
#include "_select.h"

ASSERTDATA

//
//	PUBLIC methods
//

/*
 *	CObjectMgr::GetObjectCount
 *
 *	@mfunc	returns the number of embedded objects currently in
 *			the document.
 *
 *	@rdesc	LONG, the count
 */
LONG CObjectMgr::GetObjectCount()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::GetObjectCount");

	return _objarray.Count();
}

/*
 *	CObjectMgr::GetLinkCount()
 *
 *	@mfunc	returns the number of embedded objects which are links
 *
 *	@rdesc	LONG, the count
 */
LONG CObjectMgr::GetLinkCount()
{
	LONG count = 0;
	COleObject *pobj;
	LONG i;

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::GetLinkCount");
		
	for(i = 0; i < _objarray.Count(); i++)
	{
		pobj = *_objarray.Elem(i);
		if(pobj && pobj->IsLink())
			count++;
	}
	return count;
}

/*
 *	CObjectMgr::GetObjectFromCp()
 *
 *	@mfunc	fetches an object corresponding to the given cp
 *
 *	@rdesc	the object @ a cp; NULL if nothing found
 *
 *	@comm	the algorithm is a modified binary search.  Since the
 *			"typical" access pattern will be to linearly access the
 *			objects, we used the cached index to guess first.  If
 *			that doesn't work, we resort to a binary search.
 */
COleObject *CObjectMgr::GetObjectFromCp(
	LONG cp)		//@parm the cp for the object
{
	COleObject *pobj = NULL;
	LONG i = 0;
	
	// No tracing on this method as it's too noisy.
		
	if(_objarray.Count() > 0)
	{
		if(_lastindex < _objarray.Count())
		{
			pobj = *_objarray.Elem(_lastindex);
			if(pobj && pobj->GetCp() == cp)
				return pobj;
		}
		
		// The quick lookup failed; try a binary search.
		i = FindIndexForCp(cp);

		// Because of the insert at end case, i may be equal 
		// to the count of objects().
		pobj = NULL;
		if(i < _objarray.Count())
			pobj = *_objarray.Elem(i);
	}

	// FindIndex will return a matching or _near_ index.
	// In this case, we only want a matching index
	if(pobj)
	{
		if(pobj->GetCp() != cp)
			pobj = NULL;
		else
		{
			// Set the cached index to be the next one,
			// so that somebody walking through objects in
			// cp order will always get immediate hits.
			_lastindex = i + 1;
		}
	}
	
#ifdef DEBUG
	// Make sure the binary search found the right thing

	for( i = 0 ; i < _objarray.Count();  i++ )
	{
		COleObject *pobj2 = *_objarray.Elem(i);
		if( pobj2 )
		{
			if(*_objarray.Elem(i) == pobj)
			{
				Assert((*_objarray.Elem(i))->GetCp() == cp);
			}
			else
				Assert((*_objarray.Elem(i))->GetCp() != cp);
		}
	}
#endif //DEBUG

	return pobj;
}

/*
 *	CObjectMgr::CountObjects (cObjects, cp)
 *
 *	@mfunc	Count char counts upto <p cObjects> objects away The direction of
 *			counting is determined by the sign of <p cObjects>. 
 *
 *	@rdesc	Return the signed cch counted and set <p cObjects> to count of
 *			objects actually counted.  If <p cobject> <gt> 0 and cp is at
 *			the last object, no change is made and 0 is returned.
 *
 *	@devnote This is called from TOM, which uses LONGs for cp's (because VB
 *			can't use unsigned quantities)
 */
LONG CObjectMgr::CountObjects (
	LONG&	cObjects,		//@parm Count of objects to get cch for
	LONG	cp)				//@parm cp to start counting from
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::CountObjects");

	LONG		iStart, iEnd;
	LONG		iMaxEnd = (LONG)_objarray.Count() - 1;

	if(!cObjects || !_objarray.Count())
	{
		cObjects = 0;
		return 0;
	}

	iStart = (LONG)FindIndexForCp(cp);

	// if we are looking past either end, return 0

	if (iStart > iMaxEnd && cObjects > 0 ||
		iStart == 0 && cObjects < 0 )
	{
		cObjects = 0;
		return 0;
	}

	// If the index that we found is on an object and
	// we are looking forward, it should be skipped.

	if( iStart < (LONG)_objarray.Count() && 
		(LONG)(*_objarray.Elem(iStart))->GetCp() == cp &&
		cObjects > 0)
	{
		iStart++;
	}

	if(cObjects < 0)
	{
		if(-cObjects > iStart)	// Going past the beginning
		{
			iEnd = 0;
			cObjects = -iStart;
		}
		else
			iEnd = iStart + cObjects;
	}
	else
	{
		if(cObjects > iMaxEnd - iStart) //Going past the end
		{
			iEnd = iMaxEnd;
			cObjects = iMaxEnd - iStart + 1;
		}
		else
			iEnd = iStart + cObjects - 1;
	}

	Assert(iEnd >= 0 && iEnd < (LONG)_objarray.Count() );

	return (*_objarray.Elem(iEnd))->GetCp() - cp;
}

/*
 *	CObjectMgr::CountObjectsInRange (cpMin, cpMost)
 *
 *	@mfunc	Count the number of objects in the given range.
 *
 *	@rdesc	Return the number of objects.
 */
LONG CObjectMgr::CountObjectsInRange (
	LONG	cpMin,	//@parm Beginning of range
	LONG	cpMost)	//@parm End of range
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::CountObjectsInRange");

	//Get the indexes for the objects at or after cpMin and cpMost
	//respectively.

	return FindIndexForCp(cpMost) - FindIndexForCp(cpMin);
}

/*
 *	CObjectMgr::GetFirstObjectInRange (cpMin, cpMost)
 *
 *	@mfunc	Get the first object in the given range. 
 *
 *	@rdesc	Pointer to first object in range, or NULL if none.
 */
COleObject * CObjectMgr::GetFirstObjectInRange (
	LONG	cpMin,	//@parm Beginning of range
	LONG	cpMost)	//@parm End of range
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::GetFirstObjectInRange");

	if (cpMin == cpMost)
		// degenerate range no object selected
		return NULL;

	LONG	iLast = (LONG)_objarray.Count() - 1;	// Index for next object
	LONG	iObj = FindIndexForCp(cpMin);			//  at or after cpMin

	//Make sure this is an existing object.
	if(iObj <= iLast)
	{
		//Make sure it is within the range
		COleObject * pObj = *_objarray.Elem(iObj);

		if(pObj && pObj->GetCp() <= cpMost)
			return pObj;
	}
	return NULL;
}

/*
 *	CObjectMgr::GetObjectFromIndex(index)
 *
 *	@mfunc	retrieves the object at the indicated index
 *
 *	@rdesc	a pointer to the object, if found, NULL otherwise
 */
COleObject *CObjectMgr::GetObjectFromIndex(
	LONG index)		//@parm	Index to use
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::GetObjectFromIndex");

	if( index < _objarray.Count() )
		return *_objarray.Elem(index);

	return NULL;
}

/*
 *	CObjectMgr::InsertObject(cp, preobj, publdr)
 *
 *	@mfunc	inserts an object at the indicated index.  It is the
 *			caller's responsibility to handle inserting any data
 *			(such as WCH_EMBEDDING) into the text stream.
 *
 *	@rdesc	HRESULT
 */
HRESULT CObjectMgr::InsertObject(
	LONG		  cp,		//@parm cp to use
	REOBJECT *	  preobj,	//@parm Object to insert
	IUndoBuilder *publdr)	//@parm Undo context
{
 	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::InsertObject");

	HRESULT		hr;
	COleObject *pobj = (COleObject *)(preobj->polesite);

	// Let the client know what we're up to
	if (_precall)
	{
		hr = _precall->QueryInsertObject(&preobj->clsid, preobj->pstg,
			REO_CP_SELECTION);

		if( hr != NOERROR )
			return hr;
	}

	// Set some stuff up first; since we may make outgoing calls, don't
	// change our internal state yet.
	hr = pobj->InitFromREOBJECT(cp, preobj);
	if( hr != NOERROR )
		return hr;

	return RestoreObject(pobj);
}

/*
 *	CObjectMgr::RestoreObject(pobj)
 *
 *	@mfunc	[re-]inserts the given object into the list of objects
 *			in the backing store
 *
 *	@rdesc	HRESULT
 */
HRESULT CObjectMgr::RestoreObject(
	COleObject *pobj)		//@parm Object to insert
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::RestoreObject");

	COleObject **ppobj = _objarray.Insert(FindIndexForCp(pobj->GetCp()), 1);

	if( ppobj == NULL )
		return E_OUTOFMEMORY;

	*ppobj = pobj;
	pobj->AddRef();

	return NOERROR;
}

/*
 *	CObjectMgr::SetRECallback(precall)
 *
 *	@mfunc	sets the callback interface
 *
 *	@rdesc	void
 */
void CObjectMgr::SetRECallback(
	IRichEditOleCallback *precall) //@parm Callback interface pointer
{
 	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::SetRECallback");

	if( _precall )
        SafeReleaseAndNULL((IUnknown**)&_precall);

	_precall = precall;

	if( _precall )
		_precall->AddRef();
}

/*
 *	CObjectMgr::SetHostNames(pszApp, pszDoc)
 *
 *	@mfunc	set host names for this edit instance
 *
 *	@rdesc	NOERROR or E_OUTOFMEMORY
 */
HRESULT CObjectMgr::SetHostNames(
	LPWSTR	pszApp,	//@parm app name
	LPWSTR  pszDoc)	//@parm doc name
{
 	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::SetHostNames");
	HRESULT hr = NOERROR;

	if( _pszApp )
	{
		delete _pszApp;
		_pszApp = NULL;
	}
	if( _pszDoc )
	{
		delete _pszDoc;
		_pszDoc = NULL;
	}
	if( pszApp )
	{
		_pszApp = new WCHAR[wcslen(pszApp) + 1];
		if( _pszApp )
			wcscpy(_pszApp, pszApp);
		else
			hr = E_OUTOFMEMORY;
	}
	if( pszDoc )
	{
		_pszDoc = new WCHAR[wcslen(pszDoc) + 1];
		if( _pszDoc )
			wcscpy(_pszDoc, pszDoc);
		else
			hr = E_OUTOFMEMORY;
	}
	return hr;
}

/*
 *	CObjectMgr::CObjectMgr
 *
 *	@mfunc constructor
 */
CObjectMgr::CObjectMgr()
{
	_pobjselect = NULL;
	_pobjactive = NULL;
}

/*
 *	CObjectMgr::~CObjectMgr
 *
 *	@mfunc	destructor
 */
CObjectMgr::~CObjectMgr()
{
	LONG i, count;
	COleObject *pobj;

 	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::~CObjectMgr");

	count = _objarray.Count();

	for( i = 0; i < count; i++ )
	{
		pobj = *_objarray.Elem(i);
		// We NULL stuff here to try to protect ourselves
		// better in re-entrancy cases.
		*_objarray.Elem(i) = NULL;
		if( pobj )
		{
			pobj->Close(OLECLOSE_NOSAVE);
  			pobj->MakeZombie();
    		SafeReleaseAndNULL((IUnknown**)&pobj);
		}
	}

	if( _precall )
        SafeReleaseAndNULL((IUnknown**)&_precall);
		
	if( _pszApp )
		delete _pszApp;

	if( _pszDoc )
		delete _pszDoc;
}

/*
 *	CObjectMgr::ReplaceRange (cp, cchDel, publdr)
 *
 *	@mfunc	handles the deletion of objects from a given range.  This
 *			method _must_ be called before any floating range notifications
 *			are sent.
 *
 *	@rdesc	void
 */
void CObjectMgr::ReplaceRange(
	LONG cp,				//@parm cp starting the deletion
	LONG cchDel,			//@parm Count of characters deleted
	IUndoBuilder *publdr)	//@parm Undo builder for this actions
{
	LONG	i;
	LONG	iDel = -1, 
			cDel = 0;	// index at which to delete && number of objects
						// to delete.
	COleObject *pobj;

	// nothing deleted, don't bother doing anything.
	if( !cchDel )
		return;

	// Basically, we loop through all of the objects within the
	// range of deleted text and ask them to delete themselves.
	// We remember the range of objects deleted (the starting index
	// and # of objects deleted) so that we can remove them from
	// the array all at once.

	i = FindIndexForCp(cp);

	while( i < _objarray.Count() )
	{
		pobj = *_objarray.Elem(i);
		if( pobj && pobj->GetCp() >= cp)
		{
			if( pobj->GetCp() < (cp + cchDel) )
			{
				if( _pobjactive == pobj )
				{
					// Deactivate the object just to be on the safe side.
					_pobjactive->DeActivateObj();
					_pobjactive = NULL;
				}

				if(iDel == -1)
					iDel = i;

				cDel++;
				if (_precall)
				{
					IOleObject *poo;
					if (pobj->GetIUnknown()->QueryInterface(IID_IOleObject,
						(void **)&poo) == NOERROR)
					{
						_precall->DeleteObject(poo);
						poo->Release();
					}
				}

				// if the object was selected, then it obviously
				// can't be anymore!
				if( _pobjselect == pobj )
				{
					_pobjselect = NULL;
				}

				pobj->Delete(publdr);
				*_objarray.Elem(i) = NULL;
				pobj->Release();
			}
			else
				break;
		}
		i++;
	}
	if(cDel)
		_objarray.Remove(iDel, cDel);
	return;
}

/*
 *	CObjectMgr::ScrollObjects(dx, dy, prcScroll)
 *
 *	@mfunc	informs all objects that scrolling has occured so they can
 *			update if necessary
 *
 *	@rdesc	void
 */
void CObjectMgr::ScrollObjects(
	LONG dx,			//@parm change in the x direction
	LONG dy,			//@parm change in the y direction
	LPCRECT prcScroll)	//@parm rect that is being scrolled
{
	LONG count = _objarray.Count();
	for(LONG i = 0; i < count; i++ )
	{
		COleObject *pobj = *_objarray.Elem(i);
		if(pobj)
			pobj->ScrollObject(dx, dy, prcScroll);
	}
} 	

//
//	PRIVATE methods
//

/*
 *	CObjectMgr::FindIndexForCp(cp)
 *
 *	@mfunc	does a binary search to find the index at which an object
 *			at the given cp exists or should be inserted.
 *
 *	@rdesc	LONG, an index
 */
LONG CObjectMgr::FindIndexForCp(
	LONG cp)
{
	LONG l, r;
	COleObject *pobj = NULL;
	LONG i = 0;
		
	l = 0; 
	r = _objarray.Count() - 1;
	
	while( r >= l )
	{
		i = (l + r)/2;
		pobj = *_objarray.Elem(i);
		if( !pobj )
		{
			TRACEWARNSZ("null entry in object table.  Recovering...");
			for( i = 0 ; i < _objarray.Count() -1; i++ )
			{
				pobj = *_objarray.Elem(i);
				if( pobj && pobj->GetCp() >= cp )
					return i;
			}
			return i;
		}
		if( pobj->GetCp() == cp )
			return i;

		else if( pobj->GetCp() < cp )
			l = i + 1;

		else
			r = i - 1;
	}

	// Yikes! nothing was found.  Fixup i so that
	// it points to the correct index for insertion.

	Assert(pobj || (!pobj && i == 0));

	if(pobj)
	{
		Assert(pobj->GetCp() != cp);
		if( pobj->GetCp() < cp )
			i++;
	}
	return i;
}
						
/*
 *	CObjectMgr::HandleDoubleClick(ped, &pt, flags)
 *	
 *	@mfunc		Handles a double click message, potentially activating
 *				an object.
 *
 *	@rdesc		BOOL-- TRUE if double click-processing is completely
 *				finished.
 */
BOOL CObjectMgr::HandleDoubleClick(
	CTxtEdit *ped,	//@parm edit context
	const POINT &pt,//@parm point of click (WM_LBUTTONDBLCLK wparam)
	DWORD flags)	//@parm flags (lparam)
{
	LONG cp;
	COleObject *pobj;

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, 
						"CObjectMgr::HandleDoubleClick");

	ped->_pdp->CpFromPoint(pt, NULL, NULL, NULL, FALSE, NULL, NULL, &cp);
	pobj = GetObjectFromCp(cp);

	if (!pobj)
		return FALSE;

	if (_pobjactive != pobj)
	{
		//Deactivate currently active object if any.
		if (_pobjactive)
			_pobjactive->DeActivateObj();

		return pobj->ActivateObj(WM_LBUTTONDBLCLK, flags, MAKELONG(pt.x, pt.y));
	}
	return TRUE;
}

/*
 *	CObjectMgr::HandleClick(ped, &pt)
 *	
 *	@mfunc
 *		The position of the caret is changing.  We need to
 *		Deactivate the active object, if any.  If the change is
 *		because of a mouse click and there is an object at this
 *		cp, we set a new individually selected object. Otherwise
 *		we set the individually selected object to NULL.
 *
 *	@rdesc	returns TRUE if this method set the selection.  Otherwise,
 *		returns FALSE;
 */
ClickStatus CObjectMgr::HandleClick(
	CTxtEdit *ped,	//@parm the edit context
	const POINT &pt)//@parm the point of the mouse click 
{
 	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::HandleClick");

	COleObject *	pobjnew;//, * pobjold;
	CTxtSelection * psel;
	LONG			cp;
	LONG			cpMin, cpMost;
	
	if( _pobjactive )
	{
		_pobjactive->DeActivateObj();
		return CLICK_OBJDEACTIVATED;
	}

	ped->_pdp->CpFromPoint(pt, NULL, NULL, NULL, FALSE, NULL, NULL, &cp);
	pobjnew = GetObjectFromCp(cp);

	//If we clicked on an object, set the selection to this object.
	//CTxtSelection::UpdateSelection will be called as a result of this
	//and will determine the highlighting.
	if( pobjnew )
	{
		cp = pobjnew->GetCp();
		psel = ped->GetSel();
		if (psel->GetRange(cpMin, cpMost) > 1 &&
			cpMin <= (LONG) cp &&
			(LONG) cp <= cpMost)
		{
			// There is more than one character in the selection
			// And the object is part of the selection.
			// Do not change the selection
			return CLICK_SHOULDDRAG;
		}
		
		// don't reset the selection if the object is already selected
		if( pobjnew != _pobjselect )
		{
			// Freeze the Display while we handle this click
			CFreezeDisplay fd(ped->_pdp);

			psel->SetSelection(cp, cp+1);
			if (GetSingleSelect())
			{
				// Note thate the call to SetSelection may have set selected object to NULL !!!!
				// This can happen in some strange scenarios where our state is out of whack
				AssertSz(GetSingleSelect() == pobjnew, "Object NOT Selected!!");
				return CLICK_OBJSELECTED;
			}
			return CLICK_IGNORED;
		}
		return CLICK_OBJSELECTED;
	}
	return CLICK_IGNORED;
}

/*
 *	CObjectMgr::HandleSingleSelect(ped, cp, fHiLite)
 *	
 *	@mfunc
 *		When an object is selected and it is the only thing selected, we do
 *		not highlight it by inverting it.  We Draw a frame and handles around
 *		it.  This function is called either because an object has been
 *		selected and it is the only thing selected, or because we need to
 *		check for an object that used to be in this state but may no longer be.
 */
void CObjectMgr::HandleSingleSelect(
	CTxtEdit *ped,		//@parm edit context
	LONG	  cp,		//@parm cp of object
	BOOL	  fHiLite)	//@parm is this a call for hding the selection
{
 	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::HandleSingleSelect");

	COleObject* pobjnew = GetObjectFromCp(cp);

	//This should only be called when we know we have a singley selected
	//object.  However, there are boundary cases (such as inserting an object)
	//where WCH_EMBEDDING is the backing store yet no object exists.  These
	//cases are OK; thus, we check for NULL on pobjnew.
	
	if(pobjnew)
	{
		//The object is the same as the currently selected object (if any)
		//we are deselecting it.  This works like a toggle unless state is messed up.
		//If the object is different, we are replacing the current selected
		//object (if any).
		if(!fHiLite && _pobjselect)
		{
			// This covers _pobjselct == pobjnew  Normal case
			//  and _pobjselect != pobjnew  Degenerate case.
			_pobjselect->SetREOSELECTED(FALSE);
			_pobjselect = NULL;

			//Remove frame/handles from currently selected object.
			ped->_pdp->OnPostReplaceRange(CP_INFINITE, 0, 0, cp, cp + 1);
		}
		else if(fHiLite && pobjnew != _pobjselect)
		{
			// Only do this if we are setting a new selection.
			_pobjselect = pobjnew;
			_pobjselect->SetREOSELECTED(TRUE);

			//Draw frame/handles on newly selected object.
			ped->_pdp->OnPostReplaceRange(CP_INFINITE, 0, 0, cp, cp + 1);
		}
		else
		{
			// We want to hilite the selection but the object is already selected.
			// Or we want to undo hilite on the selection but the selected object is NULL.
			// Do nothing.
		}
	}
}


/*
 *	CObjectMgr::ActivateObjectsAs (rclsid, rclsidAs)
 *
 *	@mfunc	Handles a request by the user to activate all objects of a particular
 *		class as objects of another class.
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
HRESULT CObjectMgr::ActivateObjectsAs(
	REFCLSID rclsid,
	REFCLSID rclsidAs)
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CObjectMgr::ActivateObjectsAs");

	COleObject * pobj;
	HRESULT hr, hrLatest;

	// Tell the system to treat all rclsid objects as rclsidAs
	hr = CoTreatAsClass(rclsid, rclsidAs);
	if( hr != NOERROR )
		return hr;

	LONG cobj = GetObjectCount();

	// Go through objects, letting them decide if
	// they have anything to do for this.
	for (LONG iobj = 0; iobj < cobj; iobj++)
	{
		pobj = GetObjectFromIndex(iobj);
		hrLatest = pobj->ActivateAs(rclsid, rclsidAs);
		// Make hr the latest hresult unless we have previously had an error.
		if(hr == NOERROR)
			hr = hrLatest;
	}
	return hr;
}

#ifdef DEBUG
void CObjectMgr::DbgDump(void)
{
	Tracef(TRCSEVNONE, "Object Manager %d objects", _objarray.Count());

	for(LONG i = 0 ; i < _objarray.Count();  i++)
	{
		COleObject *pobj = *_objarray.Elem(i);
		if(pobj)
			pobj->DbgDump(i);
	}
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\ols.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	OLS.CPP -- COls LineServices object class
 *	
 *	Authors:
 *		Murray Sargent: initial coding up to nonLS RichEdit functionality
 *			(with lots of help from RickSa's ols code)
 *		Keith Curtis and Worachai Chaoweeraprasit: complex script support,
 *			etc.
 *
 *	@todo
 *		1) Fix table selection
 *		2) What are we to do with RTL tables? Word has a very different model
 *		3) What we should give for LSCHP.dcpMaxContext
 *
 *	Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_edit.h"
#include "_font.h"
#include "_render.h"
#include "_osdc.h"
#include "_dfreeze.h"
#include "_tomfmt.h"
#include "_ols.h"
#include "_clasfyc.h"
#include "_uspi.h"
#include "_txtbrk.h"
#include "lskysr.h"

#ifdef LINESERVICES

ASSERTDATA

// Guess at the number of characters on the line
const int cchLineHint = 66;

#define OBJID_OLE			0
#define OBJID_REVERSE		1
#define	OBJID_COUNT			2

const WCHAR wchObjectEnd = 0x9F;
const WCHAR rgchObjectEnd[]	= {wchObjectEnd};

#define	MAX_OBJ_DEPTH		3

extern const LSCBK lscbk;

// Kinsoku break pair information
extern const INT g_cKinsokuCategories;

CLineServices *g_plsc = NULL;		// LineServices Context
COls*		   g_pols = NULL;		// COls ptr

const LSBRK rglsbrkDefault[] =
{
	0,0,	// Always prohibited
	0,1,	// OK across blanks
	1,1		// Always allowed
};

// prototypes
void 	EmitBrace(COls* pols, PLSCHP pchp, BOOL* pfHid, DWORD* pcch, PLSRUN* pprun, LPCWSTR* plpwch, int id, LPCWSTR str);
void	DupShapeState(PLSRUN prun, LONG cch);


// public inline functions
//

// Emitting fake brace to LS
inline void EmitBrace(
	COls*		pols,
	PLSCHP		pchp,
	BOOL*		pfHid,
	DWORD*		pcch,
	PLSRUN*		pprun,
	LPCWSTR*	plpwch,
	int			id,
	LPCWSTR		str)
{
	ZeroMemory(pchp, sizeof(*pchp));								
	pchp->idObj = (WORD)id;												
	*pfHid 		= 0;												
	*pcch 		= 1;												
	*pprun 		= pols->GetPlsrun(0, pols->_pme->GetCF(), FALSE);
	*plpwch		= str;												
}

// Duplicate shaping state to each runs in the chain
// note: this macro used only by GetGlyph and GetGlyphPosition
inline void DupShapeState(
	PLSRUN		prun,
	LONG		cch)
{
	PLSRUN	pnext = prun->_pNext;										
	LONG	cpEnd = prun->_cp + cch;									
	while (pnext && pnext->_cp < cpEnd)
	{
		CopyMemory(&pnext->_a, &prun->_a, sizeof(SCRIPT_ANALYSIS));
		pnext->SetFallback(prun->IsFallback());
		prun = pnext;
		pnext = prun->_pNext;
	}																
	Assert(!pnext && prun->_cp < cpEnd);
}




LONG COls::GetCpLsFromCpRe(
	LONG cpRe)
{
	if (_rgcp.Count() == 0)
		return cpRe;

	LONG *pcp = _rgcp.Elem(0);

	for(LONG cpLs = cpRe; cpLs >= *pcp; pcp++)
		 cpLs++;

	return cpLs;
}

LONG COls::GetCpReFromCpLs(
	LONG cpLs
	)
{
	if (_rgcp.Count() == 0)
		return cpLs;

	LONG *pcp = _rgcp.Elem(0);

	for(int dcp = 0; cpLs > *pcp; pcp++)
		dcp--;

	return cpLs + dcp;
}

#ifdef DEBUG
//#define DEBUG_BRACE
#endif
// return TRUE if braces added
BOOL COls::AddBraceCp(long cpLs)
{
	if (_rgcp.Count() == 0)
	{
		long *pcp = _rgcp.Insert(0, 1);
		*pcp = tomForward;
	}

	long *pcp = _rgcp.Elem(0);
	long iel = 0;

	while (cpLs > pcp[iel])
		iel++;

	if (cpLs < pcp[iel])
	{
		pcp = _rgcp.Insert(iel, 1);
		*pcp = cpLs;
		return TRUE;
	}
	return FALSE;
}

// return number of braces before cp
//
LONG COls::BracesBeforeCp(LONG cpLs)
{
	LONG 	iel, cbr = 0;
	LONG*	pcp;

	if (!cpLs || (iel = _rgcp.Count()) < 2)
		return 0;

	iel -= 2;		// exclude the last tomForward one and make a count an index
	cpLs--;			// start with the cp preceding given cp

	pcp = _rgcp.Elem(0);

	while (iel > -1 && pcp[iel] > cpLs)		// search the first one
		iel--;

	while (iel > -1 && pcp[iel] == cpLs)	// continue counting
	{
		iel--;
		cpLs--;
		cbr++;
	}
	return cbr;
}

/*
 * 	SetRun(plsrun)
 *
 *	@func
 *		Do whatever is needed to initialize the measurer (pme) to the lsrun
 *		givin by plsrun and return whether the run is for autonumbering.
 *
 *	@rdesc
 *		TRUE if plsrun refers to an autonumbering run
 */
BOOL COls::SetRun(PLSRUN plsrun)
{
	LONG cp = plsrun->_cp;
	_pme->SetCp(cp & 0x7FFFFFFF);
	return plsrun->IsBullet();
}

/*
 * 	IsSelected()
 *
 *	@mfunc
 *	return whether or not the run should be drawn as selected.
 *
 */
CLsrun::IsSelected(void)
{
	if (!_fSelected)
		return FALSE;
	CRenderer *pre = g_pols->GetRenderer();
	Assert(pre->IsRenderer());
	return pre->_fRenderSelection ? TRUE : FALSE;
}

/*
 * 	CreatePlsrun (void)
 *
 *	@func
 *	Creates a PLSRUN. Is a little tricky because we allocate them in
 *	chunks.
 *
 *	@rdesc
 */
const int cplsrunAlloc = 8;
PLSRUN COls::CreatePlsrun()
{
	CLsrunChunk *plsrunChunk = 0;
	
	//First, find a chunk to use
	int cchunk = _rglsrunChunk.Count();
	for (int ichunk = 0; cchunk && ichunk < cchunk; ichunk++)
	{
		plsrunChunk = _rglsrunChunk.Elem(ichunk);
		if (plsrunChunk->_cel < cplsrunAlloc)
			break;
	}	

	if (!cchunk || ichunk == cchunk || plsrunChunk->_cel == cplsrunAlloc)
	{
		CLsrun *rglsrun = new CLsrun[cplsrunAlloc];
		if (rglsrun)
		{
			plsrunChunk = _rglsrunChunk.Add(1, 0);
			if (!plsrunChunk)
			{
				delete[] rglsrun;
				return 0;
			}
			plsrunChunk->_prglsrun = rglsrun;
		}
		else
			return 0;
	}
	return &plsrunChunk->_prglsrun[plsrunChunk->_cel++];
}

/*
 * 	GetPlsrun(cp, pCF, fAutoNumber)
 *
 *	@func
 *		Return plsrun for info in run. The structure contains the starting cp
 * 		of the run and the script analysis if Uniscribe is activated. The
 *		analysis information is needed by subsequent callbacks - GetGlyphs and
 *		GetGlyphPositions to be passed to Uniscribe in order to shape and
 *		position glyphs correctly for complex scripts.
 *
 *	@rdesc
 *		plsrun corresponding to info in arguments
 */
PLSRUN COls::GetPlsrun(
	LONG 		cp,
	const CCharFormat *pCF,
	BOOL 		fAutoNumber)
{
	if(fAutoNumber)
		cp |= CP_BULLET;

	CLsrun *plsrun = CreatePlsrun();

	if (plsrun)
	{
		ZeroMemory(plsrun, sizeof(CLsrun));

		plsrun->_pCF = pCF;
		plsrun->_cp = fAutoNumber ? _cp | CP_BULLET : cp;

		LONG 	cpSelMin, cpSelMost;
		_pme->GetPed()->GetSelRangeForRender(&cpSelMin, &cpSelMost);

		plsrun->SetSelected(!plsrun->IsBullet() && cp >= cpSelMin && cp < cpSelMost);

		if (pCF->_wScript && !_pme->GetPasswordChar())
		{
			CUniscribe*	pusp = _pme->Getusp();
			Assert(pusp);
			const SCRIPT_PROPERTIES* psp = pusp->GeteProp(pCF->_wScript);

			plsrun->_a.eScript = (pCF->_wScript < SCRIPT_MAX_COUNT) ? pCF->_wScript : 0;
			plsrun->_a.fRTL  = !psp->fNumeric && (IsBiDiCharSet(pCF->_bCharSet) || IsBiDiCharSet(psp->bCharSet));
			plsrun->_a.fLogicalOrder = TRUE;
		}
	}
	return plsrun;
}

/*
 *	COls::~COls()
 *
 *	@mfunc
 *		Destructor
 */
COls::~COls()
{
	for (int ichunk = 0, cchunk = _rglsrunChunk.Count(); ichunk < cchunk; ichunk++)
		delete []_rglsrunChunk.Elem(ichunk)->_prglsrun;
	DestroyLine(NULL);
	if (g_plsc)
		LsDestroyContext(g_plsc);
}


/*
 *	COls::Init(pme)
 *
 *	@mfunc
 *		Initialize this LineServices object
 *
 *	@rdesc
 *		HRESULT = (success) ? NOERROR : E_FAIL
 */
HRESULT COls::Init(
	CMeasurer *pme)
{
	_pme = pme;

	if(g_plsc)
		return NOERROR;

	// Build LS context to create
	LSCONTEXTINFO lsctxinf;

	// Setup object handlers
	LSIMETHODS vlsctxinf[OBJID_COUNT];
	vlsctxinf[OBJID_OLE] = vlsimethodsOle;
	if(LsGetReverseLsimethods(&vlsctxinf[OBJID_REVERSE]) != lserrNone)
		return E_FAIL;

	lsctxinf.cInstalledHandlers = OBJID_COUNT;
    lsctxinf.pInstalledHandlers = &vlsctxinf[0];

	// Set default and all other characters to 0xFFFF
    memset(&lsctxinf.lstxtcfg, 0xFF, sizeof(lsctxinf.lstxtcfg));

	lsctxinf.fDontReleaseRuns = TRUE;
	lsctxinf.lstxtcfg.cEstimatedCharsPerLine = cchLineHint;

	// Set the characters we handle
	lsctxinf.lstxtcfg.wchNull			= 0;
	lsctxinf.lstxtcfg.wchSpace			= ' ';
	lsctxinf.lstxtcfg.wchHyphen			= '-';
	lsctxinf.lstxtcfg.wchTab			= '\t';
	lsctxinf.lstxtcfg.wchEndLineInPara	= '\v';
	lsctxinf.lstxtcfg.wchEndPara1		= '\r';
	lsctxinf.lstxtcfg.wchEndPara2		= '\n';

	lsctxinf.lstxtcfg.wchVisiAltEndPara	=
	lsctxinf.lstxtcfg.wchVisiEndPara	=
	lsctxinf.lstxtcfg.wchVisiEndLineInPara = ' ';
	
	lsctxinf.lstxtcfg.wchNonReqHyphen = SOFTHYPHEN;

	// Auto number escape character
	lsctxinf.lstxtcfg.wchEscAnmRun = wchObjectEnd;

    lsctxinf.pols = this;
    lsctxinf.lscbk = lscbk;

	if(LsCreateContext(&lsctxinf, &g_plsc) != lserrNone)
		return E_FAIL;

	//REVIEW (keithcu) Quill seems to have a more mature kinsoku
	//table. For example, we don't allow breaking across space between
	//a word and the ending punctuation. French people want this behavior.
	BYTE  rgbrkpairsKinsoku[cKinsokuCategories][cKinsokuCategories];
	BYTE *prgbrkpairsKinsoku = &rgbrkpairsKinsoku[0][0];
	for(LONG i = 0; i < cKinsokuCategories; i++)
	{
		for(LONG j = 0; j < cKinsokuCategories; j++)
		{
			LONG iBreak = 2*CanBreak(i, j);
			// If don't break, allow break across blanks unless first
			// char is open brace or second char is close brace
			if (!iBreak &&				
				GetKinsokuClass(i) != brkclsOpen &&
				GetKinsokuClass(j) != brkclsOpen)
			{
				iBreak = 1;
			}
			*prgbrkpairsKinsoku++ = iBreak;
		}
	}
	if(g_plsc->SetBreaking(ARRAY_SIZE(rglsbrkDefault), rglsbrkDefault,
					 cKinsokuCategories, &rgbrkpairsKinsoku[0][0]) != lserrNone)
	{
		return E_FAIL;
	}

	return NOERROR;
}

/*
 * 	COls::MeasureLine(xWidth, pliTarget)
 *
 *	@mfunc
 *		Wrapper for LsCreateLine
 *
 *	@rdesc
 *		TRUE if success, FALSE if failed
 */
const int dxpMaxWidth = 0x000FFFFF;
BOOL COls::MeasureLine(
    LONG	xWidth,			//@parm Width of line in device units
	CLine *	pliTarget)		//@parm Returns target-device line metrics (optional)
{
	LONG	xWidthActual = xWidth;
	CMeasurer *pme = _pme;
	const CParaFormat *pPF = pme->Get_pPF();
	const CDisplay *pdp = pme->_pdp;
	
	LONG cp = pme->GetCp();
#ifdef DEBUG
	LONG cchText = pme->GetTextLength();	// For DEBUG...
	AssertSz(cp < cchText || !pme->IsRich() && cp == cchText, "COls::Measure: trying to measure past EOD");
#endif
	DestroyLine(NULL);

	_cp = cp;
	_pdp = pdp;
	_fCheckFit = FALSE;
	pme->SetUseTargetDevice(FALSE);

	LSDEVRES lsdevres;
	lsdevres.dyrInch = pme->_dyrInch;
	lsdevres.dxrInch = pme->_dxrInch;
	lsdevres.dypInch = pme->_dypInch;
	lsdevres.dxpInch = pme->_dxpInch;

	g_plsc->SetDoc(TRUE, lsdevres.dyrInch == lsdevres.dypInch &&
					lsdevres.dxrInch == lsdevres.dxpInch, &lsdevres);

	if(xWidth == -1)
	{
		if (pdp->GetMaxWidth())
			xWidth = xWidthActual = pme->LXtoDX(pdp->GetMaxWidth());
		else
			xWidth = xWidthActual = max(0, pdp->GetMaxPixelWidth() - dxCaret);
	}

	if(!pdp->GetWordWrap())
	{
		xWidth = dxpMaxWidth;
		BOOL fNearJust = pPF->_bAlignment == PFA_LEFT && !pPF->IsRtlPara() ||
					     pPF->_bAlignment == PFA_RIGHT && pPF->IsRtlPara();
		if (!fNearJust)
			_fCheckFit = TRUE;
	}


	DWORD cBreakRecOut;
	LSLINFO	 lslinfo;
	BREAKREC rgBreak[MAX_OBJ_DEPTH];
	_xWidth = xWidth;

	LSERR lserr = g_plsc->CreateLine(cp, pme->DXtoLX(xWidth), NULL, 0, MAX_OBJ_DEPTH, rgBreak,
						 &cBreakRecOut, &lslinfo, &_plsline);

	if (_fCheckFit)
	{
		long upJunk, upStartTrailing;
		LsQueryLineDup(_plsline, &upJunk, &upJunk, &upJunk, &upStartTrailing, &upJunk);

		if (pme->_pPF->InTable())
			{
			// We play games in case of tables, so we should change width to get proper alignment.
			//
			// LS formats from negative left indent of -_dxOffset, but we'll actually display
			// from	the +_dxOffset. We will also lie to LS (or is is truth) about position of
			// the last tab. As a result of this, LS thinks the line by _dxOffset shorter than
			// it really is.
			xWidthActual -= pme->LXtoDX(pme->_pPF->_dxOffset);
			}

		if (upStartTrailing < xWidthActual)
		{
			_xWidth = xWidth = xWidthActual;
			_fCheckFit = FALSE;
			DestroyLine(NULL);
			lserr = g_plsc->CreateLine(cp, pme->DXtoLX(xWidth), NULL, 0, MAX_OBJ_DEPTH, rgBreak,
									   &cBreakRecOut, &lslinfo, &_plsline);
		}
	}

	//Line Services doesn't put the autonumbering dimensions into the line,
	//so we have to do it ourselves.
	lslinfo.dvpAscent = max(lslinfo.dvpAscent, lslinfo.dvpAscentAutoNumber);
	lslinfo.dvpDescent = max(lslinfo.dvpDescent, lslinfo.dvpDescentAutoNumber);

	pme->SetUseTargetDevice(FALSE);

	lslinfo.cpLim = GetCpReFromCpLs(lslinfo.cpLim);

	if (lserr != lserrNone)
	{
		AssertSz(lserr == lserrOutOfMemory, "Line format failed for invalid reason");
		pme->GetPed()->GetCallMgr()->SetOutOfMemory();
		return FALSE;
	}

	//REVIEW (keithcu) Doing this hit-testing during measurement is slow--is it
	//worth it to cache this data?
	if(!pme->IsRenderer())
	{
		long upJunk, upStart, upStartTrailing, upLimLine;

		// Save some LineServices results in the measurer's CLine
		pme->_li._cch = lslinfo.cpLim - cp;
		AssertSz(pme->_li._cch > 0,	"no cps on line");

		// Query line services for line width and indent.
		LsQueryLineDup(_plsline, &upJunk, &upJunk, &upStart, &upStartTrailing, &upLimLine);
		long dupWidth = upStartTrailing - upStart;

		pme->_li._xLeft = upStart;
		pme->_li._xWidth = dupWidth;

		if(pme->IsRich())
		{
			pme->_li._yHeight  = lslinfo.dvpAscent + lslinfo.dvpDescent;
			pme->_li._yDescent = lslinfo.dvpDescent;
		}
		else
			pme->CheckLineHeight();				// Use default heights

		pme->_li._cchEOP = 0;

		pme->SetCp(lslinfo.cpLim);
		if(pme->_rpTX.IsAfterEOP())				// Line ends with an EOP
		{										// Store cch of EOP (1 or 2)
			pme->_rpTX.BackupCpCRLF(FALSE);
			UINT ch = pme->GetChar();
			if(ch == CR || pme->GetPed()->fUseCRLF() && ch == LF)
				pme->_li._bFlags |= fliHasEOP;
			pme->_li._cchEOP = pme->_rpTX.AdvanceCpCRLF(FALSE);
		}
		if (lslinfo.cpLim > pme->GetTextLength() &&
			(!pme->IsRich() || pme->IsHidden()))
		{
			Assert(lslinfo.cpLim == pme->GetTextLength() + 1);
			pme->_li._cch--;
		}
		else
			pme->AdjustLineHeight();
	}

	//Setup pliTarget if caller requests it
	//FUTURE (KeithCu) If people want target information, then the display
	//information is the same, except that OnFormatRange has a bug.
	if (pliTarget)
	{
		CLine liSave = pme->_li;
		pme->_li._yHeight = max(lslinfo.dvrAscent, lslinfo.dvrAscentAutoNumber) +
							max(lslinfo.dvrDescent, lslinfo.dvrDescentAutoNumber);
		pme->_li._yDescent = lslinfo.dvrDescent;
		pme->SetUseTargetDevice(TRUE);
		pme->AdjustLineHeight();
		pme->SetUseTargetDevice(FALSE);
		*pliTarget = pme->_li;
		pme->_li = liSave;
	}
	return TRUE;
}

/*
 * 	COls::RenderLine()
 *
 *	@mfunc
 *		Wrapper for LsDisplayLine
 *
 *	@rdesc
 *		TRUE if success, FALSE if failed
 */
BOOL COls::RenderLine(
	CLine &	li)				//@parm Line to render
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "COls::RenderLine");

	LONG		cp = _pme->GetCp();
	CRenderer	*pre = GetRenderer();
	LONG		xAdj = 0, yAdj = 0;
	Assert(pre->_fRenderer);

	pre->NewLine(li);
	if(li._fCollapsed)				// Line is collapsed in Outline mode
	{
		pre->Advance(li._cch);		// Bypass line
		return TRUE;				// Let dispml continue with next line
	}
	pre->SetNumber(li._bNumber);

	CreateOrGetLine();
	if(!_plsline)
		return FALSE;

	pre->SetCp(cp);						// Back to beginning of line
	Assert(pre->_fTarget == FALSE);
	pre->Check_pccs(FALSE);
	pre->SetClipRect();

	HDC hdcSave = NULL;
	if(li._cch > 0 && pre->fUseOffScreenDC() && (li._bFlags & fliUseOffScreenDC))
	{
		// Set up an off-screen DC if we can. Note that if this fails,
		// we just use the regular DC which won't look as nice but
		// will at least display something readable.
		hdcSave = pre->SetUpOffScreenDC(xAdj, yAdj);

		// Is this a uniform text being rendered off screen?
		if(li._bFlags & fliOffScreenOnce)
		{
			// Yes - turn off special rendering since line has been rendered
			li._bFlags &= ~(fliOffScreenOnce | fliUseOffScreenDC);
		}
	}
	POINT pt = pre->GetCurPoint();			// Must follow offscreen setup
	RECT  rc = pre->GetClipRect();			//  since _ptCur, _rc change
	LONG  x = 0;
	if(pre->_pPF->InTable())
	{
		pt.x += 2*pre->LXtoDX(pre->_pPF->_dxOffset);
		x = pt.x + pre->_li._xLeft;
	}

	pre->_li._xLeft = 0;
	pre->RenderStartLine();

	pt.x += pre->XFromU(0);

	pt.y += li._yHeight - li._yDescent;		// Move to baseline	for LS
	LSERR lserr = LsDisplayLine(_plsline, &pt, pre->GetPdp()->IsMain() ? ETO_CLIPPED : 0, &rc);

	AssertSz(lserr == lserrNone, "COls::RenderLine: error in rendering line");

	pre->EndRenderLine(hdcSave, xAdj, yAdj, x);
	pre->SetCp(cp + li._cch);

	return lserr == lserrNone;
}

/*
 * 	COls::CreateOrGetLine()
 *
 *	@mfunc
 *		If _plsline is nonNull and _cp equals _pme->GetCp(), return.  Else
 *		create line with caching so that _plsline and _cp are correct for
 *		current line
 */
void COls::CreateOrGetLine()
{
	if(_plsline && _pme->GetCp() == _cp && _pme->_pdp == _pdp)
		return;

	MeasureLine(-1, NULL);		// Define new _plsline
}

/*
 * 	COls::MeasureText(cch, taMode, pdx, pdy)
 *
 *	@mfunc
 *		Gets x offset to cp given by CMeasurer _pme + cch chars along with
 *		display dimensions.
 *
 *	@rdesc
 *		xwidth measured
 */
LONG COls::MeasureText(
	LONG	 cch,			//(IN): Max cch to measure
	UINT	 taMode,		//(IN): requested coordinate
	CDispDim *pdispdim)		//(OUT): display dimensions
{
	CMeasurer *	pme = _pme;				
	LONG		cp = pme->GetCp() + cch;	// Enter with me at start of line
	POINT		pt;							// Point at cp in client coords
	BOOL		fAtLogicalRightEdge = FALSE;

	CreateOrGetLine();
	if(!_plsline)
		return 0;
	Assert(pme->_fTarget == FALSE);

	// Query point from cp
	DWORD		cActualDepth;
	LSQSUBINFO	lsqSubInfo[MAX_OBJ_DEPTH];
	LSTEXTCELL	lsTextCell;

    memset(&lsTextCell, 0, sizeof(lsTextCell));
	
	LsQueryLineCpPpoint(_plsline, GetCpLsFromCpRe(cp), MAX_OBJ_DEPTH, &lsqSubInfo[0],
									  &cActualDepth, &lsTextCell);

	pdispdim->lstflow = lsqSubInfo[cActualDepth - 1].lstflowSubline;
	pdispdim->dx = lsTextCell.dupCell;

	LSTFLOW	 lstflowLine = lsqSubInfo[0].lstflowSubline;

	POINT ptStart = {pme->XFromU(0), pme->_li._yHeight - pme->_li._yDescent};
	POINTUV ptuv = lsTextCell.pointUvStartCell;

	if(taMode & (TA_STARTOFLINE | TA_ENDOFLINE) && cActualDepth > 1)
	{
		ptuv = lsqSubInfo[0].pointUvStartRun;
		if(taMode & TA_ENDOFLINE)
			ptuv.u += lsqSubInfo[0].dupRun;
	}

	//If they ask for position inside ligature or at lim of line, give right edge of cell
	else if (cp > GetCpReFromCpLs(lsTextCell.cpStartCell))
	{
		fAtLogicalRightEdge = TRUE;
		if (lstflowLine != pdispdim->lstflow)
			ptuv.u -= lsTextCell.dupCell;
		else
			ptuv.u += lsTextCell.dupCell;
	}

	LsPointXYFromPointUV(&ptStart, lstflowLine, &ptuv, &pt);

	if(pme->_pPF->InTable())
		pt.x += 2*pme->LXtoDX(pme->_pPF->_dxOffset);

	if (pdispdim->lstflow == lstflowWS && !(taMode & (TA_LOGICAL | TA_STARTOFLINE)))
	{
		if (fAtLogicalRightEdge)
		{
			if ((taMode & TA_RIGHT) == TA_RIGHT)
				pt.x += pdispdim->dx;
			else if (taMode & TA_CENTER)
				pt.x += pdispdim->dx / 2;
			return pt.x;
		}
		else
			pt.x -= pdispdim->dx;
	}

	LONG dx = 0;

	if(taMode & TA_CENTER && !fAtLogicalRightEdge)
		dx = pdispdim->dx;
	if((taMode & TA_CENTER) == TA_CENTER)
		dx >>= 1;

	if (pdispdim->lstflow == lstflowWS && (taMode & TA_LOGICAL))
		dx = -dx;
	return max(0, pt.x + dx);
}

/*
 * 	COls::CchFromXpos(pt, &dx)
 *
 *	@mfunc
 *		Moves _pme to pt.x. Calls LsQueryLinePointPcp()
 */
void COls::CchFromXpos(
	POINT pt,			//@parm Point to find cch for in line
	CDispDim *pdispdim,	//@parm dimensions of object
	LONG	*pcpActual) //@parm CP point
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "COls::CchFromXpos");

	if(_pme->_pPF->InTable())
		pt.x -= 2*_pme->LXtoDX(_pme->_pPF->_dxOffset);

	// Make point relative to LS coordinate system - (0,0) in LS is at the
	// baseline of the line.
	POINTUV ptuv = {_pme->UFromX(pt.x), -pt.y + _pme->_li._yHeight - _pme->_li._yDescent};

	LONG cpStart = _pme->GetCp();

	CreateOrGetLine();
	if(!_plsline)
		return;
	Assert(_pme->_fTarget == FALSE);

	DWORD		cActualDepth;
	LSQSUBINFO	lsqSubInfo[MAX_OBJ_DEPTH];
	LSTEXTCELL	lsTextCell;

	memset(&lsTextCell, 0, sizeof(lsTextCell));

	LsQueryLinePointPcp(_plsline, &ptuv, MAX_OBJ_DEPTH,	&lsqSubInfo[0], &cActualDepth, &lsTextCell);

	if (cActualDepth == 0) //If we got back empty textcell, let's just query cp explicitly to get information
	{
		LsQueryLineCpPpoint(_plsline, cpStart, MAX_OBJ_DEPTH, &lsqSubInfo[0], &cActualDepth, &lsTextCell);
		Assert(cActualDepth != 0);
	}

	pdispdim->dx = lsTextCell.dupCell;
	pdispdim->lstflow = lsqSubInfo[cActualDepth - 1].lstflowSubline;

    LONG cp = *pcpActual = GetCpReFromCpLs(lsTextCell.cpStartCell);

	POINTUV ptuvCell;
	//Convert the hit-test point from u,v of line to u,v of cell
	LsPointUV2FromPointUV1(lsqSubInfo[0].lstflowSubline, &lsTextCell.pointUvStartCell, &ptuv,
		lsqSubInfo[cActualDepth - 1].lstflowSubline, &ptuvCell);

	if(ptuvCell.u > lsTextCell.dupCell/2)
		cp += lsTextCell.cpEndCell - lsTextCell.cpStartCell + 1;

	if (_pme->GetPed()->_pbrk)
	{
		// If text breaker is up, verify cluster before placing the caret
		CTxtBreaker* pbrk = _pme->GetPed()->_pbrk;
		LONG		 cpEnd = _pme->GetPed()->GetTextLength();
		while (cp < cpEnd && !pbrk->CanBreakCp(BRK_CLUSTER, cp))
			cp++;
	}

	_pme->_li._cch = cp - _cp;
	_pme->SetCp(cp);
}

/*
 * 	COls::DestroyLine(pdp)
 *
 *	@mfunc
 *		Destroys any line data structures.
 */
void COls::DestroyLine(CDisplay *pdp)
{
	CLock lock;
	if (pdp && pdp != _pdp)
		return;

	if(_plsline)
	{
		g_plsc->DestroyLine(_plsline);
		_plsline = NULL;
	}
	if (_rgcp.Count())
		_rgcp.Clear(AF_KEEPMEM);

	int cchunk = _rglsrunChunk.Count();
	for (int ichunk = 0; ichunk < cchunk; ichunk++)
		_rglsrunChunk.Elem(ichunk)->_cel = 0;
}

/*
 * 	LimitChunk(pch, &cchChunk, f10Mode)
 *
 *	@func
 *		Return object ID at *pch and shorten cchChunk to 1 if object isn't
 *		text and to the count of text chars up to a nontext object if one
 *		occurs within cchChunk and within the current paragraph.
 *
 *	@rdesc
 *		Object ID at *pch
 */
DWORD LimitChunk(const WCHAR *pch, LONG &cchChunk, BOOL f10Mode)
{
	for(LONG i = 0; i < cchChunk && *pch != CR; i++, pch++)
	{
		switch(*pch)
		{
		case WCH_EMBEDDING:
			if(i == 0)
			{
				cchChunk = 1;
				return OBJID_OLE;		// Entered at an OLE object
			}
			cchChunk = i;				// Will break before
		break;

		case EURO:
			if (i == 0)
			{
				for(; i < cchChunk && *pch == EURO; i++)
					pch++;
			}
			cchChunk = i;
		break;

		case FF:
			if(f10Mode)					// RE 1.0 treats FFs as
				continue;				//  ordinary characters

			cchChunk = i;				// Will break before
		break;
		}
	}

	return idObjTextChp;
}

/*
 * 	SetLsChp(dwObjId, pme, plsChp)
 *
 *	@func
 *		Helper function that initializes an LS chp from RE CCharFormat
 *
 *	@rdesc
 *		TRUE iff IsHidden()
 */
BOOL COls::SetLsChp(
	DWORD		dwObjId,	//(IN): Object id
	PLSRUN		plsrun,		//(IN): Current Run
	PLSCHP		plsChp)		//(OUT): LS chp
{
	ZeroMemory(plsChp, sizeof(*plsChp));
	plsChp->idObj = (WORD)dwObjId;

	//If we do FE or Latin kerning, we need to set dcpMaxContext to 2

	if (_pme->GetPed()->IsComplexScript() && plsrun->_a.eScript && !plsrun->IsBullet())
	{
		CUniscribe*		pusp = _pme->Getusp();
		Assert (pusp);
		const SCRIPT_PROPERTIES *psp = pusp->GeteProp(plsrun->_a.eScript);

		if (psp->fComplex || plsrun->_a.fRTL ||
			psp->fNumeric && W32->GetDigitSubstitutionMode() != DIGITS_NOTIMPL)
		{
			// 1. Complex script
			// 2. RTL (internal direction) run (handle mirror glyph i.e.'?')
			// 3. Numeric run and substitution mode is either Native or Context

			plsChp->fGlyphBased	= TRUE;
		}
	}

	DWORD dwEffects = plsrun->_pCF->_dwEffects;

	if(dwEffects & (CFE_UNDERLINE | CFE_LINK | CFE_REVISED))
		plsChp->fUnderline = TRUE;

	if(dwEffects & CFE_STRIKEOUT && !plsrun->IsBullet())
		plsChp->fStrike = TRUE;

	if (plsrun->_pCF->_yOffset || dwEffects & (CFE_SUPERSCRIPT | CFE_SUBSCRIPT))
	{
		_pme->SetUseTargetDevice(FALSE);
		CCcs *pccs = _pme->Check_pccs(plsrun->IsBullet());
		LONG yOffset, yAdjust;
		pccs->GetOffset(plsrun->_pCF, _pme->_dypInch, &yOffset, &yAdjust);

		plsChp->dvpPos += yOffset + yAdjust;
	}

	//If its an OLE object, but the Object doesn't exist yet, then hide it
	if (dwObjId == OBJID_OLE)
	{
		COleObject * pobj = _pme->GetPed()->GetObjectMgr()->GetObjectFromCp(_pme->GetCp());
		if (!pobj)
			return TRUE;
	}
	return dwEffects & CFE_HIDDEN;
}

/*
 *	FetchAnmRun(pols, cp, plpwchRun, pcchRun, pfHidden, plsChp, pplsrun)
 *
 *	@func
 *		 LineServices fetch bullets/numbering callback
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI COls::FetchAnmRun(
	LSCP	 cp,		//@parm [IN]: RE cp
	LPCWSTR *plpwchRun, //@parm [OUT]: Run of characters
	DWORD *	 pcchRun, 	//@parm [OUT]: Count of characters in run
	BOOL *	 pfHidden, 	//@parm [OUT]: fHidden run?
	PLSCHP	 plsChp, 	//@parm [OUT]: Char properties of run
	PLSRUN * pplsrun)	//@parm [OUT]: Abstract representation of run properties
{
	if (cp == cpFirstAnm && _pme->Get_pPF()->IsRtlPara())
	{
		ZeroMemory(plsChp, sizeof(*plsChp));
		plsChp->idObj = OBJID_REVERSE;
		*pfHidden	= 0; *pcchRun = 1;
		*pplsrun	= GetPlsrun(_pme->GetCp(), &_CFBullet, TRUE);
		*plpwchRun	= &_szAnm[0];
		return lserrNone;
	}

	*plpwchRun = &_szAnm[cp - cpFirstAnm];
	*pcchRun = _cchAnm - (cp - cpFirstAnm);	
	*pplsrun  = GetPlsrun(_pme->GetCp(), &_CFBullet, TRUE);
	SetLsChp(idObjTextChp, *pplsrun, plsChp);
	*pfHidden = FALSE;

	if (!_pme->GetNumber())
		plsChp->fUnderline = FALSE;

	return lserrNone;	
}



/*
 *	OlsFetchRun(pols, cp, plpwchRun, pcchRun, pfHidden, plsChp, pplsrun)
 *
 *	@func
 *		 LineServices fetch-run callback
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsFetchRun(
	POLS	 pols,		//@parm [IN]: COls *
	LSCP	 cpLs,		//@parm [IN]: LS cp
	LPCWSTR *plpwchRun, //@parm [OUT]: Run of characters
	DWORD *	 pcchRun, 	//@parm [OUT]: Count of characters in run
	BOOL *	 pfHidden, 	//@parm [OUT]: Hidden run?
	PLSCHP	 plsChp, 	//@parm [OUT]: Char properties of run
	PLSRUN * pplsrun)	//@parm [OUT]: Abstract representation of run properties
{
	if(cpLs < 0)
		return pols->FetchAnmRun(cpLs, plpwchRun, pcchRun, pfHidden, plsChp, pplsrun);

	CMeasurer 	*pme = pols->GetMeasurer();
	CTxtEdit 	*ped = pme->GetPed();
	BOOL		fStart = FALSE;
	BOOL		fFetchBraces = ped->IsBiDi() && g_pusp && g_pusp->IsValid() &&
							!ped->_fItemizePending && ped->GetAdjustedTextLength();
	WCHAR		chPassword = pme->GetPasswordChar();
	LONG		cpAccelerator = ped->GetCpAccelerator();
	BOOL		fAccelerator = FALSE;
	BOOL		f10Mode = ped->Get10Mode();

	if (cpLs == pols->_cp)
	{
		//If we are formatting (or re-formatting) the line, cleanup
		if (pols->_rgcp.Count())
			pols->_rgcp.Clear(AF_KEEPMEM);
		pols->_cEmit = 0;
	}
	long cpRe = pols->GetCpReFromCpLs(cpLs);


	pme->SetCp(cpRe);		// start fetching at given cp


	if (fFetchBraces && pme->_rpCF.IsValid())
	{
		// consider emitting braces only at the run boundary or start of a fetched line
		//
		if (cpRe == pols->_cp || !pme->GetIchRunCF() || !pme->GetCchLeftRunCF())
		{
			SHORT	cBrClose, cBrOpen;
			BYTE	bBaseLevel = pme->IsParaRTL() ? 1 : 0;
			BYTE	bLevel, bLevelPrev;
	
			bLevelPrev = bLevel = bBaseLevel;			// assume base level
	
			if (cpRe < ped->GetTextLength())
			{
				CBiDiLevel	level;

				bLevel = pme->_rpCF.GetLevel(&level);	// got level of current run
				fStart = level._fStart;
			}
	
			if (cpRe > pols->_cp && pme->Advance(-1))
			{
				if (pme->_rpPF.SameLevel(bBaseLevel))	// preceding run may be hidden
					bLevelPrev = pme->_rpCF.GetLevel();	// got level of preceding run
				pme->Advance(1);						// resume position
			}
	
			cBrOpen = cBrClose = bLevel - bLevelPrev;
	
			if (fStart)									// start embedding at the current run
				cBrClose = bBaseLevel - bLevelPrev;		// this means we must close all braces of preceding run
	
			cBrClose = max(0, -cBrClose);

			if (cBrClose > 0 && pols->BracesBeforeCp(cpLs) < cBrClose)
			{
				// emit close braces

				if (pols->_cEmit > 0)
				{
					EmitBrace(pols, plsChp, pfHidden, pcchRun, pplsrun, plpwchRun, idObjTextChp, rgchObjectEnd);
					if (pols->AddBraceCp(cpLs))
						pols->_cEmit--;
#ifdef DEBUG_BRACE
					Tracef(TRCSEVNONE, "CLOSE(%d) cpLs %d: emitted %d", cBrClose, cpLs, pols->_cEmit);
#endif
					return lserrNone;
				}
				else
				{
					// We assert. You can click "Ignore All" with no hang.
					AssertSz(FALSE, "Prevent emitting close brace (no open counterpart)");
				}
			}
	
			if (fStart)									// start embedding at the current run
				cBrOpen = bLevel - bBaseLevel;			// we begin openning braces
	
			if (cBrOpen > 0 && pols->BracesBeforeCp(cpLs) < cBrOpen + cBrClose)
			{
				// emit open braces
	
				EmitBrace(pols, plsChp, pfHidden, pcchRun, pplsrun, plpwchRun, OBJID_REVERSE, L" ");
				if (pols->AddBraceCp(cpLs))
					pols->_cEmit++;
#ifdef DEBUG_BRACE
				Tracef(TRCSEVNONE, "OPEN(%d) cpLs %d: emitted %d", cBrOpen, cpLs, pols->_cEmit);
#endif
				return lserrNone;
			}
		}
	}

	// Done fetching braces.
	// Begin getting real data...


#ifdef DEBUG_BRACE
	Tracef(TRCSEVNONE, "cpLs %d: emitted %d", cpLs, pols->_cEmit);
#endif

	// Initialized chunk to count of characters in format run
	LONG	cchChunk = pme->GetCchLeftRunCF();
	DWORD	dwObjId	 = idObjTextChp;

	if(!pme->IsHidden())							// Run isn't hidden
	{
		LONG cch;

		*plpwchRun = pme->GetPch(cch);		// Get text in run
		cchChunk = min(cchChunk, cch);		// Maybe less than cchChunk
		if (!pme->GetPdp()->IsMetafile())
			cchChunk = min(cchChunk, cchLineHint);

		if (chPassword)
		{
			cchChunk = min(cchChunk, int(sizeof(pols->_rgchTemp) / sizeof(WCHAR)));
			memcpy(pols->_rgchTemp, *plpwchRun, cchChunk * sizeof(WCHAR));

			for (int i = 0; i < cchChunk; i++)
			{
				if (!IsASCIIEOP((*plpwchRun)[i]))
					pols->_rgchTemp[i] = chPassword;
				else
					pols->_rgchTemp[i] = (*plpwchRun)[i];
			}
			*plpwchRun = pols->_rgchTemp;
		}

		if(cpAccelerator != -1)
		{
			LONG cpCur = pme->GetCp();		// Get current cp

			// Does accelerator character fall in this chunk?
			if (cpCur < cpAccelerator &&
				cpCur + cchChunk > cpAccelerator)
			{
				// Yes. Reduce chunk to char just before accelerator
				cchChunk = cpAccelerator - cpCur;
			}
			// Is this character the accelerator?
			else if(cpCur == cpAccelerator)
			{							// Set chunk size to 1 since only
				cchChunk = 1;			//  want to output underlined char
				fAccelerator = TRUE;	// Tell downstream routines that
										//  we're handling accelerator
			}
		}
		if(pme->GetCF()->_dwEffects & CFE_ALLCAPS)
		{
			cchChunk = min(cchChunk, int(sizeof(pols->_rgchTemp) / sizeof(WCHAR)));
			memcpy(pols->_rgchTemp, *plpwchRun, cchChunk * sizeof(WCHAR));
			CharUpperBuff(pols->_rgchTemp, cchChunk);
			*plpwchRun = pols->_rgchTemp;
		}

		//Line Services handles page breaks in a weird way, so lets just convert to a CR.
		if (*plpwchRun && *(*plpwchRun) == FF && !f10Mode)
		{
			pols->_szAnm[0] = CR;
			*plpwchRun = pols->_szAnm;
			cchChunk = 1;
		}

		AssertSz(cpRe < ped->GetTextLength() || !ped->IsRich(),	"0-length run at end of control");
		AssertSz(cch || !ped->IsRich(),	"0-length run at end of control");

		// Set run size appropriately for any objects that are in run
		dwObjId = LimitChunk(*plpwchRun, cchChunk, f10Mode);

		// Get regular highlighted positions
		LONG cpSelMin, cpSelMost;
		ped->GetSelRangeForRender(&cpSelMin, &cpSelMost);

		if(cpSelMin != cpSelMost)
		{
			if(cpRe >= cpSelMin)
			{
				if(cpRe < cpSelMost)
				{
					// Current text falls inside selection
					cch = cpSelMost - cpRe;
					cchChunk = min(cchChunk, cch);
				}
			}
			else if(cpRe + cchChunk >= cpSelMin)
			{
				// cp < cpSelMin - run starts outside of selection.
				// Limit text to start of selection.
				cchChunk = cpSelMin - cpRe;
			}
		}
	}

	*pplsrun = pols->GetPlsrun(cpRe, pme->GetCF(), FALSE);
	*pfHidden = pols->SetLsChp(dwObjId, *pplsrun, plsChp);

	if (fAccelerator)
		plsChp->fUnderline = TRUE;

	if(!cchChunk)							// Happens in plain-text controls
	{										//  and if hidden text to end of story
		if (!ped->IsRich() && pols->_cEmit > 0)
		{
			EmitBrace(pols, plsChp, pfHidden, pcchRun, pplsrun, plpwchRun, idObjTextChp, rgchObjectEnd);
			TRACEWARNSZ("(plain)Auto-emit a close brace to make balance");
			if (pols->AddBraceCp(cpLs))
				pols->_cEmit--;
			return lserrNone;
		}
		cchChunk = 1;
		*plpwchRun = szCR;
		*pfHidden = FALSE;
		//Paragraph marks should not have any script state associated with them,
		//even if the pCF that point to does.
		ZeroMemory(&(*pplsrun)->_a, sizeof((*pplsrun)->_a));
	}
	*pcchRun = cchChunk;

	return lserrNone;
}

/*
 *	OlsGetAutoNumberInfo (pols, plskalAnm, pwchAdd, plschp, pplsrun,
 *						  pfWord95Model, pduaSpaceAnm, pduaWidthAnm)
 *	@func
 *		LineServices fetch autonumbering info callback. Return info needed
 *		by LS for auto numbering. Get the chp/run for last char from auto
 *		number run. Always say we are Word95 model Anm and get rest of info
 *		from paragraph properties.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsGetAutoNumberInfo(
	POLS	 pols,			//(IN): Client context
	LSKALIGN *plskalAnm,	//(OUT):Justification
	PLSCHP   plschpAnm,
	PLSRUN   *pplsrunAnm,
	WCHAR *	 pwchAdd,		//(OUT):char to add (Nil is treated as none)
	PLSCHP	 plsChp,		//(OUT):chp for bridge character
	PLSRUN * pplsrun,		//(OUT):Run for bridge character
	BOOL *	 pfWord95Model,	//(OUT):Type of autonumber run
	long *	 pduaSpaceAnm,	//(OUT):Relevant iff fWord95Model
	long *	 pduaWidthAnm)	//(OUT):Relevant iff fWord95Model
{
	CMeasurer *pme = pols->GetMeasurer();
	const CParaFormat *pPF = pme->Get_pPF();

	*pplsrunAnm = *pplsrun = pols->GetPlsrun(pme->GetCp(), &pols->_CFBullet, TRUE);
	pols->SetLsChp(idObjTextChp, *pplsrun, plsChp);

	if (!pme->GetNumber())
		plsChp->fUnderline = FALSE;

	*plschpAnm		= *plsChp;
	*pwchAdd		= '\t';
	*pfWord95Model	= TRUE;
	*pduaSpaceAnm	= 0;
	*pduaWidthAnm	= max(pPF->_dxOffset, pPF->_wNumberingTab);
	*plskalAnm		= (LSKALIGN)(lskalLeft + (pPF->_wNumberingStyle & 3));

	return lserrNone;
}

/*
 *	OlsGetNumericSeparators (pols, cp, plspap)
 *
 *	@func
 *		Get numeric separators needed, e.g., for decimal tabs
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsGetNumericSeparators(
	POLS	pols,			//(IN): pols
	PLSRUN	plsrun,			//(IN): Run (cp here)
	WCHAR *	pwchDecimal,	//(OUT): Decimal separator for this run
	WCHAR *	pwchThousands)	//(OUT): Thousands separator for this run
{
	LCID	lcid = plsrun->_pCF->_lcid;
	WCHAR	ch = TEXT('.');

	// This may need to be virtualized for Win95/CE...
	::GetLocaleInfo(lcid, LOCALE_SDECIMAL, &ch, 1);
	*pwchDecimal = ch;
	ch = TEXT(',');
	::GetLocaleInfo(lcid, LOCALE_STHOUSAND, &ch, 1);
	*pwchThousands = ch;

	return lserrNone;
}

							
/*
 *	OlsFetchPap (pols, cp, plspap)
 *
 *	@func
 *		Fetch paragraph properties
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsFetchPap(
	POLS	pols,		//(IN): pols
	LSCP	cpLs, 		//(IN):  an arbitrary cp value inside paragraph
	PLSPAP	plspap)		//(OUT): Paragraph properties.
{
	CMeasurer *pme = pols->GetMeasurer();
	pme->SetCp(pols->_cp);

	const CParaFormat *pPF = pme->Get_pPF();
	CTxtEdit *		   ped = pme->GetPed();

	// Default all results to 0
	ZeroMemory(plspap, sizeof(*plspap));

	//LS doesn't really care where the paragraph starts
	plspap->cpFirst = pols->_cp;

	if(plspap->cpFirst && !pme->fFirstInPara())	// Not first in para: say para
		plspap->cpFirst--;						//  starts one char earlier

	plspap->cpFirstContent = plspap->cpFirst;

	if (pPF->IsRtlPara() && !pPF->InTable())
		plspap->lstflow = lstflowWS;

	// Alignment
	plspap->lskal = (LSKALIGN) g_rgREtoTOMAlign[pPF->_bAlignment];

	if (pPF->_bAlignment == PFA_FULL_INTERWORD)
	{
		plspap->lskal = lskalLeft;
		plspap->lskj = lskjFullInterWord;
	}

	// Kind of EOP
	plspap->lskeop = ped->fUseCRLF() ? lskeopEndPara12 : lskeopEndPara1;

	if (pPF->IsRtlPara())
	{	//For Line Services, left means near and right means far.
		if (plspap->lskal == lskalLeft)
			plspap->lskal = lskalRight;
		else if (plspap->lskal == lskalRight)
			plspap->lskal = lskalLeft;
	}

	if (pols->_fCheckFit)
		plspap->lskal = lskalLeft;

	// Line breaking
	if (pPF->_bAlignment > PFA_FULL_INTERWORD || !ped->fUseSimpleLineBreak() ||
		!pme->GetPdp()->GetWordWrap())		// No word wrap
	{
		plspap->grpf |= fFmiApplyBreakingRules;
	}

	LONG dx = pPF->_dxRightIndent;

	plspap->uaRightBreak   = dx;
	plspap->uaRightJustify = dx;
	if(ped->IsInOutlineView())
	{
		plspap->uaLeft	   = lDefaultTab/2 * (pPF->_bOutlineLevel + 1);
		plspap->duaIndent  = 0;
	}
	else
	{
		plspap->uaLeft	   = pPF->_dxStartIndent + pPF->_dxOffset;
		plspap->duaIndent  = -pPF->_dxOffset;
	}

	if(!pPF->InTable() && plspap->uaLeft < 0)
		plspap->uaLeft = 0;

	// Is this a bulleted paragraph? - ignore bullets in a password
	if(pPF->_wNumbering && pme->fFirstInPara() && !pme->GetPasswordChar() &&
	   !pPF->IsNumberSuppressed())
	{
		CCcs *pccs = pme->GetCcsBullet(&pols->_CFBullet);
		if (pccs)
			pccs->Release();

		plspap->grpf |= fFmiAnm;
		WCHAR *pchAnm = pols->_szAnm;
		pols->_cchAnm = 0;

		if (pPF->IsRtlPara()) //open character
			*pchAnm++ = ' ';
		
		//FUTURE (KeithCu) we turn off Indic digits if there is any Hebrew,
		//which should be refined to do a better job with worldwide documents.
		pols->_cchAnm += pPF->NumToStr(pchAnm, pme->GetNumber(),
			(pme->GetPed()->GetCharFlags() & fHEBREW) ? 0 : fIndicDigits);
		pchAnm += pols->_cchAnm;
		
		if (pPF->IsRtlPara()) 	  //End character for reverser
		{
			*pchAnm++ = wchObjectEnd;
			pols->_cchAnm += 2;	  //alloc space for open and close
		}
		*pchAnm++ = ' ';		  //Ensure a little extra space
		*pchAnm++ = wchObjectEnd; //End character for Anm
		pols->_cchAnm += 2;
	}

	return lserrNone;
}

/*
 *	OlsFetchTabs(pols, LSCP cp, PLSTABS plstabs, BOOL *pfHangingTab,
 *				 long *pduaHangingTab, WCHAR *pwchHangingTabLeader)
 *	@func
 *		Fetch tabs
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsFetchTabs(
	POLS	pols,					//(IN):	(COls *)
	LSCP	cp,						//(IN): Arbitrary cp value inside para
	PLSTABS plstabs,				//(OUT): Tabs array
	BOOL *	pfHangingTab,			//(OUT): There is hanging tab
	long *	pduaHangingTab,			//(OUT): dua of hanging tab
	WCHAR *	pwchHangingTabLeader)	//(OUT): Leader of hanging tab
{
	CMeasurer *pme = pols->GetMeasurer();

	const CParaFormat *pPF = pme->Get_pPF();
	const char rgchTabLeader[] = {0, '.', '-', '_', '_', '='};

	LONG		cTabCount = pPF->_bTabCount;
	LONG		i, iActual;
	LSTBD *		prgTab	  = pols->_rgTab;
	const LONG *prgxTabs  = pPF->GetTabs();

	Assert(cTabCount <= MAX_TAB_STOPS && (prgxTabs || !cTabCount));

	plstabs->duaIncrementalTab = pme->GetPed()->GetDefaultTab();

	*pwchHangingTabLeader = 0;
	*pduaHangingTab = pPF->_dxStartIndent + pPF->_dxOffset;
	*pfHangingTab = (!(pPF->InTable()) && pPF->_dxOffset > 0);

	for(i = 0, iActual = 0; i < cTabCount; i++)
	{
		LONG tbAlign, tbLeader;
		pPF->GetTab(i, &prgTab[iActual].ua, &tbAlign, &tbLeader, prgxTabs);

		pme->SetUseTargetDevice(FALSE);
		if (pme->LXtoDX(prgTab[iActual].ua) > pols->_xWidth)
			break;

		if(pPF->InTable())
		{
			tbAlign = lsktLeft;				// Don't have alignment and
			tbLeader = 0;			 		//	leader yet
		}
		if(tbAlign <= tomAlignDecimal)		// Don't include tomAlignBar
		{
			prgTab[iActual].lskt = (lsktab) tbAlign;
			prgTab[iActual].wchTabLeader = rgchTabLeader[tbLeader];
			iActual++;
		}
	}

	plstabs->pTab = prgTab;
	plstabs->iTabUserDefMac = iActual;
	return lserrNone;
}

/*
 *	OlsCheckParaBoundaries (pols, cpOld, cpNew, pfChanged)
 *
 *	@func
 *		Determine if para formatting between para containing cpOld and
 *		that containing cpNew are incompatible and shouldn't be formatted
 *		on the same line when connected by hidden text.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsCheckParaBoundaries(
	POLS	pols,		//(IN): Interface object
	LONG	cpOld,		//(IN): cp in one paragraph
	LONG	cpNew,		//(IN): cp in another paragraph
	BOOL *	pfChanged)	//(OUT): "Dangerous" change between para properties
{

	// It's easier (and safer) to allow LS decide which para properties to take.
	// Else we have to close objects (BiDi, for instance) before hidden EOP.

	*pfChanged = fFalse;			// they're always compatible

	return lserrNone;
}
		
/*
 *	OlsGetRunCharWidths (pols, plrun, deviceID, lpwchRun, cwchRun, du,
 *						 kTFlow, prgDu, pduRun, plimDu)
 *	@func
 *		Get run character widths
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsGetRunCharWidths(
	POLS	  pols,			//(IN): Interface object
	PLSRUN	  plsrun,		//(IN): Run (cp here)
	enum lsdevice deviceID, //(IN): Preview, reference, or absolute
	LPCWSTR	  lpwchRun,		//(IN): Run of characters
	DWORD	  cwchRun, 		//(IN): Count of characters in run
	long	  du, 			//(IN): Available space for characters
	LSTFLOW	  kTFlow,		//(IN): Text direction and orientation
	int *	  prgDu,		//(OUT): Widths of characters
	long *	  pduRun,		//(OUT): Sum of widths in rgDx[0] to rgDu[limDx-1]
	long *	  plimDu)		//(OUT): Number of widths fetched
{
	CMeasurer *pme = pols->GetMeasurer();
	BOOL fBullet = pols->SetRun(plsrun);
	DWORD i = 0;
	LONG  xWidth, xAdjust, duCalc = 0;
	BOOL  fGlyphRun = FALSE;
	pme->SetUseTargetDevice(deviceID == lsdevReference);
	CCcs *pccs = pme->Check_pccs(fBullet);
	if(!pccs)
		return lserrOutOfMemory;

	if (pme->GetPed()->IsComplexScript() &&
		plsrun->_a.eScript && !plsrun->IsBullet())
	{
		const SCRIPT_PROPERTIES *psp = pme->Getusp()->GeteProp(plsrun->_a.eScript);
		if (psp->fComplex)
			fGlyphRun = TRUE;
	}

	xAdjust = pme->LXtoDX(plsrun->_pCF->_sSpacing);
	for(;i < cwchRun; i++, lpwchRun++)
	{
		if (!fGlyphRun)
		{
			if (IsZerowidthCharacter(*lpwchRun))
				xWidth = 0;
			else
			{
				pccs->Include(*lpwchRun, xWidth);
				xWidth =  max(xWidth + xAdjust, 1);
			}
		}
		else
		{
			xWidth = 0;
			if (!IsDiacriticOrKashida(*lpwchRun, 0))
				xWidth = pccs->_xAveCharWidth;
		}

		duCalc += xWidth;				// Keep running total of width
		*prgDu++ = xWidth;				// Store width in output array
		if(xWidth + duCalc > du)		// Width exceeds width available
		{
			i++;						// Count this char as processed
			break;
		}
	}
	*plimDu = i;						// Store total chars processed
	*pduRun = duCalc;					// Store output total width
	return lserrNone;
}

/*
 *	OlsGetRunTextMetrics (pols, plsrun, deviceID, kTFlow, plsTxMet)
 *
 *	@func
 *		Get run text metrics
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsGetRunTextMetrics(
	POLS	  pols,			//(IN): interface object
	PLSRUN	  plsrun,		//(IN): run (cp here)
	enum lsdevice deviceID, //(IN): presentation or reference
	LSTFLOW	  kTFlow,		//(IN): text direction and orientation
	PLSTXM	  plsTxMet)		//(OUT): Text metrics
{
	CMeasurer *pme = pols->GetMeasurer();
	BOOL fBullet = pols->SetRun(plsrun);

	// Make sure right font is set for run
	pme->SetUseTargetDevice(deviceID == lsdevReference);
	CCcs *pccs = pme->Check_pccs(fBullet);
	if(!pccs)
		return lserrOutOfMemory;

	LONG yFEAdjust = pccs->AdjustFEHeight(pme->fAdjustFELineHt());

	// Cache descent to save a few indirections
	LONG yDescent = pccs->_yDescent + yFEAdjust;

	// Fill in metric structure
	plsTxMet->dvAscent			= pccs->_yHeight + (yFEAdjust << 1) - yDescent;
    plsTxMet->dvDescent			= yDescent;
    plsTxMet->dvMultiLineHeight = plsTxMet->dvAscent + yDescent;
    plsTxMet->fMonospaced		= pccs->_fFixPitchFont;

	if (plsrun->_pCF->_yOffset)
	{
		LONG yOffset, yAdjust;
		pccs->GetOffset(plsrun->_pCF, deviceID == lsdevReference ? pme->GetDyrInch() :
					    pme->GetDypInch(), &yOffset, &yAdjust);

		if (yOffset < 0)
			plsTxMet->dvDescent -= yOffset;
		else
			plsTxMet->dvAscent += yOffset;
		
	}

	return lserrNone;
}

/*
 *	OlsGetRunUnderlineInfo (pols, plsrun, pcheights, kTFlow, plsStInfo)
 *
 *	@func
 *		Get run underline info
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsGetRunUnderlineInfo(
	POLS	  pols,			//(IN): Interface object
	PLSRUN	  plsrun,		//(IN): Run (cp here)
	PCHEIGHTS pcheights,	//(IN): Height of line
	LSTFLOW	  kTFlow,		//(IN): Text direction and orientation
	PLSULINFO plsUlInfo)	//(OUT): Underline information
{
	CMeasurer *pme = pols->GetMeasurer();
	BOOL	   fBullet = pols->SetRun(plsrun);

	// Initialize output buffer
	ZeroMemory(plsUlInfo, sizeof(*plsUlInfo));
	//REVIEW KeithCu

	// Make sure right font is set for run
	CCcs *pccs = pme->Check_pccs(fBullet);
	if(!pccs)
		return lserrOutOfMemory;

	long dvpUlOffset = pccs->_dyULOffset;

	plsUlInfo->cNumberOfLines = 1;

	// Set underline type
	if (plsrun->_pCF->_dwEffects & CFE_LINK)
		plsUlInfo->kulbase = CFU_UNDERLINE;
	else if (plsrun->_pCF->_dwEffects & (CFE_UNDERLINE | CFE_REVISED))
		plsUlInfo->kulbase	= plsrun->_pCF->_bUnderlineType;
	else
	{
		Assert(pme->GetPed()->GetCpAccelerator() == plsrun->_cp);
		plsUlInfo->kulbase = CFU_UNDERLINE;
	}

	LONG yDescent = pccs->_yDescent + pccs->AdjustFEHeight(pme->fAdjustFELineHt());

	// Some fonts report invalid offset so we fix it up here
	//BUGBUG: subscripts with Line Services don't display.
	if(dvpUlOffset >= yDescent)
		dvpUlOffset = yDescent - 1;

	plsUlInfo->dvpFirstUnderlineOffset = dvpUlOffset;
	plsUlInfo->dvpFirstUnderlineSize   = pccs->_dyULWidth;

	return lserrNone;
}

/*
 *	OlsGetRunStrikethroughInfo (pols, plsrun, pcheights, kTFlow, plsStInfo)
 *
 *	@func
 *		Get run strikethrough info
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsGetRunStrikethroughInfo(
	POLS	  pols,			//(IN): interface object
	PLSRUN	  plsrun,		//(IN): run
	PCHEIGHTS pcheights,	//(IN): height of line
	LSTFLOW	  kTFlow,		//(IN): text direction and orientation
	PLSSTINFO plsStInfo)	//(OUT): Strikethrough information
{
	CMeasurer *pme = pols->GetMeasurer();
	BOOL fBullet = pols->SetRun(plsrun);

	AssertSz(plsrun->_pCF->_dwEffects & CFE_STRIKEOUT, "no strikeout");

	// Make sure right font is set for run
	CCcs *pccs = pme->Check_pccs(fBullet);
	if(!pccs)
		return lserrOutOfMemory;

	// Default number of lines
	plsStInfo->cNumberOfLines = 1;
	plsStInfo->dvpLowerStrikethroughOffset = -pccs->_dySOOffset;
	plsStInfo->dvpLowerStrikethroughSize   = pccs->_dySOWidth;

	return lserrNone;
}


/*	OlsDrawUnderline (pols, plsrun, kUlbase, pptStart, dupUL, dvpUL,
 *					  kTFlow, kDisp, prcClip)
 *	@func
 *		Draw underline
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsDrawUnderline(
	POLS		pols,		//(IN): interface object
	PLSRUN		plsrun,		//(IN): run (cp) to use for underlining
	UINT		kUlbase,	//(IN): underline kind
	const POINT *pptStart,	//(IN): starting position (top left)
	DWORD		dupUL,		//(IN): underline width
	DWORD		dvpUL,		//(IN): underline thickness
	LSTFLOW		lstflow,	//(IN): text direction and orientation
	UINT		kDisp,		//(IN): display mode - opaque, transparent
	const RECT *prcClip)	//(IN): clipping rectangle
{
	CRenderer *pre = pols->GetRenderer();
	Assert(pre->IsRenderer());

	pols->SetRun(plsrun);
	pre->Check_pccs();

	pre->SetSelected(plsrun->IsSelected());
	pre->SetFontAndColor(plsrun->_pCF);

	pre->SetupUnderline(kUlbase);
	pre->RenderUnderline(lstflow == lstflowWS ? pptStart->x - dupUL - 1:
						 pptStart->x, pptStart->y, dupUL, dvpUL);

	return lserrNone;
}

/*
 *	OlsDrawStrikethrough (pols, plsrun, kStbase, pptStart, dupSt, dvpSt,
 *						  kTFlow, kDisp, prcClip)
 *	@func
 *		Draw strikethrough
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsDrawStrikethrough(
	POLS		pols,		//(IN): Interface object
	PLSRUN		plsrun,		//(IN): run (cp) for strikethrough
	UINT		kStbase,	//(IN): strikethrough kind
	const POINT *pptStart,	//(IN): starting position (top left)
	DWORD		dupSt,		//(IN): strikethrough width
	DWORD		dvpSt,		//(IN): strikethrough thickness
	LSTFLOW		lstflow,	//(IN): text direction and orientation
	UINT		kDisp,		//(IN): display mode - opaque, transparent
	const RECT *prcClip)	//(IN): clipping rectangle
{
	CRenderer *pre = pols->GetRenderer();
	Assert(pre->IsRenderer());

	pols->SetRun(plsrun);
	pre->SetSelected(plsrun->IsSelected());

	pre->RenderStrikeOut(lstflow == lstflowWS ? pptStart->x - dupSt - 1:
						 pptStart->x, pptStart->y, dupSt, dvpSt);

	return lserrNone;
}


/*
 *	OlsFInterruptUnderline(pols, plsrunFirst, cpLastFirst, plsrunSecond,
 *						   cpStartSecond, pfInterruptUnderline)
 *	@func
 *		Says whether client wants to interrupt drawing of underline
 *		between the first and second runs
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsFInterruptUnderline(
	POLS   pols,				//(IN): Client context
	PLSRUN plsrunFirst,			//(IN): Run pointer for previous run
	LSCP   cpLastFirst,			//(IN): cp of last character of previous run
	PLSRUN plsrunSecond,		//(IN): Run pointer for current run
	LSCP   cpStartSecond,		//(IN): cp of first character of current run
	BOOL * pfInterruptUnderline)//(OUT): Interrupt underline between runs?
{
	CRenderer *pre = pols->GetRenderer();
	Assert(pre->IsRenderer());

	pre->SetSelected(FALSE); //Selection is handled below

	COLORREF cr = pre->GetTextColor(plsrunFirst->_pCF);

	// Interrupt underline if run text colors differ
	*pfInterruptUnderline = cr != pre->GetTextColor(plsrunSecond->_pCF) ||
							plsrunFirst->IsSelected() != plsrunSecond->IsSelected();
	return lserrNone;
}

/*
 *	OlsDrawTextRun (pols, plsrun, kStbase, pptStart, dupSt, dvpSt,
 *						  kTFlow, kDisp, prcClip)
 *	@func
 *		Draw text run
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsDrawTextRun(
	POLS		pols,			//(IN): Interface object
	PLSRUN		plsrun,			//(IN): Run (cp) to use for text
	BOOL		fStrikeoutOkay, //(IN): TRUE <==> allow strikeout
	BOOL		fUnderlineOkay, //(IN): TRUE <==> allow underlining
	const POINT *ppt, 			//(IN): Starting position
	LPCWSTR		pwchRun, 		//(IN): Run of characters
	const int *	rgDupRun, 		//(IN): Character widths
	DWORD		cwchRun, 		//(IN): Count of chars in run
	LSTFLOW		lstflow,		//(IN): Text direction and orientation
	UINT		kDisp,			//(IN): Display mode - opaque, transparent
	const POINT *pptRun,		//(IN): Starting point of run
	PCHEIGHTS	pheightsPres, 	//(IN): Presentation heights for run
	long		dupRun, 		//(IN): Presentation width for run
	long		dupUlLimRun,	//(IN): Underlining limit
	const RECT *prcClip)		//(IN): Clipping rectangle
{
	CRenderer  *pre = pols->GetRenderer();
	RECT		rc = *prcClip;
	Assert(pre->IsRenderer());

	// Set up drawing point and options
	BOOL fBullet = pols->SetRun(plsrun);
	CCcs *pccs = pre->Check_pccs(fBullet);
	if(!pccs)
		return lserrOutOfMemory;

	// y needs to be moved from baseline to top of character
	POINT pt = {ppt->x, ppt->y - (pccs->_yHeight - pccs->_yDescent)};

	if (lstflow == lstflowWS)
		pt.x -= dupRun - 1;

	pre->SetSelected(plsrun->IsSelected());
	pre->SetFontAndColor(plsrun->_pCF);

	if(!fBullet && pre->fBackgroundColor())
	{
		kDisp = ETO_OPAQUE | ETO_CLIPPED;

		POINT ptCur = pre->GetCurPoint();
		ptCur.x = pt.x;
		pre->SetCurPoint(ptCur);
		pre->SetClipLeftRight(dupRun);
		rc = pre->GetClipRect();
	}
	else if (cwchRun == 1 && pwchRun[0] == ' ') //Don't waste time drawing a space.
		return lserrNone;						//(helps grid perf test a lot)

	pre->RenderExtTextOut(pt.x, pt.y, kDisp, &rc, pwchRun, cwchRun, rgDupRun);

	return lserrNone;
}

/*
 *	GetBreakingClasses (pols, plsrun, ch, pbrkclsBefore, pbrkclsAfter)
 *
 *	@func
 *		Line services calls this callback for each run, to obtain the
 *		breaking classes (line breaking behaviors) for each character
 *
 *	    For Quill and RichEdit, the breaking class of a character is
 *		independent of whether it occurs Before or After a break opportunity.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsGetBreakingClasses(
	POLS	pols,			//(IN): Interface object
	PLSRUN	plsrun,			//(IN): Run (cp) to use for text
	LSCP	cpLs,				//(IN): cp of the character
	WCHAR	ch, 			//(IN): Char to return breaking classes for
	BRKCLS *pbrkclsBefore,	//(OUT): Breaking class if ch is lead char in pair
	BRKCLS *pbrkclsAfter)	//(OUT): Breaking class if ch is trail char in pair
{
	long 		cpRe = pols->GetCpReFromCpLs(cpLs);
	CMeasurer 	*pme = pols->GetMeasurer();
	CTxtBreaker *pbrk = pme->GetPed()->_pbrk;

	// Get line breaking class and report it twice
	*pbrkclsBefore = *pbrkclsAfter = (pbrk && pbrk->CanBreakCp(BRK_WORD, cpRe)) ?
									brkclsOpen :
									GetKinsokuClass(ch);
	return lserrNone;
}

/*
 *	OlsFTruncateBefore (pols, cpCur, wchCur, durCur, cpPrev, wchPrev,
 *						durPrev, durCut, pfTruncateBefore)
 *	@func
 *		Line services support function. This should always return
 *		FALSE for best performance
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsFTruncateBefore(
	POLS	pols,				// (IN): Client context
	PLSRUN  plsrunCur,			// (IN): PLSRUN of cp
	LSCP	cpCur,				// (IN): cp of truncation char
	WCHAR	wchCur,				// (IN): Truncation character
	long	durCur,				// (IN): Width of truncation char
	PLSRUN	plsrunPrev,			// (IN): PLSRUN of cpPrev
	LSCP	cpPrev,				// (IN): cp of truncation char
	WCHAR	wchPrev,			// (IN): Truncation character
	long	durPrev,			// (IN): Width of truncation character
	long	durCut,				// (IN): Width from RM until end of current char
	BOOL *	pfTruncateBefore)	// (OUT): Truncation point is before this char
{
	*pfTruncateBefore = FALSE;
	return lserrNone;
}

/*
 *	OlsCanBreakBeforeChar (pols, brkcls, pcond)
 *
 *	@func
 *		Line services calls this callback for a break candidate following an
 *		inline object, to determine whether breaks are prevented, possible or
 *		mandatory
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsCanBreakBeforeChar(
	POLS	pols,		//(IN): Client context
	BRKCLS	brkcls,		//(IN): Breaking class
	BRKCOND *pcond) 	//(OUT): Corresponding break condition
{
	switch (brkcls)
	{
	default:
		*pcond = brkcondCan;
		break;

	case brkclsClose:
	case brkclsNoStartIdeo:
	case brkclsExclaInterr:
	case brkclsGlueA:
		*pcond = brkcondNever;
		break;

	case brkclsIdeographic:
	case brkclsSpaceN:
	case brkclsSlash:
		*pcond = brkcondPlease;	
		break;
	};
	return lserrNone;
}

/*
 *	OlsCanBreakAfterChar (pols, brkcls, pcond)
 *
 *	@func
 *		Line services calls this callback for a break candidate preceding an
 *		inline object, to determine whether breaks are prevented, possible or
 *		mandatory
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsCanBreakAfterChar(
	POLS	pols,		//(IN): Client context
	BRKCLS	brkcls,		//(IN): Breaking class
	BRKCOND *pcond) 	//(OUT): Corresponding break condition
{
	switch (brkcls)
	{
	default:
		*pcond = brkcondCan;
		break;

	case brkclsOpen:
	case brkclsGlueA:
		*pcond = brkcondNever;
		break;

	case brkclsIdeographic:
	case brkclsSpaceN:
	case brkclsSlash:
		*pcond = brkcondPlease;	
		break;
	};
	return lserrNone;
}

/*
 *	OlsFInterruptShaping (pols, kTFlow, plsrunFirst, plsrunSecond, pfInterruptShaping)
 *
 *	@func
 *		Line services calls this callback to find out if you
 *		would like to ligate across these two runs.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsFInterruptShaping(
	POLS	pols,					//(IN): Client context
	LSTFLOW	kTFlow,					//(IN): Text direction and orientation
	PLSRUN	plsrunFirst,			//(IN): Run #1
	PLSRUN	plsrunSecond,			//(IN): Run #2
	BOOL	*pfInterruptShaping)	//(OUT): Shape across these 2 runs?
{
	*pfInterruptShaping = FALSE;

	const CCharFormat* pCFFirst = plsrunFirst->_pCF;
	const CCharFormat* pCFSecond = plsrunSecond->_pCF;

	Assert (plsrunFirst->_a.eScript && plsrunSecond->_a.eScript);

	const DWORD dwMask = CFE_BOLD | CFE_ITALIC | CFM_SUBSCRIPT;

	if (pCFFirst == pCFSecond ||
		(plsrunFirst->_a.eScript == plsrunSecond->_a.eScript &&
		!((pCFFirst->_dwEffects ^ pCFSecond->_dwEffects) & dwMask) &&
		pCFFirst->_iFont == pCFSecond->_iFont &&
		pCFFirst->_yOffset == pCFSecond->_yOffset &&
		pCFFirst->_yHeight == pCFSecond->_yHeight))
	{
		// establish link
		plsrunFirst->_pNext = plsrunSecond;
		return lserrNone;
	}

	*pfInterruptShaping = TRUE;
	return lserrNone;
}


// LS calls this callback to shape the codepoint string to a glyph indices string
// for handling glyph based script such as Arabic, Hebrew and Thai.
//
LSERR OlsGetGlyphs(
	POLS 		pols,
	PLSRUN	 	plsrun,
	LPCWSTR		pwch,
	DWORD		cch,
	LSTFLOW		kTFlow,
	PGMAP		pgmap,				// OUT: array of logical cluster information
	PGINDEX*	ppgi, 				// OUT: array of output glyph indices
	PGPROP*		ppgprop, 			// OUT: array of glyph's properties
	DWORD*		pcgi)				// OUT: number of glyph generated
{
	pols->SetRun(plsrun);

	CMeasurer*		pme = pols->GetMeasurer();
	CUniscribe* 	pusp = pme->Getusp();
	Assert (pusp);

	WORD*			pwgi;
	SCRIPT_VISATTR *psva;
	int				cgi;

	pme->SetGlyphing(TRUE);

	// Glyphing doesn't care about the target device but always
	// using target device reduces creation of Cccs in general.
	pme->SetUseTargetDevice(TRUE);

	AssertSz(IN_RANGE(1, plsrun->_a.eScript, SCRIPT_MAX_COUNT - 1), "Bad script ID!");

	// Digit substitution
	pusp->SubstituteDigitShaper(plsrun, pme);

	if (!(cgi = (DWORD)pusp->ShapeString(plsrun, &plsrun->_a, pme, pwch, (int)cch, pwgi, pgmap, psva)))
	{
		const SCRIPT_ANALYSIS	saUndef = {SCRIPT_UNDEFINED,0,0,0,0,0,0,{0}};

		// Current font cant shape given string.
		// Try SCRIPT_UNDEF so it generates invalid glyphs
		if (!(cgi = (DWORD)pusp->ShapeString(plsrun, (SCRIPT_ANALYSIS*)&saUndef, pme, pwch, (int)cch, pwgi, pgmap, psva)))
		{
			// For whatever reason we still fails.
			// Abandon glyph processing.
			plsrun->_a.fNoGlyphIndex = TRUE;
			cgi = (DWORD)pusp->ShapeString(plsrun, &plsrun->_a, pme, pwch, (int)cch, pwgi, pgmap, psva);
		}
	}

	*pcgi = cgi;

	DupShapeState(plsrun, cch);

	*ppgi = (PGINDEX)pwgi;
	*ppgprop = (PGPROP)psva;
	pme->SetGlyphing(FALSE);
	return lserrNone;
}

// LS calls this callback to find out glyph positioning for complex scripts
//
LSERR OlsGetGlyphPositions(
	POLS		pols,
	PLSRUN		plsrun,
	LSDEVICE	deviceID,
	LPWSTR		pwch,
	PCGMAP		pgmap,
	DWORD		cch,
	PCGINDEX	pgi,
	PCGPROP		pgprop,
	DWORD		cgi,
	LSTFLOW		kTFlow,
	int*		pgdx,				// OUT: array of glyph advanced width
	PGOFFSET	pgduv)				// OUT: array of offset between glyphs
{
	pols->SetRun(plsrun);

	CMeasurer*		pme = pols->GetMeasurer();
	CUniscribe* 	pusp = pme->Getusp();
	Assert (pusp);
	Assert(pgduv);
	pme->SetGlyphing(TRUE);

	// zero out before passing to shaping engine
	ZeroMemory ((void*)pgduv, cgi*sizeof(GOFFSET));

	pme->SetUseTargetDevice(deviceID == lsdevReference);

	AssertSz(IN_RANGE(1, plsrun->_a.eScript, SCRIPT_MAX_COUNT - 1), "Bad script ID!");

	if (!pusp->PlaceString(plsrun, &plsrun->_a, pme, pgi, cgi, (const SCRIPT_VISATTR*)pgprop, pgdx, pgduv, NULL))
	{
		SCRIPT_ANALYSIS	saUndef = {SCRIPT_UNDEFINED,0,0,0,0,0,0,{0}};

		if (!pusp->PlaceString(plsrun, &saUndef, pme, pgi, cgi, (const SCRIPT_VISATTR*)pgprop, pgdx, pgduv, NULL))
		{
			plsrun->_a.fNoGlyphIndex = TRUE;
			pusp->PlaceString(plsrun, &plsrun->_a, pme, pgi, cgi, (const SCRIPT_VISATTR*)pgprop, pgdx, pgduv, NULL);
		}
	}

	DupShapeState(plsrun, cch);

	pme->SetGlyphing(FALSE);
	return lserrNone;
}

LSERR OlsDrawGlyphs(
	POLS			pols,
	PLSRUN			plsrun,
	BOOL			fStrikeOut,
	BOOL			fUnderline,
	PCGINDEX		pcgi,
	const int*		pgdx,			// array of glyph width
	const int*		pgdxo,			// array of original glyph width (before justification)
	PGOFFSET		pgduv,			// array of glyph offset
	PGPROP			pgprop,			// array of glyph's properties
	PCEXPTYPE		pgxtype,		// array of expansion type
	DWORD			cgi,
	LSTFLOW			kTFlow,
	UINT			kDisp,
	const POINT*	pptRun,
	PCHEIGHTS		pHeight,
	long			dupRun,
	long			dupLimUnderline,
	const RECT*		prectClip)
{
	BOOL			fBullet = pols->SetRun(plsrun);
	CRenderer*		pre = pols->GetRenderer();
	CUniscribe* 	pusp = pre->Getusp();
	Assert(pusp && pre->IsRenderer());
	pre->SetGlyphing(TRUE);

	RECT			rc = *prectClip;
	CCcs* 			pccs = pre->Check_pccs(fBullet);

	if (!pccs)
		return lserrOutOfMemory;

	// Apply fallback font if we need to
	if (!fBullet)
		pccs = pre->ApplyFontCache(plsrun->IsFallback());

	pre->SetSelected(plsrun->IsSelected());
	pre->SetFontAndColor(plsrun->_pCF);

	// y needs to be moved from baseline to top of character
	POINT 			pt = {pptRun->x, pptRun->y - (pccs->_yHeight - pccs->_yDescent)};

	if (kTFlow == lstflowWS)
		pt.x -= dupRun - 1;	
	
	if(!fBullet && pre->fBackgroundColor())
	{
		kDisp = ETO_OPAQUE | ETO_CLIPPED;

		POINT ptCur = pre->GetCurPoint();
		ptCur.x = pt.x;
		pre->SetCurPoint(ptCur);
		pre->SetClipLeftRight(dupRun);
		rc = pre->GetClipRect();
	}

	if (rc.left == rc.right)
		goto Exit;

	if (pre->GetPdp()->IsMetafile() && !IsEnhancedMetafileDC(pre->GetDC()))
	{
		// -WMF metafile handling-
		//
		//     If the rendering device is WMF metafile. We metafile the codepoint array
		// instead of glyph indices. This requires that the target OS must know how to
		// playback complex script text (shaping, Bidi algorithm, etc.).
		//     Metafiling glyph indices only works for EMF since the WMF's META_EXTTEXTOUT
		// record stores the input string as an array of byte but a glyph index is 16-bit
		// word element.
		//     WMF also must NOT be used to record ExtTextOutW call otherwise the Unicode
		// string will be converted to mutlibyte text using system codepage. Anything
		// outside the codepage then becomes '?'.
		//     We have the workaround for such case in REExtTextOut to make sure we only
		// metafile ExtTextOutA to WMF. (wchao)
		//
	
		LONG			cch;
		const WCHAR*	pwch = pre->GetPch(cch);
		PINT			piDx;
	
		cch = min(cch, pre->GetCchLeftRunCF());
		cch = min(cch, pre->GetLine()._cch - plsrun->_cp + pols->_cp);

		// make sure that we record ETO with proper reading order.
		kDisp |= plsrun->_a.fRTL ? ETO_RTLREADING : 0;

		if (pusp->PlaceMetafileString(plsrun, pre, pwch, (int)cch, &piDx))
		{
			pre->RenderExtTextOut(pt.x, pt.y, kDisp, &rc, pwch, cch, piDx);
			goto Exit;
		}

		TRACEERRORSZ("Recording metafile failed!");

		// Fall through... with unexpected error

		// Else, metafile glyph indices for EMF...
	}

	//This is duplicated from RenderExtTextOut but the params are different so simplest solution
	//was to copy code.
	if(pre->_fDisabled)
	{
		if(pre->_crForeDisabled != pre->_crShadowDisabled)
		{
			// The shadow should be offset by a hairline point, namely
			// 3/4 of a point.  Calculate how big this is in device units,
			// but make sure it is at least 1 pixel.
			DWORD offset = MulDiv(3, pre->_dypInch, 4*72);
			offset = max(offset, 1);

			// Draw shadow
			pre->SetTextColor(pre->_crShadowDisabled);
					
			ScriptTextOut(pre->GetDC(), &pccs->_sc, pt.x + offset, pt.y + offset, kDisp, &rc, &plsrun->_a,
				NULL, 0, pcgi, (int)cgi, pgdx, NULL, pgduv);

			// Now set drawing mode to transparent
			kDisp &= ~ETO_OPAQUE;
		}
		pre->SetTextColor(pre->_crForeDisabled);
	}

	ScriptTextOut(pre->GetDC(), &pccs->_sc, pt.x, pt.y, kDisp, &rc, &plsrun->_a,
				NULL, 0, pcgi, (int)cgi, pgdx, NULL, pgduv);

Exit:
	if (!fBullet)
		pre->ApplyFontCache(0);		// reset font fallback if any

	pre->SetGlyphing(FALSE);
	return lserrNone;
}


/*
 *	OlsResetRunContents (pols, brkcls, pcond)
 *
 *	@func
 *		Line Services calls this routine when a ligature
 *		extends across run boundaries.
 *
 *		We don't have to do anything special here if we are
 *		careful about how we use our PLSRUNs.
 *	@rdesc
 *		LSERR
 */
 LSERR WINAPI OlsResetRunContents(
 	POLS 	pols,		//(IN): Client context
 	PLSRUN 	plsrun,		//(IN): Run being combined
 	LSCP 	cpFirstOld, //(IN): cp of the first run being combined
 	LSDCP 	dcpOld,		//(IN):	dcp of the first run being combined
 	LSCP 	cpFirstNew, //(IN): new cp of the run
 	LSDCP 	dcpNew)		//(IN): new dcp of the run
{
	return lserrNone;
}

/*
 *	OlsCheckForDigit (pols, cp, plspap)
 *
 *	@func
 *		Get numeric separators needed, e.g., for decimal tabs
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsCheckForDigit(
	POLS	pols,		//(IN): pols
	PLSRUN	plsrun,		//(IN): Run (cp here)
	WCHAR	wch,		//(IN): Character to check
	BOOL *	pfIsDigit)	//(OUT): This character is digit
{
	WORD	wType;

	// We could get the run LCID to use for the first parm in the following
	// call, but the digit property should be independent of LCID.
	W32->GetStringTypeEx(0, CT_CTYPE1, &wch, 1, &wType);
	*pfIsDigit = (wType & C1_DIGIT) != 0;

	return lserrNone;
}

/*
 *	OlsGetBreakThroughTab(pols, uaRightMargin, uaTabPos, puaRightMarginNew)
 *
 *	@func
 *		Just follow word95 behavior.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsGetBreakThroughTab(
	POLS	pols,				//(IN): client context
	long	uaRightMargin,		//(IN): right margin for breaking
	long	uaTabPos,			//(IN): breakthrough tab position
	long *	puaRightMarginNew)	//(OUT): new right margin
{
	*puaRightMarginNew = 20 * 1440;
	return lserrNone;
}

/*
 *	OlsFGetLastLineJustification(pols, lskj, endr, pfJustifyLastLine)
 *
 *	@func
 *		Just say no to justify last line.	
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsFGetLastLineJustification(
	POLS	pols,				//(IN): client context
	LSKJUST lskj,				//(IN): kind of justification
	LSKALIGN lskal,				//(IN): kind of alignment
	ENDRES	endr,				//(IN): result of formatting
	BOOL	*pfJustifyLastLine,	//(OUT): should last line be fully justified
	LSKALIGN *plskalLine)		//(OUT): kind of alignment for this line
{
	*pfJustifyLastLine = FALSE;
	*plskalLine = lskal;
	return lserrNone;
}

/*
 *	OlsGetHyphenInfo(pols, plsrun, pkysr, pwchYsr)
 *
 *	@func
 *		We don't support fancy YSR types, tell LS so.	
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsGetHyphenInfo(
	POLS	pols,				//(IN): client context
	PLSRUN	plsrun,				//(IN)
	DWORD*	pkysr,				//(OUT): Ysr type - see "lskysr.h"
	WCHAR*	pwchYsr)			//(OUT): Character code of YSR
{
	*pkysr = kysrNil;
	*pwchYsr = 0;	
	return lserrNone;
}

/*
 *	OlsReleaseRun (pols, plsrun)
 *
 *	@func
 *		We do nothing because the run is in an array and is
 *		released automatically.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsReleaseRun(
	POLS	pols,	//(IN): interface object
	PLSRUN	plsrun)	//(IN): run (cp) to use for underlining
{
	return lserrNone;
}

/*
 * 	OlsNewPtr(pols, cBytes)
 *
 *	@func
 *		Memory allocator.
 */
void* WINAPI OlsNewPtr(
	POLS	pols,		//@parm Not used
	DWORD	cBytes)		//@parm Count of bytes to alloc
{
	return PvAlloc(cBytes, 0);
}

/*
 * 	OlsDisposePtr(pols, pv)
 *
 *	@func
 *		Memory deallocator.
 */
void WINAPI OlsDisposePtr(
	POLS	pols,		//@parm Not used
	void *	pv)			//@parm [in]: ptr to free
{
	FreePv(pv);
}

/*
 * 	OlsDisposePtr(pols, pv, cBytes)
 *
 *	@func
 *		Memory reallocator.
 */
void* WINAPI OlsReallocPtr(
	POLS	pols,		//@parm Not used
	void *	pv, 		//@parm [in/out]: ptr to realloc
	DWORD	cBytes)		//@parm Count of bytes to realloc
{
	return PvReAlloc(pv, cBytes);
}
const REVERSEINIT reverseinit =
{
	REVERSE_VERSION,
	wchObjectEnd
};

LSERR WINAPI OlsGetObjectHandlerInfo(POLS pols, DWORD idObj, void* pObjectInfo)
{
	switch (idObj)
	{
	case OBJID_REVERSE:
		memcpy(pObjectInfo, (void *)&reverseinit, sizeof(REVERSEINIT));
		break;
	default:
		AssertSz(0, "Undefined Object handler. Add missing case.");
	}
	return lserrNone;
}

#ifdef DEBUG
/* Debugging APIs */
void WINAPI OlsAssertFailed(
	char *sz,
	char *szFile,
	int	  iLine)
{
	AssertSzFn(sz, szFile, iLine);
}
#endif


extern const LSCBK lscbk =
{
	OlsNewPtr,					// pfnNewPtr
	OlsDisposePtr,				// pfnDisposePtr
	OlsReallocPtr,				// pfnReallocPtr
	OlsFetchRun,				// pfnFetchRun
	OlsGetAutoNumberInfo,		// pfnGetAutoNumberInfo
	OlsGetNumericSeparators,	// pfnGetNumericSeparators
	OlsCheckForDigit,			// pfnCheckForDigit
	OlsFetchPap,				// pfnFetchPap
	OlsFetchTabs,				// pfnFetchTabs
	OlsGetBreakThroughTab,		// pfnGetBreakThroughTab
	OlsFGetLastLineJustification,// pfnFGetLastLineJustification
	OlsCheckParaBoundaries,		// pfnCheckParaBoundaries
	OlsGetRunCharWidths,		// pfnGetRunCharWidths
	0,							// pfnCheckRunKernability
	0,							// pfnGetRunCharKerning
	OlsGetRunTextMetrics,		// pfnGetRunTextMetrics
	OlsGetRunUnderlineInfo,		// pfnGetRunUnderlineInfo
	OlsGetRunStrikethroughInfo,	// pfnGetRunStrikethroughInfo
	0,							// pfnGetBorderInfo
	OlsReleaseRun,				// pfnReleaseRun
	0,							// pfnHyphenate
	OlsGetHyphenInfo,			// pfnGetHyphenInfo
	OlsDrawUnderline,			// pfnDrawUnderline
	OlsDrawStrikethrough,		// pfnDrawStrikethrough
	0,							// pfnDrawBorder
	0,							// pfnDrawUnderlineAsText //REVIEW (keithcu) Need to implement this??
	OlsFInterruptUnderline,		// pfnFInterruptUnderline
	0,							// pfnFInterruptShade
	0,							// pfnFInterruptBorder
	0,							// pfnShadeRectangle
	OlsDrawTextRun,				// pfnDrawTextRun
	0,							// pfnDrawSplatLine
	OlsFInterruptShaping,		// pfnFInterruptShaping
	OlsGetGlyphs,				// pfnGetGlyphs
	OlsGetGlyphPositions,		// pfnGetGlyphPositions
	OlsResetRunContents,		// pfnResetRunContents
	OlsDrawGlyphs,				// pfnDrawGlyphs
	0,							// pfnGetGlyphExpansionInfo
	0,							// pfnGetGlyphExpansionInkInfo
	0,							// pfnGetEms
	0,							// pfnPunctStartLine
	0,							// pfnModWidthOnRun
	0,							// pfnModWidthSpace
	0,							// pfnCompOnRun
	0,							// pfnCompWidthSpace
	0,							// pfnExpOnRun
	0,							// pfnExpWidthSpace
	0,							// pfnGetModWidthClasses
	OlsGetBreakingClasses,		// pfnGetBreakingClasses
	OlsFTruncateBefore,			// pfnFTruncateBefore
	OlsCanBreakBeforeChar,		// pfnCanBreakBeforeChar
	OlsCanBreakAfterChar,		// pfnCanBreakAfterChar
	0,							// pfnFHangingPunct
	0,							// pfnGetSnapGrid
	0,							// pfnDrawEffects
	0,							// pfnFCancelHangingPunct
	0,							// pfnModifyCompAtLastChar
	0,							// pfnEnumText
	0,							// pfnEnumTab
	0,							// pfnEnumPen
	OlsGetObjectHandlerInfo,	// pfnGetObjectHandlerInfo
#ifdef DEBUG
	OlsAssertFailed				// pfnAssertFailed
#else
	0							// pfnAssertFailed
#endif
};

#endif // LINESERVICES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\propchg.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	PROPCHG.CPP	-- Property Change Notification Routines |
 *	
 *	Original Author: <nl>
 *		Rick Sailor
 *
 *	History: <nl>
 *		9/5/95  ricksa  Created and documented
 *
 *	Documentation is generated straight from the code.  The following
 *	date/time stamp indicates the version of code from which the
 *	the documentation was generated.
 *
 *	Copyright (c) 1995-1997 Microsoft Corporation. All rights reserved.
 */
#include "_common.h"
#include "_edit.h"
#include "_dispprt.h"
#include "_dispml.h"
#include "_dispsl.h"
#include "_select.h"
#include "_text.h"
#include "_runptr.h"
#include "_font.h"
#include "_measure.h"
#include "_render.h"
#include "_urlsup.h"

ASSERTDATA

CTxtEdit::FNPPROPCHG CTxtEdit::_fnpPropChg[MAX_PROPERTY_BITS];

/* 
 *	CTxtEdit::UpdateAccelerator()
 *
 *	@mfunc
 *		Get accelerator cp from host
 *
 *	@rdesc
 *		HRESULT
 *
 *	@devnote:
 *		The point of this is to leave the accelerator offset unchanged
 *		in the face of an error from the host.
 */
HRESULT CTxtEdit::UpdateAccelerator()
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::UpdateAccelerator");
	LONG	cpAccel;
	HRESULT hr = _phost->TxGetAcceleratorPos(&cpAccel);

	if(SUCCEEDED(hr))
	{
		// It worked so reset our value
		AssertSz(cpAccel < 32768,
			"CTxtEdit::UpdateAccelerator: cp too large");
		_cpAccelerator = cpAccel;
	}
	return hr;
}

/* 
 *	CTxtEdit::HandleRichToPlainConversion()
 *
 *	@mfunc
 *		Convert a rich text object to a plain text object
 */
void CTxtEdit::HandleRichToPlainConversion()
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::HandleRichToPlainConversion");

	// Notify every interested party that they should dump their formatting
	_nm.NotifyPreReplaceRange(NULL, CONVERT_TO_PLAIN, 0, 0, 0, 0);

	// Set _fRich to false so we can delete the final CRLF.
	_fRich = 0;
	_fSelChangeCharFormat = 0;

//	if(_pdetecturl)
//	{
//		delete _pdetecturl;
//		_pdetecturl = NULL;
//	}

	// Tell document to dump its format runs
	_story.DeleteFormatRuns();

	// Clear out the ending CRLF
	CRchTxtPtr rtp(this, 0);
	rtp.ReplaceRange(GetTextLength(), 0, NULL, NULL, -1);

}

/* 
 *	CTxtEdit::OnRichEditChange (fPropertyFlag)
 *
 *	@mfunc
 *		Notify text services that rich-text property changed
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT CTxtEdit::OnRichEditChange(
	BOOL fPropertyFlag)		//@parm New state of richedit flag
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnRichEditChange");

	// Calculate length of empty document. Remember that multiline rich text
	// controls always have and end of paragraph marker.
	LONG cchEmptyDoc = cchCR;
	CFreezeDisplay	fd(_pdp);	// defer screen update until we finish the change.

	if(!_fRich)
		cchEmptyDoc = 0;
	else if(_f10Mode)
		cchEmptyDoc = cchCRLF;

	// This can only be changed if there is no text and nothing to undo.
	// It makes no sense to change when there is already text. This is
	// particularly true of going from rich to plain. Further, what would
	// you do with the undo state?
	if(GetTextLength() == cchEmptyDoc && (!_pundo || !_pundo->CanUndo()))
	{
#ifdef DEBUG
		// Make sure that document is in a sensible state.
		if(_fRich)
		{
			CTxtPtr	tp(this, 0);
			WCHAR	szBuf[cchCRLF];

			tp.GetText(cchCRLF, &szBuf[0]);
			AssertSz(szBuf[0] == CR && (!_f10Mode || szBuf[1] == LF),
				"CTxtEdit::OnRichEditChange: invalid document terminator");
		}
#endif // DEBUG

		if(_fRich && !fPropertyFlag)
		{
			// Going from rich text to plain text. Need to dump
			// format runs.
			HandleRichToPlainConversion();
			_fAutoFontSizeAdjust = TRUE;
		}
		else if (!_fRich && fPropertyFlag)
		{
			// Going from plain text to rich text. Need to add the 
			// appropriate EOP at the end of the document.
			SetRichDocEndEOP(0);
			_fAutoFontSizeAdjust = FALSE;
		}
		_fRich = fPropertyFlag;		
		return S_OK;
	}
	return E_FAIL;						// Flag was not updated
}

/* 
 *	CTxtEdit::OnTxMultiLineChange (fMultiline)
 *
 *	@mfunc
 *		Notify text services that the display changed.
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnTxMultiLineChange(
	BOOL fMultiLine)
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnTxMultiLineChange");

	BOOL fHadSelection = (_psel != NULL);
	CDisplay * pSavedDisplay;
	BOOL fOldShowSelection = FALSE;

	// Remember the old value for show selection
	if (fHadSelection)
		fOldShowSelection = _psel->GetShowSelection();

	// Save the current display away and null it out

	pSavedDisplay = _pdp;
	_pdp = NULL;

	// Attempt to create the new display
	if (fMultiLine)
		_pdp = new CDisplayML(this);
	else
		_pdp = new CDisplaySL(this);
	Assert(_pdp);

	if(!_pdp)
	{
		Assert(pSavedDisplay);
		_pdp = pSavedDisplay;
		return E_OUTOFMEMORY;
	}

	// Attempt to init the new display

	if(pSavedDisplay)
		_pdp->InitFromDisplay(pSavedDisplay);

	if(!_pdp->Init())
	{
		delete _pdp;
		Assert(pSavedDisplay);
		_pdp = pSavedDisplay;
		return E_FAIL;
	}

	// Ok to now kill the old display
	delete pSavedDisplay;

	// Is there are selection?
	if(_psel)
	{
		// Need to tell it there is a new display to talk to.
		_psel->SetDisplay(_pdp);
	}

	// Is this a switch to Single Line? If this is we need to
	// make sure we truncate the text to the first EOP. We wait 
	// till this point to do this check to make sure that everything 
	// is in sync before doing something which potentially affects
	// the display and the selection.
	if(!fMultiLine)
	{
		// Set up for finding an EOP
		CTxtPtr tp(this, 0);

		tp.FindEOP(tomForward);

		// Is there any EOP and text beyond?
		if (tp.GetCp() < GetAdjustedTextLength())
		{
			// FindEOP places the text after the EOP if there
			// is one. Since we want to delete the EOP as well
			// we need to back up to the EOP. 
			tp.BackupCpCRLF();

			// Sync up the cp's of all the ranges before deleting
			// the text.
			CRchTxtPtr rtp(this, tp.GetCp());

			// Truncate from the EOP to the end of the document
			rtp.ReplaceRange(GetAdjustedTextLength() - tp.GetCp(), 0, NULL, NULL, -1);
		}
	}
	_pdp->UpdateView();
	if(fHadSelection && _fFocus && fOldShowSelection)
		_psel->ShowSelection(TRUE);

	return S_OK;
}

/* 
 *	CTxtEdit::OnTxReadOnlyChange (fReadOnly)
 *
 *	@mfunc
 *		Notify text services that read-only property changed
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnTxReadOnlyChange(
	BOOL fReadOnly)		//@parm TRUE = read only, FALSE = not read only
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnTxReadOnlyChange");

	if (fReadOnly)
		_ldte.ReleaseDropTarget();

	_fReadOnly = fReadOnly;					// Cache bit
	return S_OK;
}
		

/* 
 *	CTxtEdit::OnShowAccelerator (fPropertyFlag)
 *
 *	@mfunc
 *		Update accelerator based on change
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnShowAccelerator(
	BOOL fPropertyFlag)		//@parm TRUE = show accelerator		
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnShowAccelerator");

	// Get the new accelerator character
	HRESULT hr = UpdateAccelerator();

	// Update the view - we update even in the face of an error return.
	// The point is that errors will be rare (non-existent?) and the update
	// will work even in the face of the error so why bother conditionalizing
	// the execution.
	NeedViewUpdate(TRUE);

	return hr;
}

/* 
 *	CTxtEdit::OnUsePassword (fPropertyFlag)
 *
 *	@mfunc
 *		Update use-password property
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnUsePassword(
	BOOL fPropertyFlag)		//@parm TRUE = use password character
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnUsePassword");

	Assert((DWORD)fPropertyFlag <= 1);			// Be sure it's C boolean

	_fUsePassword = fPropertyFlag;
	_pdp->UpdateView();					// State changed so update view
	
	return S_OK;
}

/* 
 *	CTxtEdit::OnTxHideSelectionChange (fHideSelection)
 *
 *	@mfunc
 *		Notify text services that hide-selection property changed
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnTxHideSelectionChange(
	BOOL fHideSelection)		//@parm TRUE = hide selection
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnTxHideSelectionChange");

	// update internal flag if selection is to be hidden
	_fHideSelection = fHideSelection;

	if (!_fFocus)
		OnHideSelectionChange(fHideSelection);
		
	return S_OK;
}

/* 
 *	CTxtEdit::OnHideSelectionChange (fHideSelection)
 *
 *	@mfunc
 *		Performs the actual hide selection.  Helper to OnTxHideSelectionChange
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnHideSelectionChange(
	BOOL fHideSelection)		//@parm TRUE = hide selection
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnHideSelectionChange");

	_fHideSelection = fHideSelection;
	
	CTxtSelection * psel = GetSel();
		 
	if(psel)
	{
		psel->ShowSelection(!fHideSelection);

		// In the case where we don't have focus we don't want to allow the user to display the caret but it's okay
		// to hide the caret.
		if (_fFocus || fHideSelection)
			psel->ShowCaret(!fHideSelection);
	}

	if(!_fInPlaceActive)
	{
		TxInvalidateRect(NULL, FALSE);		// Since _fInPlaceActive = FALSE,
		TxUpdateWindow();					//  this only tells user.exe to
	}										//  send a WM_PAINT message
	return S_OK;
}


/* 
 *	CTxtEdit::OnSaveSelection (fPropertyFlag)
 *
 *	@mfunc
 *		Notify text services that save-selection property changed
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnSaveSelection(
	BOOL fPropertyFlag)		//@parm TRUE = save selection when inactive
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnSaveSelection");

	return S_OK;
}	

/* 
 *	CTxtEdit::OnAutoWordSel (fPropertyFlag)
 *
 *	@mfunc
 *		Notify text services that auto-word-selection property changed
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnAutoWordSel(
	BOOL fPropertyFlag)		//@parm TRUE = auto word selection on
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnAutoWordSel");

	// We call back to the host when we need to know, so we don't bother doing
	// anything in response to this notification.

	return S_OK;
}

/* 
 *	CTxtEdit::OnTxVerticalChange (fVertical)
 *
 *	@mfunc
 *		Notify text services that vertical property changed
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnTxVerticalChange(
	BOOL fVertical)			//@parm TRUE - text vertically oriented.
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnTxVerticalChange");

	// We pretend like something actually happened.

	GetCallMgr()->SetChangeEvent(CN_GENERIC);
	return S_OK;
}

/* 
 *	CTxtEdit::OnClientRectChange (fPropertyFlag)
 *
 *	@mfunc
 *		Notify text services that client rectangle changed
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnClientRectChange(
	BOOL fPropertyFlag)		//@parm Ignored for this property	
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnClientRectChange");

	// It is unclear whether we need to actually do anything for this 
	// notification. Logically, the change of this property is followed
	// closely by some kind of operation which will cause the display
	// cache to be updated anyway. The old code is left here as an 
	// example of what might be done if it turns out we need to do
	// anything. For now, we will simply return S_OK to this notification.
#if 0
	if (_fInPlaceActive)
	{
		RECT rc;

		if(_phost->TxGetClientRect(&rc) == NOERROR)
			_pdp->OnClientRectChange(rc);

		return S_OK;
	}

	return NeedViewUpdate(fPropertyFlag);
#endif // 0

	// With a client rect change we do need to update the caret when
	// we get redrawn even if the basic information did not change. 
	_pdp->SetUpdateCaret();

	return S_OK;
}

/* 
 *	CTxtEdit::OnCharFormatChange (fPropertyFlag)
 *
 *	@mfunc
 *		Update default CCharFormat
 *
 *	@rdesc
 *		S_OK - update successfully processed.
 */
HRESULT CTxtEdit::OnCharFormatChange(
	BOOL fPropertyFlag)		//@parm Not used
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnCharFormatChange");

	CCharFormat CF;
	DWORD		dwMask;

	HRESULT hr = TxGetDefaultCharFormat(&CF, dwMask);
	if(hr == NOERROR)
	{
		DWORD dwMask2 = CFM2_CHARFORMAT;
		WPARAM wparam = SCF_ALL;

		if(!GetAdjustedTextLength())
		{
			dwMask2 = CFM2_CHARFORMAT | CFM2_NOCHARSETCHECK;
			wparam = 0;
		}

		// OnSetCharFormat handles updating the view.
		hr = OnSetCharFormat(wparam, &CF, NULL, dwMask, dwMask2) ? NOERROR : E_FAIL;
	}
	return hr;
}

/* 
 *	CTxtEdit::OnParaFormatChange (fPropertyFlag)
 *
 *	@mfunc
 *		Update default CParaFormat
 *
 *	@rdesc
 *		S_OK - update successfully processed
 *
 *	@devnote
 *		Because Forms^3 doesn't set cbSize correctly, we limit this API 
 *		to PARAFORMAT (until they fix it).
 */
HRESULT CTxtEdit::OnParaFormatChange(
	BOOL fPropertyFlag)		//@parm Not used
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnParaFormatChange");

	CParaFormat PF;

	HRESULT hr = TxGetDefaultParaFormat(&PF);
	if(hr == NOERROR)
	{
		// OnSetParaFormat handles updating the view.
		hr = OnSetParaFormat(SPF_SETDEFAULT, &PF, NULL, PFM_ALL2)
				? NOERROR : E_FAIL;
	}
#ifdef TABS
	GetTabsCache()->Release(PF._iTabs);
#endif
	return hr;
}

/* 
 *	CTxtEdit::NeedViewUpdate (fPropertyFlag)
 *
 *	@mfunc
 *		Notify text services that view of data changed
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::NeedViewUpdate(
	BOOL fPropertyFlag)
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::NeedViewUpdate");

	_pdp->UpdateView();
	return S_OK;
}

/* 
 *	CTxtEdit::OnTxBackStyleChange (fPropertyFlag)
 *
 *	@mfunc
 *		Notify text services that background style changed
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnTxBackStyleChange(
	BOOL fPropertyFlag)	//@parm Ignored for this property 
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnTxBackStyleChange");

	_fTransparent = (TxGetBackStyle() == TXTBACK_TRANSPARENT);
	TxInvalidateRect(NULL, FALSE);
	return S_OK;
}

/* 
 *	CTxtEdit::OnAllowBeep (fPropertyFlag)
 *
 *	@mfunc
 *		Notify text services that beep property changed
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnAllowBeep(
	BOOL fPropertyFlag)	//@parm New state of property 
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnAllowBeep");

	_fAllowBeep = fPropertyFlag;
	return S_OK;
}

/* 
 *	CTxtEdit::OnMaxLengthChange (fPropertyFlag)
 *
 *	@mfunc
 *		Notify text services that max-length property changed
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnMaxLengthChange(
	BOOL fPropertyFlag)	//@parm New state of property 
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnMaxLengthChange");

	// Query host for max text length
	DWORD length = CP_INFINITE;
	_phost->TxGetMaxLength(&length);
	_cchTextMost = length;

	return S_OK;
}

/* 
 *	CTxtEdit::OnWordWrapChange (fPropertyFlag)
 *
 *	@mfunc
 *		Notify text services that word-wrap property changed
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnWordWrapChange(
	BOOL fPropertyFlag)	//@parm TRUE = do word wrap
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnWordWrapChange");

	_pdp->SetWordWrap(fPropertyFlag);

	// Update was successful so we need the screen updated at some point
	_pdp->UpdateView();
	return S_OK;
}

/* 
 *	CTxtEdit::OnDisableDrag (fPropertyFlag)
 *
 *	@mfunc
 *		Notify text services that disable drag property changed
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnDisableDrag(
	BOOL fPropertyFlag)	//@parm New state of property 
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnDisableDrag");

	_fDisableDrag = fPropertyFlag;
	return S_OK;
}

/* 
 *	CTxtEdit::OnScrollChange (fPropertyFlag)
 *
 *	@mfunc
 *		Notify text services scroll property change
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnScrollChange(
	BOOL fPropertyFlag)	//@parm New state of property 
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnScrollChange");

	// Tell the display that scroll bars for sure need to be updated
	_pdp->SetViewChanged();

	// Tell the display to update itself.
	_pdp->UpdateView();

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\reinit.cpp ===
/*
 *
 *	REINIT.C
 *	
 *	Purpose:
 *		RICHEDIT initialization routines
 *	
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_font.h"
#include "_format.h"
#include "_disp.h"
#include "_clasfyc.h"
#include "zmouse.h"
#include "_rtfconv.h"
#include "_ols.h"
#include "_host.h"

// The IA64 linker does not currently handle DELAYLOAD
#include <delayimp.h>

ASSERTDATA

class CTxtEdit;
class CCmbBxWinHost;

extern void ReleaseTypeInfoPtrs();

static char szClassREA[sizeof(RICHEDIT_CLASSA)];
static WCHAR wszClassREW[sizeof(RICHEDIT_CLASSW)/sizeof(WCHAR)];

static WCHAR wszClassLBW[] = LISTBOX_CLASSW;
static WCHAR wszClassCBW[] = COMBOBOX_CLASSW;
#define REGISTERED_LISTBOX	1
#define REGISTERED_COMBOBOX 2

// a critical section for multi-threading support.
CRITICAL_SECTION g_CriticalSection;

HINSTANCE hinstRE = 0;

static BOOL RichFRegisterClass(VOID);

#ifdef DEBUG
BOOL fInDllMain = FALSE;  // used to ensure that GDI calls are not made during
						  // DLL_PROCESS_ATTACH
#endif

void FreeFontCache();					// Defined in font.cpp
void ReleaseOutlineBitmaps();			// Defined in render.cpp

#ifdef DEBUG
	void CatchLeaks(void);
#endif

static inline
void WINAPI
OverlayIAT(PImgThunkData pitdDst, PCImgThunkData pitdSrc) {
    memcpy(pitdDst, pitdSrc, CountOfImports(pitdDst) * sizeof IMAGE_THUNK_DATA);
    }

void OurUnloadDelayLoadedDlls(void)
{
    PUnloadInfo pui = __puiHead;

	for (;pui;)
	{
#if DELAYLOAD_VERSION >= 0x200
        if (pui->pidd->rvaUnloadIAT)
        {
            PCImgDelayDescr pidd = pui->pidd;
            HMODULE         hmod = *(HMODULE *)((PCHAR)&__ImageBase + pidd->rvaHmod);
            OverlayIAT((PImgThunkData)  ((PCHAR)&__ImageBase + pidd->rvaIAT),
                       (PCImgThunkData) ((PCHAR)&__ImageBase + pidd->rvaUnloadIAT));
            ::FreeLibrary(hmod);
			*(HMODULE *)((PCHAR)&__ImageBase+pidd->rvaHmod) = NULL;

			PUnloadInfo puiT = pui->puiNext;
			::LocalFree(pui);
			pui = puiT;
        }
#else
		if (pui->pidd->pUnloadIAT)
		{
			PCImgDelayDescr pidd = pui->pidd;
			HMODULE         hmod = *pidd->phmod;

			OverlayIAT(pidd->pIAT, pidd->pUnloadIAT);
			::FreeLibrary(hmod);
			*pidd->phmod = NULL;

			PUnloadInfo puiT = pui->puiNext;
			::LocalFree(pui);
			pui = puiT;
		}
#endif
	}
}

extern "C"
{

#ifdef PEGASUS
BOOL WINAPI DllMain(HANDLE hmod, DWORD dwReason, LPVOID lpvReserved)
#else
BOOL WINAPI DllMain(HMODULE hmod, DWORD dwReason, LPVOID lpvReserved)
#endif
{
	DebugMain (hmod, dwReason, lpvReserved);

	if(dwReason == DLL_PROCESS_DETACH)		// We are unloading
	{
		DeleteDanglingHosts();
		CRTFConverter::FreeFontSubInfo();
		FreeFontCache();
		DestroyFormatCaches();
		ReleaseTypeInfoPtrs();
		UninitKinsokuClassify();
		
		// Release various resouces allocated during running...
		delete g_pols;
		delete g_pusp;
		g_pusp = NULL;

		ReleaseOutlineBitmaps();

		if(hinstRE)
		{
			#ifndef PEGASUS
				UnregisterClassA(szClassREA, hinstRE);
				#ifdef RICHED32_BUILD
					UnregisterClassA(szClassRE10A, hinstRE);
				#endif
			#endif
			W32->UnregisterClass(wszClassREW, hinstRE);
			if (W32->_fRegisteredXBox)
			{
				// There may be cases where these window classes
				// are still in memory in which case UnregisterClass
				// will fail.  So keep track of that
				if (W32->UnregisterClass(wszClassLBW, hinstRE))
					W32->_fRegisteredXBox &= ~REGISTERED_LISTBOX;
				if (W32->UnregisterClass(wszClassCBW, hinstRE))
					W32->_fRegisteredXBox &= ~REGISTERED_COMBOBOX;
			}
		}
		delete W32;

#ifdef DEBUG
		CatchLeaks();
#endif
#ifndef _WIN64
		OurUnloadDelayLoadedDlls();
#endif
		DeleteCriticalSection(&g_CriticalSection);
	}
	else if(dwReason == DLL_PROCESS_ATTACH) // We have just loaded
	{
		#ifdef DEBUG
			fInDllMain = TRUE;
		#endif
		InitializeCriticalSection(&g_CriticalSection);
#ifndef DEBUG
		DisableThreadLibraryCalls(hmod);
#endif
		#ifdef PEGASUS
			hinstRE = (HINSTANCE) hmod;
		#else
			hinstRE = hmod;
		#endif

		W32 = new CW32System;

		WCHAR wszFileName[_MAX_PATH];
		CopyMemory(szClassREA, RICHEDIT_CLASSA, sizeof(CERICHEDIT_CLASSA));
		CopyMemory(wszClassREW, RICHEDIT_CLASSW, sizeof(CERICHEDIT_CLASSW));
		int iLen = W32->GetModuleFileName((HMODULE) hmod, wszFileName, _MAX_PATH);
		if (iLen)
		{
			iLen -= sizeof("riched20.dll") - 1;
			if (!lstrcmpi(&wszFileName[iLen] , TEXT("richedce.dll")))
			{
				// This code allows the dll to be renamed for Win CE.
				Assert(sizeof(RICHEDIT_CLASSA) == sizeof(CERICHEDIT_CLASSA));
				Assert(sizeof(RICHEDIT_CLASSW) == sizeof(CERICHEDIT_CLASSW));
				CopyMemory(szClassREA, CERICHEDIT_CLASSA, sizeof(CERICHEDIT_CLASSA));
				CopyMemory(wszClassREW, CERICHEDIT_CLASSW, sizeof(CERICHEDIT_CLASSW));
			}
		}

		if(!RichFRegisterClass())
		{
			return FALSE;
		}
		
		#ifdef DEBUG
			fInDllMain = FALSE;
		#endif
	}

	return TRUE;
}

} 	// extern "C"

/*
 *	RichFRegisterClass
 *
 *	Purpose:	
 *		registers the window classes used by richedit
 *
 *	Algorithm:
 *		register two window classes, a Unicode one and an ANSI
 *		one.  This enables clients to optimize their use of
 *		the edit control w.r.t to ANSI/Unicode data
 */

static BOOL RichFRegisterClass(VOID)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "RichFRegisterClass");
	WNDCLASS wc;

	wc.style = CS_DBLCLKS | CS_GLOBALCLASS | CS_PARENTDC;
	wc.lpfnWndProc = RichEditWndProc;
	wc.cbClsExtra = 0;
	wc.cbWndExtra = sizeof(CTxtEdit FAR *);
	wc.hInstance = hinstRE;
	wc.hIcon = 0;
	wc.hCursor = 0;
	wc.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1);
	wc.lpszMenuName = NULL;
	wc.lpszClassName = wszClassREW;

	if( W32->RegisterREClass(&wc, szClassREA, RichEditANSIWndProc) == NULL )
	{
		return FALSE;
	};

	return TRUE;
}

/*
 *	RichFRegisterClass
 *
 *	Purpose:	
 *		registers the window classes used by REListbox
 *
 *	Algorithm:
 *		register two window classes, a Unicode one and an ANSI
 *		one.  This enables clients to optimize their use of
 *		the edit control w.r.t to ANSI/Unicode data
 */
extern LRESULT CALLBACK RichListBoxWndProc(HWND, UINT, WPARAM, LPARAM);
extern LRESULT CALLBACK RichComboBoxWndProc(HWND, UINT, WPARAM, LPARAM);
__declspec(dllexport) BOOL WINAPI REExtendedRegisterClass(VOID)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "REExtendedRegisterClass");
		
	WNDCLASS wc;

	if (!(W32->_fRegisteredXBox & REGISTERED_LISTBOX))
	{
		// Globally register the listbox
		wc.style = CS_DBLCLKS | CS_GLOBALCLASS | CS_PARENTDC;
		wc.lpfnWndProc = RichListBoxWndProc;
		wc.cbClsExtra = 0;
		wc.cbWndExtra = sizeof(CTxtEdit FAR *);
		wc.hInstance = hinstRE;
		wc.hIcon = 0;
		wc.hCursor = 0;
		wc.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1);
		wc.lpszMenuName = NULL;
		wc.lpszClassName = wszClassLBW;

		if(W32->RegisterREClass(&wc, NULL, NULL))
			W32->_fRegisteredXBox |= REGISTERED_LISTBOX;
	}

	if (!(W32->_fRegisteredXBox & REGISTERED_COMBOBOX))
	{
		// globally register the combobox
		wc.style = CS_DBLCLKS | CS_GLOBALCLASS | CS_PARENTDC | CS_VREDRAW | CS_HREDRAW;
		wc.lpfnWndProc = RichComboBoxWndProc;
		wc.cbClsExtra = 0;
		wc.cbWndExtra = sizeof(CCmbBxWinHost FAR *);
		wc.hInstance = hinstRE;
		wc.hIcon = 0;
		wc.hCursor = 0;
		wc.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1);
		wc.lpszMenuName = NULL;
		wc.lpszClassName = wszClassCBW;

		if(W32->RegisterREClass(&wc, NULL, NULL))
			W32->_fRegisteredXBox |= REGISTERED_COMBOBOX;
	}

	//Set flag so we unregister the window class
	return W32->_fRegisteredXBox;
}

BOOL g_fNoLS = FALSE;
BOOL g_fNoUniscribe = FALSE;
//This is a stub function which we call when we can't find LineServices.
//The stub function needs to be the the first function we call in LS.
LSERR WINAPI LsGetReverseLsimethodsStub(LSIMETHODS *plsim)
{
	return lserrOutOfMemory;
}

//Ugly, but good enough
BOOL FIsUniscribeDll (const char *szDll)
{
	return (*szDll == 'u' || *szDll == 'U');
}

HRESULT WINAPI ScriptGetPropertiesStub(const SCRIPT_PROPERTIES ***ppSp,int *piNumScripts)
{
	return E_FAIL;
}

const SCRIPT_LOGATTR* WINAPI ScriptString_pLogAttrStub(SCRIPT_STRING_ANALYSIS ssa)
{
	// USP build 0175 (shipped with IE5 and Office2K) doesnt support this API.
	return NULL;
}

// Get Uniscibe's fake entry points

FARPROC WINAPI GetUniscribeStubs(LPCSTR szProcName)
{
	if (!lstrcmpiA(szProcName, "ScriptGetProperties"))
		return (FARPROC)ScriptGetPropertiesStub;

	if (!lstrcmpiA(szProcName, "ScriptString_pLogAttr"))
		return (FARPROC)ScriptString_pLogAttrStub;

#ifdef DEBUG
	char szAssert[128];

	wsprintfA(szAssert, "Uniscribe API =%s= is missing. Fix it NOW!", szProcName);

	AssertSz(FALSE, szAssert);
#endif

	return (FARPROC)ScriptGetPropertiesStub;	// we're dying...
}

#ifndef _WIN64
FARPROC WINAPI DliHook(unsigned dliNotify, PDelayLoadInfo pdli)
{
	FARPROC fp = 0;

	switch (dliNotify)
	{
	case dliFailLoadLib:
		{
			if (FIsUniscribeDll(pdli->szDll))
				g_fNoUniscribe = TRUE;
			else
				g_fNoLS = TRUE;

			fp = (FARPROC)(HMODULE)hinstRE;
			char szBuf[255];

			FormatMessageA(FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_FROM_SYSTEM, NULL,
						  ERROR_MOD_NOT_FOUND,
						  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
						  (char*)szBuf, sizeof(szBuf), NULL);

			CopyMemory(szBuf + lstrlenA(szBuf), " (", 3);
			CopyMemory(szBuf + lstrlenA(szBuf), pdli->szDll, lstrlenA(pdli->szDll) + 1);
			CopyMemory(szBuf + lstrlenA(szBuf), ")", 2);

			MessageBoxA(NULL, szBuf, NULL, MB_ICONEXCLAMATION | MB_TASKMODAL | MB_SETFOREGROUND);
		}
	break;


	case dliFailGetProc:
		if (FIsUniscribeDll(pdli->szDll))
			fp = (FARPROC)GetUniscribeStubs(pdli->dlp.szProcName);
		else
			fp = (FARPROC)LsGetReverseLsimethodsStub;
	break;
	}

	return fp;
}

PfnDliHook __pfnDliFailureHook = DliHook;

#endif //!_WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\rtflex.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module RTFLEX.CPP - RichEdit RTF reader lexical analyzer |
 *
 *		This file contains the implementation of the lexical analyzer part of
 *		the RTF reader.
 *
 *	Authors: <nl>
 *		Original RichEdit 1.0 RTF converter: Anthony Francisco <nl>
 *		Conversion to C++ and RichEdit 2.0:  Murray Sargent <nl>
 *
 *	@devnote
 *		All sz's in the RTF*.? files refer to a LPSTRs, not LPTSTRs, unless
 *		noted as a szUnicode.
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_rtfread.h"
#include "hash.h"

ASSERTDATA

#include "tokens.cpp"

// Array used by character classification macros to speed classification
// of chars residing in two or more discontiguous ranges, e.g., alphanumeric
// or hex.  The alphabetics used in RTF control words are lower-case ASCII.
// *** DO NOT DBCS rgbCharClass[] ***

#define	fCS		fCT + fSP
#define fSB		fBL + fSP
#define fHD		fHX + fDG
#define	fHU		fHX + fUC
#define	fHL		fHX + fLC

const BYTE rgbCharClass[256] =
{
	fCT,fCT,fCT,fCT,fCT,fCT,fCT,fCT, fCT,fCS,fCS,fCS,fCS,fCS,fCT,fCT,
	fCT,fCT,fCT,fCT,fCT,fCT,fCT,fCT, fCT,fCT,fCT,fCT,fCT,fCT,fCT,fCT,
	fSB,fPN,fPN,fPN,fPN,fPN,fPN,fPN, fPN,fPN,fPN,fPN,fPN,fPN,fPN,fPN,
	fHD,fHD,fHD,fHD,fHD,fHD,fHD,fHD, fHD,fHD,fPN,fPN,fPN,fPN,fPN,fPN,

	fPN,fHU,fHU,fHU,fHU,fHU,fHU,fUC, fUC,fUC,fUC,fUC,fUC,fUC,fUC,fUC,
	fUC,fUC,fUC,fUC,fUC,fUC,fUC,fUC, fUC,fUC,fUC,fPN,fPN,fPN,fPN,fPN,
	fPN,fHL,fHL,fHL,fHL,fHL,fHL,fLC, fLC,fLC,fLC,fLC,fLC,fLC,fLC,fLC,
	fLC,fLC,fLC,fLC,fLC,fLC,fLC,fLC, fLC,fLC,fLC,fPN,fPN,fPN,fPN,fPN,

	0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,

	0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
};

const char szRTFSig[] = "rtf";
#define cchRTFSig   3
#define cbRTFSig    (cchRTFSig * sizeof(char))

// Specifies the number of bytes we can safely "UngetChar"
// before possibly underflowing the buffer.
const int cbBackupMax = 4;

// Bug2298 - I found an RTF writer which emits uppercase RTF keywords,
// 			so I had to change IsLCAscii to IsAlphaChar for use in scanning
//			for RTF keywords.
inline BOOL IsAlphaChar(BYTE b)
{
	return IN_RANGE('a', b, 'z') || IN_RANGE('A', b, 'Z');
}

// Quick and dirty tolower(b)
inline BYTE REToLower(BYTE b)
{
	Assert(!b || IsAlphaChar(b));
	return b ? (BYTE)(b | 0x20) : 0;
}

extern BOOL IsRTF(char *pstr);

BOOL IsRTF(
	char *pstr)
{
	if(!pstr || *pstr++ != '{' || *pstr++ != '\\')
		return FALSE;					// Quick out for most common cases

	if(*pstr == 'u')					// Bypass u of possible urtf
		pstr++;

	return !CompareMemory(szRTFSig, pstr, cbRTFSig);
}

/*
 *	CRTFRead::InitLex()
 *
 *	@mfunc
 *		Initialize the lexical analyzer. Reset the variables. if reading in
 *		from resource file, sort the keyword list (). Uses global hinstRE
 *		from the RichEdit to find out where its resources are.  Note: in
 *		RichEdit 2.0, currently the resource option is not supported.
 *
 *	@rdesc
 *		TRUE				If lexical analyzer was initialized
 */
BOOL CRTFRead::InitLex()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::InitLex");

	AssertSz(cKeywords == i_TokenIndexMax,
		"Keyword index enumeration is incompatible with rgKeyword[]");
	Assert(!_szText && !_pchRTFBuffer);

	// Allocate our buffers with an extra byte for szText so that hex
	// conversion doesn't have to worry about running off the end if the
	// first char is NULL
	if ((_szText	   = (BYTE *)PvAlloc(cachTextMax + 1, GMEM_ZEROINIT)) &&
		(_pchRTFBuffer = (BYTE *)PvAlloc(cachBufferMost, GMEM_ZEROINIT)))
	{
		return TRUE;					// Signal that lexer is initialized
	}

	_ped->GetCallMgr()->SetOutOfMemory();
	_ecParseError = ecLexInitFailed;
	return FALSE;
}

/*
 *	CRTFRead::DeinitLex()
 *
 *	@mfunc
 *		Shut down lexical analyzer
 */
void CRTFRead::DeinitLex()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::DeinitLex");

#ifdef KEYWORD_RESOURCE
	if (hglbKeywords)
	{
		FreeResource(hglbKeywords);
		hglbKeywords = NULL;
		rgKeyword = NULL;
	}
#endif

	FreePv(_szText);
	FreePv(_pchRTFBuffer);
}

/*
 *	CRTFRead::GetChar()
 *	
 *	@mfunc
 *		Get next char, filling buffer as needed
 *	
 *	@rdesc
 *		BYTE			nonzero char value if success; else 0
 */
BYTE CRTFRead::GetChar()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::GetChar");

	if (_pchRTFCurrent == _pchRTFEnd && !FillBuffer())
	{
		_ecParseError = ecUnexpectedEOF;
		return 0;
	}
	return *_pchRTFCurrent++;
}

/*
 *	CRTFRead::FillBuffer()
 *
 *	@mfunc
 *		Fill RTF buffer & return != 0 if successful
 *
 *	@rdesc
 *		LONG			# chars read
 *
 *	@comm
 *		This routine doesn't bother copying anything down if
 *		pchRTFCurrent <lt> pchRTFEnd so anything not read yet is lost.
 *		The only exception to this is that it always copies down the
 *		last two bytes read so that UngetChar() will work. ReadData()
 *		actually counts on this behavior, so if you change it, change
 *		ReadData() accordingly.
 */
LONG CRTFRead::FillBuffer()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::FillBuffer");

	LONG cchRead;

	if (!_pchRTFCurrent)				
	{									
		// No data yet, nothing for backup
		// Leave cbBackupMax NULL chars so backup
		// area of buffer doesn't contain garbage.

		for(int i = 0; i < cbBackupMax; i++)
		{
			_pchRTFBuffer[i] = 0;
		}
	}
	else
	{
		Assert(_pchRTFCurrent == _pchRTFEnd);

		// Copy most recently read chars in case
		//  we need to back up

		int cbBackup = min((UINT) cbBackupMax, DiffPtrs(_pchRTFCurrent, &_pchRTFBuffer[cbBackupMax])); 
		int i;

		for(i = -1; i >= -cbBackup; i--)
			_pchRTFBuffer[cbBackupMax + i] = _pchRTFCurrent[i];

		if(cbBackup < cbBackupMax)
		{
			// NULL before the first valid character in the backup buffer
			_pchRTFBuffer[cbBackupMax + i] = 0;
		}
	}
	_pchRTFCurrent = &_pchRTFBuffer[cbBackupMax];

	// Fill buffer with as much as we can take given our starting offset
	_pes->dwError = _pes->pfnCallback(_pes->dwCookie,
									  _pchRTFCurrent,
									  cachBufferMost - cbBackupMax,
									  &cchRead);
	if (_pes->dwError)
	{
		TRACEERRSZSC("RTFLEX: GetChar()", _pes->dwError);
		_ecParseError = ecGeneralFailure;
		return 0;
	}

	_pchRTFEnd = &_pchRTFBuffer[cbBackupMax + cchRead];		// Point the end

#if defined(DEBUG) && !defined(MACPORT)
	if(_hfileCapture)
	{
		DWORD cbLeftToWrite = cchRead;
		DWORD cbWritten = 0;
		BYTE *pbToWrite = (BYTE *)_pchRTFCurrent;
		
		while(WriteFile(_hfileCapture,
						pbToWrite,
						cbLeftToWrite,
						&cbWritten,
						NULL) && 
						(pbToWrite += cbWritten,
						(cbLeftToWrite -= cbWritten)));
	}
#endif

	return cchRead;
}

/*
 *	CRTFRead::UngetChar()
 *
 *	@mfunc
 *		Bump our file pointer back one char
 *
 *	@rdesc
 *		BOOL				TRUE on success
 *
 *	@comm
 *		You can safely UngetChar _at most_ cbBackupMax times without
 *		error.
 */
BOOL CRTFRead::UngetChar()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::UngetChar");

	if (_pchRTFCurrent == _pchRTFBuffer || !_pchRTFCurrent)
	{
		Assert(0);
		_ecParseError = ecUnGetCharFailed;
		return FALSE;
	}

	--_pchRTFCurrent;
	return TRUE;
}

/*
 *	CRTFRead::UngetChar(cch)
 *
 *	@mfunc
 *		Bump our file pointer back 'cch' chars
 *
 *	@rdesc
 *		BOOL				TRUE on success
 *
 *	@comm
 *		You can safely UngetChar _at most_ cbBackupMax times without
 *		error.
 */
BOOL CRTFRead::UngetChar(UINT cch)
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::UngetChar");

	AssertSz(cch <= cbBackupMax, "CRTFRead::UngetChar():  Number of UngetChar's "
								"exceeds size of backup buffer.");

	while(cch-- > 0)
	{
		if(!UngetChar())
			return FALSE;
	}

	return TRUE;
}

/*
 *	CRTFRead::GetHex()
 *
 *	@mfunc
 *		Get next char if hex and return hex value
 *		If not hex, leave char in buffer and return 255
 *
 *	@rdesc
 *		BYTE			hex value of GetChar() if hex; else 255
 */
BYTE CRTFRead::GetHex()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::GetHex");

	BYTE ch = GetChar();

	if(IsXDigit(ch))
		return (BYTE)(ch <= '9' ? ch - '0' : (ch & 0x4f) - 'A' + 10);
	if(ch)
		UngetChar();
	return 255;
}

/*
 *	CRTFRead::GetHexSkipCRLF()
 *
 *	@mfunc
 *		Get next char if hex and return hex value
 *		If not hex, leave char in buffer and return 255
 *
 *	@rdesc
 *		BYTE			hex value of GetChar() if hex; else 255
 *
 *	@devnote
 *		Keep this in sync with GetHex above.
 */
BYTE CRTFRead::GetHexSkipCRLF()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::GetHexSkipCRLF");

	BYTE ch = GetChar();

	// Skip \r \n
	while(ch == CR || ch == LF)
		ch = GetChar(); 

	// Rest is same as CRTFRead::GetHex()
	if(IsXDigit(ch))
		return (BYTE)(ch <= '9' ? ch - '0' : (ch & 0x4f) - 'A' + 10);
	if(ch)
		UngetChar();
	return 255;
}

/*
 *	CRTFRead::TokenGetHex()
 *
 *	@mfunc
 *		Get an 8 bit character saved as a 2 hex digit value
 *
 *	@rdesc
 *		TOKEN			value of hex number read in
 */
TOKEN CRTFRead::TokenGetHex()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::TokenGetHex");

	BYTE bChar0 = GetHex();
	BYTE bChar1;

	if(bChar0 < 16 && (bChar1 = GetHex()) < 16)
		_token = (WORD)(bChar0 << 4 | bChar1);
	else
		_token = tokenError;

	return _token;
}

/*
 *	CRTFRead::SkipToEndOfGroup()
 *
 *	@mfunc
 *		Skip to end of current group
 *
 *	@rdesc
 *		EC				An error code
 */
EC CRTFRead::SkipToEndOfGroup()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::SkipToEndOfGroup");

	INT		nDepth = 1;
	BYTE	ach;

	while(TRUE)
	{
		ach = GetChar();
		switch(ach)
		{
			case BSLASH:
			{
				BYTE achNext = GetChar();

				// EOF: goto done; else ignore NULLs
				if(!achNext && _ecParseError == ecUnexpectedEOF)
					goto done;

				if(achNext == 'b' && UngetChar() && 
					TokenGetKeyword() == tokenBinaryData)
				{
					// We've encountered the \binN tag in the RTF we want
					//	to skip.  _iParam contains N from \binN once the 
					// 	tag is parsed by TokenGetKeyword()
					SkipBinaryData(_iParam);
				}
				break;
			}

			case LBRACE:
				nDepth++;
				break;

			case RBRACE:
				if (--nDepth <= 0)
					goto done;
				break;

			case 0:
				if(_ecParseError == ecUnexpectedEOF)
					goto done;

			default:
				// Detect Lead bytes here.
				int cTrailBytes = GetTrailBytesCount(ach, _nCodePage);
				if (cTrailBytes)
				{
					for (int i = 0; i < cTrailBytes; i++)
					{
						ach = GetChar();
						if(ach == 0 && _ecParseError == ecUnexpectedEOF)
							goto done;			
					}
				}
				break;
		}
	} 

	Assert(!_ecParseError);
	_ecParseError = ecUnexpectedEOF;

done:
	return _ecParseError;
}

/*
 *	CRTFRead::TokenFindKeyword(szKeyword)
 *
 *	@mfunc
 *		Find keyword <p szKeyword> and return its token value
 *
 *	@rdesc
 *		TOKEN			token number of keyword
 */
TOKEN CRTFRead::TokenFindKeyword(
	BYTE *	szKeyword)			// @parm Keyword to find
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::TokenFindKeyword");

	INT				iMin;
	INT				iMax;
	INT				iMid;
	INT				nComp;
	BYTE *			pchCandidate;
	BYTE *			pchKeyword;
	const KEYWORD *	pk;

	AssertSz(szKeyword[0],
		"CRTFRead::TokenFindKeyword: null keyword");

#ifdef RTF_HASHCACHE
	if ( _rtfHashInited )
	{
		// Hash is 23% faster than the following binary search on finds
		//  and 55% faster on misses: For 97 words stored in a 257 cache.
		//  Performance numbers will change when the total stored goes up.
		pk = HashKeyword_Fetch ( (CHAR *) szKeyword );
	}
	else
#endif
	{
		iMin = 0;
		iMax = cKeywords - 1;
		pk = NULL;
		do				// Note (MS3): Hash would be quicker than binary search
		{
			iMid		 = (iMin + iMax) / 2;
			pchCandidate = (BYTE *)rgKeyword[iMid].szKeyword;
			pchKeyword	 = szKeyword;
			while (!(nComp = REToLower(*pchKeyword) - *pchCandidate)	// Be sure to match
				&& *pchKeyword)											//  terminating 0's
			{
				pchKeyword++;
				pchCandidate++;
			}
			if (nComp < 0)
				iMax = iMid - 1;
			else if (nComp)
				iMin = iMid + 1;
			else
			{
				pk = &rgKeyword[iMid];
				break;
			}
		} while (iMin <= iMax);
	}


	if(pk)
	{
		_token = pk->token;
		
		// here, we log the RTF keyword scan to aid in tracking RTF tag ocverage
// TODO: Implement RTF tag logging for the Mac and WinCE
#if defined(DEBUG) && !defined(MACPORT) && !defined(PEGASUS)
		if(_prtflg) 
		{
#ifdef RTF_HASCACHE
			_prtflg->AddAt(szKeyword); 
#else
			_prtflg->AddAt((size_t)iMid);
#endif
		}
#endif
	}
	else
		_token = tokenUnknownKeyword;		// No match: TODO: place to take

	return _token;				 			//  care of unrecognized RTF
}

/*
 *	CRTFRead::TokenGetKeyword()
 *
 *	@mfunc
 *		Collect a keyword and its parameter. Return token's keyword
 *
 *	@rdesc
 *		TOKEN				token number of keyword
 *
 *	@comm
 *		Most RTF control words (keywords) consist of a span of lower-case
 *		ASCII letters possibly followed by a span of decimal digits. Other
 *		control words consist of a single character that isn't LC ASCII. No
 *		control words contain upper-case characters.
 */
TOKEN CRTFRead::TokenGetKeyword()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::TokenGetKeyword");

	BYTE		ach = GetChar();
	BYTE		*pach;
	SHORT		cachKeyword = 1;
	BYTE		szKeyword[cachKeywordMax];

	_szParam[0] = '\0';							// Clear parameter
	_iParam = 0;

	if(!IsAlphaChar(ach))						// Not alpha, i.e.,
	{											//  single char
		if (ach == '\'')						// Most common case needs
		{										//  special treatment
			// Convert hex to char and store result in _token
			if(TokenGetHex() == tokenError)
			{							
				_ecParseError = ecUnexpectedChar;
				goto TokenError;
			}
			if((_token == CR || _token == LF) && FInDocTextDest())
			{
				// Add raw CR or LF in the byte stream as a \par
				return tokenEndParagraph;
			}
		}
		else
		{	
			// Check for other known symbols
			const BYTE *pachSym = szSymbolKeywords;
			
			while(ach != *pachSym && *pachSym)
				pachSym++;
			if(*pachSym)						// Found one
			{
				_token = tokenSymbol[pachSym - szSymbolKeywords];
				if(_token > 0x7F)				// Token or larger Unicode
					return _token;				//  value
			}
			else if (!ach)						// No more input chars
				goto TokenError;
			else								// Code for unrecognized RTF
				_token = ach;					// We'll just insert it for now 
		}
		_token = TokenGetText((BYTE)_token);
		return _token; 
	}

	szKeyword[0] = ach;							// Collect keyword that starts
	pach = szKeyword + 1;						// 	with ASCII
	while (cachKeyword < cachKeywordMax &&
		   IsAlphaChar(ach = GetChar()))
	{
		cachKeyword++;
		*pach++ = ach;
	}

	if (cachKeyword == cachKeywordMax)
	{
		_ecParseError = ecKeywordTooLong;
		goto TokenError;
	}
	*pach = '\0';								// Terminate keyword

	if (IsDigit(ach) || ach == '-')				// Collect parameter
	{
		pach = _szParam;
		*pach++ = ach;
		if(ach != '-')
			_iParam = ach - '0';				// Get parameter value

		while (IsDigit(ach = GetChar()))
		{
			_iParam = _iParam*10 + ach - '0';
			*pach++ = ach;
		}
		*pach = '\0';							// Terminate parameter string
		if (_szParam[0] == '-')
			_iParam = -_iParam;
	}

	if (!_ecParseError &&						// We overshot:
		(ach == ' ' || UngetChar()))			//  if not ' ', unget char
			return TokenFindKeyword(szKeyword);	// Find and return keyword

TokenError:
	TRACEERRSZSC("TokenGetKeyword()", _ecParseError);
	return _token = tokenError;
}

/*
 *	CRTFRead::TokenGetText(ach)
 *
 *	@mfunc
 *		Collect a string of text starting with the char <p ach> and treat as a
 *		single token. The string ends when a LBRACE, RBRACE, or single '\\' is found.
 *
 *	@devnote
 *		We peek past the '\\' for \\'xx, which we decode and keep on going;
 *		else we return in a state where the next character is the '\\'.
 *
 *	@rdesc
 *		TOKEN			Token number of next token (tokenText or tokenError)
 */
TOKEN CRTFRead::TokenGetText(
	BYTE ach)				// @parm First char of 8-bit text string
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::TokenGetText");

	BYTE *	pach = _szText;
	SHORT	cachText = 0;
	LONG	CodePage = _pstateStackTop->nCodePage;
	BOOL	fAllASCII = TRUE;
	int		cTrailBytesNeeded = 0;

	_token = tokenError;						// Default error

	// FUTURE(BradO):  This 'goto' into a while loop is pretty weak.
	//	Restructure this 'while' loop such that the 'goto' is removed.

	// Add character passed into routine
	goto add;

	// If cTrailBytesNeeded is non-zero, we need to get all the trail bytes.  Otherwise,
	// a string end in the middle of a DBC or UTF-8 will cause bad display/print problem
	// - 5 to allow extra space for up to 4 bytes for UTF-8 and Null char
	while (cachText < cachTextMax - 5 || cTrailBytesNeeded)
	{
		ach = GetChar();
		switch (ach)
		{
			case BSLASH:
			{
				// FUTURE(BradO):  This code looks ALOT like TokenGetKeyword.
				//	We should combine the two into a common routine.

				BYTE achNext;

				// Get char after BSLASH
				achNext = GetChar();
				if(!achNext)
					goto error;
	
				if(achNext == '\'')					// Handle most frequent
				{									//  case here
					if(TokenGetHex() == tokenError)
					{
						if(cTrailBytesNeeded)
						{
							// The trail-byte must be a raw BSLASH.
							// Unget the single-quote.

							if(!UngetChar())
								goto error;
							// fall through to add BSLASH
						}
						else
						{
							_ecParseError = ecUnexpectedChar;
							goto error;
						}
					}
					else
					{
						ach = (BYTE)_token;
						if (cTrailBytesNeeded == 0 && (ach == CR || ach == LF) &&
							FInDocTextDest())
						{
							// Here, we have a raw CR or LF in document text.  
							// Unget the whole lot of characters and bail out.  
							// TokenGetKeyword will convert this CR or LF into
							// a \par.

							if(!UngetChar(4))
								goto error;
							goto done;
						}
					}
					goto add;
				}

				// Check next byte against list of RTF symbol
				// NOTE:- we need to check for RTF symbol even if we
				// are expecting a trail byte.  According to the rtf spec,
				// we cannot just take this backslash as trail byte.
				// HWC 9/97

				const BYTE *pachSymbol = szSymbolKeywords;			
				while(achNext != *pachSymbol && *pachSymbol)	
					pachSymbol++;

				TOKEN tokenTmp;

				if (*pachSymbol && 
					(tokenTmp = tokenSymbol[pachSymbol - szSymbolKeywords])
						 <= 0x7F)
				{
					ach = (BYTE)tokenTmp;
					goto add;
				}

				// In either of the last two cases below, we will want
				// to unget the byte following the BSLASH
				if(!UngetChar())
					goto error;

				if(cTrailBytesNeeded && !IsAlphaChar(achNext))
				{
					// In this situation, either this BSLASH begins the next 
					// RTF keyword or it is a raw BSLASH which is the trail 
					// byte for a DBCS character.

					// I think a fair assumption here is that if an alphanum
					// follows the BSLASH, that the BSLASH begins the next
					// RTF keyword.

					// add the raw BSLASH
					goto add;					
				}

				// Here, my guess is that the BSLASH begins the next RTF 
				// keyword, so unget the BSLASH
			    if(!UngetChar())
					goto error;					

				goto done;
			}

			case LBRACE:						// End of text string
			case RBRACE:
				if(cTrailBytesNeeded)
				{
					// Previous char was a lead-byte of a DBCS pair or UTF-8, which
					// makes this char a raw trail-byte.
					goto add;
				}

				if(!UngetChar())				// Unget delimeter
					goto error;
				goto done;

			case LF:							// Throw away noise chars
			case CR:
				break;

			case 0:
				if(_ecParseError == ecUnexpectedEOF)
					goto done;
				ach = ' ';						// Replace NULL by blank

			default:							// Collect chars
add:
				// Outstanding chars to be skipped after \uN tag
				if(_cbSkipForUnicode)
				{
					_cbSkipForUnicode--;
					continue;
				}

				*pach++ = ach;
				++cachText;
				if(ach > 0x7F)
					fAllASCII = FALSE;
	
				// Check if we are expecting more trail bytes
				if (cTrailBytesNeeded)
					cTrailBytesNeeded--;
				else
					cTrailBytesNeeded = GetTrailBytesCount(ach, CodePage);
				Assert(cTrailBytesNeeded >= 0);
		}
	}

done:
	_token = (WORD)(fAllASCII ? tokenASCIIText : tokenText);
	*pach = '\0';								// Terminate token string

error:
	return _token;
}
 
/*
 *	CRTFRead::TokenGetToken()
 *
 *	@mfunc
 *		This function reads in next token from input stream
 *
 *	@rdesc
 *		TOKEN				token number of next token
 */
TOKEN CRTFRead::TokenGetToken()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::TokenGetToken");

	BYTE		ach;

	_tokenLast	= _token;					// Used by \* destinations and FE
	_token = tokenEOF;						// Default end-of-file

SkipNoise:
	ach = GetChar();
	switch (ach)
	{
	case CR:
	case LF:
		goto SkipNoise;

	case LBRACE:
		_token = tokenStartGroup;
		break;

	case RBRACE:
		_token = tokenEndGroup;
		break;

	case BSLASH:
		_token = TokenGetKeyword();
		break;

	case 0:									
		if(_ecParseError == ecUnexpectedEOF)
			break;
		ach = ' ';							// Replace NULL by blank
											// Fall thru to default
	default:
		if( !_pstateStackTop )
		{
			TRACEWARNSZ("Unexpected token in rtf file");
			Assert(_token == tokenEOF);
			if (_ped->Get10Mode())
				_ecParseError = ecUnexpectedToken;	// Signal bad file
		}
		else if (_pstateStackTop->sDest == destObjectData || 
				 _pstateStackTop->sDest == destPicture )
		// not text but data
		{
			_token = (WORD)(tokenObjectDataValue + _pstateStackTop->sDest
							- destObjectData);
			UngetChar();
		}
		else
			_token = TokenGetText(ach);
	}
	return _token;
}


/*
 *	CRTFRead::FInDocTextDest()
 *
 *	@mfunc
 *		Returns a BOOL indicating if the current destination is one in which
 *		we would encounter document text.
 *
 *	@rdesc
 *		BOOL	indicates the current destination may contain document text.
 */
BOOL CRTFRead::FInDocTextDest() const
{
	switch(_pstateStackTop->sDest)
	{
		case destRTF:
		case destField:
		case destFieldResult:
		case destFieldInstruction:
		case destParaNumbering:
		case destParaNumText:
		case destNULL:
			return TRUE;

		case destFontTable:
		case destRealFontName:
		case destObjectClass:
		case destObjectName:
		case destFollowingPunct:
		case destLeadingPunct:
		case destColorTable:
		case destBinary:
		case destObject:
		case destObjectData:
		case destPicture:
		case destDocumentArea:
			return FALSE;
	
		default:
			AssertSz(0, "CRTFRead::FInDocTextDest():  New destination "
							"encountered - update enum in _rtfread.h");
			return TRUE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by richedit.rc
//
#define CUR_CROSS                       104
#define CUR_HAND                        105
#define CUR_ITALIC                      106
#define CUR_SELBAR                      107

#define IDC_DRAGDROPCOPY                109
#define IDC_DRAGDROPMOVE                110
#define IDC_DRAGDROPNONE                111

#if defined(APSTUDIO_INVOKED) || !defined(_MAC)
#define IDC_NOSCROLLH                   112
#define IDC_NOSCROLLV                   113
#define IDC_NOSCROLLVH                  114
#define IDC_SCROLLEAST                  115
#define IDC_SCROLLNE                    116
#define IDC_SCROLLNORTH                 117
#define IDC_SCROLLNW                    118
#define IDC_SCROLLSE                    119
#define IDC_SCROLLSOUTH                 120
#define IDC_SCROLLSW                    121
#define IDC_SCROLLWEST                  122
#define IDB_1DVSCROL                    125
#define IDB_2DSCROL                     126
#define IDB_1DHSCROL                    127
#endif

//Outline support
#if defined(DEBUG) || defined (_RELEASE_ASSERTS_)
#define IDC_MSG							200
#define IDD_ASSERT						201
#define ID_IGNOREALL					202
#define IDD_DEBUG						203
#define	IDC_MEMORY_STATISTICS			1000
#endif
#define BITMAP_ID_SUBTEXT               2100
#define BITMAP_ID_EXPANDED_HEADING      2101
#define BITMAP_ID_COLLAPSED_HEADING     2102
#define BITMAP_ID_EMPTY_HEADING         2103

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        128
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\range.cpp ===
/*
 *  @doc INTERNAL
 *
 *  @module RANGE.C - Implement the CTxtRange Class |
 *
 *      This module implements the internal CTxtRange methods.  See range2.c
 *      for the ITextRange methods
 *
 *  Authors: <nl>
 *      Original RichEdit code: David R. Fulmer <nl>
 *      Christian Fortini <nl>
 *      Murray Sargent <nl>
 *
 *  Revisions: <nl>
 *      AlexGo: update to runptr text ptr; floating ranges, multilevel undo
 *
 *  Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_range.h"
#include "_edit.h"
#include "_text.h"
#include "_rtext.h"
#include "_m_undo.h"
#include "_antievt.h"
#include "_disp.h"
#include "_uspi.h"
#include "_rtfconv.h"
#include "_txtbrk.h"
#include "_font.h"

#ifdef LINESERVICES
#include "_ols.h"
#endif

ASSERTDATA

TCHAR   szEmbedding[] = {WCH_EMBEDDING, 0};

// ===========================  Invariant stuff  ======================================================

#define DEBUG_CLASSNAME CTxtRange
#include "_invar.h"

#ifdef DEBUG
BOOL
CTxtRange::Invariant( void ) const
{
    LONG cpMin, cpMost;
    GetRange(cpMin, cpMost);

    Assert ( cpMin >= 0 );
    Assert ( cpMin <= cpMost );
    Assert ( cpMost <= GetTextLength() );
    Assert ( cpMin != cpMost || cpMost <= GetAdjustedTextLength());

    static LONG numTests = 0;
    numTests++;             // how many times we've been called.

    // make sure the selections are in range.

    return CRchTxtPtr::Invariant();
}
#endif

void CTxtRange::RangeValidateCp(LONG cp, LONG cch)
{
    LONG cchText = GetAdjustedTextLength();
    LONG cpOther = cp - cch;            // Calculate cpOther with entry cp

    _wFlags = FALSE;                    // This range isn't a selection
    _iFormat = -1;                      // Set up the default format, which
                                        //  doesn't get AddRefFormat'd
    ValidateCp(cpOther);                // Validate requested other end
    cp = GetCp();                       // Validated cp
    if(cp == cpOther && cp > cchText)   // IP cannot follow undeletable
        cp = cpOther = SetCp(cchText);  //  EOP at end of story

    _cch = cp - cpOther;                // Store valid length
}

CTxtRange::CTxtRange(CTxtEdit *ped, LONG cp, LONG cch) :
    CRchTxtPtr(ped, cp)
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::CTxtRange");

    RangeValidateCp(cp, cch);
    Update_iFormat(-1);                 // Choose _iFormat

    CNotifyMgr *pnm = ped->GetNotifyMgr();

    if(pnm)
        pnm->Add( (ITxNotify *)this );
}

CTxtRange::CTxtRange(CRchTxtPtr& rtp, LONG cch) :
    CRchTxtPtr(rtp)
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::CTxtRange");

    RangeValidateCp(GetCp(), cch);
    Update_iFormat(-1);                 // Choose _iFormat

    CNotifyMgr *pnm = GetPed()->GetNotifyMgr();

    if(pnm)
        pnm->Add( (ITxNotify *)this );
}

CTxtRange::CTxtRange(const CTxtRange &rg) :
    CRchTxtPtr((CRchTxtPtr)rg)
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::CTxtRange");

    _cch = rg._cch;
    _wFlags = FALSE;                // This range isn't a selection
    _iFormat = -1;                  // Set up the default format, which
                                    //  doesn't get AddRefFormat'd
    Set_iCF(rg._iFormat);

    CNotifyMgr *pnm = GetPed()->GetNotifyMgr();

    if(pnm)
        pnm->Add((ITxNotify *)this);
}

CTxtRange::~CTxtRange()
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::~CTxtRange");

    if(!IsZombie())
    {
        CNotifyMgr *pnm = GetPed()->GetNotifyMgr();
        if(pnm )
            pnm->Remove((ITxNotify *)this);
    }
    ReleaseFormats(_iFormat, -1);
}

CRchTxtPtr& CTxtRange::operator =(const CRchTxtPtr &rtp)
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::operator =");

    _TEST_INVARIANT_ON(rtp)

    LONG cpSave = GetCp();          // Save entry _cp for CheckChange()

    CRchTxtPtr::operator =(rtp);
    CheckChange(cpSave);
    return *this;
}

CTxtRange& CTxtRange::operator =(const CTxtRange &rg)
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::operator =");

    _TEST_INVARIANT_ON( rg );

    LONG cchSave = _cch;            // Save entry _cp, _cch for change check
    LONG cpSave  = GetCp();

    CRchTxtPtr::operator =(rg);
    _cch = rg._cch;                 // Can't use CheckChange(), since don't
                                    //  use _fExtend
    Update_iFormat(-1);
    _TEST_INVARIANT_

    if( _fSel && (cpSave != GetCp() || cchSave != _cch) )
        GetPed()->GetCallMgr()->SetSelectionChanged();

    return *this;
}

/*
 *  CTxtRange::OnPreReplaceRange (cp, cchDel, cchNew, cpFormatMin,
 *                                  cpFormatMax)
 *
 *  @mfunc
 *      called when the backing store changes
 *
 *  @devnote
 *      1) if this range is before the changes, do nothing
 *
 *      2) if the changes are before this range, simply
 *      add the delta change to GetCp()
 *
 *      3) if the changes overlap one end of the range, collapse
 *      that end to the edge of the modifications
 *
 *      4) if the changes are completely internal to the range,
 *      adjust _cch and/or GetCp() to reflect the new size.  Note
 *      that two overlapping insertion points will be viewed as
 *      a 'completely internal' change.
 *
 *      5) if the changes overlap *both* ends of the range, collapse
 *      the range to cp
 *
 *      Note that there is an ambiguous cp case; namely the changes
 *      occur *exactly* at a boundary.  In this case, the type of
 *      range matters.  If a range is normal, then the changes
 *      are assumed to fall within the range.  If the range is
 *      is protected (either in reality or via DragDrop), then
 *      the changes are assumed to be *outside* of the range.
 */
void CTxtRange::OnPreReplaceRange (
    LONG cp,                    //@parm cp at start of change
    LONG cchDel,                //@parm Count of chars deleted
    LONG cchNew,                //@parm Count of chars inserted
    LONG cpFormatMin,           //@parm the min cp of a format change
    LONG cpFormatMax)           //@parm the max cp of a format change
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::OnPreReplaceRange");

    if(CONVERT_TO_PLAIN == cp)
    {
        // We need to dump our formatting because it is gone
        _rpCF.SetToNull();
        _rpPF.SetToNull();

        if(_fSel)
            GetPed()->_fUpdateSelection = TRUE;

        Update_iFormat(-1);
        return;
    }
}

/*
 *  CTxtRange::OnPostReplaceRange (cp, cchDel, cchNew, cpFormatMin,
 *                                  cpFormatMax)
 *
 *  @mfunc
 *      called when the backing store changes
 *
 *  @devnote
 *      1) if this range is before the changes, do nothing
 *
 *      2) if the changes are before this range, simply
 *      add the delta change to GetCp()
 *
 *      3) if the changes overlap one end of the range, collapse
 *      that end to the edge of the modifications
 *
 *      4) if the changes are completely internal to the range,
 *      adjust _cch and/or GetCp() to reflect the new size.  Note
 *      that two overlapping insertion points will be viewed as
 *      a 'completely internal' change.
 *
 *      5) if the changes overlap *both* ends of the range, collapse
 *      the range to cp
 *
 *      Note that there is an ambiguous cp case; namely the changes
 *      occur *exactly* at a boundary.  In this case, the type of
 *      range matters.  If a range is normal, then the changes
 *      are assumed to fall within the range.  If the range is
 *      is protected (either in reality or via DragDrop), then
 *      the changes are assumed to be *outside* of the range.
 */
void CTxtRange::OnPostReplaceRange (
    LONG cp,                    //@parm cp at start of change
    LONG cchDel,                //@parm Count of chars deleted
    LONG cchNew,                //@parm Count of chars inserted
    LONG cpFormatMin,           //@parm Min cp of format change
    LONG cpFormatMax)           //@parm Max cp of format change
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::OnPostReplaceRange");

    // NB!! We can't do invariant testing here, because we could
    // be severely out of date!

    LONG cchtemp;
    LONG cpMin, cpMost;
    LONG cchAdjTextLen;
    LONG delta = cchNew - cchDel;

    Assert (CONVERT_TO_PLAIN != cp);
    GetRange(cpMin, cpMost);

    // This range is before the changes. Note: an insertion pt at cp
    // shouldn't be changed
    if( cp >= cpMost )
    {
        // Double check to see if we need to fix up our format
        // run pointers.  If so, all we need to do is rebind
        // our inherited rich text pointer

        if(cpFormatMin <= cpMost || cpFormatMin == CP_INFINITE)
            InitRunPtrs();

        else
        {
            // It's possible that the format runs changed anyway,
            // e.g., they became allocated, deallocated, or otherwise
            // changed.  Normally, BindToCp takes care of this
            // situation, but we don't want to pay that cost all
            // the time.
            //
            // Note that starting up the rich text subsystem will
            // generate a notification with cpFormatMin == CP_INFINITE
            //
            // So here, call CheckFormatRuns.  This makes sure that
            // the runs are in sync with what CTxtStory has
            // (doing an InitRunPtrs() _only_ if absolutely necessary).
            CheckFormatRuns();
        }
        return;
    }


    // Anywhere in the following that we want to increment the current cp by a
    // delta, we are counting on the following invariant.
    Assert(GetCp() >= 0);

    // Changes are entirely before this range.  Specifically,
    // that's determined by looking at the incoming cp *plus* the number
    // of characters deleted
    if(cp + cchDel < cpMin || _fDragProtection && cp + cchDel <= cpMin)
    {
        cchtemp = _cch;
        BindToCp(GetCp() + delta);
        _cch = cchtemp;
    }
    // The changes are internal to the range or start within the
    // range and go beyond.
    else if( cp >= cpMin && cp <= cpMost )
    {
        // Nobody should be modifying a drag-protected range.  Unfortunately,
        // Ren re-enters us with a SetText call during drag drop, so we need
        // to handle this case 'gracefully'.
        if( _fDragProtection )
        {
            TRACEWARNSZ("REENTERED during a DRAG DROP!! Trying to recover!");
        }

        if( cp + cchDel <= cpMost )
        {
            // Changes are purely internal, so
            // be sure to preserve the active end.  Basically, if
            // GetCp() *is* cpMin, then we only need to update _cch.
            // Otherwise, GetCp() needs to be moved as well
            if( _cch >= 0 )
            {
                Assert(GetCp() == cpMost);
                cchtemp = _cch;
                BindToCp(GetCp() + delta);
                _cch = cchtemp + delta;
            }
            else
            {
                BindToCp(GetCp());
                _cch -= delta;
            }

            // Special case: the range is left with only the final EOP
            // selected. This means all the characters in the range were
            // deleted so we want to move the range back to an insertion
            // point at the end of the text.
            cchAdjTextLen = GetAdjustedTextLength();

            if(GetCpMin() >= cchAdjTextLen && !GetPed()->IsStreaming())
            {
                // Reduce the range to an insertion point
                _cch = 0;
                _fExtend = FALSE;

                // Set the cp to the end of the document.
                SetCp(cchAdjTextLen);
            }
        }
        else
        {
            // Changes extended beyond cpMost.  In this case,
            // we want to truncate cpMost to the *beginning* of
            // the changes (i.e. cp)

            if( _cch > 0 )
            {
                BindToCp(cp);
                _cch = cp - cpMin;
            }
            else
            {
                BindToCp(cpMin);
                _cch = cpMin - cp;
            }
        }
    }
    else if( cp + cchDel >= cpMost )
    {
        // Nobody should be modifying a drag-protected range.  Unfortunately,
        // Ren re-enters us with a SetText call during drag drop, so we need
        // to handle this case 'gracefully'.
        if( _fDragProtection )
        {
            TRACEWARNSZ("REENTERED during a DRAG DROP!! Trying to recover!");
        }

        // Entire range was deleted, so collapse to an insertion point at cp
        BindToCp(cp);
        _cch = 0;
    }
    else
    {
        // Nobody should be modifying a drag-protected range.  Unfortunately,
        // Ren re-enters us with a SetText call during drag drop, so we need
        // to handle this case 'gracefully'.
        if( _fDragProtection )
        {
            TRACEWARNSZ("REENTERED during a DRAG DROP!! Trying to recover!");
        }

        // The change crossed over just cpMin.  In this case move cpMin
        // forward to the unchanged part
        LONG cchdiff = (cp + cchDel) - cpMin;

        Assert( cp + cchDel < cpMost );
        Assert( cp + cchDel >= cpMin );
        Assert( cp < cpMin );

        cchtemp = _cch;
        if( _cch > 0 )
        {
            BindToCp(GetCp() + delta);
            _cch = cchtemp - cchdiff;
        }
        else
        {
            BindToCp(cp + cchNew);
            _cch = cchtemp + cchdiff;
        }
    }

    if( _fSel )
    {
        GetPed()->_fUpdateSelection = TRUE;
        GetPed()->GetCallMgr()->SetSelectionChanged();
    }

    Update_iFormat(-1);                 // Make sure _iFormat is up to date

    _TEST_INVARIANT_
}

/*
 *  CTxtRange::Zombie ()
 *
 *  @mfunc
 *      Turn this range into a zombie (_cp = _cch = 0, NULL ped, ptrs to
 *      backing store arrays.  CTxtRange methods like GetRange(),
 *      GetCpMost(), GetCpMin(), and GetTextLength() all work in zombie mode,
 *      returning zero values.
 */
void CTxtRange::Zombie()
{
    CRchTxtPtr::Zombie();
    _cch = 0;
}

/*
 *  CTxtRange::CheckChange(cpSave, cchSave)
 *
 *  @mfunc
 *      Set _cch according to _fExtend and set selection-changed flag if
 *      this range is a CTxtSelection and the new _cp or _cch differ from
 *      cp and cch, respectively.
 *
 *  @devnote
 *      We can count on GetCp() and cpSave both being <= GetTextLength(),
 *      but we can't leave GetCp() equal to GetTextLength() unless _cch ends
 *      up > 0.
 */
LONG CTxtRange::CheckChange(
    LONG cpSave)        //@parm Original _cp for this range
{
    LONG cchAdj = GetAdjustedTextLength();
    LONG cchSave = _cch;

    if(_fExtend)                                // Wants to be nondegenerate
    {                                           //  and maybe it is
        LONG cp = GetCp();

        _cch = cp - (cpSave - cchSave);
        CheckIfSelHasEOP(cpSave, cchSave);
    }
    else
    {
        _cch = 0;                               // Insertion point
        _fSelHasEOP = FALSE;                    // Selection doesn't contain
        _fSelHasCell = FALSE;                   //  any char, let alone a CR
    }                                           //  or table cell

    if(!_cch && GetCp() > cchAdj)               // If still IP and active end
        CRchTxtPtr::SetCp(cchAdj);              //  follows nondeletable EOP,
                                                //  backspace over that EOP
    LONG cch = GetCp() - cpSave;
    _fMoveBack = cch < 0;

    if(cch || cchSave != _cch)
    {
        Update_iFormat(-1);
        if(_fSel)
            GetPed()->GetCallMgr()->SetSelectionChanged();

        _TEST_INVARIANT_
    }

    return cch;
}

/*
 *  CTxtRange::CheckIfSelHasEOP(cpSave, cchSave)
 *
 *  @mfunc
 *      Maintains _fSelHasEOP = TRUE iff selection contains one or more EOPs.
 *      When cpSave = -1, calculates _fSelHasEOP unconditionally and cchSave
 *      is ignored (it's only used for conditional execution). Else _fSelHasEOP
 *      is only calculated for cases that may change it, i.e., it's assumed
 *      be up to date before the change.
 *
 *  @rdesc
 *      TRUE iff _fSel and _cch
 *
 *  @devnote
 *      Call after updating range _cch
 */
BOOL CTxtRange::CheckIfSelHasEOP(
    LONG cpSave,    //@parm Previous active end cp or -1
    LONG cchSave)   //@parm Previous signed length if cpSave != -1
{
    // _fSelHasEOP only maintained for the selection
    if(!_fSel)
        return FALSE;

    if(!_cch)
    {
        _fSelHasEOP  = FALSE;           // Selection doesn't contain
        _fSelHasCell = FALSE;           //  any char, let alone CR
        return FALSE;
    }

    LONG cpMin, cpMost;
    GetRange(cpMin, cpMost);

    if(cpSave != -1)                    // Selection may have changed
    {                                   // Set up to bypass text scan if
        LONG cpMinPrev, cpMostPrev;     //  selection grew and _fSelHasEOP
                                        //  is already TRUE or got smaller
        cpMinPrev = cpMostPrev = cpSave;//  and _fSelHasEOP is FALSE.

        if(cchSave > 0)                 // Calculate previous cpMin
            cpMinPrev  -= cchSave;      //  and cpMost
        else
            cpMostPrev -= cchSave;

        // Note: _fSelHasCell shouldn't change while in a table, since
        // Update() should always expand to a cell once _fSelHasCell has
        // been deteted.
        if (!_fSelHasEOP && cpMin >= cpMinPrev && cpMost <= cpMostPrev ||
             _fSelHasEOP && cpMin <= cpMinPrev && cpMost >= cpMostPrev)
        {
            return TRUE;                // _fSelHasEOP can't change
        }
    }

    LONG    FEOP_Results;
    CTxtPtr tp(_rpTX);                  // Scan range for an EOP

    tp.SetCp(cpMin);
    tp.FindEOP(cpMost - cpMin, &FEOP_Results);
    _fSelHasCell = (FEOP_Results & FEOP_CELL) != 0;
    _fSelHasEOP  = (FEOP_Results & FEOP_EOP)  != 0;
    return TRUE;
}

/*
 *  CTxtRange::GetRange(&cpMin, &cpMost)
 *
 *  @mfunc
 *      set cpMin  = this range cpMin
 *      set cpMost = this range cpMost
 *      return cpMost - cpMin, i.e. abs(_cch)
 *
 *  @rdesc
 *      abs(_cch)
 */
LONG CTxtRange::GetRange (
    LONG& cpMin,                //@parm Pass-by-ref cpMin
    LONG& cpMost) const         //@parm Pass-by-ref cpMost
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::GetRange");

    LONG cch = _cch;

    if(cch >= 0)
    {
        cpMost  = GetCp();
        cpMin   = cpMost - cch;
    }
    else
    {
        cch     = -cch;
        cpMin   = GetCp();
        cpMost  = cpMin + cch;
    }
    return cch;
}

/*
 *  CTxtRange::GetCpMin()
 *
 *  @mfunc
 *      return this range's cpMin
 *
 *  @rdesc
 *      cpMin
 *
 *  @devnote
 *      If you need cpMost and/or cpMost - cpMin, GetRange() is faster
 */
LONG CTxtRange::GetCpMin() const
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::GetCpMin");

    LONG cp = GetCp();
    return _cch <= 0 ? cp : cp - _cch;
}

/*
 *  CTxtRange::GetCpMost()
 *
 *  @mfunc
 *      return this range's cpMost
 *
 *  @rdesc
 *      cpMost
 *
 *  @devnote
 *      If you need cpMin and/or cpMost - cpMin, GetRange() is faster
 */
LONG CTxtRange::GetCpMost() const
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::GetCpMost");

    LONG cp = GetCp();
    return _cch >= 0 ? cp : cp - _cch;
}

/*
 *  CTxtRange::Update(fScrollIntoView)
 *
 *  @mfunc
 *      Virtual stub routine overruled by CTxtSelection::Update() when this
 *      text range is a text selection.  The purpose is to update the screen
 *      display of the caret or selection to correspond to changed cp's.
 *
 *  @rdesc
 *      TRUE
 */
BOOL CTxtRange::Update (
    BOOL fScrollIntoView)       //@parm TRUE if should scroll caret into view
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::Update");

    return TRUE;                // Simple range has no selection colors or
}                               //  caret, so just return TRUE

/*
 * CTxtRange::SetCp(cp)
 *
 *  @mfunc
 *      Set active end of this range to cp. Leave other end where it is or
 *      collapse range depending on _fExtend (see CheckChange()).
 *
 *  @rdesc
 *      cp at new active end (may differ from cp, since cp may be invalid).
 */
LONG CTxtRange::SetCp(
    LONG cp)            //@parm new cp for active end of this range
{
    TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtRange::SetCp");

    LONG cpSave = GetCp();

    CRchTxtPtr::SetCp(cp);
    CheckChange(cpSave);                    // NB: this changes _cp if after
    return GetCp();                         //  final CR and _cch = 0
}

/*
 *  CTxtRange::Set (cp, cch)
 *
 *  @mfunc
 *      Set this range's active-end cp and signed cch
 */
BOOL CTxtRange::Set (
    LONG cp,                    //@parm Desired active end cp
    LONG cch)                   //@parm Desired signed count of chars
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::Set");

    BOOL bRet    = FALSE;
    LONG cchSave = _cch;            // Save entry _cp, _cch for change check
    LONG cchText = GetAdjustedTextLength();
    LONG cpSave  = GetCp();
    LONG cpOther = cp - cch;        // Desired "other" end

    ValidateCp(cp);                         // Be absolutely sure to validate
    ValidateCp(cpOther);                    //  both ends

    if(cp == cpOther && cp > cchText)       // IP cannot follow undeletable
        cp = cpOther = cchText;             //  EOP at end of story

    CRchTxtPtr::Advance(cp - GetCp());
    AssertSz(cp == GetCp(),
        "CTxtRange::Set: inconsistent cp");

    if(GetPed()->fUseCRLF())
    {
        cch = _rpTX.AdjustCpCRLF();
        if(cch)
        {
            _rpCF.AdvanceCp(cch);           // Keep all 3 runptrs in sync
            _rpPF.AdvanceCp(cch);
            cp = GetCp();
        }
        if(cpOther != cp)
        {
            CTxtPtr tp(_rpTX);
            tp.AdvanceCp(cpOther - cp);
            cpOther += tp.AdjustCpCRLF();
        }
    }

    _cch = cp - cpOther;                    // Validated _cch value
    CheckIfSelHasEOP(cpSave, cchSave);      // Maintain _fSelHasEOP in
                                            //  outline mode
    _fMoveBack = GetCp() < cpSave;

    if(cpSave != GetCp() || cchSave != _cch)
    {
        if(_fSel)
            GetPed()->GetCallMgr()->SetSelectionChanged();

        Update_iFormat(-1);
        bRet = TRUE;
    }

    _TEST_INVARIANT_
    return bRet;
}

/*
 *  CTxtRange::Advance(cch)
 *
 *  @mfunc
 *      Advance active end of range by cch.
 *      Other end stays put iff _fExtend
 *
 *  @rdesc
 *      cch actually moved
 */
LONG CTxtRange::Advance (
    LONG cch)               //@parm Signed char count to move active end
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::Advance");

    LONG cpSave = GetCp();          // Save entry _cp for CheckChange()

    CRchTxtPtr::Advance(cch);
    return CheckChange(cpSave);
}

/*
 *  CTxtRange::AdvanceCRLF()
 *
 *  @mfunc
 *      Advance active end of range one char, treating CRLF as a single char.
 *      Other end stays put iff _fExtend is nonzero.
 *
 *  @rdesc
 *      cch actually moved
 */
LONG CTxtRange::AdvanceCRLF()
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::AdvanceCRLF");

    LONG cpSave = GetCp();          // Save entry _cp for CheckChange()

    CRchTxtPtr::AdvanceCRLF();
    return CheckChange(cpSave);
}

/*
 *  CTxtRange::SnapToCluster(INT iDirection)
 *
 *  @rdesc
 *      cch actually moved
 */
LONG CTxtRange::SnapToCluster(INT iDirection)
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::SnapToCluster");

    LONG cpSave = GetCp();          // Save entry _cp for CheckChange()

    CRchTxtPtr::SnapToCluster(iDirection);
    return CheckChange(cpSave);
}

/*
 *  CTxtRange::BackupCRLF()
 *
 *  @mfunc
 *      Backup active end of range one char, treating CRLF as a single char.
 *      Other end stays put iff _fExtend
 *
 *  @rdesc
 *      cch actually moved
 */
LONG CTxtRange::BackupCRLF(
    BOOL fDiacriticCheck)
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::BackupCRLF");

    LONG cpSave = GetCp();          // Save entry _cp for CheckChange()

    CRchTxtPtr::BackupCRLF(fDiacriticCheck);
    return CheckChange(cpSave);
}

/*
 *  CTxtRange::FindWordBreak(action)
 *
 *  @mfunc
 *      Move active end as determined by plain-text FindWordBreak().
 *      Other end stays put iff _fExtend
 *
 *  @rdesc
 *      cch actually moved
 */
LONG CTxtRange::FindWordBreak (
    INT action)         //@parm action defined by CTxtPtr::FindWordBreak()
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtPtr::FindWordBreak");

    LONG cpSave = GetCp();          // Save entry _cp for CheckChange()

    CRchTxtPtr::FindWordBreak(action);
    return CheckChange(cpSave);
}

/*
 *  CTxtRange::FlipRange()
 *
 *  @mfunc
 *      Flip active and non active ends
 */
void CTxtRange::FlipRange()
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::FlipRange");

    _TEST_INVARIANT_

    CRchTxtPtr::Advance(-_cch);
    _cch = -_cch;
}

/*
 *  CTxtRange::HexToUnicode(publdr)
 *
 *  @mfunc
 *      Convert hex number ending at cpMost to a Unicode character and
 *      replace the hex number by that character. Take into account
 *      Unicode surrogates for hex values from 0x10000 up to 0x10FFFF.
 *
 *  @rdesc
 *      HRESULT S_OK if conversion successful and hex number replaced by
 *      corresponding Unicode character
 */
HRESULT CTxtRange::HexToUnicode (
    IUndoBuilder *publdr)       //@parm UndoBuilder to receive antievents
{
    LONG ch;
    LONG cpMin, cpMost;
    LONG cch = GetRange(cpMin, cpMost);
    LONG i;
    LONG lch = 0;

    if(cch)
    {
        if(cpMost > GetAdjustedTextLength() || cch > 6)
            return S_FALSE;
        Collapser(tomEnd);
    }
    else
        cch = 6;

    SetExtend(TRUE);
    for(i = 0; cch--; i += 4)
    {
        ch = GetPrevChar();
        if(ch == '+')                       // Check for U+xxxx notation
        {                                   // If it's there, set up to
            Advance(-1);                    //  delete the U+ (or u+)
            Advance((GetPrevChar() | 0x20) == 'u' ? -1 : 1);
            break;                          // Else leave the +
        }
        if(ch > 'f' || !IsXDigit(ch))
            break;
        Advance(-1);
        ch |= 0x20;
        ch -= (ch >= 'a') ? 'a' - 10 : '0';
        lch += (ch << i);
    }
    if(!lch || lch > 0x10FFFF)
        return S_FALSE;

    WCHAR str[2] = {(WCHAR)lch};
    cch = 1;
    if(lch > 0xFFFF)
    {
        lch -= 0x10000;
        str[0] = 0xD800 + (lch >> 10);
        str[1] = 0xDC00 + (lch & 0x3FF);
        cch = 2;
    }
    if(publdr)
        publdr->StopGroupTyping();

    _rpCF.AdjustBackward();                 // Use format of run preceding
    Set_iCF(_rpCF.GetFormat());             //  hex number
    _fUseiFormat = TRUE;
    _rpCF.AdjustForward();

    CleanseAndReplaceRange(cch, str, FALSE, publdr, NULL);
    return S_OK;
}

/*
 *  CTxtRange::UnicodeToHex(publdr)
 *
 *  @mfunc
 *      Convert Unicode character(s) preceeding cpMin to a hex number and
 *      select it. Translate Unicode surrogates into corresponding for hex
 *      values from 0x10000 up to 0x10FFFF.
 *
 *  @rdesc
 *      HRESULT S_OK if conversion successful and Unicode character(s) is
 *      replaced by corresponding hex number.
 */
HRESULT CTxtRange::UnicodeToHex (
    IUndoBuilder *publdr)       //@parm UndoBuilder to receive antievents
{
    if(_cch)                            // If there's a selection,
    {                                   //  convert 1st char in sel
        Collapser(tomStart);
        Advance(IN_RANGE(0xD800, CRchTxtPtr::GetChar(), 0xDBFF) ? 2 : 1);
    }
    LONG cp = GetCp();
    if(!cp)                             // No character to convert
        return S_FALSE;

    _cch = 1;                           // Select previous char
    LONG n = GetPrevChar();             // Get it

    _fExtend = TRUE;
    if(publdr)
        publdr->StopGroupTyping();

    if(IN_RANGE(0xDC00, n, 0xDFFF))     // Unicode surrogate trail word
    {
        if(cp <= 1)                     // No lead word
            return S_FALSE;
        Advance(-2);
        LONG ch = CRchTxtPtr::GetChar();
        Assert(IN_RANGE(0xD800, ch, 0xDBFF));
        n = (n & 0x3FF) + ((ch & 0x3FF) << 10) + 0x10000;
        _cch = -2;
    }

    // Convert ch to str
    LONG    cch = 0;
    LONG    quot, rem;                  // ldiv results
    WCHAR   str[6];
    WCHAR * pch = &str[0];

    for(LONG d = 1; d < n; d <<= 4)     // d = smallest power of 16 > n
        ;
    if(n && d > n)
        d >>= 4;

    while(d)
    {
        quot = n / d;                   // Avoid an ldiv
        rem = n % d;
        n = quot + '0';
        if(n > '9')
            n += 'A' - '9' - 1;
        *pch++ = (WCHAR)n;              // Store digit
        cch++;
        n = rem;                        // Setup remainder
        d >>= 4;
    }

    CleanseAndReplaceRange(cch, str, FALSE, publdr, NULL);
    _cch = cch;                         // Select number

    if(_fSel)
        Update(FALSE);

    return S_OK;
}

/*
 *  CTxtRange::IsInputSequenceValid(pch, cchIns, fOver, pfBaseChar)
 *
 *  @mfunc
 *      Verify the sequence of incoming text. Return FALSE if invalid
 *      combination is found. The criteria is to allow any combinations
 *      that are displayable on screen (the simplest approach used by system
 *      edit control).
 *
 *  @rdesc
 *      Return FALSE if invalid combination is found; else TRUE.
 *
 *      FUTURE: We may consider to support bad sequence filter or text streaming. The code
 *      below is easy enough to be extended to do so.
 */
BOOL CTxtRange::IsInputSequenceValid(
    WCHAR*  pwch,           // Inserting string
    LONG    cchIns,         // Character count
    BOOL    fOverType,      // Insert or Overwrite mode
    BOOL*   pfBaseChar)     // Is pwch[0] a cluster start (base char)?
{
    CTxtEdit*       ped = GetPed();
    CTxtPtr         tp(_rpTX);
    HKL             hkl = GetKeyboardLayout(0);
    BOOL            fr = TRUE;

    if (ped->fUsePassword() || ped->_fNoInputSequenceChk)
        return TRUE;        // no check when editing password

    if (PRIMARYLANGID(hkl) == LANG_VIETNAMESE)
    {
        // No concern about overtyping or cluster since we look backward only
        // 1 char and dont care characters following the insertion point.
        if(_cch > 0)
            tp.AdvanceCp(-_cch);
        fr = IsVietCdmSequenceValid(tp.GetPrevChar(), *pwch);
    }
    else if (PRIMARYLANGID(hkl) == LANG_THAI ||
        W32->IsIndicLcid(LOWORD(hkl)))
    {
        // Do complex things for Thai and Indic

        WCHAR           rgwchText[32];
        WCHAR*          pwchText = rgwchText;
        CUniscribe*     pusp = ped->Getusp();
        CTxtBreaker*    pbrk = ped->_pbrk;
        LONG            found = 0;
        LONG            cp, cpSave, cpLimMin, cpLimMax;
        LONG            cchDel = 0, cchText, ich;
        LONG            cpEnd = ped->GetAdjustedTextLength();

        if (_cch > 0)
            tp.AdvanceCp(-_cch);

        cp = cpSave = cpLimMin = cpLimMax = tp.GetCp();

        if (_cch)
        {
            cchDel = abs(_cch);
        }
        else if (fOverType && !tp.IsAtEOP() && cp != cpEnd)
        {
            // Delete up to the next cluster in overtype mode
            cchDel++;
            if (pbrk)
                while (cp + cchDel < cpEnd && !pbrk->CanBreakCp(BRK_CLUSTER, cp + cchDel))
                    cchDel++;
        }
        cpLimMax += cchDel;

        // Figure the min/max boundaries
        if (pbrk)
        {
            // Min boundary
            cpLimMin += tp.FindEOP(tomBackward, &found);
            if (!(found & FEOP_EOP))
                cpLimMin = 0;

            while (--cp > cpLimMin && !pbrk->CanBreakCp(BRK_CLUSTER, cp));
            cpLimMin = max(cp, cpLimMin);       // more precise boundary

            // Max boundary
            cp = cpLimMax;
            tp.SetCp(cpLimMax);
            cpLimMax += tp.FindEOP(tomForward, &found);
            if (!(found & FEOP_EOP))
                cpLimMax = ped->GetTextLength();

            while (cp < cpLimMax && !pbrk->CanBreakCp(BRK_CLUSTER, cp++));
            cpLimMax = min(cp, cpLimMax);       // more precise boundary
        }
        else
        {
            // No cluster info we statically bound to -1/+1 from selection range
            cpLimMin--;
            cpLimMin = max(0, cpLimMin);

            cpLimMax += cchDel + 1;
            cpLimMax = min(cpLimMax, ped->GetTextLength());
        }

        cp = cpSave + cchDel;
        cchText = cpSave - cpLimMin + cchIns + cpLimMax - cp;

        tp.SetCp(cpLimMin);

        if (cchText > 32)
            pwchText = new WCHAR[cchText];

        if (pwchText)
        {
            // prepare text
            cchText = tp.GetText (cpSave - cpLimMin, pwchText);
            tp.AdvanceCp (cchText + cchDel);
            ich = cchText;
            wcsncpy (&pwchText[cchText], pwch, cchIns);
            cchText += cchIns;
            cchText += tp.GetText (cpLimMax - cpSave - cchDel, &pwchText[cchText]);
            Assert (cchText == cpLimMax - cpLimMin - cchDel + cchIns);


            if (pusp)
            {
                SCRIPT_STRING_ANALYSIS  ssa;
                HRESULT                 hr;
                BOOL                    fDecided = FALSE;

                hr = ScriptStringAnalyse(NULL, pwchText, cchText, GLYPH_COUNT(cchText), -1,
                                    SSA_BREAK, -1, NULL, NULL, NULL, NULL, NULL, &ssa);
                if (S_OK == hr)
                {
                    if (fOverType)
                    {
                        const SCRIPT_LOGATTR* psla = ScriptString_pLogAttr(ssa);
                        BOOL    fBaseChar = !psla || psla[ich].fCharStop;

                        if (!fBaseChar)
                        {
                            // In overtype mode, if the inserted char is not a cluster start.
                            // We act like insert mode. Recursive call with fOvertype = FALSE.
                            fr = IsInputSequenceValid(pwch, cchIns, 0, NULL);
                            fDecided = TRUE;
                        }

                        if (pfBaseChar)
                            *pfBaseChar = fBaseChar;
                    }
                    if (!fDecided && S_FALSE == ScriptStringValidate(ssa))
                        fr = FALSE;

                    ScriptStringFree(&ssa);
                }
            }

            if (pwchText != rgwchText)
                delete[] pwchText;
        }
    }
    return fr;
}

/*
 *  CTxtRange::CleanseAndReplaceRange(cch, *pch, fTestLimit, publdr,
 *                                    pchD, pcchMove, dwFlags)
 *  @mfunc
 *      Cleanse the string pch (replace CRLFs by CRs, etc.) and substitute
 *      the resulting string for the text in this range using the CCharFormat
 *      _iFormat and updating other text runs as needed. For single-line
 *      controls, truncate on the first EOP and substitute the truncated
 *      string.  Also truncate if string would overflow the max text length.
 *
 *  @rdesc
 *      Count of new characters added
 */
LONG CTxtRange::CleanseAndReplaceRange (
    LONG            cchS,       //@parm Length of replacement (Source) text
    const WCHAR *   pchS,       //@parm Replacement (Source) text
    BOOL            fTestLimit, //@parm Whether to do limit test
    IUndoBuilder *  publdr,     //@parm UndoBuilder to receive antievents
    WCHAR *         pchD,       //@parm Destination string (multiline only)
    LONG*           pcchMove,   //@parm Count of chars moved in 1st replace
    DWORD           dwFlags)    //@parm ReplaceRange's flags
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::CleanseAndReplaceRange");

    CTxtEdit *     ped = GetPed();
    BYTE           bDefaultCharset = ped->GetCharFormat(-1)->_bCharSet;
    LONG           cchM = 0;
    LONG           cchMove = 0;
    LONG           cchNew = 0;              // Collects total cch inserted
    LONG           cch;                     // Collects cch for cur charset
    DWORD          ch, ch1;
    LONG           cpFirst = GetCpMin();
    DWORD          dw;
    DWORD          dwCharFlags = 0;
    DWORD          dwCharMask = GetCharSetMask();
    DWORD          dwCurrentFontUsed = 0;
	BOOL		   f10Mode = ped->Get10Mode();
    BOOL           fCallerDestination = pchD != 0;  // Save if pchD enters as 0
    BOOL           fDefFontHasASCII = FALSE;
    CFreezeDisplay fd(ped->_pdp);
    BOOL           fMultiLine   = ped->_pdp->IsMultiLine();
    BOOL           fFEBaseFont  = IsFECharSet(bDefaultCharset);
    BOOL           fInTable     = FALSE;
    bool           fUIFont      = fUseUIFont();
    BOOL           fUseCRLF     = ped->fUseCRLF();
    BOOL           fDefFontSymbol = dwCharMask == fSYMBOL;
    const WCHAR *  pch = pchS;
    CTempWcharBuf  twcb;                    // Buffer needed for multiline if
                                            //  pchD = 0
    CCharFormat     CFCurrent;              // Current CF used during IME in progress
    const   DWORD   fALPHA = 0x01;
    BOOL            fDeleteChar = !ped->IsRich() && _cch;

    if (ped->_fIMEInProgress)
    {
        // Initialize data to handle alpha/ASCII dual font mode
        // during IME composition
        dwCurrentFontUsed = fFE;
        CFCurrent = *ped->GetCharFormat(GetiFormat());
    }

    // Check if default font supports full ASCII and Symbol
    if (fUIFont)
    {
        DWORD   dwMaskDefFont = GetCharSetMask(TRUE);
        fDefFontHasASCII = (dwMaskDefFont & fASCII) == fASCII;
        fDefFontSymbol = dwMaskDefFont == fSYMBOL;
    }

    if(!pchS)
        cchS = 0;
    else if(fMultiLine)
    {
        if(cchS < 0)                        // Calculate length for
            cchS = wcslen(pchS);            //  target buffer
        if(cchS && !pchD)
        {
            pchD = twcb.GetBuf(cchS);
            if(!pchD)                       // Couldn't allocate buffer:
                return 0;                   //  give up with no update
        }
        pch = pchD;
        if(_cch <= 0)
            fInTable = GetPF()->InTable();
        else
        {
            CFormatRunPtr rpPF(_rpPF);
            rpPF.AdvanceCp(-_cch);
            fInTable = (ped->GetParaFormat(rpPF.GetFormat())->InTable());
        }
    }
    else if(cchS < 0)                       // Calculate string length
        cchS = tomForward;                  //  while looking for EOP

    for(cch = 0; cchS; cchS--, pchS++, cch++)
    {
        ch = *pchS;
        if(!ch && (!fMultiLine || !fCallerDestination))
            break;

        if(IN_RANGE(CELL, ch, CR))          // Handle CR and LF combos
        {
            if(!fMultiLine && ch >= LF)     // Truncate at 1st EOP to be
                break;                      //  compatible with user.exe SLE
                                            //  and for consistent behavior
            if(ch == CR && !f10Mode)
            {
                if(cchS > 1)
                {
                    ch1 = *(pchS + 1);
                    if(cchS > 2 && ch1 == CR && *(pchS+2) == LF)
                    {
                        if(fUseCRLF)
                        {
                            *pchD++ = ch;
                            *pchD++ = ch1;
                            ch = LF;
                            cch += 2;
                        }
                        else
                        {
                            // Translate CRCRLF to CR or to ' '
                            ch = ped->fXltCRCRLFtoCR() ? CR : ' ';
                        }
                        pchS += 2;          // Bypass two chars
                        cchS -= 2;
                    }
                    else if(ch1 == LF)
                    {
                        if(fUseCRLF && !fInTable)// Copy over whole CRLF
                        {
                            *pchD++ = ch;   // Here we copy CR
                            ch = ch1;       // Setup to copy LF
                            cch++;
                        }
                        pchS++;
                        cchS--;
                    }
                }
                if(fInTable && ch == CR)    // Our simple tables can't contain
                    ch = ' ';               //  CRs or CELLs
            }
            else if(!fUseCRLF && ch == LF)  // Treat lone LFs as EOPs, i.e.,
                ch = CR;                    //  be nice to Unix text files

            else if(ch == CELL && fInTable)
                ch = ' ';
        }
        else if((ch | 1) == PS)             // Translate Unicode para/line
        {                                   //  separators into CR/VT
            if(!fMultiLine)
                break;
            ch = (ch == PS) ? CR : VT;
        }

        dw = fSYMBOL;
        if(!fDefFontSymbol)
            dw = GetCharFlags(ch, bDefaultCharset);     // Check for complex scripts,
        dwCharFlags |= dw;                              // FE, and charset changes
        dw &= ~0xFF;                                    // Exclude non-fontbind flags
        if(ped->IsAutoFont() && !fDefFontSymbol)
        {
            BOOL fReplacedText = FALSE;

            if (fDeleteChar)
            {
                fDeleteChar = FALSE;
                ReplaceRange(0, NULL, publdr, SELRR_REMEMBERRANGE, NULL, RR_ITMZ_NONE);
                Set_iCF(-1);
                dwCharMask = GetCharSetMask(TRUE);
            }

            if (!ped->_fIMEInProgress)
            {
                // Simp. Chinese uses some of the Latin2 symbols
                if (dw == fLATIN2 || IN_RANGE(0x0250, ch, 0x02FF)
                    || IN_RANGE(0xFE50, ch, 0xFE6F))
                {
                    WCHAR   wch = ch;
                    if (VerifyFEString(CP_CHINESE_SIM, &wch, 1, TRUE) == CP_CHINESE_SIM ||
                        VerifyFEString(CP_CHINESE_TRAD, &wch, 1, TRUE) == CP_CHINESE_TRAD)
                        dw = fCHINESE;
                }

                if (fUIFont && dw == fHILATIN1 && fFEBaseFont)
                {
                    // Use Ansi font for HiAnsi
                    if (dwCurrentFontUsed != fHILATIN1)
                    {
                        fReplacedText = TRUE;
                        cchNew += CheckLimitReplaceRange(cch, pch, fTestLimit, publdr,
                            dw, &cchM, cpFirst, IGNORE_CURRENT_FONT, RR_ITMZ_NONE); // Replace text up to previous char
                    }
                    dwCurrentFontUsed = fHILATIN1;
                }
                else if (fUIFont && fDefFontHasASCII &&
                    (dw & fASCII || IN_RANGE(0x2018, ch, 0x201D)))
                {
                    if (dwCurrentFontUsed != fASCII)
                    {
                        cchNew += CheckLimitReplaceRange(cch, pch, fTestLimit, publdr,
                            0, &cchM, cpFirst, IGNORE_CURRENT_FONT, RR_ITMZ_NONE);  // Replace text up to previous char

                        // Use the -1 font charset/face/size so the current font effect
                        // will still be used.
                        CCharFormat CFDefault = *ped->GetCharFormat(-1);
                        SetCharFormat(&CFDefault, 0, publdr, CFM_CHARSET | CFM_FACE | CFM_SIZE,
                                 CFM2_CHARFORMAT | CFM2_NOCHARSETCHECK);

                        fReplacedText = TRUE;
                    }
                    dwCurrentFontUsed = fASCII;
                }
                else if (dw && !(dw & dwCharMask)   // No match: need charset change
                     || dwCurrentFontUsed)          //  or change in classification
                {
                    fReplacedText = TRUE;
                    dwCurrentFontUsed = 0;
                    if(dw & (fCHINESE | fBIG5) & ~255)  // If Han char, check next few
                    {                                   //  chars for a Hangul or Kana
                        Assert(cchS);
                        const WCHAR *pchT = pchS+1;
                        LONG i = min(10, cchS - 1);

                        while(i-- && *pchT)
                            dw |= GetCharFlags(*pchT++, bDefaultCharset);

                        i = CalcTextLenNotInRange();
                        if(cchS < 6 && i)           // Get flags around range
                        {
                            CTxtPtr tp(_rpTX);
                            i = min(i, 6);
                            if(!_cch)               // For insertion point, backup
                                tp.AdvanceCp(-i/2); //  half way
                            else if(_cch < 0)       // Active end at cpMin, backup
                                tp.AdvanceCp(-i);   //  whole way
                            for(; i--; tp.AdvanceCp(1))
                                dw |= GetCharFlags(tp.GetChar(), bDefaultCharset);
                        }
                        dw &= (fKANA | fHANGUL | fCHINESE | fBIG5);
                    }
                    else if(dw & (fHILATIN1 | fLATIN2) && dwCharMask & fLATIN)
                    {
                        LONG i = dwCharMask & fLATIN;
                        dw = W32->GetCharFlags125x(ch) & fLATIN;
                        if(!(dw & i))
                            for(i = 0x100; i < 0x20000 && !(dw & i); i <<= 1)
                                ;
                        dw &= i;
                    }

                    cchNew += CheckLimitReplaceRange(cch, pch, fTestLimit, publdr,
                        dw, &cchM, cpFirst, MATCH_FONT_SIG, RR_ITMZ_NONE);  // Replace text up to previous char
                }
            }
            else
            {
                // IME in progress, only need to check ASCII cases
                BOOL    fHandled = FALSE;

                if (ch <= 0x7F)
                {
                    if (fUIFont)
                    {
                        // Use default font
                        if (dwCurrentFontUsed != fASCII)
                        {
                            cchNew += CheckLimitReplaceRange(cch, pch, fTestLimit, publdr,
                                0, &cchM, cpFirst, IGNORE_CURRENT_FONT, RR_ITMZ_NONE);  // Replace text up to previous char

                            // Use the -1 font charset/face/size so the current font effect
                            // will still be used.
                            CCharFormat CFDefault = *ped->GetCharFormat(-1);
                            SetCharFormat(&CFDefault, 0, publdr, CFM_CHARSET | CFM_FACE | CFM_SIZE,
                                     CFM2_CHARFORMAT | CFM2_NOCHARSETCHECK);

                            fReplacedText = TRUE;
                        }
                        dwCurrentFontUsed = fASCII;
                        fHandled = TRUE;
                    }
                    else if (ped->_fDualFont && IsAlpha(ch))
                    {
                        // Use English Font
                        if (dwCurrentFontUsed != fALPHA)
                        {

                            cchNew += CheckLimitReplaceRange(cch, pch, fTestLimit, publdr,
                                dw, &cchM, cpFirst, IGNORE_CURRENT_FONT, RR_ITMZ_NONE); // Replace text up to previous char
                            fReplacedText = TRUE;
                        }
                        dwCurrentFontUsed = fALPHA;
                        fHandled = TRUE;
                    }
                }

                // Use current FE font
                if (!fHandled)
                {
                    if (dwCurrentFontUsed != fFE)
                    {
                        cchNew += CheckLimitReplaceRange(cch, pch, fTestLimit, publdr,
                            0, &cchM, cpFirst, IGNORE_CURRENT_FONT, RR_ITMZ_NONE);  // Replace text up to previous char
                        SetCharFormat(&CFCurrent, 0, publdr, CFM_CHARSET | CFM_FACE | CFM_SIZE,
                            CFM2_CHARFORMAT | CFM2_NOCHARSETCHECK);
                        fReplacedText = TRUE;
                    }
                    dwCurrentFontUsed = fFE;
                }
            }

            if (fReplacedText)
            {
                dwCharMask = (dw & fSYMBOL) ? fSYMBOL : GetCharSetMask();
                if(cchM)
                    cchMove = cchM;         // Can only happen on 1st replace
                pch = fMultiLine ? pchD : pchS;
                cch = 0;
            }
        }
        if(fMultiLine)                      // In multiline controls, collect
        {                                   //  possibly translated chars
            if(dw & fSYMBOL)                // Convert 0xF000 thru 0xF0FF to
                ch &= 0xFF;                 //  SYMBOL_CHARSET with 0x00 thru
            *pchD++ = ch;                   //  0xFF. FUTURE: make work for
        }                                   //  single line too...
    }
    ped->OrCharFlags(dwCharFlags, publdr);

    cchNew += CheckLimitReplaceRange(cch, pch, fTestLimit, publdr, 0, &cchM, cpFirst,
                                    IGNORE_CURRENT_FONT, RR_ITMZ_NONE);
    if(cchM)
        cchMove = cchM;                     // Can only happen on 1st replace

    if (pcchMove)
        *pcchMove = cchMove;

    if (ped->IsComplexScript())
    {
        if (dwFlags & RR_ITMZ_NONE || ped->IsStreaming())
            ped->_fItemizePending = TRUE;
        else
            ItemizeReplaceRange(cchNew, cchMove, publdr, dwFlags & RR_ITMZ_UNICODEBIDI);
    }
    return cchNew;
}

/*
 *  CTxtRange::CheckLimitReplaceRange(cchNew, *pch, fTestLimit, publdr,
 *                                    dwFlags, pcchMove, prp, iMatchCurrent, dwFlags)
 *  @mfunc
 *      Replace the text in this range by pch using CCharFormat _iFormat
 *      and updating other text runs as needed.
 *
 *  @rdesc
 *      Count of new characters added
 *
 *  @devnote
 *      moves this text pointer to end of replaced text and
 *      may move text block and formatting arrays
 */
LONG CTxtRange::CheckLimitReplaceRange (
    LONG            cch,            //@parm Length of replacement text
    TCHAR const *   pch,            //@parm Replacement text
    BOOL            fTestLimit,     //@parm Whether to do limit test
    IUndoBuilder *  publdr,         //@parm UndoBuilder to receive antievents
    DWORD           dwCharFlags,    //@parm CharFlags following pch
    LONG *          pcchMove,       //@parm Count of chars moved in 1st replace
    LONG            cpFirst,        //@parm Starting cp for font binding
    int             iMatchCurrent,  //@parm Font matching method
    DWORD           dwFlags)        //@parm ReplaceRange's flags
{
    CTxtEdit *ped = GetPed();

    if(cch || _cch)
    {
        if(fTestLimit)
        {
            LONG    cchLen = CalcTextLenNotInRange();
            DWORD   cchMax = ped->TxGetMaxLength();
            if((DWORD)(cch + cchLen) > cchMax)  // New plus old count exceeds
            {                                   //  max allowed, so truncate
                cch = cchMax - cchLen;          //  down to what fits
                cch = max(cch, 0);              // Keep it positive
                ped->GetCallMgr()->SetMaxText(); // Report exceeded
            }
        }

        if (cch && ped->IsAutoFont() && !ped->_fIMEInProgress)
        {
            LONG iFormatTemp;
            if (fUseUIFont() && GetAdjustedTextLength() != _cch)
            {
                // Delete the old string first so _iFormat is defined
                ReplaceRange(0, NULL, publdr, SELRR_REMEMBERRANGE, pcchMove, dwFlags);
                iFormatTemp = _iFormat;
            }
            else
                iFormatTemp = GetiFormat();

            BYTE bCharSetCurrent = ped->GetCharFormat(iFormatTemp)->_bCharSet;

            if (IsFECharSet(bCharSetCurrent))
            {
                // Check if current font can handle this string.
                INT     cpgCurrent = GetCodePage(bCharSetCurrent);
                INT     cpgNew = VerifyFEString(cpgCurrent, pch, cch, FALSE);

                if (cpgCurrent != cpgNew)
                {
                    // Setup the new CodePage to handle this string
                    CCharFormat CF;
                    CCFRunPtr   rp(_rpCF, ped);
                    rp.AdvanceCp(cpFirst - GetCp());

                    CF._bCharSet = GetCharSet(cpgNew);

                    if(rp.GetPreferredFontInfo(cpgNew, CF._bCharSet, CF._iFont, CF._yHeight,
                            CF._bPitchAndFamily, _iFormat, iMatchCurrent))
                    {
                        SetCharFormat(&CF, 0, publdr, CFM_CHARSET | CFM_FACE | CFM_SIZE,
                             CFM2_CHARFORMAT | CFM2_NOCHARSETCHECK);
                    }
                }
            }
        }
        cch = ReplaceRange(cch, pch, publdr, SELRR_REMEMBERRANGE, pcchMove, dwFlags);
    }

    if(dwCharFlags)
    {
        CCharFormat CF;
        CCFRunPtr   rp(_rpCF, ped);
        rp.AdvanceCp(cpFirst - GetCp());

        // If following string contains Hangul or Kana, use Korean or Japanese
        // font signatures, respectively. Else use incoming dwCharFlags
        dwCharFlags &= ~255;
        if(dwCharFlags & fHANGUL)
            dwCharFlags = fHANGUL;
        else if(dwCharFlags & fKANA)
            dwCharFlags = fKANA;
        else if(dwCharFlags & fBIG5)
            dwCharFlags = fBIG5;
        else
            Assert(!(dwCharFlags & fCHINESE) || dwCharFlags == (fCHINESE & ~255));

        LONG i = W32->ScriptIndexFromFontSig(dwCharFlags >> 8);

        CF._bCharSet = GetCharSet(i, NULL);

        if(rp.GetPreferredFontInfo(i, CF._bCharSet, CF._iFont, CF._yHeight,
                CF._bPitchAndFamily, (_cch ? -1 : _iFormat), iMatchCurrent))
        {
            SetCharFormat(&CF, 0, publdr, CFM_CHARSET | CFM_FACE | CFM_SIZE,
                 CFM2_CHARFORMAT | CFM2_NOCHARSETCHECK);
        }
    }
    return cch;
}

/*
 *  CTxtRange::ReplaceRange(cchNew, *pch, publdr. selaemode, pcchMove)
 *
 *  @mfunc
 *      Replace the text in this range by pch using CCharFormat _iFormat
 *      and updating other text runs as needed.
 *
 *  @rdesc
 *      Count of new characters added
 *
 *  @devnote
 *      moves this text pointer to end of replaced text and
 *      may move text block and formatting arrays
 */
LONG CTxtRange::ReplaceRange (
    LONG            cchNew,     //@parm Length of replacement text
    TCHAR const *   pch,        //@parm Replacement text
    IUndoBuilder *  publdr,     //@parm UndoBuilder to receive antievents
    SELRR           selaemode,  //@parm Controls how selection antievents are to be generated.
    LONG*           pcchMove,   //@parm number of chars moved after replace
    DWORD           dwFlags)    //@parm Special flags
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::ReplaceRange");

    LONG lRet;
    LONG iFormat = _iFormat;
    BOOL fReleaseFormat = FALSE;
    ICharFormatCache * pcf = GetCharFormatCache();

    _TEST_INVARIANT_

    if(!(cchNew | _cch))                    // Nothing to add or delete,
    {                                       //  so we're done
        if(pcchMove)
            *pcchMove = 0;
        return 0;
    }

    if(publdr && selaemode != SELRR_IGNORE)
    {
        Assert(selaemode == SELRR_REMEMBERRANGE);
        HandleSelectionAEInfo(GetPed(), publdr, GetCp(), _cch,
                GetCpMin() + cchNew, 0, SELAE_MERGE);
    }

    if(_cch > 0)
        FlipRange();

    // If we are replacing a non-degenerate selection, then the Word95
    // UI specifies that we should use the rightmost formatting at cpMin.
    if(_cch < 0 && _rpCF.IsValid() && !_fDualFontMode && !_fUseiFormat)
    {
        _rpCF.AdjustForward();
        iFormat = _rpCF.GetFormat();

        // This is a bit icky, but the idea is to stabilize the
        // reference count on iFormat.  When we get it above, it's
        // not addref'ed, so if we happen to delete the text in the
        // range and the range is the only one with that format,
        // then the format will go away.
        pcf->AddRef(iFormat);
        fReleaseFormat = TRUE;
    }
    _fUseiFormat = FALSE;

    LONG cchForReplace = -_cch;
    _cch = 0;
    lRet = CRchTxtPtr::ReplaceRange(cchForReplace, cchNew, pch, publdr,
                iFormat, pcchMove, dwFlags);
    if(lRet)
        _fMoveBack = FALSE;

    Update_iFormat(fReleaseFormat ? iFormat : -1);

    if(fReleaseFormat)
    {
        Assert(pcf);
        pcf->Release(iFormat);
    }

    return lRet;
}

/*
 *  CTxtRange::Delete(publdr. selaemode)
 *
 *  @mfunc
 *      Delete text in this range.
 */
void CTxtRange::Delete (
    IUndoBuilder *  publdr,     //@parm UndoBuilder to receive antievents
    SELRR           selaemode)  //@parm Controls generation of selection antievents
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::Delete");

    if(!_cch)
        return;                         // Nothing to delete

    if(!GetPed()->IsBiDi())
    {
        ReplaceRange(0, NULL, publdr, selaemode, NULL);
        return;
    }

    CFreezeDisplay fd(GetPed()->_pdp);

    ReplaceRange(0, NULL, publdr, selaemode);
}

/*
 *  CTxtRange::GetCharFormat(pCF, flags)
 *
 *  @mfunc
 *      Set *pCF = CCharFormat for this range. If cbSize = sizeof(CHARFORMAT)
 *      only transfer CHARFORMAT data.
 *
 *  @rdesc
 *      Mask of unchanged properties over range (for CHARFORMAT::dwMask)
 *
 *  @devnote
 *      NINCH means No Input No CHange (a Microsoft Word term). Here used for
 *      properties that change during the range of cch characters.  NINCHed
 *      properties in a Word-Font dialog have grayed boxes. They are indicated
 *      by zero values in their respective dwMask bit positions. Note that
 *      a blank at the end of the range does not participate in the NINCH
 *      test, i.e., it can have a different CCharFormat without zeroing the
 *      corresponding dwMask bits.  This is done to be compatible with Word
 *      (see also CTxtSelection::SetCharFormat when _fWordSelMode is TRUE).
 */
DWORD CTxtRange::GetCharFormat (
    CCharFormat *pCF,       //@parm CCharFormat to fill with results
    DWORD flags) const      //@parm flags
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::GetCharFormat");
    _TEST_INVARIANT_

    CTxtEdit * const ped = GetPed();

    if(!_cch || !_rpCF.IsValid())                   // IP or invalid CF
    {                                               //  run ptr: use CF at
        *pCF = *ped->GetCharFormat(_iFormat);       //  this text ptr
        return CFM_ALL2;
    }

    LONG          cpMin, cpMost;                    // Nondegenerate range:
    LONG          cch = GetRange(cpMin, cpMost);    //  need to scan
    LONG          cchChunk;                         // cch in CF run
    DWORD         dwMask = CFM_ALL2;                // Initially all prop def'd
    LONG          iDirection;                       // Direction of scan
    CFormatRunPtr rp(_rpCF);                        // Nondegenerate range

    /*
     * The code below reads character formatting the way Word does it,
     * that is, by not including the formatting of the last character in the
     * range if that character is a blank.
     *
     * See also the corresponding code in CTxtSelection::SetCharFormat().
     */

    if(cch > 1 && _fSel && (flags & SCF_USEUIRULES))// If more than one char,
    {                                               //  don't include trailing
        CTxtPtr tp(ped, cpMost - 1);                //  blank in NINCH test
        if(tp.GetChar() == ' ')
        {                                           // Have trailing blank:
            cch--;                                  //  one less char to check
            if(_cch > 0)                            // Will scan backward, so
                rp.AdvanceCp(-1);                   //  backup before blank
        }
    }

    if(_cch < 0)                                    // Setup direction and
    {                                               //  initial cchChunk
        iDirection = 1;                             // Scan forward
        rp.AdjustForward();
        cchChunk = rp.GetCchLeft();                 // Chunk size for _rpCF
    }
    else
    {
        iDirection = -1;                            // Scan backward
        rp.AdjustBackward();                        // If at BOR, go to
        cchChunk = rp.GetIch();                     //  previous EOR
    }

    *pCF = *ped->GetCharFormat(rp.GetFormat());     // Initialize *pCF to
                                                    //  starting format
    while(cchChunk < cch)                           // NINCH properties that
    {                                               //  change over the range
        cch -= cchChunk;                            //  given by cch
        if(!rp.ChgRun(iDirection))                  // No more runs
            break;                                  //  (cch too big)
        cchChunk = rp.GetRun(0)->_cch;

        const CCharFormat *pCFTemp = ped->GetCharFormat(rp.GetFormat());

        dwMask &= ~pCFTemp->Delta(pCF,              // NINCH properties that
                        flags & CFM2_CHARFORMAT);   //  changed, i.e., reset
    }                                               //  corresponding bits
    return dwMask;
}

/*
 *  CTxtRange::SetCharFormat(pCF, flags, publdr, dwMask, dwMask2)
 *
 *  @mfunc
 *      apply CCharFormat *pCF to this range.  If range is an insertion point,
 *      and (flags & SCF_WORD) != 0, then apply CCharFormat to word surrounding
 *      this insertion point
 *
 *  @rdesc
 *      HRESULT = (successfully set whole range) ? NOERROR : S_FALSE
 *
 *  @devnote
 *      SetParaFormat() is similar, but simpler, since it doesn't have to
 *      special case insertion-point ranges or worry about bullet character
 *      formatting, which is given by EOP formatting.
 */
HRESULT CTxtRange::SetCharFormat (
    const CCharFormat *pCF, //@parm CCharFormat to fill with results
    DWORD         flags,    //@parm SCF_WORD OR SCF_IGNORESELAE
    IUndoBuilder *publdr,   //@parm Undo builder to use
    DWORD         dwMask,   //@parm CHARFORMAT2 mask
    DWORD         dwMask2)  //@parm Second mask
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::SetCharFormat");

    LONG                cch = -_cch;            // Defaults for _cch <= 0
    LONG                cchBack = 0;            // cch to back up for formatting
    LONG                cchFormat;              // cch for formatting
    CCharFormat         CF;                     // Temporary CF
    LONG                cp;
    LONG                cpMin, cpMost;
    LONG                cpStart = 0;
    LONG                cpWordMin, cpWordMost;
    BOOL                fApplyToEOP = FALSE;
    BOOL                fProtected = FALSE;
    HRESULT             hr = NOERROR;
    LONG                iCF;
    CTxtEdit * const    ped = GetPed();         //  defined and not style
    ICharFormatCache *  pf = GetCharFormatCache();
    CFreezeDisplay      fd(ped->_pdp);

    _TEST_INVARIANT_

    if(!Check_rpCF())                           // Not rich
        return NOERROR;

    if(_cch > 0)                                // Active end at range end
    {
        cchBack = -_cch;                        // Setup to back up to
        cch = _cch;                             //  start of format area
    }
    else if(_cch < 0)
        _rpCF.AdjustForward();

    else if(!cch && (flags & (SCF_WORD | SCF_USEUIRULES)))
    {
        BOOL fCheckEOP = TRUE;
        if(flags & SCF_WORD)
        {
            FindWord(&cpWordMin, &cpWordMost, FW_EXACT);

            // If nearest word is within this range, calculate cchback and cch
            // so that we can apply the given format to the word
            if(cpWordMin < GetCp() && GetCp() < cpWordMost)
            {
                // RichEdit 1.0 made 1 final check: ensure word's format
                // is constant w.r.t. the format passed in
                CTxtRange rg(*this);

                rg.Set(cpWordMin, cpWordMin - cpWordMost);
                fProtected = rg.WriteAccessDenied();
                if(!fProtected && (rg.GetCharFormat(&CF) & dwMask) == dwMask)
                {
                    cchBack = cpWordMin - GetCp();
                    cch = cpWordMost - cpWordMin;
                }
                fCheckEOP = FALSE;
            }
        }
        if(fCheckEOP && _rpTX.IsAtEOP() && !GetPF()->_wNumbering)
        {
            CTxtPtr tp(_rpTX);
            cch = tp.AdvanceCpCRLF();
            _rpCF.AdjustForward();              // Go onto format EOP
            fApplyToEOP = TRUE;

            // Apply the characterset and face to EOP because EOP can be in any charset
            dwMask2 |= CFM2_NOCHARSETCHECK;
        }
    }
    cchFormat = cch;

    BOOL fApplyStyle = pCF->fSetStyle(dwMask, dwMask2);

    if(!cch)                                    // Set degenerate-range (IP)
    {                                           //  CF
LApplytoIP:
        DWORD dwMsk = dwMask;
        dwMask2 |= CFM2_NOCHARSETCHECK;
        CF = *ped->GetCharFormat(_iFormat);     // Copy current CF at IP to CF
        if ((CF._dwEffects & CFE_LINK) &&       // Don't allow our URL
            ped->GetDetectURL())                //  formatting to be changed
        {
            dwMsk &= ~CFM_LINK;
        }
        if(fApplyStyle)
            CF.ApplyDefaultStyle(pCF->_sStyle);
        hr = CF.Apply(pCF, dwMsk, dwMask2);     // Apply *pCF
        if(hr != NOERROR)                       // Cache result if new
            return hr;
        hr = pf->Cache(&CF, &iCF);              // In any case, get iCF
        if(hr != NOERROR)                       //  (which AddRef's it)
            return hr;

#ifdef LINESERVICES
        if (g_pols)
            g_pols->DestroyLine(NULL);
#endif

        pf->Release(_iFormat);
        _iFormat = iCF;
        if(fProtected)                          // Signal to beep if UI
            hr = S_FALSE;
    }
    else                                        // Set nondegenerate-range CF
    {                                           // Get start of affected area
        CNotifyMgr *pnm = NULL;

        if (!(flags & SCF_IGNORENOTIFY))
        {
            pnm = ped->GetNotifyMgr();              // Get the notification mgr
            if(pnm)
            {
                cpStart = GetCp() + cchBack;        // Bulletting may move
                                                    //  affected area back if
                if(GetPF()->_wNumbering)            //  formatting hits EOP that
                {                                   //  affects bullet at BOP
                    FindParagraph(&cpMin, &cpMost);

                    if(cpMost <= GetCpMost())
                        cpStart = cpMin;
                }
                pnm->NotifyPreReplaceRange(this,    // Notify interested parties of
                    CP_INFINITE, 0, 0, cpStart,     // the impending update
                        cpStart + cchFormat);
            }
        }

        _rpCF.AdvanceCp(cchBack);               // Back up to formatting start
        CFormatRunPtr rp(_rpCF);                // Clone _rpCF to walk range

        cp = GetCp() + cchBack;
        if(publdr)
        {
            LONG    cchBackup = 0, cchAdvance = 0;
            if (ped->IsBiDi())
            {
                CRchTxtPtr  rtp(*this);
                rtp._rpCF.AdvanceCp(-cchBack);  // restore previous _rpCF
                rtp.Advance(cchBack);
                cchBackup = rtp.ExpandRangeFormatting(cch, 0, cchAdvance);
                Assert(cchBackup >= 0);
            }
            rp.AdvanceCp(-cchBackup);

            IAntiEvent *pae = gAEDispenser.CreateReplaceFormattingAE(
                                ped, rp, cch + cchBackup + cchAdvance, pf, CharFormat);

            rp.AdvanceCp(cchBackup);
            if(pae)
                publdr->AddAntiEvent(pae);
        }

        // Following Word, we translate runs for 8-bit charsets to/from
        // SYMBOL_CHARSET
        LONG    cchRun;
        LONG    cchTrans;
        UINT    CodePage = 0;
        DWORD   dwFontSig = 0;
        DWORD   dwMaskSave  = dwMask;
        DWORD   dwMask2Save = dwMask2;
        LONG    cchSkip     = 0;
        BOOL    fSymbolCharSet = IsSymbolOrOEM(pCF->_bCharSet);
        BOOL    fBiDiCharSet = IsBiDiCharSet(pCF->_bCharSet);
        BOOL    fFECharSet = IsFECharSet(pCF->_bCharSet);
        BOOL    fFontCheck = (dwMask2 & CFM2_MATCHFONT);
        BOOL    fInRange;
        CTxtPtr tp(_rpTX);

        if(fFontCheck && !fSymbolCharSet)
        {
            GetFontSignatureFromFace(pCF->_iFont, &dwFontSig);
            if(!dwFontSig)
                dwFontSig = GetFontSig(pCF->_bCharSet);
        }

        if (ped->_fIMEInProgress && !(dwMask2 & CFM2_SCRIPT))
            dwMask2 |= CFM2_NOCHARSETCHECK;     // Don't check charset or it will display garbage

        while(cch > 0 && rp.IsValid())
        {
            CF = *ped->GetCharFormat(rp.GetFormat());// Copy rp CF to temp CF
            if(fApplyStyle)
                CF.ApplyDefaultStyle(pCF->_sStyle);
            cchRun = cch;

            if (CF._dwEffects & CFE_RUNISDBCS)
            {
                // Don't allow charset/face name change for DBCS run
                // causing these are garbage characters
                dwMask &= ~(CFM_CHARSET | CFM_FACE);
            }
            else if(fFontCheck)                     // Only apply font if it
            {                                   //  supports run's charset
                cchRun = rp.GetCchLeft();       // Translate up to end of
                cchRun = min(cch, cchRun);      //  current CF run
                dwMask &= ~CFM_CHARSET;         // Default no charset change

                if(cchSkip)
                {                               // Skip cchSkip chars (were
                    cchRun = cchSkip;           //  not translatable with
                    cchSkip = 0;                //  CodePage)
                }
                else if(fSymbolCharSet ^ IsSymbolOrOEM(CF._bCharSet))
                {                               // SYMBOL to/from nonSYMBOL
                    CodePage = GetCodePage(fSymbolCharSet ? CF._bCharSet : pCF->_bCharSet);
                    if(!Is8BitCodePage(CodePage))
                        goto DoASCII;

                    dwMask |= CFM_CHARSET;      // Need to change charset
                    if(fSymbolCharSet)
                        CF._wCodePageSave = CodePage;
                    else if(Is8BitCodePage(CF._wCodePageSave))
                    {
                        CodePage = CF._wCodePageSave;
                        CF._bCharSet = GetCharSet(CodePage);
                        dwMask &= ~CFM_CHARSET; // Already changed
                    }

                    tp.SetCp(cp);               // Point tp at start of run
                    cchTrans = tp.TranslateRange(cchRun, CodePage, fSymbolCharSet,
                                                 publdr /*, cchSkip */);
                    if(cchTrans < cchRun)       // Ran into char not in
                    {                           //  CodePage, so set up to
                        cchSkip = 1;            //  skip the char
                        cchRun = cchTrans;      // FUTURE: use cchSkip out
                        if(!cchRun)             //  parm from TranslateRange
                            continue;           //  instead of skipping 1 char
                    }                           //  at a time
                }
                else if(!fSymbolCharSet)
                {
DoASCII:            tp.SetCp(cp);               // Point tp at start of run
                    fInRange = tp.GetChar() < 0x80;

                    if (!fBiDiCharSet && !IsBiDiCharSet(CF._bCharSet) &&
                        fInRange &&
                        ((dwFontSig & fASCII >> 8) == fASCII >> 8 || fFECharSet || fSymbolCharSet))
                    {
                        // ASCII text and new font supports ASCII

                        // -FUTURE-
                        // We exlude BiDi here. We cannot allow applying BiDi charset to non-BiDi run or vice versa.
                        // This because we use charset for BiDi reordering. In the future we should
                        // evolve to something more elegant than charset.

                        if (!(GetFontSig(CF._bCharSet) & ~(fASCII >> 8) & dwFontSig))

                            // New font doesnt support underlying charset,
                            // apply new charset to ASCII

                            dwMask |= CFM_CHARSET;
                    }
                    else if (!(GetFontSig(CF._bCharSet) & ~(fASCII >> 8) & dwFontSig))

                        // New font doesnt support underlying charset,
                        // suppress both new charset and facename

                        dwMask &= ~CFM_FACE;

                    cchRun -= tp.MoveWhile(cchRun, 0, 0x7F, fInRange);
                }
            }
            hr = CF.Apply(pCF, dwMask, dwMask2);// Apply *pCF
            if(hr != NOERROR)
                return hr;
            dwMask = dwMaskSave;                // Restore mask in case
            dwMask2 = dwMask2Save;              //  changed above
            hr = pf->Cache(&CF, &iCF);          // Cache result if new, In any
            if(hr != NOERROR)                   //  cause, use format index iCF
                break;

#ifdef LINESERVICES
            if (g_pols)
                g_pols->DestroyLine(NULL);
#endif

            cchRun = rp.SetFormat(iCF, cchRun, pf);// Set format for this run
                                                // Proper levels will be generated later by BiDi FSM.

            pf->Release(iCF);                   // Release count from Cache above
                                                // rp.SetFormat AddRef's as needed
            if(cchRun == CP_INFINITE)
            {
                ped->GetCallMgr()->SetOutOfMemory();
                break;
            }
            cp += cchRun;
            cch -= cchRun;
        }
        _rpCF.AdjustBackward();                 // Expand scope for merging
        rp.AdjustForward();                     //  runs

        rp.MergeRuns(_rpCF._iRun, pf);          // Merge adjacent runs that
                                                //  have the same format
        if(cchBack)                             // Move _rpCF back to where it
            _rpCF.AdvanceCp(-cchBack);          //  was
        else                                    // Active end at range start:
            _rpCF.AdjustForward();              //  don't leave at EOR

        if(pnm)
        {
            pnm->NotifyPostReplaceRange(this,   // Notify interested parties
                CP_INFINITE, 0, 0, cpStart,     // of the change.
                    cpStart + cchFormat - cch);
        }

        if(publdr && !(flags & SCF_IGNORESELAE))
        {
            HandleSelectionAEInfo(ped, publdr, GetCp(), _cch, GetCp(), _cch,
                    SELAE_FORCEREPLACE);
        }

        if(!_cch)                               // In case IP with ApplyToWord
        {
            if(fApplyToEOP)                     // Formatting EOP only
                goto LApplytoIP;

            Update_iFormat(-1);
        }
        if (ped->IsRich())
            ped->GetCallMgr()->SetChangeEvent(CN_GENERIC);
    }
    if(_fSel && ped->IsRich() && !ped->_f10Mode /*bug fix #5211*/)
        ped->GetCallMgr()->SetSelectionChanged();

    AssertSz(GetCp() == (cp = _rpCF.CalculateCp()),
        "RTR::SetCharFormat(): incorrect format-run ptr");

    if (!(dwMask2 & (CFM2_SCRIPT | CFM2_HOLDITEMIZE)) && cchFormat && hr == NOERROR && !cch)
    {
        // A non-degenerate range not coming from ItemizeRuns

        // It's faster to make a copy pointer since we dont need to worry about fExtend.
        CRchTxtPtr  rtp(*this);

        rtp.Advance(cchBack + cchFormat);
        rtp.ItemizeReplaceRange(cchFormat, 0, publdr);

        return hr;
    }

    return (hr == NOERROR && cch) ? S_FALSE : hr;
}

/*
 *  CTxtRange::GetParaFormat(pPF)
 *
 *  @mfunc
 *      return CParaFormat for this text range. If no PF runs are allocated,
 *      then return default CParaFormat
 *
 *  @rdesc
 *      Mask of defined properties: 1 bit means corresponding property is
 *      defined and constant throughout range.  0 bit means it isn't constant
 *      throughout range.  Note that PARAFORMAT has fewer relevant bits
 *      (PFM_ALL vs PFM_ALL2)
 */
DWORD CTxtRange::GetParaFormat (
    CParaFormat *pPF,           //@parm ptr to CParaFormat to be filled
    DWORD        flags) const   //  be filled with possibly NINCH'd values
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::GetParaFormat");

    CTxtEdit * const ped = GetPed();

    _TEST_INVARIANT_

    DWORD dwMask = flags & PFM_PARAFORMAT           // Default presence of
                 ? PFM_ALL : PFM_ALL2;              //  all properties

    CFormatRunPtr rp(_rpPF);
    LONG          cch = -_cch;

    if(cch < 0)                                     // At end of range:
    {                                               //  go to start of range
        rp.AdvanceCp(cch);
        cch = -cch;                                 // Count with cch > 0
    }

    *pPF = *ped->GetParaFormat(rp.GetFormat());     // Initialize *pPF to
                                                    //  starting paraformat
    if(!cch || !rp.IsValid())                       // No cch or invalid PF
        return dwMask;                              //  run ptr: use PF at
                                                    //  this text ptr
    LONG cchChunk = rp.GetCchLeft();                // Chunk size for rp
    while(cchChunk < cch)                           // NINCH properties that
    {                                               //  change over the range
        cch -= cchChunk;                            //  given by cch
        if(!rp.NextRun())                           // Go to next run                                                   // No more runs
            break;                                  //  (cch too big)
        cchChunk = rp.GetCchLeft();
        dwMask &= ~ped->GetParaFormat(rp.GetFormat())// NINCH properties that
            ->Delta(pPF, flags & PFM_PARAFORMAT);   //  changed, i.e., reset
    }                                               //  corresponding bits
    return dwMask;
}

/*
 *  CTxtRange::SetParaFormat(pPF, publdr, dwMask)
 *
 *  @mfunc
 *      apply CParaFormat *pPF to this range.
 *
 *  @rdesc
 *      if successfully set whole range, return NOERROR, otherwise
 *      return error code or S_FALSE.
 */
HRESULT CTxtRange::SetParaFormat (
    const CParaFormat* pPF,     //@parm CParaFormat to apply to this range
    IUndoBuilder *publdr,       //@parm Undo context for this operation
    DWORD         dwMask)       //@parm Mask to use
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::SetParaFormat");

    LONG                cch;                // Length of text to format
    LONG                cchBack;            // cch to back up for formatting
    LONG                cp;
    LONG                cpMin, cpMost;      // Limits of text to format
    LONG                delta;
    HRESULT             hr = NOERROR;
    LONG                iPF = 0;            // Lndex to a CParaFormat
    CTxtEdit * const    ped = GetPed();
    CParaFormat         PF;                 // Temporary CParaFormat
    IParaFormatCache *  pf = GetParaFormatCache();// Format cache ptr for Cache,
                                            //  AddRefFormat, ReleaseFormat
    CBiDiLevel*         pLevel;
    CBiDiLevel          lvRTL = {1, 0};
    CBiDiLevel          lvLTR = {0, 0};
    CFreezeDisplay      fd(ped->_pdp);

    _TEST_INVARIANT_

    if(!Check_rpPF())
        return E_FAIL;

    FindParagraph(&cpMin, &cpMost);             // Get limits of text to
    cch = cpMost - cpMin;                       //  format, namely closest

    CNotifyMgr *pnm = ped->GetNotifyMgr();
    if(pnm)
    {
        pnm->NotifyPreReplaceRange(this,        // Notify interested parties of
            CP_INFINITE, 0, 0, cpMin, cpMost);  // the impending update
    }

    cchBack = cpMin - GetCp();

    _rpPF.AdvanceCp(cchBack);                   // Back up to formatting start
    CFormatRunPtr rp(_rpPF);                    // Clone _rpPF to walk range

    if(publdr)
    {
        IAntiEvent *pae = gAEDispenser.CreateReplaceFormattingAE(ped,
                            rp, cch, pf, ParaFormat);
        if(pae)
            publdr->AddAntiEvent(pae);
    }

    const CParaFormat*  pPFCurrent;         // PF at current runptr
    BOOL    fLevelChanged = FALSE;
    BOOL    fFullyDefined = FALSE;          // Default input PF not fully defined

    if (ped->HandleStyle(&PF, pPF, dwMask) == NOERROR &&
        pf->Cache(&PF, &iPF) == NOERROR)
    {
        fFullyDefined = TRUE;
    }

    do
    {
        WORD    wEffectsCurrent;
        pPFCurrent = ped->GetParaFormat(rp.GetFormat());// Get current PF
        wEffectsCurrent = pPFCurrent->_wEffects;// Save current effect so we don't
                                                //  need to use pPFCurrent because it may
                                                //  become invalid after a PF.Apply.
        if(!fFullyDefined)                      // If pPF doesn't specify
        {                                       //  full PF, fill in undefined
            PF = *pPFCurrent;
            hr = PF.Apply(pPF, dwMask);         // Apply *pPF
            if(hr != NOERROR)                   //  (Probably E_INVALIDARG)
                break;                          // Cache result if new; in any
            hr = pf->Cache(&PF, &iPF);          //  case, get format index iPF
            if(hr != NOERROR)                   // Can't necessarily return
                break;                          //  error, since may need
        }

        if (!fLevelChanged)
            fLevelChanged = (wEffectsCurrent ^ PF._wEffects) & PFE_RTLPARA;

        pLevel = PF.IsRtlPara() ? &lvRTL : &lvLTR;

        delta = rp.SetFormat(iPF, cch, pf, pLevel); // Set format for this run
        if(!fFullyDefined)                      // Release count from Cache above
            pf->Release(iPF);                   // rp.SetFormat AddRefs as needed

        if(delta == CP_INFINITE)
        {
            ped->GetCallMgr()->SetOutOfMemory();
            break;
        }
        cch -= delta;
    } while (cch > 0) ;
    if(fFullyDefined)
        pf->Release(iPF);                       // Release count from Cache above

    _rpPF.AdjustBackward();                     // If at BOR, go to prev EOR
    rp.MergeRuns(_rpPF._iRun, pf);              // Merge any adjacent runs
                                                //  that have the same format
    if(cchBack)                                 // Move _rpPF back to where it
        _rpPF.AdvanceCp(-cchBack);              //  was
    else                                        // Active end at range start:
        _rpPF.AdjustForward();                  //  don't leave at EOR

    if(pnm)
    {
        pnm->NotifyPostReplaceRange(this,       // Notify interested parties of
            CP_INFINITE, 0, 0, cpMin,   cpMost);    //  the update
    }

    if(publdr)
    {
        // Paraformatting works a bit differently, it just remembers the
        // current selection. Cast selection to range to avoid including
        // _select.h; we only need range methods.
        CTxtRange *psel = (CTxtRange *)GetPed()->GetSel();
        if(psel)
        {
            cp  = psel->GetCp();
            HandleSelectionAEInfo(ped, publdr, cp, psel->GetCch(),
                                  cp, psel->GetCch(), SELAE_FORCEREPLACE);
        }
    }

    ped->GetCallMgr()->SetChangeEvent(CN_GENERIC);

    AssertSz(GetCp() == (cp = _rpPF.CalculateCp()),
        "RTR::SetParaFormat(): incorrect format-run ptr");


    if (fLevelChanged && cpMost > cpMin)
    {
        ped->OrCharFlags(fBIDI, publdr);

        // make sure the CF is valid
        Check_rpCF();

        CTxtRange   rg(*this);

        if (publdr)
        {
            // create anti-events to keep BiDi level of paragraphs in need
            //
            ICharFormatCache*   pcfc = GetCharFormatCache();
            CFormatRunPtr       rp(_rpCF);

            rp.AdvanceCp(cpMin - _rpTX.GetCp());

            IAntiEvent *pae = gAEDispenser.CreateReplaceFormattingAE (
                                ped, rp, cpMost - cpMin, pcfc, CharFormat);
            if (pae)
                publdr->AddAntiEvent(pae);
        }
        rg.Set(cpMost, cpMost - cpMin);
        rg.ItemizeRuns (publdr);
    }

    return (hr == NOERROR && cch) ? S_FALSE : hr;
}

/*
 *  CTxtRange::SetParaStyle(pPF, publdr, dwMask)
 *
 *  @mfunc
 *      apply CParaFormat *pPF using the style pPF->sStyle to this range.
 *
 *  @rdesc
 *      if successfully set whole range, return NOERROR, otherwise
 *      return error code or S_FALSE.
 *
 *  @comm
 *      If pPF->dwMask & PFM_STYLE is nonzero, this range is expanded to
 *      complete paragraphs.  If it's zero, this call just passes control
 *      to CTxtRange::SetParaStyle().
 */
 HRESULT CTxtRange::SetParaStyle (
    const CParaFormat* pPF,     //@parm CParaFormat to apply to this range
    IUndoBuilder *publdr,       //@parm Undo context for this operation
    DWORD         dwMask)       //@parm Mask to use
{
    LONG    cchSave = _cch;         // Save range cp and cch in case
    LONG    cpSave  = GetCp();      //  para expand needed
    HRESULT hr;

    if(publdr)
        publdr->StopGroupTyping();

    if(pPF->fSetStyle(dwMask))
    {
        CCharFormat CF;             // Need to apply associated CF

        LONG cpMin, cpMost;
        Expander(tomParagraph, TRUE, NULL, &cpMin, &cpMost);

        CF._sStyle = pPF->_sStyle;
        hr = SetCharFormat(&CF, 0, publdr, CFM_STYLE, 0);
        if(hr != NOERROR)
            return hr;
    }
    hr = SetParaFormat(pPF, publdr, dwMask);
    Set(cpSave, cchSave);           // Restore this range in case expanded
    return hr;
}

/*
 *  CTxtRange::Update_iFormat(iFmtDefault)
 *
 *  @mfunc
 *      update _iFormat to CCharFormat at current active end
 *
 *  @devnote
 *      _iFormat is only used when the range is degenerate
 *
 *      The Word 95 UI specifies that the *previous* format should
 *      be used if we're in at an ambiguous cp (i.e. where a formatting
 *      change occurs) _unless_ the previous character is an EOP
 *      marker _or_ if the previous character is protected.
 */
void CTxtRange::Update_iFormat (
    LONG iFmtDefault)       //@parm Format index to use if _rpCF isn't valid
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::Update_iFormat");

    DWORD   dwEffects;
    LONG    ifmt, iFormatForward;
    const CCharFormat *pCF, *pCFForward;

    if(_cch)
        return;

    _fSelHasEOP  = FALSE;                       // Empty ranges don't contain
    _fSelHasCell = FALSE;                       //  anything, incl EOPs/cells

    if(_fDontUpdateFmt)                         // _iFormat is only used
        return;                                 //  for degenerate ranges

    if(_rpCF.IsValid() && iFmtDefault == -1)
    {
        // Get forward info before possibly adjusting backward
        _rpCF.AdjustForward();
        ifmt = iFormatForward = _rpCF.GetFormat();
        pCF  = pCFForward = GetPed()->GetCharFormat(ifmt);
        dwEffects = pCF->_dwEffects;

        if(!_rpTX.IsAfterEOP())
        {
            _rpCF.AdjustBackward();                 // Adjust backward
            ifmt = _rpCF.GetFormat();
            pCF = GetPed()->GetCharFormat(ifmt);
            dwEffects = pCF->_dwEffects;
        }

        if (!(GetPed()->_fIMEInProgress))       // Dont change fomrat during IME
        {
            if(!_rpTX.GetCp() && (pCF->_dwEffects & CFE_RUNISDBCS))
            {
                // If at beginning of document, and text is protected, just use
                // default format.
                ifmt = iFmtDefault;
            }
            else if(dwEffects & (CFE_PROTECTED | CFE_LINK | CFE_HIDDEN | CFE_RUNISDBCS))
            {
                // If range is protected or a hyperlink, pick forward format
                ifmt = iFormatForward;
            }
            else if(ifmt != iFormatForward && _fMoveBack &&
                IsRTLCharSet(pCF->_bCharSet) != IsRTLCharSet(pCFForward->_bCharSet))
            {
                ifmt = iFormatForward;
            }
        }
        iFmtDefault = ifmt;
    }

    // Don't allow _iFormat to include CFE_LINK or CFE_HIDDEN attributes
    // unless they're the default
    if(iFmtDefault != -1)
    {
        pCF = GetPed()->GetCharFormat(iFmtDefault);
        if(pCF->_dwEffects & (CFE_LINK | CFE_HIDDEN))
        {
            CCharFormat CF = *pCF;
            CF._dwEffects &= ~(CFE_LINK | CFE_HIDDEN);

            // This range must be an insertion point!
            Assert(_cch == 0);
            SetCharFormat(&CF, FALSE, NULL, CFM_ALL2, 0);
            return;
        }
    }
    Set_iCF(iFmtDefault);
}

/*
 *  CTxtRange::GetCharSetMask(fUseDocFormat)
 *
 *  @mfunc
 *      Get this range's charset mask corresponding to _iFormat.
 *      If fUseDocFormat is TRUE, then use -1 instead of _iFormat.
 *
 *  @rdesc
 *      charset mask for range or default document
 */
DWORD CTxtRange::GetCharSetMask(
    BOOL fUseDocFormat)
{
    LONG iFormat = fUseDocFormat ? -1 : GetiFormat();
    DWORD dwMask = GetFontSig((GetPed()->GetCharFormat(iFormat))->_bCharSet) << 8;

    if(dwMask & fSYMBOL)
        return dwMask;

    // For now, Indic fonts match only ASCII digits
    dwMask |= fBELOWX40;
    if (dwMask < fDEVANAGARI)
        dwMask |= fASCII;                               // fASCIIUPR+fBELOWX40

    if ((dwMask & (fKANA | fHANGUL | fCHINESE | fBIG5))
        && W32->IsFESystem() )                          // For FE systems
            dwMask |= fOTHER;                           //  match fOTHER

    else if(dwMask & fLATIN)
        dwMask |= fCOMBINING;

    return dwMask;
}

/*
 *  CTxtRange::GetiFormat()
 *
 *  @mfunc
 *      Return (!_cch || _fUseiFormat) ? _iFormat : iFormat at cpMin
 *
 *  @rdesc
 *      iFormat at cpMin if nondegenerate and !_fUseiFormat; else _iFormat
 *
 *  @devnote
 *      This routine doesn't AddRef iFormat, so it shouldn't be used if
 *      it needs to be valid after character formatting has changed, e.g.,
 *      by ReplaceRange or SetCharFormat or SetParaStyle
 */
LONG CTxtRange::GetiFormat() const
{
    if(!_cch || _fUseiFormat)
        return _iFormat;

    if(_cch > 0)
    {
        CFormatRunPtr rp(_rpCF);
        rp.AdvanceCp(-_cch);
        return rp.GetFormat();
    }
    return _rpCF.GetFormat();
}

/*
 *  CTxtRange::Get_iCF()
 *
 *  @mfunc
 *      Get this range's _iFormat (AddRef'ing, of course)
 *
 *  @devnote
 *      Get_iCF() is used by the RTF reader
 */
LONG CTxtRange::Get_iCF ()
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::Get_iCF");

    GetCharFormatCache()->AddRef(_iFormat);
    return _iFormat;
}

/*
 *  CTxtRange::Set_iCF(iFormat)
 *
 *  @mfunc
 *      Set range's _iFormat to iFormat, AddRefing and Releasing as required.
 *
 *  @rdesc
 *      TRUE if _iFormat changed
 */
BOOL CTxtRange::Set_iCF (
    LONG iFormat)               //@parm Index of char format to use
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::Set_iCF");

    if(iFormat == _iFormat)
        return FALSE;

    ICharFormatCache *pCFC = GetCharFormatCache();

    pCFC->AddRef(iFormat);
    pCFC->Release(_iFormat);            // Note: _iFormat = -1 doesn't
    _iFormat = iFormat;                 //  get AddRef'd or Release'd

    AssertSz(GetCF(), "CTxtRange::Set_iCF: illegal format");
    return TRUE;
}

/*
 *  CTxtRange::Get_iPF()
 *
 *  @mfunc
 *      Get paragraph format at active end
 *
 *  @devnote
 *      Get_iPF() is used by the RTF reader on encountering a start group
 */
LONG CTxtRange::Get_iPF ()
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::Get_iPF");

    LONG iPF = _rpPF.GetFormat();

    GetParaFormatCache()->AddRef(iPF);
    return iPF;
}

/*
 *  CTxtRange::BiDiLevelFromFSM(pFSM)
 *
 *  @mfunc
 *      Run BiDi FSM to generate proper embedding level for runs
 *
 *  @rdesc
 *      HRESULT
 */
HRESULT CTxtRange::BiDiLevelFromFSM (
    const CBiDiFSM* pFSM)       // in: ptr to FSM
{
    AssertSz(pFSM && _rpCF.IsValid(), "Not enough information to run BiDi FSM");

    LONG                cpMin, cpMost, cp, cchLeft;
    LONG                ich, cRunsStart, cRuns = 0;
    HRESULT             hr = S_OK;

    GetRange(cpMin, cpMost);

    AssertSz (cpMost - cpMin > 0, "FSM: Invalid range");

    CRchTxtPtr          rtp(*this);

    rtp.Advance(cpMin - rtp.GetCp());               // initiate position to cpMin
    CFormatRunPtr   rpPF(rtp._rpPF);                // pointer to current paragraph

    cchLeft = cpMost - cpMin;
    cp = cpMin;

    while (cchLeft > 0 && SUCCEEDED(hr))
    {
        // accumulate runs within the same paragraph level
        cRuns = GetRunsPF(&rtp, &rpPF, cchLeft);
        cRunsStart = 0;                             // assume no start run

        ich = rtp.Advance(-rtp.GetIchRunCF());      // locate preceding run
        rtp._rpCF.AdjustBackward();                 // adjusting format backward
        rtp._rpPF.AdjustBackward();                 // adjusting format backward

        if(rtp._rpPF.SameLevel(&rpPF))
        {
            // start at the beginning of preceding run
            if (rtp.Advance(-rtp.GetCchRunCF()))
                cRunsStart++;
        }
        else
        {
            // preceding run is not at the same paragraph level, resume position
            rtp.Advance(-ich);
        }

        rtp._rpCF.AdjustForward();                  // make sure we have forward run pointers
        rtp._rpPF.AdjustForward();

        // Run FSM for the number of runs in multiple paragraphs with the same level
        hr = pFSM->RunFSM(&rtp, cRuns, cRunsStart, rtp.IsParaRTL() ? 1 : 0);

        cp = cpMost - cchLeft;
        rtp.Advance(cp - rtp.GetCp());              // Advance to next paragraph(s)
        rpPF = rtp._rpPF;                           // paragraph format at cp
    }

    AssertSz (cp == cpMost , "Running BiDi FSM partially done!");

    _rpCF = rtp._rpCF;                              // We may have splitted CF runs

    return hr;
}

/*
 *  CTxtRange::GetRunsPF(prtp, prpPF, cchLeft)
 *
 *  @mfunc
 *      Get the number of CF runs within the same paragraph's base level.
 *  Its scope could cover multiple paragraphs. As long as they are in the
 *  same level, we can run them through the FSM in one go.
 *
 */
LONG CTxtRange::GetRunsPF(
    CRchTxtPtr*         prtp,       // in: RichText ptr to the first run in range
    CFormatRunPtr*      prpPF,      // in: Pointer to current paragraph run
    LONG&               cchLeft)    // in/out: number of char left
{
    Assert (prtp && prtp->_rpPF.SameLevel(prpPF) && cchLeft > 0);

    LONG                cRuns = 0;
    LONG                cchRun, cchText = cchLeft;
    ICharFormatCache*   pf = GetCharFormatCache();


    // check if the first CF run is PF bound
    //

    prtp->_rpPF.AdjustBackward();

    if (prtp->GetIchRunCF() > 0 && !prtp->_rpPF.SameLevel(prpPF))
        prtp->_rpCF.SplitFormat(pf);                    // PF breaks inside a CF run, split the run

    prtp->_rpPF.AdjustForward();                        // make sure we are all forward.
    prtp->_rpCF.AdjustForward();


    while (cchText > 0)
    {
        cchRun = min(prtp->GetCchLeftRunPF(), prtp->GetCchLeftRunCF());
        cchRun = min(cchText, cchRun);                  // find out the nearest hop
        cchText -= cchRun;

        prtp->Advance(cchRun);                          // to the next hop

        if (!prtp->_rpPF.SameLevel(prpPF))
        {                                               // this is a para with different level
            prtp->_rpCF.SplitFormat(pf);                // split that CF run
            cRuns++;                                    // count the splitted
            break;                                      // and we're done
        }

        if (!cchText ||                                 // this is the last hop -or-
            !prtp->GetIchRunCF() ||                     // we're at the start or the end of a CF run
            !prtp->GetCchLeftRunCF())
        {
            cRuns++;                                    // count this hop
        }
    }

    prtp->Advance(cchText - cchLeft);                   // resume position
    cchLeft = cchText;                                  // update number of char left

    return cRuns;
}


/*
 *  CTxtRange::SpanSubstringDir (pusp, prtp, cchString, puInitLevel, pfNumericFound)
 *
 *  @mfunc
 *      Span the run of text bound by or contains only block separators
 *      and share the same charset directionality.
 *
 *  @rdesc
 *      number of span'ed text characters
 *
 */
LONG CTxtRange::SpanSubstring(
    CUniscribe*     pusp,           // in: Uniscribe interface
    CFormatRunPtr*  prp,            // in: Format run pointer
    WCHAR*          pwchString,     // in: Input string
    LONG            cchString,      // in: String character count
    WORD&           uSubStrLevel,   // in/out: BiDi substring initial level
    DWORD           dwInFlags,      // in: Input flags
	CCharFlags*		pCharflags,		// out:Output charflags
    WORD&           wBiDiLangId)    // out:The primary language of a BiDi run
{
    Assert (pusp && cchString > 0 && prp && prp->IsValid());

    LONG                cch, cchLeft;

    cch = cchLeft = cchString;

    wBiDiLangId = LANG_NEUTRAL;     // assume unknown

    if (dwInFlags & SUBSTR_INSPANCHARSET)
    {
        // span runs with same charset's direction

        CTxtEdit*           ped = GetPed();
        CFormatRunPtr       rp(*prp);
        const CCharFormat*  pCF;
        BOOL                fNext;
        BYTE                bCharSet1, bCharSet2;

        rp.AdjustForward();

        pCF = ped->GetCharFormat(rp.GetFormat());

        bCharSet1 = bCharSet2 = pCF->_bCharSet;

        while (!(bCharSet1 ^ bCharSet2))
        {
            cch = min(rp.GetCchLeft(), cchLeft);
            cchLeft -= cch;

            if (!(fNext = rp.NextRun()) || !cchLeft)
                break;

            bCharSet1 = bCharSet2;

            pCF = ped->GetCharFormat(rp.GetFormat());
            bCharSet2 = pCF->_bCharSet;
        }
        uSubStrLevel = IsBiDiCharSet(bCharSet1) ? 1 : 0;

        if (uSubStrLevel & 1)
            wBiDiLangId = bCharSet1 == ARABIC_CHARSET ? LANG_ARABIC : LANG_HEBREW;

        cchString -= cchLeft;
        cch = cchString;

        dwInFlags |= SUBSTR_INSPANBLOCK;
    }

    if (dwInFlags & SUBSTR_INSPANBLOCK)
    {
        // scan the whole substring to collect information about it

        DWORD   dwBS = IsEOP(*pwchString) ? 1 : 0;
		BYTE	bCharMask;

        cch = 0;

		if (pCharflags)
			pCharflags->_bFirstStrong = pCharflags->_bContaining = 0;

        while (cch < cchString && !((IsEOP(pwchString[cch]) ? 1 : 0) ^ dwBS))
        {
			if (!dwBS && pCharflags)
			{
				bCharMask = 0;
	
				switch (MECharClass(pwchString[cch]))
				{
					case CC_ARABIC:
					case CC_HEBREW:
					case CC_RTL:
							bCharMask = SUBSTR_OUTCCRTL;
							break;
					case CC_LTR:
							bCharMask = SUBSTR_OUTCCLTR;
					default:
							break;
				}
	
				if (bCharMask)
				{
					if (!pCharflags->_bFirstStrong)
						pCharflags->_bFirstStrong |= bCharMask;
	
					pCharflags->_bContaining |= bCharMask;
				}
			}
            cch++;
        }
    }

    return cch;
}

/*
 *  CTxtRange::ItemizeRuns(publdr, fUnicodeBidi, iCtxBaseLevel)
 *
 *  @mfunc
 *      Break text range into smaller run(s) containing
 *
 *      1. Script ID for complex script shaping
 *      2. Charset for run internal direction
 *      3. BiDi embedding level
 *
 *  @rdesc
 *      TRUE iff one or more items found.
 *      The range's active end will be at cpMost upon return.
 *
 *  @devnote
 *      This routine could handle mixed paragraph runs
 */
BOOL CTxtRange::ItemizeRuns(
    IUndoBuilder	*publdr,        //@parm Undo context for this operation
    BOOL			fUnicodeBiDi,   //@parm TRUE: Caller needs Bidi algorithm
    BOOL			fUseCtxLevel)	//@parm Itemize using context based level (only valid if fUnicodeBiDi is true)
{
    LONG            cchString;
    int             cItems = 0;
    LONG            cpMin, cpMost;
    CTxtEdit*       ped = GetPed();
    CFreezeDisplay  fd(ped->_pdp);      // Freeze display
    int             i;
    BYTE            pbBufIn[MAX_CLIENT_BUF];
    PUSP_CLIENT     pc = NULL;
    const CBiDiFSM* pFSM;
    SCRIPT_ITEM*    psi;
    CUniscribe*     pusp;
    CTxtPtr         tp(_rpTX);
    LONG            cp, cch, cchSave;
    HRESULT         hr = E_FAIL;
    CCharFormat     CF;
    BOOL            fWhiteChunk;                            // Chunk contains only whitespaces
    WCHAR*          pwchString;
    WORD            uSubStrLevel;                           // Substring initial level
    WORD            uParaLevel;                             // Paragraph initial level
    CNotifyMgr*     pnm = NULL;                             // Notification manager
    BOOL            fRunUnicodeBiDi;
    BOOL            fStreaming = ped->IsStreaming();
    BOOL            fChangeCharSet = FALSE;
	CCharFlags		charflags = {0};
    WORD            wBiDiLangId;
#ifdef DEBUG
    LONG            cchText = tp.GetTextLength();
#endif

    // Get range and setup text ptr to the start
    //
    cch = cchString = GetRange(cpMin, cpMost);

    if (!cch)
        return FALSE;

    tp.SetCp(cpMin);

    // prepare Uniscribe
    pusp = ped->Getusp();
    if (!pusp)
        goto Exit;

    // allocate temp buffer for itemization
    pusp->CreateClientStruc(pbBufIn, MAX_CLIENT_BUF, &pc, cchString, cli_Itemize);
    if (!pc)
        goto Exit;

    Assert (tp.GetCp() == cpMin);


    if(pnm = ped->GetNotifyMgr())
        pnm->NotifyPreReplaceRange(this, CP_INFINITE, 0, 0, cpMin, cpMost);


    cp = cpMin;         // Set cp starting point at cpMin
    Set(cp, 0);         // equals to Collapser(tomStart)
    SetExtend(TRUE);

    Check_rpCF();       // Make sure _rpCF is valid
    Check_rpPF();       // _rpPF too


    // Always run UnicodeBidi for plain text control
    // (2.1 backward compatible)
    //
    if (!ped->IsRich())
    {
        fUnicodeBiDi = TRUE;
		fUseCtxLevel = FALSE;
    }

    uSubStrLevel = uParaLevel = IsParaRTL() ? 1 : 0;    // initialize substring level

    pwchString = pc->si->pwchString;
    tp.GetTextForUsp(cchString, pwchString, ped->_fNeutralOverride);

    while ( cchString > 0 &&
            ((cch = SpanSubstring(pusp, &_rpCF, pwchString, cchString, uSubStrLevel,
                    fUnicodeBiDi ? SUBSTR_INSPANBLOCK : SUBSTR_INSPANCHARSET,
					(fStreaming || fUseCtxLevel) ? &charflags : NULL,
                    wBiDiLangId)) > 0) )
    {
        cchSave = cch;
        fWhiteChunk = FALSE;

        if (uSubStrLevel ^ uParaLevel)
        {
            // Handle Bidi spaces when substring level counters paragraph base direction.

            // Spanning leading spaces
            cch = 0;
            while (cch < cchSave && pwchString[cch] == 0x20)
                cch++;

            if (cch)
                fWhiteChunk = TRUE;
            else
            {
                // Trimming out trailing whitespaces (including CR)
                cch = cchSave;
                while (cch > 0 && IsWhiteSpace(pwchString[cch-1]))
                    cch--;
                if (!cch)
                    cch = cchSave;
            }
            Assert(cch > 0);
        }

        // Itemize with Unicode Bidi algorithm when
        //   a. Plain text mode
        //   b. Caller wants (fUnicodeBidi != 0)
        //   c. Substring is RTL.
        //
        fRunUnicodeBiDi = fUnicodeBiDi || uSubStrLevel;
        fChangeCharSet = fUnicodeBiDi;

        if (!fUnicodeBiDi && uSubStrLevel == 1 && fStreaming)
        {
            // During RTF streaming if the RTL run contains strong LTR,
            // we resolve them using the paragraph base level
            if (charflags._bContaining & SUBSTR_OUTCCLTR)
                uSubStrLevel = uParaLevel;

            fChangeCharSet = TRUE;
        }


        // Caller wants context based level.
        // We want to itemize incoming plain text (into richtext doc) with the base level
        // of the first strong character found in each substrings (wchao - 7/15/99)
        //
		if (fUnicodeBiDi && fUseCtxLevel && charflags._bFirstStrong)
			uSubStrLevel = (WORD)(charflags._bFirstStrong & SUBSTR_OUTCCRTL ? 1 : 0);


        if (fWhiteChunk || pusp->ItemizeString (pc, uSubStrLevel, &cItems, pwchString, cch,
                                                fRunUnicodeBiDi, wBiDiLangId) > 0)
        {
            const SCRIPT_PROPERTIES*    psp;
            DWORD                       dwMask1;
            BYTE                        bCharSetDefault = ped->GetCharFormat(-1)->_bCharSet;

            psi = pc->si->psi;

            if (fWhiteChunk)
            {
                cItems = 1;
                psi[0].a.eScript = SCRIPT_WHITE;
                psi[0].iCharPos = 0;
                psi[1].iCharPos = cch;
            }

            Assert(cItems > 0);

            // process items
            //
            for (i=0; i < cItems; i++)
            {
                cp += psi[i+1].iCharPos - psi[i].iCharPos;
                AssertNr (cp <= cchText);
                SetCp(min(cp, cpMost));

                dwMask1 = 0;

                // Associate the script properties
                psp = pusp->GeteProp(psi[i].a.eScript);
                Assert (psp);

                if (!psp->fComplex && !psp->fNumeric &&
                    !psi[i].a.fRTL && psi[i].a.eScript < SCRIPT_MAX_COUNT)
                {
                    // Note: Value 0 here is a valid script ID (SCRIPT_UNDEFINED),
                    // guaranteed by Uniscribe to be available all the time
                    // so we're safe using it as our simplified script ID.
                    //
                    psi[i].a.eScript = 0;
                    psp = pusp->GeteProp(0);
                }

                CF._wScript = psi[i].a.eScript;

                // Stamp appropriate charset
                //
                if (pusp->GetComplexCharSet(psp, bCharSetDefault, CF._bCharSet))
                {
                    // Complex script that has distinctive charset
                    dwMask1 |= CFM_CHARSET;
                }
                else if (fChangeCharSet)
                {
                    // We run UnicodeBidi to analyse the whole thing so
                    // we need to figure out the proper charset to use as well.
                    //

                    // Note that we dont want to apply charset in general, say things
                    // like FarEast or GREEK_CHARSET should remain unchanged by
                    // this effect. But doing charset check is tough since we deal
                    // with text in range basis, so we simply call to update it here
                    // and let CCharFormat::Apply do the charset test in down level.

                    CF._bCharSet = psp->bCharSet;   // assume what Uniscribe has given us

                    if (psi[i].a.fRTL || psi[i].a.fLayoutRTL)
                    {
                        // those of strong RTL and RTL digits need RTL charset
                        CF._bCharSet = pusp->GetRtlCharSet(ped);
                    }

                    Assert(CF._bCharSet != DEFAULT_CHARSET);
                    dwMask1 |= CFM_CHARSET;
                }

                // no publdr for this call so no antievent for itemized CF
                SetCharFormat(&CF, SCF_IGNORENOTIFY, NULL, dwMask1, CFM2_SCRIPT);
                Set(cp, 0);
            }
        }
        else
        {
            // Itemization fails.

            cp += cch;
            SetCp(min(cp, cpMost));

            // reset script id to 0
            CF._wScript = 0;
            SetCharFormat(&CF, SCF_IGNORENOTIFY, NULL, 0, CFM2_SCRIPT);
            Set(cp, 0);
        }
        pwchString = &pc->si->pwchString[cp - cpMin];   // point to next substring
        cchString -= cch;
        uParaLevel = IsParaRTL() ? 1 : 0;               // paragraph level might have changed
    }

    Assert (cpMost == cp);

    // restore original range
    Set(cpMost, cpMost - cpMin);

    // retrieve ptr to Bidi FSM
    pFSM = pusp->GetFSM();

    if (pFSM)
        hr = BiDiLevelFromFSM (pFSM);

    AssertSz(SUCCEEDED(hr), "Unable to run or running BiDi FSM fails! We are in deep trouble,");


    if (pc && pbBufIn != (BYTE*)pc)
        FreePv(pc);

    // update flags
    ped->_fItemizePending = FALSE;


    // Notify backing store change to all notification sinks
    if(pnm)
        pnm->NotifyPostReplaceRange(this, CP_INFINITE, 0, 0, cpMin, cpMost);


Exit:
    return cItems > 0;
}

/*
 *  CTxtRange::IsProtected(iDirection)
 *
 *  @mfunc
 *      Return TRUE if any part of this range is protected (HACK:  or
 *      if any part of the range contains DBCS text stored in our Unicode
 *      backing store).  If degenerate,
 *      use CCharFormat from run specified by iDirection, that is, use run
 *      valid up to, at, or starting at this GetCp() for iDirection less, =,
 *      or greater than 0, respectively.
 *
 *  @rdesc
 *      TRUE iff any part of this range is protected (HACK:  or if any part
 *      of the range contains DBCS text stored in our Unicode backing store
 *      For this to work correctly, GetCharFormat() needs to return dwMask2
 *      as well).
 */
BOOL CTxtRange::IsProtected (
    LONG iDirection)    //@parm Controls which run to check if range is IP
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::IsProtected");

    CCharFormat CF;
    LONG        iFormat = -1;                   // Default default CF

    _TEST_INVARIANT_

    if(_rpCF.IsValid())                         // Active rich-text runs
    {
        if(_cch)                                // Range is nondegenerate
        {
            DWORD dwMask = GetCharFormat(&CF);
            if(CF._dwEffects & CFE_RUNISDBCS)
                return PROTECTED_YES;

            if (!(dwMask & CFM_PROTECTED) ||
                (CF._dwEffects & CFE_PROTECTED))
            {
                return PROTECTED_ASK;
            }
            return PROTECTED_NO;
        }
        iFormat = _iFormat;                     // Degenerate range: default
        if(iDirection != 0)                     //  this range's iFormat
        {                                       // Specific run direction
            CFormatRunPtr rpCF(_rpCF);

            if(iDirection < 0)                  // If at run ambiguous pos,
                rpCF.AdjustBackward();          //  use previous run
            else
                rpCF.AdjustForward();

            iFormat = rpCF.GetFormat();         // Get run format
        }
    }

    const CCharFormat *pCF = GetPed()->GetCharFormat(iFormat);

    if(pCF->_dwEffects & CFE_RUNISDBCS)
        return PROTECTED_YES;

    if(pCF->_dwEffects & CFE_PROTECTED)
        return PROTECTED_ASK;

    return PROTECTED_NO;
}

/*
 *  CTxtRange::AdjustEndEOP (NewChars)
 *
 *  @mfunc
 *      If this range is a selection and ends with an EOP and consists of
 *      more than just this EOP and fAdd is TRUE, or this EOP is the final
 *      EOP (at the story end), or this selection doesn't begin at the start
 *      of a paragraph, then move cpMost just before the end EOP. This
 *      function is used by UI methods that delete the selected text, such
 *      as PutChar(), Delete(), cut/paste, drag/drop.
 *
 *  @rdesc
 *      TRUE iff range end has been adjusted
 *
 *  @devnote
 *      This method leaves the active end at the selection cpMin.  It is a
 *      CTxtRange method to handle the selection when it mascarades as a
 *      range for Cut/Paste.
 */
BOOL CTxtRange::AdjustEndEOP (
    EOPADJUST NewChars)         //@parm NEWCHARS if chars will be added
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtRange::AdjustEndEOP");

    LONG cpMin, cpMost;
    LONG cch = GetRange(cpMin, cpMost);
    LONG cchSave = _cch;
    BOOL fRet = FALSE;

    if(cch && (cch < GetTextLength() || NewChars == NEWCHARS))
    {
        LONG    cchEOP = GetPed()->fUseCRLF() ? 2 : 1;
        CTxtPtr tp(_rpTX);

        if(_cch > 0)                            // Ensure active end is cpMin
            FlipRange();                        // (ReplaceRange() needs to
        else                                    //  do this anyhow)
            tp.AdvanceCp(-_cch);                // Ensure tp is at cpMost

        if(tp.IsAfterEOP())                     // Don't delete EOP at sel
        {                                       //  end if EOP isn't end of
            CPFRunPtr rp(*this);                //  table row and if there're
            rp.AdvanceCp(-_cch);                //  chars to add, or cpMin
            rp.AdjustBackward();                //  isn't at BOP and more than
                                                //  EOP is selected
            if(!rp.InTable() &&
               (NewChars == NEWCHARS ||
                cpMin && !_rpTX.IsAfterEOP() && cch > cchEOP))
            {
                _cch -= tp.BackupCpCRLF();      // Shorten range before EOP
                                                // Note: the -= _adds_ to a
                Update_iFormat(-1);             //  negative _cch to make
                fRet = TRUE;                    //  it less negative
            }
        }
        if((_cch ^ cchSave) < 0 && _fSel)       // Keep active end the same
            FlipRange();                        //  for selection undo
    }
    return fRet;
}

/*
 *  CTxtRange::DeleteTerminatingEOP (publdr)
 *
 *  @mfunc
 *      If this range is an insertion point that follows an EOP, select
 *      and delete that EOP
 */
void CTxtRange::DeleteTerminatingEOP(
    IUndoBuilder *publdr)
{
    Assert(!_cch);
    if(_rpTX.IsAfterEOP())
    {
        SetExtend(TRUE);
        BackupCRLF();
        ReplaceRange(0, NULL, publdr, SELRR_REMEMBERRANGE);
    }
}

/*
 *  CTxtRange::CheckTextLength(cch)
 *
 *  @mfunc
 *      Check to see if can add cch characters. If not, notify parent
 *
 *  @rdesc
 *      TRUE if OK to add cch chars
 */
BOOL CTxtRange::CheckTextLength (
    LONG cch,
    LONG *pcch)
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::CheckTextLength");

    _TEST_INVARIANT_

    DWORD cchNew = (DWORD)(CalcTextLenNotInRange() + cch);

    if(cchNew > GetPed()->TxGetMaxLength())
    {
        if (pcch)
            *pcch = cchNew - GetPed()->TxGetMaxLength();
        else
            GetPed()->GetCallMgr()->SetMaxText();

        return FALSE;
    }
    return TRUE;
}

/*
 *  CTxtRange::FindObject(pcpMin, pcpMost)
 *
 *  @mfunc
 *      Set *pcpMin  = closest embedded object cpMin <lt>= range cpMin
 *      Set *pcpMost = closest embedded object cpMost <gt>= range cpMost
 *
 *  @rdesc
 *      TRUE iff object found
 *
 *  @comm
 *      An embedded object cpMin points at the first character of an embedded
 *      object. For RichEdit, this is the WCH_EMBEDDING character.  An
 *      embedded object cpMost follows the last character of an embedded
 *      object.  For RichEdit, this immediately follows the WCH_EMBEDDING
 *      character.
 */
BOOL CTxtRange::FindObject(
    LONG *pcpMin,       //@parm Out parm to receive object's cpMin;  NULL OK
    LONG *pcpMost) const//@parm Out parm to receive object's cpMost; NULL OK
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::FindObject");

    if(!GetObjectCount())                   // No objects: can't move, so
        return FALSE;                       //  return FALSE

    BOOL    bRet = FALSE;                   // Default no object
    LONG    cpMin, cpMost;
    CTxtPtr tp(_rpTX);

    GetRange(cpMin, cpMost);
    if(pcpMin)
    {
        tp.SetCp(cpMin);
        if(tp.GetChar() != WCH_EMBEDDING)
        {
            cpMin = tp.FindExact(tomBackward, szEmbedding);
            if(cpMin >= 0)
            {
                bRet = TRUE;
                *pcpMin = cpMin;
            }
        }
    }
    if(pcpMost)
    {
        tp.SetCp(cpMost);
        if (tp.PrevChar() != WCH_EMBEDDING &&
            tp.FindExact(tomForward, szEmbedding) >= 0)
        {
            bRet = TRUE;
            *pcpMost = tp.GetCp();
        }
    }
    return bRet;
}

/*
 *  CTxtRange::FindCell(pcpMin, pcpMost)
 *
 *  @mfunc
 *      Set *pcpMin  = closest cell cpMin  <lt>= range cpMin (see comment)
 *      Set *pcpMost = closest cell cpMost <gt>= range cpMost
 *
 *  @comment
 *      This function does nothing if the range isn't completely in a table.
 */
void CTxtRange::FindCell (
    LONG *pcpMin,           //@parm Out parm for bounding-cell cpMin
    LONG *pcpMost) const    //@parm Out parm for bounding-cell cpMost
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::FindCell");

    WCHAR       ch;
    LONG        cpMin, cpMost;
    CRchTxtPtr  rtp(*this);

    _TEST_INVARIANT_

    GetRange(cpMin, cpMost);

    if(pcpMin)
    {
        if(_cch > 0)
            rtp.Advance(-_cch);

        rtp._rpPF.AdjustBackward();
        if(rtp.InTable())
        {
            while(rtp.GetCp())
            {
                rtp.BackupCRLF();
                ch = rtp.GetChar();
                if(IsASCIIEOP(ch) || ch == CELL)
                {
                    rtp.AdvanceCRLF();
                    break;
                }
                Assert(rtp.InTable());
            }
        }
        *pcpMin = rtp.GetCp();
    }

    if(pcpMost)
    {
        rtp.SetCp(cpMost);
        if(rtp.InTable())
        {
            rtp.BackupCRLF();
            do
            {
                ch = rtp.GetChar();
                rtp.AdvanceCRLF();
                Assert(rtp.InTable());
            } while(ch && !IsASCIIEOP(ch) && ch != CELL);
        }
        *pcpMost = rtp.GetCp();
    }
}

/*
 *  CTxtRange::FindParagraph(pcpMin, pcpMost)
 *
 *  @mfunc
 *      Set *pcpMin  = closest paragraph cpMin  <lt>= range cpMin (see comment)
 *      Set *pcpMost = closest paragraph cpMost <gt>= range cpMost
 *
 *  @devnote
 *      If this range's cpMost follows an EOP, use it for bounding-paragraph
 *      cpMost unless 1) the range is an insertion point, and 2) pcpMin and
 *      pcpMost are both nonzero, in which case use the next EOP.  Both out
 *      parameters are nonzero if FindParagraph() is used to expand to full
 *      paragraphs (else StartOf or EndOf is all that's requested).  This
 *      behavior is consistent with the selection/IP UI.  Note that FindEOP
 *      treats the beginning/end of document (BOD/EOD) as a BOP/EOP,
 *      respectively, but IsAfterEOP() does not.
 */
void CTxtRange::FindParagraph (
    LONG *pcpMin,           //@parm Out parm for bounding-paragraph cpMin
    LONG *pcpMost) const    //@parm Out parm for bounding-paragraph cpMost
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::FindParagraph");

    LONG    cpMin, cpMost;
    CTxtPtr tp(_rpTX);

    _TEST_INVARIANT_

    GetRange(cpMin, cpMost);
    if(pcpMin)
    {
        tp.SetCp(cpMin);                    // tp points at this range's cpMin
        if(!tp.IsAfterEOP())                // Unless tp directly follows an
            tp.FindEOP(tomBackward);        //  EOP, search backward for EOP
        *pcpMin = cpMin = tp.GetCp();
    }

    if(pcpMost)
    {
        tp.SetCp(cpMost);                   // If range cpMost doesn't follow
        if (!tp.IsAfterEOP() ||             //  an EOP or else if expanding
            (!cpMost || pcpMin) &&
             cpMin == cpMost)               //  IP at paragraph beginning,
        {
            tp.FindEOP(tomForward);         //  search for next EOP
        }
        *pcpMost = tp.GetCp();
    }
}

/*
 *  CTxtRange::FindSentence(pcpMin, pcpMost)
 *
 *  @mfunc
 *      Set *pcpMin  = closest sentence cpMin  <lt>= range cpMin
 *      Set *pcpMost = closest sentence cpMost <gt>= range cpMost
 *
 *  @devnote
 *      If this range's cpMost follows a sentence end, use it for bounding-
 *      sentence cpMost unless the range is an insertion point, in which case
 *      use the next sentence end.  The routine takes care of aligning on
 *      sentence beginnings in the case of range ends that fall on whitespace
 *      in between sentences.
 */
void CTxtRange::FindSentence (
    LONG *pcpMin,           //@parm Out parm for bounding-sentence cpMin
    LONG *pcpMost) const    //@parm Out parm for bounding-sentence cpMost
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::FindSentence");

    LONG    cpMin, cpMost;
    CTxtPtr tp(_rpTX);

    _TEST_INVARIANT_

    GetRange(cpMin, cpMost);
    if(pcpMin)                              // Find sentence beginning
    {
        tp.SetCp(cpMin);                    // tp points at this range's cpMin
        if(!tp.IsAtBOSentence())            // If not at beginning of sentence
            tp.FindBOSentence(tomBackward); //  search backward for one
        *pcpMin = cpMin = tp.GetCp();
    }

    if(pcpMost)                             // Find sentence end
    {                                       // Point tp at this range's cpLim
        tp.SetCp(cpMost);                   // If cpMost isn't at sentence
        if (!tp.IsAtBOSentence() ||         //  beginning or if at story
            (!cpMost || pcpMin) &&          //  beginning or expanding
             cpMin == cpMost)               //  IP at sentence beginning,
        {                                   //  find next sentence beginning
            if(!tp.FindBOSentence(tomForward))
                tp.SetCp(GetTextLength());  // End of story counts as
        }                                   //  sentence end too
        *pcpMost = tp.GetCp();
    }
}

/*
 *  CTxtRange::FindVisibleRange(pcpMin, pcpMost)
 *
 *  @mfunc
 *      Set *pcpMin  = _pdp->_cpFirstVisible
 *      Set *pcpMost = _pdp->_cpLastVisible
 *
 *  @rdesc
 *      TRUE iff calculated cp's differ from this range's cp's
 *
 *  @devnote
 *      CDisplay::GetFirstVisible() and GetCliVisible() return the first cp
 *      on the first visible line and the last cp on the last visible line.
 *      These won't be visible if they are scrolled off the screen.
 *      FUTURE: A more general algorithm would CpFromPoint (0,0) and
 *      (right, bottom).
 */
BOOL CTxtRange::FindVisibleRange (
    LONG *pcpMin,           //@parm Out parm for cpFirstVisible
    LONG *pcpMost) const    //@parm Out parm for cpLastVisible
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::FindVisibleRange");

    _TEST_INVARIANT_

    CDisplay *  pdp = GetPed()->_pdp;

    if(!pdp)
        return FALSE;

    if(pcpMin)
        *pcpMin = pdp->GetFirstVisibleCp();

    pdp->GetCliVisible(pcpMost);

    return TRUE;
}

/*
 *  CTxtRange::FindWord(pcpMin, pcpMost, type)
 *
 *  @mfunc
 *      Set *pcpMin  = closest word cpMin  <lt>= range cpMin
 *      Set *pcpMost = closest word cpMost <gt>= range cpMost
 *
 *  @comm
 *      There are two interesting cases for finding a word.  The first,
 *      (FW_EXACT) finds the exact word, with no extraneous characters.
 *      This is useful for situations like applying formatting to a
 *      word.  The second case, FW_INCLUDE_TRAILING_WHITESPACE does the
 *      obvious thing, namely includes the whitespace up to the next word.
 *      This is useful for the selection double-click semantics and TOM.
 */
void CTxtRange::FindWord(
    LONG *pcpMin,           //@parm Out parm to receive word's cpMin; NULL OK
    LONG *pcpMost,          //@parm Out parm to receive word's cpMost; NULL OK
    FINDWORD_TYPE type) const //@parm Type of word to find
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::FindWord");

    LONG    cch, cch1;
    LONG    cpMin, cpMost;
    CTxtPtr tp(_rpTX);

    _TEST_INVARIANT_

    Assert(type == FW_EXACT || type == FW_INCLUDE_TRAILING_WHITESPACE );

    GetRange(cpMin, cpMost);
    if(pcpMin)
    {
        tp.SetCp(cpMin);
        if(!tp.IsAtBOWord())                            // cpMin not at BOW:
            cpMin += tp.FindWordBreak(WB_MOVEWORDLEFT); //  go there

        *pcpMin = cpMin;

        Assert(cpMin >= 0 && cpMin <= GetTextLength());
    }

    if(pcpMost)
    {
        tp.SetCp(cpMost);
        if (!tp.IsAtBOWord() ||                         // If not at word strt
            (!cpMost || pcpMin) && cpMin == cpMost)     //  or there but need
        {                                               //  to expand IP,
            cch = tp.FindWordBreak(WB_MOVEWORDRIGHT);   //  move to next word

            if(cch && type == FW_EXACT)                 // If moved and want
            {                                           //  word proper, move
                cch1 = tp.FindWordBreak(WB_LEFTBREAK);  //  back to end of
                if(cch + cch1 > 0)                      //  preceding word
                    cch += cch1;                        // Only do so if were
            }                                           //  not already at end
            cpMost += cch;
        }
        *pcpMost = cpMost;

        Assert(cpMost >= 0 && cpMost <= GetTextLength());
        Assert(cpMin <= cpMost);
    }
}

/*
 *  CTxtRange::FindAttributes(pcpMin, pcpMost, dwMask)
 *
 *  @mfunc
 *      Set *pcpMin  = closest attribute-combo cpMin  <lt>= range cpMin
 *      Set *pcpMost = closest attribute-combo cpMost <gt>= range cpMost
 *      The attribute combo is given by Unit and is any OR combination of
 *      TOM attributes, e.g., tomBold, tomItalic, or things like
 *      tomBold | tomItalic.  The combo is found if any of the attributes
 *      is present.
 *
 *  @devnote
 *      Plan to add other logical combinations: tomAND, tomExact
 */
void CTxtRange::FindAttributes (
    LONG *pcpMin,           //@parm Out parm for bounding-sentence cpMin
    LONG *pcpMost,          //@parm Out parm for bounding-sentence cpMost
    LONG Unit) const        //@parm TOM attribute mask
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::FindAttributes");
    LONG        cch;
    LONG        cpMin, cpMost;
    DWORD       dwMask = Unit & ~0x80000000;    // Kill sign bit
    CCFRunPtr   rp(*this);

    Assert(Unit < 0);
    GetRange(cpMin, cpMost);

    if(!rp.IsValid())                       // No CF runs instantiated
    {
        if(rp.IsMask(dwMask))               // Applies to default CF
        {
            if(pcpMin)
                *pcpMin = 0;
            if(pcpMost)
                *pcpMost = GetTextLength();
        }
        return;
    }

    // Start at cpMin
    if(_cch > 0)
        rp.AdvanceCp(-_cch);

    // Go backward until we don't match dwMask
    if(pcpMin)
    {
        rp.AdjustBackward();
        while(rp.IsMask(dwMask) && rp.GetIch())
        {
            cpMin -= rp.GetIch();
            rp.AdvanceCp(-rp.GetIch());
            rp.AdjustBackward();
        }
        *pcpMin = cpMin;
    }

    // Now go forward from cpMost until we don't match dwMask
    if(pcpMost)
    {
        rp.AdvanceCp(cpMost - cpMin);
        rp.AdjustForward();                 // In case cpMin = cpMost
        cch = rp.GetCchLeft();
        while(rp.IsMask(dwMask) && cch)
        {
            cpMost += cch;
            rp.AdvanceCp(cch);
            cch = rp.GetCchLeft();
        }
        *pcpMost = cpMost;
    }
}

/*
 *  CTxtRange::CalcTextLenNotInRange()
 *
 *  @mfunc
 *      Helper function that calculates the total length of text
 *      excluding the current range.
 *
 *  @comm
 *      Used for limit testing. The problem being solved is that
 *      the range can contain the final EOP which is not included
 *      in the adjusted text length.
 */
LONG CTxtRange::CalcTextLenNotInRange()
{
    LONG    cchAdjLen = GetPed()->GetAdjustedTextLength();
    LONG    cchLen = cchAdjLen - abs(_cch);
    LONG    cpMost = GetCpMost();

    if (cpMost > cchAdjLen)
    {
        // Selection extends beyond adjusted length. Put amount back in the
        // selection as it has become too small by the difference.
        cchLen += cpMost - cchAdjLen;
    }
    return cchLen;
}

////////////////////////// Outline Support //////////////////////////////////

/*
 *  CTxtRange::Promote(lparam, publdr)
 *
 *  @mfunc
 *      Promote selected text according to:
 *
 *      LOWORD(lparam) == 0 ==> promote to body-text
 *      LOWORD(lparam) != 0 ==> promote/demote current selection by
 *                              LOWORD(lparam) levels
 *  @rdesc
 *      TRUE iff promotion occurred
 *
 *  @devnote
 *      Changes this range
 */
HRESULT CTxtRange::Promote (
    LPARAM        lparam,   //@parm 0 to body, < 0 demote, > 0 promote
    IUndoBuilder *publdr)   //@parm undo builder to receive antievents
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtRange::Promote");

    if(abs(lparam) >= NHSTYLES)
        return E_INVALIDARG;

    if(publdr)
        publdr->StopGroupTyping();

    if(_cch > 0)                            // Point at cpMin
        FlipRange();

    LONG        cchText = GetTextLength();
    LONG        cpEnd = GetCpMost();
    LONG        cpMin, cpMost;
    BOOL        fHeading = TRUE;            // Default heading in range
    HRESULT     hr;
    LONG        Level;
    LONG        nHeading = NHSTYLES;        // Setup to find any heading
    CParaFormat PF;
    const CParaFormat *pPF;
    CPFRunPtr   rp(*this);
    LONG        cch = rp.FindHeading(abs(_cch), nHeading);
    WORD        wEffects;

    if(!lparam)                             // Demote to subtext
    {
        if(cch)                             // Already in subtext so don't
            return S_FALSE;                 //  need to demote

        CTxtPtr tp(_rpTX);

        if(!tp.IsAfterEOP())
            cch = tp.FindEOP(tomBackward);
        nHeading = 1;
        if(tp.GetCp())                      // Get previous level and convert
        {                                   //  to heading to set up
            rp.AdvanceCp(cch);              //  following Level code
            rp.AdjustBackward();
            nHeading = rp.GetOutlineLevel()/2 + 1;
        }
    }
    else if(cch == tomBackward)             // No heading in range
    {                                       // Set up to promote to
        nHeading = rp.GetOutlineLevel()/2   //  heading
                 + (lparam > 0 ? 2 : 1);
        fHeading = FALSE;                   // Signal no heading in range
    }
    else if(cch)                            // Range starts in subtext
    {
        SetExtend(TRUE);
        Advance(cch);                       // Bypass initial nonheading
    }

    Level = 2*(nHeading - 1);               // Heading level
    PF._bOutlineLevel = (BYTE)(Level | 1);  // Corresponding subtext level

    if (!Level && lparam > 0 ||             // Can't promote Heading 1
        nHeading == NHSTYLES && lparam < 0) //  or demote Heading 9
    {
        return S_FALSE;
    }
    do
    {
        _cch = 0;
        Level -= long(2*lparam);            // Promote Level
        pPF = GetPF();
        wEffects = pPF->_wEffects;
        if(pPF->_bOutlineLevel & 1)         // Handle contiguous text in
        {                                   //  one fell swoop
            cch = fHeading ? _rpPF.GetCchLeft() : cpEnd - GetCp();
            if(cch > 0)
            {
                SetExtend(TRUE);
                Advance(cch);
            }
        }
        Expander(tomParagraph, TRUE, NULL, &cpMin, &cpMost);

        if((unsigned)Level < 2*NHSTYLES)
        {                                   // Promoted Level is valid
            DWORD dwMask = PFM_OUTLINELEVEL;// Default setting subtext level
            if(!(Level & 1) && lparam)      // Promoting or demoting heading
            {                               // Preserve collapse status
                PF._wEffects = Level ? wEffects : 0; // H1 is aways expanded
                PF._sStyle = (SHORT)(-Level/2 + STYLE_HEADING_1);
                PF._bOutlineLevel = (BYTE)(Level | 1);// Set up subtext
                dwMask = PFM_STYLE + PFM_COLLAPSED;
            }
            else if(!lparam)                // Changing heading to subtext
            {                               //  or uncollapsing subtext
                PF._wEffects = 0;           // Turn off collapsed
                PF._sStyle = STYLE_NORMAL;
                dwMask = PFM_STYLE + PFM_OUTLINELEVEL + PFM_COLLAPSED;
            }
            hr = SetParaStyle(&PF, publdr, dwMask);
            if(hr != NOERROR)
                return hr;
        }
        if(GetCp() >= cchText)              // Have handled last PF run
            break;
        Assert(_cch > 0);                   // Para/run should be selected
        pPF = GetPF();                      // Points at next para
        Level = pPF->_bOutlineLevel;
    }                                       // Iterate until past range &
    while((Level & 1) || fHeading &&        // any subtext that follows
          (GetCp() < cpEnd || pPF->_wEffects & PFE_COLLAPSED));

    return NOERROR;
}

/*
 *  CTxtRange::ExpandOutline(Level, fWholeDocument)
 *
 *  @mfunc
 *      Expand outline according to Level and fWholeDocument. Wraps
 *      OutlineExpander() helper function and updates selection/view
 *
 *  @rdesc
 *      NOERROR if success
 */
HRESULT CTxtRange::ExpandOutline(
    LONG Level,             //@parm If < 0, collapse; else expand, etc.
    BOOL fWholeDocument)    //@parm If TRUE, whole document
{
    if (!IsInOutlineView())
        return NOERROR;

    HRESULT hres = OutlineExpander(Level, fWholeDocument);
    if(hres != NOERROR)
        return hres;

    GetPed()->TxNotify(EN_PARAGRAPHEXPANDED, NULL);
    return GetPed()->UpdateOutline();
}

/*
 *  CTxtRange::OutlineExpander(Level, fWholeDocument)
 *
 *  @mfunc
 *      Expand/collapse outline for this range according to Level
 *      and fWholeDocument.  If fWholeDocument is TRUE, then
 *      1 <= Level <= NHSTYLES collapses all headings with numbers
 *      greater than Level and collapses all nonheadings. Level = -1
 *      expands all.
 *
 *      fWholeDocument = FALSE expands/collapses (Level > 0 or < 0)
 *      paragraphs depending on whether an EOP and heading are included
 *      in the range.  If Level = 0, toggle heading's collapsed status.
 *
 *  @rdesc
 *      (change made) ? NOERROR : S_FALSE
 */
HRESULT CTxtRange::OutlineExpander(
    LONG Level,             //@parm If < 0, collapse; else expand, etc.
    BOOL fWholeDocument)    //@parm If TRUE, whole document
{
    CParaFormat PF;

    if(fWholeDocument)                          // Apply to whole document
    {
        if (IN_RANGE(1, Level, NHSTYLES) ||     // Collapse to heading
            Level == -1)                        // -1 means all
        {
            Set(0, tomBackward);                // Select whole document
            PF._sStyle = (SHORT)(STYLE_COMMAND + (BYTE)Level);
            SetParaFormat(&PF, NULL, PFM_STYLE);// No undo
            return NOERROR;
        }
        return S_FALSE;                         // Nothing happened (illegal
    }                                           //  arg)

    // Expand/Collapse for Level positive/negative, respectively

    LONG cpMin, cpMost;                         // Get range cp's
    LONG cchMax = GetRange(cpMin, cpMost);
    if(_cch > 0)                                // Ensure cpMin is active
        FlipRange();                            //  for upcoming rp and tp

    LONG      nHeading = NHSTYLES;              // Setup to find any heading
    LONG      nHeading1;
    CTxtEdit *ped = GetPed();
    CPFRunPtr rp(*this);
    LONG      cch = rp.FindHeading(cchMax, nHeading);

    if(cch == tomBackward)                      // No heading found within range
        return S_FALSE;                         // Do nothing

    Assert(cch <= cchMax && (Level || !cch));   // cch is count up to heading
    CTxtPtr tp(_rpTX);
    cpMin += cch;                               // Bypass any nonheading text
    tp.AdvanceCp(cch);                          //  at start of range

    // If toggle collapse or if range contains an EOP,
    // collapse/expand all subordinates
    cch = tp.FindEOP(tomForward);               // Find next para
    if(!cch)
        return NOERROR;

    if(!Level || cch < -_cch)                   // Level = 0 or EOP in range
    {
        if(!Level)                              // Toggle collapse status
        {
            LONG cchLeft = rp.GetCchLeft();
            if (cch < cchLeft || !rp.NextRun() ||
                nHeading == STYLE_HEADING_1 - rp.GetStyle() + 1)
            {
                return NOERROR;                 // Next para has same heading
            }
            Assert(cch == cchLeft);
            Level = rp.IsCollapsed();
            rp.AdvanceCp(-cchLeft);
        }
        PF._wEffects = Level > 0 ? 0 : PFE_COLLAPSED;
        while(cpMin < cpMost)
        {                                       // We're at a heading
            tp.SetCp(cpMin);
            cch = tp.FindEOP(-_cch);
            cpMin += cch;                       // Bypass it
            if(!rp.AdvanceCp(cch))              // Point at next para
                break;                          // No more, we're done
            nHeading1 = nHeading;               // Setup to find heading <= nHeading
            cch = rp.FindHeading(tomForward, nHeading1);
            if(cch == tomBackward)              // No more higher headings
                cch = GetTextLength() - cpMin;  // Format to end of text
            Set(cpMin, -cch);                   // Collapse/expand up to here
            SetParaFormat(&PF, NULL, PFM_COLLAPSED);
            cpMin += cch;                       // Move past formatted area
            nHeading = nHeading1;               // Update nHeading to possibly
        }                                       //  lower heading #
        return NOERROR;
    }

    // Range contains no EOP: expand/collapse deepest level.
    // If collapsing, collapse all nonheading text too. Expand
    // nonheading text only if all subordinate levels are expanded.
    BOOL    fCollapsed;
    LONG    nHeadStart, nHeadDeepNC, nHeadDeep;
    LONG    nNonHead = -1;                      // No nonHeading found yet
    const CParaFormat *pPF;

    cpMin = tp.GetCp();                         // Point at start of
    cpMost = cpMin;                             //  next para
    pPF = ped->GetParaFormat(_rpPF.GetFormat());
    nHeading = pPF->_bOutlineLevel;

    Assert(!(nHeading & 1) &&                   // Must start with a heading
        !(pPF->_wEffects & PFE_COLLAPSED));     //  that isn't collapsed

    nHeadStart = nHeading/2 + 1;                // Convert outline level to
    nHeadDeep = nHeadDeepNC = nHeadStart;       //  heading number

    while(cch)                                  // Determine deepest heading
    {                                           //  and deepest collapsed
        rp.AdvanceCp(cch);                      //  heading
        pPF = ped->GetParaFormat(rp.GetFormat());
        fCollapsed = pPF->_wEffects & PFE_COLLAPSED;
        nHeading = pPF->_bOutlineLevel;
        if(nHeading & 1)                        // Text found
        {                                       // Set nNonHead > 0 if
            nNonHead = fCollapsed;              //  collapsed; else 0
            cch = rp.GetCchLeft();              // Zip to end of contiguous
            tp.AdvanceCp(cch);                  //  text paras
        }
        else                                    // It's a heading
        {
            nHeading = nHeading/2 + 1;          // Convert to heading number
            if(nHeading <= nHeadStart)          // If same or shallower as
                break;                          //  start heading we're done

            // Update deepest and deepest nonCollapsed heading #'s
            nHeadDeep = max(nHeadDeep, nHeading);
            if(!fCollapsed)
                nHeadDeepNC = max(nHeadDeepNC, nHeading);
            cch = tp.FindEOP(tomForward);       // Go to next paragraph
        }
        cpMost = tp.GetCp();                    // Include up to it
    }

    PF._sStyle = (SHORT)(STYLE_COMMAND + nHeadDeepNC);
    if(Level > 0)                               // Expand
    {
        if(nHeadDeepNC < nHeadDeep)             // At least one collapsed
            PF._sStyle++;                       //  heading: expand shallowest
        else                                    // All heads expanded: do others
            PF._sStyle = (unsigned short) (STYLE_COMMAND + 0xFF);
    }                                           // In any case, expand nonheading
    else if(nNonHead)                           // Collapse. If text collapsed
    {                                           //  or missing, do headings
        if(nHeadDeepNC == nHeadStart)
            return S_FALSE;                     // Everything already collapsed
        PF._sStyle--;                           // Collapse to next shallower
    }                                           //  heading

    Set(cpMin, cpMin - cpMost);                 // Select range to change
    SetParaFormat(&PF, NULL, PFM_STYLE);        // No undo
    return NOERROR;
}

/*
 *  CTxtRange::CheckOutlineLevel(publdr)
 *
 *  @mfunc
 *      If the paragraph style at this range isn't a heading, make
 *      sure its outline level is compatible with the preceeding one
 */
void CTxtRange::CheckOutlineLevel(
    IUndoBuilder *publdr)       //@parm Undo context for this operation
{
    LONG      LevelBackward, LevelForward;
    CPFRunPtr rp(*this);

    Assert(!_cch);

    rp.AdjustBackward();
    LevelBackward = rp.GetOutlineLevel() | 1;   // Nonheading level corresponding
                                                //  to previous PF run
    rp.AdjustForward();
    LevelForward = rp.GetOutlineLevel();

    if (!(LevelForward & 1) ||                  // Any heading can follow
        LevelForward == LevelBackward)          //  any style. Also if
    {                                           //  forward level is correct,
        return;                                 //  return
    }

    LONG        cch;                            // One or more nonheadings
    LONG        lHeading = NHSTYLES;            //  with incorrect outline
    CParaFormat PF;                             //  levels follow

    PF._bOutlineLevel = (BYTE)LevelBackward;        //  level

    cch = rp.FindHeading(tomForward, lHeading); // Find next heading
    if(cch == tomBackward)
        cch = tomForward;

    Set(GetCp(), -cch);                         // Select all nonheading text
    SetParaFormat(&PF, publdr, PFM_OUTLINELEVEL);// Change its outline level
    Set(GetCp(), 0);                            // Restore range to IP
}

#if defined(DEBUG)
/*
 *  CTxtRange::::DebugFont (void)
 *
 *  @mfunc
 *      Dump out the character and Font info for current selection.
 */
void CTxtRange::DebugFont (void)
{
    LONG            ch;
    LONG            cpMin, cpMost;
    LONG            cch = GetRange(cpMin, cpMost);
    LONG            i;
    char            szTempBuf[64];
    CTxtEdit        *ped = GetPed();
    const           WCHAR *wszFontname;
    const           CCharFormat *CF;                // Temporary CF
    const           WCHAR *GetFontName(LONG iFont);

    char            szTempPath[MAX_PATH] = "\0";
    DWORD           cchLength;
    HANDLE          hfileDump;
    DWORD           cbWritten;

    SideAssert(cchLength = GetTempPathA(MAX_PATH, szTempPath));

    // append trailing backslash if neccessary
    if(szTempPath[cchLength - 1] != '\\')
    {
        szTempPath[cchLength] = '\\';
        szTempPath[cchLength + 1] = 0;
    }

    strcat(szTempPath, "DumpFontInfo.txt");

    SideAssert(hfileDump = CreateFileA(szTempPath,
            GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL));

    if(_cch > 0)                            // start from cpMin
        FlipRange();

    CFormatRunPtr rp(_rpCF);

    for (i=0; i <= cch; i++)
    {
        LONG    iFormat;

        if (GetChar(&ch) != NOERROR)
            break;

        if (ch <= 0x07f)
            sprintf(szTempBuf, "Char= '%c'\r\n", (char)ch);
        else
            sprintf(szTempBuf, "Char= 0x%x\r\n", ch);
        OutputDebugStringA(szTempBuf);
        if (hfileDump)
            WriteFile(hfileDump, szTempBuf, strlen(szTempBuf), &cbWritten, NULL);

        iFormat = rp.GetFormat();
        CF = ped->GetCharFormat(iFormat);
        Assert(CF);

        sprintf(szTempBuf, "Font iFormat= %d, Charset= %d, Size= %d\r\nName= ",
            iFormat, CF->_bCharSet, CF->_yHeight);
        OutputDebugStringA(szTempBuf);
        if (hfileDump)
            WriteFile(hfileDump, szTempBuf, strlen(szTempBuf), &cbWritten, NULL);

        wszFontname = GetFontName(CF->_iFont);
        if (wszFontname)
        {
            if (*wszFontname <= 0x07f)
            {
                szTempBuf[0] = '\'';
                WCTMB(CP_ACP, 0,
                        wszFontname, -1, &szTempBuf[1], sizeof(szTempBuf)-1,
                        NULL, NULL, NULL);
                strcat(szTempBuf,"\'");
                OutputDebugStringA(szTempBuf);
                if (hfileDump)
                    WriteFile(hfileDump, szTempBuf, strlen(szTempBuf), &cbWritten, NULL);
            }
            else
            {
                for (; *wszFontname; wszFontname++)
                {
                    sprintf(szTempBuf, "0x%x,", *wszFontname);
                    OutputDebugStringA(szTempBuf);
                    if (hfileDump)
                        WriteFile(hfileDump, szTempBuf, strlen(szTempBuf), &cbWritten, NULL);
                }
            }
        }

        OutputDebugStringA("\r\n");
        if (hfileDump)
            WriteFile(hfileDump, "\r\n", 2, &cbWritten, NULL);

        Advance(1);
        rp.AdvanceCp(1);
    }

    // Now dump the doc font info
    CF = ped->GetCharFormat(-1);
    Assert(CF);

    sprintf(szTempBuf, "Default Font iFormat= -1, Charset= %d, Size= %d\r\nName= ",
        CF->_bCharSet, CF->_yHeight);
    OutputDebugStringA(szTempBuf);
    if (hfileDump)
        WriteFile(hfileDump, szTempBuf, strlen(szTempBuf), &cbWritten, NULL);

    wszFontname = GetFontName(CF->_iFont);
    if (wszFontname)
    {
        if (*wszFontname <= 0x07f)
        {
            szTempBuf[0] = '\'';
            WCTMB(CP_ACP, 0,
                    wszFontname, -1, &szTempBuf[1], sizeof(szTempBuf),
                    NULL, NULL, NULL);
            strcat(szTempBuf,"\'");
            OutputDebugStringA(szTempBuf);
            if (hfileDump)
                WriteFile(hfileDump, szTempBuf, strlen(szTempBuf), &cbWritten, NULL);
        }
        else
        {
            for (; *wszFontname; wszFontname++)
            {
                sprintf(szTempBuf, "0x%x,", *wszFontname);
                OutputDebugStringA(szTempBuf);
                if (hfileDump)
                    WriteFile(hfileDump, szTempBuf, strlen(szTempBuf), &cbWritten, NULL);
            }
        }
    }

    OutputDebugStringA("\r\n");
    if (hfileDump)
        WriteFile(hfileDump, "\r\n", 2, &cbWritten, NULL);


    if (ped->IsRich())
    {
        if (ped->fUseUIFont())
            sprintf(szTempBuf, "Rich Text with UI Font");
        else
            sprintf(szTempBuf, "Rich Text Control");
    }
    else
        sprintf(szTempBuf, "Plain Text Control");

    OutputDebugStringA(szTempBuf);
    if (hfileDump)
        WriteFile(hfileDump, szTempBuf, strlen(szTempBuf), &cbWritten, NULL);

    OutputDebugStringA("\r\n");
    if (hfileDump)
        WriteFile(hfileDump, "\r\n", 2, &cbWritten, NULL);

    if (hfileDump)
        CloseHandle(hfileDump);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\rtext.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module RTEXT.CPP - Rich-text ptr class |
 *
 *		This text ptr consists of a plain text ptr (_rpTX), a CCharFormat
 *		run ptr (_rpCF), and a CParaFormat run ptr (_rpPF). This module
 *		contains the methods to manipulate this combination of run ptrs
 *		consistently.
 *	
 *	Authors:<nl>
 *		RichEdit 1.0 code: David R. Fulmer
 *		Main implementation: Murray Sargent <nl>
 *		Undo and notification implementations: Alex Gounares <nl>
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_edit.h"
#include "_frunptr.h"
#include "_rtext.h"
#include "_disp.h"
#include "_select.h"
#include "_m_undo.h"
#include "_antievt.h"
#include "_objmgr.h"
#include "_txtbrk.h"

ASSERTDATA

#define DEBUG_CLASSNAME CRchTxtPtr
#include "_invar.h"

#ifdef DEBUG
/*
 *	CRchTxtPtr::Invariant
 */
BOOL CRchTxtPtr::Invariant( void ) const
{
	if (m_InvariantCheckInterval < 1 || m_InvariantCheckInterval > 10)
		const_cast<CRchTxtPtr *>(this)->m_InvariantCheckInterval = 10;

	const_cast<CRchTxtPtr *>(this)->m_InvariantCheckInterval--;

	if (m_InvariantCheckInterval)
		return TRUE;

	unsigned ch;
	LONG cch;
	LONG cchLength = GetTextLength();
	LONG cp;

	_rpTX.Invariant();
	_rpCF.Invariant();
	_rpPF.Invariant();

	if(_rpCF.IsValid())
	{
		cp  = _rpCF.CalculateCp();
		cch = _rpCF.CalcTextLength();
		Assert(GetCp() == cp && cchLength == cch);
		Assert(!_rpCF._iRun || GetPed()->IsBiDi() || _rpCF.GetRun(0)->_iFormat != _rpCF.GetRun(-1)->_iFormat);
	}

	if(_rpPF.IsValid())
	{
		cp  = _rpPF.CalculateCp();
		cch = _rpPF.CalcTextLength();
		Assert(GetCp() == cp && cchLength == cch);

		CTxtPtr	tp(_rpTX);

		tp.AdvanceCp(_rpPF.GetCchLeft() - 1);
		ch = tp.GetChar();
		if(!IsASCIIEOP(ch))
		{
			_rpTX.MoveGapToEndOfBlock();			// Make it easier to see
			AssertSz(FALSE,							//  what's going on
				"CRchTxtPtr::Invariant: PF run doesn't end with EOP");
		}

#ifdef EXTREME_CHECKING
		// We don't do this check normally as it is _extremely_ slow.
		// However, it's very useful for catching para-format run problems

		// Make sure each para format run ends on a paragraph mark!
		CFormatRunPtr	rpPF(_rpPF);

		rpPF.BindToCp(0);
		tp.BindToCp(0);
		do
		{
			tp.AdvanceCp(rpPF.GetRun(0)->_cch);
			if(!tp.IsAfterEOP())
			{
				AssertSz(0, "ParaFormat Run not aligned along paragraphs!");
			}
		} while( rpPF.NextRun() );
#endif // EXTREME_CHECKING
	}
	return TRUE;
}

#endif  // DEBUG

//======================= CRchTxtPtr constructors ========================================

CRchTxtPtr::CRchTxtPtr(CTxtEdit *ped) :
	_rpTX(ped, 0), _rpCF(NULL),	_rpPF(NULL)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::CRchTxtPtr");

	InitRunPtrs();
}

CRchTxtPtr::CRchTxtPtr(CTxtEdit *ped, LONG cp) :
	_rpTX(ped, cp), _rpCF(NULL), _rpPF(NULL)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::CRchTxtPtr");

	InitRunPtrs();
}

CRchTxtPtr::CRchTxtPtr (const CRchTxtPtr& rtp) :
	_rpTX(rtp._rpTX), _rpCF(rtp._rpCF), _rpPF(rtp._rpPF)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::CRchTxtPtr");

	_rpCF.AdjustForward();		// In case rtp is adjusted backward...
	_rpPF.AdjustForward();
}

CRchTxtPtr::CRchTxtPtr (const CDisplay * pdp) :
	_rpTX(pdp->GetPed(), 0), _rpCF(NULL), _rpPF(NULL)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::CRchTxtPtr");

	InitRunPtrs();
}

/*
 *	CRchTxtPtr::Advance(cch)
 *	
 *	@mfunc
 *		Move this rich-text ptr forward <p cch> characters.  If <p cch>
 *		<lt> 0, move backward by -<p cch> characters.
 *	
 *	@rdesc
 *		cch actually moved
 *
 */
LONG CRchTxtPtr::Advance(
	LONG cch)			// @parm count of characters to move - may be <lt> 0
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::Advance");

	if( cch != 0 )
	{
		cch = _rpTX.AdvanceCp(cch);
		_rpCF.AdvanceCp(cch);
		_rpPF.AdvanceCp(cch);
		_TEST_INVARIANT_
	}

	return cch;
}

/*
 *  CRchTxtPtr::AdvanceCRLF()
 *
 *  @mfunc
 *      Advance this text ptr one char, treating CRLF as a single char.
 *
 *  @rdesc
 *      cch actually moved
 */
LONG CRchTxtPtr::AdvanceCRLF()
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CRchTxtPtr::AdvanceCRLF");

    LONG cch = _rpTX.AdvanceCpCRLF();
    _rpPF.AdvanceCp(cch);
    _rpCF.AdvanceCp(cch);
    return cch;
}

/*
 *  CRchTxtPtr::SnapToCluster(INT iDirection)
 *
 *  @mfunc
 *      If this text ptr is not at cluster boundary, move it to the closest one.
 *
 *  @rdesc
 *      cch actually moved
 */
LONG CRchTxtPtr::SnapToCluster(INT iDirection)
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CRchTxtPtr::SnapToCluster");

	LONG	cch = 0;
	LONG	cp;

	if (GetPed()->_pbrk)
	{
		if (iDirection >= 0)
		{
			LONG	cpEnd = GetPed()->GetAdjustedTextLength();

			while ((cp = GetCp()) < cpEnd && !GetPed()->_pbrk->CanBreakCp(BRK_CLUSTER, cp))
				cch += AdvanceCRLF();
		}
		else
		{
			while ((cp = GetCp()) > 0 && !GetPed()->_pbrk->CanBreakCp(BRK_CLUSTER, cp))
				cch += BackupCRLF();
		}
	}
    return cch;
}

/*
 *  CRchTxtPtr::BackupCRLF()
 *
 *  @mfunc
 *      Backup this text ptr one char, treating CRLF as a single char.
 *
 *  @rdesc
 *      cch actually moved
 */
LONG CRchTxtPtr::BackupCRLF(
	BOOL fDiacriticCheck)
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CRchTxtPtr::BackupCRLF");

    LONG cch = _rpTX.BackupCpCRLF(fDiacriticCheck);
    _rpPF.AdvanceCp(cch);
    _rpCF.AdvanceCp(cch);
    return cch;
}

/*
 * CRchTxtPtr::ValidateCp(&cp)
 *
 *	@mfunc
 *		If <p cp> <lt> 0, set it to 0; if it's <gt> text length, set it to
 *		text length.
 */
void CRchTxtPtr::ValidateCp(
	LONG &cp) const			// @parm new cp for this text ptr
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::ValidateCp");

	LONG cchT = GetTextLength();

	cp = min(cp, cchT);				// Be sure cp is valid
	cp = max(cp, 0);
}

/*
 * CRchTxtPtr::SetCp(cp)
 *
 *	@mfunc
 *		Set this rich text ptr's cp to cp
 */
LONG CRchTxtPtr::SetCp(
	LONG cp)			// @parm new cp for this text ptr
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::SetCp");

	CRchTxtPtr::Advance(cp - GetCp());
	return GetCp();
}

/*	CRchTxtPtr::GetIchRunXX() and CRchTxtPtr::GetCchRunXX()
 *
 *	@mfunc
 *		Text-run management to retrieve current text run cch and offset
 *
 *	@rdesc
 *		current run ich or cch
 *
 *	@devnote
 *		Use of queries like _rpCF.IsValid() instead of an inclusive fRich
 *		allows rich-text formatting to be applied per rich-text category,
 *		e.g., CHARFORMATs, but not necessarily PARAFORMATs.  If the rp isn't
 *		valid, _cp is used for ich and the document length is used for cch,
 *		i.e., the values for a document describable by a single plain-text run
 */
LONG CRchTxtPtr::GetIchRunCF()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::GetIchRunCF");

	return _rpCF.IsValid() ? _rpCF.GetIch() : GetCp();
}

LONG CRchTxtPtr::GetIchRunPF()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::GetIchRunPF");

	return _rpPF.IsValid() ? _rpPF.GetIch() : GetCp();
}

LONG CRchTxtPtr::GetCchRunCF()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::GetCchRunCF");

	return _rpCF.IsValid() ? _rpCF.GetRun(0)->_cch : GetTextLength();
}

/*	CRchTxtPtr::GetCchLeftRunCF() / GetCchLeftRunPF()
 *
 *	@mfunc
 *		Return cch left in run, i.e., cchRun - ich
 *
 *	@rdesc
 *		cch left in run
 */
LONG CRchTxtPtr::GetCchLeftRunCF()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::GetCchLeftRunCF");

	return _rpCF.IsValid()
		? _rpCF.GetCchLeft() : GetTextLength() - GetCp();
}

LONG CRchTxtPtr::GetCchLeftRunPF()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::GetCchLeftRunPF");

	return _rpPF.IsValid()
		? _rpPF.GetCchLeft() : GetTextLength() - GetCp();
}

/*
 *	CRchTxtPtr::FindText(cpMost, dwFlags, pch, cchToFind)
 *	
 *	@mfunc
 *		Find text in a range starting at this text pointer;
 *		if found, moves this text pointer to that position.
 *	
 *	@rdesc
 *		character position of first match
 *		<lt> 0 if no match
 *
 *	@devnote
 *		Would be easy to match a single format (like Word 6) provided
 *		cchToFind is nonzero.  Else need to search runs (also pretty easy).
 *		For format-sensitive searches, might be easier to search for matching
 *		format run first and then within that run search for text.
 */
LONG CRchTxtPtr::FindText (
	LONG		cpMost,		// @parm Limit of search; <lt> 0 for end of text
	DWORD		dwFlags,	// @parm FR_MATCHCASE	case must match
							//		 FR_WHOLEWORD	match must be a whole word
	TCHAR const *pch,		// @parm Text to search for
	LONG		cchToFind)	// @parm Length of text to search for
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::FindText");

	_TEST_INVARIANT_

	LONG cpSave = GetCp();
	LONG cpMatch = _rpTX.FindText(cpMost, dwFlags, pch, cchToFind);

	if(cpMatch >= 0)					// cpMatch = -1 means "not found"
		SetRunPtrs(GetCp(), cpSave);	
	
			// possible code for format-dependent Finds
	return cpMatch;
}

/*
 *	CRchTxtPtr::GetCF()/GetPF()
 *	
 *	@mfunc
 *		Return ptr to CCharFormat/CParaFormat at this text ptr. If no CF/PF runs
 *		are allocated, then return ptr to default format
 *	
 *	@rdesc
 *		Ptr to CCharFormat/CParaFormat at this text ptr
 */
const CCharFormat* CRchTxtPtr::GetCF() const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::GetCF");

	return ((CTxtArray *)_rpTX._pRuns)->GetCharFormat(_rpCF.GetFormat());
}

const CParaFormat* CRchTxtPtr::GetPF() const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::GetPF");

	return ((CTxtArray *)_rpTX._pRuns)->GetParaFormat(_rpPF.GetFormat());
}

/*
 *	CRchTxtPtr::ReplaceRange(cchOld, cchNew, *pch, pcpFirstRecalc, publdr,
 *							 iFormat, pcchMove, dwFlags)
 *	@mfunc
 *		Replace a range of text at this text pointer using CCharFormat iFormat
 *		and updating other text runs as needed
 *	
 *	@rdesc
 *		Count of new characters added
 *	
 *	@devnote
 *		Moves this text pointer to end of replaced text.
 *		May move text block and formatting arrays.
 */
LONG CRchTxtPtr::ReplaceRange(
	LONG		cchOld,		//@parm length of range to replace
							//		(<lt> 0 means to end of text)
	LONG		cchNew,		//@parm length of replacement text
	TCHAR const *pch,		//@parm replacement text
	IUndoBuilder *publdr,	//@parm Undo bldr to receive antievents
	LONG		iFormat,	//@parm CCharFormat iFormat to use for cchNew
	LONG *		pcchMove,	//@parm Out parm returning cch moved if paradir change
	DWORD		dwFlags)	//@parm Special flags
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::ReplaceRange");

	LONG		  cch;
	LONG		  cchEndEOP = 0;				// Default 0 final EOP fixup
	LONG		  cchAdvance = 0;
	LONG		  cchBackup = 0;
	LONG		  cchMove = 0;					// Default nothing to move
	LONG		  cchNextEOP = cchOld;			// cch to next EOP
	LONG		  cchPrevEOP = 0;				// cch back to previous EOP
	LONG		  cpFR;							//  between PF runs
	LONG 		  cpSave = GetCp();
	LONG		  cpFormatMin = cpSave;			// Used for notifications
	LONG		  cpFormat = cpSave;			// Will add cchOld, maybe cchMove
	BOOL		  fParaDirChange = FALSE;
	CTxtEdit *	  ped = GetPed();
	IAntiEvent *  paeCF = NULL;
	IAntiEvent *  paePF = NULL;
	CNotifyMgr *  pnm;
	CObjectMgr *  pobjmgr;
	CFreezeDisplay fd(ped->_pdp);				// freeze until itemization is done

 	_TEST_INVARIANT_

	LONG cchEnd = GetTextLength() - GetCp();
	if(cchOld < 0 || cchOld > cchEnd)
		cchOld = cchEnd;

  	if(IsRich() && cchOld == cchEnd)			// Attempting to delete up
	{											//  thru final EOP
		cchEndEOP = (ped->fUseCRLF())			// Calc cch of final EOP
				  ? CCH_EOD_10 : CCH_EOD_20;

		if(cchEndEOP <= cchOld)					// Don't delete it unless
			cchOld -= cchEndEOP;				//  converting from 2.0
		if(_rpPF.IsValid())
		{
			_rpPF.AdjustBackward();				// If previous para is a
			if(GetPF()->InTable())				//  table row, don't delete
				cchEndEOP = 0;					//  final para formatting
		}										
	}
	else if(_rpPF.IsValid())					// If PARAFORMATs are enabled,
	{
		_rpPF.AdjustForward();
		if (cchOld)			
		{											//  get tp and rp at end of
			CFormatRunPtr rp(_rpPF);				//  range. Need bounding para
			CTxtPtr 	  tp(_rpTX);				//  counts to save valid PF
			BOOL		  fIsAtBOP;					//  for undo

			tp.AdvanceCp(cchOld);
			rp.AdvanceCp(cchOld);

			cch = 0;
			if(tp.IsAfterEOP())						// Range ends with an EOP:
			{										//  get EOP length by
				cch = -tp.BackupCpCRLF();			//  backing up over it
				tp.AdvanceCp(cch);					// Advance past EOP
			}
			cchNextEOP = tp.FindEOP(tomForward);	// Get cch up to next EOP

			fIsAtBOP = !GetCp() || _rpTX.IsAfterEOP();
			if (!fIsAtBOP && cch == cchOld) 		// Deleting EOP alone before
			{										// new PARAFORMAT run start
													// in para with more than EOP
				//bug fix #4978
				if (!(dwFlags & RR_NO_EOR_CHECK) &&
					(ped->GetParaFormat(rp.GetFormat())->_wEffects |
					 ped->GetParaFormat(_rpPF.GetFormat())->_wEffects) & PFE_TABLE)
					return 0;
					
				if (!rp.GetIch())						
				{
					cchMove = cchNextEOP;				// Need to move chars up to
					cpFormat += cchMove;				//  end of next para for
				}
			}
			
			cchNextEOP += cchOld;					// Count from GetCp() to EOP
				
			tp.SetCp(GetCp());						// Back to this ptr's _cp
			if(!fIsAtBOP)
				cchPrevEOP = tp.FindEOP(tomBackward);// Get cch to start of para

			// If deleting from within one format run up to or into another, set
			// up to move last para in starting format run into the run following
			// the deleted text
			LONG iPF1 =    rp.GetFormat();
			LONG iPF2 = _rpPF.GetFormat();
			if(iPF1 != iPF2)						// Change of format during
			{										//  deleted text not starting
				if(!fIsAtBOP && !cchMove)			//  at BOP
				{									
					cchMove = cchPrevEOP;			// Get cch to start of para
					cpFormatMin += cchMove;			//  in this ptr's run for
				}									//  moving into rp's run

				if ((ped->GetParaFormat(iPF1)->_wEffects ^
					 ped->GetParaFormat(iPF2)->_wEffects) & PFE_RTLPARA)
				{
					fParaDirChange = TRUE;			// Note that para direction
					Assert(ped->IsBiDi());			//  changed
				}									
			}
		}
		else if (((ped->GetParaFormat(_rpPF.GetFormat())->_wEffects) & PFE_TABLE) && _rpTX.IsAtEOP() &&
			!(dwFlags & RR_NO_EOR_CHECK) /*bug fix #5752*/)
		{
			// bug fix #5669
			// Don't allow pasting at end of row
			return 0;
		}
	}	
	
	Assert(cchNew >= 0 && cchOld >= 0);
	if(!(cchNew + cchOld))						// Nothing to do (note: all
	{											//  these cch's are >= 0)
		if(pcchMove)
			*pcchMove = 0;
		return 0;
	}						

	// Handle pre-replace range notifications.  This method is very
	// useful for delayed rendering of data copied to the clipboard.
	pnm = ped->GetNotifyMgr();
	if(pnm)
	{
		pnm->NotifyPreReplaceRange((ITxNotify *)this, cpSave, cchOld,
			cchNew, cpFormatMin, cpFormat + cchOld);
	}

	if(iFormat >= 0)
		Check_rpCF();

	// Get rid of objects first.  This let's us guarantee that when we
	// insert the objects as part of an undo, the objects themselves are
	// restored _after_ their corresponding WCH_EMBEDDINGs have been
	// added to the backing store.

	if(GetObjectCount())
	{
		pobjmgr = ped->GetObjectMgr();
		Assert(pobjmgr);
		pobjmgr->ReplaceRange(cpSave, cchOld, publdr);
	}

	// If BiDi doc, expand the range to cover the boundaries that guarantee
	// the valid state of the BiDi level so we can undo it properly. (wchao)
	if(ped->IsBiDi())
	{
		cchBackup = ExpandRangeFormatting (cchOld + cchEndEOP,
										fParaDirChange ? cchMove : 0, cchAdvance);
		Assert (cchBackup >= 0);
	}

	// The anti-events used below are a bit tricky (paeCF && paePF).
	// Essentially, this call, CRchTxtPtr::ReplaceRange generates one
	// 'combo' anti-event composed of up to two formatting AE's plus
	// the text anti-event.  These anti-events are combined together
	// to prevent ordering problems during undo/redo.
	cpFR = ReplaceRangeFormatting(cchOld + cchEndEOP, cchNew + cchEndEOP,
						iFormat, publdr, &paeCF, &paePF, cchMove, cchPrevEOP,
						cchNextEOP, cchBackup, cchAdvance);
	if(cchEndEOP)
	{
		// If we added in the EOP we need to back up by the EOP so
		// that the invariants don't get annoyed and the richtext object
		// doesn't get out of sync.
		_rpCF.AdvanceCp(-cchEndEOP);
		_rpPF.AdvanceCp(-cchEndEOP);
	}
			
	if(cpFR < 0)
	{
		Tracef(TRCSEVERR, "ReplaceRangeFormatting(%ld, %ld, %ld) failed", GetCp(), cchOld, cchNew);
		cch = 0;
		goto Exit;
	}

	// As noted above in the call to ReplaceRangeFormatting, the anti-events
	// paeCF and paePF, if non-NULL, were generated by ReplaceRangeFormatting.
	// In order to solve ordering problems, the anti-event generated by this
	// method is actually a combo anti-event of text && formatting AE's.
	cch = _rpTX.ReplaceRange(cchOld, cchNew, pch, publdr, paeCF, paePF);
	if(cch != cchNew)
	{
		Tracef(TRCSEVERR, "_rpTX.ReplaceRange(%ld, %ld, ...) failed", cchOld, cchNew);

#ifndef NODUMPFORMATRUNS
		// Boy, out of memory or something bad.  Dump our formatting and hope
		// for the best.
		//
		// FUTURE: (alexgo) degrade more gracefully than losing formatting
		// info.

		// Notify every interested party that they should dump their formatting
		if(pnm)
			pnm->NotifyPreReplaceRange(NULL, CONVERT_TO_PLAIN, 0, 0, 0, 0);

		// Tell document to dump its format runs
		ped->GetTxtStory()->DeleteFormatRuns();
#endif
		goto Exit;
	}
	AssertSz(!_rpPF.IsValid() || _rpPF.GetIch() || !GetCp() || _rpTX.IsAfterEOP(),
		"CRchTxtPtr::ReplaceRange: EOP not at end of PF run");
			
	// BUGBUG!! (alexgo) doesn't handle correctly the case where things fail
	// (due to out of memory or whatever).  See also notes in CTxtPtr::HandleReplaceRange
	// Undo.  The assert below is therefore somewhat bogus, but if it fires,
	// then our floating ranges are going to be in trouble until we fix
	// up the logic here.
	Assert(cch == cchNew);

Exit:

#ifdef DEBUG
	// Test invariant again before calling out to replace range notification.
	// In this way, we can catch bugs earlier. The invariant has its own
	// scope for convenience.
	if( 1 )
	{
		_TEST_INVARIANT_
	}
#endif

	if (ped->IsBiDi() && cpSave <= (LONG) ped->GetCpFirstStrong()
		&& ((cchOld != 0) || (cch != 0)))
	{
		// Remember whether formatting is valid before we set context direction
		BOOL fCFValidBeforeSetContextDirection = _rpCF.IsValid();
		
		// Need to check the direction of the control if the input characters
		// control the direction.
		ped->SetContextDirection();

		// Did SetContextDirection make the formatting valid?
		if (!fCFValidBeforeSetContextDirection && _rpCF.IsValid())
		{
			// Our invariant is that cps should be equal if formatting is valid
			// so make it so!
			_rpCF.BindToCp(GetCp());
		}
	}

	if(pnm)
	{
		pnm->NotifyPostReplaceRange((ITxNotify *)this, cpSave, cchOld, cch,
			cpFormatMin, cpFormat + cchOld);
	}

	ped->GetCallMgr()->SetChangeEvent(CN_TEXTCHANGED);

	if(pcchMove)						// Only return non0 cchMove if para
	{									//  direction changed, i.e., it's
		*pcchMove = fParaDirChange		//  a "BOOL" with a useful value,
				  ? cchMove : 0;		//  namely the count of chars with
	}									//  changed direction

	if (ped->IsComplexScript())
	{
		if (dwFlags & RR_ITMZ_NONE || (ped->IsStreaming() && (!pch || *pch != WCH_EMBEDDING)))
			ped->_fItemizePending = TRUE;
		else
			ItemizeReplaceRange(cchNew, fParaDirChange? cchMove : 0, publdr);
	}
	return cch;
}

/*
 *	CRchTxtPtr::InitRunPtrs()
 *
 *	@mfunc
 *		Initialize Run Ptrs of this rich-text ptr to correspond to
 *		document given by ped and to cp given by cp.
 */
void CRchTxtPtr::InitRunPtrs()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::InitRunPtrs");
	AssertSz(GetPed(), "RTP::InitRunPtrs: illegal GetPed()");

	LONG cp = GetCp();
	CTxtStory *pStory = GetPed()->GetTxtStory();// If there's RichData,
	if(pStory->_pCFRuns)						//  initialize format-run ptrs
	{
		_rpCF.SetRunArray((CRunArray *)pStory->_pCFRuns);
		_rpCF.BindToCp(cp);
	}
	if(IsRich() && pStory->_pPFRuns)
	{
		_rpPF.SetRunArray((CRunArray *)pStory->_pPFRuns);
		_rpPF.BindToCp(cp);
	}
}

/*
 *	CRchTxtPtr::SetRunPtrs(cp, cpFrom)
 *
 *	@mfunc set Run Ptrs of this rich-text ptr to correspond to cp
 *
 *	@rdesc
 *			TRUE unless cp is outside of doc (in which case RunPtrs are
 *			set to nearest document end).
 */
void CRchTxtPtr::SetRunPtrs(
	LONG cp,				// @parm character position to move RunPtrs to
	LONG cpFrom)			// @parm cp to start with
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::SetRunPtrs");

	if(cpFrom && 2*cp >= cpFrom)
	{
		_rpCF.AdvanceCp(cp - cpFrom);
		_rpPF.AdvanceCp(cp - cpFrom);
	}
	else
	{
		_rpCF.BindToCp(cp);
		_rpPF.BindToCp(cp);
	}
}

/*
 *	CRchTxtPtr::ExpandRangeFormatting(cchRange,	cchMove, cchAdvance, fSavePara)
 *
 *	@rdesc
 *		In BiDi scenario, it's possible that updating a character affects the level of
 *		the others. Such case should only happen when number being involved.
 *
 *		Example: (AN)"11:30" changing '3' to 'x' will change the level of colon from 2 to 1.
 *
 */
LONG CRchTxtPtr::ExpandRangeFormatting(
	LONG		cchRange,		// in: original length
	LONG		cchMove,		// in: number of chars moved after the replacement
	LONG&		cchAdvance)		// out: the extra chars added to the range after expanding
{
	LONG		cchBackup = 0;
	
	cchAdvance = 0;

	if (_rpCF.IsValid())
	{
   		CTxtPtr		tp(_rpTX);

		if (!IsRich())
		{
			cchBackup = -tp.FindEOP(tomBackward);
			tp.AdvanceCp(cchBackup + cchRange);
			cchAdvance = tp.FindEOP(tomForward);
		}
		else
		{
			CFormatRunPtr	rp(_rpCF);
			LONG			cp = GetCp();
	
			if (cchMove < 0)
			{
				// <cchMove> number of text to be moved down to the next paragraph
				cchBackup = -cchMove;
			}
			else if (cchMove > 0)
			{
				// <cchMove> number of text to be moved up to the previous paragraph
				cchAdvance = cchMove;
			}

			
			// Advancing/Backing up 2 adjacent runs seems to be sufficient for now.

			if (cchBackup == 0)
			{
				rp.AdjustBackward();
				cchBackup += rp.GetIch();
				if (rp.PrevRun())
					cchBackup += rp.GetCchLeft();
				rp.AdvanceCp(cchBackup);
			}

			// move the run pointer to the end of range
			rp.AdvanceCp(cchRange);
			tp.SetCp(cp + cchRange);
			if (cchAdvance == 0 && !tp.IsAtEOP())
			{
				rp.AdjustForward();
				cchAdvance += rp.GetCchLeft();
				if (rp.NextRun())
					cchAdvance += rp.GetCchLeft();
			}
		}
	}
	return cchBackup;
}


/*
 *	CRchTxtPtr::ItemizeReplaceRange(cchUpdate, cchMove, publdr, fUnicodeBidi)
 *
 *	@mfunc
 *		Find out the exact range to be itemized after calling :ReplaceRange
 *
 *	@rdesc
 *		result from ItemizeRuns.
 *		Guarantee *this* pointer wont move.
 */
BOOL CRchTxtPtr::ItemizeReplaceRange(
	LONG			cchUpdate,
	LONG			cchMove,		// Count of chars moved after replacing
	IUndoBuilder*	publdr,			//  (they need reitemizing)
	BOOL			fUnicodeBidi)
{
	BOOL	fr = FALSE;

	if (GetPed()->IsComplexScript())
	{
		Assert (cchUpdate >= 0);    // the range after ReplaceRange must be degenerate

		CTxtPtr tp(_rpTX);
		LONG    cp = GetCp();
		LONG    cpStart, cpEnd;
		BOOL    fNonUnicodeBidiRecurse = FALSE;
		BOOL	fUseCtxLevel = FALSE;


		tp.AdvanceCp(-cchUpdate);


		if (cchUpdate > 0 && GetPed()->IsRich() && fUnicodeBidi)
		{
			cpStart = cpEnd = cp;
			cpStart -= cchUpdate;

			if (GetPed()->IsBiDi())
			{
				// RAID bug 7094 : We wnat to use the IP to set the context for 
				// incoming text.
				// fUseCtxLevel = TRUE;

				// Recurse with non-BiDi, so the run preceding/succeeding this chunk get updated
				fNonUnicodeBidiRecurse = TRUE;
			}
		}
		else
		{
			tp.FindWhiteSpaceBound(cchUpdate, cpStart, cpEnd,
								!GetPed()->IsRich() ? FWS_BOUNDTOPARA : 0);
		}


		if (cchMove < 0)
		{
			// <cchMove> number of text -before- the replaced range
			// moves down to the next paragraph.
			cpStart = max(cp - cchUpdate + cchMove, 0);
		}
		else if (cchMove > 0)
		{
			// <cchMove> number of text -after- the replaced range
			// moves up to the previous paragraph.
			cpEnd = min(cp + cchMove, GetPed()->GetTextLength());
		}

		{
			CTxtRange	rg(*this, 0);

			rg.Set(cpEnd, cpEnd - cpStart);
	
			fr = rg.ItemizeRuns(publdr, fUnicodeBidi, fUseCtxLevel);

			// set pointer back to original cp
	
			// We cant use copy operator here since itemization changes format run.
			// It would cause invariant failure in _rpCF.
			cp -= rg.GetCp();
			_rpCF = rg._rpCF;
			_rpCF.AdvanceCp(cp);
	
			// ItemizeRuns invalidates rg._rpPF so that the paraformat run becomes valid
			// and we need to advance it to the current cp.
			_rpPF = rg._rpPF;
			_rpPF.AdvanceCp(cp);

			// Perf note: We dont want the range to be around when we recurse
			// since a range is a notification sink.
		}

		// Run itemization to the same range, this time forces it to be non-Bidi.
		if (fr && fNonUnicodeBidiRecurse)
			fr = ItemizeReplaceRange(cchUpdate, 0, publdr, FALSE);
	}
	return fr;
}


/*
 *	CRchTxtPtr::ReplaceRangeFormatting(cchOld, cchNew, iFormat, publdr,
 *									   ppaeCF, ppaePF, cchMove)
 *	@mfunc
 *		replace character and paragraph formatting at this text pointer
 *		using CCharFormat with index iFormat
 *	
 *	@rdesc
 *		count of new characters added
 *	
 *	@devnote
 *		moves _rpCF and _rpPF to end of replaced text
 *		moves format run arrays
 *		CCharFormat for iFormat is fully configured, i.e., no NINCHes
 */
LONG CRchTxtPtr::ReplaceRangeFormatting(
	LONG		cchOld,		//@parm length of range to replace
	LONG		cchNew,		//@parm length of replacement text
	LONG		iFormat,	//@parm Char format to use
	IUndoBuilder *publdr,	//@parm UndoBuilder to receive antievents
	IAntiEvent **ppaeCF,	//@parm where to return 'extra' CF anti-events
	IAntiEvent **ppaePF,	//@parm where to return extra PF anti-events
	LONG		cchMove,	//@parm cch to move between PF runs
	LONG		cchPrevEOP,	//@parm cch from _cp back to prev EOP
	LONG		cchNextEOP,	//@parm cch from _cp up to next EOP
	LONG		cchSaveBefore,
	LONG		cchSaveAfter)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::ReplaceRangeFormatting");

	LONG				cp = GetCp();				
	ICharFormatCache *	pcfc = GetCharFormatCache();
	IParaFormatCache *	ppfc = GetParaFormatCache();
	LONG iRunMerge	= 0;

	AssertSz(cchOld >= 0,
		"CRchTxtPtr::ReplaceRangeFormatting: Illegal cchOld");

	if(_rpCF.IsValid())
	{
		iRunMerge = _rpCF._iRun;
		if(iRunMerge > 0)
			iRunMerge--;

		Assert (cchSaveBefore >= 0 && cchSaveAfter >= 0);
		if(cchOld + cchSaveAfter + cchSaveBefore > 0)
		{										// add the soon-to-be deleted
			if(publdr)							// formats to the undo list
			{
				// Include previous cchSaveBefore chars
				_rpCF.AdvanceCp(-cchSaveBefore);
				*ppaeCF = gAEDispenser.CreateReplaceFormattingAE(
							GetPed(), _rpCF, cchSaveAfter + cchOld + cchSaveBefore, pcfc, CharFormat);
				// Restore _rpCF (we just want to save value not delete it)
				_rpCF.AdvanceCp(cchSaveBefore);
			}
			if(cchOld)							// Delete/modify CF runs <-->
				_rpCF.Delete(cchOld, pcfc, 0);	//  to cchOld chars
		}
		// If we deleted all of text in story, don't bother adding a new
		// run.	Else insert/modify CF runs corresponding to cchNew chars
		//
		// In a plain-text control, there is no final EOP; hence the test
		// for equality.
		if(cchNew > 1 || cchNew && cchOld <= GetTextLength())
			_rpCF.InsertFormat(cchNew, iFormat, pcfc);

		if((cchOld || cchNew) && _rpCF.IsValid())// Deleting all text
		{										//  invalidates _rpCF
			_rpCF.AdjustForward();
			_rpCF.MergeRuns(iRunMerge, pcfc);
			_rpCF.BindToCp(cp + cchNew);
		}
	}

	if(_rpPF.IsValid())
	{
		_rpPF.AdjustForward();					// Be absolutely sure that
												//  PF runs end with EOPs
		iRunMerge = _rpPF._iRun;
		if(iRunMerge > 0)
			iRunMerge--;

		if(cchOld)								// Delete cchOld from PF runs
		{										// add the soon-to-be deleted
			if(publdr)							// formats to the undo list
			{
				CFormatRunPtr rp(_rpPF);

				rp.AdvanceCp(cchPrevEOP);
				*ppaePF = gAEDispenser.CreateReplaceFormattingAE(GetPed(),
								rp, cchNextEOP - cchPrevEOP, ppfc, ParaFormat);
			}
		    _rpPF.Delete(cchOld, ppfc, cchMove);
		}

		if(_rpPF.IsValid())						// Deleting all text
		{										//  invalidates _rpPF
			_rpPF.AdjustForward();
			_rpPF.GetRun(0)->_cch += cchNew;	// Insert cchNew into current
			_rpPF._ich	+= cchNew;				//  PF run
			if(cchOld || cchNew)
			{
				_rpPF.MergeRuns(iRunMerge, ppfc);
				_rpPF.BindToCp(cp + cchNew);
			}
		}
	}
	return cchNew;
}

/*
 *	CRchTxtPtr::ExtendFormattingCRLF()
 *	
 *	@mfunc
 *		Use the same CCharFormat and CParaFormat indices for the EOP at
 *		this text ptr as those immediately preceding it.
 *
 *	@devnote
 *		Leaves this text ptr's format ptrs at run you get from AdjustBackward
 *		since this run ends up including the new text.
 */	
void CRchTxtPtr::ExtendFormattingCRLF()
{
	LONG		cch = GetTextLength() - GetPed()->GetAdjustedTextLength();
	CNotifyMgr *pnm = GetPed()->GetNotifyMgr();

	_rpCF.AdjustFormatting(cch, GetCharFormatCache());
	if(_rpPF.IsValid())
	{
		_rpPF.AdjustBackward();
		if(!InTable())
			_rpPF.AdjustFormatting(cch, GetParaFormatCache());
		_rpPF.AdjustForward();
	}

	if(pnm)
	{
		// We assume that Cch is positive (or zero) here
		Assert(cch >= 0);
		pnm->NotifyPostReplaceRange((ITxNotify *)this, CP_INFINITE, 0, 0,
				GetCp(), GetCp() + cch);
	}
}

/*
 *	CRchTxtPtr::IsRich()
 *	
 *	@mfunc
 *		Determine whether rich-text operation is operable
 *	
 *	@rdesc
 *		TRUE if associated CTxtEdit::_fRich = 1, i.e., control is allowed
 *		to be rich.
 */
BOOL CRchTxtPtr::IsRich()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::IsRich");

	return GetPed()->IsRich();
}

/*
 *	CRchTxtPtr::Check_rpCF()
 *	
 *	@mfunc
 *		enable _rpCF if it's not already enabled
 *	
 *	@rdesc
 *		TRUE if _rpCF is enabled
 */
BOOL CRchTxtPtr::Check_rpCF()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::Check_rpCF");

	if(_rpCF.IsValid())
		return TRUE;

	if(!_rpCF.InitRuns (GetCp(), GetTextLength(),
				&(GetPed()->GetTxtStory()->_pCFRuns)))
	{
		return FALSE;
	}

	CNotifyMgr *pnm = GetPed()->GetNotifyMgr();	// For notifying of changes
	if(pnm)
		pnm->NotifyPostReplaceRange(	 		// Notify interested parties
				(ITxNotify *)this, CP_INFINITE,	//  that
				0, 0, CP_INFINITE, CP_INFINITE);

	return TRUE;
}

/*
 *	CRchTxtPtr::Check_rpPF()
 *	
 *	@mfunc
 *		enable _rpPF if it's not already enabled
 *	
 *	@rdesc
 *		TRUE if _rpPF is enabled
 */
BOOL CRchTxtPtr::Check_rpPF()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::Check_rpPF");

	if(_rpPF.IsValid())
		return TRUE;

	if(!IsRich())
		return FALSE;

	if(!_rpPF.InitRuns (GetCp(), GetTextLength(),
				&(GetPed()->GetTxtStory()->_pPFRuns)))
	{
		return FALSE;
	}

	if (IsParaRTL())
		_rpPF.GetRun(0)->_level._value = 1;		// Set default paragraph base level

	CNotifyMgr *pnm = GetPed()->GetNotifyMgr();	// For notifying of changes
	if(pnm)
		pnm->NotifyPostReplaceRange(	 		// Notify interested parties
				(ITxNotify *)this, CP_INFINITE,	// of the change.
				0, 0, CP_INFINITE, CP_INFINITE);

	return TRUE;
}

/*
 * CRchTxtPtr::FindWordBreak(action, cpMost)
 *
 *	@mfunc
 *		Same as CTxtPtr::FindWordBreak(), but moves the whole rich text ptr
 *
 *	@rdesc
 *		cch this rich text ptr is moved
 */
LONG CRchTxtPtr::FindWordBreak(
	INT		action,		//@parm Kind of word break to find
	LONG	cpMost)		//@parm Limiting character position

{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::FindWordBreak");

	LONG cch = _rpTX.FindWordBreak(action, cpMost);
	_rpCF.AdvanceCp(cch);
	_rpPF.AdvanceCp(cch);

	return cch;
}

/*
 *	CRchTxtPtr::BindToCp(dwNewCp)
 *
 *	@mfunc
 *		Set cp to new value and recalculate that new position.
 */
void CRchTxtPtr::BindToCp(
	LONG cp)			// @parm new cp for rich text
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::BindToCp");

	_rpTX.BindToCp(cp);				// Recalculate cp for plain text

	// Use the InitRunPtrs routine so that the run pointers will get
	// re-initialized and rebound with the correct run array.  The
	// run array formerly used (if any at all) is not necessarily valid
	// when this function is called.

	InitRunPtrs();

	// Do invariant testing at end because this fixes up the rich text
	// pointer in the face of backing store changes.
	_TEST_INVARIANT_
}

/*
 *	CRchTxtPtr::CheckFormatRuns ()
 *
 *	@mfunc
 *		Check the format runs against what's in CTxtStory.  If
 *		different, forces a rebind to <p cp>
 */
void CRchTxtPtr::CheckFormatRuns()
{
	CTxtStory *pStory = GetPed()->GetTxtStory();

	if (pStory->GetCFRuns() != (CFormatRuns *)_rpCF._pRuns ||
		pStory->GetPFRuns() != (CFormatRuns *)_rpPF._pRuns)
	{
		InitRunPtrs();
	}

	_TEST_INVARIANT_
}

/*
 *	CRchTxtPtr::ChangeCase(cch, Type, publdr)
 *	
 *	@mfunc
 *		Change case of cch chars starting at this text ptr according to Type,
 *		which has the possible values:
 *
 *		tomSentenceCase	= 0: capitalize first letter of each sentence
 *		tomLowerCase	= 1: change all letters to lower case
 *		tomUpperCase	= 2: change all letters to upper case
 *		tomTitleCase	= 3: capitalize the first letter of each word
 *		tomToggleCase	= 4: toggle the case of each letter
 *	
 *	@rdesc
 *		TRUE iff a change occurred
 *
 *	@devnote
 *		Since this routine only changes the case of characters, it has no
 *		effect on rich-text formatting.  However it is part of the CRchTxtPtr
 *		class in order to notify the display of changes.  CTxtRanges are also
 *		notified just in case the text blocks are modified.
 */
BOOL CRchTxtPtr::ChangeCase (
	LONG		  cch,			//@parm # chars to change case for
	LONG		  Type,			//@parm Type of change case command
	IUndoBuilder *publdr)		//@parm UndoBuilder to receive anti-event
								//  	for any replacements
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::ChangeCase");
	_TEST_INVARIANT_

#define	BUFFERLEN	256

	LONG	cchChunk, cchFirst, cchFormat, cchGet, cchLast;
	BOOL	fAlpha, fToUpper, fUpper;			// Flags controling case change
	BOOL	fChange = FALSE;					// No change yet
	BOOL	fStart = TRUE;						// Start of Word/Sentence
	LONG	iCF;
	TCHAR *	pch;								// Ptr to walk rgCh with
	WORD *	pType;								// Ptr to walk rgType with
	WCHAR	rgCh[BUFFERLEN];					// Char buffer to work in
	WORD	rgType[BUFFERLEN];					// C1_TYPE array for rgCh

	if( GetCp() )
	{
		if( Type == tomSentenceCase )
		{
			fStart = _rpTX.IsAtBOSentence();
		}
		else if( Type == tomTitleCase )
		{
			// Check to see if we are at the beginning of
			// a word.  This is the case if the character preceeding
			// our current position is white space.
			fStart = IsWhiteSpace(GetPrevChar());
		}
	}
	while(cch > 0)								// Do 'em all (or as many as
	{											//  in story)
		cchChunk = min(BUFFERLEN, cch);			// Get next bufferful

		// FUTURE: it's too bad that we have to do all this format stuff
		// when the formatting isn't even going to change.  It would be
		// faster and simpler to use _rpTX.ReplaceRange() and just send
		// appropriate notifications.
		if(_rpCF.IsValid())						// Make sure it stays within
		{										//  current char/paraformat
			cchFormat = _rpCF.GetCchLeft();		//  runs to simplify changing
			cchChunk = min(cchChunk, cchFormat);//  text with undo
		}										
		if(_rpPF.IsValid())						
		{
			cchFormat = _rpPF.GetCchLeft();
			cchChunk = min(cchChunk, cchFormat);
		}
		cch -= cchChunk;						// Decrement the count
		cchGet = _rpTX.GetText(cchChunk, rgCh);	// Manipulate chars in buffer
		if(cchGet < cchChunk)					//  (for undo, need to use
		{										//  ReplaceRange())
			cch = 0;							// No more chars in story,
			if(!cchGet)							//  so we'll be done
				break;							// We're done already
			cchChunk = cchGet;					// Something in this chunk
		}

		W32->GetStringTypeEx(0, CT_CTYPE1, rgCh,// Find out whether chars are
						cchChunk, rgType);		//  UC, LC, or neither
		cchLast = 0;							// Default nothing to replace
		cchFirst = -1;
		for(pch = rgCh, pType = rgType;			// Process buffered chars
			cchChunk;
			cchChunk--, pch++, pType++)
		{
			fAlpha = *pType & (C1_UPPER | C1_LOWER); // Nonzero if UC or LC
			fUpper = (*pType & C1_UPPER) != 0;	// TRUE if UC
			fToUpper = fStart ? TRUE : fUpper;	// capitalize first letter of a
												// sentence
			switch(Type)
			{									// Decide whether to change
			case tomLowerCase:					//  case and determine start
				fToUpper = FALSE;				//  of word/sentence for title
				break;							//  and sentence cases

			case tomUpperCase:
				fToUpper = TRUE;
				break;

			case tomToggleCase:
				fToUpper = !fUpper;
				break;

			case tomSentenceCase:
				if(*pch == TEXT('.'))			// If sentence terminator,
					fStart = TRUE;				//  capitalize next alpha
				if(fAlpha)						// If this char is alpha, next
					fStart = FALSE;				//  char can't start a
				break;							//  sentence

			case tomTitleCase:					// If this char is alpha, next
				fStart = (fAlpha == 0);			//  char can't start a word
				break;
			default:
				return FALSE;
			}

			if(fAlpha && (fToUpper ^ fUpper))	// Only change case if it
			{									//  makes a difference (saves
				if(fToUpper)					//  on system calls and undos)
					CharUpperBuff(pch, 1);
				else
					CharLowerBuff(pch, 1);

				fChange = TRUE;					// Return value: change made
				if( cchFirst == -1 )			// Save cch of unchanged
					cchFirst = cchGet-cchChunk;	//  leading string
				cchLast = cchChunk - 1;			// Save cch of unchanged
			}									//  trailing string
		}
		if( cchFirst == -1 )
		{
			Assert(cchLast == 0);
			cchFirst = cchGet;
		}

		Advance(cchFirst);						// Skip unchanged leading
		cchGet -= cchFirst + cchLast;			//  string. cchGet = cch of
		_rpCF.AdjustForward();					//  changed span. Adjust in
												//  case cchFirst = 0
		iCF = _rpCF.GetFormat();
		GetCharFormatCache()->AddRef(iCF);
		ReplaceRange(cchGet, cchGet, rgCh + cchFirst, publdr, iCF);
		ReleaseFormats(iCF, -1);
		Advance(cchLast);						// Skip unchanged trailing
	}											//  string
	return fChange;
}

// The following defines a mask for Units implemented by UnitCounter()
#define IMPL ((1 << tomCharacter)  + (1 << tomWord) + (1 << tomSentence) + \
			  (1 << tomParagraph)  + (1 << tomLine) + (1 << tomStory) +	\
			  (1 << tomCharFormat) + (1 << tomParaFormat) + (1 << tomObject))

/*
 *	CRchTxtPtr::UnitCounter (Unit, &cUnit, cchMax)
 *
 *	@mfunc
 *		Helper function to count chars in <p cUnit> Units defined by <p Unit>
 *		<p cUnit> is a signed count.  If it extends beyond either end of the
 *		story, count up to that end and update <p cUnit> accordingly.  If
 *		<p cchMax> is nonzero, stop counting when the count exceeds <p cchMax>
 *		in magnitude.
 *
 *	@rdesc
 *		If unit is implemented, return cch corresponding to the units counted
 *		(up to a maximum magnitude of <p cchMax>) and update cUnit;
 *		else return tomForward to signal unit not implemented and cUnit = 0.
 *		If unit is implemented but unavailable, e.g., tomObject with no
 *		embedded objects, return tomBackward.
 *
 *	@devnote
 *		This is the basic engine used by the TOM CTxtRange::Move() and Index()
 *		methods.
 */
LONG CRchTxtPtr::UnitCounter (
	LONG	Unit,				//@parm Type of unit to count
	LONG &	cUnit,				//@parm Count of units to count chars for
	LONG	cchMax)				//@parm Maximum character count
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CRchTxtPtr::UnitCounter");

	LONG	action;				// Gives direction and tomWord commands
	LONG	cch;				// Collects cch counted
	LONG	cchText = GetTextLength();
	LONG	cp = GetCp();
	LONG	iDir = cUnit > 0 ? 1 : -1;
	LONG	j;					// For-loop index
	CDisplay *pdp;				// Used for tomLine case

	if(!cUnit)									// Nothing to count
	{
		return ((DWORD)Unit > tomObject || !((IMPL >> Unit) & 1))
			? tomForward : 0;					// Indicate Unit not
	}											//  implemented
	if(cchMax <= 0)
		cchMax = tomForward;					// No cch limit

	switch(Unit)
	{
	case tomCharacter:							// Smallest Unit
		cp += cUnit;							// Requested new cp
		ValidateCp(cp);							// Make sure it's OK
		cch = cUnit = cp - GetCp();				// How many cch, cUnits
		break;									//  actually moved

	case tomStory:								// Largest Unit
		cch = (cUnit > 0) ? cchText - cp : -cp;	// cch to start of story
		cUnit = cch ? iDir : 0;					// If already at end/start,
		break;									//  of story, no count

	case tomCharFormat:							// Constant CHARFORMAT
		cch = _rpCF.CountRuns(cUnit, cchMax, cp, cchText);
		break;

	case tomParaFormat:							// Constant PARAFORMAT
		cch = _rpPF.CountRuns(cUnit, cchMax, cp, cchText);
		break;

	case tomObject:
		if(!GetObjectCount())					// No objects: can't move, so
		{
			cUnit = 0;							//  set cUnit = 0 and
			return tomBackward;					//  signal Unit unavailable
		}
		cch = GetPed()->_pobjmgr->CountObjects(cUnit, GetCp());
		break;

	case tomLine:
		pdp = GetPed()->_pdp;
		if(pdp)									// If this story has a display
		{										//  use a CLinePtr
			CLinePtr rp(pdp);
			pdp->WaitForRecalc(cp, -1);
			rp.RpSetCp(cp, FALSE);
			cch = rp.CountRuns(cUnit, cchMax, cp, cchText);
			break;
		}										// Else fall thru to treat as
												//  tomPara
	default:									// tp dependent cases
	  {											// Block to contain tp() which
		CTxtPtr tp(_rpTX);						//  takes time to construct

		if (cUnit < 0)							// Counting backward
		{
			action = (Unit == tomWord)
				? WB_MOVEWORDLEFT : tomBackward;
		}
		else									// Counting forward
		{
			action = (Unit == tomWord)
				? WB_MOVEWORDRIGHT : tomForward;
		}
	
		for (cch = 0, j = cUnit; j && abs(cch) < cchMax; j -= iDir)
		{
			cp = tp.GetCp();					// Save starting cp for
			switch (Unit)						//  calculating cch for this
			{									//  Unit
			case tomWord:
				tp.FindWordBreak(action);
				break;
	
			case tomSentence:
				tp.FindBOSentence(action);
				break;
		
			case tomLine:						// Story has no line array:
			case tomParagraph:					//  treat as tomParagraph
				tp.FindEOP(action);
				break;
		
			default:
				cUnit = 0;
				return tomForward;				// Return error
			}
			if(tp.GetCp() - cp == 0)			// No count:
				break;							//  don't decrement cUnit
			cch += tp.GetCp() - cp;
		}
		cUnit -= j;								// Discount any runs not
	  }											//  counted if |cch| >= cchMax
	}

	if(abs(cch) > cchMax)						// Keep cch within requested
	{											//  limit
		cch = cch > 0 ? cchMax : -cchMax;
		if(Unit == tomCharacter)
			cUnit = cch;
	}		

	Advance(cch);								// Move to new position
	return cch;									// Total cch counted
}

/*
 *	CRchTxtPtr::GetParaNumber ()
 *
 *	@mfunc
 *		Return number of current paragraph in a numbered list. This is
 *		0 if the current paragraph isn't part of a list. It's 1 if it's
 *		the first paragraph in a list, 2 if it's the second, etc.
 *
 *	@rdesc
 *		paragraph number active at this rich text ptr
 *
 *	@devnote
 *		When the display is calc'd from the beginning or recalc'd from
 *		a previous valid position, the list number can be determined from
 *		the display.  But if CDisplayPrinter::FormatRange() works without
 *		a display, it needs to know the number.  This routine can be so used
 *		for this purpose and for debugging the display choices.
 */
LONG CRchTxtPtr::GetParaNumber() const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::GetParaNumber");

	LONG		 ch;
	LONG		 cPara = 0;
	LONG		 n;
	const CParaFormat *pPF, *pPFLast = NULL;
	CRchTxtPtr	 rtp(*this);

	while(1)
	{
		pPF = rtp.GetPF();
		// CParaFormat::UpdateNumber(2, pPFLast) returns:
		//		0 -- not a numbered list
		//		1 -- new numbered list or pPFLast = NULL
		//		2 -- list number suppressed
		//		3 -- different number in same list
		n = pPF->UpdateNumber(2, pPFLast);
		if(n == 0 || n == 1 && pPFLast && cPara)
			break;
		ch = rtp.GetPrevChar();
		if((!ch || IsASCIIEOP(ch) && ch != VT) && n != 2)
			cPara++;
		if(!ch)
			break;
		rtp._rpPF.AdvanceCp(rtp._rpTX.FindEOP(tomBackward));	
		pPFLast = pPF;						// Don't need to update _rpCF
	}										//  for this calculation
	return cPara;
}

/*
 *	Notes on RichEdit 1.0 mode:
 *
 *	CF_UNICODETEXT should not be used in RichEdit 1.0 mode.  \uN should use
 *	the alternative.
 *
 *	CleanseAndReplaceRange() and the RTF reader need to ensure that any
 *	Unicode chars entered belong to a CharSet and stamp it accordingly.
 *	If no CharSet exists for the character, then blank should be used.
 */

/*
 *	CRchTxtPtr::GetCachFromCch(cch)
 *
 *	@mfunc
 *		Return count of A chars corresponding to cch W chars starting at
 *		this text ptr.  On first call start with this text ptr at cp = 0.
 *
 *	@rdesc
 *		Count of A chars between this text ptr and cp
 *
 *	@comm
 *		The algorithm assumes that for a DBCS charset any character
 *		above 128 has two bytes, except for the halfwidth KataKana,
 *		which are single bytes in ShiftJis.
 */
LONG CRchTxtPtr::GetCachFromCch(
	LONG cch)		//@parm Count of chars to check
{
	BYTE		 bCharSet;
	LONG		 cach = 0;				// No ach counted yet
	LONG		 cch1;
	LONG		 cchRun;				// CF run count
	LONG		 cchValid;				// Text run count
	WCHAR		 ch;
	const WCHAR *pch;					// Ptr to text run
	const CCharFormat *pCF;

	while(cch > 0)
	{
		cchRun = _rpCF.IsValid()
			   ? _rpCF.GetCchLeft()
			   : GetTextLength() - GetCp();
		if(!cchRun)
			break;						// No more text
		pCF		 = GetCF();
		bCharSet = pCF->_bCharSet;
		if (!IsFECharSet(bCharSet) ||
			(pCF->_dwEffects & CFE_RUNISDBCS))
		{
			cchRun = min(cchRun, cch);
			cach  += cchRun;			// SBCS run or DBCS stored as
			cch   -= cchRun;			//  one byte per char
			Advance(cchRun);
			continue;
		}
		pch = GetPch(cchValid);
		Assert(pch);
		cchValid = min(cchValid, cchRun);
		for(cch1 = 0; cch > 0 && cchValid--; cch1++)
		{
			cch--;
			ch = *pch++;
			if(ch >= 128 && ch != WCH_EMBEDDING &&
				(bCharSet != SHIFTJIS_CHARSET || !IN_RANGE(0xFF61, ch, 0xFF9F)))
			{
				cach++;
			}
		}
		cach += cch1;
		Advance(cch1);
	}
	return cach;
}

/*
 *	CRchTxtPtr::GetCchFromCach(cach)
 *
 *	@mfunc
 *		Return count of W chars corresponding to cach A chars starting at this
 *		text ptr. On first call start with this text ptr at cp = 0.
 *
 *	@rdesc
 *		Count of W chars corresponding to cach A chars starting at this tp.
 *
 *	@comm
 *		The algorithm assumes that for a DBCS charset any character
 *		above 128 has two bytes, except for the halfwidth KataKana,
 *		which are single bytes in ShiftJis.
 */
LONG CRchTxtPtr::GetCchFromCach(
	LONG cach)		//@parm Count of ach's starting at this text ptr
{
	BYTE		 bCharSet;
	LONG		 cch = 0;				// No ch's yet
	LONG		 cch1;
	LONG		 cchRun;				// CF run count
	LONG		 cchValid;				// Text run count
	WCHAR		 ch;
	const WCHAR *pch;					// Ptr to text run
	const CCharFormat *pCF;

	while(cach > 0)
	{
		cchRun = _rpCF.IsValid()
			   ? _rpCF.GetCchLeft()
			   : GetTextLength() - GetCp();
		if(!cchRun)
			break;						// No more text
		pCF		 = GetCF();
		bCharSet = pCF->_bCharSet;
		if (!IsFECharSet(bCharSet) ||
			(pCF->_dwEffects & CFE_RUNISDBCS))
		{
			cchRun = min(cchRun, cach);	// SBCS run or DBCS stored as
			cach -= cchRun;				//  one byte per char
			cch  += cchRun;
			Advance(cchRun);
			continue;
		}
		pch = GetPch(cchValid);
		Assert(pch);
		cchValid = min(cchValid, cchRun);
		for(cch1 = 0; cach > 0 && cchValid--; cch1++)
		{
			cach--;
			ch = *pch++;
			if(ch >= 128 && ch != WCH_EMBEDDING &&
				(bCharSet != SHIFTJIS_CHARSET || !IN_RANGE(0xFF61, ch, 0xFF9F)))
			{
				cach--;
			}
		}
		cch += cch1;
		Advance(cch1);
	}
	return cch;
}

/*
 *	CRchTxtPtr::Zombie ()
 *
 *	@mfunc
 *		Turn this object into a zombie by NULLing out its _ped member
 */
void CRchTxtPtr::Zombie ()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::Zombie");

	_rpTX.Zombie();
	_rpCF.SetToNull();
	_rpPF.SetToNull();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\render.cpp ===
/*
 *	@doc INTERNAL
 *	
 *	@module - RENDER.CPP |
 *		CRenderer class
 *	
 *	Authors:
 *		RichEdit 1.0 code: David R. Fulmer
 *		Christian Fortini (initial conversion to C++)
 *		Murray Sargent
 *
 *	Copyright (c) 1995-1998 Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_render.h"
#include "_font.h"
#include "_disp.h"
#include "_edit.h"
#include "_select.h"
#include "_objmgr.h"
#include "_coleobj.h"


// Default colors for background and text on window's host printer
const COLORREF RGB_WHITE = RGB(255, 255, 255);
const COLORREF RGB_BLACK = RGB(0, 0, 0);
const COLORREF RGB_BLUE  = RGB(0, 0, 255);

ASSERTDATA

extern const COLORREF g_Colors[];
static HBITMAP g_hbitmapSubtext = 0;
static HBITMAP g_hbitmapExpandedHeading = 0;
static HBITMAP g_hbitmapCollapsedHeading = 0;
static HBITMAP g_hbitmapEmptyHeading = 0;

void EraseTextOut(HDC hdc, const RECT *prc)
{
	::ExtTextOutA(hdc, 0, 0, ETO_OPAQUE, prc, NULL, 0, NULL);
}


HRESULT InitializeOutlineBitmaps()
{
    g_hbitmapSubtext = LoadBitmap(hinstRE, MAKEINTRESOURCE(BITMAP_ID_SUBTEXT));
    g_hbitmapExpandedHeading = LoadBitmap(hinstRE, MAKEINTRESOURCE(BITMAP_ID_EXPANDED_HEADING));
    g_hbitmapCollapsedHeading = LoadBitmap(hinstRE, MAKEINTRESOURCE(BITMAP_ID_COLLAPSED_HEADING));
    g_hbitmapEmptyHeading = LoadBitmap(hinstRE, MAKEINTRESOURCE(BITMAP_ID_EMPTY_HEADING));

    if (!g_hbitmapSubtext ||
        !g_hbitmapExpandedHeading ||
        !g_hbitmapCollapsedHeading ||
        !g_hbitmapEmptyHeading)
    {
        return E_OUTOFMEMORY;
    }
    return NOERROR;
}

void ReleaseOutlineBitmaps()
{
    if (g_hbitmapSubtext)
	{
        DeleteObject(g_hbitmapSubtext);
		g_hbitmapSubtext = 0;
	}

    if (g_hbitmapExpandedHeading)
	{
		DeleteObject(g_hbitmapExpandedHeading);
		g_hbitmapExpandedHeading = 0;
	}

    if (g_hbitmapCollapsedHeading)
	{
		DeleteObject(g_hbitmapCollapsedHeading);		
		g_hbitmapCollapsedHeading = 0;
	}

    if (g_hbitmapEmptyHeading)
	{
		DeleteObject(g_hbitmapEmptyHeading);
		g_hbitmapEmptyHeading = 0;	
	}
}


/*
 * 	IsTooSimilar(cr1, cr2)
 *
 *	@mfunc
 *		Return TRUE if the colors cr1 and cr2 are so similar that they
 *		are hard to distinguish. Used for deciding to use reverse video
 *		selection instead of system selection colors.
 *
 *	@rdesc
 *		TRUE if cr1 is too similar to cr2 to be used for selection
 *
 *	@devnote
 *		The formula below uses RGB. It might be better to use some other
 *		color representation such as hue, saturation, and luminosity
 */
BOOL IsTooSimilar(
	COLORREF cr1,		//@parm First color for comparison
	COLORREF cr2)		//@parm Second color for comparison
{
	if((cr1 | cr2) & 0xFF000000)			// One color and/or the other
		return FALSE;						//  isn't RGB, so algorithm
											//  doesn't apply
	LONG DeltaR = abs(GetRValue(cr1) - GetRValue(cr2));
	LONG DeltaG = abs(GetGValue(cr1) - GetGValue(cr2));
	LONG DeltaB = abs(GetBValue(cr1) - GetBValue(cr2));

	return DeltaR + DeltaG + DeltaB < 80;
}


CRenderer::CRenderer (const CDisplay * const pdp) :
	CMeasurer (pdp)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::CRenderer");

	Init();
}	
 
CRenderer::CRenderer (const CDisplay * const pdp, const CRchTxtPtr &rtp) :
	CMeasurer (pdp, rtp)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::CRenderer");

	Init();
}

/*
 *	CRenderer::Init()
 *
 *	@mfunc
 *		Initialize most things to zero
 */
void CRenderer::Init()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::Init");

	_fRenderer = TRUE;

	static const RECT zrect = { 0, 0, 0, 0 };
	_rcView		= zrect;
	_rcRender	= zrect;	  
	_rc			= zrect;
	_xWidthLine = 0;
	_dwFlags	= 0;
	_ptCur.x	= 0;
	_ptCur.y	= 0;

	_crCurBackground = CLR_INVALID;
	_crCurTextColor = CLR_INVALID;

	_hdc		= NULL;

	CTxtSelection *psel = GetPed()->GetSel();
	_fRenderSelection = psel && psel->GetShowSelection();
	
	// Get accelerator offset if any
	_cpAccelerator = GetPed()->GetCpAccelerator();
	_plogpalette   = NULL;
}
 

/*
 * 	CRenderer::StartRender (&rcView, &rcRender, yHeightBitmap)
 *
 *	@mfunc
 *		Prepare this renderer for rendering operations
 *
 *	@rdesc
 *		FALSE if nothing to render, TRUE otherwise	
 */
BOOL CRenderer::StartRender (
	const RECT &rcView,			//@parm View rectangle
	const RECT &rcRender,		//@parm Rectangle to render
	const LONG yHeightBitmap)	//@parm Height of bitmap for offscreen DC
{
	CTxtEdit *ped		   = GetPed();
	BOOL	  fInOurHost   = ped->fInOurHost();
	BOOL	  fTransparent = _pdp->IsTransparent();
						   
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::StartRender");

	// If this a metafile or a transparent control we better not be trying
	// to render off screen. Therefore, the bitmap height must be 0.
	AssertSz(!_pdp->IsMetafile() && !fTransparent || !yHeightBitmap,
		"CRenderer::StartRender: Metafile and request for off-screen DC");

	AssertSz(_hdc == NULL, "Calling StartRender() twice?");
	_hdc = _pdp->GetDC();

#ifdef Boustrophedon
	// Note: to make this a para effect, need to turn this property on/off
	// as new paras are encountered.  I.e., more work needed (plus need to
	// define PFE_BOUSTROPHEDON).
	//if(_pPF->_wEffects & PFE_BOUSTROPHEDON)
	{
		XFORM xform = {-1, 0, 0, 1, rcView.right, 0};
		SetGraphicsMode(_hdc, GM_ADVANCED);
		SetWorldTransform(_hdc, &xform);
	}
#endif

	// Set view and rendering rects
	_rcView   = rcView;
	_rcRender = rcRender;

	if(!fInOurHost || !_pdp->IsPrinter())
	{
		// If we are displaying to a window, or we are not in the window's
		// host, we use the colors specified by the host. For text and
		// foreground.
		_crBackground = ped->TxGetBackColor();
		_crTextColor  = ped->TxGetForeColor();
	}
	else
	{
		// When the window's host is printing, the default colors are white
		// for the background and black for the text.
		_crBackground = RGB_WHITE;
		_crTextColor  = RGB_BLACK;
	}

	::SetBkColor (_hdc, _crBackground);
	_crCurBackground = _crBackground;

	// If this isn't a metafile, we set a flag indicating whether we
	// can safely erase the background
	_fErase = !fTransparent;
	if(_pdp->IsMetafile() || !_pdp->IsMain())
	{
		// Since this isn't the main display or it is a metafile,
		// we want to ignore the logic to render selections
		_fRenderSelection = FALSE;

		// This is a metafile or a printer so clear the render rectangle 
		// and then pretend we are transparent.
		_fErase = FALSE;

		if(!fTransparent)					// If control is not transparent,
			EraseTextOut(_hdc, &rcRender);	//  clear display
	}

	// Set text alignment
	// Its much faster to draw using top/left alignment than to draw
	// using baseline alignment.
	SetTextAlign(_hdc, TA_TOP | TA_LEFT);
	SetBkMode(_hdc, TRANSPARENT);

	_fUseOffScreenDC = FALSE;			// Assume we won't use offscreen DC

	if(yHeightBitmap)
	{
		HPALETTE hpal = fInOurHost ? ped->TxGetPalette() : 
		(HPALETTE) GetCurrentObject(_hdc, OBJ_PAL);

		// Create off-screen DC for rendering
		if(!_osdc.Init(_hdc, _rcRender.right - _rcRender.left, yHeightBitmap, _crBackground))
			return FALSE;

		_osdc.SelectPalette(hpal);
		_fUseOffScreenDC = TRUE;		// We are using offscreen rendering
	}

	// For hack around ExtTextOutW OnWin9x EMF problems
	_fEnhancedMetafileDC = IsEnhancedMetafileDC(_hdc);

	return TRUE;
}

/*
 *	CRenderer::EndRender()
 *
 *	@mfunc
 *		If _fErase, erase any remaining areas between _rcRender and _rcView
 */
void CRenderer::EndRender()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::EndRender");
	AssertSz(_hdc, "CRenderer::EndRender() - No rendering DC");

	if(_fErase)
	{
		RECT rc = _rcRender;
		if(_ptCur.y < _rcRender.bottom)
		{
			rc.top = _ptCur.y;
			EraseTextOut(_hdc, &rc);
		}
	}
}

/*
 *	CRenderer::NewLine (&li)
 *
 *	@mfunc
 *		Init this CRenderer for rendering the specified line
 */
void CRenderer::NewLine (const CLine &li)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::NewLine");

	_li = li;

	Assert(GetCp() + _li._cch <= GetTextLength());

	_xWidthLine = _li._xWidth;
	_li._xWidth = 0;
	_ptCur.x = _rcView.left - _pdp->GetXScroll();
	_fSelected = _fSelectedPrev = FALSE;
}

/*
 *	CRenderer::SetUpOffScreenDC(xAdj, yAdj)
 *
 *	@mfunc
 *		Setup renderer for using an off-screen DC
 *
 *	@rdesc
 *		NULL - an error occurred<nl>
 *		~NULL - DC to save 
 */
HDC CRenderer::SetUpOffScreenDC(
	LONG&	xAdj,		//@parm Offset to x 
	LONG&	yAdj)		//@parm Offset to y 
{
	// Save render DC
	HDC		hdcSave = _hdc;
	LONG	yHeightRC = _rc.bottom - _rc.top;

	// Replace render DC with an off-screen DC
	_hdc = _osdc.GetDC();
	if(!_hdc)
	{
		// There is no off-screen renderer 

		// This better be a line marked for a one-time off-screen rendering 
		// that wasn't. Note: standard cases for this happening are a line
		// that would have been displayed is scrolled off the screen 
		// because an update of the selection.
		AssertSz(_li._bFlags & fliOffScreenOnce, "Unexpected off screen DC failure");

		_hdc = hdcSave;
		return NULL;
	}

	AssertSz(!GetPed()->_fTransparent, "Off-screen render of tranparent control");

	_crCurTextColor = CLR_INVALID;
	if(_pccs)
	{
		// There is current a character format for the run so we need to
		// get in sync with that since the off screen DC isn't necessarily
		// set to that font.
		// Get the character format and set up the font
		SetFontAndColor(GetCF());
	}

	// We are rendering to a transparent background
	_fErase = FALSE;

	// Clear bitmap
	::SetBkColor(_hdc, _crBackground);
	_osdc.FillBitmap(_rcRender.right - _rcRender.left, yHeightRC);

	//Clear top of rcRender if necessary
	RECT rcErase = _rcRender;
	rcErase.top = _ptCur.y;
	rcErase.bottom = rcErase.top + _li._yHeight;

	//If the first line, erase to edge of rcRender
	if (rcErase.top <= _rcView.top)
		rcErase.top = min(_rcView.top, _rcRender.top);
	rcErase.bottom = _rc.top;

	if (rcErase.bottom > rcErase.top)
		EraseTextOut(hdcSave, &rcErase);

	// Restore background color if necessary
	if(_crBackground != _crCurBackground)
		::SetBkColor(_hdc, _crCurBackground);

	SetBkMode(_hdc, TRANSPARENT);

	// Store y adjustment to use in rendering off-screen bitmap
	yAdj = _rc.top;

	// Normalize _rc and _ptCur height for rendering to off-screen bitmap
	_ptCur.y   -= yAdj;
	_rc.top		= 0;
	_rc.bottom -= yAdj;

	// Store x adjustment to use in rendering off-screen bitmap
	xAdj = _rcRender.left;

	// Adjust _rcRender & _rcView so they are relative to x of 0
	_rcRender.left	-= xAdj;
	_rcRender.right -= xAdj;
	_rcView.left	-= xAdj;
	_rcView.right	-= xAdj;
	_rc.left		-= xAdj;
	_rc.right		-= xAdj;
	_ptCur.x		-= xAdj;

	return hdcSave;
}

/*
 *	CRenderer::RenderOffScreenBitmap(hdc, xAdj, yAdj)
 *
 *	@mfunc
 *		Render off screen bitmap and restore the state of the render.
 */
void CRenderer::RenderOffScreenBitmap(
	HDC		hdc,		//@parm DC to render to
	LONG	xAdj,		//@parm offset to real x base
	LONG	yAdj)		//@parm offset to real y base 
{	
	// Palettes for rendering bitmap
	HPALETTE hpalOld = NULL;
	HPALETTE hpalNew = NULL;

	// Restore x offsets
	_rc.left		+= xAdj;
	_rc.right		+= xAdj;
	_rcRender.left	+= xAdj;
	_rcRender.right += xAdj;
	_rcView.left	+= xAdj;
	_rcView.right	+= xAdj;
	_ptCur.x		+= xAdj;

	// Restore y offsets
	_ptCur.y		+= yAdj;
	_rc.top			+= yAdj;
	_rc.bottom		+= yAdj;

	// Create a palette if one is needed
	if(_plogpalette)				
		W32->ManagePalette(hdc, _plogpalette, hpalOld, hpalNew);

	// Render bitmap to real DC and restore _ptCur & _rc
	_osdc.RenderBitMap(hdc, xAdj, yAdj, _rcRender.right - _rcRender.left, _rc.bottom - _rc.top);

	// Restore palette after render if necessary
	if(_plogpalette)				
	{
		W32->ManagePalette(hdc, _plogpalette, hpalOld, hpalNew);
		CoTaskMemFree(_plogpalette);
		_plogpalette = NULL;
	}

	// Restore HDC to actual render DC
	_hdc = hdc;

	// Set this flag to what it should be for restored DC
	_fErase = TRUE;

	_crCurTextColor = CLR_INVALID;

	// Reset screen DC font 
	// Set up font on non-screen DC
	// Force color resynch
	if(!FormatIsChanged())				// Not on a new block,
		SetFontAndColor(GetCF());		//  so just set font and color
	else
	{									// On new block,
		ResetCachediFormat();			//  so reset everything
		SetNewFont();
	}
}

/*
 *	CRenderer::RenderLine (&li)
 *
 *	@mfunc
 *		Render visible part of current line
 *
 *	@rdesc
 *		TRUE if success, FALSE if failed
 *
 *	@devnote
 *		Only call this from CLine::RenderLine()
 */
BOOL CRenderer::RenderLine (
	CLine &	li)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::RenderLine");

	BYTE	bUnderlineSave = 0;
	LONG 	cch;
	LONG 	cchChunk;
	LONG	cchInTextRun;
	LONG	cpSelMin, cpSelMost;
	BOOL	fAccelerator = FALSE;
	HDC		hdcSave = NULL;
	LONG	nSurrogates = 0;
	const WCHAR * pstrToRender;
	CTempWcharBuf twcb;
	WCHAR	chPassword = GetPasswordChar();
	LONG	xAdj = 0;
	LONG	yAdj = 0;

	UpdatePF();

	// This is used as a temporary buffer so that we can guarantee that we will
	// display an entire format run in one ExtTextOut.
	WCHAR *	pszTempBuffer = NULL;

	// Get range to display for this rendering
	GetPed()->GetSelRangeForRender(&cpSelMin, &cpSelMost);

	NewLine(li);						// Init render at start of line
	_ptCur.x += _li._xLeft;				// Add in line left indent 

	SetClipRect();
	if(cpSelMost != cpSelMin && cpSelMost == GetCp())
		_fSelectedPrev = TRUE;

	// We use an off screen DC if there are characters to render and the
	// measurer determined that this line needs off-screen rendering. The
	// main reason for the measurer deciding that a line needs off screen
	// rendering is if there are multiple formats in the line.
	if(_li._cch > 0 && _fUseOffScreenDC && (_li._bFlags & fliUseOffScreenDC))
	{
		// Set up an off-screen DC if we can. Note that if this fails,
		// we just use the regular DC which won't look as nice but
		// will at least display something readable.
		hdcSave = SetUpOffScreenDC(xAdj, yAdj);

		// Is this a uniform text being rendered off screen?
		if(_li._bFlags & fliOffScreenOnce)
		{
			// Yes - turn off special rendering since line has been rendered
			li._bFlags &= ~(fliOffScreenOnce | fliUseOffScreenDC);
		}
	}

	// Allow for special rendering at start of line
	LONG x = _ptCur.x;
	RenderStartLine();

	Assert(GetCp() + _li._cch <= GetTextLength());

	cch = _li._cch;

	if(chPassword && IsRich())
	{
		// It is kind of odd to allow rich text password edit controls.
		// However, it does make it that much easier to create a password
		// edit control since you don't have to know to change the box to
		// plain. Anyway, if there is such a thing, we don't want to put
		// out password characters for EOPs in general and the final EOP
		// specifically. Therefore, the following ...
		if(_pdp->IsMultiLine())
			cch -= _li._cchEOP;
		else
			cch = GetPed()->GetAdjustedTextLength();
	}

	for(; cch > 0; cch -= cchChunk)
	{
		// Initial chunk (number of character to render in a single TextOut)
		// is min between CHARFORMAT run length and line length. Start with
		// count of characters left in current format run
		cchChunk = GetCchLeftRunCF();
		AssertSz(cchChunk != 0, "empty CHARFORMAT run");

		DWORD dwEffects = GetCF()->_dwEffects;
		if(dwEffects & CFE_HIDDEN)			// Don't display hidden text
		{										
			Advance(cchChunk);
			continue;
		}

		// Limit chunk to count of characters we want to display.
		cchChunk = min(cch, cchChunk);

		// Get count of characters in text run
		pstrToRender = _rpTX.GetPch(cchInTextRun);
		AssertSz(cchInTextRun > 0, "empty text run");

		if (cchInTextRun < cchChunk || chPassword || dwEffects & CFE_ALLCAPS ||
			_li._bFlags & fliHasSurrogates)
		{
			// The amount of data in the backing store run is less than the
			// number of characters we wish to display. We will copy the
			// data out of the backing store.

			// Allocate a buffer if it is needed
			if(!pszTempBuffer)
			{
				// Allocate buffer big enough to handle all future
				// requests in this loop.
				pszTempBuffer = twcb.GetBuf(cch);
			}

			// Point at buffer
			pstrToRender = pszTempBuffer;
			if(chPassword)
			{
				// Fill buffer with password characters
				for (int i = 0; i < cchChunk; i++)
					pszTempBuffer[i] = chPassword;
			}
			else
			{	// Password not requested so copy text from backing
				// store to buffer
				_rpTX.GetText(cchChunk, pszTempBuffer);
				if(dwEffects & CFE_ALLCAPS)
					CharUpperBuff(pszTempBuffer, cchChunk);
			}
		}

		if(_cpAccelerator != -1)
		{
			LONG cpCur = GetCp();		// Get current cp

			// Does accelerator character fall in this chunk?
			if (cpCur < _cpAccelerator &&
				cpCur + cchChunk > _cpAccelerator)
			{
				// Yes. Reduce chunk to char just before accelerator
				cchChunk = _cpAccelerator - cpCur;
			}
			// Is this character the accelerator?
			else if(cpCur == _cpAccelerator)
			{							// Set chunk size to 1 since only
				cchChunk = 1;			//  want to output underlined char
				fAccelerator = TRUE;	// Tell downstream routines that
										//  we're handling accelerator
				_cpAccelerator = -1;	// Only 1 accelerator per line
			}
		}
		
		// Reduce chunk to account for selection if we are rendering for a
		// display that cares about selections.
		if(_fRenderSelection && cpSelMin != cpSelMost)
		{
			LONG cchSel = cpSelMin - GetCp();
			if(cchSel > 0)
				cchChunk = min(cchChunk, cchSel);

			else if(GetCp() < cpSelMost)
			{
				cchSel = cpSelMost - GetCp();
				if(cchSel >= cch)
					_fSelectToEOL = TRUE;
				else
					cchChunk = min(cchChunk, cchSel);

				_fSelected = TRUE;		// cpSelMin <= GetCp() < cpSelMost
			}							//  so current run is selected
		}

		// If start of CCharFormat run, select font and color
		if(FormatIsChanged() || _fSelected != _fSelectedPrev)
		{
			ResetCachediFormat();
			_fSelectedPrev = _fSelected;
			if(!SetNewFont())
				return FALSE;					// Failed
		}

		if(fAccelerator)
		{
			bUnderlineSave = _bUnderlineType;
			SetupUnderline(CFU_UNDERLINE);
		}

		// Allow for further reduction of the chunk and rendering of 
		// interleaved rich text elements
		if(RenderChunk(cchChunk, pstrToRender, cch))
		{
			AssertSz(cchChunk > 0, "CRenderer::RenderLine(): cchChunk == 0");
			_fSelected = FALSE;
			continue;
		}

		AssertSz(cchChunk > 0,"CRenderer::RenderLine() - cchChunk == 0");

#ifdef UNICODE_SURROGATES
		if(_li._bFlags & fliHasSurrogates)
		{
			WCHAR  ch;
			WCHAR *pchD = pszTempBuffer;
			WCHAR *pchS = pszTempBuffer;
			for(int i = cchChunk; i--; )
			{
				ch = *pchS++;
				if (IN_RANGE(0xD800, ch, 0xDBFF) && i &&
					IN_RANGE(0xDC00, *pchS, 0xDFFF))
				{
					// Project down into plane 0
					ch = (ch << 10) | (*pchS++ & 0x3FF);
				}
				*pchD++ = ch;
			}
			nSurrogates = pchS - pchD;
		}
#endif
		_fLastChunk = (cchChunk == cch);
		RenderText(pstrToRender, cchChunk - nSurrogates);	// Render the text
		nSurrogates = 0;

		if(fAccelerator)
		{
			_bUnderlineType = bUnderlineSave;
			fAccelerator = FALSE;			// Turn off special accelerator
		}						 			//  processing
		Advance(cchChunk);

		// Break if we went past right of render rect.
		if(_ptCur.x >= min(_rcView.right, _rcRender.right))
		{
			cch -= cchChunk;
			break;
		}
	}

	EndRenderLine(hdcSave, xAdj, yAdj, x);
	Advance(cch);
	return TRUE;						// Success
}

/*
 *	CRenderer::EndRenderLine (hdcSave, xAdj, yAdj, x)
 *
 *	@mfunc
 *		Finish up rendering of line, drawing table borders, rendering
 *		offscreen DC, and erasing to right of render rect if necessary.
 */
void CRenderer::EndRenderLine(
	HDC	 hdcSave,
	LONG xAdj,
	LONG yAdj,
	LONG x)
{
	// Display table borders (only 1 pixel wide)
	if(_pPF->InTable() && _li._bFlags & fliFirstInPara)
	{
		const LONG *prgxTabs = _pPF->GetTabs();
		COLORREF crf = _crTextColor;
		LONG	   icr = _pPF->_dwBorderColor & 0x1F;

		if (IN_RANGE(1, icr, 16))
			crf = g_Colors[icr-1];
		HPEN pen = CreatePen(PS_SOLID, 0, crf);

		LONG  h = LXtoDX(_pPF->_dxOffset);
		LONG dx = LXtoDX(_pPF->_dxStartIndent);
		x -= h;
		LONG xRight = x	+ LXtoDX(GetTabPos(prgxTabs[_pPF->_bTabCount - 1])) - dx;
		LONG yTop = _ptCur.y;
		LONG yBot = yTop + _li._yHeight;

		if(pen)
		{
			HPEN oldPen = SelectPen(_hdc, pen);
			MoveToEx(_hdc, x, yTop, NULL);
			LineTo  (_hdc, xRight, yTop);
			if(!_li._fNextInTable)
			{
				MoveToEx(_hdc, x,	   yBot - 1, NULL);
				LineTo	(_hdc, xRight, yBot - 1);
			}
			h = 0;
			for(LONG i = _pPF->_bTabCount; i >= 0; i--)
			{
				MoveToEx(_hdc, x + h, yTop, NULL);
				LineTo  (_hdc, x + h, yBot);

				if (i)
					h = LXtoDX(GetTabPos(*prgxTabs++)) - dx;
			}
			if(oldPen)			
				SelectPen(_hdc, oldPen);
			
			DeleteObject(pen);
		}
	}

	if(hdcSave)
		RenderOffScreenBitmap(hdcSave, xAdj, yAdj);

	// Handle setting background color. We need to do this for each line 
	// because we return the background color to the default after each
	// line so that opaquing will work correctly.
	if(_crBackground != _crCurBackground)
	{
		::SetBkColor(_hdc, _crBackground);	// Tell window background color
		_crCurBackground = _crBackground;
	}
}

/*
 *	CRenderer::UpdatePalette (pobj)
 *
 *	@mfunc
 *		Stores palette information so that we can render any OLE objects
 *		correctly in a bitmap.
 */
void CRenderer::UpdatePalette(
	COleObject *pobj)		//@parm OLE object wrapper.
{
#ifndef PEGASUS
	LOGPALETTE *plogpalette = NULL;
	LOGPALETTE *plogpaletteMerged;
	IViewObject *pviewobj;

	// Get IViewObject interface information so we can build a palette
	// to render the object correctly.
	if (((pobj->GetIUnknown())->QueryInterface(IID_IViewObject, 
		(void **) &pviewobj)) != NOERROR)
	{
		// Couldn't get it, so pretend this didn't happen
		return;
	}

	// Get logical palette information from object
	if(pviewobj->GetColorSet(DVASPECT_CONTENT, -1, NULL, NULL, 
			NULL, &plogpalette) != NOERROR || !plogpalette)
	{
		// Couldn't get it, so pretend this didn't happen
		goto CleanUp;
	}

	if(!_plogpalette)				
	{								// No palette entries yet
		_plogpalette = plogpalette;	// Just use the one returned
		goto CleanUp;
	}

	// We have had other palette entries. We just reallocate the table
	// and put the newest entry on the end. This is crude, we might
	// sweep the table and actually merge it. However, this code
	// should be executed relatively infrequently and therefore, crude
	// should be good enough.

	// Allocate a new table - Note the " - 1" in the end has to do with
	// the fact that LOGPALETTE is defined to have one entry already.
	AssertSz(_plogpalette->palNumEntries + plogpalette->palNumEntries >= 1,
		"CRenderer::UpdatePalette - invalid palettes to merge");
	plogpaletteMerged = (LOGPALETTE *) CoTaskMemAlloc(sizeof(LOGPALETTE) + 
		((_plogpalette->palNumEntries + plogpalette->palNumEntries - 1) * sizeof(PALETTEENTRY)));

	if(!plogpaletteMerged)				// Memory allocation failed
		goto CleanTempPalette;			// Just pretend it didn't happen

	// Copy in original table.
	memcpy(&plogpaletteMerged->palPalEntry[0], &_plogpalette->palPalEntry[0],
		_plogpalette->palNumEntries * sizeof(PALETTEENTRY));

	// Put new data at end
	memcpy(&plogpaletteMerged->palPalEntry[_plogpalette->palNumEntries], 
		&plogpalette->palPalEntry[0],
		plogpalette->palNumEntries * sizeof(PALETTEENTRY));

	// Set the version number and count
	plogpaletteMerged->palVersion = plogpalette->palVersion;
	plogpaletteMerged->palNumEntries = _plogpalette->palNumEntries 
		+ plogpalette->palNumEntries;

	// Replace current palette table with merged table
	CoTaskMemFree(_plogpalette);
	_plogpalette = plogpaletteMerged;

CleanTempPalette:
	CoTaskMemFree(plogpalette);

CleanUp:

	// Release object we got since we don't need it any more
	pviewobj->Release();
#endif
}

/*
 *	CRenderer::RenderChunk (&cchChunk, pstrToRender, cch)
 *
 *	@mfunc
 *		Method reducing the length of the chunk (number of character
 *		rendered in one RenderText) and to render items interleaved in text.
 *
 *	@rdesc	
 *		TRUE if this method actually rendered the chunk, 
 * 		FALSE if it just updated cchChunk and rendering is still needed
 */
BOOL CRenderer::RenderChunk(
	LONG&		 cchChunk,		//@parm in: chunk cch; out: # chars rendered
								//  if return TRUE; else # chars yet to render
	const WCHAR *pstrToRender,	//@parm String to render up to cchChunk chars
	LONG		 cch) 			//@parm # chars left to render on line
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::RenderChunk");

	LONG		cchT;
	LONG		cchvalid;
	LONG		i;
	const TCHAR *pchT;
	COleObject *pobj;
	CObjectMgr *pobjmgr;
	
	// If line has objects, reduce cchChunk to go to next object only
	if(_li._bFlags & fliHasOle)
	{
		pchT = pstrToRender;
		cchvalid = cchChunk;

		// Search for object in chunk
		for( i = 0; i < cchvalid && *pchT != WCH_EMBEDDING; i++ )
			pchT++;

		if( i == 0 )
		{
			// First character is object so display object
			pobjmgr = GetPed()->GetObjectMgr();
			pobj = pobjmgr->GetObjectFromCp(GetCp());
			if(pobj)
			{
				LONG yAscent, yDescent, objwidth;
				pobj->MeasureObj(_dypInch, _dxpInch, objwidth, yAscent, yDescent, _li._yDescent);
				SetClipLeftRight(_li._xWidth + objwidth);

				if (W32->FUsePalette() && (_li._bFlags & fliUseOffScreenDC) && _pdp->IsMain())
				{
					// Keep track of palette needed for rendering bitmap
					UpdatePalette(pobj);
				}
				pobj->DrawObj(_pdp, _dypInch, _dxpInch, _hdc, _pdp->IsMetafile(), &_ptCur, &_rc, 
							  _li._yHeight - _li._yDescent, _li._yDescent);
				_ptCur.x	+= objwidth;
				_li._xWidth += objwidth;
			}
			cchChunk = 1;

			// Both tabs and object code need to advance the run pointer past
			// each character processed.
			Advance(1);
			return TRUE;
		}
		else 
		{
			// Limit chunk to character before object
			cchChunk -= cchvalid - i;
		}
	}

	// If line has tabs, reduce cchChunk
	if(_li._bFlags & fliHasTabs)
	{
		for(cchT = 0, pchT = pstrToRender;
			cchT < cchChunk && *pchT != TAB && *pchT != CELL
			&& *pchT != SOFTHYPHEN
			; pchT++, cchT++)
		{
			// this loop body intentionally left blank
		}
		if(!cchT)
		{
			// First char is a tab, render it and any that follow
			if(*pchT == SOFTHYPHEN)
			{
				if(cch == 1)				// Only render soft hyphen at EOL
				{
				TCHAR chT = '-';
				RenderText(&chT, 1);
				}
							
				Advance(1);					// Skip those within line
				cchChunk = 1;
			}
			else
				cchChunk = RenderTabs(cchChunk);
			Assert (cchChunk > 0);
			return TRUE;
		}
		cchChunk = cchT;		// Update cchChunk not to incl trailing tabs
	}

	// If line has special characters, reduce cchChunk to go to next special character
	if(_li._bFlags & fliHasSpecialChars)
	{
		pchT = pstrToRender;
		cchvalid = cchChunk;

		// Search for special character in chunk
		for( i = 0; i < cchvalid && *pchT != EURO; i++)
			pchT++;

		if(i == 0)
		{
			for(; i < cchvalid && *pchT == EURO; i++)
				pchT++;

			cchChunk = i;
		}
		else 
		{
			// Limit chunk to character before object
			cchChunk -= cchvalid - i;
		}
	}

	return FALSE;
}		

/*
 *	CRenderer::SetClipRect()
 *
 *	@mfunc
 *		Helper to set clipping rect for the line
 */
void CRenderer::SetClipRect()
{
	//Nominal clipping values
	_rc = _rcRender;
	_rc.top = _ptCur.y;
	_rc.bottom = _rc.top + _li._yHeight;

	//Clip to rcView
	_rc.left = max(_rc.left, _rcView.left);
	_rc.right = min(_rc.right, _rcView.right);

	_rc.top = max(_rc.top, _rcView.top);
	_rc.bottom = min(_rc.bottom, _rcView.bottom);
}

/*
 *	CRenderer::SetClipLeftRight (xWidth)
 *
 *	@mfunc
 *		Helper to sets left and right of clipping/erase rect.
 *	
 *	@rdesc
 *		Sets _rc left and right	
 */
void CRenderer::SetClipLeftRight(
	LONG xWidth)		//@parm	Width of chunk to render
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::SetClipLeftRight");

	//Nominal values
	_rc.left = _ptCur.x;
	_rc.right = _rc.left + xWidth;

	//Constrain left and right based on rcView, rcRender
	_rc.left = max(_rc.left, _rcView.left);
	_rc.left = max(_rc.left, _rcRender.left);

	_rc.right = max(_rc.right, _rc.left);
	_rc.right = min(_rc.right, _rcView.right);
	_rc.right = min(_rc.right, _rcRender.right);
}
	
/*
 *	CRenderer::GetConvertMode()
 *
 *	@mfunc
 *		Return the mode that should really be used in the RenderText call
 */
CONVERTMODE	CRenderer::GetConvertMode()
{
	CONVERTMODE cm = (CONVERTMODE)_pccs->_bConvertMode;

	// For hack around ExtTextOutW Win95 problems.
	if (cm != CVT_LOWBYTE && W32->OnWin9x() && (_pdp->IsMetafile() || _fEnhancedMetafileDC))
		return CVT_WCTMB;

	if (cm != CVT_LOWBYTE && _pdp->IsMetafile() && !_fEnhancedMetafileDC)
		return CVT_WCTMB;	// WMF cant store Unicode so we cant use ExtTextOutW

	return cm;
}		

/*
 *	CRenderer::RenderExtTextOut (x, y, fuOptions, &rc, pwchRun, cch, rgdxp)
 *
 *	@mfunc
 *		Calls ExtTextOut and handles disabled text. There is duplicate logic in OlsDrawGlyphs, but
 *		the params are different so that was simplest way.
 *
 */
void CRenderer::RenderExtTextOut(LONG x, LONG y, UINT fuOptions, RECT *prc, PCWSTR pch, UINT cch, const INT *rgdxp)
{
	CONVERTMODE cm = GetConvertMode();

	if (prc->left == prc->right)
		return;

	if(_fDisabled)
	{
		if(_crForeDisabled != _crShadowDisabled)
		{
			// The shadow should be offset by a hairline point, namely
			// 3/4 of a point.  Calculate how big this is in device units,
			// but make sure it is at least 1 pixel.
			DWORD offset = MulDiv(3, _dypInch, 4*72);
			offset = max(offset, 1);

			// Draw shadow
			SetTextColor(_crShadowDisabled);
					
			W32->REExtTextOut(cm, _pccs->_wCodePage, _hdc, x + offset, y + offset,
				fuOptions, prc, pch, cch, rgdxp, _fFEFontOnNonFEWin9x);

			// Now set drawing mode to transparent
			fuOptions &= ~ETO_OPAQUE;
		}
		SetTextColor(_crForeDisabled);
	}

	W32->REExtTextOut(cm, _pccs->_wCodePage, _hdc, x, y, fuOptions, prc, pch, cch, rgdxp, _fFEFontOnNonFEWin9x);
}

/*
 *	CRenderer::RenderText (pch, cch)
 *
 *	@mfunc
 *		Render text in the current context of this CRenderer
 *
 *
 *	@devnote
 *		Renders text only: does not do tabs or OLE objects
 */
void CRenderer::RenderText(
	const WCHAR *pch,	//@parm Text to render
	LONG cch)			//@parm Length of text to render
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::RenderText");

	LONG		yOffsetForChar, cchT;

	// Variables used for calculating length of underline.
	LONG		xWidthSelPastEOL = 0;

	UINT		fuOptions = _pdp->IsMain() ? ETO_CLIPPED : 0;
	LONG		xWidth;
	LONG		tempwidth;
	CTempBuf	rgdx;

	//Reset clip rectangle to greater of view/render rectangle
	_rc.left = max(_rcRender.left, _rcView.left);
	_rc.right = min(_rcRender.right, _rcView.right);

	// Trim all nondisplayable linebreaking chars off end
	while(cch && IsASCIIEOP(pch[cch - 1]))
		cch--;
	
	int *pdx = (int *)rgdx.GetBuf(cch * sizeof(int));

	// Measure width of text to write so next point to write can be
	// calculated.
	xWidth = 0;

	for(cchT = 0;
		cchT < cch && xWidth < _rc.right - _ptCur.x;
		cchT++)
	{
		tempwidth = 0;
#ifdef UNICODE_SURROGATES
		Assert(!IN_RANGE(0xD800, *pch, 0xDFFF));
#endif
		if (!IN_RANGE(0x300, *pch, 0x36F) && !_pccs->Include(*pch, tempwidth))
		{
			TRACEERRSZSC("CRenderer::RenderText(): Error filling CCcs", E_FAIL);
			return;
		}

		*pdx++ = tempwidth;
  		pch++;
		xWidth += tempwidth;
	}

	// Go back to start of chunk
	cch = cchT;
	pch -= cch;
	pdx -= cch;

	if(_fLastChunk && _fSelectToEOL && _li._cchEOP)
	{
		// Use the width of the current font's space to highlight
		if(!_pccs->Include(' ', tempwidth))
		{
			TRACEERRSZSC("CRenderer::RenderText(): Error no length of space", E_FAIL);
			return;
		}
		xWidthSelPastEOL = tempwidth + _pccs->_xOverhang;
		xWidth += xWidthSelPastEOL;
		_fSelectToEOL = FALSE;			// Reset the flag
	}

	_li._xWidth += xWidth;

	// Setup for drawing selections via ExtTextOut.
 	if(_fSelected || _crBackground != _crCurBackground)
	{
		SetClipLeftRight(xWidth);
		if(_fSelected)
		{
			CTxtSelection *psel = GetPed()->GetSelNC();
			if (_pPF->InTable() && GetPrevChar() == CELL && psel &&
				psel->fHasCell() && GetCp() == psel->GetCpMin())
			{
				_rc.left -= LXtoDX(_pPF->_dxOffset);
			}
		}
		fuOptions = ETO_CLIPPED | ETO_OPAQUE;
	}

	yOffsetForChar = _ptCur.y + _li._yHeight - _li._yDescent + _pccs->_yDescent - _pccs->_yHeight;
		
	LONG yOffset, yAdjust;
	_pccs->GetOffset(GetCF(), _dypInch, &yOffset, &yAdjust);
	yOffsetForChar -= yOffset + yAdjust;

	RenderExtTextOut(_ptCur.x, yOffsetForChar, fuOptions, &_rc, pch, cch, pdx);

	// Calculate width to draw for underline/strikeout
	if(_bUnderlineType != CFU_UNDERLINENONE	|| _fStrikeOut)
	{
		LONG xWidthToDraw = xWidth - xWidthSelPastEOL;
		LONG xStart = _ptCur.x;
		LONG xEnd = xStart + xWidthToDraw;
		
		xStart = max(xStart, _rcRender.left);
		xStart = max(xStart, _rcView.left);

		xEnd = min(xEnd, _rcRender.right);
		xEnd = min(xEnd, _rcView.right);

		xWidthToDraw = xEnd - xStart;

		if(xWidthToDraw > 0)
		{
			LONG y = _ptCur.y + _li._yHeight - _li._yDescent;

			y -= yOffset + yAdjust;

			// Render underline if required
			if(_bUnderlineType != CFU_UNDERLINENONE)
				RenderUnderline(xStart,	y + _pccs->_dyULOffset, xWidthToDraw, _pccs->_dyULWidth);

			// Render strikeout if required
			if(_fStrikeOut)
				RenderStrikeOut(xStart, y + _pccs->_dySOOffset,	xWidthToDraw, _pccs->_dySOWidth);
		}
	}

	_fSelected = FALSE;

	_ptCur.x += xWidth;					// Update current point
}


/*
 *	CRenderer::RenderTabs (cchMax)
 *
 *	@mfunc
 *		Render a span of zero or more tab characters in chunk *this
 *
 *	@rdesc
 *		number of tabs rendered
 *
 *	@devnote
 *		*this is advanced by number of tabs rendered
 *		MS - tabs should be rendered using opaquing rect of adjacent string
 */
LONG CRenderer::RenderTabs(
	LONG cchMax)	//@parm Max cch to render (cch in chunk)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::RenderTabs");

	LONG cch = cchMax;
	LONG ch = GetChar();
	LONG chPrev = 0;
	LONG xTab, xTabs;
	
	for(xTabs = 0; cch && (ch == TAB || ch == CELL); cch--)
	{
		xTab	= MeasureTab(ch);
		_li._xWidth += xTab;				// Advance internal width
		xTabs	+= xTab;					// Accumulate width of tabbed
		Advance(1);							//  region
		chPrev = ch;
		ch = GetChar();					   
	}

	if(_li._xWidth > _xWidthLine)
	{
		xTabs = 0;
		_li._xWidth = _xWidthLine;
	}

	if(xTabs)
	{
		LONG dx = 0;
		LONG xGap = 0;

		if(_fSelected && chPrev == CELL && ch != CR && _pPF->InTable())
		{
			LONG cpSelMin, cpSelMost;
			GetPed()->GetSelRangeForRender(&cpSelMin, &cpSelMost);
			if(GetCp() == cpSelMin || GetCp() == cpSelMost)
			{
				xGap = LXtoDX(_pPF->_dxOffset);
				if(GetCp() == cpSelMost)
				{
					dx = xGap;
					xGap = 0;
				}
			}
		}
		SetClipLeftRight(xTabs - dx);
		if(_rc.left < _rc.right)			// Something to erase
		{
			if(_fSelected)					// Use selection background color
			{
			    COLORREF cr = GetPed()->TxGetSysColor(COLOR_HIGHLIGHT);
				if (!UseXOR(cr))
				{
				    ::SetBkColor (_hdc, cr);
    				_crCurTextColor = GetPed()->TxGetSysColor(COLOR_HIGHLIGHTTEXT);    				
				}
    			else
    			{ 
    			    const CCharFormat* pCF = GetCF();
    			    ::SetBkColor (_hdc, (pCF->_dwEffects & CFE_AUTOBACKCOLOR) ? 
    			                  _crBackground ^ RGB_WHITE : pCF->_crBackColor ^ RGB_WHITE);    		            		        
    				_crCurTextColor =  (pCF->_dwEffects & CFE_AUTOCOLOR) ? 
    				              _crTextColor ^ RGB_WHITE : pCF->_crTextColor ^ RGB_WHITE;    				
    			}
			}

			// Paint background with appropriate color
			if(_fSelected || _crBackground != _crCurBackground)
				EraseTextOut(_hdc, &_rc);

			// Render underline if required
			dx = _rc.right - _rc.left;
			LONG y = _ptCur.y + _li._yHeight - _li._yDescent;
			
			LONG yOffset, yAdjust;
			_pccs->GetOffset(GetCF(), _dypInch, &yOffset, &yAdjust);
			y -= yOffset + yAdjust;

			if(_bUnderlineType != CFU_UNDERLINENONE)
				RenderUnderline(_rc.left, y + _pccs->_dyULOffset, dx, _pccs->_dyULWidth);

			// Render strikeout if required
			if(_fStrikeOut)
				RenderStrikeOut(_rc.left, y +  _pccs->_dySOOffset, dx, _pccs->_dySOWidth);

			if(_fSelected)					// Restore colors
				::SetBkColor(_hdc, _crCurBackground);
		}
		_ptCur.x += xTabs;					// Update current point
	}
	return cchMax - cch;					// Return # tabs rendered
}

/*
 * 	CRenderer::SetNewFont()
 *
 *	@mfunc
 *		Select appropriate font and color in the _hdc based on the 
 *		current character format. Also sets the background color 
 *		and mode.
 *
 *	@rdesc
 *		TRUE if it succeeds
 *
 *	@devnote
 *		The calling chain must be protected by a CLock, since this present
 *		routine access the global (shared) FontCache facility.
 */
BOOL CRenderer::SetNewFont()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::SetNewFont");

	const CCharFormat	*pCF = GetCF();
	DWORD				dwEffects = pCF->_dwEffects;
		
	// Release previous font in use
	if(_pccs)
		_pccs->Release();

	Assert(_fTarget == FALSE);
	_pccs = GetCcs(pCF);

	if(!_pccs)
	{
		TRACEERRSZSC("CRenderer::SetNewFont(): no CCcs", E_FAIL);
		return FALSE;
	}

	// Select font in _hdc
	AssertSz(_pccs->_hfont, "CRenderer::SetNewFont _pccs->_hfont is NULL");

	SetFontAndColor(pCF);
	
	// Assume no underlining
	_bUnderlineType = CFU_UNDERLINENONE;

	// We want to draw revision marks and hyperlinks with underlining, so
	// just fake out our font information.
	if(dwEffects & (CFE_UNDERLINE | CFE_REVISED | CFE_LINK))
		SetupUnderline((dwEffects & CFE_LINK) ? CFU_UNDERLINE : pCF->_bUnderlineType);

	_fStrikeOut = (dwEffects & (CFE_STRIKEOUT | CFE_DELETED)) != 0;
	return TRUE;
}

/*
 * 	CRenderer::SetupUnderline (UnderlineType)
 *
 *	@mfunc
 *		Setup internal variables for underlining
 */
void CRenderer::SetupUnderline(
	LONG UnderlineType)
{
	_bUnderlineType	   = (BYTE) UnderlineType & 0xF;	// Low nibble gives type
	_bUnderlineClrIdx  = (BYTE) UnderlineType/16;		// High nibble gives color
}

/*
 * 	CRenderer::SetFontAndColor (pCF)
 *
 *	@mfunc
 *		Select appropriate font and color in the _hdc based on the 
 *		current character format. Also sets the background color 
 *		and mode.
 */
void CRenderer::SetFontAndColor(
	const CCharFormat *pCF)			//@parm Character format for colors
{
	CTxtEdit			*ped = GetPed();

	_fDisabled = FALSE;
	if((pCF->_dwEffects & (CFE_AUTOCOLOR | CFE_DISABLED))
					   == (CFE_AUTOCOLOR | CFE_DISABLED))
	{		
		_fDisabled = TRUE;
		
		_crForeDisabled   = ped->TxGetSysColor(COLOR_3DSHADOW);
		_crShadowDisabled = ped->TxGetSysColor(COLOR_3DHILIGHT);
	}

	_fFEFontOnNonFEWin9x = FALSE;
	if (IsFECharSet(pCF->_bCharSet) && W32->OnWin9x() && !W32->OnWin9xFE())
	{
		_fFEFontOnNonFEWin9x = TRUE;
	}

	SelectFont(_hdc, _pccs->_hfont);

	// Compute height and descent if not yet done
	if(_li._yHeight == -1)
	{
		SHORT	yAdjustFE = _pccs->AdjustFEHeight(!fUseUIFont() && ped->_pdp->IsMultiLine());
		// Note: this assumes plain text 
		// Should be used only for single line control
		_li._yHeight  = _pccs->_yHeight + (yAdjustFE << 1);
		_li._yDescent = _pccs->_yDescent + yAdjustFE;
	}
	SetTextColor(GetTextColor(pCF));	// Set current text color

	COLORREF  cr;

	if(_fSelected)						// Set current background color
	{
	    cr = GetPed()->TxGetSysColor(COLOR_HIGHLIGHT);
	    if (UseXOR(cr))
		{
		    // There are 2 cases to be concerned with
		    // 1) if the background color is the same as the selection color or
		    // 2) if 1.0 Window and the background color is NOT system default
		    cr = (pCF->_dwEffects & CFE_AUTOBACKCOLOR) ?
		          _crBackground ^ RGB_WHITE : pCF->_crBackColor ^ RGB_WHITE;	    
		}
	}
	else if(pCF->_dwEffects & CFE_AUTOBACKCOLOR)
		cr = _crBackground;
	else //Text has some kind of back color
		cr = pCF->_crBackColor;

	if(cr != _crCurBackground)
	{
		::SetBkColor(_hdc, cr);			// Tell window background color
		_crCurBackground = cr;			// Remember current background color
		_fBackgroundColor = _crBackground != cr; // Change render settings so we won't
	}									//  fill with background color
}

/*
 * 	CRenderer::SetTextColor (cr)
 *
 *	@mfunc
 *		Select given text color in the _hdc
 *		Used to maintain _crCurTextColor cache
 */
void CRenderer::SetTextColor(
	COLORREF cr)			//@parm color to set in the dc
{
	if(cr != _crCurTextColor)
	{
		_crCurTextColor = cr;
		::SetTextColor(_hdc, cr);
	}
}

/*
 *	CRenderer::GetTextColor(pCF)
 *
 *	@mfunc
 *		Return text color for pCF. Depends on _bRevAuthor, display tech
 *
 *  FUTURE (keithcu) It might be nice to have black or blue selected text be
 *  white, but to have all other colors stay their other colors. What do we
 *	do if the backcolor is blue??
 *
 *	@rdesc	
 *		text color
 */
COLORREF CRenderer::GetTextColor(
	const CCharFormat *pCF)	//@parm CCharFormat specifying text color
{
	if(_fSelected)
	{
	    // There are 2 cases where XOR for selection is needed
	    // 1) if the background is the same as the selection background
	    // 2) if 1.0 window and the background isn't the system default window
	    // background color

	    // if this doesn't match the above case just return the cr
	    if (!UseXOR(GetPed()->TxGetSysColor(COLOR_HIGHLIGHT)))
	        return GetPed()->TxGetSysColor(COLOR_HIGHLIGHTTEXT);

	    // xor the current text color for the selected text color
		return (pCF->_dwEffects & CFE_AUTOCOLOR) ? _crTextColor ^ RGB_WHITE :
		    pCF->_crTextColor ^ RGB_WHITE;
    }

	// The following could be generalized to return a different color for
	// links that have been visited for this text instance (need to define
	// extra CCharFormat::_dwEffects internal flag to ID these links)
	if(pCF->_dwEffects & CFE_LINK)
	{
		// Blue doesnt show up very well against dark backgrounds.
		// In these situations, use the system selected text color.
		COLORREF crBackground = (pCF->_dwEffects & CFE_AUTOBACKCOLOR)
							  ? _crBackground :	pCF->_crBackColor;

		if (IsTooSimilar(crBackground, RGB_BLACK) || IsTooSimilar(crBackground, RGB_BLUE))
		{
			COLORREF crHighlightText = GetPed()->TxGetSysColor(COLOR_HIGHLIGHTTEXT);
			if (IsTooSimilar(crBackground, crHighlightText))
			{
				// Background is similar to highlight, use window text color
				return GetPed()->TxGetSysColor(COLOR_WINDOWTEXT);
			}
			else
			{
				return crHighlightText;
			}
		}
		else
		{
			return RGB_BLUE;
		}
	}

	if(pCF->_bRevAuthor)				// Rev author
	{
		// Limit color of rev authors to 0 through 7.
		return rgcrRevisions[(pCF->_bRevAuthor - 1) & REVMASK];
	}

	COLORREF cr = (pCF->_dwEffects & CFE_AUTOCOLOR)	? _crTextColor : pCF->_crTextColor;

	if(cr == RGB_WHITE)					// Text is white
	{
		COLORREF crBackground = (pCF->_dwEffects & CFE_AUTOBACKCOLOR)
							  ? _crBackground :	pCF->_crBackColor;
		if(crBackground != RGB_WHITE)
		{
			// Background color isn't white, so white text is probably
			// visible unless display device is only black/white. So we
			// switch to black text on such devices.
			if (GetDeviceCaps(_hdc, NUMCOLORS) == 2 ||
				GetDeviceCaps(_hdc, TECHNOLOGY) == DT_PLOTTER)
			{
				cr = RGB_BLACK;
			}
		}
	}
	return cr;
}

/*
 *	CRenderer::RenderStartLine()
 *
 *	@mfunc
 *		Render possible outline symbol and bullet if at start of line
 *
 *	@rdesc	
 *		TRUE if this method succeeded
 */
BOOL CRenderer::RenderStartLine()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::RenderStartLine");
	BOOL fDrawBack = !(GetCF()->_dwEffects & CFE_AUTOBACKCOLOR) && GetPed()->_fExtendBackColor;
	RECT rcErase = _rcRender;

	rcErase.top = _ptCur.y;
	rcErase.bottom = min(rcErase.top + _li._yHeight, _rcRender.bottom);

	//If the first line, erase to edge of rcRender
	if (rcErase.top <= _rcView.top)
		rcErase.top = min(_rcView.top, _rcRender.top);

	if (_fErase && !fDrawBack)
		EraseTextOut(GetDC(), &rcErase);

	// Fill line with background color if we are in fExtendBackColor mode
	if (fDrawBack)
	{
		// capture the old color so we reset it to what it was when we're finished
		COLORREF crOld = ::SetBkColor(GetDC(), GetCF()->_crBackColor);
		EraseTextOut(GetDC(), &_rc);

		// reset background color to the old color
		::SetBkColor(GetDC(), crOld);

		//Erase the remainder of the background area
		if (_fErase)
		{
			RECT rcTemp = rcErase;
			//Erase the top part if necessary
			if (rcErase.top < _rc.top)
			{
				rcTemp.bottom = _rc.top;
				EraseTextOut(GetDC(), &rcTemp);
			}

			//Erase the left and right parts if necessary
			rcTemp.top = _rc.top;
			rcTemp.bottom = _rc.bottom;
			if (rcErase.left < _rc.left)
			{
				rcTemp.right = _rc.left;
				EraseTextOut(GetDC(), &rcTemp);
			}
			if (rcErase.right > _rc.right)
			{
				rcTemp.left = _rc.right;
				rcTemp.right = rcErase.right;
				EraseTextOut(GetDC(), &rcTemp);
			}
		}
	}

	if(IsRich() && (_li._bFlags & fliFirstInPara))
	{
		if(IsInOutlineView())
			RenderOutlineSymbol();

		if(_pPF->_wNumbering && !fUseLineServices())
			RenderBullet();	
	}

	// Reset format if there is special background color for previous line.
	// Otherwise, current line with the same format will not re-paint with the
	// special background color
	if (_fBackgroundColor)
	{
		_iFormat = -10;					// Reset to invalid format

		// Assume that there is no special background color for the line
		_fBackgroundColor = FALSE;
	}

	// Handle setting background color. If the current background
	// color is different than the default, we need to set the background
	// to this because the end of line processing reset the color so
	// that opaquing would work.
	if(_crBackground != _crCurBackground)
	{
		// Tell the window the background color
		::SetBkColor(_hdc, _crCurBackground);
		_fBackgroundColor = TRUE;
	}

	return TRUE;
}

/*
 *	CRenderer::RenderOutlineSymbol()
 *
 *	@mfunc
 *		Render outline symbol for current paragraph
 *
 *	@rdesc
 *		TRUE if outline symbol rendered
 */
BOOL CRenderer::RenderOutlineSymbol()
{
	AssertSz(IsInOutlineView(), 
		"CRenderer::RenderOutlineSymbol called when not in outline view");

	HBITMAP	hbitmap;
	LONG	height;
	LONG	width;
	LONG	x = _ptCur.x - _li._xLeft + LXtoDX(lDefaultTab/2 * _pPF->_bOutlineLevel);
	LONG	y = _ptCur.y;

	if(!g_hbitmapSubtext && InitializeOutlineBitmaps() != NOERROR)
		return FALSE;

    HDC hMemDC = CreateCompatibleDC(_hdc); // REVIEW: performance

    if(!hMemDC)
        return FALSE; //REVIEW: out of memory

	if(_pPF->_bOutlineLevel & 1)			// Subtext
	{
		width	= BITMAP_WIDTH_SUBTEXT;
		height	= BITMAP_HEIGHT_SUBTEXT;
		hbitmap	= g_hbitmapSubtext;
	}
	else									// Heading
	{
		width	= BITMAP_WIDTH_HEADING;
		height	= BITMAP_HEIGHT_HEADING;
		hbitmap	= g_hbitmapEmptyHeading;

		CPFRunPtr rp(*this);				// Check next PF for other
		LONG	  cch = _li._cch;		 	//  outline symbols

		if(_li._cch < rp.GetCchLeft())		// Set cch = count to heading
		{									//  EOP
			CTxtPtr tp(_rpTX);
			cch = tp.FindEOP(tomForward);
		}
		rp.AdvanceCp(cch);					// Go to next paragraph
		if(rp.IsCollapsed())
			hbitmap	= g_hbitmapCollapsedHeading;

		else if(_pPF->_bOutlineLevel < rp.GetOutlineLevel())
			hbitmap	= g_hbitmapExpandedHeading;
	}

	if(!hbitmap)
		return FALSE;

    HBITMAP hbitmapDefault = (HBITMAP)SelectObject(hMemDC, hbitmap);

    // REVIEW: what if the background color changes?  Also, use a TT font
	// for symbols
	LONG h = _pdp->Zoom(height);
	LONG dy = _li._yHeight - _li._yDescent - h;

	if(dy > 0)
		dy /= 2;
	else
		dy = -dy;

    StretchBlt(_hdc, x, y + dy, _pdp->Zoom(width), h, hMemDC, 0, 0, width, height, SRCCOPY);

    SelectObject(hMemDC, hbitmapDefault);
    DeleteDC(hMemDC);
	return TRUE;
}

/*
 *	CRenderer::RenderBullet()
 *
 *	@mfunc
 *		Render bullet at start of line
 *
 *	@rdesc	
 *		TRUE if this method succeeded
 */
BOOL CRenderer::RenderBullet()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::RenderBullet");

	AssertSz(_pPF->_wNumbering, 
		"CRenderer::RenderBullet called for non-bullet");

	// Width of the bullet character
	LONG xWidth;

	// FUTURE: Unicode bullet is L'\x2022' We want to migrate to this and
	// other bullets
	LONG		cch;
	CCharFormat CF;
	WCHAR		szBullet[CCHMAXNUMTOSTR];

	CCcs *pccs = GetCcsBullet(&CF);

	if(!pccs)								// Bullet is suppressed because
		return TRUE;						//  preceding EOP is VT

	if(_pccs)
		_pccs->Release();

	_pccs = pccs;

	// Default to no underline
	_bUnderlineType = CFU_UNDERLINENONE;

	if(_pPF->IsListNumbered() && CF._dwEffects & CFE_UNDERLINE)
		_bUnderlineType = (BYTE) CF._bUnderlineType & 0xF;

	SetFontAndColor(&CF);

	BYTE bFlagSave		= _li._bFlags;
	LONG dxOffset		= LXtoDX(max(_pPF->_dxOffset, _pPF->_wNumberingTab));
	LONG xSave			= _ptCur.x;
	LONG xWidthLineSave = _xWidthLine;

	_li._bFlags = 0;

	// Set-up to render bullet in one chunk
	cch = GetBullet(szBullet, _pccs, &xWidth);
	dxOffset = max(dxOffset, xWidth);
	_xWidthLine = dxOffset;
	if(IsInOutlineView())
		dxOffset = _li._xLeft - LXtoDX(lDefaultTab/2 * (_pPF->_bOutlineLevel + 1));
	_ptCur.x -= dxOffset;

	// Render bullet
	_fLastChunk = TRUE;
	RenderText(szBullet, cch);

	// Restore render vars to continue with remainder of line.
	_ptCur.x = xSave;
	_xWidthLine = xWidthLineSave;
	_li._bFlags = bFlagSave;
	_li._xWidth = 0;

	// This releases the _pccs that we put in for the bullet
	SetNewFont();
	return TRUE;
}

/*
 *	CRenderer::RenderUnderline(xStart, yStart, xLength, yThickness)
 *
 *	@mfunc
 *		Render underline
 */
void CRenderer::RenderUnderline(
	LONG xStart, 		//@parm Horizontal start of underline
	LONG yStart,		//@parm Vertical start of underline
	LONG xLength,		//@parm Length of underline
	LONG yThickness)	//@parm Thickness of underline
{
	BOOL	 fUseLS = fUseLineServices();
	COLORREF crUnderline;
	RECT	 rcT;
	
	if (!_bUnderlineClrIdx ||
		GetPed()->GetEffectColor(_bUnderlineClrIdx, &crUnderline) != NOERROR ||
		crUnderline == tomAutoColor || crUnderline == tomUndefined)
	{
		crUnderline = _crCurTextColor;
	}

	if (_bUnderlineType != CFU_INVERT &&
		!IN_RANGE(CFU_UNDERLINEDOTTED, _bUnderlineType, CFU_UNDERLINEWAVE))
	{
		// Regular single underline case
		// Calculate where to put underline
		rcT.top = yStart;

		if (CFU_UNDERLINETHICK == _bUnderlineType)
		{
			rcT.top -= yThickness;
			yThickness += yThickness;	
		}

		// There are some cases were the following can occur - particularly
		// with bullets on Japanese systems.
		if(!fUseLS && rcT.top >= _ptCur.y + _li._yHeight)
			rcT.top = _ptCur.y + _li._yHeight -	yThickness;

		rcT.bottom	= rcT.top + yThickness;
		rcT.left	= xStart;
		rcT.right	= xStart + xLength;
		FillRectWithColor(&rcT, crUnderline);
		return;
	}

	if(_bUnderlineType == CFU_INVERT)			// Fake selection.
	{											// NOTE, not really
		rcT.top	= _ptCur.y;						// how we should invert text!!
		rcT.left = xStart;						// check out IME invert.
		rcT.bottom = rcT.top + _li._yHeight - _li._yDescent + _pccs->_yDescent;
		rcT.right = rcT.left + xLength;
  		InvertRect(_hdc, &rcT);
		return;
	}

	if(IN_RANGE(CFU_UNDERLINEDOTTED, _bUnderlineType, CFU_UNDERLINEWAVE))
	{
		static const char pen[] = {PS_DOT, PS_DASH, PS_DASHDOT, PS_DASHDOTDOT, PS_SOLID};

		HPEN hPen = CreatePen(pen[_bUnderlineType - CFU_UNDERLINEDOTTED],
							  1, crUnderline);	
		if(hPen)
		{
			HPEN hPenOld = SelectPen(_hdc, hPen);
			LONG right = xStart + xLength;

			MoveToEx(_hdc, xStart, yStart, NULL);
			if(_bUnderlineType == CFU_UNDERLINEWAVE)
			{
				LONG dy	= 1;					// Vertical displacement
				LONG x	= xStart + 1;			// x coordinate
				right++;						// Round up rightmost x
				for( ; x < right; dy = -dy, x += 2)
					LineTo(_hdc, x, yStart + dy);
			}
			else
				LineTo(_hdc, right, yStart);

			if(hPenOld)							// Restore original pen.
				SelectPen(_hdc, hPenOld);

			DeleteObject(hPen);
		}
	}
}

/*
 *	CRenderer::RenderStrikeOut(xStart, yStart, xWidth, yThickness)
 *
 *	@mfunc
 *		Render strikeout
 */
void CRenderer::RenderStrikeOut(
	LONG xStart, 		//@parm Horizontal start of strikeout
	LONG yStart,		//@parm Vertical start of strikeout
	LONG xLength,		//@parm Length of strikeout
	LONG yThickness)	//@parm Thickness of strikeout
{
	RECT rcT;

	// Calculate where to put strikeout rectangle 
	rcT.top		= yStart;
	rcT.bottom	= yStart + yThickness;
	rcT.left	= xStart;
	rcT.right	= xStart + xLength;
	FillRectWithColor(&rcT, GetTextColor(GetCF()));
}

/*
 *	CRenderer::FillRectWithTextColor(prc)
 *
 *	@mfunc
 *		Fill input rectangle with current color of text
 */
void CRenderer::FillRectWithColor(
	RECT *	 prc,		//@parm Rectangle to fill with color
	COLORREF cr)		//@parm Color to use
{
	// Create a brush with the text color
	HBRUSH hbrush = CreateSolidBrush(_fDisabled ? _crForeDisabled : cr);

	// Note if the CreateSolidBrush fails we just ignore it since there
	// isn't anything we can do about it anyway.
	if(hbrush)
	{
		// Save old brush
		HBRUSH hbrushOld = (HBRUSH)SelectObject(_hdc, hbrush);

		// Fill rectangle for underline
		PatBlt(_hdc, prc->left, prc->top, prc->right - prc->left,
			   prc->bottom - prc->top, PATCOPY);
		SelectObject(_hdc, hbrushOld);	// Put old brush back
		DeleteObject(hbrush);			// Free brush we created.
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\rtflog.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	RTFLOG.CPP - RichEdit RTF log
 *
 *		Contains the code for the RTFLog class which can be used 
 *		to log the number of times RTF tags are read by the RTF reader
 *		for use in coverage testing
 *
 *	Authors:<nl>
 *		Created for RichEdit 2.0:	Brad Olenick
 *
 *	Copyright (c) 1995-1996, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_rtflog.h"
#include "tokens.h"

extern INT cKeywords;
extern const KEYWORD rgKeyword[];

/*
 *	CRTFLog::CRTFLog()
 *	
 *	@mfunc
 *		Constructor - 
 *			1.  Opens a file mapping to log hit counts, creating
 *					the backing file if neccessary
 *			2.  Map a view of the file mapping into memory
 *			3.  Register a windows message for change notifications
 *
 */
CRTFLog::CRTFLog() : _rgdwHits(NULL), _hfm(NULL), _hfile(NULL)
{
#ifndef PEGASUS
	const char cstrMappingName[] = "RTFLOG";
	const char cstrWM[] = "RTFLOGWM";
	const int cbMappingSize = sizeof(ELEMENT) * ISize();

	BOOL fNewFile = FALSE;

	// check for existing file mapping
	if(!(_hfm = OpenFileMappingA(FILE_MAP_ALL_ACCESS,
								TRUE,
								cstrMappingName)))
	{
		// no existing file mapping

		// get the file with which to create the file mapping

		// first, attempt to open an existing file
		if(!(_hfile = CreateFileA(LpcstrLogFilename(),
								GENERIC_READ | GENERIC_WRITE,
								0,
								NULL,
								OPEN_EXISTING,
								FILE_ATTRIBUTE_NORMAL,
								NULL)))
		{
			// no existing file, attempt to create new
			if(!(_hfile = CreateFileA(LpcstrLogFilename(),
										GENERIC_READ | GENERIC_WRITE,
										0,
										NULL,
										OPEN_ALWAYS,
										FILE_ATTRIBUTE_NORMAL,
										NULL)))
			{
				return;
			}

			fNewFile = TRUE;
		}

		if(!(_hfm = CreateFileMappingA(_hfile,
									NULL,
									PAGE_READWRITE,
									0,
									cbMappingSize,
									cstrMappingName)))
		{
			return;
		}
	}

	LPVOID lpv;
	if(!(lpv = MapViewOfFile(_hfm, 
							FILE_MAP_ALL_ACCESS, 
							0,
							0,
							cbMappingSize)))
	{
		return;
	}

	// register windows message for change notifications
	SideAssert(_uMsg = RegisterWindowMessageA(cstrWM));

	// memory-mapped file is now mapped to _rgdwHits
	_rgdwHits = (PELEMENT)lpv;

	// zero the memory-mapped file if we created it new
	// (Win95 gives us a new file w/ garbage in it for some reason)
	if(fNewFile)
	{
		Reset();
	}		
#endif	
}


/*
 *	CRTFLog::Reset()
 *	
 *	@mfunc
 *		Resets the hitcount of each element in the log to 0
 *
 */
void CRTFLog::Reset()
{
	if(!FInit())
	{
		return;
	}

	for(INDEX i = 0; i < ISize(); i++)
	{
		(*this)[i] = 0;
	}

	// notify clients of change
	ChangeNotifyAll();
}


/*
 *	CRTFLog::UGetWindowMsg
 *
 *	@mdesc
 *		Returns the window message id used for change notifications
 *
 *	@rdesc
 *		UINT		window message id
 *
 *	@devnote
 *		This should be inline, but the AssertSz macro doesn't compile
 *		properly on the Mac if its placed in a header file
 *
 */
UINT CRTFLog::UGetWindowMsg() const
{
	AssertSz(FInit(), "CRTFLog::UGetWindowMsg():  CRTFLog not initialized properly");

	return _uMsg;
}


/*
 *	CRTFLog::operator[]
 *
 *	@mdesc
 *		Returns reference to element i of RTF log (l-value)
 *
 *	@rdesc
 *		ELEMENT &			reference to element i of log
 *
 *	@devnote
 *		This should be inline, but the AssertSz macro doesn't compile
 *		properly on the Mac if its placed in a header file
 *
 */
CRTFLog::ELEMENT &CRTFLog::operator[](INDEX i)
{
	AssertSz(i < ISize(), "CRTFLog::operator[]:  index out of range");
	AssertSz(FInit(), "CRTFLog::operator[]:  CRTFLog not initialized properly");

	return _rgdwHits[i]; 
}


/*
 *	CRTFLog::operator[]
 *
 *	@mdesc
 *		Returns reference to element i of RTF log (r-value)
 *
 *	@rdesc
 *		const ELEMENT &	reference to element i of log
 *		
 *	@devnote
 *		This should be inline, but the AssertSz macro doesn't compile
 *		properly on the Mac if its placed in a header file
 *
 */
const CRTFLog::ELEMENT &CRTFLog::operator[](INDEX i) const
{
	AssertSz(i < ISize(), "CRTFLog::operator[]:  index out of range");
	AssertSz(FInit(), "CRTFLog::operator[]:  CRTFLog not initialized properly");

	return _rgdwHits[i]; 
}


/*
 *	CRTFLog::LpcstrLogFilename()
 *	
 *	@mfunc
 *		Returns name of file to be used for log
 *
 *	@rdesc
 *		LPCSTR		pointer to static buffer containing file name
 */
LPCSTR CRTFLog::LpcstrLogFilename() const
{
	const char cstrLogFilename[] = "RTFLOG";
	static char szBuf[MAX_PATH] = "";
#ifndef PEGASUS
	if(!szBuf[0])
	{
		DWORD cchLength;
		char szBuf2[MAX_PATH];

		SideAssert(cchLength = GetTempPathA(MAX_PATH, szBuf2));

		// append trailing backslash if neccessary
		if(szBuf2[cchLength - 1] != '\\')
		{
			szBuf2[cchLength] = '\\';
			szBuf2[cchLength + 1] = 0;
		}

		wsprintfA(szBuf, "%s%s", szBuf2, cstrLogFilename);
	}
#endif
	return szBuf;
}


/*
 *	CRTFLog::IIndexOfKeyword(LPCSTR lpcstrKeyword, PINDEX piIndex)
 *	
 *	@mfunc
 *		Returns the index of the log element which corresponds to
 *		the RTF keyword, lpcstrKeyword
 *
 *	@rdesc
 *		BOOL		flag indicating whether index was found
 */
BOOL CRTFLog::IIndexOfKeyword(LPCSTR lpcstrKeyword, PINDEX piIndex) const
{
	INDEX i;

	for(i = 0; i < ISize(); i++)
	{
		if(strcmp(lpcstrKeyword, rgKeyword[i].szKeyword) == 0)
		{
			break;
		}
	}

	if(i == ISize())
	{
		return FALSE;
	}

	if(piIndex)
	{
		*piIndex = i;
	}

	return TRUE;
}


/*
 *	CRTFLog::IIndexOfToken(TOKEN token, PINDEX piIndex)
 *	
 *	@mfunc
 *		Returns the index of the log element which corresponds to
 *		the RTF token, token
 *
 *	@rdesc
 *		BOOL		flag indicating whether index was found
 */
BOOL CRTFLog::IIndexOfToken(TOKEN token, PINDEX piIndex) const
{
	INDEX i;

	for(i = 0; i < ISize(); i++)
	{
		if(token == rgKeyword[i].token)
		{
			break;
		}
	}

	if(i == ISize())
	{
		return FALSE;
	}

	if(piIndex)
	{
		*piIndex = i;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\rtfread.cpp ===
/*
 *  @doc INTERNAL
 *
 *  @module RTFREAD.CPP - RichEdit RTF reader (w/o objects) |
 *
 *      This file contains the nonobject code of RichEdit RTF reader.
 *      See rtfread2.cpp for embedded-object code.
 *
 *  Authors:<nl>
 *      Original RichEdit 1.0 RTF converter: Anthony Francisco <nl>
 *      Conversion to C++ and RichEdit 2.0 w/o objects:  Murray Sargent
 *      Lots of enhancements/maintenance: Brad Olenick
 *
 *  @devnote
 *      All sz's in the RTF*.? files refer to a LPSTRs, not LPTSTRs, unless
 *      noted as a szW.
 *
 *  @todo
 *      1. Unrecognized RTF. Also some recognized won't round trip <nl>
 *      2. In font.c, add overstrike for CFE_DELETED and underscore for
 *          CFE_REVISED.  Would also be good to change color for CF.bRevAuthor
 *
 *  Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_rtfread.h"
#include "_util.h"
#include "_font.h"
#include "_disp.h"

ASSERTDATA

/*
 *      Global Variables
 */

#define PFM_ALLRTF      (PFM_ALL2 | PFM_COLLAPSED | PFM_OUTLINELEVEL | PFM_BOX)

// for object attachment placeholder list
#define cobPosInitial 8
#define cobPosChunk 8

#if CFE_SMALLCAPS != 0x40 || CFE_ALLCAPS != 0x80 || CFE_HIDDEN != 0x100 \
 || CFE_OUTLINE != 0x200  || CFE_SHADOW != 0x400
#error "Need to change RTF char effect conversion routines
#endif

// for RTF tag coverage testing
#if defined(DEBUG)
#define TESTPARSERCOVERAGE() \
    { \
        if(GetProfileIntA("RICHEDIT DEBUG", "RTFCOVERAGE", 0)) \
        { \
            TestParserCoverage(); \
        } \
    }
#define PARSERCOVERAGE_CASE() \
    { \
        if(_fTestingParserCoverage) \
        { \
            return ecNoError; \
        } \
    }
#define PARSERCOVERAGE_DEFAULT() \
    { \
        if(_fTestingParserCoverage) \
        { \
            return ecStackOverflow; /* some bogus error */ \
        } \
    }
#else
#define TESTPARSERCOVERAGE()
#define PARSERCOVERAGE_CASE()
#define PARSERCOVERAGE_DEFAULT()
#endif


// FF's should not have paragraph number prepended to them
inline BOOL CharGetsNumbering(WORD ch) { return ch != FF; }

// V-GUYB: PWord Converter requires loss notification.
#ifdef REPORT_LOSSAGE
typedef struct
{
    IStream *pstm;
    BOOL     bFirstCallback;
    LPVOID  *ppwdPWData;
    BOOL     bLoss;
} LOST_COOKIE;
#endif


//======================== OLESTREAM functions =======================================

DWORD CALLBACK RTFGetFromStream (
    RTFREADOLESTREAM *OLEStream,    //@parm OleStream
    void FAR *        pvBuffer,     //@parm Buffer to read
    DWORD             cb)           //@parm Bytes to read
{
    return OLEStream->Reader->ReadData ((BYTE *)pvBuffer, cb);
}

DWORD CALLBACK RTFGetBinaryDataFromStream (
    RTFREADOLESTREAM *OLEStream,    //@parm OleStream
    void FAR *        pvBuffer,     //@parm Buffer to read
    DWORD             cb)           //@parm Bytes to read
{
    return OLEStream->Reader->ReadBinaryData ((BYTE *)pvBuffer, cb);
}


//============================ STATE Structure =================================
/*
 *  STATE::AddPF(PF, lDefTab, lDocType)
 *
 *  @mfunc
 *      If the PF contains new info, this info is applied to the PF for the
 *      state.  If this state was sharing a PF with a previous state, a new
 *      PF is created for the state, and the new info is applied to it.
 *
 *  @rdesc
 *      TRUE unless needed new PF and couldn't allocate it
 */
BOOL STATE::AddPF(
    const CParaFormat &PF,  //@parm Current RTFRead _PF
    LONG lDocType,          //@parm Default doc type to use if no prev state
    DWORD dwMask)           //@parm Mask to use
{
    // Create a new PF if:
    //  1.  The state doesn't have one yet
    //  2.  The state has one, but it is shared by the previous state and
    //      there are PF deltas to apply to the state's PF
    if(!pPF || dwMask && pstatePrev && pPF == pstatePrev->pPF)
    {
        Assert(!pstatePrev || pPF);

        pPF = new CParaFormat;
        if(!pPF)
            return FALSE;

        // Give the new PF some initial values - either from the previous
        // state's PF or by CParaFormat initialization
        if(pstatePrev)
        {
            // Copy the PF from the previous state
            *pPF = *pstatePrev->pPF;
            dwMaskPF = pstatePrev->dwMaskPF;
        }
        else
        {
            // We've just created a new PF for the state - there is no
            // previous state to copy from.  Use default values.
            pPF->InitDefault(lDocType == DT_RTLDOC ? PFE_RTLPARA : 0);
            dwMaskPF = PFM_ALLRTF;
        }
    }

    // Apply the new PF deltas to the state's PF
    if(dwMask)
    {
        if(dwMask & PFM_TABSTOPS)               // Don't change _iTabs here
        {
            pPF->_bTabCount = PF._bTabCount;
            dwMask &= ~PFM_TABSTOPS;
        }
        pPF->Apply(&PF, dwMask);
    }

    return TRUE;
}

/*
 *  STATE::DeletePF()
 *
 *  @mfunc
 *      If the state's PF is not shared by the previous state, the PF for this
 *      state is deleted.
 */
void STATE::DeletePF()
{
    if(pPF && (!pstatePrev || pPF != pstatePrev->pPF))
        delete pPF;

    pPF = NULL;
}

/*
 *  STATE::SetCodePage(CodePage)
 *
 *  @mfunc
 *      If current nCodePage is CP_UTF8, use it for all conversions (yes, even
 *      for SYMBOL_CHARSET). Else use CodePage.
 */
void STATE::SetCodePage(
    LONG CodePage)
{
    if(nCodePage != CP_UTF8)
        nCodePage = CodePage;
}

//============================ CRTFRead Class ==================================
/*
 *  CRTFRead::CRTFRead(prg, pes, dwFlags)
 *
 *  @mfunc
 *      Constructor for RTF reader
 */
CRTFRead::CRTFRead (
    CTxtRange *     prg,            //@parm CTxtRange to read into
    EDITSTREAM *    pes,            //@parm Edit stream to read from
    DWORD           dwFlags         //@parm Read flags
)
    : CRTFConverter(prg, pes, dwFlags, TRUE)
{
    TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::CRTFRead");

    Assert(prg->GetCch() == 0);

    //TODO(BradO):  We should examine the member data in the constructor
    //  and determine which data we want initialized on construction and
    //  which at the beginning of every read (in CRTFRead::ReadRtf()).

    _sDefaultFont       = -1;               // No \deff n control word yet
    _sDefaultLanguage   = INVALID_LANGUAGE;
    _sDefaultLanguageFE = INVALID_LANGUAGE;
    _sDefaultTabWidth   = 0;
    _sDefaultBiDiFont   = -1;
    _dwMaskCF           = 0;                // No char format changes yet
    _dwMaskCF2          = 0;
    _nFieldCodePage     = 0;
    _ptfField           = NULL;
    _fRestoreFieldFormat= FALSE;
    _fSeenFontTable     = FALSE;            // No \fonttbl yet
    _fCharSet           = FALSE;            // No \fcharset yet
    _dwFlagsUnion       = 0;                // No flags yet
    _pes->dwError       = 0;                // No error yet
    _cchUsedNumText     = 0;                // No numbering text yet
    _cCell              = 0;                // No table cells yet
    _iCell              = 0;
    _cTab               = 0;
    _pstateStackTop     = NULL;
    _pstateLast         = NULL;
    _szText             =
    _pchRTFBuffer       =                   // No input buffer yet
    _pchRTFCurrent      =
    _szSymbolFieldResult=
    _pchRTFEnd          = NULL;
    _prtfObject         = NULL;
    _pcpObPos           = NULL;
    _bTabLeader         = 0;
    _bTabType           = 0;
    _pobj               = 0;
    _bAlignment         = PFA_LEFT;
    _cbSkipForUnicode   = 0;

    _fHyperlinkField    = FALSE;
    _szHyperlinkFldinst = NULL;
    _szHyperlinkFldrslt = NULL;

    // Does story size exceed the maximum text size? Be very careful to
    // use unsigned comparisons here since _cchMax has to be unsigned
    // (EM_LIMITTEXT allows 0xFFFFFFFF to be a large positive maximum
    // value). I.e., don't use signed arithmetic.
    DWORD cchAdj = _ped->GetAdjustedTextLength();
    _cchMax = _ped->TxGetMaxLength();

    if(_cchMax > cchAdj)
        _cchMax = _cchMax - cchAdj;         // Room left
    else
        _cchMax = 0;                        // No room left

    ZeroMemory(_rgStyles, sizeof(_rgStyles)); // No style levels yet

    _bBiDiCharSet = 0;
    if(_ped->IsBiDi())
    {
        _bBiDiCharSet = ARABIC_CHARSET;     // Default Arabic charset

        BYTE          bCharSet;
        CFormatRunPtr rpCF(prg->_rpCF);

        // Look backward in text, trying to find a RTL CharSet.
        // NB: \fN with an RTL charset updates _bBiDiCharSet.
        do
        {
            bCharSet = _ped->GetCharFormat(rpCF.GetFormat())->_bCharSet;
            if(IsRTLCharSet(bCharSet))
            {
                _bBiDiCharSet = bCharSet;
                break;
            }
        } while (rpCF.PrevRun());
    }
    
    // Initialize OleStream
    RTFReadOLEStream.Reader = this;
    RTFReadOLEStream.lpstbl->Get = (DWORD (CALLBACK*)(LPOLESTREAM, void *, DWORD))
                               RTFGetFromStream;
    RTFReadOLEStream.lpstbl->Put = NULL;

#ifdef DEBUG

// TODO: Implement RTF tag logging for the Mac
#if !defined(MACPORT)
    _fTestingParserCoverage = FALSE;
    _prtflg = NULL;

    if(GetProfileIntA("RICHEDIT DEBUG", "RTFLOG", 0))
    {
        _prtflg = new CRTFLog;
        if(_prtflg && !_prtflg->FInit())
        {
            delete _prtflg;
            _prtflg = NULL;
        }
        AssertSz(_prtflg, "CRTFRead::CRTFRead:  Error creating RTF log");
    }
#endif
#endif // DEBUG
}

/*
 *  CRTFRead::HandleStartGroup()
 *  
 *  @mfunc
 *      Handle start of new group. Alloc and push new state onto state
 *      stack
 *
 *  @rdesc
 *      EC                  The error code
 */
EC CRTFRead::HandleStartGroup()
{
    TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::HandleStartGroup");

    STATE * pstate     = _pstateStackTop;
    STATE * pstateNext = NULL;

    if(pstate)                                  // At least one STATE already
    {                                           //  allocated
        Apply_CF();                             // Apply any collected char
        // Note (igorzv) we don't Apply_PF() here so as not to change para
        // properties before we run into \par i.e. not to use paragraph
        // properties if we copy only one word from paragraph. We can use an
        // assertion here that neither we nor Word use end of group for
        // restoring paragraph properties. So everything will be OK with stack
        pstate->iCF = (SHORT)_prg->Get_iCF();   // Save current CF
        pstate = pstate->pstateNext;            // Use previously allocated
        if(pstate)                              //  STATE frame if it exists
            pstateNext = pstate->pstateNext;    // It does; save its forward
    }                                           //  link for restoration below

    if(!pstate)                                 // No new STATE yet: alloc one
    {
        pstate = new STATE(IsUTF8 ? CP_UTF8 : _nCodePage);
        if(!pstate)                             // Couldn't alloc new STATE
            goto memerror;

        _pstateLast = pstate;                   // Update ptr to last STATE
    }                                           //  alloc'd

    STATE *pstateGetsPF;

    // Apply the accumulated PF delta's to the old current state or, if there
    //  is no current state, to the newly created state.
    pstateGetsPF = _pstateStackTop ? _pstateStackTop : pstate;
    if(!pstateGetsPF->AddPF(_PF, _bDocType, _dwMaskPF))
        goto memerror;

    _dwMaskPF = 0;       // _PF contains delta's from *_pstateStackTop->pPF

    if(_pstateStackTop)                         // There's a previous STATE
    {
        *pstate = *_pstateStackTop;             // Copy current state info
        // N.B.  This will cause the current and previous state to share
        //  the same PF.  PF delta's are accumulated in _PF.  A new PF
        //  is created for _pstateStackTop when the _PF deltas are applied.

        _pstateStackTop->pstateNext = pstate;
    }

    pstate->pstatePrev = _pstateStackTop;       // Link STATEs both ways
    pstate->pstateNext = pstateNext;
    _pstateStackTop = pstate;                   // Push stack

done:
    TRACEERRSZSC("HandleStartGroup()", -_ecParseError);
    return _ecParseError;

memerror:
    _ped->GetCallMgr()->SetOutOfMemory();
    _ecParseError = ecStackOverflow;
    goto done;
}

/*
 *  CRTFRead::HandleEndGroup()
 *
 *  @mfunc
 *      Handle end of new group
 *
 *  @rdesc
 *      EC                  The error code
 */
EC CRTFRead::HandleEndGroup()
{
    TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::HandleEndGroup");

    STATE * pstate = _pstateStackTop;
    STATE * pstatePrev;

    Assert(_PF._iTabs == -1);

    if(!pstate)                                 // No stack to pop
    {
        _ecParseError = ecStackUnderflow;
        goto done;
    }

    _pstateStackTop =                           // Pop stack
    pstatePrev      = pstate->pstatePrev;

    if(!pstatePrev)
    {
        Assert(pstate->pPF);

        // We're ending the parse.  Copy the final PF into _PF so that
        // subsequent calls to Apply_PF will have a PF to apply.
        _PF = *pstate->pPF;
        _dwMaskPF = pstate->dwMaskPF;

        _PF._iTabs = -1;                        // Force recache
        _PF._wEffects &= ~PFE_TABLE;
    }

    // Adjust the PF for the new _pstateStackTop and delete unused PF's.
    if(pstate->sDest == destParaNumbering || pstate->sDest == destParaNumText)
    {
        if(pstatePrev && pstate->pPF != pstatePrev->pPF)
        {
            // Bleed the PF of the current state into the previous state for
            // paragraph numbering groups
            Assert(pstatePrev->pPF);
            pstatePrev->DeletePF();
            pstatePrev->pPF = pstate->pPF;
            pstate->pPF = NULL;
        }
        else
            pstate->DeletePF();
        // N.B.  Here, we retain the _PF diffs since they apply to the
        // enclosing group along with the PF of the group we are leaving
    }
    else
    {
        // We're popping the state, so delete its PF and discard the _PF diffs
        Assert(pstate->pPF);
        pstate->DeletePF();

        // If !pstatePrev, we're ending the parse, in which case the _PF
        // structure contains final PF (so don't toast it).
        if(pstatePrev)
            _dwMaskPF = 0;
    }

    if(pstatePrev)
    {
        _dwMaskCF = 0;                          // Discard any CF deltas
        _dwMaskCF2 = 0;

        switch(pstate->sDest)
        {
            case destParaNumbering:
                // {\pn ...}
                pstatePrev->sIndentNumbering = pstate->sIndentNumbering;
                pstatePrev->fBullet = pstate->fBullet;
                break;

            case destObject:
                // clear our object flags just in case we have corrupt RTF
                if(_fNeedPres)
                {
                    _fNeedPres = FALSE;
                    _fNeedIcon = FALSE;
                    _pobj = NULL;
                }
                break;

            case destFontTable:
                if(pstatePrev->sDest == destFontTable)
                {
                    // We're actually leaving a sub-group within the \fonttbl
                    // group.
                    break;
                }

                // We're leaving the {\fonttbl...} group.
                _fSeenFontTable = TRUE;

                // Default font should now be defined, so select it (this
                // creates CF deltas).
                SetPlain(pstate);

                // Ensure that a document-level codepage has been determined and
                // then scan the font names and retry the conversion to Unicode,
                // if necessary.

                if(_nCodePage == INVALID_CODEPAGE)
                {
                    // We haven't determined a document-level codepage
                    // from the \ansicpgN tag, nor from the font table
                    // \fcharsetN and \cpgN values.  As a last resort,
                    // let's use the \deflangN and \deflangfeN tags

                    LANGID langid;

                    if(_sDefaultLanguageFE != INVALID_LANGUAGE)
                        langid = _sDefaultLanguageFE;

                    else if(_sDefaultLanguage != INVALID_LANGUAGE &&
                            _sDefaultLanguage != sLanguageEnglishUS)
                    {
                        // _sDefaultLanguage == sLanguageEnglishUS is inreliable
                        // in the absence of \deflangfeN.  Many FE RTF writers
                        // write \deflang1033 (sLanguageEnglishUS).

                        langid = _sDefaultLanguage;
                    }
                    else if(_dwFlags & SFF_SELECTION)
                    {
                        // For copy/paste case, if nothing available, try the system
                        // default langid.  This is to fix FE Excel95 problem.      
                        langid = GetSystemDefaultLangID();
                    }
                    else
                        goto NoLanguageInfo;

                    _nCodePage = ConvertLanguageIDtoCodePage(langid);
                }

NoLanguageInfo:
                if(_nCodePage == INVALID_CODEPAGE)
                    break;

                // Fixup mis-converted font face names

                TEXTFONT *ptf;
                LONG i;

                for(i = 0; i < _fonts.Count(); i++)
                {
                    ptf = _fonts.Elem(i);

                    if (ptf->sCodePage == INVALID_CODEPAGE ||
                        ptf->sCodePage == CP_SYMBOL)
                    {
                        if(ptf->fNameIsDBCS)
                        {
                            char szaTemp[LF_FACESIZE];
                            BOOL fMissingCodePage;

                            // Un-convert mis-converted face name
                            SideAssert(WCTMB(ptf->sCodePage, 0,
                                                ptf->szName, -1,
                                                szaTemp, sizeof(szaTemp),
                                                NULL, NULL, &fMissingCodePage) > 0);
                            Assert(ptf->sCodePage == CP_SYMBOL ||
                                        fMissingCodePage);

                            // re-convert face name using new codepage info
                            SideAssert(MBTWC(_nCodePage, 0,
                                        szaTemp, -1,
                                        ptf->szName, sizeof(ptf->szName),
                                        &fMissingCodePage) > 0);

                            if(!fMissingCodePage)
                                ptf->fNameIsDBCS = FALSE;
                        }
                    }
                }
                break;

            default:;
                // nothing
        }
        _prg->Set_iCF(pstatePrev->iCF);         // Restore previous CharFormat
        ReleaseFormats(pstatePrev->iCF, -1);
    }

done:
    TRACEERRSZSC("HandleEndGroup()", - _ecParseError);
    return _ecParseError;
}
/*
 *  CRTFRead::HandleFieldEndGroup()
 *
 *  @mfunc
 *      Handle end of \field
 *
 */
void CRTFRead::HandleFieldEndGroup()
{
    STATE * pstate  = _pstateStackTop;

    if(pstate->sDest == destField)
    {
        // for SYMBOLS
        if(!_fHyperlinkField)
        {
            if(_szSymbolFieldResult)     // There is a new field result
            {
                if(_fRestoreFieldFormat)
                {
                    _fRestoreFieldFormat = FALSE;
                    _CF = _FieldCF;
                    pstate->ptf = _ptfField;
                    pstate->SetCodePage(_nFieldCodePage);
                    _dwMaskCF = _dwMaskFieldCF;
                    _dwMaskCF2 = _dwMaskFieldCF2;
                }
                HandleText(_szSymbolFieldResult, CONTAINS_NONASCII);
                FreePv(_szSymbolFieldResult);
                _szSymbolFieldResult =NULL;
            }
        }
        else if(pstate->pstateNext)
        {
            // Setup formatting for the field result
            _CF = _FieldCF;
            pstate->ptf = _ptfField;
            pstate->SetCodePage(_nFieldCodePage);
            _dwMaskCF = _dwMaskFieldCF;
            _dwMaskCF2 = _dwMaskFieldCF2;

            // for HYPERLINK
            if(_szHyperlinkFldrslt || _szHyperlinkFldinst)
            {
                // We have the final hyperlink fldrslt string.
                // Check if it is the same as the friendly name
        
                if (_szHyperlinkFldrslt && _szHyperlinkFldinst &&
                    _szHyperlinkFldinst[1] == '<' &&
                    !CompareMemory(
                        (char*)_szHyperlinkFldrslt,
                        (char*)&_szHyperlinkFldinst[2],
                        _cchHyperlinkFldrsltUsed - 1))
                {
                    // They are the same, only need to output friendly name
                    HandleText(&_szHyperlinkFldinst[1], CONTAINS_NONASCII, _cchHyperlinkFldinstUsed);                       
                }
                else
                {
                    // Output result string
                    if(_szHyperlinkFldrslt)
                        HandleText(_szHyperlinkFldrslt, CONTAINS_NONASCII, _cchHyperlinkFldrsltUsed);

                    // Output friendly name
                    if(_szHyperlinkFldinst)
                        HandleText(_szHyperlinkFldinst, CONTAINS_NONASCII, _cchHyperlinkFldinstUsed);
                }
                
                FreePv(_szHyperlinkFldinst);
                FreePv(_szHyperlinkFldrslt);
                _szHyperlinkFldinst = NULL;
                _szHyperlinkFldrslt = NULL;
                _fHyperlinkField = FALSE;
            }
        }
    }
    else if(pstate->sDest == destFieldResult && _fHyperlinkField)
    {
        // Save the current formatting for the field result if dwMask is valid.
        // NOTE: HandleEndGroup will zero out _dwMaskCF
        if(_dwMaskCF)
        {
            // We should use FE charset in case of mixed of FE and non-FE in the url
            // Also, only use codepage other than English in case of a mixed of English
            // and non-English (e.g. English and Russian )
            if (!IsFECharSet(_FieldCF._bCharSet) && IsFECharSet(_CF._bCharSet)  ||
                _nFieldCodePage != pstate->nCodePage && _nFieldCodePage == 1252 ||
                _FieldCF._bCharSet == _CF._bCharSet && _nFieldCodePage == pstate->nCodePage)
            {
                _FieldCF = _CF;
                _ptfField = pstate->ptf;
                _nFieldCodePage = pstate->nCodePage;
                _dwMaskFieldCF = _dwMaskCF;
                _dwMaskFieldCF2 = _dwMaskCF2;
            }
        }
    }
}

/*
 *  CRTFRead::SelectCurrentFont(iFont)
 *
 *  @mfunc
 *      Set active font to that with index <p iFont>. Take into account
 *      bad font numbers.
 */
void CRTFRead::SelectCurrentFont(
    INT iFont)                  //@parm font handle of font to select
{
    TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::SelectCurrentFont");

    LONG        i       = _fonts.Count();
    STATE *     pstate  = _pstateStackTop;
    TEXTFONT *  ptf     = _fonts.Elem(0);

    AssertSz(i, "CRTFRead::SelectCurrentFont: bad font collection");
    
    for(; i-- && iFont != ptf->sHandle; ptf++)  // Search for font with handle
        ;                                       //  iFont

    // Font handle not found: use default, which is valid
    //  since \rtf copied _prg's
    if(i < 0)                                   
        ptf = _fonts.Elem(0);
                                                
    BOOL fDefFontFromSystem = (i == (LONG)_fonts.Count() - 1 || i < 0) &&
                                !_fReadDefFont;

    _CF._iFont      = GetFontNameIndex(ptf->szName);
    _dwMaskCF2      |=  CFM2_FACENAMEISDBCS;
    _CF._dwEffects  &= ~CFE_FACENAMEISDBCS;
    if(ptf->fNameIsDBCS)
        _CF._dwEffects |= CFE_FACENAMEISDBCS;

    if(pstate->sDest != destFontTable)
    {
        _CF._bCharSet           = ptf->bCharSet;
        _CF._bPitchAndFamily    = ptf->bPitchAndFamily;
        _dwMaskCF               |= CFM_FACE | CFM_CHARSET;  
        
        if (IsRTLCharSet(_CF._bCharSet) && ptf->sCodePage == 1252)
            ptf->sCodePage = (SHORT)GetCodePage(_CF._bCharSet); // Fix sCodePage to match charset
    }

	if (_ped->Get10Mode() && !_fSeenFontTable 
		&& _nCodePage == INVALID_CODEPAGE && ptf->sCodePage == 1252)
	{
		if (W32->IsFECodePage(GetACP()))
			_nCodePage = GetACP();
	}

    // Ensure that the state's codepage is not supplied by the system.
    // That is, if we are using the codepage info from the default font,
    // be sure that the default font info was read from the RTF file.
    pstate->SetCodePage((fDefFontFromSystem && _nCodePage != INVALID_CODEPAGE) ||
        ptf->sCodePage == INVALID_CODEPAGE
                        ? _nCodePage : ptf->sCodePage);
    pstate->ptf = ptf;

#ifdef CHICAGO
    // Win95c 1719: try to match a language to the char set when RTF
    //              doesn't explicitly set a language

    if (!pstate->fExplicitLang && ptf->bCharSet != ANSI_CHARSET &&
        (!pstate->sLanguage || pstate->sLanguage == sLanguageEnglishUS))
    {
        i = AttIkliFromCharset(_ped, ptf->bCharSet);
        if(i >= 0)
            pstate->sLanguage = LOWORD(rgkli[i].hkl);
    }
#endif  // CHICAGO
}

/*
 *  CRTFRead::SetPlain(pstate)
 *
 *  @mfunc
 *      Setup _CF for \plain
 */
void CRTFRead::SetPlain(
    STATE *pstate)
{
    ZeroMemory(&_CF, sizeof(CCharFormat));

    _dwMaskCF    = CFM_ALL2;
    if(_dwFlags & SFF_SELECTION && _prg->GetCp() == _cpFirst && !_fCharSet)
    {
        // Let NT 4.0 CharMap use insertion point size
        _CF._yHeight = _ped->GetCharFormat(_prg->Get_iFormat())->_yHeight;
    }
    else
        _CF._yHeight = PointsToFontHeight(yDefaultFontSize);

    _CF._dwEffects  = CFE_AUTOCOLOR | CFE_AUTOBACKCOLOR; // Set default effects
    if(_sDefaultLanguage == INVALID_LANGUAGE)
        _dwMaskCF &= ~CFM_LCID;
    else
        _CF._lcid = MAKELCID((WORD)_sDefaultLanguage, SORT_DEFAULT);

    _CF._bUnderlineType = CFU_UNDERLINE;
    SelectCurrentFont(_sDefaultFont);

    // TODO: get rid of pstate->sLanguage, since CHARFORMAT2 has lcid
    pstate->sLanguage     = _sDefaultLanguage;
    pstate->fExplicitLang = FALSE;
}

/*
 *  CRTFRead::ReadFontName(pstate, iAllASCII)
 *
 *  @mfunc
 *      read font name _szText into <p pstate>->ptf->szName and deal with
 *      tagged fonts
 */
void CRTFRead::ReadFontName(
    STATE * pstate,         //@parm state whose font name is to be read into
    int iAllASCII)          //@parm indicates that _szText is all ASCII chars
{
    TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::ReadFontName");

    if (pstate->ptf)
    {
        INT     cchName = LF_FACESIZE - 1;
        TCHAR * pchDst = pstate->ptf->szName;
        char  * pachName =  (char *)_szText ;
        
        // Append additional text from _szText to TEXTFONT::szName

        // We need to append here since some RTF writers decide
        // to break up a font name with other RTF groups
        while(*pchDst && cchName > 0)
        {
            pchDst++;
            cchName--;
        }

        INT cchLimit = cchName;
        BOOL    fTaggedName = FALSE;
        while (*pachName &&
               *pachName != ';' &&
               cchLimit)        // Remove semicolons
        {
            pachName++;
            cchLimit--;

            if (*pachName == '(')
                fTaggedName = TRUE;
        }
        *pachName = '\0';

        // Use the codepage of the font in all cases except where the font uses
        // the symbol charset (and the codepage has been mapped from the charset)
        // and UTF-8 isn't being used
        LONG nCodePage = pstate->nCodePage != CP_SYMBOL
                       ? pstate->nCodePage : _nCodePage;

        BOOL fMissingCodePage;
        Assert(!IsUTF8 || nCodePage == CP_UTF8);
        INT cch = MBTWC(nCodePage, 0,
                        (char *)_szText, -1,
                        pchDst, cchName, &fMissingCodePage);

        if(cch > 0 && fMissingCodePage && iAllASCII == CONTAINS_NONASCII)
            pstate->ptf->fNameIsDBCS = TRUE;
        else if(pstate->ptf->bCharSet == DEFAULT_CHARSET &&
                W32->IsFECodePage(nCodePage) &&
                GetTrailBytesCount(*_szText, nCodePage))
            pstate->ptf->bCharSet = GetCharSet(nCodePage);      // Fix up the charset


        // Make sure destination is null terminated
        if(cch > 0)
            pchDst[cch] = 0;

        // Fall through even if MBTWC <= 0, since we may be appending text to an
        // existing font name.

        if(pstate->ptf == _fonts.Elem(0))       // If it's the default font,
            SelectCurrentFont(_sDefaultFont);   //  update _CF accordingly

        TCHAR * szNormalName;

        if(pstate->ptf->bCharSet && pstate->fRealFontName)
        {
            // if we don't know about this font don't use the real name
            if(!FindTaggedFont(pstate->ptf->szName,
                               pstate->ptf->bCharSet, &szNormalName))
            {
                pstate->fRealFontName = FALSE;
                pstate->ptf->szName[0] = 0;
            }
        }
        else if(IsTaggedFont(pstate->ptf->szName,
                            &pstate->ptf->bCharSet, &szNormalName))
        {
            wcscpy(pstate->ptf->szName, szNormalName);
            pstate->ptf->sCodePage = (SHORT)GetCodePage(pstate->ptf->bCharSet);
            pstate->SetCodePage(pstate->ptf->sCodePage);
        }
        else if(fTaggedName && !fMissingCodePage)
        {
            // Fix up tagged name by removing characters after the ' ('
            INT i = 0;
            WCHAR   *pwchTag = pstate->ptf->szName;
            
            while (pwchTag[i] && pwchTag[i] != L'(')    // Search for '('
                i++;

            if(pwchTag[i] && i > 0)
            {               
                while (i > 0 && pwchTag[i-1] == 0x20)   // Remove spaces before the '('
                    i--;
                pwchTag[i] = 0;
            }
        }
    }
}

/*
 *  CRTFRead::GetColor (dwMask)
 *
 *  @mfunc
 *      Store the autocolor or autobackcolor effect bit and return the
 *      COLORREF for color _iParam
 *
 *  @rdesc
 *      COLORREF for color _iParam
 *
 *  @devnote
 *      If the entry in _colors corresponds to tomAutoColor, gets the value
 *      RGB(0,0,0) (since no \red, \green, and \blue fields are used), but
 *      isn't used by the RichEdit engine.  Entry 1 corresponds to the first
 *      explicit entry in the \colortbl and is usually RGB(0,0,0). The _colors
 *      table is built by HandleToken() when it handles the token tokenText
 *      for text consisting of a ';' for a destination destColorTable.
 */
COLORREF CRTFRead::GetColor(
    DWORD dwMask)       //@parm Color mask bit
{
    TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::GetColor");

    if(_iParam >= _colors.Count())              // Illegal _iParam
        return RGB(0,0,0);

    _dwMaskCF     |= dwMask;                    // Turn on appropriate mask bit
    _CF._dwEffects &= ~dwMask;                  // auto(back)color off: color is to be used

    COLORREF Color = *_colors.Elem(_iParam);
    if(Color == tomAutoColor)
    {
        _CF._dwEffects |= dwMask;               // auto(back)color on               
        Color = RGB(0,0,0);
    }       
    return Color;
}

/*
 *  CRTFRead::GetStandardColorIndex ()
 *
 *  @mfunc
 *      Return the color index into the standard 16-entry Word \colortbl
 *      corresponding to the color index _iParam for the current \colortbl
 *
 *  @rdesc
 *      Standard color index corresponding to the color associated with _iParam
 */
LONG CRTFRead::GetStandardColorIndex()
{
    TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::GetColorIndex");

    if(_iParam >= _colors.Count())              // Illegal _iParam:
        return 0;                               //  use autocolor

    COLORREF Color = *_colors.Elem(_iParam);

    for(LONG i = 0; i < 16; i++)
    {
        if(Color == g_Colors[i])
            return i + 1;
    }
    return 0;                                   // Not there: use autocolor
}

/*
 *  CRTFRead::HandleChar(ch)
 *
 *  @mfunc
 *      Handle single Unicode character <p ch>
 *
 *  @rdesc
 *      EC          The error code
 */
EC CRTFRead::HandleChar(
    WCHAR ch)           //@parm char token to be handled
{
    TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::HandleChar");

    if(!_ped->_pdp->IsMultiLine() && IsASCIIEOP(ch))
        _ecParseError = ecTruncateAtCRLF;
    else
    {
        AssertNr(ch <= 0x7F || ch > 0xFF || FTokIsSymbol(ch));
        _dwMaskCF2      |=  CFM2_RUNISDBCS;
        _CF._dwEffects  &= ~CFE_RUNISDBCS;
        AddText(&ch, 1, CharGetsNumbering(ch));
    }

    TRACEERRSZSC("HandleChar()", - _ecParseError);

    return _ecParseError;
}

/*
 *  CRTFRead::HandleEndOfPara()
 *
 *  @mfunc
 *      Insert EOP and apply current paraformat
 *
 *  @rdesc
 *      EC  the error code
 */
EC CRTFRead::HandleEndOfPara()
{
    TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::HandleEndOfPara");

    if(_pstateStackTop->fInTable)           // Our simple table model can't
    {                                       //  have numbering
        _PF._wNumbering = 0;    
        _dwMaskPF |= PFM_NUMBERING;
    }

    if(!_ped->_pdp->IsMultiLine())          // No EOPs permitted in single-
    {                                       //  line controls
        Apply_PF();                         // Apply any paragraph formatting
        _ecParseError = ecTruncateAtCRLF;   // Cause RTF reader to finish up
        return ecTruncateAtCRLF;
    }

    Apply_CF();                             // Apply _CF and save iCF, since
    LONG iFormat = _prg->Get_iCF();         //  it gets changed if processing
                                            //  CFE2_RUNISDBCS chars
    EC ec  = _ped->fUseCRLF()               // If RichEdit 1.0 compatibility
           ? HandleText(szaCRLF, ALL_ASCII) //  mode, use CRLF; else CR or VT
           : HandleChar((unsigned)(_token == tokenLineBreak ? VT :
                                   _token == tokenPage ? FF : CR));
    if(ec == ecNoError)
    {
        Apply_PF();
        _cpThisPara = _prg->GetCp();        // New para starts after CRLF
    }
    _prg->Set_iCF(iFormat);                 // Restore iFormat if changed
    ReleaseFormats(iFormat, -1);            // Release iFormat (AddRef'd by
                                            //  Get_iCF())
    return _ecParseError;
}

/*
 *  CRTFRead::HandleText(szText, iAllASCII)
 *
 *  @mfunc
 *      Handle the string of Unicode characters <p szText>
 *
 *  @rdesc
 *      EC          The error code
 */
EC CRTFRead::HandleText(
    BYTE * szText,          //@parm string to be handled
    int iAllASCII,          //@parm enum indicating if string is all ASCII chars
    LONG    cchText)        //@parm size of szText in bytes
{
    TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::HandleText");

    LONG        cch;
    BOOL        fStateChng = FALSE;
    TCHAR *     pch;
    STATE *     pstate = _pstateStackTop;
    TEXTFONT *  ptf = pstate->ptf;

    struct TEXTFONTSAVE : TEXTFONT
    {
        TEXTFONTSAVE(TEXTFONT *ptf)
        {
            if (ptf)
            {
                bCharSet        = ptf->bCharSet;
                sCodePage       = ptf->sCodePage;
                fCpgFromSystem  = ptf->fCpgFromSystem;
            }
        }
    };

    BOOL fAdjustPtf = FALSE;

    if(pstate->fltrch || pstate->frtlch)
    {
        // CharSet resolution based on directional control words
        if(_CF._bCharSet == DEFAULT_CHARSET)
        {
            _CF._bCharSet = (BYTE)(pstate->fltrch
                         ? ANSI_CHARSET : _bBiDiCharSet);
            _dwMaskCF |= CFM_CHARSET;
            fAdjustPtf = TRUE;
        }
        else
        {
            BOOL fBiDiCharSet = IsRTLCharSet(_CF._bCharSet);

            // If direction token doesn't correspond to current charset
            if(fBiDiCharSet ^ pstate->frtlch)
            {
                _dwMaskCF |= CFM_CHARSET;
                fAdjustPtf = TRUE;
                if(!fBiDiCharSet)               // Wasn't BiDi, but is now
                    SelectCurrentFont(_sDefaultBiDiFont);
                _CF._bCharSet = (BYTE)(pstate->frtlch
                             ? _bBiDiCharSet : ANSI_CHARSET);
            }
            else if (fBiDiCharSet && !W32->IsBiDiCodePage(ptf->sCodePage))
                fAdjustPtf = TRUE;
        }
    }
    else if(_ped->IsBiDi() && _CF._bCharSet == DEFAULT_CHARSET)
    {
        _CF._bCharSet = ANSI_CHARSET;
        _dwMaskCF |= CFM_CHARSET;
        fAdjustPtf = TRUE;
    }
    if (fAdjustPtf && ptf)
    {
        ptf->sCodePage = (SHORT)GetCodePage(_CF._bCharSet);
        pstate->SetCodePage(ptf->sCodePage);
    }

    TEXTFONTSAVE    tfSave(ptf);

    // TODO: what if szText cuts off in middle of DBCS?

    if(!*szText)
        goto CleanUp;

    if (cchText != -1 && _cchUnicode < cchText)
    {
        // Re-allocate a bigger buffer
        _szUnicode = (TCHAR *)PvReAlloc(_szUnicode, (cchText + 1) * sizeof(TCHAR));
        if(!_szUnicode)                 // Re-allocate space for Unicode conversions
        {
            _ped->GetCallMgr()->SetOutOfMemory();
            _ecParseError = ecNoMemory;
            goto CleanUp;
        }
        _cchUnicode = cchText + 1;
    }

    if(iAllASCII == ALL_ASCII || pstate->nCodePage == CP_SYMBOL)
    {
        // Don't use MBTWC() in cases where text contains
        // only ASCII chars (which don't require conversion)
        for(cch = 0, pch = _szUnicode; *szText; cch++)
        {
            Assert(*szText <= 0x7F || _CF._bCharSet == SYMBOL_CHARSET);
            *pch++ = (TCHAR)*szText++;
        }
        *pch = 0;

        _dwMaskCF2      |=  CFM2_RUNISDBCS;
        _CF._dwEffects  &= ~CFE_RUNISDBCS;

        // Fall through to AddText at end of HandleText()
    }
    else
    {
        BOOL      fMissingCodePage;

        // Run of text contains bytes > 0x7F.
        // Ensure that we have the correct codepage with which to interpret
        // these (possibly DBCS) bytes.

        if(ptf && ptf->sCodePage == INVALID_CODEPAGE && !ptf->fCpgFromSystem)
        {
            if(_dwFlags & SF_USECODEPAGE)
            {
                _CF._bCharSet = GetCharSet(_nCodePage);
                _dwMaskCF |= CFM_CHARSET;
            }

            // Determine codepage from the font name
            else if(CpgInfoFromFaceName(pstate->ptf))
            {
                fStateChng     = TRUE;
                SelectCurrentFont(pstate->ptf->sHandle);
                Assert(ptf->sCodePage != INVALID_CODEPAGE);
                Assert(ptf->fCpgFromSystem);
            }
            else
            {
                // Here, we were not able to determine a cpg/charset value
                // from the font name.  We have two choices: (1) either choose
                // some fallback value like 1252/0 or (2) rely on the
                // document-level cpg value.
                //
                // I think choosing the document-level cpg value will give
                // us the best results.  In FE cases, it will likely err
                // on the side of tagging too many runs as CFE2_RUNISDBCS, but
                // that is safer than using a western cpg and potentially missing
                // runs which should be CFE2_RUNISDBCS.
            }
        }

        Assert(!IsUTF8 || pstate->nCodePage == CP_UTF8);

		if (pstate->nCodePage == INVALID_CODEPAGE && _ped->Get10Mode() && ptf)
			pstate->nCodePage = ptf->sCodePage;

        cch = MBTWC(pstate->nCodePage, 0,
                    (char *)szText, -1,
                    _szUnicode, _cchUnicode, &fMissingCodePage);

        AssertSz(cch > 0, "CRTFRead::HandleText():  MBTWC implementation changed"
                            " such that it returned a value <= 0");

        if(!fMissingCodePage || !W32->IsFECodePage(pstate->nCodePage))
        {
            // Use result of MBTWC if:
            //  (1) we converted some chars and did the conversion with the codepage
            //      provided.
            //  (2) we converted some chars but couldn't use the codepage provided,
            //      but the codepage is invalid.  Since the codepage is invalid,
            //      we can't do anything more sophisticated with the text before
            //      adding to the backing store

            cch--;  // don't want char count to including terminating NULL

            _dwMaskCF2      |=  CFM2_RUNISDBCS;
            _CF._dwEffects  &= ~CFE_RUNISDBCS;
            if(pstate->nCodePage == INVALID_CODEPAGE)
                _CF._dwEffects |= CFE_RUNISDBCS;

            // fall through to AddText at end of HandleText()
        }
        else
        {
            // Conversion to Unicode failed.  Break up the string of
            // text into runs of ASCII and non-ASCII characters.

            // FUTURE(BradO):  Here, I am saving dwMask and restoring it before
            //      each AddText.  I'm not sure this is neccessary.  When I have
            //      the time, I should revisit this save/restoring and
            //      determine that it is indeed neccessary.

            BOOL fPrevIsASCII = ((*szText <= 0x7F) ? TRUE : FALSE);
            BOOL fCurrentIsASCII = FALSE;
            BOOL fLastChunk = FALSE;
            DWORD dwMaskSave = _dwMaskCF;
#if defined(DEBUG) || defined(_RELEASE_ASSERTS_)
            CCharFormat CFSave = _CF;
#endif

            pch = _szUnicode;
            cch = 0;

            // (!*szText && *pch) is the case where we do the AddText for the
            //  last chunk of text
            while(*szText || fLastChunk)
            {
                // fCurrentIsASCII assumes that no byte <= 0x7F is a
                //  DBCS lead-byte
                if(fLastChunk ||
                    (fPrevIsASCII != (fCurrentIsASCII = (*szText <= 0x7F))))
                {
                    _dwMaskCF = dwMaskSave;
#if defined(DEBUG) || defined(_RELEASE_ASSERTS_)
                    _CF = CFSave;
#endif
                    *pch = 0;

                    _dwMaskCF2      |= CFM2_RUNISDBCS;
                    _CF._dwEffects  |= CFE_RUNISDBCS;
                    if(fPrevIsASCII)
                        _CF._dwEffects &= ~CFE_RUNISDBCS;

                    Assert(cch);
                    pch = _szUnicode;

                    AddText(pch, cch, TRUE);

                    cch = 0;
                    fPrevIsASCII = fCurrentIsASCII;

                    // My assumption in saving _dwMaskCF is that the remainder
                    // of the _CF is unchanged by AddText.  This assert verifies
                    // this assumption.
                    AssertSz(!CompareMemory(&CFSave._bCharSet, &_CF._bCharSet,
                        sizeof(CCharFormat) - sizeof(DWORD)) &&
                        !((CFSave._dwEffects ^ _CF._dwEffects) & ~CFE_RUNISDBCS),
                        "CRTFRead::HandleText():  AddText has been changed "
                        "and now alters the _CF structure.");

                    if(fLastChunk)          // Last chunk of text was AddText'd
                        break;
                }

                // Not the last chunk of text.
                Assert(*szText);

                // Advance szText pointer
                if (!fCurrentIsASCII && *(szText + 1) &&
                    GetTrailBytesCount(*szText, pstate->nCodePage))
                {
                    // Current byte is a lead-byte of a DBCS character
                    *pch++ = *szText++;
                    ++cch;
                }
                *pch++ = *szText++;
                ++cch;

                // Must do an AddText for the last chunk of text
                if(!*szText || cch >= _cchUnicode - 1)
                    fLastChunk = TRUE;
            }
            goto CleanUp;
        }
    }

    if(cch > 0)
    {
        AddText(_szUnicode, cch, TRUE);
        if(fStateChng && ptf)
        {
            ptf->bCharSet       = tfSave.bCharSet;
            ptf->sCodePage      = tfSave.sCodePage;
            ptf->fCpgFromSystem = tfSave.fCpgFromSystem;
            SelectCurrentFont(ptf->sHandle);
        }
    }

CleanUp:
    TRACEERRSZSC("HandleText()", - _ecParseError);
    return _ecParseError;
}

/*
 *  CRTFRead::AddText(pch, cch, fNumber)
 *  
 *  @mfunc
 *      Add <p cch> chars of the string <p pch> to the range _prg
 *
 *  @rdesc
 *      error code placed in _ecParseError
 */
EC CRTFRead::AddText(
    TCHAR * pch,        //@parm text to add
    LONG    cch,        //@parm count of chars to add
    BOOL    fNumber)    //@parm indicates whether or not to prepend numbering
{
    TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::AddText");

    LONG            cchAdded;
    LONG            cchT;
    STATE * const   pstate = _pstateStackTop;
    TCHAR *         szDest;
    LONG            cchMove;

    // AROO: No saving state before this point (other than pstate)
    // AROO: This would cause recursion problems below

    AssertSz(pstate, "CRTFRead::AddText: no state");

    if((DWORD)cch > _cchMax)
    {
        cch = (LONG)_cchMax;
        _ecParseError = ecTextMax;
    }

    if(!cch)
        return _ecParseError;

    // FUTURE(BradO):  This strategy for \pntext is prone to bugs, I believe.
    // The recursive call to AddText to add the \pntext will trounce the
    // accumulated _CF diffs associated with the text for which AddText is
    // called.  I believe we should save and restore _CF before and after
    // the recursive call to AddText below.  Also, it isn't sufficient to
    // accumulate bits of \pntext as below, since each bit might be formatted
    // with different _CF properties.  Instead, we should accumulate a mini-doc
    // complete with multiple text, char and para runs (or some stripped down
    // version of this strategy).

    if(pstate->sDest == destParaNumText)
    {
        szDest = _szNumText + _cchUsedNumText;
        cch = min(cch, cchMaxNumText - 1 - _cchUsedNumText);
        if(cch > 0)
        {
            MoveMemory((BYTE *)szDest, (BYTE *)pch, cch*2);
            szDest[cch] = TEXT('\0');       // HandleText() takes sz
            _cchUsedNumText += cch;
        }
        return ecNoError;
    }

    if(_cchUsedNumText && fNumber)          // Some \pntext available
    {
        // Bug 3496 - The fNumber flag is an ugly hack to work around RTF
        //  commonly written by Word.  Often, to separate a numbered list
        //  by page breaks, Word will write:
        //      <NUMBERING INFO> \page <PARAGRAPH TEXT>
        //  The paragraph numbering should precede the paragraph text rather
        //  than the page break.  The fNumber flag is set to FALSE when the
        //  the text being added should not be prepended with the para-numbering,
        //  as is the case with \page (mapped to FF).

        cchT = _cchUsedNumText;
        _cchUsedNumText = 0;                // Prevent infinite recursion

        if(!pstate->fBullet)
        {
            // If there are any _CF diffs to be injected, they will be trounced
            // by this recursive call (see FUTURE comment above).

            // Since we didn't save _CF data from calls to AddText with
            // pstate->sDest == destParaNumText, we have no way of setting up
            // CFE2_RUNISDBCS and CFM2_RUNISDBCS (see FUTURE comment above).

            AddText(_szNumText, cchT, FALSE);
        }
        else if(_PF.IsListNumbered() && _szNumText[cchT - 1] == TAB)
        {
            AssertSz(cchT >= 1, "Invalid numbered text count");

            if (cchT > 1)
            {
                WCHAR ch = _szNumText[cchT - 2];

                _wNumberingStyle = (_wNumberingStyle & ~0x300)
                     | (ch == '.' ? PFNS_PERIOD :
                        ch != ')' ? PFNS_PLAIN  :
                        _szNumText[0] == '(' ? PFNS_PARENS : PFNS_PAREN);
            }
            else
            {
                // There is only a tab so we will assume they meant to
                // skip numbering.
                _wNumberingStyle = PFNS_NONUMBER;
            }
        }
    }

    if (_cpFirst && _prg->GetCp() == _cpFirst && _prg->GetPF()->InTable() &&
        _cCell && !_prg->_rpTX.IsAfterEOP())
    {
        // FUTURE: handle more general table insertions into other tables
        _iCell = 0;
        return _ecParseError = ecGeneralFailure;
    }

    Apply_CF();                             // Apply formatting changes in _CF

    // BUGS 1577 & 1565 -
    // CTxtRange::ReplaceRange will change the character formatting
    // and possibly adjust the _rpCF forward if the current char
    // formatting includes protection.  The changes affected by
    // CTxtRange::ReplaceRange are necessary only for non-streaming
    // input, so we save state before and restore it after the call
    // to CTxtRange::ReplaceRange

    LONG iFormatSave = _prg->Get_iCF();     // Save state

    if(_cbSkipForUnicode && pstate->ptf->sCodePage == INVALID_CODEPAGE &&
       (!_fSeenFontTable || !(GetCharFlags(*pch) & fOTHER & ~255)))
    {
        // No charset info for \uN, so bind fonts if no font table or
        // else if *pch isn't classifield as "other"
        cchAdded = _prg->CleanseAndReplaceRange(cch, pch, FALSE, NULL, pch);
    }
    else
    {
        cchAdded = _prg->ReplaceRange(cch, pch, NULL, SELRR_IGNORE, &cchMove);

        DWORD dwFlags = 0;
        for(cchT = cch; cchT--; )
            dwFlags |= GetCharFlags(*pch++);    // Note if ComplexScript

        _ped->OrCharFlags(dwFlags);
    }

    _prg->Set_iCF(iFormatSave);                 // Restore state
    ReleaseFormats(iFormatSave, -1);
    Assert(!_prg->GetCch());

    if(cchAdded != cch)
    {
        Tracef(TRCSEVERR, "AddText(): Only added %d out of %d", cchAdded, cch);
        _ecParseError = ecGeneralFailure;
        if(cchAdded <= 0)
            return _ecParseError;
    }
    _cchMax -= cchAdded;

    return _ecParseError;
}

/*
 *  CRTFRead::Apply_CF()
 *  
 *  @mfunc
 *      Apply character formatting changes collected in _CF
 */
void CRTFRead::Apply_CF()
{
    // If any CF changes, update range's _iFormat
    if(_dwMaskCF || _dwMaskCF2)     
    {
        AssertSz(_prg->GetCch() == 0,
            "CRTFRead::Apply_CF: nondegenerate range");

        _prg->SetCharFormat(&_CF, 0, NULL, _dwMaskCF, _dwMaskCF2);
        _dwMaskCF = 0;                          
        _dwMaskCF2 = 0;
    }
}

/*
 *  CRTFRead::Apply_PF()
 *  
 *  @mfunc
 *      Apply paragraph format given by _PF
 */
void CRTFRead::Apply_PF()
{
    LONG         cp     = _prg->GetCp();
    DWORD        dwMask = _dwMaskPF;
    CParaFormat *pPF    = &_PF;

    if(_pstateStackTop)
    {
        Assert(_pstateStackTop->pPF);

        // Add PF diffs to *_pstateStackTop->pPF
        if(!_pstateStackTop->AddPF(_PF, _bDocType, _dwMaskPF))
        {
            _ped->GetCallMgr()->SetOutOfMemory();
            _ecParseError = ecNoMemory;
            return;
        }
        _dwMaskPF = 0;  // _PF contains delta's from *_pstateStackTop->pPF

        pPF    = _pstateStackTop->pPF;
        dwMask = _pstateStackTop->dwMaskPF;
        Assert(dwMask == PFM_ALLRTF);
        if(pPF->_wNumbering)
        {
            pPF->_wNumberingTab   = _pstateStackTop->sIndentNumbering;
            pPF->_wNumberingStyle = _wNumberingStyle;
        }

    }

    if(dwMask & PFM_TABSTOPS)
    {
        LONG cTab = _cCell ? _cCell : _cTab;

        // Caching a tabs array AddRefs the corresponding cached tabs entry.
        // Be absolutely sure to release the entry before exiting the routine
        // that caches it (see GetTabsCache()->Release at end of this funtion).
        pPF->_iTabs = GetTabsCache()->Cache(_rgxCell, cTab);
        if(pPF->InTable())                  // Save _iTabs when associated
            _iTabsTable = pPF->_iTabs;      //  with a table

        AssertSz(!cTab || pPF->_iTabs >= 0,
            "CRTFRead::Apply_PF: illegal pPF->_iTabs");

        pPF->_bTabCount = cTab;
    }

    if (!(dwMask & PFM_TABSTOPS) || !pPF->_bTabCount)
        pPF->_wEffects &= ~PFE_TABLE;       // No tabs, no table

    _prg->Set(cp, cp - _cpThisPara);        // Select back to _cpThisPara
    _prg->SetParaFormat(pPF, NULL, dwMask);
    _prg->Set(cp, 0);                       // Restore _prg to an IP

    GetTabsCache()->Release(pPF->_iTabs);
    pPF->_iTabs = -1;
}

/*
 *  CRTFRead::SetBorderParm(&Parm, Value)
 *
 *  @mfunc
 *      Set the border pen width in half points for the current border
 *      (_bBorder)
 */
void CRTFRead::SetBorderParm(
    WORD&   Parm,
    LONG    Value)
{
    Assert(_bBorder <= 3);

    Value = min(Value, 15);
    Value = max(Value, 0);
    Parm &= ~(0xF << 4*_bBorder);
    Parm |= Value << 4*_bBorder;
    _dwMaskPF |= PFM_BORDER;
}

/*
 *  CRTFRead::HandleToken()
 *
 *  @mfunc
 *      Grand switch board that handles all tokens. Switches on _token
 *
 *  @rdesc
 *      EC      The error code
 *
 *  @comm
 *      Token values are chosen contiguously (see tokens.h and tokens.c) to
 *      encourage the compiler to use a jump table.  The lite-RTF keywords
 *      come first, so that an optimized OLE-free version works well.  Some
 *      groups of keyword tokens are ordered so as to simplify the code, e.g,
 *      those for font family names, CF effects, and paragraph alignment.
 */
EC CRTFRead::HandleToken()
{
    TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::HandleToken");

    BYTE                bT;                     // Temporary BYTE
    DWORD               dwT;                    // Temporary DWORD
    LONG                dy, i;
    LONG                iParam = _iParam;
    const CCharFormat * pCF;
    COLORREF *          pclrf;
    STATE *             pstate = _pstateStackTop;
    TEXTFONT *          ptf;
    WORD                wT;                     // Temporary WORD

#if defined(DEBUG)
    if(!_fTestingParserCoverage)
#endif
    {
        if(_cbSkipForUnicode &&
            _token != tokenText &&
            _token != tokenStartGroup &&
            _token != tokenEndGroup &&
            _token != tokenBinaryData)
        {
            _cbSkipForUnicode--;
            goto done;
        }
    }

    switch (_token)
    {
    case tokenURtf:                             // \urtfN - Preferred RE format
        PARSERCOVERAGE_CASE();                  // Currently we ignore the N
        _dwFlags &= 0xFFFF;                     // Kill possible codepage
        _dwFlags |= SF_USECODEPAGE | (CP_UTF8 << 16); // Save bit for Asserts
        pstate->SetCodePage(CP_UTF8);
        goto rtf;

    case tokenPocketWord:                       // \pwd - Pocket Word
        _dwFlags |= SFF_PWD;

    case tokenRtf:                              // \rtf - Backward compatible
        PARSERCOVERAGE_CASE();
rtf:    pstate->sDest = destRTF;
        Assert(pstate->nCodePage == INVALID_CODEPAGE ||
               pstate->nCodePage == (int)(_dwFlags >> 16) &&
                    (_dwFlags & SF_USECODEPAGE));

        if(!_fonts.Count() && !_fonts.Add(1, NULL)) // If can't add a font,
            goto OutOfRAM;                      //  report the bad news
        _sDefaultFont = 0;                      // Set up valid default font
        ptf = _fonts.Elem(0);
        pstate->ptf           = ptf;            // Get char set, pitch, family
        pCF                   = _prg->GetCF();  //  from current range font
        ptf->bCharSet         = pCF->_bCharSet; // These are guaranteed OK
        ptf->bPitchAndFamily  = pCF->_bPitchAndFamily;
        ptf->sCodePage        = (SHORT)GetCodePage(pCF->_bCharSet);
        wcscpy(ptf->szName, GetFontName(pCF->_iFont));
        ptf->fNameIsDBCS = (pCF->_dwEffects & CFE_FACENAMEISDBCS) != 0;
        pstate->cbSkipForUnicodeMax = iUnicodeCChDefault;
        break;

    case tokenViewKind:                         // \viewkind N
        if(!(_dwFlags & SFF_SELECTION) && IsUTF8) // RTF applies to document:
            _ped->SetViewKind(iParam);          // For RE 3.0, only settable
        break;                                  //  using RichEdit \urtf files

    case tokenViewScale:                        // \viewscale N
        if(_dwFlags & SFF_PERSISTVIEWSCALE &&
            !(_dwFlags & SFF_SELECTION))            // RTF applies to document:
            _ped->SetViewScale(iParam);
        break;

    case tokenCharacterDefault:                 // \plain
        PARSERCOVERAGE_CASE();
        SetPlain(pstate);
        break;

    case tokenCharSetAnsi:                      // \ansi
        PARSERCOVERAGE_CASE();
        _bCharSet = ANSI_CHARSET;
        break;

    case tokenDefaultLanguage:                  // \deflang
        PARSERCOVERAGE_CASE();
        _sDefaultLanguage = (SHORT)iParam;
        if(!pstate->sLanguage)
            pstate->sLanguage = _sDefaultLanguage;
        break;

    case tokenDefaultLanguageFE:                // \deflangfe
        PARSERCOVERAGE_CASE();
        _sDefaultLanguageFE = (SHORT)iParam;
        break;

    case tokenDefaultTabWidth:                  // \deftab
        PARSERCOVERAGE_CASE();
        _sDefaultTabWidth = (SHORT)iParam;
        break;


//--------------------------- Font Control Words -------------------------------

    case tokenDefaultFont:                      // \deff n
        PARSERCOVERAGE_CASE();
        if(iParam >= 0)
            _fonts.Elem(0)->sHandle = _sDefaultFont = (SHORT)iParam;
        TRACEERRSZSC("tokenDefaultFont: Negative value", iParam);
        break;

    case tokenDefaultBiDiFont:                  // \adeff n
        PARSERCOVERAGE_CASE();
        if(iParam >=0)
        {
            if(!_fonts.Add(1, NULL))                
                goto OutOfRAM;                      
            _fonts.Elem(1)->sHandle = _sDefaultBiDiFont = (SHORT)iParam;
        }
        TRACEERRSZSC("tokenDefaultBiDiFont: Negative value", iParam);
        break;

    case tokenFontTable:                        // \fonttbl
        PARSERCOVERAGE_CASE();
        pstate->sDest = destFontTable;
        pstate->ptf = NULL;
        break;

    case tokenFontFamilyBidi:                   // \fbidi
    case tokenFontFamilyTechnical:              // \ftech
    case tokenFontFamilyDecorative:             // \fdecor
    case tokenFontFamilyScript:                 // \fscript
    case tokenFontFamilyModern:                 // \fmodern
    case tokenFontFamilySwiss:                  // \fswiss
    case tokenFontFamilyRoman:                  // \froman
    case tokenFontFamilyDefault:                // \fnil
        PARSERCOVERAGE_CASE();
        AssertSz(tokenFontFamilyRoman - tokenFontFamilyDefault == 1,
            "CRTFRead::HandleToken: invalid token definition");

        if(pstate->ptf)
        {
            pstate->ptf->bPitchAndFamily
                = (BYTE)((_token - tokenFontFamilyDefault) << 4
                         | (pstate->ptf->bPitchAndFamily & 0xF));

            // Setup SYMBOL_CHARSET charset for \ftech if there isn't any charset info
            if(tokenFontFamilyTechnical == _token && pstate->ptf->bCharSet == DEFAULT_CHARSET)
                pstate->ptf->bCharSet = SYMBOL_CHARSET;
        }
        break;

    case tokenPitch:                            // \fprq
        PARSERCOVERAGE_CASE();
        if(pstate->ptf)
            pstate->ptf->bPitchAndFamily
                = (BYTE)(iParam | (pstate->ptf->bPitchAndFamily & 0xF0));
        break;

    case tokenAnsiCodePage:                     // \ansicpg
        PARSERCOVERAGE_CASE();
#ifdef DEBUG
        if(_fSeenFontTable && _nCodePage == INVALID_CODEPAGE)
            TRACEWARNSZ("CRTFRead::HandleToken():  Found an \ansicpgN tag after "
                            "the font table.  Should have code to fix-up "
                            "converted font names and document text.");
#endif
        if(!(_dwFlags & SF_USECODEPAGE))
        {
            _nCodePage = iParam;
            pstate->SetCodePage(iParam);
        }
        Assert(!IsUTF8 || pstate->nCodePage == CP_UTF8);
        break;

    case tokenCodePage:                         // \cpg
        PARSERCOVERAGE_CASE();
        pstate->SetCodePage(iParam);
        if(pstate->sDest == destFontTable && pstate->ptf)
        {
            pstate->ptf->sCodePage = (SHORT)iParam;
            pstate->ptf->bCharSet = GetCharSet(iParam);

            // If a document-level code page has not been specified,
            // grab this from the first font table entry containing a
            // \fcharsetN or \cpgN
            if(_nCodePage == INVALID_CODEPAGE)
                _nCodePage = iParam;
        }
        break;

    case tokenCharSet:                          // \fcharset n
        PARSERCOVERAGE_CASE();
        if(pstate->ptf)
        {
            pstate->ptf->bCharSet = (BYTE)iParam;
            pstate->ptf->sCodePage = (SHORT)GetCodePage((BYTE)iParam);
            pstate->SetCodePage(pstate->ptf->sCodePage);

            // If a document-level code page has not been specified,
            // grab this from the first font table entry containing a
            // \fcharsetN or \cpgN
            if (pstate->nCodePage != CP_SYMBOL &&
                _nCodePage == INVALID_CODEPAGE)
            {
                _nCodePage = pstate->nCodePage;
            }
            if(IsRTLCharSet(iParam))
            {
                if(_sDefaultBiDiFont == -1)
                    _sDefaultBiDiFont = pstate->ptf->sHandle;

                else if(_sDefaultBiDiFont != pstate->ptf->sHandle)
                {
                    // Validate default BiDi font since Word 2000 may choose
                    // a nonBiDi font
                    i   = _fonts.Count();
                    ptf = _fonts.Elem(0);
                    for(; i-- && _sDefaultBiDiFont != ptf->sHandle; ptf++)
                        ;                                       
                    if(i >= 0 && !IsRTLCharSet(ptf->bCharSet))
                        _sDefaultBiDiFont = pstate->ptf->sHandle;
                }
                if(!IsRTLCharSet(_bBiDiCharSet))
                    _bBiDiCharSet = (BYTE)iParam;
            }
            _fCharSet = TRUE;
        }
        break;

    case tokenRealFontName:                     // \fname
        PARSERCOVERAGE_CASE();
        pstate->sDest = destRealFontName;
        break;

    case tokenAssocFontSelect:                  // \af n
        PARSERCOVERAGE_CASE();                  
        if(pstate->fltrch || pstate->frtlch)    // Be sure it's Western or RTL      
        {                                       //  script and not FE       
            i   = _fonts.Count();
            ptf = _fonts.Elem(0);
            for(; i-- && iParam != ptf->sHandle; ptf++) // Search for font
                ;                                       //  with handle iParam
            if(i >= 0 && IsRTLCharSet(ptf->bCharSet))
            {
                // FUTURE: set new variable _sFontAssocBiDi = iParam
                // and select _sFontAssocBiDi if run is rtlch. This
                // should give same display as Word.
                _bBiDiCharSet = ptf->bCharSet;
            }
            break;
        }   
        if(_sDefaultBiDiFont == -1 || !pstate->fdbch)// BiDi & FE script active?    
            break;                              // No
                                                // Yes: fall thru to \f n
    case tokenFontSelect:                       // \f n
        PARSERCOVERAGE_CASE();
        pstate->fdbch = FALSE;                  // Reset DBCS flag
        if(pstate->sDest == destFontTable)      // Building font table
        {
            if(iParam == _sDefaultFont)
            {
                _fReadDefFont = TRUE;
                ptf = _fonts.Elem(0);
            }
            else if(iParam == _sDefaultBiDiFont)
                ptf = _fonts.Elem(1);

            else if(!(ptf =_fonts.Add(1,NULL))) // Make room in font table for
            {                                   //  font to be parsed
OutOfRAM:
                _ped->GetCallMgr()->SetOutOfMemory();
                _ecParseError = ecNoMemory;
                break;
            }
            pstate->ptf     = ptf;
            ptf->sHandle    = (SHORT)iParam;    // Save handle
            ptf->szName[0]  = '\0';             // Start with null string
            ptf->bPitchAndFamily = 0;
            ptf->fNameIsDBCS = FALSE;
            ptf->sCodePage  = INVALID_CODEPAGE;
            ptf->fCpgFromSystem = FALSE;
            ptf->bCharSet = DEFAULT_CHARSET;
        }
        else                                    // Font switch in text
        {
            SelectCurrentFont(iParam);
            if(IsRTLCharSet(pstate->ptf->bCharSet))
                _bBiDiCharSet = pstate->ptf->bCharSet;
        }
        break;

    case tokenFontSize:                         // \fs n
        PARSERCOVERAGE_CASE();
        _CF._yHeight = PointsToFontHeight(iParam);  // Convert font size in
        _dwMaskCF |= CFM_SIZE;                  //  half points to logical
        break;                                  //  units

    // NOTE: \*\fontemb and \*\fontfile are discarded. The font mapper will
    //       have to do the best it can given font name, family, and pitch.
    //       Embedded fonts are particularly nasty because legal use should
    //       only support read-only which parser cannot enforce.

    case tokenLanguage:                         // \lang
        PARSERCOVERAGE_CASE();
        pstate->sLanguage = (SHORT)iParam;      // These 2 lines may not be
        pstate->fExplicitLang = TRUE;           //  needed with the new lcid
        _CF._lcid = MAKELCID(iParam, SORT_DEFAULT);
        if (W32->IsBiDiLcid(_CF._lcid))
            _bBiDiCharSet = GetCharSet(ConvertLanguageIDtoCodePage(iParam));
        _dwMaskCF |= CFM_LCID;
        break;


//-------------------------- Color Control Words ------------------------------

    case tokenColorTable:                       // \colortbl
        PARSERCOVERAGE_CASE();
        pstate->sDest = destColorTable;
        _fGetColorYet = FALSE;
        break;

    case tokenColorRed:                         // \red
        PARSERCOVERAGE_CASE();
        pstate->bRed = (BYTE)iParam;
        _fGetColorYet = TRUE;
        break;

    case tokenColorGreen:                       // \green
        PARSERCOVERAGE_CASE();
        pstate->bGreen = (BYTE)iParam;
        _fGetColorYet = TRUE;
        break;

    case tokenColorBlue:                        // \blue
        PARSERCOVERAGE_CASE();
        pstate->bBlue = (BYTE)iParam;
        _fGetColorYet = TRUE;
        break;

    case tokenColorForeground:                  // \cf
        PARSERCOVERAGE_CASE();
        _CF._crTextColor = GetColor(CFM_COLOR);
        // V-GUYB: Table cell backgrounds (\clcbpat) are not handled in RE 2.0.
        // This means all table cells will have a white background. Therefore
        // change any white text to black here.
        if(_pstateStackTop->fInTable && _CF._crTextColor == RGB(0xFF, 0xFF, 0xFF))
            _CF._crTextColor = RGB(0x00, 0x00, 0x00);
        break;

    case tokenColorBackground:                  // \highlight
        PARSERCOVERAGE_CASE();
        _CF._crBackColor = GetColor(CFM_BACKCOLOR);
        break;

    case tokenExpand:                           // \expndtw N
        PARSERCOVERAGE_CASE();
        _CF._sSpacing = (SHORT) iParam;
        _dwMaskCF |= CFM_SPACING;
        break;

    case tokenCharStyle:                        // \cs N
        PARSERCOVERAGE_CASE();
        /*  FUTURE (alexgo): we may want to support character styles
        in some future version.
        _CF._sStyle = (SHORT)iParam;
        _dwMaskCF |= CFM_STYLE;  */

        if(pstate->sDest == destStyleSheet)
            goto skip_group;
        break;          

    case tokenAnimText:                         // \animtext N
        PARSERCOVERAGE_CASE();
        _CF._bAnimation = (BYTE)iParam;
        _dwMaskCF |= CFM_ANIMATION;
        break;

    case tokenKerning:                          // \kerning N
        PARSERCOVERAGE_CASE();
        _CF._wKerning = (WORD)(10 * iParam);        // Convert to twips
        _dwMaskCF |= CFM_KERNING;
        break;

    case tokenFollowingPunct:                   // \*\fchars
        PARSERCOVERAGE_CASE();
        pstate->sDest = destFollowingPunct;
        {
            char *pwchBuf=NULL;
            if (ReadRawText((_dwFlags & SFF_SELECTION) ? NULL : &pwchBuf) && pwchBuf)
            {
                if (_ped->SetFollowingPunct(pwchBuf) != NOERROR)    // Store this buffer inside doc
                    FreePv(pwchBuf);
            }
            else if (pwchBuf)
                FreePv(pwchBuf);
        }
        break;

    case tokenLeadingPunct:                     // \*\lchars
        PARSERCOVERAGE_CASE();
        pstate->sDest = destLeadingPunct;
        {           
            char *pwchBuf=NULL;
            if (ReadRawText((_dwFlags & SFF_SELECTION) ? NULL : &pwchBuf) && pwchBuf)
            {
                if (_ped->SetLeadingPunct(pwchBuf) != NOERROR)  // Store this buffer inside doc 
                    FreePv(pwchBuf);
            }
            else if (pwchBuf)
                FreePv(pwchBuf);
        }
        break;

    case tokenDocumentArea:                     // \info
        PARSERCOVERAGE_CASE();
        pstate->sDest = destDocumentArea;
        break;

#ifdef FE
    USHORT      usPunct;                        // Used for FE word breaking

    case tokenNoOverflow:                       // \nooverflow
        PARSERCOVERAGE_CASE();
        TRACEINFOSZ("No Overflow");
        usPunct = ~WBF_OVERFLOW;
        goto setBrkOp;

    case tokenNoWordBreak:                      // \nocwrap
        PARSERCOVERAGE_CASE();
        TRACEINFOSZ("No Word Break" );
        usPunct = ~WBF_WORDBREAK;
        goto setBrkOp;

    case tokenNoWordWrap:                       // \nowwrap
        PARSERCOVERAGE_CASE();
        TRACEINFOSZ("No Word Word Wrap" );
        usPunct = ~WBF_WORDWRAP;

setBrkOp:
        if(!(_dwFlags & fRTFFE))
        {
            usPunct &= UsVGetBreakOption(_ped->lpPunctObj);
            UsVSetBreakOption(_ped->lpPunctObj, usPunct);
        }
        break;

    case tokenVerticalRender:                   // \vertdoc
        PARSERCOVERAGE_CASE();
        TRACEINFOSZ("Vertical" );
        if(pstate->sDest == destDocumentArea && !(_dwFlags & fRTFFE))
            _ped->fModeDefer = TRUE;
        break;

    case tokenHorizontalRender:                 // \horzdoc
        PARSERCOVERAGE_CASE();
        TRACEINFOSZ("Horizontal" );
        if(pstate->sDest == destDocumentArea && !(_dwFlags & fRTFFE))
            _ped->fModeDefer = FALSE;
        break;

#endif
//-------------------- Character Format Control Words -----------------------------

    case tokenUnderlineHairline:                // \ulhair          [10]
    case tokenUnderlineThick:                   // \ulth            [9]
    case tokenUnderlineWave:                    // \ulwave          [8]
    case tokenUnderlineDashDotDotted:           // \uldashdd        [7]
    case tokenUnderlineDashDotted:              // \uldashd         [6]
    case tokenUnderlineDash:                    // \uldash          [5]
    case tokenUnderlineDotted:                  // \uld             [4]
    case tokenUnderlineDouble:                  // \uldb            [3]
    case tokenUnderlineWord:                    // \ulw             [2]
        PARSERCOVERAGE_CASE();
        _CF._bUnderlineType = (BYTE)(_token - tokenUnderlineWord + 2);
        _token = tokenUnderline;                // CRenderer::RenderUnderline()
        goto under;                             //  reveals which of these are
                                                //  rendered specially
    case tokenUnderline:                        // \ul          [Effect 4]
        PARSERCOVERAGE_CASE();                  //  (see handleCF)
        _CF._bUnderlineType = CFU_UNDERLINE;
under:  _dwMaskCF |= CFM_UNDERLINETYPE;
        goto handleCF;

    case tokenDeleted:                          // \deleted
        PARSERCOVERAGE_CASE();
        _dwMaskCF2 = CFM2_DELETED;              
        dwT = CFE_DELETED;
        goto hndlCF;

    // These effects are turned on if their control word parameter is missing
    // or nonzero. They are turned off if the parameter is zero. This
    // behavior is usually identified by an asterisk (*) in the RTF spec.
    // The code uses fact that CFE_xxx = CFM_xxx
handleCF:
    case tokenRevised:                          // \revised         [4000]
    case tokenDisabled:                         // \disabled        [2000]
    case tokenImprint:                          // \impr            [1000]
    case tokenEmboss:                           // \embo             [800]
    case tokenShadow:                           // \shad             [400]
    case tokenOutline:                          // \outl             [200]
    case tokenHiddenText:                       // \v                [100]
    case tokenCaps:                             // \caps              [80]
    case tokenSmallCaps:                        // \scaps             [40]
    case tokenLink:                             // \link              [20]
    case tokenProtect:                          // \protect           [10]
    case tokenStrikeOut:                        // \strike             [8]
    case tokenItalic:                           // \i                  [2]
    case tokenBold:                             // \b                  [1]
        PARSERCOVERAGE_CASE();
        dwT = 1 << (_token - tokenBold);        // Generate effect mask
        _dwMaskCF |= dwT;                       
hndlCF: _CF._dwEffects &= ~dwT;                 // Default attribute off
        if(!*_szParam || _iParam)               // Effect is on
            _CF._dwEffects |= dwT;              // In either case, the effect
        break;                                  //  is defined

    case tokenStopUnderline:                    // \ulnone
        PARSERCOVERAGE_CASE();
        _CF._dwEffects &= ~CFE_UNDERLINE;       // Kill all underlining
        _dwMaskCF          |=  CFM_UNDERLINE;
        break;

    case tokenRevAuthor:                        // \revauth
        PARSERCOVERAGE_CASE();
        /* FUTURE: (alexgo) this doesn't work well now since we don't support
        revision tables.  We may want to support this better in the future.
        So what we do now is the 1.0 technique of using a color for the
        author */
        if(iParam > 0)
        {
            _CF._dwEffects &= ~CFE_AUTOCOLOR;
            _dwMaskCF |= CFM_COLOR;
            _CF._crTextColor = rgcrRevisions[(iParam - 1) & REVMASK];
        }
        break;

    case tokenUp:                               // \up
        PARSERCOVERAGE_CASE();
        dy = 10;
        goto StoreOffset;

    case tokenDown:                             // \down
        PARSERCOVERAGE_CASE();
        dy = -10;

StoreOffset:
        if(!*_szParam)
            iParam = dyDefaultSuperscript;
        _CF._yOffset = iParam * dy;             // Half points->twips
        _dwMaskCF |= CFM_OFFSET;
        break;

    case tokenSuperscript:                      // \super
        PARSERCOVERAGE_CASE();
         dwT = CFE_SUPERSCRIPT;
         goto SetSubSuperScript;

    case tokenSubscript:                        // \sub
        PARSERCOVERAGE_CASE();
         dwT = CFE_SUBSCRIPT;
         goto SetSubSuperScript;

    case tokenNoSuperSub:                       // \nosupersub
        PARSERCOVERAGE_CASE();
         dwT = 0;
SetSubSuperScript:
         _dwMaskCF     |=  (CFE_SUPERSCRIPT | CFE_SUBSCRIPT);
         _CF._dwEffects &= ~(CFE_SUPERSCRIPT | CFE_SUBSCRIPT);
         _CF._dwEffects |= dwT;
         break;



//--------------------- Paragraph Control Words -----------------------------

    case tokenStyleSheet:                       // \stylesheet
        PARSERCOVERAGE_CASE();
        pstate->sDest = destStyleSheet;
        _Style = 0;                             // Default normal style
        break;

    case tokenTabBar:                           // \tb
        PARSERCOVERAGE_CASE();
        _bTabType = PFT_BAR;                    // Fall thru to \tx

    case tokenTabPosition:                      // \tx. Ignore if in table
        PARSERCOVERAGE_CASE();                  //  since our simple model
        if(!pstate->fInTable)                   //  uses tab positions for
        {                                       //  cell widths
            if(_cTab < MAX_TAB_STOPS && (unsigned)iParam < 0x1000000)
            {
                _rgxCell[_cTab++] = GetTabPos(iParam)
                    + (_bTabType << 24) + (_bTabLeader << 28);
            }
            _dwMaskPF |= PFM_TABSTOPS;
        }
        break;

    case tokenDecimalTab:                       // \tqdec
    case tokenFlushRightTab:                    // \tqr
    case tokenCenterTab:                        // \tqc
        PARSERCOVERAGE_CASE();
        _bTabType = (BYTE)(_token - tokenCenterTab + PFT_CENTER);
        break;

    case tokenTabLeaderEqual:                   // \tleq
    case tokenTabLeaderThick:                   // \tlth
    case tokenTabLeaderUnderline:               // \tlul
    case tokenTabLeaderHyphen:                  // \tlhyph
    case tokenTabLeaderDots:                    // \tldot
        PARSERCOVERAGE_CASE();
        _bTabLeader = (BYTE)(_token - tokenTabLeaderDots + PFTL_DOTS);
        break;

    // The following need to be kept in sync with PFE_xxx
    case tokenCollapsed:                        // \collapsed
    case tokenSideBySide:                       // \sbys
    case tokenHyphPar:                          // \hyphpar
    case tokenNoWidCtlPar:                      // \nowidctlpar
    case tokenNoLineNumber:                     // \noline
    case tokenPageBreakBefore:                  // \pagebb
    case tokenKeepNext:                         // \keepn
    case tokenKeep:                             // \keep
    case tokenRToLPara:                         // \rtlpar
        PARSERCOVERAGE_CASE();
        wT = (WORD)(1 << (_token - tokenRToLPara));
        _PF._wEffects |= wT;
        _dwMaskPF |= (wT << 16);
        break;

    case tokenLToRPara:                         // \ltrpar
        PARSERCOVERAGE_CASE();
        _PF._wEffects &= ~PFE_RTLPARA;
        _dwMaskPF |= PFM_RTLPARA;
        break;

    case tokenLineSpacing:                      // \sl N
        PARSERCOVERAGE_CASE();
        _PF._dyLineSpacing = abs(iParam);
        _PF._bLineSpacingRule                   // Handle nonmultiple rules
                = (BYTE)(!iParam || iParam == 1000
                ? 0 : (iParam > 0) ? tomLineSpaceAtLeast
                    : tomLineSpaceExactly);     // \slmult can change (has to
        _dwMaskPF |= PFM_LINESPACING;           //  follow if it appears)
        break;

    case tokenDropCapLines:                     // \dropcapliN
        if(_PF._bLineSpacingRule == tomLineSpaceExactly)    // Don't chop off
            _PF._bLineSpacingRule = tomLineSpaceAtLeast;    //  drop cap
        break;

    case tokenLineSpacingRule:                  // \slmult N
        PARSERCOVERAGE_CASE();                  
        if(iParam)
        {                                       // It's multiple line spacing
            _PF._bLineSpacingRule = tomLineSpaceMultiple;
            _PF._dyLineSpacing /= 12;           // RE line spacing multiple is
            _dwMaskPF |= PFM_LINESPACING;       //  given in 20ths of a line,
        }                                       //  while RTF uses 240ths   
        break;

    case tokenSpaceBefore:                      // \sb N
        PARSERCOVERAGE_CASE();
        _PF._dySpaceBefore = iParam;
        _dwMaskPF |= PFM_SPACEBEFORE;
        break;

    case tokenSpaceAfter:                       // \sa N
        PARSERCOVERAGE_CASE();
        _PF._dySpaceAfter = iParam;
        _dwMaskPF |= PFM_SPACEAFTER;
        break;

    case tokenStyle:                            // \s N
        PARSERCOVERAGE_CASE();
        _Style = iParam;                        // Save it in case in StyleSheet
        if(pstate->sDest != destStyleSheet)
        {                                       // Select possible heading level
            _PF._sStyle = STYLE_NORMAL;         // Default Normal style
            _PF._bOutlineLevel |= 1;

            for(i = 0; i < NSTYLES && iParam != _rgStyles[i]; i++)
                ;                               // Check for heading style
            if(i < NSTYLES)                     // Found one
            {
                _PF._sStyle = (SHORT)(-i - 1);  // Store desired heading level
                _PF._bOutlineLevel = (BYTE)(2*(i-1));// Update outline level for
            }                                   //  nonheading styles
            _dwMaskPF |= PFM_ALLRTF;
        }
        break;

    case tokenIndentFirst:                      // \fi N
        PARSERCOVERAGE_CASE();
        _PF._dxStartIndent += _PF._dxOffset     // Cancel current offset
                            + iParam;           //  and add in new one
        _PF._dxOffset = -iParam;                    // Offset for all but 1st line
                                                //  = -RTF_FirstLineIndent
        _dwMaskPF |= (PFM_STARTINDENT | PFM_OFFSET);
        break;                      

    case tokenIndentLeft:                       // \li N
    case tokenIndentRight:                      // \ri N
        PARSERCOVERAGE_CASE();
        // AymanA: For RtL para indents has to be flipped.
        Assert(PFE_RTLPARA == 0x0001);
        if((_token == tokenIndentLeft) ^ (_PF.IsRtlPara()))
        {
            _PF._dxStartIndent = iParam - _PF._dxOffset;
            _dwMaskPF |= PFM_STARTINDENT;
        }
        else
        {
            _PF._dxRightIndent = iParam;
            _dwMaskPF |= PFM_RIGHTINDENT;
        }
        break;

    case tokenAlignLeft:                        // \ql
    case tokenAlignRight:                       // \qr
    case tokenAlignCenter:                      // \qc
    case tokenAlignJustify:                     // \qj
        PARSERCOVERAGE_CASE();
        if(!pstate->fInTable)
        {
            _PF._bAlignment = (WORD)(_token - tokenAlignLeft + PFA_LEFT);
            _dwMaskPF |= PFM_ALIGNMENT;
        }
        break;

    case tokenBorderOutside:                    // \brdrbar
    case tokenBorderBetween:                    // \brdrbtw
    case tokenBorderShadow:                     // \brdrsh
        PARSERCOVERAGE_CASE();
        _PF._dwBorderColor |= 1 << (_token - tokenBorderShadow + 20);
        _dwBorderColor = _PF._dwBorderColor;
        break;

    // Paragraph and cell border segments
    case tokenBox:                              // \box
        PARSERCOVERAGE_CASE();
        _PF._wEffects |= PFE_BOX;
        _dwMaskPF    |= PFM_BOX;
        _bBorder = 0;                           // Store parms as if for
        break;                                  //  \brdrt

    case tokenCellBorderRight:                  // \clbrdrr
    case tokenCellBorderBottom:                 // \clbrdrb
    case tokenCellBorderLeft:                   // \clbrdrl
    case tokenCellBorderTop:                    // \clbrdrt
    case tokenBorderRight:                      // \brdrr
    case tokenBorderBottom:                     // \brdrb
    case tokenBorderLeft:                       // \brdrl
    case tokenBorderTop:                        // \brdrt
        PARSERCOVERAGE_CASE();
        _bBorder = (BYTE)(_token - tokenBorderTop);
        break;

    // Paragraph border styles
    case tokenBorderTriple:                     // \brdrtriple
    case tokenBorderDoubleThick:                // \brdrth
    case tokenBorderSingleThick:                // \brdrs
    case tokenBorderHairline:                   // \brdrhair
    case tokenBorderDot:                        // \brdrdot
    case tokenBorderDouble:                     // \brdrdb
    case tokenBorderDashSmall:                  // \brdrdashsm
    case tokenBorderDash:                       // \brdrdash
        PARSERCOVERAGE_CASE();
        if(_bBorder < 4)                        // Only for paragraphs
            SetBorderParm(_PF._wBorders, _token - tokenBorderDash);
        break;

    case tokenBorderColor:                      // \brdrcf
        PARSERCOVERAGE_CASE();
        if(_bBorder < 4)                        // Only for paragraphs
        {
            iParam = GetStandardColorIndex();
            _PF._dwBorderColor &= ~(0x1F << (5*_bBorder));
            _PF._dwBorderColor |= iParam << (5*_bBorder);
            _dwBorderColor = _PF._dwBorderColor;
        }
        break;

    case tokenBorderWidth:                      // \brdrw
        PARSERCOVERAGE_CASE();                  // Width is in half pts
        if(_bBorder < 4)                        // For paragraphs
        {                                       // iParam is in twips
            if(IN_RANGE(1, iParam, 4))          // Give small but nonzero
                iParam = 1;                     //  values our minimum
            else                                //  size
                iParam = (iParam + 5)/10;

            SetBorderParm(_PF._wBorderWidth, iParam);
        }
        else                                    // For cells only have 2 bits
        {
            iParam = (iParam + 10)/20;
            iParam = max(iParam, 1);
            iParam = min(iParam, 3);
            _bCellBrdrWdths |= iParam << 2*(_bBorder - 4);
        }
        break;

    case tokenBorderSpace:                      // \brsp
        PARSERCOVERAGE_CASE();                  // Space is in pts
        if(_bBorder < 4)                        // Only for paragraphs
            SetBorderParm(_PF._wBorderSpace, iParam/20);// iParam is in twips
        break;

    // Paragraph shading
    case tokenBckgrndVert:                      // \bgvert
    case tokenBckgrndHoriz:                     // \bghoriz
    case tokenBckgrndFwdDiag:                   // \bgfdiag
    case tokenBckgrndDrkVert:                   // \bgdkvert
    case tokenBckgrndDrkHoriz:                  // \bgdkhoriz
    case tokenBckgrndDrkFwdDiag:                // \bgdkfdiag
    case tokenBckgrndDrkDiagCross:              // \bgdkdcross
    case tokenBckgrndDrkCross:                  // \bgdkcross
    case tokenBckgrndDrkBckDiag:                // \bgdkbdiag
    case tokenBckgrndDiagCross:                 // \bgdcross
    case tokenBckgrndCross:                     // \bgcross
    case tokenBckgrndBckDiag:                   // \bgbdiag
        PARSERCOVERAGE_CASE();
        _PF._wShadingStyle = (WORD)((_PF._wShadingStyle & 0xFFC0)
                        | (_token - tokenBckgrndBckDiag + 1));
        _dwMaskPF |= PFM_SHADING;
        break;

    case tokenColorBckgrndPat:                  // \cbpat
        PARSERCOVERAGE_CASE();
        iParam = GetStandardColorIndex();
        _PF._wShadingStyle = (WORD)((_PF._wShadingStyle & 0x07FF) | (iParam << 11));
        _dwMaskPF |= PFM_SHADING;
        break;

    case tokenColorForgrndPat:                  // \cfpat
        PARSERCOVERAGE_CASE();
        iParam = GetStandardColorIndex();
        _PF._wShadingStyle = (WORD)((_PF._wShadingStyle & 0xF83F) | (iParam << 6));
        _dwMaskPF |= PFM_SHADING;
        break;

    case tokenShading:                          // \shading
        PARSERCOVERAGE_CASE();
        _PF._wShadingWeight = (WORD)iParam;
        _dwMaskPF |= PFM_SHADING;
        break;

    // Paragraph numbering
    case tokenParaNum:                          // \pn
        PARSERCOVERAGE_CASE();
        pstate->sDest = destParaNumbering;
        pstate->fBullet = FALSE;
        _PF._wNumberingStart = 1;
        _dwMaskPF |= PFM_NUMBERINGSTART;
        break;

    case tokenParaNumIndent:                    // \pnindent N
        PARSERCOVERAGE_CASE();
        if(pstate->sDest == destParaNumbering)
            pstate->sIndentNumbering = (SHORT)iParam;
        break;

    case tokenParaNumStart:                     // \pnstart N
        PARSERCOVERAGE_CASE();
        if(pstate->sDest == destParaNumbering)
        {
            _PF._wNumberingStart = (WORD)iParam;
            _dwMaskPF |= PFM_NUMBERINGSTART;
        }
        break;

    case tokenParaNumCont:                      // \pnlvlcont
        PARSERCOVERAGE_CASE();                  
        _prg->_rpPF.AdjustBackward();           // Maintain numbering mode
        _PF._wNumbering = _prg->GetPF()->_wNumbering;
        _prg->_rpPF.AdjustForward();
        _wNumberingStyle = PFNS_NONUMBER;       // Signal no number
        _dwMaskPF |= PFM_NUMBERING;             // Note: can be new para with
        pstate->fBullet = TRUE;                 //  its own indents
        break;

    case tokenParaNumBody:                      // \pnlvlbody
        PARSERCOVERAGE_CASE();
        _wNumberingStyle = PFNS_PAREN;
        _token = tokenParaNumDecimal;           // Default to decimal
        goto setnum;
        
    case tokenParaNumBullet:                    // \pnlvlblt
        _wNumberingStyle = 0;                   // Reset numbering styles
        goto setnum;

    case tokenParaNumDecimal:                   // \pndec
    case tokenParaNumLCLetter:                  // \pnlcltr
    case tokenParaNumUCLetter:                  // \pnucltr
    case tokenParaNumLCRoman:                   // \pnlcrm
    case tokenParaNumUCRoman:                   // \pnucrm
        PARSERCOVERAGE_CASE();
        if(_PF._wNumbering == PFN_BULLET && pstate->fBullet)
            break;                              // Ignore above for bullets

setnum: if(pstate->sDest == destParaNumbering)
        {
            _PF._wNumbering = (WORD)(PFN_BULLET + _token - tokenParaNumBullet);
            _dwMaskPF |= PFM_NUMBERING;
            pstate->fBullet = TRUE;             // We do bullets, so don't
        }                                       //  output the \pntext group
        break;

    case tokenParaNumText:                      // \pntext
        PARSERCOVERAGE_CASE();
        // Throw away previously read paragraph numbering and use
        //  the most recently read to apply to next run of text.
        _cchUsedNumText = 0;
        pstate->sDest = destParaNumText;
        break;

    case tokenParaNumAlignCenter:               // \pnqc
    case tokenParaNumAlignRight:                // \pnqr
        PARSERCOVERAGE_CASE();
        _wNumberingStyle = (_wNumberingStyle & ~3) | _token - tokenParaNumAlignCenter + 1;
        break;

    case tokenParaNumAfter:                     // \pntxta
    case tokenParaNumBefore:                    // \pntxtb
    case tokenPictureQuickDraw:                 // \macpict
    case tokenPictureOS2Metafile:               // \pmmetafile
        PARSERCOVERAGE_CASE();

skip_group:
        if(!SkipToEndOfGroup())
        {
            // During \fonttbl processing, we may hit unknown destinations,
            // e.g., \panose, that cause the HandleEndGroup to select the
            // default font, which may not be defined yet.  So, we change
            // sDest to avoid this problem.
            if(pstate->sDest == destFontTable || pstate->sDest == destStyleSheet)
                pstate->sDest = destNULL;
            HandleEndGroup();
        }
        break;

    // Tables
    case tokenInTable:                          // \intbl
        PARSERCOVERAGE_CASE();
        // Our simple table model has one para per row, i.e., no paras in
        // cells. Also no tabs in cells (both are converted to blanks). On
        // receipt of \intbl, transfer stored table info into _PF.
        if(_fInTable)
            _ecParseError = ecGeneralFailure;

        _dwMaskPF |= PFM_TABSTOPS;
        if(_wBorderWidth)                       // Store any border info
        {
            _PF._dwBorderColor = _dwBorderColor;
            _PF._wBorders     = _wBorders;
            _PF._wBorderSpace  = _wBorderSpace;
            _PF._wBorderWidth  = _wBorderWidth;
            _dwMaskPF |= PFM_BORDER;
        }

        _PF._bAlignment   = _bAlignment;        // Row alignment (no cell align)
        _PF._dxStartIndent = _xRowOffset;       // \trleft N
        _PF._dxOffset     = _dxCell;            // \trgaph N
        _PF._wEffects |= PFE_TABLE;             
        _dwMaskPF    |= PFM_TABLE | PFM_OFFSET | PFM_ALIGNMENT;
        pstate->fInTable = TRUE;                
        break;

    case tokenCell:                             // \cell
        PARSERCOVERAGE_CASE();
        if(_fInTable)
            _ecParseError = ecGeneralFailure;

        else if(pstate->fInTable)                   
        {                                       
            if(!_cCell && _iTabsTable >= 0)     // No cells defined here;
            {                                   // Use previous table defs
                CTabs *pTabs = GetTabsCache()->Elem(_iTabsTable);
                _cCell = pTabs->_cTab;
                for(int i = _cCell; i--; )
                    _rgxCell[i] = pTabs->_prgxTabs[i];

            }
            if(_iCell < _cCell)                 // Don't add more cells than
            {                                   //  defined, since Word crashes
                _iCell++;                       // Count cells inserted
                HandleChar(CELL);               // Insert cell delimiter
            }
        }
        break;

    case tokenCellHalfGap:                      // \trgaph N
        PARSERCOVERAGE_CASE();                  // Save half space between
        _dxCell = iParam;                       //  cells to add to tabs
        break;                                  // Roundtrip value at end of
                                                //  tab array
    case tokenCellX:                            // \cellx N
        PARSERCOVERAGE_CASE();
        if(_cCell < MAX_TAB_STOPS)              // Save cell right boundaries
        {                                       //  for tab settings in our
            if(!_cCell)                         //  primitive table model
            {                                   // Save border info
                _wBorders = _PF._wBorders;
                _wBorderSpace = _PF._wBorderSpace;
                _wBorderWidth = _PF._wBorderWidth;
            }
            _rgxCell[_cCell++] = iParam + (_bCellBrdrWdths << 24);
            _bCellBrdrWdths = 0;
        }
        break;

    case tokenRowDefault:                       // \trowd
        PARSERCOVERAGE_CASE();
		if(_fInTable)							// Can't insert a table into
		{										//  a table in RE 3.0
            _ecParseError = ecGeneralFailure;
			break;
		}
        // Insert newline if we are inserting a table behind characters in the
        // same line.  This follows the Word9 model.
        if (_cpFirst == _prg->GetCp() && _cpThisPara != _cpFirst)
        {
            EC ec  = _ped->fUseCRLF()           // If RichEdit 1.0 compatibility
                ? HandleText(szaCRLF, ALL_ASCII)//  mode, use CRLF; else CR
                : HandleChar((unsigned)(CR));
            if(ec == ecNoError)
                _cpThisPara = _prg->GetCp();    // New para starts after CRLF
        }

        _cCell = 0;                             // No cell right boundaries
        _dxCell = 0;                            //  or half gap defined yet
        _xRowOffset = 0;
        _bCellBrdrWdths = 0;
        _wBorderWidth = 0;                      // No borders yet
        _dwBorderColor  = 0;
        _bAlignment = PFA_LEFT;
        _iTabsTable = -1;                       // No cell widths yet
        break;

    case tokenRowLeft:                          // \trleft
        PARSERCOVERAGE_CASE();
        _xRowOffset = iParam;
        break;
                                                
    case tokenRowAlignCenter:                   // \trqc
    case tokenRowAlignRight:                    // \trqr
        PARSERCOVERAGE_CASE();
        _bAlignment = (WORD)(_token - tokenRowAlignRight + PFA_RIGHT);
        break;

    case tokenPage:                             // \page

        // FUTURE: we want to be smarter about handling FF. But for
        // now we just ignore it for bulletted and number paragraphs
        // and just make it an EOP otherwise.
        if (_PF._wNumbering != 0)
            break;

        // Intentional fall thru to EOP.
    case tokenEndParagraph:                     // \par
    case tokenLineBreak:                        // \line
        PARSERCOVERAGE_CASE();
        if(_pstateStackTop->fInTable)
            HandleChar(' ');                    // Just use a blank for \par
        else                                    //  in table
        {
            _cCell = 0;
            HandleEndOfPara();
        }
        break;                              

    case tokenRow:                              // \row. Treat as hard CR
        PARSERCOVERAGE_CASE();
        for( ; _iCell < _cCell; _iCell++)       // If not enuf cells, add
            HandleChar(CELL);                   //  them since Word crashes
        _iCell = 0;                             //  if \cellx count differs
        HandleEndOfPara();                      //  from \cell count
        break;

    case tokenParagraphDefault:                 // \pard
        PARSERCOVERAGE_CASE();
        if(pstate->sDest == destParaNumText)    // Ignore if \pn destination
            break;
                                                // Else fall thru to \secd
    case tokenEndSection:                       // \sect
    case tokenSectionDefault:                   // \sectd
        PARSERCOVERAGE_CASE();
        bT = _PF._bOutlineLevel;
        
        // Save outline level
        _PF.InitDefault(_bDocType == DT_RTLDOC ? PFE_RTLPARA : 0);
                                                // Reset para formatting
        pstate->fInTable = FALSE;               // Reset in table flag
        pstate->fBullet = FALSE;
        pstate->sIndentNumbering = 0;
        _cTab           = 0;                    // No tabs defined
        _bTabLeader     = 0;
        _bTabType       = 0;
        _bBorder        = 0;
        _PF._bOutlineLevel = (BYTE)(bT | 1);
        _dwMaskPF       = PFM_ALLRTF;
        break;


//----------------------- Field and Group Control Words --------------------------------
    // Note that we currently don't support nested fields.  For nested
    // fields, the usage of _szSymbolFieldResult, _FieldCF, _ptfField
    // and _sFieldCodePage needs to be rethought.

    case tokenField:                            // \field
        PARSERCOVERAGE_CASE();

        if (pstate->sDest == destDocumentArea ||
            pstate->sDest == destLeadingPunct ||
            pstate->sDest == destFollowingPunct ||
            pstate->fFieldInst)
        {
            // We're not equipped to handle symbols in these destinations, and
            // we don't want the fields added accidentally to document text.
            goto skip_group;
        }

        pstate->sDest = destField;
        
        _nFieldCodePage = pstate->nCodePage;    // init, for safety
        _ptfField = NULL;
        _fRestoreFieldFormat = TRUE;
        break;

    case tokenFieldResult:                      // \fldrslt
        PARSERCOVERAGE_CASE();

        pstate->fFieldInst = FALSE;
        pstate->fFieldRslt = TRUE;

        // Restore the formatting from the field instruction
        // when we are doing Hyperlink
        if(_fRestoreFieldFormat && _fHyperlinkField)
        {           
            _CF = _FieldCF;
            pstate->ptf = _ptfField;
            pstate->SetCodePage(_nFieldCodePage);
            _dwMaskCF = _dwMaskFieldCF;
            _dwMaskCF2 = _dwMaskFieldCF2;
        }
        _fRestoreFieldFormat = FALSE;

        if(!_fHyperlinkField)
        {
            // for SYMBOL
            pstate->sDest = destField;
            break;
        }

        // for HYPERLINK
        
        // By now, we should have the whole hyperlink fldinst string
        if(_szHyperlinkFldinst)
        {
            // V-GUYB: PWord Converter requires loss notification.
            // (Hyperlinks are NOT streamed out later)
            #ifdef REPORT_LOSSAGE
            if(!(_dwFlags & SFF_SELECTION)) // SFF_SELECTION is set if any kind of paste is being done.
            {
                ((LOST_COOKIE*)(_pes->dwCookie))->bLoss = TRUE;
            }
            #endif // REPORT_LOSSAGE
        
            BYTE * pNewBuffer = NULL;

            // Check if this is a friendly name
            if(_szHyperlinkFldinst[1] == '\"')
            {   
                // This is a friendly name, replace quotes with <>.
                // Also, for an unknown reason, Word escapes some chars in its HYPERLINK presentation
                // we have to get rid of the backslashes

                BYTE *  pSrc = &_szHyperlinkFldinst[2];
                BYTE *  pBuffer;
                BOOL    fLeadByte = FALSE;
                LONG    CodePage;

                CodePage = IsFECharSet(_bInstFieldCharSet) ? GetCodePage(_bInstFieldCharSet): 0;

                pNewBuffer = (BYTE *)PvAlloc(_cchHyperlinkFldinstUsed+1, GMEM_ZEROINIT);
                if(!pNewBuffer)
                {
                    _ecParseError = ecNoMemory;
                    break;
                }

                pBuffer = pNewBuffer;
                *pBuffer++ = ' ';
                *pBuffer++ = '<';

                do
                {
                    if(!fLeadByte && *pSrc == '\\') // Get rid of backslashes
                        pSrc++;

                    else if(*pSrc == '\"')
                    {
                        *pBuffer = '>';             // Find end quote
                        break;
                    }
                    else if(CodePage)
                    {
                        // Check if this is a valid Lead byte.
                        fLeadByte = fLeadByte ? FALSE : GetTrailBytesCount(*pSrc, CodePage);
                    }
                } while (*pBuffer++ = *pSrc++);                     
            }

            // No longer need this buffer...
            FreePv(_szHyperlinkFldinst);

            // Setup for the new scanned buffer
            _szHyperlinkFldinst = pNewBuffer;
            _cchHyperlinkFldinst = _cchHyperlinkFldinstUsed+1;
        }

        pstate->sDest = destFieldResult;
        if(_szHyperlinkFldinst)
        {           
            // Pre-alloc a buffer for the fldrslt strings
            _cchHyperlinkFldrslt = MAX_PATH;
            _cchHyperlinkFldrsltUsed = 0;
            _szHyperlinkFldrslt = (BYTE *)PvAlloc(_cchHyperlinkFldrslt, GMEM_FIXED);

            if(!_szHyperlinkFldrslt)
            {
                _ecParseError = ecNoMemory;
                break;
            }
            _szHyperlinkFldrslt[0] = 0;         // No text yet
        }
        else
        {
            _cchHyperlinkFldrslt = 0;
            _cchHyperlinkFldrsltUsed = 0;
            FreePv(_szHyperlinkFldrslt);

            // No friendly HYPERLINK name, no need to accumulate fldrslt strings
            _szHyperlinkFldrslt = 0;
            _fHyperlinkField = FALSE;
        }
        break;

    case tokenFieldInstruction:                 // \fldinst
        PARSERCOVERAGE_CASE();
        if(pstate->fFieldInst || pstate->fFieldRslt)
            goto skip_group;                    // Skip nested field instr
        pstate->fFieldInst = TRUE;              // TODO: skip what follows up to \fldrslt
        pstate->sDest = destFieldInstruction;
        break;

    case tokenStartGroup:                       // Save current state by
        PARSERCOVERAGE_CASE();                  //  pushing it onto stack
        _cbSkipForUnicode = 0;
        HandleStartGroup();
        if (_fNoRTFtoken)
        {
            // Hack Alert !!!!! FOr 1.0 compatibility to allow no \rtf token.
            _fNoRTFtoken = FALSE;
            pstate = _pstateStackTop;
            goto rtf;
        }
        break;

    case tokenEndGroup:
        PARSERCOVERAGE_CASE();
        _cbSkipForUnicode = 0;

        HandleFieldEndGroup();                  // Special end group handling for \field
        HandleEndGroup();                       // Restore save state by
        break;                                  //  popping stack

    case tokenOptionalDestination:              // (see case tokenUnknown)
        PARSERCOVERAGE_CASE();
        break;

    case tokenNullDestination:                  // We've found a destination
        PARSERCOVERAGE_CASE();
        // tokenNullDestination triggers a loss notifcation here for...
        //      Footer related tokens - "footer", "footerf", "footerl", "footerr",
        //                              "footnote", "ftncn", "ftnsep", "ftnsepc"
        //      Header related tokens - "header", "headerf", "headerl", "headerr"
        //      Table of contents     - "tc"
        //      Index entries         - "xe"

        // V-GUYB: PWord Converter requires loss notification.
        #ifdef REPORT_LOSSAGE
        if(!(_dwFlags & SFF_SELECTION)) // SFF_SELECTION is set if any kind of paste is being done.
        {
            ((LOST_COOKIE*)(_pes->dwCookie))->bLoss = TRUE;
        }
        #endif // REPORT_LOSSAGE
        
        goto skip_group;                        // for which we should ignore
                                                // the remainder of the group
    case tokenUnknownKeyword:
        PARSERCOVERAGE_CASE();
        if(_tokenLast == tokenOptionalDestination)
            goto skip_group;
        break;                                  // Nother place for
                                                //  unrecognized RTF


//-------------------------- Text Control Words --------------------------------

    case tokenUnicode:                          // \u <n>
        PARSERCOVERAGE_CASE();

        // FUTURE: for now, we will ignore \u <n> when we are handling fields.
        // We should re-visit the HYPERLINK handling where we are accumulating
        // ASCII text.  We will have to switch to aaccumulate Unicode in order
        // to insert this \u <n> into the string.
        if(_fHyperlinkField || pstate->fFieldInst)
            break;

        _dwMaskCF2      |=  CFM2_RUNISDBCS;
        _CF._dwEffects  &= ~CFE_RUNISDBCS;
        wT = (WORD)iParam;                      // Treat as unsigned integer
        if(pstate->ptf->bCharSet == SYMBOL_CHARSET)
        {
            if(IN_RANGE(0xF000, wT, 0xF0FF))    // Compensate for converters
                wT -= 0xF000;                   //  that write symbol codes
                                                //  up high
            else if(wT > 255)                   // Whoops, RTF is using con-                    
            {                                   //  verted value for symbol:
                char ach;                       //  convert back
                WCTMB(1252, 0, &wT, 1, &ach, 1, NULL, NULL, NULL);
                wT = (BYTE)ach;                 // Review: use CP_ACP??
            }
        }
        _cbSkipForUnicode = pstate->cbSkipForUnicodeMax;
        AddText((TCHAR *)&wT, 1, TRUE);         //  (avoids endian problems)
        break;

    case tokenUnicodeCharByteCount:             // \ucN
        PARSERCOVERAGE_CASE();
        pstate->cbSkipForUnicodeMax = (WORD)iParam;
        break;

    case tokenText:                             // Lexer concludes tokenText
    case tokenASCIIText:
        PARSERCOVERAGE_CASE();
        switch (pstate->sDest)
        {
        case destColorTable:
            pclrf = _colors.Add(1, NULL);
            if(!pclrf)
                goto OutOfRAM;

            *pclrf = _fGetColorYet ?
                RGB(pstate->bRed, pstate->bGreen, pstate->bBlue) : tomAutoColor;

            // Prepare for next color table entry
            pstate->bRed =                      
            pstate->bGreen =                    
            pstate->bBlue = 0;
            _fGetColorYet = FALSE;              // in case more "empty" color
            break;

        case destFontTable:
            if(!pstate->fRealFontName)
            {
                ReadFontName(pstate,
                                _token == tokenASCIIText ?
                                        ALL_ASCII : CONTAINS_NONASCII);
            }
            break;

        case destRealFontName:
        {
            STATE * const pstatePrev = pstate->pstatePrev;

            if(pstatePrev && pstatePrev->sDest == destFontTable)
            {
                // Mark previous state so that tagged font name will be ignored
                // AROO: Do this before calling ReadFontName so that
                // AROO: it doesn't try to match font name
                pstatePrev->fRealFontName = TRUE;
                ReadFontName(pstatePrev,
                        _token == tokenASCIIText ? ALL_ASCII : CONTAINS_NONASCII);
            }

            break;
        }

        case destFieldInstruction:
            if(_szHyperlinkFldinst)
            {
                if(!IsFECharSet(_bInstFieldCharSet) && IsFECharSet(_CF._bCharSet))
                    _bInstFieldCharSet = _CF._bCharSet;

                _ecParseError = AppendString(& _szHyperlinkFldinst, _szText, &_cchHyperlinkFldinst, &_cchHyperlinkFldinstUsed );
            }
            else
            {
                HandleFieldInstruction();
                _bInstFieldCharSet = _CF._bCharSet;
            }
            break;

        case destObjectClass:
            if(StrAlloc(&_prtfObject->szClass, _szText))
                goto OutOfRAM;
            break;
            
        case destObjectName:
            if(StrAlloc(&_prtfObject->szName, _szText))
                goto OutOfRAM;
            break;

        case destStyleSheet:
            // _szText has style name, e.g., "heading 1"
            if(W32->ASCIICompareI(_szText, (unsigned char *)"heading", 7))
            {
                dwT = (unsigned)(_szText[8] - '0');
                if(dwT < NSTYLES)
                    _rgStyles[dwT] = (BYTE)_Style;
            }
            break;

        case destDocumentArea:
        case destFollowingPunct:
        case destLeadingPunct:
            break;

// This has been changed now.  We will store the Punct strings as
// raw text strings.  So, we don't have to convert them.
// This code is keep here just in case we want to change back.
#if 0
        case destDocumentArea:
            if (_tokenLast != tokenFollowingPunct &&
                _tokenLast != tokenLeadingPunct)
            {
                break;
            }                                       // Else fall thru to
                                                    //  destFollowingPunct
        case destFollowingPunct:
        case destLeadingPunct:
            // TODO(BradO):  Consider some kind of merging heuristic when
            //  we paste FE RTF (for lead and follow chars, that is).
            if(!(_dwFlags & SFF_SELECTION))
            {
                int cwch = MBTWC(INVALID_CODEPAGE, 0,
                                        (char *)_szText, -1,
                                        NULL, 0,
                                        NULL);
                Assert(cwch);
                WCHAR *pwchBuf = (WCHAR *)PvAlloc(cwch * sizeof(WCHAR), GMEM_ZEROINIT);

                if(!pwchBuf)
                    goto OutOfRAM;

                SideAssert(MBTWC(INVALID_CODEPAGE, 0,
                                    (char *)_szText, -1,
                                    pwchBuf, cwch,
                                    NULL) > 0);

                if(pstate->sDest == destFollowingPunct)
                    _ped->SetFollowingPunct(pwchBuf);
                else
                {
                    Assert(pstate->sDest == destLeadingPunct);
                    _ped->SetLeadingPunct(pwchBuf);
                }
                FreePv(pwchBuf);
            }
            break;
#endif

        case destFieldResult:
            if(_szSymbolFieldResult)            // Field has been recalculated
                break;                          // old result out of use
            if(_szHyperlinkFldrslt)             // Append _szText to _szHyperlinkFldrslt
            {
                _ecParseError = AppendString(&_szHyperlinkFldrslt, _szText,
                                  &_cchHyperlinkFldrslt, &_cchHyperlinkFldrsltUsed);
                break;
            }
            // FALL THRU to default case

        default:
            HandleText(_szText, _token == tokenASCIIText ? ALL_ASCII : CONTAINS_NONASCII);
        }
        break;

    // \ltrmark, \rtlmark, \zwj, and \zwnj are translated directly into
    // their Unicode values. \ltrmark and \rtlmark cause no further
    // processing here because we assume that the current font has the
    // CharSet needed to identify the direction.
    case tokenLToRChars:                        // \ltrch
    case tokenRToLChars:                        // \rtlch
        pstate->fltrch = (_token == tokenLToRChars);
        pstate->frtlch = !pstate->fltrch;
        _ped->OrCharFlags(fBIDI);
        break;

    case tokenDBChars:                          // \dbch
        pstate->fdbch = TRUE;
        break;

    case tokenLToRDocument:                     // \ltrdoc
        PARSERCOVERAGE_CASE();
        _bDocType = DT_LTRDOC;
        break;

    case tokenRToLDocument:                     // \rtldoc
        PARSERCOVERAGE_CASE();
        _bDocType = DT_RTLDOC;
        break;


//------------------------- Object Control Words --------------------------------

    case tokenObject:                           // \object
        PARSERCOVERAGE_CASE();
        // V-GUYB: PWord Converter requires loss notification.
        #ifdef REPORT_LOSSAGE
        if(!(_dwFlags & SFF_SELECTION)) // SFF_SELECTION is set if any kind of paste is being done.
        {
            ((LOST_COOKIE*)(_pes->dwCookie))->bLoss = TRUE;
        }
        #endif // REPORT_LOSSAGE
        
        // Assume that the object failed to load until proven otherwise
        //  by RTFRead::ObjectReadFromEditStream
        // This works for both:
        //  - an empty \objdata tag
        //  - a non-existent \objdata tag
        _fFailedPrevObj = TRUE;

    case tokenPicture:                          // \pict
        PARSERCOVERAGE_CASE();

        pstate->sDest = (SHORT)(_token == tokenPicture ? destPicture : destObject);

        FreeRtfObject();
        _prtfObject = (RTFOBJECT *) PvAlloc(sizeof(RTFOBJECT), GMEM_ZEROINIT);
        if(!_prtfObject)
            goto OutOfRAM;
        _prtfObject->xScale = _prtfObject->yScale = 100;
        _prtfObject->cBitsPerPixel = 1;
        _prtfObject->cColorPlanes = 1;
        _prtfObject->szClass = NULL;
        _prtfObject->szName = NULL;
        _prtfObject->sType = -1;
        break;

    case tokenObjectEmbedded:                   // \objemb
    case tokenObjectLink:                       // \objlink
    case tokenObjectAutoLink:                   // \objautlink
        PARSERCOVERAGE_CASE();
        _prtfObject->sType = (SHORT)(_token - tokenObjectEmbedded + ROT_Embedded);
        break;

    case tokenObjectMacSubscriber:              // \objsub
    case tokenObjectMacPublisher:               // \objpub
    case tokenObjectMacICEmbedder:
        PARSERCOVERAGE_CASE();
        _prtfObject->sType = ROT_MacEdition;
        break;

    case tokenWidth:                            // \picw or \objw
        PARSERCOVERAGE_CASE();
        _prtfObject->xExt = iParam;
        break;

    case tokenHeight:                           // \pic or \objh
        PARSERCOVERAGE_CASE();
        _prtfObject->yExt = iParam;
        break;

    case tokenObjectSetSize:                    // \objsetsize
        PARSERCOVERAGE_CASE();
        _prtfObject->fSetSize = TRUE;
        break;

    case tokenScaleX:                           // \picscalex or \objscalex
        PARSERCOVERAGE_CASE();
        _prtfObject->xScale = iParam;
        break;

    case tokenScaleY:                           // \picscaley or \objscaley
        PARSERCOVERAGE_CASE();
        _prtfObject->yScale = iParam;
        break;

    case tokenCropLeft:                         // \piccropl or \objcropl
    case tokenCropTop:                          // \piccropt or \objcropt
    case tokenCropRight:                        // \piccropr or \objcropr
    case tokenCropBottom:                       // \piccropb or \objcropb
        PARSERCOVERAGE_CASE();
        *((LONG *)&_prtfObject->rectCrop
            + (_token - tokenCropLeft)) = iParam;
        break;

    case tokenObjectClass:                      // \objclass
        PARSERCOVERAGE_CASE();
        pstate->sDest = destObjectClass;
        break;

    case tokenObjectName:                       // \objname
        PARSERCOVERAGE_CASE();
        pstate->sDest = destObjectName;
        break;

    case tokenObjectResult:                     // \result
        PARSERCOVERAGE_CASE();
        if (_prtfObject &&                      // If it's Mac stuff, we don't
            _prtfObject->sType==ROT_MacEdition) //  understand the data, but
        {                                       //  we can try to do something
            pstate->sDest = destRTF;            //  with the results of the
        }                                       //  data
        else if(!_fFailedPrevObj && !_fNeedPres)// If we failed to retrieve
            goto skip_group;                    //  previous object, try to
                                                //  try to read results
        break;

    case tokenObjectData:                       // \objdata
        PARSERCOVERAGE_CASE();
        pstate->sDest = destObjectData;
        if(_prtfObject->sType==ROT_MacEdition)  // It's Mac stuff so just
            goto skip_group;                    //  throw away the data
        break;

    case tokenPictureWindowsMetafile:           // wmetafile
#ifdef NOMETAFILES
        goto skip_group;
#endif NOMETAFILES

    case tokenPictureWindowsBitmap:             // wbitmap
    case tokenPictureWindowsDIB:                // dibitmap
        PARSERCOVERAGE_CASE();
        _prtfObject->sType = (SHORT)(_token - tokenPictureWindowsBitmap + ROT_Bitmap);
        _prtfObject->sPictureType = (SHORT)iParam;
        break;

    case tokenBitmapBitsPerPixel:               // \wbmbitspixel
        PARSERCOVERAGE_CASE();
        _prtfObject->cBitsPerPixel = (SHORT)iParam;
        break;

    case tokenBitmapNumPlanes:                  // \wbmplanes
        PARSERCOVERAGE_CASE();
        _prtfObject->cColorPlanes = (SHORT)iParam;
        break;

    case tokenBitmapWidthBytes:                 // \wbmwidthbytes
        PARSERCOVERAGE_CASE();
        _prtfObject->cBytesPerLine = (SHORT)iParam;
        break;

    case tokenDesiredWidth:                     // \picwgoal
        PARSERCOVERAGE_CASE();
        _prtfObject->xExtGoal = (SHORT)iParam;
        break;

    case tokenDesiredHeight:                    // \pichgoal
        PARSERCOVERAGE_CASE();
        _prtfObject->yExtGoal = (SHORT)iParam;
        break;

    case tokenBinaryData:                       // \bin
        PARSERCOVERAGE_CASE();

        if(_cbSkipForUnicode)
        {
            // a \binN and its associated binary data count as a single
            //  character for the purposes of skipping over characters
            //  following a \uN
            _cbSkipForUnicode--;
            SkipBinaryData(iParam);
        }
        else
        {
            // update OleGet function
            RTFReadOLEStream.lpstbl->Get =
                    (DWORD (CALLBACK* )(LPOLESTREAM, void FAR*, DWORD))
                           RTFGetBinaryDataFromStream;
            // set data length
            _cbBinLeft = iParam;
        
            switch (pstate->sDest)
            {
                case destObjectData:
                    _fFailedPrevObj = !ObjectReadFromEditStream();
                    break;
                case destPicture:
                    StaticObjectReadFromEditStream(iParam);
                    break;

                default:
                    AssertSz(FALSE, "Binary data hit but don't know where to put it");
            }

            // restore OleGet function
            RTFReadOLEStream.lpstbl->Get =
                    (DWORD (CALLBACK* )(LPOLESTREAM, void FAR*, DWORD))
                        RTFGetFromStream;
        }

        break;

    case tokenObjectDataValue:
        PARSERCOVERAGE_CASE();
        _fFailedPrevObj = !ObjectReadFromEditStream();
        goto EndOfObjectStream;
    
    case tokenPictureDataValue:
        PARSERCOVERAGE_CASE();
        StaticObjectReadFromEditStream();
EndOfObjectStream:
        if(!SkipToEndOfGroup())
            HandleEndGroup();
        break;          

    case tokenObjectPlaceholder:
        PARSERCOVERAGE_CASE();
        if(_ped->GetEventMask() & ENM_OBJECTPOSITIONS)
        {
            if(!_pcpObPos)
            {
                _pcpObPos = (LONG *)PvAlloc(sizeof(ULONG) * cobPosInitial, GMEM_ZEROINIT);
                if(!_pcpObPos)
                {
                    _ecParseError = ecNoMemory;
                    break;
                }
                _cobPosFree = cobPosInitial;
                _cobPos = 0;
            }
            if(_cobPosFree-- <= 0)
            {
                const int cobPosNew = _cobPos + cobPosChunk;
                LPVOID pv;

                pv = PvReAlloc(_pcpObPos, sizeof(ULONG) * cobPosNew);
                if(!pv)
                {
                    _ecParseError = ecNoMemory;
                    break;
                }
                _pcpObPos = (LONG *)pv;
                _cobPosFree = cobPosChunk - 1;
            }
            _pcpObPos[_cobPos++] = _prg->GetCp();
        }
        break;

    default:
        PARSERCOVERAGE_DEFAULT();
        if(pstate->sDest != destFieldInstruction && // Values outside token
           (DWORD)(_token - tokenMin) >             //  range are treated
                (DWORD)(tokenMax - tokenMin))       //  as Unicode chars
        {
            // Currently we don't allow TABs in tables
            if(_token == TAB && pstate->fInTable)   
                _token = TEXT(' '); 
            
            // 1.0 mode doesn't use Unicode bullets nor smart quotes
            if (_ped->Get10Mode() && IN_RANGE(LQUOTE, _token, RDBLQUOTE))
            {
                if (_token == LQUOTE || _token == RQUOTE)
                    _token = L'\'';
                else if (_token == LDBLQUOTE || _token == RDBLQUOTE)
                    _token = L'\"';
            }

            HandleChar(_token);
        }
        #if defined(DEBUG)
        else
        {
            if(GetProfileIntA("RICHEDIT DEBUG", "RTFCOVERAGE", 0))
            {
                CHAR *pszKeyword = PszKeywordFromToken(_token);
                CHAR szBuf[256];

                sprintf(szBuf, "CRTFRead::HandleToken():  Token not processed - token = %d, %s%s%s",
                            _token,
                            "keyword = ",
                            pszKeyword ? "\\" : "<unknown>",
                            pszKeyword ? pszKeyword : "");

                AssertSz(0, szBuf);
            }
        }
        #endif
    }

done:
    TRACEERRSZSC("HandleToken()", - _ecParseError);
    return _ecParseError;
}

/*
 *  CRTFRead::ReadRtf()
 *
 *  @mfunc
 *      The range _prg is replaced by RTF data resulting from parsing the
 *      input stream _pes.  The CRTFRead object assumes that the range is
 *      already degenerate (caller has to delete the range contents, if
 *      any, before calling this routine).  Currently any info not used
 *      or supported by RICHEDIT is thrown away.
 *
 *  @rdesc
 *      Number of chars inserted into text.  0 means none were inserted
 *      OR an error occurred.
 */
LONG CRTFRead::ReadRtf()
{
    TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::ReadRtf");

    CTxtRange * prg = _prg;
    STATE *     pstate;
    LONG        cpFirstInPara;

    _cpFirst = prg->GetCp();
    if(!InitLex())
        goto Quit;

    TESTPARSERCOVERAGE();

    AssertSz(!prg->GetCch(),
        "CRTFRead::ReadRtf: range must be deleted");

    if(!(_dwFlags & SFF_SELECTION))
    {
        // SFF_SELECTION is set if any kind of paste is being done, i.e.,
        // not just that using the selection.  If it isn't set, data is
        // being streamed in and we allow this to reset the doc params
        _ped->InitDocInfo();
    }

    prg->SetIgnoreFormatUpdate(TRUE);

    _szUnicode = (TCHAR *)PvAlloc(cachTextMax * sizeof(TCHAR), GMEM_ZEROINIT);
    if(!_szUnicode)                 // Allocate space for Unicode conversions
    {
        _ped->GetCallMgr()->SetOutOfMemory();
        _ecParseError = ecNoMemory;
        goto CleanUp;
    }
    _cchUnicode = cachTextMax;

    // Initialize per-read variables
    _nCodePage = (_dwFlags & SF_USECODEPAGE)
               ? (_dwFlags >> 16) : INVALID_CODEPAGE;

    // Populate _PF with initial paragraph formatting properties
    _PF = *prg->GetPF();
	_dwMaskPF  = PFM_ALLRTF;			// Setup initial MaskPF
    _PF._iTabs = -1;                    // In case it's not -1
    _fInTable = _PF.InTable();

    // V-GUYB: PWord Converter requires loss notification.
    #ifdef REPORT_LOSSAGE
    if(!(_dwFlags & SFF_SELECTION))         // SFF_SELECTION is set if any
    {                                       //  kind of paste is being done
        ((LOST_COOKIE*)(_pes->dwCookie))->bLoss = FALSE;
    }
    #endif // REPORT_LOSSAGE

    // Valid RTF files start with "{\rtf", "{urtf", or "{\pwd"
    GetChar();                              // Fill input buffer                            
    UngetChar();                            // Put char back
    if(!IsRTF((char *)_pchRTFCurrent))      // Is it RTF?
    {                                       // No
        if (_ped->Get10Mode())
            _fNoRTFtoken = TRUE;
        else
        {
            _ecParseError = ecUnexpectedToken;  // Signal bad file
            goto CleanUp;
        }
    }

    // If initial cp follows EOP, use it for _cpThisPara.  Else
    // search for start of para containing the initial cp.
    _cpThisPara = _cpFirst;
    if(!prg->_rpTX.IsAfterEOP())
    {
        CTxtPtr tp(prg->_rpTX);
        tp.FindEOP(tomBackward);
        _cpThisPara = tp.GetCp();
    }
    cpFirstInPara = _cpThisPara;            // Backup to start of para before
                                            //  parsing
    while ( TokenGetToken() != tokenEOF &&  // Process tokens
            _token != tokenError        &&
            !HandleToken()              &&
            _pstateStackTop )
        ;

    if(_iCell)
    {
        if(_ecParseError == ecTextMax)  // Truncated table. Delete incomplete
        {                               //  row to keep Word happy
            CTxtPtr tp(prg->_rpTX);
            prg->Set(prg->GetCp(), -tp.FindEOP(tomBackward));
            prg->Delete(NULL, SELRR_IGNORE);
        }
        else
            AssertSz(FALSE, "CRTFRead::ReadRTF: Inserted cells but no row end");
    }
    _cCell = _iCell = 0;

    prg->SetIgnoreFormatUpdate(FALSE);          // Enable range _iFormat updates
    prg->Update_iFormat(-1);                    // Update _iFormat to CF
                                                //  at current active end
    if(!(_dwFlags & SFF_SELECTION))             // RTF applies to document:
    {                                           //  update CDocInfo
        // Apply char and para formatting of
        //  final text run to final CR
        if(prg->GetCp() == _ped->GetAdjustedTextLength())
        {
            // REVIEW: we need to think about what para properties should
            // be transferred here. E.g., borders were being transferred
            // incorrectly
            _dwMaskPF &= ~(PFM_BORDER | PFM_SHADING);
            Apply_PF();
            prg->ExtendFormattingCRLF();
        }

        // Update the per-document information from the RTF read
        CDocInfo *pDocInfo = _ped->GetDocInfo();

        if(!pDocInfo)
        {
            _ecParseError = ecNoMemory;
            goto CleanUp;
        }

        if (ecNoError == _ecParseError)         // If range end EOP wasn't
        {                                       // deleted and  new text
            prg->DeleteTerminatingEOP(NULL);    //  ends with an EOP, delete that EOP
        }

        pDocInfo->wCpg = (WORD)(_nCodePage == INVALID_CODEPAGE ?
                                        tomInvalidCpg : _nCodePage);
        if (pDocInfo->wCpg == CP_UTF8)
            pDocInfo->wCpg = 1252;

        _ped->SetDefaultLCID(_sDefaultLanguage == INVALID_LANGUAGE ?
                                tomInvalidLCID :
                                MAKELCID(_sDefaultLanguage, SORT_DEFAULT));

        _ped->SetDefaultLCIDFE(_sDefaultLanguageFE == INVALID_LANGUAGE ?
                                tomInvalidLCID :
                                MAKELCID(_sDefaultLanguageFE, SORT_DEFAULT));

        _ped->SetDefaultTabStop(TWIPS_TO_FPPTS(_sDefaultTabWidth));
        _ped->SetDocumentType(_bDocType);
    }

    if(_ped->IsComplexScript() && prg->GetCp() > cpFirstInPara)
    {
        Assert(!prg->GetCch());
        LONG    cpSave = prg->GetCp();
        LONG    cpLastInPara = cpSave;
        
        if(!prg->_rpTX.IsAtEOP())
        {
            CTxtPtr tp(prg->_rpTX);
            tp.FindEOP(tomForward);
            cpLastInPara = tp.GetCp();
            prg->Advance(cpLastInPara - cpSave);
        }
        // Itemize from the start of paragraph to be inserted till the end of
        // paragraph inserting. We need to cover all affected paragraphs because
        // paragraphs we're playing could possibly in conflict direction. Think
        // about the case that the range covers one LTR para and one RTL para, then
        // the inserting text covers one RTL and one LTR. Both paragraphs' direction
        // could have been changed after this insertion.
                
        prg->ItemizeReplaceRange(cpLastInPara - cpFirstInPara, 0, NULL);
        if (cpLastInPara != cpSave)
            prg->SetCp(cpSave);
    }

CleanUp:
    FreeRtfObject();

    pstate = _pstateStackTop;
    if(pstate)                                  // Illegal RTF file. Release
    {                                           //  unreleased format indices
        if(ecNoError == _ecParseError)          // It's only an overflow if no
            _ecParseError = ecStackOverflow;    //  other error has occurred

        while(pstate->pstatePrev)
        {
            pstate = pstate->pstatePrev;
            ReleaseFormats(pstate->iCF, -1);
        }
    }

    pstate = _pstateLast;
    if(pstate)
    {
        while(pstate->pstatePrev)               // Free all but first STATE
        {
            pstate->DeletePF();
            pstate = pstate->pstatePrev;
            FreePv(pstate->pstateNext);
        }
        pstate->DeletePF();
    }
    Assert(_PF._iTabs == -1);
    FreePv(pstate);                             // Free first STATE
    FreePv(_szUnicode);
    FreePv(_szHyperlinkFldinst);
    FreePv(_szHyperlinkFldrslt);

Quit:
    DeinitLex();

    if(_pcpObPos)
    {
        if((_ped->GetEventMask() & ENM_OBJECTPOSITIONS) && _cobPos > 0)
        {
            OBJECTPOSITIONS obpos;

            obpos.cObjectCount = _cobPos;
            obpos.pcpPositions = _pcpObPos;

            if (_ped->Get10Mode())
            {
                int i;
                LONG *pcpPositions = _pcpObPos;

                for (i = 0; i < _cobPos; i++, pcpPositions++)
                    *pcpPositions = _ped->GetAcpFromCp(*pcpPositions);
            }

            _ped->TxNotify(EN_OBJECTPOSITIONS, &obpos);
        }

        FreePv(_pcpObPos);
        _pcpObPos = NULL;
    }

#ifdef MACPORT
#if defined(ERROR_HANDLE_EOF) && ERROR_HANDLE_EOF != 38L
#error "ERROR_HANDLE_EOF value incorrect"
#endif
// transcribed from winerror.h
#define ERROR_HANDLE_EOF                 38L
#endif

    // FUTURE(BradO):  We should devise a direct mapping from our error codes
    //                  to Win32 error codes.  In particular our clients are
    //                  not expecting the error code produced by:
    //                      _pes->dwError = (DWORD) -(LONG) _ecParseError;
    if(_ecParseError)
    {
        AssertSz(_ecParseError >= 0,
            "Parse error is negative");

        if(_ecParseError == ecTextMax)
        {
            _ped->GetCallMgr()->SetMaxText();
            _pes->dwError = (DWORD)STG_E_MEDIUMFULL;
        }
        if(_ecParseError == ecUnexpectedEOF)
            _pes->dwError = (DWORD)HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);

        if(!_pes->dwError && _ecParseError != ecTruncateAtCRLF)
            _pes->dwError = (DWORD) -(LONG) _ecParseError;

#if defined(DEBUG)
        TRACEERRSZSC("CchParse_", _pes->dwError);
        if(ecNoError < _ecParseError && _ecParseError < ecLastError)
            Tracef(TRCSEVERR, "Parse error: %s", rgszParseError[_ecParseError]);
#endif
    }

    return prg->GetCp() - _cpFirst;
}


/*
 *  CRTFRead::CpgInfoFromFaceName()
 *
 *  @mfunc
 *      This routine fills in the TEXTFONT::bCharSet and TEXTFONT::nCodePage
 *      members of the TEXTFONT structure by querying the system for the
 *      metrics of the font described by TEXTFONT::szName.
 *
 *  @rdesc
 *      A flag indicating whether the charset and codepage were successfully
 *      determined.
 */
BOOL CRTFRead::CpgInfoFromFaceName(
    TEXTFONT *ptf)
{
    // FUTURE(BradO): This code is a condensed version of a more sophisticated
    // algorithm we use in font.cpp to second-guess the font-mapper.
    // We should factor out the code from font.cpp for use here as well.

    // Indicates that we've tried to obtain the cpg info from the system,
    // so that after a failure we don't re-call this routine.   
    ptf->fCpgFromSystem = TRUE;

    if(ptf->fNameIsDBCS)
    {
        // If fNameIsDBCS, we have high-ANSI characters in the facename, and
        // no codepage with which to interpret them.  The facename is gibberish,
        // so don't waste time calling the system to match it.
        return FALSE;
    }

    HDC hdc = _ped->TxGetDC();
    if(!hdc)
        return FALSE;

    LOGFONT    lf = {0};
    TEXTMETRIC tm;

    wcscpy(lf.lfFaceName, ptf->szName);
    lf.lfCharSet = GetCharSet(GetSystemDefaultCodePage());

    if(!GetTextMetrics(hdc, lf, tm) || tm.tmCharSet != lf.lfCharSet)
    {
        lf.lfCharSet = DEFAULT_CHARSET;     // Doesn't match default sys
        GetTextMetrics(hdc, lf, tm);    //  charset, so see what
    }                                       //  DEFAULT_CHARSET gives
    _ped->TxReleaseDC(hdc);

    if(tm.tmCharSet != DEFAULT_CHARSET)     // Got something, so use it
    {
        ptf->bCharSet  = tm.tmCharSet;
        ptf->sCodePage = (SHORT)GetCodePage(tm.tmCharSet);
        return TRUE;
    }

    return FALSE;
}

#if defined(DEBUG)
/*
 *  CRTFRead::TestParserCoverage()
 *
 *  @mfunc
 *      A debug routine used to test the coverage of HandleToken.  The routine
 *      puts the routine into a debug mode and then determines:
 *      
 *          1.  Dead tokens - (T & !S & !P)
 *              Here, token:
 *                  a) is defined in tom.h  (T)
 *                  b) does not have a corresponding keyword (not scanned)  (!S)
 *                  c) is not processed by HandleToken  (!P)
 *          2.  Tokens that are parsed but not scanned - (T & !S & P)
 *              Here, token:
 *                  a) is defined in tom.h  (T)
 *                  b) does not have a corresponding keyword (not scanned)  (!S}
 *                  c) is processed by HandleToken  (P)
 *          3.  Tokens that are scanned but not parsed - (T & S & !P)
 *              Here, token:
 *                  a) is defined in tom.h  (T)
 *                  b) does have a corresponding keyword (is scanned)  (S)
 *                  c) is not processed by HandleToken  (!P)
 */
void CRTFRead::TestParserCoverage()
{
    int i;
    char *rgpszKeyword[tokenMax - tokenMin];
    BOOL rgfParsed[tokenMax - tokenMin];
    char szBuf[256];

    // Put HandleToken in debug mode
    _fTestingParserCoverage = TRUE;

    // Gather info about tokens/keywords
    for(i = 0; i < tokenMax - tokenMin; i++)
    {
        _token = (TOKEN)(i + tokenMin);
        rgpszKeyword[i] = PszKeywordFromToken(_token);
        rgfParsed[i] = HandleToken() == ecNoError;
    }

    // Reset HandleToken to non-debug mode
    _fTestingParserCoverage = FALSE;

    // Should coverage check include those we know will fail test, but
    // which we've examined and know why they fail?
    BOOL fExcuseCheckedToks = TRUE;

    if(GetProfileIntA("RICHEDIT DEBUG", "RTFCOVERAGESTRICT", 0))
        fExcuseCheckedToks = FALSE;

    // (T & !S & !P)  (1. above)
    for(i = 0; i < tokenMax - tokenMin; i++)
    {
        if(rgpszKeyword[i] || rgfParsed[i])
            continue;

        TOKEN tok = (TOKEN)(i + tokenMin);

        // token does not correspond to a keyword, but still may be scanned
        // check list of individual symbols which are scanned
        if(FTokIsSymbol(tok))
            continue;

        // check list of tokens which have been checked and fail
        // the sanity check for some known reason (see FTokFailsCoverageTest def'n)
        if(fExcuseCheckedToks && FTokFailsCoverageTest(tok))
            continue;

        sprintf(szBuf, "CRTFRead::TestParserCoverage():  Token neither scanned nor parsed - token = %d", tok);
        AssertSz(0, szBuf);
    }
                
    // (T & !S & P)  (2. above)
    for(i = 0; i < tokenMax - tokenMin; i++)
    {
        if(rgpszKeyword[i] || !rgfParsed[i])
            continue;

        TOKEN tok = (TOKEN)(i + tokenMin);

        // token does not correspond to a keyword, but still may be scanned
        // check list of individual symbols which are scanned
        if(FTokIsSymbol(tok))
            continue;

        // check list of tokens which have been checked and fail
        // the sanity check for some known reason (see FTokFailsCoverageTest def'n)
        if(fExcuseCheckedToks && FTokFailsCoverageTest(tok))
            continue;

        sprintf(szBuf, "CRTFRead::TestParserCoverage():  Token parsed but not scanned - token = %d", tok);
        AssertSz(0, szBuf);
    }

    // (T & S & !P)  (3. above)
    for(i = 0; i < tokenMax - tokenMin; i++)
    {
        if(!rgpszKeyword[i] || rgfParsed[i])
            continue;

        TOKEN tok = (TOKEN)(i + tokenMin);

        // check list of tokens which have been checked and fail
        // the sanity check for some known reason (see FTokFailsCoverageTest def'n)
        if(fExcuseCheckedToks && FTokFailsCoverageTest(tok))
            continue;

        sprintf(szBuf, "CRTFRead::TestParserCoverage():  Token scanned but not parsed - token = %d, tag = \\%s", tok, rgpszKeyword[i]);
        AssertSz(0, szBuf);
    }
}

/*
 *  CRTFRead::PszKeywordFromToken()
 *
 *  @mfunc
 *      Searches the array of keywords and returns the keyword
 *      string corresponding to the token supplied
 *
 *  @rdesc
 *      returns a pointer to the keyword string if one exists
 *      and NULL otherwise
 */
CHAR *CRTFRead::PszKeywordFromToken(TOKEN token)
{
    for(int i = 0; i < cKeywords; i++)
    {
        if(rgKeyword[i].token == token)
            return rgKeyword[i].szKeyword;
    }
    return NULL;
}


/*
 *  CRTFRead::FTokIsSymbol(TOKEN tok)
 *
 *  @mfunc
 *      Returns a BOOL indicating whether the token, tok, corresponds to an RTF symbol
 *      (that is, one of a list of single characters that are scanned in the
 *      RTF reader)
 *
 *  @rdesc
 *      BOOL -  indicates whether the token corresponds to an RTF symbol
 *
 */
BOOL CRTFRead::FTokIsSymbol(TOKEN tok)
{
    const BYTE *pbSymbol = NULL;

    extern const BYTE szSymbolKeywords[];
    extern const TOKEN tokenSymbol[];

    // check list of individual symbols which are scanned
    for(pbSymbol = szSymbolKeywords; *pbSymbol; pbSymbol++)
    {
        if(tokenSymbol[pbSymbol - szSymbolKeywords] == tok)
            return TRUE;
    }
    return FALSE;
}


/*
 *  CRTFRead::FTokFailsCoverageTest(TOKEN tok)
 *
 *  @mfunc
 *      Returns a BOOL indicating whether the token, tok, is known to fail the
 *      RTF parser coverage test.  These tokens are those that have been checked
 *      and either:
 *          1) have been implemented correctly, but just elude the coverage test
 *          2) have yet to be implemented, and have been recognized as such
 *
 *  @rdesc
 *      BOOL -  indicates whether the token has been checked and fails the
 *              the parser coverage test for some known reason
 *
 */
BOOL CRTFRead::FTokFailsCoverageTest(TOKEN tok)
{
    switch(tok)
    {
    // (T & !S & !P)  (1. in TestParserCoverage)
        // these really aren't tokens per se, but signal ending conditions for the parse
        case tokenError:
        case tokenEOF:

    // (T & !S & P)  (2. in TestParserCoverage)
        // emitted by scanner, but don't correspond to recognized RTF keyword
        case tokenUnknownKeyword:
        case tokenText:
        case tokenASCIIText:

        // recognized directly (before the scanner is called)
        case tokenStartGroup:
        case tokenEndGroup:

        // recognized using context information (before the scanner is called)
        case tokenObjectDataValue:
        case tokenPictureDataValue:

    // (T & S & !P)  (3. in TestParserCoverage)
        // None

            return TRUE;
    }

    return FALSE;
}
#endif // DEBUG


// Including a source file, but we only want to compile this code for debug purposes
// TODO: Implement RTF tag logging for the Mac
#if defined(DEBUG) && !defined(MACPORT)
#include "rtflog.cpp"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\rtfread2.cpp ===
/*
 *	rtfread2.cpp
 *
 *	Description:
 *		This file contains the object functions for RichEdit RTF reader
 *
 *		Original RichEdit 1.0 RTF converter: Anthony Francisco
 *		Conversion to C++ and RichEdit 2.0:  Murray Sargent
 *
 *	* NOTE:
 *	*	All sz's in the RTF*.? files refer to a LPSTRs, not LPTSTRs, unless
 *	*	noted as a szW.
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"

#include "_rtfread.h"
#include "_coleobj.h"
//#include "_nlsprcs.h"

const char szFontsel[]="\\f";

ASSERTDATA


/*
 *	CRTFRead::HandleFieldInstruction()
 *
 *	@mfunc
 *		Handle field instruction
 *
 *	@rdesc
 *		EC		The error code
 */
EC CRTFRead::HandleFieldInstruction()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::HandleFieldInstruction");

//TODO rewrite this function for common case
//FUTURE save field instruction

	BYTE *pch, *pch1;

	for(pch1 = _szText; *pch1 == ' '; pch1++)	// Bypass any leading blanks
		;
	for(pch = pch1; *pch && *pch != ' '; pch++)
		;

	_fHyperlinkField = FALSE;
	if(W32->ASCIICompareI(pch1, (BYTE *) "SYMBOL", 6))
		HandleFieldSymbolInstruction(pch);	//  SYMBOL

	else if (W32->ASCIICompareI(pch1, (BYTE *) "HYPERLINK", 9))
	{
		_fHyperlinkField = TRUE;
		HandleFieldHyperlink(pch);
	}
	// save the current formatting for the field result
	_FieldCF = _CF;
	_ptfField = _pstateStackTop->ptf;
	_nFieldCodePage = _pstateStackTop->nCodePage;
	_dwMaskFieldCF = _dwMaskCF;
	_dwMaskFieldCF2 = _dwMaskCF2;


	TRACEERRSZSC("HandleFieldInstruction()", - _ecParseError);
	return _ecParseError;
}

/*
 *	CRTFRead::HandleFieldSymbolInstruction(pch)
 *
 *	@mfunc
 *		Handle specific  symbol field
 *
 *	@rdesc
 *		EC	The error code
 *
 *	@devnote 
 *		FUTURE: the two whiles below can be combined into one fairly easily;
 *		Look at the definitions of IsXDigit() and IsDigit() and introduce
 *		a variable flag as well as a variable base multiplier (= 10 or 16).
 */
EC CRTFRead::HandleFieldSymbolInstruction(
	BYTE *pch )		//@parm Pointer to SYMBOL field instruction
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::HandleFieldInstruction");

	BYTE	ch;
	BYTE	chSymbol = 0;
	const char *pchFontsel = szFontsel;

	while (*pch == ' ')						// Eat spaces
		++pch;
											// Collect symbol char's code 
	if (*pch == '0' &&						//  which may be in decimal
 		(*++pch | ' ') == 'x')				//  or hex
	{										// It's in hex
		ch = *++pch;
	   	while (ch && IsXDigit(ch))
	   	{
			chSymbol <<= 4;
			chSymbol += (ch <= '9') ? ch - '0' : (ch & 0x4f) - 'A' + 10;
			ch = *pch++;
	   	}
	}
	else									// Decimal
	{
	   ch = *pch;
	   while (ch && IsDigit(ch))
	   {
			chSymbol *= 10;
			chSymbol += ch - '0' ;
			ch = *++pch;
	   }
	}
	_szSymbolFieldResult = (BYTE *)PvAlloc(2, GMEM_ZEROINIT);

	if (NULL == _szSymbolFieldResult)
	{
	 	_ecParseError = ecNoMemory;
		goto CleanUp;
	}

	_szSymbolFieldResult[0] = chSymbol;

	// now check for the \\f "Facename" construct 
	// and deal with it

	while (*pch == ' ')						// Eat spaces
		++pch;

	while (*pch && *pch == *pchFontsel)		// Make sure *pch is a \f
	{										
		++pch;
		++pchFontsel;
	}
	if	(! (*pchFontsel) )
	{
		_ecParseError = HandleFieldSymbolFont(pch);	//  \\f "Facename"
	}

// ASSERTION   font & font size  will be in field result \flds
// BUGBUG: A more robust implementation would parse the font
// and font size from both \fldinst and \fldrslt (RE1.0 does this)
	
CleanUp:
	TRACEERRSZSC("HandleFieldInstruction()", - _ecParseError);
	return _ecParseError;
}

/*
 *	CRTFRead::HandleFieldSymbolFont(pch)
 *
 *	@mfunc
 *		Handle the \\f "Facename" instruction in the SYMBOL field
 *
 *	@rdesc
 *		EC	The error code
 *
 *	@devnote WARNING: may change _szText
 */
EC CRTFRead::HandleFieldSymbolFont(
	BYTE *pch)		//@parm Ptr to symbol field
{
	SHORT iFont = _fonts.Count();
	TEXTFONT tf;
	TEXTFONT *ptf = &tf;

	_pstateStackTop->ptf = &tf;
	// ReadFontName tries to append
	tf.szName[0] = '\0';

	// skip the initial blanks and quotes
	while (*pch && (*pch == ' ' || *pch == '\"'))
		++pch;

	// DONT WORRY, we'll get it back to normal
	// ReadFontName depends on _szText, so we need to alter it and then restore
	// it's just too bad we have to do it ...
	BYTE* szTextBAK = _szText;
	BOOL fAllAscii = TRUE;

	_szText = pch;

	// transform the trailing quote into ';'
	while (*pch)
	{
		if (*pch == '\"')
		{
			*pch = ';';
			break;
		}

		if(*pch > 0x7f)
			fAllAscii = FALSE;

		++pch;
	}

	// NOW we can read the font name!!
	ReadFontName(_pstateStackTop, fAllAscii ? ALL_ASCII : CONTAINS_NONASCII);

	// Try to find this face name in the font table
	BOOL fFontFound = FALSE;
	for (SHORT i = 0; i < iFont; ++i)
	{
		TEXTFONT *ptfTab = _fonts.Elem(i);
		if (0 == wcscmp(ptf->szName, ptfTab->szName))
		{
			fFontFound = TRUE;
			i = ptfTab->sHandle;
			break;
		}
	}

	// did we find the face name?
	if (!fFontFound)
	{
		Assert(i == iFont);
		i+= RESERVED_FONT_HANDLES;

		// Make room in font table for
		//  font to be inserted
		if (!(ptf =_fonts.Add(1,NULL)))
		{									
			_ped->GetCallMgr()->SetOutOfMemory();
			_ecParseError = ecNoMemory;
			goto exit;
		}

		// repeating inits from tokenFontSelect
		ptf->sHandle	= i;				// Save handle
		wcscpy(ptf->szName, tf.szName); 
		ptf->bPitchAndFamily = 0;
		ptf->fNameIsDBCS = FALSE;
		ptf->sCodePage = (SHORT)_nCodePage;
		ptf->bCharSet = DEFAULT_CHARSET;	// SYMBOL_CHARSET ??
	}

	SelectCurrentFont(i);
	
exit:
	// needs to go back to normal
	_szText = szTextBAK;

	return _ecParseError;
}

/*
 *	CRTFRead::HandleFieldHyperlink(pch)
 *
 *	@mfunc
 *		Handle HYPERLINK field
 *
 *	@rdesc
 *		EC	The error code
 */
EC CRTFRead::HandleFieldHyperlink(
	BYTE *pch)		//@parm Pointer to HYPERLINK field instruction
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::HandleFieldHyperlink");

	BYTE *pBuffer;

	for( ; *pch == ' '; pch++) ;				// Skip leading blanks

	// allocate the buffer and add the string to it
	_cchHyperlinkFldinst = MAX_PATH;
	_cchHyperlinkFldinstUsed = 1;
	pBuffer = (BYTE *)PvAlloc( MAX_PATH, GMEM_FIXED );
	
	if ( !pBuffer )
		return ( _ecParseError = ecNoMemory );		 

	pBuffer[0] = ' ';
	pBuffer[1] = '\0';
	_szHyperlinkFldinst = pBuffer;
	
	if ( *pch )
	{	
		_ecParseError = AppendString( &_szHyperlinkFldinst, pch, &_cchHyperlinkFldinst, &_cchHyperlinkFldinstUsed );
	}

	return _ecParseError;
}

/*
 *	CRTFRead::ReadData(pbBuffer, cbBuffer)
 *
 *	@mfunc
 *		Read in object data. This must be called only after all initial
 *		object header info has been read.
 *
 *	@rdesc
 *		LONG	count of bytes read in
 */
LONG CRTFRead::ReadData(
	BYTE *	pbBuffer,	//@parm Ptr to buffer where to put data
	LONG	cbBuffer)	//@parm How many bytes to read in
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::ReadData");

	BYTE bChar0, bChar1;
	LONG cbLeft = cbBuffer;

	while (cbLeft && (bChar0 = GetHexSkipCRLF()) < 16 && 
					 (bChar1 = GetHexSkipCRLF()) < 16)
	{	
		*pbBuffer++ = bChar0 << 4 | bChar1;
		cbLeft--;
	}							   
	return cbBuffer - cbLeft ; 
}

/*
 *	CRTFRead::ReadBinaryData(pbBuffer, cbBuffer)
 *
 *	@mfunc
 *		Read cbBuffer bytes into pbBuffer
 *
 *	@rdesc
 *		Count of bytes read in
 */
LONG CRTFRead::ReadBinaryData(
	BYTE *	pbBuffer,	//@parm Ptr to buffer where to put data
	LONG	cbBuffer)	//@parm How many bytes to read in
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::ReadBinaryData");

	LONG cbLeft = min(_cbBinLeft, cbBuffer);

	cbBuffer = cbLeft;

	for (; cbLeft > 0 ; cbLeft--)
	{
		*pbBuffer++ = GetChar();
	}

	_cbBinLeft -= cbBuffer; 

	return cbBuffer ;
}

/*
 *	CRTFRead::SkipBinaryData(cbSkip)
 *
 *	@mfunc
 *		Skip cbSkip bytes in input streamd
 *
 *	@rdesc
 *		LONG	count of bytes skipped
 */
LONG CRTFRead::SkipBinaryData(
	LONG cbSkip)	//@parm Count of bytes to skip
{
	BYTE rgb[1024];

	_cbBinLeft = cbSkip;

	while(ReadBinaryData(rgb, sizeof(rgb)) > 0) 
		;
	return cbSkip;
}

/*
 *	CRTFRead::ReadRawText(pszRawText)
 *
 *	@mfunc
 *		Read in raw text until }.  A buffer is allocated to save the text.
 *		The caller is responsible to free the buffer later.
 *
 *	@rdesc
 *		LONG	count of bytes read
 */
LONG CRTFRead::ReadRawText(
	char	**pszRawText)	//@parm Address of the buffer containing the raw text
{
	LONG	cch=0;
	char	*szRawTextStart = NULL;
	char	*szRawText = NULL;
	char	chLast=0;
	char	ch;
	short	cRBrace=0;
	LONG	cchBuffer = 0;
	bool	fNeedBuffer = (pszRawText != NULL);

	if (fNeedBuffer)
	{
		*pszRawText = NULL;
		cchBuffer = 128;
		szRawText = szRawTextStart = (char *)PvAlloc(128, GMEM_ZEROINIT);

		if(!szRawTextStart)
		{
			_ecParseError = ecNoMemory;
			return 0;
		}
	}

	while (_ecParseError == ecNoError)
	{
		ch = GetChar();
		
		if (ch == 0)		
			break;			// error case

		if (ch == LF || ch == CR)
			continue;		// ignore noice characters

		if (ch == '}' && chLast != '\\')
		{
			if (!cRBrace)
			{
				// Done
				UngetChar();

				if (fNeedBuffer)
					*szRawText = '\0';

				break;
			}
			cRBrace--;	// count the RBrace so we will ignore the matching pair of LBrace
		}

		if (ch == '{' && chLast != '\\')
			cRBrace++;

		chLast = ch;
		cch++;

		if (fNeedBuffer)
		{
			*szRawText = ch;
			
			if (cch == cchBuffer)
			{
				// Re-alloc a bigger buffer
				char *pNewBuff = (char *)PvReAlloc(szRawTextStart, cchBuffer + 64);
				
				if (!pNewBuff)
				{				
					_ecParseError = ecNoMemory;
					break;
				}
				
				cchBuffer += 64;
				szRawTextStart = pNewBuff;
				szRawText = szRawTextStart + cch;
			}
			else
				szRawText++;
		}
	}
	
	if (fNeedBuffer)
	{
		if (_ecParseError == ecNoError)
			*pszRawText = szRawTextStart;
		else
			FreePv(szRawTextStart);
	}
	return cch;
}

/*
 *	CRTFRead::StrAlloc(ppsz, sz)
 *
 *	@mfunc
 *		Set up a pointer to a newly allocated space to hold a string
 *
 *	@rdesc
 *		EC		The error code
 */
EC CRTFRead::StrAlloc(
	TCHAR ** ppsz,	//@parm Ptr to ptr to string that needs allocation
	BYTE *	 sz)	//@parm String to be copied into allocated space
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::StrAlloc");

	int Length =  strlen((CHAR *)sz)+1 ;

	*ppsz = (TCHAR *) PvAlloc((Length + 1)*sizeof(TCHAR), GMEM_ZEROINIT);
	if (!*ppsz)
	{
		_ped->GetCallMgr()->SetOutOfMemory();
		_ecParseError = ecNoMemory;
		goto Quit;
	}
	MultiByteToWideChar(CP_ACP,0,(char *)sz,-1,*ppsz,Length) ;

Quit:
	return _ecParseError;
}

/*
 *	CRTFRead::FreeRtfObject()
 *
 *	@mfunc
 *		Cleans up memory used by prtfobject
 */
void CRTFRead::FreeRtfObject()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::FreeRtfObject");

	if (_prtfObject)
	{
		FreePv(_prtfObject->szClass);
		FreePv(_prtfObject->szName);
		FreePv(_prtfObject);
		_prtfObject = NULL;
	}
}

/*
 *	CRTFRead::ObjectReadSiteFlags(preobj)
 *
 *	@mfunc
 *		Read dwFlags and dwUser bytes from a container specific stream
 *
 *	@rdesc
 *		BOOL	TRUE if successfully read the bytes
 */
BOOL CRTFRead::ObjectReadSiteFlags(
	REOBJECT * preobj)	//@parm REOBJ from where to copy flags. This preobj is
						//		then later put out in a site
{
	return (::ObjectReadSiteFlags(preobj) == NOERROR);
}

/*
 *	CRTFRead::ObjectReadFromStream()
 *
 *	@mfunc
 *		Reads an OLE object from the RTF output stream.
 *
 *	@rdesc
 *		BOOL		TRUE on success, FALSE on failure.
 */
BOOL CRTFRead::ObjectReadFromEditStream()
{
	WCHAR			ch = WCH_EMBEDDING;
	BOOL			fGotClsid = TRUE;
	BOOL			fRet = FALSE;
	HRESULT			hr;
	CObjectMgr *	pObjectMgr = _ped->GetObjectMgr();
	LPOLECACHE		polecache = NULL;
	LPRICHEDITOLECALLBACK  precall=NULL;
	LPENUMSTATDATA	penumstatdata = NULL;
	REOBJECT		reobj = { 0 };
	STATDATA		statdata;

	if(!pObjectMgr)
	   goto Cleanup;
	
	precall = pObjectMgr->GetRECallback();

	// If no IRichEditOleCallback exists, then fail
	if (!precall)
		goto Cleanup;

//	AssertSz(_prtfObject->szClass,"ObFReadFromEditstream: reading unknown class");

	//$ REVIEW: MAC This call is incorrect for the Mac.  It may not matter though
	//          if ole support in RichEdit is not needed for the Mac.
	if (!(_prtfObject->szClass && 
		CLSIDFromProgID(_prtfObject->szClass, &reobj.clsid) == NOERROR))
	{
		fGotClsid = FALSE;
	}

	// Get storage for the object from the application
	if (precall->GetNewStorage(&reobj.pstg))
		goto Cleanup;

	hr = OleConvertOLESTREAMToIStorage((LPOLESTREAM) &RTFReadOLEStream, reobj.pstg, NULL);
	if (FAILED(hr))					   
		goto Cleanup;		  

	// Create another object site for the new object
	_ped->GetClientSite(&reobj.polesite) ;
	if (!reobj.polesite ||
		OleLoad(reobj.pstg, IID_IOleObject, reobj.polesite,
				 (LPVOID *) &reobj.poleobj))
	{
		goto Cleanup;
	}

	if(!fGotClsid)
	{
		// We weren't able to obtain a clsid from the progid
		// in the \objclass RTF tag	
		reobj.poleobj->GetUserClassID(&reobj.clsid);
	}
	
	reobj.cbStruct = sizeof(REOBJECT);
	reobj.cp = _prg->GetCp();
	reobj.sizel.cx = HimetricFromTwips(_prtfObject->xExt)
						* _prtfObject->xScale / 100;
	reobj.sizel.cy = HimetricFromTwips(_prtfObject->yExt)
						* _prtfObject->yScale / 100;

	// Read any container flags which may have been previously saved
	if (!ObjectReadSiteFlags(&reobj))
		reobj.dwFlags = REO_RESIZABLE;		// If no flags, make best guess	

	reobj.dvaspect = DVASPECT_CONTENT;		// OLE 1 forces DVASPECT_CONTENT

	// Ask the cache if it knows what to display
	if (!reobj.poleobj->QueryInterface(IID_IOleCache, (void**)&polecache) &&
		!polecache->EnumCache(&penumstatdata))
	{
		// Go look for the best cached presentation CF_METAFILEPICT
		while (penumstatdata->Next(1, &statdata, NULL) == S_OK)
		{
			if (statdata.formatetc.cfFormat == CF_METAFILEPICT)
			{
				LPDATAOBJECT pdataobj = NULL;
				STGMEDIUM med;
				BOOL fUpdate;

				ZeroMemory(&med, sizeof(STGMEDIUM));
                if (!polecache->QueryInterface(IID_IDataObject, (void**)&pdataobj) &&
					!pdataobj->GetData(&statdata.formatetc, &med))
                {
					HANDLE	hGlobal = med.hGlobal;

					if( FIsIconMetafilePict(hGlobal) )
				    {
					    OleStdSwitchDisplayAspect(reobj.poleobj, &reobj.dvaspect,
							DVASPECT_ICON, med.hGlobal, TRUE, FALSE, NULL, &fUpdate);
				    }
				}
				ReleaseStgMedium(&med);
				if (pdataobj)
					pdataobj->Release();
				break;
			}
		}
		polecache->Release();
		penumstatdata->Release();
	}

	// EVIL HACK ALERT.  This code is borrowed from RichEdit1.0; Word generates
	// bogus objects, so we need to compensate.

	if( reobj.dvaspect == DVASPECT_CONTENT )
	{
		IStream *pstm = NULL;
		BYTE bT;
		BOOL fUpdate;

		if (!reobj.pstg->OpenStream(OLESTR("\3ObjInfo"), 0, STGM_READ |
									   STGM_SHARE_EXCLUSIVE, 0, &pstm) &&
		   !pstm->Read(&bT, sizeof(BYTE), NULL) &&
		   (bT & 0x40))
		{
		   _fNeedIcon = TRUE;
		   _fNeedPres = TRUE;
		   _pobj = (COleObject *)reobj.polesite;
		   OleStdSwitchDisplayAspect(reobj.poleobj, &reobj.dvaspect, DVASPECT_ICON,
									   NULL, TRUE, FALSE, NULL, &fUpdate);
		}
		if( pstm )
			pstm->Release();
   }

	// Since we are loading an object, it shouldn't be blank
	reobj.dwFlags &= ~REO_BLANK;

	_prg->Set_iCF(-1);	
	_prg->ReplaceRange(1, &ch, NULL, SELRR_IGNORE);  
	hr = pObjectMgr->InsertObject(reobj.cp, &reobj, NULL);
	if(hr)
		goto Cleanup;

	// EVIL HACK ALERT!!  Word doesn't give us objects with presenation
	// caches; as a result, we can't draw them!  In order to get around this,
	// we check to see if there is a presentation cache (via the same way
	// RE1.0 did) using a GetExtent call.  If that fails, we'll just use
	// the presentation stored in the RTF.  
	//
	// COMPATIBILITY ISSUE: RE1.0, instead of using the presenation stored
	// in RTF, would instead call IOleObject::Update.  There are two _big_
	// drawbacks to this approach: 1. it's incredibly expensive (potentially,
	// MANY SECONDS per object), and 2. it doesn't work if the object server
	// is not installed on the machine.

	SIZE sizeltemp;

	if( reobj.poleobj->GetExtent(reobj.dvaspect, &sizeltemp) != NOERROR )
	{
		_fNeedPres = TRUE;
		_pobj = (COleObject *)reobj.polesite;
	}

	fRet = TRUE;

Cleanup:
	if (reobj.pstg)		reobj.pstg->Release();
	if (reobj.polesite) reobj.polesite->Release();
	if (reobj.poleobj)	reobj.poleobj->Release();

	return fRet;
}

/*
 *	ObHBuildMetafilePict(prtfobject, hBits)
 *
 *	@func
 *		Build a METAFILEPICT from RTFOBJECT and the raw data.
 *
 *	@rdesc
 *		HGLOBAL		Handle to a METAFILEPICT
 */
HGLOBAL ObHBuildMetafilePict(
	RTFOBJECT *	prtfobject,	//@parm Details we picked up from RTF
	HGLOBAL 	hBits)		//@parm Handle to the raw data
{
#ifndef NOMETAFILES
	ULONG	cbBits;
	HGLOBAL	hmfp = NULL;
	LPBYTE	pbBits;
	LPMETAFILEPICT pmfp = NULL;
	SCODE	sc = E_OUTOFMEMORY;

	// Allocate the METAFILEPICT structure
    hmfp = GlobalAlloc(GHND, sizeof(METAFILEPICT));
	if (!hmfp)
		goto Cleanup;

	// Lock it down
	pmfp = (LPMETAFILEPICT) GlobalLock(hmfp);
	if (!pmfp)
		goto Cleanup;

	// Put in the header information
	pmfp->mm = prtfobject->sPictureType;
	pmfp->xExt = prtfobject->xExt;
	pmfp->yExt = prtfobject->yExt;

	// Set the metafile bits
	pbBits = (LPBYTE) GlobalLock(hBits);
	cbBits = GlobalSize(hBits);
	pmfp->hMF = SetMetaFileBitsEx(cbBits, pbBits);
	
	// We can throw away the data now since we don't need it anymore
	GlobalUnlock(hBits);
	GlobalFree(hBits);

	if (!pmfp->hMF)
		goto Cleanup;
	GlobalUnlock(hmfp);
	sc = S_OK;

Cleanup:
	if (sc && hmfp)
	{
		if (pmfp)
		{
		    if (pmfp->hMF)
		        ::DeleteMetaFile(pmfp->hMF);
			GlobalUnlock(hmfp);
		}
		GlobalFree(hmfp);
		hmfp = NULL;
	}
	TRACEERRSZSC("ObHBuildMetafilePict", sc);
	return hmfp;
#else
	return NULL;
#endif
}

/*
 *	ObHBuildBitmap(prtfobject, hBits)
 *
 *	@func
 *		Build a BITMAP from RTFOBJECT and the raw data
 *
 *	@rdesc
 *		HGLOBAL		Handle to a BITMAP
 */
HGLOBAL ObHBuildBitmap(
	RTFOBJECT *	prtfobject,	//@parm Details we picked up from RTF
	HGLOBAL 	hBits)		//@parm Handle to the raw data
{
	HBITMAP hbm = NULL;
	LPVOID	pvBits = GlobalLock(hBits);

	if(pvBits)
	{
		hbm = CreateBitmap(prtfobject->xExt, prtfobject->yExt,
						prtfobject->cColorPlanes, prtfobject->cBitsPerPixel,
						pvBits);
	}
	GlobalUnlock(hBits);
	GlobalFree(hBits);
	return hbm;
}

/*
 *	ObHBuildDib(prtfobject, hBits)
 *
 *	@func
 *		Build a DIB from RTFOBJECT and the raw data
 *
 *	@rdesc
 *		HGLOBAL		Handle to a DIB
 */
HGLOBAL ObHBuildDib(
	RTFOBJECT *	prtfobject,	//@parm Details we picked up from RTF
	HGLOBAL 	hBits)		//@parm Handle to the raw data
{
	// Apparently DIB's are just a binary dump
	return hBits;
}

/*
 *	CRTFRead::StaticObjectReadFromEditstream(cb)
 *
 *	@mfunc
 *		Reads a picture from the RTF output stream.
 *
 *	@rdesc
 *		BOOL		TRUE on success, FALSE on failure.
 */
#define cbBufferMax	16384
#define cbBufferStep 1024
#define cbBufferMin 1024

BOOL CRTFRead::StaticObjectReadFromEditStream(
	int cb)		//@parm Count of bytes to read
{
	LONG		cbBuffer;
	LONG		cbRead;
	WCHAR		ch = WCH_EMBEDDING;
	DWORD		dwAdvf;
	DWORD		dwConn;
	FORMATETC	formatetc;
	BOOL		fRet = FALSE;
	HGLOBAL		hBits = NULL;
	HRESULT		hr;
	CObjectMgr *pObjectMgr = _ped->GetObjectMgr();
	LPPERSISTSTORAGE pperstg = NULL;
	LPOLECACHE	polecache = NULL;
	REOBJECT	reobj = { 0 };
	LPBYTE		pbBuffer = NULL;
	LPSTREAM	pstm = NULL;
	STGMEDIUM	stgmedium;
	HGLOBAL (*pfnBuildPict)(RTFOBJECT *, HGLOBAL) = NULL;
	LPRICHEDITOLECALLBACK  precall ;

	if(!pObjectMgr)
	   goto Cleanup;
	
	// precall may end up being null (e.g. Windows CE).
	precall = pObjectMgr->GetRECallback();

	// Initialize various data structures
	formatetc.ptd = NULL;
	formatetc.dwAspect = DVASPECT_CONTENT;
	formatetc.lindex = -1;
	formatetc.tymed = TYMED_NULL;
	switch (_prtfObject->sType)
	{
	case ROT_Metafile:
		reobj.clsid = CLSID_StaticMetafile;
		formatetc.cfFormat = CF_METAFILEPICT;
		formatetc.tymed = TYMED_MFPICT;
		pfnBuildPict = ObHBuildMetafilePict;
		break;

	case ROT_Bitmap:
		reobj.clsid = CLSID_StaticDib;
		formatetc.cfFormat = CF_BITMAP;
		formatetc.tymed = TYMED_GDI;
		pfnBuildPict = ObHBuildBitmap;
		break;

	case ROT_DIB:
		reobj.clsid = CLSID_StaticDib;
		formatetc.cfFormat = CF_DIB;
		formatetc.tymed = TYMED_HGLOBAL;
		pfnBuildPict = ObHBuildDib;
		break;
	}

	reobj.sizel.cx = (LONG) HimetricFromTwips(_prtfObject->xExtGoal)
						* _prtfObject->xScale / 100;
	reobj.sizel.cy = (LONG) HimetricFromTwips(_prtfObject->yExtGoal)
						* _prtfObject->yScale / 100;
	stgmedium.tymed = formatetc.tymed;
	stgmedium.pUnkForRelease = NULL;

	if (precall)
	{
		if( !_fNeedPres )
		{
			// Get storage for the object from the application
			if (precall->GetNewStorage(&reobj.pstg))
				goto Cleanup;
		}
		// Let's create a stream on HGLOBAL
		if (hr = CreateStreamOnHGlobal(NULL, FALSE, &pstm))
			goto Cleanup;

		// Allocate a buffer, preferably a big one
		for (cbBuffer = cbBufferMax;
			 cbBuffer >= cbBufferMin;
			cbBuffer -= cbBufferStep)
		{
			pbBuffer = (unsigned char *)PvAlloc(cbBuffer, 0);
			if (pbBuffer)
				break;
		}
	}
	else
	{
		cbBuffer = cb;
		if (!cb)
		{
			// this means we didn't understand the picture type; so just
			// skip it without failing.
			fRet = TRUE;
			goto Cleanup;
		}
		hBits = GlobalAlloc(GMEM_FIXED, cb);
		pbBuffer = (BYTE *) GlobalLock(hBits);
	}
		
	if (!pbBuffer)
		goto Cleanup;
	
	// Copy the data from RTF into our HGLOBAL

	while ((cbRead = RTFReadOLEStream.lpstbl->Get(&RTFReadOLEStream,pbBuffer,cbBuffer)) > 0)
	{
		if (pstm && (hr = pstm->Write( pbBuffer, cbRead, NULL)))
		{
			TRACEERRSZSC("ObFReadStaticFromEditstream: Write", GetScode(hr));
			goto Cleanup;
		}
	}

	if (hBits)
	{
		Assert(!precall);
		GlobalUnlock(hBits);
		pbBuffer = NULL;		// To avoid free below
	}

	if (pstm && (hr = GetHGlobalFromStream(pstm, &hBits)))
	{
		TRACEERRSZSC("ObFReadStaticFromEditstream: no hglobal from stm", GetScode(hr));
		goto Cleanup;
	}

	// Build the picture
	if( pfnBuildPict )
	{
		stgmedium.hGlobal = pfnBuildPict(_prtfObject, hBits);
	}
	else
	{
		// this means we didn't understand the picture type; so just
		// skip it without failing.
		fRet = TRUE;
		goto Cleanup;
	}

	if( precall && !stgmedium.hGlobal )
		goto Cleanup;

	if( precall )
	{
		if( !_fNeedPres )
		{
			// Create the default handler
			hr = OleCreateDefaultHandler(reobj.clsid, NULL, IID_IOleObject,(void **) &reobj.poleobj);
			if (hr)
			{
				TRACEERRSZSC("ObFReadStaticFromEditstream: no def handler", GetScode(hr));
				goto Cleanup;
			}

			// Get the IPersistStorage and initialize it
			if ((hr = reobj.poleobj->QueryInterface(IID_IPersistStorage,(void **)&pperstg)) ||
				(hr = pperstg->InitNew(reobj.pstg)))
			{
				TRACEERRSZSC("ObFReadStaticFromEditstream: InitNew", GetScode(hr));
				goto Cleanup;
			}
			dwAdvf = ADVF_PRIMEFIRST;
		}
		else
		{
			Assert(_pobj);
			_pobj->GetIUnknown()->QueryInterface(IID_IOleObject, (void **)&(reobj.poleobj));
			dwAdvf = ADVF_NODATA;
			formatetc.dwAspect = _fNeedIcon ? DVASPECT_ICON : DVASPECT_CONTENT;
		}

		// Get the IOleCache and put the picture data there
		if (hr = reobj.poleobj->QueryInterface(IID_IOleCache,(void **)&polecache))
		{
			TRACEERRSZSC("ObFReadStaticFromEditstream: QI: IOleCache", GetScode(hr));
			goto Cleanup;
		}

		if (FAILED(hr = polecache->Cache(&formatetc, dwAdvf,
													&dwConn)))
		{
			TRACEERRSZSC("ObFReadStaticFromEditstream: Cache", GetScode(hr));
			goto Cleanup;
		}

		if (hr = polecache->SetData(&formatetc, &stgmedium,				 
											TRUE))
		{
			TRACEERRSZSC("ObFReadStaticFromEditstream: SetData", GetScode(hr));
			goto Cleanup;
		}
	}

	if( !_fNeedPres )
	{
		// Create another object site for the new object
		_ped->GetClientSite(&reobj.polesite) ;
		if (!reobj.polesite )
			goto Cleanup;

		// Set the client site
		if (reobj.poleobj && (hr = reobj.poleobj->SetClientSite(reobj.polesite)))
		{
			TRACEERRSZSC("ObFReadStaticFromEditstream: SetClientSite", GetScode(hr));
			goto Cleanup;
		}
		else if (!reobj.poleobj)
		{
			if(_prtfObject->sType == ROT_DIB)
			{
				// Windows CE static object Save the data and mark it.
				COleObject *pobj = (COleObject *)reobj.polesite;
				COleObject::ImageInfo *pimageinfo = new COleObject::ImageInfo;
				pobj->SetHdata(hBits);
				pimageinfo->xScale = _prtfObject->xScale;
				pimageinfo->yScale = _prtfObject->yScale;
				pimageinfo->xExtGoal = _prtfObject->xExtGoal;
				pimageinfo->yExtGoal = _prtfObject->yExtGoal;
				pimageinfo->cBytesPerLine = _prtfObject->cBytesPerLine;
				pobj->SetImageInfo(pimageinfo);
			}
			else
				goto Cleanup;		// There has been a mistake
		}

		// Put object into the edit control
		reobj.cbStruct = sizeof(REOBJECT);
		reobj.cp = _prg->GetCp();
		reobj.dvaspect = DVASPECT_CONTENT;
		reobj.dwFlags = REO_RESIZABLE;
		// Since we are loading an object, it shouldn't be blank
		reobj.dwFlags &= ~REO_BLANK;

		_prg->Set_iCF(-1);	
		_prg->ReplaceRange(1, &ch, NULL, SELRR_IGNORE);  
		hr = pObjectMgr->InsertObject(reobj.cp, &reobj, NULL);
		if (hr)
			goto Cleanup;
	}
	else
	{
		// the new presentation may have a different idea about how big the
		// object is supposed to be.  Make sure the object stays the correct
		// size.
		_pobj->ResetSizel(reobj.sizel);
	}
	fRet = TRUE;

Cleanup:
	if (polecache)		polecache->Release()	;
	if (reobj.pstg)		reobj.pstg->Release();
	if (reobj.polesite)	reobj.polesite->Release();
	if (reobj.poleobj)	reobj.poleobj->Release();
	if (pperstg)		pperstg->Release();
	if (pstm)			pstm->Release();
	FreePv(pbBuffer);

	_fNeedIcon = FALSE;
	_fNeedPres = FALSE;
	_pobj = NULL;

	return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\rtfwrit.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	RTFWRIT.CPP - RichEdit RTF Writer (w/o objects) |
 *
 *		This file contains the implementation of the RTF writer
 *		for the RichEdit control, except for embedded objects,
 *		which are handled mostly in rtfwrit2.cpp
 *
 *	Authors: <nl>
 *		Original RichEdit 1.0 RTF converter: Anthony Francisco <nl>
 *		Conversion to C++ and RichEdit 2.0:  Murray Sargent <nl>
 *		Lots of enhancements: Brad Olenick <nl>
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_rtfwrit.h"
#include "_objmgr.h"
#include "_coleobj.h"
#include "_font.h"

ASSERTDATA

extern const KEYWORD rgKeyword[];

//========================= Global String Constants ==================================

BYTE bCharSetANSI = ANSI_CHARSET;				// ToDo: make more general

#ifdef DEBUG
// Quick way to find out what went wrong: rgszParseError[ecParseError]
//
CHAR *	rgszParseError[] =
{
	"No error",
	"Can't convert to Unicode",				// FF
	"Color table overflow",					// FE
	"Expecting '\\rtf'",					// FD
	"Expecting '{'",						// FC
	"Font table overflow",					// FB
	"General failure",						// FA
	"Keyword too long",						// F9
	"Lexical analyzer initialize failed",	// F8
	"No memory",							// F7
	"Parser is busy",						// F6
	"PutChar() function failed",			// F5
	"Stack overflow",						// F4
	"Stack underflow",						// F3
	"Unexpected character",					// F2
	"Unexpected end of file",				// F1
	"Unexpected token",						// F0
	"UnGetChar() function failed",			// EF
	"Maximum text length reached",			// EE
	"Streaming out object failed",			// ED
	"Streaming in object failed",			// EC
	"Truncated at CR or LF",				// EB
	"Format-cache failure",					// EA
	NULL									// End of list marker
};

CHAR * szDest[] =
{
	"RTF",
	"Color Table",
	"Font Table",
	"Binary",
	"Object",
	"Object Class",
	"Object Name",
	"Object Data",
	"Field",
	"Field Result",
	"Field Instruction",
	"Symbol",
	"Paragraph Numbering",
	"Picture"
};

#endif

// Most control-word output is done with the following printf formats
static const CHAR * rgszCtrlWordFormat[] =
{
	"\\%s", "\\%s%d", "{\\%s", "{\\*\\%s", "{\\%s%d"
};

// Special control-word formats
static const CHAR szBeginFontEntryFmt[]	= "{\\f%d\\%s";
static const CHAR szBulletGroup[]		= "{\\pntext\\f%d\\'B7\\tab}";
static const CHAR szBulletFmt[]			= "{\\*\\pn\\pnlvl%s\\pnf%d\\pnindent%d{\\pntxtb\\'B7}}";
static const CHAR szBeginNumberGroup[]	= "{\\pntext\\f%d ";
static const CHAR szEndNumberGroup[]	= "\\tab}";
static const CHAR szBeginNumberFmt[]	= "{\\*\\pn\\pnlvl%s\\pnf%d\\pnindent%d\\pnstart%d";
static const CHAR szpntxtb[]			= "{\\pntxtb(}";
static const CHAR szpntxta[]			= "{\\pntxta%c}";
static const CHAR szColorEntryFmt[]		= "\\red%d\\green%d\\blue%d;";
static const CHAR szEndFontEntry[]		= ";}";
       const CHAR szEndGroupCRLF[]		= "}\r\n";
static const CHAR szEscape2CharFmt[]	= "\\'%02x\\'%02x";
static const CHAR szLiteralCharFmt[]	= "\\%c";
static const CHAR szPar[]				= "\\par\r\n";
static const CHAR szPar10[]				= "\r\n\\par ";
static const CHAR szObjPosHolder[] 		= "\\objattph\\'20";
static const CHAR szDefaultFont[]		= "\\deff0";
static const CHAR szHorzdocGroup[]		= "{\\horzdoc}";
static const CHAR szNormalStyle[]		= "{ Normal;}";
static const CHAR szHeadingStyle[]		= "{\\s%d heading %d;}";
static const CHAR szEndRow[]			= "\\row\r\n";

#define szEscapeCharFmt		&szEscape2CharFmt[6]

// Arrays of RTF control-word indices. NOTE: if any index is greater than 255,
// the corresponding array must be changed to a WORD array. The compiler
// issues a warning in such cases

const BYTE rgiszTerminators[] =
{
	i_cell, 0, i_tab, 0, i_line, i_page
};

// Keep these indices in sync with the special character values in _common.h
const WORD rgiszSpecial[] =
{
	i_enspace,				// 0x2002
	i_emspace,				// 0x2003
	0,						// 0x2004
	0,						// 0x2005
	0,						// 0x2006
	0,						// 0x2007
	0,						// 0x2008
	0,						// 0x2009
	0,						// 0x200A
	0,						// 0x200B
	i_zwnj,					// 0x200C
	i_zwj,					// 0x200D
	i_ltrmark,				// 0x200E
	i_rtlmark,				// 0x200F
	0,						// 0x2010
	0,						// 0x2011
	0,						// 0x2012
	i_endash,				// 0x2013
	i_emdash,				// 0x2014
	0,						// 0x2015
	0,						// 0x2016
	0,						// 0x2017
	i_lquote, 				// 0x2018
	i_rquote,				// 0x2019
	0,						// 0x201A
	0,						// 0x201B
	i_ldblquote, 			// 0x201C
	i_rdblquote,			// 0x201D
	0,						// 0x201E
	0,						// 0x201F
	0,						// 0x2020
	0,						// 0x2021
	i_bullet				// 0x2022
};

const BYTE rgiszEffects[] =							
{													// Effects keywords
	i_deleted, i_revised, i_disabled, i_impr, 		// Ordered max CFE_xx to
	i_embo, i_shad, i_outl, i_v, i_caps, i_scaps, 	//  min CFE_xx (cept i_deleted)
	i_disabled, i_protect, i_strike, i_ul, i_i,	i_b	// (see WriteCharFormat())
};													

#define CEFFECTS	ARRAY_SIZE(rgiszEffects)

const BYTE rgiszPFEffects[] =						// PF effects keywords
{													// Ordered max PFE_xx to
	i_collapsed, i_sbys, i_hyphpar, i_nowidctlpar,	//  min PFE_xx
	i_noline, i_pagebb, i_keepn, i_keep, i_rtlpar
};													// (see WriteParaFormat())

#define CPFEFFECTS	ARRAY_SIZE(rgiszPFEffects)

const BYTE rgiszUnderlines[] =
{
	i_ulnone, i_ul, i_ulw, i_uldb, i_uld,			// Std Word underlines
	i_uldash, i_uldashd, i_uldashdd, i_ulwave, i_ulth, i_ulhair
};

#define CUNDERLINES	ARRAY_SIZE(rgiszUnderlines)

const BYTE rgiszFamily[] =							// Font family RTF name
{													//  keywords in order of
	i_fnil, i_froman, i_fswiss, i_fmodern,			//  bPitchAndFamily
	i_fscript, i_fdecor, i_ftech, i_fbidi
};

#define CFAMILIES ARRAY_SIZE(rgiszFamily)

const BYTE rgiszAlignment[] =						// Alignment keywords
{													// Keep in sync with
	i_ql, i_qr,	i_qc, i_qj							//  alignment constants
};

const BYTE rgiszTabAlign[] =						// Tab alignment keywords
{													// Keep in sync with tab
	i_tqc, i_tqr, i_tqdec							//  alignment constants
};

const BYTE rgiszTabLead[] =							// Tab leader keywords
{													// Keep in sync with tab
	i_tldot, i_tlhyph, i_tlul, i_tlth, i_tleq		//  leader constants
};

const BYTE rgiszNumberStyle[] =						// Numbering style keywords
{													// Keep in sync with TOM
	i_pndec, i_pnlcltr, i_pnucltr,					//  values
	i_pnlcrm, i_pnucrm					
};

const BYTE rgiszBorders[] =							// Border combination keywords
{													
	i_box,
	i_brdrt, i_brdrl, i_brdrb, i_brdrr,
	i_trbrdrt, i_trbrdrl, i_trbrdrb, i_trbrdrr,
	i_clbrdrt, i_clbrdrl, i_clbrdrb, i_clbrdrr
};

const BYTE rgiszBorderStyles[] =					// Border style keywords
{													
	i_brdrdash, i_brdrdashsm, i_brdrdb, i_brdrdot,
	i_brdrhair, i_brdrs, i_brdrth, i_brdrtriple
};
#define CBORDERSTYLES ARRAY_SIZE(rgiszBorderStyles)

const BYTE rgiszBorderEffects[] =					// Border effect keywords
{													
	i_brdrbar, i_brdrbtw, i_brdrsh					// Reverse order from bits
};

const BYTE rgiszShadingStyles[] =					// Shading style keywords
{													
	i_bgbdiag, i_bgcross, i_bgdcross, i_bgdkbdiag,
	i_bgdkcross, i_bgdkdcross, i_bgdkfdiag, i_bgdkhoriz,
	i_bgdkvert, i_bgfdiag, i_bghoriz, i_bgvert 
};
#define CSHADINGSTYLES ARRAY_SIZE(rgiszShadingStyles)

// RGB with 2 bits per color type (in BGR order)
const COLORREF g_Colors[] =
{
	RGB(  0,   0,   0),	// \red0\green0\blue0
	RGB(  0,   0, 255),	// \red0\green0\blue255
	RGB(  0, 255, 255),	// \red0\green255\blue255
	RGB(  0, 255,   0),	// \red0\green255\blue0
	RGB(255,   0, 255),	// \red255\green0\blue255
	RGB(255,   0,   0),	// \red255\green0\blue0
	RGB(255, 255,   0),	// \red255\green255\blue0
	RGB(255, 255, 255),	// \red255\green255\blue255
	RGB(  0,   0, 128),	// \red0\green0\blue128
	RGB(  0, 128, 128),	// \red0\green128\blue128
	RGB(  0, 128,   0),	// \red0\green128\blue0
	RGB(128,   0, 128),	// \red128\green0\blue128
	RGB(128,   0,   0),	// \red128\green0\blue0
	RGB(128, 128,   0),	// \red128\green128\blue0
	RGB(128, 128, 128),	// \red128\green128\blue128
	RGB(192, 192, 192),	// \red192\green192\blue192
};

/*
 *	CRTFWrite::MapsToRTFKeywordW(wch)
 *
 *	@mfunc
 *		Returns a flag indicating whether the character maps to an RTF keyword
 *
 *	@rdesc
 *		BOOL			TRUE if char maps to RTF keyword
 */
inline BOOL CRTFWrite::MapsToRTFKeywordW(
	WCHAR wch)
{
	return
		!_fNCRForNonASCII &&
		(IN_RANGE(TAB, wch, CR) ||
		wch == CELL ||
		wch == BSLASH ||
		wch == LBRACE || 
		wch == RBRACE ||
		IN_RANGE(ENSPACE, wch, EMSPACE) ||
		IN_RANGE(ENDASH, wch, EMDASH) ||
		IN_RANGE(LQUOTE, wch, RQUOTE) ||
		IN_RANGE(LDBLQUOTE, wch, RDBLQUOTE) ||
		wch == BULLET ||
		wch == chOptionalHyphen ||
		wch == chNonBreakingSpace);
}

/*
 *	CRTFWrite::MapsToRTFKeywordA(ch)
 *
 *	@mfunc
 *		Returns a flag indicating whether the character maps to an RTF keyword
 *
 *	@rdesc
 *		BOOL			TRUE if char maps to RTF keyword
 */
inline BOOL CRTFWrite::MapsToRTFKeywordA(char ch)
{
	return IN_RANGE(TAB, ch, CR) ||
		ch == CELL ||
		ch == BSLASH ||
		ch == LBRACE || 
		ch == RBRACE;
}

/*
 *	CRTFWrite::MapToRTFKeywordW(pv, cch, iCharEncoding)
 *
 *	@mfunc
 *		Examines the first character in the string pointed to by pv and
 *		writes out the corresponding RTF keyword.  In situations where
 *		the first and subsequent characters map to a single keyword, we
 *		return the number of additional characters used in the mapping.
 *
 *	@rdesc
 *		int		indicates the number of additional characters used when
 *				the mapping to an RTF keyword involves > 1 characters.
 */
int CRTFWrite::MapToRTFKeyword(
	void *	pv,				//@parm ptr to ansi or Unicode string
	int		cch,
	int		iCharEncoding)
{
	Assert(iCharEncoding == MAPTOKWD_ANSI || iCharEncoding == MAPTOKWD_UNICODE);

	WCHAR ch = ((iCharEncoding == MAPTOKWD_ANSI) ? *(char *)pv : *(WCHAR *)pv);
	int cchRet = 0;

	Assert((iCharEncoding == MAPTOKWD_ANSI) ? MapsToRTFKeywordA(ch) : MapsToRTFKeywordW(ch));

	switch(ch)
	{
		case BULLET:
		case EMDASH:
		case EMSPACE:
		case ENDASH:
		case ENSPACE:
		case LDBLQUOTE:
		case LQUOTE:
		case RDBLQUOTE:
		case RQUOTE:
			Assert(ch > 0xFF);

			if(iCharEncoding != MAPTOKWD_ANSI)
			{
				AssertSz(rgiszSpecial[ch - ENSPACE] != 0,
					"CRTFWrite::WriteText(): rgiszSpecial out-of-sync");
				PutCtrlWord(CWF_STR, rgiszSpecial[ch - ENSPACE]);
			}
			break;

		case TAB:
#if TAB == CELL							// If TABs and CELLs are equal, in
			if(_pPF->InTable())			//  tables convert TABs to CELL value
				ch -= 2;				//  of 7 for rgiszTerminators[]
#else
		case CELL:
#endif
		case FF:
		case VT:
			PutCtrlWord(CWF_STR, rgiszTerminators[ch - (TAB - 2)]);
			break;

		case CR:
		{
			WCHAR ch1;
			WCHAR ch2;

			if(iCharEncoding == MAPTOKWD_ANSI)
			{
				char *pch = (char *)pv;
				ch1 = pch[1];
				ch2 = pch[2];
			}
			else
			{
				WCHAR *pch = (WCHAR *)pv;
				ch1 = pch[1];
				ch2 = pch[2];
			}

			if(cch > 1 && ch1 == CR && ch2 == LF)
			{
				// Translate CRCRLF	to a blank (represents soft line break)
				PutChar(' ');
				cchRet = 2;
				break;
			}
			if(cch && ch1 == LF)		// Ignore LF after CR
			{
				cchRet = 1;
			}							
			if(_pPF->InTable())			// CR terminates a row in our simple
			{							//  table model, so output \row
				Puts(szEndRow, sizeof(szEndRow) - 1);
				_fCheckInTable = TRUE;
				break;
			}
		}								// Fall thru to LF (EOP) case

		case LF:
			if (_ped->Get10Mode())
				Puts(szPar10, sizeof(szPar10) - 1);
			else
				Puts(szPar, sizeof(szPar) - 1);
			if(_fBullet)
			{
				if(cch > 0)
				{
					if(!_nNumber) 
						printF(szBulletGroup, _symbolFont);

					else if(!_pPF->IsNumberSuppressed())
					{
						WCHAR szNumber[CCHMAXNUMTOSTR];
						_pPF->NumToStr(szNumber, ++_nNumber, fRtfWrite);
						printF(szBeginNumberGroup, _nFont);
						WritePcData(szNumber, _cpg, FALSE);
						printF(szEndNumberGroup);
					}
				}
				else
					_fBulletPending = TRUE;
			}
			break;

		case chOptionalHyphen:
			ch = '-';					// Fall thru to printFLiteral

printFLiteral:
		case BSLASH:
		case LBRACE:
		case RBRACE:
			printF(szLiteralCharFmt, ch);
			break;

		case chNonBreakingSpace:
			ch = '~';
			goto printFLiteral;
	}
	
	return cchRet;
}


//======================== CRTFConverter Base Class ==================================

/*
 *	CRTFConverter::CRTFConverter()
 *
 *	@mfunc
 *		RTF Converter constructor
 */
CRTFConverter::CRTFConverter(
	CTxtRange *		prg,			//@parm CTxtRange for transfer
	EDITSTREAM *	pes,			//@parm Edit stream for transfer
	DWORD			dwFlags,		//@parm Converter flags
	BOOL 			fRead)			//@parm Initialization for a reader or writer
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFConverter::CRTFConverter");

	AssertSz(prg && pes && pes->pfnCallback,
		"CRTFWrite::CRTFWrite: Bad RichEdit");

	_prg			= prg;
	_pes			= pes;
	_ped			= prg->GetPed();
	_dwFlags		= dwFlags;
	_ecParseError	= ecNoError;

	if(!_ctfi)
		ReadFontSubInfo();

#if defined(DEBUG) && !defined(MACPORT)
	_hfileCapture = NULL;

#if !defined(PEGASUS)
	if(GetProfileIntA("RICHEDIT DEBUG", "RTFCAPTURE", 0))
	{
		char szTempPath[MAX_PATH] = "\0";
		const char cszRTFReadCaptureFile[] = "CaptureRead.rtf";
		const char cszRTFWriteCaptureFile[] = "CaptureWrite.rtf";
		DWORD cchLength;
		
		SideAssert(cchLength = GetTempPathA(MAX_PATH, szTempPath));

		// append trailing backslash if neccessary
		if(szTempPath[cchLength - 1] != '\\')
		{
			szTempPath[cchLength] = '\\';
			szTempPath[cchLength + 1] = 0;
		}

		strcat(szTempPath, fRead ? cszRTFReadCaptureFile : 
									cszRTFWriteCaptureFile);
		
		SideAssert(_hfileCapture = CreateFileA(szTempPath,
											GENERIC_WRITE,
											FILE_SHARE_READ,
											NULL,
											CREATE_ALWAYS,
											FILE_ATTRIBUTE_NORMAL,
											NULL));
	}
#endif // !defined(PEGASUS)

#endif // defined(DEBUG) && !defined(MACPORT)
}



//======================== OLESTREAM functions =======================================

DWORD CALLBACK RTFPutToStream (
	RTFWRITEOLESTREAM *	OLEStream,	//@parm OLESTREAM
	const void *		pvBuffer,	//@parm Buffer to  write
	DWORD				cb)			//@parm Bytes to write
{
	return OLEStream->Writer->WriteData ((BYTE *)pvBuffer, cb);
}



//============================ CRTFWrite Class ==================================

/*
 *	CRTFWrite::CRTFWrite()
 *
 *	@mfunc
 *		RTF writer constructor
 */
CRTFWrite::CRTFWrite(
	CTxtRange *		prg,			//@parm CTxtRange to write
	EDITSTREAM *	pes,			//@parm Edit stream to write to
	DWORD			dwFlags)		//@parm Write flags
	: CRTFConverter(prg, pes, dwFlags, FALSE)
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::CRTFWrite");

	ZeroMemory(&_CF, sizeof(CCharFormat));	// Setup "previous" CF with RTF
	_CF._dwEffects	= CFE_AUTOCOLOR | CFE_AUTOBACKCOLOR;//  Font info is given 
	_CF._yHeight	= -32768;				//  by first font in range
											//  [see end of LookupFont()]
	Assert(_ped);
	_ped->GetDefaultLCID(&_CF._lcid);

	// init OleStream
	RTFWriteOLEStream.Writer = this;
	RTFWriteOLEStream.lpstbl->Put = (DWORD (CALLBACK* )(LPOLESTREAM, const void FAR*, DWORD))
							   RTFPutToStream;
	RTFWriteOLEStream.lpstbl->Get = NULL;

	_fIncludeObjects = TRUE;
	if((dwFlags & SF_RTFNOOBJS) == SF_RTFNOOBJS)
		_fIncludeObjects = FALSE;

	_fNCRForNonASCII = (dwFlags & SF_NCRFORNONASCII) != 0;
	_fNeedDelimeter = FALSE;
	_nHeadingStyle = 0;					// No headings found
	_nNumber = 0;						// No paragraph numbering yet
	_fCheckInTable = FALSE;
	_pPF = NULL;
	_pbAnsiBuffer = NULL;
}											

/*
 *	CRTFWrite::FlushBuffer()
 *
 *	@mfunc
 *		Flushes output buffer
 *
 *	@rdesc
 *		BOOL			TRUE if successful
 */
BOOL CRTFWrite::FlushBuffer()
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::FlushBuffer");

	LONG cchWritten;

	if (!_cchBufferOut)
		return TRUE;

#ifdef DEBUG_PASTE
	if (FromTag(tagRTFAsText))
	{
		CHAR *	pchEnd	= &_pchRTFBuffer[_cchBufferOut];
		CHAR	chT		= *pchEnd;

		*pchEnd = 0;
		TraceString(_pchRTFBuffer);
		*pchEnd = chT;
	}
#endif

	_pes->dwError = _pes->pfnCallback(_pes->dwCookie,
									  (unsigned char *)_pchRTFBuffer,
									  _cchBufferOut,	&cchWritten);

#if defined(DEBUG) && !defined(MACPORT) && !defined(PEGASUS)
	if(_hfileCapture)
	{
		DWORD cbLeftToWrite = _cchBufferOut;
		DWORD cbWritten2 = 0;
		BYTE *pbToWrite = (BYTE *)_pchRTFBuffer;
		
		while(WriteFile(_hfileCapture,
						pbToWrite,
						cbLeftToWrite,
						&cbWritten2,
						NULL) && 
						(pbToWrite += cbWritten2,
						(cbLeftToWrite -= cbWritten2)));
	}
#endif

	if (_pes->dwError)
	{
		_ecParseError = ecPutCharFailed; 
		return FALSE;
	}
	AssertSz(cchWritten == _cchBufferOut,
		"CRTFW::FlushBuffer: incomplete write");

	_cchOut		  += _cchBufferOut;
	_pchRTFEnd	  = _pchRTFBuffer;					// Reset buffer
	_cchBufferOut = 0;

	return TRUE;
}

/*
 *	CRTFWrite::PutChar(ch)
 *
 *	@mfunc
 *		Put out the character <p ch>
 *
 *	@rdesc
 *		BOOL	TRUE if successful
 */
BOOL CRTFWrite::PutChar(
	CHAR ch)				//@parm char to be put
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::PutChar");

	CheckDelimeter();					// If _fNeedDelimeter, may need to
										//  PutChar(' ')
	// Flush buffer if char won't fit
	if (_cchBufferOut + 1 >= cachBufferMost && !FlushBuffer())
		return FALSE;

	*_pchRTFEnd++ = ch;						// Store character in buffer
	++_cchBufferOut;	
	return TRUE;
}

/*
 *	CRTFWrite::CheckInTable(fPutIntbl)
 *
 *	@mfunc
 *		If _fCheckInTable or !fPutIntbl, output row header RTF. If fPutIntbl 
 *		and _fCheckInTable, output \intbl as well. Note that fPutIntbl is
 *		FALSE when a PF is being output, since this control word needs to
 *		be output after the \pard, but the other row RTF needs to be output
 *		before the \pard.
 *
 *	@rdesc
 *		BOOL	TRUE if in table and outputted all relevant \trowd stuff
 */
BOOL CRTFWrite::CheckInTable(
	BOOL fPutIntbl)		//@parm TRUE if \intbl should be output
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::CheckInTable");

	_fCheckInTable = FALSE;
	if(_pPF->InTable())
	{
		if(!_fRangeHasEOP)
			return TRUE;

		LONG  cTab = _pPF->_bTabCount;
		LONG  h	   = _pPF->_dxOffset;
		LONG  i, j = _pPF->_dxStartIndent;
		LONG  k	   = _pPF->_bAlignment;
		DWORD Tab, Widths;

		if (!PutCtrlWord(CWF_STR, i_trowd) || // Reset table properties
			h && !PutCtrlWord(CWF_VAL, i_trgaph, h) ||
			j && !PutCtrlWord(CWF_VAL, i_trleft, j) ||
			IN_RANGE(PFA_RIGHT, k, PFA_CENTER) &&
			!PutCtrlWord(CWF_STR, k == PFA_RIGHT ? i_trqr : i_trqc))
		{
			return FALSE;
		}
		PutBorders(TRUE);
		const LONG *prgxTabs = _pPF->GetTabs();
		for(i = 0; i < cTab; i++)
		{
			Tab = *prgxTabs++;
			Widths = Tab >> 24;
			if(Widths)
			{
				for(j = 0; j < 4; j++, Widths >>= 2)
				{
					LONG w = Widths & 3;
					if(w && (!PutCtrlWord(CWF_STR, rgiszBorders[j + 9]) ||
						!PutCtrlWord(CWF_VAL, i_brdrw, 15*w) ||
						!PutCtrlWord(CWF_STR, i_brdrs)))
					{
						return FALSE;
					}
				}
				CheckDelimeter();
			}
			if(!PutCtrlWord(CWF_VAL, i_cellx, GetTabPos(Tab)))
				return FALSE;
		}
		if(!fPutIntbl || PutCtrlWord(CWF_STR, i_intbl))
			return TRUE;
	}
	return FALSE;
}

/*
 *	CRTFWrite::PutBorders(fInTable)
 *
 *	@mfunc
 *		If any borders are defined, output their control words
 *
 *	@rdesc
 *		error code
 */
EC CRTFWrite::PutBorders(
	BOOL fInTable)
{
	DWORD Widths = _pPF->_wBorderWidth;
	BOOL  fBox	 = _pPF->_wEffects & PFE_BOX;

	if(Widths || fBox)
	{
		DWORD Colors = _pPF->_dwBorderColor;
		DWORD dwEffects = Colors >> 20;
		LONG  i = 1, iMax = 4;					// NonBox for loop limits
		LONG  j, k;
		DWORD Spaces = _pPF->_wBorderSpace;
		DWORD Styles = _pPF->_wBorders;

		if(fBox)
			i = iMax = 0;						// For box, only write one set

		for( ; i <= iMax; i++, Spaces >>= 4, Styles >>= 4, Widths >>= 4, Colors >>= 5)
		{
			if(!(Widths & 0xF) && !fBox)		// No width, so no border
				continue;

			j = TWIPS_PER_POINT*(Spaces & 0xF);
			k = Colors & 0x1F;
			if (!PutCtrlWord(CWF_STR, rgiszBorders[i + 4*fInTable])		||
				!PutCtrlWord(CWF_STR, rgiszBorderStyles[Styles & 0xF])	||
				!PutCtrlWord(CWF_VAL, i_brdrw, 10*(Widths & 0xF))		||
				k &&
				!PutCtrlWord(CWF_VAL, i_brdrcf, LookupColor(g_Colors[k-1]) + 1) ||
				j && !PutCtrlWord(CWF_VAL, i_brsp, j))
			{
				break;
			}
			for(j = 3; j--; dwEffects >>= 1)		// Output border effects
			{
				if (dwEffects & 1 &&
					!PutCtrlWord(CWF_STR, rgiszBorderEffects[j]))
				{
					break;
				}				
			}
			CheckDelimeter();						// Output a ' '
		}
	}
	return _ecParseError;
}

/*
 *	CRTFWrite::Puts(sz, cb)
 *
 *	@mfunc
 *		Put out the string <p sz>
 *	
 *	@rdesc
 *		BOOL				TRUE if successful
 */
BOOL CRTFWrite::Puts(
	CHAR const * sz,
	LONG cb)		//@parm String to be put
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::Puts");

	if(*sz == '\\' || *sz == '{' || *sz == ' ')
		_fNeedDelimeter = FALSE;

	CheckDelimeter();					// If _fNeedDelimeter, may need to
										//  PutChar(' ')
	// Flush buffer if string won't fit
	if (_cchBufferOut + cb >= cachBufferMost && !FlushBuffer())
		return FALSE;

	if (cb >= cachBufferMost)			// If buffer still can't handle string,
	{									//   we have to write string directly
		LONG	cbWritten;

#ifdef DEBUG_PASTE
		if (FromTag(tagRTFAsText))
			TraceString(sz);
#endif
		_pes->dwError = _pes->pfnCallback(_pes->dwCookie,
										(LPBYTE) sz, cb, &cbWritten);
		_cchOut += cbWritten;

#if defined(DEBUG) && !defined(MACPORT) && !defined(PEGASUS)
		if(_hfileCapture)
		{
			DWORD cbLeftToWrite = cb;
			DWORD cbWritten2 = 0;
			BYTE *pbToWrite = (BYTE *)sz;
		
			while(WriteFile(_hfileCapture,
							pbToWrite,
							cbLeftToWrite,
							&cbWritten2,
							NULL) && 
							(pbToWrite += cbWritten2,
							(cbLeftToWrite -= cbWritten2)));
		}
#endif

		if (_pes->dwError)
		{
			_ecParseError = ecPutCharFailed;
			return FALSE;
		}
		AssertSz(cbWritten == cb,
			"CRTFW::Puts: incomplete write");
	}
	else
	{
		CopyMemory(_pchRTFEnd, sz, cb);		// Put string into buffer for later
		_pchRTFEnd += cb;							//  output
		_cchBufferOut += cb;
	}

	return TRUE;
}

/*
 *	CRTFWrite::PutCtrlWord(iFormat, iCtrl, iValue)
 *
 *	@mfunc
 *		Put control word with rgKeyword[] index <p iCtrl> and value <p iValue>
 *		using format rgszCtrlWordFormat[<p iFormat>]
 *
 *	@rdesc
 *		TRUE if successful
 *
 *	@devnote
 *		Sets _fNeedDelimeter to flag that next char output must be a control
 *		word delimeter, i.e., not alphanumeric (see PutChar()).
 */
BOOL CRTFWrite::PutCtrlWord(

	LONG iFormat,			//@parm Format index into rgszCtrlWordFormat
	LONG iCtrl,				//@parm Index into Keyword array
	LONG iValue)			//@parm Control-word parameter value. If missing,
{							//		 0 is assumed
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::PutCtrlWord");

	BOOL	bRet;
	CHAR	szT[60];
	LONG    cb;

	cb = sprintf(szT,
			  (char *)rgszCtrlWordFormat[iFormat],
			  rgKeyword[iCtrl].szKeyword,
			  iValue);
	_fNeedDelimeter = FALSE;
	bRet = Puts(szT, cb);
	_fNeedDelimeter = TRUE;					// Ensure next char isn't
											//  alphanumeric
	return bRet;
}

/*
 *	CRTFWrite::printF(szFmt, ...)
 *
 *	@mfunc
 *		Provide formatted output
 *
 *	@rdesc
 *		TRUE if successful
 */
BOOL _cdecl CRTFWrite::printF(
	CONST CHAR * szFmt,		//@parm Format string for printf()
	...)					//@parmvar Parameter list
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::printF");
	va_list	marker;
	CHAR	szT[60];

	va_start(marker, szFmt);
	int cb = W32->WvsprintfA(60, szT, szFmt, marker);
	va_end(marker);

	return Puts(szT, cb);
}

/*
 *	CRTFWrite::WritePcData(szData, nCodePage, fIsDBCS)
 *
 *	@mfunc
 *		Write out the string <p szData> as #PCDATA where any special chars
 *		are protected by leading '\\'.
 *
 *	@rdesc
 *		EC (_ecParseError)
 */
EC CRTFWrite::WritePcData(
	const TCHAR * szData,	//@parm #PCDATA string to write
	INT  nCodePage,			//@parm code page default value CP_ACP
	BOOL fIsDBCS)			//@parm szData is a DBCS string stuffed into Unicode buffer
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WritePcData");

	BYTE		ch;
	BOOL		fMissingCodePage;
	BOOL		fMultiByte;
	const BYTE *pch;
	const char *pchToDBCSDefault = NULL;
	BOOL *		pfUsedDefault = NULL;

	if(IsUTF8)
		nCodePage = CP_UTF8;

	if(!*szData)
		return _ecParseError;

	int	DataSize = wcslen(szData) + 1;
	int BufferSize = DataSize * 3;
	char *pBuffer = (char *)PvAlloc(BufferSize, GMEM_ZEROINIT);
	if(!pBuffer)
		return ecNoMemory;

#if defined(DEBUG) || defined(_RELEASE_ASSERTS_)
	// When WCTMB fails to convert a char, the following default
	// char is used as a placeholder in the string being converted
	const char	chToDBCSDefault = 0;
	BOOL		fUsedDefault;

	pchToDBCSDefault = &chToDBCSDefault;
	pfUsedDefault	 = &fUsedDefault;
#endif

	int cchRet = WCTMB(fIsDBCS ? INVALID_CODEPAGE : nCodePage, 0, 
						szData, -1, pBuffer, BufferSize,
						pchToDBCSDefault, pfUsedDefault,
						&fMissingCodePage);
	Assert(cchRet > 0);

	if(!fIsDBCS && fMissingCodePage && nCodePage != CP_ACP)
	{
		// Here, the system could not convert the Unicode string because the
		// code page is not installed on the system.  Fallback to CP_ACP.

		cchRet = WCTMB(CP_ACP, 0, 
						szData, -1, pBuffer, BufferSize,
						pchToDBCSDefault, pfUsedDefault,
						&fMissingCodePage);
		Assert(cchRet > 0);

		nCodePage = CP_ACP;
	}

	AssertSz(!fUsedDefault, "CRTFWrite::WritePcData():  Found character in "
							"control text which cannot be converted from "
							"Unicode");
	if(cchRet <= 0)
	{
		_ecParseError = ecCantUnicode;
		goto CleanUp;
	}

	BufferSize = cchRet;

	fMultiByte = (BufferSize > DataSize) || fIsDBCS || fMissingCodePage;
	pch = (BYTE *)pBuffer;
	ch = *pch;
	
	// If _fNeedDelimeter, may need	to PutChar(' ')
	CheckDelimeter();
									
	while (!_ecParseError && (ch = *pch++))
	{
		if(fMultiByte && *pch && nCodePage != CP_UTF8 && GetTrailBytesCount(ch, nCodePage))
			printF(szEscape2CharFmt, ch, *pch++);					// Output DBC pair
		else
		{
			if(ch == LBRACE || ch == RBRACE || ch == BSLASH)
				printF(szLiteralCharFmt, ch);

			else if(ch < 32 || ch == ';' || ch > 127)
				printF(szEscapeCharFmt, ch);

			else
				PutChar(ch);
		}
	}

CleanUp:
	FreePv(pBuffer); 
	return _ecParseError;
}

/*
 *	CRTFWrite::LookupColor(colorref)
 *
 *	@mfunc
 *		Return color-table index for color referred to by <p colorref>.
 *		If a match isn't found, an entry is added.
 *
 *	@rdesc
 *		LONG			Index into colortable
 *		<lt> 0			on error
 */
LONG CRTFWrite::LookupColor(
	COLORREF colorref)		//@parm colorref to look for
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::LookupColor");

	LONG		Count = _colors.Count();
	LONG		iclrf;
	COLORREF *	pclrf;

	for(iclrf = 0; iclrf < Count; iclrf++)		// Look for color
		if(_colors.GetAt(iclrf) == colorref)
		 	return iclrf;

	pclrf = _colors.Add(1, NULL);				// If we couldn't find it,
	if(!pclrf)									//  add it to color table
		return -1;
	*pclrf = colorref;

	return iclrf;
}

/*
 *	CRTFWrite::LookupFont(pCF)
 *
 *	@mfunc
 *		Returns index into font table for font referred to by
 *		CCharFormat *<p pCF>. If a match isn't found, an entry is added.
 *
 *	@rdesc
 *		SHORT		Index into fonttable
 *		<lt> 0		on error
 */
LONG CRTFWrite::LookupFont(
	CCharFormat const * pCF)	//@parm CCharFormat holding font name
{								//		 to look up
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::LookupFont");

	LONG		Count = _fonts.Count();
	LONG		itf;
	TEXTFONT *	ptf;
	
	for(itf = 0; itf < Count; itf++)
	{														// Look for font
		ptf = _fonts.Elem(itf);
		if (ptf->bPitchAndFamily == pCF->_bPitchAndFamily &&//  of same pitch,
			ptf->bCharSet		 == pCF->_bCharSet &&		//  char set, and
			ptf->iFont			 == pCF->_iFont)			//  name
		{
			return itf;										// Found it
		}
	}
	ptf = _fonts.Add(1, NULL);								// Didn't find it:
	if(!ptf)												//  add to table
		return -1;

	ptf->bPitchAndFamily = pCF->_bPitchAndFamily;
	ptf->bCharSet		 = pCF->_bCharSet;
	ptf->sCodePage		 = (short)GetCodePage (ptf->bCharSet);
	ptf->iFont			 = pCF->_iFont;
	ptf->fNameIsDBCS	 = (pCF->_dwEffects & CFE_FACENAMEISDBCS) != 0;

#if 0
	// Bug1523 - (BradO) I removed this section of code so that a /fN tag is always
	// emitted for the first run of text.  In theory, we should be able to
	// assume that the first run of text would carry the default font.
	// It turns out that when reading RTF, Word doesn't use anything predictable
	// for the font of the first run of text in the absence of an explicit /fN, 
	// thus, we have to explicitly emit a /fN tag for the first run of text.
	if(!Count)												// 0th font is
	{														//  default \deff0
		_CF.bPitchAndFamily	= pCF->bPitchAndFamily;			// Set "previous"
		_CF.bCharSet		= pCF->bCharSet;				//  CF accordingly
		wcscpy(_CF.szFaceName, pCF->szFaceName);
	}
#endif

	return itf;
}

/*
 *	CRTFWrite::BuildTables(rpCF, rpPF, cch, fNameIsDBCS)
 *
 *	@mfunc
 *		Build font and color tables for write range of length <p cch>
 *
 *	@rdesc
 *		EC			The error code
 */
EC CRTFWrite::BuildTables(
	CFormatRunPtr& rpCF,	//@parm CF run ptr for start of write range
	CFormatRunPtr& rpPF,	//@parm PF run ptr for start of write range
	LONG cch,				//@parm # chars in write range
	BOOL& fNameIsDBCS)		//@parm OUT =TRUE if there is any CFE_FACENAMEISDBCS Run in selection.
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::BuildTables");

	LONG				i;
	LONG				ifmt = 0;
	const CCharFormat *	pCF = NULL;
	const CParaFormat * pPF = NULL;
	CFormatRunPtr		rp(rpCF);
	CFormatRunPtr		rpPFtemp(rpPF);
	LONG				cchTotal = cch;

	fNameIsDBCS = FALSE;

	while(cch > 0)
	{
		ifmt = rp.GetFormat();					// _iFormat for next CF run
		pCF = _ped->GetCharFormat(ifmt);

		Assert(pCF);

		if (pCF->_dwEffects & CFE_FACENAMEISDBCS)
			fNameIsDBCS = TRUE;

		// Look up character-format *pCF's font and color. If either isn't
		// found, it is added to appropriate table.  Don't lookup color
		// for CCharFormats with auto-color

		if (LookupFont(pCF) < 0 ||
			(!(pCF->_dwEffects & CFE_AUTOCOLOR) &&
				LookupColor(pCF->_crTextColor) < 0) ||
			(!(pCF->_dwEffects & CFE_AUTOBACKCOLOR) &&
				LookupColor(pCF->_crBackColor) < 0))
		{
			break;
		}
		if(!rp.IsValid())
			break;
		cch -= rp.GetCchLeft();
		rp.NextRun();
	}

	// now look for bullets; if found, then we need to include
	// the "Symbol" font

	cch = cchTotal;
	_symbolFont = 0;

	while( cch > 0 )
	{
		ifmt = rpPFtemp.GetFormat();
		pPF = _ped->GetParaFormat(ifmt);
		if(!pPF)
			goto CacheError;
		
		if(pPF->_wNumbering == PFN_BULLET && !_symbolFont)
		{
			CCharFormat CF;

			// Be sure these choices agree with those in CMeasurer::GetCcsBullet()
			// and that LookupFont() doesn't access any other CF members.
			CF._iFont			= IFONT_SYMBOL;
			CF._bCharSet		= SYMBOL_CHARSET;
			CF._bPitchAndFamily = FF_DONTCARE;

			// Save Font index for Symbol. Reset it to 0 if LookupFont
			// returns error.
			_symbolFont = LookupFont(&CF);
			_symbolFont = max(_symbolFont, 0);

			// We don't need to bother looking for more bullets, since
			// in RichEdit 2.0, all bullets either have the same font or
			// have their formatting information in the character format
			// for the EOP mark.
			break;
		}
		
		WORD  Widths = pPF->_wBorderWidth;
		DWORD Colors = pPF->_dwBorderColor & 0xFFFFF;

		while(Widths && Colors)
		{
			i = Colors & 0x1F;
			if(i && (Widths & 0xF))
				LookupColor(g_Colors[i - 1]);

			Widths >>= 4;
			Colors >>= 5;
		}
		
		i = (pPF->_wShadingStyle >> 6) & 31;		// Shading forecolor
		if(i)
			LookupColor(g_Colors[i - 1]);
		i = pPF->_wShadingStyle >> 11;				// Shading backcolor
		if(i)
			LookupColor(g_Colors[i - 1]);

		if(IsHeadingStyle(pPF->_sStyle) && pPF->_sStyle < _nHeadingStyle)
			_nHeadingStyle = pPF->_sStyle;

		if(!rpPFtemp.IsValid())
			break;
		
		cch -= rpPFtemp.GetCchLeft();
		rpPFtemp.NextRun();
	}	

	return _ecParseError;

CacheError:
	_ecParseError = ecFormatCache;
	return ecFormatCache;					// Access to CF/PF cache failed
}

/*
 *	CRTFWrite::WriteFontTable()
 *
 *	@mfunc
 *		Write out font table
 *
 *	@rdesc
 *		EC				The error code
 */
EC CRTFWrite::WriteFontTable()
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WriteFontTable");

	LONG			Count = _fonts.Count();
	int				itf;
	int				m;
	int				pitch;
	TEXTFONT *		ptf;
	char *			szFamily;
	const TCHAR *	szName;
	TCHAR *			szTaggedName;

	if(!Count || !PutCtrlWord(CWF_GRP, i_fonttbl))	// Start font table group
		goto CleanUp;

	for (itf = 0; itf < Count; itf++)
	{
		ptf = _fonts.Elem(itf);

//		if (ptf->sCodePage)
//			if (! PutCtrlWord(CWF_VAL, i_cpg, ptf->sCodePage ) )
//				goto CleanUp;

		// Define font family
		m			 = ptf->bPitchAndFamily >> 4;
		szFamily	 = rgKeyword[rgiszFamily[m < CFAMILIES ? m : 0]].szKeyword;
		szName		 = GetFontName(ptf->iFont);
		szTaggedName = NULL;

		// Check to see if this is a tagged font
		if (!ptf->bCharSet ||
			!FindTaggedFont(szName, ptf->bCharSet, &szTaggedName))
		{
			szTaggedName = NULL;
		}

		pitch = ptf->bPitchAndFamily & 0xF;					// Write font
		if (!printF(szBeginFontEntryFmt, itf, szFamily))	//  entry, family,
			goto CleanUp;
		_fNeedDelimeter = TRUE;
		if (pitch && !PutCtrlWord(CWF_VAL, i_fprq, pitch))	//  and pitch
			goto CleanUp;

		if(!ptf->sCodePage && ptf->bCharSet)
			ptf->sCodePage = (short)GetCodePage(ptf->bCharSet);

		// Write charset. Win32 uses ANSI_CHARSET to mean the default Windows
		// character set, so find out what it really is

		extern BYTE bCharSetANSI;

		if(ptf->bCharSet != DEFAULT_CHARSET)
		{
			BYTE bCharSet = ptf->bCharSet;
			BOOL fWroteCharSet = TRUE;

			if(ptf->bCharSet == PC437_CHARSET || IsPrivateCharSet(bCharSet))
			{
				fWroteCharSet = FALSE;
				bCharSet = ANSI_CHARSET;
			}
			if(!PutCtrlWord(CWF_VAL, i_fcharset, bCharSet))
				goto CleanUp;

			// Skip \cpgN output if we've already output a \fcharsetN tag.
			// This is to accomodate RE 1.0, which can't handle some \cpgN
			// tags properly. Specifically, when RE 1.0 parses the \cpgN tag
			// it looks up the corresponding charset value. Turns out its
			// codepage/charset table is incomplete so it maps some codepages
			// to charset 0, trouncing the previously read \fcharsetN value.
			if (fWroteCharSet)
				goto WroteCharSet;
		}

		if(ptf->sCodePage && !PutCtrlWord(CWF_VAL, i_cpg, ptf->sCodePage))
			goto CleanUp;

WroteCharSet:
		if(szTaggedName)							
		{											
			// Have a tagged font:  write out group with real name followed by tagged name
			if(!PutCtrlWord(CWF_AST, i_fname) ||	
				WritePcData(szName, ptf->sCodePage, ptf->fNameIsDBCS) ||			
				!Puts(szEndFontEntry, sizeof(szEndFontEntry) - 1) ||
				WritePcData(szTaggedName, ptf->sCodePage, ptf->fNameIsDBCS) ||
				!Puts(szEndFontEntry, sizeof(szEndFontEntry) - 1))
			{
				goto CleanUp;
			}
		}
		else if(WritePcData(szName, ptf->sCodePage, ptf->fNameIsDBCS) ||
					!Puts(szEndFontEntry, sizeof(szEndFontEntry) - 1))
		// If non-tagged font just write name out
		{
			goto CleanUp;
		}
	}
	Puts(szEndGroupCRLF, sizeof(szEndGroupCRLF) - 1);							// End font table group

CleanUp:
	return _ecParseError;
}

/*
 *	CRTFWrite::WriteColorTable()
 *
 *	@mfunc
 *		Write out color table
 *
 *	@rdesc
 *		EC				The error code
 */
EC CRTFWrite::WriteColorTable()
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WriteColorTable");

	LONG		Count = _colors.Count();
	COLORREF	clrf;
	LONG		iclrf;

	if (!Count || !PutCtrlWord(CWF_GRP, i_colortbl)	// Start color table group
		|| !PutChar(';'))							//  with null first entry
	{
		goto CleanUp;
	}

	for(iclrf = 0; iclrf < Count; iclrf++)
	{
		clrf = _colors.GetAt(iclrf);
		if (!printF(szColorEntryFmt,
					GetRValue(clrf), GetGValue(clrf), GetBValue(clrf)))
			goto CleanUp;
	}

	Puts(szEndGroupCRLF,sizeof(szEndGroupCRLF) -1);		// End color table group

CleanUp:
	return _ecParseError;
}

/*
 *	CRTFWrite::WriteCharFormat(pCF)
 *
 *	@mfunc
 *		Write deltas between CCharFormat <p pCF> and the previous CCharFormat
 *		given by _CF, and then set _CF = *<p pCF>.
 *
 *	@rdesc
 *		EC			The error code
 *
 *	@devnote
 *		For optimal output, could write \\plain and use deltas relative to
 *		\\plain if this results in less output (typically only one change
 *		is made when CF changes, so less output results when compared to
 *		previous CF than when compared to \\plain).
 */
EC CRTFWrite::WriteCharFormat(
	const CCharFormat * pCF)		//@parm Ptr to CCharFormat
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WriteCharFormat");

	DWORD	dwEffects = pCF->_dwEffects;			// Current effects
	DWORD	dwChanges = _CF._dwEffects;				// Previous effects (will be 
	LONG	i;										//  changed between them)
	LONG	iFormat;
	LONG	iValue;									// Control-word value
	LONG	i_sz;									// Temp ctrl string index
	LONG	yOffset = pCF->_yOffset;

	DWORD UType1 = _CF._bUnderlineType;				// Previous underline type
	if(UType1 >= CUNDERLINES)						// Special underlines are
		dwChanges &= ~CFE_UNDERLINE;				//  not written out, so
													//  claim they're not on
	DWORD UType2 = pCF->_bUnderlineType;			// Current underline type
	if(UType2 >= CUNDERLINES)						// _bUnderlineType for
		dwEffects &= ~CFE_UNDERLINE;				//  specials has non0
													//  high nibble
	dwChanges ^= dwEffects;							// Now dwChanges is the
													//  diff between effects
	if (dwChanges & CFE_AUTOCOLOR ||				// Change in autocolor
		pCF->_crTextColor != _CF._crTextColor)		//  or text color
	{
		iValue = 0;									// Default autocolor
		if(!(dwEffects & CFE_AUTOCOLOR))			// Make that text color
			iValue = LookupColor(pCF->_crTextColor) + 1;
		if(!PutCtrlWord(CWF_VAL, i_cf, iValue))
			goto CleanUp;
	}

	if (dwChanges & CFE_AUTOBACKCOLOR ||			// Change in autobackcolor
		pCF->_crBackColor != _CF._crBackColor)		//  or backcolor
	{
		iValue = 0;									// Default autobackcolor
		if(!(dwEffects & CFE_AUTOBACKCOLOR))		// Make that back color
			iValue = LookupColor(pCF->_crBackColor) + 1;
		if(!PutCtrlWord(CWF_VAL, i_highlight, iValue))
			goto CleanUp;
	}

	if (pCF->_lcid		!= _CF._lcid &&
		!PutCtrlWord(CWF_VAL, i_lang, LANGIDFROMLCID((WORD)pCF->_lcid)) ||
		pCF->_sSpacing	!= _CF._sSpacing &&
		!PutCtrlWord(CWF_VAL, i_expndtw, pCF->_sSpacing)		||
		/* FUTURE (alexgo): This code is incorrect and we don't
		yet handle the Style table.  We may want to support this
		better in a future version.
		pCF->_sStyle	!= _CF._sStyle && pCF->_sStyle > 0  &&
		!PutCtrlWord(CWF_VAL, i_cs, pCF->_sStyle)			|| */
		pCF->_bAnimation	!= _CF._bAnimation &&
		!PutCtrlWord(CWF_VAL, i_animtext, pCF->_bAnimation)	||
		/* FUTURE (alexgo): this code doesn't work yet, as we don't
		output the revision table.  We may want to support this 
		better in a future version
		pCF->_bRevAuthor!= _CF._bRevAuthor &&
		!PutCtrlWord(CWF_VAL, i_revauth, pCF->_bRevAuthor)	|| */
		pCF->_wKerning	!= _CF._wKerning &&
		!PutCtrlWord(CWF_VAL, i_kerning, pCF->_wKerning/10) )
	{
		goto CleanUp;
	}

	// Handle all underline types.  Special underline types (nonzero high
	// nibble in CCharFormat::_bUnderlineType) are considered to be no
	// underline and have their UType set equal to 0 above and underline
	// effect bits reset to 0.
	if ((dwChanges & CFM_UNDERLINE) ||
		(dwEffects & CFE_UNDERLINE)	&& UType1 != UType2)
	{
		dwChanges &= ~CFE_UNDERLINE;				// Suppress underline
		i = dwEffects & CFE_UNDERLINE ? UType2: 0;	//  action in next for()
		if(!PutCtrlWord(CWF_STR, rgiszUnderlines[i]))					
			goto CleanUp;						
	}
													// This must be before next stuff
	if(dwChanges & (CFM_SUBSCRIPT | CFM_SUPERSCRIPT))//  change in sub/sup
	{												// status	
	 	i_sz = dwEffects & CFE_SUPERSCRIPT ? i_super
	    	 : dwEffects & CFE_SUBSCRIPT   ? i_sub
	       	 : i_nosupersub;
     	if(!PutCtrlWord(CWF_STR, i_sz))
			goto CleanUp;
	}

	if(dwChanges & CFE_DELETED)						// Insert deleted at high
	{												//  end of bit string
		dwChanges |= CFE_REVISED << 1;
		if(dwEffects & CFE_DELETED)
			dwEffects |= CFE_REVISED << 1;
	}

	dwChanges &= ((1 << CEFFECTS) - 1) & ~CFE_LINK;	// Output keywords for
	for(i = CEFFECTS;								//  effects that changed
		dwChanges && i--;							// rgszEffects[] contains
		dwChanges >>= 1, dwEffects >>= 1)			//  effect keywords in
	{												//  order max CFE_xx to
		if(dwChanges & 1)							//  min CFE-xx
		{											// Change from last call
			iValue = dwEffects & 1;					// If effect is off, write
			iFormat = iValue ? CWF_STR : CWF_VAL;	//  a 0; else no value
			if(!PutCtrlWord(iFormat,
				rgiszEffects[i], iValue))
					goto CleanUp;
		}
	}

	if(yOffset != _CF._yOffset)						// Change in base line 
	{												// position 
		yOffset /= 10;								// Default going to up
		i_sz = i_up;
		iFormat = CWF_VAL;
		if(yOffset < 0)								// Make that down
		{
			i_sz = i_dn;
			yOffset = -yOffset;
		}
		if(!PutCtrlWord(iFormat, i_sz, yOffset))
			goto CleanUp;
	}

	if (pCF->_bPitchAndFamily != _CF._bPitchAndFamily || // Change in font
		pCF->_bCharSet		  != _CF._bCharSet		  ||
		pCF->_iFont			  != _CF._iFont)
	{
		iValue = LookupFont(pCF);
		if(iValue < 0 || !PutCtrlWord(CWF_VAL, i_f, iValue))
			goto CleanUp;

		// RichEdit encodes the current direction in bCharSet, but Word likes
		// to know explicitly, so output the appropriate choice of \rtlch or
		// \ltrch if the direction changes
		BOOL fRTLCharSet = IsRTLCharSet(pCF->_bCharSet);

		if (fRTLCharSet != IsRTLCharSet(_CF._bCharSet) &&
			!PutCtrlWord(CWF_STR, fRTLCharSet ? i_rtlch : i_ltrch))
		{
			goto CleanUp;
		}
	}

	if (pCF->_yHeight != _CF._yHeight)					// Change in font size
	{
		iValue = (pCF->_yHeight + (pCF->_yHeight > 0 ? 5 : -5))/10;
		if(!PutCtrlWord(CWF_VAL, i_fs, iValue))
			goto CleanUp;
	}

	_CF = *pCF;									// Update previous CCharFormat

CleanUp:
	return _ecParseError;
}

/*
 *	CRTFWrite::WriteParaFormat(prtp)
 *
 *	@mfunc
 *		Write out attributes specified by the CParaFormat <p pPF> relative
 *		to para defaults (probably produces smaller output than relative to
 *		previous para format and let's you redefine tabs -- no RTF kill
 *		tab command	except \\pard)
 *
 *	@rdesc
 *		EC				The error code
 */
EC CRTFWrite::WriteParaFormat(
	const CRchTxtPtr * prtp)	//@parm Ptr to rich-text ptr at current cp
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WriteParaFormat");

	Assert(_ped);

	//if(!_fRangeHasEOP)							// Don't write para info if
	//	return _ecParseError;					//  range has no EOPs

	const CParaFormat * pPFPrev = _pPF;
	const CParaFormat * pPF = _pPF = prtp->GetPF();
	BOOL	fInTable = pPF->InTable();
	LONG	c;					  				// Temporary count
	LONG	cTab = pPF->_bTabCount;
	DWORD	dwEffects;
	DWORD	dwRule	= pPF->_bLineSpacingRule;
	LONG	dy		= pPF->_dyLineSpacing;
	LONG	i_t, i, j, k;
	LONG	tabAlign, tabLead, tabPos;
	LONG	lDocDefaultTab = _ped->GetDefaultTab();
	const LONG *prgxTabs = NULL;

	if(!lDocDefaultTab)
		lDocDefaultTab = lDefaultTab;

	CheckInTable(FALSE);
	if(fInTable)
		cTab = 0;								// Suppress \tab output

	AssertSz(cTab >= 0 && cTab <= MAX_TAB_STOPS,
		"CRTFW::WriteParaFormat: illegal cTabCount");

	// EVIL HACK ALERT! - Exchange's IMC keys on the \protect tag when it does
	//	its reply-ticking for mail being sent to Internet recipients.  
	//	Paragraphs following a \pard and containing a \protect tag are 
	//	reply-ticked, so we must ensure that each \pard in a protected range
	//	is followed by a \protect tag.

	if (_CF._dwEffects & CFE_PROTECTED && !PutCtrlWord(CWF_VAL, i_protect, 0) ||
		!PutCtrlWord(CWF_STR, i_pard) ||			// Reset para attributes
		_CF._dwEffects & CFE_PROTECTED && !PutCtrlWord(CWF_STR, i_protect))
	{
		goto CleanUp;
	}

	if(fInTable)
	{
		if(_fRangeHasEOP && !PutCtrlWord(CWF_STR, i_intbl))
			goto CleanUp;
	}
	else if(PutBorders(FALSE))
		goto CleanUp;

	if(pPF->_wShadingStyle)
	{
		i = pPF->_wShadingStyle & 15;				// Shading patterns
		j = (pPF->_wShadingStyle >> 6) & 31;			// Shading forecolor
		k = pPF->_wShadingStyle >> 11;				// Shading backcolor
		if (i && i <= CSHADINGSTYLES &&
			!PutCtrlWord(CWF_STR, rgiszShadingStyles[i - 1]) ||
			j && !PutCtrlWord(CWF_VAL, i_cfpat, LookupColor(g_Colors[j-1]) + 1) ||
			k && !PutCtrlWord(CWF_VAL, i_cbpat, LookupColor(g_Colors[k-1]) + 1))
		{
			goto CleanUp;
		}
	}
	if(pPF->_wShadingWeight && !PutCtrlWord(CWF_VAL, i_shading, pPF->_wShadingWeight))
		goto CleanUp;

	// Paragraph numbering
	_fBullet = _fBulletPending = FALSE;
	_nNumber = pPF->UpdateNumber(_nNumber, pPFPrev);

	if(pPF->_wNumbering)							// Write numbering info
	{
		LONG iFont = _symbolFont;
		WORD wStyle = pPF->_wNumberingStyle & 0xF00;

		if(pPF->IsListNumbered())
		{
			const CCharFormat *pCF;
			WCHAR szNumber[CCHMAXNUMTOSTR];

			CTxtPtr		  rpTX(prtp->_rpTX);
			CFormatRunPtr rpCF(prtp->_rpCF);

			rpCF.AdvanceCp(rpTX.FindEOP(tomForward));
			rpCF.AdjustBackward();
			pCF = _ped->GetCharFormat(rpCF.GetFormat());
			iFont = LookupFont(pCF);
			if(iFont < 0)
			{
				iFont = 0;
				TRACEERRORSZ("CWRTFW::WriteParaFormat: illegal bullet font");
			}
			_nFont = iFont;
			// TODO: make the following smarter, i.e., may need to increment
			// _nNumber instead of resetting it to 1.
			_cpg = GetCodePage(pCF->_bCharSet);

			i = 0;
			if(pPF->_wNumbering <= tomListNumberAsUCRoman)
				i = pPF->_wNumbering - tomListNumberAsArabic;

			WCHAR ch = (wStyle == PFNS_PARENS || wStyle == PFNS_PAREN) ? ')'
					 : (wStyle == PFNS_PERIOD) ? '.' : 0;
			if(wStyle != PFNS_NONUMBER)			  // Unless number suppressed
			{									  //  write \pntext group
				pPF->NumToStr(szNumber, _nNumber, fRtfWrite);
				if (!printF(szBeginNumberGroup, iFont) ||
					WritePcData(szNumber, _cpg, FALSE) ||	
					!printF(szEndNumberGroup))
				{
					goto CleanUp;
				}
			}
			j = pPF->_wNumberingStyle & 3;
			if (!printF(szBeginNumberFmt,
						wStyle == PFNS_NONUMBER ? "cont" : "body",
						iFont, pPF->_wNumberingTab,
						pPF->_wNumberingStart)				||
				IN_RANGE(1, j, 2) && !PutCtrlWord(CWF_STR,
								j == 1 ? i_pnqc : i_pnqr)	||
				!PutCtrlWord(CWF_STR, rgiszNumberStyle[i])	||
				wStyle == PFNS_PARENS && !printF(szpntxtb)	||
				ch && !printF(szpntxta, ch)					||
				!printF(szEndGroupCRLF))
			{
				goto CleanUp;
			}
		}
		else
		{
			if (!printF(szBulletGroup, iFont) ||
				!printF(szBulletFmt,
						wStyle == PFNS_NONUMBER ? "cont" : "blt",
						iFont, pPF->_wNumberingTab))
			{
				goto CleanUp;
			}
		}
		_fBullet = TRUE;
	}

	dwEffects = pPF->_wEffects & ((1 << CPFEFFECTS) - 1);
	if (_ped->IsBiDi() && !(dwEffects & PFE_RTLPARA) &&
		!PutCtrlWord(CWF_STR, i_ltrpar))		//ltrpar attribute
	{
		goto CleanUp;
	}

	for(c = CPFEFFECTS; dwEffects && c--;		// Output PARAFORMAT2 effects
		dwEffects >>= 1)	
	{
		// rgiszPFEffects[] contains PF effect keywords in the
		//  order max PFE_xx to min PFE-xx

		AssertSz(rgiszPFEffects[2] == i_hyphpar,
			"CRTFWrite::WriteParaFormat(): rgiszPFEffects is out-of-sync with PFE_XXX");
		// \hyphpar has opposite logic to our PFE_DONOTHYPHEN so we emit
		// \hyphpar0 to toggle the property off

		if (dwEffects & 1 &&
			!PutCtrlWord((c == 2) ? CWF_VAL : CWF_STR, rgiszPFEffects[c], 0))
		{
			goto CleanUp;
		}				
	}
	
	// Put out para indents. RTF first indent = -PF.dxOffset
	// RTF left indent = PF.dxStartIndent + PF.dxOffset

	if(IsHeadingStyle(pPF->_sStyle) && !PutCtrlWord(CWF_VAL, i_s, -pPF->_sStyle-1))
		goto CleanUp;
		
	if(!fInTable &&
	   (pPF->_dxOffset &&
		!PutCtrlWord(CWF_VAL, i_fi, -pPF->_dxOffset)	||
		pPF->_dxStartIndent + pPF->_dxOffset &&
		!PutCtrlWord(CWF_VAL, (pPF->IsRtlPara())
						? i_ri : i_li, pPF->_dxStartIndent + pPF->_dxOffset) ||
		pPF->_dxRightIndent	  &&
		!PutCtrlWord(CWF_VAL, (pPF->IsRtlPara())
						? i_li : i_ri, pPF->_dxRightIndent)	||
		pPF->_dySpaceBefore	  &&
		!PutCtrlWord(CWF_VAL, i_sb, pPF->_dySpaceBefore) ||
		pPF->_dySpaceAfter	  &&
		!PutCtrlWord(CWF_VAL, i_sa, pPF->_dySpaceAfter)))
	{
		goto CleanUp;
	}

	if(dwRule)									// Special line spacing active
	{
		i = 0;									// Default "At Least" or
		if (dwRule == tomLineSpaceExactly)		//  "Exactly" line spacing
			dy = -abs(dy);						// Use negative for "Exactly"

		else if(dwRule == tomLineSpaceMultiple)	// RichEdit uses 20 units/line
		{										// RTF uses 240 units/line
			i++;
			dy *= 12;							
		}

		else if (dwRule != tomLineSpaceAtLeast && dy > 0)
		{
			i++;								// Multiple line spacing
			if (dwRule <= tomLineSpaceDouble)	// 240 units per line
				dy = 120 * (dwRule + 2);
		}
		if (!PutCtrlWord(CWF_VAL, i_sl, dy) ||
			!PutCtrlWord(CWF_VAL, i_slmult, i))
		{
			goto CleanUp;
		}
	}

	if (!fInTable && IN_RANGE(PFA_RIGHT, pPF->_bAlignment, PFA_JUSTIFY) &&
		!PutCtrlWord(CWF_STR, rgiszAlignment[pPF->_bAlignment - 1]))
	{
		goto CleanUp;
	}

	prgxTabs = pPF->GetTabs();
	for (i = 0; i < cTab; i++)
	{
		pPF->GetTab(i, &tabPos, &tabAlign, &tabLead, prgxTabs);
		AssertSz (tabAlign <= tomAlignBar && tabLead <= 5,
			"CRTFWrite::WriteParaFormat: illegal tab leader/alignment");

		i_t = i_tb;								// Default \tb (bar tab)
		if (tabAlign != tomAlignBar)			// It isn't a bar tab
		{
			i_t = i_tx;							// Use \tx for tabPos
			if (tabAlign &&						// Put nonleft alignment
				!PutCtrlWord(CWF_STR, rgiszTabAlign[tabAlign-1]))
			{
				goto CleanUp;
			}
		}
		if (tabLead &&							// Put nonzero tab leader
			!PutCtrlWord(CWF_STR, rgiszTabLead[tabLead-1]) ||
			!PutCtrlWord(CWF_VAL, i_t, tabPos))
		{
			goto CleanUp;
		}
	}

CleanUp:
	return _ecParseError;
}

/*
 *	CRTFWrite::WriteText(cwch, lpcwstr, nCodePage, fIsDBCS)
 *
 *	@mfunc
 *		Write out <p cwch> chars from the Unicode text string <p lpcwstr> taking care to
 *		escape any special chars.  The Unicode text string is scanned for characters which
 *		map directly to RTF strings, and the surrounding chunks of Unicode are written
 *		by calling WriteTextChunk.
 *
 *	@rdesc
 *		EC	The error code
 */
EC CRTFWrite::WriteText(
	LONG		cwch,		//@parm # chars in buffer
	LPCWSTR 	lpcwstr,	//@parm Pointer to text
	INT			nCodePage,	//@parm Code page to use to convert to DBCS
	BOOL		fIsDBCS)	//@parm If TRUE, lpcwstr is DBCS string 
							//		stuffed into a WSTR
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WriteText");

	WCHAR *pwchScan;
	WCHAR *pwchStart;

	if(_fBulletPending)
	{
		_fBulletPending = FALSE;
		if(!_nNumber)
		{
			if(!printF(szBulletGroup, _symbolFont))
				goto CleanUp;
		}
		else if(!_pPF->IsNumberSuppressed())
		{
			WCHAR szNumber[CCHMAXNUMTOSTR];
			_pPF->NumToStr(szNumber, ++_nNumber, fRtfWrite);
			if (!printF(szBeginNumberGroup, _nFont) ||
				WritePcData(szNumber, _cpg, FALSE)	||
				!printF(szEndNumberGroup))
			{
				goto CleanUp;
			}
		}
	}
	if(_fCheckInTable)
	{
		CheckInTable(TRUE);
		if(_ecParseError)
			goto CleanUp;
	}

	pwchScan = const_cast<LPWSTR>(lpcwstr);
	pwchStart = pwchScan;
	if(_CF._bCharSet == SYMBOL_CHARSET)
	{
		pwchScan += cwch;
		cwch = 0;
	}

	// Step through the Unicode buffer, weeding out characters that have  
	// known translations to RTF strings
	while(cwch-- > 0)
	{
		WCHAR	wch = *pwchScan;

		// If this is a string for which the MultiByteToUnicode conversion
		// failed, the buffer will be filled with ANSI bytes stuffed into
		// wchar's (one per).  In this case, we don't want to map trail bytes
		// to RTF strings.
		if(fIsDBCS && GetTrailBytesCount(wch, nCodePage) && nCodePage != CP_UTF8)
		{
			// If we have more characters in the buffer, then this is the
			// DBC pair.  Otherwise, treat it as single character.
			if(cwch > 0)
			{
				cwch--;
				pwchScan += 2;
				continue;
			}
		}

		// if the char is one for which there is an appropriate RTF string
		// write the preceding chars and output the RTF string

		if(!IN_RANGE(' ', wch, 'Z') &&
		   !IN_RANGE('a', wch, 'z') &&
		   !IN_RANGE(chOptionalHyphen + 1, wch, ENSPACE - 1) &&
		   wch <= BULLET &&
		   MapsToRTFKeywordW(wch))
		{
			if (pwchScan != pwchStart &&
				WriteTextChunk(pwchScan - pwchStart, pwchStart, nCodePage, 
									fIsDBCS))
			{
				goto CleanUp;
			}

			// map the char(s) to the RTF string
			int cwchUsed = MapToRTFKeyword(pwchScan, cwch, MAPTOKWD_UNICODE);

			cwch -= cwchUsed;
			pwchScan += cwchUsed;

			// start of next run of unprocessed chars is one past current char
			pwchStart = pwchScan + 1;
			if(cwch && _fCheckInTable)
			{
				_fCheckInTable = FALSE;
				if(!PutCtrlWord(CWF_STR, i_intbl))
					goto CleanUp;
			}
		}
		pwchScan++;
	}

	// write the last chunk
	if (pwchScan != pwchStart &&
		WriteTextChunk(pwchScan - pwchStart, pwchStart, nCodePage, fIsDBCS))
	{
		goto CleanUp;
	}

CleanUp:
	return _ecParseError;
}

/*
 *	CRTFWrite::WriteTextChunk(cwch, lpcwstr, nCodePage, fIsDBCS)
 *
 *	@mfunc
 *		Write out <p cwch> chars from the Unicode text string <p lpcwstr> taking care to
 *		escape any special chars.  Unicode chars which cannot be converted to
 *		DBCS chars using the supplied codepage, <p nCodePage>, are written using the
 *		\u RTF tag.
 *
 *	@rdesc
 *		EC				The error code
 */
EC CRTFWrite::WriteTextChunk(
	LONG		cwch,					//@parm # chars in buffer
	LPCWSTR 	lpcwstr,				//@parm Pointer to text
	INT			nCodePage,				//@parm code page to use to convert to DBCS
	BOOL		fIsDBCS)				//@parm indicates whether lpcwstr is a Unicode string
										//		or a DBCS string stuffed into a WSTR
{
	// FUTURE(BradO):  There is alot of commonality b/t this routine and
	//	WritePcData.  We should re-examine these routines and consider 
	//	combining them into a common routine.

	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WriteTextChunk");

	BYTE 	b;
	LONG	cbAnsi;
	LONG	cbAnsiBufferSize;
	LONG	cbChar;
	UINT	ch;
	BOOL 	fMissingCodePage = FALSE;
	BOOL	fMultiByte;
	BOOL 	fUsedDefault = FALSE;
	BYTE *	pbAnsi;
	BYTE *	pbAnsiBuffer;

	// When WideCharToMultiByte fails to convert a char, the following default
	// char is used as a placeholder in the string being converted
	const char chToDBCSDefault = 0;

	// Allocate temp buffer for ANSI text we convert to
	cbAnsiBufferSize = cachBufferMost * (nCodePage == CP_UTF8 ? 3 : MB_LEN_MAX);
	if (!_pbAnsiBuffer)
	{
		// If the code page was CP_UTF8, it will always be CP_UTF8 for this instance
		_pbAnsiBuffer = (BYTE *)PvAlloc(cbAnsiBufferSize, GMEM_FIXED);
		if (!_pbAnsiBuffer)
			goto RAMError;
	}
	pbAnsiBuffer = _pbAnsiBuffer;

	// Convert Unicode (or fIsDBCS) buffer to ANSI 
	if(fIsDBCS)
	{
		// Supply some bogus code page which will force direct conversion
		// from wchar to bytes (losing high byte of wchar).
		// Also, don't want to use default char replacement in this case.
		cbAnsi = WCTMB(INVALID_CODEPAGE, 0, lpcwstr, cwch, 
						(char *)pbAnsiBuffer, cbAnsiBufferSize,
						NULL, NULL, NULL);
	}
	else
	{
		cbAnsi = WCTMB(nCodePage, 0, lpcwstr, cwch, 
						(char *)pbAnsiBuffer, cbAnsiBufferSize,
						&chToDBCSDefault, &fUsedDefault,
						&fMissingCodePage);
	}
	Assert(cbAnsi > 0);

	pbAnsi = pbAnsiBuffer;
	fMultiByte = (cbAnsi > cwch) || fIsDBCS || fMissingCodePage;

	while (!_ecParseError && cbAnsi-- > 0)
	{
		b = *pbAnsi;
		ch = *lpcwstr;

		// Compare ASCII chars to their Unicode counterparts to check
		// that we're in sync
		AssertSz(cwch <= 0 || ch > 127 || b == ch, 
			"CRTFWrite::WriteText: Unicode and DBCS strings out of sync");

		// If _fNCRForNonASCII, output the \uN tag for all nonASCII chars.
		// This is useful because many Unicode chars that aren't in the
		// target codepage are converted by WideCharToMultiByte() to some
		// "best match char" for the codepage, e.g., alpha (0x3B1) converts
		// to 'a' for cpg 1252.
		//
		// For NT 5, we use WC_NO_BEST_FIT_CHARS, which causes our regular
		// algorithm to output \uN values whenever the system cannot convert
		// a character correctly. This still requires readers that can handle
		// multicodepage RTF, which is problematic for some RTF-to-HTML
		// converters.
		if(!IN_RANGE(' ', b, 'z') && MapsToRTFKeywordA(b))
		{
			int cchUsed = MapToRTFKeyword(pbAnsi, cbAnsi, MAPTOKWD_ANSI);
			cbAnsi -= cchUsed;
			pbAnsi += cchUsed;
			lpcwstr += cchUsed;
			cwch -= cchUsed;
		}
		else if(nCodePage == CP_UTF8)
		{
			PutChar(b);								// Output 1st byte in any
			if(b >= 0xC0)							//  case. At least 2-byte
			{										// At least 2-byte lead
				pbAnsi++;							//  byte, so output a
				Assert(cbAnsi && IN_RANGE(0x80, *pbAnsi, 0xBF));
				cbAnsi--;							//  trail byte
				PutChar(*pbAnsi);
				if(b >= 0xE0)						// 3-byte lead byte, so
				{									//  output another trail
					pbAnsi++;						//  byte
					Assert(cbAnsi && IN_RANGE(0x80, *pbAnsi, 0xBF));
					cbAnsi--;
					PutChar(*pbAnsi);
				}
			}
		}
		else
		{
			cbChar = fMultiByte && cbAnsi && GetTrailBytesCount(b, nCodePage)
				   ? 2 : 1;
			if(ch >= 0x80 && !fIsDBCS && _fNCRForNonASCII && nCodePage != CP_SYMBOL)
			{									// Output /uN for nonASCII
				if(cbChar != _cbCharLast)
				{
					_cbCharLast = cbChar;		// cb to follow /uN
					if(!PutCtrlWord(CWF_VAL, i_uc, cbChar))
						goto CleanUp;
				}
				if(!PutCtrlWord(CWF_VAL, i_u, ch))
					goto CleanUp;
				Assert(chToDBCSDefault != '?');
				if(fUsedDefault)				// Don't output another /uN
				{								//  below
					b = '?';					
					_fNeedDelimeter = FALSE;
				}
			}
			if(cbChar == 2)
			{
				pbAnsi++;						// Output DBCS pair
				cbAnsi--;
				if(fIsDBCS)
				{
					lpcwstr++;
					cwch--;
				}
				printF(szEscape2CharFmt, b, *pbAnsi);
			}
			else 
			{
				if(b == chToDBCSDefault && fUsedDefault)
				{
					// WideCharToMultiByte() couldn't complete a conversion so it
					// used the default char we provided (0) used as a placeholder.
					// In this case we want to output the original Unicode char.
					if(!PutCtrlWord(CWF_VAL, i_u, (cwch > 0 ? ch : TEXT('?'))))
						goto CleanUp;

					_fNeedDelimeter = FALSE;
					if(!PutChar('?'))
						goto CleanUp;
				}
				else if(!IN_RANGE(32, b, 127))
					printF(szEscapeCharFmt, b);

				else
					PutChar(b);
 			}
		}
		pbAnsi++;
		lpcwstr++;
		cwch--;
	}
	goto CleanUp;

RAMError:
	_ped->GetCallMgr()->SetOutOfMemory();
	_ecParseError = ecNoMemory;

CleanUp:
	return _ecParseError;
}

/*
 *	CRTFWrite::WriteInfo()
 *
 *	@mfunc
 *		Write out Far East specific data.
 *
 *	@rdesc
 *		EC				The error code
 */
EC CRTFWrite::WriteInfo()
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WriteInfo");

	// TODO(BradO):  Ultimately it would be nice to set some kind of
	//	fRTFFE bit to determine whether to write \info stuff.  For now,
	//	we rely on the fact that lchars and fchars info actually exists
	//	to determine whether to write out the \info group.

#ifdef UNDER_WORK
	if (!(_dwFlags & fRTFFE)	||					// Start doc area
		!PutCtrlWord(CWF_GRP, i_info)	||
		!printF("{\\horzdoc}"))
			goto CleanUp;

	// Write out punctuation character info

	CHAR	sz[PUNCT_MAX];
	if(UsVGetPunct(_ped->lpPunctObj, PC_FOLLOWING, sz, sizeof(sz))
					> PUNCT_MAX - 2)
		goto CleanUp;

	if(!Puts("{\\*\\fchars") || WritePcData(sz) || !PutChar(chEndGroup))
		goto CleanUp;
	
	if(UsVGetPunct(ped->lpPunctObj, PC_LEADING, sz, sizeof(sz)) > PUNCT_MAX+2)
		goto CleanUp;

	if(!Puts("{\\*\\lchars") || WritePcData(sz) || !PutChar(chEndGroup))
		goto CleanUp;

	Puts(szEndGroupCRLF);							// End info group

#endif

	LPSTR lpstrLeading = NULL;
	LPSTR lpstrFollowing = NULL;

	// If either succeeds (but evaluate both)
	if(((_ped->GetLeadingPunct(&lpstrLeading) == NOERROR) +
		(_ped->GetFollowingPunct(&lpstrFollowing) == NOERROR)) &&
		(lpstrLeading || lpstrFollowing))
	{
		if (!PutCtrlWord(CWF_GRP, i_info) ||
			!Puts(szHorzdocGroup, sizeof(szHorzdocGroup) - 1))
		{
			goto CleanUp;
		}
		if (lpstrLeading &&
			(!PutCtrlWord(CWF_AST, i_lchars) || 
			 !Puts(lpstrLeading, strlen(lpstrLeading)) ||
			 !PutChar(chEndGroup)))
		{
			goto CleanUp;
		}
		if (lpstrFollowing &&
			(!PutCtrlWord(CWF_AST, i_fchars) || 
			 !Puts(lpstrFollowing, strlen(lpstrFollowing)) ||
			 !PutChar(chEndGroup)))
		{
			goto CleanUp;
		}
		Puts(szEndGroupCRLF, sizeof(szEndGroupCRLF) - 1);	// End info group
	}

CleanUp:
	return _ecParseError;
}

/*
 *	CRTFWrite::WriteRtf()
 *
 *	@mfunc
 *		Write range _prg to output stream _pes.
 *
 *	@rdesc
 *		LONG	Number of chars inserted into text; 0 means none were
 *				inserted, OR an error occurred.
 */
LONG CRTFWrite::WriteRtf()
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WriteRtf");

	LONG			cch, cchBuffer;
	LONG			cchCF, cchPF;
	LONG			cchT;
	LONG			cpMin, cpMost;
	BOOL 			fOutputEndGroup;
	LONG			i, j;
	LONG			lDocDefaultTab;
	TCHAR *			pch;
	TCHAR *			pchBuffer;
	CTxtEdit *		ped = _ped;
	CDocInfo *		pDocInfo = ped->GetDocInfo();
	CRchTxtPtr		rtp(*_prg);
	WORD			wCodePage = CP_ACP;

	AssertSz(_prg && _pes, "CRTFW::WriteRtf: improper initialization");

	cch = _prg->GetRange(cpMin, cpMost);		// Get rtp = cpMin, cch > 0
	rtp.SetCp(cpMin);

	_fRangeHasEOP = _prg->fHasEOP();			// Maintained for Selection

	if(!_prg->IsSel())							// Validate range for RTF
	{											//  writing. Don't write
		CPFRunPtr rp(rtp);						//  partial table row unless
		CTxtPtr tp(rtp._rpTX);					//  no CELLs are included
		LONG	Results;

		_fRangeHasEOP = tp.IsAtEOP();
		if(tp.FindEOP(cch, &Results))			// Need to get CELL info too
			 _fRangeHasEOP = TRUE;

		if(rtp.InTable())
		{
			tp.SetCp(cpMin);						
			if(!_fRangeHasEOP)					// Partial row
			{
				if(Results & FEOP_CELL)			// Has 1 or more CELLs
				{
					while(tp.GetCp() < cpMost)	// Stop at first CELL
					{
						if(tp.GetChar() == CELL)
						{
							cch = tp.GetCp() - cpMin;
							break;
						}
						tp.AdvanceCp(1);
					}
				}
			}
			else if(!tp.IsAfterEOP())   
			{									// Move back to start of row
				rtp.Advance(tp.FindEOP(tomBackward));
				cch += cpMin - rtp.GetCp();
			}
		}
		if(_fRangeHasEOP)						// Check cpMost for table
		{
			rp.AdvanceCp(cpMost - cpMin);		// Go to cpMost
			if(rp.InTable())
			{
				tp.SetCp(cpMost);
				cch += tp.FindEOP(tomForward);	// Include whole row
			}
		}
	}

	// Allocate buffers for text we pick up and for RTF output
	pchBuffer = (TCHAR *) PvAlloc(cachBufferMost * (sizeof(TCHAR) + 1) + 1,
								 GMEM_FIXED);	// Final 1 is for debug
	if(!pchBuffer)
	{
		fOutputEndGroup = FALSE;
		goto RAMError;
	}
	_pchRTFBuffer = (CHAR *)(pchBuffer + cachBufferMost);

	_pchRTFEnd = _pchRTFBuffer;				// Initialize RTF buffer ptr
	_cchBufferOut = 0;						//  and character count
	_cchOut = 0;							//  and character output

	// Determine the \ansicpgN value
	if(!pDocInfo)
	{
		fOutputEndGroup = TRUE;
		goto RAMError;
	}

	BOOL fNameIsDBCS;
	if (BuildTables(rtp._rpCF, rtp._rpPF, cch, fNameIsDBCS))
		goto CleanUp;

	wCodePage = (_dwFlags & SF_USECODEPAGE)
			  ? HIWORD(_dwFlags) : pDocInfo->wCpg;

	if (fNameIsDBCS && wCodePage == CP_UTF8)
	{
		// Cannot have UTF8 if we have any run containing broken DBCS.
		// Default back to regular rtf
		wCodePage = pDocInfo->wCpg;
		_dwFlags &= ~SF_USECODEPAGE;
	}

	// Start RTF with \rtfN, \urtfN, or \pwdN group
	i =	(_dwFlags & SF_RTFVAL) >> 16;
	if (!PutCtrlWord(CWF_GRV,
			(wCodePage == CP_UTF8) ? i_urtf :
			(_dwFlags & SFF_PWD)   ? i_pwd  : i_rtf, i + 1) ||
		ped->IsBiDi() && !Puts("\\fbidis", 7) ||
		!PutCtrlWord(CWF_STR, i_ansi)) 
	{
		goto CleanUpNoEndGroup;
	}

	if (wCodePage != tomInvalidCpg && wCodePage != CP_ACP &&
		!PutCtrlWord(CWF_VAL, i_ansicpg, wCodePage == CP_UTF8 ? pDocInfo->wCpg : wCodePage))
	{
		goto CleanUp;
	}

	if(!printF(szDefaultFont))
		goto CleanUp;

	LCID	lcid;
	LANGID	langid;

	if (_ped->GetDefaultLCID(&lcid) == NOERROR && 
		lcid != tomInvalidLCID && (langid = LANGIDFROMLCID(lcid)) &&
		!PutCtrlWord(CWF_VAL, i_deflang, langid))
	{
		goto CleanUp;
	}

	if (_ped->GetDefaultLCIDFE(&lcid) == NOERROR && 
		lcid != tomInvalidLCID && (langid = LANGIDFROMLCID(lcid)) &&
		!PutCtrlWord(CWF_VAL, i_deflangfe, langid))
	{
		goto CleanUp;
	}

	LONG	lDocType;
	_ped->GetDocumentType(&lDocType);
	if (lDocType && _ped->IsBiDi() &&
		!PutCtrlWord(CWF_STR, lDocType == DT_RTLDOC ? i_rtldoc : i_ltrdoc))
	{
		goto CleanUp;
	}

	lDocDefaultTab = pDocInfo->dwDefaultTabStop;
	if(!lDocDefaultTab)
		lDocDefaultTab = lDefaultTab;

	if (lDocDefaultTab != 720 && !PutCtrlWord(CWF_VAL, i_deftab, lDocDefaultTab) ||
		WriteFontTable() || WriteColorTable())
	{
		goto CleanUp;
	}

	if(_nHeadingStyle)
	{
		if(!PutCtrlWord(CWF_GRP, i_stylesheet) || !printF(szNormalStyle))
			goto CleanUp;
		
		for(i = 1; i < -_nHeadingStyle; i++)
		{
			if(!printF(szHeadingStyle, i, i))
				goto CleanUp;
		}
		Puts(szEndGroupCRLF, sizeof(szEndGroupCRLF) - 1); // End font table group
	}
	
	LRESULT lres;
	_ped->GetViewKind(&lres);
	_ped->GetViewScale(&j);
	if (WriteInfo() ||
		_fRangeHasEOP && !PutCtrlWord(CWF_VAL, i_viewkind, lres) ||
		(_dwFlags & SFF_PERSISTVIEWSCALE) && j != 100 &&
		!PutCtrlWord(CWF_VAL, i_viewscale, j))
	{
		goto CleanUp;
	}

	// Write Unicode character byte count for use by entire document (since
	// we don't use \plain's and since \ucN behaves as a char formatting tag,
	// we're safe outputting it only once).
	if(!PutCtrlWord(CWF_VAL, i_uc, iUnicodeCChDefault))
		goto CleanUp;

	while (cch > 0)
	{
		// Get next run of chars with same para formatting
		cchPF = rtp.GetCchLeftRunPF();
		cchPF = min(cchPF, cch);

		AssertSz(cchPF, "CRTFW::WriteRtf: Empty para format run!");

		if(WriteParaFormat(&rtp))			// Write paragraph formatting
			goto CleanUp;

		while (cchPF > 0)
		{
			// Get next run of characters with same char formatting
			cchCF = rtp.GetCchLeftRunCF();
			cchCF = min(cchCF, cchPF);
			AssertSz(cchCF, "CRTFW::WriteRtf: Empty char format run!");

			const CCharFormat *	pCF = rtp.GetCF();

			if (WriteCharFormat(pCF))		// Write char attributes
				goto CleanUp;

			INT nCodePage = CP_UTF8;
			if(!IsUTF8)
			{
				if(IsPrivateCharSet(pCF->_bCharSet))
					nCodePage = 1252;		// Force \uN's
				else
				{
					nCodePage = GetCodePage(pCF->_bCharSet);
					if(nCodePage == CP_ACP && (_dwFlags & SF_USECODEPAGE))
						nCodePage = HIWORD(_dwFlags);
				}
			}

			while (cchCF > 0)
			{
				cchBuffer = min(cachBufferMost, cchCF);
				// FUTURE: since this routine only reads the backing store
				// and GetText only reads it, we can avoid allocating the
				// buffer and use CTxtPtr::GetPch() directly as in
				// CMeasurer::Measure()
				cchBuffer = rtp._rpTX.GetText(cchBuffer, pchBuffer);
				pch  = pchBuffer;
				cchT = cchBuffer;  
				if(cchT > 0)					
				{								
					TCHAR * pchWork = pch;
					LONG    cchWork = cchT;
					LONG	cchTWork;
					LONG	cp = rtp.GetCp();

					while (cchWork >0)
					{
						cchT = cchWork ;
						pch = pchWork;
						while (cchWork > 0 )	// search for objects
						{
							if(*pchWork++ == WCH_EMBEDDING) 
								break;			// Will write out object
							cchWork--;
						}

						cchTWork = cchT - cchWork;
						if(cchTWork)			// write text before object
						{							
							if(WriteText(cchTWork, pch, nCodePage, 
									(pCF->_dwEffects & CFE_RUNISDBCS)))
							{
								goto CleanUp;
							}
						}
						cp += cchTWork;
						if(cchWork > 0)			// there is an object
						{
							COleObject *pobj;

							Assert(_ped->GetObjectMgr());

							pobj = _ped->GetObjectMgr()->GetObjectFromCp(cp);
							if(!pobj)
								goto CleanUp;

							// First, commit the object to make sure the pres. 
							// caches, etc. are up-to-date.  Don't worry 
							// about errors here.

							pobj->SafeSaveObject();

							if(_fIncludeObjects) 
								WriteObject(cp, pobj);

							else if(!Puts(szObjPosHolder, sizeof(szObjPosHolder) - 1))
								goto CleanUp;

							cp++;
							cchWork--;
						}
					}
				}
				rtp.Advance(cchBuffer);
				cchCF	-= cchBuffer;
				cchPF	-= cchBuffer;
				cch		-= cchBuffer;
			}
		}
	}

CleanUp:
	// End RTF group
	Puts(szEndGroupCRLF, sizeof(szEndGroupCRLF));
	FlushBuffer();

CleanUpNoEndGroup:
	FreePv(pchBuffer);

	if (_ecParseError != ecNoError)
	{
		TRACEERRSZSC("CRTFW::WriteRtf()", _ecParseError);
		Tracef(TRCSEVERR, "Writing error: %s", rgszParseError[_ecParseError]);
		
		if(!_pes->dwError)						// Make error code OLE-like
			_pes->dwError = -abs(_ecParseError);
		_cchOut = 0;
	}
	return _cchOut;

RAMError:
	ped->GetCallMgr()->SetOutOfMemory();
	_ecParseError = ecNoMemory;

	if(fOutputEndGroup)
		goto CleanUp;

	goto CleanUpNoEndGroup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\rtfwrit2.cpp ===
/*
 *	rtfwrit2.cpp
 *
 *	Description:
 *		This file contains the embedded-object implementation of the RTF
 *		writer for the RICHEDIT subsystem.
 *
 *	Authors:
 *		Original RichEdit 1.0 RTF converter: Anthony Francisco
 *		Conversion to C++ and RichEdit 2.0:  
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"


#include "_rtfwrit.h"
#include "_coleobj.h"

ASSERTDATA

// ************** V-GUYB: Add this for converting pictures to 2bpp during stream out.
#if defined(CONVERT2BPP) 

#define PWDV1_BPP   2

typedef struct 
{
    BITMAPINFOHEADER bmih;
    RGBQUAD          colors[4];
}
BMI2BPP;

const BYTE ColorTable2bpp[] = 
{
    0x00, 0x00, 0x00, 0x00, 
    0x55, 0x55, 0x55, 0x00, 
    0xAA, 0xAA, 0xAA, 0x00, 
    0xFF, 0xFF, 0xFF, 0x00
};
#endif // CONVERT2BPP
// ************** V-GUYB: End of conversion stuff.

static const CHAR szHexDigits[] = "0123456789abcdef";

static const CHAR szLineBreak[] = "\r\n";

const BYTE ObjectKeyWordIndexes [] =
{
	i_objw,i_objh,i_objscalex, i_objscaley, i_objcropl, i_objcropt, i_objcropr, i_objcropb
} ;

const BYTE PictureKeyWordIndexes [] =
{
	i_picw,i_pich,i_picscalex, i_picscaley, i_piccropl, i_piccropt, i_piccropr, i_piccropb
} ;

// TODO join with rtfwrit.cpp

// Most control-word output is done with the following printf formats
static const CHAR * rgszCtrlWordFormat[] =
{
	"\\%s", "\\%s%d", "{\\%s", "{\\*\\%s"
};

static const WORD IndexROT[] =
{
	i_wbitmap,
	i_wmetafile,
	i_dibitmap,
	i_objemb,
	i_objlink,
	i_objautlink
};


TFI *CRTFConverter::_rgtfi = NULL;				// @cmember Ptr to 1st font substitute record
INT CRTFConverter::_ctfi = 0;				    // @cmember Count of font substitute records
TCHAR *CRTFConverter::_pchFontSubInfo = NULL;	// @cmember Font name info


// internal table to insert charset into _rgtfi under winNT
typedef		struct
{
	TCHAR*	szLocaleName;
	BYTE	bCharSet;
} NTCSENTRY;

const NTCSENTRY	mpszcs[] =
{
	{ TEXT("cyr"),		204 },		// all lower case so we don't have to waste time
	{ TEXT("ce"),		238 },		// doing a tolower below - Exchange2 800
	{ TEXT("greek"),	161 },
	{ NULL,				0 }			// sentinel
};

#define		cszcs	ARRAY_SIZE(mpszcs)


/* 
 *  Service  RemoveAdditionalSpace (sz)
 *
 *  Purpose: 
 *			 Remove first and last space from the string 
 *			 Only one space will remain between words
 *
 *	Argument 
 *			 sz characters string
 */
void RemoveAdditionalSpace(TCHAR *sz)
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "RemoveAdditionalSpace");

	TCHAR *szSource = sz;
	TCHAR *szDestination = sz;

	while(*szSource == TEXT(' ') || *szSource == TAB)
	{
		*szSource++;
	}

	while(*szSource)
	{	 
		if(*szSource != TEXT(' ') && *szSource != TAB)
		{
			*szDestination++ = *szSource++;
		}
		else
		{
			*szDestination++ = TEXT(' ');
			szSource++;

			while(*szSource == TEXT(' ') || *szSource == TAB)
			{
				*szSource++;
			}
	 	}
	}
	*szDestination = TEXT('\0');
}

/*
 *	CRTFConverter::FreeFontSubInfo(void)
 * 
 *	@mfunc	release any allocated memory for font substitutions
 *
 *	@rdesc	void
 */
void CRTFConverter::FreeFontSubInfo()
{
	FreePv(_pchFontSubInfo);
	FreePv(_rgtfi);
	_pchFontSubInfo = NULL;
	_rgtfi = NULL;
}

/*
 *		CRTFConverter::ReadFontSubInfo(void)
 *
 *		Purpose:				  
 *			Read the table of Font Substitutes and parse out the tagged fonts
 *
 *		Returns:
 *			BOOL  TRUE	if OK		
 */
void CRTFConverter::ReadFontSubInfo()
{
#ifndef NOFONTSUBINFO 
	CLock clock;
	int cchBuffer = 600;	// Approximately the amount used by NT

	int cch;
	static const TCHAR szFontSubSection[] = TEXT("FontSubstitutes");
	TCHAR *pchTMax;

	if(_ctfi)
		return;

	AssertSz(!_rgtfi, "CRTFConverter::ReadFontSubInfo():  Who donated the rgtfi?");

	_pchFontSubInfo = (TCHAR *)PvAlloc(cchBuffer * sizeof(TCHAR), GMEM_FIXED);
	if(!_pchFontSubInfo)
	{
		goto Cleanup;
	}

next_try:
	cch = GetProfileSection(szFontSubSection, _pchFontSubInfo, cchBuffer);
	if(cch >= cchBuffer - 2)	// GetProfileSection() magic number 2
	{							
		// didn't fit, double the buffer size
		const INT cchT = cchBuffer * 2;

		if(cchT < cchBuffer)	// >32k 
		{
			goto Cleanup;
		}
		cchBuffer = cchT;
		_pchFontSubInfo = (TCHAR *)PvReAlloc(_pchFontSubInfo, cchT * sizeof(TCHAR));
		if(!_pchFontSubInfo)
		{
			goto Cleanup;
		}
		goto next_try;
	}
	else if(!cch)
	{
		*_pchFontSubInfo = 0;
	}
	else //Fits, now resize _pchFontSubInfo
	{
		_pchFontSubInfo = (WCHAR*) PvReAlloc(_pchFontSubInfo, (cch) * sizeof(WCHAR));
	}

	_ctfi = 12;		// a preliminary guess

	_rgtfi = (TFI *)PvAlloc(_ctfi * sizeof(TFI), GMEM_FIXED);
	if(!_rgtfi)
	{
		goto Cleanup;
	}

	TFI *ptfi;
	TCHAR *pchT;

	pchT = _pchFontSubInfo;
	pchTMax = _pchFontSubInfo + cch;
	ptfi = &_rgtfi[0];

	TCHAR *szTaggedName;
	TCHAR *szNonTaggedName;
	BOOL fGotTaggedCharSet;
	BOOL fGotNonTaggedCharSet;
	BYTE bTaggedCharSet;
	BYTE bNonTaggedCharSet;
	PARSEFONTNAME iParseLeft;
	PARSEFONTNAME iParseRight;

	// parse the entries
	// we are interested in the following strings:
	//
	// <tagged font name> = <nontagged font name>
	//		(where <nontagged font name> = <tagged font name> - <tag>
	// <font1 name>,<font1 charset> = <font2 name>
	// <tagged font name> = <nontagged font name>,<nontagged font charset>
	//		(where <nontagged font charset> = <tag>)
	// <font1 name>,<font1 charset> = <font2 name>,<font2 charset>
	//		(where <font1 charset> == <font2 charset>)

	iParseLeft = iParseRight = PFN_SUCCESS;

	while(pchT < pchTMax && iParseLeft != PFN_EOF
						&& iParseRight != PFN_EOF)
	{
		fGotTaggedCharSet = FALSE;
		fGotNonTaggedCharSet = FALSE;

		if((iParseLeft = ParseFontName(pchT,
						pchTMax,
						TEXT('='),
						&szTaggedName, 
						bTaggedCharSet, 
						fGotTaggedCharSet, 
						&pchT)) == PFN_SUCCESS &&
			(iParseRight = ParseFontName(pchT, 
						pchTMax,
						TEXT('\0'),
						&szNonTaggedName, 
						bNonTaggedCharSet, 
						fGotNonTaggedCharSet, 
						&pchT)) == PFN_SUCCESS)
		{
			Assert(szTaggedName && szNonTaggedName);

			BYTE bCharSet;

			if(!fGotTaggedCharSet)
			{
				if(!FontSubstitute(szTaggedName, szNonTaggedName, &bCharSet))
				{
					continue;
				}
			}
			else
			{
				bCharSet = bTaggedCharSet;
			}

			if(fGotNonTaggedCharSet && bCharSet != bNonTaggedCharSet)
			{
				continue;
			}
					
			// We have a legitimate tagged/nontagged pair, so save it.
			ptfi->szTaggedName = szTaggedName;
			ptfi->szNormalName = szNonTaggedName;
			ptfi->bCharSet = bCharSet;

			ptfi++;

    		if(DiffPtrs(ptfi, &_rgtfi[0]) >= (UINT)_ctfi)
			{
				// allocate some more
				_rgtfi = (TFI *)PvReAlloc(_rgtfi, (_ctfi + cszcs) * sizeof(TFI));
				if(!_rgtfi)
				{
					goto Cleanup;
				}
				ptfi = _rgtfi + _ctfi;
				_ctfi += cszcs;	
			}
		}
	}				
	
	_ctfi = DiffPtrs(ptfi, &_rgtfi[0]);

	if (!_ctfi)
	{
		goto Cleanup;  // to cleanup alloc'd memory
	}
	return;

Cleanup:
	if(_pchFontSubInfo)
	{
		FreePv(_pchFontSubInfo);
		_pchFontSubInfo = NULL;
	}
	if(_rgtfi)
	{
		FreePv(_rgtfi);
		_rgtfi = NULL;
	}
	_ctfi = 0;
	return;
#endif // NOFONTSUBINFO
}


/*
 *		CRTFConverter::ParseFontName(pchBuf, pchBufMax, pszName, bCharSet, fSetCharSet, ppchBufNew, chDelimiter)
 *
 *		Purpose:
 *			Parses from the input buffer, pchBuf, a string of the form:
 *				{WS}*<font_name>{WS}*[,{WS}*<char_set>{WS}*]
 *			and sets:
 *				pszName = <font_name>
 *				bCharSet = <char_set>
 *				fSetCharSet = (bCharSet set by proc) ? TRUE : FALSE
 *				ppchBufNew = pointer to point in pchBuf after parsed font name
 *
 *		Returns:
 *			BOOL  TRUE	if OK		
 */
CRTFConverter::PARSEFONTNAME CRTFConverter::ParseFontName(TCHAR *pchBuf,	//@parm IN: buffer
								TCHAR *pchBufMax,	//@parm IN: last char in buffer
								TCHAR chDelimiter,	//@parm IN:	char which delimits font name
								TCHAR **pszName,	//@parm OUT: parsed font name
								BYTE &bCharSet,		//@parm OUT: parsed char set
								BOOL &fSetCharSet,	//@parm OUT: char set parsed?
								TCHAR **ppchBufNew	//@parm OUT: ptr to next font name in input buffer
								) const
{
	PARSEFONTNAME iRet = PFN_SUCCESS;

	Assert(pchBuf);
	Assert(pchBufMax);
	Assert(pchBufMax >= pchBuf);
	Assert(pszName);
	Assert(ppchBufNew);

	fSetCharSet = FALSE;
	*pszName = pchBuf;
	
	if(pchBuf > pchBufMax)
	{
		return PFN_EOF;
	}

	while(*pchBuf && *pchBuf != TEXT(',') && *pchBuf != chDelimiter)
	{
		pchBuf++;

		if(pchBuf > pchBufMax)
		{
			return PFN_EOF;
		}
	}

	TCHAR chTemp = *pchBuf;
	*pchBuf = TEXT('\0');
	RemoveAdditionalSpace(*pszName);

	if(chTemp == TEXT(','))
	{
		TCHAR *szCharSet = ++pchBuf;

		while(*pchBuf && *pchBuf != chDelimiter)
		{
			pchBuf++;

			if(pchBuf > pchBufMax)
			{
				return PFN_EOF;
			}
		}

		chTemp = *pchBuf;

		if(chTemp != chDelimiter)
		{
			goto UnexpectedChar;
		}

		*pchBuf = TEXT('\0');
		RemoveAdditionalSpace(szCharSet);

		bCharSet = 0;
		while(*szCharSet >= TEXT('0') && *szCharSet <= TEXT('9'))
		{
			bCharSet *= 10;
			bCharSet += *szCharSet++ - TEXT('0');
		}

		fSetCharSet = TRUE;
		// iRet = PFN_SUCCESS;	(done above)
	}
	else if(chTemp == chDelimiter)
	{
		// fSetCharSet = FALSE;	(done above)
		// iRet = PFN_SUCCESS;	(done above)
	}
	else // chTemp == 0
	{
UnexpectedChar:
		Assert(!chTemp);
		// fSetCharSet = FALSE; (done above)
		iRet = PFN_FAIL;
	}

	// we had to at least get a font name out of this
	if(!**pszName)
	{
		iRet = PFN_FAIL;
	}

	// advance past the delimiter (or NULL char if malformed buffer)
	Assert(chTemp == chDelimiter || iRet != PFN_SUCCESS && chTemp == TEXT('\0'));
	pchBuf++;
	*ppchBufNew = pchBuf;

	return iRet;
}


/*
 *		CRTFConverter::FontSubstitute(szTaggedName, szNormalName, pbCharSet)
 *
 *		Purpose:
 *			Verify that szTaggedName is szNormalName plus char set tag 
 *			If yes than write corresponding charSet tp pbCharSet
 *
 * 		Arguments:														 
 *			szTaggedName    name with tag
 *			szNormalName	name without tag
 *			pbcharSEt		where to write char set
 *
 *		Returns:
 *			BOOL			
 */
BOOL CRTFConverter::FontSubstitute(TCHAR *szTaggedName, TCHAR *szNormalName, BYTE *pbCharSet)
{
	const NTCSENTRY *pszcs = mpszcs;

	Assert(szTaggedName);
	Assert(szNormalName);
	Assert(pbCharSet);
	Assert(*szTaggedName);
	// ensure same name, except for prefix

	while(*szNormalName == *szTaggedName)
	{
		*szNormalName++;
		*szTaggedName++;
	}
	
	// verify that we have reached the end of szNormalName
	while(*szNormalName)
	{
		if(*szNormalName != TEXT(' ') && *szNormalName != TAB)
		{
			return FALSE;
		}

		szNormalName++;
	}

	szTaggedName++;

	while(pszcs->bCharSet)
	{
		if(!lstrcmpi(szTaggedName, pszcs->szLocaleName))
		{ 
			*pbCharSet=pszcs->bCharSet;
			return TRUE;
		}
		pszcs++;
	}

#if defined(DEBUG) && !defined(PEGASUS)
	char szBuf[MAX_PATH];
    char szTag[256];
	
	WideCharToMultiByte(CP_ACP, 0, szTaggedName, -1, szTag, sizeof(szTag), 
							NULL, NULL);

	sprintf(szBuf, "CRTFConverter::FontSubstitute():  Unrecognized tag found at"
					" end of tagged font name - \"%s\" (Raid this asap)", szTag);
	
	TRACEWARNSZ(szBuf);
#endif

	return FALSE;
}


/*
 *	CRTFConverter::FindTaggedFont(const char *szNormalName, BYTE bCharSet, char **ppchTaggedName)
 *
 *	Purpose:												   
 *		Find font name may be with additional special tag corresponding to szNormalName & bCharSet
 *
 *	Arguments:
 *		szNormalName	font name in RTF
 *		bCharSet 		RTF char set
 *		ppchTaggedName 	where to write tagged name
 *
 *	Returns:
 *		BOOL			TRUE if find
 */
BOOL CRTFConverter::FindTaggedFont(const TCHAR *szNormalName, BYTE bCharSet, TCHAR **ppchTaggedName)
{
	int itfi;

	if(!_rgtfi)
		return FALSE;

	for(itfi = 0; itfi < _ctfi; itfi++)
	{
		if(_rgtfi[itfi].bCharSet == bCharSet &&
			!lstrcmpi(szNormalName, _rgtfi[itfi].szNormalName))
		{
			*ppchTaggedName = _rgtfi[itfi].szTaggedName;
			return TRUE;
		}
	}

	return FALSE;
}


/*
 *	CRTFConverter::IsTaggedFont(const char *szName, BYTE *pbCharSet, char **ppchNormalName)
 *
 *	Purpose:												   
 *		Figure out is szName font name with additional tag corresponding to pbCharSet
 *		If no charset specified, still try to match	 and return the correct charset
 *
 *	Arguments:
 *		szNormalName	font name in RTF
 *		bCharSet 		RTF char set
 *		ppchNormalName 	where to write normal name
 *
 *	Returns:
 *		BOOL			TRUE if is
 */
BOOL CRTFConverter::IsTaggedFont(const TCHAR *szName, BYTE *pbCharSet, TCHAR **ppchNormalName)
{
	int itfi;

	if(!_rgtfi)
		return FALSE;

	for(itfi = 0; itfi < _ctfi; itfi++)
	{
		if((*pbCharSet <= 1 || _rgtfi[itfi].bCharSet == *pbCharSet) &&
			!lstrcmpi(szName, _rgtfi[itfi].szTaggedName))
		{
			*pbCharSet = _rgtfi[itfi].bCharSet;
			*ppchNormalName = _rgtfi[itfi].szNormalName;
			return TRUE;
		}
	}
	return FALSE;
}


/*
 *	CRTFWrite::WriteData(pbBuffer, cbBuffer)
 *
 *	Purpose:
 *		Write out object data. This must be called only after all
 *		initial object header information has been written out.
 *
 *	Arguments:
 *		pbBuffer		pointer to write buffer
 *		cbBuffer		number of bytes to write out
 *
 *	Returns:
 *		LONG			number of bytes written out
 */
LONG CRTFWrite::WriteData(BYTE * pbBuffer, LONG cbBuffer)
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WriteData");

	LONG	cb = 0;
	BYTE	bT;

	_fNeedDelimeter = FALSE; 
	while(cb < cbBuffer )
	{
		bT = *pbBuffer++;						// Put out hex value of byte
		PutChar(szHexDigits[bT >> 4]);			// Store high nibble
		PutChar(szHexDigits[bT & 15]);		// Store low nibble

		// Every 78 chars and at end of group, drop a line
		if (!(++cb % 39) || (cb == cbBuffer)) 
			Puts(szLineBreak, sizeof(szLineBreak) - 1);
	}
	return cb;
}

/*
 *	CRTFWrite::WriteBinData(pbBuffer, cbBuffer)
 *
 *	Purpose:
 *		Write out object binary data. This must be called only after all
 *		initial object header information has been written out.
 *
 *	Arguments:
 *		pbBuffer		pointer to write buffer
 *		cbBuffer		number of bytes to write out
 *
 *	Returns:
 *		LONG			number of bytes written out
 */
LONG CRTFWrite::WriteBinData(BYTE * pbBuffer, LONG cbBuffer)
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WriteData");

	LONG	cb = 0;
	BYTE	bT;

	_fNeedDelimeter = FALSE; 
	while(cb < cbBuffer )
	{
		bT = *pbBuffer++;
		if (!PutChar(bT))
			break;
		cb++;
	}
	return cb;
}

/*
 *	CRTFWrite::WriteRtfObject(prtfObject, fPicture)
 *
 *	Purpose:
 *		Writes out an picture or object header's render information
 *
 *	Arguments:
 *		prtfObject		The object header information
 *		fPicture		Is this a header for a picture or an object
 *
 *	Returns:
 *		EC				The error code
 *
 *	Comments:
 *		Eventually use keywords from rtf input list rather than partially
 *		creating them on the fly
 */
EC CRTFWrite::WriteRtfObject(RTFOBJECT & rtfObject, BOOL fPicture)
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WriteRtfObject");

	LONG			i;
	LONG *			pDim;
	const BYTE *	pKeyWordIndex;

	if(fPicture)
	{
		pKeyWordIndex = PictureKeyWordIndexes;
		pDim = &rtfObject.xExtPict;
	}
	else
	{
		pKeyWordIndex = ObjectKeyWordIndexes; 
		pDim = &rtfObject.xExt;

	}


	//Extents
	for(i = 2; i--; pDim++, pKeyWordIndex++)
	{
		if (*pDim )
			PutCtrlWord(CWF_VAL, *pKeyWordIndex, (SHORT)*pDim);
	}

	// Scaling
	pDim = &rtfObject.xScale;
	for(i = 2; i--; pDim++, pKeyWordIndex++)
	{
		if (*pDim && *pDim != 100 )
			PutCtrlWord(CWF_VAL, *pKeyWordIndex, (SHORT)*pDim);
	}
	// Cropping
	pDim = &rtfObject.rectCrop.left;
	for(i = 4; i--; pDim++, pKeyWordIndex++)
	{
		if (*pDim )
		   	PutCtrlWord(CWF_VAL, *pKeyWordIndex, (SHORT)*pDim);
	}

	return _ecParseError;
}

/*
 *	CRTFWrite::WritePicture(REOBJECT &reObject,RTFOBJECT & rtfObject)
 *
 *	Purpose:
 *		Writes out an picture's header as well as the object's data.
 *
 *	Arguments:
 *		reObject		Information from GetObject
 *		prtfObject		The object header information
 *
 *	Returns:
 *			EC			The error code
 *
 *	Note:
 *		*** Writes only metafiles ***
 */
EC CRTFWrite::WritePicture(REOBJECT &reObject,RTFOBJECT & rtfObject)
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WritePicture");

	_ecParseError = ecStreamOutObj;

	// Start and write picture group
	PutCtrlWord( CWF_GRP, i_pict );

	// Write that this is metafile 
	PutCtrlWord( CWF_VAL, i_wmetafile, rtfObject.sPictureType );

	// Write picture render details
	WriteRtfObject( rtfObject, TRUE );

	// Write goal sizes
	if (rtfObject.xExtGoal )
		PutCtrlWord ( CWF_VAL, i_picwgoal, rtfObject.xExtGoal );

	if (rtfObject.yExtGoal )
		PutCtrlWord (CWF_VAL, i_pichgoal, rtfObject.yExtGoal);

	// Start picture data
	Puts( szLineBreak, sizeof(szLineBreak) - 1 );

	// Write out the data
	if ((UINT) WriteData( rtfObject.pbResult, rtfObject.cbResult ) != rtfObject.cbResult)
	{
	   goto CleanUp;
	}

	_ecParseError = ecNoError;

CleanUp:
	PutChar( chEndGroup );					// End picture data

	return _ecParseError;
}

/*
 *	CRTFWrite::WriteDib(REOBJECT &reObject,RTFOBJECT & rtfObject)
 *
 *	Purpose:
 *		Writes out an DIB primarily for Win CE
 *
 *	Arguments:
 *		reObject		Information from GetObject
 *		prtfObject		The object header information
 *
 *	Returns:
 *			EC			The error code
 *
 *	Note:
 *		*** Writes only dibs ***
 */
EC CRTFWrite::WriteDib(REOBJECT &reObject,RTFOBJECT & rtfObject)
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WritePicture");

	LPBITMAPINFO pbmi = (LPBITMAPINFO) rtfObject.pbResult;

	_ecParseError = ecStreamOutObj;

// ************** V-GUYB: Add this for converting pictures to 2bpp during stream out.

    // Store the original values so we can restore them on exit.
	LPBYTE  pbResult = rtfObject.pbResult;
	ULONG   cbResult = rtfObject.cbResult;
    HGLOBAL hMem2bpp = 0;

#if defined(CONVERT2BPP) 

    // Pictures must be saved as 2bpp if saving to PWord V1 format.
	if((_dwFlags & SFF_PWD) && ((_dwFlags & SFF_RTFVAL) >> 16 == 0))
    {
        if(pbmi->bmiHeader.biBitCount > PWDV1_BPP)
        {
            HWND         hWnd;
            HDC          hdc, hdcSrc, hdcDst;
            HBITMAP      hdibSrc, hdibDst; 
            LPBYTE       pbDibSrc, pbDibDst;
            BMI2BPP      bmi2bpp = {0};
            int          iOffset, nBytes;

            // First get a dc with the source dib in it.
            hWnd   = GetDesktopWindow();
            hdc    = GetDC(hWnd);
	        hdcSrc = CreateCompatibleDC(hdc);

            // Using CreateDIBSection below ensures that the working dibs and dcs will get a
            // bpp of the appropriate dib, not a bpp based on the bpp of the device display.
            if((hdibSrc = CreateDIBSection(hdcSrc, pbmi, DIB_RGB_COLORS, (void**)&pbDibSrc, NULL, 0)))
            {
                SelectObject(hdcSrc, hdibSrc);

                // Get an offset to the source bits.
                iOffset = sizeof(BITMAPINFOHEADER) + (sizeof(RGBQUAD) * (1<<pbmi->bmiHeader.biBitCount));
                memcpy(pbDibSrc, &rtfObject.pbResult[iOffset], rtfObject.cbResult - iOffset);

                // Now, build up a BITMAPINFO appropriate for a 2bpp dib.
                bmi2bpp.bmih = pbmi->bmiHeader;
                bmi2bpp.bmih.biBitCount = PWDV1_BPP;

                // Add the 4 color color-table.
                memcpy(bmi2bpp.colors, (RGBQUAD*)ColorTable2bpp, (1<<PWDV1_BPP) * sizeof(RGBQUAD));

                // Now create the new dib.
    	        hdcDst = CreateCompatibleDC(hdc);

            	if((hdibDst = CreateDIBSection(hdcDst, (BITMAPINFO*)&bmi2bpp, DIB_RGB_COLORS, (void**)&pbDibDst, NULL, 0)))
                {
                    SelectObject(hdcDst, hdibDst);

                    // Blit the > 2bpp dib into the 2bpp dib and let the system do the color mapping.
                    BitBlt(hdcDst, 0, 0, bmi2bpp.bmih.biWidth, bmi2bpp.bmih.biHeight, hdcSrc, 0, 0, SRCCOPY);

                    // Calculate the new bytes per line for the 2bpp dib.
                    rtfObject.cBytesPerLine = (((bmi2bpp.bmih.biWidth * PWDV1_BPP) + 31) & ~31) / 8; // DWORD boundary.

                    // Get the new size of the 2bpp byte array.
                    nBytes = rtfObject.cBytesPerLine * bmi2bpp.bmih.biHeight;

                    // Get total size of 2bpp dib, (including header and 4 color color-table).
                    cbResult = sizeof(bmi2bpp) + nBytes;

                    // Don't change the input pbResult as that is the internal representation of 
                    // the dib. This conversion to 2bpp is only for writing to the output file.
                    if((hMem2bpp = GlobalAlloc(GMEM_FIXED, cbResult)))
                    {
                        if((pbResult = (LPBYTE)GlobalLock(hMem2bpp)))
                        {
                            // Copy in the dib header.
                            memcpy(pbResult, &bmi2bpp.bmih, sizeof(BITMAPINFOHEADER));

                            // Copy in the 4 color color-table.
                            memcpy(&pbResult[sizeof(BITMAPINFOHEADER)], (RGBQUAD*)ColorTable2bpp, (1<<PWDV1_BPP) * sizeof(RGBQUAD));

                            // Now copy in the byte array.
                            memcpy(&pbResult[sizeof(bmi2bpp)], pbDibDst, nBytes);

                    	    _ecParseError = ecNoError;
                        }
                    }

                    DeleteObject(hdibDst);
                }

                DeleteDC(hdcDst);

                DeleteObject(hdibSrc);
            }

            DeleteDC(hdcSrc);
            ReleaseDC(hWnd, hdc);

            if(_ecParseError != ecNoError)
            {
                goto CleanUp;
            }
        }
    }
#endif // CONVERT2BPP
// ************** V-GUYB: End of conversion stuff.

	// Start and write picture group
	PutCtrlWord( CWF_GRP, i_pict );

	// Write that this is dib 
	PutCtrlWord( CWF_VAL, i_dibitmap,rtfObject.sPictureType );

	// V-GUYB:
    // rtfObject.*Scale is not updated as the user stretches the picture, 
    // so don't use those here. But rtfObject.*Ext has been set up in the 
    // calling routine to account for the current site dimensions.
	PutCtrlWord( CWF_VAL, i_picscalex, (rtfObject.xExt * 100) /  rtfObject.xExtGoal);
	PutCtrlWord( CWF_VAL, i_picscaley, (rtfObject.yExt * 100) /  rtfObject.yExtGoal);

	// Write picture render details
	PutCtrlWord( CWF_VAL, i_picw, pbmi->bmiHeader.biWidth );
	PutCtrlWord( CWF_VAL, i_pich, pbmi->bmiHeader.biHeight );
	PutCtrlWord( CWF_VAL, i_picwgoal, rtfObject.xExtGoal );
	PutCtrlWord( CWF_VAL, i_pichgoal, rtfObject.yExtGoal );
	PutCtrlWord( CWF_VAL, i_wbmbitspixel, pbmi->bmiHeader.biBitCount );
	PutCtrlWord( CWF_VAL, i_wbmplanes, pbmi->bmiHeader.biPlanes );
	PutCtrlWord( CWF_VAL, i_wbmwidthbytes, rtfObject.cBytesPerLine );

	// Write out the data
	PutCtrlWord( CWF_VAL, i_bin, cbResult );
	if ((UINT) WriteBinData( pbResult, cbResult ) != cbResult)
	{
		// This "recovery" action needs to be rethought.  There is no way
		// the reader will be able to get back in synch.
	   goto CleanUp;
	}

	_ecParseError = ecNoError;

CleanUp:

    // Did we lock or allocate some temporary space for a 2bpp dib?
    if(rtfObject.pbResult != pbResult)
    {
        // Yes, so unlock it now.
        GlobalUnlock(pbResult);
    }

    if(hMem2bpp)
    {
        GlobalFree(hMem2bpp);
    }

    // Restore original values.
  	rtfObject.pbResult = pbResult;
    rtfObject.cbResult = cbResult;

	PutChar(chEndGroup);					// End picture data

	return _ecParseError;
}

/*
 *	CRTFWrite::WriteObject(LONG cp)
 *
 *	Purpose:
 *		Writes out an object's header as well as the object's data.
 *
 *	Arguments:
 *		cp				The object position
 *
 *	Returns:
 *		EC				The error code
 */
EC CRTFWrite::WriteObject(LONG cp, COleObject *pobj)
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WriteObject");

	RTFOBJECT		rtfObject;
	REOBJECT        reObject = { 0} ;

	Assert(pobj);

	reObject.cbStruct = sizeof (REOBJECT) ;
	reObject.cp = cp;

	if (pobj->GetObjectData(&reObject, REO_GETOBJ_POLESITE 
						| REO_GETOBJ_PSTG | REO_GETOBJ_POLEOBJ))	// todo fix Release
	{
		TRACEERRORSZ("Error geting object ");
	}

	GetRtfObject(reObject, rtfObject);

	HGLOBAL hdata = pobj->GetHdata();
	if (hdata)
	{
		COleObject::ImageInfo *pimageinfo = pobj->GetImageInfo();
		rtfObject.pbResult = (LPBYTE) GlobalLock( hdata );
		rtfObject.cbResult = GlobalSize( hdata );
		rtfObject.sType = ROT_DIB;
		rtfObject.xExt = (SHORT) TwipsFromHimetric( reObject.sizel.cx );
		rtfObject.yExt = (SHORT) TwipsFromHimetric( reObject.sizel.cy );
		rtfObject.xScale = pimageinfo->xScale;
		rtfObject.yScale = pimageinfo->yScale;
		rtfObject.xExtGoal = pimageinfo->xExtGoal;
		rtfObject.yExtGoal = pimageinfo->yExtGoal;
		rtfObject.cBytesPerLine = pimageinfo->cBytesPerLine;
		WriteDib( reObject, rtfObject );
		GlobalUnlock( rtfObject.pbResult );

		// Make sure to release otherwise the object won't go away
		if (reObject.pstg)	reObject.pstg->Release();
		if (reObject.polesite) reObject.polesite->Release();
		if (reObject.poleobj) reObject.poleobj->Release();

		return _ecParseError;
	}

	switch(rtfObject.sType)				// Handle pictures in our own
	{										//  special way
	case ROT_Embedded:
	case ROT_Link:
	case ROT_AutoLink:
		break;

	case ROT_Metafile:
	case ROT_DIB:
	case ROT_Bitmap:
		 WritePicture( reObject, rtfObject );
		 goto CleanUpNoEndGroup; 

#ifdef DEBUG
	default:
		AssertSz(FALSE, "CRTFW::WriteObject: Unknown ROT");
		break;
#endif DEBUG
	}

	// Start and write object group
	PutCtrlWord( CWF_GRP, i_object );
	PutCtrlWord( CWF_STR, IndexROT[rtfObject.sType] );
//	PutCtrlWord(CWF_STR, i_objupdate);  // TODO may be it needs more smart decision 

	if (rtfObject.szClass)  		// Write object class
	{
		PutCtrlWord( CWF_AST, i_objclass ); 
		WritePcData( rtfObject.szClass );
		PutChar( chEndGroup );
	}

	if (rtfObject.szName)			// Write object name
	{
		PutCtrlWord( CWF_AST, i_objname ); 
		WritePcData( rtfObject.szName );
		PutChar( chEndGroup );
	}

	if (rtfObject.fSetSize)		// Write object sizing
	{								//  options
		PutCtrlWord( CWF_STR, i_objsetsize );
	}

	WriteRtfObject( rtfObject, FALSE ) ;				// Write object render info
	PutCtrlWord( CWF_AST, i_objdata ) ;				//  info, start object
	Puts( szLineBreak, sizeof(szLineBreak) - 1);		//  data group

	if (!ObjectWriteToEditstream( reObject, rtfObject ))
	{
		TRACEERRORSZ("Error writing object data");
		if (!_ecParseError)
			_ecParseError = ecStreamOutObj;
		PutChar( chEndGroup );						// End object data
		goto CleanUp;
	}

	PutChar( chEndGroup );							// End object data

	PutCtrlWord( CWF_GRP, i_result );				// Start results group
	WritePicture( reObject,rtfObject ); 				// Write results group
	PutChar( chEndGroup ); 							// End results group

CleanUp:
	PutChar( chEndGroup );						    // End object group

CleanUpNoEndGroup:
	if (reObject.pstg)	reObject.pstg->Release();
	if (reObject.polesite) reObject.polesite->Release();
	if (reObject.poleobj) reObject.poleobj->Release();
	if (rtfObject.pbResult)
	{
		HGLOBAL hmem;

		hmem = GlobalHandle( rtfObject.pbResult );
		GlobalUnlock( hmem );
		GlobalFree( hmem );
	}
	if (rtfObject.szClass)
	{
		CoTaskMemFree( rtfObject.szClass );
	}

	return _ecParseError;
}

/*
 *	GetRtfObjectMetafilePict
 *
 *	@mfunc
 *		Gets information about an metafile into a structure.
 *
 *		Arguments:
 *			HGLOBAL		The object data
 *			RTFOBJECT 	Where to put the information.
 *
 *	@rdesc
 *		BOOL		TRUE on success, FALSE if object cannot be written to RTF.
 */
BOOL CRTFWrite::GetRtfObjectMetafilePict(HGLOBAL hmfp, RTFOBJECT &rtfobject, SIZEL &sizelGoal)
{
#ifndef NOMETAFILES
	BOOL fSuccess = FALSE;
	LPMETAFILEPICT pmfp = (LPMETAFILEPICT)GlobalLock(hmfp);
	HGLOBAL	hmem = NULL;
	ULONG cb;

	if (!pmfp)
		goto Cleanup;

	// Build the header
	rtfobject.sPictureType = (SHORT) pmfp->mm;
	rtfobject.xExtPict = (SHORT) pmfp->xExt;
	rtfobject.yExtPict = (SHORT) pmfp->yExt;
	rtfobject.xExtGoal = (SHORT) TwipsFromHimetric(sizelGoal.cx);
	rtfobject.yExtGoal = (SHORT) TwipsFromHimetric(sizelGoal.cy);

	// Find out how much room we'll need
	cb = GetMetaFileBitsEx(pmfp->hMF, 0, NULL);
	if (!cb)
		goto Cleanup;

	// Allocate that space
    hmem = GlobalAlloc(GHND, cb);
	if (!hmem)
		goto Cleanup;

	rtfobject.pbResult = (LPBYTE)GlobalLock(hmem);
	if (!rtfobject.pbResult)
	{
		GlobalFree(hmem);
		goto Cleanup;
	}

	// Get the data
	rtfobject.cbResult = (ULONG) GetMetaFileBitsEx(pmfp->hMF, (UINT) cb,
													rtfobject.pbResult);
	if (rtfobject.cbResult != cb)
	{
		rtfobject.pbResult = NULL;
		GlobalFree(hmem);
		goto Cleanup;
	}
	fSuccess = TRUE;

Cleanup:
	GlobalUnlock(hmfp);
	return fSuccess;
#else
	return FALSE;
#endif
}

/*
 *	GetRtfObject (REOBJECT &reobject, RTFOBJECT &rtfobject)
 *
 *	Purpose:			   
 *		Gets information about an RTF object into a structure.
 *
 *	Arguments:
 *		REOBJECT  	Information from GetObject
 *		RTFOBJECT 	Where to put the information. Strings are read only and
 *					are owned by the object subsystem, not the caller.
 *
 *	Returns:
 *		BOOL		TRUE on success, FALSE if object cannot be written to RTF.
 */
BOOL CRTFWrite::GetRtfObject(REOBJECT &reobject, RTFOBJECT &rtfobject)
{
	BOOL fSuccess = FALSE;
	BOOL fNoOleServer = FALSE;
	const BOOL fStatic = !!(reobject.dwFlags & REO_STATIC);
	SIZEL sizelObj = reobject.sizel;
	//COMPATIBILITY:  RICHED10 code had a frame size.  Do we need something similiar.
	LPTSTR szProgId;

	// Blank out the full structure
	ZeroMemory(&rtfobject, sizeof(RTFOBJECT));

	// If the object has no storage it cannot be written.
	if (!reobject.pstg)
		return FALSE;

	// If we don't have the progID for a real OLE object, get it now
	if (!fStatic )
	{
		rtfobject.szClass = NULL;
		// We need a ProgID to put into the RTF stream.
		//$ REVIEW: MAC This call is incorrect for the Mac.  It may not matter though
		//          if ole support in RichEdit is not needed for the Mac.
		if (ProgIDFromCLSID(reobject.clsid, &szProgId))
			fNoOleServer = TRUE;
		else
			rtfobject.szClass = szProgId;
	}

#ifndef NOMETAFILES
	HGLOBAL hmfp = OleStdGetMetafilePictFromOleObject(reobject.poleobj,
										reobject.dvaspect, &sizelObj, NULL);
	if (hmfp)
	{
		LPMETAFILEPICT pmfp = NULL;

		fSuccess = GetRtfObjectMetafilePict(hmfp, rtfobject, sizelObj);
		if (pmfp = (LPMETAFILEPICT)GlobalLock(hmfp))
		{
			if (pmfp->hMF)
				DeleteMetaFile(pmfp->hMF);
			GlobalUnlock(hmfp);
		}
		GlobalFree(hmfp);

		// If we don't have Server and we can't get metafile, forget it.
		if (!fSuccess && fNoOleServer)
			return fSuccess;
	}
#endif

	if (!fStatic)
	{
		// Fill in specific fields
		rtfobject.sType = fNoOleServer ? ROT_Metafile : ROT_Embedded;	//$ FUTURE: set for links
		rtfobject.xExt = (SHORT) TwipsFromHimetric(sizelObj.cx);
		rtfobject.yExt = (SHORT) TwipsFromHimetric(sizelObj.cy);

		// fSuccess set even if we couldn't retreive a metafile
		// because we don't need a metafile in the non-static case,
		// it's just nice to have one
		fSuccess = TRUE;
	}
	rtfobject.fSetSize = 0;			//$ REVIEW: Hmmm
	return fSuccess;
}

/*
 *	ObjectWriteToEditstream
 *
 *	Purpose:
 *		Writes an OLE object data to the RTF output stream.
 *
 *	Arguments:
 *		REOBJECT	Information from GetObject
 *		RTFOBJECT 	Where to get icon data.
 *
 *	Returns:
 *		BOOL		TRUE on success, FALSE on failure.
 */
BOOL CRTFWrite::ObjectWriteToEditstream(REOBJECT &reObject, RTFOBJECT &rtfobject)
{
	HRESULT hr = 0;

	// Force the object to update its storage				  //// ????
	// Not necessary.  Already done in WriteRtf
	// reObject.polesite->SaveObject();

	// If the object is iconic we do some special magic
	if (reObject.dvaspect == DVASPECT_ICON)
	{
		HANDLE	hGlobal;
		STGMEDIUM med;

		// Force the presentation to be the iconic view.
		med.tymed = TYMED_HGLOBAL;
		hGlobal = GlobalHandle(rtfobject.pbResult);
		med.hGlobal = hGlobal;
		hr = OleConvertIStorageToOLESTREAMEx(reObject.pstg,
											CF_METAFILEPICT,
											rtfobject.xExtPict,
											rtfobject.yExtPict,
											rtfobject.cbResult, &med,
											(LPOLESTREAM) &RTFWriteOLEStream);
	}
	else
	{
		// Do the standard conversion
		hr = OleConvertIStorageToOLESTREAM(reObject.pstg, (LPOLESTREAM) &RTFWriteOLEStream);
	}
	return SUCCEEDED(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\textsrv2.h ===
/*	@doc EXTERNAL
 *
 *	@module TEXTSRV2.H  Text Service Interface |
 *	
 *	Define new private interface between the Text Services component and the host
 *
 *	History: <nl>
 *		8/1/95	ricksa	Revised interface definition
 *      7/9/99  joseogl Split off from textserv,h because ITextHost2 is undocumented
 */

#ifndef _TEXTSRV2_H
#define _TEXTSRV2_H

EXTERN_C const IID IID_ITextHost2;

/*
 *	class ITextHost2
 *
 *	@class	An optional extension to ITextHost which provides functionality
 *			necessary to allow TextServices to embed OLE objects
 */
class ITextHost2 : public ITextHost
{
public:					//@cmember Is a double click in the message queue?
	virtual BOOL		TxIsDoubleClickPending() = 0; 
						//@cmember Get the overall window for this control	 
	virtual HRESULT		TxGetWindow(HWND *phwnd) = 0;
						//@cmember Set control window to foreground
	virtual HRESULT		TxSetForegroundWindow() = 0;
						//@cmember Set control window to foreground
	virtual HPALETTE	TxGetPalette() = 0;
						//@cmember Get FE flags
	virtual HRESULT		TxGetFEFlags(LONG *pFlags) = 0;
						//@cmember Routes the cursor change to the winhost
	virtual HCURSOR		TxSetCursor2(HCURSOR hcur, BOOL bText) = 0;
						//@cmember Notification that text services is freed
	virtual void		TxFreeTextServicesNotification() = 0;
						//@cmember Get Edit Style flags
	virtual HRESULT		TxGetEditStyle(DWORD dwItem, DWORD *pdwData) = 0;
						//@cmember Get Window Style bits
	virtual HRESULT		TxGetWindowStyles(DWORD *pdwStyle, DWORD *pdwExStyle) = 0;
};

// Various flags for TxGetEditStyle data
#define TXES_ISDIALOG		1
#endif // _TEXTSRV2_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\runptr.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module RUNPTR.C -- Text run and run pointer class |
 *	
 *	Original Authors: <nl>
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 *
 *	History: <nl>
 *		6/25/95	alexgo	Commented and Cleaned up.
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_runptr.h"
#include "_text.h"

ASSERTDATA

//
//	Invariant stuff
//
#define DEBUG_CLASSNAME	CRunPtrBase

#include "_invar.h"

// ===========================  CRunPtrBase class  ==================================================

#ifdef DEBUG
/*
 *	CRunPtrBase::Invariant()
 *
 *	@mfunc
 *		Debug-only function that validates the internal state consistency
 *		for CRunPtrBase
 *
 *	@rdesc
 *		TRUE always (failures assert)
 */
BOOL CRunPtrBase::Invariant() const
{
	if(!IsValid())
	{
		Assert(_iRun == 0 && _ich >= 0);		// CLinePtr can have _ich > 0
	}
	else
	{
		Assert(_iRun < _pRuns->Count());
		LONG cch = _pRuns->Elem(_iRun)->_cch;
		Assert((DWORD)_ich <= (DWORD)cch);
	}
	return TRUE;
}

/*
 *	CRunPtrBase::ValidatePtr(pRun)
 *
 *	@mfunc
 *		Debug-only validation method that asserts if pRun doesn't point
 *		to a valid text run
 */
void CRunPtrBase::ValidatePtr(void *pRun) const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::ValidatePtr");

	AssertSz(IsValid() && pRun >= _pRuns->Elem(0) &&
			 pRun <= _pRuns->Elem(Count() - 1),
		"CRunPtr::ValidatePtr: illegal ptr");
}

/*
 *	CRunPtrBase::CalcTextLength()
 *
 *	@mfunc
 *		Calculate length of text by summing text runs accessible by this
 *		run ptr
 *
 *	@rdesc
 *		length of text so calculated, or -1 if failed
 */
LONG CRunPtrBase::CalcTextLength() const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::CalcTextLength");
    AssertSz(_pRuns,
		"CTxtPtr::CalcTextLength() - Invalid operation on single run CRunPtr");

	LONG i = Count();
	if(!i)
		return 0;

	LONG	 cb = _pRuns->Size();
	LONG	 cchText = 0;
	CTxtRun *pRun = _pRuns->Elem(0);

	while(i--)
	{
		cchText += pRun->_cch;
		pRun = (CTxtRun *)((BYTE *)pRun + cb);
	}
	return cchText;
}

#endif

/*
 *	CRunPtrBase::GetCchLeft()
 *
 *	@mfunc
 *		Calculate count of chars left in run starting at current cp.
 *		Complements GetIch(), which	is length of text up to this cp. 
 *
 *	@rdesc
 *		Count of chars so calculated
 */
LONG CRunPtrBase::GetCchLeft() const	
{
	return GetRun(0)->_cch - GetIch();
}								

/*
 *	CRunPtrBase::CRunPtrBase(pRuns)
 *
 *	@mfunc		constructor
 */
CRunPtrBase::CRunPtrBase(
	CRunArray *pRuns)		//@parm	The Run array for the run ptr
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::CRunPtrBase");

	_pRuns = pRuns; 
	_iRun = 0; 
	_ich = 0; 

	//make sure everything has been initialized
	Assert(sizeof(CRunPtrBase) == (sizeof(_pRuns) + sizeof(_iRun) 
		+ sizeof(_ich)));
}

/*
 *	CRunPtrBase::CRunPtrBase(rp)
 *
 *	Copy Constructor
 */
CRunPtrBase::CRunPtrBase(
	CRunPtrBase& rp)			//@parm	Other run pointer to initialize from
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::CRunPtrBase");

	*this = rp;
}

/* 
 *	CRunPtrBase::SetRun(iRun, ich)
 *
 *	@mfunc
 *		Sets this run ptr to the given run.  If it does not
 *		exist, then we set ourselves to the closest valid run
 *
 *	@rdesc
 *		TRUE if moved to iRun
 */
BOOL CRunPtrBase::SetRun(
	LONG iRun,					//@parm Run index to use 
	LONG ich)					//@parm Char index within run to use
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::SetRun");

	_TEST_INVARIANT_

	BOOL	 bRet = TRUE;
	LONG	 count = Count();

	// Set the run

	if(!IsValid())						// No runs instantiated:
		return FALSE;					//  leave this rp alone

	if(iRun >= count)					// Validate iRun
	{
		bRet = FALSE;
		iRun = count - 1;				// If (!count), negative iRun 
	}									//  is handled by following if
	if(iRun < 0)
	{
		bRet = FALSE;
		iRun = 0;
	}
	_iRun = iRun;

	// Set the offset
	_ich = ich;
	CTxtRun *pRun = _pRuns->Elem(iRun);
	_ich = min(ich, pRun->_cch);

	return bRet;
}
												
/*
 *	CRunPtrBase::NextRun()
 *
 *	@mfunc
 *		Change this RunPtr to that for the next text run
 *
 *	@rdesc
 *		TRUE if succeeds, i.e., target run exists
 */
BOOL CRunPtrBase::NextRun()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::NextRun");

	_TEST_INVARIANT_

 	if(_pRuns && _iRun < Count() - 1)
	{
		++_iRun;
		_ich = 0;
		return TRUE;
	}
	return FALSE;
}

/*
 *	CRunPtrBase::PrevRun()
 *
 *	@mfunc
 *		Change this RunPtr to that for the previous text run
 *
 *	@rdesc
 *		TRUE if succeeds, i.e., target run exists
 */
BOOL CRunPtrBase::PrevRun()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::PrevRun");

	_TEST_INVARIANT_

	if(_pRuns)
	{
		_ich = 0;
		if(_iRun > 0)
		{
			_iRun--;
			return TRUE;
		}
	}
	return FALSE;
}

/*
 *	CRunPtrBase::GetRun(cRun)
 *
 *	@mfunc
 *		Get address of the TxtRun that is cRun runs away from the run
 *		pointed to by this RunPtr
 *
 *	@rdesc
 *		ptr to the CTxtRun cRun's away
 */
CTxtRun* CRunPtrBase::GetRun(
	LONG cRun) const	//@parm signed count of runs to reach target CTxtRun
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::GetRun");

	_TEST_INVARIANT_
	Assert(IsValid());						// Common problem...
	return _pRuns->Elem(_iRun + cRun);
}

/*
 *	CRunPtrBase::CalculateCp()
 *
 *	@mfunc
 *		Get cp of this RunPtr
 *
 *	@rdesc
 *		cp of this RunPtr
 *
 *	@devnote
 *		May be computationally expensive if there are many elements
 *		in the array (we have to run through them all to sum cch's.
 *		Used by TOM collections and Move commands, so needs to be fast.
 */
LONG CRunPtrBase::CalculateCp () const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::GetCp");

	_TEST_INVARIANT_

	Assert(IsValid());

	LONG cb = _pRuns->Size();
	LONG cp	 = _ich;			// Correct result if _iRun = 0
	LONG iRun = _iRun;

	if(!iRun)
		return cp;

	CTxtRun *pRun = GetRun(0);

	while(iRun--)
	{
		Assert(pRun);		
		pRun = (CTxtRun *)((BYTE *)pRun - cb);
		cp += pRun->_cch;
	}
	return cp;
}

/*
 *	CRunPtrBase::BindToCp(cp)
 *
 *	@mfunc
 *		Set this RunPtr to correspond to a cp.
 *
 *	@rdesc
 *		the cp actually set to
 */
LONG CRunPtrBase::BindToCp(
	LONG cp)			//@parm character position to move this RunPtr to
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::BindToCp");

	_iRun = 0;
	_ich = 0;
	return AdvanceCp(cp);
}

/*
 *	CRunPtrBase::AdvanceCp(cch)
 *
 *	@mfunc
 *		Advance this RunPtr by (signed) cch chars.  If it lands on the
 *		end of a run, it automatically goes to the start of the next run
 *		(if one exists). 
 *
 *	@rdesc
 *		Count of characters actually moved
 */
LONG CRunPtrBase::AdvanceCp(
	LONG cch)			//@parm signed count of chars to move this RunPtr by
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::AdvanceCp");

	if(!cch || !IsValid())
		return cch;

	LONG cchSave = cch;

	if(cch < 0)
		while(cch < 0)
		{
			if(-cch <= _ich)
			{
				_ich += cch;					// Target is in this run
				cch = 0;
				break;
			}
			// Otherwise, we need to go to previous run. First add count
			// of chars from start of current run to current postion.
			cch += _ich;
			if(_iRun <= 0)						// Already in first run
			{
				_iRun = 0;
				_ich = 0;						// Move to run beginning
				break;
			}
			_ich = _pRuns->Elem(--_iRun)->_cch;	// Move to previous run
		}
	else
	{
		LONG	 cchRun;
		CTxtRun *pRun = GetRun(0);

		while(cch > 0)							// Move forward
		{
			cchRun = pRun->_cch;
			_ich += cch;

			if(_ich < cchRun)					// Target is in this run
			{
				cch = 0;						// Signal countdown completed
				break;							// (if _ich = cchRun, go to
			}									//  next run)	

			cch = _ich - cchRun;				// Advance to next run
			if(++_iRun >= Count())				// Ran past end, back up to
			{									//  end of story
				--_iRun;
				Assert(_iRun == Count() - 1);
				Assert(_pRuns->Elem(_iRun)->_cch == cchRun);
				_ich = cchRun;
				break;
			}
			_ich = 0;							// Start at new BOL
			pRun = (CTxtRun *)((BYTE *)pRun + _pRuns->Size());
		}
	}

	// NB! we check the invariant at the end to handle the case where
	// we are updating the cp for a floating range (i.e., we know that
	// the cp is invalid, so we fix it up).  So we have to check for
	// validity *after* the fixup.
	_TEST_INVARIANT_

	return cchSave - cch;						// Return TRUE if countdown
}												// completed

/*
 *	CRunPtrBase::CountRuns(&cRun, cchMax, cp, cchText)
 *
 *	@mfunc
 *		Count characters up to <p cRun> runs away or <p cchMax> chars,
 *		whichever comes first. If the target run and <p cchMax> are both
 *		beyond the corresponding end of the document, count up thru the
 *		closest run (0 or Count() - 1).  The direction of counting is
 *		determined by the sign of <p cRun>.  To count without being limited
 *		by <p cchMax>, set it equal to tomForward. An initial partial
 *		run counts as a run, i.e., if cRun > 0 and _ich < cch in current
 *		run or if cRun < 0 and _ich > 0, that counts as a run.
 *
 *	@rdesc
 *		Return the signed cch counted and set <p cRun> equal to count of runs
 *		actually counted.  If no runs are allocated, the text is treated as
 *		a single run.  If <p cRun> = 0, -_ich is returned. If <p cRun> <gt> 0
 *		and this run ptr points to the end of the last run, no change is made
 *		and 0 is returned.
 *
 *	@devnote
 *		The maximum count capability is included to be able to count units in
 *		a range.  The <p tp> argument is needed for getting the text length
 *		when no runs exist and <p cRun> selects forward counting.
 */
LONG CRunPtrBase::CountRuns (
	LONG &	cRun,			//@parm Count of runs to get cch for
	LONG	cchMax,			//@parm Maximum char count
	LONG	cp,				//@parm CRchTxtPtr::GetCp()
	LONG	cchText) const	//@parm Text length of associated story
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::CountRuns");

	_TEST_INVARIANT_

	LONG cch;

	if(!cRun)								// Nothing to do
		return 0;

	// Simple special single-run case
	if(!IsValid())							// No runs instantiated: act as a
	{										//  single run
		if(cRun > 0)						// Count forward
		{
			cch	= cchText - cp;				// Partial count to end of run
			cRun = 1;						// No more than one run
		}
		else								// Count backward
		{
			cch = -cp;						// Partial count to start of run
			cRun = -1;						// No less than minus one run
		}			
		if(!cch)							// No partial run, so no runs
			cRun = 0;						//  counted
		return cch;
	}

	// General case for which runs are instantiated

	LONG		cb	 = _pRuns->Size();		// Size of text run element
	LONG		iDir;
	LONG		iRun = _iRun;				// Cache run index for current run
	LONG		j, k;						// Handy integers
	CTxtRun *	pRun = GetRun(0);			// Not NULL since runs exist

	if(cRun < 0)							// Try to count backward cRun runs
	{
		iDir = -1;
		cb	 = -cb;							// Byte count to previous element
		cch	 = _ich;						// Remaining cch in current run
		if(cch)								// If cch != 0, initial run counts
			cRun++;							//  as a run: 1 less for for loop
		cRun = max(cRun, -iRun);			// Don't let for loop overshoot
	}
	else
	{										// Try to count forward cRun runs 
		Assert(cRun > 0);
		iDir = 1;
		cch	 = pRun->_cch - _ich;			// Remaining cch in current run
		if(cch)								// If cch != 0, initial run counts
			cRun--;							//  as a run: 1 less for for loop
		k	 = Count() - iRun - 1;			// k = # runs following current run
		cRun = min(cRun, k);				// Don't let for loop overshoot
	}

	k	 = cch;								// Remember if initial cch != 0
	for(j = cRun; j && cch < cchMax; j -= iDir)
	{
		pRun = (CTxtRun *)((BYTE *)pRun + cb);	// Point at following run
		cch += pRun->_cch;					// Add in its count
	}
	if(k)									// Initial partial run counts as
		cRun += iDir;						//  a run
	cRun -= j;								// Discount any runs not counted
											//  if |cch| >= cchMax
	return iDir*cch;						// Return total cch bypassed
}

/*
 *	CRunPtrBase::FindRun (pcpMin, pcpMost, cpMin, cch)
 *
 *	@mfunc
 *		Set *<p pcpMin>  = closest run cpMin <lt>= range cpMin, and
 *		set *<p pcpMost> = closest run cpMost <gt>= range cpMost
 *
 *	@devnote
 *		This routine plays a role analogous to CTxtRange::FindParagraph
 *		(pcpMin, pcpMost), but needs extra arguments since this run ptr does
 *		not know the range cp's.  This run ptr is located at the range active
 *		end, which is determined by the range's signed length <p cch> in
 *		conjunction with <p cpMin>.
 */
void CRunPtrBase::FindRun (
	LONG *pcpMin,			//@parm Out parm for bounding-run cpMin
	LONG *pcpMost,			//@parm Out parm for bounding-run cpMost
	LONG cpMin,				//@parm Range cpMin
	LONG cch,				//@parm Range signed length
	LONG cchText) const		//@parm Story length
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::FindRun");

	if(!IsValid())
	{
		if(pcpMin)						// Run is whole story
			*pcpMin = 0;
		if(pcpMost)
			*pcpMost = cchText;
		return;
	}

	BOOL fAdvanceCp;					// Controls AdvanceCp for pcpMost
	CRunPtrBase rp((CRunPtrBase&)(*this));	// Clone this runptr to keep it const

	rp.AdjustForward();					// Select forward run
	if(pcpMin)
	{									// If cch != 0, rp is sure to end up
		fAdvanceCp = cch;				//  at cpMin, so pcpMost needs advance
		if(cch > 0)						// rp is at cpMost, so move it to
			rp.AdvanceCp(-cch);			//  cpMin
		*pcpMin = cpMin - rp._ich;		// Subtract off offset in this run
	}
	else
		fAdvanceCp = cch < 0;			// Need to advance to get pcpMost

	if(pcpMost)
	{
		cch = abs(cch);
		if(fAdvanceCp)					// Advance to cpMost = cpMin + cch,
			rp.AdvanceCp(cch);			//  i.e., range's cpMost
		if(cch)
			rp.AdjustBackward();		// Since nondegenerate range
		*pcpMost = cpMin + cch			// Add remaining cch in run to range's
				+ rp.GetCchLeft();		//  cpMost
	}
}

/*
 *	CRunPtrBase::AdjustBackward()
 *
 *	@mfunc
 *		If the cp for this run ptr is at the "boundary" or edge between two
 *		runs, then make sure this run ptr points to the end of the first run.
 *
 *	@comm
 *		This function does nothing unless this run ptr points to the beginning
 *		or the end of a run.  This function may be needed in those cases
 *		because	a cp at the beginning of a run is identical to the cp for the
 *		end of the previous run (if it exists), i.e., such an "edge" cp is
 *		ambiguous, and you may need to be sure that this run ptr points to the
 *		end of the first run.
 *
 *		For example, consider a run that describes characters at cp's 0 to 10
 *		followed by a run that describes characters	at cp's 11 through 12. For
 *		a cp of 11, it is possible for the run ptr to be either at the *end*
 *		of the first run or at the *beginning* of the second run.	 
 *
 *	@rdesc 	nothing
 */
void CRunPtrBase::AdjustBackward()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::AdjustBackward");

	_TEST_INVARIANT_

	if(!_ich && PrevRun())				// If at start of run that isn't
		_ich = _pRuns->Elem(_iRun)->_cch;	//  the first, go to end of
}											//  previous run

/*
 *	CRunPtrBase::AdjustForward()
 *
 *	@mfunc
 *		If the cp for this run ptr is at the "boundary" or edge between two
 *		runs, then make sure this run ptr points to the start of the second
 *		run.
 *
 *	@rdesc
 *		nothing
 *	
 *	@xref
 *		<mf CRunPtrBase::AdjustBackward>
 */
void CRunPtrBase::AdjustForward()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::AdjustForward");

	_TEST_INVARIANT_

	if(!IsValid())
		return;

	CTxtRun *pRun = _pRuns->Elem(_iRun);

	if(pRun->_cch == _ich)					// If at end of run, go to start
		NextRun();							//  of next run (if it exists)
}

/*
 *	CRunPtrBase::IsValid()
 *
 *	@mfunc
 *		indicates whether the current run pointer is in the empty
 *		or NULL states (i.e. "invalid" states).
 *
 *	@rdesc
 *		TRUE is in the empty or NULL state, FALSE otherwise.
 */
BOOL CRunPtrBase::IsValid() const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::IsValid");

	return _pRuns && _pRuns->Count();
}

/*
 *	CRunPtrBase::SetToNull()
 *
 *	@mfunc
 *		Sets all run pointer information to be NULL. This
 *		is designed to handle the response to clearing document runs
 *		such as when we convert from rich text to plain text.
 *
 *	@rdesc
 *		VOID
 */
void CRunPtrBase::SetToNull() 
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::SetToNull");

	_pRuns = NULL;
	_iRun = 0;
	_ich = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\textserv.cpp ===
/*
 *  @doc EXTERNAL
 *
 *  @module TEXTSERV.CPP    -- Text Services Implementation |
 *
 *  Original Author: <nl>
 *      Rick Sailor
 *
 *  History: <nl>
 *      8/1/95  ricksa  Created and documented
 *      10/95   murrays Further doc and simplifications
 *
 *  Documentation is generated straight from the code.  The following
 *  date/time stamp indicates the version of code from which the
 *  the documentation was generated.
 *
 *  $Header: /richedit/src/textserv.cpp 53    11/15/95 2:39p Ricksa $
 *
 *  Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_edit.h"
#include "_dispprt.h"
#include "_dispml.h"
#include "_dispsl.h"
#include "_select.h"
#include "_text.h"
#include "_runptr.h"
#include "_font.h"
#include "_measure.h"
#include "_render.h"
#include "_m_undo.h"
#include "_antievt.h"
#include "_rtext.h"
#include "_urlsup.h"
#include "_magelln.h"
#include "_ols.h"
#include "_clasfyc.h"

#ifndef OBJID_NATIVEOM
#define OBJID_NATIVEOM 0xFFFFFFF0
#endif

// By turning on the PROFILE_TS compiler directive, you tell IceCap2.0
// to turn on profiling for only ITextServices API's.  Typically only
// used during profiling work.
//#define PROFILE_TS
#ifdef PROFILE_TS
#include <icapexp.h>

class CapProfile
{
public:
    CapProfile() { StartCAP(); }
    ~CapProfile() { StopCAP(); }
};

#define START_PROFILING     CapProfile capprf;
#else
#define START_PROFILING
#endif //PROFILE_TS

ASSERTDATA

// Macros to get mouse coordinates out of a message
// need to cast to SHORT first for sign extension
#define MOUSEX  ((INT)(SHORT)LOWORD(lparam))
#define MOUSEY  ((INT)(SHORT)HIWORD(lparam))

LONG ValidateTextRange(TEXTRANGE *pstrg);

// Helper function in edit.cpp
LONG GetECDefaultHeightAndWidth(
    ITextServices *pts,
    HDC hdc,
    LONG lZoomNumerator,
    LONG lZoomDenominator,
    LONG yPixelsPerInch,
    LONG *pxAveWidth,
    LONG *pxOverhang,
    LONG *pxUnderhang);

// if there's an active object being dragged around, on WM_PAINT we always
// try to reposition it to there it should be. A not-so-well-behaved object
// my generate another WM_PAINT message in response to that, even if it actually
// did not move. So we limit our number of attempts to reposition it and reset
// this counter every time a mouse moves.
// The corresponding field is declared as :2, so don't try to bump it up
// without allocating more bits!!
#define MAX_ACTIVE_OBJ_POS_TRIES (3)


///////////////////////////// Helper Functions ///////////////////////////////////
/*
 *  ConvertDrawDCMapping(hdcDraw)
 *
 *  @func
 *      Put screen DC in MM_TEXT mapping mode.
 */
void ConvertDrawDCMapping(
    HDC hdcDraw)        //@parm HDC to draw on
{
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "ConvertDrawDCMapping");

    SaveDC(hdcDraw);
    SetViewportOrgEx(hdcDraw, 0, 0, NULL);
    SetWindowOrgEx(hdcDraw, 0, 0, NULL);
    SetMapMode(hdcDraw, MM_TEXT);
}

/*
 *  BOOL CTxtEdit::LoadMsgFilter(msg, wparam, lparam)
 *
 *  @func
 *      Check if we should load the IME message filter
 *
 *  @rdesc
 *      TRUE - Load it
 *      FALSE - Don't load
 */
BOOL CTxtEdit::LoadMsgFilter(
    UINT    msg,                //@parm Message ID
    WPARAM  wparam,             //@parm Message wparam
    LPARAM  lparam)             //@parm Message lparam
{
    //TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::LoadMsgFilter");

    // For the first ever message, we want to check if
    // our client has created AIMM object for current thread
    if (!_fCheckAIMM)
    {
        DWORD   dwThreadId;
        BOOL    fLoadAimm = FALSE;

        _fCheckAIMM = 1;

        if (W32->fUseAimm())                            // Ini file say use Aimm
            fLoadAimm = TRUE;

        else if (dwThreadId = GetCurrentThreadId())
        {
            char szBuf[20];

            sprintf(szBuf, "AIMM:%08x", dwThreadId);

            if (FindAtomA(szBuf))                       // Atom presented, load Aimm
                fLoadAimm = TRUE;
        }

        if (fLoadAimm)
        {
            HWND    hWnd;

            TxGetWindow( &hWnd );

            if (hWnd)
                PostMessage(hWnd, EM_SETEDITSTYLE, SES_USEAIMM, SES_USEAIMM);
        }
    }

    switch (msg)
    {
        case WM_KEYDOWN:
        case WM_SYSKEYDOWN:
            if ( (WORD) wparam == VK_PROCESSKEY )
                return TRUE;
            break;

        case WM_INPUTLANGCHANGE:
            if (IsFELCID((WORD)(lparam)))
                return TRUE;
            break;

        case EM_SETEDITSTYLE:
            if((lparam & (SES_USEAIMM | SES_NOIME)) ||
                (wparam & (SES_USEAIMM | SES_NOIME)))
                return TRUE;
            break;

        case EM_RECONVERSION:
        case WM_IME_NOTIFY:
        case WM_IME_REQUEST:
        case WM_IME_STARTCOMPOSITION:
        case EM_GETIMEOPTIONS:
        case EM_SETIMEOPTIONS:
        case EM_SETIMECOLOR:
        case EM_GETIMECOLOR:
        case WM_IME_CHAR:
            return TRUE;

        case EM_SETLANGOPTIONS:
            if (lparam & (IMF_IMEALWAYSSENDNOTIFY | IMF_IMECANCELCOMPLETE))
                return TRUE;
            break;

        default:
            if (msg)
            {
                if (msg == MSIMEReconvertMsg || msg == MSIMEDocFeedMsg
                    || msg == MSIMEQueryPositionMsg)
                    return TRUE;
            }
            break;

    }

    return FALSE;
}

/*
 *  CTxtEdit::FormatAndPrint (hdcDraw, hicTargetDev, ptd, lprcBounds,
 *                            lprcWBounds)
 *  @mfunc
 *      Format and Print data in control
 *
 *  @rdesc
 *      S_OK - everything worked
 *      E_FAIL - unexpected failure occurred
 */
HRESULT CTxtEdit::FormatAndPrint(
    HDC hdcDraw,            //@parm HDC to draw on
    HDC hicTargetDev,       //@parm Input information context if any
    DVTARGETDEVICE *ptd,    //@parm Device target information
    RECT *lprcBounds,       //@parm Rectangle to measure
    RECT *lprcWBounds)      //@parm Metafile information
{
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::FormatAndPrint");

    // Put client rectangle in format structure
    FORMATRANGE fr;
    fr.rc = *lprcBounds;

    // Get number of device units per inch
    LONG xPerInch;
    LONG yPerInch;

    if (NULL == lprcWBounds)
    {
        xPerInch = GetDeviceCaps(hdcDraw, LOGPIXELSX);
        yPerInch = GetDeviceCaps(hdcDraw, LOGPIXELSY);
    }
    else
    {
        //Forms ^3 draws using screen resolution, while OLE specifies HIMETRIC
        xPerInch = fInOurHost() ? 2540 : W32->GetXPerInchScreenDC();
        yPerInch = fInOurHost() ? 2540 : W32->GetYPerInchScreenDC();

        SetWindowOrgEx(hdcDraw, lprcWBounds->left, lprcWBounds->top, NULL);
        SetWindowExtEx(hdcDraw, lprcWBounds->right, lprcWBounds->bottom, NULL);
    }


    // Convert rectangle into TWIPS
    fr.rc.left = MulDiv(fr.rc.left, LX_PER_INCH, xPerInch);
    fr.rc.top = MulDiv(fr.rc.top, LY_PER_INCH, yPerInch);
    fr.rc.right = MulDiv(fr.rc.right, LX_PER_INCH, xPerInch);
    fr.rc.bottom = MulDiv(fr.rc.bottom, LY_PER_INCH, yPerInch);

    // Use message based printing code to do our printing for us
    fr.hdc = hdcDraw;
    fr.hdcTarget = hicTargetDev;
    fr.rcPage = fr.rc;
    fr.chrg.cpMin = _pdp->GetFirstVisibleCp();
    fr.chrg.cpMost = -1;

    // Assume this is all going to work
    HRESULT hr = S_OK;

    SPrintControl prtcon;
    prtcon._fDoPrint = TRUE;
    prtcon._fPrintFromDraw = TRUE;

    // Print control
    if(OnFormatRange(&fr, prtcon, TRUE) == -1)
    {
        // For some reason the control could not be printed
        hr = E_FAIL;
    }

    return hr;
}

/*
 *  CTxtEdit::RectChangeHelper (pdi, dwDrawAspect, lindex, pvAspect, ptd,
 *                              hdcDraw, hicTargetDev, lprcClient, prcLocal)
 *  @func
 *      Format and Print data in the control
 *
 *  @rdesc
 *      S_OK - everything worked
 *      E_INVALIDARG - client parameter is invalid
 *
 *  @devnote
 *      Caller must release the DC from the display object.
 */
HRESULT CTxtEdit::RectChangeHelper(
    CDrawInfo *pdi,         //@parm Draw information memory
    DWORD    dwDrawAspect,  //@parm Draw aspect
    LONG     lindex,        //@parm Currently unused
    void *   pvAspect,      //@parm Info for drawing optimizations (OCX 96)
    DVTARGETDEVICE *ptd,    //@parm Info on target device
    HDC      hdcDraw,       //@parm Rendering device context
    HDC      hicTargetDev,  //@parm Target information context
    const RECT ** pprcClient,   //@parm New client rectangle
    RECT *   prcLocal)      //@parm Rect to use if previous parm is NULL
{
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::RectChangeHelper");

    HRESULT hr = S_OK;
    BOOL fRestore = FALSE;

    // We assume that if client's rectangle is supplied, it has changed.
    if(pprcClient && *pprcClient)
    {
        // Set up information context if necessary
        HDC hicLocal = NULL;

        // Did they give us a ptd without a hic?
        if(!hicTargetDev && ptd)
        {
            // Create information context for device information,
            // since it wasn't supplied
            hicLocal = CreateIC(
                (TCHAR *)((BYTE *) ptd + ptd->tdDriverNameOffset),
                (TCHAR *)((BYTE *) ptd + ptd->tdDeviceNameOffset),
                (TCHAR *)((BYTE *) ptd + ptd->tdPortNameOffset),
                (DEVMODE *)((BYTE *)  ptd + ptd->tdExtDevmodeOffset));
            if(!hicLocal)
                return E_FAIL;            // Couldn't create it

            hicTargetDev = hicLocal;
        }

        *prcLocal = **pprcClient;           // Define *prcLocal in any case

        // Force DC in MM_TEXT
        if (GetMapMode(hdcDraw) != MM_TEXT &&
            GetDeviceCaps(hdcDraw, TECHNOLOGY) != DT_METAFILE)
        {
            fRestore = TRUE;

            // Convert input parameters to new mapping
            WinLPtoDP(hdcDraw, (POINT *)prcLocal, 2);

            *pprcClient = prcLocal;

            // Convert HDC to new mapping
            ConvertDrawDCMapping(hdcDraw);
        }

        _pdp->SetDC(hdcDraw);           // Set the DC
        _pdp->SetDrawInfo(              // Set the draw info
            pdi,
            dwDrawAspect,
            lindex,
            pvAspect,
            ptd,
            hicTargetDev);

        _pdp->ReDrawOnRectChange(hicTargetDev, *pprcClient);

        if(fRestore)                    // Put DC back into correct
            RestoreDC(hdcDraw, -1);     //  mapping mode

        if(hicLocal)                    // Clean up info context if we
            DeleteDC(hicLocal);         //  created one
    }
    else if (pprcClient && _fInPlaceActive)
    {
        // We can figure out what the client rectangle is.
        TxGetClientRect(prcLocal);
        *pprcClient = prcLocal;
    }
    else                                // If not inplace active, a RECT
        hr = E_INVALIDARG;              //  must be supplied

    return hr;
}

/*
 *  CTxtEdit::SetText (pstr, flags, CodePage)
 *
 *  @mfunc  sets the text in the document, clearing out any existing
 *          text
 *
 *  @rdesc  HRESULT
 */
HRESULT CTxtEdit::SetText(
    LPCWSTR       pstr,     //@parm Text to set
    DWORD         flags,    //@parm 0 or more ST_xxx's
    LONG          CodePage, //@parm CodePage
    IUndoBuilder *publdr,   //@parm Optional place to put undo events
    LRESULT *     plres)    //@parm Optional place to return cch added
{
    CCallMgr    callmgr(this);
    BOOL        fSel = flags & ST_SELECTION;
    BOOL        fSetTextMax = TRUE;
    CTxtRange   rg(this, 0, -GetTextLength());  // Select whole story
    CTxtRange * prg = &rg;
    LRESULT     lres = 0;
    CFreezeDisplay fd(_pdp);
    CCharFormat CF;
    BOOL        fSetCF = FALSE;

    // NOTE: WM_SETTEXT is the only message using flags == ST_CHECKPROTECTION.
    // This is sent in via ANSIWndProc().  Do we need another flag to indicate
    // WM_SETTEXT or is this check good enough?  This only affect 1.0 mode.
    BOOL        f10WM_SETTEXT = flags & ST_10WM_SETTEXT;

    if(plres)
        *plres = 0;

    if(fSel)                    // Set selected text
    {
        if(!_psel)
        {
            Beep();
            return E_FAIL;
        }
        //bug fix: 6498 - we need to know if scroll position is at bottom before
        //inserting text
        if (Get10Mode())
        {
            LONG nMin, nMax, nPos, nPage;
            BOOL nEnable;
            TxGetVScroll(&nMin, &nMax, &nPos, &nPage, &nEnable);
            if (nEnable)
                _psel->SetAutoVScroll((nMax - nPage - 3) <= nPos);
        }

        prg = _psel;
    }
    else
    {
        _dwCharFlags &= 0xFF;           // No chars, so kill char flags
        if (!IsRich())
        {
            // Deleting all text from Plain text, we want to
            // go back to the -1 format
            prg->Set_iCF(-1);
            prg->SetUseiFormat(TRUE);
        }
        else
            _dwCharFlags |= fBELOWX40;  // For final EOP
    }

    if (flags & ST_CHECKPROTECTION &&
        IsProtectedRange(WM_SETTEXT, 0, (LPARAM)pstr, prg))
    {
        return E_ACCESSDENIED;
    }

    // 1.0 COMPATABILITY
    // 1.0 didn't scroll to seleection if text is inserted via EM_REPLACESEL and
    // fHideSelection is FALSE;
    BOOL    fUpdateCaret = !(Get10Mode() && (flags & ST_10REPLACESEL) && fHideSelection() && !_psel->GetAutoVScroll());

    if(!(flags & ST_KEEPUNDO))
    {

        if(IsRich() && !fSel)
        {
            if (f10WM_SETTEXT)
            {
                // If pstr is empty string, retain format at the end of current text
                // If pstr is not empty string, retain format at cp==1
                // Note: prg->_rpCF is already at SetRun(0,0)
                CFormatRunPtr rp(prg->_rpCF);

                if (!pstr || *(LPBYTE)pstr == '\0')
                {
                    LONG cchAdjusted = GetAdjustedTextLength() - 1;

                    if (cchAdjusted > 0)
                        rp.AdvanceCp(cchAdjusted);
                }

                CF = *(GetCharFormat(rp.GetFormat()));
                fSetCF = TRUE;

                prg->SetText(NULL);     // delete all the text first
            }

            // SetText causing all formatting to return to the default. We use
            // the notification system to remove the formatting. This is
            // particularly important for the final EOP which cannot be deleted.

            // Notify every interested party that they should dump their formatting
            _nm.NotifyPreReplaceRange(NULL, CONVERT_TO_PLAIN, 0, 0, 0, 0);

            // Tell document to dump its format runs
            _story.DeleteFormatRuns();

            if (fSetCF)
                prg->SetCharFormat(&CF, 0, NULL, CFM_ALL, 0);
        }

        publdr = NULL;
        if(_pundo)
            _pundo->ClearAll();

        if(_predo)
            _predo->ClearAll();

        // If we are re-entered, there may be anti-events higher up the
        // chain.  Grab the undo builder and clear things away if necessary.
        CGenUndoBuilder undobldr(this, 0);
        undobldr.Discard();
    }
    if(publdr)
        publdr->StopGroupTyping();

    // need to reinit zoomin variables if entire text is being replaced
    if (!fSel)
        InitDocInfo();


    LONG lStreamFormat = IsRTF((char *)pstr) ? SF_RTF : 0;

    if(pstr && (CodePage != 1200 || lStreamFormat))
    {
        LONG cch = strlen((LPSTR)pstr);
        LONG ch = *(LPBYTE)pstr;

        if(ch < 128 && fSel && cch == 1)
        {
            lres = 1;
            fSetTextMax = FALSE;
            TxSetMaxToMaxText(1);
            _psel->PutChar(ch, 0, publdr);
        }
        else if(cch == 2 && ch == CR && *((LPSTR)pstr + 1) == LF)
        {
            lres = 2;
            fSetTextMax = FALSE;
            TxSetMaxToMaxText(2);
            _psel->InsertEOP(publdr);
        }
        else
        {
            READHGLOBAL rhg = {(LPSTR)pstr, cch};
            EDITSTREAM  es = {(DWORD_PTR)&rhg, S_OK, ReadHGlobal};
            HCURSOR     hcur = NULL;

            // Want wait cursor to display sooner
            bool fSetCursor = rhg.cbLeft > NUMPASTECHARSWAITCURSOR;
            if(fSetCursor)
                hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

            if (CodePage <= 0)
                CodePage = (CodePage == 0) ? GetACP() : GetDefaultCodePage(EM_SETTEXTEX);

            if(!lStreamFormat)
                lStreamFormat = SF_TEXT;

            lStreamFormat |= SF_USECODEPAGE | (CodePage << 16);

            if(fSel)
                lStreamFormat |= SFF_SELECTION;

            lres = _ldte.LoadFromEs(prg, lStreamFormat, &es, FALSE, publdr);
            if(fSetCursor)
                SetCursor(hcur);

            if(es.dwError != NOERROR)
                return (HRESULT)es.dwError;
        }
    }
    else
        lres = prg->CleanseAndReplaceRange(-1, pstr, FALSE, publdr, NULL, NULL, RR_ITMZ_UNICODEBIDI);

    if (_fOutlineView)
    {
        // Outline view must have formatting.
        _psel->Check_rpPF();
    }

    if(!lres && pstr && (!lStreamFormat && *pstr != '\0' ||
        lStreamFormat && *(char *)pstr != '\0'))
    {
        // There was an input string but for some reason there was no update.
        return E_FAIL;
    }

    if(_psel)
    {
        if(fSel)
            _psel->Update(fUpdateCaret);
        else
        {
            // Setting the text means a new document so if there is a selection
            // turn it into an insertion point at the beginning of the document.
            _psel->ClearPrevSel();
            _psel->Set(0, 0);

            // Since the text is being completely replaced and all formatting
            // is being lost, let's go back to the default format for the
            // selection.
            if (!f10WM_SETTEXT)
                _psel->Set_iCF(-1);
            else if (fSetCF)
                _psel->SetCharFormat(&CF, 0, NULL, CFM_ALL, 0);

            if(_fFocus || _psel->IsParaRTL())
            {
                // Update caret to reflect new postion
                _psel->UpdateCaret(fUpdateCaret);
            }
        }
    }

    // If we've replaced the entire document, the control isn't
    // really "modified" anymore.  This is necessary to match
    // the Windows MLE behavior.  However, since RichEdit 1.0
    // did _not_ do this (they left fModified to be TRUE), we
    // only do this for RichEdit 2.0 and later.

    if(!Get10Mode() && !publdr && !fSel)
        _fModified = FALSE;

    _fSaved = FALSE;                        // ITextDocument isn't Saved

    // Adjust text limit if necessary
    if (fSetTextMax)
        TxSetMaxToMaxText();

    if(plres)
        *plres = fSel ? lres : 1;

    return S_OK;
}

/////////////////////////// ITextServices Methods ////////////////////////////////

// External IME Message Filter Interface factory
void CreateIMEMessageFilter(ITextMsgFilter **ppNewFilter);

/*
 *  @doc EXTERNAL
 *
 *  CTxtEdit::TxSendMessage (msg, wparam, lparam, plresult)
 *
 *  @mfunc
 *      Used by window host to forward messages sent to its window to the
 *      text services.
 *
 *  @rdesc
 *      NOERROR Message was processed, and some action taken <nl>
 *      S_FALSE Message was not processed.  Typically indicates that caller
 *              should process message, maybe by calling DefWindowProc <nl>
 *      S_MSG_KEYIGNORED Message processed, but no action was taken <nl>
 *      E_OUTOFMEMORY <nl>
 *
 *  @comm
 *      Note that two return values are passed back from this function.
 *      <p plresult> is the return value that should be passed back from a
 *      window proc.  However, in some cases, the returned LRESULT does not
 *      contain enough information.  For example, to implement cursoring
 *      around controls, it's useful to know if a keystroke (such as right
 *      arrow) was processed, but ignored (e.g. the caret is already at the
 *      rightmost position in the the text).  In these cases, extra
 *      information may be returned via the returned HRESULT.
 *
 *      WM_CHAR and WM_KEYDOWN should return S_MSG_KEYIGNORED when a key or
 *      char has been recognized but had no effect given the current state,
 *      e.g., a VK_RIGHT key when the insertion point is already at the end of
 *      the document). This is used by Forms3 to pass the key up the visual
 *      hierarchy, so that for example, focus moves to the next control in the
 *      TAB order.
 *
 *      This includes the following cases:
 *
 *      1. Any key trying to move the insertion point beyond the end of the
 *      document; or before the begining of the document.
 *
 *      2. Any key trying to move the insertion point beyond the last line or
 *      before the first line.
 *
 *      3. Any insertion of character (WM_CHAR) that would move the insertion
 *      point past the maximum length of the control.
 */
HRESULT CTxtEdit::TxSendMessage (
    UINT    msg,        //@parm Message id
    WPARAM  wparam,     //@parm WPARAM from window's message
    LPARAM  lparam,     //@parm LPARAM from window's message
    LRESULT *plresult)  //@parm Where to put message's return LRESULT
{
    TRACEBEGINPARAM(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::TxSendMessage", msg);

    CObjectMgr *pobjmgr;
    HRESULT     hr = NOERROR;
    LRESULT     lres = 0;
    CCallMgr    callmgr(this);

    if ( CW32System::_MSMouseRoller == msg )                    // map Magellan msg.
    {
        // map this message to WM_MOUSEWHEEL
        // In these cases the driver doesn't set the key state properly so
        // we have to do it ourselves
        short zdelta = (short)(long)wparam;
        short kstate = 0;
        if (GetKeyboardFlag(CTRL, VK_CONTROL))
            kstate |= MK_CONTROL;
        if (GetKeyboardFlag(SHIFT, VK_SHIFT))
            kstate |= MK_SHIFT;

        wparam = MAKELONG(kstate, zdelta);
        msg = WM_MOUSEWHEEL;
    }

    if (_pMsgFilter)
    {
PassMsg:
        hr = _pMsgFilter->HandleMessage(&msg, &wparam, &lparam, &lres);
        if (hr == S_OK)                 // Message has been handled.
        {
            if(plresult)
                *plresult = lres;

            return S_OK;
        }
        hr = S_OK;                      // Reset
    }
    else if (LoadMsgFilter(msg, wparam, lparam))
    {
        HWND hwnd = NULL;
        if (_fInOurHost)
        {
            // If not in Forms^3 we can get the window from our host.
            // For Forms^3 we will use NULL for the desktop Window and pray
            TxGetWindow( &hwnd );
        }
        ITextMsgFilter *pNewFilter;
        CreateIMEMessageFilter(&pNewFilter);
        if (pNewFilter)
        {
            pNewFilter->AttachDocument( hwnd, (ITextDocument2 *) this);
            AttachMsgFilter(pNewFilter);
            goto PassMsg;
        }
    }

    START_PROFILING

    IUndoBuilder *  publdr;
    CGenUndoBuilder undobldr(this, UB_AUTOCOMMIT, &publdr);

#ifdef MACPORTREMOVEIT
// PowerMac's cannot set breakpoints on a running application and have
// no way to stop the running appliation.This code allows one to
// stop the executable when the user holds down the option key and
// a break point has been set in the indicated spot below. -jOn

    BOOL fMacBreak = GetAsyncKeyState(VK_OPTION)<0;// Is user holding OPTION?

    if(fMacBreak)               // any old statement will due.
        fMacBreak = TRUE;       // Set a break point here for stopping the Mac.

#endif // MACPORTREMOVE

    switch(msg)
    {
    case EM_CANPASTE:
        // we don't check for protection here, as RichEdit 1.0
        // doesn't
        lres = _ldte.CanPaste(NULL, (CLIPFORMAT) wparam, RECO_PASTE);
        break;

    case EM_CANUNDO:
        if(_pundo)
            lres = _pundo->CanUndo();
        break;

    case EM_CANREDO:
        if(_predo)
            lres = _predo->CanUndo();
        break;

    case EM_GETUNDONAME:
        if(_pundo)
            lres = _pundo->GetNameIDFromAE((void*)wparam);
        break;

    case EM_GETREDONAME:
        if(_predo)
            lres = _predo->GetNameIDFromAE((void*)wparam);
        break;

    case EM_STOPGROUPTYPING:
        if(_pundo)
        {
            // we'll only stop group typing iff wparam
            // is zero (meaning stop regardless) _or_ if
            // wparam matches the merge anti event.
            //
            // This feature allows clients to say that only
            // a specific anti-event should close out it's
            // "fuzzy" state.  Note that currently, only the
            // merge anti-event has this fuzzy state.

            if(!wparam || (IAntiEvent *)wparam == _pundo->GetMergeAntiEvent())
                _pundo->StopGroupTyping();
        }
        break;

    case WM_CHAR:
        if(GetKeyboardFlags() & (ALTNUMPAD | HOTEURO))
        {
			if(GetKeyboardFlags() & ALTNUMPAD)
			{
				CW32System::WM_CHAR_INFO wmci;
				wmci._fAccumulate = FALSE;
				W32->AnsiFilter(msg, wparam, lparam, (void *)&wmci);
			}
			else
			{
				// We have handled the Euro, just eat this WM_CHAR
				ResetKeyboardFlag(HOTEURO);
				break;
			}
        }                               // Fall thru to WM_IME_CHAR		

    case WM_IME_CHAR:                   // 2 byte character, usually FE.
        lres = hr = OnTxChar((WORD) wparam, (DWORD) lparam, publdr);
		ResetKeyboardFlag(HOTEURO);
        break;

    case WM_USER + 39:                  // For backward compat with NT 3.51
    case EM_CHARFROMPOS:
        hr = TxCharFromPos((LPPOINT)lparam, &lres);
        break;

#ifndef NOMLKEYBOARD
    case WM_INPUTLANGCHANGE:
        if (_fSingleCodePage)
        {
            // See if the charset for the specified keyboard is supported by
            // the single code page we support. If we don't have a _pDocInfo,
            // assume the code page is the system code page. We will always
            // support the ANSI charset, as all code pages contain at least
            // a large portion of this charset (the ASCII block).
            wparam = (!wparam || wparam == GetCharSet(_pDocInfo ?
                        _pDocInfo->wCpg : GetSystemDefaultCodePage()));
        }
        goto update_kbd;

    case WM_INPUTLANGCHANGEREQUEST:
        // If the SingleCodePage option is set, then we must have a
        // "good" code page to go to; if not, just eat this message.
        //
        // This will prevent folks from typing French and Greek
        // on the same edit control, which is useful for certain
        // kinds of backward compatibility scenarios.
        //
        // HACK ALERT!  the documentation on WM_INPUTLANGCHANGEREQUEST
        // is wrong.  It turns out that _only_ the low bit of wparam
        // indicates whether or not the new keyboard can be considered
        // as the same code page.

        if (_fSingleCodePage && !(wparam & 1))
        {
            // The lowest bit check is not reliable in some platforms e.g. Viet OSR2
            // since it doesnt allow English kbd to match system charset (bug #6365).

            wparam = PRIMARYLANGID(LOWORD(lparam)) == LANG_ENGLISH &&
                     IN_RANGE (SUBLANG_ENGLISH_US, SUBLANGID(LOWORD(lparam)), SUBLANG_ENGLISH_UK);
        }

update_kbd:
        if(!_fSingleCodePage || (wparam & 1))
        {
            // Update our idea of current keyboard layout
            W32->RefreshKeyboardLayout();

            if(GetKeyboardFlags() & CTRL && GetKeyboardFlags() & SHIFT)
                SetKeyboardFlag(LETAFTERSHIFT);

            if (GetSel()->CheckChangeFont(
                    (HKL)lparam,
                    ConvertLanguageIDtoCodePage(LOWORD(lparam))))
            {
                hr = S_FALSE;   // cause default window to allow kb switch.
            }
        }
        break;
#endif

    case WM_CLEAR:
        OnClear(publdr);
        break;

    case WM_CONTEXTMENU:
        hr = OnContextMenu(lparam);
        break;

    case WM_COPY:
    case WM_CUT:
        lres = hr = CutOrCopySelection(msg, wparam, lparam, publdr);
        break;

    case WM_RENDERFORMAT:
        lres = hr = _ldte.RenderClipboardFormat(wparam);
        break;

    case WM_RENDERALLFORMATS:
        lres = hr = _ldte.RenderAllClipboardFormats();
        break;

    case WM_DESTROYCLIPBOARD:
        lres = hr = _ldte.DestroyClipboard();
        break;

    case EM_DISPLAYBAND:
        if (fInplaceActive())
        {
            OnDisplayBand((const RECT *) lparam, FALSE);
            lres = 1;
        }
        else
            hr = OLE_E_INVALIDRECT;
        break;

#ifndef NODROPFILES
    case WM_DROPFILES:
        OnDropFiles((HANDLE) wparam);
        break;
#endif

    case EM_EMPTYUNDOBUFFER:
        ClearUndo(publdr);
        break;

    case WM_ERASEBKGND:
        lres = 1;               // We handle background erase during painting
        break;

    case EM_EXGETSEL:                       // Has cp output parameter
        OnExGetSel((CHARRANGE *)lparam);
        break;

    case EM_FINDTEXT:                       // Has cp input/output parms
    case EM_FINDTEXTW:                      // Has cp input/output parms
    case EM_FINDTEXTEX:                     // Has cp input/output parms
    case EM_FINDTEXTEXW:                    // Has cp input/output parms
        lres = OnFindText(msg, (DWORD)wparam, (FINDTEXTEX *)lparam);
        break;

    case EM_FINDWORDBREAK:                  // Has cp input/output parms
        hr = TxFindWordBreak((INT)wparam, (LONG)lparam, &lres);
        break;

    case EM_FORMATRANGE:                    // Has cp input/output parms
        if(fInplaceActive())
        {
            SPrintControl prtcon;
            prtcon._fDoPrint = (wparam) ? TRUE : FALSE;
            lres = OnFormatRange((FORMATRANGE *) lparam, prtcon);
        }
        else
            hr = OLE_E_INVALIDRECT;
        break;

    case EM_GETTYPOGRAPHYOPTIONS:
        lres = _bTypography;
        break;

    case EM_GETBIDIOPTIONS:
        if(lparam && ((BIDIOPTIONS *)lparam)->cbSize == sizeof(BIDIOPTIONS))
        {
            ((BIDIOPTIONS *)lparam)->wMask =
                BOM_NEUTRALOVERRIDE | BOM_CONTEXTREADING | BOM_CONTEXTALIGNMENT;
            ((BIDIOPTIONS *)lparam)->wEffects =
                (_fNeutralOverride ? BOE_NEUTRALOVERRIDE : 0) |
                (_nContextDir   == CTX_NONE ? 0 : BOE_CONTEXTREADING) |
                (_nContextAlign == CTX_NONE ? 0 : BOE_CONTEXTALIGNMENT);
        }
        break;

    case EM_GETCHARFORMAT:
        lres = OnGetCharFormat((CHARFORMAT2 *)lparam, wparam);
        break;

    case EM_GETCODEPAGE:
        lres = GetDefaultCodePage((UINT)wparam);
        break;

    case EM_GETFIRSTVISIBLELINE:
        if (fInplaceActive())
            lres = _pdp->GetFirstVisibleLine();
        else
            hr = OLE_E_INVALIDRECT;
        break;

    case EM_GETLIMITTEXT:                   // Has cp output parameter (sort of)
        lres = TxGetMaxLength();            // Ignore unless testing screams
        break;

    case EM_GETLINE:
        if(fInplaceActive())
        {
            lres = _pdp->GetLineText((LONG)wparam, (TCHAR *)lparam,
                                (LONG) (*(WORD *) lparam));
        }
        else
            hr = OLE_E_INVALIDRECT;
        break;

    case EM_GETLINECOUNT:
        hr = TxGetLineCount(&lres);
        break;

    case EM_GETMODIFY:              // RichEdit 1.0 returned -1 if _fModified
        lres = -(LONG)_fModified;   //  is TRUE (go figure). So for backward
        break;                      //  compatibility, we do too :-(

    case EM_GETOLEINTERFACE:
        if(lparam)
        {
            if (wparam == 0x065737777)      // 'AIMM'
                W32->GetAimmObject((IUnknown **)(lparam));
            else
            {
                *(IRichEditOle **)lparam = (IRichEditOle *)this;
                AddRef();
            }
        }
        lres = TRUE;
        break;

    case EM_GETSCROLLPOS:
        {
            POINT *point = (POINT *)lparam;
            point->x = _pdp->GetXScroll();
            point->y = _pdp->GetYScroll();
            point->y = _pdp->ConvertYPosToScrollPos(point->y);
            lres = 1;
        }
        break;

    case EM_SETOLECALLBACK:
        hr = E_FAIL;
        if(lparam)
        {
            pobjmgr = GetObjectMgr();
            if(pobjmgr)
            {
                pobjmgr->SetRECallback((IRichEditOleCallback *)lparam);
                lres = TRUE;
                hr = NOERROR;
            }
        }
        break;

    case EM_GETPARAFORMAT:
        lres = OnGetParaFormat((PARAFORMAT2 *)lparam, wparam);
        break;

    case EM_GETSEL:                         // Has cp output parameter
        lres = OnGetSel((LONG*)wparam, (LONG*)lparam);
        break;

    case EM_GETSELTEXT:
        lres = OnGetSelText((TCHAR *)lparam);
        break;

    case WM_GETTEXT:
        {
            GETTEXTEX gt;

            gt.cb = wparam * 2;
            gt.flags = GT_USECRLF;
            gt.codepage = 1200;
            gt.lpDefaultChar = NULL;
            gt.lpUsedDefChar = NULL;

            lres = GetTextEx(&gt, (TCHAR *)lparam);
        }
        break;

    case WM_GETTEXTLENGTH:                  // Has cp output parameter
        {
            GETTEXTLENGTHEX gtl;

            gtl.flags = GTL_NUMCHARS | GTL_PRECISE | GTL_USECRLF;
            gtl.codepage = 1200;

            lres = GetTextLengthEx(&gtl);
        }
        break;

    case EM_GETTEXTEX:
        lres = GetTextEx((GETTEXTEX *)wparam, (TCHAR *)lparam);
        break;

    case EM_GETTEXTLENGTHEX:                // Has cp output parameter
        lres = GetTextLengthEx((GETTEXTLENGTHEX *)wparam);
        break;

    case EM_GETTEXTRANGE:                   // Has cp input parameter
    {
        TEXTRANGE * const ptr = (TEXTRANGE *)lparam;
        LONG              cch = ValidateTextRange(ptr);

        // Only copy if there's something to copy and destination is valid
        if(cch)
        {
            LONG cpMin  = GetCpFromAcp(ptr->chrg.cpMin);
            if(cch < 0)                     // Get text character count
                cch = GetTextLength();      //  because caller wants it all
            else                             // + 1 is for terminating 0
                cch = GetCpFromAcp(ptr->chrg.cpMost) - cpMin + 1;

            if(!IsBadWritePtr(ptr->lpstrText, cch * sizeof(TCHAR)))
                lres = GetTextRange(cpMin, cch, ptr->lpstrText);
        }
    }
        break;

    case EM_GETWORDBREAKPROC:
        // Client can only use either WordBreakProc or ExWordBreakProc
        // Return NULL if ExWordBreakProc is being used.
        if (!_fExWordBreakProc)
            lres = OnGetWordBreakProc();
        break;

    case EM_GETWORDBREAKPROCEX:
        // Return ExWordBreakProc if it is being used.
        if (_fExWordBreakProc)
            lres = OnGetWordBreakProc();
        break;

    case EM_GETZOOM:
        if(wparam && lparam)
        {
            *(unsigned *)wparam = GetZoomNumerator();
            *(unsigned *)lparam = GetZoomDenominator();
            lres = 1;
        }
        break;

    case EM_HIDESELECTION:
        if (Get10Mode() && lparam)
            _fHideSelection = !!wparam;

        if(!lparam || !_fFocus)
            lres = OnHideSelectionChange((BOOL)wparam);
        break;

    case WM_HSCROLL:
        hr = TxHScroll(LOWORD(wparam), HIWORD(wparam));
        break;

    case WM_KEYDOWN:
        hr = OnTxKeyDown((WORD) wparam, (DWORD) lparam, publdr);
        break;

    case WM_KEYUP:
        if(wparam == VK_APPS)
            HandleKbdContextMenu();
        else                            // Else don't say we processed
            hr = S_FALSE;               //  message

        W32->_fLRMorRLM = 0;
        if(wparam == VK_CONTROL || wparam == VK_SHIFT)
        {
            // If a BiDi control, no strong-context behavior, both a ctrl
            // and a shift key are pressed and no letter has been typed
            // after the Ctrl and Shift keys have been pressed, then the
            // selected paragraphs are set to RTL/LTR direction for the
            // right/left Shift key, respectively. The keyboard and caret
            // are also matched to this direction, and an alignment
            // notification is sent.
            DWORD dwFlags = GetKeyboardFlags();

            if (IsBiDi() && !IsStrongContext(_nContextDir) &&
                !IsStrongContext(_nContextAlign) &&
                (dwFlags & CTRL) && (dwFlags & SHIFT) &&
                // IsBiDiKbdInstalled() &&      // Do we want this???
                !(dwFlags & LETAFTERSHIFT))
            {
                CParaFormat PF;
                PF._wEffects = (dwFlags & RSHIFT) ? PFE_RTLPARA : 0;

                OnSetParaFormat(0, &PF, publdr, PFM_RTLPARA | PFM_PARAFORMAT);
                TxNotify(PF._wEffects ? EN_ALIGNRTL : EN_ALIGNLTR, 0);
            }
            if(wparam == VK_CONTROL)
                lparam = (HIWORD(lparam) & KF_EXTENDED) ? RCTRL : LCTRL;
            else
            {
                lparam = (LOBYTE(HIWORD(lparam)) == 0x36) ? RSHIFT : LSHIFT;
                if(GetKeyState(VK_SHIFT) >= 0)  // Ensure both shifts are off
                    lparam = SHIFT;             //  (potential Win95 problem)
            }
            ResetKeyboardFlag(lparam | LETAFTERSHIFT | HOTEURO);
        }
        else if(wparam == VK_MENU)
            ResetKeyboardFlag((HIWORD(lparam) & KF_EXTENDED) ? (RALT | HOTEURO) : (LALT | HOTEURO));
        break;

    case WM_KILLFOCUS:
        lres = OnKillFocus();
        break;

    case WM_LBUTTONDBLCLK:
        hr = OnTxLButtonDblClk(MOUSEX, MOUSEY, (WORD) wparam);
        break;

    case WM_LBUTTONDOWN:
        if(_fEatLeftDown)
        {
            TxSetFocus();
            _fEatLeftDown = FALSE;
        }
        else
            hr = OnTxLButtonDown(MOUSEX, MOUSEY, (WORD) wparam);
        break;

    case WM_LBUTTONUP:
        hr = OnTxLButtonUp(MOUSEX, MOUSEY, (WORD) wparam, LB_RELEASECAPTURE | LB_FLUSHNOTIFY);
        break;

#if !defined(NOMAGELLAN)
    case WM_MBUTTONDBLCLK:                      // Magellan zmouse scroll
    case WM_NCMBUTTONDOWN:                      //  support commandeers middle
    case WM_MBUTTONDOWN:                        //  button.
        OnTxMButtonDown(MOUSEX, MOUSEY, (WORD) wparam);
        break;

    case WM_MBUTTONUP:
        OnTxMButtonUp(MOUSEX, MOUSEY, (WORD) wparam);
        break;

    case WM_MOUSEWHEEL:                     // Magellan zmouse scroll n lines.
        lres = HandleMouseWheel(wparam, lparam);
        break;
#endif

    case EM_LINEFROMCHAR:                   // Has cp input parameter
        lparam = wparam;                    // Fall thru to EM_EXLINEFROMCHAR

    case EM_EXLINEFROMCHAR:                 // Has cp input parameter
        hr = TxLineFromCp((LONG)lparam, &lres);
        break;

    case EM_LINEINDEX:                      // Has cp output parameter
        hr = TxLineIndex((LONG)wparam, &lres);
        break;

    case EM_LINELENGTH:                     // Has cp input/output parameters
        hr = TxLineLength((LONG)wparam, &lres);
        break;

    case EM_LINESCROLL:                     // Has cp input parameter (cch)
        // Documentation says the line to scroll to should be relative to the current top line.
        // Richedit 2.0 based it on an absolute position.  We're breaking richedit 2.0 compatibility
        // to go back to the documentation specification and to match what riched 1.0 originally
        // did
        hr   = TxLineScroll((LONG)lparam, (LONG)wparam);// but not curr impl
        lres = _pdp->IsMultiLine();
        break;

#ifndef PEGASUS
    case WM_MOUSEACTIVATE:
        lres = MA_ACTIVATE;
        // If the window that currently has focus is part of our "application",
        // then don't eat the mouse click.  Otherwise, if it's from another
        // app, the user is probably trying to swap apps, so eat the mouse
        // down message and let our host app get a chance to come to the
        // foreground.
        if (!(IsChild((HWND)wparam, GetFocus()) ||
            (wparam && (HWND)wparam == GetFocus())))
        {
            _fEatLeftDown = TRUE;
        }
        hr = S_FALSE;       // pass WM_MOUSEACTIVATE message to DefWindProc
        break;
#endif

    case WM_MOUSEMOVE:
        // We reset the "number of tries to put an active object
        //  in place" count here
        _cActiveObjPosTries = MAX_ACTIVE_OBJ_POS_TRIES;
        hr = OnTxMouseMove(MOUSEX, MOUSEY, (WORD)wparam, publdr);
        break;

    case EM_OUTLINE:
    {
        CFreezeDisplay cfd(_pdp);

        if(wparam == EMO_GETVIEWMODE)
        {
            hr = GetViewKind(&lres);
            break;
        }

        CTxtSelection * psel = GetSelNC();

        if(!_pdp->IsMultiLine() || !IsRich() || !psel)  // Control must be rich,
            break;                                  //  multiline and active

        if(wparam == EMO_ENTER || wparam == EMO_EXIT)
        {
            hr = SetViewKind(wparam == EMO_ENTER ? VM_OUTLINE : VM_NORMAL);
            lres = !hr;
            break;
        }

        if(!IsInOutlineView() || !IsntProtectedOrReadOnly(msg, wparam, lparam))
            break;

        CTxtRange rg(*psel);

        switch(wparam)
        {
            case EMO_PROMOTE:
                hr = rg.Promote(lparam, publdr);
                psel->Update_iFormat(-1);
                psel->Update(FALSE);
                break;

            case EMO_EXPAND:
                hr = rg.ExpandOutline((short)LOWORD(lparam),
                                      HIWORD(lparam) == EMO_EXPANDDOCUMENT);
                break;

            case EMO_MOVESELECTION:
                hr = MoveSelection(lparam, publdr);
                psel->Update(TRUE);
                break;

            default:
//              TraceMessage("Unknown outline function received\r\n");
                break;
        };
        lres = !hr;
        _fModified = TRUE;
    }
        break;

    case WM_PASTE:
    case EM_PASTESPECIAL:
        if(IsntProtectedOrReadOnly(msg, wparam, lparam))
        {
            CTxtSelection *psel = GetSel();

            hr = PasteDataObjectToRange(NULL, psel,
                (CLIPFORMAT) wparam, (REPASTESPECIAL *)lparam, publdr,
                PDOR_NONE);
        }
        break;

    case WM_USER + 38:                  // For backward compat with NT 3.51
    case EM_POSFROMCHAR:                // Has cp input parameter
        // RichEdit 2.x used wparam instead of lparam for the cp and ignored
        // wparam, unlike RE 1.0 and the Win32 documentation (sigh!). We fix
        // this, but are compatible with RE 2.x for cp's whose values
        // correspond to invalid write ptr's.
        if(IsBadWritePtr((LPPOINT)wparam, sizeof(POINT)))
        {
            // Invalid write ptr, so assume incorrect RE 2.0 params
            // TODO: enable following Assert when msgtest gets updated
            //AssertSz(FALSE,
            //  "EM_POSFROMCHAR: wparam is illegal ptr, assuming cp value");
            POINT pt;
            hr = TxPosFromChar((LONG)wparam, &pt);
            lres = SUCCEEDED(hr) ? MAKELONG(pt.x, pt.y) : -1;
        }
        else
            hr = TxPosFromChar((LONG)lparam, (LPPOINT)wparam);
        break;

#ifndef PEGASUS
    case WM_RBUTTONDBLCLK:
    case WM_RBUTTONDOWN:
    case WM_RBUTTONUP:
        // Give client a chance to handle these messages,
        // if we are over a link
        if(HandleLinkNotification(msg, wparam, lparam))
            break;

        if(msg == WM_RBUTTONUP)
            hr = OnTxRButtonUp(MOUSEX, MOUSEY, (WORD) wparam, RB_DEFAULT);

        else if( msg == WM_RBUTTONDOWN)
            hr = OnTxRButtonDown(MOUSEX, MOUSEY, (WORD) wparam);

        break;
#endif

    case EM_REPLACESEL:
        wparam = wparam ? ST_CHECKPROTECTION | ST_SELECTION | ST_KEEPUNDO
                        : ST_CHECKPROTECTION | ST_SELECTION;
        hr = SetText((LPTSTR)lparam, wparam, 1200, publdr, &lres);
        break;

    case EM_REQUESTRESIZE:
        hr = _pdp->RequestResize();
        break;

    case EM_SCROLL:
        // TxVScroll returns the number of lines scrolled;
        // this info should be returned in lres
        lres = TxVScroll((WORD)wparam, 0);
        break;

    case EM_SCROLLCARET:
        OnScrollCaret();
        break;

    case EM_SELECTIONTYPE:
    {
        SELCHANGE selchg;

        GetSel()->SetSelectionInfo(&selchg);
        lres = selchg.seltyp;
    }
        break;

    case EM_SETTYPOGRAPHYOPTIONS:
        // Don't allow typography options for password & accelerator instances
        hr = OnSetTypographyOptions(wparam, lparam);
        lres = (hr == S_OK);
        break;

    case EM_SETBIDIOPTIONS:
        if(lparam && !IsRich())
        {
            WORD wMask = ((BIDIOPTIONS *)lparam)->wMask;
            WORD wEffects = (_fNeutralOverride ? BOE_NEUTRALOVERRIDE : 0) |
                            (_nContextDir   == CTX_NONE ? 0 : BOE_CONTEXTREADING) |
                            (_nContextAlign == CTX_NONE ? 0 : BOE_CONTEXTALIGNMENT);

            wEffects &= ~wMask;
            wEffects |= (wMask & ((BIDIOPTIONS *)lparam)->wEffects);
            if (_fNeutralOverride != !!(wEffects & BOE_NEUTRALOVERRIDE))
            {
                _fNeutralOverride = !_fNeutralOverride;
                if (!_pdp->IsPrinter())             // Refresh display
                {
                    _pdp->InvalidateRecalc();
                    TxInvalidateRect(NULL, FALSE);
                }
            }
            _nContextDir   = (WORD)((wEffects & BOE_CONTEXTREADING)   ? CTX_NEUTRAL : CTX_NONE);
            _nContextAlign = (WORD)((wEffects & BOE_CONTEXTALIGNMENT) ? CTX_NEUTRAL : CTX_NONE);
            if(_nContextDir != CTX_NONE || _nContextAlign != CTX_NONE)
            {
                SetContextDirection(TRUE);
                Assert(_nContextDir != CTX_NONE || _nContextAlign != CTX_NONE);
            }
        }
        break;

    case WM_SETFOCUS:
        hr = OnSetFocus();
        break;

    case EM_SETFONTSIZE:
        lres = OnSetFontSize(LONG(wparam), publdr);
        break;

    case EM_SETMODIFY:
        _fModified = wparam != 0;

#ifdef  LATER
        if (!_fModified)
            ObFreezeFrames();
#endif                      // LATER
        break;

    case EM_SETSCROLLPOS:
        {
            POINT *pPoint = (POINT*)lparam;
            _pdp->ScrollView(pPoint->x, pPoint->y, FALSE, TRUE);
            lres = 1;
        }
        break;

    case EM_EXSETSEL:
        // EM_EXSETSEL duplicates the functionality of the 32-bit EM_SETSEL
        // and exists purely for backward compatibility with Win16. We just
        // repackage the params and fall thru to EM_SETSEL
        wparam = (WPARAM)((CHARRANGE *)lparam)->cpMin;
        lparam = (LPARAM)((CHARRANGE *)lparam)->cpMost;

        // FALL-THROUGH to EM_SETSEL!!!

    case EM_SETSEL:
        lres = OnSetSel((LONG)wparam, (LONG)lparam);
        break;

    // INCREDIBLY EVIL HACK ALERT!!!!!  Win95's dialog manager doesn't even
    // pretend to be 32 bits despite the best attempts of our marketing dudes.
    // WM_USER + 1 is the old Win3.0 EM_SETSEL in which the selection range
    // was packed into the lparam.
    //
    // Sometimes (like tabbing through a dialog), Win95 will send us the 16
    // bit EM_SETSEL message, so process it here.
    case (WM_USER + 1):
        lres = OnSetSel(LOWORD(lparam), HIWORD(lparam));
        break;

    case EM_SETTARGETDEVICE:
        // Keep width sane so that LXtoDX works OK at least for displays
        // Note that 0x7fffff = 485 feet! This keeps LXtoDX working provided
        // _xPerInch < 257 (it's typically 96 for displays). For more
        // generality, we'd need to use 64-bit arithmetic (see LXtoDX).
        lparam = min(lparam, (LPARAM)0x7fffff);
        lres = _pdp->SetMainTargetDC((HDC)wparam, (LONG)lparam);
        break;

    case EM_SETTEXTEX:
        hr = SetText((LPTSTR)lparam, ((SETTEXTEX *)wparam)->flags,
                                     ((SETTEXTEX *)wparam)->codepage, publdr, &lres);
        break;

    case WM_SETTEXT:
        hr = SetText((LPTSTR)lparam, ST_CHECKPROTECTION, wparam ? wparam : 1200, publdr, &lres);
        break;

    case EM_SETWORDBREAKPROC:
        _fExWordBreakProc = 0;
        _pfnWB = (EDITWORDBREAKPROC) lparam;
        break;

    case EM_SETWORDBREAKPROCEX:
        // We don't support this API in 2.0 and greater because we pass
        // UNICODE text to the callback function.  Therefore there
        // are no benefits to this API.  Exists for 1.0 backward
        // compatibility only.
        if (Get10Mode())
        {
            _fExWordBreakProc = 1;

            // This is a bit deceiving, but lparam is a EDITWORDBREAKPROCEX but the compiler
            // will generate an error if you try to type cast the l-value
            _pfnWB = (EDITWORDBREAKPROC) lparam;
        }
        break;


    case WM_SYSCHAR:
        lres = hr = OnTxSysChar((WORD)wparam, (DWORD)lparam, publdr);
        if(hr == S_OK)
            break;
        goto def;

    case WM_SYSKEYUP:
        if(IN_RANGE(VK_SHIFT, wparam, VK_MENU))
            ResetKeyboardFlag(GetKbdFlags((WORD)wparam, (DWORD)lparam));

        if (IN_RANGE(VK_NUMPAD0, wparam, VK_NUMPAD9)  ||
            wparam == VK_CLEAR || wparam == VK_INSERT ||
            IN_RANGE(VK_PRIOR, wparam, VK_DOWN))
        {
            // Collect AltNumPad number to word around NT 4 bug and
            // generalize to any Unicode value (in decimal, ugh!)
            const static BYTE VkeyNumbers[] = {VK_NUMPAD9, VK_NUMPAD3, VK_NUMPAD1,
                VK_NUMPAD7, VK_NUMPAD4, VK_NUMPAD8, VK_NUMPAD6, VK_NUMPAD2, 0, 0,
                0, 0, VK_NUMPAD0};
                                            // Flag Alt NumPad char typed to
            SetKeyboardFlag(ALTNUMPAD);     //  distinguish hiANSI from lead
            if(!IN_RANGE(VK_NUMPAD0, wparam, VK_NUMPAD9)) // byte in Win3.1 IME
            {                               // Collect AltNumPad number
                if(wparam == VK_CLEAR)      // NumLock not active: translate
                    wparam = VK_NUMPAD5;    //  to digit codes
                else
                    wparam = VkeyNumbers[wparam - VK_PRIOR];
            }
            WORD wNum = GetKeyPadNumber();
            if(!wNum && wparam == VK_NUMPAD0)
                SetKeyboardFlag(ALT0);      // Flag that 0 is first digit
            SetKeyPadNumber(10*wNum + wparam - VK_NUMPAD0);
        }
        goto def;

    case WM_SYSKEYDOWN:
        if(OnTxSysKeyDown(wparam, lparam, publdr) == S_OK)
        {
            lres = TRUE;
            break;
        }
        goto def;

    case WM_TIMER:
        OnTxTimer((UINT)wparam);
        goto def;

    case EM_UNDO:
    case WM_UNDO:
        if (_pundo && !_fReadOnly && _fUseUndo)
        {
            hr = PopAndExecuteAntiEvent(_pundo, (void*)wparam);
            if(hr == NOERROR)
                lres = TRUE;
        }
        break;

    case EM_REDO:
        if(_predo && !_fReadOnly && _fUseUndo)
        {
            hr = PopAndExecuteAntiEvent(_predo, (void*)wparam);
            if(hr == NOERROR)
                lres = TRUE;
        }
        break;

    case EM_SETUNDOLIMIT:
        lres = HandleSetUndoLimit((DWORD)wparam);
        break;

    case WM_VSCROLL:
        // TxVScroll returns the number of lines scrolled;
        // WM_VSCROLL doesn't care about that info however.
        Assert(lres == 0);
        Assert(hr == NOERROR);
        TxVScroll(LOWORD(wparam), HIWORD(wparam));
        break;

    // Old stuff that's no longer supported
    case EM_FMTLINES:               // Controls returning CRCRLFs for soft
                                    //  line breaks in EM_GETTEXT. Could
                                    //  implement
    case WM_GETFONT:                // Can support but have to hang onto a
                                    //  default HFONT. CCcs has an _hfont, but
                                    //  need to be sure default font is in
                                    //  cache at time of return
    case EM_GETHANDLE:              // Not supported by Win95 32-bit MLE either
    case EM_SETHANDLE:              // Not supported by Win95 32-bit MLE either
#ifdef DEBUG
        TRACEINFOSZ("Homey don't play dat");
#endif
        break;

    case EM_SETTABSTOPS:
    {
        // this message only works for multi-line edit controls
        if(!_pdp->IsMultiLine())
            break;

        // perform some validation checks
        Assert(lparam || !wparam);
        LPDWORD prgdwdlgCoord = (LPDWORD)lparam;
        if (wparam && (!prgdwdlgCoord || !(*prgdwdlgCoord)))
            break;
        AssertSz(wparam <= MAX_TAB_STOPS, "Tab stop count beyond maximum allowed");
        if (wparam > MAX_TAB_STOPS)
            wparam = MAX_TAB_STOPS;

        PARAFORMAT2 pf;
        ZeroMemory(&pf, sizeof(PARAFORMAT2));
        pf.cbSize = sizeof(PARAFORMAT2);

        // contains the average width for the default font
        LONG lAvgWidth;

        //Average char width based on default font
        HDC hdc = _phost->TxGetDC();
        GetECDefaultHeightAndWidth(this, hdc, 1, 1,
            W32->GetYPerInchScreenDC(), &lAvgWidth, NULL, NULL);
        _phost->TxReleaseDC(hdc);

        Assert(lAvgWidth);

        //According to documenation wparam == 1 means the tab settings
        //will be set at incremental positions *prgdwdlgCoord and wparam == 0
        //the tab settings will be set at the default incremental position 32 (dialog coord)
        long lTab = (wparam) ? *prgdwdlgCoord : 32;
        long nCt = (wparam <= 1) ? MAX_TAB_STOPS : (signed)wparam;
        for (int i = 0; i < nCt; i++)
        {
            long lval;
            lval = (wparam <= 1) ? ((i+1) * lTab) : *prgdwdlgCoord;
            pf.rgxTabs[i] = MulDiv(MulDiv(lval, lAvgWidth, 4), 1440, W32->GetXPerInchScreenDC());
            prgdwdlgCoord++;
        }

        // Set the default paragraph formatting
        pf.cTabCount = nCt;
        pf.dwMask = PFM_TABSTOPS;
        CParaFormat PF;
        PF.Set(&pf);

        // Need to turn off group typing just like the selection would.
        if (publdr)
        {
            publdr->StopGroupTyping();
        }

        lres = OnSetParaFormat(SPF_SETDEFAULT, &PF, publdr, PFM_TABSTOPS | PFM_PARAFORMAT);
        GetTabsCache()->Release(PF._iTabs);
        break;
    }

    case EM_SETCHARFORMAT:
    {
        CHARFORMAT2 *pCF2     = (CHARFORMAT2 *)lparam;
        UINT         CodePage = 1200;
        DWORD        dwMask   = pCF2->dwMask;
        DWORD        dwMask2  = 0;

        if(!IsValidCharFormatW(pCF2))
        {
            if(!IsValidCharFormatA((CHARFORMAT2A *)lparam))
                break;
            if(dwMask & CFM_FACE)           // Need to convert to Unicode
                CodePage = GetDefaultCodePage(EM_SETCHARFORMAT);
        }

        if(Get10Mode() && (dwMask & CFM_SIZE) && (pCF2->yHeight <= 0))
        {
            // 1.0 has a hack where if the height is being set and it is
            // negative, then the height field is ignored.
            dwMask &= ~CFM_SIZE;
        }

        if (pCF2->cbSize == sizeof(CHARFORMATW) ||
            pCF2->cbSize == sizeof(CHARFORMATA))
        {
            // Restrict specifications to CHARFORMAT parameters. If the
            // host isn't our Windows host, we allow this to include the
            // CHARFORMAT2 disabled effect, since Forms^3 wanted that effect
            // but wasn't willing to use CHARFORMAT2 (even tho they asked
            // for it...)
            dwMask &= fInOurHost() ? CFM_ALL : (CFM_ALL | CFM_DISABLED);
            dwMask2 = CFM2_CHARFORMAT;      // Tell callees that CHARFORMAT
        }                                   //  was used

        CCharFormat CF;                     // Transfer external CHARFORMAT(2)
        CF.Set(pCF2, CodePage);             //  parms to internal CCharFormat
        lres = OnSetCharFormat(wparam, &CF, publdr, dwMask, dwMask2);
        break;
    }
    case WM_SETFONT:
        lres = OnSetFont((HFONT)wparam);
        break;

    case EM_SETPARAFORMAT:
    {
        PARAFORMAT2 *pPF2 = (PARAFORMAT2 *)lparam;

        if(!IsValidParaFormat(pPF2))
            break;

        DWORD dwMask = pPF2->dwMask;

        // Two more things to validate: (1) We don't let an applications set
        // up tables and (2) Tabs coming from applications must be valid.
        if (dwMask & (PFM_TABLE | PFM_OUTLINELEVEL | PFM_COLLAPSED))
        {
            // Trying to set up a table or outline view
            break;
        }

        if ((dwMask & PFM_TABSTOPS) && (pPF2->cTabCount != 0))
        {
            // Make sure all submitted tabstops make sense.
            int iMax = min(MAX_TAB_STOPS, pPF2->cTabCount);

            for (int i = 0; i < iMax; i++)
            {
                // Make sure that tab stops make sense - make sure alignment
                // is valid.
                if (GetTabAlign(pPF2->rgxTabs[i]) > tomAlignBar)
                {
                    // Invalid alignment.
                    break;
                }
            }

            if (i != iMax)
            {
                // Found error in validation loop so we are done.
                break;
            }
        }

        if(pPF2->cbSize == sizeof(PARAFORMAT))
        {
            dwMask &= PFM_ALL;              // Restrict to PARAFORMAT parms
            dwMask |= PFM_PARAFORMAT;       // Tell callees that PARAFORMAT
        }                                   //  was used

        CParaFormat PF;                     // Transfer external PARAFORMAT(2)
        PF.Set(pPF2);                       //  parms to internal CParaFormat
        lres = OnSetParaFormat(wparam, &PF, publdr, dwMask);
        GetTabsCache()->Release(PF._iTabs);
        break;
    }

    case EM_SETZOOM:
        if ((unsigned)(wparam | lparam) < 65536 && (!(wparam | lparam) ||
             (LONG)wparam < (lparam << 6) && lparam < (LONG)(wparam << 6)))
        {
            // Only get here if
            // 1) 0 <= wparam <= 65535 and 0 <= lparam <= 65535, and
            // 2) either wparam = lparam = 0 (which turns off zooming by this
            // message) or 1/64 < (zoom factor given by wparam/lparam) < 64.
            SetZoomNumerator(wparam);
            SetZoomDenominator(lparam);
            _pdp->UpdateView();
            lres = 1;
        }
        break;

    case EM_STREAMIN:
    case EM_STREAMOUT:
    {
        CTxtRange   rg(this, 0, -GetTextLength());
        CTxtRange * prg = &rg;              // Default whole doc

        wparam = W32->ValidateStreamWparam(wparam);
        if(wparam & SFF_SELECTION)          // Save to current selection
        {
            prg = (CTxtRange *)GetSel();
            AssertSz(prg,
                "EM_STREAMIN/OUT: requested selection doesn't exist");
        }
        else
        {
            // If we are not streaming into the selection, then we are
            // "loading" the entire file; this is not an undo-able operation,
            // so set the undo builder to NULL and get rid of the current
            // undo stacks
            publdr = NULL;
            ClearUndo(&undobldr);
            if(msg == EM_STREAMIN)
            {
                // Clear away the file info if necessary
                if(!(wparam & SFF_KEEPDOCINFO))
                    CloseFile(FALSE);
            }
        }

        if(msg == EM_STREAMIN)
        {
            // If we are going to be loading an entire file, we only
            // want to check "normal' protection; we can ignore the
            // fIsDBCS protection.  This does mean that somebody
            // can do an "insert file" and break apart a DBCS combo,
            // but we'll have to live with that.  Outlook uses
            // RTF streaming in many different places, so the strong
            // fIsDBCS protection breaks them.
            if ((_dwEventMask & ENM_PROTECTED) &&
                prg->IsProtected(0) == CTxtRange::PROTECTED_ASK &&
                QueryUseProtection(prg, msg, wparam, lparam))
            {
                Beep();
                Assert(lres == 0);
                break;
            }

            // Freeze the display before loading
            CFreezeDisplay fd(_pdp);

            lres = _ldte.LoadFromEs(prg, wparam, (EDITSTREAM *)lparam,
                                    FALSE, publdr);

            if (_fOutlineView)
            {
                // Outline view must have formatting.
                _psel->Check_rpPF();
            }

            if (_fFocus)
            {
                // Update caret but delay till display is thawed and do so only
                // if we have the focus. If we do this all the time we get wierd
                // scrolling effects such as scrolling to the beginning of a
                // document when the focus is set. See bug #1649 for repro of
                // wierd effects.
                _pdp->SaveUpdateCaret(TRUE);
            }
        }
        else
            lres = _ldte.SaveToEs  (prg, wparam, (EDITSTREAM *)lparam);
        break;
    }

#ifndef PEGASUS
    case WM_SYSCOLORCHANGE:
        TxInvalidateRect(NULL, FALSE);
        break;
#endif

    // debug stuff
#ifdef DEBUG
    case EM_DBGPED:
        OnDumpPed();
        break;
#endif                  // DEBUG

    case EM_SETEVENTMASK:
        lres = _dwEventMask;                // Set up to return value before
        _dwEventMask = (DWORD)lparam;       //  the change

        if (lparam & ENM_REQUESTRESIZE)
        {
            // We need to update the display just in case it changes.
            _pdp->UpdateView();
        }
        break;

    case EM_GETEVENTMASK:
        lres = _dwEventMask;
        break;

    case EM_GETTHUMB:
        LONG Pos;
        BOOL fIsEnabled;

        if (TxGetVScroll(NULL, NULL, &Pos, NULL, &fIsEnabled) == S_OK
            && fIsEnabled)
        {
            lres = Pos;
        }
        break;

    case EM_SETLANGOPTIONS:
        _fAutoFont           = (lparam & IMF_AUTOFONT) != 0;
        _fAutoKeyboard       = (lparam & IMF_AUTOKEYBOARD) != 0;
        _fAutoFontSizeAdjust = (lparam & IMF_AUTOFONTSIZEADJUST) != 0;
        _fDualFont           = (lparam & IMF_DUALFONT) != 0;
        _fUIFont             = (lparam & IMF_UIFONTS) != 0;
        lres = 1;
        break;

    case EM_GETLANGOPTIONS:
        if(_fAutoFont)
            lres |= IMF_AUTOFONT;
        if(_fAutoKeyboard)
            lres |= IMF_AUTOKEYBOARD;
        if(_fAutoFontSizeAdjust)
            lres |= IMF_AUTOFONTSIZEADJUST;
        if(_fDualFont)
            lres |= IMF_DUALFONT;
        if(_fUIFont)
            lres |= IMF_UIFONTS;
        break;

    case EM_SETEDITSTYLE:
        if (!Get10Mode())   // Not support in 1.0 mode
        {
            DWORD dwEditStyle = _bEditStyle & ~lparam;  // Kill current flag values
            dwEditStyle |= wparam & lparam;             // Or in new values

            // Certain bits aren't switchable
            dwEditStyle |= ((_fSystemEditMode) ? SES_EMULATESYSEDIT : 0);
            _bEditStyle = (WORD)dwEditStyle;

            // There are certain things which we won't allow user to reset, ie SES_EMULATESYSEDIT.
            // So reset everything and except for the SES_EMULATESYSEDIT
            if(wparam & SES_EMULATESYSEDIT)
            {
                if(SUCCEEDED(HandleSetTextMode(TM_SINGLELEVELUNDO | TM_PLAINTEXT)))
                {
                    // SES_EMULATESYSEDIT implies SES_BEEPONMAXTEXT
                    _fSystemEditBeep = TRUE;
                }
                else
                    _fSystemEditMode = FALSE;
            }

            if(wparam & SES_BIDI)
                OrCharFlags(fBIDI, publdr);

            _fLowerCase = !_fUpperCase && (dwEditStyle & SES_LOWERCASE);

        }                                           // Fall thru to EM_GETEDITSTYLE
                                                    //  to return _bEditStyle
    case EM_GETEDITSTYLE:
        if (!Get10Mode())   // Not support in 1.0 mode
            lres |= _bEditStyle;    // Some EditStyles have been filled in Cmsgflt
        break;

    case EM_SETTEXTMODE:
        // 1.0 mode does not supported EM_SETTEXTMODE
        if (!Get10Mode())
            lres = HandleSetTextMode(wparam);
        break;

    case EM_GETTEXTMODE:
        lres = IsRich() ? TM_RICHTEXT : TM_PLAINTEXT;

        lres |= (_pundo && ((CUndoStack *)_pundo)->GetSingleLevelMode())
             ? TM_SINGLELEVELUNDO : TM_MULTILEVELUNDO;

        lres |= _fSingleCodePage ? TM_SINGLECODEPAGE : TM_MULTICODEPAGE;
        break;

    case EM_LIMITTEXT:
        lparam = wparam;

        // Intentionally fall through. These messages are duplicates.

    case EM_EXLIMITTEXT:                    // Has cp input parameter (sort of)
        if(!lparam)                         // We ignore translation between
        {                                   //  acp and cp
            // 0 means set the control to the maximum size. However, because
            // 1.0 set this to 64K will keep this the same value so as not to
            // surprise anyone. Apps are free to set the value to be above 64K.
            lparam = (LPARAM)cResetTextMax;
        }
        if (Get10Mode())
        {
            // 1.0 used a signed variable to hold the length of the string.  So
            // if lparam is negative then just set lparam to zero to emulate
            // 1.0 behavior
            if ((LONG)lparam < 0)
                lparam = 0;
        }
        _cchTextMost = (LONG)lparam;
        break;

    case EM_AUTOURLDETECT:
//      if(!_fRich)
//          hr = lres = E_FAIL;

        if(lparam || (wparam | 1) != 1)
        {
            hr = lres = E_INVALIDARG;
            break;
        }
        if(wparam == TRUE && !_pdetecturl)
        {
            _pdetecturl = new CDetectURL(this);
            if(!_pdetecturl)
                hr = lres = E_OUTOFMEMORY;
        }
        else if(!wparam && _pdetecturl)
        {
            delete _pdetecturl;
            _pdetecturl = NULL;
        }
        break;

    case EM_GETAUTOURLDETECT:
        Assert(lres == 0 && hr == NOERROR);
        if(_pdetecturl)
            lres = TRUE;
        break;

    case WM_SIZE:
        // We reset the "number of tries to put an active object
        // in place" count here
        _cActiveObjPosTries = MAX_ACTIVE_OBJ_POS_TRIES;
        hr = S_FALSE;
        break;

    case WM_SETTINGCHANGE:
        // System parameters have changed.  We need to update them.
        // Note : Since we don't protect access to system parameters
        // with locks, it may be possible for some instances to not
        // see the changes immediately
        lres = 0;
        W32->InitSysParams(TRUE);

        if (W32->GetDigitSubstitutionMode() != DIGITS_NOTIMPL)
            OrCharFlags(fDIGITSHAPE, publdr);

        break;

    case EM_CONVPOSITION:
        if (wparam)
            lres = GetCpFromAcp(lparam);
        else
            lres = GetAcpFromCp(lparam);
        break;

#ifndef NOACCESSIBILITY
    case WM_GETOBJECT:
        // We need to expose the TOM interface for Accessibility by
        // calling LresultFromObject when lparam == OBJID_NATIVEOM
        if (lparam == OBJID_NATIVEOM)
        {
            IUnknown* punk;
            QueryInterface(IID_IUnknown, (void**)&punk);
            Assert(punk);
            lres = W32->LResultFromObject(IID_IUnknown, wparam, (LPUNKNOWN)punk);
            punk->Release();
            break;
        }
#endif

    default:
def:    hr = S_FALSE;
        break;
    }

    if(plresult)
        *plresult = lres;

    // TODO: FOR TESTING AIMM
    if (hr == S_FALSE && fHaveAIMM)
    {
        HWND hWnd;

        TxGetWindow(&hWnd);
        hr = CallAIMMDefaultWndProc(hWnd, msg, wparam, lparam, plresult);
    }
    return hr;
}

/*
 *  CTxtEdit::TxDraw (dwDrawAspect, lindex, pvAspect, ptd, hdcDraw,
 *                    hicTargetDev, lprcBounds, lprcWBounds, lprcUpdate,
 *                    pfnContinue, dwContinue)
 *
 *  @mfunc  Draws the text services object
 *
 *  @rdesc  HRESULT (typically S_OK).
 *
 *  @comm
 *
 *  This method renders the Text Services. It accepts the same parameters
 *  as the corresponding IViewObject::Draw method in OLE, with the extra
 *  <p lprcUpdate > parameter. It can be used while the host is inactive
 *  or active (in-place).
 *
 *  If dwDrawAspect is DVASPECT_CONTENT, this method should render a screen
 *  image of the text content to the hdcDraw device context. The hicTargetDev
 *  and ptd parameters give information on the target device context if any
 *  (usually a printer).
 *
 *  The lprcClient parameter gives the rectangle to render to, also called
 *  "client rectangle". This rectangle represents the position and extents
 *  of the entire image of the Text Services to be drawn. It is expressed in
 *  the logical coordinate system of hdcDraw. This parameter can only be NULL
 *  if the control is active. In that case, Text Services should render the
 *  in-place active view (which client rectangle can be obtained by calling
 *  TxGetClientRect on the host).
 *
 *  The lprcUpdate parameter, if not NULL, gives the rectangle to update
 *  inside that client rectangle. It is given in the logical coordinate system
 *  of hdcDraw. If NULL, the entire client rectangle should be painted.
 *
 *  Text Services should render with the appropriate zooming factor, which
 *  can be obtained from the client rect and the native size given by
 *  ITextHost::TxGetExtent. For more information, see ITextHost::TxGetExtent.
 *
 *  If the drawing aspect is DVASPECT_DOCPRINT, the TxDraw method can assume
 *  that it is rendering to the printer. In that case, hdcDraw is the printer
 *  device context. TxDraw should still render the lprcBounds rectangle,
 *  starting at the current scrolling position. TS can make optimization for
 *  rendering to the printer (like not painting the background color if white)
 *  and certain screen specific elements (such as the selection) should not be
 *  rendered.
 *
 *  General comments on OLE hosts and TxDraw (and TxSetCursor, TxQueryHitPoint):
 *
 *  OLE hosts can call the TxDraw method at any time with any rendering DC or
 *  client rectangle. All an inactive OLE object has on a permanent basis is
 *  a himetric extent. It gets the rectangle in which to render only via the
 *  IViewObject::Draw call and this rectangle is valid only for the scope of
 *  that method. In fact, the same control can be rendered consecutively in
 *  different rectangles and different DCs for example because it is displayed
 *  simultaneously in different views on the screen.
 *
 *  The client rectangle and DC passed to TxDraw should normally not be cached.
 *  However, this would force Text Services to recalc lines for every single
 *  draw, which would lead to terrible performance. So it is likely that Text
 *  Services will actually cache some information computed for a specific
 *  client rectangle and DC (such as the line breaks for example). On the
 *  next call to TxDraw, however, the validity of the cached information
 *  should be checked before it gets used, and updated information should be
 *  regenerated if necessary.
 *
 *  When the control is in-place active, the problem is even more complex
 *  since TxDraw can still be called to render other views than the in-place
 *  active one. In other words, the client rectangle passed to TxDraw may
 *  not be the same as the active view one (passed to OnTxInPlaceActivate
 *  and obtained via TxGetClientRect on the host).The the host specifies
 *  what view they wish to display based on the lViewId parameter. If the
 *  value for lViewId is TXTVIEW_ACTIVE, the view referred to is the inplace
 *  active view. TXTVIEW_INACTIVE means some other view such as a print
 *  preview or even printing itself. It is important to note that
 *  TXTVIEW_INACTIVE views may not have scroll bars.
 *
 *  The same comments apply to TxSetCursor and TxQueryHitPoint, discussed
 *  in the following sections.
 */
HRESULT CTxtEdit::TxDraw(
    DWORD    dwDrawAspect,  //@parm Draw aspect
    LONG     lindex,        //@parm Currently unused
    void *   pvAspect,      //@parm Info for drawing optimizations (OCX 96)
    DVTARGETDEVICE *ptd,    //@parm Info on target device
    HDC      hdcDraw,       //@parm Rendering device context
    HDC      hicTargetDev,  //@parm Target information context
    LPCRECTL lprcBounds,    //@parm Bounding (client) rectangle
    LPCRECTL lprcWBounds,   //@parm Clipping rect for metafiles
    LPRECT   lprcUpdate,    //@parm Dirty rectangle inside lprcBounds
    BOOL (CALLBACK * pfnContinue) (DWORD), //@parm Callback for interupting
                            //      long display (currently unused)
    DWORD    dwContinue,    //@parm Parameter to pass to pfnContinue function
    LONG     lViewId)       //@parm View identifier
{
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::TxDraw");

    HRESULT hr;

	// JMO : FUTURE : We should do sometning about reentrant draws sometime.
	// If we do that may procide a simpler fix for RAID bug 7212.

#if !defined(NOMAGELLAN)
    CMagellanBMPStateWrap bmpOff(*this, hdcDraw);
#endif

    // These are rect's are used if we convert the the input parameters if we
    // convert the HDC's mapping mode. The idea here is we avoid changing our
    // clients memory.
    RECTL rcLocalBounds;
    RECTL rcLocalWBounds;
    RECT rcLocalUpdate;
    CCallMgr callmgr(this);

    START_PROFILING

    // If the display is frozen, don't let ourselves draw.  This is a pretty
    // hoaky re-entrancy check.
    // FUTURE (alexgo/ricksa): be better about this.
    if(TXTVIEW_ACTIVE == lViewId && _pdp->IsFrozen())
    {
        _pdp->SetNeedRedisplayOnThaw(TRUE);
        TRACEINFOSZ("Forcing a redisplay on thaw");
        return E_UNEXPECTED;
    }

    if(dwDrawAspect != DVASPECT_CONTENT && dwDrawAspect != DVASPECT_DOCPRINT)
    {
        // We don't support the aspect requested
        return DV_E_DVASPECT;
    }

    if(!lprcBounds && !_fInPlaceActive || hicTargetDev && !ptd)
    {
        // If we are not inplace active we must have a client rectangle
        return E_INVALIDARG;
    }

    HDC hicLocal = NULL;

    // Did they give us a ptd without a hic?
    if(!hicTargetDev && ptd)
    {
        // Create and information context for the device information
        // since it wasn't supplied.
        hicLocal = CreateIC(
            (TCHAR *)((BYTE *) ptd + ptd->tdDriverNameOffset),
            (TCHAR *)((BYTE *) ptd + ptd->tdDeviceNameOffset),
            (TCHAR *)((BYTE *) ptd + ptd->tdPortNameOffset),
            (DEVMODE *)((BYTE *)  ptd + ptd->tdExtDevmodeOffset));
        if(!hicLocal)
            return E_FAIL;                     // Couldn't create it

        hicTargetDev = hicLocal;
    }

    BOOL fRestore = FALSE;

    // Force DC in MM_TEXT
    if(GetMapMode(hdcDraw) != MM_TEXT &&
       GetDeviceCaps(hdcDraw, TECHNOLOGY) != DT_METAFILE)
    {
        fRestore = TRUE;

        // Convert input parameters to new mapping.
        if(lprcBounds)
        {
            rcLocalBounds = *lprcBounds;
            lprcBounds = &rcLocalBounds;
            WinLPtoDP(hdcDraw, (POINT *)lprcBounds, 2);
        }

        if(lprcWBounds)
        {
            rcLocalWBounds = *lprcWBounds;
            lprcWBounds = &rcLocalWBounds;
            WinLPtoDP(hdcDraw, (POINT *)lprcWBounds, 2);
        }

        if(lprcUpdate)
        {
            rcLocalUpdate = *lprcUpdate;
            lprcUpdate = &rcLocalUpdate;
            WinLPtoDP(hdcDraw, (POINT *)lprcUpdate, 2);
        }
        // Convert HDC to new mapping
        ConvertDrawDCMapping(hdcDraw);
    }

    // Preallocate the memory so the set cannnot fail and we don't
    // have to use the heap. Note that all clean up is handled
    // outside of this object. Also note that we don't assign any
    // information here because we may not use this structure. If
    // recursion is happening we will use the top level structure.
    CDrawInfo di(this);

    _pdp->SetDrawInfo(
        &di,
        dwDrawAspect,
        lindex,
        pvAspect,
        ptd,
        hicTargetDev);

    // We use our main display object if we are the active view (which is
    // indicate by the supplied client rectangle) or if the object is
    // inactive and the ptd is NULL. We assume that the ptd being NULL means
    // that the display request is for the screen and not for a print or
    // print preview.
    if(TXTVIEW_ACTIVE == lViewId || !ptd)
    {
        hr = S_FALSE;

        // The main display object draws active views and tries to draw
        // inactive views if the control is not active.
        if (!lprcWBounds &&
            ( fInplaceActive() && TXTVIEW_ACTIVE   == lViewId ||
             !fInplaceActive() && TXTVIEW_INACTIVE == lViewId))
        {
            hr = _pdp->Draw(hdcDraw, hicTargetDev,  // We aren't interruptable
                (RECT *)lprcBounds,                 //  drawing to screen, so
                (RECT *)lprcWBounds,                //  why pretend?
                lprcUpdate, NULL, 0);
        }

        if(S_FALSE == hr)
        {
            // This is an inactive view for which the cached state
            // does not match the input request so we make a special
            // object to do the drawing.
            CDisplay *pdp = _pdp->Clone();
            if(pdp)
            {
                // Force recalc - this tells Draw to draw no matter what
                pdp->InvalidateRecalc();
                hr = pdp->Draw(hdcDraw, hicTargetDev, // Do the draw
                    (RECT *)lprcBounds,
                    (RECT *)lprcWBounds,
                    lprcUpdate, NULL, 0);
            }
            delete pdp;
        }
    }
    else
    {
        // Make a copy so that we can update it
        RECT rcForPrint = *((RECT *)lprcBounds);

        // We want data both formatted and printed
        hr = FormatAndPrint(hdcDraw, hicTargetDev, ptd, &rcForPrint,
                (RECT*)lprcWBounds);

        struct SPrintControl prtcon;

        // This call to OnFormatRange simply cleans up printer object
        OnFormatRange(NULL, prtcon);
    }

    _pdp->ReleaseDrawInfo();

    if(fRestore)                        // Put DC back into correct mapping mode
        RestoreDC(hdcDraw, -1);

    if(hicLocal)                        // Clean up information context
        DeleteDC(hicLocal);             //  if we created one

    // An active OLE object might have been dragged/scrolled away
    // from where it belongs. We need to put it back.
    // The _cActiveObjPosTries guards us from an indefinite looop here
    // (OnReposition may post another paint message, and so on)
    // We only do this when we were notified of a position or size change
    COleObject* poleobjActive;
    if (HasObjects() && _cActiveObjPosTries &&
        (poleobjActive = GetObjectMgr()->GetInPlaceActiveObject()))
    {
        // Reduce number of tries
        _cActiveObjPosTries--;

        // BUG FIX 6073
        // Only fetch the extent if the object view size or position
        // has changed
        // Get new object size (we might have resized it,
        // and we don't want to lose that!!)
        if (poleobjActive->GetViewChanged())
        {
            poleobjActive->FetchObjectExtents();
            poleobjActive->ResetViewChanged();
        }


        // Get right coordinates for object
        poleobjActive->ResetPosRect();

        // and put it there!!
        poleobjActive->OnReposition(0, 0);
    }
    return hr;
}

/*
 *  CTxtEdit::TxGetHScroll (plMin, plMax, plPos, plPage, pfEnabled)
 *
 *  @mfunc
 *      Get horizontal scroll bar state information
 *
 *  @rdesc
 *      HRESULT = S_OK
 */
HRESULT CTxtEdit::TxGetHScroll(
    LONG *plMin,        //@parm Minimum scroll position
    LONG *plMax,        //@parm Maximum scroll position
    LONG *plPos,        //@parm Current scroll position
    LONG *plPage,       //@parm View width in pixels
    BOOL *pfEnabled)    //@parm Whether horizonatl scrolling is enabled.
{
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::TxGetHScroll");

    START_PROFILING

    if(plMin)
        *plMin = 0;

    if(plMax)
        *plMax = _pdp->GetScrollRange(SB_HORZ);

    if(plPos)
        *plPos = _pdp->GetXScroll();

    if(plPage)
        *plPage = _pdp->GetViewWidth();

    // CDisplay::_fHScrollEnabled may be TRUE when not in-place active
    // because it has a dual meaning: 1) need Horiz scroll bars, and 2)
    // CDisplay::_xScroll is allowed for ES_AUTOHSCROLL even with no
    // horizontal scrollbar.  The latter can turn on _fHScrollEnabled when
    // the control is active and when the control goes inactive, it stays
    // on, so we say it's off to keep Forms^3 from displaying a horizontal
    // scroll bar. We probably should have two flags: _fHScrollEnabled and
    // _fHScrollbarEnabled, but for now, we stick with one.  No such problem
    // for vertical case, since vertical scrolling always uses a scrollbar.
    if(pfEnabled)
        *pfEnabled = _fInPlaceActive ? _pdp->IsHScrollEnabled() : 0;

    return S_OK;
}

/*
 *  CTxtEdit::TxGetVScroll (plMin, plMax, plPos, plPage, pfEnabled)
 *
 *  @mfunc
 *      Get vertical scroll bar state information
 *
 *  @rdesc
 *      HRESULT = S_OK
 */
HRESULT CTxtEdit::TxGetVScroll(
    LONG *plMin,        //@parm Minimum scroll position
    LONG *plMax,        //@parm Maximum scroll position
    LONG *plPos,        //@parm Current scroll position
    LONG *plPage,       //@parm Height of view in pixels
    BOOL *pfEnabled)    //@parm Whether vertical scroll bar is enabled.
{
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::TxGetVScroll");

    if(plMin)
        *plMin = 0;

    if(plMax)
        *plMax = _pdp->GetScrollRange(SB_VERT);

    if(plPos)
    {
        *plPos = _pdp->GetYScroll();
        *plPos = _pdp->ConvertYPosToScrollPos(*plPos);
    }

    if(plPage)
    {
        *plPage = _pdp->GetViewHeight();
        *plPage = _pdp->ConvertYPosToScrollPos(*plPage);
    }

    if(pfEnabled)
        *pfEnabled = _pdp->IsVScrollEnabled();

    return S_OK;
}

/*
 *  CTxtEdit::OnTxSetCursor (dwDrawAspect, lindex, pvAspect, ptd, hdcDraw,
 *                           hicTargetDev, lprcClient, x, y)
 *  @mfunc
 *      Notification for text services to set the cursor
 *
 *  @rdesc
 *      HRESULT = FAILED(RectChangeHelper()) ? E_INVALIDARG : S_OK
 *
 *  @comm
 *      Text Services may remeasure as a result of this call in
 *      order to determine the correct cursor.  The correct
 *      cursor will be set via ITextHost::TxSetCursor
 *
 *      More details:
 *
 *      The lprcClient parameter is the client rectangle of the view of the
 *      control over which the mouse cursor is. It is in device coordinates
 *      of the containing window in the same way the WM_SIZE message is. This
 *      may not be the view that was rendered last. Furthermore, if the control
 *      is in-place active, this may not be the view currently being active.
 *      As a consequence, Text Services should check this rectangle against
 *      its current caches values and determine whether recalcing the lines
 *      is necessary or not. The zoom factor should be included in this
 *      computation.
 *
 *      This method should only be called for screen views of the control.
 *      Therefore the DC is not passed in but should be assumed to be a screen
 *      DC.
 *
 *      The x and y parameters hold the cursor position in the same coordinate
 *      system as lprcClient, i.e., the client coordinates of the containing
 *      window.
 */
HRESULT CTxtEdit::OnTxSetCursor (
    DWORD   dwDrawAspect,   //@parm Draw aspect
    LONG    lindex,         //@parm Currently unused
    void *  pvAspect,       //@parm Info for drawing optimizations (OCX 96)
    DVTARGETDEVICE *ptd,    //@parm Info on target device
    HDC     hdcDraw,        //@parm Rendering device context
    HDC     hicTargetDev,   //@parm Target information context
    LPCRECT lprcClient,     //@parm Control's client rectangle
    INT     x,              //@parm x position of cursor
    INT     y)              //@parm y position of cursor
{
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::OnTxSetCursor");

    CCallMgr callmgr(this);
    BOOL     fText = FALSE;
    HITTEST  Hit;
    RECT     rcClient;
    CDrawInfo di(this);
    START_PROFILING

    if(FAILED(RectChangeHelper(&di, dwDrawAspect, lindex, pvAspect, ptd,
                               hdcDraw, hicTargetDev, &lprcClient, &rcClient)))
    {
        return E_INVALIDARG;
    }

    // Set the cursor
    CTxtSelection * const psel = GetSel();
    HCURSOR hcurNew = _hcurArrow;           // Default using system arrow
    POINT   pt = {x, y};
    BOOL    fInLink = FALSE;

    if(PtInRect(&rcClient, pt))
    {
        // Find out what the cursor is pointing at
        _pdp->CpFromPoint(pt, lprcClient, NULL, NULL, FALSE, &Hit);

        if(Hit == HT_LeftOfText)
            hcurNew = _hcurSelBar;

        // This is a bit strange, but RichEdit 1.0 does this--give client a
        // chance to handle cursor itself if we are over a link.
        else if(Hit == HT_Link)
        {
            if(HandleLinkNotification(WM_SETCURSOR, 0,
                MAKELPARAM(pt.x, pt.y), &fInLink))
            {
                return NOERROR;
            }
            hcurNew = _hcurHand;
        }
        else if(Hit != HT_Nothing && Hit != HT_OutlineSymbol && Hit != HT_BulletArea)
        {
            if(!psel || !psel->PointInSel(pt, lprcClient) || _fDisableDrag)
            {
                hcurNew = (Hit == HT_Italic) ? _hcurItalic : _hcurIBeam;
                fText = TRUE;
            }

            // If we have an object manager and if there is a selected object,
            // check for hits on the frame handles.
            if(_pobjmgr)
            {
                COleObject *pobjselect = _pobjmgr->GetSingleSelect();
                if(pobjselect)
                {
                    // Handle hits on frame handles.
                    LPTSTR  idcur   = pobjselect->CheckForHandleHit(pt);
                    HCURSOR hcurObj = W32->GetSizeCursor(idcur);
                    if(hcurObj)
                        hcurNew = hcurObj;
                }
            }
        }
    }
    _phost->TxSetCursor(hcurNew, fText);    // Tell host to set cursor
    if(hdcDraw)                             // Release DC if we got it
        _pdp->ResetDC();

    _pdp->ReleaseDrawInfo();
    return S_OK;
}

/*
 *  CTxtEdit::TxQueryHitPoint (dwDrawAspect, lindex, pvAspect, ptd, hdcDraw,
 *                              hicTargetDev, lprcClient, x, y, pHitResult)
 *  @mfunc
 *      Returns whether point is within text services rectangle
 *
 *  @rdesc
 *      HRESULT
 *
 *  @comm
 *      This method allows the host to implement transparent hit-testing
 *      on text.
 *
 *      The lprcClient parameter is the client rectangle in device coordinates
 *      of the view on which hit testing is performed.
 *
 *      The pt parameter hold the position of the cursor in the same
 *      coordinate system as the lprcClient rectangle (the client
 *      coordinates of the containing window).
 *
 *      Same general comments about client rectangle and DC as for
 *      TxSetCursor apply.
 *
 *      pHitResult returns one of the following values: <nl>
 *
 *      TXTHITRESULT_NOHIT       Hit was outside client rectangle. <nl>
 *      TXTHITRESULT_HIT         Point was inside client rectangle and over
 *                               either text or an opaque background.
 *      TXTHITRESULT_TRANSPARENT Point was inside client rectangle with a
 *                               transparent background and not over text.
 *      TXTHITRESULT_CLOSE       Hit was close to an opaque area.
 *
 *      Refer to the Windowless OLE Control spec for more details on
 *      these return values and how they should be determined.
 */
HRESULT CTxtEdit::TxQueryHitPoint(
    DWORD   dwDrawAspect,   //@parm Draw aspect
    LONG    lindex,         //@parm Currently unused
    void *  pvAspect,       //@parm Info for drawing optimizations (OCX 96)
    DVTARGETDEVICE *ptd,    //@parm Info on target device
    HDC     hdcDraw,        //@parm Rendering device context
    HDC     hicTargetDev,   //@parm Target information context
    LPCRECT lprcClient,     //@parm Control's client rectangle
    INT     x,              //@parm x coordinate to check
    INT     y,              //@parm y coordinate to check
    DWORD * pHitResult)     //@parm Result of hit test see TXTHITRESULT
                            //      enumeration for valid values
{
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::TxQueryHitPoint");

    RECT     rcClient;
    CCallMgr callmgr(this);
    CDrawInfo di(this);

    START_PROFILING

    if (FAILED(RectChangeHelper(&di, dwDrawAspect, lindex, pvAspect, ptd,
        hdcDraw, hicTargetDev, &lprcClient, &rcClient)))
    {
        return E_INVALIDARG;
    }

    HRESULT hr;
    POINT   pt = {x, y};

    if(!_fTransparent)
    {
        *pHitResult = TXTHITRESULT_HIT;
        hr = S_OK;
    }
    else
        hr = _pdp->TransparentHitTest(hdcDraw, lprcClient, pt, pHitResult);

    // Release DC if we got it
    if(hdcDraw)
        _pdp->ResetDC();

    _pdp->ReleaseDrawInfo();
    return hr;
}

/*
 *  CTxtEdit::OnTxInPlaceActivate (prcClient)
 *
 *  @mfunc
 *      Notifies text services that this control is inplace active
 *
 *  @rdesc
 *      S_OK - successfully activated object <nl>
 *      E_FAIL - could not activate object due to error. <nl>
 *
 *  @comm
 *      When transitioning directly from a non-active state to the UI-active
 *      state, the host should call OnTxInPlaceActivate first and then
 *      OnTxUIActivate. Similarly, when transitioning from the UI-active
 *      state to a non active state, the host should call OnTxUIDeactivate
 *      first and then OnTxInPlaceDeactivate.
 *
 *      OnTxInPlaceActivate takes the client rectangle of the view being
 *      activated as a parameter. This rectangle is given in client coordinate
 *      of the containing window. It is the same as would be obtained by
 *      calling TxGetClientRect on the host.
 *
 *      UI-activation is different from getting the focus. To let Text
 *      Services know that the control is getting or losing focus, the
 *      host will send WM_SETFOCUS and WM_KILLFOCUS messages. Note that a
 *      windowless host will pass NULL as the wParam (window that lost the
 *      focus) for these messages.
 *
 *      As a reminder, inplace activation typically refers to an embedded
 *      object "running inplace" (for regular controls && embeddings, it
 *      would have a window to draw in, for example).  UI active means that
 *      an object currently has the 'editing focus'.  Specifically, things
 *      like menus and toolbars on the container may also contain elements
 *      from the UI active control/embedding.  There can only be one
 *      UI active control at any given time, while many can be inplace active
 *      at once.
 */
HRESULT CTxtEdit::OnTxInPlaceActivate(
    const RECT *prcClient)  //@parm Control's client rectangle
{
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::OnTxInPlaceActivate");

    RECT rcView;
    HDC hdc;
    BOOL fSucceeded = TRUE;
    CCallMgr callmgr(this);

    START_PROFILING

    // Needs to set here for further TxGetDC() to work
    _fInPlaceActive = TRUE;

    // Set rendering DC to be the screen
    hdc = TxGetDC();
    if(!hdc)
        goto err;

    // Tell display that it is active
    _pdp->SetActiveFlag(TRUE);
    _pdp->SetDC(hdc);

    // Compute view rect from passsed in client rect
    _pdp->GetViewRect(rcView, prcClient);

    // Recalc/update view
    _pdp->RecalcView(rcView);

    // Get selection.  Otherwise, if SetFocus is called later without
    // selection, then the Selection state is not set correctly.
    GetSel();
    if(_pdp->GetViewWidth())
    {
        // Get selection if we can
        if(_psel)                       // Set the caret
            _psel->Update(FALSE);
        else                            // Couldn't create selection,
            fSucceeded = FALSE;         //  so fail activation
    }

    // Release the DC
    TxReleaseDC(hdc);
    _pdp->SetDC(NULL);

    // If getting the selection worked we are home free
    if(fSucceeded)
        return S_OK;

err:
    _fInPlaceActive = FALSE;
    return E_FAIL;
}

/*
 *  CTxtEdit::OnTxInPlaceDeactivate()
 *
 *  @mfunc  Notifies text services that this is no longer in place active.
 *
 *  @rdesc  S_OK
 *
 *  @comm   See OnTxInPlaceActivate for a detailed description of
 *  activation/deactivation.
 *
 *  @xref <mf CTxtEdit::OnTxInPlaceActivate>
 *
 */
HRESULT CTxtEdit::OnTxInPlaceDeactivate()
{
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::OnTxInPlaceDeactivate");

    START_PROFILING

    // Get properties that affect whether we will discard the selection
    DWORD dwBits;

    // Tell display that it is not longer active
    _pdp->SetActiveFlag(FALSE);

    // Because we are inactive, this will tell any background recalc going
    // on to stop.
    _pdp->StepBackgroundRecalc();

    _phost->TxGetPropertyBits(TXTBIT_HIDESELECTION | TXTBIT_SAVESELECTION,
        &dwBits);

    // If we don't want to save the selection and we want to hide it while
    // inactive, then we discard our selection
    if(!(dwBits & TXTBIT_SAVESELECTION) && (dwBits & TXTBIT_HIDESELECTION))
        DiscardSelection();

    _fInPlaceActive = FALSE;
    return S_OK;
}

/*
 *  CTxtEdit::OnTxUIActivate()
 *
 *  @mfunc  Informs text services that the control is now UI active.
 *
 *  @rdesc  S_OK
 *
 *  @comm   See OnTxInPlaceActivate for a detailed description of
 *  activation/deactivation.
 *
 *  @xref <mf CTxtEdit::OnTxInPlaceActivate>
 *
 *
 */
HRESULT CTxtEdit::OnTxUIActivate()
{
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::OnTxUIActivate");

    return S_OK;
}

/*
 *  CTxtEdit::OnTxUIDeactivate()
 *
 *  @mfunc  Informs text services that the control is now UI deactive.
 *
 *  @rdesc  S_OK
 *
 *  @comm   See OnTxInPlaceActivate for a detailed description of
 *  activation/deactivation.
 *
 *  @xref <mf CTxtEdit::OnTxInPlaceActivate>
 *
 */
HRESULT CTxtEdit::OnTxUIDeactivate()
{
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::OnTxUIDeactivate");

    return S_OK;
}

/*
 *  CTxtEdit::TxGetText (pbstrText)
 *
 *  @mfunc  Returns all of the UNICODE plain text in the control as an
 *          OLE BSTR.
 *
 *  @rdesc
 *      S_OK - Text successfully returned in the output argument <nl>
 *      E_INVALIDARG - invalid BSTR pointer passed in. <nl>
 *      E_OUTOFMEMORY - could not allocate memory for copy of the text <nl>
 *
 *  @comm   The caller takes ownership of the returned BSTR.  WM_GETTEXT
 *          and TOM ITextRange::GetText are alternate techniques for
 *          retrieving plain text data.
 *
 *          If there is no text in the control, no BSTR will be allocated
 *          and NULL will be returned.
 *
 *          The returned text will NOT necessarily be NULL terminated.
 */
HRESULT CTxtEdit::TxGetText(
    BSTR *pbstrText )   //@parm where to return an allocated BSTR
{
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::TxGetText");

    CTxtPtr     tp(this, 0);
    CCallMgr callmgr(this);

    START_PROFILING

    if(!pbstrText)
        return E_INVALIDARG;

    const LONG cch = GetTextLength();

    if(cch <= 0)
    {
        *pbstrText = 0;
        return S_OK;
    }
    *pbstrText = SysAllocStringLen(NULL, cch);
    if(!*pbstrText)
    {
        GetCallMgr()->SetOutOfMemory();
        return E_OUTOFMEMORY;
    }

    tp.GetText(cch, *pbstrText);
    return S_OK;
}

/*
 *  CTxtEdit::TxSetText (pszText)
 *
 *  @mfunc  Sets all of the text in the control
 *
 *  @rdesc
 *      S_OK - text was successfully set    <nl>
 *      E_FAIL - text could not be updated. <nl>
 *
 *  @comm
 *      This method should be used with care; it essentially re-initializes
 *      the text engine with some new data; any previous data and formatting
 *      information will be LOST, including undo information.
 *
 *      If previous data has been copied to the clipboard, that data will be
 *      rendered completely to the clipboard (via OleFlushClipboard) before
 *      it is discarded.
 *
 *      This method is NOT undo-able.
 *
 *      Two alternate approaches to setting text are WM_SETTEXT and TOM
 *      ITextRange::SetText.
 *
 *  @xref
 *      <mf CTxtRange::SetText>
 */
HRESULT CTxtEdit::TxSetText(
    LPCTSTR pszText)        //@parm String to replace the current text with
{
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::TxSetText");

    START_PROFILING

    return SetText(pszText, ST_CHECKPROTECTION, 1200);
}

/*
 *  CTxtEdit::TxGetCurTargetX (px)
 *
 *  @mfunc
 *      Get the target x position of the caret
 *
 *  @rdesc
 *      HRESULT with possible values:
 *
 *      S_OK         - x position of the caret returned <nl>
 *      E_FAIL       - There is no selection <nl>
 *      E_INVALIDARG - Input argument is invalid <nl>
 *
 *  @comm
 *      This method is useful for implementing up-down cursoring
 *      through a conceptual vertical line.  To illustrate this feature,
 *      consider setting the insertion point at, say, column 20 in a
 *      text editor.  Now cursor up and down--notice that wherever possible,
 *      the editor tries to put the insertion point as close to column 20
 *      as it can for the current line.  Column 20 is thus the "target" column
 *      for the insertion point.
 *
 *      Users would like to have this same capability when cursoring through
 *      Forms; however, as other controls don't necessarily share the same
 *      notion of column position, the target caret position is expressed simply
 *      as an x-coordinate on the display (in *client* coordinates).
 */
HRESULT CTxtEdit::TxGetCurTargetX(
    LONG *px)           //@parm the x location in client coordinates
{
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::TxGetCurTargetX");

    START_PROFILING
    CTxtSelection *psel = GetSel();

    if(!psel)
        return E_FAIL;

    if(!px)
        return E_INVALIDARG;

    *px = psel->GetXCaretReally();
    return S_OK;
}

/*
 *  CTxtEdit::TxGetBaseLinePos(pBaseLinePos)
 *
 *  @mfunc  Get the base line position of the first visible line, in pixels,
 *  relative the TS client rectangle. Needed for aligning controls on their
 *  baselines.
 *
 *  @rdesc  HRESULT = E_NOTIMPL
 */
HRESULT CTxtEdit::TxGetBaseLinePos(
    LONG *pBaseLinePos)     //@parm Where to return baseline position
{
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::TxGetBaseLinePos");

    return E_NOTIMPL;
}

/*
 *  CTxtEdit::TxGetNaturalSize (dwAspect, hdcDraw, hicTargetDev, ptd, dwMode,
 *                              psizelExtent, pwidth, pheight)
 *
 *  @mfunc  Allow control to be resized so it fits content appropriately
 *
 *  @rdesc  S_OK            <nl>
 *          E_INVALIDARG    <nl>
 *          E_FAIL  Unable to determine correct size    <nl>
 *          E_OUTOFMEMORY   <nl>
 *
 *  @comm
 *
 *  The first 4 parameters are similar to equivalent parameters in
 *  TxDraw and give the same information. In the case TS needs to
 *  recalc lines, it should use these values the same ways as in
 *  TxDraw.
 *
 *  <p pWidth> and <p pHeight> are IN/OUT parameters. The host passes the
 *  "tentative" width and height of the client rectangle for the text object
 *  and Text Services will compare these values against its current cached
 *  state, and if different should recalc lines. Then it will compute
 *  and return the natural size. As spec-ed currently, the host can ask for 2
 *  different kinds of natural sizes:
 *
 *  TXTNS_FITTOCONTENT: the entire text should be formatted to the
 *  width that is passed in.Then Text Services return the height of
 *  the entire text and the width of the widest line. Note that this
 *  option ignores any paragraph formatting such as centering and
 *  only returns the raw size for the text.
 *
 *  TXTNS_ROUNDTOLINE: returns the integral height of the number of lines that
 *  will fit in the input height rounded to the next full line boundary.
 *
 *  Note that passed and returned width and height correspond to
 *  the *client* rectangle in client units.
 *
 *
 *  BACKGROUND
 *  Here is a quick description of the features mentioned above:
 *
 *  FITTOCONTEXT: Normally happens when the user double clicks one
 *  of the control grab handles. Sizes the control to the "optimal"
 *  size to fit the entire content. Should accomodate the height of
 *  the entire text and the width of the widest line.
 *
 *  ROUNDTOLINE (Integral height): if this property is set, when the
 *  user resizes the control, it snaps to heights that allow an
 *  integral number of lines to be displayed (no line will be clipped).
 */
HRESULT CTxtEdit::TxGetNaturalSize(
    DWORD   dwAspect,   //@parm Aspect for drawing.  Values taken from OLE's
                        //      DVASPECT enumeration
    HDC     hdcDraw,    //@parm DC into which drawing would occur
    HDC hicTargetDev,   //@parm DC for which text should be formatted, i.e.,
                        //      for WYSIWYG
    DVTARGETDEVICE *ptd,//@parm More info on the target device
    DWORD   dwMode,     //@parm Type of fitting requested.  Either
                        //      TXTNS_FITTOCONTENT or TXTNS_ROUNDTOLINE
    const SIZEL *psizelExtent,//@parm Size of extent to use for zooming
    LONG *  pwidth,     //@parm Width for such a fitting [in,out]
    LONG *  pheight)    //@parm Height for such a fitting [in,out]
{
#ifndef PEGASUS
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::TxGetNaturalSize");

    HRESULT hr;
    CCallMgr callmgr(this);

    START_PROFILING

    if(dwAspect != DVASPECT_CONTENT && dwAspect != DVASPECT_DOCPRINT)
    {
        // We don't support the aspect requested
        return DV_E_DVASPECT;
    }

    if (hicTargetDev && !ptd ||
        dwMode != TXTNS_FITTOCONTENT && dwMode != TXTNS_ROUNDTOLINE ||
        !pwidth || !pheight)
    {
        // Either and information context is provided without the device
        // target or the mode is not valid or the width was not provided
        // or the height was not provided. In short, the input parameters
        // are not valid so tell the caller.
        return E_INVALIDARG;
    }

    if(!psizelExtent->cy)
    {
        // No extent for control, so just return 0
        *pwidth = 0;
        *pheight = 0;
        return S_OK;
    }

    HDC hicLocal = NULL;

    // Did they give us a ptd without a hic?
    if(!hicTargetDev && ptd)
    {
        // Create and information context for the device information
        // since it wasn't supplied.
        hicLocal = CreateIC(
            (TCHAR *)((BYTE *) ptd + ptd->tdDriverNameOffset),
            (TCHAR *)((BYTE *) ptd + ptd->tdDeviceNameOffset),
            (TCHAR *)((BYTE *) ptd + ptd->tdPortNameOffset),
            (DEVMODE *)((BYTE *)  ptd + ptd->tdExtDevmodeOffset));

        if(!hicLocal)
            return E_FAIL;              // Couldn't create it

        hicTargetDev = hicLocal;
    }

    // Assume that we need to change mapping modes. Note that we need to be
    // in MM_TEXT because our measuring assumes this is so.
    BOOL fRestore = FALSE;

    // Convenient place to put height & width for converting them to
    // device units.
    POINT pt;
    pt.x = *pwidth;
    pt.y = *pheight;

    // WARNING: From this point on we expect to execute this routine clear
    // through so that the DC state can be reset if we set it and because
    // we reset the extents so that the zoom factor can be calculated
    // appropriately for this call. Therefore, be very careful about
    // any return statements you might want to add.

    // force DC in MM_TEXT
    if(GetMapMode(hdcDraw) != MM_TEXT &&
        GetDeviceCaps(hdcDraw, TECHNOLOGY) != DT_METAFILE)
    {
        WinLPtoDP(hdcDraw, &pt, 1);         // Convert to device units
        fRestore = TRUE;                    // Remember that DC got converted
        ConvertDrawDCMapping(hdcDraw);
    }

    // Set the extent information needed for zooming
    _pdp->SetTempZoomDenominator(psizelExtent->cy);

    if(TXTNS_ROUNDTOLINE == dwMode)
    {
        // Round to fit simply calculates the
        hr = _pdp->RoundToLine(hdcDraw, pt.x, &pt.y);
    }
    else
    {
        // Get natural size for entire presentation
        // Allocate memory for the draw information
        CDrawInfo di(this);

        // Set up the drawing parameters
        _pdp->SetDrawInfo(
            &di,
            dwAspect,
            -1,
            NULL,
            ptd,
            hicTargetDev);

        // Set the Draw DC
        _pdp->SetDC(hdcDraw);

        // Tell display to figure size needed for this display
        hr = _pdp->GetNaturalSize(hdcDraw, hicTargetDev, dwMode, &pt.x, &pt.y);

        _pdp->ResetDC();                // Restore state
        _pdp->ReleaseDrawInfo();
    }

    if(fRestore)                        // Put DC back into correct
        RestoreDC(hdcDraw, -1);         //  mapping mode

    if(SUCCEEDED(hr))                   // Set return values if this worked
    {
        if(fRestore)
        {
            // Convert return value back to input logical units if we
            // converted them to use them.
            DPtoLP(hdcDraw, &pt, 1);
        }
        *pwidth = pt.x;                 // Update return values
        *pheight = pt.y;
    }

    if(hicLocal)                        // Clean up info context
        DeleteDC(hicLocal);             //  if we created one

    _pdp->ResetTempZoomDenominator();   // Reset temporary zoom factor

    return hr;
#else
    return 0;
#endif
}

/*
 *  CTxtEdit::TxGetDropTarget (ppDropTarget)
 *
 *  @mfunc  Get the drop target for the text control
 *
 *  @rdesc
 *      S_OK - Got drop target successfully <nl>
 *      E_OUTOFMEMORY - Could not create drop target <nl>
 *
 *  @comm
 *      The caller (host) is responsible for calling Register/Revoke
 *      DragDrop and for calling IUnknown::Release on the returned
 *      drop target when done.
 */
HRESULT CTxtEdit::TxGetDropTarget(
    IDropTarget **ppDropTarget) //@parm Where to put pointer to drop target
{
#ifndef PEGASUS
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::TxGetDropTarget");

    HRESULT hr;
    CCallMgr callmgr(this);

    START_PROFILING

    hr = _ldte.GetDropTarget(ppDropTarget);
    if(hr == NOERROR)
        (*ppDropTarget)->AddRef();
    return hr;
#else
    return 0;
#endif
}

/*
 *  CTxtEdit::OnTxPropertyBitsChange (dwMask, dwBits)
 *
 *  @mfunc  Set properties that can be represented by bits.
 *
 *  @rdesc  HRESULT
 *
 *  @comm   The following property bits are understood: <nl>
 *
 *      TXTBIT_RICHTEXT             <nl>
 *      TXTBIT_MULTILINE            <nl>
 *      TXTBIT_READONLY             <nl>
 *      TXTBIT_SHOWACCELERATOR      <nl>
 *      TXTBIT_USEPASSWORD          <nl>
 *      TXTBIT_HIDESELECTION        <nl>
 *      TXTBIT_SAVESELECTION        <nl>
 *      TXTBIT_AUTOWORDSEL          <nl>
 *      TXTBIT_AUTOSIZE             <nl>
 *      TXTBIT_VERTICAL             <nl>
 *      TXTBIT_SELECTIONBAR         <nl>
 *      TXTBIT_WORDWRAP             <nl>
 *
 *      TXTBIT_CLIENTRECTCHANGE     <nl>
 *      TXTBIT_VIEWINSETCHANGE      <nl>
 *      TXTBIT_BACKSTYLECHANGE      <nl>
 *      TXTBIT_MAXLENGTHCHANGE      <nl>
 *      TXTBIT_SCROLLBARCHANGE      <nl>
 *      TXTBIT_CHARFORMATCHANGE     <nl>
 *      TXTBIT_PARAFORMATCHANGE     <nl>
 *      TXTBIT_ALLOWBEEP            <nl>
 *      TXTBIT_EXTENTCHANGE         <nl>
 *
 *  A brief description of each property follows:
 *
 *
 *  Client rectangle (TXTBIT_CLIENTRECTCHANGE):
 *
 *  The rectangle the Text Services are responsible for painting
 *  and managing. The host will rely on the Text Services for painting
 *  that area. Text Services must not paint or invalidate areas outside of
 *  that rectangle.
 *
 *  The host will forward mouse messages to the Text Services whenever the
 *  cursor is over this rectangle.
 *
 *  This rectangle is expressed in client coordinates of the containing window.
 *
 *  IMPORTANT: this property cannot be queried from the host when it is
 *  inactive. The TxGetClientRect method will fail if called at inactive time.
 *
 *
 *  View inset (TXTBIT_VIEWINSETCHANGE):
 *
 *  This is the amount of space on each side between the client rectangle and
 *  the view rectangle. The view rectangle (also called Formating rectangle)
 *  is the rectangle the text should be formatted in.
 *
 *  The view insets are is passed in a RECT structure but this is not really
 *  a rectangle. It should be treated as 4 independent values to substract
 *  on each side of the client rectangle to figure the view rectangle.
 *
 *  The view insets are passed in himetrics so that they do not depend on
 *  the client rectangle and the rendering DC.
 *
 *  View insets can be negative on either side of the client rectangle,
 *  leading to a bigger view rectangle than the client rectangle. The text
 *  should then be clipped to the client rectangle. If the view rectangle
 *  is wider than the client rectangle, then the host may add a horizontal
 *  scrollbar to the control.
 *
 *  Single line Text Services ignore the right boundary of the view rectangle
 *  when formatting text.
 *
 *  The view inset is available from the host at all times, active or
 *  inactive.
 *
 *
 *  Backstyle (TXTBIT_BACKSTYLECHANGE):
 *
 *  The style of the background of the client rectangle. Can be either of
 *  the following values: <nl>
 *      #define TXTBACK_TRANSPARENT     0 <nl>
 *      #define TXTBACK_SOLID           1 <nl>
 *
 *  Values for this property are similar to VB4 values for the same property.
 *
 *
 *  MaxLength (TXTBIT_MAXLENGTHCHANGE):
 *
 *  The maximum length the text can have. Text Services should reject
 *  character insertion and  pasted text when this maximum is reached.
 *  TxSetText however should still accept (and set) text longer than the
 *  maximum length. This is because this method is used for binding and
 *  it is critical to maintain the integrity of the data the control
 *  is bound to.
 *
 *
 *  Scrollbar (TXTBIT_SCROLLBARCHANGE):
 *
 *  This property indicates which scollbar is present and whether scollbars
 *  are hidden or disabled when scrolling is impossible. It also controls
 *  auto-scrolling when the insertion point gets off the client rectangle.
 *
 *  This is a DWORD where bits are layed out as in the system window style.
 *  Possible bits are:
 *  WS_HSCROLL              // control has horizontal scrollbar <nl>
 *  WS_VSCROLL              // control has vertical scrollbar <nl>
 *  ES_AUTOVSCROLL          // auto-scroll horizontally <nl>
 *  ES_AUTOVSCROLL          // auto-scroll vertically <nl>
 *  ES_DISABLENOSCROLL      // scrollbar should be disabled when scrolling
 *                             impossible <nl>
 *
 *  Default CHARFORMAT (TXTBIT_CHARFORMATCHANGE):
 *
 *  The CHARFORMAT or CHARFORMAT2 used for default character-format runs,
 *  i.e., those not explicitly formatted via the selection or TOM methods.

 *
 *  Default PARAFORMAT (TXTBIT_PARAFORMATCHANGE):
 *
 *  The PARAFORMAT or PARAFORMAT2 used for default paragraph-format runs,
 *  i.e., those not explicitly formatted via the selection or TOM methods.
 *
 *
 *  TXTBIT_ALLOWBEEP:
 *
 *  TXTBIT_EXTENTCHANGE:
 *
 *
 *  TXTBIT_RICHTEXT:
 *
 *  Whether the Text Services should be in Rich-Text mode or not.  This
 *  principally affects how editing commands are applied.  For example,
 *  applying bold to some text in a plain edit control makes all of the
 *  text bold, rather than just the selected text in a rich text control.
 *
 *  Note that if there is either undo state or the object has any text,
 *  the attempt to change this bit will be ignored.
 *
 *
 *  TXTBIT_MULTILINE:
 *
 *  If this property is FALSE, Text Services should not process the CR
 *  key and truncate any incoming text containing hard line breaks just
 *  before the first line break. It is OK to also truncate text set via
 *  TxSetText (meaning, it is the responsibility of the host to not use a s
 *  single line control when bound to a multi-line field).
 *
 *  If this property is TRUE, Text Services should work in multiline mode.
 *  The TXTBIT_WORDWRAP can be used to know whether to wrap the lines to
 *  the view rectangle or clip them.
 *
 *
 *  TXTBIT_READONLY:
 *
 *  If this property is TRUE, Text Services should not accept any editing
 *  change via the user interface. However, they should still accept
 *  programmatic changes via EM_SETTEXT, EM_REPLACETEXT and TxSetText.
 *
 *  In read only mode, the user should still be able to move the
 *  insertion point, select text and carry out other non content modifying
 *  operations such as Copy.
 *
 *
 *  TXTBIT_SHOWACCELERATOR:
 *
 *  Refer to the "Accelerator" section for details about this property.
 *
 *
 *  TXTBIT_USEPASSWORD:
 *
 *  If this property is TRUE, the Text Services should show the entire
 *  text using the character obtained by TxGetPasswordChar.
 *
 *  The notification on this property may mean two different things:
 *   The password character changed,
 *   The password character was not used before and is used now
 *  (or vice versa).
 *
 *
 *  TXTBIT_HIDESELECTION:
 *
 *  If this property is TRUE, Text Services should hide the selection
 *  when the control is inactive. If it is FALSE, the selection, if any,
 *  should still be displayed when the control is inactive.
 *
 *  If TRUE, this property implies TXTBIT_SAVESELECTION = TRUE.
 *
 *
 *  TXTBIT_SAVESELECTION:
 *
 *  If this property is TRUE, Text Services should remember the
 *  boundaries of the selection when the control goes inactive. If FALSE,
 *  it is not necessary to remember the selection when the control goes
 *  inactive. It can be reset to start = 0, length = 0 when the control
 *  goes active again.
 *
 *  This property is used by hosts for which it is not necessary to
 *  remember the selection when inactive.
 *
 *
 *  TXTBIT_AUTOWORDSEL:
 *
 *  This property turns the AutoWordSelect feature on or off.
 *
 *
 *  TXTBIT_AUTOSIZE:
 *
 *  This property turns the AutoSize feature on or off. Refer to the
 *  "AutoSize" section for more details.
 *
 *
 *  TXTBIT_VERTICAL:
 *
 *  This property turns on vertical writing. Used for FE support.
 *  Details TBD.
 *
 *
 *  TXTBIT_WORDWRAP:
 *
 *  If this property is TRUE and MultiLine is also TRUE, then Text Services
 *  should wrap the line to the view rectangle. If this property is FALSE,
 *  the lines should not be wrapped but clipped. The right side of the
 *  view rectangle should be ignored.
 *
 *  If the MultiLine property is off, this property has no effect.
 *
 *
 *  TXTBIT_LINESELECTION:
 *
 *  This property turns on or off the Line Selection feature. This feature
 *  enable the user to select lines or paragraph by placing the mouse cursor
 *  over a "line selection" area on the left of the control. The cursor is
 *  displayed as a NE arrow in that area. If the Line Selection feature is
 *  off, that area should not be shown.
 *
 */
HRESULT CTxtEdit::OnTxPropertyBitsChange(
    DWORD dwMask,           //@parm Bits representing properties to be changed
    DWORD dwBits)           //@parm New values for bit properties
{
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::OnTxPropertyBitsChange");

    HRESULT hr = E_FAIL;
    DWORD dwLoopMask = dwMask;
    CCallMgr callmgr(this);

    START_PROFILING

    for (int i = 0; (i < MAX_PROPERTY_BITS) && (dwLoopMask != 0);
        i++, dwLoopMask >>= 1)
    {
        if (dwLoopMask & 1)
        {
            hr = (this->*_fnpPropChg[i])((dwBits & (1 << i)) != 0);
            if (FAILED(hr))
                return hr;
        }
    }
    return S_OK;
}

/*
 *  CTxtEdit::TxGetCachedSize (pdwWidth, pdwHeight)
 *
 *  @mfunc
 *      Returns the cached drawing size (if any) that text services
 *      is using.  Typically, this will be the size of the last client
 *      rect used in TxDraw, TxSetCursor, etc., although it is not
 *      guaranteed to be.
 *
 *  @rdesc
 *      HRESULT
 *
 *  @comm
 *      This information is provided to allow the host to potentially
 *      perform various optimizations, amongst other things.
 */
HRESULT CTxtEdit::TxGetCachedSize(
    DWORD *pdwWidth,    //@parm Where to put width (in client coords)
    DWORD *pdwHeight)   //@parm Where to put height (in client coords)
{
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::TxGetCachedSize");

    return _pdp->GetCachedSize(pdwHeight, pdwWidth);
}

// Forward declaration of initialization helper.
// These really should be in some header file.  But which?
// Currently the definitions are in dxfrobj.cpp and font.cpp
void RegisterFETCs();
void InitFontCache();

/*
 *  CreateTextServices (punkOuter, phost, ppserv)
 *
 *  @func
 *      Create an instance of the RichEdit Engine.  This engine supports the
 *      ITextServices and Microsoft Text Object Model (TOM) interfaces.
 *
 *  @rdesc
 *      S_OK - New text services instance created successfully. <nl>
 *      E_INVALIDARG - An invalid argument was passed in. <nl>
 *      E_OUTOFMEMORY - Memory for text services object could not be allocated. <nl>
 *      E_FAIL - Text services could not be initialized
 *
 *  @comm
 *      Text Services may be created as a standard OLE aggregated object.
 *      Callers should follow standard OLE32 rules for dealing with
 *      aggregated objects and caching interface pointers obtained via
 *      QueryInterface from the private IUnknown.
 */
STDAPI CreateTextServices(
    IUnknown *punkOuter,    //@parm Outer unknown, may be NULL
    ITextHost *phost,       //@parm Client's ITextHost implementation; must be
                            //      valid
    IUnknown **ppUnk)       //@parm Private IUnknown of text services engine
{
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CreateTextServices");

    static bool fOnce = FALSE;

    if (!fOnce) {
        CLock lock;
        fOnce = TRUE;
        W32->InitSysParams();
        W32->InitPreferredFontInfo();
        RegisterFETCs();                    // Register new clipboard formats
        CreateFormatCaches();               // Create global format caches
        if ( !InitKinsokuClassify() )
        {
            // Init tables for classifying Unicode chars.
            return E_FAIL;
        }
        InitFontCache();
    }

    if(!ppUnk)
        return E_INVALIDARG;

    CTxtEdit *ped = new CTxtEdit((ITextHost2*)phost, punkOuter);
    if(!ped)
        return E_OUTOFMEMORY;

    if(ped->Init(NULL))
    {
        *ppUnk = ped->GetPrivateIUnknown();
        return S_OK;
    }
    delete ped;
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\select.cpp ===
/*
 *  @doc INTERNAL
 *
 *  @module SELECT.CPP -- Implement the CTxtSelection class |
 *
 *      This module implements the internal CTxtSelection methods.
 *      See select2.c and range2.c for the ITextSelection methods
 *
 *  Authors: <nl>
 *      RichEdit 1.0 code: David R. Fulmer
 *      Christian Fortini (initial conversion to C++)
 *      Murray Sargent <nl>
 *
 *  @devnote
 *      The selection UI is one of the more intricate parts of an editor.
 *      One common area of confusion is the "ambiguous cp", that is,
 *      a cp at the beginning of one line, which is also the cp at the
 *      end of the previous line.  We control which location to use by
 *      the _fCaretNotAtBOL flag.  Specifically, the caret is OK at the
 *      beginning of the line (BOL) (_fCaretNotAtBOL = FALSE) except in
 *      three cases:
 *
 *          1) the user clicked at or past the end of a wrapped line,
 *          2) the user typed End key on a wrapped line,
 *          3) the active end of a nondegenerate selection is at the EOL.
 *
 *  Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_select.h"
#include "_edit.h"
#include "_disp.h"
#include "_measure.h"
#include "_font.h"
#include "_rtfconv.h"
#include "_antievt.h"

#ifdef LINESERVICES
#include "_ols.h"
#endif

ASSERTDATA


// ======================= Invariant stuff and Constructors ======================================================

#define DEBUG_CLASSNAME CTxtSelection
#include "_invar.h"

#ifdef DEBUG
BOOL
CTxtSelection::Invariant() const
{
    // FUTURE: maybe add some thoughtful asserts...

    static LONG numTests = 0;
    numTests++;             // how many times we've been called

    if(IsInOutlineView() && _cch)
    {
        LONG cpMin, cpMost;
        GetRange(cpMin, cpMost);

        CTxtPtr tp(_rpTX);                  // Scan range for an EOP
        tp.SetCp(cpMin);

        // _fSelHasEop flag may be off when last cr selected so don't
        // assert in that case.
        if (GetPed()->GetAdjustedTextLength() != cpMost)
        {
            AssertSz((unsigned)(tp.FindEOP(cpMost - cpMin) != 0) == _fSelHasEOP,
                "Incorrect CTxtSelection::_fSelHasEOP");
        }
    }

    return CTxtRange::Invariant();
}
#endif

CTxtSelection::CTxtSelection(CDisplay * const pdp) :
                CTxtRange(pdp->GetPed())
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::CTxtSelection");

    Assert(pdp);
    Assert(GetPed());

    _fSel      = TRUE;                  // This range is a selection
    _pdp       = pdp;
    _hbmpCaret = NULL;
    _fEOP      = FALSE;                 // Haven't typed a CR

    // Set show-selection flag to inverse of hide-selection flag in ped
    _fShowSelection = !GetPed()->fHideSelection();

    // When we are initialized we don't have a selection therefore,
    // we do want to show caret.
    _fShowCaret = TRUE;
}

void SelectionNull(CTxtEdit *ped)
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "SelectionNull");

    if(ped)
        ped->SetSelectionToNull();
}


CTxtSelection::~CTxtSelection()
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::~CTxtSelection");

    DeleteCaretBitmap(FALSE);

    // Notify edit object that we are gone (if there's a nonNULL ped, i.e.,
    // if the selection isn't a zombie).
    SelectionNull(GetPed());
}

////////////////////////////////  Assignments  /////////////////////////////////////////


CRchTxtPtr& CTxtSelection::operator =(const CRchTxtPtr& rtp)
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::operator =");

    _TEST_INVARIANT_
    return CTxtRange::operator =(rtp);
}

CTxtRange& CTxtSelection::operator =(const CTxtRange &rg)
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::operator =");

    _TEST_INVARIANT_
    return CTxtRange::operator =(rg);
}

//////////////////////  Update caret & selection mechanism  ///////////////////////////////

/*
 *  CTxtSelection::Update(fScrollIntoView)
 *
 *  @mfunc
 *      Update selection and/or caret on screen. As a side
 *      effect, this methods ends deferring updates.
 *
 *  @rdesc
 *      TRUE if success, FALSE otherwise
 */
BOOL CTxtSelection::Update (
    BOOL fScrollIntoView)       //@parm TRUE if should scroll caret into view
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::Update");

    LONG cch;
    LONG cchSave = _cch;
    LONG cchText = GetTextLength();
    LONG cp, cpMin, cpMost;
    BOOL fMoveBack = _fMoveBack;
    CTxtEdit *ped = GetPed();

    if(!_cch)                               // Update _cpAnchor, etc.
        UpdateForAutoWord();

    if(!ped->fInplaceActive() || ped->IsStreaming())
    {
        // Nothing to do while inactive or streaming in text or RTF data
        return TRUE;
    }

    if(_cch && (_fSelHasEOP || _fSelHasCell))
    {
        BOOL fInTable = GetPF()->InTable();
        if(!fInTable)
        {
            CFormatRunPtr rp(_rpPF);
            rp.AdvanceCp(-_cch);
            fInTable = (ped->GetParaFormat(rp.GetFormat()))->InTable();
        }
        if(fInTable)
            Expander(_fSelHasEOP ? tomParagraph : tomCell,
                 TRUE, NULL, &cpMin, &cpMost);
    }

    if(IsInOutlineView() && !ped->IsMouseDown() && _rpPF.IsValid())
    {
        CPFRunPtr rp(*this);

        cp = GetCp();
        GetRange(cpMin, cpMost);
        if(_cch && (cpMin || cpMost < cchText))
        {
            LONG *pcpMin  = &cpMin;
            LONG *pcpMost = &cpMost;

            // If selection contains an EOP, expand to para boundaries
            if(_fSelHasEOP)
            {
                if(_fMoveBack ^ (_cch < 0)) // Decreasing selection
                {                           //  size: move active end
                    if(_fMoveBack)
                        pcpMost = NULL;     //  to StartOf para
                    else
                        pcpMin = NULL;      //  to EndOf para
                }
                Expander(tomParagraph, TRUE, NULL, pcpMin, pcpMost);
            }

            LONG cpMinSave  = cpMin;        // Save initial cp's to see if
            LONG cpMostSave = cpMost;       //  we need to Set() below

            // The following handles selection expansion correctly, but
            // not compression; need logic like that preceding Expander()
            rp.AdvanceCp(cpMin - cp);       // Start at cpMin
            if(rp.IsCollapsed())
                cpMin += rp.FindExpandedBackward();
            rp.AdjustForward();

            BOOL fCpMinCollapsed = rp.IsCollapsed();
            rp.AdvanceCp(cpMost - cpMin);   // Go to cpMost
            Assert(cpMost == rp.CalculateCp());
            if(rp.IsCollapsed())
                cpMost += rp.FindExpandedForward();

            if(fCpMinCollapsed || rp.IsCollapsed() && cpMost < cchText)
            {
                if(rp.IsCollapsed())
                {
                    rp.AdvanceCp(cpMin - cpMost);
                    rp.AdjustForward();
                    cpMost = cpMin;
                }
                else
                    cpMin = cpMost;
            }
            if(cpMin != cpMinSave || cpMost != cpMostSave)
                Set(cpMost, cpMost - cpMin);
        }
        if(!_cch && rp.IsCollapsed())       // Note: above may have collapsed
        {                                   //  selection...
            cch = fMoveBack ? rp.FindExpandedBackward() : 0;
            if(rp.IsCollapsed())
                cch = rp.FindExpanded();

            _fExtend = FALSE;
            Advance(cch);
            rp.AdjustForward();
            if(cch <= 0 && rp.IsCollapsed() && _rpTX.IsAfterEOP())
                BackupCRLF();
            _fCaretNotAtBOL = FALSE;
        }
    }

    // Don't let active end be in hidden text
    CCFRunPtr rp(*this);

    cp = GetCp();
    GetRange(cpMin, cpMost);
    if(_cch && (cpMin || cpMost < cchText))
    {
        rp.AdvanceCp(cpMin - cp);           // Start at cpMin
        BOOL fHidden = rp.IsInHidden();
        rp.AdvanceCp(cpMost - cpMin);       // Go to cpMost

        if(fHidden)                         // It's hidden, so collapse
            Collapser(tomEnd);              //  selection at End for treatment

        else if(rp.IsInHidden() &&          // cpMin OK, how about cpMost?
            cpMost < cchText)
        {                                   // Check both sides of edge
            Collapser(tomEnd);              //  collapse selection at end
        }
    }
    if(!_cch && rp.IsInHidden())            // Note: above may have collapsed
    {                                       //  selection...
        cch = fMoveBack ? rp.FindUnhiddenBackward() : 0;
        if(!fMoveBack || rp.IsHidden())
            cch = rp.FindUnhidden();

        _fExtend = FALSE;
        Advance(cch);
        _fCaretNotAtBOL = FALSE;
    }
    if((cchSave ^ _cch) < 0)                // Don't change active end
        FlipRange();

    if(!_cch && cchSave)                    // Fixups changed nondegenerate
    {                                       //  selection to IP. Update
        Update_iFormat(-1);                 //  _iFormat and _fCaretNotAtBOL
        _fCaretNotAtBOL = FALSE;
    }

    _TEST_INVARIANT_

    // Recalc up to active end (caret)
    if(!_pdp->WaitForRecalc(GetCp(), -1))   // Line recalc failure
        Set(0, 0);                          // Put caret at start of text

    ShowCaret(ped->_fFocus);
    UpdateCaret(fScrollIntoView);           // Update Caret position, possibly
                                            //  scrolling it into view
    ped->TxShowCaret(FALSE);
    UpdateSelection();                      // Show new selection
    ped->TxShowCaret(TRUE);

    return TRUE;
}

/*
 *  CTxtSelection::CheckSynchCharSet(dwCharFlag)
 *
 *  @mfunc
 *      Check if the current keyboard matches the current font's charset;
 *      if not, call CheckChangeFont to find the right font
 *
 *  @rdesc
 *      Current keyboard codepage
 */
UINT CTxtSelection::CheckSynchCharSet(
    DWORD dwCharFlag)
{
    CTxtEdit *ped      = GetPed();
    LONG      iFormat  = GetiFormat();
    const CCharFormat *pCF = ped->GetCharFormat(iFormat);
    BYTE      bCharSet = pCF->_bCharSet;
    HKL       hkl      = GetKeyboardLayout(0xFFFFFFFF); // Force refresh
    WORD      wlidKbd  = LOWORD(hkl);
    UINT      uKbdCodePage = ConvertLanguageIDtoCodePage(wlidKbd);

    // If current font is not set correctly,
    // change to a font preferred by current keyboard.

    // To summarize the logic below:
    //      Check that lcidKbd is valid
    //      Check that current charset differs from current keyboard
    //      Check that current keyboard is legit in a single codepage control
    //      Check that current charset isn't SYMBOL, DEFAULT, or OEM
    if (wlidKbd &&
        (UINT)GetCodePage(bCharSet) != uKbdCodePage &&
        (!ped->_fSingleCodePage ||
            uKbdCodePage == 1252 ||
            uKbdCodePage == (ped->_pDocInfo ?
                                ped->_pDocInfo->wCpg :
                                GetSystemDefaultCodePage())) &&
        bCharSet != SYMBOL_CHARSET &&
        bCharSet != OEM_CHARSET &&
        !(W32->IsFECodePage(uKbdCodePage) && bCharSet == ANSI_CHARSET))
    {
        CheckChangeFont(hkl, uKbdCodePage, iFormat, dwCharFlag);
    }

    return uKbdCodePage;
}

/*
 *  CTxtSelection::MatchKeyboardToPara()
 *
 *  @mfunc
 *      Match the keyboard to the current paragraph direction. If the paragraph
 *      is an RTL paragraph then the keyboard will be switched to an RTL
 *      keyboard, and vice versa.
 *
 *  @rdesc
 *      TRUE iff a keyboard was changed
 *
 *  @devnote
 *      We use the following tests when trying to find a keyboard to match the
 *      paragraph direction:
 *
 *      See if the current keyboard matches the direction of the paragraph.
 *
 *      Search backward from rtp looking for a charset that matches the
 *          direction of the paragraph.
 *
 *      Search forward from rtp looking for a charset that matches the
 *          direction of the paragraph.
 *
 *      See if the default charformat charset matches the direction of the
 *          paragraph.
 *
 *      See if there's only a single keyboard that matches the paragraph
 *          direction.
 *
 *      If all this fails, just leave the keyboard alone.
 */
BOOL CTxtSelection::MatchKeyboardToPara()
{
    CTxtEdit *ped = GetPed();
    if(!ped->IsBiDi() || !GetPed()->_fFocus || GetPed()->_fIMEInProgress)
        return FALSE;

    BOOL fRTLPara = IsParaRTL();        // Get paragraph direction

    if(W32->IsBiDiLcid(LOWORD(GetKeyboardLayout(0))) == fRTLPara)
        return FALSE;

    // Current keyboard direction didn't match paragraph direction...

    BYTE                bCharSet;
    HKL                 hkl = 0;
    const CCharFormat * pCF;
    CFormatRunPtr       rpCF(_rpCF);

    // Look backward in text, trying to find a CharSet that matches
    // the paragraph direction.
    do
    {
        pCF = ped->GetCharFormat(rpCF.GetFormat());
        bCharSet = pCF->_bCharSet;
        if(IsRTLCharSet(bCharSet) == fRTLPara)
            hkl = W32->CheckChangeKeyboardLayout(bCharSet);
    } while (!hkl && rpCF.PrevRun());

    if(!hkl)
    {
        // Didn't find an appropriate charformat so reset run pointer
        // and look forward instead
        rpCF = _rpCF;
        while (!hkl && rpCF.NextRun())
        {
            pCF = ped->GetCharFormat(rpCF.GetFormat());
            bCharSet = pCF->_bCharSet;
            if(IsRTLCharSet(bCharSet) == fRTLPara)
                hkl = W32->CheckChangeKeyboardLayout(bCharSet);
        }
        if(!hkl)
        {
            // Still didn't find an appropriate charformat so see if
            // default charformat matches paragraph direction.
            pCF = ped->GetCharFormat(rpCF.GetFormat());
            bCharSet = pCF->_bCharSet;
            if(IsRTLCharSet(bCharSet) == fRTLPara)
                hkl = W32->CheckChangeKeyboardLayout(bCharSet);

            if(!hkl)
            {
                // If even that didn't work, walk through the list of
                // keyboards and grab the first one we come to that matches
                // the paragraph direction.
                pCF = NULL;
                hkl = W32->FindDirectionalKeyboard(fRTLPara);
            }
        }
    }

    if (hkl && ped->_fFocus && IsCaretShown())
    {
        CreateCaret();
        ped->TxShowCaret(TRUE);
    }

    return hkl ? TRUE : FALSE;
}

/*
 *  CTxtSelection::GetCaretPoint(&rcClient, pt, &rp)
 *
 *  @mfunc
 *      This routine determines where the caret should be positioned
 *      on screen.
 *      This routine is trivial, except for the Bidi case. In that case
 *      if we are told to retrieve formatting from the forward CP, we draw
 *      the caret at the logical left edge of the CP. Else, we draw it at
 *      the logical right edge of the previous CP.
 *
 *  @rdesc
 *      TRUE if we didn't OOM.
 */
BOOL CTxtSelection::GetCaretPoint(
    RECT &    rcClient,
    POINT &   pt,
    CLinePtr *prp,
    BOOL      fBeforeCp)
{
    CDispDim    dispdim;
    CRchTxtPtr  rtp(*this);
    UINT        taMode = TA_BASELINE | TA_LOGICAL;

    if(GetPed()->IsBiDi() && _rpCF.IsValid())
    {
        if(_fHomeOrEnd)                 // Home/End
            taMode |= _fCaretNotAtBOL ? TA_ENDOFLINE : TA_STARTOFLINE;

        else if(!GetIchRunCF() || !GetCchLeftRunCF())
        {
            // In a Bidi context on a run boundary where the reverse level
            // changes, then we should respect the fBeforeCp flag.
            BYTE    bLevelBwd, bLevelFwd;
            BOOL    fStart = FALSE;
            LONG    cp = rtp._rpTX.GetCp();
            CBiDiLevel level;

            bLevelBwd = bLevelFwd = rtp.IsParaRTL() ? 1 : 0;

            rtp._rpCF.AdjustBackward();
            if (cp)
                bLevelBwd = rtp._rpCF.GetLevel();

            rtp._rpCF.AdjustForward();
            if (cp != rtp._rpTX.GetTextLength())
            {
                bLevelFwd = rtp._rpCF.GetLevel(&level);
                fStart = level._fStart;
            }

            if((bLevelBwd != bLevelFwd || fStart) && !fBeforeCp && rtp.Advance(-1))
            {
                // Direction change at cp, caret in prev CF run, and can
                // backspace to previous char: then get to the right of
                // previous char
                taMode |= TA_RIGHT;
                _fCaretNotAtBOL = !rtp._rpTX.IsAfterEOP();
            }
        }
    }
    if (_pdp->PointFromTp(rtp, &rcClient, _fCaretNotAtBOL, pt, prp, taMode, &dispdim) < 0)
        return FALSE;

    return TRUE;
}

/*
 *  CTxtSelection::UpdateCaret(fScrollIntoView, bForceCaret)
 *
 *  @mfunc
 *      This routine updates caret/selection active end on screen.
 *      It figures its position, size, clipping, etc. It can optionally
 *      scroll the caret into view.
 *
 *  @rdesc
 *      TRUE if view was scrolled, FALSE otherwise
 *
 *  @devnote
 *      The caret is actually shown on screen only if _fShowCaret is TRUE.
 */
BOOL CTxtSelection::UpdateCaret (
    BOOL fScrollIntoView,   //@parm If TRUE, scroll caret into view if we have
    BOOL bForceCaret)       // focus or if not and selection isn't hidden
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::UpdateCaret");
    _TEST_INVARIANT_

    if(_pdp->IsFrozen())                // If display is currently frozen
    {                                   //  save call for another time
        _pdp->SaveUpdateCaret(fScrollIntoView);
        return FALSE;
    }

    CTxtEdit *ped = GetPed();
    if(ped->IsStreaming())              // Don't bother doing anything if we
        return FALSE;                   //  are loading in text or RTF data

    if(!ped->fInplaceActive())          // If not inplace active, set up
    {                                   //  for when focus is regained
        if(fScrollIntoView)
            ped->_fScrollCaretOnFocus = TRUE;
        return FALSE;
    }

    DWORD       dwScrollBars    = ped->TxGetScrollBars();
    BOOL        fAutoVScroll    = FALSE;
    BOOL        fAutoHScroll    = FALSE;
    BOOL        fBeforeCp       = _rpTX.IsAfterEOP();
    POINT       pt;
    CLinePtr    rp(_pdp);
    RECT        rcClient;
    RECT        rcView;

    LONG        xWidthView, yHeightView;
    LONG        xScroll         = _pdp->GetXScroll();
    LONG        yScroll         = _pdp->GetYScroll();

    INT         yAbove          = 0;    // Ascent of line above & beyond IP
    INT         yAscent;                // Ascent of IP
    INT         yAscentLine;
    LONG        yBase;                  // Base of IP & line
    INT         yBelow          = 0;    // Descent of line below & beyond IP
    INT         yDescent;               // Descent of IP
    INT         yDescentLine;
    INT         ySum;
    LONG        yViewTop, yViewBottom;

    if(ped->_fFocus && (_fShowCaret || bForceCaret))
    {
        _fShowCaret = TRUE; // We're trying to force caret to display so set this flag to true

        if(!_fDualFontMode && !_fNoKeyboardUpdate && !_fIsChar && !_fHomeOrEnd)
        {
            // Avoid re-entrance to CheckChangeKeyboardLayout
            _fNoKeyboardUpdate = TRUE;

            // If we're in "dual font" mode, charset change is only
            // temporary and we don't want to change keyboard layout
            CheckChangeKeyboardLayout();

            if(!fBeforeCp && ped->IsBiDi() && _rpCF.IsValid() &&
               (!_rpCF.GetIch() || !_rpCF.GetCchLeft()))
            {
                _rpCF.AdjustBackward();
                BOOL fRTLPrevRun = IsRTLCharSet(GetCF()->_bCharSet);
                _rpCF.AdjustForward();

                if (fRTLPrevRun != IsRTLCharSet(GetCF()->_bCharSet) &&
                    fRTLPrevRun != W32->IsBiDiLcid(GetKeyboardLCID()))
                {
                    fBeforeCp = TRUE;
                }
            }

            _fNoKeyboardUpdate = FALSE;
        }
    }

    // Get client rectangle once to save various callers getting it
    ped->TxGetClientRect(&rcClient);
    _pdp->GetViewRect(rcView, &rcClient);

    // View can be bigger than client rect because insets can be negative.
    // We don't want the caret to be any bigger than the client view otherwise
    // the caret will leave pixel dust on other windows.
    yViewTop    = max(rcView.top, rcClient.top);
    yViewBottom = min(rcView.bottom, rcClient.bottom);

    xWidthView = rcView.right - rcView.left;
    yHeightView = yViewBottom - yViewTop;

    if(fScrollIntoView)
    {
        fAutoVScroll = (dwScrollBars & ES_AUTOVSCROLL) != 0;
        fAutoHScroll = (dwScrollBars & ES_AUTOHSCROLL) != 0;

        // If we're not forcing a scroll, only scroll if window has focus
        // or selection isn't hidden
        if (!ped->Get10Mode() || !GetForceScrollCaret())
			fScrollIntoView = ped->_fFocus || !ped->fHideSelection();
    }

    if(!fScrollIntoView && (fAutoVScroll || fAutoHScroll))
    {                                           // Would scroll but don't have
        ped->_fScrollCaretOnFocus = TRUE;       //  focus. Signal to scroll
        if (!ped->Get10Mode() || !GetAutoVScroll())
            fAutoVScroll = fAutoHScroll = FALSE;    //  when we do get focus
    }
    SetAutoVScroll(FALSE);

    if (!_cch && IsInOutlineView() && IsCollapsed())
        goto not_visible;

    if (!GetCaretPoint(rcClient, pt, &rp, fBeforeCp))
        goto not_visible;

    // HACK ALERT - Because plain-text multiline controls do not have the
    // automatic EOP, we need to special case their processing here because
    // if you are at the end of the document and last character is an EOP,
    // you need to be on the next line in the display not the current line.

    if(CheckPlainTextFinalEOP())            // Terminated by an EOP
    {
        LONG Align = GetPF()->_bAlignment;

        pt.x = rcView.left;                 // Default left
        if(Align == PFA_CENTER)
            pt.x = (rcView.left + rcView.right)/2;

        else if(Align == PFA_RIGHT)
            pt.x = rcView.right;

        pt.x -= xScroll;                    // Absolute coordinate

        // Bump the y up a line. We get away with the calculation because
        // the document is plain text so all lines have the same height.
        // Also, note that the rp below is used only for height
        // calculations, so it is perfectly valid for the same reason
        // even though it is not actually pointing to the correct line.
        // (I told you this is a hack.)
        pt.y += rp->_yHeight;
    }

    _xCaret = (LONG) pt.x;
    yBase   = (LONG) pt.y;

    // Compute caret height, ascent, and descent
    yAscent = GetCaretHeight(&yDescent);
    yAscent -= yDescent;

    // Default to line empty case. Use what came back from the default
    // calculation above.
    yDescentLine = yDescent;
    yAscentLine = yAscent;

    if(rp.IsValid())
    {
        if(rp->_yDescent != -1)
        {
            // Line has been measured so we can use the line's values
            yDescentLine = rp->_yDescent;
            yAscentLine  = rp->_yHeight - yDescentLine;
        }
    }

    if(yAscent + yDescent == 0)
    {
        yAscent = yAscentLine;
        yDescent = yDescentLine;
    }
    else
    {
        // This is a bit counter-intuitive at first.  Basically, even if
        // the caret should be large (e.g., due to a large font at the
        // insertion point), we can only make it as big as the line.  If
        // a character is inserted, then the line becomes bigger, and we
        // can make the caret the correct size.
        yAscent = min(yAscent, yAscentLine);
        yDescent = min(yDescent, yDescentLine);
    }

    if(fAutoVScroll)
    {
        Assert(yDescentLine >= yDescent);
        Assert(yAscentLine >= yAscent);

        yBelow = yDescentLine - yDescent;
        yAbove = yAscentLine - yAscent;

        ySum = yAscent;

        // Scroll as much as possible into view, giving priorities
        // primarily to IP and secondarily ascents
        if(ySum > yHeightView)
        {
            yAscent = yHeightView;
            yDescent = 0;
            yAbove = 0;
            yBelow = 0;
        }
        else if((ySum += yDescent) > yHeightView)
        {
            yDescent = yHeightView - yAscent;
            yAbove = 0;
            yBelow = 0;
        }
        else if((ySum += yAbove) > yHeightView)
        {
            yAbove = yHeightView - (ySum - yAbove);
            yBelow = 0;
        }
        else if((ySum += yBelow) > yHeightView)
            yBelow = yHeightView - (ySum - yBelow);
    }
    else
    {
        AssertSz(yAbove == 0, "yAbove non-zero");
        AssertSz(yBelow == 0, "yBelow non-zero");
    }

    // Update real caret x pos (constant during vertical moves)
    _xCaretReally = _xCaret - rcView.left + xScroll;
    if (!(dwScrollBars & ES_AUTOHSCROLL) &&         // Not auto hscrolling
        !_pdp->IsHScrollEnabled())                  //  and no scrollbar
    {
        if (_xCaret < rcView.left)                  // Caret off left edge
            _xCaret = rcView.left;
        else if(_xCaret + GetCaretDelta() > rcView.right)// Caret off right edge
            _xCaret = rcView.right - dxCaret;       // Back caret up to
    }                                               //  exactly the right edge
    // From this point on we need a new caret
    _fCaretCreated = FALSE;
    if(ped->_fFocus)
        ped->TxShowCaret(FALSE);                    // Hide old caret before
                                                    //  making a new one
    if(yBase + yDescent + yBelow > yViewTop &&
        yBase - yAscent - yAbove < yViewBottom)
    {
        if(yBase - yAscent - yAbove < yViewTop)     // Caret is partially
        {                                           //  visible
            if(fAutoVScroll)                        // Top isn't visible
                goto scrollit;
            Assert(yAbove == 0);

            yAscent = yBase - yViewTop;             // Change ascent to amount
            if(yBase < yViewTop)                    //  visible
            {                                       // Move base to top
                yDescent += yAscent;
                yAscent = 0;
                yBase = yViewTop;
            }
        }
        if(yBase + yDescent + yBelow > yViewBottom)
        {
            if(fAutoVScroll)                        // Bottom isn't visible
                goto scrollit;
            Assert(yBelow == 0);

            yDescent = yViewBottom - yBase;         // Change descent to amount
            if(yBase > yViewBottom)                 //  visible
            {                                       // Move base to bottom
                yAscent += yDescent;
                yDescent = 0;
                yBase = yViewBottom;
            }
        }

        // Anything still visible?
        if(yAscent <= 0 && yDescent <= 0)
            goto not_visible;

        // If left or right isn't visible, scroll or set non_visible
        if (_xCaret < rcView.left ||                 // Left isn't visible
            _xCaret + GetCaretDelta() > rcView.right)// Right isn't visible
        {
            if(fAutoHScroll)
                goto scrollit;
            goto not_visible;
        }

        _yCaret = yBase - yAscent;
        _yHeightCaret = (INT) yAscent + yDescent;
    }
    else if(fAutoHScroll || fAutoVScroll)           // Caret isn't visible
        goto scrollit;                              //  scroll it into view
    else
    {
not_visible:
        // Caret isn't visible, don't show it
        _xCaret = -32000;
        _yCaret = -32000;
        _yHeightCaret = 1;
    }

    // Now update caret for real on screen. We only want to show the caret
    // if it is in the view and there is no selection.
    if(ped->_fFocus && _fShowCaret)
    {
        CreateCaret();
        ped->TxShowCaret(TRUE);
    }
    return FALSE;

scrollit:
    if(fAutoVScroll)
    {
        // Scroll to top for cp = 0. This is important if the first line
        // contains object(s) taller than the client area is high.  The
        // resulting behavior agrees with the Word UI in all ways except in
        // Backspacing (deleting) the char at cp = 0 when it is followed by
        // other chars that preceed the large object.
        if(!GetCp())
            yScroll = 0;

        else if(yBase - yAscent - yAbove < yViewTop)            // Top invisible
            yScroll -= yViewTop - (yBase - yAscent - yAbove);   // Make it so

        else if(yBase + yDescent + yBelow > yViewBottom)        // Bottom invisible
        {
            yScroll += yBase + yDescent + yBelow - yViewBottom; // Make it so

            // Don't do following special adjust if the current line is bigger
            // than the client area
            if(rp->_yHeight < yViewBottom - yViewTop)
            {
                yScroll = _pdp->AdjustToDisplayLastLine(yBase + rp->_yHeight,
                    yScroll);
            }
        }
    }
    if(fAutoHScroll)
    {
        if(_xCaret < rcView.left)                           // Left invisible
        {
            xScroll -= rcView.left - _xCaret;               // Make it visible
            if(xScroll > 0)                                 // Scroll left in
            {                                               //  chunks to make
                xScroll -= xWidthView / 3;                  //  typing faster
                xScroll = max(0, xScroll);
            }
        }
        else if(_xCaret + GetCaretDelta() > rcView.right)   // right invisible
        {                                                   // Make it visible
            xScroll += _xCaret + dxCaret - rcView.left      // We don't scroll
                    - xWidthView;                           // in chunks because
        }                                                   // this more edit
    }                                                       // control like.
    if(yScroll != _pdp->GetYScroll() || xScroll != _pdp->GetXScroll())
    {
        if (_pdp->ScrollView(xScroll, yScroll, FALSE, FALSE) == FALSE)
        {
            if(ped->_fFocus && _fShowCaret)
            {
                CreateCaret();
                ped->TxShowCaret(TRUE);
            }
            return FALSE;
        }
        return TRUE;
    }
    return FALSE;
}

/*
 *  CTxtSelection::GetCaretHeight(pyDescent)
 *
 *  @mfunc
 *      Add a given amount to _xCaret (to make special case of inserting
 *      a character nice and fast)
 *
 *  @rdesc
 *      Caret height, <lt> 0 if failed
 */
INT CTxtSelection::GetCaretHeight (
    INT *pyDescent) const       //@parm Out parm to receive caret descent
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::GetCaretHeight");
                                // (undefined if the return value is <lt> 0)
    _TEST_INVARIANT_

    CLock lock;                     // Uses global (shared) FontCache
    CTxtEdit *ped = GetPed();
    const CCharFormat *pCF = ped->GetCharFormat(_iFormat);
    const CDevDesc *pdd = _pdp->GetDdRender();

    HDC hdc = pdd->GetDC();
    if(!hdc)
        return -1;

    LONG yHeight = -1;
    LONG dypInch = MulDiv(GetDeviceCaps(hdc, LOGPIXELSY), _pdp->GetZoomNumerator(), _pdp->GetZoomDenominator());
    CCcs *pccs = fc().GetCcs(pCF, dypInch);
    if(!pccs)
        goto ret;

    LONG yOffset, yAdjust;
    pccs->GetOffset(pCF, dypInch, &yOffset, &yAdjust);

    SHORT   yAdjustFE;
    yAdjustFE = pccs->AdjustFEHeight(!fUseUIFont() && ped->_pdp->IsMultiLine());
    if(pyDescent)
        *pyDescent = pccs->_yDescent + yAdjustFE - yAdjust - yOffset;

    yHeight = pccs->_yHeight + (yAdjustFE << 1);

    pccs->Release();
ret:
    pdd->ReleaseDC(hdc);
    return yHeight;
}

/*
 *  CTxtSelection::ShowCaret(fShow)
 *
 *  @mfunc
 *      Hide or show caret
 *
 *  @rdesc
 *      TRUE if caret was previously shown, FALSE if it was hidden
 */
BOOL CTxtSelection::ShowCaret (
    BOOL fShow)     //@parm TRUE for showing, FALSE for hiding
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::ShowCaret");

    _TEST_INVARIANT_

    const BOOL fRet = _fShowCaret;

    if(fRet != fShow)
    {
        _fShowCaret = fShow;
        if(GetPed()->_fFocus || GetPed()->fInOurHost())
        {
            if(fShow && !_fCaretCreated)
                CreateCaret();
            GetPed()->TxShowCaret(fShow);
        }
    }
    return fRet;
}

/*
 *  CTxtSelection::IsCaretInView()
 *
 *  @mfunc
 *      Returns TRUE iff caret is inside visible view
 */
BOOL CTxtSelection::IsCaretInView() const
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::IsCaretInView");

    _TEST_INVARIANT_

    RECT rc;
    _pdp->GetViewRect(rc);

    return  (_xCaret + dxCaret       > rc.left) &&
            (_xCaret                 < rc.right) &&
            (_yCaret + _yHeightCaret > rc.top) &&
            (_yCaret                 < rc.bottom);
}

/*
 *  CTxtSelection::CaretNotAtBOL()
 *
 *  @mfunc
 *      Returns TRUE iff caret is not allowed at BOL
 */
BOOL CTxtSelection::CaretNotAtBOL() const
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::CaretNotAtBOL");

    _TEST_INVARIANT_

    return _cch ? (_cch > 0) : _fCaretNotAtBOL;
}

/*
 *  CTxtSelection::LineLength(pcch)
 *
 *  @mfunc
 *      get # unselected chars on lines touched by current selection
 *
 *  @rdesc
 *      said number of chars
 */
LONG CTxtSelection::LineLength(
    LONG *pcp) const
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::LineLength");

    _TEST_INVARIANT_

    LONG     cch;
    CLinePtr rp(_pdp);

    if(!_cch)                           // Insertion point
    {
        rp.RpSetCp(GetCp(), _fCaretNotAtBOL);
        cch = rp.GetAdjustedLineLength();
        *pcp = GetCp() - rp.RpGetIch();
    }
    else
    {
        LONG cpMin, cpMost, cchLast;
        GetRange(cpMin, cpMost);
        rp.RpSetCp(cpMin, FALSE);       // Selections can't start at EOL
        cch = rp.RpGetIch();
        *pcp = cpMin - cch;
        rp.RpSetCp(cpMost, TRUE);       // Selections can't end at BOL

        // Remove trailing EOP, if it exists and isn't already selected
        cchLast = rp.GetAdjustedLineLength() - rp.RpGetIch();
        if(cchLast > 0)
            cch += cchLast;
    }
    return cch;
}

/*
 *  CTxtSelection::ShowSelection(fShow)
 *
 *  @mfunc
 *      Update, hide or show selection on screen
 *
 *  @rdesc
 *      TRUE iff selection was previously shown
 */
BOOL CTxtSelection::ShowSelection (
    BOOL fShow)         //@parm TRUE for showing, FALSE for hiding
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::ShowSelection");

    _TEST_INVARIANT_

    const BOOL fShowPrev = _fShowSelection;
    const BOOL fInplaceActive = GetPed()->fInplaceActive();
    LONG cpSelSave = _cpSel;
    LONG cchSelSave = _cchSel;

    // Sleep(1000);
    _fShowSelection = fShow;

    if(fShowPrev && !fShow)
    {
        if(cchSelSave)          // Hide old selection
        {
            // Set up selection before telling the display to update
            _cpSel = 0;
            _cchSel = 0;

            if(fInplaceActive)
                _pdp->InvertRange(cpSelSave, cchSelSave, selSetNormal);
        }
    }
    else if(!fShowPrev && fShow)
    {
        if(_cch)                                // Show new selection
        {
            // Set up selection before telling the display to update
            _cpSel = GetCp();
            _cchSel = _cch;

            if(fInplaceActive)
                _pdp->InvertRange(GetCp(), _cch, selSetHiLite);
        }
    }
    return fShowPrev;
}

/*
 *  CTxtSelection::UpdateSelection()
 *
 *  @mfunc
 *      Updates selection on screen
 *
 *  Note:
 *      This method inverts the delta between old and new selections
 */
void CTxtSelection::UpdateSelection()
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::UpdateSelection");

    _TEST_INVARIANT_

    LONG    cp = GetCp();
    LONG    cpNA    = cp - _cch;
    LONG    cpSelNA = _cpSel - _cchSel;
    LONG    cpMin, cpMost;
    LONG    cpMinSel = 0;
    LONG    cpMostSel = 0;
    CObjectMgr* pobjmgr = NULL;
    LONG    NumObjInSel = 0, NumObjInOldSel = 0;
    LONG    cpSelSave = _cpSel;
    LONG    cchSelSave = _cchSel;

    GetRange(cpMin, cpMost);

    //We need to know if there were objects is the previous and current
    //selections to determine how they should be selected.
    if(GetPed()->HasObjects())
    {
        pobjmgr = GetPed()->GetObjectMgr();
        if(pobjmgr)
        {
            CTxtRange   tr(GetPed(), _cpSel, _cchSel);

            tr.GetRange(cpMinSel, cpMostSel);
            NumObjInSel = pobjmgr->CountObjectsInRange(cpMin, cpMost);
            NumObjInOldSel = pobjmgr->CountObjectsInRange(cpMinSel, cpMostSel);
        }
    }

    //If the old selection contained a single object and nothing else
    //we need to notify the object manager that this is no longer the
    //case if the selection is changing.
    if (NumObjInOldSel && (abs(_cchSel) == 1) &&
        !(cpMin == cpMinSel && cpMost == cpMostSel))
    {
        if(pobjmgr)
            pobjmgr->HandleSingleSelect(GetPed(), cpMinSel, /* fHilite */ FALSE);
    }

    // Update selection data before the invert so the selection can be
    // painted by the render
    _cpSel  = GetCp();
    _cchSel = _cch;

    if(_fShowSelection)
    {
        if(!_cch || !cchSelSave ||              // Old/new selection missing,
            cpMost < min(cpSelSave, cpSelNA) || //  or new preceeds old,
            cpMin  > max(cpSelSave, cpSelNA))   //  or new follows old, so
        {                                       //  they don't intersect
            if(_cch)
                _pdp->InvertRange(cp, _cch, selSetHiLite);
            if(cchSelSave)
                _pdp->InvertRange(cpSelSave, cchSelSave, selSetNormal);
        }
        else
        {
            if(cpNA != cpSelNA)                 // Old & new dead ends differ
            {                                   // Invert text between them
                _pdp->InvertRange(cpNA, cpNA - cpSelNA, selUpdateNormal);
            }
            if(cp != cpSelSave)                 // Old & new active ends differ
            {                                   // Invert text between them
                _pdp->InvertRange(cp, cp - cpSelSave, selUpdateHiLite);
            }
        }
    }

    // If new selection contains a single object and nothing else, we need
    // to notify object manager as long as it's not the same object.
    if (NumObjInSel && abs(_cch) == 1 &&
        (cpMin != cpMinSel || cpMost != cpMostSel))
    {
        if(pobjmgr)
            pobjmgr->HandleSingleSelect(GetPed(), cpMin, /* fHiLite */ TRUE);
    }
}

/*
 *  CTxtSelection::SetSelection(cpFirst, cpMost)
 *
 *  @mfunc
 *      Set selection between two cp's
 *
 *  @devnote
 *      <p cpFirst> and <p cpMost> must be greater than 0, but may extend
 *      past the current max cp.  In that case, the cp will be truncated to
 *      the max cp (at the end of the text).
 */
void CTxtSelection::SetSelection (
    LONG cpMin,             //@parm Start of selection and dead end
    LONG cpMost)            //@parm End of selection and active end
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::SetSelection");

    _TEST_INVARIANT_
    CTxtEdit *ped = GetPed();

    StopGroupTyping();

    if(ped->HasObjects())
    {
        CObjectMgr* pobjmgr = GetPed()->GetObjectMgr();
        if(pobjmgr)
        {
			COleObject *pobjactive = pobjmgr->GetInPlaceActiveObject();
			if (pobjactive)
			{
				if (pobjactive != pobjmgr->GetObjectFromCp(cpMin) || cpMost - cpMin > 1)
					pobjactive->DeActivateObj();
			}
        }
    }

    _fCaretNotAtBOL = FALSE;            // Put caret for ambiguous cp at BOL
    Set(cpMost, cpMost - cpMin);        // Set() validates cpMin, cpMost

    if(GetPed()->fInplaceActive())              // Inplace active:
        Update(!ped->Get10Mode() ? TRUE : !ped->fHideSelection());  //  update selection now
    else
    {
        // Update selection data used for screen display so whenever we
        // get displayed the selection will be displayed.
        _cpSel  = GetCp();
        _cchSel = _cch;

        if(!ped->fHideSelection())
        {
            // Selection isn't hidden so tell container to update display
            // when it feels like.
            ped->TxInvalidateRect(NULL, FALSE);
            ped->TxUpdateWindow();
        }
    }
    CancelModes();                      // Cancel word selection mode
}

/*
 *  CTxtSelection::PointInSel(pt, prcClient, Hit)
 *
 *  @mfunc
 *      Figures whether a given point is within the selection
 *
 *  @rdesc
 *      TRUE if point inside selection, FALSE otherwise
 */
BOOL CTxtSelection::PointInSel (
    const POINT pt,         //@parm Point in containing window client coords
    const RECT *prcClient,  //@parm Client rectangle can be NULL if active
    HITTEST     Hit) const  //@parm May be computer Hit value
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::PointInSel");
    _TEST_INVARIANT_

    if(!_cch || Hit && Hit < HT_Text)   // Degenerate range (no selection):
        return FALSE;                   //  mouse can't be in, or Hit not
                                        //  in text
    LONG cpActual;
    _pdp->CpFromPoint(pt, prcClient, NULL, NULL, FALSE, &Hit, NULL, &cpActual);

    if(Hit < HT_Text)
        return FALSE;

    LONG cpMin,  cpMost;
    GetRange(cpMin, cpMost);

    return cpActual >= cpMin && cpActual < cpMost;
}


//////////////////////////////////  Selection with the mouse  ///////////////////////////////////

/*
 *  CTxtSelection::SetCaret(pt, fUpdate)
 *
 *  @mfunc
 *      Sets caret at a given point
 *
 *  @devnote
 *      In the plain-text case, placing the caret at the beginning of the
 *      line following the final EOP requires some extra code, since the
 *      underlying rich-text engine doesn't assign a line to a final EOP
 *      (plain-text doesn't currently have the rich-text final EOP).  We
 *      handle this by checking to see if the count of lines times the
 *      plain-text line height is below the actual y position.  If so, we
 *      move the cp to the end of the story.
 */
void CTxtSelection::SetCaret(
    const POINT pt,     //@parm Point of click
    BOOL fUpdate)       //@parm If TRUE, update the selection/caret
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::SetCaret");

    _TEST_INVARIANT_

    LONG        cp, cpActual;
    CDispDim    dispdim;
    HITTEST     Hit;
    RECT        rcView;
    CLinePtr    rp(_pdp);
    CRchTxtPtr  rtp(GetPed());
    LONG        y;

    StopGroupTyping();

    // Set caret at point
    if(_pdp->CpFromPoint(pt, NULL, &rtp, &rp, FALSE, &Hit, &dispdim, &cpActual) >= 0)
    {
        cp = rtp.GetCp();

        // If the resolved CP is greater than the cp we are above, then we
        // want to stay backwards.
        BOOL fBeforeCp = cp <= cpActual;

        // Set selection to the correct location.  If plain-text
        // multiline control, we need to check to see if pt.y is below
        // the last line of text.  If so and if the text ends with an EOP,
        // we need to set the cp at the end of the story and set up to
        // display the caret at the beginning of the line below the last
        // line of text
        if(!IsRich() && _pdp->IsMultiLine())        // Plain-text,
        {                                           //  multiline control
            _pdp->GetViewRect(rcView, NULL);
            y = pt.y + _pdp->GetYScroll() - rcView.top;

            if(y > rp.Count()*rp->_yHeight)         // Below last line of
            {                                       //  text
                rtp.Advance(tomForward);            // Move rtp to end of text
                if(rtp._rpTX.IsAfterEOP())          // If text ends with an
                {                                   //  EOP, set up to move
                    cp = rtp.GetCp();               //  selection there
                    rp.AdvanceCp(-rp.GetIch());     // Set rp._ich = 0 to
                }                                   //  set _fCaretNotAtBOL
            }                                       //  = FALSE to display
        }                                           //  caret at next BOL

        Set(cp, 0);
        if(GetPed()->IsBiDi())
        {
            if(!fBeforeCp)
                _rpCF.AdjustBackward();
            else
                _rpCF.AdjustForward();
            Set_iCF(_rpCF.GetFormat());
        }
        _fCaretNotAtBOL = rp.RpGetIch() != 0;   // Caret OK at BOL if click
        if(fUpdate)
            Update(TRUE);
        else
            UpdateForAutoWord();

        _SelMode = smNone;                      // Cancel word selection mode
    }
}

/*
 *  CTxtSelection::SelectWord(pt)
 *
 *  @mfunc
 *      Select word around a given point
 */
void CTxtSelection::SelectWord (
    const POINT pt)         //@parm Point of click
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::SelectWord");

    _TEST_INVARIANT_

    // Get rp where the hit is
    if(_pdp->CpFromPoint(pt, NULL, this, NULL, FALSE) >= 0)
    {
        // Extend both active and dead ends on word boundaries
        _cch = 0;                           // Start with IP at pt
        SetExtend(FALSE);
        FindWordBreak(WB_MOVEWORDRIGHT);    // Go to end of word
        SetExtend(TRUE);
        FindWordBreak(WB_MOVEWORDLEFT);     // Extend to start of word
        GetRange(_cpAnchorMin, _cpAnchorMost);
        GetRange(_cpWordMin, _cpWordMost);

        if(!_fInAutoWordSel)
            _SelMode = smWord;

        // cpMost needs to be the active end
        if(_cch < 0)
            FlipRange();
        Update(FALSE);
    }
}

/*
 *  CTxtSelection::SelectUnit(pt, Unit)
 *
 *  @mfunc
 *      Select line/paragraph around a given point and enter
 *      line/paragraph selection mode. In Outline View, convert
 *      SelectLine to SelectPara, and SelectPara to SelectPara
 *      along with all subordinates
 */
void CTxtSelection::SelectUnit (
    const POINT pt,     //@parm Point of click
    LONG        Unit)   //@parm tomLine or tomParagraph
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::SelectPara");

    _TEST_INVARIANT_

    AssertSz(Unit == tomLine || Unit == tomParagraph,
        "CTxtSelection::SelectPara: Unit must equal tomLine/tomParagraph");

    LONG     nHeading;
    CLinePtr rp(_pdp);

    // Get rp and selection active end where the hit is
    if(_pdp->CpFromPoint(pt, NULL, this, &rp, FALSE) >= 0)
    {
        LONG cchBackward, cchForward;
        BOOL fOutline = IsInOutlineView();

        if(Unit == tomLine && !fOutline)            // SelectLine
        {
            _cch = 0;                               // Start with insertion
            cchBackward = -rp.RpGetIch();           //  point at pt
            cchForward  = rp->_cch;
            _SelMode = smLine;
        }
        else                                        // SelectParagraph
        {
            cchBackward = rp.FindParagraph(FALSE);  // Go to start of para
            cchForward  = rp.FindParagraph(TRUE);   // Extend to end of para
            _SelMode = smPara;
        }
        SetExtend(FALSE);
        Advance(cchBackward);

        if(Unit == tomParagraph && fOutline)        // Move para in outline
        {                                           //  view
            rp.AdjustBackward();                    // If heading, include
            nHeading = rp.GetHeading();             //  subordinate paras
            if(nHeading)
            {
                for(; rp.NextRun(); cchForward += rp->_cch)
                {
                    LONG n = rp.GetHeading();
                    if(n && n <= nHeading)
                        break;
                }
            }
        }
        SetExtend(TRUE);
        Advance(cchForward);
        GetRange(_cpAnchorMin, _cpAnchorMost);
        Update(FALSE);
    }
}

/*
 *  CTxtSelection::SelectAll()
 *
 *  @mfunc
 *      Select all text in story
 */
void CTxtSelection::SelectAll()
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::SelectAll");

    _TEST_INVARIANT_

    StopGroupTyping();

    LONG cchText = GetTextLength();

    Set(cchText,  cchText);
    Update(FALSE);
}

/*
 *  CTxtSelection::ExtendSelection(pt)
 *
 *  @mfunc
 *      Extend/Shrink selection (moves active end) to given point
 */
void CTxtSelection::ExtendSelection (
    const POINT pt)     //@parm Point to extend to
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::ExtendSelection");

    _TEST_INVARIANT_

    LONG        cch;
    LONG        cchPrev = _cch;
    LONG        cp;
    LONG        cpMin, cpMost;
    BOOL        fAfterEOP;
    const BOOL  fWasInAutoWordSel = _fInAutoWordSel;
    INT         iDir = 0;
    CTxtEdit *  ped = GetPed();
    CLinePtr    rp(_pdp);
    CRchTxtPtr  rtp(ped);

    StopGroupTyping();

    // Get rp and rtp at the point pt
    if(_pdp->CpFromPoint(pt, NULL, &rtp, &rp, TRUE) < 0)
        return;

    // If we are in word, line, or paragraph select mode, we need to make
    // sure the active end is correct.  If we are extending backward from
    // the first Unit selected, we want the active end to be at cpMin. If
    // we are extending forward from the first Unit selected, we want the
    // active end to be at cpMost.
    if(_SelMode != smNone)
    {
        cch = _cpAnchorMost - _cpAnchorMin;
        GetRange(cpMin, cpMost);
        cp = rtp.GetCp();

        if(cp <= cpMin  && _cch > 0)            // If active end changes,
            Set(_cpAnchorMin, -cch);            //  select the original
                                                //  Unit (will be extended
        if(cp >= cpMost && _cch < 0)            //  below)
            Set(_cpAnchorMost, cch);
    }

    SetExtend(TRUE);
    cch = rp.RpGetIch();
    if(_SelMode > smWord && cch == rp->_cch)    // If in line or para select
    {                                           //  modes and pt at EOL,
        rtp.Advance(-cch);                      //  make sure we stay on that
        rp.RpAdvanceCp(-cch);                   //  line
        cch = 0;
    }

    SetCp(rtp.GetCp());                         // Move active end to pt
                                                // Caret OK at BOL _unless_
    _fCaretNotAtBOL = _cch > 0;                 //  forward selection
                                                // Now adjust selection
    if(_SelMode == smLine)                      //  depending on mode
    {                                           // Extend selection by line
        if(_cch >= 0)                           // Active end at cpMost
            cch -= rp->_cch;                    // Setup to add chars to EOL
        Advance(-cch);
    }
    else if(_SelMode == smPara)
        Advance(rp.FindParagraph(_cch >= 0));   // Extend selection by para

    else
    {
        // If the sign of _cch has changed this means that the direction
        // of the selection is changing and we want to reset the auto
        // selection information.
        if((_cch ^ cchPrev) < 0)
        {
            _fAutoSelectAborted = FALSE;
            _cpWordMin  = _cpAnchorMin;
            _cpWordMost = _cpAnchorMost;
        }

        cp = rtp.GetCp();
        fAfterEOP = rtp._rpTX.IsAfterEOP();

        _fInAutoWordSel = _SelMode != smWord && GetPed()->TxGetAutoWordSel()
            && !_fAutoSelectAborted
            && (cp < _cpWordMin || cp > _cpWordMost);

        if(_fInAutoWordSel && !fWasInAutoWordSel)
        {
            CTxtPtr txtptr(GetPed(), _cpAnchor);

            // Extend both ends dead to word boundaries
            ExtendToWordBreak(fAfterEOP,
                _cch < 0 ? WB_MOVEWORDLEFT : WB_MOVEWORDRIGHT);

            if(_cch < 0)
            {
                // Direction is left so update word border on left
                _cpWordPrev = _cpWordMin;
                _cpWordMin = GetCp();
            }
            else
            {
                // Direction is right so update word border on right
                _cpWordPrev = _cpWordMost;
                _cpWordMost = GetCp();
            }

            // If we are at start of a word already, we don't need to extend
            // selection in other direction
            if(!txtptr.IsAtBOWord() && txtptr.GetChar() != ' ')
            {
                FlipRange();
                Advance(_cpAnchor - GetCp());   // Extend from anchor

                FindWordBreak(_cch < 0 ? WB_MOVEWORDLEFT : WB_MOVEWORDRIGHT);

                if(_cch > 0)                // Direction is right so
                    _cpWordMost = GetCp();  //  update word border on right
                else                        // Direction is left so
                    _cpWordMin = GetCp();   //  update word border on left
                FlipRange();
            }
        }
        else if(_fInAutoWordSel || _SelMode == smWord)
        {
            // Save direction
            iDir = cp <= _cpWordMin ? WB_MOVEWORDLEFT : WB_MOVEWORDRIGHT;

            if(_SelMode == smWord)          // Extend selection by word
            {
                if(cp > _cpAnchorMost || cp < _cpAnchorMin)
                    FindWordBreak(iDir);
                else if(_cch <= 0)          // Maintain current active end
                    Set(_cpAnchorMin, _cpAnchorMin - _cpAnchorMost);
                else
                    Set(_cpAnchorMost, _cpAnchorMost - _cpAnchorMin);
            }
            else
                ExtendToWordBreak(fAfterEOP, iDir);

            if(_fInAutoWordSel)
            {
                if(WB_MOVEWORDLEFT == iDir)
                {
                    // Direction is left so update word border on left
                    _cpWordPrev = _cpWordMin;
                    _cpWordMin = GetCp();
                }
                else
                {
                    // Direction is right so update word border on right
                    _cpWordPrev = _cpWordMost;
                    _cpWordMost = GetCp();
                }
            }
        }
        else if(fWasInAutoWordSel)
        {
            // If we are in between where the previous word ended and
            // the cp we auto selected to, then we want to stay in
            // auto select mode.
            if(_cch < 0)
            {
                if(cp >= _cpWordMin && cp < _cpWordPrev)
                {
                    // Set direction for end of word search
                    iDir = WB_MOVEWORDLEFT;

                    // Mark that we are still in auto select mode
                    _fInAutoWordSel = TRUE;
                }
            }
            else if(cp <= _cpWordMost && cp >= _cpWordPrev)
            {
                // Mark that we are still in auto select mode
                _fInAutoWordSel = TRUE;

                // Set direction for end of word search
                iDir = WB_MOVEWORDRIGHT;
            }

            //We have to check to see if we are on the boundary between
            //words because we don't want to extend the selection until
            //we are actually beyond the current word.
            if(cp != _cpWordMost && cp != _cpWordMin)
            {
                if(_fInAutoWordSel)
                {
                    // Auto selection still on so make sure we have the
                    // entire word we are on selected
                    ExtendToWordBreak(fAfterEOP, iDir);
                }
                else
                {
                    // FUTURE: Word has a behavior where it extends the
                    // selection one word at a time unless you back up
                    // and then start extending the selection again, in
                    // which case it extends one char at a time.  We
                    // follow this behavior.  However, Word will resume
                    // extending a word at a time if you continue extending
                    // for several words.  We just keep extending on char
                    // at a time.  We might want to change this sometime.

                    _fAutoSelectAborted = TRUE;
                }
            }
        }

        if(_fAutoSelectAborted)
        {
            // If we are in the range of a word we previously selected
            // we want to leave that selected. If we have moved back
            // a word we want to pop back an entire word. Otherwise,
            // leave the cp were it is.
            if(_cch < 0)
            {
                if(cp > _cpWordMin && cp < _cpWordPrev)
                {
                    // In the range leave the range at the beginning of the word
                    ExtendToWordBreak(fAfterEOP, WB_MOVEWORDLEFT);
                }
                else if(cp >= _cpWordPrev)
                {
                    AutoSelGoBackWord(&_cpWordMin,
                        WB_MOVEWORDRIGHT, WB_MOVEWORDLEFT);
                }
            }
            else if(cp < _cpWordMost && cp >= _cpWordPrev)
            {
                // In the range leave the range at the beginning of the word
                ExtendToWordBreak(fAfterEOP, WB_MOVEWORDRIGHT);
            }
            else if(cp < _cpWordPrev)
            {
                AutoSelGoBackWord(&_cpWordMost,
                    WB_MOVEWORDLEFT, WB_MOVEWORDRIGHT);
            }
        }
    }
    // An OLE object cannot have an anchor point <b> inside </b> it,
    // but sometimes we'd like it to behave like a word. So, if
    // the direction changed, the object has to stay selected --
    // this is the "right thing" (kind of word selection mode)

    // If we had something selected and the direction changed
    if(cchPrev && (_cch ^ cchPrev) < 0)
    {
        FlipRange();

        // See if an object was selected on the other end
        BOOL fObjectWasSelected = (_cch > 0 ? _rpTX.GetChar() : GetPrevChar())
                                    == WCH_EMBEDDING;
        // If it was, we want it to stay selected
        if(fObjectWasSelected)
            Advance(_cch > 0 ? 1 : -1);

        FlipRange();
    }
    Update(TRUE);
}

/*
 *  CTxtSelection::ExtendToWordBreak (fAfterEOP, iAction)
 *
 *  @mfunc
 *      Moves active end of selection to the word break in the direction
 *      given by iDir unless fAfterEOP = TRUE.  When this is TRUE, the
 *      cursor just follows an EOP marker and selection should be suppressed.
 *      Otherwise moving the cursor to the left of the left margin would
 *      select the EOP on the line above, and moving the cursor to the
 *      right of the right margin would select the first word in the line
 *      below.
 */
void CTxtSelection::ExtendToWordBreak (
    BOOL fAfterEOP,     //@parm Cursor is after an EOP
    INT  iAction)       //@parm Word break action (WB_MOVEWORDRIGHT/LEFT)
{
    if(!fAfterEOP)
        FindWordBreak(iAction);
}

/*
 *  CTxtSelection::CancelModes(fAutoWordSel)
 *
 *  @mfunc
 *      Cancel either all modes or Auto Select Word mode only
 */
void CTxtSelection::CancelModes (
    BOOL fAutoWordSel)      //@parm TRUE cancels Auto Select Word mode only
{                           //     FALSE cancels word, line and para sel mode
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::CancelModes");
    _TEST_INVARIANT_

    if(fAutoWordSel)
    {
        if(_fInAutoWordSel)
        {
            _fInAutoWordSel = FALSE;
            _fAutoSelectAborted = FALSE;
        }
    }
    else
        _SelMode = smNone;
}


///////////////////////////////////  Keyboard movements  ////////////////////////////////////

/*
 *  CTxtSelection::Left(fCtrl)
 *
 *  @mfunc
 *      do what cursor-keypad left-arrow key is supposed to do
 *
 *  @rdesc
 *      TRUE iff movement occurred
 *
 *  @comm
 *      Left/Right-arrow IPs can go to within one character (treating CRLF
 *      as a character) of EOL.  They can never be at the actual EOL, so
 *      _fCaretNotAtBOL is always FALSE for these cases.  This includes
 *      the case with a right-arrow collapsing a selection that goes to
 *      the EOL, i.e, the caret ends up at the next BOL.  Furthermore,
 *      these cases don't care whether the initial caret position is at
 *      the EOL or the BOL of the next line.  All other cursor keypad
 *      commands may care.
 *
 *  @devnote
 *      _fExtend is TRUE iff Shift key is pressed or being simulated
 */
BOOL CTxtSelection::Left (
    BOOL fCtrl)     //@parm TRUE iff Ctrl key is pressed (or being simulated)
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::Left");

    _TEST_INVARIANT_

    LONG cp;

    CancelModes();
    StopGroupTyping();

    if(!_fExtend && _cch)                       // Collapse selection to
    {                                           //  nearest whole Unit before
        if(fCtrl)                               //  cpMin
            Expander(tomWord, FALSE, NULL, &cp, NULL);
        Collapser(tomStart);                    // Collapse to cpMin
    }
    else                                        // Not collapsing selection
    {
        if (!GetCp() ||                         // Already at beginning of
            !BypassHiddenText(tomBackward))     //  story
        {
            Beep();
            return FALSE;
        }
        if(IsInOutlineView() && (_fSelHasEOP || // If outline view with EOP
            _fExtend && _rpTX.IsAfterEOP()))    //  now or will have after
        {                                       //  this command,
            return Up(FALSE);                   //  treat as up arrow
        }
        if(fCtrl)                               // WordLeft
            FindWordBreak(WB_MOVEWORDLEFT);
        else                                    // CharLeft
        {
            BackupCRLF();
            SnapToCluster(-1);
        }
    }

    _fCaretNotAtBOL = FALSE;                    // Caret always OK at BOL
    Update(TRUE);
    return TRUE;
}

/*
 *  CTxtSelection::Right(fCtrl)
 *
 *  @mfunc
 *      do what cursor-keypad right-arrow key is supposed to do
 *
 *  @rdesc
 *      TRUE iff movement occurred
 *
 *  @comm
 *      Right-arrow selection can go to the EOL, but the cp of the other
 *      end identifies whether the selection ends at the EOL or starts at
 *      the beginning of the next line.  Hence here and in general for
 *      selections, _fCaretNotAtBOL is not needed to resolve EOL/BOL
 *      ambiguities.  It should be set to FALSE to get the correct
 *      collapse character.  See also comments for Left() above.
 *
 *  @devnote
 *      _fExtend is TRUE iff Shift key is pressed or being simulated
 */
BOOL CTxtSelection::Right (
    BOOL fCtrl)     //@parm TRUE iff Ctrl key is pressed (or being simulated)
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::Right");

    _TEST_INVARIANT_

    LONG    cchText;
    LONG    cp;

    CancelModes();
    StopGroupTyping();

    if(!_fExtend && _cch)                       // Collapse selection to
    {                                           //  nearest whole Unit after
        if(fCtrl)                               //  cpMost
            Expander(tomWord, FALSE, NULL, NULL, &cp);
        Collapser(tomEnd);
    }
    else                                        // Not collapsing selection
    {
        cchText = _fExtend ? GetTextLength() : GetAdjustedTextLength();
        if (GetCp() >= cchText ||               // Already at end of story
            !BypassHiddenText(tomForward))
        {
            Beep();                             // Tell the user
            return FALSE;
        }
        if(IsInOutlineView() && _fSelHasEOP)    // If outline view with EOP
            return Down(FALSE);                 // Treat as down arrow
        if(fCtrl)                               // WordRight
            FindWordBreak(WB_MOVEWORDRIGHT);
        else                                    // CharRight
        {
            AdvanceCRLF();
            SnapToCluster();
        }
    }

    _fCaretNotAtBOL = _fExtend;                 // If extending to EOL, need
    Update(TRUE);                               //  TRUE to get _xCaretReally
    return TRUE;                                //  at EOL
}

/*
 *  CTxtSelection::Up(fCtrl)
 *
 *  @mfunc
 *      do what cursor-keypad up-arrow key is supposed to do
 *
 *  @rdesc
 *      TRUE iff movement occurred
 *
 *  @comm
 *      Up arrow doesn't go to EOL regardless of _xCaretPosition (stays
 *      to left of EOL break character), so _fCaretNotAtBOL is always FALSE
 *      for Up arrow.  Ctrl-Up/Down arrows always end up at BOPs or the EOD.
 *
 *  @devnote
 *      _fExtend is TRUE iff Shift key is pressed or being simulated
 */
BOOL CTxtSelection::Up (
    BOOL fCtrl)     //@parm TRUE iff Ctrl key is pressed (or being simulated)
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::Up");

    _TEST_INVARIANT_

    LONG        cchSave = _cch;                 // Save starting position for
    LONG        cpSave = GetCp();               //  change check
    BOOL        fCollapse = _cch && !_fExtend;  // Collapse nondegenerate sel
    BOOL        fPTNotAtEnd;
    CLinePtr    rp(_pdp);
    LONG        xCaretReally = _xCaretReally;   // Save desired caret x pos

    CancelModes();
    StopGroupTyping();

    if(fCollapse)                               // Collapse selection at cpMin
    {
        Collapser(tomTrue);
        _fCaretNotAtBOL = FALSE;                // Selections can't begin at
    }                                           //  EOL
    rp.RpSetCp(GetCp(), _fCaretNotAtBOL);       // Initialize line ptr

    if(fCtrl)                                   // Move to beginning of para
    {
        if(!fCollapse &&                        // If no selection collapsed
            rp > 0 && !rp.RpGetIch())           //  and are at BOL,
        {                                       //  backup to prev BOL to make
            rp--;                               //  sure we move to prev. para
            Advance(-rp->_cch);
        }
        Advance(rp.FindParagraph(FALSE));       // Go to beginning of para
        _fCaretNotAtBOL = FALSE;                // Caret always OK at BOL
    }
    else                                        // Move up a line
    {                                           // If on first line, can't go
        fPTNotAtEnd = !CheckPlainTextFinalEOP();//  up
        if(rp <= 0 && fPTNotAtEnd)
        {
            //if(!_fExtend)// &&_pdp->GetYScroll())
                UpdateCaret(TRUE);              // Be sure caret in view
        }
        else
        {
            LONG cch;
            BOOL fSelHasEOPInOV = IsInOutlineView() && _fSelHasEOP;
            if(fSelHasEOPInOV && _cch > 0)
            {
                rp.AdjustBackward();
                cch = rp->_cch;
                rp.AdvanceCp(-cch);             // Go to start of line
                Assert(!rp.GetIch());
                cch -= rp.FindParagraph(FALSE); // Ensure start of para in
            }                                   //  case of word wrap
            else
            {
                cch = 0;
                if(fPTNotAtEnd)
                {
                    cch = rp.RpGetIch();
                    rp--;
                }
                cch += rp->_cch;
            }
            Advance(-cch);                      // Move to previous BOL
            if(fSelHasEOPInOV && !_fSelHasEOP)  // If sel had EOP but doesn't
            {                                   //  after Advance, must be IP
                Assert(!_cch);                  // Suppress restore of
                xCaretReally = -1;              //  _xCaretReally
            }
            else if(!SetXPosition(xCaretReally, rp))// Set this cp corresponding
                Set(cpSave, cchSave);           //  to xCaretReally here, but
        }                                       //   agree on Down()
    }

    if(GetCp() == cpSave && _cch == cchSave)
    {
        // Continue to select to the beginning of the first line
        // This is what 1.0 is doing
        if(_fExtend)
            return Home(fCtrl);

        Beep();                                 // Nothing changed, so beep
        return FALSE;
    }

    Update(TRUE);                               // Update and then restore
    if(!_cch && !fCtrl && xCaretReally >= 0)    //  _xCaretReally conditionally
        _xCaretReally = xCaretReally;           // Need to use _cch instead of
                                                //  cchSave in case of collapse
    return TRUE;
}

/*
 *  CTxtSelection::Down(fCtrl)
 *
 *  @mfunc
 *      do what cursor-keypad down-arrow key is supposed to do
 *
 *  @rdesc
 *      TRUE iff movement occurred
 *
 *  @comm
 *      Down arrow can go to the EOL if the _xCaretPosition (set by
 *      horizontal motions) is past the end of the line, so
 *      _fCaretNotAtBOL needs to be TRUE for this case.
 *
 *  @devnote
 *      _fExtend is TRUE iff Shift key is pressed or being simulated
 */
BOOL CTxtSelection::Down (
    BOOL fCtrl)     //@parm TRUE iff Ctrl key is pressed (or being simulated)
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::Down");

    _TEST_INVARIANT_

    LONG        cch;
    LONG        cchSave = _cch;                 // Save starting position for
    LONG        cpSave = GetCp();               //  change check
    BOOL        fCollapse = _cch && !_fExtend;  // Collapse nondegenerate sel
    CLinePtr    rp(_pdp);
    LONG        xCaretReally = _xCaretReally;   // Save _xCaretReally

    CancelModes();
    StopGroupTyping();

    if(fCollapse)                               // Collapse at cpMost
    {
        Collapser(tomEnd);
        _fCaretNotAtBOL = TRUE;                 // Selections can't end at BOL
    }

    rp.RpSetCp(GetCp(), _fCaretNotAtBOL);
    if(fCtrl)                                   // Move to next para
    {
        Advance(rp.FindParagraph(TRUE));        // Go to end of para
        if(IsInOutlineView() && !BypassHiddenText(tomForward))
            SetCp(cpSave);
        else
            _fCaretNotAtBOL = FALSE;            // Next para is never at EOL
    }
    else if(_pdp->WaitForRecalcIli(rp + 1))     // Go to next line
    {
        LONG cch;
        BOOL fSelHasEOPInOV = IsInOutlineView() && _fSelHasEOP;
        if(fSelHasEOPInOV && _cch < 0)
            cch = rp.FindParagraph(TRUE);
        else
        {
            cch = rp.GetCchLeft();              // Advance selection to end
            rp++;                               //  of current line
        }
        Advance(cch);
        if(fSelHasEOPInOV && !_fSelHasEOP)      // If sel had EOP but doesn't
        {                                       //  after Advance, must be IP
            Assert(!_cch);                      // Suppress restore of
            xCaretReally = -1;                  //  _xCaretReally
        }
        else if(!SetXPosition(xCaretReally, rp))// Set *this to cp <--> x
            Set(cpSave, cchSave);               // If failed, restore sel
    }
    else if(!_fExtend)                          // No more lines to pass
        // && _pdp->GetYScroll() + _pdp->GetViewHeight() < _pdp->GetHeight())
    {
        if (!IsRich() && _pdp->IsMultiLine() && // Plain-text, multiline
            !_fCaretNotAtBOL)                   //  control with caret OK
        {                                       //  at BOL
            cch = Advance(rp.GetCchLeft());     // Advance selection to end
            if(!_rpTX.IsAfterEOP())             // If control doesn't end
                Advance(-cch);                  //  with EOP, go back
        }
        UpdateCaret(TRUE);                      // Be sure caret in view
    }

    if(GetCp() == cpSave && _cch == cchSave)
    {
        // Continue to select to the end of the lastline
        // This is what 1.0 is doing.
        if(_fExtend)
            return End(fCtrl);

        Beep();                                 // Nothing changed, so beep
        return FALSE;
    }

    Update(TRUE);                               // Update and then
    if(!_cch && !fCtrl && xCaretReally >= 0)    //  restore _xCaretReally
        _xCaretReally = xCaretReally;           // Need to use _cch instead of
    return TRUE;                                //  cchSave in case of collapse
}

/*
 *  CTxtSelection::SetXPosition(xCaret, rp)
 *
 *  @mfunc
 *      Put this text ptr at cp nearest to xCaret.  If xCaret is in right
 *      margin, we put caret either at EOL (for lines with no para mark),
 *      or just before para mark
 *
 *  @rdesc
 *      TRUE iff could create measurer
 */
BOOL CTxtSelection::SetXPosition (
    LONG        xCaret,     //@parm Desired horizontal coordinate
    CLinePtr&   rp)         //@parm Line ptr identifying line to check
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::SetXPosition");

    _TEST_INVARIANT_

    LONG        cch = 0;
    CMeasurer   me(_pdp, *this);

    if(IsInOutlineView())
    {
        BOOL fSelHasEOP = _fSelHasEOP;
        rp.AdjustForward();
        _fCaretNotAtBOL = FALSE;                // Leave at start of line
        while(rp->_fCollapsed)
        {
            if(_fMoveBack)
            {
                if(!rp.PrevRun())               // No more uncollapsed text
                    return FALSE;               //  before current cp
                cch -= rp->_cch;
            }
            else
            {
                cch += rp->_cch;
                if(!rp.NextRun())               // No more uncollapsed text
                    return FALSE;               //  after current cp
                if(_fExtend && _cch > 0)
                    _fCaretNotAtBOL = TRUE;     // Leave at end of line
            }
        }
        if(cch)
            Advance(cch);
        if(fSelHasEOP)
            return TRUE;
        if(cch)
            me.Advance(cch);
    }

    POINT pt = {xCaret, 0};
    CDispDim dispdim;
    HITTEST hit;
    cch = rp->CchFromXpos(me, pt, &dispdim, &hit);// Move out from start of line
    if(!_fExtend && cch == rp->_cch &&          // Not extending, at EOL,
        rp->_cchEOP)                            //  and have EOP:
    {                                           //  backup before EOP
        cch += me._rpTX.BackupCpCRLF();         // Note: me._rpCF/_rpPF
    }                                           //  are now inconsistent
    SetCp(me.GetCp());                          //  but doesn't matter since
    _fCaretNotAtBOL = cch != 0;                 //  me.GetCp() doesn't care

    return TRUE;
}

/*
 *  CTxtSelection::GetXCaretReally()
 *
 *  @mfunc
 *      Get _xCaretReally - horizontal scrolling + left margin
 *
 *  @rdesc
 *      x caret really
 */
LONG CTxtSelection::GetXCaretReally()
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::GetXCaretReally");

    _TEST_INVARIANT_

    RECT rcView;

    _pdp->GetViewRect(rcView);

    return _xCaretReally - _pdp->GetXScroll() + rcView.left;
}

/*
 *  CTxtSelection::Home(fCtrl)
 *
 *  @mfunc
 *      do what cursor-keypad Home key is supposed to do
 *
 *  @rdesc
 *          TRUE iff movement occurred
 *
 *  @devnote
 *      _fExtend is TRUE iff Shift key is pressed or being simulated
 */
BOOL CTxtSelection::Home (
    BOOL fCtrl)     //@parm TRUE iff Ctrl key is pressed (or being simulated)
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::Home");

    _TEST_INVARIANT_

    const LONG  cchSave = _cch;
    const LONG  cpSave  = GetCp();

    CancelModes();
    StopGroupTyping();

    if(fCtrl)                                   // Move to start of document
        SetCp(0);
    else
    {
        CLinePtr rp(_pdp);

        if(_cch && !_fExtend)                   // Collapse at cpMin
        {
            Collapser(tomStart);
            _fCaretNotAtBOL = FALSE;            // Selections can't start at
        }                                       //  EOL

        rp.RpSetCp(GetCp(), _fCaretNotAtBOL);   // Define line ptr for

        Advance(-rp.RpGetIch());                //  current state. Now BOL
    }
    _fCaretNotAtBOL = FALSE;                    // Caret always goes to BOL
    _fHomeOrEnd = TRUE;

    if(!MatchKeyboardToPara() && GetCp() == cpSave && _cch == cchSave)
    {
        Beep();                                 // No change, so beep
        _fHomeOrEnd = FALSE;
        return FALSE;
    }

    Update(TRUE);
    _fHomeOrEnd = FALSE;
    return TRUE;
}

/*
 *  CTxtSelection::End(fCtrl)
 *
 *  @mfunc
 *      do what cursor-keypad End key is supposed to do
 *
 *  @rdesc
 *      TRUE iff movement occurred
 *
 *  @comm
 *      On lines without paragraph marks (EOP), End can go all the way
 *      to the EOL.  Since this character position (cp) is the same as
 *      that for the start of the next line, we need _fCaretNotAtBOL to
 *      distinguish between the two possible caret positions.
 *
 *  @devnote
 *      _fExtend is TRUE iff Shift key is pressed or being simulated
 */
BOOL CTxtSelection::End (
    BOOL fCtrl)     //@parm TRUE iff Ctrl key is pressed (or being simulated)
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::End");

    _TEST_INVARIANT_

    LONG        cch;
    const LONG  cchSave = _cch;
    const LONG  cpSave  = GetCp();
    CLinePtr    rp(_pdp);

    CancelModes();
    StopGroupTyping();

    if(fCtrl)                                   // Move to end of document
    {
        SetCp(GetTextLength());
        _fCaretNotAtBOL = FALSE;
        goto Exit;
    }
    else if(!_fExtend && _cch)                  // Collapse at cpMost
    {
        Collapser(tomEnd);
        _fCaretNotAtBOL = TRUE;                 // Selections can't end at BOL
    }

    rp.RpSetCp(GetCp(), _fCaretNotAtBOL);       // Initialize line ptr

    cch = rp->_cch;                             // Default target pos in line
    Advance(cch - rp.RpGetIch());               // Move active end to EOL

    if(!_fExtend && rp->_cchEOP && _rpTX.IsAfterEOP())// Not extending and have EOP:
        cch += BackupCRLF();                          //  backup before EOP

    _fCaretNotAtBOL = cch != 0;                 // Decide ambiguous caret pos by whether at BOL

Exit:
    if(!MatchKeyboardToPara() && GetCp() == cpSave && _cch == cchSave)
    {
        Beep();                                 // No change, so Beep
        return FALSE;
    }

    _fHomeOrEnd = TRUE;
    Update(TRUE);
    _fHomeOrEnd = FALSE;
    return TRUE;
}

/*
 *  CTxtSelection::PageUp(fCtrl)
 *
 *  @mfunc
 *      do what cursor-keypad PgUp key is supposed to do
 *
 *  @rdesc
 *      TRUE iff movement occurred
 *
 *  @devnote
 *      _fExtend is TRUE iff Shift key is pressed or being simulated
 */
BOOL CTxtSelection::PageUp (
    BOOL fCtrl)     //@parm TRUE iff Ctrl key is pressed (or being simulated)
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::PageUp");

    _TEST_INVARIANT_

    const LONG  cchSave = _cch;
    const LONG  cpSave  = GetCp();
    LONG        xCaretReally = _xCaretReally;

    CancelModes();
    StopGroupTyping();

    if(_cch && !_fExtend)                       // Collapse selection
    {
        Collapser(tomStart);
        _fCaretNotAtBOL = FALSE;
    }

    if(fCtrl)                                   // Ctrl-PgUp: move to top
    {                                           //  of visible view for
        SetCp(_pdp->IsMultiLine()               //  multiline but top of
            ? _pdp->GetFirstVisibleCp() : 0);   //  text for SL
        _fCaretNotAtBOL = FALSE;
    }
    else if(_pdp->GetFirstVisibleCp() == 0)     // PgUp in top Pg: move to
    {                                           //  start of document
        SetCp(0);
        _fCaretNotAtBOL = FALSE;
    }
    else                                        // PgUp with scrolling to go
    {                                           // Scroll up one windowful
        ScrollWindowful(SB_PAGEUP);             //  leaving caret at same
    }                                           //  position in window

    if(GetCp() == cpSave && _cch == cchSave)    // Beep if no change
    {
        Beep();
        return FALSE;
    }

    Update(TRUE);
    if(GetCp())                                 // Maintain x offset on page
        _xCaretReally = xCaretReally;           //  up/down
    return TRUE;
}

/*
 *  CTxtSelection::PageDown(fCtrl)
 *
 *  @mfunc
 *      do what cursor-keypad PgDn key is supposed to do
 *
 *  @rdesc
 *      TRUE iff movement occurred
 *
 *  @devnote
 *      _fExtend is TRUE iff Shift key is pressed or being simulated
 */
BOOL CTxtSelection::PageDown (
    BOOL fCtrl)     //@parm TRUE iff Ctrl key is pressed (or being simulated)
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::PageDown");

    _TEST_INVARIANT_

    const LONG  cchSave         = _cch;
    LONG        cpMostVisible;
    const LONG  cpSave          = GetCp();
    POINT       pt;
    CLinePtr    rp(_pdp);
    LONG        xCaretReally    = _xCaretReally;

    CancelModes();
    StopGroupTyping();

    if(_cch && !_fExtend)                       // Collapse selection
    {
        Collapser(tomStart);
        _fCaretNotAtBOL = TRUE;
    }

    _pdp->GetCliVisible(&cpMostVisible, fCtrl);

    if(fCtrl)                                   // Move to end of last
    {                                           //  entirely visible line
        RECT rcView;

        SetCp(cpMostVisible);

        if(_pdp->PointFromTp(*this, NULL, TRUE, pt, &rp, TA_TOP) < 0)
            return FALSE;

        _fCaretNotAtBOL = TRUE;

        _pdp->GetViewRect(rcView);

        if(rp > 0 && pt.y + rp->_yHeight > rcView.bottom)
        {
            Advance(-rp->_cch);
            rp--;
        }

        if(!_fExtend && !rp.GetCchLeft() && rp->_cchEOP)
        {
            BackupCRLF();                       // After backing up over EOP,
            _fCaretNotAtBOL = FALSE;            //  caret can't be at EOL
        }
    }
    else if(cpMostVisible == GetTextLength())
    {                                           // Move to end of text
        SetCp(GetTextLength());
        _fCaretNotAtBOL = !_rpTX.IsAfterEOP();
    }
    else
    {
        if(!ScrollWindowful(SB_PAGEDOWN))       // Scroll down 1 windowful
            return FALSE;
    }

    if(GetCp() == cpSave && _cch == cchSave)    // Beep if no change
    {
        Beep();
        return FALSE;
    }

    Update(TRUE);
    _xCaretReally = xCaretReally;
    return TRUE;
}

/*
 *  CTxtSelection::ScrollWindowful(wparam)
 *
 *  @mfunc
 *      Sroll up or down a windowful
 *
 *  @rdesc
 *      TRUE iff movement occurred
 */
BOOL CTxtSelection::ScrollWindowful (
    WPARAM wparam)      //@parm SB_PAGEDOWN or SB_PAGEUP
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::ScrollWindowful");
                                                // Scroll windowful
    _TEST_INVARIANT_

    POINT pt;                                   //  leaving caret at same
    CLinePtr rp(_pdp);                          //  point on screen
    LONG cpFirstVisible = _pdp->GetFirstVisibleCp();
    LONG cpLastVisible;
    LONG cpMin;
    LONG cpMost;

    GetRange(cpMin, cpMost);

    // Get last character in the view
    _pdp->GetCliVisible(&cpLastVisible, TRUE);

    // Is active end in visible area of control?
    if((cpMin < cpFirstVisible && _cch <= 0) || (cpMost > cpLastVisible && _cch >= 0))
    {
        // Not in view - we need to calculate a new range for selection
        SetCp(cpFirstVisible);

        // Real caret postion is now at beginning of line
        _xCaretReally = 0;
    }

    if(_pdp->PointFromTp(*this, NULL, _fCaretNotAtBOL, pt, &rp, TA_TOP) < 0)
        return FALSE;

    // The point is visible so use that
    pt.x = _xCaretReally;
    pt.y += rp->_yHeight / 2;
    _pdp->VScroll(wparam, 0);

    if(_fExtend)
    {
        // Disable auto word select -- if we have to use ExtendSelection()
        // for non-mouse operations, let's try to get rid of its side-effects
        BOOL fInAutoWordSel = _fInAutoWordSel;
        _fInAutoWordSel = FALSE;
        ExtendSelection(pt);
        _fInAutoWordSel = fInAutoWordSel;
    }
    else
        SetCaret(pt, FALSE);

    return TRUE;
}

//////////////////////////// Keyboard support /////////////////////////////////

/*
 *  CTxtSelection::CheckChangeKeyboardLayout (BOOL fChangedFont)
 *
 *  @mfunc
 *      Change keyboard for new font, or font at new character position.
 *
 *  @comm
 *      Using only the currently loaded KBs, locate one that will support
 *      the insertion points font. This is called anytime a character format
 *      change occurs, or the insert font (caret position) changes.
 *
 *  @devnote
 *      The current KB is preferred. If a previous association
 *      was made, see if the KB is still loaded in the system and if so use
 *      it. Otherwise, locate a suitable KB, preferring KB's that have
 *      the same charset ID as their default, preferred charset. If no match
 *      can be made then nothing changes.
 */
void CTxtSelection::CheckChangeKeyboardLayout ()
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::CheckChangeKeyboardLayout");

    CTxtEdit * const ped = GetPed();                // Document context

    if (ped && ped->_fFocus && !ped->fUseUIFont() &&    // If ped, focus, not UIFont, & auto
        ped->IsAutoKeyboard() &&                        //  kbd, check kbd change
        !ped->_fIMEInProgress &&						//  not in IME composition and
		ped->GetAdjustedTextLength() &&					//  not empty control and
		_rpTX.GetPrevChar() != WCH_EMBEDDING)			//  not an object, then
    {													//  check kbd change
        LONG    iFormat = GetiFormat();

        const CCharFormat *pCF = ped->GetCharFormat(iFormat);
        BYTE bCharSet = pCF->_bCharSet;

        if (!IsFECharSet(bCharSet) &&
            (bCharSet != ANSI_CHARSET || !IsFELCID((WORD)GetKeyboardLayout(0))) &&
            !fc().GetInfoFlags(pCF->_iFont).fNonBiDiAscii)
        {
            // Don't do auto-kbd inside FE or single-codepage ASCII font.
            W32->CheckChangeKeyboardLayout(bCharSet);
        }
    }
}

/*
 *  CTxtSelection::CheckChangeFont (hkl, cpg, iSelFormat, dwCharFlag)
 *
 *  @mfunc
 *      Change font for new keyboard layout.
 *
 *  @comm
 *      If no previous preferred font has been associated with this KB, then
 *      locate a font in the document suitable for this KB.
 *
 *  @rdesc
 *      TRUE iff suitable font is found
 *
 *  @devnote
 *      This routine is called via WM_INPUTLANGCHANGEREQUEST message
 *      (a keyboard layout switch). This routine can also be called
 *      from WM_INPUTLANGCHANGE, but we are called more, and so this
 *      is less efficient.
 *
 *      Exact match is done via charset ID bitmask. If a match was previously
 *      made, use it. A user can force the insertion font to be associated
 *      to a keyboard if the control key is held through the KB changing
 *      process. The association is broken when another KB associates to
 *      the font. If no match can be made then nothing changes.
 */
bool CTxtSelection::CheckChangeFont (
    const HKL   hkl,            //@parm Keyboard Layout to go
    UINT        cpg,            //@parm code page to use (could be ANSI for FE with IME off)
    LONG        iSelFormat,     //@parm Format to use for selection case
    DWORD       dwCharFlag)     //@parm 0 if called from WM_INPUTLANGCHANGE/WM_INPUTLANGCHANGEREQUEST
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::CheckChangeFont");
    CTxtEdit * const ped = GetPed();

    if (!ped->IsAutoFont() ||           // EXIT if auto font is turned off
        _cch && !dwCharFlag)            //  or if kbd change with nondegenerate
        return true;                    //  selection (WM_INPUTLANGCHANGEREQUEST)

    // Set new format using current format and new KB info.
    LONG               iCurrentFormat = _cch ? iSelFormat : _iFormat;
    const CCharFormat *pCF = ped->GetCharFormat(iCurrentFormat);
    CCharFormat        CF = *pCF;
    WORD               wLangID = LOWORD(hkl);

    CF._lcid     = wLangID;
    CF._bCharSet = GetCharSet(cpg);

    if (pCF->_lcid == wLangID && CF._bCharSet == pCF->_bCharSet)
    {
        if (ped->_fFocus && IsCaretShown())
        {
            CreateCaret();
            ped->TxShowCaret(TRUE);
        }
        return true;
    }

    CCFRunPtr   rp(*this);
    int         iMatchFont = MATCH_FONT_SIG;

    // If current is a primary US or UK kbd. We allow matching ASCII fonts
    if ((!dwCharFlag || dwCharFlag & fASCII) &&
        PRIMARYLANGID(wLangID) == LANG_ENGLISH &&
        IN_RANGE (SUBLANG_ENGLISH_US, SUBLANGID(wLangID), SUBLANG_ENGLISH_UK) &&
        wLangID == HIWORD((DWORD_PTR)hkl))
    {
        iMatchFont |= MATCH_ASCII;
    }

    if (rp.GetPreferredFontInfo(
            cpg,
            CF._bCharSet,
            CF._iFont,
            CF._yHeight,
            CF._bPitchAndFamily,
            iCurrentFormat,
            iMatchFont))
    {
        if (W32->IsFECodePage(cpg) || cpg == CP_THAI)
            ped->OrCharFlags(GetFontSig((WORD)cpg) << 8);

        // FUTURE: turn current fBIDI into fRTL and make
        // fBIDI = (fRTL | fARABIC | fHEBREW). Then can combine following if
        // with preceding if
        else if (W32->IsBiDiCodePage(cpg))
            ped->OrCharFlags(fBIDI | (GetFontSig((WORD)cpg) << 8));

        if (!_cch)
        {
            SetCharFormat(&CF, SCF_NOKBUPDATE, NULL, CFM_FACE | CFM_CHARSET | CFM_LCID | CFM_SIZE, CFM2_NOCHARSETCHECK);
            if(ped->IsComplexScript())
                UpdateCaret(FALSE);
        }
        else
        {
            // Create a format and use it for the selection
            LONG    iCF;
            ICharFormatCache *pf = GetCharFormatCache();

            pf->Cache(&CF, &iCF);

#ifdef LINESERVICES
            if (g_pols)
                g_pols->DestroyLine(NULL);
#endif

            Set_iCF(iCF);
            pf->Release(iCF);                           // pf->Cache AddRef it
            _fUseiFormat = TRUE;
        }
        return true;
    }

    return false;
}


//////////////////////////// PutChar, Delete, Replace  //////////////////////////////////
/*
 *  CTxtSelection::PutChar(ch, dwFlags, publdr)
 *
 *  @mfunc
 *      Insert or overtype a character
 *
 *  @rdesc
 *      TRUE if successful
 */
BOOL CTxtSelection::PutChar (
    TCHAR       ch,         //@parm Char to put
    DWORD       dwFlags,    //@parm Overtype mode and whether keyboard input
    IUndoBuilder *publdr)   //@parm If non-NULL, where to put anti-events
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::PutChar");

    _TEST_INVARIANT_

    BOOL      fOver = dwFlags & 1;
    CTxtEdit *ped = GetPed();

    SetExtend(FALSE);

    if(ch == TAB && GetPF()->InTable())
    {
        LONG cpMin, cpMost;
        LONG cch = GetRange(cpMin, cpMost);
        LONG cch0 = 0;
        LONG iDir = GetKeyboardFlags() & SHIFT ? -1 : 1;
        if(_fSelHasEOP)                         // If selection has an EOP
        {                                       //  collapse to cpMin and
            Collapser(tomStart);                //  go forward
            iDir = 1;
            if(!GetPF()->InTable())
            {
                Update(TRUE);
                return TRUE;
            }
        }
        if((_cch ^ iDir) < 0)                   // If at cpMost going back or
            FlipRange();                        //  at cpMin going forward,
                                                //  switch active end
        CRchTxtPtr rtp(*this);

        CancelModes();
        StopGroupTyping();

        if(iDir < 0 || _cch)
            rtp.Advance(-1);

        // Scan for start/end of next/prev cell
        do
        {
            ch  = rtp.GetChar();
        } while(rtp.Advance(iDir) && ch != CELL && rtp.GetPF()->InTable());

        if(ch != CELL)
        {
            if(iDir < 0)
                return FALSE;
insertRow:  rtp.BackupCRLF();               // Tabbed past end of table:
            Set(rtp.GetCp(), 0);            //  insert new row
            return InsertEOP(publdr);
        }
        if(iDir > 0)                        // Check for IP between CELL
        {                                   //  and CR at row end
            if(rtp.GetChar() == CR)
                rtp.AdvanceCRLF();          // Bypass row end
        }
        for(cch = 0;                        // Determine cchSel
            (ch = rtp.GetChar()) != CELL && rtp.GetPF()->InTable();
            cch += iDir)
        {
            cch0 = rtp.Advance(iDir);
            if(!cch0)
                break;
        }
        if(iDir > 0)                        // Tabbing forward
        {
            if(ch != CELL)                  // Went past end of table
                goto insertRow;             //  so go insert new row
        }
        else if(cch)                        // Tabbing backward with
        {                                   //  nondegenerate selection
            if(cch0)                        // Didn't run into start of story
            {
                rtp.Advance(1);             // Advance over CELL. Then if at
                if(rtp.GetChar() == CR)     //  end of row, advance over EOP
                    cch += rtp.AdvanceCRLF();
            }
            else                            // Ran into start of story
                cch -= 1;                   // Include another char since
        }                                   //  broke out of for loop
        else if(cpMin > 1)                  // Handles tabbing back over
            rtp.Advance(1);                 //  adjacent null cells

        Set(rtp.GetCp(), cch);
        _fCaretNotAtBOL = FALSE;
        Update(TRUE);
        return TRUE;
    }

    // EOPs might be entered by ITextSelection::TypeText()
    if(IsEOP(ch))
        return _pdp->IsMultiLine()          // EOP isn't allowed in
            ? InsertEOP(publdr, ch) : FALSE;//  single line controls

    if(publdr)
    {
        publdr->SetNameID(UID_TYPING);
        publdr->StartGroupTyping();
    }

    // FUTURE: a Unicode lead surrogate needs to have a trail surrogate, i.e.,
    // two 16-bit chars. A more thorough check would worry about this.
    if ((DWORD)GetTextLength() >= ped->TxGetMaxLength() &&
        ((_cch == -1 || !_cch && fOver) && _rpTX.IsAtEOP() ||
         _cch == 1 && _rpTX.IsAfterEOP()))
    {
        // Can't overtype a CR, so need to insert new char but no room
        ped->GetCallMgr()->SetMaxText();
        return FALSE;
    }
    if((!fOver || !_cch && GetCp() == GetTextLength()) &&
        !CheckTextLength(1))                        // Return if we can't
    {                                               //  add even 1 more char
        return FALSE;
    }

    // The following if statement implements Word95's "Smart Quote" feature.
    // To build this in, we still need an API to turn it on and off.  This
    // could be EM_SETSMARTQUOTES with wparam turning the feature on or off.
    // murrays. NB: this needs localization for French, German, and many
    // other languages (unless system can provide open/close chars given
    // an LCID).

    if((ch == '\'' || ch == '"') &&                 // Smart quotes
        SmartQuotesEnabled() &&
        PRIMARYLANGID(GetKeyboardLayout(0)) == LANG_ENGLISH)
    {
        LONG    cp = GetCpMin();                    // Open vs close depends
        CTxtPtr tp(ped, cp - 1);                    //  on char preceding
                                                    //  selection cpMin
        ch = (ch == '"') ? RDBLQUOTE : RQUOTE;      // Default close quote
                                                    //  or apostrophe. If at
        WCHAR chp = tp.GetChar();
        if(!cp || IsWhiteSpace(chp) || chp == '(')  //  BOStory or preceded
            ch--;                                   //  by whitespace, use
    }                                               //  open quote/apos


    // Some languages, e.g., Thai, Vietnamese require verifying the input
    // sequence order before submitting it to the backing store.

    BOOL    fBaseChar = TRUE;                       // Assume ch is a base consonant
    if(!IsInputSequenceValid(&ch, 1, fOver, &fBaseChar))
    {
        SetDualFontMode(FALSE);                     // Ignore bad sequence
        return FALSE;
    }


    DWORD bCharSetDefault = ped->GetCharFormat(-1)->_bCharSet;
    DWORD dw = GetCharFlags(ch, bCharSetDefault);
    ped->OrCharFlags(dw, publdr);

    // BEFORE we do "dual-font", we sync the keyboard and current font's
    // (_iFormat) charset if it hasn't been done.
    const CCharFormat *pCFCurrent = NULL;
    CCharFormat CF = *ped->GetCharFormat(GetiFormat());
    BYTE bCharSet = CF._bCharSet;
    BOOL fRestoreCF = FALSE;

    if(ped->IsAutoFont())
    {
        UINT uKbdcpg = 0;
        BOOL fFEKbd = FALSE;

        if(!(ped->_fIMEInProgress))
            uKbdcpg = CheckSynchCharSet(dw);

        if (fUseUIFont() && ch <= 0x0FF)
        {
            // For UIFont, we need to format ANSI characters
            // so we will not have different formats between typing and
            // WM_SETTEXT.
            if (!ped->_fIMEInProgress && dw == fHILATIN1)
            {
                // Use Ansi font if based font or current font is FE.
                if(IsFECharSet(bCharSetDefault) || IsFECharSet(bCharSet))
                    SetupDualFont();                // Use Ansi font for HiAnsi
            }
            else if (dw & fASCII && (GetCharSetMask(TRUE) & fASCII) == fASCII)
            {
                CCharFormat CFDefault = *ped->GetCharFormat(-1);
                if (IsRich() && IsBiDiCharSet(CFDefault._bCharSet)
                    && !W32->IsBiDiCodePage(uKbdcpg))
                    CFDefault._bCharSet = ANSI_CHARSET;

                SetCharFormat(&CFDefault, SCF_NOKBUPDATE, publdr, CFM_CHARSET | CFM_FACE | CFM_SIZE,
                         CFM2_CHARFORMAT | CFM2_NOCHARSETCHECK | CFM2_HOLDITEMIZE);

                _fUseiFormat = FALSE;
                pCFCurrent = &CF;
                fRestoreCF = ped->_fIMEInProgress;

            }
        }
        else if(!fUseUIFont()    && bCharSet != ANSI_CHARSET &&
                (ped->_fDualFont && bCharSet != SYMBOL_CHARSET &&
                (((fFEKbd = (ped->_fIMEInProgress || W32->IsFECodePage(uKbdcpg))) && ch < 127 && IsAlpha(ch)) ||
                 (!fFEKbd && IsFECharSet(ped->GetCharFormat(GetiFormat())->_bCharSet) && ch < 127))
                || ped->_fHbrCaps))
        {
            SetupDualFont();
            pCFCurrent = &CF;
            fRestoreCF = ped->_fIMEInProgress;
        }
    }

    // = Indic/Thai overtyping convention =
    //
    // The deal is that we will overwrite the cluster if ch is a cluster-start char
    // otherwise we just insert. This new convention was proposed by SA Office2000.
    //
    //                     Abc.Def.Ghi
    // Typing X at D       Abc.X.Ghi
    // Typing y and z      Abc.Xyz.Ghi

    SetExtend(TRUE);                                // Tell Advance() to
    if(fOver && fBaseChar)                          //  select chars
    {                                               // If nothing selected and
        if(!_cch && !_rpTX.IsAtEOP())               //  not at EOP char, try
        {                                           //  to select char at IP
            LONG iFormatSave = Get_iCF();           // Remember char's format

            AdvanceCRLF();
            SnapToCluster();

            ReplaceRange(0, NULL, publdr,
                SELRR_REMEMBERENDIP);               // Delete this character.
            ReleaseFormats(_iFormat, -1);
            _iFormat = iFormatSave;                 // Restore char's format.
        }
    }
    else if(_SelMode == smWord && ch != TAB && _cch)// Replace word selection
    {
        // The code below wants the active end to be at the end of the
        // word.  Make sure this is so.

        // FUTURE: (alexgo, andreib), _cch will only be less than zero
        // in certain weird timing situations where we get a mouse move
        // message in between the double click and mouse up messages.
        // we should rethink how we process messages && the ordering thereof.
        if(_cch < 0)
            FlipRange();
                                                    // Leave word break chars
        CTxtPtr tp(_rpTX);                          //  at end of selection
        Assert(_cch > 0);

        tp.AdvanceCp(-1);
        if(tp.GetCp() && tp.FindWordBreak(WB_ISDELIMITER))// Delimeter at sel end
            FindWordBreak(WB_LEFTBREAK);            // Backspace over it, etc.
    }

    _fIsChar = TRUE;                                // Tell CDisplay::UpdateView
    _fDontUpdateFmt = TRUE;                         //  we're PuttingChar()
    LONG iFormat = GetiFormat();                    // Save current value
    AdjustEndEOP(NEWCHARS);
    if(!_cch)
        Set_iCF(iFormat);
    _fDontUpdateFmt = FALSE;

    if(ped->_fUpperCase)
        CharUpperBuff(&ch, 1);
    else if(ped->_fLowerCase)
        CharLowerBuff(&ch, 1);

    {
        CFreezeDisplay  fd(GetPed()->_pdp);

        if(!_cch)
        {
            if(bCharSet == DEFAULT_CHARSET)
            {
                CCharFormat CFTemp;

                if (dw & fFE)       // Find a better charset for FE char
                    CFTemp._bCharSet = MatchFECharSet(dw, GetFontSignatureFromFace(CF._iFont));
                else
                    CFTemp._bCharSet = GetCharSet(W32->ScriptIndexFromFontSig(dw >> 8), NULL);

                SetCharFormat(&CFTemp, SCF_NOKBUPDATE, NULL, CFM_CHARSET, CFM2_NOCHARSETCHECK);
            }
            else if(bCharSet == SYMBOL_CHARSET && dwFlags & KBD_CHAR && ch > 255)
            {
                UINT cpg = GetKeyboardCodePage(0);  // If 125x, convert char
                if(IN_RANGE(1250, cpg, 1257))       //  back to ANSI for storing
                {                                   //  SYMBOL_CHARSET chars
                    BYTE ach;
                    WCTMB(cpg, 0, &ch, 1, (char *)&ach, 1, NULL, NULL, NULL);
                    ch = ach;
                }
            }
        }
        if(dwFlags & KBD_CHAR || ped->_fIMEInProgress || bCharSet == SYMBOL_CHARSET)
            ReplaceRange(1, &ch, publdr, SELRR_REMEMBERRANGE);
        else
            CleanseAndReplaceRange(1, &ch, TRUE, publdr, NULL);
    }

    _fIsChar = FALSE;

    // Restore font for Hebrew CAPS. Note that FE font is not restored
    // (is handled by IME).
    if(pCFCurrent && (W32->UsingHebrewKeyboard() || fRestoreCF))
        SetCharFormat(pCFCurrent, SCF_NOKBUPDATE, NULL, CFM_FACE | CFM_CHARSET | CFM_SIZE, CFM2_NOCHARSETCHECK);

    else if(iFormat != Get_iFormat())
        CheckChangeKeyboardLayout();

    SetDualFontMode(FALSE);

    if (!_pdp->IsFrozen())
        CheckUpdateWindow();                        // Need to update display
                                                    //  for pending chars.
    return TRUE;
}

/*
 *  CTxtSelection::CheckUpdateWindow()
 *
 *  @mfunc
 *      If it's time to update the window, after pending-typed characters,
 *      do so now. This is needed because WM_PAINT has a lower priority
 *      than WM_CHAR.
 */
void CTxtSelection::CheckUpdateWindow()
{
    DWORD ticks = GetTickCount();
    DWORD delta = ticks - _ticksPending;

    if(!_ticksPending)
        _ticksPending = ticks;
    else if(delta >= ticksPendingUpdate)
        GetPed()->TxUpdateWindow();
}

/*
 *  CTxtSelection::BypassHiddenText(iDir)
 *
 *  @mfunc
 *      Bypass hidden text forward/backward for iDir positive/negative
 *
 *  @rdesc
 *      TRUE if succeeded or no hidden text. FALSE if at document limit
 *      (end/start for Direction positive/negative) or if hidden text between
 *      cp and that limit.
 */
BOOL CTxtSelection::BypassHiddenText(
    LONG iDir)
{
    if(iDir > 0)
        _rpCF.AdjustForward();
    else
        _rpCF.AdjustBackward();

    if(!(GetPed()->GetCharFormat(_rpCF.GetFormat())->_dwEffects & CFE_HIDDEN))
        return TRUE;

    BOOL fExtendSave = _fExtend;
    SetExtend(FALSE);

    CCFRunPtr rp(*this);
    LONG cch = (iDir > 0)
             ? rp.FindUnhiddenForward() : rp.FindUnhiddenBackward();

    BOOL bRet = !rp.IsHidden();             // Note whether still hidden
    if(bRet)                                // It isn't:
        Advance(cch);                       //  bypass hidden text
    SetExtend(fExtendSave);
    return bRet;
}

/*
 *  CTxtSelection::InsertEOP(publdr)
 *
 *  @mfunc
 *      Insert EOP character(s)
 *
 *  @rdesc
 *      TRUE if successful
 */
BOOL CTxtSelection::InsertEOP (
    IUndoBuilder *publdr,   //@parm If non-NULL, where to put anti-events
    WCHAR ch)               //@parm Possible EOP char
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::InsertEOP");

    _TEST_INVARIANT_

    LONG    cchEOP = GetPed()->fUseCRLF() ? 2 : 1;
    BOOL    fResult = FALSE;
    LONG    i, iFormatSave;
    WCHAR   szBlankRow[MAX_TAB_STOPS + 1] = {CR, LF, 0};
    WCHAR * pch = szBlankRow;
    BOOL    fPFInTable;
    WORD    wPFNumbering;
    BYTE    bPFTabCount;
    BOOL    fPrevPFInTable = TRUE;

    {
        const CParaFormat *pPF = GetPF();       // Get paragraph format

        // pPF may become invalid after SetParaFormat.  So, we need
        // to save up necessary data from pPF.
        fPFInTable = pPF->InTable();
        wPFNumbering = pPF->_wNumbering;
        bPFTabCount = pPF->_bTabCount;
    }

    if(ch && (GetPed()->fUseCRLF() || IN_RANGE(VT, ch, FF)))
    {
        szBlankRow[0] = ch;
        cchEOP = 1;
    }

    _fEOP = TRUE;

    if(publdr)
    {
        publdr->StartGroupTyping();
        publdr->SetNameID(UID_TYPING);
    }

    if(fPFInTable)
    {
        SetExtend(FALSE);               // Don't want extended selection
        if(!_cch && !_rpPF.GetIch())
        {
            const CParaFormat *pPFPrev; // Get previous paragraph format

            _rpPF.AdjustBackward();
            pPFPrev = GetPed()->GetParaFormat(_rpPF.GetFormat());
            fPrevPFInTable = (pPFPrev->_wEffects & PFE_TABLE) ? TRUE : FALSE;

            _rpPF.AdjustForward();
        }

        if(fPrevPFInTable)
        {
            if(GetCp() && !_rpTX.IsAfterEOP())
            {
                while(!_rpTX.IsAtEOP() && Advance(1))
                    ;
                *pch++ = CR;
            }
            for(i = bPFTabCount; i--; *pch++ = CELL)
                ;
            *pch++ = CR;
            pch = szBlankRow;
            cchEOP = bPFTabCount + 1;
        }
    }
    if(!GetCch() && wPFNumbering && _rpTX.IsAfterEOP())
    {
        // Two enters in a row turn off numbering
        CParaFormat PF;
        PF._wNumbering = 0;
        PF._dxOffset = 0;
        SetParaFormat(&PF, publdr, PFM_NUMBERING | PFM_OFFSET);
    }

    if(CheckTextLength(cchEOP))             // If cchEOP chars can fit...
    {
        CFreezeDisplay  fd(GetPed()->_pdp);
        iFormatSave = Get_iCF();            // Save CharFormat before EOP
                                            // Get_iCF() does AddRefFormat()
        if(wPFNumbering)                    // Bullet paragraph: EOP has
        {                                   //  desired bullet CharFormat
            CFormatRunPtr rpCF(_rpCF);      // Get run pointers for locating
            CTxtPtr       rpTX(_rpTX);      //  EOP CharFormat

            rpCF.AdvanceCp(rpTX.FindEOP(tomForward));
            rpCF.AdjustBackward();
            Set_iCF(rpCF.GetFormat());      // Set _iFormat to EOP CharFormat
        }

        // Put in appropriate EOP mark
        fResult = ReplaceRange(cchEOP, pch, // If Shift-Enter, insert VT
            publdr, SELRR_REMEMBERRANGE, NULL, RR_NO_EOR_CHECK);

        Set_iCF(iFormatSave);               // Restore _iFormat if changed
        ReleaseFormats(iFormatSave, -1);    // Release iFormatSave
        if(fPFInTable)
        {
            if(!fPrevPFInTable)             // Turn off PFE_TABLE bit of
            {                               //  EOP just inserted
                CParaFormat PF;
                _cch = cchEOP;              // Select EOP just inserted
                PF._wEffects = 0;
                SetParaFormat(&PF, publdr, PFM_TABLE);
                _cch = 0;                   // Back to insertion point
            }
            else if(cchEOP > 1)
            {
                if(*pch == CR)
                    cchEOP--;
                Advance(-cchEOP);
                _fCaretNotAtBOL = FALSE;
                Update(FALSE);
            }
        }
    }
    return fResult;
}

/*
 *  CTxtSelection::Delete(fCtrl, publdr)
 *
 *  @mfunc
 *      Delete the selection. If fCtrl is true, this method deletes from
 *      min of selection to end of word
 *
 *  @rdesc
 *      TRUE if successful
 */
BOOL CTxtSelection::Delete (
    DWORD fCtrl,            //@parm If TRUE, Ctrl key depressed
    IUndoBuilder *publdr)   //@parm if non-NULL, where to put anti-events
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::Delete");

    _TEST_INVARIANT_

    SELRR   mode = SELRR_REMEMBERRANGE;

    AssertSz(!GetPed()->TxGetReadOnly(), "CTxtSelection::Delete(): read only");

    if(!_cch)
        BypassHiddenText(tomForward);

    if(publdr)
    {
        publdr->StopGroupTyping();
        publdr->SetNameID(UID_DELETE);
    }

    SetExtend(TRUE);                        // Setup to change selection
    if(fCtrl)
    {                                       // Delete to word end from cpMin
        Collapser(tomStart);                //  (won't necessarily repaint,
        FindWordBreak(WB_MOVEWORDRIGHT);    //  since won't delete it)
    }

    if(!_cch)                               // No selection
    {
        mode = SELRR_REMEMBERCPMIN;
        if(!AdvanceCRLF())                  // Try to select char at IP
        {                                   // End of text, nothing to delete
            Beep();                         // Only executed in plain text,
            return FALSE;                   //  since else there's always
        }                                   //  a final EOP to select
        SnapToCluster();
        _fMoveBack = TRUE;                  // Convince Update_iFormat() to
        _fUseiFormat = TRUE;                //  use forward format
    }
    AdjustEndEOP(NONEWCHARS);
    ReplaceRange(0, NULL, publdr, mode);    // Delete selection
    return TRUE;
}

/*
 *  CTxtSelection::BackSpace(fCtrl, publdr)
 *
 *  @mfunc
 *      do what keyboard BackSpace key is supposed to do
 *
 *  @rdesc
 *      TRUE iff movement occurred
 *
 *  @comm
 *      This routine should probably use the Move methods, i.e., it's
 *      logical, not directional
 *
 *  @devnote
 *      _fExtend is TRUE iff Shift key is pressed or being simulated
 */
BOOL CTxtSelection::Backspace (
    BOOL fCtrl,     //@parm TRUE iff Ctrl key is pressed (or being simulated)
    IUndoBuilder *publdr)   //@parm If not-NULL, where to put the antievents
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::Backspace");

    _TEST_INVARIANT_

    SELRR   mode = SELRR_REMEMBERRANGE;

    AssertSz(!GetPed()->TxGetReadOnly(),
        "CTxtSelection::Backspace(): read only");

    _fCaretNotAtBOL = FALSE;

    if(publdr)
    {
        publdr->SetNameID(UID_TYPING);

        if(_cch || fCtrl)
            publdr->StopGroupTyping();
    }

    SetExtend(TRUE);                        // Set up to extend range
    if(fCtrl)                               // Delete word left
    {
        if(!GetCpMin())                     // Beginning of story: no word
        {                                   //  to delete
            Beep();
            return FALSE;
        }
        Collapser(tomStart);                // First collapse to cpMin
        if(!BypassHiddenText(tomBackward))
            goto beep;
        FindWordBreak(WB_MOVEWORDLEFT);     // Extend word left
    }
    else if(!_cch)                          // Empty selection
    {                                       // Try to select previous char
        if (!BypassHiddenText(tomBackward) ||
            !BackupCRLF(FALSE))
        {                                   // Nothing to delete
beep:       Beep();
            return FALSE;
        }
        mode = SELRR_REMEMBERENDIP;

        if(publdr)
            publdr->StartGroupTyping();
    }
    ReplaceRange(0, NULL, publdr, mode);    // Delete selection

    return TRUE;
}

/*
 *  CTxtSelection::ReplaceRange(cchNew, pch, publdr, SELRRMode)
 *
 *  @mfunc
 *      Replace selected text by new given text and update screen according
 *      to _fShowCaret and _fShowSelection
 *
 *  @rdesc
 *      length of text inserted
 */
LONG CTxtSelection::ReplaceRange (
    LONG cchNew,            //@parm Length of replacing text or -1 to request
                            // <p pch> sz length
    const TCHAR *pch,       //@parm Replacing text
    IUndoBuilder *publdr,   //@parm If non-NULL, where to put anti-events
    SELRR SELRRMode,        //@parm what to do about selection anti-events.
    LONG*   pcchMove,       //@parm number of chars moved after replacing
    DWORD   dwFlags)        //@parm Special flags
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::ReplaceRange");

    _TEST_INVARIANT_

    LONG        cchNewSave;
    LONG        cchOld;
    LONG        cchText     = GetTextLength();
    LONG        cpFirstRecalc;
    LONG        cpMin, cpMost;
    LONG        cpSave;
    BOOL        fDeleteAll = FALSE;
    BOOL        fHeading = FALSE;
    const BOOL  fUpdateView = _fShowSelection;

    CancelModes();

    if(cchNew < 0)
        cchNew = wcslen(pch);

    if(!_cch && !cchNew)                        // Nothing to do
        return 0;

    if (!GetPed()->IsStreaming() &&             // If not pasting,
        (!_cch && *pch != CR &&                 // Don't insert bet CELL & CR
         CRchTxtPtr::GetChar() == CR && GetPrevChar() == CELL && GetPF()->InTable() ||
         _cch != cchText && (IsInOutlineView() && IsCollapsed() ||
         IsHidden())))
    {                                           // Don't insert into collapsed
        Beep();                                 //  or hidden region (should
        return 0;                               //  only happen if whole story
    }                                           //  collapsed or hidden)

    GetPed()->GetCallMgr()->SetSelectionChanged();

    CheckTableSelection();
    cchOld = GetRange(cpMin, cpMost);

    if (cpMin > min(_cpSel, _cpSel + _cchSel) ||// If new sel doesn't
        cpMost < max(_cpSel, _cpSel + _cchSel)) //  contain all of old
    {                                           //  sel, remove old sel
        ShowSelection(FALSE);
        _fShowCaret = TRUE;
    }

    _fCaretNotAtBOL = FALSE;
    _fShowSelection = FALSE;                    // Suppress the flashies

    // If we are streaming in text or RTF data, don't bother with incremental
    // recalcs.  The data transfer engine will take care of a final recalc
    if(!GetPed()->IsStreaming())
    {
        // Do this before calling ReplaceRange() so that UpdateView() works
        // AROO !!! Do this before replacing the text or the format ranges!!!
        if(!_pdp->WaitForRecalc(cpMin, -1))
        {
            Tracef(TRCSEVERR, "WaitForRecalc(%ld) failed", cpMin);
            cchNew = 0;                         // Nothing inserted
            goto err;
        }
    }

    if(publdr)
    {
        Assert(SELRRMode != SELRR_IGNORE);

        // Use selection AntiEvent mode to determine what to do for undo
        LONG cp = cpMin;
        LONG cch = 0;

        if(SELRRMode == SELRR_REMEMBERRANGE)
        {
            cp = GetCp();
            cch = _cch;
        }
        else if(SELRRMode == SELRR_REMEMBERENDIP)
        {
            cp = cpMost;
        }
        else
        {
            Assert(SELRRMode == SELRR_REMEMBERCPMIN);
        }

        HandleSelectionAEInfo(GetPed(), publdr, cp, cch, cpMin + cchNew,
            0, SELAE_MERGE);
    }

    if(_cch == cchText && !cchNew)              // For delete all, set
    {                                           //  up to choose Normal
        fDeleteAll = TRUE;                      //  or Heading 1
        FlipRange();
        fHeading = IsInOutlineView() && IsHeadingStyle(GetPF()->_sStyle);
    }

    cpSave      = cpMin;
    cpFirstRecalc = cpSave;
    cchNewSave  = cchNew;
    cchNew      = CTxtRange::ReplaceRange(cchNew, pch, publdr, SELRR_IGNORE, pcchMove, dwFlags);
    _cchSel     = 0;                            // No displayed selection
    _cpSel      = GetCp();
    cchText     = GetTextLength();              // Update total text length

    if(cchNew != cchNewSave)
    {
        Tracef(TRCSEVERR, "CRchTxtPtr::ReplaceRange(%ld, %ld, %ld) failed", GetCp(), cchOld, cchNew);
        _fShowSelection = fUpdateView;
        goto err;
    }

    // The cp should be at *end* (cpMost) of replaced range (it starts
    // at cpMin of the prior range).
    AssertSz(_cpSel == cpSave + cchNew && _cpSel <= cchText,
        "CTxtSelection::ReplaceRange() - Wrong cp after replacement");

    _fShowSelection = fUpdateView;

    if(fDeleteAll)                              // When all text is deleted
    {                                           //  use Normal style unless
        CParaFormat PF;                         //  in Outline View and first
        PF._sStyle = fHeading ? STYLE_HEADING_1 : STYLE_NORMAL;
        SetParaStyle(&PF, NULL, PFM_STYLE);     //  para was a heading
        if(GetPed()->IsBiDi())
        {
            if(GetPed()->_fFocus && !GetPed()->_fIMEInProgress)
            {
                MatchKeyboardToPara();
                CheckSynchCharSet(0);
            }
        }
        else
            Update_iFormat(-1);
    }

    // Only update caret if inplace active
    if(GetPed()->fInplaceActive())
        UpdateCaret(fUpdateView);               // May need to scroll
    else                                        // Update caret when we get
        GetPed()->_fScrollCaretOnFocus = TRUE;  //  focus again

    return cchNew;

err:
    TRACEERRSZSC("CTxtSelection::ReplaceRange()", E_FAIL);
    Tracef(TRCSEVERR, "CTxtSelection::ReplaceRange(%ld, %ld)", cchOld, cchNew);
    Tracef(TRCSEVERR, "cchText %ld", cchText);

    return cchNew;
}

/*
 *  CTxtSelection::GetPF()
 *
 *  @mfunc
 *      Return ptr to CParaFormat at active end of this selection. If no PF
 *      runs are allocated, then return ptr to default format.  If active
 *      end is at cpMost of a nondegenerate selection, use the PF of the
 *      previous char (last char in selection).
 *
 *  @rdesc
 *      Ptr to CParaFormat at active end of this selection
 */
const CParaFormat* CTxtSelection::GetPF()
{
    TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtSelection::GetPF");

    if(_cch > 0)
        _rpPF.AdjustBackward();
    const CParaFormat* pPF = GetPed()->GetParaFormat(_rpPF.GetFormat());
    if(_cch > 0)
        _rpPF.AdjustForward();
    return pPF;
}

/*
 *  CTxtSelection::CheckTableSelection()
 *
 *  @mfunc
 *      Select whole cells if one or more CELLs are selected
 */
void CTxtSelection::CheckTableSelection ()
{
    if(!_fSelHasEOP && GetPF()->InTable())          // For now, don't let
    {                                               //  table CELLs be
        LONG    cpMin, cpMost;                      //  deleted, unless in
        CTxtPtr tp(_rpTX);                          //  complete rows

        GetRange(cpMin, cpMost);
        if(_cch > 0)
            tp.AdvanceCp(-_cch);                    // Start at cpMin

        while(tp.GetCp() < cpMost)
        {
            if(tp.GetChar() == CELL)                // Stop selection at CELL
            {
                Set(cpMin, cpMin - tp.GetCp());
                UpdateSelection();
                return;
            }
            tp.AdvanceCp(1);
        }
    }
}

/*
 *  CTxtSelection::SetCharFormat(pCF, fApplyToWord, publdr, dwMask, dwMask2)
 *
 *  @mfunc
 *      apply CCharFormat *pCF to this selection.  If range is an IP
 *      and fApplyToWord is TRUE, then apply CCharFormat to word surrounding
 *      this insertion point
 *
 *  @rdesc
 *      HRESULT = NOERROR if no error
 */
HRESULT CTxtSelection::SetCharFormat (
    const CCharFormat *pCF, //@parm Ptr to CCharFormat to fill with results
    DWORD         flags,    //@parm If SCF_WORD and selection is an IP,
                            //      use enclosing word
    IUndoBuilder *publdr,   //@parm Undo context
    DWORD         dwMask,   //@parm CHARFORMAT2 mask
    DWORD         dwMask2)  //@parm Second mask
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::SetCharFormat");

    HRESULT hr = 0;
    LONG    iFormat = _iFormat;

    if(publdr)
        publdr->StopGroupTyping();

    /*
     * The code below applies character formatting to a double-clicked
     * selection the way Word does it, that is, not applying the formatting to
     * the last character in the selection if that character is a blank.
     *
     * See also the corresponding code in CTxtRange::GetCharFormat().
     */

    LONG        cpMin, cpMost;
    LONG        cch = GetRange(cpMin, cpMost);;
    BOOL        fCheckKeyboard = (flags & SCF_NOKBUPDATE) == 0;
    CTxtRange   rg(GetPed());
    CCharFormat CF;

    if(_SelMode == smWord && (flags & SCF_USEUIRULES) && cch)
    {
        // In word select mode, don't include final blank in SetCharFormat
        CTxtPtr tpLast(GetPed(), cpMost - 1);
        if(tpLast.GetChar() == ' ')         // Selection ends with a blank:
        {
            cpMost--;                       // Setup end point to end at last
            cch--;                          //  char in selection
            fCheckKeyboard = FALSE;
            flags &= ~SCF_WORD;
        }
    }

    BYTE bCharSet = pCF->_bCharSet;

    // Smart SB/DB Font Apply Feature
    if (cch && IsRich() &&                  // > 0 chars in rich text
        !GetPed()->_fSingleCodePage &&      // Not in single cp mode
        (dwMask & CFM_FACE))                // font change
    {

        if (!(dwMask & CFM_CHARSET) || bCharSet == DEFAULT_CHARSET)
        {
            // Setup charset for DEFAULT_CHARSET or when the client only specifies
            // facename
            CF = *pCF;
            CF._bCharSet = GetFirstAvailCharSet(GetFontSignatureFromFace(CF._iFont));
            pCF = &CF;
        }

        dwMask2 |= CFM2_MATCHFONT;          // Signal to match font charsets
#if 0
        // Single byte 125x CharSet
        CFreezeDisplay fd(_pdp);            // Speed this up

        CTxtPtr     tp(GetPed(), cpMin);
        CCharFormat CF = *pCF;

        while(cpMin < cpMost)
        {
            BOOL fInCharSet = In125x(tp.GetChar(), pCF->_bCharSet);

            while(fInCharSet == In125x(tp.GetChar(), pCF->_bCharSet) &&
                   tp.GetCp() < cpMost)
            {
                tp.AdvanceCp(1);
            }
            dwMask &= ~(CFM_FACE | CFM_CHARSET);
            if(fInCharSet)
                dwMask |= (CFM_FACE | CFM_CHARSET);

            rg.SetRange(cpMin, tp.GetCp());
            HRESULT hr1 = dwMask
                        ? rg.SetCharFormat(&CF, flags | SCF_IGNORESELAE, publdr, dwMask, dwMask2)
                        : NOERROR;
            hr = FAILED(hr) ? hr : hr1;
            cpMin = tp.GetCp();
        }
#endif
    }
    if(_cch)
    {
        // Selection is being set to a charformat
        if (IsRich())
        {
            GetPed()->SetfSelChangeCharFormat();
        }

        // REVIEW (murrays): can _iFormat change if _cch != 0?
        // It is OK to not update _iFormat for a non degenerate selection
        // even if UI rules and word select have reduced it.
        rg.SetRange(cpMin, cpMost);
        hr = rg.SetCharFormat(pCF, flags, publdr, dwMask, dwMask2);
    }
    else
    {
        // But for a degenerate selection, _iFormat must be updated
        hr = CTxtRange::SetCharFormat(pCF, flags, publdr, dwMask, dwMask2);
    }

    if(fCheckKeyboard && (dwMask & CFM_CHARSET) && _iFormat != iFormat)
        CheckChangeKeyboardLayout();

    _fIsChar = TRUE;
    UpdateCaret(!GetPed()->fHideSelection());
    _fIsChar = FALSE;
    return hr;
}

/*
 *  CTxtSelection::SetParaFormat(pPF, publdr)
 *
 *  @mfunc
 *      apply CParaFormat *pPF to this selection.
 *
 *  @rdesc
 *      HRESULT = NOERROR if no error
 */
HRESULT CTxtSelection::SetParaFormat (
    const CParaFormat* pPF, //@parm ptr to CParaFormat to apply
    IUndoBuilder *publdr,   //@parm Undo context for this operation
    DWORD         dwMask)   //@parm Mask to use
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::SetParaFormat");

    CFreezeDisplay  fd(GetPed()->_pdp);
    HRESULT         hr;

    if(publdr)
        publdr->StopGroupTyping();

    // Apply the format
    hr = CTxtRange::SetParaFormat(pPF, publdr, dwMask);

    UpdateCaret(!GetPed()->Get10Mode() || IsCaretInView());
    return hr;
}

/*
 *  CTxtSelection::SetSelectionInfo (pselchg)
 *
 *  @mfunc  Fills out data members in a SELCHANGE structure
 */
void CTxtSelection::SetSelectionInfo(
    SELCHANGE *pselchg)     //@parm SELCHANGE structure to use
{
    LONG cpMin, cpMost;
    LONG cch = GetRange(cpMin, cpMost);;

    pselchg->chrg.cpMin  = cpMin;
    pselchg->chrg.cpMost = cpMost;
    pselchg->seltyp      = SEL_EMPTY;

    // OR in the following selection type flags if active:
    //
    // SEL_EMPTY:       insertion point
    // SEL_TEXT:        at least one character selected
    // SEL_MULTICHAR:   more than one character selected
    // SEL_OBJECT:      at least one object selected
    // SEL_MULTIOJBECT: more than one object selected
    //
    // Note that the flags are OR'ed together.
    if(cch)
    {
        LONG cObjects = GetObjectCount();           // Total object count
        if(cObjects)                                // There are objects:
        {                                           //  get count in range
            CObjectMgr *pobjmgr = GetPed()->GetObjectMgr();
            Assert(pobjmgr);

            cObjects = pobjmgr->CountObjectsInRange(cpMin, cpMost);
            if(cObjects > 0)
            {
                pselchg->seltyp |= SEL_OBJECT;
                if(cObjects > 1)
                    pselchg->seltyp |= SEL_MULTIOBJECT;
            }
        }

        cch -= cObjects;
        AssertSz(cch >= 0, "objects are overruning the selection");

        if(cch > 0)
        {
            pselchg->seltyp |= SEL_TEXT;
            if(cch > 1)
                pselchg->seltyp |= SEL_MULTICHAR;
        }
    }
}

/*
 *  CTxtSelection::UpdateForAutoWord ()
 *
 *  @mfunc  Update state to prepare for auto word selection
 *
 *  @rdesc  void
 */
void CTxtSelection::UpdateForAutoWord()
{
    AssertSz(!_cch,
        "CTxtSelection::UpdateForAutoWord: Selection isn't degenerate");

    // If enabled, prepare Auto Word Sel
    if(GetPed()->TxGetAutoWordSel())
    {
        CTxtPtr tp(_rpTX);

        // Move anchor to new location
        _cpAnchor = GetCp();

        // Remember that FindWordBreak moves tp's cp
        // (aren't side effects wonderful?
        tp.FindWordBreak(WB_MOVEWORDRIGHT);
        _cpAnchorMost =_cpWordMost = tp.GetCp();

        tp.FindWordBreak(WB_MOVEWORDLEFT);
        _cpAnchorMin = _cpWordMin = tp.GetCp();

        _fAutoSelectAborted = FALSE;
    }
}

/*
 *  CTxtSelection::AutoSelGoBackWord(pcpToUpdate, iDirToPrevWord, iDirToNextWord)
 *
 *  @mfunc  Backup a word in auto word selection
 */
void CTxtSelection::AutoSelGoBackWord(
    LONG *  pcpToUpdate,    //@parm end of word selection to update
    int     iDirToPrevWord, //@parm direction to next word
    int     iDirToNextWord) //@parm direction to previous word
{
    if (GetCp() >= _cpAnchorMin &&
        GetCp() <= _cpAnchorMost)
    {
        // We are back in the first word. Here we want to pop
        // back to a selection anchored by the original selection

        Set(GetCp(), GetCp() - _cpAnchor);
        _fAutoSelectAborted = FALSE;
        _cpWordMin  = _cpAnchorMin;
        _cpWordMost = _cpAnchorMost;
    }
    else
    {
        // pop back a word
        *pcpToUpdate = _cpWordPrev;

        CTxtPtr tp(_rpTX);

        _cpWordPrev = GetCp() + tp.FindWordBreak(iDirToPrevWord);
        FindWordBreak(iDirToNextWord);
    }
}

/*
 *  CTxtSelection::InitClickForAutWordSel (pt)
 *
 *  @mfunc  Init auto selection for click with shift key down
 *
 *  @rdesc  void
 */
void CTxtSelection::InitClickForAutWordSel(
    const POINT pt)     //@parm Point of click
{
    // If enabled, prepare Auto Word Sel
    if(GetPed()->TxGetAutoWordSel())
    {
        // If auto word selection is occuring we want to pretend
        // that the click is really part of extending the selection.
        // Therefore, we want the auto word select data to look as
        // if the user had been extending the selection via the
        // mouse all along. So we set the word borders to the
        // word that would have been previously selected.

        // Need this for finding word breaks
        CRchTxtPtr  rtp(GetPed());
        LONG cpClick = _pdp->CpFromPoint(pt, NULL, &rtp, NULL, TRUE);
        int iDir = -1;

        if(cpClick < 0)
        {
            // If this fails what can we do? Prentend it didn't happen!
            // We can do this because it will only make the UI act a
            // little funny and chances are the user won't even notice.
            return;
        }

        // Assume click is within anchor word
        _cpWordMost = _cpAnchorMost;
        _cpWordMin = _cpAnchorMin;

        if(cpClick > _cpAnchorMost)
        {
            // Click is after anchor word, so set cpMost appropriately
            iDir = WB_MOVEWORDLEFT;
            rtp.FindWordBreak(WB_MOVEWORDLEFT);
            _cpWordMost = rtp.GetCp();
        }
        // Click is before the anchor word
        else if(cpClick < _cpAnchorMost)
        {
            // Click is before  anchor word, so set cpMin appropriately.
            iDir = WB_MOVEWORDRIGHT;
            rtp.FindWordBreak(WB_MOVEWORDRIGHT);
            _cpWordMin = rtp.GetCp();
        }

        if(iDir != -1)
        {
            rtp.FindWordBreak(iDir);
            _cpWordPrev = rtp.GetCp();
        }
    }
}

/*
 *  CTxtSelection::CreateCaret ()
 *
 *  @mfunc  Create a caret
 *
 *  @devnote
 *      The caret is characterized by a height (_yHeightCaret), a keyboard
 *      direction (if BiDi), a width (1 to 8, since OS can't handle carets
 *      larger than 8 pixels), and an italic state.  One could cache this
 *      info thereby avoiding computing the caret on every keystroke.
 */
void CTxtSelection::CreateCaret()
{
    CTxtEdit *      ped  = GetPed();
    const CCharFormat *pCF = ped->GetCharFormat(_iFormat);
    DWORD           dwCaretType = 0;
    BOOL            fItalic;
    LONG            y = min(_yHeightCaret, 512);

    y = max(0, y);

    // Caret shape reflects current charset
    if(IsComplexKbdInstalled())
    {
        // Custom carets aren't italicized
        fItalic = 0;
        LCID    lcid = GetKeyboardLCID();

        dwCaretType = CARET_CUSTOM;

        if (W32->IsBiDiLcid(lcid))
            dwCaretType = CARET_CUSTOM | CARET_BIDI;

        else if (PRIMARYLANGID(lcid) == LANG_THAI)
            dwCaretType = CARET_CUSTOM | CARET_THAI;

        else if (W32->IsIndicLcid(lcid))
            dwCaretType = CARET_CUSTOM | CARET_INDIC;
    }
    else
        fItalic = pCF->_dwEffects & CFE_ITALIC && _yHeightCaret > 15; //9 pt/15 pixels looks bad

    INT dx = dxCaret;
    DWORD dwCaretInfo = (_yHeightCaret << 16) | (dx << 8) | (dwCaretType << 4) |
                        (fItalic << 1) | !_cch;

    if (ped->_fKoreanBlockCaret)
    {
        // Support Korean block caret during Kor IME composition
        // Basically, we want to create a caret using the width and height of the
        // character at current cp.
        CDisplay    *pdp = ped->_pdp;
        LONG        cpMin, cpMost;
        POINT       ptStart, ptEnd;

        GetRange(cpMin, cpMost);

        CRchTxtPtr tp(ped, cpMin);

        if (pdp->PointFromTp(tp, NULL, FALSE, ptStart, NULL, TA_TOP+TA_LEFT) != -1 &&
            pdp->PointFromTp(tp, NULL, FALSE, ptEnd, NULL, TA_BOTTOM+TA_RIGHT) != -1)
        {
            // Destroy whatever caret bitmap we had previously
            DeleteCaretBitmap(TRUE);

            LONG    iCharWidth = ptEnd.x - ptStart.x;
            if (!ped->fUseLineServices())
            {
                const CCharFormat *pCF = tp.GetCF();
                CLock lock;
                HDC hdc = W32->GetScreenDC();
                if(hdc)
                {
                    LONG dypInch = MulDiv(GetDeviceCaps(hdc, LOGPIXELSY), _pdp->GetZoomNumerator(), _pdp->GetZoomDenominator());
                    CCcs *pccs = fc().GetCcs(pCF, dypInch);
                    if(pccs)
                    {
                        LONG iKorCharWidth;
                        if (pccs->Include(0xAC00, iKorCharWidth))
                            iCharWidth = iKorCharWidth;
                        pccs->Release();
                    }
                }
            }

            ped->TxCreateCaret(0, iCharWidth, ptEnd.y - ptStart.y);
            _fCaretCreated = TRUE;
            ped->TxSetCaretPos(ptStart.x, ptStart.y);
        }

        return;
    }

    // We always create the caret bitmap on the fly since it
    // may be of arbitrary size
    if (dwCaretInfo != _dwCaretInfo)
    {
        _dwCaretInfo = dwCaretInfo;                 // Update caret info

        // Destroy whatever caret bitmap we had previously
        DeleteCaretBitmap(FALSE);

        if (y && y == _yHeightCaret && (_cch || fItalic || dwCaretType))
        {
            LONG dy = 4;                            // Assign value to suppress
            LONG i;                                 //  compiler warning
            WORD rgCaretBitMap[512];
            WORD wBits = 0x0020;

            if(_cch)                                // Create blank bitmap if
            {                                       //  selection is nondegenerate
                y = 1;                              //  (allows others to query
                wBits = 0;                          //  OS where caret is)
                fItalic = FALSE;
            }
            if(fItalic)
            {
                i = (5*y)/16 - 1;                   // System caret can't be wider
                i = min(i, 7);                      //  than 8 bits
                wBits = 1 << i;                     // Make larger italic carets
                dy = y/7;                           //  more vertical. Ideal is
                dy = max(dy, 4);                    //  usually up 4 over 1, but
            }                                       //  if bigger go up 5 over 1...
            for(i = y; i--; )
            {
                rgCaretBitMap[i] = wBits;
                if(fItalic && !(i % dy))
                    wBits /= 2;
            }

            if(!fItalic && !_cch && dwCaretType)
            {
                dwCaretType &= ~CARET_CUSTOM;

                // Create an appropriate shape
                switch (dwCaretType)
                {
                    case CARET_BIDI:
                        // BiDi is a caret with a little triangle on top (flag shape pointing left)
                        rgCaretBitMap[0] = 0x00E0;
                        rgCaretBitMap[1] = 0x0060;
                        break;
                    case CARET_THAI:
                        // Thai is an L-like shape (same as system edit control)
                        rgCaretBitMap[y-2] = 0x0030;
                        rgCaretBitMap[y-1] = 0x0038;
                        break;
                    case CARET_INDIC:
                        // Indic is a T-like shape
                        rgCaretBitMap[0] = 0x00F8;
                        rgCaretBitMap[1] = 0x0070;
                        break;
                    default:
                        if (ped->IsBiDi())
                        {
                            // Non-BiDi caret in BiDi document (flag shape pointing right)
                            rgCaretBitMap[0] = 0x0038;
                            rgCaretBitMap[1] = 0x0030;
                        }
                }
            }
            _hbmpCaret = (HBITMAP)CreateBitmap(8, y, 1, 1, rgCaretBitMap);
        }
    }

    ped->TxCreateCaret(_hbmpCaret, dx, (INT)_yHeightCaret);
    _fCaretCreated = TRUE;

    LONG xShift = _hbmpCaret ? 2 : 0;
    if(fItalic)
    {
        // TODO: figure out better shift algorithm. Use CCcs::_xOverhang?
        if(pCF->_iFont == IFONT_TMSNEWRMN)
            xShift = 4;
        xShift += y/16;
    }
    xShift = _xCaret - xShift;
#ifdef Boustrophedon
    //if(_pPF->_wEffects & PFE_BOUSTROPHEDON)
    {
        RECT rcView;
        _pdp->GetViewRect(rcView, NULL);
        xShift = rcView.right - xShift;
    }
#endif
    ped->TxSetCaretPos(xShift, (INT)_yCaret);
}

/*
 *  CTxtSelection::DeleteCaretBitmap (fReset)
 *
 *  @mfunc  DeleteCaretBitmap
 */
void CTxtSelection::DeleteCaretBitmap(
    BOOL fReset)
{
    if(_hbmpCaret)
    {
        DestroyCaret();
        DeleteObject((void *)_hbmpCaret);
        _hbmpCaret = NULL;
    }
    if(fReset)
        _dwCaretInfo = 0;
}

/*
 *  CTxtSelection::SetDelayedSelectionRange (cp, cch)
 *
 *  @mfunc  sets the selection range such that it won't take effect until
 *          the control is "stable"
 */
void CTxtSelection::SetDelayedSelectionRange(
    LONG    cp,         //@parm Active end
    LONG    cch)        //@parm Signed extension
{
    CSelPhaseAdjuster *pspa;

    pspa = (CSelPhaseAdjuster *)GetPed()->GetCallMgr()->GetComponent(
                        COMP_SELPHASEADJUSTER);
    Assert(pspa);
    pspa->CacheRange(cp, cch);
}

/*
 *  CTxtSelection::CheckPlainTextFinalEOP ()
 *
 *  @mfunc
 *      returns TRUE if this is a plain-text, multiline control with caret
 *      allowed at BOL and the selection at the end of the story following
 *      and EOP
 *
 *  @rdesc
 *      TRUE if all of the conditions above are met
 */
BOOL CTxtSelection::CheckPlainTextFinalEOP()
{
    return !IsRich() && _pdp->IsMultiLine() &&      // Plain-text, multiline
           !_fCaretNotAtBOL &&                      //  with caret OK at BOL,
           GetCp() == GetTextLength() &&            //  & cp at end of story
           _rpTX.IsAfterEOP();
}


/*
 *  CTxtSelection::StopGroupTyping()
 *
 *  @mfunc
 *      Tell undo manager to stop group typing
 */
void CTxtSelection::StopGroupTyping()
{
    IUndoMgr * pundo = GetPed()->GetUndoMgr();

    if(pundo)
        pundo->StopGroupTyping();
}

/*
 *  CTxtSelection::SetupDualFont(ch)
 *
 *  @mfunc  checks to see if dual font support is necessary; in this case,
 *          switching to an English font if English text is entered into
 *          an FE run
 *  @rdesc
 *      A pointer to the current CharFormat if the font has to be changed.
 */
void CTxtSelection::SetupDualFont()
{
    CTxtEdit    *ped = GetPed();
    CCharFormat CF;

    CF._bCharSet = ANSI_CHARSET;
    CCFRunPtr   rp(*this);

    if (rp.GetPreferredFontInfo(
            1252,
            CF._bCharSet,
            CF._iFont,
            CF._yHeight,
            CF._bPitchAndFamily,
            _iFormat,
            IGNORE_CURRENT_FONT))
    {
        if (!_cch)
            SetCharFormat(&CF, SCF_NOKBUPDATE, NULL, CFM_FACE | CFM_CHARSET | CFM_SIZE, 0);
        else
        {
            // For selection, we need to set the character format at cpMin+1
            // and use the format for the selection.
            CTxtRange rg(ped, GetCpMin() + 1, 0);
            rg.SetCharFormat(&CF, SCF_NOKBUPDATE, NULL, CFM_FACE | CFM_CHARSET | CFM_SIZE, 0);
            Set_iCF(rg.Get_iCF());
            GetCharFormatCache()->Release(_iFormat);    // rg.Get_iCF() AddRefs it
            _fUseiFormat = TRUE;
        }

        SetDualFontMode(TRUE);
    }
}

//
//  CSelPhaseAdjuster methods
//

/*
 *  CSelPhaseAdjuster::CSelPhaseAdjuster
 *
 *  @mfunc  constructor
 */
CSelPhaseAdjuster::CSelPhaseAdjuster(
    CTxtEdit *ped)      //@parm the edit context
{
    _cp = _cch = -1;
    _ped = ped;
    _ped->GetCallMgr()->RegisterComponent((IReEntrantComponent *)this,
                            COMP_SELPHASEADJUSTER);
}

/*
 *  CSelPhaseAdjuster::~CSelPhaseAdjuster
 *
 *  @mfunc  destructor
 */
CSelPhaseAdjuster::~CSelPhaseAdjuster()
{
    // Save some indirections
    CTxtEdit *ped = _ped;

    if(_cp != -1)
    {
        ped->GetSel()->SetSelection(_cp - _cch, _cp);

        // If the selection is updated, then we invalidate the
        // entire display because the old selection can still
        // appear othewise because the part of the screen that
        // it was on is not updated.
        if(ped->fInplaceActive())
        {
            // Tell entire client rectangle to update.
            // FUTURE: The smaller we make this the better.
            ped->TxInvalidateRect(NULL, FALSE);
        }
    }
    ped->GetCallMgr()->RevokeComponent((IReEntrantComponent *)this);
}

/*
 *  CSelPhaseAdjuster::CacheRange(cp, cch)
 *
 *  @mfunc  tells this class the selection range to remember
 */
void CSelPhaseAdjuster::CacheRange(
    LONG    cp,         //@parm Active end to remember
    LONG    cch)        //@parm Signed extension to remember
{
    _cp     = cp;
    _cch    = cch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\text.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module TEXT.C -- CTxtPtr implementation |
 *	
 *	Authors: <nl>
 *		Original RichEdit code: David R. Fulmer <nl>
 *		Christian Fortini <nl>
 *		Murray Sargent <nl>
 *
 *	History: <nl>
 *		6/25/95		alexgo	cleanup and reorganization (use run pointers now)
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_text.h"
#include "_edit.h"
#include "_antievt.h"
#include "_clasfyc.h"
#include "_txtbrk.h"


ASSERTDATA

//-----------------------------Internal functions--------------------------------
// Text Block management
static void TxDivideInsertion(LONG cch, LONG ichBlock, LONG cchAfter,
			LONG *pcchFirst, LONG *pcchLast);

/*
 *	IsWhiteSpace(ch)
 *
 *	@func
 *		Used to determine if ch is an EOP char (see IsEOP() for definition),
 *		TAB or blank. This function is used in identifying sentence start
 *		and end.
 *
 *	@rdesc
 *		TRUE if ch is whitespace
 */
BOOL IsWhiteSpace(unsigned ch)
{
	return ch == ' ' || IN_RANGE(CELL, ch, CR) || (ch | 1) == PS;
}

/*
 *	IsSentenceTerminator(ch)
 *
 *	@func
 *		Used to determine if ch is a standard sentence terminator character,
 *		namely, '?', '.', or '!'
 *
 *	@rdesc
 *		TRUE if ch is a question mark, period, or exclamation point.
 */
BOOL IsSentenceTerminator(unsigned ch)
{
	return ch == '?' || ch == '.' || ch == '!';		// Std sentence delimiters
}


// ===========================  Invariant stuff  ==================================================

#define DEBUG_CLASSNAME CTxtPtr
#include "_invar.h"

// ===============================  CTxtPtr  ======================================================

#ifdef DEBUG

/*
 *	CTxtPtr::Invariant
 *
 *	@mfunc	invariant check
 */
BOOL CTxtPtr::Invariant() const
{
	static LONG	numTests = 0;
	numTests++;				// Counts how many times we've been called

	// Make sure _cp is within range
	Assert(_cp >= 0);

	LONG cchValid;
	*(LONG_PTR *)&_pchCp = (LONG_PTR)GetPch(cchValid);

	CRunPtrBase::Invariant();

	if(IsValid())
	{
		// We use less than or equals here so that we can be an insertion
		// point at the *end* of the currently existing text.
		Assert(_cp <= GetTextLength());

		// Make sure all the blocks are consistent...
		Assert(GetTextLength() == ((CTxtArray *)_pRuns)->Invariant());
		Assert(_cp == CRunPtrBase::CalculateCp());
	}
	else
	{
		Assert(_ich == 0);
	}

	return TRUE;
}

/*
 *	CTxtPtr::MoveGapToEndOfBlock ()
 *	
 *	@mfunc
 *		Function to move buffer gap to current block end to aid in debugging
 */
void CTxtPtr::MoveGapToEndOfBlock () const
{
 	CTxtBlk *ptb = GetRun(0);
	ptb->MoveGap(ptb->_cch);				// Move gaps to end of cur block
}

#endif	// DEBUG


/*
 *	CTxtPtr::CTxtPtr(ped, cp)
 *
 *	@mfunc	constructor
 */
CTxtPtr::CTxtPtr (
	CTxtEdit *ped,		//@parm	Ptr to CTxtEdit instance
	LONG	  cp)		//@parm cp to set the pointer to
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::CTxtPtr");

	_ped = ped;
	_cp = 0;
	SetRunArray((CRunArray *) &ped->GetTxtStory()->_TxtArray);
	if(IsValid())
		_cp = BindToCp(cp);
}

/*
 *	CTxtPtr::CTxtPtr(&tp)
 *
 *	@mfunc	Copy Constructor
 */
CTxtPtr::CTxtPtr (
	const CTxtPtr &tp)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::CTxtPtr");

	// copy all the values over
	*this = tp;
}	

/*
 *	CTxtPtr::GetTextLength()
 *	
 *	@mfunc
 *		Return count of characters in the story pointed to by this
 *		text ptr.  Includes the story's final CR in the count
 *
 *	@rdesc
 *		cch for the story pointed to by this text ptr
 *
 *	@devnote
 *		This method returns 0 if the text ptr is a zombie, a state
 *		identified by _ped = NULL.
 */
LONG CTxtPtr::GetTextLength() const
{
	return _ped ? ((CTxtArray *)_pRuns)->_cchText : 0;
}

/*
 *	CTxtPtr::GetChar()
 *	
 *	@mfunc
 *		Return character at this text pointer, NULL if text pointer is at
 *		end of text
 *
 *	@rdesc
 *		Character at this text ptr
 */
TCHAR CTxtPtr::GetChar()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::GetChar");

	LONG		 cchValid;
	const TCHAR *pch = GetPch(cchValid);

	return pch ? *pch : 0;
}

/*
 *	CTxtPtr::GetPrevChar()
 *	
 *	@mfunc
 *		Return character just before this text pointer, NULL if text pointer
 *		beginning of text
 *
 *	@rdesc
 *		Character just before this text ptr
 */
TCHAR CTxtPtr::GetPrevChar()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::GetPrevChar");

	LONG		 cchValid;
	const TCHAR *pch = GetPchReverse(cchValid);

	return pch ? *(pch - 1) : 0;
}

/*
 *	CTxtPtr::GetPch(&cchValid)
 *	
 *	@mfunc
 *		return a character pointer to the text at this text pointer
 *
 *	@rdesc
 *		a pointer to an array of characters.  May be NULL.  If non-null,
 *		then cchValid is guaranteed to be at least 1
 */
const TCHAR * CTxtPtr::GetPch(
	LONG & 	cchValid) const	//@parm	Count of chars for which ptr is valid
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::GetPch");
							//		returned pointer is valid
	LONG		ich = _ich;
	TCHAR *		pchBase;
	CTxtBlk *	ptb = IsValid() ? GetRun(0) : NULL;

	cchValid = 0;						// Default nothing valid
	if(!ptb)
		return NULL;

	// If we're at the edge of a run, grab the next run or
	// stay at the current run.

	if(_ich == ptb->_cch)
	{
		if(_iRun < Count() - 1)
		{
			// set us to the next text block
			ptb = GetRun(1);
			ich = 0;
		}
		else							// At very end of text:
			return NULL;				//  just return NULL
	}

	AssertSz(CbOfCch(ich) <= ptb->_cbBlock,
		"CTxtPtr::GetPch(): _ich bigger than block");

	pchBase = ptb->_pch + ich;


	// Check to see if we need to skip over gap.  Recall that
	// the game may come anywhere in the middle of a block,
	// so if the current ich (note, no underscore, we want
	// the active ich) is beyond the gap, then recompute pchBase
	// by adding in the size of the block.
	//
	// cchValid will then be the number of characters left in
	// the text block (or _cch - ich)

	if(CbOfCch(ich) >= ptb->_ibGap)
	{
		pchBase += CchOfCb(ptb->_cbBlock) - ptb->_cch;
		cchValid = ptb->_cch - ich;
	}
	else
	{
		// We're valid until the buffer gap (or see below).
		cchValid = CchOfCb(ptb->_ibGap) - ich;
	}

	AssertSz(cchValid > 0 && GetCp() + cchValid <= GetTextLength(),
		"CTxtPtr::GetPch: illegal cchValid");
	return pchBase;
}

/*
 *	CTxtPtr::GetPchReverse(&cchValidReverse, pcchValid)
 *	
 *	@mfunc
 *		return a character pointer to the text at this text pointer
 *		adjusted so that there are some characters valid *behind* the
 *		pointer.
 *
 *	@rdesc
 *		a pointer to an array of characters.  May be NULL.  If non-null,
 *		then cchValidReverse is guaranteed to be at least 1
 */
const TCHAR * CTxtPtr::GetPchReverse(
	LONG & 	cchValidReverse,		//@parm	length for reverse
	LONG *	pcchValid)				//@parm length forward
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::GetPchReverse");

	_TEST_INVARIANT_

	LONG		cchTemp;
	LONG		ich = _ich;
	TCHAR *		pchBase;
	CTxtBlk *	ptb = IsValid() ? GetRun(0) : NULL;

	cchValidReverse = 0;				// Default no valid chars in run
	if(!ptb)
		return NULL;

	// If we're at the edge of a run, grab the previous run or
	// stay at the current run.
	if(!_ich)
	{
		if(_iRun)
		{
			ptb = GetRun(-1);			// Go to next text block
			ich = ptb->_cch;
		}
		else							// At start of text:
			return NULL;				//  just return NULL
	}

	AssertSz(CbOfCch(ich) <= ptb->_cbBlock,
		"CTxtPtr::GetPchReverse(): _ich bigger than block");

	pchBase = ptb->_pch + ich;

	// Check to see if we need to skip over gap.  Recall that
	// the game may come anywhere in the middle of a block,
	// so if the current ich (note, no underscore, we want
	// the active ich) is at least one char past the gap, then recompute
	// pchBase by adding the size of the gap (so that it's after
	// the gap).  This differs from GetPch(), which works forward and
	// wants pchBase to include the gap size if ich is at the gap, let
	// alone one or more chars past it.
	//
	// Also figure out the count of valid characters.  It's
	// either the count of characters from the beginning of the
	// text block, i.e. ich, or the count of characters from the
	// end of the buffer gap.

	cchValidReverse = ich;					// Default for ich <= gap offset
	cchTemp = ich - CchOfCb(ptb->_ibGap);	// Calculate displacement
	if(cchTemp > 0)							// Positive: pchBase is after gap
	{
		cchValidReverse = cchTemp;
		pchBase += CchOfCb(ptb->_cbBlock) - ptb->_cch;	// Add in gap size
	}
	if(pcchValid)							// if client needs forward length
	{
		if(cchTemp > 0)
			cchTemp = ich - ptb->_cch;
		else
			cchTemp = -cchTemp;

		*pcchValid = cchTemp;
	}

	AssertSz(cchValidReverse > 0 && GetCp() - cchValidReverse >= 0,
		"CTxtPtr::GetPchReverse: illegal cchValidReverse");
	return pchBase;
}

/*
 *	CTxtPtr::BindToCp(cp)
 *
 *	@mfunc
 *		set cached _cp = cp (or nearest valid value)
 *
 *	@rdesc
 *		_cp actually set
 *
 *	@comm
 *		This method overrides CRunPtrBase::BindToCp to keep _cp up to date
 *		correctly.
 *
 *	@devnote
 *		Do *not* call this method when high performance is needed; use
 *		AdvanceCp() instead, which advances from 0 or from the cached
 *		_cp, depending on which is closer.
 */
LONG CTxtPtr::BindToCp(
	LONG	cp)			//@parm	char position to bind to
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::BindToCp");

	_cp = CRunPtrBase::BindToCp(cp);

	// We want to be able to use this routine to fix up things so we don't
	// check invariants on entry.
	_TEST_INVARIANT_
	return _cp;
}


/*
 *	CTxtPtr::SetCp(cp)
 *
 *	@mfunc
 *		'efficiently' sets cp by advancing from current position or from 0,
 *		depending on which is closer
 *
 *	@rdesc
 *		cp actually set to
 */
LONG CTxtPtr::SetCp(
	LONG	cp)		//@parm char position to set to
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::SetCp");

	AdvanceCp(cp - _cp);
	return _cp;
}

/*
 *	CTxtPtr::AdvanceCp(cch)
 *
 *	@mfunc
 *		Advance cp by cch characters
 *
 *	@rdesc
 *		Actual number of characters advanced by
 *
 *	@comm
 *		We override CRunPtrBase::AdvanceCp so that the cached _cp value
 *		can be correctly updated and so that the advance can be made
 *		from the cached _cp or from 0, depending on which is closer.
 *
 *	@devnote
 *		It's also easy to bind at the end of the story. So an improved
 *		optimization would bind there if 2*(_cp + cch) > _cp + text length.
 */
LONG CTxtPtr::AdvanceCp(
	LONG cch)			// @parm count of chars to advance by
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::AdvanceCp");

	if(!IsValid())							// No runs yet, so don't go
		return 0;							//  anywhere

	const LONG	cpSave = _cp;				// Save entry _cp
	LONG		cp = cpSave + cch;			// Requested target cp (maybe < 0)

	if(cp < cpSave/2)						// Closer to 0 than cached cp
	{
		cp = max(cp, 0);					// Don't undershoot
		_cp = CRunPtrBase::BindToCp(cp);
	}
	else
		_cp += CRunPtrBase::AdvanceCp(cch);	//  exist

	// NB! the invariant check needs to come at the end; we may be
	// moving 'this' text pointer in order to make it valid again
	// (for the floating range mechanism).

	_TEST_INVARIANT_
	return _cp - cpSave;					// cch this CTxtPtr moved
}

/*
 *	CTxtPtr::GetText(cch, pch)
 *	
 *	@mfunc
 *		get a range of cch characters starting at this text ptr. A literal
 *		copy is made, i.e., with no CR -> CRLF and WCH_EMBEDDING -> ' '
 *		translations.  For these translations, see CTxtPtr::GetPlainText()
 *	
 *	@rdesc
 *		count of characters actually copied
 *
 *  @comm
 *		Doesn't change this text ptr
 */
LONG CTxtPtr::GetText(
	LONG	cch, 			//@parm Count of characters to get
	TCHAR *	pch)			//@parm Buffer to copy the text into
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::GetText");

	LONG cchSave = cch;
	LONG cchValid;
	const TCHAR *pchRead;
	CTxtPtr tp(*this);

	_TEST_INVARIANT_

	// Use tp to read valid blocks of text until all the requested
	// text is read or until the end of story is reached.
	while( cch )
	{
		pchRead = tp.GetPch(cchValid);
		if(!pchRead)					// No more text
			break;

		cchValid = min(cchValid, cch);
		CopyMemory(pch, pchRead, cchValid*sizeof(TCHAR));
		pch += cchValid;
		cch -= cchValid;
		tp.AdvanceCp(cchValid);
	}
	return cchSave - cch;
}

/*
 *	OverRideNeutralChar(ch)
 *	
 *	@mfunc
 *		Helper for overriding BiDi neutral character classification.
 *		Option is used in Access Expression Builder.
 *	
 *	@rdesc
 *		Modified character or unmodified input character
 */
WCHAR OverRideNeutralChar(WCHAR ch)
{
	if (ch < '!' || ch > '}')
		return ch;

	if (IN_RANGE('!', ch, '>'))
	{
		// True for !"#&'()*+,-./:;<=>
		if ((0x00000001 << (ch - TEXT(' '))) & 0x7C00FFCE)
			ch = 'a';
	}

	if (IN_RANGE('[', ch, '^') || ch == '{' ||  ch == '}')
	{
		// True for [/]^{}
		ch = 'a';
	}

	return ch;
}

/*
 *	CTxtPtr::GetTextForUsp(cch, pch)
 *	
 *	@mfunc
 *		get a range of cch characters starting at this text ptr. A literal
 *		copy is made, with translation to fool Uniscribe classification
 *	
 *	@rdesc
 *		count of characters actually copied
 *
 *  @comm
 *		Doesn't change this text ptr
 */
LONG CTxtPtr::GetTextForUsp(
	LONG	cch, 				//@parm Count of characters to get
	TCHAR *	pch,				//@parm Buffer to copy the text into
	BOOL	fNeutralOverride)	//@parm Neutral override option
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::GetTextForUsp");

	LONG cchSave = cch;
	LONG cchValid;
	const TCHAR *pchRead;
	CTxtPtr tp(*this);
	int i;
	TCHAR xltchar;

	_TEST_INVARIANT_

	// Use tp to read valid blocks of text until all the requested
	// text is read or until the end of story is reached.
	while( cch )
	{
		pchRead = tp.GetPch(cchValid);
		if(!pchRead)					// No more text
			break;

		cchValid = min(cchValid, cch);

		if (!fNeutralOverride)
		{
			for (i = 0; i < cchValid; i++)
			{
				xltchar = pchRead[i];
				if (IN_RANGE('#', xltchar, '-'))
				{
					/* #$+- */
					if ((0x1 << (xltchar - '#')) & 0x503)
						xltchar = '@';
				}
				pch[i] = xltchar;
			}
		}
		else
		{
			for (i = 0; i < cchValid; i++)
			{
				pch[i] = OverRideNeutralChar(pchRead[i]);
			}
		}

		pch += cchValid;
		cch -= cchValid;
		tp.AdvanceCp(cchValid);
	}
	return cchSave - cch;
}

/*
 *	CTxtPtr::GetPlainText(cchBuff, pch, cpMost, fTextize, fAdjustCRLF)
 *	
 *	@mfunc
 *		Copy up to cchBuff characters or up to cpMost, whichever comes
 *		first, translating lone CRs into CRLFs.  Move this text ptr just
 *		past the last character processed.  If fTextize, copy up to but
 *		not including the first WCH_EMBEDDING char. If not fTextize,
 *		replace	WCH_EMBEDDING by a blank since RichEdit 1.0 does.
 *	
 *	@rdesc
 *		Count of characters copied
 *
 *  @comm
 *		An important feature is that this text ptr is moved just past the
 *		last char copied.  In this way, the caller can conveniently read
 *		out plain text in bufferfuls of up to cch chars, which is useful for
 *		stream I/O.  This routine won't copy the final CR even if cpMost
 *		is beyond it.
 */
LONG CTxtPtr::GetPlainText(
	LONG	cchBuff,		//@parm Buffer cch
	TCHAR *	pch,			//@parm Buffer to copy text into
	LONG	cpMost,			//@parm Largest cp to get
	BOOL	fTextize,		//@parm True if break on WCH_EMBEDDING
	BOOL	fAdjustCRLF)	//@parm TRUE to call AdjustCpCRLF()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::GetPlainText");

	LONG		 cch = cchBuff;				// Countdown counter
	LONG		 cchValid;					// Valid ptr cch
	LONG		 cchT;						// Temporary cch
	unsigned	 ch;						// Current char
	const TCHAR *pchRead;					// Backing-store ptr

	_TEST_INVARIANT_

	if(fAdjustCRLF)
		AdjustCpCRLF();						// Be sure we start on an EOP bdy

	LONG cchText = _ped->GetAdjustedTextLength();
	cpMost = min(cpMost, cchText);			// Don't write final CR
	if(GetCp() >= cpMost)
		return 0;

	while(cch > 0)							// While room in buffer
	{
		if(!(pchRead = GetPch(cchValid)))	// No more chars available
			break;							//  so we're out of here
		
		cchT = GetCp() + cchValid - cpMost;
		if(cchT > 0)						// Don't overshoot
		{
			cchValid -= cchT;
			if(cchValid <= 0)
				break;						// Nothing left before cpMost
		}

		for(cchT = 0; cch > 0 && cchT < cchValid; cchT++, cch--)
		{
			ch = *pch++ = *pchRead++;		// Copy next char (but don't
			if(IsASCIIEOP(ch) && !_ped->Get10Mode() && ch != FF)	//  count it yet)
			{
				AdvanceCp(cchT);			// Move up to CR
				if(cch < 2)					// No room for LF, so don't				
					goto done;				//  count CR either
											// Bypass EOP w/o worrying about
				cchT = AdvanceCpCRLF();		//  buffer gaps and blocks
				if(cchT > 2)				// Translate CRCRLF to ' '
				{							// Usually copied count exceeds
					Assert(cchT == 3);		//  internal count, but CRCRLFs
					*(pch - 1) = ' ';		//  reduce the relative increase:
				}							//  NB: error for EM_GETTEXTLENGTHEX
				else						// CRLF or lone CR
				{							// Store LF in both cases for
					*(pch - 1) = CR;		// Be sure it's a CR not a VT,
#ifndef MACPORT								//  FF, or lone LF
					*pch++ = LF;			// Windows. No LF for Mac
					cch--;					// One less for target buffer
#endif
				}
				cch--;						// CR (or ' ') copied
				cchT = 0;					// Don't AdvanceCp() more below
				break;						// Go get new pchRead & cchValid
			}
			else if(ch == WCH_EMBEDDING)	// Object lives here
			{
				if(fTextize)				// Break on WCH_EMBEDDING
				{
					AdvanceCp(cchT);		// Move this text ptr up to
					goto done;				//  WCH_EMBEDDING and return
				}
				*(pch - 1) = ' ';			// Replace embedding char by ' '
			}								//  since RichEdit 1.0 does
		}
		AdvanceCp(cchT);
	}

done:
	return cchBuff - cch;
}

/*
 *	CTxtPtr::AdvanceCpCRLF()
 *	
 *	@mfunc
 *		Advance text pointer by one character, safely advancing
 *		over CRLF, CRCRLF, and UTF-16 combinations
 *	
 *	@rdesc
 *		Number of characters text pointer has been moved by
 *
 */
LONG CTxtPtr::AdvanceCpCRLF(
	BOOL	fMulticharAdvance)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::AdvanceCpCRLF");

	_TEST_INVARIANT_

	LONG	cp;
	LONG	cpSave	= _cp;
	TCHAR	ch		= GetChar();		// Char on entry
	TCHAR	ch1		= NextChar();		// Advance to and get next char
	BOOL	fTwoCRs = FALSE;
	BOOL	fCombiningMark = FALSE;

	if(ch == CR)
	{
		if(ch1 == CR && _cp < GetTextLength())
		{
			fTwoCRs = TRUE;				// Need at least 3 chars to
			ch1 = NextChar();			//  have CRCRLF at end
		}
		if(ch1 == LF)
			AdvanceCp(1);				// Bypass CRLF
		else if(fTwoCRs)
			AdvanceCp(-1);				// Only bypass one CR of two

		AssertSz(_ped->fUseCRLF() || _cp == cpSave + 1,
			"CTxtPtr::AdvanceCpCRLF: EOP isn't a single char");
	}

	// Handle Unicode UTF-16 surrogates
	if(IN_RANGE(0xD800, ch, 0xDBFF))	// Started on UTF-16 lead word
	{
		if (IN_RANGE(0xDC00, ch1, 0xDFFF))
			AdvanceCp(1);					// Bypass UTF-16 trail word
		else
			AssertSz(FALSE, "CTxtPtr::AdvanceCpCRLF: illegal Unicode surrogate combo");
	}

	if (fMulticharAdvance)
	{
		while(IN_RANGE(0x300, ch1, 0x36F))	// Bypass combining diacritical marks
		{
			fCombiningMark = TRUE;
			cp = _cp;
			ch1 = NextChar();
			if (_cp == cp)
				break;
		}
	}

	LONG cch = _cp - cpSave;
	AssertSz(!cch || cch == 1 || fCombiningMark ||
			 cch == 2 && IN_RANGE(0xD800, ch, 0xDBFF) ||
			 (_ped->fUseCRLF() && GetPrevChar() == LF &&
				(cch == 2 || cch == 3 && fTwoCRs)),
		"CTxtPtr::AdvanceCpCRLF(): Illegal multichar");

	return cch;				// # chars bypassed
}

/*
 *	CTxtPtr::NextChar()
 *	
 *	@mfunc
 *		Increment this text ptr and return char it points at
 *	
 *	@rdesc
 *		Next char
 */
TCHAR CTxtPtr::NextChar()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::NextChar");

	_TEST_INVARIANT_

 	AdvanceCp(1);
	return GetChar();
}

/*
 *	CTxtPtr::PrevChar()
 *	
 *	@mfunc
 *		Decrement this text ptr and return char it points at
 *	
 *	@rdesc
 *		Previous char
 */
TCHAR CTxtPtr::PrevChar()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::PrevChar");

	_TEST_INVARIANT_

	return AdvanceCp(-1) ? GetChar() : 0;
}

/*
 *	CTxtPtr::BackupCpCRLF(fDiacriticCheck)
 *	
 *	@mfunc
 *		Backup text pointer by one character, safely backing up
 *		over CRLF, CRCRLF, and UTF-16 combinations
 *	
 *	@rdesc
 *		Number of characters text pointer has been moved by
 *
 */
LONG CTxtPtr::BackupCpCRLF(
	BOOL fMulticharBackup)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::BackupCpCRLF");

	_TEST_INVARIANT_

	LONG  cpSave = _cp;
	WCHAR ch	 = PrevChar();			// Advance to and get previous char


	if(fMulticharBackup)
	{									// Bypass combining diacritical marks
		while(IN_RANGE(0x300, ch, 0x36F))
			ch = PrevChar();
	}

	// Handle Unicode UTF-16 surrogates
	if(_cp && IN_RANGE(0xDC00, ch, 0xDFFF))
	{
		ch = PrevChar();
		if (!IN_RANGE(0xD800, ch, 0xDBFF))
		{
			AssertSz(FALSE, "CTxtPtr::BackupCpCRLF: illegal Unicode surrogate combo");
			ch = NextChar();
		}
	}

	if (ch == LF &&					 	// Try to back up 1 char in any case
		(_cp && PrevChar() != CR ||		// If LF, does prev char = CR?
		 _cp && PrevChar() != CR))		// If so, does its prev char = CR?
	{									//  (CRLF at BOD checks CR twice; OK)
		AdvanceCp(1);					// Backed up too far
	}

	AssertSz( _cp == cpSave ||
			  ch == LF && GetChar() == CR ||
			  !(ch == LF || fMulticharBackup &&
							(IN_RANGE(0x300, ch, 0x36F) ||
							 IN_RANGE(0xDC00, ch, 0xDFFF) && IN_RANGE(0xD800, GetPrevChar(), 0xDBFF)) ),
			 "CTxtPtr::BackupCpCRLF(): Illegal multichar");

	return _cp - cpSave;				// - # chars this CTxtPtr moved
}

/*
 *	CTxtPtr::AdjustCpCRLF()
 *	
 *	@mfunc
 *		Adjust the position of this text pointer to the beginning of a CRLF,
 *		CRCRLF, or UTF-16 combination if it is in the middle of such a
 *		combination
 *	
 *	@rdesc
 *		Number of characters text pointer has been moved by
 *
 *	@future
 *		Adjust to beginning of sequence containing Unicode combining marks
 */
LONG CTxtPtr::AdjustCpCRLF()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::AdjustCpCRLF");

	_TEST_INVARIANT_

	LONG	 cpSave = _cp;
	unsigned ch		= GetChar();

	// Handle Unicode UTF-16 surrogates
	if(IN_RANGE(0xDC00, ch, 0xDFFF))	// Landed on UTF-16 trail word
	{
		AdvanceCp(-1);					// Backup to UTF-16 lead word
		AssertSz(IN_RANGE(0xD800, GetChar(), 0xDBFF),
			"CTxtPtr::AdvanceCpCRLF: illegal Unicode surrogate combo");
		return -1;
	}

	if(!IsASCIIEOP(ch))							// Early out
		return 0;

	if(ch == LF && cpSave && PrevChar() != CR)	// Landed on LF not preceded
	{											//  by CR, so go back to LF
		AdvanceCp(1);							// Else on CR of CRLF or
	}											//  second CR of CRCRLF

	// Note: since we replace all CRCRLFs by blanks on input, the following
	// code is probably archaic
	if(GetChar() == CR)							// Land on a CR of CRLF or
	{											//  second CR of CRCRLF?
		CTxtPtr tp(*this);

		if(tp.NextChar() == LF)
		{
			tp.AdvanceCp(-2);					// First CR of CRCRLF ?
			if(tp.GetChar() == CR)				// Yes or CRLF is at start of
				AdvanceCp(-1);					//  story. Try to back up over
		}										//  CR (If at BOS, no effect)
	}
	return _cp - cpSave;
}

/*
 *	CTxtPtr::IsAtEOP()
 *	
 *	@mfunc
 *		Return TRUE iff this text pointer is at an end-of-paragraph mark
 *	
 *	@rdesc
 *		TRUE if at EOP
 *
 *	@devnote
 *		End of paragraph marks for RichEdit 1.0 and the MLE can be CRLF
 *		and CRCRLF.  For RichEdit 2.0, EOPs can also be CR, VT (0xB - Shift-
 *		Enter), and FF (0xC - page break or form feed).
 */
BOOL CTxtPtr::IsAtEOP()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::IsAtEOP");

	_TEST_INVARIANT_

	unsigned ch = GetChar();

	if(IsASCIIEOP(ch))							// See if LF <= ch <= CR
	{											// Clone tp in case
		CTxtPtr tp(*this);						//  AdjustCpCRLF moves
		return !tp.AdjustCpCRLF();				// Return TRUE unless in
	}											//  middle of CRLF or CRCRLF
	return (ch | 1) == PS;						// Allow Unicode 0x2028/9 also
}

/*
 *	CTxtPtr::IsAfterEOP()
 *	
 *	@mfunc
 *		Return TRUE iff this text pointer is just after an end-of-paragraph
 *		mark
 *	
 *	@rdesc
 *		TRUE iff text ptr follows an EOP mark
 */
BOOL CTxtPtr::IsAfterEOP()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::IsAfterEOP");

	_TEST_INVARIANT_

	if(IsASCIIEOP(GetChar()))
	{
		CTxtPtr tp(*this);					// If in middle of CRLF
		if(tp.AdjustCpCRLF())				//  or CRCRLF, return FALSE
			return FALSE;
	}
	return IsEOP(GetPrevChar());			// After EOP if after Unicode
}								   			//  PS or LF, VT, FF, or CR

// Needed for CTxtPtr::ReplaceRange() and InsertRange()
#if cchGapInitial < 1
#error "cchGapInitial must be at least one"
#endif

/*
 *	CTxtPtr::MoveWhile(cch, chFirst, chLast, fInRange)
 *	
 *	@mfunc
 *		Move this text ptr 1) to first char (fInRange ? in range : not in range)
 *		chFirst thru chLast or 2) cch chars, which ever comes first.  Return
 *		count of chars left in run on return. E.g., chFirst = 0, chLast = 0x7F
 *		and fInRange = TRUE	breaks on first nonASCII char.
 *	
 *	@rdesc
 *		cch left in run on return
 */
LONG CTxtPtr::MoveWhile(
	LONG  cchRun,	//@parm Max cch to check
	WCHAR chFirst,	//@parm First ch in range
	WCHAR chLast,	//@parm Last ch in range
	BOOL  fInRange)	//@parm break on non0/0 high byte for TRUE/FALSE
{
	LONG  cch;
	LONG  i;
	const WCHAR *pch;

	while(cchRun)
	{
		pch = GetPch(cch);
		cch = min(cch, cchRun);
		for(i = 0; i < cch; i++)
		{
			if(IN_RANGE(chFirst, *pch++, chLast) ^ fInRange)
			{
				AdvanceCp(i);		// Advance to 1st char with 0/non0 masked
				return cchRun - i;	//  value
			}
		}
		cchRun -= cch;
		AdvanceCp(cch);				// Advance to next txt bdy
	}
	return 0;
}

/*
 *	CTxtPtr::FindWordBreak(action, cpMost)
 *	
 *	@mfunc
 *		Find a word break and move this text pointer to it.
 *
 *	@rdesc
 *		Offset from cp of the word break
 */
LONG CTxtPtr::FindWordBreak(
	INT		action,		//@parm See TxWordBreakProc header
	LONG	cpMost)		//@parm Limiting character position
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::FindWordBreak");

	_TEST_INVARIANT_

	const INT			breakBufSize = 16;
	LONG				bufferSize;
	LONG				cch;
	LONG				cchBuffer;
	LONG				cchChunk;
	LONG				cchText = GetTextLength();
	TCHAR				ch = GetChar();
	TCHAR				pchBreakBuf[breakBufSize];
	LONG				cpSave = _cp;				// For calculating break pt
	LONG				ichBreak;
	TCHAR *				pBuf;
	TCHAR const *		pch;
	LONG				t;							// Temp for abs() macro
	BOOL				b10ModeWordBreak = (_ped->Get10Mode() && _ped->_pfnWB);

	if(action == WB_CLASSIFY || action == WB_ISDELIMITER)
		return ch ? _ped->TxWordBreakProc(&ch, 0, CbOfCch(1), action, GetCp()) : 0;

	if(action & 1)									// Searching forward
	{												// Easiest to handle EOPs			
		if(action == WB_MOVEWORDRIGHT && IsEOP(ch))	//  explicitly (spanning
		{											//  a class can go too
			AdjustCpCRLF();							//  far). Go to end of
			AdvanceCpCRLF();						//  EOP "word"
			goto done;
		}
													// Calc. max search
		if((DWORD)cpMost > (DWORD)cchText)			// Bounds check: get < 0
			cpMost = cchText;						//  as well as too big
		cch = cpMost - _cp;

		while(cch > 0)
		{											// The independent buffer
			cchBuffer = min(cch, breakBufSize - 1);	//  avoids gaps in BS
			cch -= bufferSize = cchBuffer;
			pBuf = pchBreakBuf;						// Fill buffer forward

			// Grab the first character in reverse for fnWB that require 2
			// chars. Note, we play with _ich to get single char fnWB
			// to ignore this character.			 							
			pch = GetPchReverse(cchChunk);
			*pBuf++ = (cchChunk ? *(pch - 1) : L' ');

			while ( cchBuffer )						// Finish filling
			{
				pch = GetPch(cchChunk);
				if (!cchChunk) { Assert(0); break; }

				cchChunk = min(cchBuffer, cchChunk);
				AdvanceCp(cchChunk);
				wcsncpy(pBuf, pch, cchChunk);
				pBuf += cchChunk;
				cchBuffer -= cchChunk;
			}
			ichBreak = _ped->TxWordBreakProc(pchBreakBuf, 1,		// Find the break
						CbOfCch(bufferSize+1), action, GetCp()-bufferSize, GetCp()-bufferSize) - 1;

			// in 1.0 mode some apps will return 0 implying the current cp position is a valid break point
			if (ichBreak == -1 && b10ModeWordBreak)
				ichBreak = 0;

			// Apparently, some fnWBs return ambiguous results						
			if(ichBreak >= 0 && ichBreak <= bufferSize)
			{
				// Ambiguous break pt?
				// Due to the imprecise nature of the word break proc spec,
				// we've reached an ambiguous condition where we don't know
				// if this is really a break, or just the end of the data.
				// By backing up or going forward by 2, we'll know for sure.
				// NOTE: we'll always be able to advance or go back by 2
				// because we guarantee that when !cch that we have
				// at least breakBufSize (16) characters in the data stream.
				if (ichBreak < bufferSize || !cch)
				{
					AdvanceCp( ichBreak - bufferSize );
					break;
				}

				// Need to recalc break pt to disambiguate
				t = AdvanceCp(ichBreak - bufferSize - 2);	// abs() is a
				cch += abs(t);						//  macro
			}
		}
	}
	else	// REVERSE - code dup based on EliK "streams" concept.
	{
		if(!_cp)									// Can't go anywhere
			return 0;

		if(action == WB_MOVEWORDLEFT)				// Easiest to handle EOPs			
		{											//  here
			if(IsASCIIEOP(ch) && AdjustCpCRLF())	// In middle of a CRLF or
				goto done;							//  CRCRLF "word"
			ch = PrevChar();						// Check if previous char
			if(IsEOP(ch))							//  is an EOP char
			{
				if(ch == LF)						// Backspace to start of
					AdjustCpCRLF();					//  CRLF and CRCRLF
				goto done;
			}
			AdvanceCp(1);							// Move back to start char
		}
													// Calc. max search
		if((DWORD)cpMost > (DWORD)_cp)				// Bounds check (also
			cpMost = _cp;							//  handles cpMost < 0)
		cch = cpMost;

		while(cch > 0)
		{											// The independent buffer
			cchBuffer = min(cch, breakBufSize - 1);	//  avoids gaps in BS
			cch -= bufferSize = cchBuffer;
			pBuf = pchBreakBuf + cchBuffer;			// Fill from the end.

			// Grab the first character forward for fnWB that require 2 chars.
			// Note: we play with _ich to get single char fnWB to ignore this
			// character.
			pch = GetPch(cchChunk);
			if ( !cchChunk ) pch = L" ";			// Any break char
			*pBuf = *pch;

			while ( cchBuffer > 0 )					// Fill rest of buffer
			{										//  before going in reverse
				pch = GetPchReverse(cchChunk );
				if (!cchChunk) { Assert(0); break; }

				cchChunk = min(cchBuffer, cchChunk);
				AdvanceCp(-cchChunk);
				pch -= cchChunk;
				pBuf -= cchChunk;
				wcsncpy(pBuf, pch, cchChunk);
				cchBuffer -= cchChunk;
			}
													// Get break left.
			ichBreak = _ped->TxWordBreakProc(pchBreakBuf, bufferSize,
							 CbOfCch(bufferSize+1), action, GetCp(), GetCp()+bufferSize);
			
			// in 1.0 mode some apps will return 0 implying the current cp position is a valid break point
			if (ichBreak == 0 && b10ModeWordBreak)
				ichBreak = bufferSize;

			// Apparently, some fnWBs return ambiguous results
			if(ichBreak >= 0 && ichBreak <= bufferSize)
			{										// Ambiguous break pt?
				// NOTE: when going in reverse, we have >= bufsize - 1
				//  because there is a break-after char (hyphen).
				if ( ichBreak > 0 || !cch )
				{
					AdvanceCp(ichBreak);			// Move _cp to break point.
					break;
				}													
				cch += AdvanceCp(2 + ichBreak);		// Need to recalc break pt
			}										//  to disambiguate.
		}
	}

done:
	return _cp - cpSave;							// Offset of where to break
}

/*
 *	CTxtPtr::TranslateRange(cch, CodePage, fSymbolCharSet, publdr)
 *
 *	@mfunc
 *		Translate a range of text at this text pointer to...
 *	
 *	@rdesc
 *		Count of new characters added (should be same as count replaced)
 *	
 *	@devnote
 *		Moves this text pointer to end of replaced text.
 *		May move text block and formatting arrays.
 */
LONG CTxtPtr::TranslateRange(
	LONG		  cch,				//@parm length of range to translate
	UINT		  CodePage,			//@parm CodePage for MBTWC or WCTMB
	BOOL		  fSymbolCharSet,	//@parm Target charset
	IUndoBuilder *publdr)			//@parm Undo bldr to receive antievents
{
	CTempWcharBuf twcb;
	CTempCharBuf tcb;

	UINT	ch;
	BOOL	fAllASCII = TRUE;
	BOOL	fNoCodePage;
	BOOL	fUsedDef;	//@parm Out parm to receive whether default char used
	LONG	i;
	char *	pastr = tcb.GetBuf(cch);
	WCHAR *	pstr  = twcb.GetBuf(cch);
	WCHAR * pstrT = pstr;

	i = GetText(cch, pstr);
	Assert(i == cch);

	if(fSymbolCharSet)					// Target is SYMBOL_CHARSET
	{
		WCTMB(CodePage, 0, pstr, cch, pastr, cch, "\0", &fUsedDef,
			  &fNoCodePage, FALSE);
		if(fNoCodePage)
			return cch;
		for(; i && *pastr; i--)			// Break if conversion failed
		{								//  (NULL default char used)
			if(*pstr >= 128)
				fAllASCII = FALSE;
			*pstr++ = *(BYTE *)pastr++;
		}
		cch -= i;
		if(fAllASCII)
			return cch;
	}
	else								// Target isn't SYMBOL_CHARSET
	{
		while(i--)
		{
			ch = *pstr++;				// Source is SYMBOL_CHARSET, so
			*pastr++ = (char)ch;		//  all chars should be < 256
			if(ch >= 128)				// In any event, truncate to BYTE
				fAllASCII = FALSE;
		}								
		if(fAllASCII)					// All ASCII, so no conversion needed
			return cch;

		MBTWC(CodePage, 0, pastr - cch, cch, pstrT, cch, &fNoCodePage);
		if(fNoCodePage)
			return cch;
	}
	return ReplaceRange(cch, cch, pstrT, publdr, NULL, NULL);
}

/*
 *	CTxtPtr::ReplaceRange(cchOld, cchNew, *pch, publdr, paeCF, paePF)
 *	
 *	@mfunc
 *		replace a range of text at this text pointer.
 *	
 *	@rdesc
 *		count of new characters added
 *	
 *	@comm	SideEffects: <nl>
 *		moves this text pointer to end of replaced text <nl>
 *		moves text block array <nl>
 */
LONG CTxtPtr::ReplaceRange(
	LONG cchOld, 				//@parm length of range to replace
								// (<lt> 0 means to end of text)
	LONG cchNew, 				//@parm length of replacement text
	TCHAR const *pch, 			//@parm replacement text
	IUndoBuilder *publdr,		//@parm if non-NULL, where to put an
								// anti-event for this action
	IAntiEvent *paeCF,			//@parm char format AE
	IAntiEvent *paePF )			//@parm paragraph formatting AE
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::ReplaceRange");

	_TEST_INVARIANT_

	LONG cchAdded = 0;
	LONG cchInBlock;
	LONG cchNewInBlock;

	if(cchOld < 0)
		cchOld = GetTextLength() - _cp;

	if(publdr)
		HandleReplaceRangeUndo( cchOld, cchNew, publdr, paeCF, paePF);

	// Blocks involving replacement

	while(cchOld > 0 && cchNew > 0)
	{	
		CTxtBlk *ptb = GetRun(0);

		// cchOld should never be nonzero if the text run is empty
		AssertSz(ptb,
			"CTxtPtr::Replace() - Pointer to text block is NULL !");

		ptb->MoveGap(_ich);
		cchInBlock = min(cchOld, ptb->_cch - _ich);
		if(cchInBlock > 0)
		{
			cchOld			-= cchInBlock;
			ptb->_cch		-= cchInBlock;
			((CTxtArray *)_pRuns)->_cchText	-= cchInBlock;
		}
		cchNewInBlock = CchOfCb(ptb->_cbBlock) - ptb->_cch;

		// if there's room for a gap, leave one
		if(cchNewInBlock > cchGapInitial)
			cchNewInBlock -= cchGapInitial;

		if(cchNewInBlock > cchNew)
			cchNewInBlock = cchNew;

		if(cchNewInBlock > 0)
		{
			CopyMemory(ptb->_pch + _ich, pch, CbOfCch(cchNewInBlock));
			cchNew			-= cchNewInBlock;
			_cp				+= cchNewInBlock;
			_ich			+= cchNewInBlock;
			pch				+= cchNewInBlock;
			cchAdded		+= cchNewInBlock;
			ptb->_cch		+= cchNewInBlock;
			ptb->_ibGap		+= CbOfCch(cchNewInBlock);
			((CTxtArray *)_pRuns)->_cchText	+= cchNewInBlock;
		}
	   	if(_iRun >= Count() - 1 || !cchOld )
		   	break;

		// Go to next block
		_iRun++;
   		_ich = 0;
	}

	if(cchNew > 0)
		cchAdded += InsertRange(cchNew, pch);

	else if(cchOld > 0)
		DeleteRange(cchOld);
	
	return cchAdded;
}

/*
 *	CTxtPtr::HandleReplaceRangeUndo (cchOld, cchNew, pch, publdr)
 *
 *	@mfunc
 *		worker function for ReplaceRange.  Figures out what will happen in
 *		the replace range call and creates the appropriate anti-events
 *
 *	@devnote
 *		We first check to see if our replace range data can be merged into
 *		an existing anti-event.  If it can, then we just return.
 *		Otherwise, we copy the deleted characters into an allocated buffer
 *		and then create a ReplaceRange anti-event.
 *
 *		In order to handle ordering problems between formatting and text
 *		anti-events (that is, text needs to exist before formatting can
 *		be applied), we have any formatting anti-events passed to us first.
 */
void CTxtPtr::HandleReplaceRangeUndo(
	LONG			cchOld, //@parm Count of characters to delete
	LONG			cchNew, //@parm Count of new characters to add
	IUndoBuilder *	publdr,	//@parm Undo builder to receive anti-event
	IAntiEvent *	paeCF,	//@parm char formatting AE
	IAntiEvent *	paePF )	//@parm paragraph formatting AE
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::HandleReplaceRangeUndo");

	_TEST_INVARIANT_

	IAntiEvent *pae = publdr->GetTopAntiEvent();
	TCHAR *		pch = NULL;

	if(pae)
	{
		SimpleReplaceRange	sr;
		sr.cpMin = _cp;
		sr.cpMax = _cp + cchNew;
		sr.cchDel = cchOld;
	
		if(pae->MergeData(MD_SIMPLE_REPLACERANGE, &sr) == NOERROR)
		{
			// If the data was merged successfully, then we do
			// not need these anti-events
			if(paeCF)
				DestroyAEList(paeCF);

			if(paePF)
				DestroyAEList(paePF);

			// we've done everything we need to.
			return;
		}
	}

	// Allocate a buffer and grab the soon-to-be deleted
	// text (if necessary)

	if( cchOld > 0 )
	{
		pch = new TCHAR[cchOld];
		if( pch )
			GetText(cchOld, pch);
		else
			cchOld = 0;
	}

	// The new range will exist from our current position plus
	// cchNew (because everything in cchOld gets deleted)

	pae = gAEDispenser.CreateReplaceRangeAE(_ped, _cp, _cp + cchNew,
			cchOld, pch, paeCF, paePF);

	if( !pae )
		delete pch;

	if( pae )
		publdr->AddAntiEvent(pae);
}

/*
 *	CTxtPtr::InsertRange(cch, pch)
 *	
 *	@mfunc
 *		Insert a range of characters at this text pointer			
 *	
 *	@rdesc
 *		Count of characters successfully inserted
 *	
 *	@comm Side Effects: <nl>
 *		moves this text pointer to end of inserted text <nl>
 *		moves the text block array <nl>
 */
LONG CTxtPtr::InsertRange (
	LONG cch, 				//@parm length of text to insert
	TCHAR const *pch)		//@parm text to insert
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::InsertRange");

	_TEST_INVARIANT_

	LONG cchSave = cch;
	LONG cchInBlock;
	LONG cchFirst;
	LONG cchLast = 0;
	LONG ctbNew;
	CTxtBlk *ptb;
	
	// Ensure text array is allocated
	if(!Count())
	{
		LONG	cbSize = -1;

		// If we don't have any blocks, allocate first block to be big enuf
		// for the inserted text *only* if it's smaller than the normal block
		// size. This allows us to be used efficiently as a display engine
		// for small amounts of text.

		if(cch < CchOfCb(cbBlockInitial))
			cbSize = CbOfCch(cch);

		if(!((CTxtArray *)_pRuns)->AddBlock(0, cbSize))
		{
			_ped->GetCallMgr()->SetOutOfMemory();
			goto done;
		}
	}

	ptb = GetRun(0);
	cchInBlock = CchOfCb(ptb->_cbBlock) - ptb->_cch;
	AssertSz(ptb->_cbBlock <= cbBlockMost, "block too big");

	// try and resize without splitting...
	if(cch > cchInBlock &&
		cch <= cchInBlock + CchOfCb(cbBlockMost - ptb->_cbBlock))
	{
		if( !ptb->ResizeBlock(min(cbBlockMost,
				CbOfCch(ptb->_cch + cch + cchGapInitial))) )
		{
			_ped->GetCallMgr()->SetOutOfMemory();
			goto done;
		}
		cchInBlock = CchOfCb(ptb->_cbBlock) - ptb->_cch;
	}
	if(cch <= cchInBlock)
	{
		// all fits into block without any hassle

		ptb->MoveGap(_ich);
		CopyMemory(ptb->_pch + _ich, pch, CbOfCch(cch));
		_cp				+= cch;					// *this points at end of
		_ich			+= cch;					//  insertion
		ptb->_cch		+= cch;
		((CTxtArray *)_pRuns)->_cchText	+= cch;
		ptb->_ibGap		+= CbOfCch(cch);

		return cch;
	}

	// won't all fit in this block

	// figure out best division into blocks
	TxDivideInsertion(cch, _ich, ptb->_cch - _ich,&cchFirst, &cchLast);

	// Subtract cchLast up front so return value isn't negative
	// if SplitBlock() fails
	cch -= cchLast;	// don't include last block in count for middle blocks

	// split block containing insertion point

	// ***** moves _prgtb ***** //
	if(!((CTxtArray *)_pRuns)->SplitBlock(_iRun, _ich, cchFirst, cchLast,
		_ped->IsStreaming()))
	{
		_ped->GetCallMgr()->SetOutOfMemory();
		goto done;
	}
	ptb = GetRun(0);			// recompute ptb after (*_pRuns) moves

	// copy into first block (first half of split)
	if(cchFirst > 0)
	{
		AssertSz(ptb->_ibGap == CbOfCch(_ich), "split first gap in wrong place");
		AssertSz(cchFirst <= CchOfCb(ptb->_cbBlock) - ptb->_cch, "split first not big enough");

		CopyMemory(ptb->_pch + _ich, pch, CbOfCch(cchFirst));
		cch				-= cchFirst;
		pch				+= cchFirst;
		_ich			+= cchFirst;
		ptb->_cch		+= cchFirst;
		((CTxtArray *)_pRuns)->_cchText	+= cchFirst;
		ptb->_ibGap		+= CbOfCch(cchFirst);
	}

	// copy into middle blocks
	// FUTURE: (jonmat) I increased the size for how large a split block
	// could be and this seems to increase the performance, we should test
	// the block size difference on a retail build, however. 5/15/1995
	ctbNew = cch / cchBlkInsertmGapI /* cchBlkInitmGapI */;
	if(ctbNew <= 0 && cch > 0)
		ctbNew = 1;
	for(; ctbNew > 0; ctbNew--)
	{
		cchInBlock = cch / ctbNew;
		AssertSz(cchInBlock > 0, "nothing to put into block");

		// ***** moves _prgtb ***** //
		if(!((CTxtArray *)_pRuns)->AddBlock(++_iRun,
			CbOfCch(cchInBlock + cchGapInitial)))
		{
			_ped->GetCallMgr()->SetOutOfMemory();
			BindToCp(_cp);	//force a rebind;
			goto done;
		}
		// NOTE: next line intentionally advances ptb to next CTxtBlk

		ptb = GetRun(0);
		AssertSz(ptb->_ibGap == 0, "New block not added correctly");

		CopyMemory(ptb->_pch, pch, CbOfCch(cchInBlock));
		cch				-= cchInBlock;
		pch				+= cchInBlock;
		_ich			= cchInBlock;
		ptb->_cch		= cchInBlock;
		((CTxtArray *)_pRuns)->_cchText	+= cchInBlock;
		ptb->_ibGap		= CbOfCch(cchInBlock);
	}
	AssertSz(cch == 0, "Didn't use up all text");

	// copy into last block (second half of split)
	if(cchLast > 0)
	{
		AssertSz(_iRun < Count()-1, "no last block");
		ptb = Elem(++_iRun);
		AssertSz(ptb->_ibGap == 0,	"split last gap in wrong place");
		AssertSz(cchLast <= CchOfCb(ptb->_cbBlock) - ptb->_cch,
									"split last not big enuf");

		CopyMemory(ptb->_pch, pch, CbOfCch(cchLast));
		// don't subtract cchLast from cch; it's already been done
		_ich			= cchLast;
		ptb->_cch		+= cchLast;
		((CTxtArray *)_pRuns)->_cchText	+= cchLast;
		ptb->_ibGap		= CbOfCch(cchLast);
		cchLast = 0;						// Inserted all requested chars
	}

done:
	AssertSz(cch + cchLast >= 0, "we should have inserted some characters");
	AssertSz(cch + cchLast <= cchSave, "don't insert more than was asked for");

	cch = cchSave - cch - cchLast;			// # chars successfully inserted
	_cp += cch;

	AssertSz (GetTextLength() ==
				((CTxtArray *)_pRuns)->CalcTextLength(),
				"CTxtPtr::InsertRange(): _pRuns->_cchText messed up !");
	return cch;
}

/*
 *	TxDivideInsertion(cch, ichBlock, cchAfter, pcchFirst, pcchLast)
 *	
 *	@func
 *		Find best way to distribute an insertion	
 *	
 *	@rdesc
 *		nothing
 */
static void TxDivideInsertion(
	LONG cch, 				//@parm length of text to insert
	LONG ichBlock, 			//@parm offset within block to insert text
	LONG cchAfter,			//@parm length of text after insertion in block
	LONG *pcchFirst, 		//@parm exit: length of text to put in first block
	LONG *pcchLast)			//@parm exit: length of text to put in last block
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "TxDivideInsertion");

	LONG cchFirst = max(0, cchBlkCombmGapI - ichBlock);
	LONG cchLast  = max(0, cchBlkCombmGapI - cchAfter);
	LONG cchPartial;
	LONG cchT;

	// Fill first and last blocks to min block size if possible

	cchFirst = min(cch, cchFirst);
	cch		-= cchFirst;
	cchLast = min(cch, cchLast);
	cch		-= cchLast;

	// How much is left over when we divide up the rest?
	cchPartial = cch % cchBlkInsertmGapI;
	if(cchPartial > 0)
	{
		// Fit as much as the leftover as possible in the first and last
		// w/o growing the first and last over cbBlockInitial
		cchT		= max(0, cchBlkInsertmGapI - ichBlock - cchFirst);
		cchT		= min(cchT, cchPartial);
		cchFirst	+= cchT;
		cch			-= cchT;
		cchPartial	-= cchT;
		if(cchPartial > 0)
		{
			cchT	= max(0, cchBlkInsertmGapI - cchAfter - cchLast);
			cchT	= min(cchT, cchPartial);
			cchLast	+= cchT;
		}
	}
	*pcchFirst = cchFirst;
	*pcchLast = cchLast;
}

/*
 *	CTxtPtr::DeleteRange(cch)
 *	
 *	@mfunc
 *		Delete cch characters starting at this text pointer		
 *	
 *	@rdesc
 *		nothing
 *	
 *	@comm Side Effects:	<nl>
 *		moves text block array
 */
void CTxtPtr::DeleteRange(
	LONG cch)		//@parm length of text to delete
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::DeleteRange");

	_TEST_INVARIANT_

	LONG		cchInBlock;
	LONG		ctbDel = 0;					// Default no blocks to delete
	LONG		itb;
	CTxtBlk *	ptb = GetRun(0);

	AssertSz(ptb,
		"CTxtPtr::DeleteRange: want to delete, but no text blocks");

	if (cch > GetTextLength() - _cp)	// Don't delete beyond end of story
		cch = GetTextLength() - _cp;

	((CTxtArray *)_pRuns)->_cchText -= cch;

	// remove from first block
	ptb->MoveGap(_ich);
	cchInBlock = min(cch, ptb->_cch - _ich);
	cch -= cchInBlock;
	ptb->_cch -= cchInBlock;

#ifdef DEBUG
	((CTxtArray *)_pRuns)->Invariant();
#endif // DEBUG


	for(itb = ptb->_cch ? _iRun + 1 : _iRun;
			cch && cch >= Elem(itb)->_cch; ctbDel++, itb++)
	{
		// More to go: scan for complete blocks to remove
		cch -= Elem(itb)->_cch;
	}

	if(ctbDel)
	{
		// ***** moves (*_pRuns) ***** //
		itb -= ctbDel;
		((CTxtArray *)_pRuns)->RemoveBlocks(itb, ctbDel);
	}

	// Remove from last block
	if(cch > 0)
	{
		ptb = Elem(itb);
		AssertSz(cch < ptb->_cch, "last block too small");
		ptb->MoveGap(0);
		ptb->_cch -= cch;
#ifdef DEBUG
		((CTxtArray *)_pRuns)->Invariant();
#endif // DEBUG

	}
	((CTxtArray *)_pRuns)->CombineBlocks(_iRun);

	if(_iRun >= Count() || !Elem(_iRun)->_cch)
		BindToCp(_cp);					// Empty block: force tp rebind

	AssertSz (GetTextLength() ==
				((CTxtArray *)_pRuns)->CalcTextLength(),
				"CTxtPtr::DeleteRange(): _pRuns->_cchText messed up !");
}

/*
 *	CTxtPtr::FindText (cpMost, dwFlags, pch, cch)
 *
 *	@mfunc
 *		Find the text string <p pch> of length <p cch> starting at this
 *		text pointer. If found, move this text pointer to the end of the
 *		matched string and return the cp of the first character of the matched
 *		string.  If not found, return -1 and don't change this text ptr.
 *	
 *	@rdesc
 *		character position of first match
 *		<lt> 0 if no match
 */
LONG CTxtPtr::FindText (
	LONG		 cpLimit, 	//@parm Limit of search or <lt> 0 for end of text
	DWORD		 dwFlags, 	//@parm FR_MATCHCASE	case must match <nl>
							//		FR_WHOLEWORD	match must be a whole word
	const TCHAR *pch,		//@parm Text to find
	LONG		 cch)		//@parm Length of text to find
{
	LONG cpFirst, cpLast;
	CTxtFinder tf;

	if(tf.FindText(*this, cpLimit, dwFlags, pch, cch, cpFirst, cpLast))
	{
		// Set text ptr to char just after last char in found string
		SetCp(cpLast + 1);

		// Return cp of first char in found string
		return cpFirst;
	}
	return -1;
}

/*
 *	CTxtPtr::FindOrSkipWhiteSpaces (cchMax, pdwResult, fAdvance, fSkip)
 *	
 *	@mfunc
 *		Find a whitespace or a non-whitespace character (skip all whitespaces).
 *
 *	@rdesc
 *		Signed number of character this ptr was moved by the operation.
 *		In case of moving backward, the return position was already adjusted forward
 *		so the caller doesnt need to.
 */
LONG CTxtPtr::FindOrSkipWhiteSpaces (
	LONG 		cchMax, 			//@parm Max signed count of char to search
	DWORD		dwFlags,			//@parm Input flags
	DWORD* 		pdwResult)			//@parm Flag set if found
{
	const TCHAR*	pch;
	CTxtPtr			tp(*this);
	LONG			iDir = cchMax < 0 ? -1 : 1;
	LONG			cpSave = _cp;
	LONG			cchChunk, cch = 0;
	DWORD			dwResult = 0;
	BOOL 			(*pfnIsWhite)(unsigned) = IsWhiteSpace;

	if (dwFlags & FWS_BOUNDTOPARA)
		pfnIsWhite = IsEOP;

	if (cchMax < 0)
		cchMax = -cchMax;

	while (cchMax > 0 && !dwResult)
	{
		pch = iDir > 0 ? tp.GetPch(cch) : tp.GetPchReverse(cch);

		if (!pch)
			break;						// No text available

		if (iDir < 0)
			pch--;						// Going backward, point at previous char

		cch = min(cch, cchMax);
	
		for(cchChunk = cch; cch > 0; cch--, pch += iDir)
		{
			if ((dwFlags & FWS_SKIP) ^ pfnIsWhite(*pch))
			{
				dwResult++;
				break;
			}
		}
		cchChunk -= cch;
		cchMax -= cchChunk;

		tp.AdvanceCp(iDir * cchChunk);	// advance to next chunk
	}
	
	if (pdwResult)
		*pdwResult = dwResult;

	cch = tp.GetCp() - cpSave;

	if (dwFlags & FWS_ADVANCECP)
		AdvanceCp(cch);					// Auto advance if requested

	return cch;
}

/*
 *	CTxtPtr::FindWhiteSpaceBound (cchMin, cpStart, cpEnd)
 *	
 *	@mfunc
 *		Figure the smallest boundary that covers cchMin and limited by
 *		whitespaces (included CR/LF). This is how it works.
 *
 *      Text:           xxx  xxx  xxx  xxx  xxx
 *      cp + cchMin:             xxxxx
 *      Boundary:            xxxxxxxxxxxxx
 *		
 */
LONG CTxtPtr::FindWhiteSpaceBound (
	LONG 		cchMin, 			// @parm Minimum char count to be covered
	LONG& 		cpStart, 			// @parm Boundary start
	LONG& 		cpEnd,				// @parm Boundary end
	DWORD		dwFlags)			// @parm Input flags
{
	CTxtPtr			tp(*this);
	LONG			cch	= tp.GetTextLength();
	LONG			cp	= _cp;

	Assert (cp + cchMin <= cch);

	cpStart = cpEnd	= cp;
	cpEnd	+= max(2, cchMin);			// make sure it covers minimum requirement.
	cpEnd	= min(cpEnd, cch);			// but not too many


	dwFlags &= FWS_BOUNDTOPARA;


	// Figure nearest upper bound
	//
	tp.SetCp(cpEnd);
	cpEnd += tp.FindOrSkipWhiteSpaces(cch - cpEnd, dwFlags | FWS_ADVANCECP);			// find a whitespaces
	cpEnd += tp.FindOrSkipWhiteSpaces(cch - cpEnd, dwFlags | FWS_ADVANCECP | FWS_SKIP);	// skip whitespaces
	if (!(dwFlags & FWS_BOUNDTOPARA))
		cpEnd += tp.FindOrSkipWhiteSpaces(cch - cpEnd, dwFlags | FWS_ADVANCECP);		// find a whitespace


	// Figure nearest lower bound
	//
	tp.SetCp(cpStart);
	cpStart += tp.FindOrSkipWhiteSpaces(-cpStart, dwFlags | FWS_ADVANCECP);				// find a whitespace
	cpStart += tp.FindOrSkipWhiteSpaces(-cpStart, dwFlags | FWS_ADVANCECP | FWS_SKIP);	// skip whitespaces
	if (!(dwFlags & FWS_BOUNDTOPARA))
		cpStart += tp.FindOrSkipWhiteSpaces(-cpStart, dwFlags | FWS_ADVANCECP);			// find a whitespace

	Assert (cpStart <= cpEnd && cpEnd - cpStart >= cchMin);
	
	return cpEnd - cpStart;
}


/*
 *	CTxtPtr::FindEOP(cchMax, pResults)
 *	
 *	@mfunc
 *		Find EOP mark in a range within cchMax chars from this text pointer
 *		and position *this after it.  If no EOP is found and cchMax is not
 *		enough to reach the start or end of the story, leave this text ptr
 *		alone and return 0.  If no EOP is found and cchMax is sufficient to
 *		reach the start or end of the story, position this text ptr at the
 *		beginning/end of document (BOD/EOD) for cchMax <lt>/<gt> 0,
 *		respectively, that is, BOD and EOD are treated as a BOP and an EOP,
 *		respectively.	
 *
 *	@rdesc
 *		Return cch this text ptr is moved. Return in *pResults whether a CELL
 *		or EOP was found.  The low byte gives the cch of the EOP if moving
 *		forward (else it's just 1).
 *
 *	@devnote
 *		This function assumes that this text ptr isn't in middle of a CRLF
 *		or CRCRLF (found only in RichEdit 1.0 compatibility mode).  Changing
 *		the for loop could speed up ITextRange MoveUntil/While substantially.
 */
LONG CTxtPtr::FindEOP (
	LONG  cchMax,		//@parm Max signed count of chars to search
	LONG *pResults)		//@parm Flags saying if EOP and CELL are found
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::FindEOP");

	LONG		cch = 0, cchStart;			// cch's for scans
	unsigned	ch;							// Current char
	LONG		cpSave	= _cp;				// Save _cp for returning delta
	LONG		iDir	= 1;				// Default forward motion
	const TCHAR*pch;						// Used to walk text chunks
	LONG		Results = 0;				// Nothing found yet
	CTxtPtr		tp(*this);					// tp to search text with

	if(cchMax < 0)							// Backward search
	{
		iDir = -1;							// Backward motion
		cchMax = -cchMax;					// Make max count positive
		cch = tp.AdjustCpCRLF();			// If in middle of CRLF or
		if(!cch && IsAfterEOP())			//  CRCRLF, or follow any EOP,
			cch = tp.BackupCpCRLF();		//  backup before EOP
		cchMax += cch;
	}

	while(cchMax > 0)						// Scan until get out of search
	{										//  range or match an EOP
		pch = iDir > 0						// Point pch at contiguous text
			? tp.GetPch(cch)				//  chunk going forward or
			: tp.GetPchReverse(cch);		//  going backward

		if(!pch)							// No more text to search
			break;

		if(iDir < 0)						// Going backward, point at
			pch--;							//  previous char

		cch = min(cch, cchMax);				// Limit scan to cchMax chars
		for(cchStart = cch; cch; cch--)		// Scan chunk for EOP
		{
			ch = *pch;
			if(ch == CELL)
				Results |= FEOP_CELL;		// Note that CELL was found

			if(IsEOP(ch))					// Note that EOP was found
			{								// Going forward, cch may = 0
				Results |= FEOP_EOP;		
				break;
			}
			pch += iDir;
		}
		cchStart -= cch;					// Get cch of chars passed by
		cchMax -= cchStart;					// Update cchMax

		AssertSz(iDir > 0 && GetCp() + cchStart <= GetTextLength() ||
				 iDir < 0 && GetCp() - cchStart >= 0,
			"CTxtPtr::FindEOP: illegal advance");

		tp.AdvanceCp(iDir*cchStart);		// Update tp
		if(Results & FEOP_EOP)				// Found an EOP
			break;
	}										// Continue with next chunk

	LONG cp = tp.GetCp();

	if ((Results & FEOP_EOP) || !cp ||		// Found EOP or cp is at story
		cp == GetTextLength())				//  beginning or end
	{										
		SetCp(cp);							// Set _cp = tp._cp
		if(iDir > 0)						// Going forward, put ptr just
			Results = (Results & ~255) | AdvanceCpCRLF();//  after EOP (going
	}										//  back, is already after EOP)
	if(pResults)							// Report whether EOP and CELL
		*pResults = Results;				//  were found

	return _cp - cpSave;					// Return cch this tp moved
}

/*
 *	CTxtPtr::FindBOSentence(cch)
 *	
 *	@mfunc
 *		Find beginning of sentence in a range within cch chars from this text
 *		pointer and	position *this at it.  If no sentence beginning is found,
 *		position *this at beginning of document (BOD) for cch <lt> 0 and
 *		leave *this unchanged for cch >= 0.
 *
 *	@rdesc
 *		Count of chars moved *this moves
 *
 *	@comm
 *		This routine defines a sentence as a character string that ends with
 *		period followed by at least one whitespace character or the EOD.  This
 *		should be replacable so that other kinds of sentence endings can be
 *		used.  This routine also matches initials like "M. " as sentences.
 *		We could eliminate those by requiring that sentences don't end with
 *		a word consisting of a single capital character.  Similarly, common
 *		abbreviations like "Mr." could be bypassed.  To allow a sentence to
 *		end with these "words", two blanks following a period could be used
 *		to mean an unconditional end of sentence.
 */
LONG CTxtPtr::FindBOSentence (
	LONG cch)			//@parm max signed count of chars to search
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::FindBOSentence");

	_TEST_INVARIANT_

	LONG	cchWhite = 0;						// No whitespace chars yet
	LONG	cp;
	LONG	cpSave	 = _cp;						// Save value for return
	BOOL	fST;								// TRUE if sent terminator
	LONG	iDir	 = cch > 0 ? 1 : -1;		// AdvanceCp() increment
	CTxtPtr	tp(*this);							// tp to search with

	if(iDir > 0)								// If going forward in white
		while(IsWhiteSpace(tp.GetChar()) &&		//  space, backup to 1st non
				tp.AdvanceCp(-1)) ;				//  whitespace char (in case
												//  inside sentence ending)
	while(iDir > 0 || tp.AdvanceCp(-1))			// Need to back up if finding
	{											//  backward
		for(fST = FALSE; cch; cch -= iDir)		// Find sentence terminator
		{
			fST = IsSentenceTerminator(tp.GetChar());
			if(fST || !tp.AdvanceCp(iDir))
				break;
		}
		if(!fST)								// If FALSE, we	ran out of
			break;								//  chars

		while(IsWhiteSpace(tp.NextChar()) && cch)
		{										// Bypass a span of blank
			cchWhite++;							//  chars
			cch--;
		}

		if(cchWhite && (cch >= 0 || tp._cp < cpSave))// Matched new sentence
			break;								//  break

		if(cch < 0)								// Searching backward
		{
			tp.AdvanceCp(-cchWhite - 1);		// Back up to terminator
			cch += cchWhite + 1;				// Fewer chars to search
		}
		cchWhite = 0;							// No whitespace yet for next
	}											//  iteration

	cp = tp._cp;
	if(cchWhite || !cp || cp == GetTextLength())// If sentence found or got
		SetCp(cp);								//  start/end of story, set
												//  _cp to tp's
	return _cp - cpSave;						// Tell caller cch moved
}

/*
 *	CTxtPtr::IsAtBOSentence()
 *	
 *	@mfunc
 *		Return TRUE iff *this is at the beginning of a sentence (BOS) as
 *		defined in the description of the FindBOSentence(cch) routine
 *
 *	@rdesc
 *		TRUE iff this text ptr is at the beginning of a sentence
 */
BOOL CTxtPtr::IsAtBOSentence()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::IsAtBOSentence");

	if(!_cp)									// Beginning of story is an
		return TRUE;							//  unconditional beginning
												//  of sentence
	unsigned ch = GetChar();

	if (IsWhiteSpace(ch) ||						// Proper sentences don't
		IsSentenceTerminator(ch))				//  start with whitespace or
	{											//  sentence terminators
		return FALSE;
	}
												
	LONG	cchWhite;
	CTxtPtr tp(*this);							// tp to walk preceding chars

	for(cchWhite = 0;							// Backspace over possible
		IsWhiteSpace(ch = tp.PrevChar());		//  span of whitespace chars
		cchWhite++) ;

	return cchWhite && IsSentenceTerminator(ch);
}

/*
 *	CTxtPtr::IsAtBOWord()
 *	
 *	@mfunc
 *		Return TRUE iff *this is at the beginning of a word, that is,
 *		_cp = 0 or the char at _cp is an EOP, or
 *		FindWordBreak(WB_MOVEWORDRIGHT) would break at _cp.
 *
 *	@rdesc
 *		TRUE iff this text ptr is at the beginning of a Word
 */
BOOL CTxtPtr::IsAtBOWord()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::IsAtBOWord");

	if(!_cp || IsAtEOP())					// Story beginning is also
		return TRUE;						//  a word beginning

	CTxtPtr tp(*this);
	tp.AdvanceCp(-1);
	tp.FindWordBreak(WB_MOVEWORDRIGHT);
	return _cp == tp._cp;
}

/*
 *	CTxtPtr::FindExact(cchMax, pch)
 *	
 *	@mfunc
 *		Find exact text match for null-terminated string pch in a range
 *		starting at this text pointer. Position this just after matched
 *		string and return cp at start of string, i.e., same as FindText().
 *	
 *	@rdesc
 *		Return cp of first char in matched string and *this pointing at cp
 *		just following matched string.  Return -1 if no match
 *
 *	@comm
 *		Much faster than FindText, but still a simple search, i.e., could
 *		be improved.
 *
 *		FindText can delegate to this search for search strings in which
 *		each char can only match itself.
 */
LONG CTxtPtr::FindExact (
	LONG	cchMax,		//@parm signed max # of chars to search
	TCHAR *	pch)		//@parm ptr to null-terminated string to find exactly
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::FindExact");

	_TEST_INVARIANT_

	LONG	cch, cchStart;
	LONG	cchValid;
	LONG	cchText = GetTextLength();
	LONG	cpMatch;
	LONG	iDir = 1;						// Default for forward search
	const TCHAR	*pc;
	CTxtPtr	tp(*this);						// tp to search text with

	if(!*pch)
		return -1;							// Signal null string not found

	if(cchMax < 0)							// Backward search
	{
		iDir = -1;
		cchMax = -cchMax;					// Make count positive
	}

	while(cchMax > 0)
	{
		if(iDir > 0)
		{
			if(tp.GetCp() >= cchText)	// Can't go further
				break;
			pc  = tp.GetPch(cchValid);		// Characters we can search w/o
			cch = cchValid; 				//  encountering block end/gap,
		}									//  i.e., stay within text chunk
		else
		{
			if(!tp.GetCp())					// Can't back up any more
				break;
			tp.AdvanceCp(-1);
			pc  = tp.GetPchReverse(cchValid);
			cch = cchValid + 1;
		}

		cch = min(cch, cchMax);
		if(!cch || !pc)
			break;							// No more text to search

		for(cchStart = cch;					// Find first char
			cch && *pch != *pc; cch--)		// Most execution time is spent
		{									//  in this loop going forward or
			pc += iDir;						//  backward. x86 rep scasb/scasw
		}									//  are faster

		cchStart -= cch;
		cchMax	 -= cchStart;				// Update cchMax
		tp.AdvanceCp( iDir*(cchStart));		// Update tp

		if(cch && *pch == *pc)				// Matched first char
		{									// See if matches up to null
			cpMatch = tp.GetCp();			// Save cp of matched first char
			cch = cchMax;
			for(pc = pch;					// Try to match rest of string
				cch && *++pc==tp.NextChar();// Note: this match goes forward
				cch--) ;					//  for both values of iDir
			if(!cch)
				break;						// Not enuf chars for string

			if(!*pc)						// Matched null-terminated string
			{								//  *pch. Set this tp just after
				SetCp(tp.GetCp());			//  matched string and return cp
				return cpMatch;				//  at start
			}
			tp.SetCp(cpMatch + iDir);		// Move to char just following or
		}									//  preceding matched first char
	}										// Up-to-date tp: continue search

	return -1;								// Signal string not found
}

/*
 *	CTxtPtr::NextCharCount(&cch)
 *
 *	@mfunc
 *		Helper function for getting next char and decrementing abs(*pcch)
 *
 *	@rdesc
 *		Next char
 */
TCHAR CTxtPtr::NextCharCount (
	LONG& cch)					//@parm count to use and decrement
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtPtr::NextCharCount");

	LONG	iDelta = (cch > 0) ? 1 : -1;

	if(!cch || !AdvanceCp(iDelta))
		return 0;

	cch -= iDelta;							// Count down or up
	return GetChar();						// Return char at _cp
}

/*
 *	CTxtPtr::Zombie ()
 *
 *	@mfunc
 *		Turn this object into a zombie by NULLing out its _ped member
 */
void CTxtPtr::Zombie ()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::Zombie");

	_ped = NULL;
	_cp = 0;
	SetToNull();
}

/*
 *	CTxtIStream::CTxtIStream(tp, iDir)
 *
 *	@mfunc
 *		Creates from the textptr, <p tp>, a character input stream with which
 *		to retrieve characters starting from the cp of the <p tp> and proceeding
 *		in the direction indicated by <p iDir>.
 */
CTxtIStream::CTxtIStream(
	const CTxtPtr &tp,
	int iDir
) : CTxtPtr(tp)
{
	_pfnGetChar = (iDir == DIR_FWD ?
				   &CTxtIStream::GetNextChar : &CTxtIStream::GetPrevChar);
	_cch = 0;
	_pch = NULL;
}

/*
 * 	CTxtIStream::GetNextChar()
 *
 *	@mfunc
 *		Returns the next character in the text stream.
 *		Ensures that at least one valid character exists in _pch and then returns
 *		the next character in _pch.
 *
 * 	@rdesc
 *		TCHAR	the next character in the character input stream
 *				0, if end of text stream
 */
TCHAR CTxtIStream::GetNextChar()
{
	if(!_cch)
		FillPchFwd();

	if(_cch)
	{
		_cch--;
		return *_pch++;
	}
	return 0;
}

/*
 * 	CTxtIStream::GetPrevChar()
 *
 *	@mfunc
 *		Returns the next character in the text stream, where the direction of the
 *		stream is reverse.
 *		Ensures that at least one valid character exists in _pch and then returns
 *		the next character in _pch.  Here, _pch points to the end of a string
 *		containing _cch valid characters.
 *
 * 	@rdesc
 *		TCHAR	the next character in the character input stream (travelling backwards
 *				along the string pointed to by _pch)
 *				0, if end of text stream
 */
TCHAR CTxtIStream::GetPrevChar()
{
	if(!_cch)
		FillPchRev();

	if(_cch)
	{
		_cch--;
		return *(--_pch);
	}
	return 0;
}


/*
 *	CTxtIStream::FillPchFwd()
 *
 *	@mfunc
 *		Gets the next run of characters and advances the cp of this CTxtPtr (base
 *		class) just past the run.
 *		This ensures enough chars in _pch to facilitate the next _cch calls to
 *		GetNextChar().
 */
void CTxtIStream::FillPchFwd()
{
	_pch = GetPch(_cch);
	AdvanceCp(_cch);
}

/*
 *	CTxtIStream::FillPchRev()
 *
 *	@mfunc
 *		Gets the run of characters preceding the one previously pointed to by _pch
 * 		and advances the cp of this CTxtPtr (base class) to the beginning of the run.
 *		This ensures enough chars in _pch to facilitate the next _cch calls to
 *		GetPrevChar().
 */
void CTxtIStream::FillPchRev()
{
	_pch = GetPchReverse(_cch);

	AdvanceCp(-_cch);
}

/*
 *	CTxtFinder::FindText (cpMost, dwFlags, pch, cchToFind)
 *
 *	@mfunc
 *		Find the text string <p pch> of length <p cchToFind> starting at this
 *		text pointer. If found, <p cpFirst> and <p cpLast> are set to
 *		the cp's of the first and last characters in the matched string (wrt tp).
 *		If not found, return FALSE.
 *	
 *	@rdesc
 *		TRUE	string matched.  First char at tp.GetCp() + cchOffFirst.
 *					Last char at tp.GetCp() + cchOffLast.
 *		FALSE	string not found.
 */
BOOL CTxtPtr::CTxtFinder::FindText (
	const CTxtPtr &tp,
	LONG		cpLimit, 	//@parm Limit of search or <lt> 0 for end of text
	DWORD		dwFlags, 	//@parm FR_MATCHCASE	case must match <nl>
							//		FR_WHOLEWORD	match must be a whole word
	const TCHAR *pchToFind, //@parm Text to search for
	LONG cchToFind,			//@parm Count of chars to search for
	LONG &cpFirst,			//@parm If string found, returns cp (wrt tp) of first char
	LONG &cpLast)			//@parm If string found, returns cp (wrt tp) of last char
{
	if(!cchToFind)
		return FALSE;

	_fSearchForward = dwFlags & FR_DOWN;

	// Calculate max number of chars we must search for pchToFind
	if(_fSearchForward)
	{
		const LONG cchText = tp.GetTextLength();
			
		if((DWORD)cpLimit > (DWORD)cchText)		// NB: catches cpLimit < 0 too
			cpLimit = cchText;

		_cchToSearch = cpLimit - tp.GetCp();
	}
	else
	{
		if((DWORD)cpLimit > (DWORD)tp.GetCp())	// NB: catches cpLimit < 0 too
			cpLimit = 0;

		_cchToSearch = tp.GetCp() - cpLimit;
	}

	if(cchToFind > _cchToSearch)
	{
		// Not enough chars in requested direction within which
		// to find string
		return FALSE;
	}

	const BOOL fWholeWord = dwFlags & FR_WHOLEWORD;

	_fIgnoreCase	 = !(dwFlags & FR_MATCHCASE);
	_fMatchAlefhamza = dwFlags & FR_MATCHALEFHAMZA;
	_fMatchKashida	 = dwFlags & FR_MATCHKASHIDA;
	_fMatchDiac		 = dwFlags & FR_MATCHDIAC;

	typedef LONG (CTxtPtr::CTxtFinder::*PFNMATCHSTRING)(TCHAR const *pchToFind,
											LONG cchToFind,
											CTxtIStream &tistr);

	// Setup function pointer appropriate for this type of search
	CTxtEdit*	   ped = tp._ped;
	PFNMATCHSTRING pfnMatchString;

#define MATCHARABICSPECIALS	(FR_MATCHALEFHAMZA | FR_MATCHKASHIDA | FR_MATCHDIAC)
	// If match all Arabic special characters exactly, then use simpler
	// MatchString routine.  If ignore any and BiDi text exists, use
	// MatchStringBiDi.
	pfnMatchString = (ped->IsBiDi() &&
						(dwFlags & MATCHARABICSPECIALS) != MATCHARABICSPECIALS)
				   ? &CTxtFinder::MatchStringBiDi
				   : &CTxtFinder::MatchString;

	_iDirection = _fSearchForward ? 1 : -1;

	BOOL fFound = FALSE;
	TCHAR chFirst = _fSearchForward ? *pchToFind : pchToFind[cchToFind - 1];
	const TCHAR *pchRemaining = _fSearchForward ?
		&pchToFind[1] : &pchToFind[cchToFind - 2];
	LONG cchRead;
	LONG cchReadToFirst = 0;
	LONG cchReadToLast;
	CTxtIStream tistr(tp,
					  _fSearchForward ? CTxtIStream::DIR_FWD : CTxtIStream::DIR_REV);

	while((cchRead = FindChar(chFirst, tistr)) != -1)
	{
		cchReadToFirst += cchRead;

		if(cchToFind == 1)					// Only one char in string - we've matched it!
		{			
			if (_iDirection > 0)			// Searching forward
			{
				Assert(tp.GetCp() + cchReadToFirst - 1 >= 0);
				cpLast = cpFirst = tp.GetCp() + cchReadToFirst - 1;
			}
			else							// Searching backward
			{
				Assert(tp.GetCp() - cchReadToFirst >= 0);
				cpLast = cpFirst = tp.GetCp() - cchReadToFirst;
			}
			fFound = TRUE;
		}
		else
		{
			// Check if this first char begins a match of string
			CTxtIStream tistrT(tistr);
			cchRead = (this->*pfnMatchString)(pchRemaining, cchToFind - 1, tistrT);
			if(cchRead != -1)
			{
				cchReadToLast = cchReadToFirst + cchRead;
			
				if (_iDirection > 0)			// Searching forward
				{					
					Assert(tp.GetCp() + cchReadToFirst - 1 >= 0);
					Assert(tp.GetCp() + cchReadToLast - 1 >= 0);

					cpFirst = tp.GetCp() + cchReadToFirst - 1;
					cpLast = tp.GetCp() + cchReadToLast - 1;
				}
				else							// Searching backward
				{					
					Assert(tp.GetCp() - cchReadToFirst >= 0);
					Assert(tp.GetCp() - cchReadToLast >= 0);

					cpFirst = tp.GetCp() - cchReadToFirst;
					cpLast = tp.GetCp() - cchReadToLast;
				}

				fFound = TRUE;
			}
		}
		
		if(fFound)
		{
			Assert(cpLast < tp.GetTextLength());
			
			if(!fWholeWord)
				break;
			
			// Check if matched string is whole word
			
			LONG cchT;
			LONG cpBefore = (_fSearchForward ? cpFirst : cpLast) - 1;
			LONG cpAfter  = (_fSearchForward ? cpLast : cpFirst) + 1;

			if((cpBefore < 0 ||
				(ped->TxWordBreakProc(const_cast<LPTSTR>(CTxtPtr(tp._ped, cpBefore).GetPch(cchT)),
					   0,
					   sizeof(TCHAR),
					   WB_CLASSIFY, cpBefore) & WBF_CLASS) ||
				ped->_pbrk && ped->_pbrk->CanBreakCp(BRK_WORD, cpBefore + 1))

				&&

			   (cpAfter >= tp.GetTextLength() ||
				(ped->TxWordBreakProc(const_cast<LPTSTR>(CTxtPtr(tp._ped, cpAfter).GetPch(cchT)),
					   0,
					   sizeof(TCHAR),
					   WB_CLASSIFY, cpAfter) & WBF_CLASS) ||
				ped->_pbrk && ped->_pbrk->CanBreakCp(BRK_WORD, cpAfter)))
			{
				break;
			}
			else
				fFound = FALSE;
		}
	}

	if(fFound && !_fSearchForward)
	{
		// For search backwards, first and last are juxtaposed
		LONG cpTemp = cpFirst;

		cpFirst = cpLast;
		cpLast = cpTemp;
	}
	return fFound;
}

/*
 *	CTxtPtr::CTxtFinder::CharCompMatchCase(ch1, ch2)
 *
 *	@func	Character comparison function sensitive to case according to parms
 *			of current search.
 *
 *	@rdesc	TRUE iff characters are equal
 */
inline BOOL CTxtPtr::CTxtFinder::CharComp(
	TCHAR ch1,
	TCHAR ch2) const
{
    // We compare the characters ourselves if ignore case AND the character isn't a surrogate
    //
	return (_fIgnoreCase && !IN_RANGE(0xD800, ch1, 0xDFFF)) ? CharCompIgnoreCase(ch1, ch2) : (ch1 == ch2);
}

/*
 *	CTxtPtr::CTxtFinder::CharCompIgnoreCase(ch1, ch2)
 *
 *	@func	Character comparison function
 *
 *	@rdesc	TRUE iff characters are equal, ignoring case
 */
inline BOOL CTxtPtr::CTxtFinder::CharCompIgnoreCase(
	TCHAR ch1,
	TCHAR ch2) const
{
	return CompareString(LOCALE_USER_DEFAULT,
						 NORM_IGNORECASE | NORM_IGNOREWIDTH,
						 &ch1, 1, &ch2, 1) == 2;
}

/*
 *	CTxtPtr::CTxtFinder::FindChar(ch, tistr)
 *
 *	@mfunc
 *		Steps through the characters returned from <p tistr> until a character is
 *		found which matches ch or until _cchToSearch characters have been examined.
 *		If found, the return value indicates the number of chars read from <p tistr>.
 *		If not found, -1 is returned.
 *
 *	@rdesc
 *		-1,	if char not found
 * 		n, 	if char found.  n indicates number of chars read from <p tistr>
 *				to find the char
 */
LONG CTxtPtr::CTxtFinder::FindChar(
	TCHAR ch,
	CTxtIStream &tistr)
{
	LONG cchSave = _cchToSearch;

	while(_cchToSearch)
	{
		_cchToSearch--;

		TCHAR chComp = tistr.GetChar();

		if(CharComp(ch, chComp) ||
		   (!_fMatchAlefhamza && IsAlef(ch) && IsAlef(chComp)))
		{
			return cchSave - _cchToSearch;
		}
	}
	return -1;
}

/*
 *	CTxtPtr::CTxtFinder::MatchString(pchToFind, cchToFind, tistr)
 *
 *	@mfunc
 *		This method compares the characters returned from <p tistr> against those
 *		found in pchToFind.  If the string is found, the return value indicates
 *		how many characters were read from <p tistr> to match the string.
 *		If the string is not found, -1 is returned.
 *	
 *	@rdesc
 *		-1,	if string not found
 * 		n, 	if string found.  n indicates number of chars read from <p tistr>
 *				to find string
 */
LONG CTxtPtr::CTxtFinder::MatchString(
	const TCHAR *pchToFind,
	LONG cchToFind,
	CTxtIStream &tistr)
{
	if((DWORD)_cchToSearch < (DWORD)cchToFind)
		return -1;

	LONG cchT = cchToFind;

	while(cchT--)
	{
		if(!CharComp(*pchToFind, tistr.GetChar()))
			return -1;

		pchToFind += _iDirection;
	}
	return cchToFind;
}

/*
 *	CTxtPtr::CTxtFinder::MatchStringBiDi(pchToFind, cchToFind, tistr)
 *
 *	@mfunc
 *		This method compares the characters returned from <p tistr> against those
 *		found in pchToFind.  If the string is found, the return value indicates
 *		how many characters were read from <p tistr> to match the string.
 *		If the string is not found, -1 is returned.
 *		Kashida, diacritics and Alefs are matched/not matched according
 *		to the type of search requested.
 *	
 *	@rdesc
 *		-1,	if string not found
 * 		n, 	if string found.  n indicates number of chars read from <p tistr>
 *				to find string
 */
LONG CTxtPtr::CTxtFinder::MatchStringBiDi(
	const TCHAR *pchToFind,
	LONG		 cchToFind,
	CTxtIStream &tistr)
{
	if((DWORD)_cchToSearch < (DWORD)cchToFind)
		return -1;

	LONG cchRead = 0;

	while(cchToFind)
	{
		TCHAR chComp = tistr.GetChar();
		cchRead++;

		if(!CharComp(*pchToFind, chComp))
		{
			if (!_fMatchKashida && chComp == KASHIDA ||
				!_fMatchDiac && IsBiDiDiacritic(chComp))
			{
				continue;
			}
			if (!_fMatchAlefhamza &&
				IsAlef(*pchToFind) && IsAlef(chComp))
			{
				// Skip *pchToFind
			}
			else
				return -1;
		}
		pchToFind += _iDirection;
		cchToFind--;
	}
	return cchRead;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\tokens.h ===
/*
 *	@doc INTERNAL
 *
 *	@module _TOKENS.H -- All the tokens and then some |
 *
 *	Authors: <nl>
 *		Original RichEdit 1.0 RTF converter: Anthony Francisco <nl>
 *		Conversion to C++ and RichEdit 2.0:  Murray Sargent
 *		
 *	@devnote
 *		The Text Object Model (TOM) keywords come first followed by picture
 *		and object keywords.  The order within a group can matter, since it
 *		may be used to simplify the input process.  Token values <lt> 256
 *		(tokenMin) are used for target character Unicodes as are token values
 *		greater than tokenMax.
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#ifndef _TOKEN_H
#define _TOKEN_H

typedef	WORD	TOKEN;

/*
 *		Keyword --> Token table
 */
typedef struct _keyword
{
	CHAR *	szKeyword;				// The RTF keyword sans '\\'
	TOKEN	token;
} KEYWORD;


// @enum TOKENS | RichEdit RTF Control Word Tokens

enum TOKENS							// Keyword tokens
{
	// Tokens for internal use
	tokenMin = 256,					// Lower tokens treated as Unicode chars
	tokenText = tokenMin,			// A string of characters
	tokenASCIIText,					// A string of characters with values <= 0x7F
	tokenUnknownKeyword,			// A keyword we don't recognize
	tokenError,						// Error condition token
#ifdef UNUSED_TOKENS
	tokenUnknown,					// Unknown token
#endif
	tokenEOF,						// End-of-file token
	tokenStartGroup, 				// Start group token
	tokenEndGroup,					// End group token
	tokenObjectDataValue,			// Data for object 
	tokenPictureDataValue,			// Data for picture


	// RTF control word tokens from here to end of enumeration
	tokenURtf,						// @emem urtf
	tokenPocketWord,				// @emem pwd
	tokenRtf,						// @emem rtf
	tokenCharSetAnsi,				// @emem ansi
	tokenAnsiCodePage,				// @emem ansicpg
	tokenViewKind,					// @emem viewkind		
	tokenViewScale,					// @emem viewscale		

	tokenDefaultFont,				// @emem deff
	tokenDefaultBiDiFont,           // @emem adeff
	tokenDefaultLanguage,			// @emem deflang
	tokenDefaultLanguageFE,			// @emem deflangfe
	tokenDefaultTabWidth,			// @emem deftab
	tokenParagraphDefault,			// @emem pard
	tokenCharacterDefault,			// @emem plain


	// Fonts
	tokenFontTable,					// @emem fonttbl
	tokenFontSelect,				// @emem f
	tokenAssocFontSelect,			// @emem af
									//			Keep next 8 in order
	tokenFontFamilyDefault,			// @emem fnil
	tokenFontFamilyRoman,			// @emem froman
	tokenFontFamilySwiss,			// @emem fswiss
	tokenFontFamilyModern,			// @emem fmodern
	tokenFontFamilyScript,			// @emem fscript
	tokenFontFamilyDecorative,		// @emem fdecor
	tokenFontFamilyTechnical,		// @emem ftech
	tokenFontFamilyBidi,			// @emem fbidi

	tokenCharSet,					// @emem fcharset
	tokenPitch,						// @emem fprq
	tokenRealFontName,				// @emem fname
	tokenCodePage,					// @emem cpg
	tokenFontSize,					// @emem fs

	// Colors
	tokenColorTable,				// @emem colortbl
	tokenColorBackground,			// @emem highlight (used to be cb)
	tokenColorForeground,			// @emem cf
									//			Keep next 3 in order
	tokenColorRed,					// @emem red
	tokenColorGreen,				// @emem green
	tokenColorBlue,					// @emem blue


	// Character formatting						Keep next 15 effects in order
	tokenBold,						// @emem b
	tokenItalic,					// @emem i
	tokenUnderline,					// @emem ul
	tokenStrikeOut,					// @emem strike
	tokenProtect,					// @emem protect
	tokenLink,						// @emem link (check this...)
	tokenSmallCaps,					// @emem scaps
	tokenCaps,						// @emem caps
	tokenHiddenText,				// @emem v
	tokenOutline,					// @emem outl
	tokenShadow,					// @emem shad
	tokenEmboss,					// @emem embo
	tokenImprint,					// @emem impr
	tokenDisabled,					// @emem disabled
	tokenRevised,					// @emem revised

	tokenDeleted,					// @emem deleted

	tokenStopUnderline,				// @emem ulnone	Keep next 10 in order
	tokenUnderlineWord,				// @emem ulw	This thru uld are standard
	tokenUnderlineDouble,			// @emem uldb	 Word underlines
	tokenUnderlineDotted,			// @emem uld		
	tokenUnderlineDash,				// @emem uldash
	tokenUnderlineDashDotted,		// @emem uldashd	
	tokenUnderlineDashDotDotted,	// @emem uldashdd
	tokenUnderlineWave,				// @emem ulwave This down thru uldash are
	tokenUnderlineThick,			// @emem ulth	 for FE
	tokenUnderlineHairline,			// @emem ulhair

	tokenDown,						// @emem dn
	tokenUp,						// @emem up
									// 				Keep next 3 in order
	tokenSubscript,					// @emem sub
	tokenNoSuperSub,				// @emem nosupersub
	tokenSuperscript,				// @emem super

	tokenAnimText,					// @emem animtext
	tokenExpand,					// @emem expndtw
	tokenKerning,					// @emem kerning
	tokenLanguage,					// @emem lang
	tokenCharStyle,					// @emem cs

	// Paragraph Formatting
	tokenEndParagraph,				// @emem par
	tokenLineBreak,					// @emem line
	tokenIndentFirst,				// @emem fi
	tokenIndentLeft,				// @emem li
	tokenIndentRight,				// @emem ri
									//			Keep next 4 in order
	tokenAlignLeft,					// @emem ql		PFA_LEFT
	tokenAlignRight,				// @emem qr		PFA_RIGHT
	tokenAlignCenter,				// @emem qc		PFA_CENTER
	tokenAlignJustify,				// @emem qj		PFA_JUSTIFY

	tokenSpaceBefore,				// @emem sb
	tokenSpaceAfter,				// @emem sa
	tokenLineSpacing,				// @emem sl
	tokenLineSpacingRule,			// @emem slmult
	tokenDropCapLines,				// @emem dropcapli
	tokenStyle,						// @emem s

	tokenLToRPara,					// @emem ltrpar
	tokenBox,
									//			keep next 8 in order 
	tokenRToLPara,					// @emem rtlpar
	tokenKeep,						// @emem keep
	tokenKeepNext,					// @emem keepn
	tokenPageBreakBefore,			// @emem pagebb
	tokenNoLineNumber,				// @emem noline
	tokenNoWidCtlPar,				// @emem nowidctlpar
	tokenHyphPar,					// @emem hyphpar
	tokenSideBySide,				// @emem sbys
	tokenCollapsed,					// @emem collapsed
									// Keep following 8 together
	tokenBorderTop,					// @emem brdrt
	tokenBorderLeft,				// @emem brdrl
	tokenBorderBottom,				// @emem brdrb
	tokenBorderRight,				// @emem brdrr
	tokenCellBorderTop,				// @emem clbrdrt
	tokenCellBorderLeft,			// @emem clbrdrl
	tokenCellBorderBottom,			// @emem clbrdrb
	tokenCellBorderRight,			// @emem clbrdrr
									// Keep following 3 together
	tokenBorderShadow,				// @emem brdrsh
	tokenBorderBetween,				// @emem brdrbtw
	tokenBorderOutside,				// @emem brdrbar
									// Keep following 8 together
	tokenBorderDash,				// @emem brdrdash
	tokenBorderDashSmall,			// @emem brdrdashsm
	tokenBorderDouble,				// @emem brdrdb
	tokenBorderDot,					// @emem brdrdot
	tokenBorderHairline,			// @emem brdrhair
	tokenBorderSingleThick,			// @emem brdrs
	tokenBorderDoubleThick,			// @emem brdrth
	tokenBorderTriple,				// @emem brdrtriple

	tokenBorderColor,				// @emem brdrcf
	tokenBorderWidth,				// @emem brdrw
	tokenBorderSpace,				// @emem brsp

	tokenColorBckgrndPat,			// @emem cbpat
	tokenColorForgrndPat,			// @emem cfpat
	tokenShading,					// @emem shading
									//			keep next 12 in order
	tokenBckgrndBckDiag,			// @emem bgbdiag
	tokenBckgrndCross,				// @emem bgcross
	tokenBckgrndDiagCross,			// @emem bgdcross
	tokenBckgrndDrkBckDiag,			// @emem bgdkbdiag
	tokenBckgrndDrkCross,			// @emem bgdkcross
	tokenBckgrndDrkDiagCross,		// @emem bgdkdcross
	tokenBckgrndDrkFwdDiag,			// @emem bgdkfdiag
	tokenBckgrndDrkHoriz,			// @emem bgdkhoriz
	tokenBckgrndDrkVert,	   		// @emem bgdkvert
	tokenBckgrndFwdDiag,			// @emem bgfdiag
	tokenBckgrndHoriz,				// @emem bghoriz
	tokenBckgrndVert,				// @emem bgvert

	tokenTabPosition,				// @emem tx
	tokenTabBar,					// @emem tb
									//			keep next 5 in order 
	tokenTabLeaderDots,				// @emem tldot
	tokenTabLeaderHyphen,			// @emem tlhyph
	tokenTabLeaderUnderline,		// @emem tlul
	tokenTabLeaderThick,			// @emem tlth
	tokenTabLeaderEqual,			// @emem tleq
									//			keep next 4 in order 
	tokenCenterTab,					// @emem tqc
	tokenFlushRightTab,				// @emem tqr
	tokenDecimalTab,				// @emem tqdec

	tokenParaNum,					// @emem pn
	tokenParaNumIndent,				// @emem pnindent
	tokenParaNumBody,				// @emem pnlvlbody
	tokenParaNumCont,				// @emem pnlvlcont
	tokenParaNumAlignCenter,		// @emem pnqc
	tokenParaNumAlignRight,			// @emem pnqr
									//			keep next 6 in order
	tokenParaNumBullet,				// @emem pnlvlblt
	tokenParaNumDecimal,			// @emem pndec
	tokenParaNumLCLetter,			// @emem pnlcltr
	tokenParaNumUCLetter,			// @emem pnucltr
	tokenParaNumLCRoman,			// @emem pnlcrm
	tokenParaNumUCRoman,			// @emem pnucrm

	tokenParaNumText,				// @emem pntext
	tokenParaNumStart,				// @emem pnstart
	tokenParaNumAfter,				// @emem pntxta
	tokenParaNumBefore,				// @emem pntxtb

	tokenOptionalDestination,		// @emem *
	tokenField,						// @emem field
	tokenFieldResult,				// @emem fldrslt
	tokenFieldInstruction,			// @emem fldinst
	tokenStyleSheet,				// @emem stylesheet
	tokenEndSection,				// @emem sect
	tokenSectionDefault,			// @emem sectd
	tokenDocumentArea,				// @emem info

	// Tables
	tokenInTable,					// @emem intbl
	tokenCell,						// @emem cell
	tokenCellHalfGap,				// @emem trgaph
	tokenCellX,						// @emem cellx
	tokenRow,						// @emem row
	tokenRowDefault,				// @emem trowd
	tokenRowLeft,					// @emem trleft
	tokenRowAlignRight,				// @emem trqr	(trqc must follow trqr)
	tokenRowAlignCenter,			// @emem trqc

	tokenUnicode,					// @emem u
	tokenUnicodeCharByteCount,		// @emem uc

	// Special characters
	tokenFormulaCharacter,			// |
	tokenIndexSubentry,				// :


	tokenLToRChars,					// @emem ltrch
	tokenLToRDocument,				// @emem ltrdoc
	tokenDisplayLToR,				// @emem ltrmark	See also ltrpar
	tokenRToLChars,					// @emem rtlch
	tokenRToLDocument,				// @emem rtldoc
	tokenDisplayRToL,				// @emem rtlmark
	tokenZeroWidthJoiner,			// @emem zwj
	tokenZeroWidthNonJoiner,		// @emem zwnj
	tokenDBChars,					// @emem dbch

	//	T3J keywords
	tokenFollowingPunct,			// @emem fchars
	tokenLeadingPunct,				// @emem lchars

#ifdef FE
	tokenHorizontalRender,			// @emem horzdoc
	tokenVerticalRender,			// @emem vertdoc
	tokenNoOverflow,				// @emem nooverflow
	tokenNoWordBreak,				// @emem nocwrap
	tokenNoWordWrap,				// @emem nowwrap
#endif

	// Pictures						 				Keep next 4 in RECT order
	tokenCropLeft,					// @emem piccropl
	tokenCropTop,					// @emem piccropt
	tokenCropBottom,				// @emem piccropb
	tokenCropRight,					// @emem piccropr
	tokenHeight,					// @emem pich
	tokenWidth,						// @emem picw
	tokenScaleX,					// @emem picscalex
	tokenScaleY,					// @emem picscaley
	tokenPicture,					// @emem pict
	tokenDesiredHeight,				// @emem pichgoal
	tokenDesiredWidth,				// @emem picwgoal
									//				Keep next 3 in order
	tokenPictureWindowsBitmap,		// @emem wbitmap
	tokenPictureWindowsMetafile,	// @emem wmetafile
	tokenPictureWindowsDIB,			// @emem dibitmap

	tokenBinaryData,				// @emem bin
	tokenPictureQuickDraw,			// @emem macpict
	tokenPictureOS2Metafile,		// @emem pmmetafile
	tokenBitmapBitsPerPixel,		// @emem wbmbitspixel
	tokenBitmapNumPlanes,			// @emem wbmplanes
	tokenBitmapWidthBytes,			// @emem wbmwidthbytes


	// Objects
//	tokenCropLeft,					// @emem objcropl		(see // Pictures)
//	tokenCropTop,					// @emem objcropt
//	tokenCropRight,					// @emem objcropr
//	tokenCropBottom,				// @emem objcropb
//	tokenHeight,					// @emem objh
//	tokenWidth,						// @emem objw
//	tokenScaleX,					// @emem objscalex
//	tokenScaleY,					// @emem objscaley
									//				Keep next 3 in order
	tokenObjectEmbedded,			// @emem objemb
	tokenObjectLink,				// @emem objlink
	tokenObjectAutoLink,			// @emem objautlink

	tokenObjectClass,				// @emem objclass
	tokenObjectData,				// @emem objdata
	tokenObject,					// @emem object
	tokenObjectMacICEmbedder,		// @emem objicemb
	tokenObjectName,				// @emem objname
	tokenObjectMacPublisher,		// @emem objpub
	tokenObjectSetSize,				// @emem objsetsize
	tokenObjectMacSubscriber,		// @emem objsub
	tokenObjectResult,				// @emem result

	// Document info and layout
	tokenRevAuthor,					// @emem revauth

#ifdef UNUSED_TOKENS
	tokenTimeSecond,				// @emem sec
	tokenTimeMinute,				// @emem min
	tokenTimeHour,					// @emem hr
	tokenTimeDay,					// @emem dy
	tokenTimeMonth,					// @emem mo
	tokenTimeYear,					// @emem yr
	tokenMarginLeft,				// @emem margl
	tokenMarginRight,				// @emem margr
	tokenSectionMarginLeft,			// @emem marglsxn
	tokenSectionMarginRight,		// @emem margrsxn
#endif

	tokenObjectPlaceholder,			// @emem objattph

	tokenPage,						// @emem page

	tokenNullDestination,			// @emem ??various??

	tokenMax						// Larger tokens treated as Unicode chars
};

// @enum TOKENINDEX | RTFWrite Indices into rgKeyword[]

enum TOKENINDEX						// rgKeyword[] indices
{									// MUST be in exact 1-to-1 with rgKeyword
	i_adeff,						//  entries (see tokens.c).  Names consist
	i_af,
	i_animtext,						
	i_ansi,
	i_ansicpg,						
	i_b,							
	i_bgbdiag,
	i_bgcross,
	i_bgdcross,
	i_bgdkbdiag,
	i_bgdkcross,
	i_bgdkdcross,
	i_bgdkfdiag,
	i_bgdkhoriz,
	i_bgdkvert,
	i_bgfdiag,
	i_bghoriz,
	i_bgvert,
	i_bin,
	i_blue,
	i_box,
	i_brdrb,
	i_brdrbar,
	i_brdrbtw,
	i_brdrcf,
	i_brdrdash,
	i_brdrdashsm,
	i_brdrdb,
	i_brdrdot,
	i_brdrhair,
	i_brdrl,
	i_brdrr,
	i_brdrs,
	i_brdrsh,
	i_brdrt,
	i_brdrth,
	i_brdrtriple,
	i_brdrw,
	i_brsp,
	i_bullet,
	i_caps,
	i_cbpat,
	i_cell,
	i_cellx,
	i_cf,
	i_cfpat,
	i_clbrdrb,
	i_clbrdrl,
	i_clbrdrr,
	i_clbrdrt,
	i_collapsed,
	i_colortbl,
	i_cpg,
	i_cs,
	i_dbch,
	i_deff,
	i_deflang,
	i_deflangfe,
	i_deftab,
	i_deleted,
	i_dibitmap,
	i_disabled,
	i_dn,
	i_dropcapli,
	i_embo,
	i_emdash,
	i_emspace,
	i_endash,
	i_enspace,
	i_expndtw,
	i_f,
	i_fbidi,
	i_fchars,
	i_fcharset,
	i_fdecor,
	i_fi,
	i_field,
	i_fldinst,
	i_fldrslt,
	i_fmodern,
	i_fname,
	i_fnil,
	i_fonttbl,
	i_footer,
	i_footerf,
	i_footerl,
	i_footerr,
	i_footnote,
	i_fprq,
	i_froman,
	i_fs,
	i_fscript,
	i_fswiss,
	i_ftech,
	i_ftncn,
	i_ftnsep,
	i_ftnsepc,
	i_green,
	i_header,
	i_headerf,
	i_headerl,
	i_headerr,
	i_highlight,
	i_hyphpar,
	i_i,
	i_impr,
	i_info,
	i_intbl,
	i_keep,
	i_keepn,
	i_kerning,
	i_lang,
	i_lchars,
	i_ldblquote,
	i_li,
	i_line,
	i_lnkd,
	i_lquote,
	i_ltrch,
	i_ltrdoc,
	i_ltrmark,
	i_ltrpar,
	i_macpict,
	i_noline,
	i_nosupersub,
	i_nowidctlpar,
	i_objattph,
	i_objautlink,
	i_objclass,
	i_objcropb,
	i_objcropl,
	i_objcropr,
	i_objcropt,
	i_objdata,
	i_object,
	i_objemb,
	i_objh,
	i_objicemb,
	i_objlink,
	i_objname,
	i_objpub,
	i_objscalex,
	i_objscaley,
	i_objsetsize,
	i_objsub,
	i_objw,
	i_outl,
	i_page,
	i_pagebb,
	i_par,
	i_pard,
	i_piccropb,
	i_piccropl,
	i_piccropr,
	i_piccropt,
	i_pich,
	i_pichgoal,
	i_picscalex,
	i_picscaley,
	i_pict,
	i_picw,
	i_picwgoal,
	i_plain,
	i_pmmetafile,
	i_pn,
	i_pndec,
	i_pnindent,
	i_pnlcltr,
	i_pnlcrm,
	i_pnlvlblt,
	i_pnlvlbody,
	i_pnlvlcont,
	i_pnqc,
	i_pnqr,
	i_pnstart,
	i_pntext,
	i_pntxta,
	i_pntxtb,
	i_pnucltr,
	i_pnucrm,
	i_protect,
	i_pwd,
	i_qc,
	i_qj,
	i_ql,
	i_qr,
	i_rdblquote,
	i_red,
	i_result,
	i_revauth,
	i_revised,
	i_ri,
	i_row,
	i_rquote,
	i_rtf,
	i_rtlch,
	i_rtldoc,
	i_rtlmark,
	i_rtlpar,
	i_s,
	i_sa,
	i_sb,
	i_sbys,
	i_scaps,
	i_sect,
	i_sectd,
	i_shad,
	i_shading,
	i_sl,
	i_slmult,
	i_strike,
	i_stylesheet,
	i_sub,
	i_super,
	i_tab,
	i_tb,
	i_tc,
	i_tldot,
	i_tleq,
	i_tlhyph,
	i_tlth,
	i_tlul,
	i_tqc,
	i_tqdec,
	i_tqr,
	i_trbrdrb,
	i_trbrdrl,
	i_trbrdrr,
	i_trbrdrt,
	i_trgaph,
	i_trleft,
	i_trowd,
	i_trqc,
	i_trqr,
	i_tx,
	i_u,
	i_uc,
	i_ul,
	i_uld,
	i_uldash,
	i_uldashd,
	i_uldashdd,
	i_uldb,
	i_ulhair,
	i_ulnone,
	i_ulth,
	i_ulw,
	i_ulwave,
	i_up,
	i_urtf,
	i_v,
	i_viewkind,
	i_viewscale,
	i_wbitmap,
	i_wbmbitspixel,
	i_wbmplanes,
	i_wbmwidthbytes,
	i_wmetafile,
	i_xe,
	i_zwj,
	i_zwnj,
	i_TokenIndexMax
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\tokens.cpp ===
/*
 *		tokens.cpp
 *
 *		The sorted table of strings and token values
 *
 *		Note: if you insert new keywords, be sure to insert the corresponding
 *		i_keyword in the i_xxx enum in tokens.h.  This enum defines the
 *		indices used by RTFWrit to output RTF control words.
 *
 *		Original RichEdit 1.0 RTF converter: Anthony Francisco
 *		Conversion to C++ and RichEdit 2.0:  Murray Sargent
 *
 *	Copyright (c) 1995-1998 Microsoft Corporation. All rights reserved.
 */
#include "_common.h"
#include "tokens.h"

extern const KEYWORD rgKeyword[] =
{
	{"adeff",		tokenDefaultBiDiFont},
	{"af",			tokenAssocFontSelect},
	{"animtext",	tokenAnimText},
	{"ansi",		tokenCharSetAnsi},
	{"ansicpg",		tokenAnsiCodePage},
	{"b",			tokenBold},
	{"bgbdiag",		tokenBckgrndBckDiag},
	{"bgcross",		tokenBckgrndCross},
	{"bgdcross",	tokenBckgrndDiagCross},
	{"bgdkbdiag",	tokenBckgrndDrkBckDiag},
	{"bgdkcross",	tokenBckgrndDrkCross},
	{"bgdkdcross",	tokenBckgrndDrkDiagCross},
	{"bgdkfdiag",	tokenBckgrndDrkFwdDiag},
	{"bgdkhoriz",	tokenBckgrndDrkHoriz},
	{"bgdkvert",	tokenBckgrndDrkVert},
	{"bgfdiag",		tokenBckgrndFwdDiag},
	{"bghoriz",		tokenBckgrndHoriz},
	{"bgvert",		tokenBckgrndVert},
	{"bin",			tokenBinaryData},
	{"blue",		tokenColorBlue},
	{"box",			tokenBox},
	{"brdrb",		tokenBorderBottom},
	{"brdrbar",		tokenBorderOutside},
	{"brdrbtw",		tokenBorderBetween},
	{"brdrcf",		tokenBorderColor},
	{"brdrdash",	tokenBorderDash},
	{"brdrdashsm",	tokenBorderDashSmall},
	{"brdrdb",		tokenBorderDouble},
	{"brdrdot",		tokenBorderDot},
	{"brdrhair",	tokenBorderHairline},
	{"brdrl",		tokenBorderLeft},
	{"brdrr",		tokenBorderRight},
	{"brdrs",		tokenBorderSingleThick},
	{"brdrsh",		tokenBorderShadow},
	{"brdrt",		tokenBorderTop},
	{"brdrth",		tokenBorderDoubleThick},
	{"brdrtriple",	tokenBorderTriple},
	{"brdrw",		tokenBorderWidth},
	{"brsp",		tokenBorderSpace},
	{"bullet",		BULLET},
	{"caps",		tokenCaps},
	{"cbpat",		tokenColorBckgrndPat},
	{"cell",		tokenCell},
	{"cellx",		tokenCellX},
	{"cf",			tokenColorForeground},
	{"cfpat",		tokenColorForgrndPat},
	{"clbrdrb",		tokenCellBorderBottom},
	{"clbrdrl",		tokenCellBorderLeft},
	{"clbrdrr",		tokenCellBorderRight},
	{"clbrdrt",		tokenCellBorderTop},
	{"collapsed",	tokenCollapsed},
	{"colortbl",	tokenColorTable},
	{"cpg",			tokenCodePage},
	{"cs",			tokenCharStyle},
	{"dbch",		tokenDBChars},
	{"deff",		tokenDefaultFont},
	{"deflang",		tokenDefaultLanguage},
	{"deflangfe",	tokenDefaultLanguageFE},
	{"deftab",		tokenDefaultTabWidth},
	{"deleted",		tokenDeleted},
	{"dibitmap",	tokenPictureWindowsDIB},
	{"disabled",	tokenDisabled},
	{"dn",			tokenDown},
	{"dropcapli",	tokenDropCapLines},
	{"embo",		tokenEmboss},
#if 1
	{"emdash",		'-'},
	{"emspace",		' '},
	{"endash",		'-'},
	{"enspace",		' '},
#else
	// FUTURE(BradO):  It turns out that we can't reliably
	//	display these Unicode characters for any particular
	//	font applied to them.  If we choose to do something
	//	more intelligent to ensure that these special chars
	//	are displayed regardless of the font applied, then
	//	we should re-enable this code (see Bug #3179).

	{"emdash",		EMDASH},
	{"emspace",		EMSPACE},
	{"endash",		ENDASH},
	{"enspace",		ENSPACE},
#endif
	{"expndtw",		tokenExpand},
	{"f",			tokenFontSelect},
	{"fbidi",		tokenFontFamilyBidi},
	{"fchars",		tokenFollowingPunct},
	{"fcharset",	tokenCharSet},
	{"fdecor",		tokenFontFamilyDecorative},
	{"fi",			tokenIndentFirst},
	{"field",		tokenField},
	{"fldinst",		tokenFieldInstruction},
	{"fldrslt",		tokenFieldResult},
	{"fmodern",		tokenFontFamilyModern},
	{"fname",		tokenRealFontName},
	{"fnil",		tokenFontFamilyDefault},
	{"fonttbl",		tokenFontTable},
	{"footer",		tokenNullDestination},
	{"footerf",		tokenNullDestination},
	{"footerl",		tokenNullDestination},
	{"footerr",		tokenNullDestination},
	{"footnote",	tokenNullDestination},
	{"fprq",		tokenPitch},
	{"froman",		tokenFontFamilyRoman},
	{"fs",			tokenFontSize},
	{"fscript",		tokenFontFamilyScript},
	{"fswiss",		tokenFontFamilySwiss},
	{"ftech",		tokenFontFamilyTechnical},
	{"ftncn",		tokenNullDestination},
	{"ftnsep",		tokenNullDestination},
	{"ftnsepc",		tokenNullDestination},
	{"green",		tokenColorGreen},
	{"header",		tokenNullDestination},
	{"headerf",		tokenNullDestination},
	{"headerl",		tokenNullDestination},
	{"headerr",		tokenNullDestination},
	{"highlight",	tokenColorBackground},
	{"hyphpar",		tokenHyphPar},
	{"i",			tokenItalic},
	{"impr",		tokenImprint},
	{"info",		tokenDocumentArea},
	{"intbl",		tokenInTable},
	{"keep",		tokenKeep},
	{"keepn",		tokenKeepNext},
	{"kerning",		tokenKerning},
	{"lang",		tokenLanguage},
	{"lchars",		tokenLeadingPunct},
	{"ldblquote",	LDBLQUOTE},
	{"li",			tokenIndentLeft},
	{"line",		tokenLineBreak},
	{"lnkd",		tokenLink},
	{"lquote",		LQUOTE},
	{"ltrch",		tokenLToRChars},
	{"ltrdoc",		tokenLToRDocument},
	{"ltrmark",		LTRMARK},
	{"ltrpar",		tokenLToRPara},
	{"macpict",		tokenPictureQuickDraw},
	{"noline",		tokenNoLineNumber},
	{"nosupersub",	tokenNoSuperSub},
	{"nowidctlpar", tokenNoWidCtlPar},  
	{"objattph",	tokenObjectPlaceholder},
	{"objautlink",	tokenObjectAutoLink},
	{"objclass",	tokenObjectClass},
	{"objcropb",	tokenCropBottom},
	{"objcropl",	tokenCropLeft},
	{"objcropr",	tokenCropRight},
	{"objcropt",	tokenCropTop},
	{"objdata",		tokenObjectData},
	{"object",		tokenObject},
	{"objemb",		tokenObjectEmbedded},
	{"objh",		tokenHeight},
	{"objicemb",	tokenObjectMacICEmbedder},
	{"objlink",		tokenObjectLink},
	{"objname",		tokenObjectName},
	{"objpub",		tokenObjectMacPublisher},
	{"objscalex",	tokenScaleX},
	{"objscaley",	tokenScaleY},
	{"objsetsize",	tokenObjectSetSize},
	{"objsub",		tokenObjectMacSubscriber},
	{"objw",		tokenWidth},
	{"outl",		tokenOutline},
	{"page",		tokenPage},
	{"pagebb",		tokenPageBreakBefore},
	{"par",			tokenEndParagraph},
	{"pard",		tokenParagraphDefault},
	{"piccropb",	tokenCropBottom},
	{"piccropl",	tokenCropLeft},
	{"piccropr",	tokenCropRight},
	{"piccropt",	tokenCropTop},
	{"pich",		tokenHeight},
	{"pichgoal",	tokenDesiredHeight},
	{"picscalex",	tokenScaleX},
	{"picscaley",	tokenScaleY},
	{"pict",		tokenPicture},
	{"picw",		tokenWidth},
	{"picwgoal",	tokenDesiredWidth},
	{"plain",		tokenCharacterDefault},
	{"pmmetafile",	tokenPictureOS2Metafile},
	{"pn",			tokenParaNum},
	{"pndec",		tokenParaNumDecimal},
	{"pnindent",	tokenParaNumIndent},
	{"pnlcltr",		tokenParaNumLCLetter},
	{"pnlcrm",		tokenParaNumLCRoman},
	{"pnlvlblt",	tokenParaNumBullet},
	{"pnlvlbody",	tokenParaNumBody},
	{"pnlvlcont",	tokenParaNumCont},
	{"pnqc",		tokenParaNumAlignCenter},
	{"pnqr",		tokenParaNumAlignRight},
	{"pnstart",		tokenParaNumStart},
	{"pntext",		tokenParaNumText},
	{"pntxta",		tokenParaNumAfter},
	{"pntxtb",		tokenParaNumBefore},
	{"pnucltr",		tokenParaNumUCLetter},
	{"pnucrm",		tokenParaNumUCRoman},
	{"protect",		tokenProtect},
	{"pwd",			tokenPocketWord},
	{"qc",			tokenAlignCenter},
	{"qj",			tokenAlignJustify},
	{"ql",			tokenAlignLeft},
	{"qr",			tokenAlignRight},
	{"rdblquote",	RDBLQUOTE},
	{"red",			tokenColorRed},
	{"result",		tokenObjectResult},
	{"revauth",		tokenRevAuthor},
	{"revised",		tokenRevised},
	{"ri",			tokenIndentRight},
	{"row",			tokenRow},
	{"rquote",		RQUOTE},
	{"rtf",			tokenRtf},
	{"rtlch",		tokenRToLChars},
	{"rtldoc",		tokenRToLDocument},
	{"rtlmark",		RTLMARK},
	{"rtlpar",		tokenRToLPara},
	{"s",			tokenStyle},
 	{"sa",			tokenSpaceAfter},
	{"sb",			tokenSpaceBefore},
	{"sbys",		tokenSideBySide},
	{"scaps",		tokenSmallCaps},
	{"sect",		tokenEndSection},
	{"sectd",		tokenSectionDefault},
	{"shad",		tokenShadow},
	{"shading",		tokenShading},
	{"sl",			tokenLineSpacing},
	{"slmult",		tokenLineSpacingRule},
	{"strike",		tokenStrikeOut},
	{"stylesheet",	tokenStyleSheet},
	{"sub",			tokenSubscript},
	{"super",		tokenSuperscript},
	{"tab",			9},
	{"tb",			tokenTabBar},
	{"tc",			tokenNullDestination},
	{"tldot",		tokenTabLeaderDots},
	{"tleq",		tokenTabLeaderEqual},
	{"tlhyph",		tokenTabLeaderHyphen},
	{"tlth",		tokenTabLeaderThick},
	{"tlul",		tokenTabLeaderUnderline},
	{"tqc",			tokenCenterTab},
	{"tqdec",		tokenDecimalTab},
	{"tqr",			tokenFlushRightTab},
	{"trbrdrb",		tokenBorderBottom},
	{"trbrdrl",		tokenBorderLeft},
	{"trbrdrr",		tokenBorderRight},
	{"trbrdrt",		tokenBorderTop},
	{"trgaph",		tokenCellHalfGap},
	{"trleft",		tokenRowLeft},
	{"trowd",		tokenRowDefault},
	{"trqc",		tokenRowAlignCenter},
	{"trqr",		tokenRowAlignRight},
	{"tx",			tokenTabPosition},
	{"u",			tokenUnicode},
	{"uc",			tokenUnicodeCharByteCount},
	{"ul",			tokenUnderline},
	{"uld",			tokenUnderlineDotted},
	{"uldash",		tokenUnderlineDash},
	{"uldashd",		tokenUnderlineDashDotted},
	{"uldashdd",	tokenUnderlineDashDotDotted},
	{"uldb",		tokenUnderlineDouble},
	{"ulhair",		tokenUnderlineHairline},
	{"ulnone",		tokenStopUnderline},
	{"ulth",		tokenUnderlineThick},
	{"ulw",			tokenUnderlineWord},
	{"ulwave",		tokenUnderlineWave},
	{"up",			tokenUp},
	{"urtf",		tokenURtf},
	{"v",			tokenHiddenText},
	{"viewkind",	tokenViewKind},
	{"viewscale",	tokenViewScale},
	{"wbitmap",		tokenPictureWindowsBitmap},
	{"wbmbitspixel",tokenBitmapBitsPerPixel},
	{"wbmplanes",	tokenBitmapNumPlanes},
	{"wbmwidthbytes",tokenBitmapWidthBytes},
	{"wmetafile",	tokenPictureWindowsMetafile},
	{"xe",			tokenNullDestination},
	{"zwj",			ZWJ},
	{"zwnj",		ZWNJ}
};

INT cKeywords = sizeof(rgKeyword) / sizeof(rgKeyword[0]);

extern const BYTE  szSymbolKeywords[] = "*:{}\\_|\r\n-~";

extern const TOKEN tokenSymbol[] =				// Keep in same order as szSymbolKeywords
{
	tokenOptionalDestination,		// *
	tokenIndexSubentry,				// :
	'{',							// {
	'}',							// }
	'\\',							// BSLASH
	'-',							// _ (nonbreaking hyphen; should be 0x2011)
	tokenFormulaCharacter,			// |
	tokenEndParagraph,				// CR
	tokenEndParagraph,				// LF
	0xAD,							// - (optional hyphen)
#if 1
	' '								// ~ (nonbreaking space)
#else
	// FUTURE(BradO):  It turns out that we can't reliably
	//	display these Unicode characters for any particular
	//	font applied to them.  If we choose to do something
	//	more intelligent to ensure that these special chars
	//	are displayed regardless of the font applied, then
	//	we should re-enable this code (see Bug #3179).

	0xa0							// ~ (nonbreaking space)
#endif
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\tomsel.cpp ===
/*
 *	@doc TOM
 *
 *	@module	tomsel.cpp - Implement the CTxtSelection Class |
 *	
 *		This module contains the TOM ITextSelection implementation for
 *		the selection object
 *
 *	History: <nl>
 *		5/24/95 - Alex Gounares: stubs <nl>
 *		8/95	- Murray Sargent: core implementation
 *
 *	@comm
 *		The "cursor-pad" functions (Left, Right, Up, Down, Home, End)
 *		are simple generalizations of the corresponding keystrokes and have
 *		to express the same UI.  Consequently they are typically not as
 *		efficient for moving the cursor around as ITextRange methods, which
 *		are designed for particular purposes.  This is especially true for
 *		counts larger than one.
 *
 *	@devnote
 *		All ITextSelection methods inherited from ITextRange are handled by
 *		the ITextRange methods, since they either don't affect the display of
 *		the selection (e.g., Get methods), or virtual methods are used that
 *		perform the appropriate updating of the selection on screen.
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_select.h"
#include "_disp.h"
#include "_edit.h"

#define DEBUG_CLASSNAME CTxtSelection
#include "_invar.h"


//---------------------- CTxtSelection methods	------------------------------------

/*
 *	CTxtSelection::EndKey (Unit, Extend, pDelta)
 *
 *	@mfunc
 *		Act as UI End key, such that <p Extend> is TRUE corresponds to the
 *		Shift key being depressed and <p Unit> = start of line/document for
 *		Ctrl key not being/being depressed.  Returns *<p pDelta> = count of
 *		characters active end is moved forward, i.e., a number >= 0.
 *
 *	@rdesc
 *		HRESULT =  (invalid Unit) ? E_INVALIDARG :
 *				   (if change) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtSelection::EndKey (
	long  	Unit,			//@parm Unit to use
	long  	Extend,			//@parm Extend selection or go to IP
	long *	pDelta)			//@parm Out parm to receive count of chars moved
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtSelection::EndKey");

	return Homer(Unit, Extend, pDelta, End);
}

/*
 *	CTxtSelection::GetFlags (pFlags)
 *
 *	@mfunc
 *		Set <p pFlags> = this text selection's flags
 *
 *	@rdesc
 *		HRESULT = (<p pFlags>) ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtSelection::GetFlags(
	long * pFlags) 		//@parm Out parm to receive selection flags
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtSelection::GetFlags");

	if(!pFlags)
		return E_INVALIDARG;

	if(IsZombie())	
	{
		*pFlags = tomSelStartActive | tomSelReplace;
		return CO_E_RELEASED;
	}

	DWORD	dwFlags = _cch <= 0;			// Store tomSelStartActive value

	if(_fCaretNotAtBOL)
		dwFlags |= tomSelAtEOL;

	if(GetPed()->_fOverstrike)
		dwFlags |= tomSelOvertype;

	if(GetPed()->_fFocus)
		dwFlags |= tomSelActive;

	*pFlags = dwFlags | tomSelReplace;		// tomSelReplace isn't optional

	return NOERROR;
}

/*
 *	CTxtSelection::GetSelectionType (pType)
 *
 *	@mfunc
 *		Set *pType = type of this text selection
 *
 *	@rdesc
 *		HRESULT = <p pType> ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtSelection::GetType(
	long * pType) 		//@parm Out parm to receive selection type
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtSelection::GetSelectionType");

	if(!pType)
		return E_INVALIDARG;

	*pType = !_cch ? tomSelectionIP
		   : (_cch == -1 && _rpTX.GetChar() == WCH_EMBEDDING ||
			  _cch ==  1 && GetPrevChar()   == WCH_EMBEDDING)
		   ? tomSelectionInlineShape : tomSelectionNormal;

	return IsZombie() ? CO_E_RELEASED : NOERROR;
}

/*
 *	CTxtSelection::HomeKey (Unit, Extend, pDelta)
 *
 *	@mfunc
 *		Act as UI Home key, such that <p Extend> is TRUE corresponds to the
 *		Shift key being depressed and <p Unit> = start of line/document for
 *		Ctrl key not being/being depressed.  Returns *<p pDelta> = count of
 *		characters active end is moved forward, i.e., a number <= 0.
 *
 *	@rdesc
 *		HRESULT =  (invalid Unit) ? E_INVALIDARG :
 *				   (if change) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtSelection::HomeKey (
	long  	Unit,			//@parm Unit to use
	long  	Extend,			//@parm Extend selection or go to IP
	long *	pDelta)			//@parm Out parm to receive count of chars moved
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtSelection::HomeKey");
	
	return Homer(Unit, Extend, pDelta, Home);
}

/*
 *	CTxtSelection::MoveDown (Unit, Count, Extend, pDelta)
 *
 *	@mfunc
 *		Act as UI Down arrow, such that <p Extend> is TRUE corresponds to the
 *		Shift key being depressed and <p Unit> = tomLine/tomParagraph for
 *		Ctrl key not being/being depressed. In addition, <p Unit> can equal
 *		tomWindow/tomWindowEnd for the Ctrl key not being/being depressed.
 *		This second pair emulates PgDn behavior.  The method returns
 *		*<p pDelta> = actual count of units moved.
 *
 *	@rdesc
 *		HRESULT = (if change) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtSelection::MoveDown (
	long  	Unit,			//@parm Unit to use
	long  	Count,			//@parm Number of Units to move
	long  	Extend,			//@parm Extend selection or go to IP
	long *	pDelta)			//@parm Out parm to receive actual count of
							//		Units moved
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtSelection::MoveDown");
 	return GeoMover(Unit, Count, Extend, pDelta, 3);
}

/*
 *	CTxtSelection::MoveLeft (Unit, Count, Extend, pDelta)
 *
 *	@mfunc
 *		Act as UI left arrow, such that <p Extend> is TRUE corresponds to the
 *		Shift key being depressed and <p Unit> = tomChar/tomWord for Ctrl key
 *		not	being/being	depressed.  Returns *<p pDelta> = actual count of
 *		units moved
 *
 *	@rdesc
 *		HRESULT = (if change) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtSelection::MoveLeft (
	long  	Unit,			//@parm Unit to use
	long  	Count,			//@parm Number of Units to move
	long  	Extend,			//@parm Extend selection or go to IP
	long *	pDelta)			//@parm Out parm to receive actual count of
							//		Units moved
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtSelection::MoveLeft");

	return GeoMover(Unit, Count, Extend, pDelta, 0);
}

/*
 *	CTxtSelection::MoveRight (Unit, Count, Extend, pDelta)
 *
 *	@mfunc
 *		Act as UI right arrow, such that <p Extend> is TRUE corresponds to the
 *		Shift key being depressed and <p Unit> = tomChar/tomWord for Ctrl key
 *		not	being/being	depressed.  Returns *<p pDelta> = actual count of
 *		units moved
 *
 *	@rdesc
 *		HRESULT = (if change) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtSelection::MoveRight (
	long  	Unit,			//@parm Unit to use
	long  	Count,			//@parm Number of Units to move
	long  	Extend,			//@parm Extend selection or go to IP
	long *	pDelta)			//@parm Out parm to receive actual count of
							//		Units moved
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtSelection::MoveRight");
	return GeoMover(Unit, Count, Extend, pDelta, 1);
}

/*
 *	CTxtSelection::MoveUp (Unit, Count, Extend, pDelta)
 *
 *	@mfunc
 *		Act as UI Up arrow, such that <p Extend> is TRUE corresponds to the
 *		Shift key being depressed and <p Unit> = tomLine/tomParagraph for
 *		Ctrl key not being/being depressed. In addition, <p Unit> can equal
 *		tomWindow/tomWindowEnd for the Ctrl key not being/being depressed.
 *		This second pair emulates PgUp behavior.  The method returns
 *		*<p pDelta> = actual count of units moved.
 *
 *	@rdesc
 *		HRESULT = (if change) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtSelection::MoveUp (
	long  	Unit,			//@parm Unit to use
	long  	Count,			//@parm Number of Units to move
	long  	Extend,			//@parm Extend selection or go to IP
	long *	pDelta)			//@parm Out parm to receive actual count of
							//		Units moved
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtSelection::MoveUp");

	return GeoMover(Unit, Count, Extend, pDelta, 2);
}

/*
 *	CTxtSelection::SetFlags (Flags)
 *
 *	@mfunc
 *		Set this text selection's flags = Flags
 *
 *	@rdesc
 *		HRESULT = NOERROR
 *
 *	@comm
 *		RichEdit ignores tomSelReplace since it's always on
 */
STDMETHODIMP CTxtSelection::SetFlags(
	long Flags) 			//@parm New flag values
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtSelection::SetFlags");

	if(IsZombie())	
		return CO_E_RELEASED;

	_fCaretNotAtBOL			= (Flags & tomSelAtEOL) != 0;
	GetPed()->_fOverstrike	= (Flags & tomSelOvertype) != 0;

	if(!(Flags & tomSelStartActive) ^ (_cch > 0))
		FlipRange();

	if((Flags & tomSelActive) && !GetPed()->_fFocus)
		GetPed()->TxSetFocus();

	return NOERROR;
}

/*
 *	CTxtRange::SetPoint (x, y, Extend)
 *
 *	@mfunc
 *		Select text at or up through (depending on <p Extend>) the point
 *		(<p x>, <p y>).
 *
 *	@rdesc
 *		HRESULT = NOERROR
 */
STDMETHODIMP CTxtSelection::SetPoint (
	long	x,			//@parm Horizontal coord of point to select
	long	y,			//@parm	Vertical   coord of point to select
	long 	Extend) 	//@parm Whether to extend selection to point
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtSelection::SelectPoint");

	if(IsZombie())	
		return CO_E_RELEASED;

	CCallMgr	callmgr(GetPed());
	POINT		pt = {x, y};

	if(Extend)
		ExtendSelection (pt);
	else
		SetCaret(pt, FALSE);		

	return NOERROR;
}

/*
 *	CTxtSelection::TypeText (bstr)
 *
 *	@mfunc
 *		Type the string given by bstr at this selection as if someone typed it.
 *		This is similar to the underlying ITextRange::SetText() method, but is
 *		sensitive to the Ins/Ovr key state.
 *
 *	@rdesc
 *		HRESULT = !<p bstr> ? E_INVALIDARG :
 *				  (whole string typed) ? NOERROR : S_FALSE
 *	@comm
 *		This is faster than sending chars via SendMessage(), but it's slower
 *		than using ITextRange::SetText()
 */
STDMETHODIMP CTxtSelection::TypeText (
	BSTR bstr)				//@parm String to type into this selection
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtSelection::TypeText");

	if(!bstr)
		return E_INVALIDARG;

	if(IsZombie())	
		return CO_E_RELEASED;

	CCallMgr callmgr(GetPed());

	if(!GetPed()->IsntProtectedOrReadOnly(WM_CHAR, 0, 0))
		return E_ACCESSDENIED;

	BOOL			fOver	= GetPed()->_fOverstrike;
	DWORD			iCount;
	OLECHAR *		pch		= bstr;
	IUndoBuilder *	publdr;
	CGenUndoBuilder undobldr(GetPed(), UB_AUTOCOMMIT, &publdr);
	CFreezeDisplay	fd(_pdp);

	iCount = SysStringLen(bstr);
	
	for ( ; iCount && PutChar(*pch++, fOver, publdr); iCount--)
	{
		// Simulate one character input at a time
		undobldr.Done();
	}
	return iCount ? S_FALSE : NOERROR;
}


//--------------------- ITextSelection PRIVATE helper methods -----------------------------

/*
 *	@doc INTERNAL
 *
 *	CTxtSelection::GeoMover (Unit, Count, Extend, pDelta, iDir)
 *
 *	@mfunc
 *		Helper function to move active end <p Count> <p Unit>s geometrically
 *
 *		Extends range if <p Extend> is TRUE; else collapses range to Start if
 *		<p Count> <lt> 0 and to End if <p Count> <gt> 0.
 *
 *		Sets *<p pDelta> = count of Units moved
 *
 *		Used by ITextSelection::Left(), Right(), Up(), and Down()
 *
 *	@rdesc
 *		HRESULT = (if change) ? NOERROR : (if Unit supported) ? S_FALSE
 *			: E_NOTIMPL
 */
HRESULT CTxtSelection::GeoMover (
	long  		Unit,		//@parm Unit to use
	long  		Count,		//@parm Number of Units to move
	long 	 	Extend,		//@parm Extend selection or go to IP
	long *	  	pDelta,		//@parm Out parm to receive count of Units moved
	LONG	  	iDir)		//@parm Direction to move in if Count > 0
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtSelection::GeoMover");

	if(pDelta)							// Default no movement
		*pDelta = 0;

	if(IsZombie())	
		return CO_E_RELEASED;

	CCallMgr callmgr(GetPed());
	LONG	 CountSave = Count;
	LONG	 cp;
	LONG	 cUnit;
	LONG	 iDefUnit = (iDir & 0xfe) == 2 ? tomLine : tomCharacter;
	BOOL	 fCollapse = !Extend && _cch;
	BOOL	 fCtrl	 = Unit != iDefUnit;

	_fExtend = Extend != 0;

	if(Count < 0)
	{
		Count = -Count;
		iDir ^= 1;
	}
	
	if(iDefUnit == tomLine)				// Up or Down
	{
		if(Unit == tomScreen)
		{
			iDir ^= 6;					// Convert Up/Down to PgUp/PgDn
			fCtrl = FALSE;
		}
		else if(Unit == tomWindow)		// Go to top/bottom of window
		{
			iDir ^= 6;					// Convert Up/Down to PgUp/PgDn
			Count = 1;					// Be sure Count = 1
		}								// Leave fCtrl = 1
		else if(fCtrl && Unit != tomParagraph)
			return E_INVALIDARG;
	}
	else if(fCtrl && Unit != tomWord)
		return E_INVALIDARG;

	for (cUnit = Count; Count; Count--)
	{
		cp = GetCp();					// Save cp for comparison
		switch(iDir)					// iDir bit 0 inc/dec for 1/0
		{								// iDir values are chosen contiguously
		case 0:							//  to encourage compiler to use a
			Left(fCtrl);				//  jump table
			break;

		case 1:							// tomCharacter/tomWord OK here
			Right(fCtrl);
			break;

		case 2:							// tomLine/tomParagraph OK here
			Up(fCtrl);
			break;

		case 3:							// tomLine/tomParagraph OK here
			Down(fCtrl);
			break;

		case 4:							// tomWindow/tomScreen OK here
			PageUp(fCtrl);
			break;

		case 5:							// tomWindow/tomScreen OK here
			PageDown(fCtrl);
		}
		if(cp == GetCp() && !fCollapse)	// Didn't move or collapse
			break;						//  so we're done
		fCollapse = FALSE;				// Collapse counts as a Unit
	}

	cUnit -= Count;						// Count of Units moved
	if(CountSave < 0)
		cUnit = -cUnit;					// Negative Counts get negative results

	if(pDelta)
		*pDelta = cUnit;

	return cUnit ? NOERROR : S_FALSE;
}

/*
 *	CTxtSelection::Homer (Unit, Extend, pDelta, pfn)
 *
 *	@mfunc
 *		Helper function to move active end Home or End depending on pfn
 *
 *		Extends range if <p Extend> is TRUE; else collapses range to Start if
 *		<p Count> <lt> 0 and to End if <p Count> <gt> 0.
 *
 *		Sets *<p pDelta> = count of chars moved	forward
 *
 *		Used by ITextSelection::Home(), End()
 *
 *	@rdesc
 *		HRESULT =  (invalid Unit) ? E_INVALIDARG :
 *				   (if change) ? NOERROR : S_FALSE
 */
HRESULT CTxtSelection::Homer (
	long  	Unit,			//@parm Unit to use
	long 	Extend,			//@parm Extend selection or go to IP
	long *	pDelta,			//@parm Out parm to receive count of Units moved
	BOOL	(CTxtSelection::*pfn)(BOOL))	//@parm Direction to move in
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtSelection::Homer");

	if(pDelta)							// Default no movement
		*pDelta = 0;

	if(IsZombie())	
		return CO_E_RELEASED;

	if(Unit != tomLine && Unit != tomStory)
		return E_INVALIDARG;

	CCallMgr callmgr(GetPed());
	LONG	 cch = GetCp();

	_fExtend = Extend != 0;

	(this->*pfn)(Unit != tomLine);
	cch = GetCp() - cch;
	if(pDelta)
		*pDelta = cch;

	return cch ? NOERROR : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\tomrange.cpp ===
/*
 *  @doc TOM
 *
 *  @module TOMRANGE.CPP - Implement the CTxtRange Class |
 *  
 *      This module contains the implementation of the TOM ITextRange
 *      interface on the CTxtRange object
 *
 *  History: <nl>
 *      5/24/95 - Alex Gounares: stubs created <nl>
 *      8/95    - MurrayS: main implementation <nl>
 *      11/95   - MurrayS: upgrade to TOM spec of 12/10/95 <nl>
 *      5/96    - MurrayS: added zombie protection
 *
 *  @comm
 *      All ITextRange methods return HRESULTs.  If the method can move a
 *      range cp, the HRESULT is NOERROR if movement occurs and S_FALSE if
 *      no movement occurs.  These methods usually take a <p pDelta> argument
 *      that returns the count of characters or Units actually moved.  If this
 *      parameter is NULL, E_INVALIDARG is returned.  Other return values
 *      include E_NOTIMPL, e.g., for Unit values not implemented,
 *      E_OUTOFMEMORY, e.g., when allocations fail, and CO_E_RELEASED, when
 *      the CTxtEdit (_ped) to which the range is attached has been deleted.
 *
 *      For more complete documentation, please see tom.doc
 *
 *  @devnote
 *      All ptr parameters must be validated before use and all entry points
 *      need to check whether this range is a zombie.  These checks are
 *      done in one of three places: 1) immediately on entry to a function,
 *      2) immediately on entry to a helper function (e.g., private Mover()
 *      for the move methods), or 3) before storing the out value.
 *      Alternative 3) is used for optional return values, such as pDelta
 *      and pB.
 *
 *      To achieve a simple, efficient inheritance model, CTxtSelection
 *      inherits ITextSelection through CTxtRange.  Otherwise we'd have a
 *      diamond inheritance, since ITextSelection itself inherits from
 *      ITextRange. Diamond inheritance creates two copies of the multiply
 *      inherited class unless that class is inherited virtually. Virtual
 *      inheritance uses run-time base-offset tables and is slower and
 *      bigger.  To avoid such a mess, we include the extra ITextSelection
 *      methods in CTxtRange, with the intention that they'll never be called
 *      and therefore they return E_NOTIMPL. This is overridden for
 *      ITextSelection objects
 *
 *  @future
 *      1) Finder match ^p, etc.
 *      2) Fast GetEffects() method. Would speed up the myriad IsProtected()
 *         calls and be useful for getting other effects as well.
 *      3) Fast copies/pastes of RichEdit binary format. This can be done by
 *         creating a method to copy a range to a new CTxtStory and a method
 *         to insert a CTxtStory.
 *      4) Delayed rendering
 *
 *  Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_select.h"
#include "_edit.h"
#include "_line.h"
#include "_frunptr.h"
#include "_tomfmt.h"
#include "_disp.h"
#include "_objmgr.h"
#include "_callmgr.h"
#include "_measure.h"

ASSERTDATA

#define DEBUG_CLASSNAME CTxtRange
#include "_invar.h"

HRESULT QueryInterface (REFIID riid, REFIID riid1, IUnknown *punk,
                        void **ppv, BOOL fZombie);


//----------------- CTxtRange (ITextRange) PUBLIC methods ----------------------------------

//----------------------- CTxtRange IUnknown Methods -------------------------------------

/*
 *  CTxtRange::QueryInterface (riid, ppv)
 *
 *  @mfunc
 *      IUnknown method
 *
 *  @rdesc
 *      HRESULT = (!ppv) ? E_INVALIDARG :
 *                (interface found) ? NOERROR : E_NOINTERFACE
 */
STDMETHODIMP CTxtRange::QueryInterface (
    REFIID  riid,           //@parm Reference to requested interface ID
    void ** ppv)            //@parm Out parm to receive interface ptr
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::QueryInterface");

    REFIID riid1 = _fSel && IsEqualIID(riid, IID_ITextSelection)
                 ? IID_ITextSelection : IID_ITextRange;
#ifndef PEGASUS
    return ::QueryInterface(riid, riid1, this, ppv, IsZombie());
#else
    return 0;
#endif
}

/*
 *  CTxtRange::AddRef()
 *
 *  @mfunc
 *      IUnknown method
 *
 *  @rdesc
 *      ULONG - incremented reference count
 */
STDMETHODIMP_(ULONG) CTxtRange::AddRef()
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::AddRef");

    return ++_cRefs;
}

/*
 *  CTxtRange::Release()
 *
 *  @mfunc
 *      IUnknown method
 *
 *  @rdesc
 *      ULONG - decremented reference count
 */
STDMETHODIMP_(ULONG) CTxtRange::Release()
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Release");

    _cRefs--;

    if(!_cRefs)
    {
        delete this;
        return 0;
    }

    Assert(_cRefs > 0);
    return _cRefs;
}


//------------------------ CTxtRange IDispatch Methods -------------------------------------

/*
 *  CTxtRange::GetTypeInfoCount(pcTypeInfo)
 *
 *  @mfunc
 *      Get the number of TYPEINFO elements (1)
 *
 *  @rdesc
 *      HRESULT
 */
STDMETHODIMP CTxtRange::GetTypeInfoCount (
    UINT * pcTypeInfo)          //@parm Out parm to receive type-info count
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetTypeInfoCount");

    if(!pcTypeInfo)
        return E_INVALIDARG;

    *pcTypeInfo = 1;
    return NOERROR;
}

/*
 *  CTxtRange::GetTypeInfo(iTypeInfo, lcid, ppTypeInfo)
 *
 *  @mfunc
 *      Return ptr to type information object for ITextSelection interface
 *
 *  @rdesc
 *      HRESULT
 */
STDMETHODIMP CTxtRange::GetTypeInfo (
    UINT        iTypeInfo,      //@parm Index of type info to return
    LCID        lcid,           //@parm Local ID of type info
    ITypeInfo **ppTypeInfo)     //@parm Out parm to receive type info
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetTypeInfo");

    return ::GetTypeInfo(iTypeInfo, g_pTypeInfoSel, ppTypeInfo);
}

/*
 *  CTxtRange::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid)
 *
 *  @mfunc
 *      Get DISPIDs for methods in the ITextSelection, ITextRange, ITextFont,
 *      and ITextPara interfaces
 *
 *  @rdesc
 *      HRESULT
 *
 *  @devnote
 *      If the ITextFont and ITextPara ever offer more methods than exposed
 *      in their type libraries, the code should delegate to the corresponding
 *      GetIDsOfNames. The current code only gets DISPIDs for the methods in
 *      type libraries, thereby not having to instantiate the objects.
 */
STDMETHODIMP CTxtRange::GetIDsOfNames (
    REFIID      riid,           //@parm Interface ID to interpret names for
    OLECHAR **  rgszNames,      //@parm Array of names to be mapped
    UINT        cNames,         //@parm Count of names to be mapped
    LCID        lcid,           //@parm Local ID to use for interpretation
    DISPID *    rgdispid)       //@parm Out parm to receive name mappings
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetIDsOfNames");

    HRESULT hr = GetTypeInfoPtrs();             // Ensure TypeInfo ptrs are OK
    if(hr != NOERROR)
        return hr;
        
    if(g_pTypeInfoSel->GetIDsOfNames(rgszNames, cNames, rgdispid) == NOERROR)
        return NOERROR;

    if(g_pTypeInfoFont->GetIDsOfNames(rgszNames, cNames, rgdispid) == NOERROR)
        return NOERROR;

    return g_pTypeInfoPara->GetIDsOfNames(rgszNames, cNames, rgdispid);
}

/*
 *  CTxtRange::Invoke(dispidMember, riid, lcid, wFlags, pdispparams,
 *                    pvarResult, pexcepinfo, puArgError)
 *  @mfunc
 *      Invoke methods for the ITextRange and ITextSelection objects, as
 *      well as for ITextFont and ITextPara interfaces on those objects.
 *
 *  @rdesc
 *      HRESULT
 */
STDMETHODIMP CTxtRange::Invoke (
    DISPID      dispidMember,   //@parm Identifies member function
    REFIID      riid,           //@parm Pointer to interface ID
    LCID        lcid,           //@parm Locale ID for interpretation
    USHORT      wFlags,         //@parm Flags describing context of call
    DISPPARAMS *pdispparams,    //@parm Ptr to method arguments
    VARIANT *   pvarResult,     //@parm Out parm for result (if not NULL)
    EXCEPINFO * pexcepinfo,     //@parm Out parm for exception info
    UINT *      puArgError)     //@parm 