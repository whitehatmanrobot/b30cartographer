tMetricsRFONTOBJ - no room in cache\n");

// These constructors used to be in the calling routine - cGet*****
// That was the wrong place because we anticipate many calls that never
// miss the cache.  Better to have them here and lock on every miss.

    PDEVOBJ pdo(pRfont->prfnt->hdevProducer);

// Call font driver to get the metrics.

    ULONG ulMode = QFD_GLYPHANDBITMAP;
    if ( pRfont->prfnt->ulContent == FO_PATHOBJ )
    {
        ulMode = QFD_GLYPHANDOUTLINE;
    }

    GLYPHDATA gd;

    if (pdo.QueryFontData(
            pRfont->prfnt->dhpdev,
            pRfont->pfo(),
            ulMode,
            hg,
            pRfont->bSmallMetrics() ? &gd : pc->pgdNext,
            NULL,
            0) == FD_ERROR)
    {
        WARNING("xInsertMetricsRFONTOBJ: QueryFontData failed\n");
        return FALSE;
    }

    if (pRfont->bSmallMetrics())
        COPYSMALLMETRICS(pc->pgdNext, &gd);

    ASSERTGDI(pc->pgdNext->hg == hg, "xInsertMetricsRFONTOBJ - hg not set\n");

    pc->pgdNext->gdf.pgb = NULL;

// Set returned value, adjust cache, indicate success

    *ppgd = pc->pgdNext;

    if( pRfont->bSmallMetrics() )
    {
        pc->pgdNext = (GLYPHDATA*) (((BYTE*) pc->pgdNext ) + offsetof(GLYPHDATA,fxInkTop));
    }
    else
    {
        pc->pgdNext += 1;
    }

#if DBG
    pc->cMetrics += 1;
#endif

    return TRUE;
}


ULONG ulClearTypeFilter(GLYPHBITS *pgb, GLYPHDATA *pgd, PRFONT prfnt);


/******************************Public*Routine******************************\
* BOOL xInsertMetricsPlusRFONTOBJ
*
* Insert the requested glyph's metrics into the font cache.
* In addition, try to get the glyph data, too, but don't flush the
* cache to try to get them.
*
* History:
*  13-Nov-92 -by- Paul Butzi
* Wrote it.
\**************************************************************************/

extern "C" BOOL xInsertMetricsPlusRFONTOBJ(
    PRFONTOBJ   pRfont,
    GLYPHDATA **ppgd,
    WCHAR       wc
)
{
    HGLYPH hg;
    WCGP  *pwcgp;
    pwcgp = pRfont->prfnt->wcgp;

    if (pRfont->prfnt->flType & RFONT_TYPE_UNICODE)
    {
        hg = pRfont->hgXlat(wc);
    }
    else
    {
        hg = (HGLYPH)wc;  // here is the tiny speed advantage
    }

// Make sure we don't insert the default glyph more than once.
// Just return the correct answer if we know it.

    if
    (
        (hg == pRfont->prfnt->hgDefault)
        && (pwcgp->pgdDefault != (GLYPHDATA *) NULL)
    )
    {
        *ppgd = pwcgp->pgdDefault;
        return(TRUE);
    }

    CACHE *pc = &pRfont->prfnt->cache;

// If only getting hglyphs, use bInsertMetrics

    if (pRfont->prfnt->ulContent == FO_HGLYPHS)
    {
        return pRfont->bInsertMetrics(ppgd, wc);
    }

// Verify enough room in metrics cache area, grow if needed.
// Note that failure to fit a glyphdata is a hard error, get out now.

    if (!pRfont->bCheckMetricsCache())
    {
        WARNING("bInsertMetricsPlus - bCheckMetricsCache failed!\n");
        return FALSE;
    }
    ASSERTGDI(pc->pgdNext < pc->pgdThreshold,
                        "bInsertMetricsPlus - no room in cache\n");

// Handle paths somewhere else!

    if ( pRfont->prfnt->ulContent == FO_PATHOBJ )
    {
        return pRfont->bInsertMetricsPlusPath(ppgd, wc);
    }

// These constructors used to be in the calling routine - cGet*****
// That was the wrong place because we anticipate many calls that never
// miss the cache.  Better to have them here and lock on every miss.

    PDEVOBJ pdo(pRfont->prfnt->hdevProducer);

// Look to see if there is room in the glyphbits cache
// Grow the glyphbits cache if neccessary, but don't flush the cache

    ULONG cjNeeded;
    GLYPHDATA gd;

// If mode is paths, or max glyph will fit, assume max glyph
// otherwise, call up and ask how big

    if (pc->cjGlyphMax < (SIZE_T)(pc->pgbThreshold - pc->pgbNext))
    {
        cjNeeded = pc->cjGlyphMax;
    }
    else
    {
        cjNeeded = pdo.QueryFontData(
                       pRfont->prfnt->dhpdev,
                       pRfont->pfo(),
                       QFD_GLYPHANDBITMAP,
                       hg,
                       &gd,
                       NULL,
                       0);
        if ( cjNeeded == FD_ERROR )
        {
            WARNING("bInsertGlyphMetricsPlus - qfd for size failed\n");
            return FALSE;
        }

        if (pRfont->pfo()->flFontType & FO_CLEARTYPE_X)
        {
            ULONG cx = (ULONG)(gd.rclInk.right  - gd.rclInk.left);
            ULONG cy = (ULONG)(gd.rclInk.bottom - gd.rclInk.top);
            cjNeeded = CJ_CTGD(cx+2,cy);
        }
    }

// We will try to fit the glyphbits in.  If they fit, they'll go
// in at pc->pgbNext, so we set that as the default.
// If they won't fit, we'll set the pointer to null to avoid getting
// the bits

    VOID *pgb = pRfont->pgbCheckGlyphCache(cjNeeded);
    GLYPHDATA *pgd = pRfont->bSmallMetrics() ? &gd : pc->pgdNext;

// Call font driver to get the metrics.

    cjNeeded = pdo.QueryFontData(
                       pRfont->prfnt->dhpdev,
                       pRfont->pfo(),
                       QFD_GLYPHANDBITMAP,
                       hg,
                       pgd,
                       pgb,
                       cjNeeded);

    if ( cjNeeded == FD_ERROR )
    {
        WARNING("bInsertGlyphMetricsPlus - qfd for data failed\n");
        return FALSE;
    }

// need to add CLEARTYPE filtering correction again:

    if (pRfont->pfo()->flFontType & FO_CLEARTYPE_X)
    {
        ULONG cx = (ULONG)(pgd->rclInk.right  - pgd->rclInk.left);
        ULONG cy = (ULONG)(pgd->rclInk.bottom - pgd->rclInk.top);

        cjNeeded = CJ_CTGD(cx+2,cy);

        if (pgb)
        {
            cjNeeded = ulClearTypeFilter((GLYPHBITS *)pgb, pgd, pRfont->prfnt);
        }
    }

    #if DBG
    if (pgb)
    {
        //TRACE_INSERT(("xInsertMetricsPlus: inserted hg = 0x%lx, cj = 0x%lx at pgbNext: 0x%lx\n", hg, cjNeeded, pgb));
    }
    else
    {
        TRACE_INSERT(("xInsertMetricsPlus: cound not insert hg = 0x%lx, cj = 0x%lx\n", hg, cjNeeded));
    }
    #endif

    if (pRfont->bSmallMetrics())
        COPYSMALLMETRICS(pc->pgdNext, &gd);

    ASSERTGDI(pc->pgdNext->hg == hg, "bInsertMetricsPlus - hg not set\n");
    ASSERTGDI(pc->pgdNext->gdf.pgb == pgb, "bInsertMetricsPlus - pgb not set\n");

// Set the returned value

    *ppgd = pc->pgdNext;

// Adjust the cache next pointers as needed.

    if (pRfont->bSmallMetrics())
    {
        pc->pgdNext = (GLYPHDATA*)(((BYTE*)pc->pgdNext) + offsetof(GLYPHDATA,fxInkTop));
    }
    else
    {
        pc->pgdNext += 1;
    }

#if DBG
    pc->cMetrics += 1;
#endif

    if ( pgb != NULL )
    {
        pc->pgbNext += cjNeeded;

    #if DBG
        pc->cGlyphs += 1;
        pc->cjTotal += cjNeeded;
    #endif
    }

    return TRUE;
}

/******************************Public*Routine******************************\
* BOOL bInsertMetricsPlusPath
*
* Insert the requested glyph's metrics into the font cache.
* In addition, try to get the glyph data, too, but don't flush the
* cache to try to get them.
*
* History:
*  13-Nov-92 -by- Paul Butzi
* Wrote it.
\**************************************************************************/

BOOL RFONTOBJ::bInsertMetricsPlusPath(
    GLYPHDATA **ppgd,
    WCHAR       wc
)
{
    HGLYPH hg;
    CACHE *pc = &prfnt->cache;

    if (prfnt->wcgp == NULL)
    {
        if (!bAllocateCache())
        {
            return(FALSE);
        }
    }

    if (prfnt->flType & RFONT_TYPE_UNICODE)
    {
        hg = hgXlat(wc);
    }
    else
    {
        hg = (HGLYPH)wc;  // here is the tiny speed advantage
    }

// These constructors used to be in the calling routine - cGet*****
// That was the wrong place because we anticipate many calls that never
// miss the cache.  Better to have them here and lock on every miss.

    PDEVOBJ pdo(prfnt->hdevProducer);

    PATHMEMOBJ pmo;
    if (!pmo.bValid())
        return(FALSE);

// Call font driver to get the metrics.

    GLYPHDATA gd;

    ULONG cjNeeded = pdo.QueryFontData(
                       prfnt->dhpdev,
                       pfo(),
                       QFD_GLYPHANDOUTLINE,
                       hg,
                       bSmallMetrics() ? &gd : pc->pgdNext,
                       &pmo,
                       0);

    if ( cjNeeded == FD_ERROR )
            return FALSE;

    if (bSmallMetrics())
        COPYSMALLMETRICS(pc->pgdNext, &gd);

    PDEVOBJ pdoCon(prfnt->hdevConsumer);

// Don't cache bezier glyphs for display drivers even if GCAPS_BEZIERS is
// set because dynamic mode changes may cause this capability to change at
// any time.

    if ( (pdo.bDisplayPDEV()) ||
        ((pdo.flGraphicsCaps() & GCAPS_BEZIERS) == 0) )
    {
        if (!pmo.bFlatten())
            return FALSE;
    }

    ASSERTGDI(pc->pgdNext->hg == hg, "bInsertMetricsPlus - hg not set\n");

    cjNeeded = offsetof(EPATHFONTOBJ, pa.apr) + pmo.cjSize();

    VOID *pgb = pgbCheckGlyphCache(cjNeeded);

    if ( pgb != NULL )
    {
        EPATHFONTOBJ *epfo = (EPATHFONTOBJ *)pgb;
        epfo->vInit(cjNeeded);
        epfo->bClone(pmo);

        pc->pgdNext->gdf.ppo = (PATHOBJ *)epfo;
    }
    else
    {
        pc->pgdNext->gdf.ppo = NULL;
    }

// Set the returned value

    *ppgd = pc->pgdNext;

// Adjust the cache next pointers as needed.

    if( prfnt->cache.bSmallMetrics )
    {
        pc->pgdNext = (GLYPHDATA*)(((BYTE*)pc->pgdNext) + offsetof(GLYPHDATA,fxInkTop));
    }
    else
    {
        pc->pgdNext += 1;
    }

#if DBG
    pc->cMetrics += 1;
#endif

    if ( pgb != NULL )
    {
        pc->pgbNext += cjNeeded;
    #if DBG
        pc->cGlyphs += 1;
        pc->cjTotal += cjNeeded;
    #endif
    }

    return TRUE;
}



/******************************Public*Routine******************************\
* BOOL xInsertGlyphbitsRFONTOBJ
*
* Insert the requested glyph into the glyph cache
*
* History:
*  13-Nov-92 -by- Paul Butzi
* Wrote it.
\**************************************************************************/

extern "C" BOOL xInsertGlyphbitsRFONTOBJ(
    PRFONTOBJ pRfont,
    GLYPHDATA *pgd,
    ULONG  bFlushOk
)
{

    CACHE *pc = &pRfont->prfnt->cache;

    if ( (pRfont->prfnt->flType & RFONT_TYPE_NOCACHE) ||
         (pRfont->prfnt->ulContent == FO_HGLYPHS) )
    {
        return FALSE;
    }

    if ( pRfont->prfnt->ulContent == FO_PATHOBJ )
        return pRfont->bInsertGlyphbitsPath(pgd, bFlushOk);

    PDEVOBJ pdo(pRfont->prfnt->hdevProducer);

// Look to see if there is room in the glyphbits cache
// Grow the glyphbits cache if neccessary, but don't flush the cache

    ULONG cjNeeded;

// If max glyph will fit, assume max glyph
// otherwise, call up and ask how big

    GLYPHDATA gd;

    if ( (pc->cjGlyphMax < (SIZE_T)(pc->pgbThreshold - pc->pgbNext))  )
    {
        cjNeeded = pc->cjGlyphMax;
    }
    else
    {
        cjNeeded = pdo.QueryFontData(
                       pRfont->prfnt->dhpdev,
                       pRfont->pfo(),
                       QFD_GLYPHANDBITMAP,
                       pgd->hg,
                       &gd,
                       NULL,
                       0);


        if ( cjNeeded == FD_ERROR )
            return FALSE;

        if (pRfont->pfo()->flFontType & FO_CLEARTYPE_X)
        {
            ULONG cx = (ULONG)(gd.rclInk.right  - gd.rclInk.left);
            ULONG cy = (ULONG)(gd.rclInk.bottom - gd.rclInk.top);
            cjNeeded = CJ_CTGD(cx+2,cy);
        }
    }

// Now, we try to fit the bits in.  If they fit, fine.
// If not, and we can flush the cache, we flush it and try again.
// If we couldn't flush, or we flushed and still fail, just return.

    GLYPHBITS *pgb;

    TRACE_INSERT(("InsertGlyphbits: attempting to insert bits at: 0x%lx\n", pc->pgbNext));

    while ((pgb = (GLYPHBITS *)pRfont->pgbCheckGlyphCache(cjNeeded)) == NULL)
    {
        if ( !bFlushOk )
            return FALSE;

        TRACE_INSERT(("InsertGlyphbits: Flushing the cache\n"));

        pRfont->vFlushCache();
        bFlushOk = FALSE;
    }

// Call font driver to get the metrics.

    cjNeeded = pdo.QueryFontData(
                         pRfont->prfnt->dhpdev,
                         pRfont->pfo(),
                         QFD_GLYPHANDBITMAP,
                         pgd->hg,
                         &gd,
                         (VOID *)pgb,
                         cjNeeded);

    if ( cjNeeded == FD_ERROR )
            return FALSE;

     if (pRfont->pfo()->flFontType & FO_CLEARTYPE_X)
    {
        ULONG cx = (ULONG)(gd.rclInk.right  - gd.rclInk.left);
        ULONG cy = (ULONG)(gd.rclInk.bottom - gd.rclInk.top);

        cjNeeded = CJ_CTGD(cx+2,cy);

        if (pgb)
        {
            cjNeeded = ulClearTypeFilter(pgb, &gd, pRfont->prfnt);
        }
    }

#if DBG
    if(cjNeeded > pc->cjGlyphMax)
    {
        DbgPrint("cjNeeded = %x cjGlyphmax = %x\n", cjNeeded, pc->cjGlyphMax);
        DbgBreakPoint();
    }
#endif

    TRACE_INSERT(("InsertGlyphbits: inserted hg = 0x%lx, cj = 0x%lx at pgbNext: 0x%lx\n", pgd->hg, cjNeeded, pc->pgbNext));

// Set the returned value

    pgd->gdf.pgb = pgb;

// Adjust the cache next pointers as needed.

    pc->pgbNext += cjNeeded;
#if DBG
    pc->cGlyphs += 1;
    pc->cjTotal += cjNeeded;
#endif
    return TRUE;
}

/******************************Public*Routine******************************\
* BOOL bInsertGlyphbitsPath
*
* Insert the requested glyph into the glyph cache
*
* History:
*  13-Nov-92 -by- Paul Butzi
* Wrote it.
\**************************************************************************/

BOOL RFONTOBJ::bInsertGlyphbitsPath(
    GLYPHDATA *pgd,
    ULONG  bFlushOk
)
{
    CACHE *pc = &prfnt->cache;

    ASSERTGDI(prfnt->wcgp != NULL, "bInsertGlyphbitsPath: wcgp is NULL\n");
    ASSERTGDI(!(prfnt->flType & RFONT_TYPE_NOCACHE),
        "bInsertGlyphbitsPath: NOCACHE cache type\n");

// These constructors used to be in the calling routine - cGet*****
// That was the wrong place because we anticipate many calls that never
// miss the cache.  Better to have them here and lock on every miss.

    PDEVOBJ pdo(prfnt->hdevProducer);

    PATHMEMOBJ pmo;
    if (!pmo.bValid())
    {
        return FALSE; // MEMORY ALLOC FAILED, HMGR routines log error code
    }

// Call font driver to get the path

    ULONG cjNeeded = pdo.QueryFontData(
                       prfnt->dhpdev,
                       pfo(),
                       QFD_GLYPHANDOUTLINE,
                       pgd->hg,
                       (GLYPHDATA *)NULL,
                       &pmo,
                       0);

    if ( cjNeeded == FD_ERROR )
            return FALSE;

    PDEVOBJ pdoCon(prfnt->hdevConsumer);

// Don't cache bezier glyphs for display drivers even if GCAPS_BEZIERS is
// set because dynamic mode changes may cause this capability to change at
// any time.

    if ( (pdoCon.bDisplayPDEV()) ||
        ((pdoCon.flGraphicsCaps() & GCAPS_BEZIERS) == 0) )
    {
        if (!pmo.bFlatten())
            return FALSE;
    }

    cjNeeded = offsetof(EPATHFONTOBJ, pa.apr) + pmo.cjSize();

// Now, we try to fit the bits in.  If they fit, fine.
// If not, and we can flush the cache, we flush it and try again.
// If we couldn't flush, or we flushed and still fail, just return.

    VOID *pgb;

    while ( (pgb = pgbCheckGlyphCache(cjNeeded)) == NULL )
    {
        if ( !bFlushOk )
            return FALSE;

        vFlushCache();
        bFlushOk = FALSE;
    }

    EPATHFONTOBJ *epfo = (EPATHFONTOBJ *)pgb;
    epfo->vInit(cjNeeded);
    epfo->bClone(pmo);

// Set the returned value

    pgd->gdf.ppo = (PATHOBJ *)epfo;

// Adjust the cache next pointers as needed.

    pc->pgbNext += cjNeeded;
#if DBG
    pc->cGlyphs += 1;
    pc->cjTotal += cjNeeded;
#endif
    return TRUE;
}


/******************************Public*Routine******************************\
* BOOL RFONTOBJ::bInsertGlyphbitsLookaside
*
* Get the glyph bits into the lookaside buffer
*
* History:
*  13-Nov-92 -by- Paul Butzi
* Wrote it.
\**************************************************************************/

BOOL RFONTOBJ::bInsertGlyphbitsLookaside(
    GLYPHPOS *pgp,
    ULONG imode
    )
{
    if ( imode == FO_PATHOBJ )
        return bInsertPathLookaside(pgp);

    CACHE *pc = &prfnt->cache;

// Make sure the lookaside buffer has enough room for the bitmap

    ULONGSIZE_T cjMaxBitmap = prfnt->cjGlyphMax + sizeof(GLYPHDATA);

// Allocate the buffer and save its size if existing buffer isn't big enough

    if( prfnt->cache.cjAuxCacheMem < cjMaxBitmap )
    {

        if ( prfnt->cache.pjAuxCacheMem != NULL )
        {
            VFREEMEM(prfnt->cache.pjAuxCacheMem);
        }

        prfnt->cache.pjAuxCacheMem = (PBYTE)PALLOCMEM(cjMaxBitmap, 'cacG');

        if ( prfnt->cache.pjAuxCacheMem == NULL )
        {
            prfnt->cache.cjAuxCacheMem = 0;
            WARNING("bGetGlyphbitsLookaside - error allocating buffer\n");
            return FALSE;
        }

        prfnt->cache.cjAuxCacheMem = cjMaxBitmap;
    }

    GLYPHDATA *pgd = (GLYPHDATA *)prfnt->cache.pjAuxCacheMem;
    GLYPHBITS *pgb = (GLYPHBITS *)(pgd + 1);

// Call font driver to get the metrics.

    PDEVOBJ pdo(prfnt->hdevProducer);

    ULONG cjNeeded = pdo.QueryFontData(
                       prfnt->dhpdev,
                       pfo(),
                       QFD_GLYPHANDBITMAP,
                       pgp->hg,
                       pgd,
                       (VOID *)pgb,
                       prfnt->cjGlyphMax);

    if ( cjNeeded == FD_ERROR )
            return FALSE;

    if (pfo()->flFontType & FO_CLEARTYPE_X)
    {
        ULONG cx = (ULONG)(pgd->rclInk.right  - pgd->rclInk.left);
        ULONG cy = (ULONG)(pgd->rclInk.bottom - pgd->rclInk.top);

        cjNeeded = CJ_CTGD(cx+2,cy);

        if (pgb)
        {
            cjNeeded = ulClearTypeFilter(pgb, pgd, prfnt);
        }
    }

    #if DBG
    if(cjNeeded > pc->cjGlyphMax)
    {
        KdPrint(("cjNeeded = %x cjGlyphmax = %x\n", cjNeeded, pc->cjGlyphMax));
        DbgBreakPoint();
    }
    #endif

// Set the returned value

    pgp->pgdf = (GLYPHDEF *)pgd;
    pgd->gdf.pgb = pgb;

    return TRUE;

}


/******************************Public*Routine******************************\
* BOOL RFONTOBJ::bInsertPathLookaside
*
* Get the glyph bits into the lookaside buffer
*
* History:
*  13-Nov-92 -by- Paul Butzi
* Wrote it.
\**************************************************************************/

BOOL RFONTOBJ::bInsertPathLookaside(
    GLYPHPOS *pgp,
    BOOL bFlatten
    )
{

    CACHE *pc = &prfnt->cache;

    PDEVOBJ pdo(prfnt->hdevProducer);

    GLYPHDATA gdTemp;
    PATHMEMOBJ pmo;
    if (!pmo.bValid())
        return(FALSE);

// Call font driver to get the path

    ULONG cjNeeded = pdo.QueryFontData(
                       prfnt->dhpdev,
                       pfo(),
                       QFD_GLYPHANDOUTLINE,
                       pgp->hg,
                       &gdTemp,
                       &pmo,
                       0);

    if ( cjNeeded == FD_ERROR )
            return FALSE;

    PDEVOBJ pdoCon(prfnt->hdevConsumer);

// Don't cache bezier glyphs for display drivers even if GCAPS_BEZIERS is
// set because dynamic mode changes may cause this capability to change at
// any time.

    if ( ((pdoCon.bDisplayPDEV()) ||
          ((pdoCon.flGraphicsCaps() & GCAPS_BEZIERS) == 0))
         && bFlatten )
    {
        if (!pmo.bFlatten())
            return FALSE;
    }

    cjNeeded = sizeof(GLYPHDATA) + offsetof(EPATHFONTOBJ, pa.apr) + pmo.cjSize();

// Make sure the lookaside buffer is allocated

    if ( ( prfnt->cache.cjAuxCacheMem < cjNeeded ) &&
         ( prfnt->cache.pjAuxCacheMem != NULL ))
    {
        #if DBG
        IFIOBJ ifio(prfnt->ppfe->pifi);
        TRACE_CACHE((
            " -- TRACE_CACHE --\n"
            "    RFONTOBJ::bInsertPathLookaside\n"
            "    FaceName = \"%ws\"\n"
            "        ExFreePool\n"
            "           cache.pjAuxCacheMem = %-#x\n",
            ifio.pwszFaceName(),
            prfnt->cache.pjAuxCacheMem
            ))
        #endif

        VFREEMEM((PVOID) prfnt->cache.pjAuxCacheMem);
        prfnt->cache.pjAuxCacheMem = NULL;
        prfnt->cache.cjAuxCacheMem = 0;
    }

    if ( prfnt->cache.pjAuxCacheMem == NULL )
    {
        prfnt->cache.pjAuxCacheMem = (PBYTE)PALLOCMEM(cjNeeded, 'cacG');

        if ( prfnt->cache.pjAuxCacheMem == NULL )
        {
            WARNING("bGetGlyphbitsLookaside - error allocating buffer\n");
            return FALSE;
        }
        prfnt->cache.cjAuxCacheMem = cjNeeded;
        #if DBG
        IFIOBJ ifio(prfnt->ppfe->pifi);
        TRACE_CACHE((
            " -- TRACE_CACHE --\n"
            "    RFONTOBJ::bInsertPathLookaside\n"
            "    FaceName = \"%ws\"\n"
            "    ExAllocatePoolWithTag\n"
            "      tag                  = Gcac\n"
            "      size                 = %-#x\n"
            "      cache.pjAuxCacheMem  = %-#x\n",
            ifio.pwszFaceName(),
            cjNeeded,
            prfnt->cache.pjAuxCacheMem
            ));
        #endif
    }
    GLYPHDATA *pgd = (GLYPHDATA *)prfnt->cache.pjAuxCacheMem;
    EPATHFONTOBJ *epfo = (EPATHFONTOBJ *)(pgd + 1);
    epfo->vInit(cjNeeded - sizeof(GLYPHDATA));
    epfo->bClone(pmo);


// Set the returned value

    *pgd = gdTemp;
    pgp->pgdf = (GLYPHDEF *)pgd;
    pgd->gdf.ppo = epfo;

    return TRUE;

}




/******************************Public*Routine******************************\
* BOOL bCheckMetrics                                                       *
*                                                                          *
* Make sure there's enough room for a GLYPHDATA in the metrics part of the *
* cache.  Return FALSE if we failed to do so.                              *
*                                                                          *
* History:                                                                 *
*  25-Nov-92 -by- Paul Butzi                                               *
* Wrote it.                                                                *
\**************************************************************************/


BOOL RFONTOBJ::bCheckMetricsCache()
{
    CACHE *pc = &prfnt->cache;

    ASSERTGDI(prfnt->wcgp != NULL, "bCheckMetricsCache: wcgp is NULL\n");

// Verify enough room in metrics cache area, grow if needed.

    if ( ( bSmallMetrics() ?
         ((GLYPHDATA*) ((BYTE*)(pc->pgdNext) + offsetof(GLYPHDATA,fxInkTop))) :
         (pc->pgdNext + 1) ) > pc->pgdThreshold )
    {
        DATABLOCK *pdbl;

    // allocate a new block of GLYPHDATA structs

        if ((pdbl = (DATABLOCK*)PALLOCNOZ(GD_INC, 'cacG')) == (DATABLOCK*)NULL)
        {
            return(FALSE);
        }
        #if DBG
        IFIOBJ ifio(prfnt->ppfe->pifi);
        TRACE_CACHE((
            " -- TRACE_CACHE --\n"
            "    RFONTOBJ::bCheckMetrics\n"
            "    FaceName = \"%ws\"\n"
            "    ExAllocatePoolWithTag\n"
            "      tag                  = Gcac\n"
            "      size                 = %-#x\n"
            "      cache.pdblBase     = %-#x\n",
            ifio.pwszFaceName(),
            GD_INC,
            pdbl
            ));
        #endif

    // insert this block into the chain of GLYPHDATA blocks

        pdbl->pdblNext = pc->pdblBase;
        pc->pdblBase = pdbl;
        pc->pgdThreshold = (GLYPHDATA*) ((BYTE *)pdbl + GD_INC);
        pc->pgdNext = &pdbl->agd[0];
    }

    ASSERTGDI((( bSmallMetrics() ?
                (GLYPHDATA*) ((BYTE*)(pc->pgdNext) + offsetof(GLYPHDATA,fxInkTop)) :
                (pc->pgdNext + 1)) <= pc->pgdThreshold),
                "bInsertMetrics - no room in cache\n" );

    return TRUE;
}


/******************************Public*Routine******************************\
* PVOID pgbCheckGlyphCache
*
* Make sure there's enough room for a glyph in the glyph part of the
* cache.  Return NULL if we failed to do so.
*
* History:
*  25-Nov-92 -by- Paul Butzi
* Wrote it.
\**************************************************************************/

PVOID RFONTOBJ::pgbCheckGlyphCache( SIZE_T cjNeeded )
{
    CACHE *pc = &prfnt->cache;

    ASSERTGDI(prfnt->wcgp != NULL, "pgbCheckGlyphCache: wcgp is NULL\n");

    if ((pc->pgbNext + cjNeeded) > pc->pgbThreshold)
    {
    // there are two possible situations that can arise here.
    // One is that there already is a block allocated, following  the pbblCur
    // in the linked list, which is presently unused. This would be the case
    // after the cache was flushed and then partially refilled.
    // The other possible situation is that the pbblCur is
    // the last block allocated and we have to allocate
    // another block if we are allowed to, i.e. if the total
    // number of blocks is not exceeding cBlocksMax.

        BITBLOCK *pbblNext;

        if (pc->pbblCur && (pbblNext = pc->pbblCur->pbblNext))
        {
            TRACE_INSERT(("pgbCheckGlyphCache:Inserting into existing block at 0x%lx\n", pbblNext));
            pc->pbblCur = pbblNext;
            pc->pgbNext = pc->pbblCur->ajBits;

        // we do not want to use the last 8 bytes in the BITBLOCK. Some drivers
        // read the last dword (or quadword) past the end of the GLYPHBITS.
        // If there is a GLYPHBITS at the very and of the BITBLOCK AND the
        // allocation happens to be at the end of the page the read will AV.

            pc->pgbThreshold = (PBYTE)pc->pbblCur + pc->cjbbl - sizeof(double);

            ASSERTGDI(pc->cBlocks == pc->cBlocksMax,
                "Glyphbits logic wrong, cBlocks ??? \n");
        }
        else
        {
            ULONG cjBlockSize = (pc->cBlocks == 0) ?
                                pc->cjbblInitial : pc->cjbbl;

            if
            (
                !(prfnt->flType & RFONT_TYPE_NOCACHE) &&
                (pc->cBlocks < pc->cBlocksMax)        &&
                ((offsetof(BITBLOCK,ajBits) + cjNeeded) <= cjBlockSize)
            )
            {
            // The only reason we need the last check is the PATHOBJ case
            // where cjNeeded may actually not fit in the block of cjbbl bytes.
            // This is because we have no way of knowing how big the paths
            // are going to be (especailly after doing bFlatten) and our
            // pc->cjGlyphMax is just a good guess in this case.

            // We are going to append another block at the end of the list

                pbblNext = (BITBLOCK *) PALLOCNOZ(cjBlockSize,' bgG');

                if (!pbblNext)
                {
                    WARNING1("gdisrv!bInitCache(): glyphbit allocation failed\n");
                    SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
                    return NULL;
                }
                TRACE_CACHE((
                    "      tag            = Ggb"
                    "      size           = %-#x"
                    "      pbbl           = %-#x\n",
                    cjBlockSize,
                    pbblNext
                    ));
                TRACE_INSERT((
                    "Block %ld, cGlyphs = %ld, tag = Ggb, cjBlockSize = 0x%lx, pbbl = %-#x\n",
                    pc->cBlocks, // do before incrementing cBlocks
                    pc->cGlyphs,
                    cjBlockSize,
                    pbblNext
                    ));

            //  we have just allocated another block, update cBlocks:

                pc->cBlocks += 1;

            // append this block to the end of the list

                if (!pc->pbblCur) // first block ever for this rfont
                {
                    ASSERTGDI(
                        (pc->pbblBase == NULL) && (pc->cBlocks == 1),
                        "The font cache is trashed\n");
                    pc->pbblBase = pc->pbblCur = pbblNext;
                }
                else
                {
                    ASSERTGDI(
                        (pc->pbblCur->pbblNext == NULL),
                        "The end of the font cache linked list is trashed\n");
                    pc->pbblCur->pbblNext = pbblNext;
                    pc->pbblCur = pbblNext;
                }

            // init the header of the current block

                pc->pbblCur->pbblNext = NULL;         // essential initialization
                pc->pgbNext = pc->pbblCur->ajBits;

            // we do not want to use the last 8 bytes in the BITBLOCK. Some drivers
            // read the last dword (or quadword) past the end of the GLYPHBITS.
            // If there is a GLYPHBITS at the very and of the BITBLOCK AND the
            // allocation happens to be at the end of the page the read will AV.

                pc->pgbThreshold = (PBYTE)pc->pbblCur + cjBlockSize - sizeof(double);
            }
            else
            {
            // tough luck, we are not allowed to add more blocks

                return NULL;
            }
        }
    }

    ASSERTGDI((pc->pgbNext + cjNeeded) <= pc->pgbThreshold,
              "pgbCheckGlyphCache, we are about to trash the font cache\n");

    return pc->pgbNext;
}


/******************************Public*Routine******************************\
* VOID vFlushCache()
*
* Flush the glyph cache.
*
* History:
*  Fri 29-Sep-1995 -by- Bodin Dresevic [BodinD]
* rewrote.
*  25-Nov-92 -by- Paul Butzi
* Wrote it.
\**************************************************************************/


VOID RFONTOBJ::vFlushCache()
{
    CACHE *pc = &prfnt->cache;

// all the pointers to glyphs bits will be invalidated and we will start
// filling the glyphbits cache all over again. Therefore, we set the current
// block to be the same as base block and pgbN to the first available field in
// in the Current block.
// Note that vFlushCache is allways called after pgbCheckGlyphCache has failed.
// pgbCheckGlyphCache could fail for one of the two following reasons:
//
// a) (pc->cBlocks == pc->cBlocksMax) && (no room in the last block)
// b) (pc->cBlocks < pc->cBlocksMax) &&
//    (failed to alloc mem for the new bitblock).
//
// In the latter case we do not want to flush glyphbits cache.
// Instead we shall try to allocate one more time a bit later.


    if (pc->pbblBase && (pc->cBlocks == pc->cBlocksMax))
    {
        pc->pbblCur = pc->pbblBase;
        pc->pgbNext = pc->pbblCur->ajBits;

    // we do not want to use the last 8 bytes in the BITBLOCK. Some drivers
    // read the last dword (or quadword) past the end of the GLYPHBITS.
    // If there is a GLYPHBITS at the very and of the BITBLOCK AND the
    // allocation happens to be at the end of the page the read will AV.

        pc->pgbThreshold = (PBYTE)pc->pbblCur + pc->cjbblInitial - sizeof(double);
    }

// now go and invalidate the glyphbit pointers in the glyphdata cache

    UINT  cjGD = bSmallMetrics() ?
                 offsetof(GLYPHDATA,fxInkTop) : sizeof(GLYPHDATA);
    BYTE *pjBegin;
    BYTE *pjEnd;

    if ( prfnt->wcgp->pgdDefault != NULL )
        prfnt->wcgp->pgdDefault->gdf.pgb = NULL;

    for
    (
        DATABLOCK *pdbl = pc->pdblBase;
        pdbl != (DATABLOCK*)NULL;
        pdbl = pdbl->pdblNext
    )
    {

        if (pdbl == pc->pdblBase)
        {
        // this is the current block so pjEnd is just pc->pgdNext

            pjEnd = (PBYTE) pc->pgdNext;
        }
        else if (pdbl->pdblNext == (DATABLOCK*)NULL)
        {
        // this is the first block and has the WCPG attached so we need to
        // look into pc.pjFirstBlockEnd to determine the end of it

            pjEnd = pc->pjFirstBlockEnd;
        }
        else
        {
        // this is a normal block so we know it must be GD_INC
        // bytes long

            pjEnd = ((BYTE*) pdbl) + GD_INC;
        }

        pjBegin = (BYTE*)&pdbl->agd[0];

        for ( ; pjBegin < pjEnd ; pjBegin += cjGD)
        {
            ((GLYPHDATA*) pjBegin)->gdf.pgb = NULL;
        }
    }
}



// out of line method for assembler linkage

extern "C" GLYPHDATA *xpgdDefault(RFONTOBJ *pRfontobj)
{
    return pRfontobj->pgdDefault();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\cleanup.cxx ===
/******************************Module*Header*******************************\
* Module Name: cleanup.cxx
*
*   Process termination - this file cleans up objects when a process
*   terminates.
*
* Created: 22-Jul-1991 12:24:52
* Author: Eric Kutter [erick]
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"
#include "muclean.hxx"

extern BOOL bDeleteBrush(HBRUSH,BOOL);                      // brushobj.cxx
extern VOID vCleanupPrivateFonts();                         // pftobj.cxx

extern HCOLORSPACE ghStockColorSpace;                       // icmapi.cxx

#if DBG
ULONG
DbgPrint(
    PCH Format,
    ...
    );
#define DBGPRINT(x) DbgPrint(x)
#else
#define DBGPRINT(x)
#endif

ULONG gInitialBatchCount = 0x14;

/******************************Public*Routine******************************\
*
* History:
*  24-Jul-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID vCleanupDCs(W32PID pid)
{
    HOBJ hobj = HmgNextOwned((HOBJ) 0, pid);

    for (;(hobj != (HOBJ) NULL);hobj = HmgNextOwned(hobj, pid))
    {
        if (HmgObjtype(hobj) == DC_TYPE)
        {
            HmgSetLock(hobj, 0);
            bDeleteDCInternal((HDC)hobj,TRUE,TRUE);
        }
    }
}

/******************************Public*Routine******************************\
*
* History:
*  Sat 20-Jun-1992 -by- Patrick Haluptzok [patrickh]
* Wrote it.
\**************************************************************************/

VOID vCleanupBrushes(W32PID pid)
{
    HOBJ hobj = HmgNextOwned((HOBJ) 0, pid);

    for (;(hobj != (HOBJ) NULL);hobj = HmgNextOwned(hobj, pid))
    {
        if (HmgObjtype(hobj) == BRUSH_TYPE)
        {
            bDeleteBrush((HBRUSH)hobj,TRUE);
        }
    }
}

/******************************Public*Routine******************************\
*
* History:
*  Sat 20-Jun-1992 -by- Patrick Haluptzok [patrickh]
* Wrote it.
\**************************************************************************/

VOID vCleanupSurfaces(W32PID pid, CLEANUPTYPE cutype)
{
    HOBJ hobj = HmgNextOwned((HOBJ) 0, pid);

    for (;(hobj != (HOBJ) NULL);hobj = HmgNextOwned(hobj, pid))
    {
        if (HmgObjtype(hobj) == SURF_TYPE)
        {
          SURFREF so((HSURF)hobj);

          //
          // Skip PDEV surfaces; they are cleaned up with the PDEV
          // (see PDEVOBJ::vUnreferencePdev and PDEVOBJ::vDisableSurface).
          //

          if (!so.ps->bPDEVSurface())
              so.bDeleteSurface(cutype);
        }
    }
}

/******************************Public*Routine******************************\
*
* History:
*  24-Jul-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID vCleanupFonts(W32PID pid)
{
    HOBJ hobj = HmgNextOwned((HOBJ) 0, pid);

    for (;(hobj != (HOBJ) NULL);hobj = HmgNextOwned(hobj, pid))
    {
        if (HmgObjtype(hobj) == LFONT_TYPE)
        {
            bDeleteFont((HLFONT) hobj, FALSE);
        }
    }
}

/******************************Public*Routine******************************\
* vCleanupLCSPs
*
* History:
*
*    9/20/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID vCleanupLCSPs(W32PID pid)
{
    HOBJ hobj = HmgNextOwned((HOBJ) 0, pid);

    for (;(hobj != (HOBJ) NULL);hobj = HmgNextOwned(hobj, pid))
    {
        if (HmgObjtype(hobj) == ICMLCS_TYPE)
        {
            bDeleteColorSpace((HCOLORSPACE)hobj);
        }
    }
}

/******************************Public*Routine******************************\
*
* Eliminate user pregion to make sure delete succceds
*
\**************************************************************************/

VOID vCleanupRegions(W32PID pid)
{
    HOBJ hobj = HmgNextOwned((HOBJ) 0, pid);

    for (;(hobj != (HOBJ) NULL);hobj = HmgNextOwned(hobj, pid))
    {
        if (HmgObjtype(hobj) == RGN_TYPE)
        {
            RGNOBJ ro;

            ro.prgn = (PREGION)HmgLock(hobj,RGN_TYPE);

            if (ro.prgn)
            {
                PENTRY pent = PENTRY_FROM_POBJ(ro.prgn);

                if (pent)
                {
                    pent->pUser = NULL;
                }

                DEC_EXCLUSIVE_REF_CNT(ro.prgn);
            }
            else
            {
                WARNING("vCleanupRegions: locked region has bad pEntry");
            }

            bDeleteRegion((HRGN)hobj);
        }
    }
}

/******************************Public*Routine******************************\
*
* History:
*  01-Feb-2001 -by- Xudong Wu [tessiew]
* Wrote it.
\**************************************************************************/

VOID vRemoveRefPalettes(W32PID pid)
{
    HOBJ hobj = HmgNextOwned((HOBJ) 0, pid);

    for (;(hobj != (HOBJ) NULL);hobj = HmgNextOwned(hobj, pid))
    {
        if (HmgObjtype(hobj) == PAL_TYPE)
        {
            SEMOBJ  semo(ghsemPalette);

            EPALOBJ palobj((HPALETTE)hobj);
            palobj.apalResetColorTable();
        }
    }
}

/******************************Public*Routine******************************\
*
* History:
*  07-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL bEnumFontClose(ULONG_PTR ulEnum)
{
    EFSOBJ efso((HEFS) ulEnum);

    if (!efso.bValid())
    {
        WARNING("gdisrv!bDeleteFontEnumState(): bad HEFS handle\n");
        return FALSE;
    }

    efso.vDeleteEFSOBJ();

    return TRUE;
}

/******************************Public*Routine******************************\
* NtGdiInit()
*
*   This routine must be called before any other GDI routines.  Currently
*   it doesn't actualy do anything, just forces a kernel mode transition
*   which will cause GdiProcessCallout to get called.
*
* History:
*  07-Sep-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL NtGdiInit()
{
    return(TRUE);
}

/******************************Public*Routine******************************\
* NtGdiCloseProcess
*
*   Release the resources held by the specified process.
*
*   The cutype is set to CLEANUP_SESSION only for MultiUserGreCleanup
*   (Hydra) processing.  It is used to do extra work to allow cleanup
*   of cross-process data not normally cleaned up on process termination,
*   just GRE termination (e.g., global and default data such as the
*   default bitmap and the public font tables).
*
* History:
*  03-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL FASTCALL
NtGdiCloseProcess(W32PID W32Pid, CLEANUPTYPE cutype)
{
    BOOL bRes = TRUE;

    ASSERTGDI(cutype != CLEANUP_NONE, "NtGdiCloseProcess: illegal cutype\n");

    //
    // Enum all the objects for the process and kill them.
    //
    // For MultiUserGreCleanup, MultiUserGreCleanupHmgRemoveAllLocks is
    // called for each object type to force all such objects in the
    // handle manager to be unlocked and deletable.
    //

    //
    // Cleanup DCs.
    //

    vCleanupDCs(W32Pid);

    //
    // Cleanup fonts.
    //

    if (cutype == CLEANUP_SESSION)
        MultiUserGreCleanupHmgRemoveAllLocks((OBJTYPE)LFONT_TYPE);
    vCleanupFonts(W32Pid);

    //
    // Cleanup brushes.
    //

    if (cutype == CLEANUP_SESSION)
        MultiUserGreCleanupHmgRemoveAllLocks((OBJTYPE)BRUSH_TYPE);
    vCleanupBrushes(W32Pid);

    //
    // Clean up the ddraw & d3d types
    //
    
    DxDdCloseProcess(W32Pid);

    //
    // Cleanup surfaces.
    //

    if (cutype == CLEANUP_SESSION)
    {
        //
        // Need to forget about some global/default objects so they
        // can be deleted.
        //

        SURFACE::pdibDefault = NULL;
        ppalDefault          = NULL;
        ppalMono             = NULL;
        hpalMono             = (HPALETTE) 0;

        MultiUserGreCleanupHmgRemoveAllLocks((OBJTYPE)SURF_TYPE);
    }
    vCleanupSurfaces(W32Pid, cutype);

    //
    // Cleanup regions.
    //

    if (cutype == CLEANUP_SESSION)
    {
        //
        // Need to forget about some global/default objects so they
        // can be deleted.
        //

        hrgnDefault = NULL;
        prgnDefault = NULL;

        MultiUserGreCleanupHmgRemoveAllLocks((OBJTYPE)RGN_TYPE);
    }
    vCleanupRegions(W32Pid);

    //
    // Cleanup ICM color spaces.
    //

    if (cutype == CLEANUP_SESSION)
    {
        //
        // Need to forget about some global/default objects so they
        // can be deleted.
        //

        ghStockColorSpace    = NULL;

        MultiUserGreCleanupHmgRemoveAllLocks((OBJTYPE)ICMLCS_TYPE);
    }
    vCleanupLCSPs(W32Pid);

    //
    // Cleanup private fonts.
    //

    if (cutype == CLEANUP_SESSION)
    {
        //
        // Relinquish locks on ALL remaining objects in handle manager.
        //

        MultiUserGreCleanupHmgRemoveAllLocks((OBJTYPE)DEF_TYPE);
    }

    if (cutype == CLEANUP_PROCESS)
    {
        // Private fonts should be cleaned up when a process goes away.

        vCleanupPrivateFonts();        
    }
    
    //
    // Remove the ppalColor reference in the palettes
    //
    
    vRemoveRefPalettes(W32Pid);


    // Clean up the rest
    //

    HOBJ hobj = HmgNextOwned((HOBJ) 0, W32Pid);

    for (;(hobj != (HOBJ) NULL);hobj = HmgNextOwned(hobj, W32Pid))
    {
        switch (HmgObjtype(hobj))
        {
        case PAL_TYPE:
            bRes = bDeletePalette((HPAL)hobj, TRUE, cutype);
            break;

        case EFSTATE_TYPE:
            bRes = bEnumFontClose((ULONG_PTR)hobj);
            break;

        case DRVOBJ_TYPE:
            {
            HmgSetLock(hobj, 0);

            //
            // Free the DRIVEROBJ.
            //

            DRIVEROBJ *pdriv = EngLockDriverObj((HDRVOBJ)hobj);

            PDEVOBJ po(pdriv->hdev);

            ASSERTGDI(po.bValid(), "ERROR invalid PDEV in DRIVEROBJ");

            BOOL bRet = EngDeleteDriverObj((HDRVOBJ)hobj, TRUE, TRUE);

            ASSERTGDI(bRet, "Cleanup driver objects failed in process termination");
            }
            break;

        case CLIENTOBJ_TYPE:
            GreDeleteClientObj(hobj);
            break;

        default:
            bRes = FALSE;
            break;
        }

        #if DBG
        if (bRes == FALSE)
        {
            //
            // During shutdown, fonts are handled later so that public
            // fonts and tables can be safely deleted (see function
            // MultiUserGreCleanupAllFonts).
            //

            if ((cutype != CLEANUP_SESSION) ||
                ((HmgObjtype(hobj) != PFE_TYPE) &&
                 (HmgObjtype(hobj) != PFT_TYPE)))
            {
                DbgPrint("GDI ERROR: vCleanup couldn't delete "
                         "obj = %lx, type j=%lx\n", hobj, HmgObjtype(hobj));
                DbgBreakPoint();
            }
        }
        #endif
    }

    return bRes;
}

/******************************Public*Routine******************************\
*
* History:
*  24-Jul-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

extern "C"
NTSTATUS
GdiProcessCallout(
    IN PW32PROCESS Process,
    IN BOOLEAN Initialize
    )
{

    BOOL bRes = TRUE;

    if (Initialize)
    {
        NTSTATUS ntStatus = STATUS_SUCCESS;
        PPEB Peb;

        Process->pDCAttrList    = NULL;
        Process->pBrushAttrList = NULL;
        Process->GDIHandleCount = 0;

        //
        // check if the PEB is valid, if not then this is the SYSTEM process
        // and has a NULL PEB. This process has no user-mode access so it
        // is not neccessary to map in the shared handle table.
        //

        Peb = PsGetProcessPeb(Process->Process);
        if (Peb != NULL)
        {
            //
            // Temporary entry to allow setting GDI
            // batch limit before each process startup.
            //

            Peb->GdiDCAttributeList = gInitialBatchCount;

            ASSERTGDI(sizeof(Peb->GdiHandleBuffer) >= sizeof(GDIHANDLECACHE),
                        "Handle cache not large enough");

            RtlZeroMemory(
                           Peb->GdiHandleBuffer,
                           sizeof(GDIHANDLECACHE)
                         );

            //
            // map a READ_ONLY view of the hmgr shared handle table into the
            // process's address space
            //

            PVOID BaseAddress = NULL;
            SIZE_T CommitSize =  0;
            OBJECT_ATTRIBUTES ObjectAttributes;
            UNICODE_STRING UnicodeString;
            HANDLE SectionHandle = NULL;

            ntStatus = ObOpenObjectByPointer( gpHmgrSharedHandleSection,
                                            0L,
                                            (PACCESS_STATE) NULL,
                                            SECTION_ALL_ACCESS,
                                            (POBJECT_TYPE) NULL,
                                            KernelMode,
                                            &SectionHandle);

            if (NT_SUCCESS(ntStatus))
            {
                ntStatus = ZwMapViewOfSection(
                                SectionHandle,
                                NtCurrentProcess(),
                                &BaseAddress,
                                0L,
                                0L,
                                NULL,
                                &CommitSize,
                                ViewUnmap,
                                0L,
                                PAGE_READONLY
                                );

                if (NT_SUCCESS(ntStatus))
                {
                    //
                    // set table address
                    //
                    // we must set the GdiSharedHandleTable value
                    // to the shared table pointer so that if GDI32 gets
                    // unloaded and re-loaded it can still get the pointer.
                    //
                    // NOTE: we also depend on this pointer being initialized
                    // *BEFORE* we make any GDI or USER call to the kernel
                    // (which has the automatic side-effect of calling this
                    // routine.
                    //

                    Peb->GdiSharedHandleTable =
                            (PVOID)BaseAddress;
                }
                else
                {
                    KdPrint(("ZwMapViewOfSection fails, status = 0x%lx\n",ntStatus));
                    ntStatus = STATUS_DLL_INIT_FAILED;
                }
            }
            else
            {
                KdPrint(("ObOpenObjectByPointer fails, status = 0x%lx\n",ntStatus));
                ntStatus = STATUS_DLL_INIT_FAILED;
            }
        }

        return ntStatus;
    }
    else
    {
        //
        // This call takes place when the last thread of a process goes away.
        // Note that such thread might not be a w32 thread
        //

        //
        // first lets see if this is the spooler and if so, clean him up
        vCleanupSpool();

        W32PID W32Pid = W32GetCurrentPID();

        bRes = NtGdiCloseProcess(W32Pid, CLEANUP_PROCESS);

        if (bRes)
        {
            if(Process->GDIHandleCount != 0)
            {
                WARNING("GdiProcessCallout: handle count != 0 at termination\n");
            }

        }
    }

    return (bRes ? STATUS_SUCCESS : STATUS_CANNOT_DELETE);
}


/******************************Public*Routine******************************\
* GdiThreadCallout
*
*   For Inintialize case, set initial values for W32THREAD elements.
*   For rundown case, move all thread DCATTR memory blocks to the process
*   list.
*
* History:
*
*    15-May-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

extern "C"
VOID GdiThreadCallout(
    IN PETHREAD pEThread,
    IN PSW32THREADCALLOUTTYPE CalloutType
    )
{

    switch (CalloutType)
    {
        case PsW32ThreadCalloutExit:
            {
                PDC_ATTR    pdca;
                PW32THREAD  pThread;

                //
                // Flush the TEB batch. KiSystemService flushes the batch
                // only if the service is a win32k.sys service. During thread
                // termination, the transition to kernel mode is not one of
                // these, and so we can get here without the batch being
                // flushed. Bug #338052 demonstrated this.
                //
                
                GdiThreadCalloutFlushUserBatch();

                //
                // W32 thread execution end. Note that the thread
                //  object can be locked so it might be used after
                //  this call returns.
                //

                pdca = (PDC_ATTR)((PW32THREAD)PsGetThreadWin32Thread(pEThread))->pgdiDcattr;
                if (pdca != NULL)
                {

                    //
                    // Thread->pgdiDcattr is not NULL so HmgFreeDcAttr will
                    // not put pdca back on thread but will place it on the
                    // process list.
                    //

                    HmgFreeDcAttr(pdca);
                }

                #if !defined(_GDIPLUS_)

                //
                // Clean up user mode printer driver related stuff
                //

                pThread = (PW32THREAD) PsGetThreadWin32Thread(pEThread);

                {
                    PUMPDOBJ pumpdobj;

                    while (pumpdobj = (PUMPDOBJ)pThread->pUMPDObjs)
                    {    
                        pumpdobj->Cleanup();
                        VFREEMEM(pumpdobj);
                    }
                }

                if (pThread->pUMPDHeap != NULL)
                    DestroyUMPDHeap((PUMPDHEAP) pThread->pUMPDHeap);

#if defined(_WIN64)
                //
                // Cleanup Proxy port
                //

                if(pThread->pProxyPort)
                {
                    PROXYPORT proxyport((ProxyPort*)pThread->pProxyPort);

                    proxyport.Close();
                    pThread->pProxyPort = NULL;
                }
#endif
                //
                // Cleanup any debug block that may have been allocated
                //

                if(pThread->pSemTable)
                {
                    VFREEMEM(pThread->pSemTable);
                    pThread->pSemTable = NULL;
                }
                #endif // !_GDIPLUS_

                break;
            }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\curseng.cxx ===
/******************************Module*Header*******************************\
* Module Name: curseng.cxx                                                 
*                                                                          
* Engine cursor support.   These routines are only called by USER to       
* set the cursor shape and move it about the screen.  This is not the      
* engine simulation of the pointer.                                        
*                                                                          
* Created: 18-Mar-1991 11:39:40                                            
* Author: Tue 12-May-1992 01:49:04 -by- Charles Whitmer [chuckwh]          
*                                                                          
* Copyright (c) 1991-1999 Microsoft Corporation                            
\**************************************************************************/

#include "precomp.hxx"

// We always create the alpha bitmap from the master shape with two
// rows of pixels on every side to give room for two pixels of blur and
// for an edge of work space.

#define ALPHA_EDGE 3

// Some constants defining the shadow cursor:

#define SHADOW_X_OFFSET 3
#define SHADOW_Y_OFFSET 1
#define SHADOW_ALPHA    0x40000000

/******************************Public*Routine******************************\
* vDetermineSurfaceBounds
*
* Calculate a tight bounds for the surface, given a byte-value that is
* evaluated as the 'space' on the edges.
*
* History:
*  20-Oct-1996 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

LONG galBitsPerPixel[] = { 0, 1, 4, 8, 16, 24, 32 };

VOID vDetermineSurfaceBounds(
SURFOBJ* pso,
BYTE     jBlank,
LONG     yTop,              // Start scan
LONG     yBottom,           // End scan
RECTL*   prclBounds)        // Output
{
    LONG    lDelta;
    BYTE*   pjScan0;
    BYTE*   pj;
    ULONG   cj;
    ULONG   cy;
    ULONG   i;
    BYTE*   pjTop;
    BYTE*   pjBottom;
    BYTE*   pjLeft;
    BYTE*   pjRight;
    BYTE    jStamp;
    LONG    iLeft;
    LONG    iRight;
    LONG    xRight;
    LONG    cBitsPerPixel;

    ASSERTGDI(pso->iType == STYPE_BITMAP,
        "Can directly access only STYPE_BITMAP surfaces");

    lDelta   = pso->lDelta;
    cBitsPerPixel = galBitsPerPixel[pso->iBitmapFormat];
    xRight        = pso->sizlBitmap.cx;
    cj            = (xRight * cBitsPerPixel + 7) >> 3;
    pjScan0  = (BYTE*) pso->pvScan0;
    iLeft    = 0;
    iRight   = cj;

    // Blank the right bits up to the byte multiple:

    if ((pso->iBitmapFormat == BMF_1BPP) && (xRight & 7))
    {
        jStamp = (0x100 >> (xRight & 7)) - 1; // 1 -> 0x7f, 2 -> 0x3f ...7 -> 0x01

        pjRight = pjScan0 + lDelta * yTop + cj - 1;
        if (jBlank)
        {
            for (pj = pjRight, i = (yBottom - yTop); i != 0; pj += lDelta, i--)
            {
                *pj |= jStamp;
            }
        }
        else
        {
            jStamp = ~jStamp;
            for (pj = pjRight, i = (yBottom - yTop); i != 0; pj += lDelta, i--)
            {
                *pj &= jStamp;
            }
        }
    }

    // Trim the top:

    pjTop = pjScan0 + lDelta * yTop;
    while (TRUE)
    {
        for (pj = pjTop, i = cj; i != 0; pj++, i--)
        {
            if (*pj != jBlank)
                goto Done_Top_Trim;
        }

        pjTop += lDelta;
        yTop++;

        // Catch the case where the surface is completely empty:

        if (yTop >= yBottom)
        {
            prclBounds->left   = LONG_MAX;
            prclBounds->top    = LONG_MAX;
            prclBounds->right  = LONG_MIN;
            prclBounds->bottom = LONG_MIN;
            return;
        }
    }

Done_Top_Trim:

    // Trim the bottom:

    pjBottom = pjScan0 + lDelta * (yBottom - 1);
    while (TRUE)
    {
        for (pj = pjBottom, i = cj; i != 0; pj++, i--)
        {
            if (*pj != jBlank)
                goto Done_Bottom_Trim;
        }

        pjBottom -= lDelta;
        yBottom--;
        ASSERTGDI(yTop < yBottom, "Empty cursor should have been caught above");
    }

Done_Bottom_Trim:

    // Trim the left side:

    cy = yBottom - yTop;
    pjLeft = pjTop;
    while (TRUE)
    {
        for (pj = pjLeft, i = cy; i != 0; pj += lDelta, i--)
        {
            if (*pj != jBlank)
                goto Done_Left_Trim;
        }

        pjLeft++;
        iLeft++;
        ASSERTGDI(iLeft < iRight, "Empty cursor should have been caught above");
    }

Done_Left_Trim:

    // Trim the right side:

    pjRight = pjTop + cj - 1;
    while (TRUE)
    {
        for (pj = pjRight, i = cy; i != 0; pj += lDelta, i--)
        {
            if (*pj != jBlank)
                goto Done_Right_Trim;
        }

        pjRight--;
        iRight--;
        ASSERTGDI(iLeft < iRight, "Empty cursor should have been caught above");
    }

Done_Right_Trim:

    prclBounds->top    = yTop;
    prclBounds->bottom = yBottom;
    prclBounds->left   = (8 * iLeft)                      / cBitsPerPixel;  // Floor
    prclBounds->right  = (8 * iRight + cBitsPerPixel - 1) / cBitsPerPixel;  // Ceiling

    // Account for the fact that we are checking on bytes worth at a time, and
    // so might actually end up somewhat past the right edge of the bitmap:

    prclBounds->right = min(prclBounds->right, pso->sizlBitmap.cx);
}

/******************************Public*Routine******************************\
* vCalculateCursorBounds
*
* Calculate a tight bounds for the specified cursor shape.
*
* History:
*  20-Oct-1996 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vCalculateCursorBounds(
SURFOBJ*    psoMask,
SURFOBJ*    psoColor,
RECTL*      prclBounds)
{
    LONG    cyMask;
    ERECTL  erclBounds;
    ERECTL  erclMask;

    cyMask = psoMask->sizlBitmap.cy >> 1;
        
    vDetermineSurfaceBounds(psoMask, 0xff, 0, cyMask, &erclMask);

    if (psoColor == NULL)
    {
        vDetermineSurfaceBounds(psoMask, 0x00, cyMask, 2 * cyMask, &erclBounds);

        if (!erclBounds.bWrapped())
        {
        erclBounds.top    -= cyMask;
        erclBounds.bottom -= cyMask;
    }
    }
    else
    {
        vDetermineSurfaceBounds(psoColor, 0x00, 0, cyMask, &erclBounds);
    }

    // The bounds are the union of the AND mask bounds and the OR mask bounds:

    erclBounds |= erclMask;
    if (erclBounds.bWrapped())
    {
        erclBounds.left   = 0;
        erclBounds.top    = 0;
        erclBounds.right  = 1;
        erclBounds.bottom = 1;
    }

    // KdPrint((">> Cursor bounds: (%li, %li, %li, %li)\n", 
    //  erclBounds.left, erclBounds.top, erclBounds.right, erclBounds.bottom)); 
    //
    // Stash the bounds away for next time:

    *prclBounds = erclBounds;
}

/******************************Public*Routine******************************\
* bBlurCursorShadow
*
* Do an in-place blur of the cursor shadow (i.e., the blurred image will
* replace the image passed in).
*
* This is done by applying an approximation of a 3x3 boxcar convolution.
*
* The cursor shadow is assumed to be in the MSB of the surface.  The surface
* is assumed to be a 32bpp BGRA surface.
*
* History:
*  03-Mar-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL bBlurCursorShadow(
SURFOBJ*    pso)
{
    USHORT aus0[64];
    USHORT aus1[64];
    USHORT aus2[64];
    PUSHORT apus[3];

    // Function assumes caller will pass a 32bpp surface.

    ASSERTGDI(pso->iBitmapFormat == BMF_32BPP,
              "bBlurCursorShadow: bad iBitmapFormat\n");

    // Must at least be 3x3.  Don't bother if it's too small.

    if ((pso->sizlBitmap.cx < 3) || (pso->sizlBitmap.cy < 3))
    {
        WARNING("bBlurCursorShadow: bitmap too small\n");
        return(FALSE);
    }

    // Setup temporary scanline memory.  If it will fit, use the stack
    // buffer.  Otherwise allocate pool memory.

    if (pso->sizlBitmap.cx > 64)
    {
        apus[0] = (PUSHORT) PALLOCMEM(pso->sizlBitmap.cx * sizeof(USHORT) * 3, 'pmtG');
        if (apus[0])
        {
            apus[1] = apus[0] + pso->sizlBitmap.cx;
            apus[2] = apus[1] + pso->sizlBitmap.cx;
        }
    }
    else
    {
        apus[0] = aus0;
        apus[1] = aus1;
        apus[2] = aus2;
    }

    if (apus[0] == NULL)
    {
        WARNING("bBlurCursorShadow: mem alloc failure\n");
        return(FALSE);
    }

    // Fill up the scanline memory with 3x1 boxcar sums for the
    // first three scanlines.

    PULONG pulIn = (PULONG) pso->pvScan0;
    PULONG pulTmp;
    USHORT usLast;
    USHORT *pus, *pusEnd;
    ULONG j;

    for (j = 0; j < 3; j++)
    {
        // Compute the scanline sum.  Note that output is two pixels
        // smaller than the input.

        pus = apus[j];
        pusEnd = pus + (pso->sizlBitmap.cx - 2);
        pulTmp = pulIn;

        while (pus < pusEnd)
        {
            *pus = (USHORT) ((pulTmp[0] >> 24) + (pulTmp[1] >> 24) + (pulTmp[2] >> 24));
            pus    += 1;
            pulTmp += 1;
        }

        // Next scanline.

        pulIn = (PULONG) (((PBYTE) pulIn) + pso->lDelta);
    }

    // Compute the average (3x3 boxcar convolution) for each output
    // scanline.

    PULONG pulOut = ((PULONG) (((PBYTE) pso->pvScan0) + pso->lDelta)) + 1;
    ULONG ulNumScans = pso->sizlBitmap.cy - 2;
    ULONG ulNext = 0;

    while (ulNumScans--)
    {
        // Setup output pointers.

        PULONG pulAvg = pulOut;
        PULONG pulAvgEnd = pulAvg + (pso->sizlBitmap.cx - 2);

        // Setup pointers to run the scanline 3x1 sums.

        PUSHORT pusTmp[3];

        pusTmp[0] = apus[0];
        pusTmp[1] = apus[1];
        pusTmp[2] = apus[2];

        // Compute the average scanline.

        while (pulAvg < pulAvgEnd)
        {
            USHORT usSum;

            // Strictly speaking we should divide the sum by 9, but since
            // this is just for looks, we can approximate as a divide by 8
            // minus a divide by 64 (will produce in a slightly too small
            // result).
            //
            //      1/9                = 0.111111111...    in decimal
            //                         = 0.000111000111... in binary
            //
            // Approximations:
            //
            //      1/8 - 1/64                  = 0.109375
            //      1/8 - 1/64 + 1/512          = 0.111328125
            //      1/8 - 1/64 + 1/512 - 1/4096 = 0.111083984

            usSum = *pusTmp[0] + *pusTmp[1] + *pusTmp[2];
            //*pulAvg = (usSum / 9) << 24;
            //*pulAvg = ((usSum >> 3) - (usSum >> 6)) << 24;
            *pulAvg = (usSum >> 3) << 24;

            pulAvg    += 1;
            pusTmp[0] += 1;
            pusTmp[1] += 1;
            pusTmp[2] += 1;
        }

        // Next output scanline.

        pulOut = (PULONG) (((PBYTE) pulOut) + pso->lDelta);

        // Need to compute 3x1 boxcar sum for the next scanline.

        if (ulNumScans)
        {
            // Compute the scanline sum.  Note that output is two pixels
            // smaller than the input.

            pus = apus[ulNext];
            pusEnd = pus + (pso->sizlBitmap.cx - 2);
            pulTmp = pulIn;

            while (pus < pusEnd)
            {
                *pus = (USHORT) ((pulTmp[0] >> 24) + (pulTmp[1] >> 24) + (pulTmp[2] >> 24));
                pus    += 1;
                pulTmp += 1;
            }

            // Next scanline.

            pulIn = (PULONG) (((PBYTE) pulIn) + pso->lDelta);

            // Next scanline summation buffer.

            ulNext++;
            if (ulNext >= 3)
                ulNext = 0;
        }
    }

    // Cleanup temporary memory.

    if (apus[0] != aus0)
    {
        VFREEMEM(apus[0]);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* bApplicationAlphaCursor
*
* This routine will create a pre-muliplied alpha version of the specified
* cursor if the cursor has non-pre-mulitplied alpha values in it.
*
* History:
*  20-Oct-1996 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL bApplicationAlphaCursor(
SURFOBJ*    psoAlpha,
SURFOBJ*    psoColor,
RECTL*      prclBounds)
{
    ULONG   ulAlpha;
    ULONG   ul;
    ULONG*  pulScan0;
    ULONG*  pul;
    ULONG   cPixels;
    BOOL    bPerPixelAlpha;
    ULONG   i;
    RECTL   rclDst;

    ASSERTGDI(psoColor->iBitmapFormat == BMF_32BPP,
        "Expected only BGRA 32-bpp bitmaps");

    // Copy the cursor to our alpha surface, accounting for the same
    // offset that is needed for shadowed cursors:

    rclDst.left   = ALPHA_EDGE;
    rclDst.top    = ALPHA_EDGE;
    rclDst.right  = ALPHA_EDGE + prclBounds->right;
    rclDst.bottom = ALPHA_EDGE + prclBounds->bottom;

    EngCopyBits(psoAlpha, psoColor, NULL, NULL, &rclDst, &gptlZero);

    // Check for any pixels with non-zero alpha:

    cPixels  = psoAlpha->sizlBitmap.cx * psoAlpha->sizlBitmap.cy;
    pulScan0 = (ULONG*) psoAlpha->pvBits;

    bPerPixelAlpha = FALSE;
    for (pul = pulScan0, i = cPixels; i != 0; pul++, i--)
    {
        if ((*pul & 0xff000000) != 0)
        {
            bPerPixelAlpha = TRUE;
            break;
        }
    }

    if (bPerPixelAlpha)
    {
        // Okay, we can now assume that the application gave us a per-pixel
        // alpha cursor shape.  Now go through and convert it to pre-multiplied
        // alpha.

        for (pul = pulScan0, i = cPixels; i != 0; pul++, i--)
        {
            ul = *pul;
            ulAlpha = (ul & 0xff000000) >> 24;
            *pul = (((ul & 0xff000000)))
                 | ((((ul & 0xff0000) * ulAlpha) >> 8) & 0xff0000)
                 | ((((ul & 0xff00) * ulAlpha) >> 8) & 0xff00)
                 | ((((ul & 0xff) * ulAlpha) >> 8) & 0xff);
        }
    }

    return(bPerPixelAlpha);
}

/******************************Public*Routine******************************\
* bShadowAlphaCursor
*
* This routine will create a pre-multiplied alpha version of the specified
* cursor along with a shadow mask, assuming that the specified cursor does
* not try to do 'XOR'.
*
* History:
*  20-Oct-1996 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL bShadowAlphaCursor(
SURFOBJ*    psoAlpha,
SURFOBJ*    psoMask,
SURFOBJ*    psoColor,
XLATEOBJ*   pxloMask,
XLATEOBJ*   pxloColor,
RECTL*      prclBounds)
{
    BOOL        bRet = FALSE;               // Assume failure
    ULONG       cxMask;
    ULONG       cyMask;
    RECTL       rclDst;
    XLATEOBJ    xlo;
    ULONG       aulXlate[2];
    ULONG*      pul;
    ULONG       i;
    POINTL      ptlSrc;

    cyMask = psoMask->sizlBitmap.cy >> 1;
    cxMask = psoMask->sizlBitmap.cx;
    xlo.pulXlate = aulXlate;

    // We can only generate a shadow cursor if there are no XOR pixels
    // in the definition of the cursor (because we use an AlphaBlend
    // function which has no concept of XOR).  So check if there are
    // any XOR pixels.  We do this by ANDing the XOR mask with the AND
    // mask; if any part of the result is non-zero, then there is an
    // XOR component to the cursor.
    //
    // First, make a copy of the AND bits, converting it to 32bpp for
    // convenience:

    rclDst.left   = 0;
    rclDst.top    = 0;
    rclDst.right  = cxMask;
    rclDst.bottom = cyMask;

    if (psoColor != NULL)
    {
        EngBitBlt(psoAlpha, psoColor, NULL, NULL, pxloColor, &rclDst,
                  &gptlZero, NULL, NULL, NULL, 0xeeee); // SRCPAINT
    }
    else
    {
        ptlSrc.x = 0;
        ptlSrc.y = cyMask;

        EngBitBlt(psoAlpha, psoMask, NULL, NULL, pxloMask, &rclDst,
                  &ptlSrc, NULL, NULL, NULL, 0xeeee); // SRCPAINT
    }

    // Now, AND in the XOR mask.  Use a fake XLATEOBJ to do the color
    // expansion:

    aulXlate[0] = 0x00000000;
    aulXlate[1] = 0xffffffff;
    EngBitBlt(psoAlpha, psoMask, NULL, NULL, &xlo, &rclDst, &gptlZero,
              NULL, NULL, NULL, 0x8888);                // SRCAND

    // Now check for any non-zero resulting pixels:

    pul = (ULONG*) psoAlpha->pvBits;
    i = psoAlpha->sizlBitmap.cy * abs(psoAlpha->lDelta) / 4;

    for (; i != 0; pul++, i--)
    {
        if (*pul != 0)
        {
            return(FALSE);
        }
    }

    // Okay, we're golden for adding the shadow.  First, construct a
    // rectangle that represents the shadow's position:

    rclDst.left   = ALPHA_EDGE + SHADOW_X_OFFSET;
    rclDst.top    = ALPHA_EDGE + SHADOW_Y_OFFSET;
    rclDst.right  = ALPHA_EDGE + SHADOW_X_OFFSET + prclBounds->right;
    rclDst.bottom = ALPHA_EDGE + SHADOW_Y_OFFSET + prclBounds->bottom;

    // Create a copy of the mask, giving the mask a particular alpha
    // value:

    aulXlate[0] = SHADOW_ALPHA;
    aulXlate[1] = 0x0;
    EngCopyBits(psoAlpha, psoMask, NULL, &xlo, &rclDst, &gptlZero);

    // Create the blur from the copy.  We invoke the 3x3 blur twice
    // to get a better blur (note that we changed ALPHA_EDGE to
    // accomodate this).

    if (bBlurCursorShadow(psoAlpha) && bBlurCursorShadow(psoAlpha))
    {
        rclDst.left   = ALPHA_EDGE;
        rclDst.top    = ALPHA_EDGE;
        rclDst.right  = ALPHA_EDGE + prclBounds->right;
        rclDst.bottom = ALPHA_EDGE + prclBounds->bottom;

        // Now, zero the opaque pixels:

        aulXlate[0] = 0x00000000;
        aulXlate[1] = 0xffffffff;
        EngBitBlt(psoAlpha, psoMask, NULL, NULL, &xlo, &rclDst, &gptlZero,
                  NULL, NULL, NULL, 0x8888);                // SRCAND

        // Now, give all the opaque pixels an alpha value of 0xff:

        aulXlate[0] = 0xff000000;
        aulXlate[1] = 0x00000000;
        EngBitBlt(psoAlpha, psoMask, NULL, NULL, &xlo, &rclDst, &gptlZero,
                  NULL, NULL, NULL, 0xeeee);                // SRCPAINT

        // Finally, OR in the opaque bits on top of the shadow:

        if (psoColor != NULL)
        {
            EngBitBlt(psoAlpha, psoColor, NULL, NULL, pxloColor, &rclDst,
                      &gptlZero, NULL, NULL, NULL, 0xeeee); // SRCPAINT
        }
        else
        {
            ptlSrc.x = 0;
            ptlSrc.y = cyMask;

            EngBitBlt(psoAlpha, psoMask, NULL, NULL, pxloMask, &rclDst,
                      &ptlSrc, NULL, NULL, NULL, 0xeeee); // SRCPAINT
        }

        bRet = TRUE;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* vProcessCursorShape
*
* This routine will:
*
*   1. Calculate the bounds on the cursor shape;
*   2. Create a pre-multiplied alpha surface if the cursor shape has per-
*      pixel alpha;
*   3. Create a pre-multiplied alpha shadow surface for the cursor if
*      we've been asked to create a 'shadow'.
*
* History:
*  20-Oct-1996 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vProcessCursorShape(
HDEV        hdev,
BOOL        bShadow, 
SURFOBJ*    psoMask,
SURFOBJ*    psoColor,
PALETTE*    ppalColor,
RECTL*      prclBounds,
HBITMAP*    phbmAlpha)
{
    SPRITESTATE*    pSpriteState;
    SURFACE*        psurfColor;
    SURFMEM         SurfDimo;
    BOOL            bAlpha;
    DEVBITMAPINFO   dbmi;
    SURFOBJ*        psoAlpha;
    RECTL           rclAlpha;
    RECTL           rclColor;

    // Delete the existing hbmAlpha, so that it can be regenerated.

    if (*phbmAlpha != NULL)
    {
        GreDeleteObject(*phbmAlpha);
        *phbmAlpha = NULL;
    }

    // Do a first-pass bounds calculation taking into account only
    // the monochrome mask:

    vCalculateCursorBounds(psoMask, NULL, prclBounds);

    // Create a 32bpp DIB to hold the alpha bits.  We add in 4 to
    // the dimensions to account for the one pixel extra on every
    // side that the blurring result needs, plus the one extra
    // pixel on every side that the blurring process needs as work-
    // space.

    rclAlpha.left   = 0;
    rclAlpha.top    = 0;
    rclAlpha.right  = SHADOW_X_OFFSET + (2 * ALPHA_EDGE) 
                    + (psoMask->sizlBitmap.cx);
    rclAlpha.bottom = SHADOW_Y_OFFSET + (2 * ALPHA_EDGE) 
                    + (psoMask->sizlBitmap.cy >> 1);

    dbmi.cxBitmap = rclAlpha.right;
    dbmi.cyBitmap = rclAlpha.bottom;
    dbmi.iFormat  = BMF_32BPP;
    dbmi.fl       = BMF_TOPDOWN;
    dbmi.hpal     = NULL;

    if (SurfDimo.bCreateDIB(&dbmi, NULL))
    {
        psoAlpha = SurfDimo.pSurfobj();
        psurfColor = SURFOBJ_TO_SURFACE_NOT_NULL(psoColor);

        EXLATEOBJ xloMono;
        EXLATEOBJ xloColor;
        XEPALOBJ palColor(ppalColor);
        XEPALOBJ palDefault(ppalDefault);
        XEPALOBJ palRGB(gppalRGB);
        XEPALOBJ palMono(ppalMono);

        if (xloMono.bInitXlateObj(NULL, DC_ICM_OFF, palMono, palRGB,
                                  palDefault, palDefault, 0, 0xffffff, 0))
        {
            if ((psoColor == NULL) || 
            (xloColor.bInitXlateObj(NULL, DC_ICM_OFF, palColor, palRGB,
                                    palDefault, palDefault, 0, 0, 0)))
        {
            bAlpha = FALSE;

                if (psoColor != NULL)
                {
                    // Do a second-pass bounds accumulation, taking into
                    // account both the monochrome and color masks.  We
                    // use the Alpha surface to create a directly-readable
                    // copy of 'psoColor' (it might be STYPE_DEVBITMAP):
    
                    rclColor.left   = 0;
                    rclColor.top    = 0;
                    rclColor.right  = psoMask->sizlBitmap.cx;
                    rclColor.bottom = psoMask->sizlBitmap.cy >> 1;
    
                    EngCopyBits(psoAlpha, 
                                psoColor, 
                                NULL, 
                                xloColor.pxlo(), 
                                &rclColor, 
                                &gptlZero);
    
                    vCalculateCursorBounds(psoMask, psoAlpha, prclBounds);
                }
    
            if ((psoColor != NULL) && 
                (xloColor.pxlo()->flXlate & XO_TRIVIAL) &&
                (psoColor->iBitmapFormat == BMF_32BPP))
            {
                    EngEraseSurface(psoAlpha, &rclAlpha, 0);
    
                bAlpha = bApplicationAlphaCursor(psoAlpha, 
                                                 psoColor,
                                                 prclBounds);
            }

            if ((!bAlpha) && (bShadow))
            {
                EngEraseSurface(psoAlpha, &rclAlpha, 0);

                bAlpha = bShadowAlphaCursor(psoAlpha,
                                            psoMask,
                                            psoColor,
                                            xloMono.pxlo(),
                                            xloColor.pxlo(),
                                            prclBounds);
            }

            if (bAlpha)
            {
                SurfDimo.vKeepIt();
                SurfDimo.vSetPID(OBJECT_OWNER_PUBLIC);
                *phbmAlpha = (HBITMAP) SurfDimo.ps->hsurf();
            }
        }
    }
    }
}

/******************************Public*Routine******************************\
* vSetPointer
*
* Set the cursor shape, position and hot spot.
*
* History:
*  Sat 25-Apr-1998 -by- J. Andrew Goossen [andrewgo]
* Re-wrote it to handle sprites, shadows, and alpha cursors.
*
*  Sun 09-Aug-1992 -by- Patrick Haluptzok [patrickh]
* add engine pointer simulations, validate data from USER.
*
*  Tue 12-May-1992 01:49:04 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

VOID vSetPointer(HDEV hdev, PCURSINFO pci, ULONG fl, ULONG ulTrailLength, ULONG ulFreq)
{
    BOOL bShadow = (fl & SPS_ALPHA);
    PDEVOBJ po(hdev);

    ASSERTGDI(po.bValid() && !po.bMetaDriver(), "Invalid HDEV");

    if (po.bDisabled())
        return;

    // Perhaps we're being told to tear the pointer down.  

    if (pci == (PCURSINFO) NULL)
    {
        if (po.bSoftwarePointer())
        {
            EngSetPointerShape(po.pSurface()->pSurfobj(), NULL, NULL, 
                               NULL, 0, 0, 0, 0, NULL, 0);
        }
        if (po.bHardwarePointer())
        {
            PPFNDRV(po, MovePointer)(po.pSurface()->pSurfobj(), -1, -1, NULL);
        }

        po.bHardwarePointer(FALSE);
        po.bSoftwarePointer(FALSE);
        po.bMouseTrails(FALSE);

        return;
    }

    // OK, now we have some serious work to be done.  We have to have a mask.
    // Lock down and validate the cursor.

    SURFREF soMask((HSURF) pci->hbmMask);

    if (!soMask.bValid() || 
        (soMask.ps->iFormat() != BMF_1BPP) ||
        (soMask.ps->sizl().cy & 0x0001))
    {
        WARNING("GreSetPointer failed because of weird cursor\n");
        return;
    }

    XEPALOBJ    palSrc;
    XEPALOBJ    palDisp;
    XEPALOBJ    palDispDC(ppalDefault);

    SURFACE    *psurfColor = NULL;
    SURFACE    *psurfAlpha = NULL;
    XLATEOBJ   *pxlo = NULL;
    EXLATEOBJ   xlo;
    SURFREF     soColor;
    SURFREF     soAlpha;
    PPALETTE    ppalSrc;
    FLONG       flDriver;
    RECTL*      prclOpaqueBounds;
    RECTL       rclAlphaBounds;

    // We can reference pSurface() only once the Devlock is acquired,
    // for dynamic mode changing.

    SURFOBJ* psoDisplay = po.pSurface()->pSurfobj();

    if (pci->hbmColor)
    {
        soColor.vAltCheckLock((HSURF) pci->hbmColor);

        if (soColor.bValid())
        {
            if (soColor.ps->sizl().cy != (soMask.ps->sizl().cy >> 1))
            {
                WARNING("GreSetPointer failed color not half height mask\n");
                return;
            }

            // Handle the weird case where we get a compatible bitmap created
            // for the parent:

            ppalSrc = soColor.ps->ppal();
            if ((ppalSrc == NULL) && (po.hdevParent() != po.hdev()))
            {
                PDEVOBJ poParent(po.hdevParent());
                ppalSrc = poParent.ppalSurf();
            }

            if (!bIsCompatible(&ppalSrc, ppalSrc, soColor.ps, po.hdev()))
            {
                WARNING("GreSetPointer failed - bitmap not compatible with surface\n");
                return;
            }

            palSrc.ppalSet(ppalSrc);
            palDisp.ppalSet(po.ppalSurf());

            if (xlo.bInitXlateObj(NULL, DC_ICM_OFF, palSrc, palDisp, palDispDC,
                                  palDispDC, 0x000000L, 0xFFFFFFL, 0))
            {
                pxlo = xlo.pxlo();
                psurfColor = soColor.ps;
            }
        }
    }

    // If we've never seen this cursor before, compute the bounds and
    // create the alpha shadow if necessary.

    prclOpaqueBounds = (RECTL*) &pci->rcBounds;
    if ((prclOpaqueBounds->bottom == 0) ||
        ((pci->CURSORF_flags & CURSORF_SHADOW) && !bShadow) ||
        (!(pci->CURSORF_flags & CURSORF_SHADOW) && bShadow))
    {
        vProcessCursorShape(hdev,
                            bShadow,
                            soMask.pSurfobj(),
                            psurfColor->pSurfobj(),
                            ppalSrc,
                            (RECTL*) &pci->rcBounds,
                            (HBITMAP*) &pci->hbmAlpha);

        if (bShadow)
        {
            pci->CURSORF_flags |= CURSORF_SHADOW;
        }
        else
        {
            pci->CURSORF_flags &= ~CURSORF_SHADOW;
        }
    }
    
    // Ignore the alpha flag now and use the existence of 'hbmAlpha' to
    // determine whether the cursor should use the pre-generated alpha 
    // surface.

    fl &= ~SPS_ALPHA;

    if ((pci->hbmAlpha != NULL) && (po.iDitherFormat() > BMF_8BPP))
    {
        soAlpha.vAltCheckLock((HSURF) pci->hbmAlpha);
        psurfAlpha = soAlpha.ps;

        rclAlphaBounds.left   = pci->rcBounds.left;
        rclAlphaBounds.top    = pci->rcBounds.top;
        rclAlphaBounds.right  = pci->rcBounds.right  
                              + SHADOW_X_OFFSET + (2 * ALPHA_EDGE);
        rclAlphaBounds.bottom = pci->rcBounds.bottom 
                              + SHADOW_Y_OFFSET + (2 * ALPHA_EDGE);

        // Trim off the outside edge on all sides, which was used only
        // temporarily by the bBlurCursorShadow routine.

        rclAlphaBounds.left++;
        rclAlphaBounds.top++;
        rclAlphaBounds.right--;
        rclAlphaBounds.bottom--;
    }

    ULONG iMode;
    LONG xPointer;
    LONG yPointer;
    RECTL rclBoundsCopy;
    BOOL bHardwarePointer;
    BOOL bSoftwarePointer;
    BOOL bSynchronousPointer;
    BOOL bMouseTrails;

    if (!po.bDisabled())
    {
        po.ptlHotSpot(pci->xHotspot, pci->yHotspot);

        xPointer = po.ptlPointer().x;
        yPointer = po.ptlPointer().y;

        flDriver = SPS_CHANGE | (fl & (SPS_ANIMATESTART | SPS_ANIMATEUPDATE));

        bHardwarePointer = FALSE;
        bSoftwarePointer = TRUE;
        bMouseTrails = FALSE;
        bSynchronousPointer = FALSE;

        if(ulTrailLength != 0 && ulFreq != 0)
        {
            ulTrailLength = MIN(ulTrailLength, 16);
            ulFreq = MIN(ulFreq, 255);
            flDriver |= ((ulTrailLength << 8) & SPS_LENGTHMASK);
            flDriver |= ((ulFreq <<12) & SPS_FREQMASK);
            bMouseTrails = TRUE;
        }

        if (PPFNVALID(po, SetPointerShape) &&
            (!bMouseTrails || (po.flGraphicsCaps2() & GCAPS2_MOUSETRAILS)) )
        {
            // Give the hardware the first crack at the alpha surface (if
            // there is one).

            if (psurfAlpha != NULL)
            {
                if (po.flGraphicsCaps2() & GCAPS2_ALPHACURSOR)
                {
                    rclBoundsCopy = rclAlphaBounds;
                    iMode = PPFNDRV(po, SetPointerShape)
                                            (psoDisplay,
                                             NULL,
                                             psurfAlpha->pSurfobj(),
                                             NULL,
                                             pci->xHotspot + ALPHA_EDGE,
                                             pci->yHotspot + ALPHA_EDGE,
                                             xPointer,
                                             yPointer,
                                             &rclBoundsCopy,
                                             flDriver | SPS_ALPHA);

                    // SPS_ACCEPT_EXCLUDE is obsolete ... force software
                    // iMode is now treated as a set of flags

                    if(iMode == SPS_ACCEPT_EXCLUDE)
                        bHardwarePointer = FALSE;
                    else
                        bHardwarePointer = (iMode & SPS_ACCEPT_NOEXCLUDE ? TRUE : FALSE);

                    bSoftwarePointer = !bHardwarePointer;

                    bSynchronousPointer = (iMode & SPS_ACCEPT_SYNCHRONOUS ? TRUE : FALSE);

                }
            }
            else
            {
                // Handle the normal, no-alpha, cursor case:

                rclBoundsCopy = *prclOpaqueBounds;
                iMode = PPFNDRV(po, SetPointerShape)
                                        (psoDisplay,
                                         soMask.pSurfobj(),
                                         psurfColor->pSurfobj(),
                                         pxlo,
                                         pci->xHotspot,
                                         pci->yHotspot,
                                         xPointer,
                                         yPointer,
                                         &rclBoundsCopy,
                                         flDriver);

                // Since the introduction of 'sprites', we no longer 
                // support SPS_ACCEPT_EXCLUDE.  
    
                if (iMode == SPS_ACCEPT_EXCLUDE)
                {
                    PPFNDRV(po, MovePointer)(psoDisplay, -1, -1, NULL);
                    iMode = SPS_DECLINE;
                }

                bHardwarePointer = (iMode & SPS_ACCEPT_NOEXCLUDE ? TRUE : FALSE);

                bSoftwarePointer = !bHardwarePointer;

                bSynchronousPointer = (iMode & SPS_ACCEPT_SYNCHRONOUS ? TRUE : FALSE);
            }
        }

        if (bSoftwarePointer)
        {
            if (psurfAlpha != NULL)
            {
                EngSetPointerShape(psoDisplay,
                                   NULL,
                                   psurfAlpha->pSurfobj(),
                                   NULL,
                                   pci->xHotspot + ALPHA_EDGE,
                                   pci->yHotspot + ALPHA_EDGE,
                                   xPointer,
                                   yPointer,
                                   &rclAlphaBounds,
                                   flDriver | SPS_ALPHA);
            }
            else
            {
                EngSetPointerShape(psoDisplay,
                                   soMask.pSurfobj(),
                                   psurfColor->pSurfobj(),
                                   pxlo,
                                   pci->xHotspot,
                                   pci->yHotspot,
                                   xPointer,
                                   yPointer,
                                   prclOpaqueBounds,
                                   flDriver);
            }
        }

        if ((!bSoftwarePointer) && (po.bSoftwarePointer()))
        {
            // Turn off software cursor:

            EngMovePointer(psoDisplay, -1, -1, NULL);
        }
        if ((!bHardwarePointer) && (po.bHardwarePointer()))
        {
            // Turn off hardware cursor:

            PPFNDRV(po, MovePointer)(psoDisplay, -1, -1, NULL);
        }

        po.bSoftwarePointer(bSoftwarePointer);
        po.bHardwarePointer(bHardwarePointer);
        po.bMouseTrails(bMouseTrails);

        // Synchronous pointer flag forces synchronization of pointer even if
        // GCAPS_ASYNCMOVE was specified allowing drivers to accept some pointers
        // but have them drawn synchronously.

        po.bSynchronousPointer(bSynchronousPointer);
    }
}

/******************************Public*Routine******************************\
* vMovePointer
*
* Move the Pointer to the specified location.  This is called only by
* USER.
*
* History:
*  Thu 14-Apr-1994 -by- Patrick Haluptzok [patrickh]
* Optimize / make Async pointers work
*
* See GreMovePointer for info on ulFlags
* 
*  Tue 12-May-1992 02:11:51 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

VOID vMovePointer(HDEV hdev, int x, int y, LONG ulFlags)
{
    RECTL  *prcl;
    SURFOBJ *pso;

    PDEVOBJ po(hdev);
    ASSERTGDI(po.bValid() && !po.bMetaDriver(), "Invalid HDEV");

    // bDisabled can't change with hsemDevLock and hsemPointer both held.
    // bPtrHidden can't change unless hsemPointer is held if the
    // pointer is currently Async and the device supports Async movement.

    if ((po.ptlPointer().x != x) || (po.ptlPointer().y != y) || po.bMouseTrails())
    {
        po.ptlPointer(x, y);
        
        if (!po.bDisabled())
        {
            pso = po.pSurface()->pSurfobj();
    
            if (po.bHardwarePointer())
            {
                if (!PPFNVALID(po, MovePointerEx))
                {
                    PPFNDRV(po, MovePointer)(pso, x, y, NULL);
                }
                else
                {
                    // Use the Ex entry point to pass additional info
                    // to the driver. E.g. TS uses this to pass source
                    // information about mouse moves so that programmatic
                    // mouse moves that originate at the server are always
                    // sent down to the client.

                    PPFNDRV(po, MovePointerEx)(pso, x, y, ulFlags);
                }
            }
    
            if (po.bSoftwarePointer())
            {
                EngMovePointer(pso, x, y, NULL);
            }

            // Panning drivers want to see the pointer update even
            // if the pointer isn't enabled, because the position
            // is used to update the visible rectangle within the
            // virtual desktop space.
            //
            // Note: There are cases where ntuser will turn off the
            // cursor expecting us to ignore pointer moves.
            // Unfortunately, this can happen during mode changes where
            // ntuser may have a temporarily bigger desktop than
            // physically exists in ntgdi. Therefore, we must check
            // the pointer position against the virtual desktop bounds.

            if ((po.flGraphicsCaps() & GCAPS_PANNING) && (y != -1) &&
                (x < pso->sizlBitmap.cx) && (y < pso->sizlBitmap.cy))
            {
                // The driver wants to be notified of the pointer
                // position even if a pointer isn't actually visible
                // (invisible panning!).  Let it know the pointer is
                // still turned off by giving it a negative 'y':
    
                PPFNDRV(po, MovePointer)(pso, x, y - pso->sizlBitmap.cy, NULL);
            }
        }
    }
}

/******************************Public*Routine******************************\
* GreSetPointer
*
* Set the cursor shape and hot spot.
*
\**************************************************************************/

VOID GreSetPointer(HDEV hdev, PCURSINFO pci, ULONG fl, ULONG ulTrailLength, ULONG ulFreq)
{
    PVDEV       pvdev;
    PDISPSURF   pds;
    LONG        csurf;

    PDEVOBJ po(hdev);

    DEVLOCKOBJ dlo(po);
    SEMOBJ so(po.hsemPointer());

    // Just pass directly to 'bSetPointer' when not running multi-mon:

    if (!po.bMetaDriver())
    {
        vSetPointer(hdev, pci, fl, ulTrailLength, ulFreq);
    }
    else
    {
        // Okay, we've got work to do.
    
        pvdev = (VDEV*) po.dhpdev();
        pds   = pvdev->pds;
        csurf = pvdev->cSurfaces;

        do {
            vSetPointer(pds->hdev, pci, fl, ulTrailLength, ulFreq);

            pds = pds->pdsNext;
        } while (--csurf);
    }
}

/******************************Public*Routine******************************\
* GreMovePointer
*
* Set the cursor position.
*
*
* ulFlags specified additional information about the move.
* E.g. Termsrv uses this to determine when to send updates to the client.
*
* If you make a programmatic mouse move that originates at the server
* use MP_PROCEDURAL
*
*
\**************************************************************************/

VOID GreMovePointer(HDEV hdev, int x, int y, ULONG ulFlags)
{
    GDIFunctionID(GreMovePointer);

    PVDEV       pvdev;
    PDISPSURF   pds;
    LONG        csurf;
    BOOL        bUnlockBoth = FALSE;

    PDEVOBJ po(hdev);
 
    // If the driver has indicated it has bAsyncPointerMove capabilities
    // and it currently is managing the pointer, and the pointer is
    // supported in hardware so it doesn't need to be excluded
    // (indicated by bPtrNeedsExcluding) then we only need to grab the pointer
    // mutex which is only grabbed by people trying to make the pointer
    // shape change and a few other odd ball places.
    //
    // Otherwise we grab the DEVLOCK and the pointer mutex which
    // ensures nobody else is drawing, changing the pointer shape,
    // etc.

    if (po.bAsyncPointerMove() && !po.bSoftwarePointer())
    {
        //
        // Note: We pass in NULL for parent semaphore here because we have
        // no yet acquired the dev lock and thus under global ordering
        // restrictions.
        //

        GreAcquireSemaphoreEx(po.hsemPointer(), SEMORDER_POINTER, NULL);

        // Make sure we really got it, bAsyncPointerMove may change if you
        // don't hold the DEVLOCK or the POINTER mutex.

        if (!po.bAsyncPointerMove() || po.bSoftwarePointer())
        {
            // Release and regrab everything, for sure we are safe with
            // both of them.

            GreReleaseSemaphoreEx(po.hsemPointer());
            GreAcquireSemaphoreEx(po.hsemDevLock(), SEMORDER_DEVLOCK, NULL);
            GreAcquireSemaphoreEx(po.hsemPointer(), SEMORDER_POINTER, po.hsemDevLock());
            bUnlockBoth = TRUE;
        }
    }
    else
    {
        GreAcquireSemaphoreEx(po.hsemDevLock(), SEMORDER_DEVLOCK, NULL);
        GreAcquireSemaphoreEx(po.hsemPointer(), SEMORDER_POINTER, po.hsemDevLock());
        bUnlockBoth = TRUE;
    }

    GreEnterMonitoredSection(po.ppdev, WD_POINTER);

    // Just pass directly to 'vMovePointer' when not running multi-mon:

    if (!po.bMetaDriver())
    {
        vMovePointer(hdev, x, y, ulFlags);
    }
    else
    {
        // Okay, we've got work to do.
    
        pvdev = (VDEV*) po.dhpdev();
        pds   = pvdev->pds;
        csurf = pvdev->cSurfaces;
    
        do {
            if ((x >= pds->rcl.left)  &&
                (x <  pds->rcl.right) &&
                (y >= pds->rcl.top)   &&
                (y <  pds->rcl.bottom))
            {
                vMovePointer(pds->hdev, x - pds->rcl.left, y - pds->rcl.top,
                             ulFlags);
            }
            else
            {
                vMovePointer(pds->hdev, -1, -1,
                             ulFlags);
            }

            pds = pds->pdsNext;
        } while (--csurf);
    }
    
    po.ptlPointer(x, y);

    GreExitMonitoredSection(po.ppdev, WD_POINTER);
    GreReleaseSemaphoreEx(po.hsemPointer());
    if (bUnlockBoth)
    {
        GreReleaseSemaphoreEx(po.hsemDevLock());
    }
}

/******************************Public*Routine******************************\
* EngSetPointerTag
*
* This is the engine entry point that allows device drivers to create a
* 'tag' that will be combined with the pointer shape whenever it's sent
* to other drivers in the DDML chain via the DrvSetPointerShape call.
*
* This functionality is primarily intended to allow remoting DDML drivers
* to allow a name be added to the pointer to signify who owns 'control' of
* the machine's input.  But they don't want to transmit the shape with the
* name over the wire, which is why we adopt the convention that this applies
* to every *other* device in the DDML chain.
*
* History:
*  20-Oct-1996 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL EngSetPointerTag(
HDEV        hdev,           // Identifies device's PDEV.  This is not the MDEV!
SURFOBJ*    psoInputMask,   // May be NULL when resetting the tag
SURFOBJ*    psoInputColor,  // Will be NULL if monochrome
XLATEOBJ*   pxlo,           // Reserved, must be NULL for now
FLONG       fl)             // Reserved, must be zero for now
{
    // We shipped NT4 SP3 with this functionality, but it's obsolete as
    // of NT5.

    return(FALSE);
}

/******************************Public*Routine******************************\
* DEVLOCKOBJ::bLock
*
* Device locking object.  Optionally computes the Rao region.
*
* History:
*  Sun 30-Aug-1992 -by- Patrick Haluptzok [patrickh]
* change to boolean return
*
*  Mon 27-Apr-1992 22:46:41 -by- Charles Whitmer [chuckwh]
* Clean up again.
*
*  Tue 16-Jul-1991 -by- Patrick Haluptzok [patrickh]
* Clean up.
*
*  15-Sep-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL DEVLOCKOBJ::bLock(XDCOBJ& dco)
{
    GDIFunctionID(DEVLOCKOBJ::bLock);

    hsemTrg  = NULL;         // Remember the semaphore we're waiting on.
    ppdevTrg = NULL;         // Remember pdev we're monitoring.
    fl       = DLO_VALID;    // Remember if it is valid.

    // We lock the semphore on direct display DCs and DFB's if
    // the device has set GCAPS_SYNCHRONIZEACCESS set.

    if (dco.bSynchronizeAccess())
    {
        // make sure we don't have any wrong sequence of acquiring locks
        // should always acquire a DEVLOCK before we have the palette semaphore

       ASSERTGDI ( (!GreIsSemaphoreOwnedByCurrentThread(ghsemPalette)) 
                || (GreIsSemaphoreOwnedByCurrentThread(dco.hsemDcDevLock())),
          "potential deadlock!\n");

        // Grab the display semaphore

        if(dco.bShareAccess())
        {
            GreAcquireSemaphoreShared(ghsemShareDevLock);
            fl |= DLO_SHAREDACCESS;
        }
        else
        {
            hsemTrg  = dco.hsemDcDevLock();
            ppdevTrg = dco.pdc->ppdev();
            GreAcquireSemaphoreEx(hsemTrg, SEMORDER_DEVLOCK, NULL);
            GreEnterMonitoredSection(ppdevTrg, WD_DEVLOCK);
        }

        if (dco.pdc->bInFullScreen())
        {
            fl &= ~(DLO_VALID);
            return(FALSE);
        }
    }

    // Compute the new Rao region if it's dirty.

    if (dco.pdc->bDirtyRao())
    {
        if (!dco.pdc->bCompute())
        {
            fl &= ~(DLO_VALID);
            return(FALSE);
        }
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* DEVLOCKOBJ::vLockNoDrawing
*
* Device locking object for when no drawing will take place.
*
* Used primarily to protect against dynamic mode changing when looking at
* surface fields.  Because no drawing will take place, the rao region
* computations and full-screen checks need not be made.
*
* History:
*  Thu 8-Feb-1996 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID DEVLOCKOBJ::vLockNoDrawing(XDCOBJ& dco)
{
    GDIFunctionID(DEVLOCKOBJ::vLockNoDrawing);

    hsemTrg  = NULL;         // Remember the semaphore we're waiting on.
    ppdevTrg = NULL;         // Remember pdev we're monitoring.
    fl       = DLO_VALID;    // Remember if it is valid.

    // We lock display DC's even if bSynchronizeAccess() isn't set so that
    // the surface palette will still be locked down even for device-
    // dependent-bitmaps.

    PDEVOBJ po(dco.hdev());

    if (po.bDisplayPDEV())
    {
        // Grab the display semaphore

        hsemTrg  = dco.hsemDcDevLock();
        ppdevTrg = dco.pdc->ppdev();
        GreAcquireSemaphoreEx(hsemTrg, SEMORDER_DEVLOCK, NULL);
        GreEnterMonitoredSection(ppdevTrg, WD_DEVLOCK);
    }
}

/******************************Public*Routine******************************\
* DEVLOCKBLTOBJ::bLock
*
* Device locking object.  Optionally computes the Rao region.
*
* History:
*  Sun 30-Aug-1992 -by- Patrick Haluptzok [patrickh]
* change to boolean return
*
*  Mon 27-Apr-1992 22:46:41 -by- Charles Whitmer [chuckwh]
* Clean up again.
*
*  Tue 16-Jul-1991 -by- Patrick Haluptzok [patrickh]
* Clean up.
*
*  15-Sep-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL DEVLOCKBLTOBJ::bLock(XDCOBJ& dco)
{
    GDIFunctionID(DEVLOCKBLTOBJ::bLock);

    hsemTrg  = NULL;        // Remember the semaphore we're waiting on.
    hsemSrc  = NULL;        // Remember the semaphore we're waiting on.
    ppdevTrg = NULL;        // Remember pdev we're monitoring.
    ppdevSrc = NULL;        // Remember pdev we're monitoring.
    fl       = DLO_VALID;   // Remember if it is valid.

    // We lock the semphore on direct display DCs and DFB's if
    // the device has set GCAPS_SYNCHRONIZEACCESS set.

    if (dco.bSynchronizeAccess())
    {
        // Grab the display semaphore

        if(dco.bShareAccess())
        {
            GreAcquireSemaphoreShared(ghsemShareDevLock);
            fl |= DLO_SHAREDACCESS;
        }
        else
        {
            hsemTrg  = dco.hsemDcDevLock();
            ppdevTrg = dco.pdc->ppdev();
            GreAcquireSemaphoreEx(hsemTrg, SEMORDER_DEVLOCK, NULL);
            GreEnterMonitoredSection(ppdevTrg, WD_DEVLOCK);
        }

        // Check if we are in full screen and drawing
        // to the Display, this may just be a DFB.

        if (dco.bInFullScreen())
        {
            fl &= ~(DLO_VALID);
            return(FALSE);
        }
    }

    // Compute the new Rao region if it's dirty.

    if (dco.pdc->bDirtyRao())
    {
        if (!dco.pdc->bCompute())
        {
            fl &= ~(DLO_VALID);
            return(FALSE);
        }
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* DEVLOCKBLTOBJ::bLock
*
* Lock both a source and target DC.  Used by StretchBlt, PlgBlt and such.
*
* We must check to see if we are in full screen and fail if we are.
*
* History:
*  Mon 18-Apr-1994 -by- Patrick Haluptzok [patrickh]
* bSynchronize Checks
*
*  16-Feb-1993 -by-  Eric Kutter [erick]
* Added full screen checks
*
*  11-Nov-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL DEVLOCKBLTOBJ::bLock(XDCOBJ& dcoTrg, XDCOBJ& dcoSrc)
{
    GDIFunctionID(DEVLOCKBLTOBJ::bLock);

    hsemTrg  = NULL;
    hsemSrc  = NULL;
    ppdevTrg = NULL;        // Remember pdev we're monitoring.
    ppdevSrc = NULL;        // Remember pdev we're monitoring.
    fl       = DLO_VALID;

    if(dcoSrc.bShareAccess() || dcoTrg.bShareAccess())
    {
        GreAcquireSemaphoreShared(ghsemShareDevLock);
        fl |= DLO_SHAREDACCESS;
    }

    if (dcoSrc.bSynchronizeAccess())
    {
        // Grab the display semaphore

        if(!dcoSrc.bShareAccess())
        {
            hsemSrc  = dcoSrc.hsemDcDevLock();
            ppdevSrc = dcoSrc.pdc->ppdev();
            GreAcquireSemaphoreEx(hsemSrc, SEMORDER_DEVLOCK, NULL);
            GreEnterMonitoredSection(ppdevSrc, WD_DEVLOCK);
        }

        // Check if we are in full screen and drawing
        // to the Display, this may just be a DFB.

        if (dcoSrc.bInFullScreen())
        {
            fl &= ~(DLO_VALID);
            return(FALSE);
        }
    }

    if (dcoTrg.bSynchronizeAccess())
    {
        // Grab the display semaphore

        if(!dcoTrg.bShareAccess())
        {
            hsemTrg  = dcoTrg.hsemDcDevLock();
            ppdevTrg = dcoTrg.pdc->ppdev();
            GreAcquireSemaphoreEx(hsemTrg, SEMORDER_DEVLOCK, NULL);
            GreEnterMonitoredSection(ppdevTrg, WD_DEVLOCK);
        }

        // Check if we are in full screen and drawing
        // to the Display, this may just be a DFB.

        if (dcoTrg.bInFullScreen())
        {
            fl = 0;
            return(FALSE);
        }
    }

    // Compute the new Rao regions.

    if (dcoTrg.pdc->bDirtyRao())
    {
        if (!dcoTrg.pdc->bCompute())
        {
            fl &= ~(DLO_VALID);
            return(FALSE);
        }
    }

    if (dcoSrc.pdc->bDirtyRao())
    {
        if (!dcoSrc.pdc->bCompute())
        {
            fl &= ~(DLO_VALID);
            return(FALSE);
        }
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\cliserv.h ===
/******************************Module*Header*******************************\
* Module Name: cliserv.h
*
*
* Copyright (c) 1997-1999 Microsoft Corporation
*
\**************************************************************************/

typedef struct _CLISERV {
             CSOBJ   Object;        // public's view of this
             KEVENT  ServerEvent;   // server waits on this
             KEVENT  ClientEvent;   // client waits on this
    struct _CLISERV *pNext;         // pointer to next in linked list
          COPY_PROC *pfnCopy;       // pointer to copy function
              PVOID  pvCopyArg;     // to be passed to copy function
        CLIENT_PROC *pfnClient;     // pointer to client function
              PVOID  pvClientArg;   // to be passed to client fucntion
         HSEMAPHORE  hsem;          // serializes client access
          PEPROCESS  pServerProcess;// pointer to server process
           PETHREAD  pServerThread; // for debugging purposes
           struct {
               unsigned int waitcount : 31; // # processes waiting on hsem
               unsigned int isDead    : 1;  // signals death
           } state;
           PROXYMSG  *pMsg;          // supplied by server
} CLISERV;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\dcgdi.cxx ===
/******************************Module*Header*******************************\
* Module Name: dcgdi.cxx
*
* APIs for GDI DC component
*
* Created: 13-Aug-1990 00:15:53
* Author: Donald Sidoroff [donalds]
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

BOOL bSavePath(XDCOBJ& dco, LONG lSave);
BOOL bSaveRegion(DCOBJ&, LONG);

VOID vRestorePath(XDCOBJ& dco, LONG lSave);
VOID vRestoreRegion(DCOBJ&, LONG);

typedef BOOL (*SFN)(DCOBJ&, LONG);      // Save function type
typedef VOID (*RFN)(DCOBJ&, LONG);      // Restore function type

/******************************Public*Routine******************************\
* bDeleteDCInternal
*
*   bForce - This is set to TRUE when user calls through GreDeleteDC and
*            FALSE when the app calls through th client server window
*
* API entry point to delete a DC.
*
* History:
*  Thu 12-Sep-1991 -by- Patrick Haluptzok [patrickh]
* clean it up, query User for deletability, cascade if's for code size.
*
*  Fri 12-Jul-1991 -by- Patrick Haluptzok [patrickh]
* added deletion of regions
*
*  18-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL
bDeleteDCInternal(
    HDC hdc,
    BOOL bForce,
    BOOL bProcessCleanup)
{
    BOOL bReturn = FALSE;

    // Lock it down, since this is an API lock no apps can get at it.  We just
    // have to worry about USER having it Alt-locked now.

    DCOBJ  dco(hdc);

    if (dco.bValid())
    {
        // We can do a cleanDC without affecting USER.

        dco.bCleanDC();

        // Check if User has marked the DC as undeletable or bForce is set.
        // bForce should only be set when user asks us to delete the dc.

        if (bForce || dco.bIsDeleteable())
        {
            // free client attr

            if (!bProcessCleanup)
            {
                GreFreeDCAttributes(hdc);
            }

            // ASSERTGDI(dco.bIsDeleteable(), "User is freeing an undeletable DC");
            // Decrement the reference count on the brushes in the old DC.

            // we do not dec the ref cnt of a brush from the client side
            // since sync brush never inc the ref cnt

            DEC_SHARE_REF_CNT_LAZY0(dco.pdc->pbrushFill());
            DEC_SHARE_REF_CNT_LAZY0(dco.pdc->pbrushLine());

            // We now need to do the same thing for the selected font

            DEC_SHARE_REF_CNT_LAZY_DEL_LOGFONT(dco.pdc->plfntNew());

            // And then color space, too

            DEC_SHARE_REF_CNT_LAZY_DEL_COLORSPACE(dco.pdc->pColorSpace());

            // Ok we are golden now.  User has no holds on this DC.
            // Remember our PDEV.

            PDEVOBJ po(dco.hdev());

            dco.pdc->vReleaseVis();
            dco.pdc->vReleaseRao();

            if (dco.pdc->prgnRao())
            {
                dco.pdc->prgnRao()->vDeleteREGION();
            }

            // Free the memory for the DC.  We don't even need to do this
            // under a multi-lock because we have an API lock so no other
            // App threads can come in and User has said that it is deleteable
            // and they are the only dudes who could get us with an Alt-Lock.

            // we may still hold a dc lock when the user mode printer driver
            // abnomally terminates.  Ignore the counts.

            if (!po.bUMPD())
            {
                ASSERTGDI(HmgQueryLock((HOBJ)hdc) == 1, "bDeleteDC cLock != 1");
                ASSERTGDI(HmgQueryAltLock((HOBJ)hdc) == 0, "bDeleteDC cAltLock != 0");
            }

            // delete DC from handle manager.

            dco.bDeleteDC(bProcessCleanup);

            // Remove the reference to the PDEV.

            po.vUnreferencePdev(bProcessCleanup ? CLEANUP_PROCESS
                                                : CLEANUP_NONE);

            // Return success.

            bReturn = TRUE;
        }
        else
        {
            // User now maps CreateDC -> GetDC so that all DC's get clipped
            // to the same Desktop.  We now have to check here and give User
            // a chance to clean it up.

            dco.vUnlock();

            if (UserReleaseDC(hdc))
            {
                bReturn = TRUE;
            }
            else
            {
                WARNING("FAILED to delete because it is a NON-DeletableDC\n");
            }
        }
    }
    else
    {
    // Some other thread has it locked down so fail.

        SAVE_ERROR_CODE(ERROR_BUSY);
    }

    return(bReturn);
}

BOOL
GreDeleteDC(
    HDC hdc)
{
    return(bDeleteDCInternal(hdc,TRUE,FALSE));
}

/******************************Public*Routine******************************\
* BOOL GreRestoreDC(hdc, lDC)
*
* Restore the DC.
*
* History:
*  Mon 15-Jul-1991 -by- Patrick Haluptzok [patrickh]
* bug fix, delete the DC when done with it.
*
*  Tue 18-Jun-1991 -by- Patrick Haluptzok [patrickh]
* added the brush, palette, pen, and bitmap cases.
*
*  13-Aug-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL GreRestoreDC(HDC hdc,int lDC)
{
    DCOBJ   dco(hdc);                       // Lock the DC
    BOOL    bRet = TRUE;

    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        bRet = FALSE;
    }
    else
    {
        // !! What the heck is this SYNC_DRAWING_ATTRS doing here?

        SYNC_DRAWING_ATTRS(dco.pdc);

        if (lDC < 0)
            lDC += (int)dco.lSaveDepth();

        if ((lDC < 1) || (lDC >= dco.lSaveDepth()))
        {
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            bRet = FALSE;
        }
        else
        {
            PDEVOBJ po(dco.hdev());

            // Acquire the devlock here to protect against dynamic mode changes
            // that affect the device palette.  This also protects us if the
            // bitmap which selected in DC, is a Device Format Bitmap that is
            // owned by the display driver.

            DEVLOCKOBJ dlo(po);

            // Acquire the semaphore palette to be symmetrical with GreSaveDC
            // and to protect the dynamic mode change code as it walks all
            // the DC's, so that its changes don't get wiped out by the
            // vCopyTo we're about to do.

            SEMOBJ semo(ghsemPalette);

            // if we are printing using a TempInfoDC, save it.  Since there is only one
            // of these that does not sit in the dclevel, we save and restore this state
            // accross save/restoreDC

            BOOL bTempInfoDC = dco.pdc->bTempInfoDC();

            if (bTempInfoDC)
                dco.pdc->bMakeInfoDC(FALSE);

            // Remember current mapping mode.

            ULONG ulMapModeDC = dco.pdc->ulMapMode();

            do
            {
                // Decrement the reference count on the brushes in the old DC.
                // We do not DEC the ref cnt of a brush from the client side
                // since sync brush never INCs the ref cnt

                DEC_SHARE_REF_CNT_LAZY0(dco.pdc->pbrushFill());
                DEC_SHARE_REF_CNT_LAZY0(dco.pdc->pbrushLine());

                // same thing for currently selected font:

                DEC_SHARE_REF_CNT_LAZY_DEL_LOGFONT(dco.pdc->plfntNew());

                // same thing for currently selected color space:

                DEC_SHARE_REF_CNT_LAZY_DEL_COLORSPACE(dco.pdc->pColorSpace());

                // Restore Regions and Paths.

                vRestoreRegion(dco, dco.lSaveDepth() - 1);
                vRestorePath(dco, dco.lSaveDepth() - 1);

                // Restore the bitmaps if necesary.

                if (dco.dctp() == DCTYPE_MEMORY)
                {
                    hbmSelectBitmap(hdc, STOCKOBJ_BITMAP, TRUE);
                }

                // Bug #223129:  We need to get a lock on the saved DC even when the process
                // has reached its handle quota (this is OK because the saved DC is about to
                // be deleted anyway).  This is accomplished using the vLockAllOwners method
                // of the DCOBJ.

                DCOBJ dcoSaved;
                dcoSaved.vLockAllOwners(dco.hdcSave());

                ASSERTGDI(dcoSaved.bValid(),"GreRestoreDC(): dcoSaved is invalid\n");

                // Select the palette in if necessary.  This will put the palette back in
                // the DC chain.

                if (dco.hpal() != dcoSaved.hpal())
                {
                    GreSelectPalette((HDC)hdc, (HPALETTE)dcoSaved.ppal()->hGet(), TRUE);
                }
                else
                {
                    // hpals are equal:
                    //
                    // ResizePalette could have changed the ppal associated with the
                    // hpal, in this case fix the ppal

                    if (dco.ppal() != dcoSaved.ppal())
                    {
                        EPALOBJ palRestore((HPALETTE)dco.hpal());

                        if (dco.ppal() != palRestore.ppalGet())
                        {
                            RIP("GRE RestoreDC - hpal and ppal in invalid state");
                        }

                        // fix ppal in dcoSaved

                        dcoSaved.pdc->ppal(palRestore.ppalGet());
                    }
                }

                // Decrement its reference count if it's not the default palette.  We
                // inced it while it's in a saved DC level to prevent it from being deleted.

                if (dcoSaved.ppal() != ppalDefault)
                {
                    XEPALOBJ palTemp(dcoSaved.ppal());
                    palTemp.vDec_cRef();
                }

                // Update the DC with saved information, then delete the saved level.

                dcoSaved.pdc->vCopyTo(dco);
                dcoSaved.bDeleteDC();

            } while (lDC < dco.lSaveDepth());

            // if mapping mode has been changed, invalidate xform.

            if (ulMapModeDC != dco.pdc->ulMapMode())
                dco.pdc->vXformChange(TRUE);

            // if we are printing using a TempInfoDC, restore it

            if (bTempInfoDC)
                dco.pdc->bMakeInfoDC(TRUE);

            // Assume Rao has been made dirty by the above work.

            dco.pdc->vReleaseRao();
            dco.pdc->vUpdate_VisRect(dco.pdc->prgnVis());

            // Assume the brushes, charset, color space and color transform are dirty.

            dco.ulDirtyAdd(DIRTY_BRUSHES|DIRTY_CHARSET|DIRTY_COLORSPACE|DIRTY_COLORTRANSFORM);

            if (dco.dctp() == DCTYPE_MEMORY)
            {
                dco.pdc->bSetDefaultRegion();
            }

            // Correctly set the bit indicating whether or not we need to
            // grab the Devlock before drawing

            SURFACE *pSurfCurrent = dco.pSurface();

            //
            // Note that this condition should match that of GreSelectBitmap
            // for the memory DC case:
            //

            if (dco.bDisplay() ||
                ((dco.dctp() == DCTYPE_MEMORY) &&
                 (pSurfCurrent != NULL) &&
                 (
                  (pSurfCurrent->bUseDevlock()) ||
                  (pSurfCurrent->bDeviceDependentBitmap() && po.bDisplayPDEV())
                 )
                )
               )
            {
                dco.bSynchronizeAccess(TRUE);
                dco.bShareAccess(pSurfCurrent->bShareAccess());
            }
            else
            {
                dco.bSynchronizeAccess(FALSE);
            }

            // Update ptlFillOrigin accelerator

            dco.pdc->vCalcFillOrigin();
        }
    }

    return(bRet);
}

/*********************************Class************************************\
* class SAVEOBJ
*
* This is just a call to a save/restore function pair disguised to look
* like a memory object.  The restore will happen automagically when the
* scope is exitted, unless told not to do so.
*
* Note:
*   This is used only by GreSaveDC
*
* History:
*  23-Apr-1991 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

class SAVEOBJ   /* svo */
{
private:
    LONG    lLevel;
    BOOL    bSave;
    DCOBJ  *pdco;
    RFN     rfn;                    // Restore function

public:
    SAVEOBJ(DCOBJ& dco, LONG lLevel_, SFN sfn, RFN rfn_)
    {
        pdco = &dco;
        lLevel = lLevel_;
        rfn = rfn_;
        bSave = (*sfn)(dco, lLevel_ + 1);
    }

   ~SAVEOBJ()
    {
        if (bSave)
            (*rfn)(*pdco, lLevel);
    }

    BOOL bValid()                   { return(bSave); }
    VOID vKeepIt()                  { bSave = FALSE; }
};

/*********************************Class************************************\
* class DCMODOBJ
*
* This class modifies the given DC.  It will undo the modification, unless
* told to keep it.
*
* Note:
*   This is used only by GreSaveDC
*
* History:
*  23-Apr-1991 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

class DCMODOBJ  /* dcmod */
{
private:
    DCOBJ  *pdco;
    HDC     hdcSaveOld;

public:
    DCMODOBJ(DCOBJ& dco, HDC hdcSave)
    {
        pdco = &dco;
        hdcSaveOld = dco.hdcSave();
        dco.pdc->hdcSave(hdcSave);
    }

   ~DCMODOBJ()
    {
        if (pdco != (DCOBJ *) NULL)
            pdco->pdc->hdcSave(hdcSaveOld);
    }

    VOID vKeepIt()                  { pdco = (DCOBJ *) NULL; }
};

/******************************Public*Routine******************************\
* int GreSaveDC(hdc)
*
* Save the DC.
*
* History:
*  Tue 25-Jun-1991 -by- Patrick Haluptzok [patrickh]
* add saving bitmaps, palettes.
*
*  13-Aug-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

int GreSaveDC(HDC hdc)
{
    DCOBJ   dco(hdc);                       // Lock down the DC
    LONG    lSave;
    int     iRet = 0;

    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
    }
    else
    {
        SYNC_DRAWING_ATTRS(dco.pdc);

        PDEVOBJ po(dco.hdev());

    // Acquire the devlock here to protect against dynamic mode changes
    // that affect the device palette.  This also protects us if the
    // bitmap which selected in DC, is a Device Format Bitmap that is
    // owned by the display driver.

        DEVLOCKOBJ dlo(po);

    // We must grab the semaphore now so that ResizePalette doesn't
    // change the ppal in the DC before the copy is added to the list
    // off the palette.  Also grab it to prevent the dynamic mode
    // changing code from falling over when it traverses saved DCs.

        SEMOBJ semo(ghsemPalette);

    // if we are printing using a TempInfoDC, save it.  Since there is only one
    // of these that does not sit in the dclevel, we save and restore this state
    // accross save/restoreDC

        BOOL bTempInfoDC = dco.pdc->bTempInfoDC();

        if (bTempInfoDC)
            dco.pdc->bMakeInfoDC(FALSE);

        {
            DCMEMOBJ    dcmo(dco);              // Allocate RAM and copy the DC

            if (!dcmo.bValid())
            {
                SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
            }
            else
            {
                DCMODOBJ    dcmod(dco, dcmo.hdc());

                SAVEOBJ svoPath(dco, dcmo.lSaveDepth(), (SFN)bSavePath, (RFN)vRestorePath);

                if (svoPath.bValid())
                {
                    SAVEOBJ svoRgn(dco, dcmo.lSaveDepth(), bSaveRegion, vRestoreRegion);

                    if (svoRgn.bValid())
                    {
                    // we are done with the objects so we can now set the owner to none
                    // so this thing can't be deleted.

                        if (!GreSetDCOwner(dcmo.hdc(),OBJECT_OWNER_NONE))
                        {
                            WARNING("GreSaveDC - couldn't set owner\n");
                        }
                        else
                        {
                            // At this point we are golden.  No more errors can occur,
                            // so we mark all the things we've allocated as permanent.

                            svoRgn.vKeepIt();
                            svoPath.vKeepIt();
                            dcmod.vKeepIt();
                            dcmo.vKeepIt();

                            // Inc the surface ref count if appropriate

                            if (dcmo.pSurface() != (SURFACE *) NULL)
                            {
                                if ((!dcmo.pSurface()->bPDEVSurface()) && (!dcmo.pSurface()->bRedirection()))
                                {
                                    dcmo.pSurface()->vInc_cRef();
                                }
                            }

                            // Increment the reference count on the brushes we saved.
                            // No need to check ownership, since these are already
                            // selected in

                            INC_SHARE_REF_CNT(dco.pdc->pbrushFill());

                            INC_SHARE_REF_CNT(dco.pdc->pbrushLine());

                            // inc ref count for the font selected in the dc

                            INC_SHARE_REF_CNT(dco.pdc->plfntNew());

                            // int ref count for the color space selected in the dc

                            INC_SHARE_REF_CNT(dco.pdc->pColorSpace());

                            // Take care of the palette.
                            // Increment its reference count if it's not the default palette.  We
                            // inc it while it's in a saved DC level to prevent it from being deleted.

                            if (dco.ppal() != ppalDefault)
                            {
                                XEPALOBJ palTemp(dco.ppal());
                                ASSERTGDI(palTemp.bValid(), "ERROR SaveDC not valid palette");
                                palTemp.vInc_cRef();
                            }

                            // Increment and return the save level of the original DC.

                            lSave = dco.lSaveDepth();
                            dco.pdc->lIncSaveDepth();
                            iRet = (int)lSave;

                        }   // GreSetDCOwner
                    }       //
                }           // ~SAVEOBJ  svoRgn
            }                   // ~DCMODOBJ dcmod
        }                       // ~DCMEMOBJ dcmo

    // if we are printing using a TempInfoDC, restore it

        if (bTempInfoDC)
            dco.pdc->bMakeInfoDC(TRUE);
    }
    return(iRet);
}

/******************************Public*Routine******************************\
* BOOL GreSetDCOrg(hdc,x,y,prlc)
*
* Set the origin and optionally the window area of the DC.
*
* History:
*  19-Oct-1996 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL GreSetDCOrg(HDC hdc,LONG x,LONG y,PRECTL prcl)
{
    BOOL    bRet = FALSE;
    DCOBJA  dco(hdc);

    ASSERTDEVLOCK(dco.pdc);

    if (dco.bValid())
    {
        bRet = TRUE;

        dco.eptlOrigin().x = x;
        dco.eptlOrigin().y = y;
        dco.pdc->vCalcFillOrigin();

        if (prcl != NULL)
        {
            dco.erclWindow() = *(ERECTL *) prcl;
        }
    }

    return(bRet);
}
/******************************Public*Routine******************************\
* BOOL GreGetDCOrg(hdc,pptl)
*
* Get the origin of the DC.
*
* History:
*  Sun 02-Jan-1994 -by- Patrick Haluptzok [patrickh]
* smaller and faster
*
*  13-Aug-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL GreGetDCOrg(HDC hdc,LPPOINT pptl)
{
    return(GreGetDCPoint(hdc,DCPT_DCORG,(PPOINTL)pptl));
}

/******************************Public*Routine******************************\
* BOOL GreGetDCOrgEx(hdc,ppt,prcl)
*
* History:
*  12-Dec-1997 -by- Vadim Gorokhovsky [vadimg]
* Wrote it.
\**************************************************************************/

BOOL GreGetDCOrgEx(HDC hdc,PPOINT ppt,PRECT prc)
{
    DCOBJA  dco(hdc);

    if (dco.bValid())
    {
        *(ERECTL *)prc = dco.erclWindow();
        return(GreGetDCPoint(hdc,DCPT_DCORG,(PPOINTL)ppt));
    }
    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL GreGetBounds(hdc, prcl, fl)
*
* Return the current bounds information and reset the bounding area.
*
* WARNING: USER MUST HOLD THE DEVICE LOCK BEFORE CALLING THIS ROUTINE
*
* History:
*  28-Jul-1991 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL GreGetBounds(HDC hdc, LPRECT prcl, DWORD fl)
{
    DCOBJA  doa(hdc);
    ERECTL  erclScreen;
    BOOL    bEmpty;

    if (!doa.bValid())
    {
        bEmpty = TRUE;  // bEmpty == TRUE is the error condition
    }
    else
    {
        if (fl & GGB_ENABLE_WINMGR)
        {
            doa.fsSet(DC_ACCUM_WMGR);
        }
        else if (fl & GGB_DISABLE_WINMGR)
        {
            doa.fsClr(DC_ACCUM_WMGR);
        }

    // Get the state of the bounds rectangle

        bEmpty = (doa.erclBounds().bEmpty() ||
                  doa.erclBounds().bWrapped());

        if (!bEmpty)
        {
            if (prcl != (LPRECT) NULL)
            {
                erclScreen  = doa.erclBounds();
                erclScreen += doa.eptlOrigin();
                *prcl = *((LPRECT) &erclScreen);
            }

        // Force it to be empty

            doa.erclBounds().left   = POS_INFINITY;
            doa.erclBounds().top    = POS_INFINITY;
            doa.erclBounds().right  = NEG_INFINITY;
            doa.erclBounds().bottom = NEG_INFINITY;
        }
    }
    return(!bEmpty);
}

/******************************Public*Routine******************************\
* BOOL GreGetBoundsRect(hdc, prcl, fl)
*
* Return the current bounds info.
*
* History:
*  Thu 27-May-1993 -by- Patrick Haluptzok [patrickh]
* Change to exclusive lock, not a special User call.
*
*  06-Apr-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

DWORD GreGetBoundsRect(HDC hdc, LPRECT prcl, DWORD fl)
{
    DCOBJ  dco(hdc);
    DWORD  dwRet = DCB_SET;

    if (!dco.bValid())
    {
        dwRet = 0;
    }
    else
    {
        ERECTL *percl;

        if (fl & DCB_WINDOWMGR)
        {
            if (dco.erclBounds().bWrapped())
            {
                dwRet = DCB_RESET;
            }
            else
            {
                percl = &dco.erclBounds();
                *prcl = *((LPRECT) percl);
            }
        }
        else
        {
            if (dco.erclBoundsApp().bWrapped())
            {
                dwRet = DCB_RESET;
            }
            else
            {
                DEVLOCKOBJ  dlo(dco);

                if (!dlo.bValid())
                {
                    dwRet = dco.bFullScreen() ? DCB_RESET : 0;
                }
                else
                {
                    RGNOBJ  ro(dco.prgnEffRao());
                    ERECTL  ercl;

                    ro.vGet_rcl(&ercl);
                    ercl -= dco.eptlOrigin();
                    percl = &dco.erclBoundsApp();

                    prcl->left   = MAX(percl->left,   ercl.left);
                    prcl->right  = MIN(percl->right,  ercl.right);
                    prcl->top    = MAX(percl->top,    ercl.top);
                    prcl->bottom = MIN(percl->bottom, ercl.bottom);

                    EXFORMOBJ exoDtoW(dco, DEVICE_TO_WORLD);
                    if (!exoDtoW.bValid())
                    {
                       dwRet = 0;
                    }
                    else if (!exoDtoW.bRotation())
                    {
                        if (!exoDtoW.bXform((POINTL *) prcl, 2))
                            dwRet = 0;
                    }
                    else
                    {
                        POINTL apt[4];

                        *((RECT *)apt) = *prcl;
                        apt[2].x = prcl->left;
                        apt[2].y = prcl->bottom;
                        apt[3].x = prcl->right;
                        apt[3].y = prcl->top;

                        if (!exoDtoW.bXform(apt, 4))
                        {
                            dwRet = 0;
                        }
                        else
                        {
                            prcl->left   = MIN4(apt[0].x,apt[1].x,apt[2].x,apt[3].x);
                            prcl->right  = MAX4(apt[0].x,apt[1].x,apt[2].x,apt[3].x);
                            prcl->top    = MIN4(apt[0].y,apt[1].y,apt[2].y,apt[3].y);
                            prcl->bottom = MAX4(apt[0].y,apt[1].y,apt[2].y,apt[3].y);
                        }
                    }
                }
            }
        }

        if ((dwRet == DCB_SET) && (fl & DCB_RESET))
        {
            percl->left  = percl->top    = POS_INFINITY;
            percl->right = percl->bottom = NEG_INFINITY;
        }
    }
    return(dwRet);
}

/******************************Public*Routine******************************\
* BOOL GreSetBoundsRect(hdc, prcl, fl)
*
* Set the current bounds info.
*
* History:
*  Thu 27-May-1993 -by- Patrick Haluptzok [patrickh]
* Make it exclusive lock, this is a general purpose API
*
*  06-Apr-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

DWORD GreSetBoundsRect(HDC hdc, LPRECT prcl, DWORD fl)
{
    DWORD dwState = 0;
    DCOBJ dco(hdc);

    if (dco.bValid())
    {
        ERECTL *percl;
        FSHORT  fsEnable;
        BOOL    bEnabled;
        BOOL    bError = FALSE;

        if (fl & DCB_WINDOWMGR)
        {
            percl    = &dco.erclBounds();
            fsEnable = DC_ACCUM_WMGR;
            bEnabled = dco.bAccum();
        }
        else
        {
            percl    = &dco.erclBoundsApp();
            fsEnable = DC_ACCUM_APP;
            bEnabled = dco.bAccumApp();
        }

        dwState = (fl & DCB_WINDOWMGR);

        if (percl->bWrapped())
            dwState |= DCB_RESET;
        else
            dwState |= DCB_SET;

        if (bEnabled)
            dwState |= DCB_ENABLE;
        else
            dwState |= DCB_DISABLE;

    // Reset the rectangle if we've been asked to do so.

        if (fl & DCB_RESET)
        {
            percl->left  = percl->top    = POS_INFINITY;
            percl->right = percl->bottom = NEG_INFINITY;
        }

    // If we are accumulating, do the union.

        if (fl & DCB_ACCUMULATE)
        {
            ASSERTGDI(prcl,"GreSetBoundsRect - DCB_ACCUMULATE with no prcl\n");

        // Convert the incoming rectangle to DEVICE coordinates.

            if (!(fl & DCB_WINDOWMGR))
            {
                EXFORMOBJ   exo(dco, WORLD_TO_DEVICE);

                if (!exo.bRotation())
                {
                    if (!exo.bXform((POINTL *)prcl, 2))
                        bError = TRUE;
                }
                else
                {
                    POINTL apt[4];
                    *((RECT *)apt) = *prcl;
                    apt[2].x = prcl->left;
                    apt[2].y = prcl->bottom;
                    apt[3].x = prcl->right;
                    apt[3].y = prcl->top;

                    if (!exo.bXform(apt, 4))
                    {
                        bError = TRUE;
                    }
                    else
                    {
                        prcl->left   = MIN4(apt[0].x,apt[1].x,apt[2].x,apt[3].x);
                        prcl->right  = MAX4(apt[0].x,apt[1].x,apt[2].x,apt[3].x);
                        prcl->top    = MIN4(apt[0].y,apt[1].y,apt[2].y,apt[3].y);
                        prcl->bottom = MAX4(apt[0].y,apt[1].y,apt[2].y,apt[3].y);
                    }
                }
            }

            *percl |= *((ERECTL *) prcl);
        }

        if (!bError)
        {
        // Enable or Disable accumulation

            if (fl & DCB_ENABLE)
                dco.fsSet(fsEnable);

            if (fl & DCB_DISABLE)
                dco.fsClr(fsEnable);
        }
        else
        {
            dwState = 0;
        }
    }

    return(dwState);
}

/******************************Public*Routine******************************\
* GreMarkUndeletableDC
*
* Private API for USER.
*
* Mark a DC as undeletable.  This must be called before the hdc is ever
* passed out so that we are guranteed the lock will not fail because a
* app is using it.
*
* History:
*  13-Sep-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID GreMarkUndeletableDC(HDC hdc)
{
    XDCOBJ dco(hdc);

    if (dco.bValid())
    {
        dco.vMakeUndeletable();
        dco.vUnlockFast();
    }
    else
    {
        WARNING("ERROR User gives Gdi invalid DC");
    }
}

/******************************Public*Routine******************************\
* GreMarkDeletableDC
*
* Private API for USER.
*
* This can be called anytime by USER to make the DC deletable.
*
* History:
*  13-Sep-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID GreMarkDeletableDC(HDC hdc)
{
    XDCOBJ dcoa;

    dcoa.vAltLock(hdc);

    if (dcoa.bValid())
    {
        dcoa.vMakeDeletable();
        dcoa.vAltUnlockFast();
    }
    else
    {
        WARNING("ERROR User gives Gdi invalid DC");
    }
}

/******************************Public*Routine******************************\
* HFONT GreGetHFONT(HDC)
*
*   This is a private entry point user by USER when they pass the
*   DRAWITEMSTRUC message to the client to get the current handle.
*   This is done because they may have set the font on the server
*   side, in which case the client does not know about it.
*
* History:
*  Tue 28-Dec-1993 -by- Patrick Haluptzok [patrickh]
* smaller and faster
*
*  16-Sep-1991 - by - Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HFONT GreGetHFONT(HDC hdc)
{
    XDCOBJ dco(hdc);

    HFONT hfont = (HFONT) 0;

    if (dco.bValid())
    {
        hfont = (HFONT) dco.pdc->hlfntNew();
        dco.vUnlockFast();
    }

    return(hfont);
}

/******************************Public*Routine******************************\
* GreCancelDC()
*
* History:
*  14-Apr-1992 -by-  - by - Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL GreCancelDC(HDC hdc)
{
    BOOL bReturn;

    //
    // The handle manager lock prevents the DC from being deleted while
    // we've got the DC alt-locked, and it also prevents the dynamic
    // mode change code from updating pSurface() while we're looking at
    // it.
    //

    MLOCKFAST mlo;
    XDCOBJ dco;

    dco.vAltCheckLock(hdc);

    if (bReturn = dco.bValid())
    {
        SURFACE *pSurface = dco.pSurface();

        if (pSurface != (SURFACE *) NULL)
            pSurface->vSetAbort();

        dco.vAltUnlockFast();
    }
#if DBG
    else
    {
        WARNING("GreCancelDC passed invalid DC\n");
    }
#endif

    return(bReturn);
}

/******************************Public*Routine******************************\
* VOID GreMarkDCUnreadable(hdc)
*
* Mark a DC as secure.
*
* History:
*  13-Aug-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID APIENTRY GreMarkDCUnreadable(HDC hdc)
{
    XDCOBJ  dco;
    dco.vAltLock(hdc);

    MLOCKFAST mlo; // Protect pSurface() access

    if (dco.bValid())
    {
        ASSERTGDI(dco.dctp() == DCTYPE_DIRECT, "Non-screen DC marked as secure!\n");

        dco.pSurface()->flags(dco.pSurface()->flags() | UNREADABLE_SURFACE);

        PDEVOBJ pdo(dco.hdev());
        SPRITESTATE *pState = pdo.pSpriteState();
        pState->flOriginalSurfFlags |= UNREADABLE_SURFACE;
        pState->flSpriteSurfFlags |= UNREADABLE_SURFACE;

        dco.vAltUnlockFast();
    }
    else
    {
        WARNING("Invalid DC passed to GreMarkDCUnreadable\n");
    }
}

DWORD dwGetFontLanguageInfo(XDCOBJ& dco);

/******************************Public*Routine******************************\
* BOOL NtGdiGetDCDword(hdc,uint)
*
* Query DC to get a particular DWORD of info.
*
* History:
*  9-Nov-1994 -by- Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/

#if DBG
    ULONG acGetDCDword[DDW_MAX] = {0};
#endif

BOOL NtGdiGetDCDword( HDC hdc, UINT u, DWORD *pdwResult )
{
    BOOL bResult = TRUE;
    DWORD dwTmp;

    XDCOBJ dco( hdc );

    if(!dco.bValid())
    {
        WARNING("Invalid DC or offset passed to GreGetDCDword\n");
        bResult = FALSE;
    }
    else
    {
        switch( u )
        {
        case DDW_JOURNAL:
            dwTmp = !(dco.flGraphicsCaps() & GCAPS_DONTJOURNAL);
            break;

        case DDW_RELABS:
            dwTmp = dco.pdc->lRelAbs();
            break;

        case DDW_BREAKEXTRA :
            dwTmp = dco.pdc->lBreakExtra();
            break;

        case DDW_CBREAK:
            dwTmp = dco.pdc->cBreak();
            break;

        case DDW_MAPMODE:
            dwTmp = dco.ulMapMode();
            break;

        case DDW_ARCDIRECTION:
            if (MIRRORED_DC(dco.pdc))
                dwTmp = dco.pdc->bClockwise() ? AD_COUNTERCLOCKWISE : AD_CLOCKWISE;
            else
                dwTmp = dco.pdc->bClockwise() ? AD_CLOCKWISE : AD_COUNTERCLOCKWISE;
            break;

        case DDW_SAVEDEPTH:
            dwTmp = dco.lSaveDepth();
            break;

        case DDW_FONTLANGUAGEINFO:
            dwTmp = dwGetFontLanguageInfo(dco);
            break;

        case DDW_ISMEMDC:
            dwTmp = ( dco.dctp() == DCTYPE_MEMORY );
            break;

        default:
            WARNING("Illegal offset passed to GreGetDCDword\n");
            bResult = FALSE;
            break;
        }

        if (bResult)
        {
        #if DBG

            acGetDCDword[u]++;

        #endif

            _try
            {
                ProbeAndWriteUlong(pdwResult, dwTmp);
            }
            _except(EXCEPTION_EXECUTE_HANDLER)
            {
                // SetLastError(GetExceptionCode());
                bResult = FALSE;
            }
        }

        dco.vUnlockFast();
    }
    return(bResult);
}

/******************************Public*Routine******************************\
* BOOL NtGdiGetAndSetDCDword(hdc,uint,DWORD,DWORD*)
*
* Set a particular value in a DC DWORD and return the old value.  Note this
* function should not be incorperated with GetDCDword because all the values
* will eventually be place in an array eliminating the need for a switch
* statement.  This function, however, will need to do valiation specific
* to each particular attribute so we wil still need a switch statement.
*
* History:
*  9-Nov-1994 -by- Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/

#if DBG
    ULONG acSetDCDword[GASDDW_MAX] = {0};
#endif

BOOL NtGdiGetAndSetDCDword( HDC hdc, UINT u, DWORD dwIn, DWORD *pdwResult )
{
    BOOL bResult = TRUE;
    DWORD dwTmp = ERROR;

    XDCOBJ dco( hdc );

    if(!dco.bValid())
    {
        WARNING("Invalid DC passed to GreGetAndSetDCDword\n");

        if (u == GASDDW_TEXTCHARACTEREXTRA)
        {
            _try
            {
                ProbeAndWriteUlong(pdwResult, 0x80000000);
            }
            _except(EXCEPTION_EXECUTE_HANDLER)
            {
                // SetLastError(GetExceptionCode());
            }
        }

        return FALSE;
    }

    switch( u )
    {
    case GASDDW_COPYCOUNT:
        dwTmp = dco.ulCopyCount();
        dco.ulCopyCount( dwIn );
        break;

    case GASDDW_EPSPRINTESCCALLED:
        dwTmp = (DWORD) dco.bEpsPrintingEscape();
        dco.vClearEpsPrintingEscape();
        break;

    case GASDDW_RELABS:
        dwTmp = dco.pdc->lRelAbs();
        dco.pdc->lRelAbs(dwIn);
        break;

    case GASDDW_SELECTFONT:
        WARNING("should not be here\n");
/*
        dwTmp = (DWORD) dco.pdc->hlfntNew();
        dco.pdc->hlfntNew((HLFONT)dwIn);
        if ((HLFONT)dwIn != dco.pdc->hlfntCur())
            dco.ulDirtyAdd(DIRTY_CHARSET);
*/
        break;

    case GASDDW_MAPPERFLAGS:
        if( dwIn & (~ASPECT_FILTERING) )
        {
            WARNING1("gdisrv!GreSetMapperFlags(): unknown flag\n");
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            dwTmp = GDI_ERROR;
        }
        else
        {
            dwTmp =  dco.pdc->flFontMapper();
            dco.pdc->flFontMapper((DWORD) dwIn);
        }
        break;

    case GASDDW_MAPMODE:
        {
            DWORD dwResult = dco.ulMapMode();

            if (dwResult != dwIn)
            {
                dwResult = dco.pdc->iSetMapMode(dwIn);
            }

            dwTmp = dwResult;
        }
        break;

    case GASDDW_ARCDIRECTION:
        if (MIRRORED_DC(dco.pdc)) {
            dwTmp = dco.pdc->bClockwise() ? AD_COUNTERCLOCKWISE : AD_CLOCKWISE;

            if (dwIn == AD_CLOCKWISE)
                dco.pdc->vClearClockwise();
            else if (dwIn == AD_COUNTERCLOCKWISE)
                dco.pdc->vSetClockwise(); 
            else
            {
                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                dwTmp = ERROR;
            }
        }
        else
        {
            dwTmp = dco.pdc->bClockwise() ? AD_CLOCKWISE : AD_COUNTERCLOCKWISE;

            if (dwIn == AD_CLOCKWISE)
                dco.pdc->vSetClockwise();
            else if (dwIn == AD_COUNTERCLOCKWISE)
                dco.pdc->vClearClockwise();
            else
            {
                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                dwTmp = ERROR;
            }
        }
        
        break;

    default:
        WARNING("Illegal offset passed to GreGetAndSetDCDword\n");
        bResult = FALSE;
        break;
    }

    if (bResult)
    {
    #if DBG

        acSetDCDword[u]++;

    #endif

         _try
        {
            ProbeAndWriteUlong(pdwResult, dwTmp);
        }
        _except(EXCEPTION_EXECUTE_HANDLER)
        {
            // SetLastError(GetExceptionCode());
            bResult = FALSE;
        }
    }

    dco.vUnlockFast();

    return(bResult);
}

/******************************Public*Routine******************************\
* GreGetDCPoint()
*
* History:
*  30-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL GreGetDCPoint(
    HDC     hdc,
    UINT    u,
    PPOINTL pptOut
    )
{
    BOOL   bResult = TRUE;
    XDCOBJ dco(hdc);

    if( dco.bValid() )
    {
        switch(u)
        {
        case DCPT_VPEXT:
            if (dco.pdc->bPageExtentsChanged() && (dco.ulMapMode() == MM_ISOTROPIC))
                dco.pdc->vMakeIso();

            dco.pdc->vGet_szlViewportExt((PSIZEL)pptOut);
            break;

        case DCPT_WNDEXT:
            dco.pdc->vGet_szlWindowExt((PSIZEL)pptOut);

            if (MIRRORED_DC(dco.pdc))
                pptOut->x = -pptOut->x;
            break;

        case DCPT_VPORG:
            dco.pdc->vGet_ptlViewportOrg(pptOut);

            if (MIRRORED_DC(dco.pdc))
                pptOut->x = -pptOut->x;
            break;

        case DCPT_WNDORG:
            dco.pdc->vGet_ptlWindowOrg(pptOut);
            pptOut->x = dco.pdc->pDCAttr->lWindowOrgx;
            break;

        case DCPT_ASPECTRATIOFILTER:
            bResult = GreGetAspectRatioFilter(hdc,(LPSIZE)pptOut);
            break;

        case DCPT_DCORG:
            *pptOut = dco.eptlOrigin();
            break;

        default:
            RIP("Illegal offset passed to GreGetAndSetDCPoint\n");
            bResult = FALSE;
        }

        dco.vUnlockFast();
    }
    else
    {
        WARNING("Invalid DC passed to GreGetDCPoint\n");
        bResult = FALSE;
    }

    return(bResult);
}

/******************************Public*Routine******************************\
* NtGdiGetDCObject()
*
* History:
*  01-Dec-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HANDLE NtGdiGetDCObject(HDC hdc, int itype)
{
    HANDLE  hReturn = (HANDLE) 0;

    //
    // Try to lock the DC. If we fail, we just return failure.
    //

    XDCOBJ dco(hdc);

    if (dco.bValid())
    {
        SYNC_DRAWING_ATTRS(dco.pdc);

        //
        // The DC is locked.
        //
        switch (itype)
        {
        case LO_BRUSH_TYPE:
             hReturn = (HANDLE)(dco.pdc->pbrushFill())->hGet();
             break;

        case LO_PEN_TYPE:
        case LO_EXTPEN_TYPE:
             hReturn = (HANDLE)(dco.pdc->pbrushLine())->hGet();
             break;

        case LO_FONT_TYPE:
             hReturn =  (HANDLE) dco.pdc->hlfntNew();
             break;

        case LO_PALETTE_TYPE:
             hReturn = (HANDLE) dco.hpal();
             break;

        case LO_BITMAP_TYPE:
             {
                 //
                 // Acquire the Devlock because we're groveling
                 // in the DC's surface pointer, which could otherwise
                 // be changed asynchronously by the dyanmic mode change
                 // code.
                 //

                 DEVLOCKOBJ dlo;
                 dlo.vLockNoDrawing(dco);
                 hReturn =  (HANDLE) dco.pSurfaceEff()->hsurf();
                 break;
             }

        default: break;
        }

        dco.vUnlockFast();
    }

    return(hReturn);
}

/******************************Public*Routine******************************\
* GreCleanDC(hdc)
*
* Set up some stuff up in the DC
*
* History:
*  20-Apr-1995 -by- Andre Vachon [andreva]
\**************************************************************************/

BOOL
GreCleanDC(
    HDC hdc
    )
{
    DCOBJ  dco(hdc);

    if (dco.bValid())
    {
        if (dco.bCleanDC())
        {
            return(TRUE);
        }
#if DBG
        PVOID pv1, pv2;

        RtlGetCallersAddress(&pv1,&pv2);
        DbgPrint("GreCleanDC failed to lock DC (%p), (c1 = %p, c2 = %p)\n",
                  hdc, pv1, pv2);
#endif
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* GreSetDCOwner
*
* Set the owner of the DC
*
* if the owner is set to OBJECTOWNER_NONE, this dc will not be useable
* until GreSetDCOwner is called to explicitly give the dc to someone else.
*
* Arguments:
*
*   hdc     - DC to modify
*   lPid    - one of  OBJECT_OWNER_NONE,OBJECT_OWNER_PUBLIC or
*             OBJECT_OWNER_CURRENT
*
* Return Value:
*
*   TRUEif DC ownership changed, FALSE otherwise
*
* History:
*
*    24-Aug-1995 Merge DC ownership routines
*
\**************************************************************************/

BOOL
GreSetDCOwner(
    HDC    hdc,
    W32PID lPid
    )
{
    BOOL bStatus     = FALSE;
    PDC_ATTR pDcattr = NULL;

    PENTRY pentry;
    UINT uiIndex = (UINT) HmgIfromH(hdc);

    if (uiIndex < gcMaxHmgr)
    {
        pentry = &gpentHmgr[uiIndex];

        //
        // before handle is locked, check if an allocation may
        // be needed since DCATTRs can't be allocated under a handle lock.
        // Note: instead, we could use a per-process mutex for process list protection.
        //

        if (lPid == OBJECT_OWNER_CURRENT)
        {
            pDcattr = HmgAllocateDcAttr();
        }

        //
        // Acquire handle lock. Don't check PID here because owner could be
        // NONE, not PUBLIC
        //

        HANDLELOCK HandleLock(pentry,FALSE);

        if (HandleLock.bValid())
        {
            POBJ pobj = pentry->einfo.pobj;

            if ((pentry->Objt == DC_TYPE) && (pentry->FullUnique== HmgUfromH(hdc)))
            {
                if ((pobj->cExclusiveLock == 0) ||
                    (pobj->Tid == (PW32THREAD)PsGetCurrentThread()))
                {
                    W32PID lPidBrush = lPid;


                    //
                    // Handle is locked. It is illegal to acquire the hmgr resource
                    // when a handle is locked.
                    //

                    #if DBG
                    //
                    // check if the rgn selected in the DC is valid
                    // when USER mark the HDC to be usable again
                    //
                    if ((lPid != OBJECT_OWNER_NONE) &&
                        (HandleLock.Pid() == OBJECT_OWNER_NONE))
                    {
                         PDEVOBJ pdo(((PDC)pobj)->hdev());
                         SURFACE *pSurf = ((PDC)pobj)->pSurface();
                         REGION *prgn = ((PDC)pobj)->prgnVis();
                         BOOL bValidateVisrgn = ((PDC)pobj)->bValidateVisrgn();

                         if (pdo.bValid() && !pdo.bMetaDriver() &&
                             pSurf && bValidateVisrgn && prgn)
                         {
                            BOOL bIsOK = ((pSurf->sizl().cx >= prgn->rcl.right) &&
                                         (pSurf->sizl().cy >= prgn->rcl.bottom)&&
                                         (prgn->rcl.left >= 0) &&
                                         (prgn->rcl.top >= 0));

                            ASSERTGDI(bIsOK, "Rgn size is bigger than surface size");
                         }
                    }
                    #endif

                    if ((lPid == OBJECT_OWNER_NONE) ||
                        (lPid == OBJECT_OWNER_PUBLIC))
                    {
                        //
                        // free DCATTR if PID matches current process, otherwise
                        // fail this call. This is an ok path, it just means user has a
                        // DC on their delayed dc destroy queue and they are trying to
                        // delete it now from a different process. This doesn't work
                        // because we have no way of accessing or freeing DC_ATTRs  of
                        // a different process
                        //

                        if (HandleLock.Pid() == W32GetCurrentPID())
                        {
                            //
                            // if user mode DC_ATTR is allocated for this dc
                            //

                            if (((PDC)pobj)->pDCAttr != &((PDC)pobj)->dcattr)
                            {
                                //
                                // copy pDCAttrs to dcattr, then reset pDCAttr to DC memory
                                //

                                ((PDC)pobj)->dcattr = *((PDC)pobj)->pDCAttr;

                                //
                                // free DCATTR
                                //

                                pDcattr = ((PDC)pobj)->pDCAttr;

                                //
                                // Set pDCAttr to point to internal structure
                                //

                                ((PDC)pobj)->pDCAttr = &((PDC)pobj)->dcattr;

                                //
                                // clear ENTRY
                                //

                                pentry->pUser = NULL;
                            }

                            //
                            // set DC owner to NONE or PUBLIC
                            //

                            HandleLock.Pid(lPid);

                            //
                            // dec process handle count
                            //

                            HmgDecProcessHandleCount(W32GetCurrentPID());

                            bStatus = TRUE;
                        }
                        else if (HandleLock.Pid() == OBJECT_OWNER_NONE)
                        {
                            //
                            // Allow to set from NONE to PUBLIC or NONE.
                            //

                            HandleLock.Pid(lPid);

                            bStatus = TRUE;
                        }
                    }
                    else if (lPid == OBJECT_OWNER_CURRENT)
                    {
                        //
                        // can only set to OBJECT_OWNER_CURRENT if DC is
                        // not owned, or already owned by current pid.
                        //
                        // Get the current PID
                        //

                        lPid = W32GetCurrentPID();

                        if (
                            (HandleLock.Pid() == lPid) ||
                            (HandleLock.Pid() == OBJECT_OWNER_NONE) ||
                            (HandleLock.Pid() == OBJECT_OWNER_PUBLIC)
                           )
                        {
                            BOOL bIncHandleCount = FALSE;

                            //
                            // DC may already have DC_ATTR allocated
                            //

                            bStatus = TRUE;

                            //
                            // only inc handle count if assigning a new PID
                            //

                            if (HandleLock.Pid() != lPid)
                            {
                                //
                                // don't check quota for DCs
                                //

                                HmgIncProcessHandleCount(lPid,DC_TYPE);

                                bIncHandleCount = TRUE;
                            }

                            //
                            // check user object not already allocated for this handle
                            //

                            if (pentry->pUser == NULL)
                            {
                                if (pDcattr != NULL)
                                {
                                    //
                                    // set DC dc_attr pointer
                                    //

                                    ((PDC)pobj)->pDCAttr = pDcattr;

                                    //
                                    // set pUser in ENTRY
                                    //

                                    pentry->pUser = pDcattr;

                                    //
                                    // copy clean attrs
                                    //

                                    *pDcattr = ((PDC)pobj)->dcattr;

                                    //
                                    // set pDcattr to NULL so it is not freed
                                    //

                                    pDcattr = NULL;
                                }
                                else
                                {
                                    WARNING1("HmgSetDCOwnwer failed - No DC_ATTR available\n");
                                    bStatus = FALSE;

                                    //
                                    // Reduce handle quota count
                                    //

                                    if (bIncHandleCount)
                                    {
                                        HmgDecProcessHandleCount(lPid);
                                    }
                                }
                            }

                            if (bStatus)
                            {
                                //
                                // Set new owner
                                //

                                HandleLock.Pid(lPid);
                            }
                        }
                        else
                        {
                            WARNING("HmgSetDCOwnwer failed, trying to set directly from one PID to another\n");
                        }
                    }
                    else
                    {
                        WARNING("HmgSetDCOwnwer failed, bad lPid\n");
                    }

                    if((lPidBrush != OBJECT_OWNER_NONE) && bStatus)
                    {
                        if(!GreSetBrushOwner((HBRUSH)(((PDC)pobj)->hbrush()),lPidBrush)||
                           !GreSetBrushOwner((HBRUSH)(((PDC)pobj)->pbrushFill())->hGet(),lPidBrush)||
                           !GreSetBrushOwner((HBRUSH)(((PDC)pobj)->pbrushLine())->hGet(),lPidBrush))
                        {
                            WARNING("HmgSetDCOwner, Brushes could not be moved");
                        }
                    }
                }
                else
                {
                    WARNING1("HmgSetDCOwnwer failed - Handle is exclusively locked\n");
                }
            }
            else
            {
                WARNING1("HmgSetDCOwnwer failed - bad unique or object type");
            }

            HandleLock.vUnlock();
        }
    }
    else
    {
        WARNING1("HmgSetOwner failed - invalid handle index\n");
    }

    //
    // free dcattr if needed
    //

    if (pDcattr)
    {
        HmgFreeDcAttr(pDcattr);
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
* GreSetupDCAttributes
*
* Arguments:
*
*   hdc - handle to DC
*   pDCAttr - pointer to memory block allocated in USER space by caller
*
* Return Value:
*
*   BOOL Status
*
* History:
*
*    24-Apr-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
GreSetupDCAttributes(
    HDC hdc
    )
{
    BOOL bRet = FALSE;

    DCOBJ dco(hdc);

    if (dco.bValid())
    {
        PDC_ATTR pDCAttr = HmgAllocateDcAttr();

        if (pDCAttr != NULL)
        {
            //
            // set DC dc_attr pointer
            //

            dco.pdc->pDCAttr = pDCAttr;

            //
            // make sure USER object not already allocate for this handle
            //

            ASSERTGDI(gpentHmgr[HmgIfromH(hdc)].pUser == NULL,
                                "GreSetupDCAttributes: pUser not NULL");

            //
            // setup shared global handle table for this DC
            //

            gpentHmgr[HmgIfromH(hdc)].pUser = pDCAttr;

            //
            // copy old attrs
            //

            *pDCAttr = dco.pdc->dcattr;

            bRet = TRUE;
        }

    }

    return(bRet);
}

/******************************Public*Routine******************************\
* GreFreeDCAttributes
*
* Arguments:
*
*   hdc
*
* Return Value:
*
*   BOOL
*
* History:
*
*    27-Apr-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
GreFreeDCAttributes(
    HDC hdc
    )
{
    BOOL bStatus = FALSE;
    DCOBJ dco(hdc);

    if (dco.bValid())
    {
        //
        // free dc attribute block if not default, then set to default
        //

        if (dco.pdc->pDCAttr != &dco.pdc->dcattr)
        {
            ASSERTGDI(dco.pdc->pDCAttr != NULL,"GreFreeDCAttributes:  pDCAttr is NULL");

            //
            // copy pDCAttrs to dcattr
            //

            dco.pdc->dcattr = *(dco.pdc->pDCAttr);

            //
            // free DC_ATTR memory
            //

            HmgFreeDcAttr(dco.pdc->pDCAttr);

            //
            // Set pDCAttr to point to internal structure
            //

            dco.pdc->pDCAttr = &dco.pdc->dcattr;

            //
            // clear DCATTR in ENTRY
            //

            gpentHmgr[HmgIfromH(hdc)].pUser = (PDC_ATTR)NULL;

            bStatus = TRUE;
        }

    }
    return(bStatus);
}

/****************************************************************************
*  NtGdiComputeXformCoefficients
*
* This function is used by the client side char-width caching code.  It
* forces computation of the World To Device Transform and puts the
* coefficients in the shared attribute structure.   If the world to device
* xform is not just simple scalling it returns FALSE indicating that extents
* and widths should not be cached.
*
*
*  History:
*   6/12/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*****************************************************************************/

extern "C" BOOL NtGdiComputeXformCoefficients(
    HDC hdc                // Handle to the DC
    )
{
    BOOL bRet = FALSE;
    XDCOBJ dco(hdc);

    if( dco.bValid() )
    {
        EXFORMOBJ xo(dco, WORLD_TO_DEVICE);
        ASSERTGDI(xo.bValid(),"NtGdiFastWidths exformobj not valid\n");

        if( xo.bScale() )
        {
            bRet = TRUE;
        }
        dco.vUnlockFast();
    }

    return(bRet);

}

BOOL
bUMPD(
    HDC hdc)
{
    XDCOBJ dco(hdc);
    BOOL bRet = FALSE;

    if( dco.bValid())
    {
        bRet = dco.bUMPD();

        dco.vUnlockFast();
    }

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\cpanel.cxx ===
/******************************Module*Header*******************************\
* Module Name: cpanel.cxx
*
* Control panel private entry point(s).
*
* Created: 21-Apr-1992 16:49:18
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1992-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

/******************************Public*Routine******************************\
* GetFontResourceInfoW
*
* The GetFontResourceInfo copies LOGFONTs, IFIMETRICs, or description
* strings into a return buffer for all the fonts in the specified font
* resource file.
*
* Parameters:
*
*   lpFilename
*
*       Specifies the filename of the font resource being queried.  It
*       must be a NULL-terminated ANSI string.
*
*   lpBytes
*       If lpBytes is 0 upon entry to the function, then the number of
*       BYTE's required for the requested information is returned via
*       this parameter.  The lpBuffer is ignored for this case.
*
*       If lpBytes is not 0 upon entry, then it specifies the size of
*       the buffer pointed to by lpBuffer.  The number of bytes copied
*       to the buffer is returned via this parameter upon exit.
*
*   lpBuffer
*
*       The return buffer into which the requested information is copied.
*       If lpBytes is 0, then this parameter is ignored.
*
*   iType
*
*       Must be one of the following:
*
*           GFRI_NUMFONTS
*
*               Copy into the return buffer a ULONG containing the
*               number of fonts in the font resource file.  Caller
*               should pass in the address of a ULONG for lpBuffer
*               and sizeof(ULONG) for *lpBytes.
*
*           GFRI_DESCRIPTION
*
*               Copy the font resource's description string into the
*               return buffer.  This may be a empty string.
*
*           GFRI_LOGFONTS
*
*               Copy an array of LOGFONTs corresponding to each of the
*               fonts in the font resource.  Note that the LOGFONTs
*               must be returned in the font's NOTIONAL COORDINATES
*               since there is no DC specified.
*
*           GFRI_ISTRUETYPE
*
*               Returns TRUE via lpBuffer if font resource is TrueType.
*               FALSE otherwise.  All other parameters are ignored.
*               Caller should pass in the address of a BOOL for lpBuffer
*               and sizeof(BOOL) for *lpBytes.
*
*           GFRI_TTFILENAME
*
*               Returns the .TTF filename imbedded as a string resource
*               in .FOT 16-bit TrueType font files.  The filename is
*               copied into the lpBuffer.  The function returns FALSE
*               if a filename could not be extracted.
*
*           GFRI_ISREMOVED
*
*               Returns TRUE via lpBuffer if the font file is no longer
*               in the engine font table (or was never there).  FALSE is
*               returned via lpBuffer if the font file is still in the
*               font table.  Caller should pass in the address of a BOOL
*               for lpBuffer and sizeof(BOOL for *lpBytes.
*
* Returns:
*     TRUE if the function is successful, FALSE otherwise.
*
* Comments:
*   This function is intended as a private entry point for Control Panel.
*
* History:
*   2-Sep-1993 -by- Gerrit van Wingerden [gerritv]
* Turned it into a "W" function.
*
*  15-Jul-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL GetFontResourceInfoInternalW(
    LPWSTR          lpFilename,
    ULONG           cwc,
    ULONG           cFiles,
    UINT            cjIn,
    PSIZE_T         lpBytes,
    LPVOID          lpBuffer,
    DWORD           iType)
{
    BOOL bRet = FALSE;
    PFF *pPFF;

// Stabilize public PFT.

    SEMOBJ  so(ghsemPublicPFT);

// Create and validate user object for public PFT.

    PUBLIC_PFTOBJ  pfto;
    ASSERTGDI(pfto.bValid(), "How could it not be valid");

// Find the correct PFF.

    if (pPFF = pfto.pPFFGet(lpFilename, cwc, cFiles, NULL, 0))
    {
        PFFOBJ  pffo(pPFF);

        ASSERTGDI (
            pffo.bValid(),
            "gdisrv!GetFontResourceInfoInternal(): bad HPFF handle\n"
            );

        {
        // What info is requested?

            switch (iType)
            {
            case GFRI_NUMFONTS:

            // Is there a buffer?

                if (cjIn)
                {
                // If buffer big enough, return the count of fonts.

                    if ( cjIn >= sizeof(ULONG) )
                        *((PULONG) lpBuffer) = pffo.cFonts();
                    else
                        return bRet;
                }

            // In either case, return size of ULONG.

                *((SIZE_T *) lpBytes) = sizeof(ULONG);
                bRet = TRUE;

                break;

            case GFRI_DESCRIPTION:
                {
                    ULONG cjRet;
                    PDEVOBJ pdo(pPFF->hdev);

                    cjRet = pdo.QueryFontFile(
                                   (ULONG_PTR) pPFF->hff,
                                   QFF_DESCRIPTION,
                                   0,
                                   (PULONG) NULL);


                    if (cjRet != FD_ERROR )
                    {
                        //
                        // If buffer exists, we need to copy into it.
                        //

                        if (cjIn)
                        {
                            //
                            // Get description string in UNICODE.
                            //

                            if (cjRet <= cjIn)
                            {
                                cjRet = pdo.QueryFontFile(
                                               (ULONG_PTR) pPFF->hff,
                                               QFF_DESCRIPTION,
                                               cjIn,
                                               (PULONG) lpBuffer);
                            }
                            else
                            {
                                // the buffer passed in is not big enough to contain the description for that font
                                cjRet = FD_ERROR;
                            }


                        }
                    }

                    if (cjRet != FD_ERROR )
                    {
                        //
                        // Return size (byte count) of description string.
                        //

                        *((SIZE_T *) lpBytes) = (SIZE_T) cjRet;
                        bRet = TRUE;

                    }
                }

                break;


            case GFRI_LOGFONTS:

                if (cjIn == 0)
                    *((SIZE_T *) lpBytes) = (SIZE_T) pffo.cFonts() * sizeof(LOGFONTW);
                else
                {
                    PLOGFONTW   plf = (PLOGFONTW) lpBuffer;  // LOGFONTW ptr into lpBuffer
                    ULONG       iFont;      // index to font
                    SIZE_T      cjCopy = 0; // bytes copied

                // Make sure buffer is big enough.

                    if (cjIn < (pffo.cFonts() * sizeof(LOGFONTW)))
                    {
                        WARNING("gdisrv!GetFontResourceInfoInternal(): buffer too small\n");
                        return bRet;
                    }

                // Run the list of PFEs.

                    for (iFont=0; iFont<pffo.cFonts(); iFont++)
                    {
                        PFEOBJ  pfeo(pffo.ppfe(iFont));

                        ASSERTGDI (
                            pfeo.bValid(),
                            "gdisrv!GetFontResourceInfoInternal(): bad HPFE handle\n"
                            );

                    // If data converted to LOGFONTW, increment size and
                    // move pointer to next.

                        vIFIMetricsToLogFontW(plf, pfeo.pifi());
                        cjCopy += sizeof(*plf);
                        plf++;
                    }

                    *((SIZE_T *) lpBytes) = (SIZE_T) cjCopy;
                }

                bRet = TRUE;

                break;

            case GFRI_ISTRUETYPE:

            // Is there a buffer?

                if (cjIn)
                {
                // If buffer not NULL, return the BOOL.

                    if ( (lpBuffer != (LPVOID) NULL) && (cjIn >= sizeof(BOOL)) )
                        *((BOOL *) lpBuffer) = (pffo.hdev() == (HDEV) gppdevTrueType);
                    else
                        return bRet;
                }

            // In either case, return size of ULONG.

                *((SIZE_T *) lpBytes) = sizeof(BOOL);
                bRet = TRUE;

                break;


            case GFRI_ISREMOVED:

            // We found the font file and we are in GFRI_ISREMOVED mode, that
            // means we should return a FALSE boolean signifying that the font
            // is still present in the system (i.e., the load count is still
            // non-zero for this font file).

            // Is there a buffer?

                if (cjIn)
                {
                // If buffer not NULL, return the BOOL.

                    if ( (lpBuffer != (LPVOID) NULL) && (cjIn >= sizeof(BOOL)) )
                        *((BOOL *) lpBuffer) = FALSE;
                    else
                        return bRet;
                }

            // In either case, return size of ULONG.

                *((SIZE_T *) lpBytes) = sizeof(BOOL);
                bRet = TRUE;

                break;

            default:
                WARNING("gdisrv!GetFontResourceInfoInternal(): unknown query type\n");
                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);

                break;  // bRet is FALSE

            } /* switch */

        // Ich bin "outahere"!

            return bRet;

        } /* if */

    } /* for */

// Couldn't find the font file in the public PFT.  If we are in GFRI_ISREMOVED
// mode, that means we should return a TRUE boolean signifying that the font
// if no longer (or was never) added to the system.

    if ( iType == GFRI_ISREMOVED )
    {
    // Is there a buffer?

        if (cjIn)
        {
        // If buffer not NULL, return the BOOL.

            if ( (lpBuffer != (LPVOID) NULL) && (cjIn >= sizeof(BOOL)) )
                *((BOOL *) lpBuffer) = TRUE;
            else
                return bRet;
        }

    // In either case, return size of ULONG.

        *((SIZE_T *) lpBytes) = sizeof(BOOL);
        bRet = TRUE;
    }

 #if DBG
// If not in GFRI_ISREMOVED mode, then this is a problem.  Why were we not able
// to find the font in the table.  Lets alert the debugger.

    if ( iType != GFRI_ISREMOVED )
    {
        DbgPrint("gdisrv!GetFontResourceInfoInternal(): no entry found for %s\n", lpFilename);
    }
#endif

// Ich bin "outahere"!

    return bRet;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\dcobj.cxx ===
/******************************Module*Header*******************************\
* Module Name: dcobj.cxx                                                   *
*                                                                          *
* Non inline methods for DC user object.  These are in a separate module   *
* to save other modules from having to do more includes.                   *
*                                                                          *
* Created: 09-Aug-1989 13:57:58                                            *
* Author: Donald Sidoroff [donalds]                                        *
*                                                                          *
* Copyright (c) 1989-1999 Microsoft Corporation                            *
\**************************************************************************/

#include "precomp.hxx"

extern RECTL rclEmpty;

/******************************Public*Routine******************************\
*
* VOID XDCOBJ::vSetDefaultFont(BOOL bDisplay)
*
*
* Effects: called from bCleanDC and CreateDC
*
* History:
*  21-Mar-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID XDCOBJ::vSetDefaultFont(BOOL bDisplay)
{
// If display PDEV, then select System stock font.

    HLFONT  hlfntNew;

    if (bDisplay)
    {
        ulDirty(ulDirty() | DISPLAY_DC );
        hlfntNew = STOCKOBJ_SYSFONT;
    }
    else
    {
        hlfntNew = STOCKOBJ_DEFAULTDEVFONT;
    }

// this can not fail with the stock fonts, also increments ref count

    PLFONT plfnt = (PLFONT)HmgShareCheckLock((HOBJ)hlfntNew, LFONT_TYPE);
    ASSERTGDI(plfnt, "vSetDefaultFont: plfnt == NULL\n");

    pdc->hlfntNew(hlfntNew);
    pdc->plfntNew(plfnt);
}

/******************************Member*Function*****************************\
* DCSAVE::bDelete()
*
* Attempt to delete the DC.
*
* History:
*  Sat 19-Aug-1989 00:32:58 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

BOOL XDCOBJ::bDeleteDC(BOOL bProcessCleanup)
{
    PFFLIST *pPFFList;
    BOOL bIsPrivate;

    RFONTOBJ rfDeadMeat(pdc->prfnt());   // deletion constructor, see rfntobj.cxx

// Nuke the brushes (unreference count to brush realization)

    peboFill()->vNuke();
    peboLine()->vNuke();
    peboText()->vNuke();
    peboBackground()->vNuke();

// remove any colortransform in this DC.

    vCleanupColorTransform(bProcessCleanup);

// remove any remote fonts

    if(pPFFList = pdc->pPFFList)
    {
        while( pPFFList )
        {
            PFFLIST *pTmp;

            pTmp = pPFFList;
            pPFFList = pPFFList->pNext;

            GreAcquireSemaphoreEx(ghsemPublicPFT, SEMORDER_PUBLICPFT, NULL);
            
            // this list is also used for local printing with embed fonts

            bIsPrivate = (pTmp->pPFF->pPFT == gpPFTPrivate) ? TRUE : FALSE;
            PUBLIC_PFTOBJ pfto(pTmp->pPFF->pPFT);

       //pPFFList != NULL only if the PFFs have been added to the DC for remote printing.
       // bUnloadWorkhorse should release the ghsemPublicPFT

            if (!pfto.bUnloadWorkhorse( pTmp->pPFF, 0, ghsemPublicPFT, bIsPrivate ? FR_PRINT_EMB_FONT : FR_NOT_ENUM))
            {
                WARNING("XDCOBJ::bDelete unable to delete remote font.\n");
            }

            VFREEMEM( pTmp );
        }
    }

// remove this from handle manager.

    HmgFree((HOBJ)pdc->hGet());

    pdc = (PDC) NULL;           // Prevents ~DCOBJ from doing anything.

    return(TRUE);
}

/******************************Data*Structure******************************\
* dclevelDefault
*
* Defines the default DC image for use by DCMEMOBJ.
*
* History:
*  Thu 09-Aug-1990 20:54:02 -by- Charles Whitmer [chuckwh]
* Wrote the nearly bare bones version.  We'll build it back up with the
* DC structure as we add components.
\**************************************************************************/

DC_ATTR DcAttrDefault =
{
    {0},                            // PVOID         pvLDC;
    (ULONG)DIRTY_CHARSET,           // ULONG         ulDirty_;
    (HBRUSH)0,                      // HBRUSH        hbrush
    (HPEN)0,                        // HPEN          hpen
    (COLORREF)0x00ffffff,           // COLORREF      crBackgroundClr;
    (COLORREF)0x00ffffff,           // ULONG         ulBackgroundClr;
    (COLORREF)0,                    // COLORREF      crForegroundClr;
    (COLORREF)0,                    // ULONG         ulForegroundClr;
    (COLORREF)0x00ffffff,           // COLORREF      crDCBrushClr;
    (COLORREF)0x00ffffff,           // ULONG         ulDCBrushClr;
    (COLORREF)0,                    // COLORREF      crDCPenClr;
    (COLORREF)0,                    // ULONG         ulDCPenClr;
    (ULONG)0,                       // ULONG         iCS_CP;
    GM_COMPATIBLE,                  // ULONG         iGraphicsMode;
    R2_COPYPEN,                     // BYTE          jROP2;
    OPAQUE,                         // BYTE          jBkMode;
    ALTERNATE,                      // BYTE          jFillMode;
    BLACKONWHITE,                   // BYTE          jStretchBltMode;
    {0},                            // POINTL        ptlCurrent
    {0},                            // POINTL        ptfxCurrent
    OPAQUE,                         // LONG          lBkMode;
    ALTERNATE,                      // ULONG         lFillMode;
    BLACKONWHITE,                   // LONG          lStretchBltMode;
    0,                              // FLONG         flFontMapper;
                                    //
    DC_ICM_OFF,                     // LONG          lIcmMode;
    (HANDLE)0,                      // HANDLE        hcmXform;
    (HCOLORSPACE)0,                 // HCOLORSPACE   hColorSpace;
    (DWORD)0,                       // DWORD         dwDIBColorSpace;
    (COLORREF)CLR_INVALID,          // COLORREF      IcmBrushColor;
    (COLORREF)CLR_INVALID,          // COLORREF      IcmPenColor;
    {0},                            // PVOID         pvICM;
                                    //
    TA_LEFT|TA_TOP|TA_NOUPDATECP,   // FLONG         flTextAlign;
    TA_LEFT|TA_TOP|TA_NOUPDATECP,   // LONG          lTextAlign;
    (LONG)0,                        // LONG          lTextExtra;
    (LONG)ABSOLUTE,                 // LONG          lRelAbs;
    (LONG)0,                        // LONG          lBreakExtra;
    (LONG)0,                        // LONG          cBreak;
    (HLFONT)0,                      // HLFONT        hlfntNew;

    {                               // MATRIX        mxWorldToDevice
        EFLOAT_16,                  // EFLOAT        efM11
        EFLOAT_0,                   // EFLOAT        efM12
        EFLOAT_0,                   // EFLOAT        efM21
        EFLOAT_16,                  // EFLOAT        efM22
        EFLOAT_0,                   // EFLOAT        efDx
        EFLOAT_0,                   // EFLOAT        efDy
        0,                          // FIX           fxDx
        0,                          // FIX           fxDy
        XFORM_SCALE          |      // FLONG         flAccel
        XFORM_UNITY          |
        XFORM_NO_TRANSLATION |
        XFORM_FORMAT_LTOFX
    },
    {                               // MATRIX        mxDeviceToWorld
        EFLOAT_1Over16,             // EFLOAT        efM11
        EFLOAT_0,                   // EFLOAT        efM12
        EFLOAT_0,                   // EFLOAT        efM21
        EFLOAT_1Over16,             // EFLOAT        efM22
        EFLOAT_0,                   // EFLOAT        efDx
        EFLOAT_0,                   // EFLOAT        efDy
        0,                          // FIX           fxDx
        0,                          // FIX           fxDy
        XFORM_SCALE          |      // FLONG         flAccel
        XFORM_UNITY          |
        XFORM_NO_TRANSLATION |
        XFORM_FORMAT_FXTOL
    },
    {                               // MATRIX        mxWorldToPage
        EFLOAT_1,                   // EFLOAT        efM11
        EFLOAT_0,                   // EFLOAT        efM12
        EFLOAT_0,                   // EFLOAT        efM21
        EFLOAT_1,                   // EFLOAT        efM22
        EFLOAT_0,                   // EFLOAT        efDx
        EFLOAT_0,                   // EFLOAT        efDy
        0,                          // FIX           fxDx
        0,                          // FIX           fxDy
        XFORM_SCALE          |      // FLONG         flAccel
        XFORM_UNITY          |
        XFORM_NO_TRANSLATION |
        XFORM_FORMAT_LTOL
    },

    EFLOAT_16,                      // EFLOAT efM11PtoD
    EFLOAT_16,                      // EFLOAT efM22PtoD
    EFLOAT_0,                       // EFLOAT efDxPtoD
    EFLOAT_0,                       // EFLOAT efDyPtoD

    MM_TEXT,                        // ULONG         iMapMode;
    0,                              // DWORD         dwLayout;
    0,                              // LONG          lWindowOrgx;

    {0,0},                          // POINTL        ptlWindowOrg;
    {1,1},                          // SIZEL         szlWindowExt;
    {0,0},                          // POINTL        ptlViewPortOrg;
    {1,1},                          // SIZEL         szlViewPortExt;

    WORLD_TO_PAGE_IDENTITY        | // flXform
    PAGE_TO_DEVICE_SCALE_IDENTITY |
    PAGE_TO_DEVICE_IDENTITY,

    {0,0},                          // SIZEL         szlVirtualDevicePixel;
    {0,0},                          // SIZEL         szlVirtualDeviceMm;
    {0,0},                          // POINTL        ptlBrushOrigin;
    {0}                             // RECTREGION    VisRectRegion;
};

DCLEVEL dclevelDefault =
{
    0,                              // HPAL          hpal;
    0,                              // PPALETTE      ppal;
    0,                              // PVOID         pColorSpace;
    DC_ICM_OFF,                     // ULONG         lIcmMode;
    1,                              // LONG          lSaveDepth;
    0,                              // LONG          lSaveDepthStartDoc;
    (HDC) 0,                        // HDC           hdcSave;
    {0,0},                          // POINTL        ptlKmBrushOrigin;
    (PBRUSH)NULL,                   // PBRUSH        pbrFill;
    (PBRUSH)NULL,                   // PBRUSH        pbrLine;
    (PLFONT)NULL,                   // PLFONT        plfntNew_;
    HPATH_INVALID,                  // HPATH         hpath;
    0,                              // FLONG         flPath;
    {                               // LINEATTRS     laPath;
        0,                          // FLONG         fl;
        0,                          // ULONG         iJoin;
        0,                          // ULONG         iEndCap;
        {IEEE_0_0F},                // FLOAT_LONG    elWidth;
        IEEE_10_0F,                 // FLOAT         eMiterLimit;
        0,                          // ULONG         cstyle;
        (PFLOAT_LONG) NULL,         // PFLOAT_LONG   pstyle;
        {IEEE_0_0F}                 // FLOAT_LONG    elStyleState;
    },
    NULL,                           // HRGN          prgnClip;
    NULL,                           // HRGN          prgnMeta;
    {                               // COLORADJUSTMENT   ca
        sizeof(COLORADJUSTMENT),    // WORD          caSize
        CA_DEFAULT,                 // WORD          caFlags
        ILLUMINANT_DEFAULT,         // WORD          caIlluminantIndex
        HT_DEF_RGB_GAMMA,           // WORD          caRedPowerGamma
        HT_DEF_RGB_GAMMA,           // WORD          caGreenPowerGamma
        HT_DEF_RGB_GAMMA,           // WORD          caBluePowerGamma
        REFERENCE_BLACK_DEFAULT,    // WORD          caReferenceBlack
        REFERENCE_WHITE_DEFAULT,    // WORD          caReferenceWhite
        CONTRAST_ADJ_DEFAULT,       // SHORT         caContrast
        BRIGHTNESS_ADJ_DEFAULT,     // SHORT         caBrightness
        COLORFULNESS_ADJ_DEFAULT,   // SHORT         caColorfulness
        REDGREENTINT_ADJ_DEFAULT,   // SHORT         caRedGreenTint
    },

    0,                              // FLONG         flFontState;
    {0,0},                          // UNIVERSAL_FONT_ID ufi;
    {{0,0},{0,0},{0,0},{0,0}},      // UNIVERSAL_FON_ID aQuickLinks[QUICK_UFI_LINKS]
    0,                              // PUNIVERSAL_FONT_ID pufi
    0,                              // UINT uNumLinkedFonts
    0,                              // BOOL bTurnOffLinking

    0,                              // FLONG         flFlags;
    0,                              // FLONG         flbrush;

    {                               // MATRIX        mxWorldToDevice
        EFLOAT_16,                  // EFLOAT        efM11
        EFLOAT_0,                   // EFLOAT        efM12
        EFLOAT_0,                   // EFLOAT        efM21
        EFLOAT_16,                  // EFLOAT        efM22
        EFLOAT_0,                   // EFLOAT        efDx
        EFLOAT_0,                   // EFLOAT        efDy
        0,                          // FIX           fxDx
        0,                          // FIX           fxDy
        XFORM_SCALE          |      // FLONG         flAccel
        XFORM_UNITY          |
        XFORM_NO_TRANSLATION |
        XFORM_FORMAT_LTOFX
    },
    {                               // MATRIX        mxDeviceToWorld
        EFLOAT_1Over16,             // EFLOAT        efM11
        EFLOAT_0,                   // EFLOAT        efM12
        EFLOAT_0,                   // EFLOAT        efM21
        EFLOAT_1Over16,             // EFLOAT        efM22
        EFLOAT_0,                   // EFLOAT        efDx
        EFLOAT_0,                   // EFLOAT        efDy
        0,                          // FIX           fxDx
        0,                          // FIX           fxDy
        XFORM_SCALE          |      // FLONG         flAccel
        XFORM_UNITY          |
        XFORM_NO_TRANSLATION |
        XFORM_FORMAT_FXTOL
    },
    {                               // MATRIX        mxWorldToPage
        EFLOAT_1,                   // EFLOAT        efM11
        EFLOAT_0,                   // EFLOAT        efM12
        EFLOAT_0,                   // EFLOAT        efM21
        EFLOAT_1,                   // EFLOAT        efM22
        EFLOAT_0,                   // EFLOAT        efDx
        EFLOAT_0,                   // EFLOAT        efDy
        0,                          // FIX           fxDx
        0,                          // FIX           fxDy
        XFORM_SCALE          |      // FLONG         flAccel
        XFORM_UNITY          |
        XFORM_NO_TRANSLATION |
        XFORM_FORMAT_LTOL
    },

    EFLOAT_16,                      // EFLOAT efM11PtoD
    EFLOAT_16,                      // EFLOAT efM22PtoD
    EFLOAT_0,                       // EFLOAT efDxPtoD
    EFLOAT_0,                       // EFLOAT efDyPtoD
    EFLOAT_0,                       // EFLOAT efM11_TWIPS
    EFLOAT_0,                       // EFLOAT efM22_TWIPS
    EFLOAT_0,                       // efPr11
    EFLOAT_0,                       // efPr22

    0,                              // SURFACE      *pSurface;
    {0,0},                          // SIZEL         sizl;
};

/******************************Public*Routine******************************\
* BOOL DCOBJ::bCleanDC ()
*
* Restores the DCLEVEL to the same as when DC was created via CreateDC (i.e,
* resets it back to dclevelDefault).  Also used to clean the DC before
* deletion.
*
* Returns:
*   TRUE if successful, FALSE if an error occurs.
*
* History:
*  21-May-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL XDCOBJ::bCleanDC ()
{

// Set TRUE if cleaning the DC invalidates the prfnt with respect to
// the DC's transform.

    BOOL bFontXformDirty;

// Sync the brush

    SYNC_DRAWING_ATTRS(pdc);

// If the current map mode is MM_TEXT and the current prfnt is NOT dirty
// with respect to the transform, then after we scrub the DC clean, the
// pfrnt is still clean with respect to transform.  Otherwise, the font
// is dirty with respect to transform.

    if ((ulMapMode() == MM_TEXT) && !this->pdc->bXFormChange())
        bFontXformDirty = FALSE;
    else
        bFontXformDirty = TRUE;

// Restore DC to lowest level.

    if (1 < lSaveDepth())
        GreRestoreDC(hdc(), 1);

// Restore the palette.

    if (ppal() != ppalDefault)
        GreSelectPalette(hdc(), (HPALETTE)dclevelDefault.hpal, TRUE);

    if (dctp() == DCTYPE_MEMORY)
    {
        // Restore the bitmap if necessary.

        hbmSelectBitmap(hdc(), STOCKOBJ_BITMAP, TRUE);

        // Watch out that DirectDraw sometimes marks DCTYPE_MEMORY
        // surfaces as being 'full-screen'.  Consequently, we have
        // to reset that here.
        //
        // (Note that we don't reset the flag for DCTYPE_DIRECT
        // surfaces, because that flag is automatically updated by
        // PDEVOBJ::bDisabled() for all DCTYPE_DIRECT surfaces when
        // the mode changes.)

        bInFullScreen(FALSE);
    }

// Reset pixel format.

    ipfdDevMax(-1);

// If any regions exist, delete them.

    if (pdc->dclevel.prgnClip != NULL)
    {
        RGNOBJ ro1(pdc->dclevel.prgnClip);

        // Note: GreRestoreDC(1) should guarantee regions' reference
        //       counts are 1

        ASSERTGDI (ro1.cGet_cRefs() == 1,
            "DCOBJ::bCleanDC(): bad ref count, deleting prgnClip\n");

        ro1.bDeleteRGNOBJ();
        pdc->dclevel.prgnClip = NULL;
    }

    if (pdc->dclevel.prgnMeta != NULL)
    {
        RGNOBJ ro2(pdc->dclevel.prgnMeta);

        // Note: GreRestoreDC(1) should guarantee regions' reference
        //       counts are 1

        ASSERTGDI (ro2.cGet_cRefs() == 1,
            "DCOBJ::bCleanDC(): bad ref count, deleting prgnMeta\n");

        ro2.bDeleteRGNOBJ();
        pdc->dclevel.prgnMeta = NULL;
    }

// delete the path

    if (pdc->dclevel.hpath != HPATH_INVALID)
    {
        XEPATHOBJ epath(pdc->dclevel.hpath);
        ASSERTGDI(epath.bValid(), "Invalid DC path");
        epath.vDelete();
    }

// Undo the locks from when the fill and line brushes were selected.
// (Un-reference-count the brushes.)

    DEC_SHARE_REF_CNT_LAZY0(pdc->dclevel.pbrFill);
    DEC_SHARE_REF_CNT_LAZY0(pdc->dclevel.pbrLine);

// make sure to delete the old logfont object if it is marked for deletion

    DEC_SHARE_REF_CNT_LAZY_DEL_LOGFONT(pdc->plfntNew());

// decrement ref count for the colorspace selected in DC.

    DEC_SHARE_REF_CNT_LAZY_DEL_COLORSPACE(pdc->dclevel.pColorSpace);

// Make sure everything else is set to default.
//
// Preserve 'pSurface' and 'sizl' in the DCLEVEL -- it may asynchronously
// be updated by dynamic mode changing.

    RtlCopyMemory(&pdc->dclevel, &dclevelDefault, offsetof(DCLEVEL, pSurface));
    RtlCopyMemory(pdc->pDCAttr, &DcAttrDefault, sizeof(DC_ATTR));

// Mark brush, charset, color space and color transform as dirty.

    ulDirtyAdd(DIRTY_BRUSHES|DIRTY_CHARSET|DIRTY_COLORSPACE|DIRTY_COLORTRANSFORM);

// Lock the fill and line brushes we just selected in.
// (Reference-count the brushes.)
// These locks can't fail.

    INC_SHARE_REF_CNT(pdc->dclevel.pbrFill);
    INC_SHARE_REF_CNT(pdc->dclevel.pbrLine);

// Clean up the font stuff.  (This must be done after copying the default
// dclevel).

    {
        PDEVOBJ pdo(hdev());

    // If display PDEV, then select System stock font.

        vSetDefaultFont(pdo.bDisplayPDEV());

    // if primary display dc, set the DC_PRIMARY_DISPLAY flag on

        if (hdev() == UserGetHDEV())
        {
            ulDirtyAdd(DC_PRIMARY_DISPLAY);
        }

// OK, set the dclevel's font xfrom dirty flag from the value computed
// BEFORE the GreRestoreDC.

        this->pdc->vXformChange(bFontXformDirty);
    }

// Lock color space we just selected in.

    INC_SHARE_REF_CNT(pdc->dclevel.pColorSpace);
    
    RFONTOBJ rfoDead(pdc->prfnt()); // special constructor deactivates
    pdc->prfnt(0);                  //                      this RFONT

// free up linked UFIs if not allocated pointing to fast buffer

    if(pdc->dclevel.pufi && (pdc->dclevel.pufi != pdc->dclevel.aQuickLinks))
    {
        VFREEMEM(pdc->dclevel.pufi);
        pdc->dclevel.pufi = NULL;
    }

// Set the filling origin to whatever the DC origin is.

    pdc->ptlFillOrigin(pdc->eptlOrigin().x,pdc->eptlOrigin().y);

// Assume Rao has been made dirty by the above work.

    pdc->vReleaseRao();

    return(TRUE);
}

/******************************Member*Function*****************************\
* XDCOBJ::bSetLinkedUFIs( PFF *ppff );
*
* Add the list of linked UFIs to tDC
*
* History:
*  Mon 15-Dec-1996 -by- Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/

BOOL XDCOBJ::bSetLinkedUFIs(PUNIVERSAL_FONT_ID pufis, UINT uNumUFIs)
{
    pdc->dclevel.bTurnOffLinking = (uNumUFIs) ? FALSE : TRUE;

// If pufi hasn't been initialized or it is too small, reinitialize it.

    if(!pdc->dclevel.pufi || (uNumUFIs > pdc->dclevel.uNumLinkedFonts))
    {
        if(pdc->dclevel.pufi && (pdc->dclevel.pufi != pdc->dclevel.aQuickLinks))
        {
            VFREEMEM(pdc->dclevel.pufi);
            pdc->dclevel.pufi = NULL;
        }

        if(uNumUFIs < QUICK_UFI_LINKS)
        {
            pdc->dclevel.pufi = pdc->dclevel.aQuickLinks;
        }
        else
        {
            if(!(pdc->dclevel.pufi = (PUNIVERSAL_FONT_ID)
                 PALLOCMEM(sizeof(UNIVERSAL_FONT_ID) * uNumUFIs,'ddaG')))
            {
                WARNING("GDI: XDCOBJ::bSetLinkedUFIs of of memory\n");
                pdc->dclevel.uNumLinkedFonts = 0;
                return(FALSE);
            }
        }
        pdc->dclevel.uNumLinkedFonts = uNumUFIs;
    }

    memcpy(pdc->dclevel.pufi, pufis, sizeof(UNIVERSAL_FONT_ID) * uNumUFIs);

    return(TRUE);
}

/******************************Member*Function*****************************\
* XDCOBJ::bAddRemoteFont( PFF *ppff );
*
* Add the PFF of a remote font to this DC.
*
* History:
*  Mon 06-Feb-1995 -by- Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/

BOOL XDCOBJ::bAddRemoteFont( PFF *ppff )
{
    BOOL bRet = FALSE;
    PFFLIST *pPFFList;

    pPFFList = (PFFLIST*) PALLOCMEM( sizeof(PFFLIST),'ddaG' );

    if( pPFFList == NULL )
    {
        WARNING("XDCOBJ::bAddRemoteFont unable to allocate memory\n");
    }
    else
    {
        pPFFList->pNext = pdc->pPFFList;
        pdc->pPFFList = pPFFList;
        pPFFList->pPFF = ppff;
        bRet = TRUE;
    }

    return(bRet);
}

/****************************Member*Function*****************************\
* XDCOBJ::bRemoveMergeFont(UNIVERSAL_FONT_ID ufi);
*
* Remove a merged font from the public font table and pPFFList in the dc.
*
* History:
*  Jan-27-1997  Xudong Wu  [tessiew]
* Wrote it.
\************************************************************************/
BOOL XDCOBJ::bRemoveMergeFont(UNIVERSAL_FONT_ID ufi)
{
    GDIFunctionID(XDCOBJ::bRemoveMergeFont);

    PFFLIST  *pPFFCur, *pPFFPrev;
    BOOL     bRet = FALSE;

    pPFFPrev = pPFFCur = pdc->pPFFList;

    while(pPFFCur && !bRet)
    {
        PFFOBJ  pffo(pPFFCur->pPFF);

        if (pffo.ulCheckSum() == ufi.CheckSum)
        {
            UINT    iFont;

            // check whether the Index field also match

            for (iFont = 0; iFont < pffo.cFonts(); iFont++ )
            {
                ASSERTGDI(pffo.ppfe(iFont), "Invalid ppfe\n");

                if (pffo.ppfe(iFont)->ufi.Index == ufi.Index)
                {
                    bRet = TRUE;
                    break;
                }
            }
        }
            
        if (!bRet)
        {
            pPFFPrev = pPFFCur;
            pPFFCur = pPFFCur->pNext;
        }
    }

    if (bRet)
    {
        GreAcquireSemaphoreEx(ghsemPublicPFT, SEMORDER_PUBLICPFT, NULL);

        PUBLIC_PFTOBJ   pfto;

        // bUnloadWorkhorse should release gpsemPublicePFT

        if (!(bRet = pfto.bUnloadWorkhorse(pPFFCur->pPFF, 0, ghsemPublicPFT, FR_NOT_ENUM)))
        {
            WARNING("Unable to delete the font.\n");
        }
        else
        {
            if (pPFFCur == pdc->pPFFList)
            {
                pdc->pPFFList = pPFFCur->pNext;
            }
            else
            {
                pPFFPrev->pNext = pPFFCur->pNext;
            }

            VFREEMEM(pPFFCur);
        }
    }

    return bRet;
}

/******************************Member*Function*****************************\
* DCMEMOBJ::DCMEMOBJ()
*
* Allocates RAM for a new DC.  Fills the RAM with default values.
*
* History:
*
*  Fri 07-Dec-1990 -by- Patrick Haluptzok [patrickh]
* Adding palette support
*
*  Thu 09-Aug-1990 17:29:25 -by- Charles Whitmer [chuckwh]
* Changed a little for NT DDI.
*
*  Fri 01-Sep-1989 04:36:19 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

DCMEMOBJ::DCMEMOBJ(
    ULONG iType,
    BOOL  bAltType)
{
    pdc = (PDC) NULL;
    bKeep = FALSE;

    //
    // Check the type.
    //

    ASSERTGDI((iType == DCTYPE_INFO)   ||
              (iType == DCTYPE_MEMORY) ||
              (iType == DCTYPE_DIRECT), "Invalid DC type");

    //
    // Allocate the DC 0 initialized
    //

    PDC pdcTemp = pdc = (PDC)HmgAlloc(sizeof(DC), DC_TYPE, HMGR_ALLOC_LOCK);

    if (pdcTemp != (PDC)NULL)
    {
        //
        // if this is an alternate DC (may need special attention on the client side
        // due to printing or metafiling) set the type to LO_ALTDC_TYPE from LO_TYPE
        //

        if (bAltType)
        {
            HmgModifyHandleType((HOBJ)MODIFY_HMGR_TYPE(pdcTemp->hGet(),LO_ALTDC_TYPE));
        }

        pdcTemp->dcattr    = DcAttrDefault;
        pdcTemp->pDCAttr   = &pdcTemp->dcattr;
        pdcTemp->dclevel   = dclevelDefault;

        //
        // Lock the fill and line brushes we just selected in as part of the
        // default DC.
        // (Reference-count the brushes.)
        // These locks can't fail.
        //

        INC_SHARE_REF_CNT(pdc->dclevel.pbrFill);
        INC_SHARE_REF_CNT(pdc->dclevel.pbrLine);
        INC_SHARE_REF_CNT(pdc->dclevel.pColorSpace);

        pdcTemp->dctp((DCTYPE) iType);
        pdcTemp->fs(0);
        ASSERTGDI(pdcTemp->hpal() == STOCKOBJ_PAL, "Bad initial hpal for DCMEMOBJ");
        ASSERTGDI(pdcTemp->hdcNext() == (HDC) 0, "ERROR this is baddfd343dc");
        ASSERTGDI(pdcTemp->hdcPrev() == (HDC) 0, "ERROR this is e43-99crok4");
        pdcTemp->ptlFillOrigin(0,0);
        ulDirty(DIRTY_BRUSHES|DIRTY_CHARSET|DIRTY_COLORSPACE|DIRTY_COLORTRANSFORM);

        //
        // Update the pointer to the COLORADJUSTMENT structure for
        // the 4 EBRUSHOBJ.
        //

        COLORADJUSTMENT *pca = pColorAdjustment();
        pdcTemp->peboFill()->pColorAdjustment(pca);
        pdcTemp->peboLine()->pColorAdjustment(pca);
        pdcTemp->peboText()->pColorAdjustment(pca);
        pdcTemp->peboBackground()->pColorAdjustment(pca);

        pdcTemp->prfnt(PRFNTNULL);
        pdcTemp->hlfntCur(HLFONT_INVALID);
        pdcTemp->flSimulationFlags(0);
        ulCopyCount((ULONG)-1);
        ipfdDevMax(-1);       // also reset in bCleanDC
        pdcTemp->prgnVis(NULL);
        pdcTemp->vPFFListSet(NULL);
        pdcTemp->vCXFListSet(NULL);
    }
}

/******************************Member*Function*****************************\
* DCMEMOBJ::DCMEMOBJ(&dcobjs)
*
* Create a new DC and copy in the DC passed to us.  This is used by
* SaveDC.
*
* History:
*  06-Jan-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

DCMEMOBJ::DCMEMOBJ(DCOBJ& dco)
{
    //
    // Assume failure.
    //

    bKeep = FALSE;

    //
    // Allocate the DC,
    //

    pdc = (PDC)HmgAlloc(sizeof(DC), DC_TYPE, HMGR_ALLOC_LOCK);

    if (pdc != (PDC)NULL)
    {
        pdc->fs(0);
        pdc->prgnVis(NULL);
        pdc->ppdev(dco.pdc->ppdev());

        //
        // shared attrs point to self
        //

        pdc->pDCAttr = &pdc->dcattr;
        dco.pdc->vCopyTo(*this);
    }
}

/******************************Member*Function*****************************\
* DCSAVE::vCopyTo
*
* Carbon copy the DCOBJ
*
* History:
*  24-Apr-1991 -by- Donald Sidoroff [donalds]
* Moved it out-of-line.
\**************************************************************************/

VOID DC::vCopyTo(XDCOBJ& dco)
{
    //
    // The dynamic mode changing code needs to be able to dynamically update
    // some fields in the DCLEVEL, and consequently needs to be able to track
    // all DCLEVELs.  So this routine should be used carefully and under
    // the appropriate lock to ensure that the dynamic mode change code does
    // not fall over.  We do both because one or the other might not have
    // set DC_SYNCHRONIZE.
    //

    vAssertDynaLock(TRUE);
    dco.pdc->vAssertDynaLock(TRUE);

    //
    // copy dc level and dcattr
    //

    *dco.pdc->pDCAttr = *pDCAttr;
    dco.pdc->dclevel = dclevel;
}

/******************************Member*Function*****************************\
* DCMEMOBJ::~DCMEMOBJ()
*
* Frees a DC unless told to keep it.
*
* History:
*  Sat 19-Aug-1989 00:30:53 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

DCMEMOBJ::~DCMEMOBJ()
{
    if (pdc != (PDC) NULL)
    {
        if (bKeep)
        {
            DEC_EXCLUSIVE_REF_CNT(pdc);
        }
        else
        {
            if (pdc->pDCAttr != &pdc->dcattr)
            {
                RIP("ERROR,~DCMEMOBJ on DC with client attrs\n");
            }

            //
            // shouldn't free DC with client attrs
            //

            HmgFree((HOBJ)pdc->hGet());
        }

        pdc = (PDC) NULL;
    }
}

/******************************Member*Function*****************************\
* DC::vUpdate_VisRect
*
* update user-mode vis region bounding rectangle if dirty
*
* History:
* 2/18/99 LingyunW [Lingyun Wang]
* Wrote it.
\**************************************************************************/
VOID DC::vUpdate_VisRect(REGION *prgn)
{
    //
    // update user-mode vis region bounding rectangle if dirty
    //
    if ((PENTRY_FROM_POBJ(this)->Flags & HMGR_ENTRY_INVALID_VIS))
    {

        if (prgn)
        {

            //
            // setup user-mode region info
            //

            RGNOBJ roVis(prgn);

            pDCAttr->VisRectRegion.Flags = roVis.iComplexity();


            if (roVis.iComplexity() == NULLREGION)
            {
                //
                // set pdcatrr vis rgn to NULLRGN
                //

                pDCAttr->VisRectRegion.Rect = rclEmpty;

            }
            else
            {
                PPOINTL pptlWindow = (PPOINTL)prclWindow();

                RECTL rcl;

                roVis.vGet_rcl(&rcl);

                //
                // subtract window offset from user-mode region
                //

                rcl.left   -= pptlWindow->x;
                rcl.top    -= pptlWindow->y;
                rcl.right  -= pptlWindow->x;
                rcl.bottom -= pptlWindow->y;

                pDCAttr->VisRectRegion.Rect = rcl;
            }

            //
            // mark DCATTR VIS region as valid
            //

        }
        else
        {
            pDCAttr->VisRectRegion.Rect = rclEmpty;

        }
        PENTRY_FROM_POBJ(this)->Flags &= ~HMGR_ENTRY_INVALID_VIS;

    }
}
/******************************Public*Routine******************************\
* DCREGION::bSetDefaultRegion(x, y)
*
* Set the default region and erclWindow for bitmaps and surfaces
*
* History:
*  11-Dec-1990 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL DC::bSetDefaultRegion()
{
// Release the old RaoRgn

    vReleaseRao();

// Get the extents

    SIZEL   sizl;

    vGet_sizlWindow(&sizl);

// Get a rectangle matching the device extents

    ERECTL  ercl(0, 0, sizl.cx, sizl.cy);

    //
    // Bug #310012: Under multimon, the rectangle isn't necessarily
    // based at 0,0. See dcrgn.cxx.
    //
    
    ERECTL  erclSurface = ercl;

    PDEVOBJ pdo(hdev());
    ASSERTGDI(pdo.bValid(), "Invalid pdev\n");
    {
        DEVLOCKOBJ dl(pdo);
        if (pdo.bMetaDriver() && bHasSurface() && pSurface()->bPDEVSurface())
        {
            erclSurface += *pdo.pptlOrigin();
        }
    }

// If a VisRgn exists, initialize it, else create a new one

    if ((prgnVis() != (REGION *) NULL) &&
        (prgnVis() != prgnDefault))
    {
        RGNOBJ  ro(prgnVis());

        ro.vSet((RECTL *) &erclSurface);
    }
    else
    {
        RGNMEMOBJ rmoRect;

        if (!rmoRect.bValid())
        {
            prgnVis(prgnDefault);
            return(FALSE);
        }

    // Set the region to the rectangle

        rmoRect.vSet((RECTL *) &erclSurface);

    // Make it long lived

        prgnVis(rmoRect.prgnGet());
    }
    prgnVis()->vStamp();

    eptlOrigin((EPOINTL*) &ercl);
    
    //
    // Note that we don't use erclSurface to set erclWindow.
    // erclWindow's value is a complete hack, and User won't fix it.
    // Their code requires that the top left point of erclWindow is equal
    // to the DC origin. On top of that, they overload the DC origin: e.g. in a 
    // monitor-specific DC for an 800x600 monitor
    // based at (1024,0), erclWindow is (-1024, 0, -224, 600). Go figure.
    //
    erclWindow(&ercl);
    
    erclClip(&erclSurface);

// Whenever DC origin changes, it affects ptlFillOrigin.  Since the origin
// was set to zero, we can just copy the brush origin in as the fill origin.

// set by user using a DC not owned by the current process

    ptlFillOrigin(&dcattr.ptlBrushOrigin);

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL DCPATH::bOldPenNominal(exo, lPenWidth)
*
* Decides if the old-style (created with CreatePen) pen is a nominal
* width pen or a wide line, depending on the current transform.
*
* History:
*  27-Jan-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

#define FX_THREE_HALVES         (LTOFX(1) + (LTOFX(1) >> 1))
#define FX_THREE_HALVES_SQUARED (FX_THREE_HALVES * FX_THREE_HALVES)

BOOL DC::bOldPenNominal(
EXFORMOBJ& exo,          // Current world-to-device transform
LONG lPenWidth)          // Pen's width
{
    BOOL   bRet = FALSE;

    if (!(pDCAttr->flXform & WORLD_TRANSFORM_SET))
    {
    // If no world transform set, use the same criteria as does Win3 (namely,
    // the pen is nominal if the transformed x-value is less than 1.5)

        EVECTORL evtl(lPenWidth, 0);

        if (exo.bXform(&evtl, (PVECTORFX) &evtl, 1))
            if (ABS(evtl.x) < FX_THREE_HALVES)
                bRet = TRUE;
    }
    else
    {
    // A world transform has been set.

        VECTORL avtl[2];

        avtl[0].x = lPenWidth;
        avtl[0].y = 0;
        avtl[1].x = 0;
        avtl[1].y = lPenWidth;

    // We want to be consistent under rotation when using the
    // intellectually challenged CreatePen pens, so we go to the trouble
    // of ensuring that the transformed axes of the pen lie within
    // a circle of radius 1.5:

        if (exo.bXform(avtl, (PVECTORFX) avtl, 2))
        {
        // We can kick out most pens with this simple test:

            if ((MAX(ABS(avtl[0].x), ABS(avtl[0].y)) < FX_THREE_HALVES) &&
                (MAX(ABS(avtl[1].x), ABS(avtl[1].y)) < FX_THREE_HALVES))

            // We now know it's safe to compute the square of the
            // Euclidean lengths in 32-bits without overflow:

                if (((avtl[0].x * avtl[0].x + avtl[0].y * avtl[0].y)
                                          < FX_THREE_HALVES_SQUARED) &&
                    ((avtl[1].x * avtl[1].x + avtl[1].y * avtl[1].y)
                                          < FX_THREE_HALVES_SQUARED))
                    bRet = TRUE;
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* VOID DC::vRealizeLineAttrs(exo)
*
* Initializes the given LINEATTRS structure.  Uses fields from the DC
* and the current brush.
*
* This function will be called as a result of a change in current pen,
* or a change in current transform.  As a result, we reset the style
* state.
*
* History:
*  23-Sep-1992 -by- Donald Sidoroff [donalds]
* Added failure case
*
*  27-Jan-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID DC::vRealizeLineAttrs(EXFORMOBJ& exo)
{
    PPEN ppen = (PPEN) dclevel.pbrLine;

    LINEATTRS *pla = &dclevel.laPath;

// Remember that we've realized the LINEATTRS for this pen:

    if (ppen->bIsOldStylePen())
    {
    // A pen of width zero is always nominal, regardless of the transform:

        if ((exo.bIdentity() && ppen->lWidthPen() <= 1) ||
            (ppen->lWidthPen() == 0)                    ||
            bOldPenNominal(exo, ppen->lWidthPen()))
        {
            pla->elWidth.l      = 1;                  // Nominal width line
            if (ppen->pstyle() != (PFLOAT_LONG) NULL)
            {
                pla->cstyle     = ppen->cstyle();     // Size of style array
                pla->pstyle     = ppen->pstyle();
                pla->fl         = LA_STYLED;          // Cosmetic, styled
            }
            else
            {
                pla->cstyle     = 0;
                pla->pstyle     = (PFLOAT_LONG) NULL;
                pla->fl         = 0;                  // Cosmetic, no style
            }
            pla->elStyleState.l = 0;                  // Reset style state
        }
        else
        {
            pla->fl        = LA_GEOMETRIC;       // Geometric
            pla->elWidth.e = ppen->l_eWidthPen(); // Need float value of width
            pla->cstyle    = 0;
            pla->pstyle    = (PFLOAT_LONG) NULL; // Old wide pens are un-styled
            pla->elStyleState.e = IEEE_0_0F;
        }
    }
    else
    {
    // New-style ExtCreatePen pen:

        if (ppen->bIsCosmetic())
        {
            pla->fl             = ppen->bIsAlternate() ? LA_ALTERNATE : 0;
            pla->elWidth.l      = ppen->lWidthPen();
            pla->elStyleState.l = 0;
        }
        else
        {
            pla->fl             = LA_GEOMETRIC;
            pla->elWidth.e      = ppen->l_eWidthPen();
            pla->elStyleState.e = IEEE_0_0F;
        }

        pla->cstyle = ppen->cstyle();
        pla->pstyle = ppen->pstyle();
        if (pla->pstyle != NULL)
        {
            pla->fl |= LA_STYLED;
        }
    }

    pla->iJoin   = ppen->iJoin();
    pla->iEndCap = ppen->iEndCap();
}

/******************************Public*Routine******************************\
* VOID DCOBJ::vAccumulate(ercl)
*
* Accumulate bounds
*
* History:
*  08-Dec-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID XDCOBJ::vAccumulate(ERECTL& ercl)
{
    if (bAccum())
    {
        erclBounds() |= ercl;
    }

    if (bAccumApp())
    {
        erclBoundsApp() |= ercl;
    }
}

/******************************Member*Function*****************************\
* DC::bMakeInfoDC
*
*   This routine is used to take a printer DC and temporarily make it a
*   Metafile DC for spooled printing.  This way it can be associated with
*   an enhanced metafile.  During this period, it should look and act just
*   like an info DC.
*
*   bSet determines if it should be set into the INFO DC state or restored
*   to the Direct state.
*
* History:
*  06-Jan-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL DC::bMakeInfoDC(
    BOOL bSet)
{
    BOOL bRet = FALSE;

    if (!bDisplay())
    {
        if (bSet)
        {
            if (!bTempInfoDC() && (dctp() == DCTYPE_DIRECT))
            {
                vSetTempInfoDC();
                dctp(DCTYPE_INFO);
                vSavePsurfInfo();

                // now that this is an info dc, we want it to be the size of
                // the entire surface

                PDEVOBJ pdo(hdev());

                if ((pdo.sizl().cx != sizl().cx) ||
                    (pdo.sizl().cy != sizl().cy))
                {
                    sizl(pdo.sizl());
                    bSetDefaultRegion();
                }


                bRet = TRUE;
            }
            else
            {
                WARNING("GreMakeInfoDC(TRUE) - already infoDC\n");
            }
        }
        else
        {
            if (bTempInfoDC() && (dctp() == DCTYPE_INFO))
            {
                vClearTempInfoDC();
                dctp(DCTYPE_DIRECT);
                vRestorePsurfInfo();

                // back to an direct DC.  It needs to be reset to the size of
                // the surface. (band)

                if (bHasSurface())
                {
                    if ((pSurface()->sizl().cx != sizl().cx) ||
                        (pSurface()->sizl().cy != sizl().cy))
                    {
                        sizl(pSurface()->sizl());
                        bSetDefaultRegion();
                    }
                }

                bRet = TRUE;
            }
            else
            {
                WARNING("GreMakeInfoDC(FALSE) - not infoDC\n");
            }
        }
    }
    else
    {
        WARNING("GreMakeInfoDC - on display dc\n");
    }

    return(bRet);
}

/******************************Member*Function*****************************\
* DC::vAssertDynaLock()
*
*   This routine verifies that appropriate locks are held before accessing
*   DC fields that may otherwise be changed asynchronously by the dynamic
*   mode-change code.
*
* History:
*  06-Feb-1996 -by-  J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

#if DBG

VOID DC::vAssertDynaLock(BOOL bDcLevelField)
{
    //
    // One of the following conditions is enough to allow the thread
    // to safely access fields that may be modified by the dyanmic
    // mode changing:
    //
    // 1.  It's an info DC, or a DC with the default bitmap selected in --
    //     these will not change modes;
    // 2.  It's a DCLEVEL specific field and a DIB is selected in that
    //     doesn't require DevLock locking;
    // 3.  Direct DC's that aren't the display, such as printers --
    //     these will not dynamically change modes;
    // 4.  That the DEVLOCK is held;
    // 5.  That the Palette semaphore is held;
    // 6.  That the Handle Manager semaphore is held;
    // 7.  That the USER semaphore is held.
    //

#if !defined(_GDIPLUS_)

    ASSERTGDI(!bHasSurface()                                         ||
              ((bDcLevelField) && !(fs() & DC_SYNCHRONIZEACCESS))    ||
              ((dctp() == DCTYPE_DIRECT) && !bDisplay())             ||
              (GreIsSemaphoreOwnedByCurrentThread(hsemDcDevLock_))   ||
              (GreIsSemaphoreSharedByCurrentThread(ghsemShareDevLock)) ||
              (GreIsSemaphoreOwnedByCurrentThread(ghsemPalette))     ||
              (GreIsSemaphoreOwnedByCurrentThread(ghsemHmgr))        ||
              UserIsUserCritSecIn(),
              "A dynamic mode change lock must be held to access this field");

#endif

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\dda.cxx ===
/*************************************************************************\
* Module Name: dda.cxx
*
* DDA calculations for clipping.
*
* Created: 20-Mar-1991
* Author: Paul Butzi
*
* Copyright (c) 1991-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

FLONG gaflRound[] = {
    FL_H_ROUND_DOWN | FL_V_ROUND_DOWN, // no flips
    FL_H_ROUND_DOWN | FL_V_ROUND_DOWN, // FLIP_D
    FL_H_ROUND_DOWN,                   // FLIP_V
    FL_V_ROUND_DOWN,                   // FLIP_V | FLIP_D
    FL_V_ROUND_DOWN,                   // SLOPE_ONE
    0xffffffff,                        // SLOPE_ONE | FLIP_D
    FL_H_ROUND_DOWN,                   // SLOPE_ONE | FLIP_V
    0xffffffff,                        // SLOPE_ONE | FLIP_V | FLIP_D

// These entries are used only by the complex line clipping component, which
// actually does a left-to-right flip about x = 0 (the line drawing code
// only does a left-for-right exchange and so doesn't need these extra
// bits):

    FL_V_ROUND_DOWN,                   // FLIP_H
    FL_H_ROUND_DOWN,                   // FLIP_H | FLIP_D
    0,                                 // FLIP_H | FLIP_V
    0,                                 // FLIP_H | FLIP_V | FLIP_D
    FL_V_ROUND_DOWN,                   // FLIP_H | SLOPE_ONE
    0xffffffff,                        // FLIP_H | SLOPE_ONE | FLIP_D
    FL_H_ROUND_DOWN,                   // FLIP_H | SLOPE_ONE | FLIP_V
    0xffffffff                         // FLIP_H | SLOPE_ONE | FLIP_V | FLIP_D
};

/******************************Public*Routine******************************\
* BOOL bInit(pptfx0, pptfx1)
*
* Does DDA setup for line clipping.
*
* Return:
*   TRUE  - ok.
*   FALSE - zero length line.
*
* History:
*  27-Aug-1992 -by- J. Andrew Goossen [andrewgo]
* Rewrote it.
*
*  20-Feb-1992 -by- J. Andrew Goossen [andrewgo]
* Made lines exclusive of the end-point.
*
*  4-Apr-1991 -by- Paul Butzi [paulb]
* Wrote it.
\**************************************************************************/

BOOL DDA_CLIPLINE::bInit(
POINTFIX* pptfx0,
POINTFIX* pptfx1)
{
    ULONG M0;
    ULONG N0;
    ULONG x0;
    ULONG x1;
    ULONG y0;

    fl = 0;

    M0 = pptfx0->x;
    dM = pptfx1->x;

    if ((LONG) dM < (LONG) M0)
    {
    // Line runs from right to left, so flip across x = 0:

        M0 = -(LONG) M0;
        dM = -(LONG) dM;
        fl |= FL_FLIP_H;
    }

// Compute the delta.  The DDI says we can never have a valid delta
// with a magnitude more than 2^31 - 1, but the engine never actually
// checks its transforms.  To ensure that we'll never puke on our shoes,
// we check for that case and simply refuse to draw the line:

    dM -= M0;
    if ((LONG) dM < 0)
        return(FALSE);

    N0 = pptfx0->y;
    dN = pptfx1->y;

    if ((LONG) dN < (LONG) N0)
    {
    // Line runs from bottom to top, so flip across y = 0:

        N0 = -(LONG) N0;
        dN = -(LONG) dN;
        fl |= FL_FLIP_V;
    }

// Compute another delta:

    dN -= N0;
    if ((LONG) dN < 0)
        return(FALSE);

    if (dN >= dM)
    {
        if (dN == dM)
        {
        // Have to special case slopes of one:

            fl |= FL_FLIP_SLOPE_ONE;
        }
        else
        {
        // Since line has slope greater than 1, flip across x = y:

            register ULONG ulTmp;
            SWAPL(dM, dN, ulTmp);
            SWAPL(M0, N0, ulTmp);
            fl |= FL_FLIP_D;
        }
    }

    fl |= gaflRound[(fl & FL_CLIPLINE_ROUND_MASK) >> FL_CLIPLINE_ROUND_SHIFT];

    ptlOrg.x = LFLOOR((LONG) M0);
    ptlOrg.y = LFLOOR((LONG) N0);

    M0 = FXFRAC(M0);
    N0 = FXFRAC(N0);

    {
    // Calculate the remainder term [ dM * (N0 + F/2) - M0 * dN ]

        eqGamma = Int32x32To64((LONG) dM, N0 + F/2) - Int32x32To64((LONG) dN, M0);
        if (fl & FL_V_ROUND_DOWN)
            eqGamma--;                   // Adjust so y = 1/2 rounds down
        eqGamma >>= FLOG2;
    }

/***********************************************************************\
* Figure out which pixels are at the ends of the line.                  *
\***********************************************************************/

// Calculate x0, x1:

    ULONG N1 = FXFRAC(N0 + dN);
    ULONG M1 = FXFRAC(M0 + dM);

    x1 = LFLOOR(M0 + dM);

// Line runs left-to-right:

// Compute x1:

    x1--;
    if (M1 > 0)
    {
        if (N1 == 0)
        {
            if (LROUND(M1, fl & FL_H_ROUND_DOWN))
                x1++;
        }
        else if (ABS((LONG) (N1 - F/2)) <= (LONG) M1)
        {
            x1++;
        }
    }

    if ((fl & (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
           == (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
    {
    // Have to special-case diagonal lines going through our
    // the point exactly equidistant between two horizontal
    // pixels, if we're supposed to round x=1/2 down:

        if ((M1 > 0) && (N1 == M1 + 8))
            x1--;

        if ((M0 > 0) && (N0 == M0 + 8))
        {
            x0 = 0;
            goto left_to_right_compute_y0;
        }
    }

// Compute x0:

    x0 = 0;
    if (M0 > 0)
    {
        if (N0 == 0)
        {
            if (LROUND(M0, fl & FL_H_ROUND_DOWN))
                x0 = 1;
        }
        else if (ABS((LONG) (N0 - F/2)) <= (LONG) M0)
        {
            x0 = 1;
        }
    }

// Compute y0:

left_to_right_compute_y0:

    y0 = 0;
    if ((eqGamma >> 32) >= 0 &&
        ((ULONG) eqGamma >= dM - (dN & (-(LONG) x0))))
    {
        y0 = 1;
    }

    if ((LONG) x1 < (LONG) x0)
        return(FALSE);

    lX0 = x0 + ptlOrg.x;
    lX1 = x1 + ptlOrg.x;
    lY0 = y0 + ptlOrg.y;

// Calculate y1 from the slope (this could be simplified so we wouldn't
// have to do a divide):

    LONGLONG eq = Int32x32To64((LONG) dN, x1) + eqGamma;
    lY1 = (LONG) DIV(eq,dM) + ptlOrg.y;

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\debug.h ===
/**************************************************************************\
 *
 * DEBUGGING macros
 *
\**************************************************************************/

#ifndef _GDIDEBUG_H_
#define _GDIDEBUG_H_

#define DBG_BASIC   (DBG || 0)
#define DBG_TRACE   (DBG || 0)

#define DBG_CORE    (DBG_BASIC || DBG_TRACE || DBG)


// GDIFunctionName
//   Used to identify the current function.
//   Use GDIFunctionID inside each function with the name of the function 
//     or some unique identifier.
//   Scope wil be used to resolve the right GDIFunctionName to use.
typedef const char *GDIFunctionNameType;
typedef const char GDIFunctionIDType[];

static const GDIFunctionNameType GDIFunctionName = NULL;   // This is the default value.

extern GDIFunctionIDType UnknownGDIFunc;

#define GDIFunctionID(id)   static const GDIFunctionIDType GDIFunctionName = #id


#if DBG_CORE
    extern HSEMAPHORE ghsemDEBUG;       // for serializing debug output
#endif


#if DBG_BASIC

    //
    // Variable defined in USER\server\server.c
    // set to 1 on DBG build trace through display driver loading
    //

    extern ULONG GreTraceDisplayDriverLoad;
    extern ULONG GreTraceFontLoad;

    VOID  WINAPI DoRip(PSZ);
    VOID  WINAPI DoWarning(PSZ,LONG);
    VOID  WINAPI DoIDRip(PCSTR,PSZ);
    VOID  WINAPI DoIDWarning(PCSTR,PSZ,LONG);

    #define RIP(x) do { if (GDIFunctionName) DoIDRip(GDIFunctionName, (PSZ) x); else DoRip((PSZ) x); } while (0)
    #define ASSERTGDI(x,y) if(!(x)) RIP(y)
    #define WARNING(x)  do { if (GDIFunctionName) DoIDWarning(GDIFunctionName,x,0); else DoWarning(x,0); } while (0)
    #define WARNING1(x) do { if (GDIFunctionName) DoIDWarning(GDIFunctionName,x,1); else DoWarning(x,1); } while (0)

    #define TRACE_INIT(str)  { if (GreTraceDisplayDriverLoad) {  KdPrint(str); } }
    #define TRACE_CACHE(str) { if (gflFontDebug & DEBUG_CACHE){  KdPrint(str); } }
    #define TRACE_INSERT(str) { if (gflFontDebug & DEBUG_INSERT){  KdPrint(str); } }

    #define TRACE_FONT(str) {                    \
        if (GreTraceFontLoad) {                  \
            TEB *pteb = NtCurrentTeb();          \
            CLIENT_ID *pId = &pteb->ClientId;    \
            GreAcquireSemaphore(ghsemDEBUG);     \
            KdPrint(("TRACE_FONT: p=%u t=%u\n",  \
                pId->UniqueProcess,              \
                pId->UniqueThread));             \
            KdPrint(("    "));                   \
            KdPrint(str);                        \
            KdPrint(("\n"));                     \
            GreReleaseSemaphore(ghsemDEBUG);     \
        }                                        \
    }

    VOID vPrintENUMLOGFONTEXDVW(ENUMLOGFONTEXDVW *pelfw);
    VOID vPrintIFIMETRICS(IFIMETRICS *pifi);

    #define DBGEXCEPT 1
    extern int bStopExcept;
    extern int bWarnExcept;

    #define WARNINGX(n)                                         \
    if (bWarnExcept)                                            \
    {                                                           \
        DbgPrint("GDI exception hit WARNINGX(%d)\n",n);         \
        if (bStopExcept)                                        \
            DbgBreakPoint();                                    \
    }


#else

    #define RIP(x)
    #define ASSERTGDI(x,y)
    #define WARNING(x)
    #define WARNING1(x)
    #define TRACE_INIT(str)
    #define TRACE_CACHE(str)
    #define TRACE_INSERT(str)
    #define TRACE_FONT(str)
    #define WARNINGX(n)

#endif


#if DBG_TRACE

    #define GDITRACE_KEYS_PER_CLASS     32

    // GDI Trace Classes
    typedef enum {
        GDITC_TEMP,

        GDITC_ATTRIBUTE,
        GDITC_BLT,
        GDITC_BRUSH,
        GDITC_CLIP,
        GDITC_COLOR,
        GDITC_CURVE,
        GDITC_DC,
        GDITC_DRV,
        GDITC_ENG,
        GDITC_FILL,
        GDITC_FONT,
        GDITC_LINE,
        GDITC_META,
        GDITC_PALETTE,
        GDITC_PATH,
        GDITC_PEN,
        GDITC_REGION,
        GDITC_SHAPE,
        GDITC_SPRITE,
        GDITC_SYSTEM,
        GDITC_TEXT,
        GDITC_VIEW,

        GDITC_TOTAL
    } GDITraceClass;

    // Special classes
    #define GDITC_0             0
    #define GDITC_NOCLASS       0

    // GDI Trace Entry Flags
    #define GDITRACE_FLAG_ALWAYS        0x01
    #define GDITRACE_FLAG_ANYTRACE      0x02
    #define GDITRACE_FLAG_IGNORE_CLASS  0x04
    #define GDITRACE_FLAG_INTERNAL_MASK 0x08
    #define GDITRACE_FLAG_INTERNAL      (GDITRACE_FLAG_INTERNAL_MASK | GDITRACE_FLAG_IGNORE_CLASS)

    #define GDITF_0             0
    #define GDITF_NOFLAG        0
    #define GDITF_ALWAYS        (GDITRACE_FLAG_ALWAYS << GDITRACE_FLAG_SHIFT)
    #define GDITF_ANYTRACE      (GDITRACE_FLAG_ANYTRACE << GDITRACE_FLAG_SHIFT)
    #define GDITF_IGNORE_CLASS  (GDITRACE_FLAG_IGNORE_CLASS << GDITRACE_FLAG_SHIFT)
    #define GDITF_INTERNAL_MASK (GDITRACE_FLAG_INTERNAL_MASK << GDITRACE_FLAG_SHIFT)
    #define GDITF_INTERNAL      (GDITRACE_FLAG_INTERNAL << GDITRACE_FLAG_SHIFT)


    typedef DWORD   GDITraceEntry;
    typedef WORD    GDITraceKeyMask;
    typedef DWORD   GDITraceClassMask;
    #define GDITRACE_KEY_MASK_BITS_TEST     16  // 8*sizeof(GDITraceKeyMask)
    #define GDITRACE_CLASS_MASK_BITS_TEST   32  // 8*sizeof(GDITraceClassMask)


    #define GDITRACE_ENTRY_BITS             (8*sizeof(GDITraceEntry))

    #define GDITRACE_KEY_MASK_BITS          (8*sizeof(GDITraceKeyMask))
    #define GDITRACE_FLAGS                  4
    #define GDITRACE_KEY_INDEX_BITS         (GDITRACE_ENTRY_BITS-GDITRACE_KEY_MASK_BITS-GDITRACE_FLAGS)

    // 1 bit to cover 2 masks per class (2 subclasses)
    #define GDITRACE_SUBCLASS_BITS          1
    #define GDITRACE_CLASS_BITS             (GDITRACE_KEY_INDEX_BITS-GDITRACE_SUBCLASS_BITS)

    // 5 bits cover 32 bit positions in a GDITraceClassMask
    #define GDITRACE_CLASS_MASK_BITPOS_BITS 5
    #define GDITRACE_CLASS_INDEX_BITS       (GDITRACE_CLASS_BITS-GDITRACE_CLASS_MASK_BITPOS_BITS)

    #if (1 << GDITRACE_SUBCLASS_BITS) != ((GDITRACE_KEYS_PER_CLASS+GDITRACE_KEY_MASK_BITS_TEST-1)/GDITRACE_KEY_MASK_BITS_TEST)
        #error Adjust GDITRACE_SUBCLASS_BITS to cover Key Masks per Class (SubClasses).
    #endif

    #define GDITRACE_CLASS_MASK_BITS        (1 << GDITRACE_CLASS_MASK_BITPOS_BITS)
    #if GDITRACE_CLASS_MASK_BITS != GDITRACE_CLASS_MASK_BITS_TEST
        #error  Adjust GDITRACE_CLASS_MASK_BITPOS_BITS to cover bit positions in GDITraceClassMask
    #endif

    typedef struct {
        GDITraceEntry   KeyMask:GDITRACE_KEY_MASK_BITS;
        GDITraceEntry   SubClass:GDITRACE_SUBCLASS_BITS;
        GDITraceEntry   ClassBitPos:GDITRACE_CLASS_MASK_BITPOS_BITS;
        GDITraceEntry   ClassIndex:GDITRACE_CLASS_INDEX_BITS;
        GDITraceEntry   Always:1;
        GDITraceEntry   Anytrace:1;
        GDITraceEntry   IgnoreClass:1;
        GDITraceEntry   Internal:1;
    } GDITraceEntryType;

    #define GDITRACE_KEY_SHIFT                 0
    #define GDITRACE_KEY_MASK                  ((1 << GDITRACE_KEY_MASK_BITS) - 1)
    #define GDITRACE_KEY_INDEX_SHIFT           (GDITRACE_KEY_SHIFT+GDITRACE_KEY_MASK_BITS)
    #define GDITRACE_KEY_INDEX_MASK            ((1 << GDITRACE_KEY_INDEX_BITS) - 1)
        #define GDITRACE_SUBCLASS_SHIFT             GDITRACE_KEY_INDEX_SHIFT
        #define GDITRACE_SUBCLASS_MASK              ((1 << GDITRACE_SUBCLASS_BITS) - 1)
        #define GDITRACE_CLASS_SHIFT                (GDITRACE_SUBCLASS_SHIFT+GDITRACE_SUBCLASS_BITS)
        #define GDITRACE_CLASS_MASK                 ((1 << GDITRACE_CLASS_BITS) - 1)
            #define GDITRACE_CLASS_MASK_BITPOS_SHIFT    GDITRACE_CLASS_SHIFT
            #define GDITRACE_CLASS_MASK_BITPOS_MASK     ((1 << GDITRACE_CLASS_MASK_BITPOS_BITS) - 1)
            #define GDITRACE_CLASS_INDEX_SHIFT          (GDITRACE_CLASS_MASK_BITPOS_SHIFT+GDITRACE_CLASS_MASK_BITPOS_BITS)
            #define GDITRACE_CLASS_INDEX_MASK           ((1 << GDITRACE_CLASS_INDEX_BITS) - 1)
    #define GDITRACE_FLAG_SHIFT                 (GDITRACE_KEY_INDEX_SHIFT+GDITRACE_KEY_INDEX_BITS)
    #define GDITRACE_FLAG_MASK                  ((1 << GDITRACE_FLAGS) - 1)

    #define GDITRACE_KEY_MASKS_PER_CLASS    ((GDITRACE_KEYS_PER_CLASS+GDITRACE_KEY_MASK_BITS-1)/GDITRACE_KEY_MASK_BITS)
    #define GDITRACE_TOTAL_KEY_MASKS        (GDITC_TOTAL*GDITRACE_KEY_MASKS_PER_CLASS)

    #define GDITRACE_TOTAL_CLASS_MASKS      ((GDITC_TOTAL+GDITRACE_CLASS_MASK_BITS-1)/GDITRACE_CLASS_MASK_BITS)

    extern GDITraceClassMask    gGDITraceClassMask[GDITRACE_TOTAL_CLASS_MASKS];
    extern GDITraceKeyMask      gGDITraceKeyMask[GDITRACE_TOTAL_KEY_MASKS];
    extern GDITraceKeyMask      gGDITraceInternalMask[GDITRACE_TOTAL_KEY_MASKS];
    extern HANDLE               gGDITraceHandle1;
    extern HANDLE               gGDITraceHandle2;
    extern BOOL                 gGDITraceHandleBreak;


    #define GDITRACE_COMPOSE_WORD_MASK  ((1 << (8*sizeof(WORD))) - 1)
    #define GDITRACE_COMPOSE_SHIFT_PER_WORD_INDEX                       \
        (8*sizeof(WORD)*sizeof(WORD)/sizeof(GDITraceKeyMask))
    #define GDITRACE_COMPOSE_WORD_INDICIES_PER_MASK                     \
        ((unsigned)(sizeof(GDITraceKeyMask)/sizeof(WORD)))

    // ComposeGDITE(WORD Mask, int MaskWordIndex, TOKEN Class, TOKEN Flag)
    #define ComposeGDITE(Mask, MaskWordIndex, Class, Flags)                    \
        (                                                                      \
            (((((Mask) & GDITRACE_COMPOSE_WORD_MASK) <<                        \
                (GDITRACE_COMPOSE_SHIFT_PER_WORD_INDEX*                        \
                 (MaskWordIndex % GDITRACE_COMPOSE_WORD_INDICIES_PER_MASK))) & \
              GDITRACE_KEY_MASK) << GDITRACE_KEY_SHIFT)                      | \
            (((MaskWordIndex / GDITRACE_COMPOSE_WORD_INDICIES_PER_MASK) &      \
              GDITRACE_SUBCLASS_MASK) << GDITRACE_SUBCLASS_SHIFT)            | \
            (((GDITC_##Class) & GDITRACE_CLASS_MASK) << GDITRACE_CLASS_SHIFT)| \
            ((GDITF_##Flags) & (GDITRACE_FLAG_MASK << GDITRACE_FLAG_SHIFT))    \
        )


    #define GDITE(Key)          GDITE_##Key

    // DEFTK( TOKEN Key, WORD Mask, int MaskWordIndex, TOKEN Class, TOKEN Flag)
    #define DEFTK(Key, Mask, MaskWordIndex, Class, Flags)                   \
        typedef enum {                                                      \
            GDITE(Key) = ComposeGDITE(Mask, MaskWordIndex, Class, Flags),   \
        } enum_GDITE_##Key;

    #define GDITM(Key)          (((GDITE(Key)) >> GDITRACE_KEY_SHIFT) & GDITRACE_KEY_MASK)
    #define GDITMIndex(Key)     (((GDITE(Key)) >> GDITRACE_KEY_INDEX_SHIFT) & GDITRACE_KEY_INDEX_MASK)

    #define GDITCBit(Key)       (((GDITE(Key)) >> GDITRACE_CLASS_MASK_BITPOS_SHIFT) & GDITRACE_CLASS_MASK_BITPOS_MASK)
    #define GDITCIndex(Key)     (((GDITE(Key)) >> GDITRACE_CLASS_INDEX_SHIFT) & GDITRACE_CLASS_INDEX_MASK)

    #define GDITFAlways(Key)    ((GDITE(Key)) & GDITF_ALWAYS)
    #define GDITFAnytrace(Key)  ((GDITE(Key)) & GDITF_ANYTRACE)
    #define GDITFIgnoreC(Key)   ((GDITE(Key)) & GDITF_IGNORE_CLASS)
    #define GDITFInternal(Key)  ((GDITE(Key)) & GDITF_INTERNAL_MASK)


    DEFTK(ALWAYS,                            0, 0, 0, ALWAYS)
    DEFTK(ANYTRACE,                          0, 0, 0, ANYTRACE)
    DEFTK(NEVER,                             0, 0, 0, IGNORE_CLASS)
    DEFTK(HANDLETRACE,                       0, 0, 0, IGNORE_CLASS)


    DEFTK(TEMP,                              0, 0, TEMP, 0)


    DEFTK(ATTRIBUTE,                         0, 0, ATTRIBUTE, 0)
    DEFTK(     GreGetBkColor,           0x0001, 0, ATTRIBUTE, 0)
    DEFTK(     GreSetBkColor,           0x0002, 0, ATTRIBUTE, 0)

    DEFTK(BLT,                               0, 0, BLT, 0)
    DEFTK(   NtGdiAlphaBlend,           0x0001, 0, BLT, 0)
    DEFTK(   NtGdiBitBlt,               0x0002, 0, BLT, 0)
    DEFTK(     GreGradientFill,         0x0004, 0, BLT, 0)
    DEFTK(     GreMaskBlt,              0x0008, 0, BLT, 0)
    DEFTK(   NtGdiMaskBlt,              0x0008, 0, BLT, 0)
    DEFTK(   NtGdiPatBlt,               0x0010, 0, BLT, 0)
    DEFTK(     GrePlgBlt,               0x0020, 0, BLT, 0)
    DEFTK(   NtGdiPlgBlt,               0x0020, 0, BLT, 0)
    DEFTK(     GrePolyPatBlt,           0x0040, 0, BLT, 0)
    DEFTK(   NtGdiPolyPatBlt,           0x0040, 0, BLT, 0)
    DEFTK(     GrePolyPatBltInternal,   0x0040, 0, BLT, INTERNAL)
    DEFTK(     GreStretchBlt,           0x0080, 0, BLT, 0)
    DEFTK(   NtGdiStretchBlt,           0x0080, 0, BLT, 0)
    DEFTK(   NtGdiTransparentBlt,       0x0100, 0, BLT, 0)

    DEFTK(BRUSH,                             0, 0, BRUSH, 0)

    DEFTK(CLIP,                              0, 0, CLIP, 0)
    DEFTK(     GreExcludeClipRect,      0x0001, 0, CLIP, 0)
    DEFTK(   NtGdiExcludeClipRect,      0x0001, 0, CLIP, 0)
    DEFTK(     GreGetAppClipBox,        0x0002, 0, CLIP, 0)
    DEFTK(   NtGdiGetAppClipBox,        0x0002, 0, CLIP, 0)
    DEFTK(     GreGetClipBox,           0x0004, 0, CLIP, 0)
    DEFTK(     GreIntersectClipRect,    0x0008, 0, CLIP, 0)
    DEFTK(   NtGdiIntersectClipRect,    0x0008, 0, CLIP, 0)
    DEFTK(   NtGdiOffsetClipRgn,        0x0010, 0, CLIP, 0)
    DEFTK(   NtGdiSelectClipPath,       0x0020, 0, CLIP, 0)
    DEFTK(  GreExtSelectClipRgn,        0x0040, 0, CLIP, 0)
    DEFTK(NtGdiExtSelectClipRgn,        0x0040, 0, CLIP, 0)

    DEFTK(CURVE,                             0, 0, CURVE, 0)

    DEFTK(DC,                                0, 0, DC, 0)

    DEFTK(DRV,                               0, 0, DRV, 0)

    DEFTK(ENG,                               0, 0, ENG, 0)

    DEFTK(FILL,                              0, 0, FILL, 0)
    DEFTK(   NtGdiFillRgn,              0x000, 0, FILL, 0)
    DEFTK(   NtGdiFrameRgn,             0x000, 0, FILL, 0)
    DEFTK(   NtGdiInvertRgn,            0x000, 0, FILL, 0)

    DEFTK(FONT,                              0, 0, FONT, 0)

    DEFTK(LINE,                              0, 0, LINE, 0)

    DEFTK(META,                              0, 0, META, 0)

    DEFTK(PALETTE,                           0, 0, PALETTE, 0)

    DEFTK(PATH,                              0, 0, PATH, 0)
    DEFTK(   NtGdiPathToRegion,         0x000, 0, PATH, 0)

    DEFTK(PEN,                               0, 0, PEN, 0)

    DEFTK(REGION,                            0, 0, REGION, 0)
    DEFTK(     GreCombineRgn,           0x0001, 0, REGION, 0)
    DEFTK(   NtGdiCombineRgn,           0x0001, 0, REGION, 0)
    DEFTK(   NtGdiCreateEllipticRgn,    0x0002, 0, REGION, 0)
    DEFTK(     GreCreatePolyPolygonRgnInternal, 0x0004, 0, REGION, 0)
    DEFTK(     GreCreateRectRgn,        0x0008, 0, REGION, 0)
    DEFTK(   NtGdiCreateRectRgn,        0x0008, 0, REGION, 0)
    DEFTK(     GreCreateRectRgnIndirect,0x0010, 0, REGION, 0)
    DEFTK(  GreExtCreateRegion,         0x0020, 0, REGION, 0)
    DEFTK(NtGdiExtCreateRegion,         0x0020, 0, REGION, 0)
    DEFTK(   NtGdiCreateRoundRectRgn,   0x0040, 0, REGION, 0)
    DEFTK(   NtGdiEqualRgn,             0x0080, 0, REGION, 0)
    DEFTK(     GreGetRandomRgn,         0x0100, 0, REGION, 0)
    DEFTK(   NtGdiGetRandomRgn,         0x0100, 0, REGION, 0)
    DEFTK(     GreGetRegionData,        0x0200, 0, REGION, 0)
    DEFTK(   NtGdiGetRegionData,        0x0200, 0, REGION, 0)
    DEFTK(     GreGetRgnBox,            0x0400, 0, REGION, 0)
    DEFTK(   NtGdiGetRgnBox,            0x0400, 0, REGION, 0)
    DEFTK(     GreOffsetRgn,            0x0800, 0, REGION, 0)
    DEFTK(   NtGdiOffsetRgn,            0x0800, 0, REGION, 0)
    DEFTK(     GrePtInRegion,           0x1000, 0, REGION, 0)
    DEFTK(   NtGdiPtInRegion,           0x1000, 0, REGION, 0)
    DEFTK(     GreRectInRegion,         0x2000, 0, REGION, 0)
    DEFTK(   NtGdiRectInRegion,         0x2000, 0, REGION, 0)
    DEFTK(     GreSetRectRgn,           0x4000, 0, REGION, 0)
    DEFTK(   NtGdiSetRectRgn,           0x4000, 0, REGION, 0)
    DEFTK(     GreSubtractRgnRectList,  0x8000, 0, REGION, 0)

    DEFTK(SHAPE,                             0, 0, SHAPE, 0)

    DEFTK(SPRITE,                            0, 0, SPRITE, 0)

    DEFTK(SYSTEM,                            0, 0, SYSTEM, 0)
    DEFTK(   NtGdiFlushUserBatch,       0x0001, 0, SYSTEM, 0)

    DEFTK(TEXT,                              0, 0, TEXT, 0)

    DEFTK(VIEW,                              0, 0, VIEW, 0)
    DEFTK(     GreGetViewportOrg,       0x000, 0, VIEW, 0)
    DEFTK(     GreSetViewportOrg,       0x000, 0, VIEW, 0)


    __inline
    BOOL
    GDITraceEnabled()
    {
        int i;
        for (i = 0; i < GDITRACE_TOTAL_CLASS_MASKS; i++)
            if (gGDITraceClassMask[i]) return TRUE;
        for (i = 0; i < GDITRACE_TOTAL_KEY_MASKS; i++)
            if (gGDITraceKeyMask[i]) return TRUE;
        return FALSE;
    }


    #define GDITraceWrapCore(key, code)                                         \
        if (!GDITFInternal(key) ||                                              \
            (GDITM(key) & gGDITraceInternalMask[GDITMIndex(key)])               \
            )                                                                   \
        {                                                                       \
            code;                                                               \
        }

    #define GDITraceWrap(key, code)                                             \
    do {                                                                        \
        BOOL GDITraceSuccess;                                                   \
        GDITraceWrapCore(key, code)                                             \
    } while ( 0 )

    #define GDITracePrint(prefix, msg, arglist)                                 \
    do {                                                                        \
        if (GDIFunctionName)                                                     \
        {                                                                       \
            DbgPrint(prefix);                                                   \
            EngDebugPrint((PCHAR)GDIFunctionName, msg, arglist);                 \
        }                                                                       \
        else                                                                    \
        {                                                                       \
            EngDebugPrint(prefix, msg, arglist);                                \
        }                                                                       \
    } while ( 0 )

    #define GDITraceCore(ss, key, msg, arglist)                                 \
    if (GDITFAlways(key) || GDITFAnytrace(key))                                 \
    {                                                                           \
        if (GDITFAlways(key) || GDITraceEnabled())                              \
        {                                                                       \
            GreAcquireSemaphore(ghsemDEBUG);                                    \
            GDITracePrint("GDI: ", msg, arglist);                               \
            GreReleaseSemaphore(ghsemDEBUG);                                    \
            if (ss) GDITraceSuccess = TRUE;                                     \
        }                                                                       \
    }                                                                           \
    else if ((GDITM(key) != 0) &&                                               \
             ((GDITM(key) & gGDITraceKeyMask[GDITMIndex(key)]) ||               \
              ((! GDITFIgnoreC(key)) &&                                         \
               ((1 << GDITCBit(key)) & gGDITraceClassMask[GDITCIndex(key)]))))  \
    {                                                                           \
        GreAcquireSemaphore(ghsemDEBUG);                                        \
        if (ss) {                                                               \
            GDITracePrint("GDI: ", msg, arglist);                               \
            GDITraceSuccess = TRUE;                                             \
        } else {                                                                \
            EngDebugPrint("GDI: " #key, msg, arglist);                          \
        }                                                                       \
        GreReleaseSemaphore(ghsemDEBUG);                                        \
    }                                                                           \
    else if ((! GDITFIgnoreC(key)) &&                                           \
             ((1 << GDITCBit(key)) & gGDITraceClassMask[GDITCIndex(key)]))      \
    {                                                                           \
        GreAcquireSemaphore(ghsemDEBUG);                                        \
        EngDebugPrint("GDI: " #key " Trace ", msg, arglist);                    \
        GreReleaseSemaphore(ghsemDEBUG);                                        \
        if (ss) GDITraceSuccess = TRUE;                                         \
    }


    #define GDITraceHandleMatch(ss, key, msg, arglist)                          \
    do {                                                                        \
        GreAcquireSemaphore(ghsemDEBUG);                                        \
        if (ss) {                                                               \
            GDITracePrint("GDI: hMatch: ", msg, arglist);                       \
            GDITraceSuccess = TRUE;                                             \
        } else {                                                                \
            EngDebugPrint("GDI: hMatch: " #key, msg, arglist);                  \
        }                                                                       \
        if (gGDITraceHandleBreak)                                               \
        {                                                                       \
            EngDebugBreak();                                                    \
        }                                                                       \
        GreReleaseSemaphore(ghsemDEBUG);                                        \
    } while ( 0 )


    #define GDITraceHandleCore(ss, key, msg, arglist, handle)                   \
        HANDLE Handle = (HANDLE)(handle);                                       \
        if ((Handle != NULL) &&                                                 \
            ((gGDITraceHandle1 == Handle) ||                                    \
             (gGDITraceHandle2 == Handle)))                                     \
        {                                                                       \
            GDITraceHandleMatch(ss, key, msg, arglist);                         \
        }

/*
    #define GDITraceHandle2Core(ss, key, msg, arglist, handle1, handle2)        \
        HANDLE Handle1 = (HANDLE)(handle1);                                     \
        HANDLE Handle2 = (HANDLE)(handle2);                                     \
        if (((gGDITraceHandle1 != NULL) &&                                      \
             ((gGDITraceHandle1 == Handle1) ||                                  \
              (gGDITraceHandle1 == Handle2))                                    \
            ) ||                                                                \
            ((gGDITraceHandle2 != NULL) &&                                      \
             ((gGDITraceHandle2 == Handle1) ||                                  \
              (gGDITraceHandle2 == Handle2))                                    \
           ))                                                                   \
        {                                                                       \
            GDITraceHandleMatch(ss, key, msg, arglist);                         \
        }
*/

    #define GDITraceHandle3Core(ss, key, msg, arglist, handle1, handle2, handle3)\
        HANDLE Handle1 = (HANDLE)(handle1);                                     \
        HANDLE Handle2 = (HANDLE)(handle2);                                     \
        HANDLE Handle3 = (HANDLE)(handle3);                                     \
        if (((gGDITraceHandle1 != NULL) &&                                      \
             ((gGDITraceHandle1 == Handle1) ||                                  \
              (gGDITraceHandle1 == Handle2) ||                                  \
              (gGDITraceHandle1 == Handle3))                                    \
            ) ||                                                                \
            ((gGDITraceHandle2 != NULL) &&                                      \
             ((gGDITraceHandle2 == Handle1) ||                                  \
              (gGDITraceHandle2 == Handle2) ||                                  \
              (gGDITraceHandle2 == Handle3))                                    \
           ))                                                                   \
        {                                                                       \
            GDITraceHandleMatch(ss, key, msg, arglist);                         \
        }


    // GDITraceXxxx Parameters
    //
    //      key    - key setup by DEFTK or defined as GDITE_key
    //      msg     - msg printf formatted string
    //      arglist - var arg pointer
    //      handle  - handle(s) used at this trace point

    // Test key key and print "GDI: <key><msg>"
    #define GDITrace(key, msg, arglist)                 \
    GDITraceWrap(key,                                   \
        GDITraceCore(0, key, msg, arglist)              \
    )

    // Test handle and print "GDI: hMatch: <key><msg>" or do GDITrace
    #define GDITraceHandle(key, msg, arglist, handle)                           \
    GDITraceWrap(key,                                                           \
        GDITraceHandleCore(0, key, msg, arglist, handle)                        \
        else GDITraceCore(0, key, msg, arglist)                                 \
    )

    // Test handles and print "GDI: hMatch: <key><msg>" or do GDITrace
    #define GDITraceHandle2(key, msg, arglist, handle1, handle2)                \
        GDITraceHandle3(key, msg, arglist, handle1, handle2, NULL)

    // Test handles and print "GDI: hMatch: <key><msg>" or do GDITrace
    #define GDITraceHandle3(key, msg, arglist, handle1, handle2, handle3)       \
    GDITraceWrap(key,                                                           \
        GDITraceHandle3Core(0, key, msg, arglist, handle1, handle2, handle3)    \
        else GDITraceCore(0, key, msg, arglist)                                 \
    )


    // Mark beginning of trace with multiple tests
    //   msg and arglist will be used in the print message for any
    //   successful GDITraceMultiXxxx prior to GDITraceMultiEnd.
    //   GDIFunctionName will be printed if GDIFunctionID is used.
    #define GDITraceMultiBegin(msg, arglist)                        \
    do {                                                            \
        BOOL  GDITraceSuccess = FALSE;                              \
        const PCHAR MultiMsg = msg;                                 \
        const va_list MultiList = arglist

    // Test key key and print "GDI: <GDIFunctionName><msg>"
    #define GDITraceMulti(key)                                      \
        if (!GDITraceSuccess)                                       \
        {                                                           \
            GDITraceWrapCore(key,                                   \
                GDITraceCore(1, key, MultiMsg, MultiList)           \
            )                                                       \
        }

    // Test handle and print "GDI: hMatch: <GDIFunctionName><msg>"
    #define GDITraceMultiHandle(handle)                             \
        GDITraceMultiHandle3(handle, NULL, NULL)

    // Test handles and print "GDI: hMatch: <GDIFunctionName><msg>"
    #define GDITraceMultiHandle2(handle1, handle2)                  \
        GDITraceMultiHandle3(handle1, handle2, NULL)

    // Test handles and print "GDI: hMatch: <GDIFunctionName><msg>"
    #define GDITraceMultiHandle3(handle1, handle2, handle3)         \
        if (!GDITraceSuccess)                                       \
        {                                                           \
            GDITraceHandle3Core(1, HANDLETRACE, MultiMsg, MultiList, handle1, handle2, handle3) \
        }

    // Mark end of trace with multiple tests
    #define GDITraceMultiEnd()                                      \
    } while ( 0 )

#else
    #define GDITE(Key)
    #define DEFTK(Key, Mask, MaskWordIndex, Class, Flags)

    #define GDITrace(key, msg, arglist)
    #define GDITraceHandle(key, msg, arglist, handle)
    #define GDITraceHandle2(key, msg, arglist, handle1, handle2)
    #define GDITraceHandle3(key, msg, arglist, handle1, handle2, handle3)

    #define GDITraceMultiBegin(msg, arglist)
    #define GDITraceMulti(key)
    #define GDITraceMultiHandle(handle)
    #define GDITraceMultiHandle2(handle1, handle2)
    #define GDITraceMultiHandle3(handle1, handle2, handle3)
    #define GDITraceMultiEnd()
#endif

#endif  _GDIDEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\ddsup.cxx ===
/******************************Module*Header*******************************\
* Module Name: ddsup.cxx                                                   *
*                                                                          *
* Copyright (c) 1990-2000 Microsoft Corporation                            *
*                                                                          *
* DirectDraw support routines                                              *
*                                                                          *
\**************************************************************************/

#include "precomp.hxx"

DRVFN gaEngFuncs[] =
{
    { INDEX_DxEngUnused,                      (PFN) NULL                             },
    { INDEX_DxEngIsTermSrv,                   (PFN) DxEngIsTermSrv                   },
    { INDEX_DxEngScreenAccessCheck,           (PFN) DxEngScreenAccessCheck           },
    { INDEX_DxEngRedrawDesktop,               (PFN) DxEngRedrawDesktop               },
    { INDEX_DxEngDispUniq,                    (PFN) DxEngDispUniq                    },
    { INDEX_DxEngIncDispUniq,                 (PFN) DxEngIncDispUniq                 },
    { INDEX_DxEngVisRgnUniq,                  (PFN) DxEngVisRgnUniq                  },
    { INDEX_DxEngLockShareSem,                (PFN) DxEngLockShareSem                },
    { INDEX_DxEngUnlockShareSem,              (PFN) DxEngUnlockShareSem              },
    { INDEX_DxEngEnumerateHdev,               (PFN) DxEngEnumerateHdev               },
    { INDEX_DxEngLockHdev,                    (PFN) DxEngLockHdev                    },
    { INDEX_DxEngUnlockHdev,                  (PFN) DxEngUnlockHdev                  },
    { INDEX_DxEngIsHdevLockedByCurrentThread, (PFN) DxEngIsHdevLockedByCurrentThread },
    { INDEX_DxEngReferenceHdev,               (PFN) DxEngReferenceHdev               },
    { INDEX_DxEngUnreferenceHdev,             (PFN) DxEngUnreferenceHdev             },   
    { INDEX_DxEngGetDeviceGammaRamp,          (PFN) DxEngGetDeviceGammaRamp          },
    { INDEX_DxEngSetDeviceGammaRamp,          (PFN) DxEngSetDeviceGammaRamp          },
    { INDEX_DxEngSpTearDownSprites,           (PFN) DxEngSpTearDownSprites           },
    { INDEX_DxEngSpUnTearDownSprites,         (PFN) DxEngSpUnTearDownSprites         },
    { INDEX_DxEngSpSpritesVisible,            (PFN) DxEngSpSpritesVisible            },
    { INDEX_DxEngGetHdevData,                 (PFN) DxEngGetHdevData                 },
    { INDEX_DxEngSetHdevData,                 (PFN) DxEngSetHdevData                 },
    { INDEX_DxEngCreateMemoryDC,              (PFN) DxEngCreateMemoryDC              },
    { INDEX_DxEngGetDesktopDC,                (PFN) DxEngGetDesktopDC                },
    { INDEX_DxEngDeleteDC,                    (PFN) DxEngDeleteDC                    },
    { INDEX_DxEngCleanDC,                     (PFN) DxEngCleanDC                     },
    { INDEX_DxEngSetDCOwner,                  (PFN) DxEngSetDCOwner                  },
    { INDEX_DxEngLockDC,                      (PFN) DxEngLockDC                      },
    { INDEX_DxEngUnlockDC,                    (PFN) DxEngUnlockDC                    },
    { INDEX_DxEngSetDCState,                  (PFN) DxEngSetDCState                  },
    { INDEX_DxEngGetDCState,                  (PFN) DxEngGetDCState                  },
    { INDEX_DxEngSelectBitmap,                (PFN) DxEngSelectBitmap                },
    { INDEX_DxEngSetBitmapOwner,              (PFN) DxEngSetBitmapOwner              },
    { INDEX_DxEngDeleteSurface,               (PFN) DxEngDeleteSurface               },
    { INDEX_DxEngGetSurfaceData,              (PFN) DxEngGetSurfaceData              },
    { INDEX_DxEngAltLockSurface,              (PFN) DxEngAltLockSurface              },
    { INDEX_DxEngUploadPaletteEntryToSurface, (PFN) DxEngUploadPaletteEntryToSurface },
    { INDEX_DxEngMarkSurfaceAsDirectDraw,     (PFN) DxEngMarkSurfaceAsDirectDraw     },
    { INDEX_DxEngSelectPaletteToSurface,      (PFN) DxEngSelectPaletteToSurface      },
    { INDEX_DxEngSyncPaletteTableWithDevice,  (PFN) DxEngSyncPaletteTableWithDevice  },
    { INDEX_DxEngSetPaletteState,             (PFN) DxEngSetPaletteState             },
    { INDEX_DxEngGetRedirectionBitmap,        (PFN) DxEngGetRedirectionBitmap        },
    { INDEX_DxEngLoadImage,                   (PFN) DxEngLoadImage                   }
};

ULONG gcEngFuncs = sizeof(gaEngFuncs) / sizeof(DRVFN);

DRVFN *gpDxFuncs = NULL;

HANDLE                ghDxGraphics = NULL;
PFN_StartupDxGraphics gpfnStartupDxGraphics = NULL;
PFN_CleanupDxGraphics gpfnCleanupDxGraphics = NULL;

DWORD gdwDirectDrawContext = 0;

extern ULONG giVisRgnUniqueness;

extern "C" ULONG APIENTRY DxApiGetVersion(VOID);

/******************************Public*Routine******************************\
* DxDdStartupDxGraphics()
*
* History:
*
* Write it:
*    31-Aug-2000 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

NTSTATUS DxDdStartupDxGraphics(
    ULONG          dummy1,
    DRVENABLEDATA *dummy2,
    ULONG          dummy3,
    DRVENABLEDATA *dummy4,
    DWORD         *dummy5,
    PEPROCESS      pepSession)
{
    NTSTATUS NtStatus;

    UNREFERENCED_PARAMETER(dummy1);
    UNREFERENCED_PARAMETER(dummy2);
    UNREFERENCED_PARAMETER(dummy3);
    UNREFERENCED_PARAMETER(dummy4);

    // Note: this is a dummy call to bring in dxapi.sys which we link to
    DxApiGetVersion();

    //
    // Load directx driver.
    //
    ghDxGraphics = EngLoadImage(L"drivers\\dxg.sys");

    if (ghDxGraphics)
    {
        //
        // Get initialization entry point.
        //
        gpfnStartupDxGraphics = (PFN_StartupDxGraphics)
                EngFindImageProcAddress(ghDxGraphics,"DxDdStartupDxGraphics");

        //
        // Get Un-initialization entry point.
        //
        gpfnCleanupDxGraphics = (PFN_CleanupDxGraphics)
                EngFindImageProcAddress(ghDxGraphics,"DxDdCleanupDxGraphics");

        if ((gpfnStartupDxGraphics == NULL) ||
            (gpfnCleanupDxGraphics == NULL))
        {
            WARNING("Can't find initalization export from dxg.sys");
            NtStatus = STATUS_PROCEDURE_NOT_FOUND;
            goto DxDd_InitError;
        }

        //
        // Initialize directx driver.
        //
        DRVENABLEDATA dedEng;
        DRVENABLEDATA dedDxg;

        // iDriverVersion for win32k.sys version
        //
        //  - 0x00050001 for Whistler

        dedEng.iDriverVersion = 0x00050001;
        dedEng.c              = gcEngFuncs;
        dedEng.pdrvfn         = gaEngFuncs;

        NtStatus = (*gpfnStartupDxGraphics)(sizeof(DRVENABLEDATA),
                                            &dedEng,
                                            sizeof(DRVENABLEDATA),
                                            &dedDxg,
                                            &gdwDirectDrawContext,
                                            pepSession);

        if (NT_SUCCESS(NtStatus))
        {
            //
            // Keep the pointer to array of dxg calls
            //
            gpDxFuncs = dedDxg.pdrvfn;

            //
            // Now everything initialized correctly.
            //
            return (STATUS_SUCCESS);
        }
        else
        {
            WARNING("Failed on initialization for dxg.sys");

            //
            // fall through to error handling code.
            //
        }
    }
    else
    {
        WARNING("Failed on loading dxg.sys");

        //
        // fall through to error handling code.
        //
        NtStatus = STATUS_DLL_NOT_FOUND;
    }

DxDd_InitError:

    if (ghDxGraphics)
    {
        EngUnloadImage(ghDxGraphics);
    }

    //
    // Put eveything back to NULL. 
    //
    ghDxGraphics = NULL;
    gpfnStartupDxGraphics = NULL;
    gpfnCleanupDxGraphics = NULL;
    gpDxFuncs = NULL;

    return (NtStatus);
}

/******************************Public*Routine******************************\
* DxDdCleanupDxGraphics()
*
* History:
*
* Write it:
*    31-Aug-2000 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

NTSTATUS DxDdCleanupDxGraphics(VOID)
{
    if (ghDxGraphics)
    {
        //
        // call directx driver to let them clean up.
        //
        if (gpfnCleanupDxGraphics)
        {
            (*gpfnCleanupDxGraphics)();
        }

        //
        // Unload modules.
        //
        EngUnloadImage(ghDxGraphics);
    }

    //
    // Put eveything back to NULL. 
    //
    ghDxGraphics = NULL;
    gpfnStartupDxGraphics = NULL;
    gpfnCleanupDxGraphics = NULL;
    gpDxFuncs = NULL;

    return (STATUS_SUCCESS);
}

/***************************************************************************\
*
* Internal functions called by dxg.sys
*
\***************************************************************************/

BOOL DxEngIsTermSrv(VOID)
{
    return(!!(SharedUserData->SuiteMask & (1 << TerminalServer)));
}

BOOL DxEngScreenAccessCheck(VOID)
{
    return(UserScreenAccessCheck());
}
    
BOOL DxEngRedrawDesktop(VOID)
{
    UserRedrawDesktop();
    return (TRUE);
}

ULONG DxEngDispUniq(VOID)
{
    return (gpGdiSharedMemory->iDisplaySettingsUniqueness);
}

BOOL DxEngIncDispUniq(VOID)
{
    LONG* pl = (PLONG) &gpGdiSharedMemory->iDisplaySettingsUniqueness;
    InterlockedIncrement(pl);
    return (TRUE);
}

ULONG DxEngVisRgnUniq(VOID)
{
    return (giVisRgnUniqueness);
}

BOOL DxEngLockShareSem(VOID)
{
    GDIFunctionID(DxEngLockShareSem);
    GreAcquireSemaphoreEx(ghsemShareDevLock, SEMORDER_SHAREDEVLOCK, NULL);
    return (TRUE);
}

BOOL DxEngUnlockShareSem(VOID)
{
    GDIFunctionID(DxEngUnlockShareSem);
    GreReleaseSemaphoreEx(ghsemShareDevLock);
    return (TRUE);
}

HDEV DxEngEnumerateHdev(HDEV hdev)
{
    return (hdevEnumerate(hdev));
}

BOOL DxEngLockHdev(HDEV hdev)
{
    GDIFunctionID(DxEngLockHdev);
    PDEVOBJ poLock(hdev);
    GreAcquireSemaphoreEx(poLock.hsemDevLock(), SEMORDER_DEVLOCK, NULL);
    GreEnterMonitoredSection(poLock.ppdev, WD_DEVLOCK);
    return (TRUE);
}

BOOL DxEngUnlockHdev(HDEV hdev)
{
    GDIFunctionID(DxEngUnlockHdev);
    PDEVOBJ poLock(hdev);
    GreExitMonitoredSection(poLock.ppdev, WD_DEVLOCK);
    GreReleaseSemaphoreEx(poLock.hsemDevLock());
    return (TRUE);
}

BOOL DxEngIsHdevLockedByCurrentThread(HDEV hdev)
{
    PDEVOBJ poLock(hdev);
    return (GreIsSemaphoreOwnedByCurrentThread(poLock.hsemDevLock()));
}

BOOL DxEngReferenceHdev(HDEV hdev)
{
    PDEVOBJ po(hdev);
    po.vReferencePdev();
    return (TRUE);
}

BOOL DxEngUnreferenceHdev(HDEV hdev)
{
    PDEVOBJ po(hdev);
    po.vUnreferencePdev();
    return (TRUE);
}

BOOL DxEngGetDeviceGammaRamp(HDEV hdev,PVOID pv)
{
    return (GreGetDeviceGammaRampInternal(hdev,pv));
}

BOOL DxEngSetDeviceGammaRamp(
       HDEV  hdev,
       PVOID pv,
       BOOL  b)
{
    return (GreSetDeviceGammaRampInternal(hdev,pv,b));
}

BOOL DxEngSpTearDownSprites(
       HDEV   hdev,
       RECTL* prcl,
       BOOL   b)
{
    return (bSpTearDownSprites(hdev,prcl,b));
}

BOOL DxEngSpUnTearDownSprites(
       HDEV   hdev,
       RECTL* prcl,
       BOOL   b)
{
    vSpUnTearDownSprites(hdev,prcl,b);
    return (TRUE);
}

BOOL DxEngSpSpritesVisible(HDEV hdev)
{
    return (bSpSpritesVisible(hdev));
}

ULONG_PTR DxEngGetHdevData(
          HDEV  hdev,
          DWORD dwIndex)
{
    ULONG_PTR ulRet = 0;
    PDEVOBJ po(hdev);

    switch (dwIndex)
    {
    case HDEV_SURFACEHANDLE:
        ulRet = (ULONG_PTR)(po.pSurface()->hGet());
        break;
    case HDEV_MINIPORTHANDLE:
        ulRet = (ULONG_PTR)(po.hScreen());
        break;
    case HDEV_DITHERFORMAT:
        ulRet = (ULONG_PTR)(po.iDitherFormat());
        break;
    case HDEV_GCAPS:
        ulRet = (ULONG_PTR)(po.flGraphicsCapsNotDynamic());
        break;
    case HDEV_GCAPS2:
        ulRet = (ULONG_PTR)(po.flGraphicsCaps2NotDynamic());
        break;
    case HDEV_FUNCTIONTABLE:
        ulRet = (ULONG_PTR)(po.apfn());
        break;
    case HDEV_DHPDEV:
        ulRet = (ULONG_PTR)(po.dhpdev());
        break;
    case HDEV_DXDATA:
        ulRet = (ULONG_PTR)(po.pDirectDrawContext());
        break;
    case HDEV_DXLOCKS:
        ulRet = (ULONG_PTR)(po.cDirectDrawDisableLocks());
        break;
    case HDEV_CAPSOVERRIDE:
        ulRet = (ULONG_PTR)(po.dwDriverCapableOverride());
        break;
    case HDEV_DISABLED:
        ulRet = (ULONG_PTR)(po.bDisabled());
        break;
    case HDEV_DDML:
        ulRet = (ULONG_PTR)(po.bMetaDriver());
        break;
    case HDEV_CLONE:
        ulRet = (ULONG_PTR)(po.bCloneDriver());
        break;
    case HDEV_DISPLAY:
        ulRet = (ULONG_PTR)(po.bDisplayPDEV());
        break;
    case HDEV_PARENTHDEV:
        ulRet = (ULONG_PTR)(po.hdevParent());
        break;
    case HDEV_DELETED:
        ulRet = (ULONG_PTR)(po.bDeleted());
        break;
    case HDEV_PALMANAGED:
        ulRet = (ULONG_PTR)(po.bIsPalManaged());
        break;
    case HDEV_LDEV:
        ulRet = (ULONG_PTR)(po.pldev());
        break;
    case HDEV_GRAPHICSDEVICE:
        ulRet = (ULONG_PTR)(((PDEV *)po.hdev())->pGraphicsDevice);
        break;
    }

    return (ulRet);
}

BOOL DxEngSetHdevData(
          HDEV  hdev,
          DWORD dwIndex,
          ULONG_PTR ulData)
{
    BOOL bRet = FALSE;
    PDEVOBJ po(hdev);

    switch (dwIndex)
    {
    case HDEV_DXLOCKS:
        po.cDirectDrawDisableLocks((ULONG)ulData);
        bRet = TRUE;
        break;
    }

    return (bRet);
}

// Functions for control DC

HDC  DxEngCreateMemoryDC(
     HDEV hdev)
{
    return (GreCreateDisplayDC(hdev,DCTYPE_MEMORY,FALSE));
}

HDC  DxEngGetDesktopDC(
     ULONG ulType,
     BOOL  bAltType,
     BOOL bValidate)
{
    return (UserGetDesktopDC(ulType, bAltType, bValidate));
}

BOOL DxEngDeleteDC(
     HDC  hdc,
     BOOL bForce)
{
    return (bDeleteDCInternal(hdc, bForce, FALSE));
}

BOOL DxEngCleanDC(
     HDC hdc)
{
    return (GreCleanDC(hdc));
}

BOOL DxEngSetDCOwner(
     HDC    hdc,
     W32PID pidOwner)
{
    return (GreSetDCOwner(hdc, pidOwner));
}

PVOID DxEngLockDC(
     HDC hdc)
{
    PVOID  pvLockedDC = NULL;
    XDCOBJ dco(hdc);
    if (dco.bValid())
    {
        pvLockedDC = (PVOID)(dco.pdc);
        dco.vDontUnlockDC();
    }
    return (pvLockedDC);
}

BOOL DxEngUnlockDC(
     PVOID pvLockedDC)
{
    XDCOBJ dco;
    dco.pdc = (PDC)pvLockedDC;
    dco.vUnlock();
    return (TRUE);
}

BOOL DxEngSetDCState(
     HDC   hdc,
     DWORD dwState,
     ULONG_PTR ulData)
{
    BOOL    bRet = FALSE;
    MDCOBJA dco(hdc); // Multiple Alt Lock.
    if (dco.bValid())
    {
        switch (dwState)
        {
        case DCSTATE_FULLSCREEN:
            dco.bInFullScreen((BOOL)ulData);
            bRet = TRUE;
            break;
        }
    }
    return (bRet);
}
    
ULONG_PTR DxEngGetDCState(
     HDC   hdc,
     DWORD dwState)
{
    ULONG_PTR ulRet = 0;
    XDCOBJ dco(hdc);
    if (dco.bValid())
    {
        switch (dwState)
        {
        case DCSTATE_FULLSCREEN:
            ulRet = (ULONG_PTR)(dco.bInFullScreen());
            break;
        case DCSTATE_VISRGNCOMPLEX:
        {
            RGNOBJ ro(dco.pdc->prgnVis());
            ulRet = (ULONG_PTR)(ro.iComplexity());
            break;
        }
        case DCSTATE_HDEV:
            ulRet = (ULONG_PTR)(dco.hdev());
            break;
        }
        dco.vUnlockFast();
    }
    return (ulRet);
}

// Functions for control Bitmap/Surface

HBITMAP DxEngSelectBitmap(
        HDC     hdc,
        HBITMAP hbm)
{
    return (hbmSelectBitmap(hdc, hbm, TRUE));
}

BOOL DxEngSetBitmapOwner(
     HBITMAP hbm,
     W32PID  pidOwner)
{
    return (GreSetBitmapOwner(hbm, pidOwner));
}

BOOL DxEngDeleteSurface(
     HSURF hsurf)
{
    return (bDeleteSurface(hsurf));
}

ULONG_PTR DxEngGetSurfaceData(
     SURFOBJ* pso,
     DWORD    dwIndex)
{
    ULONG_PTR ulRet = 0;
    SURFACE *pSurface = SURFOBJ_TO_SURFACE_NOT_NULL(pso);
    switch (dwIndex)
    {
    case SURF_HOOKFLAGS:
        ulRet = (ULONG_PTR) pSurface->flags();
        break;
    case SURF_IS_DIRECTDRAW_SURFACE:
        ulRet = (ULONG_PTR) pSurface->bDirectDraw();
        break;
    case SURF_DD_SURFACE_HANDLE:
        ulRet = (ULONG_PTR) pSurface->hDDSurface;
        break;
    }
    return (ulRet);
}

SURFOBJ* DxEngAltLockSurface(
         HBITMAP hsurf)
{
    SURFREF so;

    so.vAltLock((HSURF) hsurf);
    if (so.bValid())
    {
        so.vKeepIt();
        return(so.pSurfobj());
    }
    else
    {
        WARNING("DxEngAltLockSurface failed to lock handle\n");
        return((SURFOBJ *) NULL);
    }
}

BOOL DxEngUploadPaletteEntryToSurface(
     HDEV     hdev,
     SURFOBJ* pso,
     PALETTEENTRY* puColorTable,
     ULONG    cColors)
{
    BOOL    bRet = FALSE;
    PDEVOBJ po(hdev);

    if (po.bValid() && pso && puColorTable)
    {
        // Update the color table.

        SURFACE *pSurface = SURFOBJ_TO_SURFACE_NOT_NULL(pso);

        // Note that the scumy application might have delete the cached
        // bitmap, so we have to check for bValid() here.  (It's been a
        // bad app, so we just protect against crashing, and don't bother
        // to re-create a good bitmap for him.)

        if (pSurface->bValid())
        {
            XEPALOBJ pal(pSurface->ppal());
            ASSERTGDI(pal.bValid(), "Unexpected invalid palette");

            // Since we'll be mucking with the palette table:

            pal.vUpdateTime();

            if (puColorTable == NULL)
            {
                ASSERTGDI(po.bIsPalManaged(), "Expected palettized display");

                // Make this palette share the same colour table as the
                // screen, so that we always get identity blts:

                pal.apalColorSet(po.ppalSurf());

                bRet = TRUE;
            }
            else
            {
                // Previously, there might not have been a color table, but
                // now there is.  So reset the shared-palette pointer:

                pal.apalResetColorTable();

                PAL_ULONG* ppalstruc = pal.apalColorGet();
                __try
                {
                    for (ULONG i = 0; i < cColors; i++)
                    {
                        ppalstruc->pal = *puColorTable;
                        puColorTable++;
                        ppalstruc++;
                    }

                    bRet = TRUE;
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNING("hbmDdCreateAndLockSurface: Bad color table");
                }
            }
        }
    }

    return (FALSE);
}

BOOL DxEngMarkSurfaceAsDirectDraw(
     SURFOBJ* pso,
     HANDLE   hDdSurf)
{
    if (pso)
    {
        SURFACE *pSurface = SURFOBJ_TO_SURFACE_NOT_NULL(pso);

        // Make sure that the USE_DEVLOCK flag is set so
        // that the devlock is always acquired before drawing
        // to the surface -- needed so that we can switch to
        // a different mode and 'turn-off' access to the
        // surface by changing the clipping:

        pSurface->vSetUseDevlock();
        pSurface->vSetDirectDraw();
        pSurface->hDDSurface = hDdSurf;
    
        return (TRUE);
    }

    return (FALSE);
}

HPALETTE DxEngSelectPaletteToSurface(
         SURFOBJ* pso,
         HPALETTE hpal)
{
    HPALETTE hpalRet = NULL;
    EPALOBJ  pal(hpal);

    if (pso && pal.bValid())
    {
        SURFACE *pSurface = SURFOBJ_TO_SURFACE_NOT_NULL(pso);

        // Get palette currently selected.

        PPALETTE ppalOld = pSurface->ppal();

        // Select palette into surface and increment ref count.

        pSurface->ppal(pal.ppalGet());

        pal.vRefPalette();

#if 0 // TODO:
        if ((ppalOld != ppalDefaut) && (ppalOld != NULL))
        {
            hpalRet = ppalOld->hGet();
            ppalOld->vUnrefPalette();
        }
#endif
    }

    return (hpalRet);
}

// Functions for control palette

BOOL DxEngSyncPaletteTableWithDevice(
     HPALETTE hpal,
     HDEV     hdev)
{
    BOOL     bRet = FALSE;
    PDEVOBJ  po(hdev);
    EPALOBJ  pal(hpal);
    if (po.bValid() && pal.bValid())
    {
        pal.apalColorSet(po.ppalSurf());
        bRet = TRUE;
    }
    return (bRet);
}

BOOL DxEngSetPaletteState(
     HPALETTE  hpal,
     DWORD     dwIndex,
     ULONG_PTR ulData)
{
    BOOL    bRet = FALSE;
    EPALOBJ pal(hpal);
    if (pal.bValid())
    {
        switch (dwIndex)
        {
        case PALSTATE_DIBSECTION:
            if (ulData)
            {
                pal.flPal(PAL_DIBSECTION);
            }
            else
            {
                pal.flPalSet(pal.flPal() & ~PAL_DIBSECTION);
            }
            bRet = TRUE;
        }
    }
    return (bRet);
}

// Functions for window handle

HBITMAP DxEngGetRedirectionBitmap(
        HWND hWnd
        )
{
#ifdef DX_REDIRECTION
    return (UserGetRedirectionBitmap(hWnd));
#else
    return (NULL);
#endif // DX_REDIRECTION
}

// Functions to load image file

HANDLE DxEngLoadImage(
     LPWSTR pwszDriver,
     BOOL   bLoadInSessionSpace
     )
{
    BOOL   bLoaded;
    HANDLE h;

    GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);

    h = ldevLoadImage(pwszDriver, TRUE, &bLoaded, bLoadInSessionSpace);

    GreReleaseSemaphoreEx(ghsemDriverMgmt);

    return h;
}

/***************************************************************************\
*
* Stub routines to call dxg.sys
*
\***************************************************************************/

#define PPFNGET_DXFUNC(name) ((PFN_Dx##name)((gpDxFuncs[INDEX_Dx##name]).pfn))
#define CALL_DXFUNC(name)    (*(PPFNGET_DXFUNC(name)))

extern "C"
DWORD  APIENTRY NtGdiDxgGenericThunk(
    IN     ULONG_PTR ulIndex,
    IN     ULONG_PTR ulHandle,
    IN OUT SIZE_T   *pdwSizeOfPtr1,
    IN OUT PVOID     pvPtr1,
    IN OUT SIZE_T   *pdwSizeOfPtr2,
    IN OUT PVOID     pvPtr2)
{
    return (CALL_DXFUNC(DxgGenericThunk)(ulIndex,ulHandle,
                                         pdwSizeOfPtr1,pvPtr1,
                                         pdwSizeOfPtr2,pvPtr2));
}

DWORD APIENTRY NtGdiDdAddAttachedSurface(
    IN     HANDLE hSurface,
    IN     HANDLE hSurfaceAttached,
    IN OUT PDD_ADDATTACHEDSURFACEDATA puAddAttachedSurfaceData)
{
    return (CALL_DXFUNC(DdAddAttachedSurface)(hSurface,hSurfaceAttached,puAddAttachedSurfaceData));
}

BOOL APIENTRY NtGdiDdAttachSurface(
    IN     HANDLE hSurfaceFrom,
    IN     HANDLE hSurfaceTo)
{
    return (CALL_DXFUNC(DdAttachSurface)(hSurfaceFrom,hSurfaceTo));
}

DWORD APIENTRY NtGdiDdBlt(
    IN     HANDLE hSurfaceDest,
    IN     HANDLE hSurfaceSrc,
    IN OUT PDD_BLTDATA puBltData)
{
    return (CALL_DXFUNC(DdBlt)(hSurfaceDest,hSurfaceSrc,puBltData));
}

DWORD APIENTRY NtGdiDdCanCreateSurface(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_CANCREATESURFACEDATA puCanCreateSurfaceData)
{
    return (CALL_DXFUNC(DdCanCreateSurface)(hDirectDraw,puCanCreateSurfaceData));
}

DWORD APIENTRY NtGdiDdColorControl(
    IN     HANDLE hSurface,
    IN OUT PDD_COLORCONTROLDATA puColorControlData)
{
    return (CALL_DXFUNC(DdColorControl)(hSurface,puColorControlData));
}

HANDLE APIENTRY NtGdiDdCreateDirectDrawObject(
    IN     HDC hdc)
{
    return (CALL_DXFUNC(DdCreateDirectDrawObject)(hdc));
}

DWORD  APIENTRY NtGdiDdCreateSurface(
    IN     HANDLE  hDirectDraw,
    IN     HANDLE* hSurface,
    IN OUT DDSURFACEDESC* puSurfaceDescription,
    IN OUT DD_SURFACE_GLOBAL* puSurfaceGlobalData,
    IN OUT DD_SURFACE_LOCAL* puSurfaceLocalData,
    IN OUT DD_SURFACE_MORE* puSurfaceMoreData,
    IN OUT DD_CREATESURFACEDATA* puCreateSurfaceData,
       OUT HANDLE* puhSurface)
{
    return (CALL_DXFUNC(DdCreateSurface)(hDirectDraw,hSurface,puSurfaceDescription,
                                         puSurfaceGlobalData,puSurfaceLocalData,
                                         puSurfaceMoreData,puCreateSurfaceData,
                                         puhSurface));
}

HANDLE APIENTRY NtGdiDdCreateSurfaceObject(
    IN     HANDLE hDirectDrawLocal,
    IN     HANDLE hSurface,
    IN     PDD_SURFACE_LOCAL puSurfaceLocal,
    IN     PDD_SURFACE_MORE puSurfaceMore,
    IN     PDD_SURFACE_GLOBAL puSurfaceGlobal,
    IN     BOOL bComplete)
{
    return (CALL_DXFUNC(DdCreateSurfaceObject)(
                        hDirectDrawLocal,hSurface,
                        puSurfaceLocal,puSurfaceMore,puSurfaceGlobal,
                        bComplete));
}

BOOL APIENTRY NtGdiDdDeleteSurfaceObject(
    IN     HANDLE hSurface)
{
    return (CALL_DXFUNC(DdDeleteSurfaceObject)(hSurface));
}

BOOL APIENTRY NtGdiDdDeleteDirectDrawObject(
    IN     HANDLE hDirectDrawLocal)
{
    return (CALL_DXFUNC(DdDeleteDirectDrawObject)(hDirectDrawLocal));
}

DWORD APIENTRY NtGdiDdDestroySurface(
    IN     HANDLE hSurface,
    IN     BOOL bRealDestroy)
{
    return (CALL_DXFUNC(DdDestroySurface)(hSurface,bRealDestroy));
}

DWORD APIENTRY NtGdiDdFlip(
    IN     HANDLE hSurfaceCurrent,
    IN     HANDLE hSurfaceTarget,
    IN     HANDLE hSurfaceCurrentLeft,
    IN     HANDLE hSurfaceTargetLeft,
    IN OUT PDD_FLIPDATA puFlipData)
{
    return (CALL_DXFUNC(DdFlip)(hSurfaceCurrent,hSurfaceTarget,
                                hSurfaceCurrentLeft,hSurfaceTargetLeft,puFlipData));
}

DWORD APIENTRY NtGdiDdGetAvailDriverMemory(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETAVAILDRIVERMEMORYDATA puGetAvailDriverMemoryData)
{
    return (CALL_DXFUNC(DdGetAvailDriverMemory)(hDirectDraw,puGetAvailDriverMemoryData));
}

DWORD APIENTRY NtGdiDdGetBltStatus(
    IN     HANDLE hSurface,
    IN OUT PDD_GETBLTSTATUSDATA puGetBltStatusData)
{
    return (CALL_DXFUNC(DdGetBltStatus)(hSurface,puGetBltStatusData));
}

HDC APIENTRY NtGdiDdGetDC(
    IN     HANDLE hSurface,
    IN     PALETTEENTRY* puColorTable)
{
    return (CALL_DXFUNC(DdGetDC)(hSurface,puColorTable));
}

DWORD APIENTRY NtGdiDdGetDriverInfo(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETDRIVERINFODATA puGetDriverInfoData)
{
    return (CALL_DXFUNC(DdGetDriverInfo)(hDirectDraw,puGetDriverInfoData));
}

DWORD APIENTRY NtGdiDdGetFlipStatus(
    IN     HANDLE hSurface,
    IN OUT PDD_GETFLIPSTATUSDATA puGetFlipStatusData)
{
    return (CALL_DXFUNC(DdGetFlipStatus)(hSurface,puGetFlipStatusData));
}

DWORD APIENTRY NtGdiDdGetScanLine(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETSCANLINEDATA puGetScanLineData)
{
    return (CALL_DXFUNC(DdGetScanLine)(hDirectDraw,puGetScanLineData));
}

DWORD APIENTRY NtGdiDdSetExclusiveMode(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_SETEXCLUSIVEMODEDATA puSetExclusiveModeData)
{
    return (CALL_DXFUNC(DdSetExclusiveMode)(hDirectDraw,puSetExclusiveModeData));
}

DWORD APIENTRY NtGdiDdFlipToGDISurface(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_FLIPTOGDISURFACEDATA puFlipToGDISurfaceData)
{
    return (CALL_DXFUNC(DdFlipToGDISurface)(hDirectDraw,puFlipToGDISurfaceData));
}

DWORD APIENTRY NtGdiDdLock(
    IN     HANDLE hSurface,
    IN OUT PDD_LOCKDATA puLockData,
    IN HDC hdcClip)
{
    return (CALL_DXFUNC(DdLock)(hSurface,puLockData,hdcClip));
}

BOOL APIENTRY NtGdiDdQueryDirectDrawObject(
    HANDLE                      hDirectDrawLocal,
    DD_HALINFO*                 pHalInfo,
    DWORD*                      pCallBackFlags,
    LPD3DNTHAL_CALLBACKS        puD3dCallbacks,
    LPD3DNTHAL_GLOBALDRIVERDATA puD3dDriverData,
    PDD_D3DBUFCALLBACKS         puD3dBufferCallbacks,
    LPDDSURFACEDESC             puD3dTextureFormats,
    DWORD*                      puNumHeaps,
    VIDEOMEMORY*                puvmList,
    DWORD*                      puNumFourCC,
    DWORD*                      puFourCC)
{
    return (CALL_DXFUNC(DdQueryDirectDrawObject)(hDirectDrawLocal,pHalInfo,pCallBackFlags,
                                                 puD3dCallbacks,puD3dDriverData,puD3dBufferCallbacks,
                                                 puD3dTextureFormats,puNumHeaps,puvmList,
                                                 puNumFourCC,puFourCC));
}
 
BOOL APIENTRY NtGdiDdReenableDirectDrawObject(
    IN     HANDLE hDirectDrawLocal,
    IN OUT BOOL* pubNewMode)
{
    return (CALL_DXFUNC(DdReenableDirectDrawObject)(hDirectDrawLocal,pubNewMode));
}

BOOL APIENTRY NtGdiDdReleaseDC(
    IN     HANDLE hSurface)
{
    return (CALL_DXFUNC(DdReleaseDC)(hSurface));
}

BOOL APIENTRY NtGdiDdResetVisrgn(
    IN     HANDLE hSurface,
    IN HWND hwnd)
{
    return (CALL_DXFUNC(DdResetVisrgn)(hSurface,hwnd));
}

DWORD APIENTRY NtGdiDdSetColorKey(
    IN     HANDLE hSurface,
    IN OUT PDD_SETCOLORKEYDATA puSetColorKeyData)
{
    return (CALL_DXFUNC(DdSetColorKey)(hSurface,puSetColorKeyData));
}

DWORD APIENTRY NtGdiDdSetOverlayPosition(
    IN     HANDLE hSurfaceSource,
    IN     HANDLE hSurfaceDestination,
    IN OUT PDD_SETOVERLAYPOSITIONDATA puSetOverlayPositionData)
{
    return (CALL_DXFUNC(DdSetOverlayPosition)(hSurfaceSource,hSurfaceDestination,puSetOverlayPositionData));
}

VOID  APIENTRY NtGdiDdUnattachSurface(
    IN     HANDLE hSurface,
    IN     HANDLE hSurfaceAttached)
{
    CALL_DXFUNC(DdUnattachSurface)(hSurface,hSurfaceAttached);
}

DWORD APIENTRY NtGdiDdUnlock(
    IN     HANDLE hSurface,
    IN OUT PDD_UNLOCKDATA puUnlockData)
{
    return (CALL_DXFUNC(DdUnlock)(hSurface,puUnlockData));
}

DWORD APIENTRY NtGdiDdUpdateOverlay(
    IN     HANDLE hSurfaceDestination,
    IN     HANDLE hSurfaceSource,
    IN OUT PDD_UPDATEOVERLAYDATA puUpdateOverlayData)
{
    return (CALL_DXFUNC(DdUpdateOverlay)(hSurfaceDestination,hSurfaceSource,puUpdateOverlayData));
}

DWORD APIENTRY NtGdiDdWaitForVerticalBlank(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_WAITFORVERTICALBLANKDATA puWaitForVerticalBlankData)
{
    return (CALL_DXFUNC(DdWaitForVerticalBlank)(hDirectDraw,puWaitForVerticalBlankData));
}

HANDLE APIENTRY NtGdiDdGetDxHandle(
    IN     HANDLE hDirectDraw,
    IN     HANDLE hSurface,
    IN     BOOL bRelease)
{
    return (CALL_DXFUNC(DdGetDxHandle)(hDirectDraw,hSurface,bRelease));
}

BOOL APIENTRY NtGdiDdSetGammaRamp(
    IN     HANDLE hDirectDraw,
    IN     HDC hdc,
    IN     LPVOID lpGammaRamp)
{
    return (CALL_DXFUNC(DdSetGammaRamp)(hDirectDraw,hdc,lpGammaRamp));
}

DWORD APIENTRY NtGdiDdLockD3D(
    IN     HANDLE hSurface,
    IN OUT PDD_LOCKDATA puLockData)
{
    return (CALL_DXFUNC(DdLockD3D)(hSurface,puLockData));
}

DWORD APIENTRY NtGdiDdUnlockD3D(
    IN     HANDLE hSurface,
    IN OUT PDD_UNLOCKDATA puUnlockData)
{
    return (CALL_DXFUNC(DdUnlockD3D)(hSurface,puUnlockData));
}

DWORD APIENTRY NtGdiDdCreateD3DBuffer(
    IN     HANDLE hDirectDraw,
    IN OUT HANDLE* hSurface,
    IN OUT DDSURFACEDESC* puSurfaceDescription,
    IN OUT DD_SURFACE_GLOBAL* puSurfaceGlobalData,
    IN OUT DD_SURFACE_LOCAL* puSurfaceLocalData,
    IN OUT DD_SURFACE_MORE* puSurfaceMoreData,
    IN OUT DD_CREATESURFACEDATA* puCreateSurfaceData,
    IN OUT HANDLE* puhSurface)
{
    return (CALL_DXFUNC(DdCreateD3DBuffer)(hDirectDraw,hSurface,puSurfaceDescription,
                                           puSurfaceGlobalData,puSurfaceLocalData,puSurfaceMoreData,
                                           puCreateSurfaceData,puhSurface));
}

DWORD APIENTRY NtGdiDdCanCreateD3DBuffer(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_CANCREATESURFACEDATA puCanCreateSurfaceData)
{
    return (CALL_DXFUNC(DdCanCreateD3DBuffer)(hDirectDraw,puCanCreateSurfaceData));
}

DWORD APIENTRY NtGdiDdDestroyD3DBuffer(
    IN     HANDLE hSurface)
{
    return (CALL_DXFUNC(DdDestroyD3DBuffer)(hSurface));
}

DWORD APIENTRY NtGdiD3dContextCreate(
    IN     HANDLE hDirectDrawLocal,
    IN     HANDLE hSurfColor,
    IN     HANDLE hSurfZ,
    IN OUT D3DNTHAL_CONTEXTCREATEI *pdcci)
{
    return (CALL_DXFUNC(D3dContextCreate)(hDirectDrawLocal,hSurfColor,hSurfZ,pdcci));
}

DWORD APIENTRY NtGdiD3dContextDestroy(
    IN     LPD3DNTHAL_CONTEXTDESTROYDATA pdcdad)
{
    return (CALL_DXFUNC(D3dContextDestroy)(pdcdad));
}

DWORD APIENTRY NtGdiD3dContextDestroyAll(
       OUT LPD3DNTHAL_CONTEXTDESTROYALLDATA pdcdad)
{
    return (CALL_DXFUNC(D3dContextDestroyAll)(pdcdad));
}

DWORD APIENTRY NtGdiD3dValidateTextureStageState(
    IN OUT LPD3DNTHAL_VALIDATETEXTURESTAGESTATEDATA pData)
{
    return (CALL_DXFUNC(D3dValidateTextureStageState)(pData));
}

DWORD APIENTRY NtGdiD3dDrawPrimitives2(
    IN     HANDLE hCmdBuf,
    IN     HANDLE hVBuf,
    IN OUT LPD3DNTHAL_DRAWPRIMITIVES2DATA pded,
    IN OUT FLATPTR* pfpVidMemCmd,
    IN OUT DWORD* pdwSizeCmd,
    IN OUT FLATPTR* pfpVidMemVtx,
    IN OUT DWORD* pdwSizeVtx)
{
    return (CALL_DXFUNC(D3dDrawPrimitives2)(hCmdBuf,hVBuf,pded,pfpVidMemCmd,
                                            pdwSizeCmd,pfpVidMemVtx,pdwSizeVtx));
}

DWORD APIENTRY NtGdiDdGetDriverState(
    IN OUT PDD_GETDRIVERSTATEDATA pdata)
{
    return(CALL_DXFUNC(DdGetDriverState)(pdata));
}

DWORD APIENTRY NtGdiDdCreateSurfaceEx(
    IN     HANDLE hDirectDraw,
    IN     HANDLE hSurface,
    IN     DWORD dwSurfaceHandle)
{
    return (CALL_DXFUNC(DdCreateSurfaceEx)(hDirectDraw,hSurface,dwSurfaceHandle));
}

DWORD  APIENTRY NtGdiDdGetMoCompGuids(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETMOCOMPGUIDSDATA puGetMoCompGuidsData)
{
    return (CALL_DXFUNC(DdGetMoCompGuids)(hDirectDraw,puGetMoCompGuidsData));
}

DWORD  APIENTRY NtGdiDdGetMoCompFormats(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETMOCOMPFORMATSDATA puGetMoCompFormatsData)
{
    return (CALL_DXFUNC(DdGetMoCompFormats)(hDirectDraw,puGetMoCompFormatsData));
}

DWORD  APIENTRY NtGdiDdGetMoCompBuffInfo(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETMOCOMPCOMPBUFFDATA puGetBuffData)
{
    return (CALL_DXFUNC(DdGetMoCompBuffInfo)(hDirectDraw,puGetBuffData));
}

DWORD APIENTRY NtGdiDdGetInternalMoCompInfo(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETINTERNALMOCOMPDATA puGetInternalData)
{
    return (CALL_DXFUNC(DdGetInternalMoCompInfo)(hDirectDraw,puGetInternalData));
}

HANDLE APIENTRY NtGdiDdCreateMoComp(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_CREATEMOCOMPDATA puCreateMoCompData)
{
    return (CALL_DXFUNC(DdCreateMoComp)(hDirectDraw,puCreateMoCompData));
}

DWORD APIENTRY NtGdiDdDestroyMoComp(
    IN     HANDLE hMoComp,
    IN OUT PDD_DESTROYMOCOMPDATA puDestroyMoCompData)
{
    return (CALL_DXFUNC(DdDestroyMoComp)(hMoComp,puDestroyMoCompData));
}

DWORD APIENTRY NtGdiDdBeginMoCompFrame(
    IN     HANDLE hMoComp,
    IN OUT PDD_BEGINMOCOMPFRAMEDATA puBeginFrameData)
{
    return (CALL_DXFUNC(DdBeginMoCompFrame)(hMoComp,puBeginFrameData));
}

DWORD APIENTRY NtGdiDdEndMoCompFrame(
    IN     HANDLE hMoComp,
    IN OUT PDD_ENDMOCOMPFRAMEDATA  puEndFrameData)
{
    return (CALL_DXFUNC(DdEndMoCompFrame)(hMoComp,puEndFrameData));
}

DWORD APIENTRY NtGdiDdRenderMoComp(
    IN     HANDLE hMoComp,
    IN OUT PDD_RENDERMOCOMPDATA puRenderMoCompData)
{
    return (CALL_DXFUNC(DdRenderMoComp)(hMoComp,puRenderMoCompData));
}

DWORD APIENTRY NtGdiDdQueryMoCompStatus(
    IN OUT HANDLE hMoComp,
    IN OUT PDD_QUERYMOCOMPSTATUSDATA puQueryMoCompStatusData)
{
    return (CALL_DXFUNC(DdQueryMoCompStatus)(hMoComp,puQueryMoCompStatusData));
}

DWORD APIENTRY NtGdiDdAlphaBlt(
    IN     HANDLE hSurfaceDest,
    IN     HANDLE hSurfaceSrc,
    IN OUT PDD_BLTDATA puBltData)
{
    return (CALL_DXFUNC(DdAlphaBlt)(hSurfaceDest,hSurfaceSrc,puBltData));
}

DWORD APIENTRY NtGdiDvpCanCreateVideoPort(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_CANCREATEVPORTDATA puCanCreateVPortData)
{
    return (CALL_DXFUNC(DvpCanCreateVideoPort)(hDirectDraw,puCanCreateVPortData));
}

DWORD APIENTRY NtGdiDvpColorControl(
    IN     HANDLE hVideoPort,
    IN OUT PDD_VPORTCOLORDATA puVPortColorData)
{
    return (CALL_DXFUNC(DvpColorControl)(hVideoPort,puVPortColorData));
}

HANDLE APIENTRY NtGdiDvpCreateVideoPort(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_CREATEVPORTDATA puCreateVPortData)
{
    return (CALL_DXFUNC(DvpCreateVideoPort)(hDirectDraw,puCreateVPortData));
}

DWORD  APIENTRY NtGdiDvpDestroyVideoPort(
    IN     HANDLE hVideoPort,
    IN OUT PDD_DESTROYVPORTDATA puDestroyVPortData)
{
    return (CALL_DXFUNC(DvpDestroyVideoPort)(hVideoPort,puDestroyVPortData));
}

DWORD  APIENTRY NtGdiDvpFlipVideoPort(
    IN     HANDLE hVideoPort,
    IN     HANDLE hDDSurfaceCurrent,
    IN     HANDLE hDDSurfaceTarget,
    IN OUT PDD_FLIPVPORTDATA puFlipVPortData)
{
    return (CALL_DXFUNC(DvpFlipVideoPort)(hVideoPort,hDDSurfaceCurrent,
                                          hDDSurfaceTarget,puFlipVPortData));
}

DWORD  APIENTRY NtGdiDvpGetVideoPortBandwidth(
    IN     HANDLE hVideoPort,
    IN OUT PDD_GETVPORTBANDWIDTHDATA puGetVPortBandwidthData)
{
    return (CALL_DXFUNC(DvpGetVideoPortBandwidth)(hVideoPort,puGetVPortBandwidthData));
}

DWORD  APIENTRY NtGdiDvpGetVideoPortField(
    IN     HANDLE hVideoPort,
    IN OUT PDD_GETVPORTFIELDDATA puGetVPortFieldData)
{
    return (CALL_DXFUNC(DvpGetVideoPortField)(hVideoPort,puGetVPortFieldData));
}

DWORD  APIENTRY NtGdiDvpGetVideoPortFlipStatus(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETVPORTFLIPSTATUSDATA puGetVPortFlipStatusData)
{
    return (CALL_DXFUNC(DvpGetVideoPortFlipStatus)(hDirectDraw,puGetVPortFlipStatusData));
}

DWORD  APIENTRY NtGdiDvpGetVideoPortInputFormats(
    IN     HANDLE hVideoPort,
    IN OUT PDD_GETVPORTINPUTFORMATDATA puGetVPortInputFormatData)
{
    return (CALL_DXFUNC(DvpGetVideoPortInputFormats)(hVideoPort,puGetVPortInputFormatData));
}

DWORD  APIENTRY NtGdiDvpGetVideoPortLine(
    IN     HANDLE hVideoPort,
    IN OUT PDD_GETVPORTLINEDATA puGetVPortLineData)
{
    return (CALL_DXFUNC(DvpGetVideoPortLine)(hVideoPort,puGetVPortLineData));
}

DWORD  APIENTRY NtGdiDvpGetVideoPortOutputFormats(
    IN     HANDLE hVideoPort,
    IN OUT PDD_GETVPORTOUTPUTFORMATDATA puGetVPortOutputFormatData)
{
    return (CALL_DXFUNC(DvpGetVideoPortOutputFormats)(hVideoPort,puGetVPortOutputFormatData));
}

DWORD  APIENTRY NtGdiDvpGetVideoPortConnectInfo(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETVPORTCONNECTDATA puGetVPortConnectData)
{
    return (CALL_DXFUNC(DvpGetVideoPortConnectInfo)(hDirectDraw,puGetVPortConnectData));
}

DWORD  APIENTRY NtGdiDvpGetVideoSignalStatus(
    IN     HANDLE hVideoPort,
    IN OUT PDD_GETVPORTSIGNALDATA puGetVPortSignalData)
{
    return (CALL_DXFUNC(DvpGetVideoSignalStatus)(hVideoPort,puGetVPortSignalData));
}

DWORD  APIENTRY NtGdiDvpUpdateVideoPort(
    IN     HANDLE hVideoPort,
    IN     HANDLE* phSurfaceVideo,
    IN     HANDLE* phSurfaceVbi,
    IN OUT PDD_UPDATEVPORTDATA puUpdateVPortData)
{
    return (CALL_DXFUNC(DvpUpdateVideoPort)(hVideoPort,phSurfaceVideo,phSurfaceVbi,puUpdateVPortData));
}

DWORD  APIENTRY NtGdiDvpWaitForVideoPortSync(
    IN     HANDLE hVideoPort,
    IN OUT PDD_WAITFORVPORTSYNCDATA puWaitForVPortSyncData)
{
    return (CALL_DXFUNC(DvpWaitForVideoPortSync)(hVideoPort,puWaitForVPortSyncData));
}

DWORD  APIENTRY NtGdiDvpAcquireNotification(
    IN     HANDLE hVideoPort,
    IN OUT HANDLE* phEvent,
    IN     LPDDVIDEOPORTNOTIFY pNotify)
{
    return (CALL_DXFUNC(DvpAcquireNotification)(hVideoPort,phEvent,pNotify));
}

DWORD  APIENTRY NtGdiDvpReleaseNotification(
    IN     HANDLE hVideoPort,
    IN     HANDLE hEvent)
{
    return (CALL_DXFUNC(DvpReleaseNotification)(hVideoPort,hEvent));
}

FLATPTR WINAPI HeapVidMemAllocAligned( 
                LPVIDMEM lpVidMem,
                DWORD dwWidth, 
                DWORD dwHeight, 
                LPSURFACEALIGNMENT lpAlignment , 
                LPLONG lpNewPitch )
{
    return (CALL_DXFUNC(DdHeapVidMemAllocAligned)(lpVidMem,dwWidth,dwHeight,lpAlignment,lpNewPitch));
}

VOID WINAPI VidMemFree( LPVMEMHEAP pvmh, FLATPTR ptr )
{
    CALL_DXFUNC(DdHeapVidMemFree)(pvmh,ptr);
}

PVOID APIENTRY EngAllocPrivateUserMem(
    PDD_SURFACE_LOCAL pSurfaceLocal,
    SIZE_T cj,
    ULONG tag
    )
{
    return (CALL_DXFUNC(DdAllocPrivateUserMem)(pSurfaceLocal,cj,tag));
}

VOID APIENTRY EngFreePrivateUserMem(
    PDD_SURFACE_LOCAL pSurfaceLocal,
    PVOID pv
    )
{
    CALL_DXFUNC(DdFreePrivateUserMem)(pSurfaceLocal,pv);
}

HRESULT APIENTRY EngDxIoctl(
    ULONG ulIoctl,
    PVOID pBuffer,
    ULONG ulBufferSize
    )
{
    return (CALL_DXFUNC(DdIoctl)(ulIoctl,pBuffer,ulBufferSize));
}

PDD_SURFACE_LOCAL APIENTRY EngLockDirectDrawSurface(HANDLE hSurface)
{
    return (CALL_DXFUNC(DdLockDirectDrawSurface)(hSurface));
}

BOOL APIENTRY EngUnlockDirectDrawSurface(PDD_SURFACE_LOCAL pSurface)
{
    return (CALL_DXFUNC(DdUnlockDirectDrawSurface)(pSurface));
}

VOID APIENTRY GreSuspendDirectDraw(
    HDEV    hdev,
    BOOL    bChildren
    )
{
    CALL_DXFUNC(DdSuspendDirectDraw)(hdev,(bChildren ? DXG_SR_DDRAW_CHILDREN : 0));
}

VOID APIENTRY GreSuspendDirectDrawEx(
    HDEV    hdev,
    ULONG   fl
    )
{
    CALL_DXFUNC(DdSuspendDirectDraw)(hdev,fl);
}

VOID APIENTRY GreResumeDirectDraw(
    HDEV    hdev,
    BOOL    bChildren
    )
{
    CALL_DXFUNC(DdResumeDirectDraw)(hdev,(bChildren ? DXG_SR_DDRAW_CHILDREN : 0));
}

VOID APIENTRY GreResumeDirectDrawEx(
    HDEV    hdev,
    ULONG   fl
    )
{
    CALL_DXFUNC(DdResumeDirectDraw)(hdev,fl);
}

BOOL APIENTRY GreGetDirectDrawBounds(
    HDEV    hdev,
    RECT*   prcBounds
    )
{
    return (CALL_DXFUNC(DdGetDirectDrawBounds)(hdev,prcBounds));
}

BOOL APIENTRY GreEnableDirectDrawRedirection(
    HDEV hdev,
    BOOL bEnable
    )
{
    return (CALL_DXFUNC(DdEnableDirectDrawRedirection)(hdev,bEnable));
}

BOOL DxDdEnableDirectDraw(
    HDEV hdev,
    BOOL bEnableDriver
    )
{
    return (CALL_DXFUNC(DdEnableDirectDraw)(hdev,bEnableDriver));
}

VOID DxDdDisableDirectDraw(
    HDEV hdev,
    BOOL bDisableDriver
    )
{
    CALL_DXFUNC(DdDisableDirectDraw)(hdev,bDisableDriver);
}

VOID DxDdDynamicModeChange(
    HDEV    hdevOld,
    HDEV    hdevNew,
    ULONG   fl
    )
{
    CALL_DXFUNC(DdDynamicModeChange)(hdevOld,hdevNew,fl);
}

VOID DxDdCloseProcess(W32PID W32Pid)
{
    //
    // This function can be called at clean up even
    // if dxg.sys hasn't been initialized. so before
    // call dxg.sys, make sure it has been initialized
    // or not.
    //
    if (ghDxGraphics && gpDxFuncs)
    {
        CALL_DXFUNC(DdCloseProcess)(W32Pid);
    }
}

VOID DxDdSetAccelLevel(HDEV hdev, DWORD dwAccelLevel, DWORD dwOverride)
{
    CALL_DXFUNC(DdSetAccelLevel)(hdev,dwAccelLevel,dwOverride);
}

DWORD DxDdGetSurfaceLock(HDEV hdev)
{
    return (CALL_DXFUNC(DdGetSurfaceLock)(hdev));
}

PVOID DxDdEnumLockedSurfaceRect(HDEV hdev, PVOID pvSurf, RECTL *prcl)
{
    return (CALL_DXFUNC(DdEnumLockedSurfaceRect)(hdev,pvSurf,prcl));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\dcrgn.cxx ===
/******************************Module*Header*******************************\
* Module Name: dcrgn.cxx
*
* Non inline DC Region object routines
*
* Created: 02-Jul-1990 12:36:30
* Author: Donald Sidoroff [donalds]
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

RECTL rclEmpty = {POS_INFINITY,POS_INFINITY,NEG_INFINITY,NEG_INFINITY};

#if DBG

ULONG dbgrgn = 0;
HDC   gflhdc = 0;

VOID DisplayRegion(
    PREGION prgn,
    PCHAR   s
    )
{
    DbgPrint("DisplayRegion %s = 0x%p\n",s,prgn);
    if (prgn)
    {
        DbgPrint("Region bounding rect = (%li,%li) to (%li,%li)\n",
            prgn->rcl.left,
            prgn->rcl.top,
            prgn->rcl.right,
            prgn->rcl.bottom
            );
    }
}

#endif

/******************************Public*Routine******************************\
* DC::bCompute()
*
* Compute the current Rao region.  The Rao region is the ANDed version of
* all the regions.  Since the only region that must exist is the Vis region
* we allow this to be the Rao without actually computing it.  (Refer to the
* prgnEffRao() method)  This is only done if no other regions are defined.
* This is a nifty accelerator.
*
* WARNING: This routine should only be called while the device is locked.
* calling at any other time doesn't make sense, since our vis region may
* change asynchronously.
*
* History:
*
*  11-Jul-1995 -by- Mark Enstrom [marke]
*
*   Don't always delete and re-allocate rao region
*
*  07-Mar-1992 -by- Donald Sidoroff [donalds]
* Complete rewrite
*
*  09-Jul-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL DC::bCompute()
{
    ASSERTDEVLOCK(this);

    RGNLOG rl(prgnVis(),"DC::bCompute",(ULONG_PTR)prgnRao());

    ASSERTGDI(prgnVis() != NULL,"DC::bCompute - prgnVis == NULL\n");

    BOOL bRes = FALSE;

    if (!(prgnVis() == NULL))
    {
        bRes = TRUE;

        //
        // quick check to see if there is just the vis rgn.  Better to pay
        // the cost of the check twice in the rare case to speed up the check
        // for the common case
        //

        RGNOBJ roVis(prgnVis());

        if (((ULONG_PTR)prgnClip() | (ULONG_PTR)prgnMeta() | (ULONG_PTR)prgnAPI()) == 0)
        {
            //
            // get rid of RAO now since it won't be needed
            //

            if (prgnRao() != NULL)
            {
                RGNOBJ roRao(prgnRao());
                roRao.bDeleteRGNOBJ();
                prgnRao(NULL);
            }

            //
            // set erclClip to the bounding rcl
            //

            roVis.vGetSubRect(&(erclClip()));

            //
            // Mark as clean
            //

            fsClr(DC_DIRTY_RAO);
        }
        else
        {
            PREGION aprgn[3];
            int  cRgn = 0;

            //
            // Load the regions into the buffer
            //

            if ((aprgn[cRgn] = prgnClip()) != NULL)
            {
                cRgn++;
            }

            if ((aprgn[cRgn] = prgnMeta()) != NULL)
            {
                cRgn++;
            }

            if ((aprgn[cRgn] = prgnAPI()) != NULL)
            {
                cRgn++;
            }

            RGNOBJ roRao(prgnRao());

            if (roRao.prgn == NULL)
            {
                //
                // need to create RAO
                //

                RGNMEMOBJ rmoRao;

                if (rmoRao.bValid())
                {
                    roRao.prgn = rmoRao.prgn;
                }
            }

            if (!roRao.bValid())
            {
                bRes = FALSE;
            }
            else if (cRgn == 1)
            {
                RGNOBJ ro(aprgn[0]);

                if (!roRao.bCopy(ro))
                {
                    bRes = FALSE;
                }
            }
            else if (cRgn == 2)
            {
                RGNOBJ roA(aprgn[0]);
                RGNOBJ roB(aprgn[1]);

                if (roRao.iCombine(roA, roB, RGN_AND) == ERROR)
                {
                    bRes = FALSE;
                }
            }
            else
            {
                RGNMEMOBJTMP rmo;
                RGNOBJ roA(aprgn[0]);
                RGNOBJ roB(aprgn[1]);
                RGNOBJ roC(aprgn[2]);

                if (!rmo.bValid() ||
                    (rmo.iCombine(roA, roB, RGN_AND) == ERROR) ||
                    (roRao.iCombine(rmo, roC, RGN_AND) == ERROR))
                {
                    bRes = FALSE;
                }
            }

            if (bRes)
            {
                roRao.vStamp();

                //
                // We first have to offset the new Rao,
                //

                if (roRao.bOffset((PPOINTL) prclWindow()))
                {
                    //
                    // If the Vis is a rectangle and bounds the Rao, we are done
                    //

                    if (roVis.bRectl() && roVis.bContain(roRao))
                    {
                        prgnRao(roRao.prgnGet());
                        roRao.vGetSubRect(&(erclClip()));
                        fsClr(DC_DIRTY_RAO);
                    }
                    else
                    {
                        //
                        // Sigh, once again we find ourselves looking for a place to do a merge.
                        //

                        RGNMEMOBJTMP rmo;

                        if (!rmo.bValid() ||
                            (rmo.iCombine(roVis, roRao, RGN_AND) == ERROR) ||
                            !roRao.bCopy(rmo))
                        {
                            bRes = FALSE;
                        }
                        else
                        {
                            prgnRao(roRao.prgnGet());
                            roRao.vGetSubRect(&(erclClip()));
                            fsClr(DC_DIRTY_RAO);
                        }
                    }
                }
                else
                {
                    bRes = FALSE;
                }
            }

            if (!bRes)
            {
                WARNING("DC::bCompute failed");

                //
                // RAO creation failed at some point, bswap may have
                // already deleted the old RAO rgn, so the DC pointer
                // must be set to NULL
                //

                prgnRao(NULL);

                if (roRao.bValid())
                {
                    //
                    // if the RAO still exists,
                    // then delete it.
                    //

                    roRao.bDeleteRGNOBJ();
                }
            }
        }

        //
        // update user-mode vis region bounding rectangle if dirty
        //
        vUpdate_VisRect(prgnVis());

    }

    return(bRes);
}

/******************************Public*Routine******************************\
* LONG DC::iCombine(prcl, iMode)
*
* Combine the clip region with the rectangle by the mode
*
* History:
*  09-Jul-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

LONG DC::iCombine(
RECTL *prcl,
LONG   iMode)
{
    PREGION     prgn = prgnClip();
    LONG        iTmp;

    if (!VALID_SCRPRC(prcl))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(ERROR);
    }

    RGNMEMOBJ   rmoRcl;
    if (!rmoRcl.bValid())
        return(ERROR);

    rmoRcl.vSet(prcl);

    vReleaseRao();

    if (prgn != NULL)
    {
        RGNMEMOBJ   rmo;

        if (!rmo.bValid())
        {
            iTmp = ERROR;
        }
        else
        {
            RGNOBJ ro(prgn);

            iTmp = rmo.iCombine(ro, rmoRcl, iMode);

            if (iTmp != ERROR)
            {
                rmo.vSelect((HDC)hGet());


                prgnClip(rmo.prgnGet());


                #if DBG

                if ((dbgrgn) && (gflhdc == hGet()))
                {
                    DbgPrint("iCombine: hdc = 0x%p, new region = 0x%p\n",hHmgr,prgnClip());
                }

                #endif

            // If nobody is using the old clip region, delete it.

                ro.vUnselect();

                if (ro.cGet_cRefs() == 0)
                    ro.bDeleteRGNOBJ();
            }
            else
            {
                rmo.bDeleteRGNOBJ();
            }
        }

        rmoRcl.bDeleteRGNOBJ();
    }
    else if (iMode == RGN_AND)
    {
        rmoRcl.vSelect((HDC)hGet());

        prgnClip(rmoRcl.prgnGet());


        #if DBG

        if ((dbgrgn) && (gflhdc == hGet()))
        {
            DbgPrint("iCombine: hdc = 0x%p, new region = 0x%p\n",hHmgr,prgnClip());
        }

        #endif

        iTmp = SIMPLEREGION;
    }
    else
    {
        RGNMEMOBJ    rmo2;
        RGNMEMOBJTMP rmo3;
        SIZEL        sizl;

        if (!rmo2.bValid())
        {
            iTmp = ERROR;
        }
        else if (!rmo3.bValid())
        {
            rmo2.bDeleteRGNOBJ();
            iTmp = ERROR;
        }
        else
        {
            vGet_sizlWindow(&sizl);

            ERECTL ercl(0, 0, sizl.cx, sizl.cy);

            //
            // Bug #310012: Under multimon, the rectangle isn't necessarily
            // based at 0,0.
            //
            
            PDEVOBJ pdo(hdev());
            ASSERTGDI(pdo.bValid(), "Invalid pdev\n");
            {
                DEVLOCKOBJ dl(pdo);
                if (pdo.bMetaDriver() && bHasSurface() && pSurface()->bPDEVSurface())
                {
                    ercl += *pdo.pptlOrigin();
                }
            }

            // Clip Rgn is maintained in the DC coordinate space;
            // so, the window on physical device surface needs to be
            // converted into DC coordinates.  DC Window shown in PDEV
            // coordinates.
            //
            //            (0,0)      sizl.cx
            //              +-----------------------+
            //              |                       |
            //              |  PDEV Surface         |
            // (eptlOrigin) |                       |
            //   +----------+-----------+           |
            //   |          |           |           |  sizl.cy
            //   |  DC Window           |           |
            //   |     (erclWindow)     |           |
            //   |          |           |           |
            //   +----------+-----------+           |
            //              |                       |
            //              +-----------------------+
            //
            // With the eptlOrigin adjustment the clip will be positioned
            // as shown below.
            //
            // (0,0)      (-eptlOrigin)
            //   +----------+-----------+-----------+
            //   |          |           |           |
            //   |  DC Window           |           |
            //   |   (erclWindow-eptlOrigin)        |
            //   |          |           |           |
            //   +----------+-----------+           |
            //              |                       |
            //              |  Default Clip Region  |
            //              |                       |
            //              |                       |
            //              +-----------------------+
            //
            // Note: erclWindow-epltOrigin-eptlOrigin may give us more
            // narrow clip region, but using dclevel.sizl-eptlOrigin
            // will get the job done since we get that more narrow 
            // area when combined with prgnVis.

            ercl -= eptlOrigin();

            rmo3.vSet((PRECTL) &ercl);

            iTmp = rmo2.iCombine(rmo3, rmoRcl, iMode);

            if (iTmp != ERROR)
            {
                rmo2.vSelect((HDC)hGet());
                prgnClip(rmo2.prgnGet());

                #if DBG

                if ((dbgrgn) && (gflhdc == hGet()))
                {
                    DbgPrint("iCombine: hdc = 0x%p, new region = 0x%p\n",hHmgr,prgnClip());
                }

                #endif

            }
            else
            {
                rmo2.bDeleteRGNOBJ();
            }
        }

        rmoRcl.bDeleteRGNOBJ();
    }

    return(iTmp);
}

/******************************Public*Routine******************************\
* LONG DC::iCombine(pexo, prcl, iMode)
*
* Combine the clip region a possibly transformed rectangle by the given mode
*
* History:
*  28-Apr-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

LONG DC::iCombine(
EXFORMOBJ *pexo,
RECTL     *prcl,
LONG       iMode)
{
    POINTL  aptl[4];

    aptl[0].x = prcl->left;
    aptl[0].y = prcl->top;
    aptl[1].x = prcl->right;
    aptl[1].y = prcl->top;
    aptl[2].x = prcl->right;
    aptl[2].y = prcl->bottom;
    aptl[3].x = prcl->left;
    aptl[3].y = prcl->bottom;

// Create a path, and draw the parallelogram.

    PATHMEMOBJ  pmo;

    if (!pmo.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return(ERROR);
    }

    if (!pmo.bMoveTo(pexo, &aptl[0]))
        return(ERROR);

    if (!pmo.bPolyLineTo(pexo, &aptl[1], 3))
        return(ERROR);

    if (!pmo.bCloseFigure())
        return(ERROR);

// Now, convert it back into a region.

    RGNMEMOBJ rmoPlg(pmo, ALTERNATE);

    if (!rmoPlg.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return(ERROR);
    }

// Merge it into the current clipping region.

    REGION *prgn = prgnClip();
    LONG iTmp = ERROR;

    vReleaseRao();

    if (prgn != NULL)
    {
        RGNMEMOBJ rmo;

        if (rmo.bValid())
        {
            RGNOBJ ro(prgn);

            iTmp = rmo.iCombine(ro, rmoPlg, iMode);

            if (iTmp != ERROR)
            {
                rmo.vSelect((HDC)hGet());
                prgnClip(rmo.prgnGet());


                #if DBG

                if ((dbgrgn) && (gflhdc == hGet()))
                {
                    DbgPrint("iCombine: hdc = 0x%lx, new region = 0x%lx\n",hHmgr,prgnClip());
                }

                #endif


                // If nobody is using the old clip region, delete it.

                ro.vUnselect();

                if (ro.cGet_cRefs() == 0)
                    ro.bDeleteRGNOBJ();
            }
            else
            {
                rmo.bDeleteRGNOBJ();
            }
        }

        rmoPlg.bDeleteRGNOBJ();
    }
    else if (iMode == RGN_AND)
    {
        rmoPlg.vSelect((HDC)hGet());
        prgnClip(rmoPlg.prgnGet());


        #if DBG

        if ((dbgrgn) && (gflhdc == hGet()))
        {
            DbgPrint("iCombine: hdc = 0x%p, new region = 0x%p\n",hHmgr,prgnClip());
        }

        #endif

        iTmp = rmoPlg.iComplexity();
    }
    else
    {
        RGNMEMOBJ rmo2;
        SIZEL     sizl;

        if (rmo2.bValid())
        {
            RGNMEMOBJTMP rmo3;

            if (!rmo3.bValid())
            {
                rmo2.bDeleteRGNOBJ();
            }
            else
            {
                vGet_sizlWindow(&sizl);

                ERECTL      ercl(0, 0, sizl.cx, sizl.cy);

                //
                // Bug #310012: Under multimon, the rectangle isn't necessarily
                // based at 0,0.
                //
                
                PDEVOBJ pdo(hdev());
                ASSERTGDI(pdo.bValid(), "Invalid pdev\n");
                {
                    DEVLOCKOBJ dl(pdo);
                    if (pdo.bMetaDriver() && bHasSurface() && pSurface()->bPDEVSurface())
                    {
                        ercl += *pdo.pptlOrigin();
                    }
                }

                // Place Clip Region in DC Coordinates
                // See comments in DC::iCombine(lprcl, iMode) above.
                ercl -= eptlOrigin();

                rmo3.vSet((PRECTL) &ercl);

                iTmp = rmo2.iCombine(rmo3, rmoPlg, iMode);

                if (iTmp == ERROR)
                {
                    rmo2.bDeleteRGNOBJ();
                }
                else
                {
                    rmo2.vSelect((HDC)hGet());
                    prgnClip(rmo2.prgnGet());

                    #if DBG

                    if ((dbgrgn) && (gflhdc == hGet()))
                    {
                        DbgPrint("iCombine: hdc = 0x%p, new region = 0x%p\n",hHmgr,prgnClip());
                    }

                    #endif
                }
            }
        }

        rmoPlg.bDeleteRGNOBJ();
    }

    return(iTmp);
}

/******************************Public*Routine******************************\
* BOOL DC::bReset()
*
* Reset regions associated with the DC
*
* History:
*  05-Jul-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL DC::bReset()
{
    #if DBG

    if (dbgrgn)
    {
        DbgPrint("DC::bReset()\n");
    }

    #endif

    REGION *prgn;

    if ((prgn = dclevel.prgnMeta) != NULL)
    {
        RGNOBJ roMeta(prgn);

        roMeta.vUnselect();

        if (roMeta.cGet_cRefs() == 0)
            roMeta.bDeleteRGNOBJ();

        dclevel.prgnMeta = NULL;

        vReleaseRao();
    }

    if ((prgn = dclevel.prgnClip) != NULL)
    {
        RGNOBJ roClip(prgn);

        roClip.vUnselect();

        if (roClip.cGet_cRefs() == 0)
            roClip.bDeleteRGNOBJ();

        dclevel.prgnClip = NULL;

        vReleaseRao();
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bSaveRegion(dco, cLevel)
*
* Save the DC's regions
*
* History:
*  07-May-1991 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL bSaveRegion(DCOBJ& dco, LONG cLevel)
{
    if (cLevel == 1)
    {
        RECTL   rcl;
        SIZEL   sizl;

        dco.pdc->vGet_sizl(&sizl);

        rcl.left   = 0;
        rcl.bottom = 0;
        rcl.right  = sizl.cx;
        rcl.top    = sizl.cy;

        {
            RGNMEMOBJ rmo;

            if (!rmo.bValid())
                return(FALSE);

            //
            // Bug #310012: Under multimon, the rectangle isn't necessarily
            // based at 0,0.
            //
            
            PDEVOBJ pdo(dco.hdev());
            ASSERTGDI(pdo.bValid(), "Invalid pdev\n");
            {
                DEVLOCKOBJ dl(pdo);
                if (pdo.bMetaDriver() && dco.bHasSurface() && dco.pSurface()->bPDEVSurface())
                {
                    ((ERECTL) rcl) += *pdo.pptlOrigin();
                }
            }
            
            rmo.vSet(&rcl);

            dco.pdc->prgnVis(rmo.prgnGet());
        }

        return(TRUE);
    }


    DCOBJ  dcoSaved(dco.hdcSave());

    if (!dcoSaved.bLocked())
        return(FALSE);

    PREGION prgn;

    if ((prgn = dcoSaved.pdc->prgnMeta()) != NULL)
    {
        RGNOBJ roMeta(prgn);

        roMeta.vSelect(dco.hdc());
    }

    if ((prgn = dcoSaved.pdc->prgnClip()) != NULL)
    {
        RGNOBJ roClip(prgn);

        roClip.vSelect(dco.hdc());
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vRestoreRegion(dco, cLevel)
*
* Restore the DC's regions
*
* History:
*  08-May-1991 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vRestoreRegion(DCOBJ& dco, LONG cLevel)
{
    DONTUSE(cLevel);    // needed to keep save/restore calls happy

    PREGION prgn;

    if ((prgn = dco.pdc->prgnMeta()) != NULL)
    {
        RGNOBJ roMeta(prgn);

        roMeta.vUnselect();

        if (roMeta.cGet_cRefs() == 0)
            roMeta.bDeleteRGNOBJ();
    }

    if ((prgn = dco.pdc->prgnClip()) != NULL)
    {
        RGNOBJ roClip(prgn);

        roClip.vUnselect();

        if (roClip.cGet_cRefs() == 0)
            roClip.bDeleteRGNOBJ();
    }
}

/******************************Public*Routine******************************\
* int DC::iSelect(hrgn, iMode)
*
* Select the region into the DC as the current clip region
*
* History:
*  17-Sep-1991 -by- Donald Sidoroff [donalds]
* Made DC::iSelect for SelectObject/SelectClipRgn compatibility.
*
*  02-Sep-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

int DC::iSelect(HRGN hrgn, int iMode)
{
    int iRet;

    if (hrgn != (HRGN)0)
    {
        RGNOBJAPI ro(hrgn,TRUE);
        if (ro.bValid())
            iRet = iSelect(ro.prgnGet(),iMode);
        else
            iRet = RGN_ERROR;
    }
    else
    {
        if (iMode == RGN_COPY)
            iRet = iSelect((PREGION)NULL,iMode);
        else
            iRet = RGN_ERROR;
    }
    return(iRet);
}

/******************************Member*Function*****************************\
*
* History:
*  23-Oct-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int DC::iSelect(PREGION prgn, int iMode)
{
    PREGION prgnOld = prgnClip();
    PREGION prgnNew = NULL;
    int     iRet = RGN_ERROR;

    if ((iMode == RGN_COPY) ||
        ((iMode == RGN_AND) && (prgn != NULL) && (prgnOld == NULL)))
    {

        //
        // Select in a region?
        //

        if (prgn != NULL)
        {
            RGNOBJ ro(prgn);
            RGNOBJ roClip(prgnOld);

            //
            // There was no old region so create a new region and
            // copy the input region to it, or the old region can't
            // be modified due to other references.
            //

            if ((prgnOld == NULL) || (roClip.cGet_cRefs() != 1))
            {

                RGNMEMOBJ rmo(ro.sizeRgn());

                if (rmo.bValid())
                {
                    rmo.vCopy(ro);
                    rmo.vSelect((HDC)hGet());
                    prgnNew = rmo.prgnGet();

                    iRet = (int) rmo.iComplexity();

                    //
                    // select new region in and release RAO
                    //

                    prgnClip(prgnNew);
                    vReleaseRao();

                    //
                    //  If there was an old clip region, it must be
                    //  unreferenced.
                    //

                    if (prgnOld != NULL)
                    {
                        roClip.vUnselect();

                        if (roClip.cGet_cRefs() == 0)
                        {
                            roClip.bDeleteRGNOBJ();
                        }
                    }
                }
            }
            else
            {
                //
                // select in a new region, there already was an old one so
                // bCopy the new to the old
                //

                if (roClip.bCopy(ro))
                {

                    //
                    // bCopy might change prgn
                    //

                    prgnNew = roClip.prgnGet();

                    iRet = (int) roClip.iComplexity();

                    //
                    // set new region pointer and release RAO
                    //

                    prgnClip(prgnNew);

                    vReleaseRao();
                }
            }
        }
        else
        {
            iRet = SIMPLEREGION;

            //
            // new clip region is NULL, delete old if it exists
            //

            if (prgnOld != NULL)
            {

                RGNOBJ roClip(prgnOld);

                roClip.vUnselect();

                if (roClip.cGet_cRefs() == 0)
                {
                    roClip.bDeleteRGNOBJ();
                }

                prgnClip(NULL);
                vReleaseRao();
            }
        }
    }
    else
    {

        //
        // We didn't simply select the new region.
        //

        RGNOBJ ro(prgn);

        RGNMEMOBJ   rmo;

        if (rmo.bValid())
        {

            if (prgnOld != NULL)
            {
                RGNOBJ roClip(prgnOld);

                if ((iRet = (int) rmo.iCombine(roClip,ro,iMode)) != RGN_ERROR)
                {
                    rmo.vSelect((HDC)hGet());
                    prgnNew = rmo.prgnGet();

                    prgnClip(prgnNew);


                    #if DBG

                    if (dbgrgn)
                    {
                        DbgPrint("iSelect: hdc = 0x%p, new region = 0x%p\n",hHmgr,prgnClip());
                    }

                    #endif

                    vReleaseRao();

                    roClip.vUnselect();
                    if (roClip.cGet_cRefs() == 0)
                    {
                        roClip.bDeleteRGNOBJ();
                    }
                }
            }
            else
            {
                //
                // Since no clip region exists, make a dummy the size of the surface
                //

                RGNMEMOBJTMP rmo2;
                SIZEL        sizl;

                if (rmo2.bValid())
                {
                    vGet_sizlWindow(&sizl);

                    ERECTL  ercl(0, 0, sizl.cx, sizl.cy);

                    //
                    // Bug #310012: Under multimon, the rectangle isn't necessarily
                    // based at 0,0.
                    //
                    
                    PDEVOBJ pdo(hdev());
                    ASSERTGDI(pdo.bValid(), "Invalid pdev\n");
                    {
                        DEVLOCKOBJ dl(pdo);
                        if (pdo.bMetaDriver() && bHasSurface() && pSurface()->bPDEVSurface())
                        {
                            ercl += *pdo.pptlOrigin();
                        }
                    }

                    // Place Clip Region in DC Coordinates
                    // See comments in DC::iCombine(lprcl, iMode) above.
                    ercl -= eptlOrigin();

                    rmo2.vSet((PRECTL) &ercl);
                    iRet = (int) rmo.iCombine(rmo2,ro,iMode);

                    if (iRet != RGN_ERROR)
                    {
                        rmo.vSelect((HDC)hGet());
                        prgnNew = rmo.prgnGet();

                        prgnClip(prgnNew);

                        #if DBG

                        if (dbgrgn)
                        {
                            DbgPrint("iSelect: hdc = 0x%p, new region = 0x%p\n",hHmgr,prgnClip());
                        }

                        #endif

                        vReleaseRao();
                    }
                }
            }

            if (iRet == RGN_ERROR)
            {
                rmo.bDeleteRGNOBJ();
            }
        }
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* int DC::iSetMetaRgn()
*
* Select the region into the DC as the current meta region
*
* History:
*  01-Nov-1991 19:13:33 -by- Donald Sidoroff [donalds]
* Wrote it.
*
*  25-Nov-1992 -by-  Eric Kutter [erick]
*   rewrote
\**************************************************************************/

int DC::iSetMetaRgn()
{


    #if DBG

    if (dbgrgn)
    {
        DbgPrint("DC::iSetMetaRgn()\n");
    }

    #endif

    int iRet = RGN_ERROR;

    if (prgnMeta() == (PREGION)0)
    {
        if (prgnClip() == NULL)
            return(SIMPLEREGION);

        RGNOBJ ro(prgnClip());

        iRet = (int) ro.iComplexity();

    // NOTE: Since we're just copying the handle, the reference counts should
    // remain the same.

        prgnMeta(prgnClip());

        prgnClip(NULL);

        #if DBG

        if (dbgrgn)
        {
            DbgPrint("iSetMetaRgn: hdc = 0x%p, new region = 0x%p\n",hHmgr,prgnClip());
        }

        #endif

        return(iRet);
    }
    else
    {
        RGNOBJ roMeta(prgnMeta());

    // if we only have a meta rgn, just return that.

        if (prgnClip() == NULL)
            return(roMeta.iComplexity());

    // need the merge the two into a new region

        RGNOBJ roClip(prgnClip());

        RGNMEMOBJ rmo;

        if (!rmo.bValid())
            return(iRet);

    // combine the regions

        iRet = (int) rmo.iCombine(roMeta,roClip,RGN_AND);

        if (iRet != RGN_ERROR)
        {
            rmo.vSelect((HDC)hGet());

        // delete the old meta rgn

            prgnMeta(rmo.prgnGet());

            roMeta.vUnselect();
            if (roMeta.cGet_cRefs() == 0)
                roMeta.bDeleteRGNOBJ();

        // delete the old clip rgn

            prgnClip(NULL);


            #if DBG

            if (dbgrgn)
            {
                DbgPrint("iSetMetaRgn: hdc = 0x%p, new region = 0x%p\n",hHmgr,prgnClip());
            }

            #endif

            roClip.vUnselect();
            if (roClip.cGet_cRefs() == 0)
                roClip.bDeleteRGNOBJ();

            vReleaseRao();

        }
        else
            rmo.bDeleteRGNOBJ();
    }
    return(iRet);
}

/******************************Public*Routine******************************\
* VOID DC::vReleaseVis()
*
* Release the current VisRgn
*
* History:
*  06-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID DC::vReleaseVis()
{

    #if DBG

    if ((dbgrgn) && (gflhdc == hGet()))
    {
        DbgPrint("DC::vReleaseVis\n");
    }

    #endif

    fsSet(DC_DIRTY_RAO);
    PENTRY_FROM_POBJ(this)->Flags |= HMGR_ENTRY_INVALID_VIS;

    erclClip(&rclEmpty);

    ASSERTGDI(prgnVis() != NULL,"DC::vReleaseVis - prgnVis == NULL\n");

    RGNLOG rl((HRGN)prgnVis(),0,"DC::vReleaseVis");

    prgnVis()->vDeleteREGION();
    prgnVis(prgnDefault);

}

/******************************Public*Routine******************************\
* VOID DC::vReleaseRao()
*
* Release the current RaoRgn
*
* History:
*  06-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID DC::vReleaseRao()
{

    #if DBG

    if ((dbgrgn) && (gflhdc == hGet()))
    {
        DbgPrint("DC::vReleaseRao\n");
    }

    #endif

    fsSet(DC_DIRTY_RAO);

    PENTRY_FROM_POBJ(this)->Flags |= HMGR_ENTRY_INVALID_VIS;

    erclClip(&rclEmpty);

    RGNLOG rl(prgnRao(),"DC::vReleaseRao");
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\dither.cxx ===
/******************************Module*Header*******************************\
* Module Name: dither.cxx
*
* This algorithm for color dithering is patent pending and its use is
* restricted to Microsoft products and drivers for Microsoft products.
* Use in non-Microsoft products or in drivers for non-Microsoft products
* is prohibited without the expressed written consent of Microsoft Corp.
*
* The patent application is the primary reference for the operation of the
* color dithering code.
*
* Note that in the comments and variable names, "vertex" means "vertex of
* either the inner (half intensity) or outer (full intensity) color cube."
* Vertices map to colors 0-7 and 9-15 of the Windows standard (required)
* 16-color palette, where vertices 0-7 are the vertices of the inner color
* cube, and 0 plus 9-15 are the vertices of the full color cube. Vertex 8 is
* 75% gray; this could be used in the dither, but that would break apps that
* depend on the exact Windows 3.1 dithering. This code is Window 3.1
* compatible.
*
* Note that as a result of the compatibility requirement, the dither
* produced by this algorithm is the exact same dither as that produced
* by the default Windows 3.1 16 color and 256 color VGA drivers.
*
* Copyright (c) 1992-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

/**************************************************************************\
* This function takes a value from 0 - 255 and uses it to create an
* 8x8 pile of bits in the form of a 1BPP bitmap.  It can also take an
* RGB value and make an 8x8 bitmap.  These can then be used as brushes
* to simulate color unavaible on the device.
*
* For monochrome the basic algorithm is equivalent to turning on bits
* in the 8x8 array according to the following order:
*
*  00 32 08 40 02 34 10 42
*  48 16 56 24 50 18 58 26
*  12 44 04 36 14 46 06 38
*  60 28 52 20 62 30 54 22
*  03 35 11 43 01 33 09 41
*  51 19 59 27 49 17 57 25
*  15 47 07 39 13 45 05 37
*  63 31 55 23 61 29 53 21
*
* Reference: A Survey of Techniques for the Display of Continous
*            Tone Pictures on Bilevel Displays,;
*            Jarvis, Judice, & Ninke;
*            COMPUTER GRAPHICS AND IMAGE PROCESSING 5, pp 13-40, (1976)
\**************************************************************************/

#define SWAP_RB 0x00000004
#define SWAP_GB 0x00000002
#define SWAP_RG 0x00000001

#define SWAPTHEM(a,b) (ulTemp = a, a = b, b = ulTemp)

// PATTERNSIZE is the number of pixels in a dither pattern.
#define PATTERNSIZE 64

// Tells which row to turn a pel on in when dithering for monochrome bitmaps.
static BYTE ajByte[] = {
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7,
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7
};

// The array of monochrome bits used for monc
static BYTE ajBits[] = {
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80
};

// Translates vertices back to the original subspace. Each row is a subspace,
// as encoded in ulSymmetry, and each column is a vertex between 0 and 15.
BYTE jSwapSubSpace[8*16] = {
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    0, 2, 1, 3, 4, 6, 5, 7, 8, 10, 9, 11, 12, 14, 13, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 4, 2, 6, 1, 5, 3, 7, 8, 12, 10, 14, 9, 13, 11, 15,
    0, 2, 4, 6, 1, 3, 5, 7, 8, 10, 12, 14, 9, 11, 13, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
};


// Converts a nibble value in the range 0-15 to a dword value containing the
// nibble value packed 8 times.

// For 8bpp, also translate to 256-color palette index.
ULONG ulNibbleTo8bppDword[16] = {
    0x00000000,
    0x01010101,
    0x02020202,
    0x03030303,
    0x04040404,
    0x05050505,
    0x06060606,
    0xF8F8F8F8,
    0x07070707,
    0xF9F9F9F9,
    0xFAFAFAFA,
    0xFBFBFBFB,
    0xFCFCFCFC,
    0xFDFDFDFD,
    0xFEFEFEFE,
    0xFFFFFFFF
};

// For 4bpp, no translation is necessary.
ULONG ulNibbleTo4bppDword[16] = {
    0x00000000,
    0x01010101,
    0x02020202,
    0x03030303,
    0x04040404,
    0x05050505,
    0x06060606,
    0x07070707,
    0x08080808,
    0x09090909,
    0x0A0A0A0A,
    0x0B0B0B0B,
    0x0C0C0C0C,
    0x0D0D0D0D,
    0x0E0E0E0E,
    0x0F0F0F0F
};


// Specifies where in the dither pattern colors should be placed in order
// of increasing intensity.

// 8bpp specific version.
ULONG aulDither8bppOrder[] = {
  0, 36,  4, 32, 18, 54, 22, 50,
  2, 38,  6, 34, 16, 52, 20, 48,
  9, 45, 13, 41, 27, 63, 31, 59,
 11, 47, 15, 43, 25, 61, 29, 57,
  1, 37,  5, 33, 19, 55, 23, 51,
  3, 39,  7, 35, 17, 53, 21, 49,
  8, 44, 12, 40, 26, 62, 30, 58,
 10, 46, 14, 42, 24, 60, 28, 56,
};

// 4bpp specific version. This is organized in the following form, for
// efficiency: every set of 8 pixels (0-7, 8-15, 16-23, ... ,56-63) is
// placed in the dither pattern in the order: 0 2 4 6 1 3 5 7. This is
// done so that two longs can be combined to put 8 pixels in DIB4 format
// at once (the first dword is shifted left 4, then the two dwords are
// ORed, to produce 0 1 2 3 4 5 6 7 order in memory), which is much faster than
// combining the output of the straight dither ordering.
// The effective dither ordering after we combine each pair of ULONGS at the
// end (the desired dither ordering) matches aulDither8bppOrder (see above).
//
ULONG aulDither4bppOrder[] = {
  0, 34,  2, 32, 17, 51, 19, 49,
  1, 35,  3, 33, 16, 50, 18, 48,
 12, 46, 14, 44, 29, 63, 31, 61,
 13, 47, 15, 45, 28, 62, 30, 60,
  4, 38,  6, 36, 21, 55, 23, 53,
  5, 39,  7, 37, 20, 54, 22, 52,
  8, 42, 10, 40, 25, 59, 27, 57,
  9, 43, 11, 41, 24, 58, 26, 56,
};


// Array to convert to 256 color from 16 color. Maps from index that represents
// a 16-color vertex (color) to value that specifies the color index in the
// 256-color palette.
BYTE ajConvert[] =
{
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    248,
    7,
    249,
    250,
    251,
    252,
    253,
    254,
    255
};

// Describes a single colour tetrahedron vertex for dithering:
typedef struct _VERTEX_DATA {
    ULONG ulCount;              // Number of pixels in this vertex
    ULONG ulVertex;             // Vertex number
} VERTEX_DATA;                      /* vd, pv */

VERTEX_DATA*    vComputeSubspaces(ULONG, VERTEX_DATA*);
VOID            vDitherColor8bpp(ULONG*, VERTEX_DATA*, VERTEX_DATA*, ULONG);
VOID            vDitherColor4bpp(ULONG*, VERTEX_DATA*, VERTEX_DATA*, ULONG);

/******************************Public*Routine******************************\
* vComputeSubspaces
*
* Calculates the subspace data associated with rgb, stores the data at
* pvVertexData, in the form of an array of VERTEX_DATA structures,
* suitable for vDitherColor. Returns a pointer to the byte after the
* last VERTEX_DATA structure.
*
* Ignores the high byte of rgb.
*
\**************************************************************************/

VERTEX_DATA* vComputeSubspaces(
ULONG           rgb,
VERTEX_DATA*    pvVertexData)
{
    ULONG   ulRedTemp, ulGreenTemp, ulBlueTemp, ulSymmetry;
    ULONG   ulRed, ulGre, ulBlu, ulTemp;
    ULONG   ulVertex0Temp, ulVertex1Temp, ulVertex2Temp, ulVertex3Temp;

    // Split the color into red, green, and blue components
    ulRedTemp   = ((PAL_ULONG *)&rgb)->pal.peRed;
    ulGreenTemp   = ((PAL_ULONG *)&rgb)->pal.peGreen;
    ulBlueTemp   = ((PAL_ULONG *)&rgb)->pal.peBlue;

    // Sort the RGB so that the point is transformed into subspace 0, and
    // keep track of the swaps in ulSymmetry so we can unravel it again
    // later.  We want r >= g >= b (subspace 0).
    ulSymmetry = 0;
    if (ulBlueTemp > ulRedTemp) {
        SWAPTHEM(ulBlueTemp,ulRedTemp);
        ulSymmetry = SWAP_RB;
    }

    if (ulBlueTemp > ulGreenTemp) {
        SWAPTHEM(ulBlueTemp,ulGreenTemp);
        ulSymmetry |= SWAP_GB;
    }

    if (ulGreenTemp > ulRedTemp) {
        SWAPTHEM(ulGreenTemp,ulRedTemp);
        ulSymmetry |= SWAP_RG;
    }

    ulSymmetry <<= 4;   // for lookup purposes

    // Scale the values from 0-255 to 0-64. Note that the scaling is not
    // symmetric at the ends; this is done to match Windows 3.1 dithering
    ulRed = (ulRedTemp + 1) >> 2;
    ulGre = (ulGreenTemp + 1) >> 2;
    ulBlu = (ulBlueTemp + 1) >> 2;

    // Compute the subsubspace within subspace 0 in which the point lies,
    // then calculate the # of pixels to dither in the colors that are the
    // four vertexes of the tetrahedron bounding the color we're emulating.
    // Only vertices with more than zero pixels are stored, and the
    // vertices are stored in order of increasing intensity, saving us the
    // need to sort them later
    if ((ulRedTemp + ulGreenTemp) > 256) {
        // Subsubspace 2 or 3
        if ((ulRedTemp + ulBlueTemp) > 256) {
            // Subsubspace 3
            // Calculate the number of pixels per vertex, still in
            // subsubspace 3, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 3 is:
            // 7, 9, 0x0B, 0x0F
            if ((ulVertex0Temp = (64 - ulRed) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            ulVertex2Temp = ulGre - ulBlu;
            ulVertex3Temp = (ulRed - 64) + ulBlu;
            if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0F];
            }
        } else {
            // Subsubspace 2
            // Calculate the number of pixels per vertex, still in
            // subsubspace 2, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 2 is:
            // 3, 7, 9, 0x0B
            ulVertex1Temp = ulBlu << 1;
            ulVertex2Temp = ulRed - ulGre;
            ulVertex3Temp = (ulRed - 32) + (ulGre - 32);
            if ((ulVertex0Temp = ((PATTERNSIZE - ulVertex1Temp) -
                        ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex1Temp != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
            }
        }
    } else {
        // Subsubspace 0 or 1
        if (ulRedTemp > 128) {
            // Subsubspace 1
            // Calculate the number of pixels per vertex, still in
            // subsubspace 1, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 1 is:
            // 1, 3, 7, 9
            if ((ulVertex0Temp = ((32 - ulGre) + (32 - ulRed)) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
            }
            ulVertex2Temp = ulBlu << 1;
            ulVertex3Temp = (ulRed - 32) << 1;
            if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
        } else {
            // Subsubspace 0
            // Calculate the number of pixels per vertex, still in
            // subsubspace 0, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 0 is:
            // 0, 1, 3, 7
            if ((ulVertex0Temp = (32 - ulRed) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x00];
            }
            if ((ulVertex1Temp = (ulRed - ulGre) << 1) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
            }
            ulVertex3Temp = ulBlu << 1;
            if ((ulVertex2Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex1Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
        }
    }

    return(pvVertexData);
}

/******************************Public*Routine******************************\
* vDitherColor8bpp
*
* Dithers the ulNumVertices vertices described by vVertexData into pulDest.
*
\**************************************************************************/

VOID vDitherColor8bpp(
ULONG*          pulDest,
VERTEX_DATA*    vVertexData,
VERTEX_DATA*    pvVertexDataEnd,
ULONG           ulNumVertices)
{
    ULONG ulTemp, ulNumPixels, ulColor;
    VERTEX_DATA *pvMaxVertex, *pvVertexData;
    ULONG  *pulDitherOrder;
    BYTE    jColor;
    BYTE   *pjDither = (BYTE *)pulDest;

    if (ulNumVertices > 2) {

        // There are 3 or 4 vertices in this dither
        if (ulNumVertices == 3) {

            // There are 3 vertices in this dither

            // Find the vertex with the most pixels, and fill the whole
            // destination bitmap with that vertex's color, which is faster
            // than dithering it
            if (vVertexData[1].ulCount >= vVertexData[2].ulCount) {
                pvMaxVertex = &vVertexData[1];
                ulTemp = vVertexData[1].ulCount;
            } else {
                pvMaxVertex = &vVertexData[2];
                ulTemp = vVertexData[2].ulCount;
            }

        } else {

            // There are 4 vertices in this dither

            // Find the vertex with the most pixels, and fill the whole
            // destination bitmap with that vertex's color, which is faster
            // than dithering it
            if (vVertexData[2].ulCount >= vVertexData[3].ulCount) {
                pvMaxVertex = &vVertexData[2];
                ulTemp = vVertexData[2].ulCount;
            } else {
                pvMaxVertex = &vVertexData[3];
                ulTemp = vVertexData[3].ulCount;
            }
        }

        if (vVertexData[1].ulCount > ulTemp) {
            pvMaxVertex = &vVertexData[1];
            ulTemp = vVertexData[1].ulCount;
        }
        if (vVertexData[0].ulCount > ulTemp) {
            pvMaxVertex = &vVertexData[0];
        }

        // Prepare a dword version of the most common vertex number (color)
        ulColor = ulNibbleTo8bppDword[pvMaxVertex->ulVertex];

        // Mark that the vertex we're about to do doesn't need to be done
        // later
        pvMaxVertex->ulVertex = 0xFF;

        // Block fill the dither pattern with the more common vertex
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;
        *(pulDest+8) = ulColor;
        *(pulDest+9) = ulColor;
        *(pulDest+10) = ulColor;
        *(pulDest+11) = ulColor;
        *(pulDest+12) = ulColor;
        *(pulDest+13) = ulColor;
        *(pulDest+14) = ulColor;
        *(pulDest+15) = ulColor;

        // Now dither all the remaining vertices in order 0->2 or 0->3
        // (in order of increasing intensity)
        pulDitherOrder = aulDither8bppOrder;
        pvVertexData = vVertexData;
        do {
            if (pvVertexData->ulVertex == 0xFF) {
                // This is the max vertex, which we already did, but we
                // have to account for it in the dither order
                pulDitherOrder += pvVertexData->ulCount;
            } else {
                jColor = (BYTE) ajConvert[pvVertexData->ulVertex];
                ulNumPixels = pvVertexData->ulCount;
                switch (ulNumPixels & 3) {
                    case 3:
                        pjDither[*(pulDitherOrder+2)] = jColor;
                    case 2:
                        pjDither[*(pulDitherOrder+1)] = jColor;
                    case 1:
                        pjDither[*(pulDitherOrder+0)] = jColor;
                        pulDitherOrder += ulNumPixels & 3;
                    case 0:
                        break;
                }
                if ((ulNumPixels >>= 2) != 0) {
                    do {
                        pjDither[*pulDitherOrder] = jColor;
                        pjDither[*(pulDitherOrder+1)] = jColor;
                        pjDither[*(pulDitherOrder+2)] = jColor;
                        pjDither[*(pulDitherOrder+3)] = jColor;
                        pulDitherOrder += 4;
                    } while (--ulNumPixels);
                }
            }
        } while (++pvVertexData < pvVertexDataEnd);

    } else if (ulNumVertices == 2) {

        // There are exactly two vertices with more than zero pixels; fill
        // in the dither array as follows: block fill with vertex with more
        // points first, then dither in the other vertex
        if (vVertexData[0].ulCount >= vVertexData[1].ulCount) {
            // There are no more vertex 1 than vertex 0 pixels, so do
            // the block fill with vertex 0
            ulColor = ulNibbleTo8bppDword[vVertexData[0].ulVertex];
            // Do the dither with vertex 1
            jColor = (BYTE) ajConvert[vVertexData[1].ulVertex];
            ulNumPixels = vVertexData[1].ulCount;
            // Set where to start dithering with vertex 1 (vertex 0 is
            // lower intensity, so its pixels come first in the dither
            // order)
            pulDitherOrder = aulDither8bppOrder + vVertexData[0].ulCount;
        } else {
            // There are more vertex 1 pixels, so do the block fill
            // with vertex 1
            ulColor = ulNibbleTo8bppDword[vVertexData[1].ulVertex];
            // Do the dither with vertex 0
            jColor = (BYTE) ajConvert[vVertexData[0].ulVertex];
            ulNumPixels = vVertexData[0].ulCount;
            // Set where to start dithering with vertex 0 (vertex 0 is
            // lower intensity, so its pixels come first in the dither
            // order)
            pulDitherOrder = aulDither8bppOrder;
        }

        // Block fill the dither pattern with the more common vertex
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;
        *(pulDest+8) = ulColor;
        *(pulDest+9) = ulColor;
        *(pulDest+10) = ulColor;
        *(pulDest+11) = ulColor;
        *(pulDest+12) = ulColor;
        *(pulDest+13) = ulColor;
        *(pulDest+14) = ulColor;
        *(pulDest+15) = ulColor;

        // Dither in the less common vertex
        switch (ulNumPixels & 3) {
            case 3:
                pjDither[*(pulDitherOrder+2)] = jColor;
            case 2:
                pjDither[*(pulDitherOrder+1)] = jColor;
            case 1:
                pjDither[*(pulDitherOrder+0)] = jColor;
                pulDitherOrder += ulNumPixels & 3;
            case 0:
                break;
        }
        if ((ulNumPixels >>= 2) != 0) {
            do {
                pjDither[*pulDitherOrder] = jColor;
                pjDither[*(pulDitherOrder+1)] = jColor;
                pjDither[*(pulDitherOrder+2)] = jColor;
                pjDither[*(pulDitherOrder+3)] = jColor;
                pulDitherOrder += 4;
            } while (--ulNumPixels);
        }

    } else {

        // There is only one vertex in this dither

        // No sorting or dithering is needed for just one color; we can
        // just generate the final DIB directly
        ulColor = ulNibbleTo8bppDword[vVertexData[0].ulVertex];
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;
        *(pulDest+8) = ulColor;
        *(pulDest+9) = ulColor;
        *(pulDest+10) = ulColor;
        *(pulDest+11) = ulColor;
        *(pulDest+12) = ulColor;
        *(pulDest+13) = ulColor;
        *(pulDest+14) = ulColor;
        *(pulDest+15) = ulColor;
    }
}


/******************************Public*Routine******************************\
* vDitherColor4bpp
*
* Dithers the ulNumVertices vertices described by vVertexData into pulDest.
*
\**************************************************************************/

VOID vDitherColor4bpp(
    ULONG * pulDest,
    VERTEX_DATA * vVertexData,
    VERTEX_DATA * pvVertexDataEnd,
    ULONG ulNumVertices)
{
    ULONG ulTemp, ulNumPixels, ulColor;
    VERTEX_DATA *pvMaxVertex, *pvVertexData;
    ULONG  *pulTemp, *pulDitherOrder;
    BYTE    jColor;
    BYTE    ajDither[64];

    if (ulNumVertices > 2) {

        // There are 3 or 4 vertices in this dither
        if (ulNumVertices == 3) {

            // There are 3 vertices in this dither

            // Find the vertex with the most pixels, and fill the whole
            // destination bitmap with that vertex's color, which is faster
            // than dithering it
            if (vVertexData[1].ulCount >= vVertexData[2].ulCount) {
                pvMaxVertex = &vVertexData[1];
                ulTemp = vVertexData[1].ulCount;
            } else {
                pvMaxVertex = &vVertexData[2];
                ulTemp = vVertexData[2].ulCount;
            }

        } else {

            // There are 4 vertices in this dither

            // Find the vertex with the most pixels, and fill the whole
            // destination bitmap with that vertex's color, which is faster
            // than dithering it
            if (vVertexData[2].ulCount >= vVertexData[3].ulCount) {
                pvMaxVertex = &vVertexData[2];
                ulTemp = vVertexData[2].ulCount;
            } else {
                pvMaxVertex = &vVertexData[3];
                ulTemp = vVertexData[3].ulCount;
            }
        }

        if (vVertexData[1].ulCount > ulTemp) {
            pvMaxVertex = &vVertexData[1];
            ulTemp = vVertexData[1].ulCount;
        }
        if (vVertexData[0].ulCount > ulTemp) {
            pvMaxVertex = &vVertexData[0];
        }

        // Prepare a dword version of the most common vertex number (color)
        ulColor = ulNibbleTo4bppDword[pvMaxVertex->ulVertex];

        // Mark that the vertex we're about to do doesn't need to be done
        // later
        pvMaxVertex->ulVertex = 0xFF;

        // Block fill the dither pattern with the more common vertex
        pulTemp = (ULONG *)ajDither;
        *pulTemp = ulColor;
        *(pulTemp+1) = ulColor;
        *(pulTemp+2) = ulColor;
        *(pulTemp+3) = ulColor;
        *(pulTemp+4) = ulColor;
        *(pulTemp+5) = ulColor;
        *(pulTemp+6) = ulColor;
        *(pulTemp+7) = ulColor;
        *(pulTemp+8) = ulColor;
        *(pulTemp+9) = ulColor;
        *(pulTemp+10) = ulColor;
        *(pulTemp+11) = ulColor;
        *(pulTemp+12) = ulColor;
        *(pulTemp+13) = ulColor;
        *(pulTemp+14) = ulColor;
        *(pulTemp+15) = ulColor;

        // Now dither all the remaining vertices in order 0->2 or 0->3
        // (in order of increasing intensity)
        pulDitherOrder = aulDither4bppOrder;
        pvVertexData = vVertexData;
        do {
            if (pvVertexData->ulVertex == 0xFF) {
                // This is the max vertex, which we already did, but we
                // have to account for it in the dither order
                pulDitherOrder += pvVertexData->ulCount;
            } else {
                jColor = (BYTE) pvVertexData->ulVertex;
                ulNumPixels = pvVertexData->ulCount;
                switch (ulNumPixels & 3) {
                    case 3:
                        ajDither[*(pulDitherOrder+2)] = jColor;
                    case 2:
                        ajDither[*(pulDitherOrder+1)] = jColor;
                    case 1:
                        ajDither[*(pulDitherOrder+0)] = jColor;
                        pulDitherOrder += ulNumPixels & 3;
                    case 0:
                        break;
                }
                if ((ulNumPixels >>= 2) != 0) {
                    do {
                        ajDither[*pulDitherOrder] = jColor;
                        ajDither[*(pulDitherOrder+1)] = jColor;
                        ajDither[*(pulDitherOrder+2)] = jColor;
                        ajDither[*(pulDitherOrder+3)] = jColor;
                        pulDitherOrder += 4;
                    } while (--ulNumPixels);
                }
            }
        } while (++pvVertexData < pvVertexDataEnd);

    } else if (ulNumVertices == 2) {

        // There are exactly two vertices with more than zero pixels; fill
        // in the dither array as follows: block fill with vertex with more
        // points first, then dither in the other vertex
        if (vVertexData[0].ulCount >= vVertexData[1].ulCount) {
            // There are no more vertex 1 than vertex 0 pixels, so do
            // the block fill with vertex 0
            ulColor = ulNibbleTo4bppDword[vVertexData[0].ulVertex];
            // Do the dither with vertex 1
            jColor = (BYTE) vVertexData[1].ulVertex;
            ulNumPixels = vVertexData[1].ulCount;
            // Set where to start dithering with vertex 1 (vertex 0 is
            // lower intensity, so its pixels come first in the dither
            // order)
            pulDitherOrder = aulDither4bppOrder + vVertexData[0].ulCount;
        } else {
            // There are more vertex 1 pixels, so do the block fill
            // with vertex 1
            ulColor = ulNibbleTo4bppDword[vVertexData[1].ulVertex];
            // Do the dither with vertex 0
            jColor = (BYTE) vVertexData[0].ulVertex;
            ulNumPixels = vVertexData[0].ulCount;
            // Set where to start dithering with vertex 0 (vertex 0 is
            // lower intensity, so its pixels come first in the dither
            // order)
            pulDitherOrder = aulDither4bppOrder;
        }

        // Block fill the dither pattern with the more common vertex
        pulTemp = (ULONG *)ajDither;
        *pulTemp = ulColor;
        *(pulTemp+1) = ulColor;
        *(pulTemp+2) = ulColor;
        *(pulTemp+3) = ulColor;
        *(pulTemp+4) = ulColor;
        *(pulTemp+5) = ulColor;
        *(pulTemp+6) = ulColor;
        *(pulTemp+7) = ulColor;
        *(pulTemp+8) = ulColor;
        *(pulTemp+9) = ulColor;
        *(pulTemp+10) = ulColor;
        *(pulTemp+11) = ulColor;
        *(pulTemp+12) = ulColor;
        *(pulTemp+13) = ulColor;
        *(pulTemp+14) = ulColor;
        *(pulTemp+15) = ulColor;

        // Dither in the less common vertex
        switch (ulNumPixels & 3) {
            case 3:
                ajDither[*(pulDitherOrder+2)] = jColor;
            case 2:
                ajDither[*(pulDitherOrder+1)] = jColor;
            case 1:
                ajDither[*(pulDitherOrder+0)] = jColor;
                pulDitherOrder += ulNumPixels & 3;
            case 0:
                break;
        }
        if ((ulNumPixels >>= 2) != 0) {
            do {
                ajDither[*pulDitherOrder] = jColor;
                ajDither[*(pulDitherOrder+1)] = jColor;
                ajDither[*(pulDitherOrder+2)] = jColor;
                ajDither[*(pulDitherOrder+3)] = jColor;
                pulDitherOrder += 4;
            } while (--ulNumPixels);
        }

    } else {

        // There is only one vertex in this dither

        // No sorting or dithering is needed for just one color; we can
        // just generate the final DIB directly
        ulColor = ulNibbleTo4bppDword[vVertexData[0].ulVertex];
        ulColor |= ulColor << 4;
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;

        return;
    }

    // Now convert the 64 bytes into the 4BPP Engine Format Bitmap
    pulTemp = (ULONG *)ajDither;

    *pulDest = (*pulTemp << 4) | *(pulTemp + 1);
    *(pulDest + 1) = (*(pulTemp + 2) << 4) | *(pulTemp + 3);
    *(pulDest + 2) = (*(pulTemp + 4) << 4) | *(pulTemp + 5);
    *(pulDest + 3) = (*(pulTemp + 6) << 4) | *(pulTemp + 7);
    *(pulDest + 4) = (*(pulTemp + 8) << 4) | *(pulTemp + 9);
    *(pulDest + 5) = (*(pulTemp + 10) << 4) | *(pulTemp + 11);
    *(pulDest + 6) = (*(pulTemp + 12) << 4) | *(pulTemp + 13);
    *(pulDest + 7) = (*(pulTemp + 14) << 4) | *(pulTemp + 15);
}


/******************************Public*Routine******************************\
* EngDitherColor
*
* Dithers an RGB color to an 8X8 approximation using the reserved VGA
* colours.
*
\**************************************************************************/

ULONG EngDitherColor(
HDEV    hdev, 
ULONG   iMode,
ULONG   rgb,
ULONG*  pul)
{
    ULONG   ulGrey, ulRed, ulGre, ulBlu, ulTemp, ulRet;
    VERTEX_DATA vVertexData[4];
    VERTEX_DATA *pvVertexData;
    PDEVOBJ po(hdev);

    ulRet = DCR_SOLID;

    // We handle only 8x8 dithers.  If the driver has their value set to
    // something else, we have to bail.

    if ((po.cxDither() != 8) || (po.cyDither() != 8))
    {
        WARNING("EngDitherColor works only when driver sets its DEVINFO");
        WARNING("cxDither and cyDither values to 8");
    }
    else
    {
        // Figure out if we need a full color dither or only a monochrome dither.
    
        // Note: we should get color dithers only at 8bpp and 4bpp, because
        //       those are the only color depths at which drivers should
        //       set GCAPS_COLOR_DITHER.
    
        if (iMode != DM_MONOCHROME)
        {
            // We only handle 8bpp and 4bpp color dithers:
    
            if (po.iDitherFormat() == BMF_8BPP ||
                po.iDitherFormat() == BMF_4BPP)
            {
                // Full color dither
        
                // Calculate what color subspaces are involved in the dither
                pvVertexData = vComputeSubspaces(rgb, vVertexData);
        
                // Now that we have found the bounding vertices and the number of
                // pixels to dither for each vertex, we can create the dither pattern
        
                // Handle 1, 2, and 3 & 4 vertices per dither separately
                ulTemp = (ULONG) (pvVertexData - vVertexData);    
                                                        // # of vertices with more than
                                                        //  zero pixels in the dither
        
                if (po.iDitherFormat() == BMF_8BPP)
                {
                    vDitherColor8bpp(pul, vVertexData, pvVertexData, ulTemp);
                }
                else
                {
                    vDitherColor4bpp(pul, vVertexData, pvVertexData, ulTemp);
                }
        
                ulRet = DCR_DRIVER;
            }
            else
            {
                WARNING("EngDitherColor works for DM_DEFAULT only when at 8bpp or 4bpp");
            }
        }
        else
        {
            // Note: we can get monochrome dithers at any colour depth because
            //       we always set GCAPS_MONO_DITHER.
    
            // For monochrome we will only use the Intensity (grey level)
    
            RtlFillMemory((PVOID) pul, PATTERNSIZE/2, 0);  // zero the dither bits
    
            ulRed   = (ULONG) ((PALETTEENTRY *) &rgb)->peRed;
            ulGre = (ULONG) ((PALETTEENTRY *) &rgb)->peGreen;
            ulBlu  = (ULONG) ((PALETTEENTRY *) &rgb)->peBlue;
    
            // I = .30R + .59G + .11B
            // For convience the following ratios are used:
            //
            //  77/256 = 30.08%
            // 151/256 = 58.98%
            //  28/256 = 10.94%
    
            ulGrey  = (((ulRed * 77) + (ulGre * 151) + (ulBlu * 28)) >> 8) & 255;
    
            // Convert the RGBI from 0-255 to 0-64 notation.
    
            ulGrey = (ulGrey + 1) >> 2;
    
            while(ulGrey) {
                ulGrey--;
                pul[ajByte[ulGrey]] |= ((ULONG) ajBits[ulGrey]);
            }
    
            ulRet = DCR_DRIVER;
        }
    }

    return(ulRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\dibapi.cxx ===
/******************************Module*Header*******************************\
* Module Name: dibapi.cxx
*
* This contains all the functions relating to DIBs
*
* Created: 12-Mar-1991 13:53:29
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

BOOL bIdenticalFormat (XEPALOBJ, INT);

//
// This is to convert BMF constants into max # of palette entries
//

ULONG gacPalEntries[7] =
{
    0,
    2,
    16,
    256,
    0,
    0,
    0
};

extern PAL_ULONG aPalVGA[16];

//
// IS_BMI_JPEG
//
// Checks if the header pointed to by pv is a BITMAPINFO for a JPEG.
// Evaluates to TRUE if JPEG, FALSE otherwise.
//

#define IS_BMI_JPEG(pv) \
    ((pv) && \
     (((BITMAPINFO *)(pv))->bmiHeader.biSize >= sizeof(BITMAPINFOHEADER)) && \
     (((BITMAPINFO *)(pv))->bmiHeader.biCompression == BI_JPEG))

//
// IS_BMI_PNG
//
// Checks if the header pointed to by pv is a BITMAPINFO for a PNG.
// Evaluates to TRUE if PNG, FALSE otherwise.
//

#define IS_BMI_PNG(pv) \
    ((pv) && \
     (((BITMAPINFO *)(pv))->bmiHeader.biSize >= sizeof(BITMAPINFOHEADER)) && \
     (((BITMAPINFO *)(pv))->bmiHeader.biCompression == BI_PNG))

//
// IS_PASSTHROUGH_IMAGE
//
// Checks if the biCompression value is one of the passthrough formats that
// can be passed to devices (BI_JPEG or BI_PNG).
//

#define IS_PASSTHROUGH_IMAGE(biCompression) \
    (((biCompression) == BI_JPEG) || ((biCompression) == BI_PNG))

//
// IS_BMI_PASSTHROUGH_IMAGE
//
// Checks if the header pointed to by pv is a BITMAPINFO for a JPEG or PNG.
// Evaluates to TRUE if JPEG or PNG, FALSE otherwise.
//

#define IS_BMI_PASSTHROUGH_IMAGE(pv) \
    ((pv) && \
     (((BITMAPINFO *)(pv))->bmiHeader.biSize >= sizeof(BITMAPINFOHEADER)) && \
     IS_PASSTHROUGH_IMAGE(((BITMAPINFO *)(pv))->bmiHeader.biCompression))

//
// IS_CMYK_BITMAP
//
// Checks if the bitmap uses CMYK color data either in color table or bitmap
// itself.
//

#define IS_CMYK_BITMAP(biCompression)  \
    (((biCompression) == BI_CMYK) ||     \
     ((biCompression) == BI_CMYKRLE4) || \
     ((biCompression) == BI_CMYKRLE8))

/******************************Public*Routine******************************\
* vCopyCoreToInfoHeader
*
* Copy a BITMAPCOREINFOHEADER to BITMAPINFOHEADER
*
*  06-Mar-1995 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

VOID vCopyCoreToInfoHeader(LPBITMAPINFOHEADER pbmih, LPBITMAPCOREHEADER pbmch)
{
    pbmih->biSize = sizeof(BITMAPINFOHEADER);
    pbmih->biWidth = pbmch->bcWidth;
    pbmih->biHeight = pbmch->bcHeight;
    pbmih->biPlanes = pbmch->bcPlanes;
    pbmih->biBitCount = pbmch->bcBitCount;
    pbmih->biCompression = BI_RGB;
    pbmih->biSizeImage = 0;
    pbmih->biXPelsPerMeter = 0;
    pbmih->biYPelsPerMeter = 0;
    pbmih->biClrUsed = 0;
    pbmih->biClrImportant = 0;
}

/******************************Public*Routine******************************\
* vCopyCoreToInfoColorTable
*
* Copy a RGBTRIPLE color table to a RGBQUAD color table
*
*  06-Mar-1995 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

VOID vCopyCoreToInfoColorTable(RGBQUAD *pQuad, RGBTRIPLE *pTri, INT cEntries, INT iUsage)
{
   INT cj;

   cj = cEntries;

   if (iUsage != DIB_PAL_COLORS)
   {
       while (cj--)
       {
           pQuad->rgbRed = pTri->rgbtRed;
           pQuad->rgbGreen = pTri->rgbtGreen;
           pQuad->rgbBlue = pTri->rgbtBlue;
           pQuad->rgbReserved = 0;

           pQuad++;
           pTri++;
       }
   }
   else
   // DIB_PAL_COLORS
   {
        RtlCopyMemory((LPBYTE)pQuad,(LPBYTE)pTri,cEntries * sizeof(USHORT));
   }
}

/******************************Public*Routine******************************\
* GreCreateDIBitmapComp
*
* Only called by CreateDIBitmap from client - when CREATEDIB is not set
*
* History:
*
*  03-Mar-1995 -by- Lingyun Wang [lingyunw]
* Changed from GreCreateDIBitmapInternal.
\**************************************************************************/

HBITMAP
APIENTRY
GreCreateDIBitmapComp(
    HDC hdc,
    INT cx,
    INT cy,
    DWORD fInit,
    LPBYTE pInitBits,
    LPBITMAPINFO pInitInfo,
    DWORD iUsage,
    UINT cjMaxInitInfo,
    UINT cjMaxBits,
    FLONG fl,
    HANDLE hcmXform)
{
    DEVBITMAPINFO dbmi;

    //
    // It is old style call so do the compatible thing.
    // Let's validate some of the parameters
    //

    if ((iUsage != DIB_PAL_INDICES) &&
         (iUsage != DIB_PAL_COLORS)  &&
         (iUsage != DIB_RGB_COLORS))
    {
        WARNING1("GreCreateDIBitmapComp failed because of invalid parameters\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(0);
    }

    //
    // Cannot support the device passthrough formats (BI_JPEG, BI_PNG).
    //

    if (IS_BMI_PASSTHROUGH_IMAGE(pInitInfo))
    {
        WARNING1("GreCreateDIBitmapComp invalid pInitInfo (BITMAPINFOHEADER)\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(0);
    }

    dbmi.cxBitmap = cx;

    //
    // Check for the upside down bitmaps.
    //

    if (cy < 0)
    {
         dbmi.cyBitmap = -cy;
    }
    else
    {
         dbmi.cyBitmap = cy;
    }

    HBITMAP hbmReturn = GreCreateCompatibleBitmap(hdc, (int) dbmi.cxBitmap, (int) dbmi.cyBitmap);

    if (hbmReturn)
    {
        if ((fInit & CBM_INIT) &&
            (pInitBits != NULL) &&
            (pInitInfo != NULL))
        {
            if (GreSetDIBitsInternal(
                            hdc,
                            hbmReturn,
                            0,
                            (UINT) dbmi.cyBitmap,
                            pInitBits,
                            pInitInfo,
                            (UINT) iUsage,
                            cjMaxBits,
                            cjMaxInitInfo,
                            hcmXform
                            ))
            {
                return(hbmReturn);
            }
            else
            {
                WARNING1("CreateDIBitmapComp failed SetDIBits compat\n");
            }
        }
        else
        {
            return(hbmReturn);
        }

        GreDeleteObject(hbmReturn);
    }

    WARNING1("CreateDIBitmapComp failed CreateCompatBitmap\n");
    return(0);
}


/******************************Public*Routine******************************\
* GreCreateDIBitmapReal
*
* Called by CreateDIBitmap from client when CREATEDIB is set and
* CreateDIBSection
*
*   hdc             - handle of device context
*   pInfoHeader     - bitmap size and format
*   fInit           - initialization flag
*   pInitBits       - initialization data
*   pInitInfo       - initialization color info
*   iUsage          - color-data usage
*   cjMaxInitInfo   - size of bitmapinfo
*   cjMaxBits       - size of bitmap
*   hSection        - For DIBSECTION, Section or NULL
*   dwOffset        - For DIBSECTION
*   hSecure         - For DIBSECTION, VM Secure handle
*   fl              - creation flags
*   dwColorSpace    - identifier of client side color space data
*   ppvBits         - receives pointer to the bitmap bits
*
* History:
*
* 07-Apr-1995 -by- Mark Enstrom [marke]
*   add DIBSection support
* 03-Mar-1995 -by- Lingyun Wang [lingyunw]
*   Changed from GreCreateDIBitmapInternal.
*  04-Dec-1990 -by- Patrick Haluptzok patrickh
\**************************************************************************/

HBITMAP
APIENTRY
GreCreateDIBitmapReal(
    HDC hdc,
    DWORD fInit,
    LPBYTE pInitBits,
    LPBITMAPINFO pInitInfo,
    DWORD iUsage,
    UINT cjMaxInitInfo,
    UINT cjMaxBits,
    HANDLE hSection,
    DWORD  dwOffset,
    HANDLE hSecure,
    FLONG  fl,
    ULONG_PTR  dwColorSpace,
    PVOID *ppvBits)
{
    ULONG ulSize;
    DEVBITMAPINFO dbmi;

    //
    // It is a new DIB bitmap creation.  This code can essentially
    // be used as the base for CreateDIBSection when it is written.
    //
    // Let's validate some of the parameters.
    //

    if (((iUsage != DIB_PAL_COLORS) &&
         (iUsage != DIB_PAL_NONE) &&
         (iUsage != DIB_RGB_COLORS)) ||
        ((iUsage == DIB_PAL_NONE) && ((fl & CDBI_INTERNAL) == 0)) ||
        (pInitInfo == (LPBITMAPINFO) NULL) ||
        (cjMaxInitInfo < sizeof(BITMAPINFOHEADER)) ||   // Check first so we can access biSize.
        (cjMaxInitInfo < (ulSize = pInitInfo->bmiHeader.biSize)) ||
        (IS_BMI_PASSTHROUGH_IMAGE(pInitInfo)) ||
        (ulSize < sizeof(BITMAPINFOHEADER)))
    {
        WARNING1("GreCreateDIBitmapReal failed new DIB because of invalid parameters\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(0);
    }

    UINT uiCompression;
    dbmi.fl = 0;

    PULONG pulColors;
    ULONG ulClrUsed;

    cjMaxInitInfo -= ((UINT) ulSize);

    dbmi.cxBitmap = pInitInfo->bmiHeader.biWidth;

    if (pInitInfo->bmiHeader.biHeight < 0)
    {
        dbmi.cyBitmap = -(pInitInfo->bmiHeader.biHeight);
        dbmi.fl = BMF_TOPDOWN;
    }
    else
    {
        dbmi.cyBitmap = pInitInfo->bmiHeader.biHeight;
    }

    dbmi.iFormat = (UINT) pInitInfo->bmiHeader.biBitCount;
    uiCompression = (UINT) pInitInfo->bmiHeader.biCompression;
    ulClrUsed = (ULONG) pInitInfo->bmiHeader.biClrUsed;
    pulColors = (PULONG) ((LPBYTE)pInitInfo+ulSize);

    //
    // Figure out what this guy is asking for
    //

    ULONG cColors;
    FLONG iPalMode = PAL_INDEXED;
    FLONG iPalType;
    FLONG flRed;
    FLONG flGre;
    FLONG flBlu;

    if (uiCompression == BI_RGB)
    {
        switch (dbmi.iFormat)
        {
        case 1:
            dbmi.iFormat = BMF_1BPP;
            cColors = 2;
            iPalMode = PAL_INDEXED;
            iPalType = PAL_FREE;
            break;
        case 4:
            dbmi.iFormat = BMF_4BPP;
            cColors = 16;
            iPalMode = PAL_INDEXED;
            iPalType = PAL_FREE;
            break;
        case 8:
            dbmi.iFormat = BMF_8BPP;
            cColors = 256;
            iPalMode = PAL_INDEXED;
            iPalType = PAL_FREE;
            break;
        default:

            if (iUsage == DIB_PAL_COLORS)
            {
                iUsage = DIB_RGB_COLORS;
            }

            cColors = 0;
            iPalType = PAL_FIXED;

            switch (dbmi.iFormat)
            {
            case 16:
                dbmi.iFormat = BMF_16BPP;
                flRed = 0x7c00;
                flGre = 0x03e0;
                flBlu = 0x001f;
                iPalMode = PAL_BITFIELDS;
                break;
            case 24:
                dbmi.iFormat = BMF_24BPP;
                iPalMode = PAL_BGR;
                break;
            case 32:
                dbmi.iFormat = BMF_32BPP;
                iPalMode = PAL_BGR;
                break;
            default:
                WARNING1("CreateDIBitmapReal failed invalid bitcount in bmi for BI_RGB\n");
                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                return(0);
            }
        }
    }
    else if (uiCompression == BI_BITFIELDS)
    {
        if (
             (
               (ulSize <= sizeof(BITMAPINFOHEADER)) &&
               (cjMaxInitInfo < (sizeof(ULONG) * 3))
             ) ||
             (iUsage != DIB_RGB_COLORS)
           )
        {
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            WARNING1("CreateDIBitmapReal 16bpp failed - no room for flags\n");
            return((HBITMAP) 0);
        }

        //
        // if BITMAPV4 or greater then masks are stored in info header
        //

        if (ulSize >= sizeof(BITMAPINFOHEADER))
        {
            pulColors = (PULONG) ((LPBYTE)pInitInfo+sizeof(BITMAPINFOHEADER));
        }

        flRed = pulColors[0];
        flGre = pulColors[1];
        flBlu = pulColors[2];

        cColors = 0;
        iPalMode = PAL_BITFIELDS;
        iPalType = PAL_FIXED;

        switch (dbmi.iFormat)
        {
        case 16:
            dbmi.iFormat = BMF_16BPP;
            break;
        case 32:
            dbmi.iFormat = BMF_32BPP;
            break;
        default:
            WARNING1("CreateDIBitmap failed invalid bitcount in bmi in BI_BITFIELDS\n");
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            return(0);
        }
    }
    else if (uiCompression == BI_CMYK)
    {
        ASSERTGDI(iUsage == DIB_RGB_COLORS,
                  "CreateDIBitmap(BI_CMYK):iUsage should be DIB_RGB_COLORS\n");

        DCOBJ dco(hdc);

        //
        // Current device context accept CMYK color ?
        //
        if (!dco.bValid() || !dco.pdc->bIsCMYKColor())
        {
            WARNING1("CreateDIBitmapReal:DC is not in CMYK color mode for BI_CMYK\n");
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            return(0);
        }

        switch (dbmi.iFormat)
        {
        case 1:
            dbmi.iFormat = BMF_1BPP;
            cColors      = 2;
            iPalMode     = PAL_INDEXED;
            iPalType     = PAL_FREE;
            break;
        case 4:
            dbmi.iFormat = BMF_4BPP;
            cColors      = 16;
            iPalMode     = PAL_INDEXED;
            iPalType     = PAL_FREE;
            break;
        case 8:
            dbmi.iFormat = BMF_8BPP;
            cColors      = 256;
            iPalMode     = PAL_INDEXED;
            iPalType     = PAL_FREE;
            break;
        case 32:
            dbmi.iFormat = BMF_32BPP;
            cColors      = 0;
            iPalMode     = PAL_CMYK;
            iPalType     = PAL_FIXED;
            break;
        default:
            WARNING1("CreateDIBitmapReal failed invalid bitcount in bmi for BI_CMYK\n");
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            return(0);
        }
    }
    else
    {
        WARNING1("CreateDIBitmap failed - invalid Compression\n");

        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(0);
    }

    //
    // Allocate a palette for this bitmap.
    //

    PALMEMOBJ palPerm;

    if (!palPerm.bCreatePalette(iPalMode, cColors, (PULONG) NULL,
                                flRed, flGre, flBlu, iPalType))
    {
        WARNING1("Failed palette creation in GreCreateBitmap\n");
        return(0);
    }

    dbmi.hpal = (HPALETTE) palPerm.hpal();

    //
    // Attempt to allocate the bitmap from handle manager.
    //

    SURFMEM   SurfDimo;
    PBYTE     pDIB = (PBYTE) NULL;
    HANDLE    hDIB = NULL;


    if (fl & CDBI_DIBSECTION)
    {
        //
        // Let's mark the palette created as being a DIBSECTION palette
        // so when we attempt to map it to another palette we try to
        // make it identity before going through the closest match search.
        //

        palPerm.flPal(PAL_DIBSECTION);


        //
        // In  kernel mode, pInitBits contains the DIBSection address
        //

        pDIB = pInitBits;
        hDIB = hSection;

        if (pDIB == (PVOID)NULL)
        {
            return(0);
        }

        //
        // Clear pInitBits so we can fall through nicely later.
        //

        pInitBits = (LPBYTE) NULL;
    }
    else if (hdc)
    {
       DCOBJ dco(hdc);

       if (dco.bValid() && dco.bUMPD())
          dbmi.fl |= UMPD_SURFACE;
    }

    if (!SurfDimo.bCreateDIB(&dbmi, pDIB, hDIB, dwOffset, hSecure, dwColorSpace) ||
        (SurfDimo.ps->bDIBSection() && (SurfDimo.ps->cjBits() != cjMaxBits)))
    {
        WARNING("GreCreateDIBitmap failed bCreateDIB or size mismatch\n");
        return(0);
    }

    //
    // Initialize bits if provided.
    //

    if (pInitBits != (LPBYTE) NULL)
    {
        ASSERTGDI(fInit & CBM_INIT, "CreateDIBitmap bits sent but no CBM_INIT set");

        if (SurfDimo.ps->cjBits() > cjMaxBits)
        {
            WARNING1("CreateDIBitmap failed because invalid bitmap buffer size CBM_CREATEDIB\n");
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            return(0);
        }

        RtlCopyMemory(SurfDimo.ps->pvBits(), (PVOID) pInitBits, (UINT) SurfDimo.ps->cjBits());
    }

    //
    // Check if it is not equal to 0.  If it is not 0 use that as the number
    // of palette entries to initialize.  If it is 0 then cPalEntries has the
    // correct number already computed in it.
    //

    if (ulClrUsed != 0)
    {
        if (ulClrUsed < cColors)
        {
            cColors = ulClrUsed;
        }
    }

    //
    // Intitialize the palette
    //

    if (cColors)
    {
        ASSERTGDI(iUsage != DIB_PAL_INDICES, "ERROR logic error, should have returned FALSE");

        switch (iUsage)
        {
        case DIB_RGB_COLORS:
            if (cjMaxInitInfo < (cColors * 4))
            {
                WARNING1("CreateDIBitmap failed DIB_RGB_COLORS size buffer RGBQUAD\n");
                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                return(0);
            }

            //
            // Copy bitmap color table into palette
            //

            if (IS_CMYK_BITMAP(uiCompression))
            {
                palPerm.vCopy_cmykquad(pulColors, 0, cColors);
            }
            else
            {
                palPerm.vCopy_rgbquad((RGBQUAD *) pulColors, 0, cColors);
            }

            //
            // NOPALETTE is a private option for DirectDraw to permit the
            // DIBSection to share its colour table with the display.
            //

            if ((fl & CDBI_NOPALETTE) && (dbmi.iFormat == BMF_8BPP))
            {
                BOOL b;
                DCOBJ dco(hdc);

                b = FALSE;
                if (dco.bValid())
                {
                    PDEVOBJ po(dco.hdev());

                    //
                    // Acquire the devlock to protect us from a dynamic mode
                    // change while we muck with po.ppalSurf():
                    //

                    DEVLOCKOBJ dlo(po);

                    if ((po.iDitherFormat() == BMF_8BPP) &&
                        (po.bIsPalManaged()) &&
                        (po.bDisplayPDEV()))
                    {
                        b = TRUE;
                        palPerm.apalColorSet(po.ppalSurf());
                    }
                }

                if (!b)
                {
                    WARNING("Display not 8bpp, failing CreateDIBSection(CDBI_NOPALETTE)");
                    return(0);
                }
            }

            break;

        case DIB_PAL_COLORS:

        {
            PUSHORT pusIndices;

            if (cjMaxInitInfo < (cColors * sizeof(USHORT)))
            {
                WARNING1("CreateDIBitmap failed DIB_PAL_COLORS size buffer USHORT\n");
                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                return(0);
            }

            pusIndices = (PUSHORT) pulColors;

            //
            // Validate the DC.
            //

            DCOBJ dco(hdc);

            if (!dco.bValid())
            {
                WARNING1("CreateDIBitmap failed CBM_CREATEDIB because DIB_PAL_COLORS and invalid DC\n");
                return(0);
            }
            {
                //
                // Hold the Devlock while munging around in the
                // surface to protect against dynamic mode changing.
                //

                DEVLOCKOBJ dlo;

                dlo.vLockNoDrawing(dco);

                SURFACE *pSurf = dco.pSurfaceEff();
                PDEVOBJ  po(dco.hdev());
                XEPALOBJ palSurf(pSurf->ppal() ? pSurf->ppal() : po.ppalSurf());
                XEPALOBJ palDC(dco.ppal());
                palPerm.vGetEntriesFrom(palDC, palSurf, pusIndices, cColors);
            }
        }
            break;

        case DIB_PAL_NONE:

            //
            // This is so CreateDIBPatternBrush can call off to this to do the
            // work and then init the palette himself.
            //

            break;
        }
    }

    if (ppvBits)
    {
        *ppvBits = SurfDimo.ps->pvBits();
    }

    //
    // Make the palette a keeper and return.
    //

    SurfDimo.ps->vSetApiBitmap();
    SurfDimo.vKeepIt();
    palPerm.vKeepIt();
    return((HBITMAP)SurfDimo.ps->hsurf());
}


/******************************Public*Routine******************************\
* GreSetDIBitsInternal
*
*    API function - Sets the bits of a DIB to a bitmap.
*
* Arguments:
*
*   hdc         - handle of device context
*   hbmp        - handle of bitmap
*   iStartScan  - starting scan line
*   cNumScans   - number of scan lines
*   pInitBits   - array of bitmap bits
*   pInitInfo   - address of structure with bitmap data
*   iUsage      - type of color indices to use
*   cjMaxBits   - maximum size of pInitBits
*   cjMaxInfo   - maximum size of cjMaxInfo
*   hcmXform    - handle of color transformation (optional)
*
* History:
*
*  12-Mar-1991 -by- Patrick Haluptzok patrickh
\**************************************************************************/

int
APIENTRY
GreSetDIBits(
    HDC hdc,
    HBITMAP hbm,
    UINT iStartScans,
    UINT cNumScans,
    LPBYTE pInitBits,
    LPBITMAPINFO pInitInfo,
    UINT iUsage)
{
    PBITMAPINFO pbmi = pInitInfo;
    INT iRet;

    //
    // if it is a COREHEADER, covert it
    //
    if (pInitInfo && (pInitInfo->bmiHeader.biSize == sizeof(BITMAPCOREHEADER)))
    {
        pbmi = pbmiConvertInfo (pInitInfo, iUsage);
    }

    //
    // Cannot support the device passthrough formats (BI_JPEG, BI_PNG).
    //

    if (IS_BMI_PASSTHROUGH_IMAGE(pInitInfo))
    {
        WARNING1("GreSetDIBits invalid pInitBits\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(0);
    }

    iRet = GreSetDIBitsInternal(
                        hdc,
                        hbm,
                        iStartScans,
                        cNumScans,
                        pInitBits,
                        pbmi,
                        iUsage,
                        (UINT)~0,
                        (UINT)~0,
                        NULL);

   if (pbmi && (pbmi != pInitInfo))
   {
       VFREEMEM (pbmi);
   }

   return (iRet);
}

int
APIENTRY
GreSetDIBitsInternal(
    HDC hdc,
    HBITMAP hbm,
    UINT iStartScans,
    UINT cNumScans,
    LPBYTE pInitBits,
    LPBITMAPINFO pInitInfo,
    UINT iUsage,
    UINT cjMaxBits,
    UINT cjMaxInfo,
    HANDLE hcmXform)
{
    //
    // Lock down and validate the bitmap.  Make sure it's a bitmap.
    //

    HDC      hdcTemp;
    HPALETTE hpalTemp = (HPALETTE) 0;
    HBITMAP  hbmTemp;
    int      iReturn = 0;
    BOOL     bMakeDC = FALSE;
    ULONG    cx;
    ULONG    cy;

    //
    // Validate header and cannot support the device
    // passthrough formats (BI_JPEG, BI_PNG).
    //

    if ((pInitInfo == (LPBITMAPINFO) NULL) ||
        IS_BMI_PASSTHROUGH_IMAGE(pInitInfo))
    {
        WARNING1("GreSetDIBitsInternal failed - pInitInfo is invalid\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
    }
    else
    {
        ASSERTGDI (pInitInfo->bmiHeader.biSize >= sizeof(BITMAPINFOHEADER), "setdibitstodevice,bad size\n");

        cx = pInitInfo->bmiHeader.biWidth;
        if (pInitInfo->bmiHeader.biHeight < 0)
        {
            cy = -pInitInfo->bmiHeader.biHeight;
        }
        else
        {
            cy = pInitInfo->bmiHeader.biHeight;
        }

        SURFREF soDest((HSURF)hbm);

        if ((!soDest.bValid()) || (!soDest.ps->bApiBitmap()))
        {
            WARNING1("SetDIBits failed - Bitmap is not valid\n");
            SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        }
        else
        {
            if (soDest.ps->cRef() != 0)
            {
                hdcTemp = soDest.ps->hdc();
            }
            else
            {
                hdcTemp = (HDC) NULL;
            }

            if (hdcTemp == (HDC) NULL)
            {
                hdcTemp = GreCreateCompatibleDC(hdc);
                bMakeDC = TRUE;

                if (hdcTemp == (HDC) NULL)
                {
                    WARNING1("GreSetDIBits failed CreateCompatibleDC, is hdc valid?\n");
                }
            }

            if (hdcTemp != (HDC)NULL)
            {
                BOOL bSuccess = TRUE;

                if (hdc != (HDC) NULL)
                {
                    DCOBJ dco(hdc);

                    if (!dco.bValid())
                    {
                        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
                        WARNING1("SetDIBits failed - hdc is invalid\n");
                        bSuccess = FALSE;
                    }
                    else
                    {
                        hpalTemp = (HPALETTE) GreSelectPalette(hdcTemp, (HPALETTE)dco.hpal(), (BOOL)TRUE);
                    }
                }

                if (bSuccess)
                {

                    hbmTemp = (HBITMAP)GreSelectBitmap(hdcTemp, (HBITMAP)hbm);

                    if (hbmTemp == (HBITMAP) 0)
                    {
                        WARNING1("GreSetDIBits failed to Select, is bitmap valid?\n");
                    }
                    else
                    {

                        iReturn = GreSetDIBitsToDeviceInternal(
                                                    hdcTemp,
                                                    0,
                                                    0,
                                                    cx,
                                                    cy,
                                                    0,
                                                    0,
                                                    iStartScans,
                                                    cNumScans,
                                                    pInitBits,
                                                    pInitInfo,
                                                    iUsage,
                                                    cjMaxBits,
                                                    cjMaxInfo,
                                                    FALSE,
                                                    hcmXform
                                                    );

                        if (hpalTemp != (HPALETTE) 0)
                        {
                            GreSelectPalette(hdcTemp, hpalTemp, TRUE);
                        }

                        GreSelectBitmap(hdcTemp, (HBITMAP)hbmTemp);

                    }
                }

                if (bMakeDC)
                {
                    bDeleteDCInternal(hdcTemp,TRUE,FALSE);
                }
            }
        }
    }
    return(iReturn);
}

/******************************Public*Routine******************************\
* GreSetDIBitsToDevice
*
*   API entry point for blting DIBS to a DC.
*
* Arguments:
*
*   hdcDest               - handle of device context
*   xDst                  - x-coordinate of upper-left corner of dest. rect.
*   yDst                  - y-coordinate of upper-left corner of dest. rect.
*   cx                    - source rectangle width
*   cy                    - source rectangle height
*   xSrc                  - x-coordinate of lower-left corner of source rect.
*   ySrc                  - y-coordinate of lower-left corner of source rect.
*   iStartScan            - first scan line in array
*   cNumScan              - number of scan lines
*   pInitBits             - address of array with DIB bits
*   pInfoHeader           - address of structure with bitmap info.
*   iUsage                - RGB or palette indices
*   cjMaxBits             - maximum soace of pInitBits
*   cjMaxInfo             - maximum soace ofpInfoHeader
*   bTransformCoordinates - Transform necessary
*
* Return Value:
*
*   Number of scan lines set or 0 for error
*
* History:
*
*  12-Mar-1991 -by- Patrick Haluptzok patrickh
\**************************************************************************/

// I believe nobody should be calling this, but just in case... (erick)
// The internal version is called by server.c

int
APIENTRY
GreSetDIBitsToDevice(
    HDC hdcDest,
    int xDst,
    int yDst,
    DWORD cx,
    DWORD cy,
    int xSrc,
    int ySrc,
    DWORD iStartScan,
    DWORD cNumScan,
    LPBYTE pInitBits,
    LPBITMAPINFO pInfoHeader,
    DWORD iUsage)
{
    return(GreSetDIBitsToDeviceInternal(
                            hdcDest,
                            xDst,
                            yDst,
                            cx,
                            cy,
                            xSrc,
                            ySrc,
                            iStartScan,
                            cNumScan,
                            pInitBits,
                            pInfoHeader,
                            iUsage,
                            (UINT)~0,
                            (UINT)~0,
                            TRUE,
                            NULL));
}


int
APIENTRY
GreSetDIBitsToDeviceInternal(
    HDC hdcDest,
    int xDst,
    int yDst,
    DWORD cx,
    DWORD cy,
    int xSrc,
    int ySrc,
    DWORD iStartScan,
    DWORD cNumScan,
    LPBYTE pInitBits,
    LPBITMAPINFO pInfoHeader,
    DWORD iUsage,
    UINT cjMaxBits,
    UINT cjMaxInfo,
    BOOL bTransformCoordinates,
    HANDLE hcmXform)
{
    // If the dc is mirrored then make x point to the most left point.
    if (GreGetLayout(hdcDest) & LAYOUT_RTL) {
        xDst += (cx - 1);
    }

    //
    // Size of bitmap info header, copy out, it can change async.
    //

    ULONG ulSize;

    //
    // Let's validate the parameters so we don't gp-fault ourselves and
    // to save checks later on.
    //

    if ((pInfoHeader == (LPBITMAPINFO) NULL) ||
        (pInitBits == (LPBYTE) NULL)         ||
        ((iUsage != DIB_RGB_COLORS) &&
         (iUsage != DIB_PAL_COLORS) &&
         (iUsage != DIB_PAL_INDICES))        ||
         (cjMaxInfo < sizeof(BITMAPINFOHEADER)) ||
         ( pInfoHeader->bmiHeader.biSize < sizeof(BITMAPINFOHEADER)))
    {
        WARNING1("GreSetDIBitsToDevice failed because 1 of last 3 params is invalid\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(0);
    }

    ulSize = pInfoHeader->bmiHeader.biSize;

    //
    // Get the info from the Header depending upon what kind it is.
    //

    UINT uiBitCount, uiCompression, uiWidth, uiPalUsed;
    LONG lHeight;
    PULONG pulColors;
    DEVBITMAPINFO dbmi;
    dbmi.fl = 0;
    dbmi.hpal = 0;

    uiBitCount = (UINT) pInfoHeader->bmiHeader.biBitCount;
    uiCompression = (UINT) pInfoHeader->bmiHeader.biCompression;
    uiWidth = (UINT) pInfoHeader->bmiHeader.biWidth;
    lHeight = pInfoHeader->bmiHeader.biHeight;
    uiPalUsed = (UINT) pInfoHeader->bmiHeader.biClrUsed;
    pulColors = (PULONG) ((LPBYTE)pInfoHeader+ulSize);

    if (lHeight < 0)
    {
        dbmi.fl = BMF_TOPDOWN;

        if ((uiCompression != BI_RGB) && (uiCompression != BI_BITFIELDS) &&
            (uiCompression != BI_JPEG) && (uiCompression != BI_PNG) &&
            (uiCompression != BI_CMYK) && (uiCompression != BI_CMYKRLE4) &&
            (uiCompression != BI_CMYKRLE8))
        {
            WARNING1("GreSetDIBits: TOP_DOWN RLE not allowed\n");
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            return (0);
        }

        lHeight = -lHeight;
    }

    //
    // Now that cjMaxInfo has been validated for the header, adjust it to refer to
    // the color table
    //

    cjMaxInfo -= (UINT)ulSize;

    //
    // Figure out what this guy is blting from.
    //

    ULONG cColorsMax;
    FLONG iPalMode;
    FLONG iPalType;
    FLONG flRed;
    FLONG flGre;
    FLONG flBlu;

    BOOL  bRLE = FALSE;

    if (uiCompression == BI_BITFIELDS)
    {
        //
        // Handle 16 and 32 bit per pel bitmaps.
        //

        if ((ulSize <= sizeof(BITMAPINFOHEADER)) && (cjMaxInfo < (sizeof(ULONG) * 3)))
        {
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            WARNING1("SetDIBitsToDevice 16/32bpp failed - not room for flags\n");
            return(0);
        }

        if (iUsage == DIB_PAL_COLORS)
        {
            iUsage = DIB_RGB_COLORS;
        }

        switch (uiBitCount)
        {
        case 16:
            dbmi.iFormat = BMF_16BPP;
            break;
        case 32:
            dbmi.iFormat = BMF_32BPP;
            break;
        default:
            WARNING1("SetDIBitsToDevice failed for BI_BITFIELDS\n");
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            return(0);
        }

        //
        // if BITMAPV4 or greater then masks are stored in info header
        //

        if (ulSize > sizeof(BITMAPINFOHEADER))
        {
            pulColors = (PULONG) ((LPBYTE)pInfoHeader+sizeof(BITMAPINFOHEADER));
        }

        flRed = pulColors[0];
        flGre = pulColors[1];
        flBlu = pulColors[2];

        cColorsMax = 0;
        iPalMode = PAL_BITFIELDS;
        iPalType = PAL_FIXED;
        dbmi.cjBits = ((((uiBitCount * uiWidth) + 31) >> 5) << 2) * cNumScan;
    }
    else if (uiCompression == BI_RGB)
    {
        switch (uiBitCount)
        {
        case 1:
            dbmi.iFormat = BMF_1BPP;
            cColorsMax = 2;
            iPalMode = PAL_INDEXED;
            iPalType = PAL_FREE;
            break;
        case 4:
            dbmi.iFormat = BMF_4BPP;
            cColorsMax = 16;
            iPalMode = PAL_INDEXED;
            iPalType = PAL_FREE;
            break;
        case 8:
            dbmi.iFormat = BMF_8BPP;
            cColorsMax = 256;
            iPalMode = PAL_INDEXED;
            iPalType = PAL_FREE;
            break;
        default:

            if (iUsage == DIB_PAL_COLORS)
            {
                iUsage = DIB_RGB_COLORS;
            }

            cColorsMax = 0;
            iPalType = PAL_FIXED;

            switch (uiBitCount)
            {
            case 16:
                dbmi.iFormat = BMF_16BPP;
                flRed = 0x7c00;
                flGre = 0x03e0;
                flBlu = 0x001f;
                iPalMode = PAL_BITFIELDS;
                break;
            case 24:
                dbmi.iFormat = BMF_24BPP;
                iPalMode = PAL_BGR;
                break;
            case 32:
                dbmi.iFormat = BMF_32BPP;
                iPalMode = PAL_BGR;
                break;
            default:
                WARNING1("SetDIBitsToDevice failed invalid bitcount in bmi BI_RGB\n");
                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                return(0);
            }
        }

        dbmi.cjBits = ((((uiBitCount * uiWidth) + 31) >> 5) << 2) * cNumScan;
    }
    else if (uiCompression == BI_CMYK)
    {
        ASSERTGDI(iUsage == DIB_RGB_COLORS,
                  "SetDIBitsToDevice(BI_CMYK):iUsage should be DIB_RGB_COLORS\n");

        DCOBJ dcoDest(hdcDest);

        //
        // Current device context accept CMYK color ?
        //
        if (!dcoDest.bValid() || !dcoDest.pdc->bIsCMYKColor())
        {
            WARNING1("SetDIBitsToDevice:DC is not in CMYK color mode for BI_CMYK\n");
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            return(0);
        }

        switch (uiBitCount)
        {
        case 1:
            dbmi.iFormat = BMF_1BPP;
            cColorsMax   = 2;
            iPalMode     = PAL_INDEXED;
            iPalType     = PAL_FREE;
            break;
        case 4:
            dbmi.iFormat = BMF_4BPP;
            cColorsMax   = 16;
            iPalMode     = PAL_INDEXED;
            iPalType     = PAL_FREE;
            break;
        case 8:
            dbmi.iFormat = BMF_8BPP;
            cColorsMax   = 256;
            iPalMode     = PAL_INDEXED;
            iPalType     = PAL_FREE;
            break;
        case 32:
            dbmi.iFormat = BMF_32BPP;
            cColorsMax   = 0;
            iPalMode     = PAL_CMYK;
            iPalType     = PAL_FIXED;
            break;
        default:
            WARNING1("SetDIBitsToDevice failed invalid bitcount in bmi BI_CMYK\n");
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            return(0);
        }

        dbmi.cjBits = ((((uiBitCount * uiWidth) + 31) >> 5) << 2) * cNumScan;
    }
    else if ((uiCompression == BI_RLE4) || (uiCompression == BI_CMYKRLE4))
    {
        if (uiCompression == BI_CMYKRLE4)
        {
            ASSERTGDI(iUsage == DIB_RGB_COLORS,
                      "SetDIBitsToDevice(BI_CMYKRLE4):iUsage should be DIB_RGB_COLORS\n");

            DCOBJ dcoDest(hdcDest);

            //
            // Current device context accept CMYK color ?
            //
            if (!dcoDest.bValid() || !dcoDest.pdc->bIsCMYKColor())
            {
                WARNING1("SetDIBitsToDevice:DC is not in CMYK color mode for BI_CMYKRLE4\n");
                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                return(0);
            }
        }

        if (uiBitCount != 4)
        {
            WARNING1("SetDIBitsToDevice invalid bitcount BI_RLE4\n");
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            return(0);
        }

        dbmi.iFormat    = BMF_4RLE;
        cColorsMax      = 16;
        iPalMode        = PAL_INDEXED;
        iPalType        = PAL_FREE;
        iStartScan      = 0;
        cNumScan        = lHeight;
        dbmi.cjBits     = pInfoHeader->bmiHeader.biSizeImage;
        bRLE            = TRUE;
    }
    else if ((uiCompression == BI_RLE8) || (uiCompression == BI_CMYKRLE8))
    {
        if (uiCompression == BI_CMYKRLE8)
        {
            ASSERTGDI(iUsage == DIB_RGB_COLORS,
                      "SetDIBitsToDevice(BI_CMYKRLE8):iUsage should be DIB_RGB_COLORS\n");

            DCOBJ dcoDest(hdcDest);

            //
            // Current dc context accept CMYK color ?
            //
            if (!dcoDest.bValid() || !dcoDest.pdc->bIsCMYKColor())
            {
                WARNING1("SetDIBitsToDevice:DC is not in CMYK color mode for BI_CMYKRLE8\n");
                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                return(0);
            }
        }

        if (uiBitCount != 8)
        {
            WARNING1("SetDIBitsToDevice invalid bitcount BI_RLE8\n");
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            return(0);
        }

        dbmi.iFormat    = BMF_8RLE;
        cColorsMax      = 256;
        iPalMode        = PAL_INDEXED;
        iPalType        = PAL_FREE;
        iStartScan      = 0;
        cNumScan        = lHeight;
        dbmi.cjBits     = pInfoHeader->bmiHeader.biSizeImage;
        bRLE            = TRUE;
    }
    else if (uiCompression == BI_JPEG)
    {
        //
        // The XLATEOBJ we setup for BI_JPEG is only valid for
        // querying the ICM flags in the flXlate member.
        //

        dbmi.iFormat    = BMF_JPEG;
        cColorsMax      = 0;
        iPalMode        = PAL_BGR;
        iPalType        = PAL_FIXED;
        iStartScan      = 0;
        //cNumScan        = lHeight;
        dbmi.cjBits     = pInfoHeader->bmiHeader.biSizeImage;
    }
    else if (uiCompression == BI_PNG)
    {
        //
        // The XLATEOBJ we setup for BI_PNG is only valid for
        // querying the ICM flags in the flXlate member.
        //

        dbmi.iFormat    = BMF_PNG;
        cColorsMax      = 0;
        iPalMode        = PAL_BGR;
        iPalType        = PAL_FIXED;
        iStartScan      = 0;
        //cNumScan        = lHeight;
        dbmi.cjBits     = pInfoHeader->bmiHeader.biSizeImage;
    }
    else
    {
        WARNING1("GreSetDIBitsToDevice failed invalid Compression in header\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(0);
    }

    ULONG cColors;

    if (uiPalUsed != 0)
    {
        if (uiPalUsed <= cColorsMax)
        {
            cColors = uiPalUsed;
        }
        else
        {
            cColors = cColorsMax;
        }
    }
    else
    {
        cColors = cColorsMax;
    }

    if (cjMaxBits < dbmi.cjBits)
    {
        WARNING1("GreSetDIBitsToDevice failed because of invalid cjMaxBits\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(0);
    }

    dbmi.cxBitmap   = uiWidth;
    dbmi.cyBitmap   = (IS_PASSTHROUGH_IMAGE(uiCompression)) ? lHeight
                                                            : cNumScan;

    //
    // Lock the destination DC.
    //
    // This is our first constructor/destructor so from here on out
    // we need to minimize the number of returns.  Each return generates
    // a bunch of destructors, bloating the code size.
    //

    DCOBJ dcoDest(hdcDest);

    if (dcoDest.bValid())
    {
        PDEVOBJ po(dcoDest.hdev());

        EPOINTL eptlDst(xDst,yDst);

        //
        // Check for state incompatible with BI_JPEG or BI_PNG support.
        //

        if (IS_PASSTHROUGH_IMAGE(pInfoHeader->bmiHeader.biCompression))
        {
            //
            // Device must support image format
            // No rotations allowed (checked below)
            // DIB_RGB_COLORS only
            // No hcmXform
            //

            if (!dcoDest.bSupportsPassthroughImage(pInfoHeader->bmiHeader.biCompression) ||
                (iUsage != DIB_RGB_COLORS) || hcmXform)
            {
                //
                // Return 0 for error.
                //

                WARNING("SetDIBitsToDevice -- invalid BI_JPEG/BI_PNG operation\n");
                cNumScan = 0;
            }
        }

        if (bTransformCoordinates)
        {
            EXFORMOBJ xoDest(dcoDest, WORLD_TO_DEVICE);

            //
            // Transform the dest point to DEVICE coordinates.
            //

            xoDest.bXform(eptlDst);

            //
            // Check for state incompatible with BI_JPEG or BI_PNG support.
            //

            if (cNumScan &&
                IS_PASSTHROUGH_IMAGE(pInfoHeader->bmiHeader.biCompression))
            {
                //
                // No rotations allowed
                //

                if (xoDest.bRotation())
                {
                    //
                    // Return 0 for error.
                    //

                    WARNING("SetDIBitsToDevice -- invalid BI_JPEG/BI_PNG operation\n");
                    cNumScan = 0;
                }
            }
        }

        //
        // Make the rectangle well ordered.
        //

        ERECTL erclDest(eptlDst.x, eptlDst.y, eptlDst.x + cx, eptlDst.y + cy);
        erclDest.vOrder();

        if (!erclDest.bEmpty() && cNumScan)
        {
            //
            // Accumulate bounds.  We can do this before knowing if the operation is
            // successful because bounds can be loose.
            //

            if (dcoDest.fjAccum())
            {
                dcoDest.vAccumulate(erclDest);
            }

            //
            // Lock the Rao region if we are drawing on a display surface.  The Rao
            // region might otherwise change asynchronously.  The DEVLOCKOBJ also makes
            // sure that the VisRgn is up to date, calling the window manager if
            // necessary to recompute it.  It also protects us from having the
            // surface change asynchronously by a dynamic mode change.
            //

            DEVLOCKOBJ dlo(dcoDest);

            SURFACE *pSurfDest = dcoDest.pSurface();

            //
            // Return null operations.
            //

            if (pSurfDest != NULL)
            {
                //
                // if color transform is not specified, use DC's color transform.
                //
                if (hcmXform == NULL)
                {
                    hcmXform = dcoDest.pdc->hcmXform();
                }
                else
                {
                    ICMMSG(("GreSetDIBitsToDeviceInternal():Bitmap has thier own colorspace\n"));
                }

                ULONG lIcmMode = dcoDest.pdc->lIcmMode();

                if (IS_CMYK_COLOR(lIcmMode))   /* DC is CMYK color mode ? */
                {
                    if ((hcmXform == NULL) || !IS_CMYK_BITMAP(uiCompression))
                    {
                        //
                        // DC mode is CMYK color, but bitmap itself is not.
                        // so clear CMYK color bit, so that XLATEOBJ will not
                        // have XO_FROM_CMYK
                        //
                        CLEAR_COLORTYPE(lIcmMode);
                        //
                        // then it's RGB.
                        //
                        lIcmMode |= DC_ICM_RGB_COLOR;
                    }
                }

                //
                // Allocate a palette for this bitmap
                //

                PALMEMOBJ palTemp;
                XEPALOBJ  palDest(pSurfDest->ppal());
                XEPALOBJ  palDestDC(dcoDest.ppal());

                //
                // Associate the DC's palette with the bitmap for use when
                // converting DDBs to DIBs for dynamic mode changes.
                //

                if (!palDestDC.bIsPalDefault())
                {
                    pSurfDest->hpalHint(palDestDC.hpal());
                }

                //
                // bSuccess gets set to FALSE only if the following switch
                // executes with error.  We do this to avoid doing a
                // return from the switch statement.
                //

                BOOL bSuccess = TRUE;
                BOOL bNeedAssociatePalette = FALSE;
                XLATEOBJ  *pxlo;
                EXLATEOBJ  xlo;

                switch (iUsage)
                {
                case DIB_RGB_COLORS:

                    if (palTemp.bCreatePalette(iPalMode, cColorsMax, (PULONG) NULL,
                                                flRed, flGre, flBlu, iPalType))
                    {
                        if (cColors)
                        {
                            if (cjMaxInfo < (cColors * 4))
                            {
                                WARNING1("SetDIBitsToDevice failed DIB_RGB_COLORS bmi invalid size\n");
                                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                                bSuccess = FALSE;
                            }
                            else
                            {
                                //
                                // Copy bitmap color table into palette
                                //

                                if (IS_CMYK_BITMAP(uiCompression))
                                {
                                    palTemp.vCopy_cmykquad(pulColors, 0, cColors);
                                }
                                else
                                {
                                    palTemp.vCopy_rgbquad((RGBQUAD *) pulColors, 0, cColors);
                                }
                            }

                            if (bSuccess)
                            {

                                //
                                // This is a special version of the constructor that doesn't search the
                                // cache and doesn't put it in the cache when it's done.
                                //

                                if (xlo.pInitXlateNoCache(
                                                          hcmXform,
                                                          lIcmMode,
                                                          palTemp,
                                                          palDest,
                                                          palDestDC,
                                                          0,
                                                          0,
                                                          0x00FFFFFF
                                                         )
                                                     )
                                {
                                    pxlo = xlo.pxlo();
                                }
                                else
                                {
                                    //
                                    // Error is logged by bMakeXlate.
                                    //

                                    WARNING1("GreSetDIBitsToDevice failed XLATE init because of low memory\n");
                                    bSuccess = FALSE;
                                }
                            }
                        }
                        else
                        {
                            //
                            // This is a special version of the constructor that doesn't search the
                            // cache and doesn't put it in the cache when it's done.
                            //

                            if (bSuccess)
                            {
                                if (xlo.pInitXlateNoCache(
                                                          hcmXform,
                                                          lIcmMode,
                                                          palTemp,
                                                          palDest,
                                                          palDestDC,
                                                          0,
                                                          0,
                                                          0x00FFFFFF
                                                         )
                                                     )
                                {
                                    pxlo = xlo.pxlo();
                                }
                                else
                                {
                                    //
                                    // Error is logged by bMakeXlate.
                                    //

                                    WARNING1("GreSetDIBitsToDevice failed XLATE init because of low memory\n");
                                    bSuccess = FALSE;
                                }
                            }
                        }
                    }
                    else
                    {
                        WARNING1("Failed palette creation in SetDIBitsToDevice\n");
                        bSuccess = FALSE;
                    }

                    break;

                case DIB_PAL_COLORS:

                    if (cjMaxInfo < (cColors * sizeof(USHORT)))
                    {
                        WARNING1("SetDIBitsToDevice failed DIB_PAL_COLORS is invalid\n");
                        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                        bSuccess = FALSE;
                    }
                    else
                    {
                        if (!xlo.bMakeXlate((PUSHORT) pulColors, palDestDC, pSurfDest, cColors, cColorsMax))
                        {
                            WARNING1("GDISRV GreSetDIBitsToDevice failed bMakeXlate\n");
                            bSuccess = FALSE;
                        }
                        else
                        {
                            pxlo = xlo.pxlo();

                            //
                            // If we are drawing to display meta-screen with multi-monitor system
                            // and it's colour-depth is not same for all those monitor.
                            // we need to create palette to map color to other-than primary
                            // monitor(s).
                            //

                            if (gbMultiMonMismatchColor && po.bDisplayPDEV())
                            {
                                if (palTemp.bCreatePalette(iPalMode, cColorsMax, (PULONG) NULL,
                                                           flRed, flGre, flBlu, iPalType))
                                {
                                    XEPALOBJ palSurfEff(pSurfDest->ppal() ? pSurfDest->ppal() : po.ppalSurf());

                                    //
                                    // Keep DC (or Surface) palette entry to temporay palette.
                                    //

                                    palTemp.vGetEntriesFrom(palDestDC, palSurfEff, (PUSHORT)pulColors, cColors);
                                    bNeedAssociatePalette = TRUE;
                                }
                            }
                        }
                    }

                    break;

                case DIB_PAL_INDICES:

                    ULONG iFormatDC = pSurfDest->iFormat();

                    if ((iFormatDC == dbmi.iFormat) ||
                        ((iFormatDC == BMF_4BPP) && (dbmi.iFormat == BMF_4RLE)) ||
                        ((iFormatDC == BMF_8BPP) && (dbmi.iFormat == BMF_8RLE)))
                    {
                        pxlo = &xloIdent;
                    }
                    else
                    {
                        WARNING1("SetDIBitsToDevice failed - DIB_PAL_INDICES used - DIB not format of Dst\n");
                        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                        bSuccess = FALSE;
                    }
                }

                //
                // Attempt to allocate the bitmap from handle manager.
                //

                SURFMEM SurfDimoTemp;
                SurfDimoTemp.bCreateDIB(&dbmi, (PVOID) pInitBits);

                if (bSuccess && (SurfDimoTemp.bValid()))
                {
                    //
                    // Bug #69739
                    //
                    // Set uniqueness to zero so that it will not be cached by
                    // a driver (NetMeeting for example) down below.
                    //

                    SurfDimoTemp.ps->iUniq(0);

                    if (dlo.bValid())
                    {
                        //
                        // With a fixed DC origin we can change the destination to SCREEN coordinates.
                        //

                        erclDest += dcoDest.eptlOrigin();

                        if (bNeedAssociatePalette)
                        {
                            ASSERTGDI(SurfDimoTemp.ps->ppal() == NULL,
                                      "SetDIBitsToDevice():Surface has palette already\n");

                            SurfDimoTemp.ps->ppal(palTemp.ppalGet());
                        }

                        //
                        // Lock the dest ldev.
                        //

                        PDEVOBJ pdo(pSurfDest->hdev());

                        //
                        // Handle RLE bitmaps here.  We don't need to adjust src origin or dst rect
                        // since we must enumerate through the entire RLE.
                        //

                        if (bRLE)
                        {
                            //
                            // Compute the clipping complexity and maybe reduce the exclusion rectangle.
                            //

                            EPOINTL eptlSrc;

                            eptlSrc.x = xSrc;
                            eptlSrc.y = lHeight - ySrc - cy;

                            ECLIPOBJ co(dcoDest.prgnEffRao(), erclDest);

                            //
                            // Check the destination which is reduced by clipping.
                            //

                            if (!co.erclExclude().bEmpty())
                            {
                                //
                                // Exclude the pointer.
                                //

                                DEVEXCLUDEOBJ dxo(dcoDest,&co.erclExclude(),&co);

                                //
                                // Inc the target surface uniqueness
                                //

                                INC_SURF_UNIQ(pSurfDest);

                                //
                                // Dispatch the call.  Give it no mask.
                                //

                                (*PPFNGET(pdo,CopyBits,pSurfDest->flags()))
                                (
                                    pSurfDest->pSurfobj(),      // Destination surface.
                                    SurfDimoTemp.pSurfobj(),    // Source surface.
                                    (CLIPOBJ *)&co,             // Clip object.
                                    pxlo,                       // Palette translation object.
                                    (RECTL *) &erclDest,        // Destination rectangle.
                                    (POINTL *)  &eptlSrc        // Source origin.
                                );
                            }
                        }
                        else
                        {
                            //
                            // Handle BitBlts that have a source.  Create a rect bounding the
                            // src and the bits that have been supplied.
                            //

                            EPOINTL eptlSrc;
                            ERECTL erclReduced;

                            eptlSrc.x = xSrc;
                            erclReduced.left   = 0;
                            erclReduced.right   = uiWidth;

                            eptlSrc.y = lHeight - ySrc - cy;

                            //
                            // When we are here lHeight is positive. The destination dimensions are 
                            // determined from the height, iStartScan, and cNumScan.
                            //

                            erclReduced.top     = lHeight - (iStartScan + cNumScan);
                            erclReduced.bottom  = lHeight - iStartScan;

                            EPOINTL eptlOffset;
                            eptlOffset.x = erclDest.left - eptlSrc.x;
                            eptlOffset.y = erclDest.top - eptlSrc.y;

                            //
                            // First make sure it doesn't go off the edge of the src bitmap if we had
                            // the whole thing.
                            //

                            erclReduced += eptlOffset;
                            erclReduced *= erclDest;

                            if (!erclReduced.bEmpty())
                            {
                                //
                                // Compute the clipping complexity and maybe reduce the exclusion rectangle.
                                //

                                ECLIPOBJ co(dcoDest.prgnEffRao(), erclReduced);

                                //
                                // Check the destination which is reduced by clipping.
                                //

                                if (!co.erclExclude().bEmpty())
                                {
                                    erclReduced = co.erclExclude();

                                    //
                                    // Compute the (reduced) origin.
                                    //

                                    eptlSrc.x = erclReduced.left - eptlOffset.x;
                                    eptlSrc.y = erclReduced.top - eptlOffset.y;

                                    //
                                    // Transform the source point to DEVICE coordinates of the bitmap we
                                    // have allocated.
                                    //

                                    eptlSrc.y -= lHeight - (iStartScan + cNumScan);

                                    //
                                    // Exclude the pointer.
                                    //

                                    DEVEXCLUDEOBJ dxo(dcoDest,&erclReduced,&co);

                                    //
                                    // Inc the target surface uniqueness
                                    //

                                    INC_SURF_UNIQ(pSurfDest);

                                    BOOL bRes = (*PPFNGET(pdo,CopyBits,pSurfDest->flags()))
                                           (pSurfDest->pSurfobj(),      // Destination surface.
                                            SurfDimoTemp.pSurfobj(),        // Source surface.
                                            (CLIPOBJ *)&co,             // Clip object.
                                            pxlo,                       // Palette translation object.
                                            (RECTL *) &erclReduced,     // Destination rectangle.
                                            (POINTL *)  &eptlSrc        // Source origin.
                                        );

                                    if (!bRes)
                                    {
                                        WARNING1("GreSetDIBitsToDevice failed DrvCopyBits\n");
                                        cNumScan = 0;
                                    }
                                }
                            }
                        }

                        if (bNeedAssociatePalette)
                        {
                            SurfDimoTemp.ps->ppal(NULL);
                        }
                    }
                }
                else // if (bSuccess && (SurfDimoTemp.bValid()))
                {
                    #if DBG
                    if (bSuccess)
                    {
                        WARNING1("Some silly switch failure in SetDIBitsToDevice\n");
                    }
                    else
                    {
                        WARNING1("GreSetDIBitsToDevice failed to allocate temporary bitmap\n");
                    }
                    #endif
                    cNumScan = 0;
                }
            }
            else // if (pSurfDest != NULL)
            {
                WARNING1("SetDIBitsToDevice failed - pSurfDst == NULL\n");
            }
        }
        else // if (!erclDest.bEmpty())
        {
            WARNING1("SetDIBitsToDevice failed - empty dst rect\n");
        }

    }
    else // if (!dcoDest.bValid())
    {
        WARNING1("GreSetDIBitsToDevice failed because of invalid hdc parameter\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        cNumScan = 0;
    }

    return(cNumScan);
}

/******************************Public*Routine******************************\
* BOOL bIdenticalFormat
*
*   checks if the Source surface pal format is the same as the DIB pal format
*   when DIB format is BI_RGB
*
* History:
*  3-Nov-1995 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
BOOL bIdenticalFormat (XEPALOBJ palSrc, INT iFormat)
{
    FLONG flRedSrc, flGreSrc, flBluSrc;
    FLONG flRedDst, flGreDst, flBluDst;
    BOOL bRet = TRUE;

    if (palSrc.bIsBitfields())
    {
        flRedSrc = palSrc.flRed();
        flGreSrc = palSrc.flGre();
        flBluSrc = palSrc.flBlu();
    }
    else
    //
    // RGB, BGR
    //
    {
        ASSERTGDI (iFormat == BMF_32BPP, "bIdenticalFormat-16bpp non bitfield surf?\n");

        flGreSrc = 0x0000FF00;

        if (palSrc.bIsRGB())
        {
            flRedSrc = 0x000000FF;
            flBluSrc = 0x00FF0000;
        }
        else
        {
            ASSERTGDI(palSrc.bIsBGR(), "What is it then?");
            flRedSrc = 0x00FF0000;
            flBluSrc = 0x000000FF;
        }
     }


     if (iFormat == BMF_16BPP)
     {
         flRedDst = 0x7c00;
         flGreDst = 0x03e0;
         flBluDst = 0x001f;
     }
     //
     // BMF_32BPP
     //
     else
     {
         flRedDst = 0x00FF0000;
         flGreDst = 0x0000FF00;
         flBluDst = 0x000000FF;
     }

     if ((flRedSrc != flRedDst) ||
         (flGreSrc != flGreDst) ||
         (flBluSrc != flBluDst))
     {
         bRet = FALSE;
     }

    return (bRet);
}


/******************************Public*Routine******************************\
* GreGetDIBits
*
*   API entry point geting the DIB bits out of a bitmap.
*
*   If they ask for the bits in the same format as they are stored
*   internally we give them the exact same palette entries and bits.
*   If they ask for a format NBPP different than they are internally
*   stored we :
*
*   for 1BPP give them black,white and blt to it.
*   for 4BPP give them VGA colors and blt to it.
*   for 8BPP give them a good spread of colors and blt to it.
*   for 16BPP give them 5-5-5
*   for 24BPP give them RGB.
*   for 32BPP give them RGB.
*
* Arguments:
*
*   hdc           - handle of device context
*   hBitmap       - handle of bitmap
*   iStartScan    - first scan line to set in destination bitmap
*   cNumScan      - number of scan lines to copy
*   pjBits        - address of array for bitmap bits
*   pBitsInfo     - address of structure with bitmap data
*   iUsage        - RGB or palette index
*   cjMaxBits     - Maximum for pjBits
*   cjMaxInfo     - Maximum for pBitsInfo
*
* Returns:
*
*   Number of scan lines copied, 0 for failure
*
*
* History:
*  12-Mar-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

int
APIENTRY
GreGetDIBitsInternal(
    HDC          hdc,
    HBITMAP      hBitmap,
    UINT         iStartScan,
    UINT         cNumScan,
    LPBYTE       pjBits,
    LPBITMAPINFO pBitsInfo,
    UINT         iUsage,
    UINT         cjMaxBits,
    UINT         cjMaxInfo)
{
    //
    // Let's make sure we are given valid input.
    //

    if (pBitsInfo == (LPBITMAPINFO) NULL)
    {
        WARNING1("GreGetDIBits failed with NULL BITMAPINFO parameter\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(0);
    }

    switch(iUsage)
    {
    case DIB_PAL_INDICES:
    case DIB_PAL_COLORS:
    case DIB_RGB_COLORS:
        break;
    default:

        WARNING1("GreGetDIBits failed with invalid DIB_ iUsage type\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(0);
    }

    //
    // check to make sure that at least the minimum sized header will fit
    //

    if (cjMaxInfo < sizeof(BITMAPCOREHEADER))
    {
        WARNING1("GreGetDIBits failed cjMaxInfo\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(0);
    }

    //
    // Because of CS we must set pjBits to NULL if it should be NULL
    // This is indicated by cNumScan being 0.
    //

    if (cNumScan == 0)
    {
        pjBits = (PBYTE) NULL;
    }

    //
    // Validate the bitmap.
    //

    SURFREF SurfBM((HSURF)hBitmap);

    if (!SurfBM.bValid())
    {
        WARNING1("GreGetDIBits failed to lock down the bitmap\n");
        return(0);
    }

    ULONG ulSize = pBitsInfo->bmiHeader.biSize;

    //
    // First check if they just want us to fill in the bmiinfo, no color
    // table, no bits.  This is indicated by NULL bits and 0 for bitcount.
    //

    if (pjBits == (PBYTE) NULL)
    {
        if (ulSize == sizeof(BITMAPCOREHEADER))
        {
            //
            // If bitcount is 0 they want to know what we have.
            //

            if (((LPBITMAPCOREINFO) pBitsInfo)->bmciHeader.bcBitCount == 0)
            {
                ((LPBITMAPCOREINFO) pBitsInfo)->bmciHeader.bcWidth = (USHORT) SurfBM.ps->sizl().cx;

                ((LPBITMAPCOREINFO) pBitsInfo)->bmciHeader.bcHeight = (USHORT) SurfBM.ps->sizl().cy;
                ((LPBITMAPCOREINFO) pBitsInfo)->bmciHeader.bcPlanes = 1;
                ((LPBITMAPCOREINFO) pBitsInfo)->bmciHeader.bcBitCount = (USHORT) gaulConvert[SurfBM.ps->iFormat()];

                //
                // the core header does not support 16/32 bpp bitmaps
                //

                if (((LPBITMAPCOREINFO) pBitsInfo)->bmciHeader.bcBitCount >= 16)
                {
                    ((LPBITMAPCOREINFO) pBitsInfo)->bmciHeader.bcBitCount = 24;
                }

                return(TRUE);
            }
        }
        else
        {
            if (cjMaxInfo < sizeof(BITMAPINFOHEADER))
                return(0);

            //
            // If bitcount is 0 they want to know what we have.
            //

            if (pBitsInfo->bmiHeader.biBitCount == 0)
            {
                //
                // zero out extra fields that are not going to be filled up later
                //
                if (ulSize > sizeof(BITMAPINFOHEADER))
                    RtlZeroMemory((PVOID)pBitsInfo, ulSize);

                pBitsInfo->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
                pBitsInfo->bmiHeader.biWidth = SurfBM.ps->sizl().cx;
                pBitsInfo->bmiHeader.biHeight = SurfBM.ps->sizl().cy;

                pBitsInfo->bmiHeader.biPlanes = 1;
                pBitsInfo->bmiHeader.biCompression = BI_RGB;
                pBitsInfo->bmiHeader.biBitCount = (USHORT) gaulConvert[SurfBM.ps->iFormat()];

                //
                // If it is a 16 bpp or 32 bpp bitmap, set the compression field
                //

                if ((pBitsInfo->bmiHeader.biBitCount == 16) ||
                    (pBitsInfo->bmiHeader.biBitCount == 32))
                {
                    pBitsInfo->bmiHeader.biCompression = BI_BITFIELDS;
                }

                pBitsInfo->bmiHeader.biSizeImage = pBitsInfo->bmiHeader.biHeight *
                ((((pBitsInfo->bmiHeader.biBitCount * pBitsInfo->bmiHeader.biWidth)
                                 + 31) >> 5) << 2);
                pBitsInfo->bmiHeader.biXPelsPerMeter = 0;
                pBitsInfo->bmiHeader.biYPelsPerMeter = 0;
                pBitsInfo->bmiHeader.biClrUsed =
                pBitsInfo->bmiHeader.biClrImportant = gacPalEntries[SurfBM.ps->iFormat()];
                
                //
                // top down -vs- bottom up
                // We need to put this at the end because we use the positive
                // height to compute the size (above).
                //
                // On Win95/98, negative height is returned if it's top-down 
                // DIBSECTION. #196691 [lingyunw]
                //
                // We should flip the height here, but too much stuff already
                // depends on the bad NT4 compatible behaviour of this code.
                // Win9x has fixed this, so we should return and fix this in
                // a later release.
                //
                //if ((SurfBM.ps->bDIBSection()||SurfBM.ps->bDirectDraw()) && 
                //    (SurfBM.ps->fjBitmap() & BMF_TOPDOWN))
                //{
                //    pBitsInfo->bmiHeader.biHeight = -pBitsInfo->bmiHeader.biHeight;
                //}
                //
                              
                return(TRUE);
            }
        }
    }

    //
    // Ok they want us to pay attention to what is in the bmBitmapInfo.
    //

    //
    // Cannot support the device passthrough formats (BI_JPEG, BI_PNG).
    //

    if (IS_BMI_PASSTHROUGH_IMAGE(pBitsInfo))
    {
        WARNING1("GreGetDIBits failed -- invalid pBitsInfo (BITMAPINFOHEADER)\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(0);
    }

    DCOBJ dco(hdc);

    if (!dco.bValid())
    {
        WARNING1("GreGetDIBits failed because invalid hdc\n");
        return(0);
    }

    PDEVOBJ po(dco.hdev());
    ASSERTGDI(po.bValid(), "ERROR po is invalid");

    XEPALOBJ palDC(dco.ppal());
    ASSERTGDI(palDC.bValid(), "ERROR palDC is invalid");

    //
    // Acquire the devlock here to protect against dynamic mode changes
    // that affect the device palette.  This also protects us if the
    // bitmap is a Device Format Bitmap that is owned by the display
    // driver.
    //

    DEVLOCKOBJ dlo(po);

    PPALETTE ppalSrc;

    if (!bIsCompatible(&ppalSrc, SurfBM.ps->ppal(), SurfBM.ps, dco.hdev()))
    {
        WARNING1("GreGetDIBits failed - bitmap not compatible with surface\n");
        return(0);
    }

    XEPALOBJ      palBM(ppalSrc);
    PUSHORT       pusIndices;
    BOOL          bCoreInfo;
    DEVBITMAPINFO dbmi;

    dbmi.fl = 0;

    UINT uiWidth, uiHeight, uiBitCount, uiSizeScan, uiCompression;

    if (ulSize == sizeof(BITMAPCOREHEADER))
    {
        bCoreInfo = TRUE;
        pusIndices = (PUSHORT) ((LPBITMAPCOREINFO) pBitsInfo)->bmciColors;
        uiWidth = (UINT) ((LPBITMAPCOREINFO) pBitsInfo)->bmciHeader.bcWidth;
        uiHeight = (UINT) ((LPBITMAPCOREINFO) pBitsInfo)->bmciHeader.bcHeight;
        ((LPBITMAPCOREINFO) pBitsInfo)->bmciHeader.bcPlanes = 1;
        uiBitCount = (UINT) ((LPBITMAPCOREINFO) pBitsInfo)->bmciHeader.bcBitCount;
        uiSizeScan = ((((uiBitCount * uiWidth) + 31) >> 5) << 2);
        uiCompression = BI_RGB;
    }
    else
    {
        //
        // make sure the header is large enough for a full INFOHEADER
        //

        if (cjMaxInfo < sizeof(BITMAPINFOHEADER))
        {
            return(0);
        }

        //
        // zero out extra fields
        //
        if (ulSize > sizeof(BITMAPINFOHEADER))
        {
            RtlZeroMemory((PVOID)((BYTE *)pBitsInfo+sizeof(BITMAPINFOHEADER)),
                ulSize-sizeof(BITMAPINFOHEADER));
        }

        //
        // First fill in bmiHeader
        //
        bCoreInfo = FALSE;
        pusIndices = (PUSHORT) (pBitsInfo->bmiColors);
        pBitsInfo->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
        pBitsInfo->bmiHeader.biPlanes = 1;
        uiBitCount = (UINT) pBitsInfo->bmiHeader.biBitCount;
        uiCompression = pBitsInfo->bmiHeader.biCompression;
        uiWidth = (UINT) pBitsInfo->bmiHeader.biWidth;

        if (pBitsInfo->bmiHeader.biHeight < 0)
        {
            dbmi.fl = BMF_TOPDOWN;

            if ((uiCompression != BI_RGB) && (uiCompression != BI_BITFIELDS))
            {
                WARNING1("GreGetDIBits: TOP_DOWN RLE not allowed\n");
                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                return (0);
            }

            uiHeight = (UINT) -pBitsInfo->bmiHeader.biHeight;
        }
        else
        {
            uiHeight = (UINT) pBitsInfo->bmiHeader.biHeight;
        }

        //
        // Get a valid compression set in.
        //

        if (uiCompression == BI_BITFIELDS)
        {
            //
            // We only give BI_BITFIELDS if they want 16 or 32 bpp.
            //

            if ((uiBitCount != 16) &&
                (uiBitCount != 32))
            {
                uiCompression = pBitsInfo->bmiHeader.biCompression = BI_RGB;
            }
        }
        else if (uiCompression == BI_RLE8)
        {
            //
            // We only give BI_RLE8 if they want 8 bpp data.
            //

            if (uiBitCount != 8)
            {
                uiCompression = pBitsInfo->bmiHeader.biCompression = BI_RGB;
            }
        }
        else if (uiCompression == BI_RLE4)
        {
            //
            // We only give BI_RLE4 if they want 4 bpp data.
            //

            if (uiBitCount != 4)
            {
                uiCompression = pBitsInfo->bmiHeader.biCompression = BI_RGB;
            }
        }
        else if (uiCompression == BI_CMYK)
        {
            //
            // We will give BI_CMYK, if dc allowed.
            //
            if (dco.pdc->bIsCMYKColor())
            {
                uiCompression = pBitsInfo->bmiHeader.biCompression = BI_CMYK;
            }
        }
        else
        {
            //
            // We give them BI_RGB.
            //

            uiCompression = pBitsInfo->bmiHeader.biCompression = BI_RGB;
        }

        uiSizeScan = ((((uiBitCount * uiWidth) + 31) >> 5) << 2);

        if ((uiCompression == BI_RGB) || (uiCompression == BI_BITFIELDS))
        {
            pBitsInfo->bmiHeader.biSizeImage = uiSizeScan * uiHeight;
        }

        pBitsInfo->bmiHeader.biClrUsed = 0;
        pBitsInfo->bmiHeader.biClrImportant = 0;
    }

    BOOL bRLE = (uiCompression == BI_RLE4) ||
                (uiCompression == BI_RLE8);

    //
    // Get iStartScan and cNumScan in a valid range.
    //

    iStartScan = MIN(uiHeight, iStartScan);
    cNumScan = MIN((uiHeight - iStartScan), cNumScan);

    //
    // check to see if all scans will fit in the passed buffer
    //

    if (!bRLE)
    {
        if (cjMaxBits < (uiSizeScan * cNumScan))
        {
         #if DBG
            DbgPrint("ERROR GreGetDIBitsInternal %lu %lu %lu %lu %lu\n", cjMaxBits, uiSizeScan, cNumScan, iStartScan, uiHeight);
        #endif
            WARNING1("GreGetDIBits: cjMaxBits is to small\n");
            return(0);
        }
    }

    //
    // Find out what they are asking for
    //

    ULONG cColors;
    dbmi.hpal = (HPALETTE) 0;

    if (uiCompression == BI_BITFIELDS)
    {
        //
        // Handle 16 and 32 bit per pel bitmaps.
        //

        if ((ulSize <= sizeof(BITMAPINFO)) && (cjMaxInfo < (sizeof(ULONG) * 3)))
        {
            WARNING1("GetDIBits 16/32bpp failed - not room for flags\n");
            return(0);
        }
    }

    switch (uiBitCount)
    {
    case 1:
        dbmi.iFormat = BMF_1BPP;
        cColors = 2;
        break;
    case 4:
        dbmi.iFormat = BMF_4BPP;
        cColors = 16;
        break;
    case 8:
        dbmi.iFormat = BMF_8BPP;
        cColors = 256;
        break;
    default:

        if (iUsage == DIB_PAL_COLORS)
        {
            iUsage = DIB_RGB_COLORS;
        }

        cColors = 0;

        switch (uiBitCount)
        {
        case 16:
            dbmi.iFormat = BMF_16BPP;
            break;
        case 24:
            dbmi.iFormat = BMF_24BPP;
            break;
        case 32:
            dbmi.iFormat = BMF_32BPP;
            break;
        default:
            WARNING1("GetDIBits failed invalid bitcount in bmi BI_RGB\n");
            return(0);
        }
    }

    //
    // Initialize a DIB and palette for them.
    //

    PALMEMOBJ palMem;
    XEPALOBJ palTarg;
    ULONG cEntryTemp;

    if (iUsage == DIB_PAL_COLORS)
    {
        //
        // We are guranteed to be getting for just the 1,4,8 BPP case here.
        //

        ASSERTGDI(palDC.cEntries() != 0, "Created 0 entry DC palette");

        //
        // Make sure the color table will fit in the BITMAPINFO
        //

        if (cjMaxInfo < (ulSize + cColors * sizeof(USHORT)))
        {
            WARNING1("GreGetDIBits: not enough memory for the color table DIB_PAL_COLORS\n");
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            return(0);
        }

        //
        // For a palette managed device we need to do special work
        // to get the color table correct for 8bpp get.  Grab sem
        // so we can look at ptransFore.
        //

        SEMOBJ semo(ghsemPalette);

        if ((!palBM.bValid()) && (dbmi.iFormat == BMF_8BPP) && (palDC.ptransFore() != NULL))
        {
            ASSERTGDI(po.bIsPalManaged(), "ERROR not palmanaged on invalid palbm");

            palTarg.ppalSet(palBM.ppalGet());

            //
            // 0 it out like windows
            //

            for (cEntryTemp = 0; cEntryTemp < 256; cEntryTemp++)
            {
                pusIndices[cEntryTemp] = 0;
            }

            USHORT usTemp;
            ASSERTGDI(palDC.cEntries() <= USHRT_MAX, "palDC.cEntries too large\n");

            for (cEntryTemp = 0; cEntryTemp < 256; cEntryTemp++)
            {
                for (usTemp = 0; usTemp < (USHORT)palDC.cEntries(); usTemp++)
                {
                    if (palDC.ptransFore()->ajVector[usTemp] == cEntryTemp)
                    {
                        pusIndices[cEntryTemp] = usTemp;
                        break;
                    }
                }
            }
        }
        else
        {
            //
            // We need to create a palette to blt to.
            //

            if (!palMem.bCreatePalette(PAL_INDEXED, cColors,
                                        (PULONG) NULL,
                                        0, 0, 0, PAL_FIXED))
            {
                WARNING1("GetDIBits failed bCreatePalette for DIB_PAL_COLORS\n");
                return(0);
            }

            palTarg.ppalSet(palMem.ppalGet());

            //
            // Initialize the pusIndices field.
            //

            for (cEntryTemp = 0; cEntryTemp < cColors; cEntryTemp++)
            {
                pusIndices[cEntryTemp] = (USHORT) cEntryTemp;
            }

            //
            // We need to copy the RGB's in from the logical DC palette, reaching down when
            // necessary.
            //

            XEPALOBJ palTemp(po.ppalSurf());

            palTarg.vGetEntriesFrom(palDC, palBM.bValid() ? palBM : palTemp, pusIndices, cColors);
        }
    }
    else if (iUsage == DIB_RGB_COLORS)
    {
        BOOL bCopyPal = FALSE;

        if ((SurfBM.ps->iFormat() == dbmi.iFormat) && (palBM.bValid()))
        {
            bCopyPal = TRUE;

            //
            // for 16/32, do more checking
            //
            if ((uiCompression != BI_BITFIELDS) &&
                ((dbmi.iFormat == BMF_16BPP) || (dbmi.iFormat == BMF_32BPP)))
            {
                bCopyPal =  bIdenticalFormat (palBM, dbmi.iFormat);
            }
            //
            // for 24, check RGB order.
            //
            else if ((dbmi.iFormat == BMF_24BPP) && (palBM.bIsRGB()))
            {
                //
                // Bitmap palette is PAL_RGB, but we need PAL_BGR.
                //
                bCopyPal = FALSE;
            }
        }

        //
        // We can just use palBM, no temporary needed.
        //
        if (bCopyPal)
        {
            palTarg.ppalSet(palBM.ppalGet());
        }
        else
        {
            //
            // We need a temporary palette to fill in with the correct mix of colors and then to
            // use in the xlateobj construction.
            //

            if (!palMem.bCreatePalette(cColors ? PAL_INDEXED :
                                                  ((dbmi.iFormat == BMF_16BPP) ? PAL_BITFIELDS : PAL_BGR),
                                        cColors,
                                        (PULONG) NULL,
                                        0x00007C00, 0x000003E0, 0x0000001F, PAL_FIXED))
            {
                WARNING1("GetDIBits failed bCreatePalette\n");
                return(0);
            }

            palTarg.ppalSet(palMem.ppalGet());


            if ((SurfBM.ps->iFormat() == dbmi.iFormat) && (dbmi.iFormat == BMF_8BPP))
            {
                //
                // This is the 8BPP palette managed bitmap case.  There is no palette and
                // we need to construct the correct colors based on the DC's logical palette.
                //

                //
                // We init the pusIndices to just point into the DC palette and then pull the
                // RGB's out with the same logic we use in CreateDIBitmap.  Then we fill the
                // pusIndices with the correct RGB's.
                //
                // Initialize the pusIndices field.
                //

                for (cEntryTemp = 0; cEntryTemp < cColors; cEntryTemp++)
                {
                    pusIndices[cEntryTemp] = (USHORT) cEntryTemp;
                }

                //
                // Get the correct palette setup
                //

                XEPALOBJ palTemp(po.ppalSurf());

                palTarg.vGetEntriesFrom(palDC, palTemp, pusIndices, cColors);
                palTarg.vInit256Default();
            }
            else
            {
                //
                // Fill in a general mix of colors.  Don't use more colors
                // than the source bitmap has.
                //
                // Actually use as many colors as the destination has. To be
                // Compatible with Windows Millenium. 
                //

                switch(dbmi.iFormat)
                {
                case BMF_1BPP:

                    palTarg.vInitMono();
                    break;

                case BMF_4BPP:

                     palTarg.vInitVGA();
                     break;

                case BMF_8BPP:

                    palTarg.vInit256Rainbow();
                }
            }
        }

        //
        // Fill in the color table.
        //

        if (bCoreInfo)
        {
            if (cjMaxInfo < (sizeof(BITMAPCOREHEADER) + cColors * 3))
            {
                WARNING1("GreGetDIBits: not enough memory for the color table2\n");
                return(0);
            }

            if ((uiBitCount != 16) &&
                (uiBitCount != 24) &&
                (uiBitCount != 32))
            {
                //
                // It's the 1,4,8 bpp case in which case we have to write
                // out information.
                //

                palTarg.vFill_triples((RGBTRIPLE *) pusIndices,
                                0, cColors);
            }
        }
        else
        {
            if (uiCompression == BI_BITFIELDS)
            {
                // If uiCompression == BI_BITFIELDS we should have space for
                // 3 DWORD color masks which will be filled in below. Do
                // this only if we have enough space for 3 masks.

                ASSERTGDI(cColors == 0,"GreGetDIBits: BI_BITFIELDS & cColors != 0\n");
                if (cjMaxInfo >= sizeof(BITMAPINFOHEADER) + 3*sizeof(DWORD))
                    cColors = 3;
            }

            if (cjMaxInfo < (sizeof(BITMAPINFOHEADER) + cColors * 4))
            {
                WARNING1("GreGetDIBits: not enough memory for the color table33\n");
                return(0);
            }

            if (palTarg.flPal() & PAL_BRUSHHACK)
            {
                RtlCopyMemory(pusIndices,(PUSHORT) palTarg.apalColorGet(),
                          cColors * sizeof(SHORT));
            }
            else if ((uiCompression == BI_BITFIELDS) ||
                (uiBitCount == 1) ||
                (uiBitCount == 4) ||
                (uiBitCount == 8))
            {
                //
                // We don't fill it in if it's BI_RGB and 16/24/32.
                //

                palTarg.vFill_rgbquads((RGBQUAD *) pusIndices,
                                0, cColors);
            }
        }
    }
    else
    {
        //
        // This is the DIB_PAL_INDICES case
        //

        if (dbmi.iFormat != SurfBM.ps->iFormat())
        {
            WARNING1("GetDIBits failed DIB_PAL_INDICES - incompat DIB/bitmap format\n");
            return(0);
        }

        palTarg.ppalSet(palBM.ppalGet());
    }

    //
    // Now get the xlate ready.
    //

    XLATEOBJ *pxlo;
    EXLATEOBJ xlo;

    if (xlo.bInitXlateObj(
                    dco.pdc->hcmXform(),
                    dco.pdc->lIcmMode(),
                    palBM,
                    palTarg,
                    palDC,
                    palDC,
                    0,
                    0x00FFFFFF,
                    0))
    {
        pxlo = xlo.pxlo();
    }
    else
    {
        //
        // bInitXlateObj will log the correct error.
        //

        WARNING1("GreGetDIBits failed bInitXlateObj\n");
        return(0);
    }

    //
    // If they just want the color table leave now.
    //

    if ((pjBits == (PBYTE) NULL) &&
        (!bRLE))
    {
        return(TRUE);
    }

    LPBYTE pjCompressionBits;

    if (bRLE)
    {
        if (cNumScan == 0)
            cNumScan = uiHeight;

        pjCompressionBits = NULL;
    }
    else
    {
        pjCompressionBits = pjBits;
    }

    //
    // Attempt to allocate the bitmap from handle manager.
    //

    dbmi.cxBitmap   = uiWidth;
    dbmi.cyBitmap   = cNumScan;

    //
    // Create the dest surface.
    //

    SURFMEM   SurfDimoTemp;
    SurfDimoTemp.bCreateDIB(&dbmi, (PVOID) pjCompressionBits);

    if (!SurfDimoTemp.bValid())
    {
        return(0);
    }

    ASSERTGDI((pjCompressionBits == NULL) ||
              (pjCompressionBits == SurfDimoTemp.ps->pvBits()),
                               "ERROR compression invalid bits");

    //
    // For non-RLE the assignment below does nothing.  For RLE we have
    // it gets the pointer to the bits we allocated.
    //

    pjCompressionBits = (PBYTE) SurfDimoTemp.ps->pvBits();

    SurfDimoTemp.ps->hdev(dco.hdev());

    //
    // Zero fill the memory allocated.
    //

    RtlZeroMemory(SurfDimoTemp.ps->pvBits(), (UINT) SurfDimoTemp.ps->cjBits());

    //
    // Fill in pjBits
    //

    ERECTL erclDest(0, 0, dbmi.cxBitmap, dbmi.cyBitmap);
    EPOINTL eptlSrc(0, uiHeight -
                       (iStartScan + cNumScan));

    //
    // Compute the offset between source and dest, in screen coordinates.
    //

    EPOINTL eptlOffset;
    ERECTL erclReduced;

    eptlOffset.x = erclDest.left - eptlSrc.x;  // == -eptlSrc
    eptlOffset.y = erclDest.top  - eptlSrc.y;

    erclReduced.left    = 0 + eptlOffset.x;
    erclReduced.top     = eptlOffset.y;
    erclReduced.right   = SurfBM.ps->sizl().cx + eptlOffset.x;
    erclReduced.bottom  = SurfBM.ps->sizl().cy + eptlOffset.y;

    //
    // Intersect the dest with the source.
    //

    erclDest *= erclReduced;

    if (erclDest.bEmpty())
    {
        return(0);
    }

    //
    // The bitmap may be a DFB.  Synchronization should have been taken
    // care by the devlock that we already acquired.
    //

    ASSERTGDI(!(SurfBM.ps->bUseDevlock()) ||
              (SurfBM.ps->hdev() == po.hdev()), "Devlock not acquired");

    EngCopyBits(SurfDimoTemp.pSurfobj(),
                SurfBM.pSurfobj(),
                (CLIPOBJ *) NULL,
                pxlo,
                (PRECTL) &erclDest,
                (PPOINTL) &eptlSrc);

    if (bRLE)
    {
        //
        // If pjBits is NULL we want these to write the size to hold the
        // compressed bits in the header.  If pjBits is not NULL we want
        // to compress the data into the buffer and fail returning 0 if
        // the buffer is not big enough.
        //

        if (uiCompression == BI_RLE4)
        {
             pBitsInfo->bmiHeader.biSizeImage = EncodeRLE4(
                                                    pjCompressionBits,
                                                    pjBits,
                                                    uiWidth,
                                                    cNumScan,
                                                    pBitsInfo->bmiHeader.biSizeImage
                                                    );
        }
        else if (uiCompression == BI_RLE8)
        {
            pBitsInfo->bmiHeader.biSizeImage = EncodeRLE8(
                                                    pjCompressionBits,
                                                    pjBits,
                                                    uiWidth,
                                                    cNumScan,
                                                    pBitsInfo->bmiHeader.biSizeImage
                                                    );
        }

        //
        // if the encoded data doesn't fit into the buffer
        // the encode routines return 0 and we do the same

        if (pBitsInfo->bmiHeader.biSizeImage == 0)
        {
            return(0);
        }
    }

    return(erclDest.bottom - erclDest.top);
}

/******************************Public*Routine******************************\
* GreSetBitmapDimension
*
* API entry point for setting the sizlDim of the bitmap.
* sizlDim is not used by GDI, but is kept around for the user to query.
*
* Returns: TRUE if successful, FALSE for failure.
*
* History:
*  02-May-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
GreSetBitmapDimension(
    HBITMAP hbm,
    int     ulX,
    int     ulY,
    LPSIZE pSize)
{
    BOOL    bReturn = FALSE;
    SURFREF Surf((HSURF)hbm);

    if (Surf.bValid())
    {
        if (Surf.ps->bApiBitmap())
        {
            SIZEL sizl;

            if (pSize != (LPSIZE) NULL)
            {
                *pSize = Surf.ps->sizlDim();
            }

            sizl.cx = ulX;
            sizl.cy = ulY;
            Surf.ps->sizlDim(sizl);
            bReturn = TRUE;
        }
    }
    else
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
    }

    return(bReturn);
}


/******************************Public*Routine******************************\
* GreGetBitmapDimension
*
* API entry point for getting the sizlDim of the bitmap.
* sizlDim is not used by GDI, but is kept around for the user to query.
*
* Returns: TRUE if successful, FALSE for failure.
*
* History:
*  02-May-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
GreGetBitmapDimension(
    HBITMAP hbm,
    LPSIZE pSize)
{
    BOOL    bReturn = FALSE;
    SURFREF Surf((HSURF)hbm);

    if (Surf.bValid())
    {
        if (Surf.ps->bApiBitmap())
        {
            if (pSize != (LPSIZE) NULL)
            {
                *pSize =  Surf.ps->sizlDim();
                bReturn = TRUE;
            }
            else
            {
                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            }
        }
    }
    else
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
    }

    return(bReturn);
}


/******************************Public*Routine******************************\
* GreStretchDIBits
*
*   API entry for stretching a DIB to a DC.
*
* Arguments:
*
*   hdc             - handle of device context
*   xDst            - x-coordinate of upper-left corner of dest. rect.
*   yDst            - y-coordinate of upper-left corner of dest. rect.
*   cWidthDest      - width of destination rectangle
*   cHeightDest     - height of destination rectangle
*   xSrc            - x-coordinate of upper-left corner of source rect.
*   ySrc            - y-coordinate of upper-left corner of source rect.
*   cWidthSrc       - width of source rectangle
*   cHeightSrc      - height of source rectangle
*   pInitBits       - address of bitmap bits
*   pInfoHeader     - address of bitmap data
*   iUsage          - usage
*   rop4            - raster operation code
*   cjMaxInfo       - maximum size of pInfoHeader
*   cjMaxBits       - maximum size of pIintBits
*
* Return Value:
*
*   Number of scan lines copied or 0 for error
*
* History:
*
*  10-May-1991 -by- Patrick Haluptzok patrickh
\**************************************************************************/

int
APIENTRY
GreStretchDIBits(
    HDC     hdc,
    int     xDst,
    int     yDst,
    int     cWidthDest,
    int     cHeightDest,
    int     xSrc,
    int     ySrc,
    int     cWidthSrc,
    int     cHeightSrc,
    LPBYTE  pjBits,
    LPBITMAPINFO    pInfoHeader,
    DWORD   iUsage,
    DWORD   Rop)
{
    PBITMAPINFO pbmi = pInfoHeader;
    INT  iRet = 0;

    //
    // if it is a COREHEADER, covert it
    //
    if (pInfoHeader && (pInfoHeader->bmiHeader.biSize == sizeof(BITMAPCOREHEADER)))
    {
        pbmi = pbmiConvertInfo (pInfoHeader, iUsage);
    }

    iRet = GreStretchDIBitsInternal(hdc,
                                    xDst,
                                    yDst,
                                    cWidthDest,
                                    cHeightDest,
                                    xSrc,
                                    ySrc,
                                    cWidthSrc,
                                    cHeightSrc,
                                    pjBits,
                                    pbmi,
                                    iUsage,
                                    Rop,
                                    (UINT)~0,
                                    (UINT)~0,
                                    NULL);

    if (pbmi && (pbmi != pInfoHeader))
    {
        VFREEMEM (pbmi);
    }

    return (iRet);
}

#define DIB_FLIP_X  1
#define DIB_FLIP_Y  2


int
APIENTRY
GreStretchDIBitsInternal(
    HDC          hdc,
    int          xDst,
    int          yDst,
    int          cWidthDest,
    int          cHeightDest,
    int          xSrc,
    int          ySrc,
    int          cWidthSrc,
    int          cHeightSrc,
    LPBYTE       pInitBits,
    LPBITMAPINFO pInfoHeader,
    DWORD        iUsage,
    DWORD        rop4,
    UINT         cjMaxInfo,
    UINT         cjMaxBits,
    HANDLE       hcmXform)
{
    int     iRetHeight = 0;

    #if DBG
    if (pInfoHeader)
    {
        ASSERTGDI (pInfoHeader->bmiHeader.biSize >= sizeof(BITMAPINFOHEADER), "bad header\n");
    }
    #endif
    //
    // Process the rop and get the A-vector notation.
    //

    int ropCode = (rop4 >> 16) & 0x000000FF;

    ULONG ulAvec = (ULONG) gajRop3[ropCode];

    //
    // Check for no source required.
    //

    if (!(ulAvec & AVEC_NEED_SOURCE))
    {
        iRetHeight = NtGdiPatBlt(hdc,xDst,yDst,cWidthDest,cHeightDest, rop4);
    }
    else
    {
        //
        // Validate the hdc.
        //

        DCOBJ dcoDest(hdc);

        if (!dcoDest.bValid())
        {
            WARNING1("StretchDIBits failed - invalid DC\n");
        }
        else
        {

            //
            // Let's validate the parameters so we don't gp-fault ourselves.
            //
            // Size in header, copy it out, it can change.
            //

            ULONG ulSize;

            if ((pInfoHeader == (LPBITMAPINFO) NULL) ||
                (pInitBits == (LPBYTE) NULL)         ||
                ((iUsage != DIB_RGB_COLORS) &&
                 (iUsage != DIB_PAL_COLORS) &&
                 (iUsage != DIB_PAL_INDICES))        ||
                (cjMaxInfo < sizeof(BITMAPCOREHEADER)) ||   // Check first that we can access biSize.
                (cjMaxInfo < (ulSize = pInfoHeader->bmiHeader.biSize)) ||
                 (ulSize < sizeof(BITMAPINFOHEADER)))
            {
                WARNING1("GreStretchDIBits failed because 1 of 3 params is invalid\n");
            }
            else
            {

                ULONG jStretchBltMode = dcoDest.pdc->jStretchBltMode();

                //
                // This is used to hold the height of the bitmap in.
                //

                int yHeight;

                //
                // Get the transform now, we'll need it later
                //

                EXFORMOBJ exo(dcoDest, WORLD_TO_DEVICE);

                //
                // Check for state incompatible with BI_JPEG or BI_PNG support.
                //

                if (IS_PASSTHROUGH_IMAGE(pInfoHeader->bmiHeader.biCompression))
                {
                    //
                    // Device must support image format
                    // Only support rop 0xCCCC
                    // No rotations allowed
                    // DIB_RGB_COLORS only
                    // No hcmXform
                    //

                    if (!dcoDest.bSupportsPassthroughImage(pInfoHeader->bmiHeader.biCompression) ||
                        (ropCode != 0xcc) || exo.bRotation() ||
                        (iUsage != DIB_RGB_COLORS) || hcmXform)
                    {
                        //
                        // Return 0 for error.
                        //

                        WARNING("StretchDIBits -- invalid BI_JPEG/BI_PNG operation\n");
                        return iRetHeight;
                    }
                }

                //
                // if it is one to one mapping, lets just call SetDIBitsToDevice
                //

                if ((cWidthDest  == cWidthSrc)  &&
                    (cHeightDest == cHeightSrc) &&
                    (cHeightSrc  >  0)          &&
                    (cWidthSrc > 0)             &&
                    ((xSrc | ySrc) == 0)        &&
                    (ropCode == 0xcc)           &&
                    (jStretchBltMode != HALFTONE))
                {
                    if (exo.bTranslationsOnly())
                    {
                        yHeight = (int)ABS(pInfoHeader->bmiHeader.biHeight);
                        cHeightSrc = min(cHeightSrc, yHeight);

                        return(GreSetDIBitsToDeviceInternal(
                                hdc,
                                xDst,
                                yDst,
                                cWidthDest,
                                cHeightDest,
                                xSrc,
                                ySrc,
                                ySrc,
                                cHeightSrc,
                                pInitBits,
                                pInfoHeader,
                                iUsage,
                                cjMaxBits,
                                cjMaxInfo,
                                TRUE,
                                hcmXform));
                    }
                }

                //
                // We really just want to blt it into a temporary DIB and then
                // blt it out.
                //
                // Calls with DIB_PAL_COLORS will fail HTBlt since there is no
                // src pal.  On mono printers, this looks really bad with no gray scale.
                // Make it go thru GreStretchBlt so we won't lose HALFTONE here.
                // [lingyunw]
                //
                BOOL bForceHalftone = FALSE;

                if ((iUsage == DIB_PAL_COLORS))
                {
                    DEVLOCKOBJ dlo(dcoDest);

                    if (dcoDest.pSurface() && dcoDest.pSurface()->iFormat() == BMF_1BPP)
                    {
                        bForceHalftone = TRUE;
                    }
                }

                if ((ropCode != 0xcc) || (exo.bRotation()) || bForceHalftone)
                {
                    //
                    // Set up src rectangle in upper-left coordinates.
                    //

                    yHeight = (int)pInfoHeader->bmiHeader.biHeight;

                    int ySrcNew;

                    if (yHeight > 0)
                    {
                        ySrcNew = yHeight - ySrc - cHeightSrc;
                    }
                    else
                    {
                        ySrcNew = ySrc;
                    }

                    //
                    // We have to decompress it first and then call StretchBlt
                    //

                    HDC hdcTemp = GreCreateCompatibleDC(hdc);

                    UINT uiCompression = (UINT) pInfoHeader->bmiHeader.biCompression;

                    HBITMAP hbm;

                    //
                    // Let GreCreateDIBitmapComp to decompress RLEs
                    //
                    if ((uiCompression != BI_RLE8) && (uiCompression != BI_RLE4))
                    {
                       hbm = GreCreateDIBitmapReal(hdc,
                                             CBM_INIT,
                                             pInitBits,
                                             pInfoHeader,
                                             iUsage,
                                             cjMaxInfo,
                                             cjMaxBits,
                                             (HANDLE)0,
                                             0,
                                             (HANDLE)0,
                                             0,
                                             0,
                                             NULL);
                    }
                    else
                    {
                       hbm = GreCreateDIBitmapComp(hdc,
                                          ((BITMAPINFOHEADER *) pInfoHeader)->biWidth,
                                          ((BITMAPINFOHEADER *) pInfoHeader)->biHeight,
                                          CBM_INIT,
                                          pInitBits,
                                          pInfoHeader,
                                          iUsage,
                                          cjMaxInfo,
                                          cjMaxBits,
                                          CDBI_INTERNAL,
                                          hcmXform
                                          );

                    }

                    if ((hdcTemp == (HDC) NULL) || (hbm == (HBITMAP) NULL))
                    {
                        //
                        // The creation calls will log the correct errors.
                        //

                        WARNING1("StretchDIBits failed to allocate temp DC and temp bitmap\n");
                        bDeleteDCInternal(hdcTemp,TRUE,FALSE);
                        GreDeleteObject(hbm);
                    }
                    else
                    {

                        HBITMAP hbmTemp = (HBITMAP)GreSelectBitmap(hdcTemp, (HBITMAP)hbm);
                        ASSERTGDI(hbmTemp == STOCKOBJ_BITMAP, "ERROR GDI SetDIBits");

                        //
                        // Send them off to someone we know can do it.
                        //

                        BOOL bReturn = GreStretchBltInternal
                                       (
                                           hdc,
                                           xDst,
                                           yDst,
                                           cWidthDest,
                                           cHeightDest,
                                           hdcTemp,
                                           xSrc,ySrcNew,
                                           cWidthSrc,
                                           cHeightSrc,
                                           rop4,
                                           (DWORD) 0x00FFFFFF,
                                           STRETCHBLT_ENABLE_ICM
                                       );

                        bDeleteDCInternal(hdcTemp,TRUE,FALSE);
                        GreDeleteObject(hbm);

                        if (bReturn)
                        {
                            iRetHeight = yHeight;
                        }
                    }

                    return(iRetHeight);
                }

                //
                // Get the info from the Header depending upon what kind it is.
                //

                UINT uiBitCount, uiCompression, uiWidth, uiPalUsed;
                PULONG pulColors;
                DEVBITMAPINFO dbmi;
                dbmi.fl = 0;
                BOOL bSuccess = TRUE;

                uiBitCount = (UINT) pInfoHeader->bmiHeader.biBitCount;
                uiCompression = (UINT) pInfoHeader->bmiHeader.biCompression;
                uiWidth = (UINT) pInfoHeader->bmiHeader.biWidth;
                yHeight = (int) pInfoHeader->bmiHeader.biHeight;
                uiPalUsed = (UINT) pInfoHeader->bmiHeader.biClrUsed;
                pulColors = (PULONG) ((LPBYTE)pInfoHeader+ulSize);

                if (yHeight < 0)
                {
                    dbmi.fl = BMF_TOPDOWN;
                    yHeight = -yHeight;
                }

                //
                // Now that cjMaxInfo has been validated for the header, adjust it to refer to
                // the color table
                //

                cjMaxInfo -= (UINT)ulSize;

                //
                // Figure out what this guy is blting from.
                //

                ULONG cColorsMax;
                FLONG iPalMode;
                FLONG iPalType;
                FLONG flRed;
                FLONG flGre;
                FLONG flBlu;
                BOOL bRLE = FALSE;

                if (uiCompression == BI_BITFIELDS)
                {
                    //
                    // Handle 16 and 32 bit per pel bitmaps.
                    //

                    if ((ulSize <= sizeof(BITMAPINFO)) && (cjMaxInfo < (sizeof(ULONG) * 3)))
                    {
                        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                        WARNING1("SetDIBitsToDevice 16/32bpp failed - not room for flags\n");
                        bSuccess = FALSE;
                    }
                    else
                    {

                        if (iUsage == DIB_PAL_COLORS)
                        {
                            iUsage = DIB_RGB_COLORS;
                        }

                        switch (uiBitCount)
                        {
                        case 16:
                            dbmi.iFormat = BMF_16BPP;
                            break;
                        case 32:
                            dbmi.iFormat = BMF_32BPP;
                            break;
                        default:
                            WARNING1("SetDIBitsToDevice failed for BI_BITFIELDS\n");
                            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                            bSuccess = FALSE;
                        }

                        //
                        // if BITMAPV4 or greater then masks are stored in info header
                        //

                        if (ulSize >= sizeof(BITMAPINFOHEADER))
                        {
                            pulColors = (PULONG) ((LPBYTE)pInfoHeader+sizeof(BITMAPINFOHEADER));
                        }

                        flRed = pulColors[0];
                        flGre = pulColors[1];
                        flBlu = pulColors[2];
                        cColorsMax = 0;
                        iPalMode = PAL_BITFIELDS;
                        iPalType = PAL_FIXED;
                        dbmi.cjBits = ((((uiBitCount * uiWidth) + 31) >> 5) << 2) * yHeight;
                    }
                }
                else if (uiCompression == BI_RGB)
                {
                    switch (uiBitCount)
                    {
                    case 1:
                        dbmi.iFormat = BMF_1BPP;
                        cColorsMax = 2;
                        iPalMode = PAL_INDEXED;
                        iPalType = PAL_FREE;
                        break;
                    case 4:
                        dbmi.iFormat = BMF_4BPP;
                        cColorsMax = 16;
                        iPalMode = PAL_INDEXED;
                        iPalType = PAL_FREE;
                        break;
                    case 8:
                        dbmi.iFormat = BMF_8BPP;
                        cColorsMax = 256;
                        iPalMode = PAL_INDEXED;
                        iPalType = PAL_FREE;
                        break;
                    default:

                        if (iUsage == DIB_PAL_COLORS)
                        {
                            iUsage = DIB_RGB_COLORS;
                        }

                        switch (uiBitCount)
                        {
                        case 16:
                            dbmi.iFormat = BMF_16BPP;
                            flRed = 0x7c00;
                            flGre = 0x03e0;
                            flBlu = 0x001f;
                            cColorsMax = 0;
                            iPalMode = PAL_BITFIELDS;
                            iPalType = PAL_FIXED;
                            break;
                        case 24:
                            dbmi.iFormat = BMF_24BPP;
                            cColorsMax = 0;
                            iPalMode = PAL_BGR;
                            iPalType = PAL_FIXED;
                            break;
                        case 32:
                            dbmi.iFormat = BMF_32BPP;
                            cColorsMax = 0;
                            iPalMode = PAL_BGR;
                            iPalType = PAL_FIXED;
                            break;
                        default:
                            WARNING1("SetDIBitsToDevice failed invalid bitcount in bmi BI_RGB\n");
                            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                            bSuccess = FALSE;
                        }
                    }

                    if (bSuccess)
                    {
                        dbmi.cjBits = ((((uiBitCount * uiWidth) + 31) >> 5) << 2) * yHeight;
                    }
                }
                else if (uiCompression == BI_CMYK)
                {
                    ASSERTGDI(iUsage == DIB_RGB_COLORS,
                              "StretchDIBits(BI_CMYK):iUsage should be DIB_RGB_COLORS\n");

                    DCOBJ dco(hdc);

                    //
                    // Current device context accept CMYK color ?
                    //
                    if (!dco.bValid() || !dco.pdc->bIsCMYKColor())
                    {
                        WARNING1("SetDIBitsToDevice:DC is not in CMYK color mode for BI_CMYK\n");
                        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                        bSuccess = FALSE;
                    }
                    else
                    {
                        switch (uiBitCount)
                        {
                        case 1:
                            dbmi.iFormat = BMF_1BPP;
                            cColorsMax   = 2;
                            iPalMode     = PAL_INDEXED;
                            iPalType     = PAL_FREE;
                            break;
                        case 4:
                            dbmi.iFormat = BMF_4BPP;
                            cColorsMax   = 16;
                            iPalMode     = PAL_INDEXED;
                            iPalType     = PAL_FREE;
                            break;
                        case 8:
                            dbmi.iFormat = BMF_8BPP;
                            cColorsMax   = 256;
                            iPalMode     = PAL_INDEXED;
                            iPalType     = PAL_FREE;
                            break;
                        case 32:
                            dbmi.iFormat = BMF_32BPP;
                            cColorsMax   = 0;
                            iPalMode     = PAL_CMYK;
                            iPalType     = PAL_FIXED;
                            break;
                        default:
                            WARNING1("SetDIBitsToDevice failed invalid bitcount in bmi BI_CMYK\n");
                            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                            bSuccess = FALSE;
                        }
                    }

                    if (bSuccess)
                    {
                        dbmi.cjBits = ((((uiBitCount * uiWidth) + 31) >> 5) << 2) * yHeight;
                    }
                }
                else if ((uiCompression == BI_RLE4) || (uiCompression == BI_CMYKRLE4))
                {
                    if (uiCompression == BI_CMYKRLE4)
                    {
                        ASSERTGDI(iUsage == DIB_RGB_COLORS,
                                  "StretchDIBits(BI_CMYKRLE4):iUsage should be DIB_RGB_COLORS\n");

                        DCOBJ dco(hdc);

                        //
                        // Current device context accept CMYK color ?
                        //
                        if (!dco.bValid() || !dco.pdc->bIsCMYKColor())
                        {
                            WARNING1("SetDIBitsToDevice:DC is not in CMYK color mode for BI_CMYKRLE4\n");
                            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                            bSuccess = FALSE;
                        }
                    }

                    if (bSuccess)
                    {
                        if (uiBitCount != 4)
                        {
                            WARNING1("StretchDIBits invalid bitcount BI_RLE4\n");
                            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                            bSuccess = FALSE;
                        }

                        dbmi.iFormat    = BMF_4RLE;
                        cColorsMax      = 16;
                        iPalMode        = PAL_INDEXED;
                        iPalType        = PAL_FREE;
                        dbmi.cjBits     = pInfoHeader->bmiHeader.biSizeImage;
                        bRLE            = TRUE;
                    }
                }
                else if ((uiCompression == BI_RLE8) || (uiCompression == BI_CMYKRLE8))
                {
                    if (uiCompression == BI_CMYKRLE8)
                    {
                        ASSERTGDI(iUsage == DIB_RGB_COLORS,
                                  "StretchDIBits(BI_CMYKRLE8):iUsage should be DIB_RGB_COLORS\n");

                        DCOBJ dco(hdc);

                        //
                        // Current device context accept CMYK color ?
                        //
                        if (!dco.bValid() || !dco.pdc->bIsCMYKColor())
                        {
                            WARNING1("SetDIBitsToDevice:DC is not in CMYK color mode for BI_CMYKRLE8\n");
                            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                            bSuccess = FALSE;
                        }
                    }

                    if (bSuccess)
                    {
                        if (uiBitCount != 8)
                        {
                            WARNING1("StretchDIBits invalid bitcount BI_RLE8\n");
                            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                            bSuccess = FALSE;
                        }

                        dbmi.iFormat    = BMF_8RLE;
                        cColorsMax      = 256;
                        iPalMode        = PAL_INDEXED;
                        iPalType        = PAL_FREE;
                        dbmi.cjBits     = pInfoHeader->bmiHeader.biSizeImage;
                        bRLE            = TRUE;
                    }
                }
                else if (uiCompression == BI_JPEG)
                {
                    //
                    // The XLATEOBJ we setup for BI_JPEG is only valid for
                    // querying the ICM flags in the flXlate member.
                    //

                    dbmi.iFormat    = BMF_JPEG;
                    cColorsMax      = 0;
                    iPalMode        = PAL_BGR;
                    iPalType        = PAL_FIXED;
                    dbmi.cjBits     = pInfoHeader->bmiHeader.biSizeImage;
                }
                else if (uiCompression == BI_PNG)
                {
                    //
                    // The XLATEOBJ we setup for BI_PNG is only valid for
                    // querying the ICM flags in the flXlate member.
                    //

                    dbmi.iFormat    = BMF_PNG;
                    cColorsMax      = 0;
                    iPalMode        = PAL_BGR;
                    iPalType        = PAL_FIXED;
                    dbmi.cjBits     = pInfoHeader->bmiHeader.biSizeImage;
                }
                else
                {
                    WARNING1("GreStretchDIBits failed invalid Compression in header\n");
                    SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                    bSuccess = FALSE;
                }

                if (bSuccess)
                {
                    //
                    // if color transform is not specified, use DC's color transform.
                    //

                    if (hcmXform == NULL)
                    {
                        hcmXform = dcoDest.pdc->hcmXform();
                    }
                    else
                    {
                        ICMMSG(("GreStretchDIBitsInternal():Bitmap has thier own colorspace\n"));
                    }

                    ULONG lIcmMode = dcoDest.pdc->lIcmMode();

                    if (IS_CMYK_COLOR(lIcmMode))   /* DC is CMYK color mode ? */
                    {
                        if ((hcmXform == NULL) || !IS_CMYK_BITMAP(uiCompression))
                        {
                            //
                            // DC mode is CMYK color, but bitmap itself is not.
                            // so clear CMYK color bit, so that XLATEOBJ will not
                            // have XO_FROM_CMYK
                            //
                            CLEAR_COLORTYPE(lIcmMode);
                            //
                            // then it's RGB.
                            //
                            lIcmMode |= DC_ICM_RGB_COLOR;
                        }
                    }

                    dbmi.cxBitmap   = uiWidth;
                    dbmi.cyBitmap   = yHeight;

                    ULONG cColors;

                    if (uiPalUsed != 0)
                    {
                        if (uiPalUsed <= cColorsMax)
                        {
                            cColors = uiPalUsed;
                        }
                        else
                        {
                            cColors = cColorsMax;
                        }
                    }
                    else
                    {
                        cColors = cColorsMax;
                    }

                    if (cjMaxBits < dbmi.cjBits)
                    {
                        WARNING1("GreStretchDIBits failed because of invalid cjMaxBits\n");
                        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                    }
                    else
                    {
                        PDEVOBJ po(dcoDest.hdev());
                        ERECTL erclTrg(xDst, yDst, xDst + cWidthDest, yDst + cHeightDest);

                        //
                        // Transform the dest point to DEVICE coordinates.
                        //

                        EXFORMOBJ xoDest(dcoDest, WORLD_TO_DEVICE);

                        if (!xoDest.bXform(erclTrg))
                        {
                            WARNING1("StretchDIBits failed to transform coordinates\n");
                        }
                        else
                        {
                            //
                            // Return null operations.
                            //

                            if (erclTrg.bEmpty())
                            {
                                iRetHeight = cHeightSrc;
                            }
                            else
                            {
                                //
                                //  Windows uses 'last point' exclusion on StretchBlt calls.
                                //  This means we can't simply 'order' a rectangle, we must
                                //  Flip it, remember that it has flipped and adjust the
                                //  coordinates to match Windows, this is sick and twisted
                                //  but it's compatible. [donalds] 03-Jun-1993
                                //

                                FLONG   flFlip = 0;
                                LONG    lTmp;

                                if (erclTrg.left > erclTrg.right)
                                {
                                    lTmp = erclTrg.left, erclTrg.left = erclTrg.right, erclTrg.right = lTmp;

                                    //
                                    // WINBUG #274633 3-19-2000 andarsov. When the transformation has the 
                                    // bMirrored flag, it does the increment of left, right itself.
                                    // The check below prevents the double increment, and losing of a pixel column.
                                    //

                                    if (!xoDest.bMirrored)
                                    {
                                        erclTrg.left++;
                                        erclTrg.right++;
                                    }

                                    flFlip ^= DIB_FLIP_X;
                                }

                                if (erclTrg.top > erclTrg.bottom)
                                {
                                    lTmp = erclTrg.top, erclTrg.top = erclTrg.bottom, erclTrg.bottom = lTmp;

                                    erclTrg.top++;
                                    erclTrg.bottom++;

                                    flFlip ^= DIB_FLIP_Y;
                                }

                                //
                                // We need a well ordered rectangle to compute clipping and exclusion with.
                                //

                                PALMEMOBJ palTemp;

                                if (iUsage == DIB_RGB_COLORS)
                                {
                                    //
                                    // Allocate a palette for this bitmap.
                                    //

                                    if (!palTemp.bCreatePalette(iPalMode,
                                                                cColorsMax,
                                                                (PULONG) NULL,
                                                                flRed,
                                                                flGre,
                                                                flBlu,
                                                                iPalType
                                                               )
                                                             )
                                    {
                                        WARNING1("Failed palette creation in StretchDIBits\n");
                                        bSuccess = FALSE;
                                    }
                                }

                                if (bSuccess)
                                {
                                    DEVLOCKOBJ dlo(dcoDest);
                                    SURFACE   *pSurfDst = dcoDest.pSurfaceEff();

                                    dbmi.fl |= dcoDest.bUMPD() ? UMPD_SURFACE : 0;

                                    dbmi.hpal = 0;

                                    //
                                    // Attempt to allocate the bitmap.
                                    //

                                    SURFMEM SurfDimoTemp;

                                    if (bRLE)
                                    {
                                        DEVBITMAPINFO dbmiRLE;
                                        SURFMEM       SurfDimoRLE;

                                        dbmiRLE = dbmi;

                                        if (!SurfDimoRLE.bCreateDIB(&dbmiRLE, pInitBits))
                                        {
                                            WARNING("GreStretchDIBits failed SurfDimoRLE alloc\n");
                                            bSuccess = FALSE;
                                        }
                                        else
                                        {
                                            //
                                            // Well StretchBlt can't handle RLE's, so we unpack it into
                                            // SurfDimoTemp which must be an uncompressed format.
                                            //

                                            if (dbmi.iFormat == BMF_4RLE)
                                            {
                                                dbmi.iFormat = BMF_4BPP;
                                            }
                                            else
                                            {
                                                dbmi.iFormat = BMF_8BPP;
                                            }

                                            if (!SurfDimoTemp.bCreateDIB(&dbmi, NULL))
                                            {
                                                WARNING("GreStretchDIBits failed\n");
                                                bSuccess = FALSE;
                                            }
                                            else
                                            {
                                                ERECTL erclTemp(0,0, dbmi.cxBitmap, dbmi.cyBitmap);

                                                EngCopyBits(SurfDimoTemp.pSurfobj(),
                                                            SurfDimoRLE.pSurfobj(),
                                                            (CLIPOBJ *) NULL,
                                                            NULL,
                                                            (PRECTL) &erclTemp,
                                                            (PPOINTL) &gptl00
                                                           );
                                            }
                                        }
                                    }
                                    else
                                    {
                                        if (!SurfDimoTemp.bCreateDIB(&dbmi,pInitBits))
                                        {
                                            WARNING("GreStretchDIBits failed\n");
                                            bSuccess = FALSE;
                                        }
                                    }

                                    if (bSuccess)
                                    {
                                        //
                                        // Lock the Rao region if we are drawing on a display surface.  The Rao
                                        // region might otherwise change asynchronously.  The DEVLOCKOBJ also makes
                                        // sure that the VisRgn is up to date, calling the window manager if
                                        // necessary to recompute it.  It also protects us from pSurfDest
                                        // being changed asynchronously by a dynamic mode change.
                                        //

                                        DEVLOCKOBJ dlo(dcoDest);

                                        SURFACE   *pSurfDest = dcoDest.pSurfaceEff();
                                        XEPALOBJ   palDest(pSurfDest->ppal());
                                        XEPALOBJ   palDestDC(dcoDest.ppal());
                                        XLATEOBJ  *pxlo;
                                        EXLATEOBJ  xlo;
                                        BOOL       bNeedAssociatePalette = FALSE;

                                        //
                                        // Associate the DC's palette with the bitmap for use when
                                        // converting DDBs to DIBs for dynamic mode changes.
                                        //

                                        if (!palDestDC.bIsPalDefault())
                                        {
                                            pSurfDest->hpalHint(palDestDC.hpal());
                                        }

                                        switch (iUsage)
                                        {
                                        case DIB_RGB_COLORS:

                                            if (cColors)
                                            {
                                                if (cjMaxInfo < (cColors * 4))
                                                {
                                                    WARNING1("StretchDIBits failed DIB_RGB_COLORS bmi invalid size\n");
                                                    bSuccess = FALSE;

                                                    //
                                                    // break out of case
                                                    //

                                                    break;
                                                }
                                                else
                                                {
                                                    //
                                                    // Copy bitmap color table into palette
                                                    //

                                                    if (IS_CMYK_BITMAP(uiCompression))
                                                    {
                                                        palTemp.vCopy_cmykquad(pulColors, 0, cColors);
                                                    }
                                                    else
                                                    {
                                                        palTemp.vCopy_rgbquad((RGBQUAD *) pulColors, 0, cColors);
                                                    }
                                                }

                                                //
                                                // This is a special version of the constructor that doesn't search the
                                                // cache and doesn't put it in the cache when it's done.
                                                //

                                                if (NULL == xlo.pInitXlateNoCache(
                                                                                  hcmXform,
                                                                                  lIcmMode,
                                                                                  palTemp,
                                                                                  palDest,
                                                                                  palDestDC,
                                                                                  0,
                                                                                  0,
                                                                                  0x00FFFFFF
                                                                                 )
                                                                             )
                                                {
                                                    //
                                                    // Error message is already logged.
                                                    //

                                                    WARNING1("GreStretchDIBits failed XLATE init\n");
                                                    bSuccess = FALSE;
                                                }

                                            }
                                            else
                                            {

                                                //
                                                // This is a special version of the constructor that doesn't search the
                                                // cache and doesn't put it in the cache when it's done.
                                                //

                                                if (NULL == xlo.pInitXlateNoCache(
                                                                                  hcmXform,
                                                                                  lIcmMode,
                                                                                  palTemp,
                                                                                  palDest,
                                                                                  palDestDC,
                                                                                  0,
                                                                                  0,
                                                                                  0x00FFFFFF
                                                                                 )
                                                                             )
                                                {
                                                    //
                                                    // Error message is already logged.
                                                    //

                                                    WARNING1("GreStretchDIBits failed XLATE init\n");
                                                    bSuccess = FALSE;
                                                }

                                            }

                                            pxlo = xlo.pxlo();
                                            break;

                                        case DIB_PAL_COLORS:

                                            if (cjMaxInfo < (cColors * sizeof(USHORT)))
                                            {
                                                WARNING1("StretchDIBits failed DIB_PAL_COLORS is invalid\n");
                                                bSuccess = FALSE;
                                            }
                                            else
                                            {
                                                if (!xlo.bMakeXlate(
                                                            (PUSHORT) pulColors,
                                                            palDestDC,
                                                            pSurfDest,
                                                            cColors,
                                                            cColorsMax))
                                                {
                                                    WARNING1("GDISRV GreStretchDIBits failed bMakeXlate\n");
                                                    bSuccess = FALSE;
                                                }
                                                else
                                                {
                                                    pxlo = xlo.pxlo();

                                                    //
                                                    // If we are drawing to display meta-screen with multi-monitor
                                                    // system and it's colour-depth is not same for all those monitor.
                                                    // we need to create palette to map color to other-than primary
                                                    // monitor(s).
                                                    //

                                                    if (gbMultiMonMismatchColor && po.bDisplayPDEV())
                                                    {
                                                        if (palTemp.bCreatePalette(iPalMode, cColorsMax, (PULONG) NULL,
                                                                                   flRed, flGre, flBlu, iPalType))
                                                        {
                                                            XEPALOBJ palSurfEff(pSurfDest->ppal() ? \
                                                                                pSurfDest->ppal() : po.ppalSurf());

                                                            //
                                                            // Keep DC (or Surface) palette entry to temporay palette.
                                                            //

                                                            palTemp.vGetEntriesFrom(palDestDC, palSurfEff,
                                                                                     (PUSHORT)pulColors, cColors);

                                                            bNeedAssociatePalette = TRUE;
                                                        }
                                                        else
                                                        {
                                                            WARNING1("GreStretchDIBitsInternal: Failed to create temporary palette");
                                                            bSuccess = FALSE;
                                                        }
                                                    }
                                                }
                                            }

                                            break;

                                        case DIB_PAL_INDICES:

                                            if (pSurfDest->iFormat() != dbmi.iFormat)
                                            {
                                                WARNING1("StretchDIBits failed - DIB_PAL_INDICES used - DIB not format of Dst\n");
                                                bSuccess = FALSE;
                                            }

                                            pxlo = &xloIdent;
                                        }

                                        if (bSuccess)
                                        {

                                            //
                                            // Accumulate bounds.  We can do this before knowing if the operation is
                                            // successful because bounds can be loose.
                                            //

                                            if (dcoDest.fjAccum())
                                            {
                                                dcoDest.vAccumulate(erclTrg);
                                            }

                                            //
                                            // Bail out if this is an INFO_DC, but only after we have the attempted to grab devlock
                                            //

                                            if (dcoDest.bFullScreen())
                                            {
                                                iRetHeight = yHeight;
                                            }
                                            else
                                            {

                                                //
                                                // now bail out if the devlock failed for any other reason
                                                //

                                                if (!dlo.bValid())
                                                {
                                                    WARNING1("GreStretchDIBits failed the DEVLOCK\n");
                                                }
                                                else
                                                {

                                                    //
                                                    // With a fixed DC origin we can change the destination to SCREEN coordinates.
                                                    //

                                                    erclTrg += dcoDest.eptlOrigin();

                                                    //
                                                    // Handle BitBlts that have a source.  Create a rect bounding the
                                                    // src and the bits that have been supplied.
                                                    //

                                                    EPOINTL eptlSrc;
                                                    ERECTL  erclSrc;

                                                    erclSrc.left = xSrc;

                                                    //
                                                    // If the DIB is regular PM DIB the coordinates are lower-left and need
                                                    // to adjusted to upper left.
                                                    //

                                                    //
                                                    // fix a bug for JPEG/TOPDOWN case
                                                    // the same problem occurs for general DIBs but it's too risky
                                                    // to fix now
                                                    //
                                                    if ((uiCompression == BI_JPEG) && (dbmi.fl & BMF_TOPDOWN))
                                                    {
                                                       erclSrc.top = ySrc;
                                                    }
                                                    else
                                                    {
                                                        erclSrc.top = yHeight - ySrc - cHeightSrc;
                                                    }

                                                    erclSrc.bottom = erclSrc.top + cHeightSrc;
                                                    erclSrc.right = erclSrc.left + cWidthSrc;

                                                    //
                                                    // Order the Src rectangle, flipping Dst to reflect it.
                                                    //

                                                    if (erclSrc.left > erclSrc.right)
                                                    {
                                                        lTmp = erclSrc.left, erclSrc.left = erclSrc.right, erclSrc.right = lTmp;

                                                        erclSrc.left++;
                                                        erclSrc.right++;

                                                        flFlip ^= DIB_FLIP_X;
                                                    }

                                                    if (erclSrc.top > erclSrc.bottom)
                                                    {
                                                        lTmp = erclSrc.top, erclSrc.top = erclSrc.bottom, erclSrc.bottom = lTmp;

                                                        erclSrc.top++;
                                                        erclSrc.bottom++;

                                                        flFlip ^= DIB_FLIP_Y;
                                                    }

                                                    //
                                                    // Make sure some portion of the source is on the src surface.
                                                    //

                                                    if ((erclSrc.right <= 0) ||
                                                        (erclSrc.bottom <= 0) ||
                                                        (erclSrc.left >= SurfDimoTemp.ps->sizl().cx) ||
                                                        (erclSrc.top >= SurfDimoTemp.ps->sizl().cy) ||
                                                        (erclSrc.bEmpty()))
                                                    {

                                                        //
                                                        // Well nothing is visible, let's get out of here.
                                                        //

                                                        WARNING1("GreStretchDIBits nothing visible in SRC rectangle\n");
                                                    }
                                                    else
                                                    {

                                                        //
                                                        // Compute the clipping complexity and maybe reduce the exclusion rectangle.
                                                        //

                                                        ECLIPOBJ co(dcoDest.prgnEffRao(), erclTrg);

                                                        //
                                                        // Check the destination which is reduced by clipping.
                                                        //

                                                        if (co.erclExclude().bEmpty())
                                                        {
                                                            iRetHeight = yHeight;
                                                        }
                                                        else
                                                        {
                                                            if (bNeedAssociatePalette)
                                                            {
                                                                ASSERTGDI(SurfDimoTemp.ps->ppal() == NULL,
                                                                  "SetDIBitsToDevice():Surface has palette already\n");

                                                                SurfDimoTemp.ps->ppal(palTemp.ppalGet());
                                                            }

                                                            //
                                                            // Exclude the pointer.
                                                            //

                                                            DEVEXCLUDEOBJ dxo(dcoDest,&erclTrg,&co);

                                                            //
                                                            // Get the function pointer.
                                                            //

                                                            PFN_DrvStretchBlt pfn;

                                                            //
                                                            // There are a bunch of conditions that we don't want to
                                                            // call the driver, so we make pfn point to the Eng
                                                            // function. But if the destination is a meta, we want it
                                                            // to actually call the Mul layer.
                                                            //
                                                            // WINBUG #357937 4-3-2001 jasonha Meta DEVBITMAPs must go thru Mul layer
                                                            //  Don't check iType:
                                                            //    DEVICE/DEVBITMAP -> MulStretchBlt
                                                            //    BITMAP (not hooked) -> EngStretchBlt

                                                            PDEVOBJ pdoDest(pSurfDest->hdev());

                                                            pfn = PPFNGET(pdoDest, StretchBlt, pSurfDest->flags());

                                                            if ((pSurfDest->flags() & HOOK_StretchBlt) && !pdoDest.bMetaDriver())
                                                            {
                                                                // Don't call the driver if it doesn't do halftone.

                                                                if (jStretchBltMode == HALFTONE)
                                                                {
                                                                    if (!(dcoDest.flGraphicsCaps() & GCAPS_HALFTONE))
                                                                        pfn = (PFN_DrvStretchBlt)EngStretchBlt;
                                                                }

                                                                //
                                                                // Don't call the driver if the source rectangle exceeds
                                                                // the source surface. Some drivers punt using a duplicate
                                                                // of the source SURFOBJ, but without preserving its
                                                                // sizlBitmap member.
                                                                // This causes a source clipping bug (77102).
                                                                //

                                                                if((erclSrc.left < 0) ||
                                                                   (erclSrc.top  < 0) ||
                                                                   (erclSrc.right  > SurfDimoTemp.ps->sizl().cx) ||
                                                                   (erclSrc.bottom > SurfDimoTemp.ps->sizl().cy))
                                                                {
                                                                    pfn = (PFN_DrvStretchBlt)EngStretchBlt;
                                                                }
                                                            }

                                                            //
                                                            // Reflect the accumulated flipping on the target
                                                            //

                                                            if (flFlip & DIB_FLIP_X)
                                                            {
                                                                lTmp = erclTrg.left, erclTrg.left = erclTrg.right, erclTrg.right = lTmp;
                                                            }

                                                            if (flFlip & DIB_FLIP_Y)
                                                            {
                                                                lTmp = erclTrg.top, erclTrg.top = erclTrg.bottom, erclTrg.bottom = lTmp;
                                                            }

                                                            //
                                                            // Inc the target surface uniqueness
                                                            //

                                                            INC_SURF_UNIQ(pSurfDest);

                                                            //
                                                            // Dispatch the call.
                                                            //


                                                            BOOL bRes = (*pfn)(pSurfDest->pSurfobj(),
                                                                               SurfDimoTemp.pSurfobj(),
                                                                               (SURFOBJ *) NULL,
                                                                               (CLIPOBJ *)&co,
                                                                               pxlo,
                                                                               (dcoDest.pColorAdjustment()->caFlags & CA_DEFAULT) ?
                                                                                    (PCOLORADJUSTMENT)NULL : dcoDest.pColorAdjustment(),
                                                                               &dcoDest.pdc->ptlFillOrigin(),
                                                                               &erclTrg,
                                                                               &erclSrc,
                                                                               NULL,
                                                                               (ULONG) jStretchBltMode
                                                                              );

                                                            if (bRes)
                                                            {
                                                                iRetHeight = yHeight;
                                                            }
                                                            else
                                                            {
                                                                WARNING1("GreStretchDIBits failed DrvStretchBlt\n");
                                                            }

                                                            if (bNeedAssociatePalette)
                                                            {
                                                                SurfDimoTemp.ps->ppal(NULL);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }

                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    return(iRetHeight);
}

/**************************************************************************\
* psurfCreateDIBSurfaceAndXform
*
*   Create Surface and Palette from DIB input
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    2/18/1997 Mark Enstrom [marke]
*
\**************************************************************************/

PSURFACE
psurfCreateDIBSurface(
    HDC          hdcDest,
    LPBYTE       pInitBits,
    LPBITMAPINFO pInfoHeader,
    DWORD        iUsage,
    UINT         cjMaxInfo,
    UINT         cjMaxBits
    )
{
    SURFMEM SurfDimoTemp;
    BOOL    bSuccess = TRUE;

    #if DBG
    if (pInfoHeader)
    {
        ASSERTGDI (pInfoHeader->bmiHeader.biSize >= sizeof(BITMAPINFOHEADER), "bad header\n");
    }
    #endif

    //
    // Validate the hdc.
    //

    DCOBJ dcoDest(hdcDest);

    if (!dcoDest.bValid())
    {
        WARNING1("psurfCreateDIBSurfaceAndXform failed - invalid DC\n");
    }
    else
    {
        //
        // Let's validate the parameters so we don't gp-fault ourselves.
        //
        // Size in header, copy it out, it can change.
        //

        ULONG ulSize;

        if ((pInfoHeader == (LPBITMAPINFO) NULL) ||
            (pInitBits == (LPBYTE) NULL)         ||
            ((iUsage != DIB_RGB_COLORS) &&
             (iUsage != DIB_PAL_COLORS) &&
             (iUsage != DIB_PAL_INDICES))        ||
            (cjMaxInfo < sizeof(BITMAPCOREHEADER)) ||   // Check first that we can access biSize.
            (cjMaxInfo < (ulSize = pInfoHeader->bmiHeader.biSize)) ||
             (ulSize < sizeof(BITMAPINFOHEADER)))
        {
            WARNING1("psurfCreateDIBSurfaceAndXform failed input parameter validation\n");
        }
        else
        {
            //
            // This is used to hold the height of the bitmap in.
            //

            int yHeight;

            //
            // Get the info from the Header depending upon what kind it is.
            //

            BOOL          bSuccess = TRUE;
            UINT          uiBitCount, uiCompression, uiWidth, uiPalUsed;
            PULONG        pulColors;
            DEVBITMAPINFO dbmi;

            dbmi.fl = 0;

            uiBitCount    = (UINT) pInfoHeader->bmiHeader.biBitCount;
            uiCompression = (UINT) pInfoHeader->bmiHeader.biCompression;

            uiWidth = (UINT) pInfoHeader->bmiHeader.biWidth;
            yHeight = (int) pInfoHeader->bmiHeader.biHeight;

            uiPalUsed = (UINT) pInfoHeader->bmiHeader.biClrUsed;
            pulColors = (PULONG) ((LPBYTE)pInfoHeader+ulSize);

            if (yHeight < 0)
            {
                dbmi.fl = BMF_TOPDOWN;
                yHeight = -yHeight;
            }

            //
            // Now that cjMaxInfo has been validated for the header, adjust it to refer to
            // the color table
            //

            cjMaxInfo -= (UINT)ulSize;

            //
            // Figure out what this guy is blting from.
            //

            ULONG cColorsMax;
            FLONG iPalMode;
            FLONG iPalType;
            FLONG flRed;
            FLONG flGre;
            FLONG flBlu;
            BOOL  bRLE = FALSE;

            if (uiCompression == BI_BITFIELDS)
            {
                //
                // Handle 16 and 32 bit per pel bitmaps.
                //

                if ((ulSize <= sizeof(BITMAPINFO)) && (cjMaxInfo < (sizeof(ULONG) * 3)))
                {
                    SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                    WARNING1("psurfCreateDIBSurfaceAndXform failed - not room for flags\n");
                    bSuccess = FALSE;
                }
                else
                {
                    //
                    // if BITMAPV4 or greater then masks are stored in info header
                    //

                    if (ulSize >= sizeof(BITMAPINFOHEADER))
                    {
                        pulColors = (PULONG) ((LPBYTE)pInfoHeader+sizeof(BITMAPINFOHEADER));
                    }

                    flRed = pulColors[0];
                    flGre = pulColors[1];
                    flBlu = pulColors[2];

                    if (iUsage == DIB_PAL_COLORS)
                    {
                        iUsage = DIB_RGB_COLORS;
                    }

                    switch (uiBitCount)
                    {
                    case 16:
                        dbmi.iFormat = BMF_16BPP;
                        break;
                    case 32:
                        dbmi.iFormat = BMF_32BPP;
                        break;
                    default:
                        WARNING1("SetDIBitsToDevice failed for BI_BITFIELDS\n");
                        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                        bSuccess = FALSE;
                    }

                    cColorsMax = 0;
                    iPalMode = PAL_BITFIELDS;
                    iPalType = PAL_FIXED;
                    dbmi.cjBits = ((((uiBitCount * uiWidth) + 31) >> 5) << 2) * yHeight;

                }
            }
            else if (uiCompression == BI_RGB)
            {
                switch (uiBitCount)
                {
                case 1:
                    dbmi.iFormat = BMF_1BPP;
                    cColorsMax = 2;
                    iPalMode = PAL_INDEXED;
                    iPalType = PAL_FREE;
                    break;
                case 4:
                    dbmi.iFormat = BMF_4BPP;
                    cColorsMax = 16;
                    iPalMode = PAL_INDEXED;
                    iPalType = PAL_FREE;
                    break;
                case 8:
                    dbmi.iFormat = BMF_8BPP;
                    cColorsMax = 256;
                    iPalMode = PAL_INDEXED;
                    iPalType = PAL_FREE;
                    break;
                default:

                    if (iUsage == DIB_PAL_COLORS)
                    {
                        iUsage = DIB_RGB_COLORS;
                    }

                    switch (uiBitCount)
                    {
                    case 16:
                        dbmi.iFormat = BMF_16BPP;
                        flRed = 0x7c00;
                        flGre = 0x03e0;
                        flBlu = 0x001f;
                        cColorsMax = 0;
                        iPalMode = PAL_BITFIELDS;
                        iPalType = PAL_FIXED;
                        break;
                    case 24:
                        dbmi.iFormat = BMF_24BPP;
                        cColorsMax = 0;
                        iPalMode = PAL_BGR;
                        iPalType = PAL_FIXED;
                        break;
                    case 32:
                        //
                        // This is for alpha API, assume
                        // 32 bpp BGR input is BGRA
                        //
                        dbmi.iFormat = BMF_32BPP;
                        cColorsMax = 0;
                        iPalMode = PAL_BGR;
                        iPalType = PAL_FIXED;
                        break;
                    default:
                        WARNING1("psurfCreateDIBSurfaceAndXform failed invalid bitcount in bmi BI_RGB\n");
                        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                        bSuccess = FALSE;
                    }
                }

                if (bSuccess)
                {
                    dbmi.cjBits = ((((uiBitCount * uiWidth) + 31) >> 5) << 2) * yHeight;
                }
            }
            else if (uiCompression == BI_CMYK)
            {
                ASSERTGDI(iUsage == DIB_RGB_COLORS,
                          "psurfCreateDIBSurface(BI_CMYK):iUsage should be DIB_RGB_COLORS\n");

                DCOBJ dcoDest(hdcDest);

                //
                // Current dc context accept CMYK color ?
                //
                if (!dcoDest.bValid() || !dcoDest.pdc->bIsCMYKColor())
                {
                    WARNING1("psurfCreateDIBSurface:DC is not in CMYK color mode for BI_CMYK\n");
                    SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                    bSuccess = FALSE;
                }
                else
                {
                    switch (uiBitCount)
                    {
                    case 1:
                        dbmi.iFormat = BMF_1BPP;
                        cColorsMax   = 2;
                        iPalMode     = PAL_INDEXED;
                        iPalType     = PAL_FREE;
                        break;
                    case 4:
                        dbmi.iFormat = BMF_4BPP;
                        cColorsMax   = 16;
                        iPalMode     = PAL_INDEXED;
                        iPalType     = PAL_FREE;
                        break;
                    case 8:
                        dbmi.iFormat = BMF_8BPP;
                        cColorsMax   = 256;
                        iPalMode     = PAL_INDEXED;
                        iPalType     = PAL_FREE;
                        break;
                    case 32:
                        dbmi.iFormat = BMF_32BPP;
                        cColorsMax   = 0;
                        iPalMode     = PAL_CMYK;
                        iPalType     = PAL_FIXED;
                        break;
                    default:
                        WARNING1("psurfCreateDIBSurfaceAndXform failed invalid bitcount in bmi BI_RGB\n");
                        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                        bSuccess = FALSE;
                    }
                }

                if (bSuccess)
                {
                    dbmi.cjBits = ((((uiBitCount * uiWidth) + 31) >> 5) << 2) * yHeight;
                }
            }
            else
            {
                //
                // rle not supported
                //

                WARNING1("psurfCreateDIBSurfaceAndXform does not support RLE\n");
                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                bSuccess = FALSE;
            }

            if (bSuccess)
            {
                dbmi.cxBitmap   = uiWidth;
                dbmi.cyBitmap   = yHeight;

                ULONG cColors;

                if (uiPalUsed != 0)
                {
                    if (uiPalUsed <= cColorsMax)
                    {
                        cColors = uiPalUsed;
                    }
                    else
                    {
                        cColors = cColorsMax;
                    }
                }
                else
                {
                    cColors = cColorsMax;
                }

                if (cjMaxBits < dbmi.cjBits)
                {
                    WARNING1("psurfCreateDIBSurfaceAndXform failed because of invalid cjMaxBits\n");
                    SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                }
                else
                {
                    PALMEMOBJ palTemp;

                    //
                    // Allocate a palette for this bitmap.
                    //

                    if (!palTemp.bCreatePalette(iPalMode,
                                                cColorsMax,
                                                (PULONG) NULL,
                                                flRed,
                                                flGre,
                                                flBlu,
                                                iPalType
                                               )
                                             )
                    {
                        WARNING1("psurfCreateDIBSurfaceAndXform: Failed palette creation\n");
                        bSuccess = FALSE;
                    }

                    if (bSuccess && palTemp.bValid())
                    {
                        //
                        // need palette, is not locked in!
                        //

                        palTemp.vKeepIt();
                        dbmi.hpal = palTemp.hpal();

                        //
                        // Attempt to allocate the bitmap.
                        //

                        if (!SurfDimoTemp.bCreateDIB(&dbmi,pInitBits))
                        {
                            WARNING("psurfCreateDIBSurfaceAndXform failed bCreateDIB\n");
                            bSuccess = FALSE;
                        }

                        if (bSuccess)
                        {
                            //
                            // Lock the Rao region if we are drawing on a display surface.  The Rao
                            // region might otherwise change asynchronously.  The DEVLOCKOBJ also makes
                            // sure that the VisRgn is up to date, calling the window manager if
                            // necessary to recompute it.  It also protects us from pSurfDest
                            // being changed asynchronously by a dynamic mode change.
                            //

                            DEVLOCKOBJ dlo(dcoDest);

                            SURFACE   *pSurfDest = dcoDest.pSurfaceEff();
                            XEPALOBJ   palDest(pSurfDest->ppal());
                            XEPALOBJ   palDestDC(dcoDest.ppal());

                            switch (iUsage)
                            {
                            case DIB_RGB_COLORS:

                                if (cColors)
                                {
                                    if (cjMaxInfo < (cColors * 4))
                                    {
                                        WARNING1("psurfCreateDIBSurfaceAndXform: failed DIB_RGB_COLORS bmi invalid size\n");
                                        bSuccess = FALSE;

                                        //
                                        // break out of case
                                        //

                                        break;
                                    }
                                    else
                                    {
                                        //
                                        // Copy bitmap color table into palette
                                        //

                                        if (IS_CMYK_BITMAP(uiCompression))
                                        {
                                            palTemp.vCopy_cmykquad(pulColors, 0, cColors);
                                        }
                                        else
                                        {
                                            palTemp.vCopy_rgbquad((RGBQUAD *) pulColors, 0, cColors);
                                        }
                                    }
                                }
                                break;

                            case DIB_PAL_COLORS:

                                {
                                    //
                                    // translate PAL_INDICIES into colors
                                    // from dc palette
                                    //

                                    ULONG palIndex;

                                    PUSHORT pDibPalColor = (PUSHORT)pulColors;

                                    //
                                    // DIB_PAL_COLOR array is direct user input, verify
                                    //

                                    for (palIndex=0;palIndex<cColors;palIndex++)
                                    {
                                        PALETTEENTRY PalEntry;
                                        ULONG TempIndex = pDibPalColor[palIndex];

                                        if (TempIndex > 256)
                                        {
                                            TempIndex = 0;
                                        }

                                        PalEntry = palDestDC.palentryGet(TempIndex);

                                        PalEntry.peFlags = 0;

                                        palTemp.palentrySet(palIndex,PalEntry);
                                    }

                                    palTemp.vUpdateTime();
                                }

                                break;

                                //
                                // error case, don't support DIB_PAL_INDICIES
                                //

                                default:
                                    bSuccess = FALSE;
                            }
                        }
                    }
                }
            }
        }
    }

    if (bSuccess)
    {
        //
        // keep but ref count is 0
        //

        SurfDimoTemp.vKeepIt();

        return(SurfDimoTemp.ps);
    }
    else
    {
        return(NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\debugko.cxx ===
/******************************Module*Header*******************************\
* Module Name: debugko.cxx
*
* Contains compile in routines that match the kernel debugger extensions
*
* Created: 16-jun-1995
* Author: Andre Vachon [andreva]
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"


GDIFunctionIDType UnknownGDIFunc = "Unidentified GDI Function";


#if DBG_BASIC

ULONG GreTraceDisplayDriverLoad = 0;
ULONG GreTraceFontLoad = 0;

LONG gWarningLevel = 0;

// DoWarning1 is for ASM functions to call at Warning Level 1

VOID DoWarning1(PSZ psz)
{
    if (1 <= gWarningLevel)
    {
        DbgPrint("GDI: ");
        DbgPrint(psz);
        DbgPrint("\n");
    }
}

VOID DoWarning(PSZ psz, LONG ulLevel)
{
    if (ulLevel <= gWarningLevel)
    {
        DbgPrint("GDI: ");
        DbgPrint(psz);
        DbgPrint("\n");
    }
}

VOID DoRip(PSZ psz)
{
    if (gWarningLevel >= 0)
    {
        DbgPrint("GDI Assertion: ");
        DbgPrint(psz);
        DbgPrint("\n");
        DbgBreakPoint();
    }
}

VOID DoIDWarning(PCSTR ID, PSZ psz, LONG ulLevel)
{
    if (ulLevel <= gWarningLevel)
    {
        DbgPrint("GDI: ");
        if (ID)
        {
            DbgPrint((PCH)ID);
            DbgPrint(": ");
        }
        DbgPrint(psz);
        DbgPrint("\n");
    }
}

VOID DoIDRip(PCSTR ID, PSZ psz)
{
    if (gWarningLevel >= 0)
    {
        DbgPrint("GDI Assertion: ");
        if (ID)
        {
            DbgPrint((PCH)ID);
            DbgPrint(": ");
        }
        DbgPrint(psz);
        DbgPrint("\n");
        DbgBreakPoint();
    }
}

//
// Font debugging
//

#define dprintf DbgPrint
#include <kdftdbg.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\drawgdi.cxx ===
/******************************Module*Header*******************************\
* Module Name: drawgdi.cxx
*
* Contains all the draw APIs for GDI.
*
* Created: 29-Oct-1990
* Author: J. Andrew Goossen [andrewgo]
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

extern PPEN gpPenNull;
extern PBRUSH gpbrNull;

#include "flhack.hxx"

/******************************Public*Routine******************************\
* LONG lGetQuadrant(eptef)
*
* Returns the quadrant number (0 to 3) of the point.
*
*  22-Aug-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

LONG lGetQuadrant(EPOINTFL& eptef)
{
    LONG lQuadrant = 0;

    if (eptef.y.bIsNegative())
    {
        if (eptef.x.bIsNegative())
        {
            lQuadrant = 2;
        } else {
            lQuadrant = 3;
        }

    } else {

        if ((eptef.x.bIsNegative()) || (eptef.x.bIsZero()))
        {

            lQuadrant = 1;

            //
            // check for case of exactly on -x axis
            //

            if (eptef.y.bIsZero()) {

                lQuadrant = 2;

            }

        }

    }

    return(lQuadrant);
}

/******************************Public*Routine******************************\
* BOOL GreAngleArc (hdc,x,y,ulRadius,eStartAngle,eSweepAngle)
*
* Draws an arc.  Angles are in degrees and are specified in IEEE floating
* point, and not necessarily our own internal representation.
*
* History:
*  Sat 22-Jun-1991 00:34:22 -by- Charles Whitmer [chuckwh]
* Added ATTRCACHE support.
*
*  20-Nov-1990 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GreAngleArc
(
 HDC         hdc,
 int         x,
 int         y,
 ULONG       ulRadius,
 FLOATL      eStartAngle,
 FLOATL      eSweepAngle
)
{
    LONG   lStartQuad;
    LONG   lEndQuad;
    LONG   lSweptQuadrants;
    EFLOAT efEndAngle;

// Lock the DC.

    DCOBJ dco(hdc);

    if (!dco.bValid() || dco.bStockBitmap())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

    // sync user-mode attributes

    SYNC_DRAWING_ATTRS(dco.pdc);

    LONG   lRadius = (LONG) ulRadius;
    ERECTL ercl(x - lRadius, y - lRadius, x + lRadius, y + lRadius);

// Check for overflow of either ulRadius to lRadius conversion or that
// the circle defining the arc extends outside of world space:

    if (lRadius < 0 || ercl.left > x || ercl.right < x
                    || ercl.top > y  || ercl.bottom < y)
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    EXFORMOBJ exo(dco, WORLD_TO_DEVICE);

// Get a path, and notify that we will update the current point:

    PATHSTACKOBJ pso(dco, TRUE);
    if (!pso.bValid())
    {
        return(FALSE);
    }

// Make the rectangle well ordered in logical space:

    ercl.vOrder();

// Convert IEEE floats to our internal representation:

    EFLOAT efStartAngle;
    EFLOAT efSweepAngle;
    efStartAngle = eStartAngle;
    efSweepAngle = eSweepAngle;

// efEndAngle must be more than efStartAngle for 'bPartialArc':

    if (efSweepAngle.bIsNegative())
    {
        register LONG ll;
        SWAPL(ercl.top, ercl.bottom, ll);
        efSweepAngle.vNegate();
        efStartAngle.vNegate();
    }

// Assert: Now efSweepAngle >= 0

    EBOX ebox(exo, ercl);

// A line is always drawn to the first point of the arc:

    PARTIALARC paType = PARTIALARCTYPE_LINETO;

// The arc is swept multiple times if the sweep angle is more than
// 360 degrees.  Because we approximate circles with Beziers,
// arcs of less than 90 degrees are more circular than arcs of 90
// degrees.  Since the resulting curves are different, we can't do
// multiple sweeps by:
//
//      bPartialArc(StartAngle, 360)
//      bEllipse()
//      bPartialArc(0, EndAngle)
//
// Since multiple sweeps will be rare, we don't bother making it
// too efficient.

    EFLOAT efQuadrantsSwept = efSweepAngle;
    efQuadrantsSwept *= FP_1DIV90;
    efQuadrantsSwept.bEfToLTruncate(lSweptQuadrants);

// We arbitrarily limit this to sweeping eight circles (otherwise, if
// someone gave a really big sweep angle we would lock the system for
// a really long time):

    LONG lCirclesSwept = lSweptQuadrants >> 2;
    if (lCirclesSwept > 8)
        lCirclesSwept = 8;

    EPOINTFL eptefStart;
    EPOINTFL eptefEnd;

    EFLOAT efAngleSwept;
    BOOL bAngleSweptIsZero;

    efEndAngle  = efStartAngle;
    efEndAngle += efSweepAngle;

    // ASSERT: efEndAngle >= efStartAngle, since efSweepAngle >= 0.

    // If the difference between efEndAngle and efStartAngle is less than about 3 degrees,
    // then the error in computation of eptefStart and eptefEnd using vCosSin will be enough
    // so that the computation of the Bezier points in bPartialArc (which calls bPartialQuadrantArc)
    // will be noticeably wrong.

    // determine whether (efEndAngle - efStartAngle - 3.0 < 0.0)
    efAngleSwept = efEndAngle;
    efAngleSwept -= efStartAngle;
    bAngleSweptIsZero = efAngleSwept.bIsZero();
    efAngleSwept -= FP_3_0;

    if (efAngleSwept.bIsNegative() && !bAngleSweptIsZero)
    {
        vCosSinPrecise(efStartAngle, &eptefStart.x, &eptefStart.y);
        vCosSinPrecise(efEndAngle, &eptefEnd.x, &eptefEnd.y);
    }
    else
    {
        vCosSin(efStartAngle, &eptefStart.x, &eptefStart.y);
        vCosSin(efEndAngle, &eptefEnd.x, &eptefEnd.y);
    }

    lStartQuad = lGetQuadrant(eptefStart);
    if (efStartAngle > FP_3600_0 || efStartAngle < FP_M3600_0)
    {
        vArctan(eptefStart.x, eptefStart.y, efStartAngle, lStartQuad);
    }

    lEndQuad = lGetQuadrant(eptefEnd);
    if (efEndAngle > FP_3600_0 || efEndAngle < FP_M3600_0)
    {
        vArctan(eptefEnd.x, eptefEnd.y, efEndAngle, lEndQuad);

    // We have to re-count the number of swept quadrants:

        lSweptQuadrants = (lEndQuad - lStartQuad) & 3;
        if ((lSweptQuadrants == 0) && (efStartAngle > efEndAngle))
            lSweptQuadrants = 3;
    }

// Quadrants range from 0 to 3:

    lEndQuad &= 3;
    lStartQuad &= 3;
    lSweptQuadrants &= 3;

    for (LONG ll = 0; ll < lCirclesSwept; ll++)
    {
        if (!bPartialArc(paType, pso, ebox,
                         eptefStart, lStartQuad, efStartAngle,
                         eptefEnd, lEndQuad, efEndAngle,
                         lSweptQuadrants) ||
            !bPartialArc(PARTIALARCTYPE_CONTINUE, pso, ebox,
                         eptefEnd, lEndQuad, efEndAngle,
                         eptefStart, lStartQuad, efStartAngle,
                         3 - lSweptQuadrants))
            return(FALSE);

        paType = PARTIALARCTYPE_CONTINUE;
    }

    if (!bPartialArc(paType, pso, ebox,
                     eptefStart, lStartQuad, efStartAngle,
                     eptefEnd, lEndQuad, efEndAngle,
                     lSweptQuadrants))
        return(FALSE);

// Set the DC's current position in device space.  It would be too much
// work to calculate the world space current position, so simply mark it
// as invalid:

    dco.pdc->vInvalidatePtlCurrent();
    dco.pdc->vValidatePtfxCurrent();
    dco.ptfxCurrent() = pso.ptfxGetCurrent();

// If we're not in an active path bracket, stroke the temporary path
// we created:

    return(dco.pdc->bActive() ||
           pso.bStroke(dco, dco.plaRealize(exo), &exo));
}


/******************************Public*Routine******************************\
* BOOL NtGdiEllipse()
*
* Draws an ellipse in a counter-clockwise direction.
*
* History:
*  20-Nov-1990 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiEllipse(
    HDC hdc,
    int xLeft,
    int yTop,
    int xRight,
    int yBottom
    )
{
    DCOBJ dco(hdc);

    if (!dco.bValid() || dco.bStockBitmap())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

    ERECTL ercl(xLeft, yTop, xRight, yBottom);

// Handle the PS_INSIDEFRAME pen attribute and lower-right exclusion
// by adjusting the box now.  At the same time, get the transform
// type and order the rectangle:

    EXFORMOBJ  exo(dco, WORLD_TO_DEVICE);
    LINEATTRS *pla = dco.plaRealize(exo);

    // sync the client side cached brush

    SYNC_DRAWING_ATTRS(dco.pdc);

// TRUE flag indicates that this is an ellipse, so adjust the bound box
// to make the fill nice:

    EBOX ebox(dco, ercl, pla, TRUE);

    if (ebox.bEmpty())
        return(TRUE);

// Get a path and notify that we won't update the current position:

    PATHSTACKOBJ pso(dco);
    if (!pso.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    if (!bEllipse(pso, ebox))
    {
        return(FALSE);
    }

// If the transform is simple and the path consists entirely of the
// ellipse we just added, we can set the flag indicating that the path
// consists of a single ellipse inscribed in the path's bounding
// rectangle.  (This flag will get reset if anything is added to the
// path later.)

    if (exo.bScale() && pso.cCurves == 5)
        pso.fl |= PO_ELLIPSE;

    if (dco.pdc->bActive())
        return(TRUE);

    BOOL bRet;

    if (!ebox.bFillInsideFrame())
        bRet = pso.bStrokeAndFill(dco, pla, &exo);
    else
    {
    // Handle PS_INSIDEFRAME pen attribute for case when the pen is
    // bigger than the bound box.  We fill the result with the pen
    // brush:

        PBRUSH pbrOldFill = dco.pdc->pbrushFill();
        dco.pdc->pbrushFill(dco.pdc->pbrushLine());
        dco.pdc->flbrushAdd(DIRTY_FILL);
        bRet = pso.bFill(dco);
        dco.pdc->pbrushFill(pbrOldFill);
        dco.pdc->flbrushAdd(DIRTY_FILL);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL NtGdiLineTo (hdc,x,y)
*
* Draws a line from the current position to the specified point.
*
* Current position is used.
*
* History:
*  29-Oct-1990 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY NtGdiLineTo
(
 HDC         hdc,
 int         x,
 int         y
)
{
    FIX     x1;
    FIX     y1;
    FIX     x2;
    FIX     y2;
    ERECTL  rclBounds;
    MIX     mix;
    BOOL    bReturn = TRUE;             // Assume we'll succeed

    XDCOBJ dco(hdc);

    if (dco.bValid())
    {
        if (!dco.bStockBitmap())
        {
            EXFORMOBJ exo(dco, WORLD_TO_DEVICE);

            LINEATTRS* pla = dco.plaRealize(exo);

        // Make sure that the line is solid and cosmetic, that no path is
        // being accumulated in the DC, and that this is not an Info DC
        // or something that has no surface:

            SYNC_DRAWING_ATTRS(dco.pdc);

        // Since we can send down only integer end-points to the driver
        // with DrvLineTo, we go through this special case only if we're
        // not in 'advanced mode' (non-advanced mode supports only integer
        // transforms, for compatibility), or if the current transform
        // does translation only:

            if (!(pla->fl & (LA_STYLED | LA_GEOMETRIC | LA_ALTERNATE)) &&
                !(dco.pdc->bActive()) &&
                (exo.bTranslationsOnly() || (dco.pdc->iGraphicsMode() != GM_ADVANCED)))
            {
            // If it's a device managed surface, call DrvLineTo if it's
            // hooked by the driver, otherwise call DrvStrokePath; if it's
            // an engine managed surface, call DrvLineTo if it's hooked by
            // the driver, otherwise call EngLineTo:

                PDEVOBJ po(dco.hdev());

            // Grab the devlock now so that we can safely get the window
            // origin and look at the surface:

                DEVLOCKOBJ dlo(dco);
                if (dlo.bValid())
                {
                    if (dco.bHasSurface())
                    {
                        // Don't call EngLineTo if the driver doesn't hook DrvLineTo
                        // but does hook DrvStrokePath.

                        SURFACE* pSurfDst = dco.pSurface();

                        PFN_DrvLineTo pfnDrvLineTo = NULL;

                        if (pSurfDst->flags() & HOOK_LINETO)
                        {
                            pfnDrvLineTo = PPFNDRV(po, LineTo);
                        }
                        else if ((pSurfDst->iType() == STYPE_BITMAP) &&
                                 !(pSurfDst->flags() & HOOK_STROKEPATH))
                        {
                            pfnDrvLineTo = EngLineTo;
                        }

                        if (pfnDrvLineTo != NULL)
                        {
                        // We've satisfied all the conditions for DrvLineTo!

                            if (exo.bTranslationsOnly())
                            {
                                LONG xOffset = exo.fxDx() >> 4;
                                LONG yOffset = exo.fxDy() >> 4;

                                x2 = x + xOffset;
                                y2 = y + yOffset;

                                if (dco.pdc->bValidPtlCurrent())
                                {
                                    x1 = dco.ptlCurrent().x + xOffset;
                                    y1 = dco.ptlCurrent().y + yOffset;
                                }
                                else
                                {
                                    x1 = dco.ptfxCurrent().x >> 4;
                                    y1 = dco.ptfxCurrent().y >> 4;
                                }
                            }
                            else
                            {
                                ASSERTGDI(dco.pdc->iGraphicsMode() != GM_ADVANCED,
                                          "Someone changed an 'if'");

                                POINTL aptl[2];

                                aptl[0].x = x;
                                aptl[0].y = y;
                                if (!dco.pdc->bValidPtfxCurrent())
                                {
                                    aptl[1].x = dco.ptlCurrent().x;
                                    aptl[1].y = dco.ptlCurrent().y;

                                    exo.bXform(aptl, 2);

                                    x1 = aptl[1].x;
                                    y1 = aptl[1].y;
                                }
                                else
                                {
                                    exo.bXform(aptl, 1);

                                    x1 = dco.ptfxCurrent().x >> 4;
                                    y1 = dco.ptfxCurrent().y >> 4;
                                }

                                x2 = aptl[0].x;
                                y2 = aptl[0].y;
                            }

                         // Validation to avoid FIX overflow errors.
                         // Input after transformation must be restricted to 27bits.
                         // This is apparently a spec issue.

                            if (!BLTOFXOK(x2)||
                                !BLTOFXOK(y2)) 
                            {
                                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);

                             // The XDCOBJ dco is locked and the destructor does not 
                             // automagically clean up the lock so we do it here.
                            
                                dco.vUnlockFast();
                            
                                return FALSE;
                            }
                    
                        // Remember the new current position, in both logical
                        // space and device space, before applying the window offset:
                        
                            dco.pdc->vCurrentPosition(x, y, x2 << 4, y2 << 4);
                            LONG xOrigin = dco.eptlOrigin().x;
                            LONG yOrigin = dco.eptlOrigin().y;

                            x1 += xOrigin;
                            x2 += xOrigin;
                            y1 += yOrigin;
                            y2 += yOrigin;

                         // parameter validation to avoid sticky overflow errors.
                         // Using BLTOFXOK here is really an overkill - we're trying to 
                         // avoid the +1 below from wrapping and generating a non well-ordered
                         // bounds rectangle. 
                         // Note: the above code adding xOrigin and yOrigin cannot generate
                         // non well-ordered rectangles because of the comparisons below during
                         // the computation of the bound box. This is true even if one of the 
                         // corners wraps and an incorrect bound box is computed (The rect will
                         // be wrong and the line will be wrong too - but they'll match and the
                         // code won't crash with an access violation because a valid clip rect 
                         // will be generated.)

                            if (!BLTOFXOK(x1)||
                                !BLTOFXOK(y1)||
                                !BLTOFXOK(x2)||
                                !BLTOFXOK(y2)) 
                            {
                                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);

                             // We're exiting - undo the current position.
                             // This code should match the undo code just after the call to 
                             // the driver below.
                            
                                dco.pdc->vPtfxCurrentPosition(
                                    (x1 - xOrigin) << 4, (y1 - yOrigin) << 4);       

                             // The XDCOBJ dco is locked and the destructor does not 
                             // automagically clean up the lock so we do it here.
                            
                                dco.vUnlockFast();
                                return FALSE;
                            }


                        // Compute the bound box, remembering that it must be lower-right
                        // exclusive:

                            if (x1 <= x2)
                            {
                                rclBounds.left  = x1;
                                rclBounds.right = x2 + 1;
                            }
                            else
                            {
                                rclBounds.left  = x2;
                                rclBounds.right = x1 + 1;
                            }

                            if (y1 <= y2)
                            {
                                rclBounds.top    = y1;
                                rclBounds.bottom = y2 + 1;
                            }
                            else
                            {
                                rclBounds.top    = y2;
                                rclBounds.bottom = y1 + 1;
                            }

                            if (dco.fjAccum())
                            {
                                // Bounds are accumulated relative to the window origin.
                                // Fortunately, we don't often take this path:

                                ERECTL rclWindow;

                                rclWindow.left   = rclBounds.left   - xOrigin;
                                rclWindow.right  = rclBounds.right  - xOrigin;
                                rclWindow.top    = rclBounds.top    - yOrigin;
                                rclWindow.bottom = rclBounds.bottom - yOrigin;

                                dco.vAccumulate(rclWindow);
                            }

                            if (dco.pdc->pbrushLine() != gpPenNull)
                            {
                                ECLIPOBJ *pco = NULL;

                            // This is a pretty gnarly expression to save a return in here.
                            // Basically pco can be NULL if the rect is completely in the
                            // cached rect in the DC or if we set up a clip object that
                            // isn't empty.

                                if (((rclBounds.left   >= dco.prclClip()->left) &&
                                     (rclBounds.right  <= dco.prclClip()->right) &&
                                     (rclBounds.top    >= dco.prclClip()->top) &&
                                     (rclBounds.bottom <= dco.prclClip()->bottom)) ||
                                    (pco = dco.pco(),
                                     pco->vSetup(dco.prgnEffRao(),rclBounds,CLIP_NOFORCE),
                                     (!pco->erclExclude().bEmpty())))
                                {
                                    EBRUSHOBJ* pebo = dco.peboLine();

                                // We have to make sure that we have a solid pen
                                // for cosmetic lines.  If the pen is dirty, we
                                // may be looking at an uninitialized field, but
                                // that's okay because we'd only be making the pen
                                // dirty again:

                                    if (pebo->iSolidColor == (ULONG) -1)
                                    {
                                        dco.ulDirtyAdd(DIRTY_LINE);
                                    }

                                    if (dco.bDirtyBrush(DIRTY_LINE))
                                    {
                                        dco.vCleanBrush(DIRTY_LINE);

                                        XEPALOBJ palDst(pSurfDst->ppal());
                                        XEPALOBJ palDstDC(dco.ppal());

                                        pebo->vInitBrush(dco.pdc,
                                                         dco.pdc->pbrushLine(),
                                                         palDstDC,
                                                         palDst,
                                                         pSurfDst,
                                                         FALSE);
                                    }

                                // Exclude the pointer:

                                    DEVEXCLUDEOBJ dxo(
                                      dco,
                                      (pco == NULL) ? &rclBounds : &pco->erclExclude(),
                                      pco
                                    );

                                // Update the target surface uniqueness:

                                    INC_SURF_UNIQ(pSurfDst);

                                // No validation has been done on jROP2, so we must
                                // do it here:

                                    mix  = (((MIX) dco.pdc->jROP2() - 1) & 0xf) + 1;
                                    mix |= (mix << 8);

                                    if (!pfnDrvLineTo(pSurfDst->pSurfobj(),
                                                      pco,
                                                      pebo,
                                                      x1,
                                                      y1,
                                                      x2,
                                                      y2,
                                                      &rclBounds,
                                                      mix))
                                    {
                                        // The driver decided to punt.  Make sure
                                        // we undo the current position:

                                        dco.pdc->vPtfxCurrentPosition(
                                            (x1 - xOrigin) << 4, (y1 - yOrigin) << 4);

                                        goto SlowWay;
                                    }
                                }
                                else
                                {
                                // Completely clipped away, so return success.

                                }
                            }
                            else
                            {
                            // Null pens always succeed.

                            }
                        }
                        else
                        {
                        // LineTo isn't hooked:

                            goto SlowWay;

                        }
                    }
                    else
                    {
                    // It's an info DC, so we have no alternative...

                        goto SlowWay;
                    }
                }
                else
                {
                // If we can't grab the devlock, we may be full-screen:

                    bReturn = dco.bFullScreen();
                }

                dco.vUnlockFast();

                return(bReturn);
            }

SlowWay:

        // We have to do it the slow way, by making a path:

            EPOINTL eptl(x, y);

        // Get a path, and notify that we will update the current point:

            {
                PATHSTACKOBJ pso(dco, TRUE);
                if (!pso.bValid())
                {
                    SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
                }
                else
                {
                    if (pso.bPolyLineTo(&exo, &eptl, 1))
                    {
                        dco.pdc->vCurrentPosition(eptl, pso.ptfxGetCurrent());

                        bReturn = (dco.pdc->bActive() ||
                                   pso.bStroke(dco, pla, &exo));
                    }
                }
            }
        }
        else
        {
            SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
            bReturn = FALSE;
        }

        dco.vUnlockFast();
    }
    else
    {
        // We couldn't lock the DC.

        bReturn = FALSE;
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
    }

    return(bReturn);
}

/******************************Public*Routine******************************\
* BOOL GreMoveTo(hdc, x, y, pptl)
*
* Changes the current position.  Optionally returns old current position.
*
* History:
*  29-Oct-1990 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GreMoveTo
(
HDC     hdc,
int     x,
int     y,
LPPOINT pptl
)
{
    XDCOBJ dco(hdc);
    if (dco.bValid())
    {
        if (!dco.bStockBitmap())
        {
            if (pptl != (LPPOINT) NULL)
            {
                if (!dco.pdc->bValidPtlCurrent())
                {
                    ASSERTGDI(dco.pdc->bValidPtfxCurrent(), "Both CPs invalid?");

                    EXFORMOBJ exoDtoW(dco, DEVICE_TO_WORLD);
                    if (!exoDtoW.bValid())
                    {
                        dco.vUnlockFast();
                        return(FALSE);
                    }

                    exoDtoW.bXform(&dco.ptfxCurrent(), &dco.ptlCurrent(), 1);
                }

                *((POINTL*) pptl) = dco.ptlCurrent();
            }

        // Don't bother computing the device-space current position; simply mark
        // it invalid:

            dco.ptlCurrent().x = x;
            dco.ptlCurrent().y = y;
            dco.pdc->vInvalidatePtfxCurrent();
            dco.pdc->vValidatePtlCurrent();

            if (!dco.pdc->bActive())
            {
            // If we're not in a path, we have to reset our style state:

                LINEATTRS* pla = dco.plaRealized();

                if (pla->fl & LA_GEOMETRIC)
                    pla->elStyleState.e = IEEE_0_0F;
                else
                    pla->elStyleState.l = 0L;
            }

            dco.vUnlockFast();
            return(TRUE);
        }
        else
        {
            dco.vUnlockFast();
        }
    }

    SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL GrePolyBezier (hdc,pptl,cptl)
*
* Draw multiple Beziers.  Current position is not used.
*
* History:
*  29-Oct-1990 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GrePolyBezier
(
 HDC         hdc,
 LPPOINT     pptl,
 ULONG       cptl
)
{
    DCOBJ dco(hdc);

    if (!dco.bValid() || dco.bStockBitmap())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

// Number of points must be 1 more than 3 times the number of curves:

    if (cptl < 4 || cptl % 3 != 1)
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

// sync the client side cached brush

    SYNC_DRAWING_ATTRS(dco.pdc);

    EXFORMOBJ exo(dco, WORLD_TO_DEVICE);

// Get a path and notify that we won't update the current position:

    PATHSTACKOBJ pso(dco);
    if (!pso.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    if (!pso.bMoveTo(&exo, (PPOINTL) pptl) ||
        !pso.bPolyBezierTo(&exo, ((PPOINTL) pptl) + 1, cptl - 1))
    {
        return(FALSE);
    }

    return(dco.pdc->bActive() ||
           pso.bStroke(dco, dco.plaRealize(exo), &exo));
}

/******************************Public*Routine******************************\
* BOOL GrePolyBezierTo (hdc,pptl,cptl)
*
* Draws multiple Beziers.  Current position is used and updated.
*
* History:
*  29-Oct-1990 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GrePolyBezierTo
(
 HDC         hdc,
 LPPOINT     pptl,
 ULONG       cptl
)
{
    DCOBJ dco(hdc);

    if (!dco.bValid() || dco.bStockBitmap())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

// Number of points must be 3 times the number of curves:

    if (cptl < 3 || cptl % 3 != 0)
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

// sync the client side cached brush

    SYNC_DRAWING_ATTRS(dco.pdc);

    EXFORMOBJ exo(dco, WORLD_TO_DEVICE);

// Get a path, and notify that we will update the current point:

    PATHSTACKOBJ pso(dco, TRUE);
    if (!pso.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    if (!pso.bPolyBezierTo(&exo, (PPOINTL) pptl, cptl))
        return(FALSE);

    dco.pdc->vCurrentPosition(((POINTL*) pptl)[cptl - 1],
                                pso.ptfxGetCurrent());

    return(dco.pdc->bActive() ||
           pso.bStroke(dco, dco.plaRealize(exo), &exo));
}

/******************************Public*Routine******************************\
* BOOL GrePolyDraw(hdc,pptl,pfj,cptl)
*
* Draw a collection of lines and Bezier curves in a single call.
*
* History:
*  31-Jul-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GrePolyDraw
(
 HDC         hdc,
 LPPOINT     pptl,
 LPBYTE      pfj,
 ULONG       cptl
)
{
// No point in validating pfj[] now because with shared memory
// window, client could trounce on pfj[] between now and when we
// get around to processing it.

    DCOBJ dco(hdc);

    if (!dco.bValid() || dco.bStockBitmap())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

    SYNC_DRAWING_ATTRS(dco.pdc);

// Handle easy case:

    if (cptl == 0)
        return(TRUE);

    EXFORMOBJ exo(dco, WORLD_TO_DEVICE);

// Get a path, and notify that we will update the current point:

    PATHSTACKOBJ pso(dco, TRUE);
    if (!pso.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

// Accumulate the path.

    PBYTE  pfjEnd = pfj + cptl;
    PBYTE  pfjStart;
    SIZE_T cc;
    BOOL   bReturn = FALSE;         // Fail by default

    while (pfj < pfjEnd)
    {
        pfjStart = pfj;
        switch(*pfj++)
        {
        case (PT_LINETO):

        // Collect all the consecutive LineTo's

            while (pfj < pfjEnd && *pfj == PT_LINETO)
                pfj++;

            if (pfj < pfjEnd && (*pfj & ~PT_CLOSEFIGURE) == PT_LINETO)
                pfj++;

        // Now fall through...

        case (PT_LINETO | PT_CLOSEFIGURE):
            cc = (SIZE_T)(pfj - pfjStart);

            // Sundown, pfj will never exceed pfjEnd = pj + cptl where cptl is a
            // ULONG, so it's safe to truncate here.

            if (!pso.bPolyLineTo(&exo, (PPOINTL) pptl, (ULONG)cc))
                return(bReturn);

            pptl += cc;

            if (*(pfj - 1) & PT_CLOSEFIGURE)
                pso.bCloseFigure();

            break;

        case (PT_BEZIERTO):

        // Collect all the consecutive BezierTo's (the first PT_BEZIERTO in
        // a series should never have the PT_CLOSEFIGURE flag set)

            while (pfj < pfjEnd && *pfj == PT_BEZIERTO)
                pfj++;

            if (pfj < pfjEnd && (*pfj & ~PT_CLOSEFIGURE) == PT_BEZIERTO)
                pfj++;

        // The number of BezierTo points must be a multiple of 3

            cc = (SIZE_T)(pfj - pfjStart);
            if (cc % 3 != 0)
            {
                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                return(FALSE);
            }

            //Sundown, safe to truncate here
            if (!pso.bPolyBezierTo(&exo, (PPOINTL) pptl, (ULONG)cc))
                return(bReturn);

            pptl += cc;

            if (*(pfj - 1) & PT_CLOSEFIGURE)
                pso.bCloseFigure();

            break;

        case (PT_MOVETO):
            if (!pso.bMoveTo(&exo, (PPOINTL) pptl))
                return(bReturn);

            pptl++;
            break;

        default:

        // Abort without drawing anything:

            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            return(FALSE);
        }
    }

    dco.pdc->vCurrentPosition(*((POINTL*) pptl - 1),
                                pso.ptfxGetCurrent());

    return(dco.pdc->bActive() ||
           pso.bStroke(dco, dco.plaRealize(exo), &exo));
}

/******************************Public*Routine******************************\
* BOOL GrePolylineTo (hdc,pptl,cptl)
*
* Draw a polyline figure.  Current position is used and updated.
*
* History:
*  29-Oct-1990 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GrePolylineTo
(
 HDC         hdc,
 LPPOINT     pptl,
 ULONG       cptl
)
{
// Lock the DC.

    DCOBJ dco(hdc);

    if (!dco.bValid() || dco.bStockBitmap())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

    SYNC_DRAWING_ATTRS(dco.pdc);

// Return a trivial call.

    if (cptl == 0)
        return(TRUE);

// Locate the current transform.

    EXFORMOBJ exo(dco, WORLD_TO_DEVICE);

// Get a path, and notify that we will update the current point:

    PATHSTACKOBJ pso(dco, TRUE);

// Accumulate the lines.

    if (!pso.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    if (!pso.bPolyLineTo(&exo,(PPOINTL) pptl, cptl))
        return(FALSE);

    dco.pdc->vCurrentPosition(((POINTL*) pptl)[cptl - 1],
                                pso.ptfxGetCurrent());

// Return now if we're in a path bracket, otherwise stroke the line:

    return(dco.pdc->bActive() ||
           pso.bStroke(dco, dco.plaRealize(exo), &exo));
}

/******************************Public*Routine******************************\
* BOOL GrePolyPolygonInternal(hdc,pptl,pcptl,ccptl,cMaxPoints)
*
* Creates multiple polygons.  Current position is not used.
*
* History:
*  29-Oct-1990 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GrePolyPolygonInternal(
    HDC         hdc,
    LPPOINT     pptl,
    LPINT       pcptl,
    int         ccptl,
    UINT        cMaxPoints
)
{
    BOOL bStatus = TRUE;

    DCOBJ dco(hdc);

    if (dco.bValid() && !dco.bStockBitmap())
    {
        //
        // sync the client side cached brush
        //

        SYNC_DRAWING_ATTRS(dco.pdc);

        //
        // quick out on the trivial case
        //

        if (ccptl != 0)
        {
            EXFORMOBJ exo(dco, WORLD_TO_DEVICE);

            //
            // Get a path and notify that we won't update the current position:
            //

            PATHSTACKOBJ pso(dco);
            if (pso.bValid())
            {
                bStatus = bPolyPolygon(pso,
                                       exo,
                                       (PPOINTL) pptl,
                                       (PLONG) pcptl,
                                       (LONG) ccptl,
                                       cMaxPoints);

                if (bStatus)
                {
                    bStatus = (dco.pdc->bActive() ||
                               pso.bStrokeAndFill(dco, dco.plaRealize(exo), &exo));
                }
            }
            else
            {
                SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
                bStatus = FALSE;
            }
        }
    }
    else
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        bStatus = FALSE;
    }
    return(bStatus);
}

/******************************Public*Routine******************************\
* BOOL bMakePathRecords
*
* Constructs an array of pathrecords from a given set of pre-transformed
* polypolyline points.
*
* NOTE: 'pcptl' and 'pptlSrc' are allowed to be user-mode pointers, so this
*       routine may access violate -- in this case, the caller must provide
*       'try/excepts'!
*
* History:
*  24-Sep-1996 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL bMakePathRecords
(
    PATHRECORD* pprThis,            // Destination buffer for pathrecords
    ULONG*      pcptl,              // Pointer to count of polylines
                                    //   Note: Might be user-mode address!
    LONG        cptlRem,            // Maximum number of points allowable
    POINTL*     pptlSrc,            // Pointer to polypolyline points
                                    //   Note: Might be user-mode address!
    ULONG       cpr,                // Count of resulting pathrecords
    LONG        xOffset,            // x-offset in pre-transformed coordinates
    LONG        yOffset,            // y-offset in pre-transformed coordinates
    RECTFX*     prcfxBoundBox,      // Returns bounds of lines
    PATHRECORD**pprLast             // Returns pointer to last pathrecord
)
{
    ULONG       cptl;
    LONG        xBoundLeft;
    LONG        yBoundsTop;
    LONG        xBoundRight;
    LONG        yBoundsBottom;
    BOOL        bRet;
    PATHRECORD* pprPrev;

    bRet = TRUE;                    // Assume success

    xBoundLeft    = LONG_MAX;
    yBoundsTop    = LONG_MAX;
    xBoundRight   = LONG_MIN;
    yBoundsBottom = LONG_MIN;

    pprThis->pprprev = NULL;

    while (TRUE)
    {
    // We have to check 'cptlRem' to be sure that the malevolent
    // application hasn't modified the pcptl array -- we must make
    // sure we don't add any more points than what we allocated
    // (less is okay, though):

        cptl = *pcptl++;
        cptlRem -= cptl;
        if ((cptlRem < 0) || (((LONG) cptl) < 2))
        {
            // We either ran out of buffer space, do not have enough
            // points in the array, or a negative number of points were
            // specified (keep in mind that cptlRem is a LONG, so cptl
            // also needs to be treated as a LONG for the check).

            bRet = FALSE;
            break;
        }

        pprThis->count = cptl;
        pprThis->flags = (PD_BEGINSUBPATH | PD_ENDSUBPATH);
        pprPrev = pprThis;

    // Copy all the points for this pathrecord, and at the same time
    // add in the window offset and collect the bounds:

        do {
            LONG x;
            LONG y;

            x = pptlSrc->x;

            if (x < xBoundLeft)
                xBoundLeft = x;
            if (x > xBoundRight)
                xBoundRight = x;

            pprThis->aptfx[0].x = x + xOffset;

            y = pptlSrc->y;

            if (y < yBoundsTop)
                yBoundsTop = y;
            if (y > yBoundsBottom)
                yBoundsBottom = y;

            pprThis->aptfx[0].y = y + yOffset;

        // For efficiency, we advance 'pprThis' by the size of a point,
        // rather than incuring more cycles to get a pointer directly
        // to the points:

            pprThis = (PATHRECORD*) ((BYTE*) pprThis + sizeof(POINTFIX));
            pptlSrc++;

        } while (--cptl != 0);

        if (--cpr == 0)
            break;

        pprThis = (PATHRECORD*) (pprThis->aptfx);
        pprThis->pprprev = pprPrev;
        pprPrev->pprnext = pprThis;
    }

    if (bRet)
    {
        pprPrev->pprnext = NULL;
        *pprLast = pprPrev;

    // Watch for overflow when we added in 'xOffset' and 'yOffset':

        prcfxBoundBox->xLeft  = xOffset + xBoundLeft;
        prcfxBoundBox->xRight = xOffset + xBoundRight;

        if (xBoundLeft > xBoundRight)
            bRet = FALSE;

        prcfxBoundBox->yTop    = yOffset + yBoundsTop;
        prcfxBoundBox->yBottom = yOffset + yBoundsBottom;

        if (yBoundsTop > yBoundsBottom)
            bRet = FALSE;

    // If 'cptlRem' isn't zero, someone modified the 'pcptl' array while we
    // were looking at it!

        if (cptlRem != 0)
            bRet = FALSE;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL NtGdiFastPolyPolyline(hdc, pptl, pcptl, ccpl)
*
* Fast path for drawing solid, nominal width polylines.  Will return FALSE
* if the fast-path can't be used.
*
* History:
*  29-Oct-1990 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

extern "C" {
    BOOL NtGdiFastPolyPolyline(HDC, CONST POINT*, ULONG*, ULONG);
};

#define POLYBUFFERSIZE 100

BOOL NtGdiFastPolyPolyline
(
 HDC            hdc,
 CONST POINT   *pptl,           // Pointer to user-mode data
 ULONG         *pcptl,          // Pointer to user-mode data
 ULONG          ccptl
)
{
    ULONG   cMaxPoints = 0;
    BOOL    bReturn = FALSE;             // Assume we'll fail

    DCOBJ dco(hdc);
    if (dco.bValid() && !dco.bStockBitmap())
    {
        EXFORMOBJ exo(dco, WORLD_TO_DEVICE);

        LINEATTRS* pla = dco.plaRealize(exo);

        SYNC_DRAWING_ATTRS(dco.pdc);

        if (ccptl != 0)
        {
            __try
            {
                ULONG   i;
                ULONG*  pul;
                ULONG   c;

                if (ccptl <= (MAXULONG/sizeof(ULONG)))
                {
                    ProbeForRead(pcptl, ccptl * sizeof(ULONG), sizeof(BYTE));

                    c = 0;
                    i = ccptl;
                    pul = pcptl;
                    do {

                    // Don't add directly to 'cMaxPoints' here because we're in
                    // a try/except and the compiler can't register 'cMaxPoints'
                    // but can enregister 'c.
                    //
                    // Also note that we do not care if a bad app puts bogus
                    // data in here to cause cMaxPoints to overflow since
                    // code not only uses cMaxPoints to allocate memory, but
                    // also passes it to bXform and bMakePathRecords to
                    // ensure we do not access past the amount allocated.
                    // Furthermore, bMakePathRecords also checks for the
                    // overflow case as it processes each Polyline and
                    // will return failure if it detects the overflow.

                        c += *pul++;

                    } while (--i != 0);

                    if (c <= (MAXULONG/sizeof(POINT)))
                    {
                        ProbeForRead(pptl, c * sizeof(POINT), sizeof(BYTE));

                        // Only set cMaxPoints if no overflows or exceptions
                        // occur.  Otherwise cMaxPoints is zero and test
                        // for cMaxPoints > 0 below will fail.

                        cMaxPoints = c;
                    }
                }
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(5);
            }

        // Watch out for overflow:

            if ((cMaxPoints > 0) &&
                (ccptl      < 0x08000000) &&
                (cMaxPoints < 0x08000000))
            {
            // We handle only solid cosmetic lines in this special case.
            // We don't do styled lines so that we don't have to worry about
            // updating the style state in the DC after the call is done, and
            // we don't have to check for opaque styles (for which we would
            // have to call the driver twice).

                if (!dco.pdc->bActive() &&
                    ((pla->fl & (LA_GEOMETRIC | LA_ALTERNATE)) == 0) &&
                    (pla->pstyle == NULL))
                {
                    LONG        xOffset;
                    LONG        yOffset;
                    BOOL        bIntegers;
                    MIX         mix;
                    ULONG       cjAlloc;
                    EPATHOBJ    epo;
                    PATH        path;
                    PATHRECORD* pprFirst;
                    POINTL*     pptlTransform;
                    union {
                        PATHRECORD  prStackBuffer;
                        BYTE        ajStackBuffer[POLYBUFFERSIZE];
                    };

                    cjAlloc = ccptl * offsetof(PATHRECORD, aptfx)
                            + cMaxPoints * sizeof(POINTFIX);

                    if (cjAlloc > POLYBUFFERSIZE)
                    {
                        pprFirst = (PATHRECORD*) PVALLOCTEMPBUFFER(cjAlloc);
                        if (pprFirst == NULL)
                        {
                        // bReturn is already FALSE

                            return(bReturn);
                        }
                    }
                    else
                    {
                        pprFirst = &prStackBuffer;
                    }

                    DEVLOCKOBJ dlo(dco);
                    if (dlo.bValid())
                    {
                    // Now that we have the devlock, we can safely add in
                    // the window offset:

                        xOffset = dco.eptlOrigin().x;
                        yOffset = dco.eptlOrigin().y;

                        bReturn = TRUE;
                        bIntegers = TRUE;
                        pptlTransform = (POINTL*) pptl;

                        // We don't have to call transform routines if we only 
                        // have a translation.  If we are not in compatible mode
                        // we also require integer translations.

                        if ((!exo.bTranslationsOnly()) ||
                            (dco.pdc->iGraphicsMode() != GM_COMPATIBLE &&
                             ((exo.fxDx() | exo.fxDy()) & (FIX_ONE - 1)) != 0))
                        {
                        // The transform isn't trivial, so call out to transform
                        // all the points.  Rather than allocate yet another
                        // buffer, we stick the transformed points at the end
                        // of our pathrecords buffer.

                            pptlTransform = (POINTL*) ((BYTE*) pprFirst
                                          + cjAlloc
                                          - sizeof(POINTFIX) * cMaxPoints);

                        // Because we're dealing with user-mode buffers for
                        // 'pptl' and 'pcptl', we copy the points under the
                        // protection of a 'try / except'.  'bXform' is
                        // guaranteed to be recoverable:

                            __try
                            {
                                if (dco.pdc->iGraphicsMode() == GM_ADVANCED)
                                {
                                // In advanced mode, the transform can cause
                                // fractional coordinates, so we can't set the
                                // PO_ALL_INTEGERS flag:

                                    bIntegers = FALSE;

                                    // Since we will add DC offsets to the
                                    // path records in bMakePathRecords, 
                                    // just convert to fixed and apply 
                                    // non-translation transformation
                                    // elements here.
                                    bReturn = exo.bXform(
                                                    (VECTORL*) pptl,
                                                    (VECTORFX*) pptlTransform,
                                                    cMaxPoints);

                                    // Convert offsets to fixed point and add 
                                    // translation values
                                    xOffset = LTOFX(xOffset) + exo.fxDx();
                                    yOffset = LTOFX(yOffset) + exo.fxDy();
                                }
                                else
                                {
                                // In compatibility mode, the transform never
                                // causes fractional coordinates, so we can
                                // transform directly to integers and set the
                                // PO_ALL_INTEGERS flag:

                                    bIntegers = TRUE;
                                    bReturn = exo.bXform(
                                                    (POINTL*) pptl,
                                                    (POINTL*) pptlTransform,
                                                    cMaxPoints);
                                }
                            }
                            __except(EXCEPTION_EXECUTE_HANDLER)
                            {
                                bReturn = FALSE;
                            }
                        }
                        else
                        {
                            // Add translation values to offsets applied in 
                            // bMakePathRecords
                            xOffset += FXTOL(exo.fxDx());
                            yOffset += FXTOL(exo.fxDy());
                        }

                        // We special case integer polylines and actually
                        // record integer coordinates in the path instead
                        // of integers.  At bEnum() time we will transform
                        // them to fixed coordinates if the driver doesn't
                        // expect to receive integers.

                        epo.fl = bIntegers ? PO_ALL_INTEGERS : 0;

                        // Because we're dealing with user-mode buffers for
                        // 'pptl' and 'pcptl', we copy the points under the
                        // protection of a 'try / except'.  bMakePathRecord
                        // is guaranteed to be recoverable:

                        __try
                        {
                            bReturn &= bMakePathRecords(
                                            pprFirst,
                                            pcptl,
                                            cMaxPoints,
                                            pptlTransform,
                                            ccptl,
                                            xOffset,
                                            yOffset,
                                            &path.rcfxBoundBox,
                                            &path.pprlast);
                        }
                        __except(EXCEPTION_EXECUTE_HANDLER)
                        {
                            bReturn = FALSE;
                        }

                        // The bound-box was collected in integer coordinates
                        // but has to be fixed:
                        if (bIntegers)
                        {
                            path.rcfxBoundBox.xLeft   <<= 4;
                            path.rcfxBoundBox.xRight  <<= 4;
                            path.rcfxBoundBox.yTop    <<= 4;
                            path.rcfxBoundBox.yBottom <<= 4;
                        }

                        if (!bReturn)
                        {
                            if (pprFirst != &prStackBuffer)
                            {
                                FREEALLOCTEMPBUFFER(pprFirst);
                            }

                            return(bReturn);
                        }

                    // Initialize all the remaining path fields:

                        path.pprfirst    = pprFirst;
                        path.flags       = 0;
                        path.pprEnum     = NULL;
                        epo.cCurves      = cMaxPoints - ccptl;
                        epo.ppath        = &path;

                        ERECTL erclBoundBox(path.rcfxBoundBox);

                    // Make sure the bounds are lower-right exclusive:

                        erclBoundBox.bottom++;
                        erclBoundBox.right++;

                        if (dco.fjAccum())
                        {
                            ERECTL ercl;

                        // Bounds are accumulated relative to the window
                        // origin:

                            ercl.left   = erclBoundBox.left   - dco.eptlOrigin().x;
                            ercl.right  = erclBoundBox.right  - dco.eptlOrigin().x;
                            ercl.top    = erclBoundBox.top    - dco.eptlOrigin().y;
                            ercl.bottom = erclBoundBox.bottom - dco.eptlOrigin().y;

                            dco.vAccumulate(ercl);
                        }

                        if (dco.pdc->pbrushLine() != gpPenNull)
                        {
                            SURFACE* pSurfDst = dco.pSurface();
                            if (pSurfDst != NULL)
                            {
                                XEPALOBJ   palDst(pSurfDst->ppal());
                                XEPALOBJ   palDstDC(dco.ppal());
                                EBRUSHOBJ* pebo = dco.peboLine();

                            // We have to make sure that we have a solid pen
                            // for cosmetic lines.  If the pen is dirty, we
                            // may be looking at an uninitialized field, but
                            // that's okay because we'd only be making the pen
                            // dirty again:

                                if (pebo->iSolidColor == (ULONG) -1)
                                {
                                    dco.ulDirtyAdd(DIRTY_LINE);
                                }

                                if (dco.bDirtyBrush(DIRTY_LINE))
                                {
                                    dco.vCleanBrush(DIRTY_LINE);

                                    pebo->vInitBrush(dco.pdc,
                                                     dco.pdc->pbrushLine(),
                                                     palDstDC, palDst,
                                                     pSurfDst,
                                                     FALSE);
                                }

                            // No validation has been done on jROP2, so we must
                            // do it here:

                                mix  = (((MIX) dco.pdc->jROP2() - 1) & 0xf) + 1;
                                mix |= (mix << 8);

                                ECLIPOBJ eco(dco.prgnEffRao(), erclBoundBox);
                                if (!eco.erclExclude().bEmpty())
                                {
                                    PDEVOBJ pdo(pSurfDst->hdev());

                                // Exclude the pointer:

                                    DEVEXCLUDEOBJ dxo(dco, &eco.erclExclude(), &eco);

                                // Update the target surface uniqueness:

                                    INC_SURF_UNIQ(pSurfDst);

                                    bReturn = (*PPFNGET(pdo, StrokePath, pSurfDst->flags()))
                                                    (
                                                      pSurfDst->pSurfobj(),
                                                      &epo,
                                                      &eco,
                                                      NULL,
                                                      pebo,
                                                      NULL,
                                                      pla,
                                                      mix
                                                    );
                                }
                                else
                                {
                                // Completely clipped away:

                                    bReturn = TRUE;
                                }
                            }
                            else
                            {
                            // When there's no surface pointer, we're drawing to an
                            // INFO DC, or something:

                                bReturn = TRUE;
                            }
                        }
                        else
                        {
                        // Null pens will always succeed:

                            bReturn = TRUE;
                        }
                    }
                    else
                    {
                    // If we can't grab the devlock, it may be because we're
                    // in full-screen:

                        bReturn = dco.bFullScreen();
                    }

                    if (pprFirst != &prStackBuffer)
                    {
                        FREEALLOCTEMPBUFFER(pprFirst);
                    }
                }
            }
        }
        else
        {
        // Trivial case always succeeds:

            bReturn = TRUE;
        }
    }

    return(bReturn);
}

/******************************Public*Routine******************************\
* BOOL GrePolyPolylineInternal(hdc,pptl,pcptl,cptl,cMaxPoints)
*
* Slow way to draw multiple polylines.  Current position is not used.
*
* History:
*  29-Oct-1990 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

#define POLYBUFFERSIZE 100

BOOL APIENTRY GrePolyPolylineInternal
(
 HDC            hdc,
 CONST POINT   *pptl,
 ULONG         *pcptl,
 ULONG          ccptl,
 UINT           cMaxPoints
)
{
    BOOL bReturn = FALSE;             // Assume we'll fail

    DCOBJ dco(hdc);
    if (dco.bValid() && !dco.bStockBitmap())
    {
        EXFORMOBJ exo(dco, WORLD_TO_DEVICE);

        LINEATTRS* pla = dco.plaRealize(exo);

        SYNC_DRAWING_ATTRS(dco.pdc);

        if (ccptl != 0)
        {
        // We'll do it the slow way.  First, get a path and notify that
        // we won't update the current position:

        // Note: This instance of PATHSTACKOBJ takes up a bunch of stack
        //       space that we could share with prStackBuffer is stack
        //       space ever becomes tight.

            PATHSTACKOBJ pso(dco);
            if (!pso.bValid())
            {
                SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
                return(FALSE);
            }

            LONG   cPts;
            ULONG* pcptlEnd = pcptl + ccptl;

            do {

            // We have to be careful to make a local copy of this
            // polyline's point count (by copying it to cPts) to get
            // the value out of the shared client/server memory window,
            // where the app could trash the value at any time:

                cPts = *pcptl;
                cMaxPoints = (UINT) ((LONG) cMaxPoints - cPts);

            // Fail if any polyline is less than 2 points or if we've
            // passed our maximum number of points:

                if ((LONG) cMaxPoints < 0 || cPts < 2)
                {
                    SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                    return(FALSE);
                }

                if (!pso.bMoveTo(&exo, (PPOINTL) pptl) ||
                    !pso.bPolyLineTo(&exo, ((PPOINTL) pptl) + 1, cPts - 1))
                    return(FALSE);

                pptl += cPts;
                pcptl++;

            } while (pcptl < pcptlEnd);

            bReturn = (dco.pdc->bActive() ||
                       pso.bStroke(dco, dco.plaRealize(exo), &exo));

        }
        else
        {
        // Trivial case always succeeds:

            bReturn = TRUE;
        }
    }
    else
    {
        // We couldn't lock the DC.  bReturn is already FALSE.

        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
    }

    return(bReturn);
}

/******************************Public*Routine******************************\
* BOOL NtGdiRectangle()
*
* Draws a rectangle.  Current position is not used.  The rectangle is
* drawn in a counter-clockwise direction.
*
* History:
*  29-Oct-1990 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiRectangle(
    HDC hdc,
    int xLeft,
    int yTop,
    int xRight,
    int yBottom
    )
{
    BOOL        bRet;
    LINEATTRS*  pla;

    DCOBJ dco(hdc);
    if (!dco.bValid() || dco.bStockBitmap())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

    if (MIRRORED_DC(dco.pdc)) 
    {
        // If it a mirrored DC then shift the rect one pixel to the right
        // This will give the effect of including the right edge of the rect and exclude the left edge.
        --xLeft;
        --xRight;
    }
    ERECTL ercl(xLeft, yTop, xRight, yBottom);

// Sync the client side cached brush

    SYNC_DRAWING_ATTRS(dco.pdc);

    EXFORMOBJ exoWorld(dco, WORLD_TO_DEVICE);

    if (exoWorld.bScale() && !dco.pdc->bActive())
    {
    // We try to optimize the simple cases as much as possible.  The first
    // criteria is that there is no funky transform in effect, and the
    // second is that we're not accumulating a path.

        if (dco.pdc->pbrushLine() == gpPenNull)
        {
        // Unfortunately, we have to check here if we have a NULL brush
        // as well:

            if (dco.pdc->pbrushFill() == gpbrNull)
            {
                return(TRUE);
            }

        // When we don't have a pen, we do a simple PatBlt:

            if (dco.pdc->iGraphicsMode() != GM_ADVANCED)
            {
            // Round to the nearest integer if not in advanced mode.

                if (exoWorld.bTranslationsOnly())
                {
                    LONG lOffset;

                    lOffset = FXTOLROUND(exoWorld.fxDx());
                    ercl.left   += lOffset;
                    ercl.right  += lOffset;

                    lOffset = FXTOLROUND(exoWorld.fxDy());
                    ercl.top    += lOffset;
                    ercl.bottom += lOffset;
                }
                else
                {
                    ASSERTGDI(exoWorld.bScale(), "Fast path can't do weird xforms");

                    ercl.left   = FXTOLROUND(exoWorld.fxFastX(ercl.left));
                    ercl.right  = FXTOLROUND(exoWorld.fxFastX(ercl.right));
                    ercl.top    = FXTOLROUND(exoWorld.fxFastY(ercl.top));
                    ercl.bottom = FXTOLROUND(exoWorld.fxFastY(ercl.bottom));
                }

                ercl.vOrder();

            // If we're not in advanced mode, figures are lower-right
            // exclusive, so we have to adjust the rectangle:

                ercl.right--;
                ercl.bottom--;
            }
            else
            {
                if (exoWorld.bTranslationsOnly())
                {
                    LONG lOffset;

                    lOffset = FXTOLCEILING(exoWorld.fxDx());
                    ercl.left   += lOffset;
                    ercl.right  += lOffset;

                    lOffset = FXTOLCEILING(exoWorld.fxDy());
                    ercl.top    += lOffset;
                    ercl.bottom += lOffset;
                }
                else
                {
                    ASSERTGDI(exoWorld.bScale(), "Fast path can't do weird xforms");

                    ercl.left   = FXTOLCEILING(exoWorld.fxFastX(ercl.left));
                    ercl.right  = FXTOLCEILING(exoWorld.fxFastX(ercl.right));
                    ercl.top    = FXTOLCEILING(exoWorld.fxFastY(ercl.top));
                    ercl.bottom = FXTOLCEILING(exoWorld.fxFastY(ercl.bottom));
                }

                ercl.vOrder();
            }

            if (ercl.bWrapped())
                return(TRUE);

            return(GreRectBlt(dco, &ercl));
        }

        pla = dco.plaRealize(exoWorld);
        if (!(pla->fl & LA_GEOMETRIC))
        {
        // We handle here the case where we draw the outline with a pen.

            BYTE rpo[sizeof(RECTANGLEPATHOBJ)];

        // NOTE: For compatibility with Win3.1, we round the points to
        // integer coordinates.  If we didn't do this, the rectangle outline
        // would be rendered according to GIQ, and could have pixels
        // 'missing' in the corners if the corners didn't end on integers.

            if (dco.pdc->iGraphicsMode() != GM_ADVANCED)
            {
                if (exoWorld.bTranslationsOnly())
                {
                    LONG lOffset;

                    lOffset = FXTOLROUND(exoWorld.fxDx());
                    ercl.left   += lOffset;
                    ercl.right  += lOffset;

                    lOffset = FXTOLROUND(exoWorld.fxDy());
                    ercl.top    += lOffset;
                    ercl.bottom += lOffset;
                }
                else
                {
                    ASSERTGDI(exoWorld.bScale(), "Fast path can't do weird xforms");

                    ercl.left   = FXTOLROUND(exoWorld.fxFastX(ercl.left));
                    ercl.right  = FXTOLROUND(exoWorld.fxFastX(ercl.right));
                    ercl.top    = FXTOLROUND(exoWorld.fxFastY(ercl.top));
                    ercl.bottom = FXTOLROUND(exoWorld.fxFastY(ercl.bottom));
                }

                ercl.vOrder();

            // If we're not in advanced mode, figures are lower-right
            // exclusive, so we have to adjust the rectangle.

                ercl.right--;
                ercl.bottom--;
                if ((ercl.left > ercl.right) || (ercl.top > ercl.bottom))
                    return(TRUE);
            }
            else
            {
                if (exoWorld.bTranslationsOnly())
                {
                    LONG lOffset;

                    lOffset = FXTOLCEILING(exoWorld.fxDx());
                    ercl.left   += lOffset;
                    ercl.right  += lOffset;

                    lOffset = FXTOLCEILING(exoWorld.fxDy());
                    ercl.top    += lOffset;
                    ercl.bottom += lOffset;
                }
                else
                {
                    ASSERTGDI(exoWorld.bScale(), "Fast path can't do weird xforms");

                    ercl.left   = FXTOLCEILING(exoWorld.fxFastX(ercl.left));
                    ercl.right  = FXTOLCEILING(exoWorld.fxFastX(ercl.right));
                    ercl.top    = FXTOLCEILING(exoWorld.fxFastY(ercl.top));
                    ercl.bottom = FXTOLCEILING(exoWorld.fxFastY(ercl.bottom));
                }

                ercl.vOrder();
            }

            ((RECTANGLEPATHOBJ*) &rpo)->vInit(&ercl, dco.pdc->bClockwise());

        // An important feature is to not draw the interior when we've
        // got a NULL brush:

            if (dco.pdc->pbrushFill() != gpbrNull)
            {
            // For compatibility, we also have to shrink the fill rectangle
            // on the top and left sides when we don't have a NULL pen
            // (this matters for some ROPs and styled pens):

                ercl.left++;
                ercl.top++;

                if (!ercl.bWrapped() && !GreRectBlt(dco, &ercl))
                    return(FALSE);
            }

            return(((RECTANGLEPATHOBJ*) &rpo)->bStroke(dco, pla, NULL));
        }
    }

// Now cover the cases we haven't handled.

// We may have not realize the LINEATTRS yet, so make sure we do now (it
// will early-out if we have already realized it):

    pla = dco.plaRealize(exoWorld);

    EBOX ebox(dco, ercl, pla);
    if (ebox.bEmpty())
        return(TRUE);

// Get a path and add to it:

    PATHSTACKOBJ pso(dco);
    if (!pso.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    if (!pso.bMoveTo((EXFORMOBJ*) NULL, &ebox.aeptl[0])        ||
        !pso.bPolyLineTo((EXFORMOBJ*) NULL, &ebox.aeptl[1], 3) ||
        !pso.bCloseFigure())
    {
        return(FALSE);
    }

    if (dco.pdc->bActive())
        return(TRUE);

    if (!ebox.bFillInsideFrame())
    {

    // Rectangles created with old-style pens always have miter joins:

        ULONG iSaveJoin = pla->iJoin;

        if (((PPEN)dco.pdc->pbrushLine())->bIsOldStylePen())
        {
            pla->iJoin = JOIN_MITER;
        }

        bRet = pso.bStrokeAndFill(dco, pla, &exoWorld);

        pla->iJoin = iSaveJoin;
    }
    else
    {
    // Handle PS_INSIDEFRAME pen attribute for case when the pen is
    // bigger than the bound box.  We fill the result with the pen
    // brush:

        PBRUSH pbrOldFill = dco.pdc->pbrushFill();
        dco.pdc->pbrushFill(dco.pdc->pbrushLine());
        dco.pdc->flbrushAdd(DIRTY_FILL);
        bRet = pso.bFill(dco);
        dco.pdc->pbrushFill(pbrOldFill);
        dco.pdc->flbrushAdd(DIRTY_FILL);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL NtGdiRoundRect (hdc,x1,y1,x2,y2,x3,y3)
*
* Draws a rounded rectangle in a counter-clockwise direction.
*
* History:
*  20-Nov-1990 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiRoundRect(
    HDC hdc,
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3
    )
{
    // If either axis of the ellipse is zero, then we'll be outputing
    // a rectangle.  We do this check here and not in 'bRoundRect'
    // because Rectangle needs the DC (for checking for the fast rectangle
    // condition).

    // Note that for compatibility with Win3, this must be here!  Zero-size
    // ellipse roundrects created with old-style pens must have miter joins,
    // and Rectangle will take care of that:

    if (x3 == 0 || y3 == 0)
        return(NtGdiRectangle(hdc,x1,y1,x2,y2));

    DCOBJ dco(hdc);
    if (!dco.bValid() || dco.bStockBitmap())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

    // Sync the client side cached brush

    SYNC_DRAWING_ATTRS(dco.pdc);

    ERECTL ercl(x1, y1, x2, y2);

    EXFORMOBJ exo(dco, WORLD_TO_DEVICE);

    EBOX ebox(dco, ercl, dco.plaRealize(exo), TRUE);
    if (ebox.bEmpty())
        return(TRUE);

    // Get a path and notify that we won't update the current position:

    PATHSTACKOBJ pso(dco);
    if (!pso.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    if (!bRoundRect(pso, ebox, x3, y3))
        return(FALSE);

    if (dco.pdc->bActive())
        return(TRUE);

    BOOL bRet;

    if (!ebox.bFillInsideFrame())
        bRet = pso.bStrokeAndFill(dco, dco.plaRealize(exo), &exo);
    else
    {
    // Handle PS_INSIDEFRAME pen attribute for case when the pen is
    // bigger than the bound box.  We fill the result with the pen
    // brush:

        PBRUSH pbrOldFill = dco.pdc->pbrushFill();
        dco.pdc->pbrushFill(dco.pdc->pbrushLine());
        dco.pdc->flbrushAdd(DIRTY_FILL);
        bRet = pso.bFill(dco);
        dco.pdc->pbrushFill(pbrOldFill);
        dco.pdc->flbrushAdd(DIRTY_FILL);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* bSyncBrushObj()
*
*   This routine just makes sure that the kernel brush matches the user mode
*   brush.
*
* History:
*  19-Jul-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL bSyncBrushObj(
    PBRUSH pbrush)
{
    BOOL bRet = TRUE;

    if (pbrush)
    {
        PBRUSHATTR pBrushattr = pbrush->pBrushattr();

        //
        // if the brush handle is a cached solid brush,
        // call GreSetSolidBrushInternal to change the color
        //

        if (pBrushattr->AttrFlags & ATTR_NEW_COLOR)
        {
            //
            // set the new color for the cached brush
            //

            if (!GreSetSolidBrushLight(pbrush,pBrushattr->lbColor,pbrush->bIsPen()))
            {
                WARNING1("GreSyncbrush failed to setsolidbrushiternal\n");
                bRet = FALSE;
            }
            else
            {
                pBrushattr->AttrFlags &= ~ATTR_NEW_COLOR;
            }
        }
    }

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\drvobj.cxx ===
/******************************Module*Header*******************************\
* Module Name: drvobj.cxx
*
* DRVOBJ object code.  The DRVOBJ is an engine object which tracks
* driver managed pre-process resource that need to be freed upon
* client-side process termination.
*
* Created: 18-Jan-1994 19:27:17
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1994-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

/******************************Public*Routine******************************\
* EngCreateDriverObj
*
* Allocate an object that will be own by the process and cleaned up at
* process termination if it's still left around.
*
* History:
*  18-Jan-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

HDRVOBJ APIENTRY EngCreateDriverObj(PVOID pvObj, FREEOBJPROC pFreeObjProc, HDEV hdev)
{
    HDRVOBJ hdoRet = (HDRVOBJ) 0;
    PDRVOBJ pdo = (PDRVOBJ) ALLOCOBJ(sizeof(DRVOBJ), DRVOBJ_TYPE, FALSE);

    if (pdo != (PDRVOBJ) NULL)
    {
        PDEVOBJ po(hdev);

        pdo->pvObj     = pvObj;
        pdo->pFreeProc = pFreeObjProc;
        pdo->hdev      = hdev;
        pdo->dhpdev    = po.dhpdev();
        pdo->Process   = PsGetCurrentProcess();

        hdoRet = (HDRVOBJ) HmgInsertObject((HOBJ) pdo, 0, DRVOBJ_TYPE);


        if (hdoRet != (HDRVOBJ) 0)
        {
            // Don't free the PDEV until the DRIVEROBJ is destroyed.

            po.vReferencePdev();
        }
        else
        {
            WARNING("EngCreateDriverObj(): HmgInsertObject failed\n");
            FREEOBJ(pdo, DRVOBJ_TYPE);
        }
    }
    else
    {
        WARNING("EngCreateDriverObj(): ALLOCOBJ failed\n");
    }

    return(hdoRet);
}

/******************************Public*Routine******************************\
* EngLockDriverObj
*
* This grabs an exclusive lock on this object for the calling thread.
* This will fail if the handle is invalid, the object is already locked
* by another thread, or the caller isn't the correct PID (the PID that
* created the object).
*
* History:
*  31-May-1994 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

DRIVEROBJ * APIENTRY EngLockDriverObj(HDRVOBJ hdo)
{
    DRIVEROBJ *pDriverObj = NULL;

    DRVOBJ *pdo = (DRVOBJ *) HmgLock((HOBJ) hdo, DRVOBJ_TYPE);

    if (pdo)
    {
        PDEVOBJ po(pdo->hdev);
        ASSERTGDI(po.bValid(), "Expected a valid hdev");

        //
        // Since a DRVOBJ is derived from a DRIVEROBJ, this automatically
        // points to the DRIVEROBJ part of the object:
        //

        pDriverObj = pdo;
    }

    return(pDriverObj);
}

/******************************Public*Routine******************************\
* EngUnlockDriverObj
*
* Unlocks the handle.  Note this call assumes the handle passed in is
* valid, if it isn't we are in big trouble, the handle table will be
* corrupted, a particular object will have its lock count messed up
* making it undeletable.
*
* History:
*  31-May-1994 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL APIENTRY EngUnlockDriverObj(HDRVOBJ hdo)
{
    //
    // Note to be paranoid we could lock it again and if that succeeds
    // unlock it twice to make the engine immune to hosed up drivers.
    //

    PBYTE pjTemp = (PBYTE) HmgLock((HOBJ) hdo, DRVOBJ_TYPE);

    ASSERTGDI(pjTemp != NULL, "ERROR EngUnlockDriverObj failed - bad handle, driver error");

    if (pjTemp)
    {
        DEC_EXCLUSIVE_REF_CNT(pjTemp);
        DEC_EXCLUSIVE_REF_CNT(pjTemp);
        return(TRUE);
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* EngDeleteDriverObj
*
* This is called by the driver to delete the handle it created for the
* object it created.
*
* Deletes the DRVOBJ.  The FreeObjProc in the DRVOBJ is optionally called
* before the DRVOBJ is freed.
*
* Returns:
*   TRUE if sucessful, FALSE otherwise.
*
* History:
*  18-Jan-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY EngDeleteDriverObj(HDRVOBJ hdo, BOOL bCallFreeProc, BOOL bLocked)
{
    GDIFunctionID(EngDeleteDriverObj);

    PDRVOBJ pdo;
    DRIVEROBJ *pDriverObj;

    if (pdo = (PDRVOBJ) HmgLock((HOBJ) hdo, DRVOBJ_TYPE))
    {
        PDEVOBJ po(pdo->hdev);
        BOOL bDeleteOK = TRUE; 
        ASSERTGDI(po.bValid(), "Expected valid hdev");

        pDriverObj = pdo;

        if (bCallFreeProc)
        {
            ASSERTGDI(PsGetCurrentProcess() == pdo->Process,
                "Unexpected process context for clean-up");

            GreAcquireSemaphoreEx(po.hsemDevLock(), SEMORDER_DEVLOCK, NULL);
            bDeleteOK = (*pdo->pFreeProc)(pDriverObj);
            GreReleaseSemaphoreEx(po.hsemDevLock());
        }

        if(bDeleteOK)
        {
            PDRVOBJ pdoTemp;
            if ((pdoTemp = (PDRVOBJ) HmgRemoveObject((HOBJ) hdo, bLocked ? 2 : 1, 0, TRUE, DRVOBJ_TYPE)) != NULL)
            {
                po.vUnreferencePdev();
                FREEOBJ(pdoTemp, DRVOBJ_TYPE);
                return(TRUE);
            }
            else
            {
                WARNING("HmgRemoveObject failed\n");
            }
        }
        else
        {
            WARNING("Driver failed to delete the object\n");
        }

        DEC_EXCLUSIVE_REF_CNT(pdo);
    }
    else
    {
        WARNING("Failed to lock hdo\n");
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\drawattr.cxx ===
/******************************Module*Header*******************************\
* Module Name: drawattr.cxx
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

extern DC_ATTR DcAttrDefault;

/******************************Public*Routine******************************\
* GreSetROP2
*
* Set the foreground mix mode.  Return the old foreground mode or 0 if
* hdc is invalid.
*
* History:
*  Thu 25-Nov-1993 -by- Patrick Haluptzok [patrickh]
* Smaller code.
*
*  28-Nov-1990 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

ULONG GreSetROP2(HDC hdc,int iROP)
{
    ULONG iOldROP = 0;
    XDCOBJ dco(hdc);

    if (dco.bValid())
    {
        iOldROP = dco.pdc->jROP2();
        dco.pdc->jROP2((BYTE)iROP);
        dco.vUnlockFast();
    }

    return(iOldROP);
}


/******************************Public*Routine******************************\
* GreGetBkColor
*
* Get the back ground color.  Return CLR_INVALID if invalid hdc.
*
* History:
*  Thu 25-Nov-1993 -by- Patrick Haluptzok [patrickh]
* Smaller code.
*
*  28-Nov-1990 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

COLORREF GreGetBkColor(HDC hdc)
{
    GDITraceHandle(GreGetBkColor, "(%X)\n", (va_list)&hdc, hdc);

    COLORREF clrRet = CLR_INVALID;

    XDCOBJ dco(hdc);

    if (dco.bValid())
    {
        clrRet = dco.pdc->ulBackClr();
        dco.vUnlockFast();
    }

    return(clrRet);
}

/******************************Public*Routine******************************\
* GreSetBkColor
*
* Set the back ground color.
*
* History:
*  Thu 25-Nov-1993 -by- Patrick Haluptzok [patrickh]
* smaller, don't dirty brush unnecesarily.
*
*  28-Nov-1990 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

COLORREF GreSetBkColor(HDC hdc,COLORREF cr)
{
    GDITrace(GreSetBkColor, "(%X, %X)\n", (va_list)&hdc);

    COLORREF crOld = CLR_INVALID;

    XDCOBJ dco(hdc);

    if (dco.bValid())
    {
        crOld = dco.pdc->ulBackClr();
        dco.pdc->ulBackClr(cr);

        cr &= 0x13ffffff;

        if (cr != crOld)
        {
            dco.pdc->crBackClr(cr);
            dco.pdc->ulDirtyAdd(DIRTY_FILL|DIRTY_LINE|DIRTY_BACKGROUND);
        }
        dco.vUnlockFast();
    }

    GDITrace(GreSetBkColor, " returns %X\n", (va_list)&crOld);

    return(crOld);
}

/******************************Public*Routine******************************\
* GreSetGraphicsMode
*
* Set graphics mode to default or advanced.
*
* History:
*  3-11-94 -by- Lingyun Wang [lingyunw]
* moved client side attr to server side
*
*  Thu 25-Nov-1993 -by- Patrick Haluptzok [patrickh]
* Smaller code.
*
*  19-Oct-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

int GreSetGraphicsMode(HDC hdc, int iMode)
{
    ULONG ulModeOld = 0;

    XDCOBJ dco(hdc);

    if (dco.bValid())
    {
        ulModeOld = dco.pdc->iGraphicsMode();

        if ((iMode == GM_COMPATIBLE) || (iMode == GM_ADVANCED))
        {
            dco.pdc->iGraphicsMode(iMode);
        }
        else
        {
            WARNING("GreSetGraphicsMode passed invalid mode");
        }
        dco.vUnlockFast();
    }

    return((int)ulModeOld);
}


/******************************Public*Routine******************************\
* GreGetBkMode
*
* Get the background mix mode.
*
* History:
*
*  Thu 25-Nov-1993 -by- Patrick Haluptzok [patrickh]
* Smaller code.
*
*  28-Nov-1990 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int GreGetBkMode(HDC hdc)
{
    ULONG ulRet = 0;

    XDCOBJ dco(hdc);
    if (dco.bValid())
    {
        ulRet = dco.pdc->lBkMode();
        dco.vUnlockFast();
    }

    return((int)ulRet);
}

/******************************Public*Routine******************************\
* GreSetBkMode
*
* Set the background mix mode.  This must be either OPAQUE or TRANSPARENT.
* If it is not one of these values or the hdc is invalid, return 0.
* If it is a valid mode, return the old mode in the dc.
*
* History:
* 3-Nov-1994 -by- Lingyun Wang [lingyunw]
* Moved client side BkMode to Server side
*
*  Thu 25-Nov-1993 -by- Patrick Haluptzok [patrickh]
* Smaller code.
*
*  28-Nov-1990 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int GreSetBkMode(HDC hdc,int iBkMode)
{
    ULONG ulBkModeOld = 0;

    XDCOBJ dco(hdc);
    if (dco.bValid())
    {
        ulBkModeOld = dco.pdc->lBkMode();
        dco.pdc->lBkMode(iBkMode);

        if ((iBkMode != OPAQUE) && (iBkMode != TRANSPARENT))
        {
            iBkMode = TRANSPARENT;
            WARNING("ulBkModeOld passed bad mode\n");
        }

        dco.pdc->jBkMode((BYTE)iBkMode);
        dco.vUnlockFast();

    }
    return((int)ulBkModeOld);
}


/******************************Public*Routine******************************\
* GreSetPolyFillMode
*
* Set the polyline fill mode to either ALTERNATE or WINDING.  Any other
* value is invalid and causes an error to be returned.  An error is also
* returned if hdc is invalid.
* If successful, return the old fill mode.
*
* History:
*  Thu 25-Nov-1993 -by- Patrick Haluptzok [patrickh]
* Smaller code.
*
*  28-Nov-1990 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

ULONG GreSetPolyFillMode(HDC hdc, int iPolyFillMode)
{
    ULONG ulPolyFillModeOld = 0;

    XDCOBJ dco(hdc);
    if (dco.bValid())
    {
        ulPolyFillModeOld = dco.pdc->lFillMode();
        dco.pdc->lFillMode(iPolyFillMode);

        if (iPolyFillMode != WINDING)
        {
            iPolyFillMode = ALTERNATE;
            WARNING("GreSetPolyFillMode passed bad mode");
        }
        dco.pdc->jFillMode((BYTE)iPolyFillMode);

        dco.vUnlockFast();
    }
    return(ulPolyFillModeOld);
}


/******************************Public*Routine******************************\
* GreSetStretchBltMode
*
* Set the current stretch blt mode.  iStretchMode must be one of:
*     BLACKONWHITE
*     COLORONCOLOR
*     WHITEONBLACK
*     HALFTONE
*
* If hdc is invalid or iStretchMode is not one of the above, 0 is returned.
* Otherwise, the old stretch blt mode value is returned.
*
* History:
* 3-11-94 -by- Lingyun Wang [lingyunw]
* Moved client side attr to server side
*
*  Thu 25-Nov-1993 -by- Patrick Haluptzok [patrickh]
* Smaller code.
*
*  Tue 28-May-1991 -by- Patrick Haluptzok [patrickh]
* fixed return value bug, rewrote to compile smaller by nesting
*
*  28-Nov-1990 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int GreSetStretchBltMode(HDC hdc, int iStretchMode)
{
    ULONG ulStretchModeOld = 0;

    XDCOBJ dco(hdc);
    if (dco.bValid())
    {
        ulStretchModeOld = dco.pdc->lStretchBltMode();
        dco.pdc->lStretchBltMode(iStretchMode);

        if (iStretchMode > MAXSTRETCHBLTMODE)
        {
            iStretchMode = (DWORD) WHITEONBLACK;
            WARNING("GreSetStretchBltMode passed bad mode");
        }

        dco.pdc->jStretchBltMode((BYTE)iStretchMode);
        dco.vUnlockFast();
    }
    return((int)ulStretchModeOld);
}

/******************************Public*Routine******************************\
* GreGetTextColor
*
* Get the current text color.
*
* History:
*  Thu 25-Nov-1993 -by- Patrick Haluptzok [patrickh]
* Smaller code.
*
*  28-Nov-1990 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

COLORREF GreGetTextColor(HDC hdc)
{
    COLORREF clr = CLR_INVALID;

    XDCOBJ dco(hdc);
    if (dco.bValid())
    {
        clr = dco.pdc->ulTextClr();
        dco.vUnlockFast();
    }

    return(clr);
}

/******************************Public*Routine******************************\
* GreSetTextColor
*
* Set the current text color.
*
* History:
*  Thu 25-Nov-1993 -by- Patrick Haluptzok [patrickh]
* Smaller code.
*
*  28-Nov-1990 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

COLORREF GreSetTextColor(HDC hdc, COLORREF cr)
{
    COLORREF  crOld = CLR_INVALID;

    XDCOBJ dco(hdc);
    if (dco.bValid())
    {
        crOld = dco.pdc->ulTextClr();
        dco.pdc->ulTextClr(cr);

        cr &= 0x13ffffff;

        if (cr != crOld)
        {
            dco.pdc->crTextClr(cr);
            dco.pdc->ulDirtyAdd(DIRTY_FILL|DIRTY_LINE|DIRTY_TEXT);
        }
        dco.vUnlockFast();
    }

    return(crOld);
}

/******************************Public*Routine******************************\
* GreGetFillBrush
*
*   Return the fill brush of the DC
*
* Arguments:
*
*   hdc
*
* Return Value:
*
*   hbrush or NULL
*
\**************************************************************************/

extern "C"
HBRUSH
GreGetFillBrush(HDC hdc)
{
    HBRUSH hbrRet = NULL;

    XDCOBJ dcobj(hdc);

    if (dcobj.bValid())
    {
        hbrRet = (HBRUSH)(dcobj.pdc->pbrushFill())->hGet();
        dcobj.vUnlockFast();
    }


    return(hbrRet);
}






=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\draweng.cxx ===
/******************************Module*Header*******************************\
* Module Name: draweng.cxx
*
* Internal helper functions for GDI draw calls.
*
* Created: 19-Nov-1990
* Author: J. Andrew Goossen [andrewgo]
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

#include "flhack.hxx"

#if DBG

    LONG lConv(EFLOAT ef)
    {
        LONG l;
        ef *= FP_1000_0;
        ef.bEfToL(l);
        return(l);
    }

#endif

/******************************Public*Routine******************************\
* EFLOAT efHalfDiff(a, b)
*
* Computes (a - b) / 2 without overflow or loss of precision.
*
* History:
*  19-Nov-1990 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

inline EFLOAT efHalfDiff(LONG a, LONG b)
{
    EFLOATEXT efResult((a >> 1) - (b >> 1));

    if ((a ^ b) & 1)
    {
        if (a & 1)
            efResult += FP_0_5;
        else
            efResult -= FP_0_5;
    }

    return(efResult);
}

/******************************Public*Routine******************************\
* EFLOAT efMid(a, b)
*
* Computes (a + b) / 2 without overflow or loss of precision.  Note that
* we can't convert 'a' and 'b' to floats and then add them because we're
* not guaranteed that an 'EFLOAT' will have a mantissa with more than
* the 32 bit precision of a LONG.
*
* History:
*  19-Nov-1990 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

inline EFLOAT efMid(LONG a, LONG b)
{
    return(efHalfDiff(a, -b));
}

/******************************Public*Routine******************************\
* EFLOAT efHalf(ul)
*
* Compute half of 'ul' without overflow or loss of precision.
*
* History:
*  19-Nov-1990 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

inline EFLOAT efHalf(ULONG ul)
{
    EFLOATEXT efResult((LONG) (ul >> 1));

    if (ul & 1)
        efResult += FP_0_5;

    return(efResult);
}


/******************************Public*Routine******************************\
* VOID vHalf(ptl)
*
* Halves the given vector.  Rounds .5 fractions up.  Assumes it's in FIX
* format so that we don't have to worry about overflow.
*
* History:
*  19-Dec-1990 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

inline VOID vHalf(POINTL& ptl)
{
    ptl.x = (ptl.x + 1) >> 1;
    ptl.y = (ptl.y + 1) >> 1;
}


/******************************Public*Routine******************************\
* EBOX::EBOX(ercl)
*
* EBOX Constructor for figures created by Create-region APIs.
*
* History:
*  19-Nov-1990 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

EBOX::EBOX(ERECTL& ercl, BOOL bFillEllipse)
{
    ercl.vOrder();

    rclWorld = ercl;
    bIsEmpty = FALSE;
    bIsFillInsideFrame = FALSE;

// Do the Win3 silliness and make the box lower-right exclusive
// (remember that regions are already lower-right exclusive, so this
// will double the exclusiveness...)

    aeptl[0].x = LTOFX(ercl.right - 1);
    aeptl[0].y = LTOFX(ercl.top);
    aeptl[2].x = LTOFX(ercl.left);
    aeptl[2].y = LTOFX(ercl.bottom - 1);

// If this will be a filled ellipse, we bump up the size in all
// dimensions to get a nicer looking fill:

    if (bFillEllipse)
    {
        aeptl[0].x += GROW_ELLIPSE_SIZE - LTOFX(1);
        aeptl[0].y -= GROW_ELLIPSE_SIZE;
        aeptl[2].x -= GROW_ELLIPSE_SIZE;
        aeptl[2].y += GROW_ELLIPSE_SIZE - LTOFX(1);
    }

    aeptl[1].y = aeptl[0].y;
    aeptl[1].x = aeptl[2].x;
    aeptl[3].x = aeptl[0].x;
    aeptl[3].y = aeptl[2].y;

    eptlA.x = ((aeptl[0].x - aeptl[1].x) + 1) >> 1;
    eptlA.y = 0;
    eptlB.x = 0;
    eptlB.y = ((aeptl[1].y - aeptl[2].y) + 1) >> 1;

    eptlOrigin = aeptl[2];
    eptlOrigin += eptlA;
    eptlOrigin += eptlB;
}


/******************************Public*Routine******************************\
* EBOX::EBOX(exo, rcl)
*
* EBOX Constructor for figures that don't need lower-right exclusion and
* PS_INSIDEFRAME functionality.  Rectangle must already be well-ordered
* so that (top, left) is the upper-left corner of the box when
* the World-to-Page transform is identity and the rectangle is transformed
* to device coordinates.
*
* History:
*  19-Nov-1990 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

EBOX::EBOX(
EXFORMOBJ& exo,
RECTL&     rcl)
{
    rclWorld = rcl;
    bIsEmpty = FALSE;
    bIsFillInsideFrame = FALSE;

    aeptl[0].x = rcl.right;
    aeptl[0].y = rcl.top;
    aeptl[1].x = rcl.left;
    aeptl[1].y = rcl.top;
    aeptl[2].x = rcl.left;
    aeptl[2].y = rcl.bottom;

    exo.bXformRound(aeptl, (PPOINTFIX) aeptl, 3);

    eptlA =  aeptl[0];
    eptlA -= aeptl[1];

    eptlB =  aeptl[1];
    eptlB -= aeptl[2];

    aeptl[3] = aeptl[2];
    aeptl[3] += eptlA;

    vHalf(eptlA);
    vHalf(eptlB);

    eptlOrigin = aeptl[2];
    eptlOrigin += eptlA;
    eptlOrigin += eptlB;
}

/******************************Public*Routine******************************\
* EBOX::EBOX(dco, rclBox, pla, bFillEllipse)
*
* Constructor for figures that need lower-right exclusion and
* PS_INSIDEFRAME functionality.
*
* History:
*  19-Nov-1990 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

EBOX::EBOX(DCOBJ& dco, RECTL& rclBox, LINEATTRS *pla, BOOL bFillEllipse)
{
    rclWorld = rclBox;
    bIsEmpty = FALSE;
    bIsFillInsideFrame = FALSE;

    //Shift the rect one pixcel if the dc is mirrored
    if (MIRRORED_DC(dco.pdc)) {
        --rclWorld.left;
        --rclWorld.right;
    }
    if (dco.pdc->iGraphicsMode() == GM_ADVANCED)
    {
    // If we're in advanced mode, we always draw counterclockwise in
    // logical space:

        ((ERECTL*)&rclWorld)->vOrder();
    }
    else
    {
        register LONG lTmp;

    // Win3 always draws counterclockwise in device space; this means
    // we might be drawing clockwise in logical space.  We have to be
    // compatible.
    //
    // There is the additional problem that metafiles may apply a
    // rotating transform on top; we have to correctly rotate the Win3
    // result
    //
    // Order the points so that with an identity world-to-page transform,
    // the drawing direction will always be counterclockwise (or clock-
    // wise, if the DC bit is set) in device space, regardless of the
    // page-to-device transform (Win3 always draws counterclockwise):

        if ((dco.pdc->befM11IsNegative() && (rclWorld.left < rclWorld.right)) ||
            (!dco.pdc->befM11IsNegative() && (rclWorld.left > rclWorld.right)))
        {
           SWAPL(rclWorld.left, rclWorld.right, lTmp);
        }

        if ((dco.pdc->befM22IsNegative() && (rclWorld.top < rclWorld.bottom)) ||
            (!dco.pdc->befM22IsNegative() && (rclWorld.top > rclWorld.bottom)))
        {
           SWAPL(rclWorld.bottom, rclWorld.top, lTmp);
        }
    }

// To simplify things, we've assumed we'll be drawing counter-clockwise
// (in logical space if in Advanced mode, in device space if in Compatibility
// mode).  We now check the SetArcDirection setting; if it says to draw
// clockwise we merely have to flip our bound box upside down:

    if (dco.pdc->bClockwise())
    {
        register LONG lTmp;
        SWAPL(rclWorld.top, rclWorld.bottom, lTmp);
    }

    ERECTL ercl(rclWorld);

// It was decided that the PS_INSIDEFRAME attribute of the
// pen current when the call is done is to be used.  That is,
// when accumulating a path, the pen that is current when the
// figure call is done is used for PS_INSIDEFRAME; all other
// pen attributes of the path come from the pen that is active
// when the path is stroked or filled.

    PPEN ppen = (PPEN) dco.pdc->pbrushLine();

    EXFORMOBJ exo(dco, WORLD_TO_DEVICE);

    BOOL bInsideFrame = (ppen->bIsInsideFrame() && (pla->fl & LA_GEOMETRIC));

    if (bInsideFrame)
    {
    // We have to be careful of overflow because we're dealing with
    // world space coordinates, which may use all 32 bits:

        EFLOAT efHalfPen = efHalf(ppen->lWidthPen());
        EFLOAT efdx = efHalfDiff(ercl.left, ercl.right);
        EFLOAT efdy = efHalfDiff(ercl.top,  ercl.bottom);
        efdx.vAbs();
        efdy.vAbs();

    // PS_INSIDEFRAME is plain dumb.  What happens when the bounding
    // box is smaller in dimension than the width of the pen?  For
    // Ellipses, Rectangles and RoundRects, we'll Fill instead of
    // StrokeAndFill'ing.  (Do nothing if this occurs for Arcs, Chords
    // or Pies, just like Win3 does.)

        if (efHalfPen > efdx || efHalfPen > efdy)
        {
            bIsFillInsideFrame = TRUE;
            bInsideFrame = FALSE;
        }
    }

// In Win3, figures are lower-right exclusive in device space.  This
// convention is hard to maintain with the introduction of arbitrary
// affine transforms (like rotations).  If the GraphicsMode has been
// set to advanced, or we're doing an PS_INSIDEFRAME pen, we're
// lower-right inclusive; otherwise we're lower-right exclusive.
//
// The metafile code is able to set a world transform without going
// to advanced mode, so we check for that too:

    if (dco.pdc->iGraphicsMode() == GM_ADVANCED ||
        bInsideFrame                              ||
        bIsFillInsideFrame                        ||
        dco.pdc->flXform() & WORLD_TRANSFORM_SET)
    {
    // We're lower-right inclusive:

        aeptl[0].x = ercl.right;
        aeptl[0].y = ercl.top;
        aeptl[1].x = ercl.left;
        aeptl[1].y = ercl.top;
        aeptl[2].x = ercl.left;
        aeptl[2].y = ercl.bottom;

        exo.bXformRound(aeptl, (PPOINTFIX) aeptl, 3);

    // HEURISTIC:  For a filled ellipse, if the corners of the bound
    // box are on the integer grid, we expand it a bit so that we get
    // a nicer, more symmetric fill according to our filling conventions:

        if (bFillEllipse && ppen->flStylePen() == PS_NULL &&
            ((aeptl[0].x | aeptl[0].y | aeptl[2].x | aeptl[2].y) &
             (LTOFX(1) - 1)) == 0)
        {
            register LONG lDelta;

            lDelta = (aeptl[0].x > aeptl[2].x) ?
                     GROW_ELLIPSE_SIZE :
                    -GROW_ELLIPSE_SIZE;

            aeptl[0].x += lDelta;
            aeptl[1].x -= lDelta;
            aeptl[2].x -= lDelta;

            lDelta = (aeptl[2].y > aeptl[0].y) ?
                     GROW_ELLIPSE_SIZE :
                    -GROW_ELLIPSE_SIZE;

            aeptl[0].y -= lDelta;
            aeptl[1].y -= lDelta;
            aeptl[2].y += lDelta;
        }
    }
    else
    {
    // Since the DC is not lower right inclusive, it means that we
    // have a simple transform: scaling and translation only.

        exo.bXformRound((PPOINTL) &ercl, (PPOINTFIX) &ercl, 2);

        LONG cShrink = LTOFX(1);

    // HEURISTIC:  For a filled ellipse, if the corners of the bound
    // box are on the integer grid, we expand it a bit so that we get
    // a nicer, more symmetric fill according to our filling conventions:

        if (bFillEllipse && ppen->flStylePen() == PS_NULL &&
            (((ercl.right | ercl.bottom | ercl.left | ercl.top) &
              (LTOFX(1) - 1)) == 0))
        {
            register LONG lDelta;

            lDelta = (ercl.right > ercl.left) ?
                     GROW_ELLIPSE_SIZE :
                    -GROW_ELLIPSE_SIZE;

            ercl.right  += lDelta;
            ercl.left   -= lDelta;

            lDelta = (ercl.bottom > ercl.top) ?
                     GROW_ELLIPSE_SIZE :
                    -GROW_ELLIPSE_SIZE;

            ercl.top    -= lDelta;
            ercl.bottom += lDelta;

        // We have to shrink by two pixels to be more compatible with Win3
        // in this case:

            cShrink = LTOFX(2);
        }

        LONG dx = ercl.right  - ercl.left;
        LONG dy = ercl.bottom - ercl.top;

        if (ABS(dx) < cShrink || ABS(dy) < cShrink)
        {
            bIsEmpty = TRUE;
            return;
        }

    // Shrink the bounding box for the lower-right exclusivity.

        if (dx > 0)
            ercl.right -= cShrink;
        else
            ercl.left -= cShrink;

        if (dy > 0)
            ercl.bottom -= cShrink;
        else
            ercl.top -= cShrink;

    //     It makes no sense to do this when accumulating a path:
    //     when the path is to be converted to a region, we have
    //     no idea what orientation of the transform is.  That is,
    //     we can't be sure what sides to push in (we have no idea
    //     what the transform will be when the region is painted or
    //     whatever).  Oh well: win3.x compatibility rules!

        aeptl[0].x = ercl.right;
        aeptl[0].y = ercl.top;
        aeptl[1].x = ercl.left;
        aeptl[1].y = ercl.top;
        aeptl[2].x = ercl.left;
        aeptl[2].y = ercl.bottom;
    }

// Widelines in Win3 are so broken that it's unclear if the
// PS_INSIDEFRAME adjustment takes lower-right exclusion into
// account.  We let the region lower-right exclusion take care
// of it.

    if (bInsideFrame)
    {
    // We handle the PS_INSIDEFRAME attribute by shrinking the
    // bound box by half the pen width on all sides.  This must
    // be done in device space, otherwise we would lose accuracy.
    //
    // As such, the box is now only a parallelogram as it may
    // have been sheered, etc., and so we must push in the corners
    // using vectors.

        EAPOINTL avecCorner[2];

        avecCorner[1].x = avecCorner[1].y = ppen->lWidthPen();

    // Orient the world space vector avecCorner[1] so that in world space
    // it points from the top, left corner of the bound box towards
    // the center of the box:

        if (rclWorld.right < rclWorld.left)
            avecCorner[1].x = -avecCorner[1].x;

        if (rclWorld.bottom < rclWorld.top)
            avecCorner[1].y = -avecCorner[1].y;

    // Now set avecCorner[0] so that in world space it points from the
    // top, right corner of the bound box towards the center:

        avecCorner[0].x = -avecCorner[1].x;
        avecCorner[0].y =  avecCorner[1].y;

    // This transform shouldn't fail because we've already stripped
    // the MSBs of ptlPen:

        exo.bXform((PVECTORL) avecCorner, (PVECTORFX) avecCorner, 2);

    // We push in the box by only half the pen width, so halve the
    // corner vectors:

        vHalf(avecCorner[0]);
        vHalf(avecCorner[1]);

    // We push in all the corners of the bound box by the corner vectors:

        aeptl[0] += avecCorner[0];
        aeptl[1] += avecCorner[1];
        aeptl[2] -= avecCorner[0];
    }

    eptlA =  aeptl[0];
    eptlA -= aeptl[1];

    eptlB =  aeptl[1];
    eptlB -= aeptl[2];

    aeptl[3] = aeptl[2];
    aeptl[3] += eptlA;

    vHalf(eptlA);
    vHalf(eptlB);
    eptlOrigin = aeptl[2];
    eptlOrigin += eptlA;
    eptlOrigin += eptlB;
}


/******************************Public*Routine******************************\
* EBOX::ptlXform(ptef)
*
* Transforms a point constructed on the unit circle centered at the
* origin to the ellipse described by the bounding box.
*
*                              (A.x       A.y     )
*            (x' y') = (x y 1) (B.x       B.y     )
*                              (Origin.x  Origin.y)
*
* History:
*  19-Nov-1990 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

POINTL EBOX::ptlXform(EPOINTFL& ptef)
{
    EPOINTL eptl;

    EFLOATEXT efTerm1(eptlA.x);
    EFLOATEXT efTerm2(eptlB.x);
    efTerm1 *= ptef.x;
    efTerm2 *= ptef.y;
    efTerm1 += efTerm2;
    efTerm1.bEfToL(eptl.x);

    efTerm1 = eptlA.y;
    efTerm2 = eptlB.y;
    efTerm1 *= ptef.x;
    efTerm2 *= ptef.y;
    efTerm1 += efTerm2;
    efTerm1.bEfToL(eptl.y);

    eptl += eptlOrigin;

    return(eptl);
}

/******************************Public*Routine******************************\
* VOID vArctan(x, y, efTheta, lQuadrant)
*
* Returns the Arctangent angle in degrees.  Uses a look-up table with
* linear interpolation.  Accuracy is kinda good, I guess, with a table
* size of 32.  Returns the quadrant of the angle (0 through 3).
*
* History:
*  Wed 23-Oct-1991 09:39:21 by Kirk Olynyk [kirko]
* This routine is now used in FONTMAP.CXX. Please be careful when
* modifying.
*  19-Nov-1990 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

const BYTE gajArctanQuadrant[] = { 0, 1, 3, 2, 0, 1, 3, 2 };

VOID vArctan
(
 EFLOAT  x,
 EFLOAT  y,
 EFLOAT& efTheta,
 LONG&   lQuadrant
)
{
    LONG lOctant = 0;

    if (x.bIsNegative())
    {
        x.vNegate();
        lOctant |= NEGATE_X;
    }
    if (y.bIsNegative())
    {
        y.vNegate();
        lOctant |= NEGATE_Y;
    }
    if (y > x)
    {
        EFLOAT ef = x;
        x = y;
        y = ef;
        lOctant |= SWITCH_X_AND_Y;
    }

// If x == 0 and y == 0, Arctan is undefined.  May as well return 0.

    if (x.bIsZero())
    {
        efTheta = FP_0_0;
        lQuadrant = 0;
        return;
    }

// Calculate efIndex = (y / x) * ARCTAN_TABLE_SIZE:

    EFLOAT efIndex = y;
    efIndex *= FP_ARCTAN_TABLE_SIZE;
    efIndex /= x;

// lIndex = floor(efIndex):

    LONG lIndex;
    efIndex.bEfToLTruncate(lIndex);

// efDelta = fraction(efIndex):

    EFLOAT efDelta;
    efIndex.vFraction(efDelta);

    ASSERTGDI(lIndex >= 0 && lIndex <= ARCTAN_TABLE_SIZE + 1,
           "Arctan: Index out of bounds\n");
    ASSERTGDI(!efDelta.bIsNegative() && FP_1_0 > efDelta,
           "Arctan: Delta out of bounds\n");

// gaefArctan has an extra 0 at the end of the table so that
// calculations for slope == 1 don't require special case code.
//
//    efTheta = gaefArctan[lIndex]
//            + efDelta * (gaefArctan[lIndex + 1] - gaefArctan[lIndex]):

    efTheta = gaefArctan[lIndex + 1];
    efTheta -= gaefArctan[lIndex];
    efTheta *= efDelta;
    efTheta += gaefArctan[lIndex];

    switch (lOctant)
    {
        case OCTANT_1:
        {
            efTheta.vNegate();
            efTheta += FP_90_0;
            break;
        }
        case OCTANT_2:
        {
            efTheta += FP_90_0;
            break;
        }
        case OCTANT_3:
        {
            efTheta.vNegate();
            efTheta += FP_180_0;
            break;
        }
        case OCTANT_4:
        {
            efTheta += FP_180_0;
            break;
        }
        case OCTANT_5:
        {
            efTheta.vNegate();
            efTheta += FP_270_0;
            break;
        }
        case OCTANT_6:
        {
            efTheta += FP_270_0;
            break;
        }
        case OCTANT_7:
        {
            efTheta.vNegate();
            efTheta += FP_360_0;
            break;
        }
    }

    ASSERTGDI(!efTheta.bIsNegative() && efTheta <= FP_360_0,
              "Arctan: Weird result\n");

    lQuadrant = (LONG) gajArctanQuadrant[lOctant];
    return;
}


/******************************Public*Routine******************************\
* EFLOAT efSin(efTheta)
*
* Returns the Sine of efTheta, which is specified in degrees.  Uses
* a look-up table with linear interpolation for the approximation.
* It is accurate to within 0.02% using a table size of 32.
*
* History:
*  19-Nov-1990 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

EFLOAT efSin(EFLOAT efTheta)
{
    BOOL      bNegate = FALSE;
    EFLOATEXT efResult;

// Use property that Sin(-x) = -Sin(x):

    if (efTheta.bIsNegative())
    {
        bNegate = TRUE;
        efTheta.vNegate();
    }

// efIndex = (efTheta / 90) * SINE_TABLE_SIZE:

    EFLOAT efIndex = efTheta;
    efIndex *= FP_SINE_FACTOR;

// Use floor of efIndex to compute table index:

    LONG lIndex;
    efIndex.bEfToLTruncate(lIndex);

// efDelta is used for the linear interpolation:

    EFLOAT efDelta;
    efIndex.vFraction(efDelta);

// Compute the quadrant (0 to 3) in which the angle is:

    LONG lQuadrant = lIndex >> SINE_TABLE_POWER;

// Use property that Sin(180 + x) = -Sin(x):

    if (lQuadrant & 2)
        bNegate = !bNegate;

    if (lQuadrant & 1)
    {
    // Use property that Sin(90 + x) = Sin(90 - x):

        lIndex = SINE_TABLE_SIZE - (lIndex & SINE_TABLE_MASK);

    // efResult = gaefSin[lIndex]
    //          - efDelta * (gaefSin[lIndex] - gaefSin[lIndex - 1]):

        efResult = gaefSin[lIndex];
        efResult -= gaefSin[lIndex - 1];
        efResult *= efDelta;
        efResult.vNegate();
        efResult += gaefSin[lIndex];
    }
    else
    {
        lIndex &= SINE_TABLE_MASK;

    // efResult = gaefSin[lIndex]
    //          + efDelta * (gaefSin[lIndex + 1] - gaefSin[lIndex]):

        efResult = gaefSin[lIndex + 1];
        efResult -= gaefSin[lIndex];
        efResult *= efDelta;
        efResult += gaefSin[lIndex];
    }

    if (bNegate)
        efResult.vNegate();

    return (efResult);
}


/******************************Public*Routine******************************\
* EFLOAT efCos(efTheta)
*
* Returns the Cosine of efTheta, which is specified in degrees.
*
* Note: Because of rounding errors, for very large values of efTheta,
*       it's possible that the value returned from efCos(efTheta) is
*       approximately that returned from efSin(efTheta).
*
* History:
*  19-Nov-1990 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

EFLOAT efCos(EFLOAT efTheta)
{
    efTheta += FP_90_0;
    return(efSin(efTheta));
}


/******************************Public*Routine******************************\
* VOID vCosSin(efTheta, pefCos, pefSin)
*
* Returns the Cosine and Sine of efTheta, which is specified in degrees.
* Uses a look-up table with linear interpolation for the approximation.
* It is accurate to within 0.02% using a table size of 32.
*
* Unlike separately calling efCos(efTheta) and efSin(efTheta), this function
* will at least guarantee that the returned point is on the unit circle.
* However, for APIs such as Arc() and AngleArc(), the error in the computation
* will be far enough off the unit circle so that those APIs don't function
* correctly.  In those cases where even a small error can be significant, one
* should use vCosSinPrecise() to get an exact computation (to within the precision
* of a float) of sine and cosine.
*
* History:
*  5-May-1993 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vCosSin(EFLOAT efTheta, EFLOAT* pefCos, EFLOAT* pefSin)
{
    BOOL      bNegate = FALSE;
    EFLOATEXT efResult;
    LONG      lTmpIndex;

// ------------------------------------------------------------------
// Handle setup common to both Sin and Cos.

// Use property that Sin(-x) = -Sin(x):

    if (efTheta.bIsNegative())
    {
        bNegate = TRUE;
        efTheta.vNegate();
    }

// efIndex = (efTheta / 90) * SINE_TABLE_SIZE:

    EFLOAT efIndex = efTheta;
    efIndex *= FP_SINE_FACTOR;

// Use floor of efIndex to compute table index:

    LONG lIndex;
    efIndex.bEfToLTruncate(lIndex);

// efDelta is used for the linear interpolation:

    EFLOAT efDelta;
    efIndex.vFraction(efDelta);

// Compute the quadrant (0 to 3) in which the angle is:

    LONG lQuadrant = lIndex >> SINE_TABLE_POWER;

// ------------------------------------------------------------------
// Now handle Sin(efTheta).

// Use property that Sin(180 + x) = -Sin(x):

    if (lQuadrant & 2)
        bNegate = !bNegate;

    if (lQuadrant & 1)
    {
    // Use property that Sin(90 + x) = Sin(90 - x):

        lTmpIndex = SINE_TABLE_SIZE - (lIndex & SINE_TABLE_MASK);

    // efResult = gaefSin[lTmpIndex]
    //          - efDelta * (gaefSin[lTmpIndex] - gaefSin[lTmpIndex - 1]):

        efResult = gaefSin[lTmpIndex];
        efResult -= gaefSin[lTmpIndex - 1];
        efResult *= efDelta;
        efResult.vNegate();
        efResult += gaefSin[lTmpIndex];
    }
    else
    {
        lIndex &= SINE_TABLE_MASK;

    // efResult = gaefSin[lIndex]
    //          + efDelta * (gaefSin[lIndex + 1] - gaefSin[lIndex]):

        efResult = gaefSin[lIndex + 1];
        efResult -= gaefSin[lIndex];
        efResult *= efDelta;
        efResult += gaefSin[lIndex];
    }

    if (bNegate)
        efResult.vNegate();

    *pefSin = efResult;

// ------------------------------------------------------------------
// Now handle Cos(efTheta).

// Since Cos(-x) = Cos(x), bNegate is always initially false:

    bNegate = FALSE;

// We use the property that Cos(x) = Sin(x + 90) to convert the
// problem to determining the Sine again:

    lQuadrant++;

// Use property that Sin(180 + x) = -Sin(x):

    if (lQuadrant & 2)
        bNegate = !bNegate;

    if (lQuadrant & 1)
    {
    // Use property that Sin(90 + x) = Sin(90 - x):

        lTmpIndex = SINE_TABLE_SIZE - (lIndex & SINE_TABLE_MASK);

    // efResult = gaefSin[lTmpIndex]
    //          - efDelta * (gaefSin[lTmpIndex] - gaefSin[lTmpIndex - 1]):

        efResult = gaefSin[lTmpIndex];
        efResult -= gaefSin[lTmpIndex - 1];
        efResult *= efDelta;
        efResult.vNegate();
        efResult += gaefSin[lTmpIndex];
    }
    else
    {
        lIndex &= SINE_TABLE_MASK;

    // efResult = gaefSin[lIndex]
    //          + efDelta * (gaefSin[lIndex + 1] - gaefSin[lIndex]):

        efResult = gaefSin[lIndex + 1];
        efResult -= gaefSin[lIndex];
        efResult *= efDelta;
        efResult += gaefSin[lIndex];
    }

    if (bNegate)
        efResult.vNegate();

    *pefCos = efResult;
}


/******************************Public*Routine******************************\
* VOID vCosSinPrecise(efTheta, pefCos, pefSin)
*
* Returns the Cosine and Sine of efTheta, which is specified in degrees.
* This function should be used when more precision is needed than vCosSin
* can provide.
*
* This function uses the Taylor (actually MacLaurin) expansion of
* sin x and cos x out to (NUM_TERMS / 2) terms, where x is in radians.
* The MacLaurin expansions are:
*
* cos x = 1 - (x^2)/2! + (x^4)/4! - (x^6)/6! + ... + (-1)^n (x^(2n))/(2n)! + ...
* sin x = x - (x^3)/3! + (x^5)/5! - (x^7)/7! + ... + (-1)^n (x^(2n+1))/(2n+1)! + ...
*
* The result will have error no more than the next term that would have been computed
* (since it is an alternating and converging series.
* If x is between 0 and pi/2, then if NUM_TERMS = 13, the error (assuming the
* floating point compuations are exact) is no more than 5.7e-08, which is less than
* the precision of an IEEE floating point number (23 bits of precision).
*
* History:
*  19-Feb-1999 -by- Donald Chinn [dchinn]
* Wrote it.
\**************************************************************************/

#define NUM_TERMS 13
VOID vCosSinPrecise(EFLOAT efTheta, EFLOAT* pefCos, EFLOAT* pefSin)
{
    EFLOAT efTemp, efTemp2;     // temporaries for intermediate calculation
    BOOL bThetaIsNegative = FALSE;
    BOOL bThetaIsGr180 = FALSE;
    BOOL bThetaIsGr90 = FALSE;

    ULONG i;
    EFLOAT efThetaRadians;      // theta in radians
    EFLOAT efCosResult;
    EFLOAT efSinResult;
    EFLOAT efI;                 // used to hold the floating point value of i during expansion
    EFLOAT efThetaRadiansPow;   // used to hold (efThetaRadians)^i during expansion
    EFLOAT efFactorial;         // used to hold i! during expansion
    EFLOAT efTerm;              // used to hold +/- (efThetaRadians)^i / (i!)


    // sin(x) = - sin(-x)
    // cos(x) =   cos(-x)
    if (efTheta.bIsNegative())
    {
        bThetaIsNegative = TRUE;
        efTheta.vNegate();
    }

    // ASSERT: efTheta >= 0

    // sin(x) = sin(x + 360*i), for all integers i.  (x in degrees)
    // cos(x) = cos(x + 360*i), for all integers i.
    efTemp = efTheta;
    efTemp /= FP_360_0;
    efTemp.vFraction(efTemp2);

    efTheta = efTemp2;
    efTheta *= FP_360_0;

    // ASSERT: 0 <= efTheta < 360

    // if 0 <= x <= 360 (x in degrees), then
    // sin(x) = - sin(360 - x)
    // cos(x) =   cos(360 - x).

    // if efTheta > 180, then set  efTheta = 360 - efTheta.
    efTemp = FP_180_0;
    efTemp -= efTheta;
    if (efTemp.bIsNegative())
    {
        bThetaIsGr180 = TRUE;
        efTemp = FP_360_0;
        efTemp -= efTheta;
        efTheta = efTemp;
    }

    // ASSERT: 0 <= efTheta <= 180

    // if 0 <= x <= 180 (x in degrees), then
    // sin(x) =   sin(180 - x)
    // cos(x) = - cos(180 - x).

    // if efTheta > 90, then set  efTheta = 180 - efTheta.
    efTemp = FP_90_0;
    efTemp -= efTheta;
    if (efTemp.bIsNegative())
    {
        bThetaIsGr90 = TRUE;
        efTemp = FP_180_0;
        efTemp -= efTheta;
        efTheta = efTemp;
    }

    // ASSERT: 0 <= efTheta <= 90

    // convert input angle from degrees to radians
    // efThetaRadians = efTheta * PI / 180;
    efThetaRadians = efTheta;
    efThetaRadians *= FP_PI;
    efThetaRadians /= FP_180_0;

    // first term of the MacLaurin expansion
    efCosResult = FP_1_0;
    efSinResult = efThetaRadians;

    // later terms in the MacLaurin expansion
    // in this loop, i corresponds to the term +/- (efThetaRadians)^i/(i!)
    for (i = 2, efI = FP_2_0, efFactorial = FP_2_0, efThetaRadiansPow = efThetaRadians;
         i < NUM_TERMS;
         i++, efI += FP_1_0, efFactorial *= efI)
    {
        // compute (efThetaRadians)^i
        efThetaRadiansPow *= efThetaRadians;

        // ASSERT: at this point, i, efI, efThetaRadiansPow, and efFactorial are all consistent

        // compute the i-th term
        efTerm = efThetaRadiansPow;
        efTerm /= efFactorial;

        // sign of the term -- the pattern is:
        // if i == 2 or 3, then the sign is negative;
        // if i == 4 or 5, then the sign is positive;
        // etc. (the pattern repeats every two values of i)
        if ((i / 2) % 2)
        {
            // i/2 is odd -- sign is negative
            efTerm.vNegate();
        }

        // add the term to the appropriate expansion
        if (i % 2)
        {
            // i is odd -- add to the sine expansion
            efSinResult += efTerm;
        }
        else
        {
            // i is even -- add to the cosine expansion
            efCosResult += efTerm;
        }

    }

    // Adjust the sign of the result
    if ((bThetaIsNegative && !bThetaIsGr180) ||
        (!bThetaIsNegative && bThetaIsGr180))
    {
        efSinResult.vNegate();
    }

    if (bThetaIsGr90)
    {
        efCosResult.vNegate();
    }

    *pefCos = efCosResult;
    *pefSin = efSinResult;
}


/******************************Public*Routine******************************\
* BOOL bPartialQuadrantArc(paType, epo, ebox, efStartAngle, efEndAngle)
*
* Constructs a partial arc of 90 degrees or less using an approximation
* technique by Kirk Olynyk.  The arc is approximated by a cubic Bezier.
* Optionally draws a line to the first point.
*
* Restrictions:
*
*    efEndAngle must be within 90 degrees of efStartAngle.
*
* Steps in constructing the curve:
*
*    1) Construct the conic section at the origin for the unit circle;
*    2) Approximate this conic by a cubic Bezier;
*    3) Scale and translate result.
*
* 1)  Constructing the Conic
*
*       'efStartAngle' and 'efEndAngle' determine the end-points of the
*       conic (call them vectors from the origin, A and C).  We need the
*       middle vector B and the sharpness to completely determine the
*       conic.
*
*       For the portion of a circular arc that is 90 degrees or less,
*       conic sharpness is Cos((efEndAngle - efStartAngle) / 2).
*
*       B is calculated by the intersection of the two lines that are
*       at the ends of A and C and are perpendicular to A and C,
*       respectively.  That is, since A and C lie on the unit circle, B
*       is the point of intersection of the two lines that are tangent
*       to the unit circle at A and C.
*
*       If A = (a, b), then the equation of the line through (a, b)
*       tangent to the circle is ax + by = 1.  Similarly, for
*       C = (c, d), the equation of the line is cx + dy = 1.  The
*       intersection of these two lines is defined by:
*
*              x = (d - b) / (ad - bc)
*       and    y = (a - c) / (ad - bc).
*
*       Then, B = (x, y).
*
* 2)  Approximating the conic as a Bezier cubic
*
*       For sharpness values 'close' to 1, the conic may be approximated
*       by a cubic Bezier; error is less for sharpnesses closer to 1.
*
*     Error
*
*       Since the largest angle handled by this routine is 90 degrees,
*       sharpness is guaranteed to be between 1 / sqrt(2) = .707 and 1.
*       Error in the approximation for a 90 degree arc is approximately
*       0.2%; it is less for smaller angles.  0.2% is deemed small
*       enough error; thus, a 90 degree circular arc is always
*       approximated by just one Bezier.
*
*       One notable implication of the fact that arcs have less error
*       for smaller angles is that when a partial arc is xor-ed with
*       the corresponding complete ellipse, some of the partial arc
*       will not be completely xor-ed out.  (Too bad.)
*
*       Given a conic section defined by (A, B, C, S), we find the
*       cubic Bezier defined by the four control points (V0, V1, V2, V3)
*       that provides the closest approimxation.  We require that the
*       Bezier be tangent to the triangle at the same endpoints.  That is,
*
*               V1 = (1 - Tau1) A + (Tau1) B
*               V2 = (1 - Tau2) C + (Tau2) B
*
*       Simplify by taking Tau = Tau1 = Tau2, and we get:
*
*               V0 = A
*               V1 = (1 - Tau) A + (Tau) B
*               V2 = (1 - Tau) C + (Tau) B
*               V3 = C
*
*
*       Where Tau = 4 S / (3 (S + 1)), S being the sharpness.
*       S = cos(angle / 2) for an arc of 90 degrees or less.
*       So, for one quadrant of a circle, and since A and B actually
*       extend from the corners of the bound box, and not the center,
*
*         Tau = 1 - (4 * cos(45)) / (3 * (cos(45) + 1)) = 0.44772...
*
*       See Kirk Olynyk's "Conics to Beziers" for more.
*
* 3)    The arc is transformed to the bound box.
*
* History:
*  27-Nov-1990 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL bPartialQuadrantArc
(
 PARTIALARC  paType,         // MoveToEx or LineTo the first point
 EPATHOBJ&   epo,
 EBOX&       ebox,           // Bound box
 EPOINTFL&   eptefVecA,
 EFLOAT&     efStartAngle,
 EPOINTFL&   eptefVecC,
 EFLOAT&     efEndAngle
)
{

    EPOINTFL ptefV0;
    EPOINTFL ptefV1;
    EPOINTFL ptefV2;
    EPOINTFL ptefV3;

    EPOINTFL eptefVecB;

// Do some explicit common sub-expression elimination:

// efDenom = eptefVecA.x * eptefVecC.y - eptefVecA.y * eptefVecC.x;

    EFLOAT efTerm2 = eptefVecA.y;
    efTerm2 *= eptefVecC.x;

    EFLOAT efDenom = eptefVecA.x;
    efDenom *= eptefVecC.y;
    efDenom -= efTerm2;
    efDenom.vAbs();

// efDenom == 0 if eptefVecA and eptefVecC are parallel vectors.
// Since they're both centered at the origin, and are in the
// same quadrant, this implies that eptefVecA == eptefVecC, or
// equivalently, efStartAngle == efEndAngle, which we special case.
//
// Compare to epsilon, which is arbitrarily 2 ^ -16, thus skipping
// angles of less than 0.000874 degrees.

    if (efDenom <= FP_EPSILON)
    {

    // We have a zero degree arc.  If we're doing a _LINETO or _MOVETO,
    // we have to set the current point in the path.  We can't early
    // out if doing a _CONTINUE because of AngleArc in XOR mode doing
    // a sweep of more than 360 degrees when the start angle is a
    // multiple of 90 degrees: bPartialQuadrantArc may have left the
    // current position in a slightly different point what we will
    // expect for the next part of the arc, due to rounding error.

        ptefV0 = eptefVecA;
        ptefV1 = ptefV0;
        ptefV2 = eptefVecC;
        ptefV3 = ptefV2;
    }
    else
    {

    // eptefVecB.x = (eptefVecC.y - eptefVecA.y) / efDenom;
    // eptefVecB.y = (eptefVecA.x - eptefVecC.x) / efDenom;

        eptefVecB.x = eptefVecC.y;
        eptefVecB.x -= eptefVecA.y;
        eptefVecB.x /= efDenom;

        eptefVecB.y = eptefVecA.x;
        eptefVecB.y -= eptefVecC.x;
        eptefVecB.y /= efDenom;

    // efSharp = efCos((efEndAngle - efStartAngle) / 2.0f):

        EFLOAT efSharp;
        {
            EFLOAT efSweep = efEndAngle;
            efSweep -= efStartAngle;
            efSweep.vDivBy2();
            efSharp = efCos(efSweep);

        // Given cos(x + n * 180) = +/- cos(x) for integer n.  We
        // know that the arc is 90 degrees or less, so efSharp is
        // non-negative.  This lets us effectively use input angles
        // modulo 360 degrees:

            efSharp.vAbs();
        }

    // At this point we've figured out the control points and sharpness
    // of the conic section defining the arc.  Now convert them to Bezier
    // form.

        {
            EFLOAT efSharpPlusOne = efSharp;
            efSharpPlusOne += FP_1_0;

        // efAlpha = Tau = 4 * S / (3 * (S + 1)):

            EFLOAT efAlpha = FP_4DIV3;
            efAlpha *= efSharp;
            efAlpha /= efSharpPlusOne;

        // efBeta = 1 - Tau:

            EFLOAT efBeta = FP_1_0;
            efBeta -= efAlpha;

        // ptefAlphaTimesVecB = (Tau) B:

            EPOINTFL ptefAlphaTimesVecB = eptefVecB;
            ptefAlphaTimesVecB *= efAlpha;

        // V0 = A:

            ptefV0 = eptefVecA;

        // V1 = (1 - Tau) A + (Tau) B:

            ptefV1 = eptefVecA;
            ptefV1 *= efBeta;
            ptefV1 += ptefAlphaTimesVecB;

        // V2 = (1 - Tau) C + (Tau) B:

            ptefV2 = eptefVecC;
            ptefV2 *= efBeta;
            ptefV2 += ptefAlphaTimesVecB;

        // V3 = C:

            ptefV3 = eptefVecC;
        }
    }

// When PARTIALARCTYPE_CONTINUE is set, we know that the first control
// point of the Bezier is the same as the last point added to the path,
// so we don't have to add it again.

    if (paType != PARTIALARCTYPE_CONTINUE)
    {
        POINTL ptl = ebox.ptlXform(ptefV0);
        switch (paType)
        {
        case PARTIALARCTYPE_MOVETO:
            if (!epo.bMoveTo((PEXFORMOBJ) NULL, &ptl))
                return(FALSE);
            break;
        case PARTIALARCTYPE_LINETO:
            if (!epo.bPolyLineTo((PEXFORMOBJ) NULL, &ptl, 1))
                return(FALSE);
            break;
        }
    }

    POINTL aptl[3];

// Now transform to the bound box:

    aptl[0] = ebox.ptlXform(ptefV1);
    aptl[1] = ebox.ptlXform(ptefV2);
    aptl[2] = ebox.ptlXform(ptefV3);

    return(epo.bPolyBezierTo((PEXFORMOBJ) NULL, aptl, 3));
}

/******************************Public*Routine******************************\
* VOID vGetAxis(lQuadrant, eptef)
*
* History:
*  22-Aug-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

inline VOID vGetAxis
(
 LONG      lQuadrant,
 EPOINTFL& eptef
)
{
    eptef.x = gaefAxisCoord[(lQuadrant + 1) & 3];
    eptef.y = gaefAxisCoord[lQuadrant];
}

/******************************Public*Routine******************************\
* BOOL bPartialArc(paType, epo, ebox,
*                  eptefStart, lStartQuadrant, efStartAngle,
*                  eptefEnd, lEndQuadrant, efEndAngle,
*                  lQuadrants)
*
* Constructs a partial arc.  Optionally draws a line to the first point.
* The arc is drawn counter-clockwise.  efStartAngle and efEndAngle are
* interpretted modulo 360.  If the start and end are coincident, a
* complete ellipse is drawn if lQuadrants != 0.
*
* It works by breaking the arc into curves of 90 degrees or less, and
* then approximating these using Beziers.
*
* Restrictions: Only draws counter-clockwise, up to one revolution.
*
* History:
*  27-Nov-1990 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL bPartialArc
(
 PARTIALARC  paType,
 EPATHOBJ&   epo,
 EBOX&       ebox,
 EPOINTFL&   eptefStart,
 LONG        lStartQuadrant,
 EFLOAT&     efStartAngle,
 EPOINTFL&   eptefEnd,
 LONG        lEndQuadrant,
 EFLOAT&     efEndAngle,
 LONG        lQuadrants
)
{
    BOOL bSuccess;

// If arc is less than 90 degrees, we can make the call straight to
// bPartialQuadrantArc:

    if (lQuadrants == 0)
    {
        bSuccess = bPartialQuadrantArc(paType,
                                       epo,
                                       ebox,
                                       eptefStart,
                                       efStartAngle,
                                       eptefEnd,
                                       efEndAngle);
    }
    else
    {

    // Increment lStartQuadrant so that it's actually the quadrant
    // of the first possible 90 degree arc:

        lStartQuadrant = (lStartQuadrant + 1) & 3;

    // The arc is more than 90 degrees, so we have to break it
    // up into chunks that are 90 degrees or smaller.  We break it
    // up by quadrant.

        EAPOINTL    aeptl[3];         // Buffer for quadrant arcs
        EPOINTFL    eptefAxis;

        vGetAxis(lStartQuadrant, eptefAxis);
        bSuccess = bPartialQuadrantArc(paType,
                                       epo,
                                       ebox,
                                       eptefStart,
                                       efStartAngle,
                                       eptefAxis,
                                       gaefAxisAngle[lStartQuadrant]);

        if (lStartQuadrant != lEndQuadrant)
        {

        // Compute vectors for constructing arcs of exactly 90 degrees:

            EPOINTL  eptlC;
            EPOINTL  eptlD;
            LONGLONG eq;        // Temporary variable

        // Compute the placement of the inner control points for the
        // Bezier curve:

            vEllipseControlsIn((VECTORFX*) &ebox.eptlA, (VECTORFX*) &eptlC, &eq);
            vEllipseControlsIn((VECTORFX*) &ebox.eptlB, (VECTORFX*) &eptlD, &eq);

            LONG ll = lStartQuadrant;
            do
            {
                switch (ll)
                {
                case 0:
                    aeptl[0] = ebox.aeptl[0]; aeptl[0] -= eptlD;
                    aeptl[1] = ebox.aeptl[0]; aeptl[1] -= eptlC;
                    aeptl[2] = ebox.aeptl[0]; aeptl[2] -= ebox.eptlA;
                    break;

                case 1:
                    aeptl[0] = ebox.aeptl[1]; aeptl[0] += eptlC;
                    aeptl[1] = ebox.aeptl[1]; aeptl[1] -= eptlD;
                    aeptl[2] = ebox.aeptl[1]; aeptl[2] -= ebox.eptlB;
                    break;

                case 2:
                    aeptl[0] = ebox.aeptl[2]; aeptl[0] += eptlD;
                    aeptl[1] = ebox.aeptl[2]; aeptl[1] += eptlC;
                    aeptl[2] = ebox.aeptl[2]; aeptl[2] += ebox.eptlA;
                    break;

                case 3:
                    aeptl[0] = ebox.aeptl[3]; aeptl[0]  -= eptlC;
                    aeptl[1] = ebox.aeptl[3]; aeptl[1] += eptlD;
                    aeptl[2] = ebox.aeptl[3]; aeptl[2] += ebox.eptlB;
                    break;
                }

                bSuccess &= epo.bPolyBezierTo((PEXFORMOBJ) NULL, aeptl, 3);

                ll = (ll + 1) & 3;

            } while (ll != lEndQuadrant);
        }

        vGetAxis(lEndQuadrant, eptefAxis);
        bSuccess &= bPartialQuadrantArc(PARTIALARCTYPE_CONTINUE,
                                        epo,
                                        ebox,
                                        eptefAxis,
                                        gaefAxisAngle[lEndQuadrant],
                                        eptefEnd,
                                        efEndAngle);
    }
    return(bSuccess);
}


/******************************Public*Routine******************************\
* BOOL NtGdiArcInternal (arctype,x1,y1,x2,y2,x3,y3,x4,y4)
*
* Draws an arc figure.  Used by the 'Arc', 'Chord' and 'Pie' APIs.
* Adds to the active path associated with the DC if there is one;
* otherwise, adds to a temporary one and bStroke's or bStrokeAndFill's
* it.
*
* History:
*  27-Nov-1990 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiArcInternal(
    ARCTYPE arctype,            // Arc, Pie, Chord, or ArcTo
    HDC     hdc,
    int     x1,
    int     y1,
    int     x2,
    int     y2,
    int     x3,
    int     y3,
    int     x4,
    int     y4
    )
{
    ERECTL  ercl(x1, y1, x2, y2);
    EPOINTL ptl1(x3, y3);
    EPOINTL ptl2(x4, y4);    

    DCOBJ dco(hdc);

    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

// Watch out: enums are signed, so we need to check "both ends":

    if ((arctype < 0) || (arctype >= ARCTYPE_MAX))
    {
        RIP("bCurve: Unknown curve type.");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    SYNC_DRAWING_ATTRS(dco.pdc);

// Get the current path or a temporary path.  If we're doing an ArcTo,
// notify that we will update the current point:

    PATHSTACKOBJ pso(dco, arctype == ARCTYPE_ARCTO);
    if (!pso.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

// Need World-to-Device transform for widening the line:

    EXFORMOBJ  exo(dco, WORLD_TO_DEVICE);
    LINEATTRS *pla = dco.plaRealize(exo);

// Handle the PS_INSIDEFRAME pen attribute and lower-right exclusion
// by adjusting the box now.  At the same time, get the transform
// type and order the rectangle.  Plus, pass TRUE to indicate that
// the bound box should be adjusted for nice output with NULL pens:

    EBOX ebox(dco, ercl, pla, TRUE);

// Like Win3, we don't handle the case when the pen is bigger than either
// dimension of the bound-box:

    if (ebox.bFillInsideFrame())
        return(FALSE);

// We exit early if the the bound box is less than a pixel in some
// dimension and we're doing lower-right exclusion.  Since we have
// drawn what the app asked for, we return success.

    if (ebox.bEmpty())
    {
        return(TRUE);
    }

    EPOINTFL eptefOrg(efMid(ebox.rclWorld.left, ebox.rclWorld.right),
                      efMid(ebox.rclWorld.top,  ebox.rclWorld.bottom));

    EFLOAT  efStartAngle;
    EFLOAT  efEndAngle;
    LONG    lStartQuad;
    LONG    lEndQuad;

// Make sure we don't divide by zero:

    if (ebox.rclWorld.left == ebox.rclWorld.right ||
        ebox.rclWorld.top  == ebox.rclWorld.bottom)
    {
        efEndAngle = efStartAngle = FP_0_0;
        lStartQuad = lEndQuad = 0;
    }
    else
    {
        EFLOAT efdx = efHalfDiff(ebox.rclWorld.right, ebox.rclWorld.left);
        EFLOAT efdy = efHalfDiff(ebox.rclWorld.top,   ebox.rclWorld.bottom);

        ASSERTGDI(!efdx.bIsZero() && !efdy.bIsZero(), "bArc: scaling is zero\n");

    // Compute the start and end angles of the ellipse when its
    // more convenient, namely when we have the points in world
    // space.
    //
    // The ellipse must be scaled back to the unit circle before
    // the angle is computed.  The signs of 'efdx' and 'efdy'
    // determine the correct orientation:

        EPOINTFL ptefNormalized;

        ptefNormalized = ptl1;
        ptefNormalized -= eptefOrg;
        ptefNormalized.x /= efdx;
        ptefNormalized.y /= efdy;

        vArctan(ptefNormalized.x, ptefNormalized.y, efStartAngle, lStartQuad);

        ptefNormalized = ptl2;
        ptefNormalized -= eptefOrg;
        ptefNormalized.x /= efdx;
        ptefNormalized.y /= efdy;

        vArctan(ptefNormalized.x, ptefNormalized.y, efEndAngle, lEndQuad);

    // If efEndAngle == efStartAngle, we'll draw a complete ellipse.
    // Note that we can't just call 'bEllipse' for this case because
    // drawing must start and end at the specified angles (this
    // matters for styled lines).

    }

    EPOINTFL eptefStart;
    EPOINTFL eptefEnd;

    EFLOAT efAngleSwept;
    BOOL bAngleSweptIsZero;

    // If the difference between efEndAngle and efStartAngle is less than about 3 degrees,
    // then the error in computation of eptefStart and eptefEnd using vCosSin will be enough
    // so that the computation of the Bezier points in bPartialArc (which calls bPartialQuadrantArc)
    // will be noticeably wrong.

    // if efEndAngle == efStartAngle, then we are drawing an entire ellipse, and so
    // it is safe to use vCosSin.

    // determine whether (abs(efEndAngle - efStartAngle) - 3.0 < 0.0)
    efAngleSwept = efEndAngle;
    efAngleSwept -= efStartAngle;

    if (efAngleSwept.bIsNegative())
    {
        efAngleSwept.vNegate();
    }
    bAngleSweptIsZero = efAngleSwept.bIsZero();
    efAngleSwept -= FP_3_0;

    if (efAngleSwept.bIsNegative() && !bAngleSweptIsZero)
    {
        vCosSinPrecise(efStartAngle, &eptefStart.x, &eptefStart.y);
        vCosSinPrecise(efEndAngle, &eptefEnd.x, &eptefEnd.y);
    }
    else
    {
        vCosSin(efStartAngle, &eptefStart.x, &eptefStart.y);
        vCosSin(efEndAngle, &eptefEnd.x, &eptefEnd.y);
    }

    if (!bPartialArc((arctype == ARCTYPE_ARCTO) ?
                                 PARTIALARCTYPE_LINETO :
                                 PARTIALARCTYPE_MOVETO,
                      pso,
                      ebox,
                      eptefStart,
                      lStartQuad,
                      efStartAngle,
                      eptefEnd,
                      lEndQuad,
                      efEndAngle,
                      ((lStartQuad == lEndQuad) &&
                       (efEndAngle > efStartAngle)) ? 0 : 1))
        return(FALSE);

    switch(arctype)
    {
    case ARCTYPE_ARC:
        break;

    case ARCTYPE_ARCTO:

    // Set the DC's current position in device space.  It would be too much
    // work to calculate the world space current position, so simply mark it
    // as invalid:

        dco.pdc->vInvalidatePtlCurrent();
        dco.pdc->vValidatePtfxCurrent();
        dco.ptfxCurrent() = pso.ptfxGetCurrent();

        break;
    case ARCTYPE_CHORD:

    // Draw a line from the end of the curve to the start to create
    // the 'Chord':

        if (!pso.bCloseFigure())
            return(FALSE);

        break;

    case ARCTYPE_PIE:
        {

    // Draw a line from the end of the curve to the center of the
    // figure to the start of the curve to create the 'Pie':

            if (!pso.bPolyLineTo((PEXFORMOBJ) NULL, &ebox.eptlOrigin, 1) ||
                !pso.bCloseFigure())
                return(FALSE);
        }
        break;
    }

// Return if we're accumulating a path:

    if (dco.pdc->bActive())
        return(TRUE);

// Stroke or StrokeAndFill depending on the curve type:

    BOOL bSuccess;
    switch(arctype)
    {
    case ARCTYPE_ARCTO:
    case ARCTYPE_ARC:
        bSuccess = pso.bStroke(dco, dco.plaRealize(exo), &exo);
        break;
    case ARCTYPE_CHORD:
    case ARCTYPE_PIE:
        bSuccess = pso.bStrokeAndFill(dco, dco.plaRealize(exo), &exo);
        break;
    }

    return(bSuccess);
}

/******************************Public*Routine******************************\
* BOOL bEllipse(epo, ebox)
*
* Adds an ellipse to the path.  Used by 'Ellipse' and 'CreateEllipticalRgn'
* APIs.
*
* 4 Beziers are used, one for each quadrant of the ellipse.  Drawing
* starts at the positive x-axis, and proceeds in a counter-clockwise
* direction.
*
* History:
*  27-Nov-1990 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL bEllipse
(
 EPATHOBJ&   epo,
 EBOX&       ebox            // Bounding box
)
{
    ASSERTGDI(epo.bValid(), "bEllipse: Bad object parm\n");

// 'eptlC' and 'eptlD' are vectors from the corners of the bounding
// box that are where the inner control points of the Beziers are
// placed:

    EPOINTL eptlC;
    EPOINTL eptlD;

    LONGLONG eqTmp;

    vEllipseControlsIn((VECTORFX*) &ebox.eptlA, (VECTORFX*) &eptlC, &eqTmp);
    vEllipseControlsIn((VECTORFX*) &ebox.eptlB, (VECTORFX*) &eptlD, &eqTmp);

    BOOL bSuccess;
    {
    // Start drawing at the 'x-axis':

        EPOINTL eptlStart = ebox.aeptl[3];
        eptlStart += ebox.eptlB;
        bSuccess = epo.bMoveTo((PEXFORMOBJ) NULL, &eptlStart);
    }

// Use one 96 byte buffer so that we only have to call bPolyBezierTo
// once.  I would declare this as an array of EPOINTLs, but the
// compiler doesn't like the static constructors:

    EAPOINTL aeptl[12];

// First Quadrant

    aeptl[0] = ebox.aeptl[0]; aeptl[0] -= eptlD;
    aeptl[1] = ebox.aeptl[0]; aeptl[1] -= eptlC;
    aeptl[2] = ebox.aeptl[0]; aeptl[2] -= ebox.eptlA;

// Second Quadrant:

    aeptl[3] = ebox.aeptl[1]; aeptl[3] += eptlC;
    aeptl[4] = ebox.aeptl[1]; aeptl[4] -= eptlD;
    aeptl[5] = ebox.aeptl[1]; aeptl[5] -= ebox.eptlB;

// Third Quadrant:

    aeptl[6] = ebox.aeptl[2]; aeptl[6] += eptlD;
    aeptl[7] = ebox.aeptl[2]; aeptl[7] += eptlC;
    aeptl[8] = ebox.aeptl[2]; aeptl[8] += ebox.eptlA;

// Fourth Quadrant:

    aeptl[9]  = ebox.aeptl[3]; aeptl[9]  -= eptlC;
    aeptl[10] = ebox.aeptl[3]; aeptl[10] += eptlD;
    aeptl[11] = ebox.aeptl[3]; aeptl[11] += ebox.eptlB;

    return(epo.bPolyBezierTo((PEXFORMOBJ) NULL, aeptl, 12) &&
           epo.bCloseFigure());
}


/******************************Public*Routine******************************\
* BOOL bRoundRect(epo, exoWorldToDevice, ebox, x, y)
*
* Adds a rounded rectangle to the path.  Used by 'RoundRect' and
* 'CreateRoundRectRgn' APIs.
*
* 4 Beziers and 4 lines are used.  Drawing starts at the first curve
* in the "upper right" corner of the rounded rectangle, and proceeds
* in a "counter-clockwise" direction.
*
* This routine constructs the RoundRect by taking advantage of the fact
* that all the control points defining the lines and the Beziers lie on
* the bounding box.
*
* History:
*  27-Nov-1990 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL bRoundRect
(
 EPATHOBJ&   epo,
 EBOX&       ebox,            // Bound box of rectangle
 LONG        x,               // Width of ellipse in World coordinates
 LONG        y                // Height of ellipse in World coordinates
)
{
    ASSERTGDI(epo.bValid(), "bRoundRect: Bad object parm\n");

    EFLOAT efdx = efHalfDiff(ebox.rclWorld.left, ebox.rclWorld.right);
    EFLOAT efdy = efHalfDiff(ebox.rclWorld.top, ebox.rclWorld.bottom);

    EFLOATEXT efFractionA;
    EFLOATEXT efFractionB;

    if (efdx.bIsZero() || efdy.bIsZero())
    {
        efFractionA = FP_0_0;
        efFractionB = FP_0_0;
    }
    else
    {
    // Old Windows takes the absolute values of the ellipse dimensions
    // used for drawing the corners:

        x = ABS(x);
        y = ABS(y);

    // Determine what fraction of the bound box that the ellipse
    // comprises:

        efdx.vAbs();
        efdy.vAbs();
        efFractionA = x;
        efFractionB = y;
        efFractionA /= efdx;
        efFractionB /= efdy;

    }

//
// If the ellipse given by the user has larger dimensions than the
// bound box, shrink those dimensions so that they are the same as
// the bound box:
//

    if (efFractionA > FP_2_0)
        efFractionA = FP_1_0;
    else
        efFractionA.vDivBy2();

    if (efFractionB > FP_2_0)
        efFractionB = FP_1_0;
    else
        efFractionB.vDivBy2();

//DbgPrint("FracA: %li  FracB: %li\n", lConv(efdx), lConv(efdy));

//
// 'eptlX' and 'eptlY' are the vectors from the vertices of the
// bounding box defining the start and end-points of the Beziers
// used for the rounded corners.  'eptlXprime' and 'eptlYprime'
// define the inner two control points (all the Beziers' control
// points lie on the bounding box):
//
//                         -------------------> ebox.eptlA
//
//                         :                                      :
//                         |                                      |
//       ^                 |\                                    /|
//       |                 |  \                                /  |
//       |              ^  |    \                            /    |
// eptlY |   eptlYprime |  2--------------------------------------3
//
//                         --> eptlXprime
//
//                         ------> eptlX
//
//                  eptlX = efFractionA * ebox.eptlA
//                  eptlY = efFractionB * ebox.eptlB
//

    EPOINTL eptlX;
    EPOINTL eptlY;
    EPOINTL eptlXprime;
    EPOINTL eptlYprime;

    {
        LONGLONG eqTmp;
        EPOINTFL eptefX;
        EPOINTFL eptefY;
        eptefX = ebox.eptlA;
        eptefY = ebox.eptlB;

        eptefX *= efFractionA;
        eptefY *= efFractionB;

    // This conversion should not fail:

        eptefX.bToPOINTL(eptlX);
        eptefY.bToPOINTL(eptlY);

    // We now know where to put the end-points of the bezier curves.  Now
    // compute the inner control points:

        vEllipseControlsIn((VECTORFX*) &eptlX, (VECTORFX*) &eptlXprime, &eqTmp);
        vEllipseControlsIn((VECTORFX*) &eptlY, (VECTORFX*) &eptlYprime, &eqTmp);
    }

    EAPOINTL aeptl[3];
    EPOINTL  eptl;
    BOOL     bFailure = FALSE;       // Fail by default

    eptl = ebox.aeptl[0];
    eptl -= eptlY;
    if (!epo.bMoveTo((PEXFORMOBJ) NULL, &eptl))
        return(bFailure);

    aeptl[0] = ebox.aeptl[0]; aeptl[0] -= eptlYprime;
    aeptl[1] = ebox.aeptl[0]; aeptl[1] -= eptlXprime;
    aeptl[2] = ebox.aeptl[0]; aeptl[2] -= eptlX;

    if (!epo.bPolyBezierTo((PEXFORMOBJ) NULL, aeptl, 3))
        return(bFailure);

// Quadrant two:

    eptl = ebox.aeptl[1];
    eptl += eptlX;
    if (!epo.bPolyLineTo((PEXFORMOBJ) NULL, &eptl, 1))
        return(bFailure);

    aeptl[0] = ebox.aeptl[1]; aeptl[0] += eptlXprime;
    aeptl[1] = ebox.aeptl[1]; aeptl[1] -= eptlYprime;
    aeptl[2] = ebox.aeptl[1]; aeptl[2] -= eptlY;

    if (!epo.bPolyBezierTo((PEXFORMOBJ) NULL, aeptl, 3))
        return(bFailure);

// Quadrant three:

    eptl = ebox.aeptl[2];
    eptl += eptlY;
    if (!epo.bPolyLineTo((PEXFORMOBJ) NULL, &eptl, 1))
        return(bFailure);

    aeptl[0] = ebox.aeptl[2]; aeptl[0] += eptlYprime;
    aeptl[1] = ebox.aeptl[2]; aeptl[1] += eptlXprime;
    aeptl[2] = ebox.aeptl[2]; aeptl[2] += eptlX;

    if (!epo.bPolyBezierTo((PEXFORMOBJ) NULL, aeptl, 3))
        return(bFailure);

// Quadrant four:

    eptl = ebox.aeptl[3];
    eptl -= eptlX;
    if (!epo.bPolyLineTo((PEXFORMOBJ) NULL, &eptl, 1))
        return(bFailure);

    aeptl[0] = ebox.aeptl[3]; aeptl[0] -= eptlXprime;
    aeptl[1] = ebox.aeptl[3]; aeptl[1] += eptlYprime;
    aeptl[2] = ebox.aeptl[3]; aeptl[2] += eptlY;

    if (!epo.bPolyBezierTo((PEXFORMOBJ) NULL, aeptl, 3))
        return(bFailure);

// Done:

    return(epo.bCloseFigure());
}


/******************************Public*Routine******************************\
* BOOL bPolyPolygon(epo, exo, pptl, pcptl, ccptl, cMaxPoints)
*
* Adds a PolyPolygon to the path.  Used by CreatePolyPolygonRgn and
* PolyPolygon APIs.  Returns FALSE if fails, and sets last error code.
*
* History:
*  27-Nov-1990 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL bPolyPolygon
(
 EPATHOBJ&   epo,
 EXFORMOBJ&  exo,
 PPOINTL     pptl,
 LONG*       pcptl,
 ULONG       ccptl,
 LONG        cMaxPoints
)
{
    ASSERTGDI(epo.bValid(), "bPolyPolygon: Bad epo\n");
    ASSERTGDI(exo.bValid(), "bPolyPolygon: Bad exo\n");

    if (ccptl == 0)
        return(TRUE);

    LONG  cPts;
    LONG* pcptlEnd = pcptl + ccptl;

// Now add to the path:

    do {

    // We have to be careful to make a local copy of this polygon's point
    // count (by copying to to cPts) to get the value out of the shared
    // client/server memory window, where the app could trash the value at
    // any time:

        cPts = *pcptl;
        cMaxPoints -= cPts;

    // Check parameters.  Each polygon must have at least 2 points.

        if (cMaxPoints < 0 || cPts < 2)
        {
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            return(FALSE);
        }

        if (!epo.bMoveTo(&exo, pptl) ||
            !epo.bPolyLineTo(&exo, pptl + 1, cPts - 1) ||
            !epo.bCloseFigure())
            return(FALSE);

        pptl += cPts;
        pcptl++;

    } while (pcptl < pcptlEnd);

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\drawstream.cxx ===
/******************************Module*Header*******************************\
* Module Name: drawstream.cxx
*
* All code related to handling draw streams except for multi-mon and
* sprite layer hooking.
*
* Created: 3-21-2001
* Author: Barton House [bhouse]
*
* Copyright (c) 1990-2001 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

#if defined(USE_NINEGRID_STATIC)
HSEMAPHORE gNineGridSem = 0;
#endif

/******************************Private*************************************\
* Nine Grid Code Follows
*
*    A bunch of nine grid structures and code follow below.  This code
*    will be cleaned up and moved to its own file shortly.
*
* History:
*
*    3-18-2001 bhouse Created it
*
\**************************************************************************/


typedef struct _DNGSTRETCH
{
    ULONG xStart;
    ULONG xAccum;
    ULONG xFrac;
    ULONG xInt;
    ULONG ulDestWidth;
    ULONG ulSrcWidth;
    int   left;
    int   right;
} DNGSTRETCH;

typedef struct _DNGINTERNALDATA
{
    int     cxClipMin;
    int     cxClipMax;

    ULONG*  pvDestBits;
    LONG    lDestDelta;
    int     iDestWidth;
    int     iClipWidth;

    ULONG*  pvSrcBits;
    LONG    lSrcDelta;
    int     iSrcWidth;
    int     iSrcBufWidth;

    int     cxLeftWidth;
    int     xMinLeft;
    int     xMaxLeft;

    int     cxRightWidth;
    int     xMinRight;
    int     xMaxRight;

    int     cxMiddleWidth;
    int     cxNewMiddleWidth;
    int     xMinMiddle;
    int     xMaxMiddle;

    // Variable for shrunken corners and sides
    BOOL    fShowMiddle;
    DNGSTRETCH stretchLeft;
    DNGSTRETCH stretchRight;
    int     cxNewLeftWidth;
    int     cxNewRightWidth;

    BOOL    fTileMode;
    // Specific to non-tile mode (i.e. stretch mode)
    DNGSTRETCH stretchMiddle;

    LONG    lBufWidth;

} DNGINTERNALDATA;


static inline void DNG_StretchRow(ULONG* pvDestBits, ULONG* pvSrcBits, DNGSTRETCH * ps)
{
    ULONG*  pvTemp = pvDestBits + ps->left;
    ULONG*  pvSentinel = pvDestBits + ps->right;

    ULONG   xInt = ps->xInt;
    ULONG   xFrac = ps->xFrac;
    ULONG   xTmp;
    ULONG   xAccum = ps->xAccum;
    ULONG * pulSrc = pvSrcBits + ps->xStart;
    ULONG   ulSrc;

    while (pvTemp != pvSentinel)
    {
        ulSrc  = *pulSrc;
        xTmp   = xAccum + xFrac;
        pulSrc = pulSrc + xInt + (xTmp < xAccum);
        *pvTemp = ulSrc;
        pvTemp++;
        xAccum = xTmp;
    }
}

static inline void DNG_InitStretch(DNGSTRETCH* pStretch, ULONG ulDestWidth, ULONG ulSrcWidth, int left, int right)
{
    pStretch->right = right;
    pStretch->left  = left;

    ULONGLONG dx = ((((ULONGLONG) ulSrcWidth << 32) - 1) / (ULONGLONG) ulDestWidth) + 1;
    ULONGLONG x = (((ULONGLONG) ulSrcWidth << 32) / (ULONGLONG) ulDestWidth) >> 1;
    ULONG   xInt = pStretch->xInt = (ULONG) (dx >> 32);
    ULONG   xFrac = pStretch->xFrac = (ULONG) (dx & 0xFFFFFFFF);

    ULONG   xAccum = (ULONG) (x & 0xFFFFFFFF);
    ULONG   xStart = (ULONG) (x >> 32);

    if (left <= 5)
    {
        ULONG xTmp;
        for (int i = 0; i < left; i++)
        {
            xTmp   = xAccum + xFrac;
            xStart = xStart + xInt + (xTmp < xAccum);
            xAccum = xTmp;
        }
    }
    else
    {
        ULONGLONG xTmp = ((ULONGLONG) xFrac * (ULONGLONG) left) + (ULONGLONG) xAccum;

        xStart = xStart + (xInt * left) + (ULONG) (xTmp >> 32);
        xAccum = (ULONG) xTmp;
    }

    pStretch->xStart = xStart;
    pStretch->xAccum = xAccum;
}

static inline void DNG_DrawRow(DNGINTERNALDATA* pdng)
{
    ULONG* pvDestLoc = pdng->pvDestBits;
    ULONG* pvSrcLoc = pdng->pvSrcBits;

    // Left
    if (pdng->cxClipMin < pdng->cxNewLeftWidth)
    {
        if (pdng->cxLeftWidth == pdng->cxNewLeftWidth)
        {
            RtlCopyMemory(pvDestLoc + pdng->xMinLeft, pvSrcLoc + pdng->xMinLeft, (pdng->xMaxLeft - pdng->xMinLeft) * sizeof(ULONG));
        }
        else
        {
            DNG_StretchRow(pvDestLoc, pvSrcLoc, &pdng->stretchLeft);
        }
    }
    pvDestLoc += pdng->cxNewLeftWidth;
    pvSrcLoc  += pdng->cxLeftWidth;
  
    // Middle
    if (pdng->fShowMiddle)
    {
        if (pdng->xMinMiddle < pdng->xMaxMiddle)
        {
            if (pdng->fTileMode)
            {
                ULONG* pvTempSrc = pvSrcLoc;
                ULONG* pvTempDest = pvDestLoc;

                // Fill in Top Tile
                int xMin = pdng->xMinMiddle;
                int xDiff = xMin - pdng->cxLeftWidth;
                pvDestLoc += xDiff;
                int iTileSize = pdng->cxMiddleWidth - (xDiff % pdng->cxMiddleWidth);
                pvSrcLoc += xDiff % pdng->cxMiddleWidth;

                int xMax = pdng->xMaxMiddle;
                for (int x = xMin; x < xMax; x++, pvDestLoc++ , pvSrcLoc++)
                {
                    *pvDestLoc = *pvSrcLoc;
                    iTileSize--;
                    if (iTileSize == 0)
                    {
                        iTileSize = pdng->cxMiddleWidth;
                        pvSrcLoc -= iTileSize;
                    }
                }

                pvDestLoc = pvTempDest;
                pvSrcLoc = pvTempSrc;
            }
            else
            {
                DNG_StretchRow(pvDestLoc, pvSrcLoc, &pdng->stretchMiddle);
            }
        }
        pvDestLoc += pdng->cxNewMiddleWidth;
    }   
    pvSrcLoc  += pdng->cxMiddleWidth;

    // Right
    if (pdng->cxClipMax > (pdng->iDestWidth - pdng->cxNewRightWidth))
    {
        if (pdng->cxRightWidth == pdng->cxNewRightWidth)
        {
            RtlCopyMemory(pvDestLoc + pdng->xMinRight, pvSrcLoc + pdng->xMinRight, (pdng->xMaxRight - pdng->xMinRight) * sizeof(ULONG));
        }
        else
        {
            DNG_StretchRow(pvDestLoc, pvSrcLoc, &pdng->stretchRight);
        }
    }
}

static inline void DNG_StretchCol(DNGINTERNALDATA* pdng, DNGSTRETCH * ps)
{
    ULONG*  pvOldDestBits = pdng->pvDestBits;
    ULONG*  pvOldSrcBits = pdng->pvSrcBits;
    
    ULONG*  pvTemp = pdng->pvDestBits - (pdng->lDestDelta * ps->left);
    ULONG*  pvSentinel = pdng->pvDestBits - (pdng->lDestDelta * ps->right); 

    ULONG   xInt = ps->xInt;
    ULONG   xFrac = ps->xFrac;
    ULONG   xTmp;
    ULONG   xAccum = ps->xAccum;
    ULONG * pulSrc = pdng->pvSrcBits - (LONG)(pdng->lSrcDelta * ps->xStart); // Note the LONG cast so we get correct pointer arithmetic on WIN64.
    ULONG   xDelta = 1; // force stretch on first scan

    while (pvTemp != pvSentinel)
    {
        if (xDelta != 0)
        {
            pdng->pvDestBits = pvTemp;
            pdng->pvSrcBits = pulSrc;
            DNG_DrawRow(pdng);
        }
        else
        {
            RtlCopyMemory(pvTemp + pdng->cxClipMin, pvTemp + pdng->cxClipMin + pdng->lDestDelta, pdng->iClipWidth * sizeof(ULONG));
        }

        xTmp   = xAccum + xFrac;

        xDelta = (xInt + (xTmp < xAccum));
        pulSrc = pulSrc - (LONG)(pdng->lSrcDelta * xDelta); // Note LONG cast
        pvTemp -= pdng->lDestDelta;
        xAccum = xTmp;
    }

    pdng->pvDestBits = pvOldDestBits;
    pdng->pvSrcBits = pvOldSrcBits;
}

static void RenderNineGridInternal(
    SURFOBJ            *psoScratch,
    SURFOBJ            *psoSrc,
    RECTL              *prclClip,
    RECTL              *prclDst,
    RECTL              *prclSrc,
    DS_NINEGRIDINFO    *ngi,
    PDRAWSTREAMINFO     pdsi,
    BOOL                bMirror)
{
    RECTL   rcDest = *prclDst;
    RECTL   rcClip = *prclClip;
    ULONG*  pvDestBits = NULL;
    int     iDestWidth = rcDest.right - rcDest.left;
    int     iDestHeight = rcDest.bottom - rcDest.top;
    int     iClipWidth = rcClip.right - rcClip.left;
    int     iClipHeight = rcClip.bottom - rcClip.top;
    LONG    lBufWidth = psoScratch->sizlBitmap.cx;
    LONG    lBufHeight = psoScratch->sizlBitmap.cy;
    
    DNGINTERNALDATA dng;

    // The code below assumes that the source and scratch is 32bpp

    ASSERTGDI(psoSrc->iBitmapFormat == BMF_32BPP, "RenderNineGridInternal: source not 32bpp");
    ASSERTGDI(psoScratch->iBitmapFormat == BMF_32BPP, "RenderNineGridInternal: scratch not 32bpp");

    // The code below assumes that both source and scratch are bottom up

//    ASSERTGDI(psoSrc->lDelta < 0, "RenderNineGridInternal: source is not bottom up");
//    ASSERTGDI(psoScratch->lDelta < 0, "RenderNineGridInternal: scratch is not bottom up");

    dng.lBufWidth = lBufWidth;
    
    LONG lDestDelta = psoScratch->lDelta / (LONG)(sizeof(ULONG));
    dng.lDestDelta = lDestDelta;

    LONG lSrcDelta = psoSrc->lDelta / (LONG)(sizeof(ULONG));
    dng.lSrcDelta = lSrcDelta;

    dng.cxClipMin = rcClip.left - rcDest.left;
    dng.cxClipMax = rcClip.right - rcDest.left;
    int cyClipMin = rcClip.top - rcDest.top;
    int cyClipMax = rcClip.bottom - rcDest.top;
    
    // pvScan0 points to the pixel addressed at (cxClipMin, cyClipMin)
    // pvDestBits points to the pixel addressed at (0, iDestHeight - 1)
    pvDestBits = (ULONG *) psoScratch->pvScan0;
    pvDestBits += (iDestHeight - 1 - cyClipMin) * lDestDelta;
    pvDestBits -=  dng.cxClipMin;

    int cxImage = rcClip.right - rcClip.left;
    int cyImage = rcClip.bottom - rcClip.top;

    LONG lSrcBufWidth = psoSrc->sizlBitmap.cx;
    LONG lSrcWidth = prclSrc->right - prclSrc->left;
    LONG lSrcHeight = prclSrc->bottom - prclSrc->top;

    ULONG * lSrcBits = (ULONG *) psoSrc->pvScan0 + (lSrcDelta * prclSrc->top) + prclSrc->left;
    lSrcBits += (lSrcDelta * (prclSrc->bottom - prclSrc->top - 1));

//    ULONG * lSrcBits = (ULONG *) psoSrc->pvScan0 + (lSrcDelta * (psoSrc->sizlBitmap.cy - 1));




    if (ngi->flFlags & DSDNG_TRUESIZE)
    {
        ULONG* pvDestLoc = pvDestBits - ((iDestHeight - 1) * lDestDelta);
        ULONG* pvSrcLoc = lSrcBits - ((lSrcHeight - 1) * lSrcDelta);
        int yMin = cyClipMin;
        pvDestLoc += yMin * lDestDelta;
        pvSrcLoc += yMin * lSrcDelta;
        int yMax = min(lSrcHeight, cyClipMax);

        int xMin = dng.cxClipMin;
        int xMax = min(lSrcWidth, dng.cxClipMax);

        if (xMax > xMin)
        {
            for (int y = yMin; y < yMax; y++, pvDestLoc += lDestDelta, pvSrcLoc += lSrcDelta)
            {
                RtlCopyMemory(pvDestLoc + xMin, pvSrcLoc + xMin, (xMax - xMin) * 4);
            }
        }

        cxImage = xMax - xMin;
        cyImage = yMax - yMin;
    }
    else
    {
        // Setup data
        dng.iDestWidth  = iDestWidth;
        dng.iClipWidth  = iClipWidth;
        dng.iSrcWidth   = lSrcWidth;
        dng.iSrcBufWidth = lSrcBufWidth;

        dng.cxLeftWidth    = ngi->ulLeftWidth;
        dng.cxRightWidth   = ngi->ulRightWidth;

        dng.fTileMode = (ngi->flFlags & DSDNG_TILE);

        // Calculate clip stuff

        // Pre-calc corner stretching variables
        dng.fShowMiddle = ((iDestWidth  - dng.cxLeftWidth - dng.cxRightWidth > 0) && (lSrcWidth - dng.cxLeftWidth - dng.cxRightWidth > 0));

        if (!dng.fShowMiddle)
        {
            dng.cxNewLeftWidth  = (dng.cxLeftWidth + dng.cxRightWidth == 0) ? 0 : (dng.cxLeftWidth * dng.iDestWidth) / (dng.cxLeftWidth + dng.cxRightWidth);
            dng.cxNewRightWidth = dng.iDestWidth - dng.cxNewLeftWidth;
        }
        else
        {
            dng.cxNewLeftWidth  = dng.cxLeftWidth;
            dng.cxNewRightWidth = dng.cxRightWidth;
        }

        // Pre-calc Left side variables
        dng.xMinLeft = dng.cxClipMin;
        dng.xMaxLeft = min(dng.cxNewLeftWidth, dng.cxClipMax);
        if (!dng.fShowMiddle && dng.cxNewLeftWidth)
        {
            DNG_InitStretch(&dng.stretchLeft, dng.cxNewLeftWidth, dng.cxLeftWidth, dng.xMinLeft, dng.xMaxLeft);
        }

        // Pre-calc Horizontal Middle Variables
        dng.cxMiddleWidth    = dng.iSrcWidth  - dng.cxLeftWidth - dng.cxRightWidth;
        dng.cxNewMiddleWidth = dng.iDestWidth - dng.cxNewLeftWidth - dng.cxNewRightWidth;
        dng.xMinMiddle = max(dng.cxNewLeftWidth, dng.cxClipMin);
        dng.xMaxMiddle = min(dng.cxNewLeftWidth + dng.cxNewMiddleWidth, dng.cxClipMax);
        if (dng.fShowMiddle)
        {
            DNG_InitStretch(&dng.stretchMiddle, dng.cxNewMiddleWidth, dng.cxMiddleWidth, dng.xMinMiddle - dng.cxNewLeftWidth, dng.xMaxMiddle - dng.cxNewLeftWidth);
        }

        // Pre-calc Right side variables
        dng.xMinRight = max(dng.iDestWidth - dng.cxNewRightWidth, dng.cxClipMin) - dng.cxNewLeftWidth - dng.cxNewMiddleWidth;
        dng.xMaxRight = min(dng.iDestWidth, dng.cxClipMax) - dng.cxNewLeftWidth - dng.cxNewMiddleWidth;
        if (!dng.fShowMiddle && dng.cxNewRightWidth)
        {
            DNG_InitStretch(&dng.stretchRight, dng.cxNewRightWidth, dng.cxRightWidth, dng.xMinRight, dng.xMaxRight);
        }

        BOOL fShowVertMiddle = ((iDestHeight - ngi->ulTopHeight - ngi->ulBottomHeight > 0) && (lSrcHeight - ngi->ulTopHeight - ngi->ulBottomHeight > 0));
        int cyTopHeight    = ngi->ulTopHeight;
        int cyBottomHeight = ngi->ulBottomHeight;
        int cyNewTopHeight;
        int cyNewBottomHeight;
        if (!fShowVertMiddle)
        {
            cyNewTopHeight = (cyTopHeight + cyBottomHeight == 0) ? 0 : (cyTopHeight * iDestHeight) / (cyTopHeight + cyBottomHeight);
            cyNewBottomHeight = iDestHeight - cyNewTopHeight;
        }
        else
        {
            cyNewTopHeight    = cyTopHeight;
            cyNewBottomHeight = cyBottomHeight;
        }

        // Draw Bottom
        // Draw the scan line from (iDestHeight - cyNewBottomHeight) to less than iDestHeight, in screen coordinates
        int yMin = max(iDestHeight - cyNewBottomHeight, cyClipMin);
        int yMax = min(iDestHeight, cyClipMax);

        if (cyClipMax > iDestHeight - cyNewBottomHeight)
        {
            dng.pvDestBits = pvDestBits;
            dng.pvSrcBits = lSrcBits;
            if (cyBottomHeight == cyNewBottomHeight)
            {
                int yDiff = yMin - (iDestHeight - cyNewBottomHeight);
                dng.pvDestBits -= (cyBottomHeight - 1 - yDiff) * lDestDelta;
                
                dng.pvSrcBits  -= (cyBottomHeight - 1 - yDiff) * lSrcDelta;
                for (int y = yMin; y < yMax; y++, dng.pvDestBits += lDestDelta, dng.pvSrcBits += lSrcDelta)
                {
                    DNG_DrawRow(&dng);
                }
            }
            else if (cyNewBottomHeight > 0)
            {
                DNGSTRETCH stretch;
                DNG_InitStretch(&stretch, cyNewBottomHeight, cyBottomHeight, cyNewBottomHeight - (yMax - iDestHeight + cyNewBottomHeight), cyNewBottomHeight - (yMin - iDestHeight + cyNewBottomHeight));
                DNG_StretchCol(&dng, &stretch);
            }
        }

        // Draw Middle
        // Draw the scan line from cyNewTopHeight to less than (iDestHeight - cyNewBottomHeight), in screen coordinates
        int cySrcTileSize = lSrcHeight - ngi->ulTopHeight - ngi->ulBottomHeight;
        int cyDestTileSize = iDestHeight - ngi->ulTopHeight - ngi->ulBottomHeight;
        if (fShowVertMiddle && (cySrcTileSize>0) && (cyDestTileSize>0) && (cyClipMin < iDestHeight - cyNewBottomHeight) && (cyClipMax > cyNewTopHeight))
        {
            dng.pvDestBits = pvDestBits - ngi->ulBottomHeight * lDestDelta;
            dng.pvSrcBits = lSrcBits - ngi->ulBottomHeight * lSrcDelta;

            int yMin = max(cyTopHeight, cyClipMin);

            if (dng.fTileMode)
            {
                // Start off tile
                dng.pvDestBits -= (cyDestTileSize - 1) * lDestDelta;
                dng.pvSrcBits  -= (cySrcTileSize - 1)  * lSrcDelta;

                int yDiff = yMin - cyTopHeight;
                dng.pvDestBits += yDiff * lDestDelta;

                int yOffset = (yDiff % cySrcTileSize);
                dng.pvSrcBits += yOffset * dng.lSrcDelta;
                int iTileOffset = cySrcTileSize - yOffset;

                int yMax = min(yMin + min(cySrcTileSize, cyDestTileSize), min(iDestHeight - cyBottomHeight, cyClipMax));
                for (int y = yMin; y < yMax; y++, dng.pvDestBits += lDestDelta, dng.pvSrcBits += lSrcDelta)
                {
                    DNG_DrawRow(&dng);
                    iTileOffset--;
                    if (iTileOffset == 0)
                    {
                        iTileOffset = cySrcTileSize;
                        dng.pvSrcBits -= lSrcDelta * cySrcTileSize;
                    }
                }

                // Repeat tile pattern
                dng.pvSrcBits = dng.pvDestBits - (lDestDelta * cySrcTileSize);
                yMin = yMax;
                yMax = min(iDestHeight - cyBottomHeight, cyClipMax);
                for (int y = yMin; y < yMax; y++, dng.pvDestBits += lDestDelta, dng.pvSrcBits += lDestDelta)
                {
                    RtlCopyMemory(dng.pvDestBits + dng.cxClipMin, dng.pvSrcBits + dng.cxClipMin, dng.iClipWidth * sizeof(ULONG));
                }
            }
            else
            {
                int yMax = min(iDestHeight - cyBottomHeight, cyClipMax);

                DNGSTRETCH stretch;
                DNG_InitStretch(&stretch, cyDestTileSize, cySrcTileSize, cyDestTileSize - (yMax - cyTopHeight), cyDestTileSize - (yMin - cyTopHeight));
                // Convert from screen coords to DIB coords
                DNG_StretchCol(&dng, &stretch);
            }
        }

        // Draw Top
        // Draw the scan line from 0 to less than cyNewTopHeight, in screen coordinates
        yMin = cyClipMin;
        yMax = min(cyNewTopHeight, cyClipMax);

        if (cyClipMin < cyNewTopHeight)
        {
            dng.pvDestBits = pvDestBits - (iDestHeight - cyNewTopHeight) * lDestDelta;
            dng.pvSrcBits = lSrcBits - (lSrcHeight - ngi->ulTopHeight) * lSrcDelta;
            if (cyTopHeight == cyNewTopHeight)
            {
                dng.pvDestBits -= (cyTopHeight - 1 - yMin) * lDestDelta;
                dng.pvSrcBits  -= (cyTopHeight - 1 - yMin) * lSrcDelta;
                for (int y = yMin; y < yMax; y++, dng.pvDestBits += lDestDelta, dng.pvSrcBits += lSrcDelta)
                {
                    DNG_DrawRow(&dng);
                }
            }
            else if (cyNewTopHeight > 0)
            {
                DNGSTRETCH stretch;
                DNG_InitStretch(&stretch, cyNewTopHeight, cyTopHeight, cyNewTopHeight - yMax, cyNewTopHeight - yMin);
                DNG_StretchCol(&dng, &stretch);
            }
        }
    }

    if (bMirror)
    {
        // Flip the buffer
        for (int y = 0; y < iClipHeight; y++)
        {
            ULONG* pvLeftBits = (ULONG *) psoScratch->pvScan0 + (y * lDestDelta);
            ULONG* pvRightBits = pvLeftBits + iClipWidth - 1;
            for (int x = 0; x < (iClipWidth / 2); x++)
            {
                ULONG ulTemp = *pvLeftBits;
                *pvLeftBits = *pvRightBits;
                *pvRightBits = ulTemp;

                pvLeftBits++;
                pvRightBits--;
            }
        }
    }
}

static void RenderNineGrid(
    SURFOBJ            *psoDst,
    SURFOBJ            *psoSrc,
    SURFOBJ            *psoScratch,
    CLIPOBJ            *pco,
    RECTL              *prclClip,
    XLATEOBJ           *pxlo,
    RECTL              *prclDst,
    RECTL              *prclSrc,
    DS_NINEGRIDINFO    *ngi,
    PDRAWSTREAMINFO     pdsi,
    BOOL                bMirror)
{
    PSURFACE pSurfSrc = SURFOBJ_TO_SURFACE(psoSrc);
    PSURFACE pSurfDst = SURFOBJ_TO_SURFACE(psoDst);

    PDEVOBJ pdoSrc(pSurfSrc->hdev());
    PDEVOBJ pdoDst(pSurfDst->hdev());

    XLATE * pxl = (XLATE *) pxlo;

    SIZEL   sizlScratch;

    // only mirror the contents if we need to

    bMirror = bMirror && (ngi->flFlags & DSDNG_MUSTFLIP);
        
    // render nine grid into scratch

    ERECTL erclClip = *prclClip;

    if(bMirror)
    {
        // We need to remap the clip to ensure we generate the right flipped bits
        erclClip.right = prclDst->right - (prclClip->left - prclDst->left);
        erclClip.left = prclDst->right - (prclClip->right - prclDst->left);
    }

    RenderNineGridInternal(psoScratch, psoSrc, &erclClip, prclDst, prclSrc, ngi, pdsi, bMirror);
    
    // copy scratch to destination
    
    LONG    lClipWidth = prclClip->right - prclClip->left;
    LONG    lClipHeight = prclClip->bottom - prclClip->top;

    ERECTL  erclScratch(0, 0, lClipWidth, lClipHeight);

    if(ngi->flFlags & DSDNG_PERPIXELALPHA)
    {
        EBLENDOBJ   eBlendObj;

        eBlendObj.BlendFunction.AlphaFormat = AC_SRC_ALPHA;
        eBlendObj.BlendFunction.BlendFlags = 0;
        eBlendObj.BlendFunction.SourceConstantAlpha = 255;
        eBlendObj.BlendFunction.BlendOp = AC_SRC_OVER;

        eBlendObj.pxlo32ToDst = pdsi->pxloBGRAToDst;
        eBlendObj.pxloDstTo32 = pdsi->pxloDstToBGRA;
        eBlendObj.pxloSrcTo32 = pdsi->pxloSrcToBGRA;
        
        PPFNDIRECT(psoDst, AlphaBlend)(psoDst, psoScratch, pco, pxlo, prclClip, &erclScratch, &eBlendObj);
    }
    else if(ngi->flFlags & DSDNG_TRANSPARENT)
    {
        PPFNDIRECT(psoDst, TransparentBlt)(psoDst, psoScratch, pco, pxlo, prclClip, &erclScratch, ngi->crTransparent, 0);
    }
    else
    {
        PPFNDIRECT(psoDst, CopyBits)(psoDst, psoScratch, pco, pxlo, prclClip, &gptlZero);
    }
    
}

/******************************Private*Routine******************************\
* xxEngNineGrid
*
* This stuff will be moved to EngNineGrid
*
*
* History:
*
*    3-18-2001 bhouse Created it
*
\**************************************************************************/

static int xxEngNineGrid(
    SURFOBJ            *psoDst,
    SURFOBJ            *psoSrc,
    CLIPOBJ            *pco,
    XLATEOBJ           *pxlo,
    RECTL *             prclDst,
    RECTL *             prclSrc,
    DS_NINEGRIDINFO    *ngi,
    PDRAWSTREAMINFO     pdsi)
{
    BOOL    bRet = FALSE;

    PSURFACE pSurfSrc = SURFOBJ_TO_SURFACE(psoSrc);
    PSURFACE pSurfDst = SURFOBJ_TO_SURFACE(psoDst);

    PDEVOBJ pdoSrc(pSurfSrc->hdev());
    PDEVOBJ pdoDst(pSurfDst->hdev());

    XLATE * pxl = (XLATE *) pxlo;
    ERECTL  erclDst = *prclDst;

    BOOL bMirror = (erclDst.left > erclDst.right);
    
    if(bMirror)
    {
        LONG    lRight = erclDst.left;
        erclDst.left = erclDst.right;
        erclDst.right = lRight;
    }

    // NOTE: TRUESIZE is a hack.  The caller should do this reduction
    //       and pass us an appropriate destination.
    // TODO: Talk with Justin Mann about changing his behavior in how
    //       he calls us here.  We should add assertions that the
    //       destination dimensions never exceeds the source dimensions and
    //       modify GdiDrawStream callers to pass appropriate data.

    if(ngi->flFlags & DSDNG_TRUESIZE)
    {
        LONG lSrcWidth = prclSrc->right - prclSrc->left;
        LONG lSrcHeight = prclSrc->bottom - prclSrc->top;

        // reduce destination to source size

        if((erclDst.right - erclDst.left) > lSrcWidth)
        {
            if(bMirror)
                erclDst.left = erclDst.right - lSrcWidth;
            else
                erclDst.right = erclDst.left + lSrcWidth;
        }
    
        if((erclDst.bottom - erclDst.top) > lSrcHeight)
        {
            if(bMirror)
                erclDst.top = erclDst.bottom - lSrcHeight;
            else
                erclDst.bottom = erclDst.top + lSrcHeight;
        }
    }

    SIZEL   sizlScratch;
    
    ERECTL erclClip = erclDst;

    // For now, we only support 32bpp sources

    ASSERTGDI(psoSrc->iBitmapFormat == BMF_32BPP, "EngNineGrid: source not 32bpp");

    if(pco != (CLIPOBJ *) NULL && pco->iDComplexity != DC_TRIVIAL)
    {
        erclClip *= pco->rclBounds;
    }

    ASSERTGDI(erclClip.left >= 0 &&
              erclClip.top >= 0 &&
              erclClip.right <= psoDst->sizlBitmap.cx &&
              erclClip.bottom <= psoDst->sizlBitmap.cy, "EngNineGrid: bad clip");


    if(!erclClip.bEmpty())
    {
        LONG    lClipWidth = erclClip.right - erclClip.left;
        LONG    lClipHeight = erclClip.bottom - erclClip.top;

        ASSERTGDI(lClipWidth > 0, "RenderNineGrid: clip width <= 0");
        ASSERTGDI(lClipHeight > 0, "RenderNineGrid: clip height <= 0");

        #define SCRATCH_WIDTH    (256)
        #define SCRATCH_HEIGHT   (64)

#if defined(USE_NINEGRID_STATIC)

        SEMOBJ hsem(gNineGridSem);
        static HSURF hsurfScratch = NULL;

        if(hsurfScratch == NULL)
        {
            DEVBITMAPINFO   dbmi;
            SURFMEM         surfScratch;

            XEPALOBJ    palScratch(pSurfSrc->ppal());

            if(!palScratch.bValid())
            {
                WARNING("xxEngNineGrid: palScratch is not valid\n");
                goto exit;
            }

            dbmi.cxBitmap = SCRATCH_WIDTH;
            dbmi.cyBitmap = SCRATCH_HEIGHT;
            dbmi.iFormat = pSurfSrc->iFormat();
            dbmi.fl = 0;
            dbmi.hpal = palScratch.hpal();

            if(!surfScratch.bCreateDIB(&dbmi, (VOID*) NULL))
            {
                WARNING("xxEngNineGrid: could not create surfScratch\n");
                goto exit;
            }

            surfScratch.vKeepIt();
            surfScratch.vSetPID(OBJECT_OWNER_PUBLIC);

            // Ensure that the scratch surface is not cached by driver
            surfScratch.ps->iUniq(0);

            hsurfScratch = surfScratch.ps->hsurf();
        
        }

        SURFREFAPI surfScratch(hsurfScratch);

        if(!surfScratch.bValid())
        {
            WARNING("xxEngNineGrid: SURFREFAPI(surfScratch) failed\n");
            goto exit;
        }

        SURFOBJ * psoScratch = surfScratch.pSurfobj();
#else
        SURFACE *pSurfScratch;
        SURFMEM dimoScratch;

        {
            DEVBITMAPINFO   dbmi;

            XEPALOBJ    palScratch(pSurfSrc->ppal());

            if(!palScratch.bValid())
            {
                WARINING("xxEngNineGrid: palScratch is not valid\n");
                goto exit;
            }

            dbmi.cxBitmap = SCRATCH_WIDTH;
            dbmi.cyBitmap = SCRATCH_HEIGHT;
            dbmi.iFormat = pSurfSrc->iFormat();
            dbmi.fl = 0;
            dbmi.hpal = palScratch.hpal();

            if(!dimoScratch.bCreateDIB(&dbmi, (VOID*) NULL))
            {
                WARINING("xxEngNineGrid: could not create surfScratch\n");
                goto exit;
            }

            pSurfScratch = dimoScratch.ps;
        }

        SURFOBJ *psoScratch = pSurfScratch->pSurfobj();
        
#endif

        if(lClipWidth >  SCRATCH_WIDTH || lClipHeight > SCRATCH_HEIGHT)
        {
            LONG    lBufWidth = SCRATCH_WIDTH;
            LONG    lBufHeight = SCRATCH_HEIGHT;

            LONG lReducedClipTop = erclClip.top;

            while(lReducedClipTop < erclClip.bottom)
            {
                LONG lReducedClipBottom = lReducedClipTop + lBufHeight;

                if(lReducedClipBottom > erclClip.bottom)
                    lReducedClipBottom = erclClip.bottom;

                LONG lReducedClipLeft = erclClip.left;

                while(lReducedClipLeft < erclClip.right)
                {
                    LONG lReducedClipRight = lReducedClipLeft + lBufWidth;

                    if(lReducedClipRight > erclClip.right)
                        lReducedClipRight = erclClip.right;

                    ERECTL erclReducedClip(lReducedClipLeft, lReducedClipTop,
                                           lReducedClipRight, lReducedClipBottom);

                    RenderNineGrid(psoDst,
                                   psoSrc,
                                   psoScratch,
                                   pco,
                                   &erclReducedClip,
                                   pxlo,
                                   &erclDst,
                                   prclSrc,
                                   ngi,
                                   pdsi,
                                   bMirror);

                    lReducedClipLeft += lBufWidth;
                }

                lReducedClipTop += lBufHeight;
            }
        }
        else
        {
            RenderNineGrid(psoDst, psoSrc, psoScratch, pco, &erclClip, pxlo, &erclDst, prclSrc, ngi, pdsi, bMirror);
        }
    }

    bRet = TRUE;

exit:

    return bRet;
}

/******************************Private*Routine******************************\
* EngNineGrid
*
* Purpose:  Draws a nine grid.
*
* Description:
*
*    <fill in details>
*
* History:
*
*    3-18-2001 bhouse Created it
*
\**************************************************************************/

BOOL EngNineGrid(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    PRECTL      prclDst,
    PRECTL      prclSrc,
    PNINEGRID   png,
    BLENDOBJ*   pBlendObj,
    PVOID       pvReserved)
{
    DRAWSTREAMINFO  dsi;
    EBLENDOBJ *peBlendObj = (EBLENDOBJ*)pBlendObj;

    //
    // The source surface of EngNineGrid should always be a 
    // GDI managed (memory) one.
    //

    if (psoSrc->iType != STYPE_BITMAP || psoSrc->iBitmapFormat != BMF_32BPP)
    {
        WARNING("EngNineGrid: psoSrc is not STYPE_BITMAP or not 32 Bpp\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    dsi.bCalledFromBitBlt = FALSE;
    dsi.dss.blendFunction = pBlendObj->BlendFunction;
    dsi.dss.crColorKey = png->crTransparent;
    dsi.dss.ptlSrcOrigin.x = 0;
    dsi.dss.ptlSrcOrigin.y = 0;
    dsi.pptlDstOffset = &gptlZero;
    dsi.pvStream = NULL;
    dsi.ulStreamLength = 0;
    dsi.pxloBGRAToDst = peBlendObj->pxlo32ToDst;
    dsi.pxloDstToBGRA = peBlendObj->pxloDstTo32;
    dsi.pxloSrcToBGRA = peBlendObj->pxloSrcTo32;

    return xxEngNineGrid(psoDst, psoSrc, pco, pxlo, prclDst, prclSrc, (DS_NINEGRIDINFO *) png, &dsi);
}

#if 0
    // code to convert nine grid to blt commands                    

                    LONG lSrcLeftWidth = cmd->ngi.ulLeftWidth;
                    LONG lSrcRightWidth = cmd->ngi.ulRightWidth;
                    LONG lSrcTopHeight = cmd->ngi.ulLeftWidth;
                    LONG lSrcBottomHeight = cmd->ngi.ulRightWidth;

                    LONG lDstLeftWidth = lSrcLeftWidth;
                    LONG lDstRightWidth = lSrcRightWidth;
                    LONG lDstTopHeight = lSrcTopHeight;
                    LONG lDstBottomHeight = lSrcBottomHeight;

                    LONG lDstWidth = erclDst.right - erclDst.left;
                    BOOL bDrawMiddle;
                    BOOL bMirror = (lDstWidth < 0);

                    if(bMirror)
                    {
                        // horizontal mirror

                        lDstLeftWidth = -lDstLeftWidth;
                        lDstRightWidth = -lDstRightWidth;

                        bDrawMiddle = (lDstWidth < lDstLeftWidth + lDstRightWidth);
                    }
                    else
                    {
                        bDrawMiddle = (lDstWidth > lDstLeftWidth + lDstRightWidth);
                    }

                    if(!bDrawMiddle && (lDstWidth != (lDstLeftWidth + lDstRightWidth)))
                    {
                        if((lDstLeftWidth + lDstRightWidth) == 0)
                            continue;  // this should never happen, we can probably remove

                        lDstLeftWidth = lDstLeftWidth * lDstWidth / (lDstLeftWidth + lDstRightWidth);
                        lDstRightWidth = lDstWidth - lDstLeftWidth;
                    }


                    DS_BLT  cmdBlts[9];
                    DS_BLT *cmdBlt = cmdBlts;

                    if(cmd->ngi.flFlags & DSDNG_TRUESIZE)
                    {
                    
                        // left top
    
                        cmdBlt->ulCmdID = DS_BLTID;
                        cmdBlt->flFlags = 0;
                        if(cmd->ngi.flFlags & DSDNG_PERPIXELALPHA) cmdBlt->flFlags |= DSBLT_ALPHABLEND;
                        else if(cmd->ngi.flFlags & DSDNG_TRANSPARENT) cmdBlt->flFlags |= DSBLT_TRANSPARENT;


                        LONG lDstHeight = erclDst.bottom - erclDst.top;
                        LONG lSrcWidth = cmd->rclSrc.right - cmd->rclSrc.left;
                        LONG lSrcHeight = cmd->rclSrc.bottom - cmd->rclSrc.top;

                        LONG lWidth;

                        if(bMirror)
                        {
                            lWidth = (-lSrcWidth  > lDstWidth ? -lSrcWidth : lDstWidth);
                        }
                        else
                        {
                            lWidth = (lSrcWidth < lDstWidth ? lSrcWidth : lDstWidth);
                        }

                        LONG lHeight = (lSrcHeight < lDstHeight ? lSrcHeight : lDstHeight);
    
                        cmdBlt->rclDst.left = erclDst.left;
                        cmdBlt->rclDst.top = erclDst.top;
                        cmdBlt->rclDst.right = erclDst.left + lWidth;
                        cmdBlt->rclDst.bottom = erclDst.top + lHeight;
    
                        cmdBlt->rclSrc.left = cmd->rclSrc.left;
                        cmdBlt->rclSrc.top = cmd->rclSrc.top;
                        cmdBlt->rclSrc.right = cmd->rclSrc.left + lWidth;
                        cmdBlt->rclSrc.bottom = cmd->rclSrc.top + lHeight;

                        cmd++;
                    
                    }
                    else
                    {
                        // left top
    
                        cmdBlt->ulCmdID = DS_BLTID;
                        cmdBlt->flFlags = 0;
                        if(cmd->ngi.flFlags & DSDNG_TILE) cmdBlt->flFlags |= DSBLT_HTILE | DSBLT_VTILE;
                        if(cmd->ngi.flFlags & DSDNG_PERPIXELALPHA) cmdBlt->flFlags |= DSBLT_ALPHABLEND;
                        else if(cmd->ngi.flFlags & DSDNG_TRANSPARENT) cmdBlt->flFlags |= DSBLT_TRANSPARENT;
    
                        cmdBlt->rclDst.left = erclDst.left;
                        cmdBlt->rclDst.top = erclDst.top;
                        cmdBlt->rclDst.right = erclDst.left + lDstLeftWidth;
                        cmdBlt->rclDst.bottom = erclDst.top + lDstTopHeight;
    
                        cmdBlt->rclSrc.left = cmd->rclSrc.left;
                        cmdBlt->rclSrc.top = cmd->rclSrc.top;
                        cmdBlt->rclSrc.right = cmd->rclSrc.left + lSrcLeftWidth;
                        cmdBlt->rclSrc.bottom = cmd->rclSrc.top + lSrcTopHeight;
    
                        // middle top
    
                        cmdBlt++;
                        *cmdBlt = cmdBlt[-1];
    
                        cmdBlt->rclDst.left = cmdBlt->rclDst.right;
                        cmdBlt->rclDst.right = erclDst.right - lDstRightWidth;
    
                        cmdBlt->rclSrc.left = cmdBlt->rclSrc.right;
                        cmdBlt->rclSrc.right = cmd->rclSrc.right - lSrcRightWidth;
    
                        // right top
    
                        cmdBlt++;
                        *cmdBlt = cmdBlt[-1];
    
                        cmdBlt->rclDst.left = cmdBlt->rclDst.right;
                        cmdBlt->rclDst.right = erclDst.right;
    
                        cmdBlt->rclSrc.left = cmdBlt->rclSrc.right;
                        cmdBlt->rclSrc.right = cmd->rclSrc.right;
    
                        // left middle
    
                        cmdBlt++;
                        *cmdBlt = cmdBlt[-1];
    
                        cmdBlt->rclDst.left = erclDst.left;
                        cmdBlt->rclDst.top = erclDst.top + lDstTopHeight;
                        cmdBlt->rclDst.right = erclDst.left + lDstLeftWidth;
                        cmdBlt->rclDst.bottom = erclDst.bottom - lDstBottomHeight;
    
                        cmdBlt->rclSrc.left = cmd->rclSrc.left;
                        cmdBlt->rclSrc.top = cmd->rclSrc.top + lSrcTopHeight;
                        cmdBlt->rclSrc.right = cmd->rclSrc.left + lSrcLeftWidth;
                        cmdBlt->rclSrc.bottom = cmd->rclSrc.bottom - lSrcBottomHeight;
    
    
                        // middle middle
    
                        if(bDrawMiddle)
                        {
                            cmdBlt++;
                            *cmdBlt = cmdBlt[-1];
                            
                            cmdBlt->rclDst.left = cmdBlt->rclDst.right;
                            cmdBlt->rclDst.right = erclDst.right - lDstRightWidth;
        
                            cmdBlt->rclSrc.left = cmdBlt->rclSrc.right;
                            cmdBlt->rclSrc.right = cmd->rclSrc.right - lSrcRightWidth;
                        }
                        
                        // right middle
    
                        cmdBlt++;
                        *cmdBlt = cmdBlt[-1];
    
                        cmdBlt->rclDst.left = erclDst.right - lDstRightWidth;
                        cmdBlt->rclDst.right = erclDst.right;
    
                        cmdBlt->rclSrc.left = cmd->rclSrc.right - lSrcRightWidth;
                        cmdBlt->rclSrc.right = cmd->rclSrc.right;
    
                        // left bottom
    
                        cmdBlt++;
                        *cmdBlt = cmdBlt[-1];
    
                        cmdBlt->rclDst.left = erclDst.left;
                        cmdBlt->rclDst.top = erclDst.bottom - lDstBottomHeight;
                        cmdBlt->rclDst.right = erclDst.left + lDstLeftWidth;
                        cmdBlt->rclDst.bottom = erclDst.bottom;
    
                        cmdBlt->rclSrc.left = cmd->rclSrc.left;
                        cmdBlt->rclSrc.top = cmd->rclSrc.bottom - lSrcBottomHeight;
                        cmdBlt->rclSrc.right = cmd->rclSrc.left + lSrcLeftWidth;
                        cmdBlt->rclSrc.bottom = cmd->rclSrc.bottom;
                        
                        // middle bottom
    
                        cmdBlt++;
                        *cmdBlt = cmdBlt[-1];
                        
                        cmdBlt->rclDst.left = cmdBlt->rclDst.right;
                        cmdBlt->rclDst.right = erclDst.right - lDstRightWidth;
    
                        cmdBlt->rclSrc.left = cmdBlt->rclSrc.right;
                        cmdBlt->rclSrc.right = cmd->rclSrc.right - lSrcRightWidth;
                        
                        // right bottom
    
                        cmdBlt++;
                        *cmdBlt = cmdBlt[-1];
    
                        cmdBlt->rclDst.left = cmdBlt->rclDst.right;
                        cmdBlt->rclDst.right = erclDst.right;
    
                        cmdBlt->rclSrc.left = cmdBlt->rclSrc.right;
                        cmdBlt->rclSrc.right = cmd->rclSrc.right;
    
                        cmdBlt++;
                    }
        
                    COLORREF crSave = pdss->crColorKey;
                    BLENDFUNCTION bfxSave = pdss->blendFunction;

                    pdss->blendFunction.AlphaFormat = AC_SRC_ALPHA;
                    pdss->blendFunction.BlendFlags = 0;
                    pdss->blendFunction.SourceConstantAlpha = 255;
                    pdss->blendFunction.BlendOp = AC_SRC_OVER;

                    // It is safe to go direct from here ... the source can't be a sprite
                    // and the destination has already been taken care of (we have to
                    // go through the sprite layer for the dest to get this far).
                    bRet = (*PPFNDRVENG(psoDst, DrawStream))(psoDst, psoSrc, pco, pxlo, prclDstClip, &gptlZero,
                                  (ULONG) ((BYTE*) cmdBlt - (BYTE*) cmdBlts), cmdBlts, pdss);


                    pdss->crColorKey = crSave;
                    pdss->blendFunction = bfxSave;
#endif


#if DS_ENABLE_BLT

int EngTileBits(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL *     prclDst,
    RECTL *     prclSrc,
    POINTL *    tileOrigin)
{
    int iRet = TRUE;

    if(tileOrigin->x != 0 || tileOrigin->y != 0)
        return FALSE;

    PSURFACE pSurfSrc = SURFOBJ_TO_SURFACE(psoSrc);
    PSURFACE pSurfDst = SURFOBJ_TO_SURFACE(psoDst);
    
    PDEVOBJ pdoSrc(pSurfSrc->hdev());
    PDEVOBJ pdoDst(pSurfDst->hdev());

    XLATE * pxl = (XLATE *) pxlo;

    // TODO bhouse
    // we should handle all of the clipping cases
    // in the fast copy.

    LONG    tileWidth = prclSrc->right - prclSrc->left;
    LONG    tileHeight = prclSrc->bottom - prclSrc->top;
    
    if(tileWidth <= 0 || tileHeight <= 0)
        return FALSE;

    PFN_DrvCopyBits pfnCopyBits;

    // TODO: create a new dest if DC_RECT and adjust tileOrigin

     
    if((pSurfSrc->iType() == STYPE_BITMAP && !(pSurfSrc->fjBitmap() & BMF_NOTSYSMEM)) &&
       (pSurfDst->iType() == STYPE_BITMAP && !(pSurfDst->fjBitmap() & BMF_NOTSYSMEM)) &&
       pxl->bIsIdentity() &&
       (pco == NULL || pco->iDComplexity == DC_TRIVIAL) &&
       pSurfSrc->iFormat() >= BMF_8BPP &&
       pSurfSrc->iFormat() <= BMF_32BPP)
    {
        // tile it by hand nice and fast

        // TODO bhouse
        // Easy optimization here, we don't need to sync
        // every time ... seems wastefull as heck

        pdoSrc.vSync(psoDst,NULL,0);
        pdoDst.vSync(psoSrc,NULL,0);

        ULONG   ulBytesPerPixel = (pSurfSrc->iFormat() - BMF_8BPP) + 1;
        ULONG   ulTileWidthBytes = tileWidth * ulBytesPerPixel;
        ULONG   ulDstWidthBytes = (prclDst->right - prclDst->left) * ulBytesPerPixel;
        
        PBYTE   pbSrcStart = (PBYTE) pSurfSrc->pvScan0() +
                        (prclSrc->top * pSurfSrc->lDelta()) +
                        (prclSrc->left * ulBytesPerPixel);
        
        PBYTE   pbSrcEnd = (PBYTE) pSurfSrc->pvScan0() +
                        (prclSrc->bottom * pSurfSrc->lDelta()) +
                        (prclSrc->left * ulBytesPerPixel);
        
        PBYTE   pbDst = (PBYTE) pSurfDst->pvScan0() +
                        (prclDst->top * pSurfDst->lDelta()) +
                        (prclDst->left * ulBytesPerPixel);
        
        PBYTE   pbDstEnd = (PBYTE) pSurfDst->pvScan0() +
                        (prclDst->bottom * pSurfDst->lDelta()) +
                        (prclDst->left * ulBytesPerPixel);
        
        PBYTE   pbSrc = pbSrcStart;

        while(pbDst != pbDstEnd)
        {
            PBYTE   pbDstLineEnd = pbDst + ulDstWidthBytes;
            PBYTE   pbDstLine = pbDst;

            while(pbDstLine < pbDstLineEnd)
            {
                ULONG   ulCopyBytes = (ULONG)(pbDstLineEnd - pbDstLine);

                if(ulCopyBytes > ulTileWidthBytes)
                    ulCopyBytes = ulTileWidthBytes;

                RtlCopyMemory(pbDstLine, pbSrc, ulCopyBytes);

                pbDstLine += ulCopyBytes;

            }

            pbSrc += pSurfSrc->lDelta();
            
            if(pbSrc == pbSrcEnd)
                pbSrc = pbSrcStart;

            pbDst += pSurfDst->lDelta();
        }

        return TRUE;

    }
//    else if(pSurfDst->iType() == STYPE_BITMAP)
//        pfnCopyBits = EngCopyBits;
    else
        pfnCopyBits = PPFNGET(pdoDst,CopyBits,pSurfDst->flags());
    
    // brain dead method

    LONG    y = prclDst->top;
    LONG    yEnd = prclDst->bottom;
    LONG    xEnd = prclDst->right;
    RECTL   dstRect;
    
    while(y < yEnd)
    {
        LONG    dy = yEnd - y;

        if(dy > tileHeight) dy = tileHeight;

        LONG x = prclDst->left;

        while(x < xEnd)
        {
            LONG dx = xEnd - x;

            if(dx > tileWidth) dx = tileWidth;


            dstRect.left = x;
            dstRect.top = y;
            dstRect.right = x + dx;
            dstRect.bottom = y + dy;

            // TODO bhouse
            // Lame clipping has to be fixed
            if(pco == NULL || pco->iDComplexity == DC_TRIVIAL || bIntersect(&pco->rclBounds, &dstRect))
                if(!(*pfnCopyBits)(psoDst, psoSrc, pco, pxlo, &dstRect, (POINTL*) prclSrc))
                    return FALSE;
            
            x += dx;
        }

        y += dy;
    }

    return TRUE;

}

int EngTransparentTile(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL *     prclDst,
    RECTL *     prclSrc,
    POINTL *    tileOrigin,
    COLORREF    crTransparentColor
    )
{
    int iRet = TRUE;

    if(tileOrigin->x != 0 || tileOrigin->y != 0)
        return FALSE;

    PSURFACE pSurfSrc = SURFOBJ_TO_SURFACE(psoSrc);
    PSURFACE pSurfDst = SURFOBJ_TO_SURFACE(psoDst);
    
    PDEVOBJ pdoSrc(pSurfSrc->hdev());
    PDEVOBJ pdoDst(pSurfDst->hdev());

    XLATE * pxl = (XLATE *) pxlo;

    // TODO bhouse
    // we should handle all of the clipping cases
    // in the fast copy.

    LONG    tileWidth = prclSrc->right - prclSrc->left;
    LONG    tileHeight = prclSrc->bottom - prclSrc->top;
    
    if(tileWidth <= 0 || tileHeight <= 0)
        return FALSE;

    PFN_DrvTransparentBlt pfnTransparentBlt;
     
//    if(pSurfDst->iType() == STYPE_BITMAP)
//        pfnTransparentBlt = EngTransparentBlt;
//    else
        pfnTransparentBlt = PPFNGET(pdoDst,TransparentBlt,pSurfDst->flags());

    
    // brain dead method

    ERECTL  dstRect;
    ERECTL  srcRect;
    
    LONG    y = prclDst->top;
    LONG    yEnd = prclDst->bottom;
    LONG    xEnd = prclDst->right;

    srcRect.left = prclSrc->left;
    srcRect.top = prclSrc->top;

    while(y < yEnd)
    {
        LONG    dy = yEnd - y;

        if(dy > tileHeight) dy = tileHeight;

        LONG x = prclDst->left;

        dstRect.top = y;
        dstRect.bottom = y + dy;
        
        srcRect.bottom = srcRect.top + dy;

        while(x < xEnd)
        {
            LONG dx = xEnd - x;

            if(dx > tileWidth) dx = tileWidth;


            dstRect.left = x;
            dstRect.right = x + dx;

            srcRect.right = srcRect.left + dx;

            // TODO bhouse
            // Lame clipping has to be fixed
            if(pco == NULL || pco->iDComplexity == DC_TRIVIAL || bIntersect(&pco->rclBounds, &dstRect))
                if(!(*pfnTransparentBlt)(psoDst, psoSrc, pco, pxlo, &dstRect, &srcRect, crTransparentColor, FALSE))
                    return FALSE;
            
            x += dx;
        }

        y += dy;
    }

    return TRUE;

}

int EngAlphaTile(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL *     prclDst,
    RECTL *     prclSrc,
    POINTL *    tileOrigin,
    BLENDOBJ   *pBlendObj
    )
{
    int iRet = TRUE;

    if(tileOrigin->x != 0 || tileOrigin->y != 0)
        return FALSE;

    PSURFACE pSurfSrc = SURFOBJ_TO_SURFACE(psoSrc);
    PSURFACE pSurfDst = SURFOBJ_TO_SURFACE(psoDst);
    
    PDEVOBJ pdoSrc(pSurfSrc->hdev());
    PDEVOBJ pdoDst(pSurfDst->hdev());

    XLATE * pxl = (XLATE *) pxlo;

    // TODO bhouse
    // we should handle all of the clipping cases
    // in the fast copy.

    LONG    tileWidth = prclSrc->right - prclSrc->left;
    LONG    tileHeight = prclSrc->bottom - prclSrc->top;
    
    if(tileWidth <= 0 || tileHeight <= 0)
        return FALSE;

    PFN_DrvAlphaBlend pfnAlphaBlend;
     
//    if(pSurfDst->iType() == STYPE_BITMAP)
//        pfnAlphaBlend = EngAlphaBlend;
//    else
        pfnAlphaBlend = PPFNGET(pdoDst,AlphaBlend,pSurfDst->flags());

    
    // brain dead method

    LONG    y = prclDst->top;
    LONG    yEnd = prclDst->bottom;
    LONG    xEnd = prclDst->right;
    RECTL   dstRect;
    RECTL   srcRect;
    
    while(y < yEnd)
    {
        LONG    dy = yEnd - y;

        if(dy > tileHeight) dy = tileHeight;

        LONG x = prclDst->left;

        while(x < xEnd)
        {
            LONG dx = xEnd - x;

            if(dx > tileWidth) dx = tileWidth;


            dstRect.left = x;
            dstRect.top = y;
            dstRect.right = x + dx;
            dstRect.bottom = y + dy;

            srcRect.left = prclSrc->left;
            srcRect.top = prclSrc->top;
            srcRect.right = srcRect.left + dx;
            srcRect.bottom = srcRect.top + dy;

            // TODO bhouse
            // Lame clipping has to be fixed
            if(pco == NULL || pco->iDComplexity == DC_TRIVIAL || bIntersect(&pco->rclBounds, &dstRect))
                if(!(*pfnAlphaBlend)(psoDst, psoSrc, pco, pxlo, &dstRect, &srcRect, pBlendObj ))
                    return FALSE;
            
            x += dx;
        }

        y += dy;
    }

    return TRUE;

}

int EngDrawStreamBlt(
    SURFOBJ            *psoDst,
    SURFOBJ            *psoSrc,
    CLIPOBJ            *pco,
    XLATEOBJ           *pxlo,
    RECTL *             prclDst,
    RECTL *             prclSrc,
    FLONG               flFlags,
    PDRAWSTREAMINFO     pdsi)
{
    int iRet = TRUE;

    ERECTL  erclDst = *prclDst;

    BOOL bMirror = (erclDst.left > erclDst.right);
    
    if(bMirror)
    {
        LONG    lRight = erclDst.left;
        erclDst.left = erclDst.right;
        erclDst.right = lRight;
    }

    if(pco != NULL && pco->iDComplexity != DC_TRIVIAL && !bIntersect(&pco->rclBounds, &erclDst))
        return TRUE;
    
    PSURFACE pSurfDst = SURFOBJ_TO_SURFACE(psoDst);
    
    PDEVOBJ pdoDst(pSurfDst->hdev());
    
    FLONG   flTile = (flFlags & (DSBLT_VTILE | DSBLT_HTILE));

    if(flTile && flTile != (DSBLT_VTILE | DSBLT_HTILE))
    {
        // TODO: handle the case where we are tiling in one
        //       direction and stretching in the other
        return TRUE;
    }

    if(flFlags & DSBLT_ALPHABLEND)
    {
        EBLENDOBJ   eBlendObj;

        eBlendObj.BlendFunction = pdsi->dss.blendFunction;
        eBlendObj.pxlo32ToDst = pdsi->pxloBGRAToDst;
        eBlendObj.pxloDstTo32 = pdsi->pxloDstToBGRA;
        eBlendObj.pxloSrcTo32 = pdsi->pxloSrcToBGRA;

        if(flTile)
        {

            iRet = EngAlphaTile(psoDst, psoSrc, pco, pxlo, &erclDst,
                            prclSrc, &gptlZero, (BLENDOBJ*) &eBlendObj);
        }
        else
        {
            iRet = (*PPFNGET(pdoDst,AlphaBlend,pSurfDst->flags()))(psoDst, psoSrc, pco, pxlo, &erclDst, prclSrc, &eBlendObj);
        }
    }
    else if(flFlags & DSBLT_TRANSPARENT)
    {
        if(flTile)
        {
            iRet = EngTransparentTile(psoDst, psoSrc, pco, pxlo, &erclDst,
                            prclSrc, &gptlZero, pdsi->dss.crColorKey);
        }
        else
        {
            iRet = (*PPFNGET(pdoDst, TransparentBlt, pSurfDst->flags()))(psoDst, psoSrc, pco, pxlo,
                                  &erclDst, prclSrc,
                                  pdsi->dss.crColorKey,
                                  FALSE);
        }
    }
    else
    {
        if(flTile)
        {
            iRet = EngTileBits(psoDst, psoSrc, pco, pxlo, &erclDst,
                            prclSrc, &gptlZero);
        }
        else
        {
            iRet = (*PPFNGET(pdoDst, StretchBlt, pSurfDst->flags()))(psoDst, psoSrc, NULL, pco, pxlo,
                              NULL, NULL,
                              &erclDst, prclSrc,
                              NULL,
                              COLORONCOLOR);
        }
    }

    return iRet;
}
#endif

/******************************Private*Routine******************************\
* EngDrawStream
*
* Purpose:  Draws a graphics stream
*
* Description:
*
*    Parses the graphics stream rendering each command as approprite.
*
* History:
*
*    3-18-2001 bhouse Created it
*
\**************************************************************************/

BOOL
EngDrawStream(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    PRECTL      prclDstClip,
    PPOINTL     pptlDstOffset,
    ULONG       cjIn,
    PVOID       pvIn,
    DSSTATE    *pdss
)
{
    BOOL    bRet = TRUE;

    PDRAWSTREAMINFO   pdsi = (PDRAWSTREAMINFO) pdss;

    ASSERTGDI(psoDst != NULL, "ERROR EngDrawStream:  No Dst. Object\n");
    ASSERTGDI(psoSrc != NULL, "ERROR EngDrawStream:  No Src. Object\n");
    ASSERTGDI(prclDstClip != (PRECTL) NULL,  "ERROR EngDrawStream:  No Target Bounds Rect.\n");
    ASSERTGDI(prclDstClip->left < prclDstClip->right, "ERROR EngCopyBits0\n");
    ASSERTGDI(prclDstClip->top < prclDstClip->bottom, "ERROR EngCopyBits1\n");

    PSURFACE pSurfDst = SURFOBJ_TO_SURFACE(psoDst);
    PSURFACE pSurfSrc = SURFOBJ_TO_SURFACE(psoSrc);

    PDEVOBJ pdoDst(pSurfDst->hdev());
    
    ASSERTGDI(pSurfDst->iFormat() != BMF_JPEG,
              "ERROR EngCopyBits: dst BMF_JPEG\n");
    ASSERTGDI(pSurfDst->iFormat() != BMF_PNG,
              "ERROR EngCopyBits: dst BMF_PNG\n");
    ASSERTGDI(pSurfSrc->iFormat() != BMF_JPEG,
              "ERROR EngCopyBits: src BMF_JPEG\n");
    ASSERTGDI(pSurfSrc->iFormat() != BMF_PNG,
              "ERROR EngCopyBits: src BMF_PNG\n");

    ULONG * pul = (ULONG *) pvIn;

    while(cjIn >= sizeof(ULONG))
    {
        ULONG   command = *pul;
        HDC     hdcTarget;
        HDC     hdcSource;
        ULONG   commandSize;

        switch(command)
        {
        case DS_NINEGRIDID: 
            {
                // TODO: ensure that the destination rect is within bounds
                DS_NINEGRID * cmd = (DS_NINEGRID *) pul;

                commandSize = sizeof(*cmd);

                if(cjIn < commandSize) goto exit;

                ERECTL  erclDst(cmd->rclDst);

                erclDst += *pptlDstOffset;

                // Note, we are going directly to the driver or to EngNineGrid
                // without going back through sprite or multimon layer.  This is
                // ok because we will have already gone through those layers to
                // get here and the source can not be a primary surface.
                
                PFN_DrvNineGrid pfn = pSurfDst->pfnNineGrid();

                if( psoDst->dhpdev == NULL || !(pdoDst.flGraphicsCaps2() & GCAPS2_REMOTEDRIVER))
                    pfn = EngNineGrid;
                 
                // TODO: have the eBlendObj be part of DRAWSTREAMINFO

                EBLENDOBJ   eBlendObj;

                eBlendObj.BlendFunction.AlphaFormat = AC_SRC_ALPHA;
                eBlendObj.BlendFunction.BlendFlags = 0;
                eBlendObj.BlendFunction.SourceConstantAlpha = 255;
                eBlendObj.BlendFunction.BlendOp = AC_SRC_OVER;
                eBlendObj.pxlo32ToDst = pdsi->pxloBGRAToDst;
                eBlendObj.pxloDstTo32 = pdsi->pxloDstToBGRA;
                eBlendObj.pxloSrcTo32 = pdsi->pxloSrcToBGRA;

                bRet = (*pfn)(psoDst, psoSrc, pco, pxlo, &erclDst, &cmd->rclSrc, (PNINEGRID) &cmd->ngi, &eBlendObj, NULL);

            }
            break;
        
#if DS_ENABLE_BLT

        case DS_BLTID: 
            {

                // TODO: ensure that the destination rect is within bounds
                DS_BLT * cmd = (DS_BLT *) pul;

                commandSize = sizeof(*cmd);

                if(cjIn < commandSize) goto exit;

                ERECTL  erclDst(cmd->rclDst);

                erclDst += *pptlDstOffset;

                if(!EngDrawStreamBlt(psoDst, psoSrc, pco, pxlo, &erclDst,
                                &cmd->rclSrc, cmd->flFlags, pdsi))
                    goto exit;

            }
            break;

        case DS_SETCOLORKEYID: 
            {
                // TODO: ensure that the destination rect is within bounds
                DS_SETCOLORKEY * cmd = (DS_SETCOLORKEY *) pul;

                commandSize = sizeof(*cmd);

                if(cjIn < commandSize) goto exit;

                pdsi->dss.crColorKey = cmd->crColorKey;

            }
            break;
        
        case DS_SETBLENDID: 
            {
                // TODO: ensure that the destination rect is within bounds
                DS_SETBLEND * cmd = (DS_SETBLEND *) pul;

                commandSize = sizeof(*cmd);

                if(cjIn < commandSize) goto exit;

                pdsi->dss.blendFunction = cmd->blendFunction;
            
            }
            break;
        
#endif
        
        default:
            goto exit;
        }

        cjIn -= commandSize;
        pul += commandSize / 4;
    }

exit:

    return bRet;

}

/******************************Private*Routine******************************\
*
* NtGdiDrawStreamInternal
*
* Draws the given graphics stream to the given destination using
* the given source for any stream commands which require a source.
*
* History:
*  3-18-2001 bhouse Created it
*
\**************************************************************************/


BOOL
NtGdiDrawStreamInternal(
    XDCOBJ&         dcoDst,
    EXFORMOBJ&      xoDst,
    SURFACE*        pSurfSrc,
    XLATEOBJ *      pxlo,
    RECTL*          prclDstClip,
    RECTL*          prclDstBounds,
    LONG            cjIn,
    LPSTR           pvIn,
    PDRAWSTREAMINFO pdsi
)
{
    BOOL bReturn = FALSE;
    
    ASSERTGDI(dcoDst.bValid(), "NtGdiDrawStrea: invalide destination DC\n");
    ASSERTGDI(pSurfSrc != NULL, "NtGdiDrawStream: null source surface\n");
      
    ERECTL erclDstClip(*prclDstClip);
    ERECTL erclDstBounds(*prclDstBounds);
    EPOINTL eptlDstOffset(0,0);
   
    if(dcoDst.bDisplay() && !dcoDst.bRedirection() && !UserScreenAccessCheck())
    {
        //WARNING("NtGdiDrawStreamInternal: Screen Access Check Failed\n");
        SAVE_ERROR_CODE(ERROR_ACCESS_DENIED);
        goto exit;
    }
    if(xoDst.bRotation())
    {
        WARNING("NtGdiDrawStreamInternal: destination has rotational transform\n");
        goto exit;
    }
    
    if(xoDst.bTranslationsOnly())
    {
        xoDst.bXform(eptlDstOffset);
    }
    else
    {
        // walk the stream applying transform
        ULONG *pul = (ULONG *) pvIn;
        ULONG *pulEnd = (ULONG*) ((BYTE*) pul + cjIn);
        
        while(pul < pulEnd)
        {
            switch(*pul)
            {
            case DS_NINEGRIDID:
                {
                    DS_NINEGRID * cmd = (DS_NINEGRID *) pul;
                    xoDst.bXform(*(ERECTL*)&cmd->rclDst);
                    pul = (ULONG*) (cmd+1);
                }
                break;
            default:
                WARNING("NtGdiDrawStreamInternal: unrecognized draw stream command\n");
                goto exit;
            }
        }
    }
    
    xoDst.bXform(erclDstBounds);
    erclDstBounds.vOrder();
    
    if(erclDstClip.bEmpty())
    {
        WARNING("NtGdiDrawStreamInternal: destination clip is empty\n");
        goto exit;
    }
    
    //
    // Check pSurfDst, this may be an info DC or a memory DC with default bitmap.
    //
    
    SURFACE *pSurfDst = dcoDst.pSurface();
    
    //
    // Set up the brush if necessary.
    //
    
    EBRUSHOBJ *pbo = NULL;
    
    //
    // With a fixed DC origin we can change the destination to SCREEN coordinates.
    //
    
    eptlDstOffset += dcoDst.eptlOrigin();
    erclDstClip += dcoDst.eptlOrigin();
    
    //
    // This is a pretty gnarly expression to save a return in here.
    // Basically pco can be NULL if the rect is completely in the
    // cached rect in the DC or if we set up a clip object that isn't empty.
    //
    
    ECLIPOBJ *pco = NULL;
    BOOL      bForce = !erclDstClip.bContain(erclDstBounds);
    
    if (((erclDstBounds.left   >= dcoDst.prclClip()->left) &&
       (erclDstBounds.right  <= dcoDst.prclClip()->right) &&
       (erclDstBounds.top    >= dcoDst.prclClip()->top) &&
       (erclDstBounds.bottom <= dcoDst.prclClip()->bottom) &&
       (!bForce)) ||
      (pco = dcoDst.pco(),
       pco->vSetup(dcoDst.prgnEffRao(), erclDstClip, (bForce ? CLIP_FORCE : CLIP_NOFORCE)),
       erclDstClip = pco->erclExclude(),
       (!erclDstClip.bEmpty())))
    {
    
        //
        // Inc the target surface uniqueness
        //
        
        INC_SURF_UNIQ(pSurfDst);
        
        PFN_DrvDrawStream pfn = pSurfDst->pfnDrawStream();

        //
        // Only call through draw stream layer for primary pdev surfaces
        // and Meta DEVBITMAPS.
        // This will allows us to call through sprite layer and multi-mon
        // layer for the primary and Meta DEVBIMAPS only.
        // Device drivers currently are not allowed to hook draw stream.

        // NOTE: we have run out of hook flags.  We will need to extend the
        //       hook flag mechanism to support additional DDI.  This check
        //       is a hack to avoid calling through the sprite and multi-mon
        //       layers.  (Normally, the hook flags would be set correctly
        //       to do the right thing).

        PDEVOBJ pdoDst(pSurfDst->hdev());

        BOOL bDstMetaDriver = (dcoDst.bSynchronizeAccess() && pdoDst.bValid() && pdoDst.bMetaDriver());

        if(!pSurfDst->bPDEVSurface() && !(bDstMetaDriver && pSurfDst->iType() == STYPE_DEVBITMAP))
            pfn = EngDrawStream;

        bReturn = (*pfn) (
                   pSurfDst->pSurfobj(),
                   pSurfSrc->pSurfobj(),
                   pco,
                   pxlo,
                   &erclDstClip,
                   &eptlDstOffset,
                   cjIn,
                   pvIn,
                   (DSSTATE*) pdsi);
        
    }
    else
    {
      bReturn = TRUE;
    }

exit:

  return(bReturn);
}

BOOL gGreDrawStream = TRUE;
BOOL gDrawClipped = FALSE;

/******************************Private*Routine******************************\
*
* GreDrawStream
*
* Draws a graphics stream.  hdcDst is the primary output device is more
* then one target is set within the stream.
*
* History:
*  3-18-2001 bhouse Created it
*
\**************************************************************************/

BOOL GreDrawStream(
    HDC                 hdcDst,
    ULONG               cjIn,
    PVOID               pvIn
)
{                         
    XDCOBJ              dcoDst;
    XDCOBJ              dcoSrc;
    SURFREF             soSrc;
    BOOL                bRet = FALSE;
    EXFORMOBJ           xoSrc;
    EXFORMOBJ           xoDst;
    DEVLOCKBLTOBJ       dloSrc;
    DEVLOCKBLTOBJ       dloDst;
    SURFACE *           pSurfDst;
    SURFACE *           pSurfSrc = NULL;
    XEPALOBJ            palSrcDC;
    XLATEOBJ *          pxlo;
    XEPALOBJ            palDst;
    XEPALOBJ            palDstDC;
    XEPALOBJ            palSrc;
    XEPALOBJ            palRGB(gppalRGB);
    EXLATEOBJ           xlo;
    ERECTL              erclDstClip;
    BOOL                bAlphaBlendPresent = FALSE;
    PVOID               pvPrimStart = NULL;
    DRAWSTREAMINFO      dsi;
    ERECTL              erclDstBounds;
    BOOL                bFoundTrg = FALSE;

    dloSrc.vInit();
    dloDst.vInit();

    if(!gGreDrawStream)
    {
        WARNING("GreDrawStream: gGreDrawStream == 0\n");
        goto exit;
    }

    if(cjIn < sizeof(ULONG))
    {
        WARNING("GreDrawStream: cjIn < sizeof(ULONG)\n");
        goto exit;
    }

    ULONG * pul = (ULONG *) pvIn;

    if(*pul++ != 'DrwS')
    {
        WARNING("GreDrawStream: did not find DrwS magic number\n");
        goto exit;
    }

    cjIn -= sizeof(ULONG);

    while(cjIn >= sizeof(ULONG))
    {
        ULONG   command = *pul;
        HDC     hdcTarget;
        HDC     hdcSource;
        ULONG   commandSize;

        switch(command)
        {
        case DS_SETTARGETID: // set target
            {
                if(pvPrimStart != NULL) goto drawStream;
                
                dloDst.vUnLock();
                dcoDst.vUnlock();
                soSrc.vUnlock();
                
                DS_SETTARGET *  cmd = (DS_SETTARGET *) pul;

                commandSize = sizeof(*cmd);
    
                if(cjIn < commandSize)
                {
                    WARNING("GreDrawStream: cjIn < commandSize\n");
                    goto exit;
                }

                if((HDC) LongToHandle((LONG)(cmd->hdc)) != hdcDst)
                {
                    WARNING("GreDrawStream: cmd->hdc != hdcDst\n");
                    goto exit;
                }
    
                dcoDst.vLock((HDC) LongToHandle((LONG)(cmd->hdc)));
    
                if(!dcoDst.bValid())
                {
                    WARNING("GreDrawStream: !dcoDst.bValid()\n");
                    goto exit;
                }

                if(dcoDst.bStockBitmap())
                {
                    WARNING("GreDrawStream: dcoDst has Stock bitmap selected\n");
                    goto exit;
                }
               
                if(!dloDst.bLock(dcoDst))
                {
                    WARNING("GreDrawStream: Could not lock dcoDst\n");
                    goto exit;
                }
                
                xoDst.vQuickInit(dcoDst, WORLD_TO_DEVICE);
    
                if(xoDst.bRotation())
                {
                    WARNING("GreDrawStream: dcoDst has a rotation transform\n");
                    goto exit;
                }
               
                erclDstClip = cmd->rclDstClip;
   
                xoDst.bXform(erclDstClip);
                erclDstClip.vOrder();
                
                if (dcoDst.fjAccum())
                  dcoDst.vAccumulate(erclDstClip);
                
                pSurfDst = dcoDst.pSurface();
                
                if (pSurfDst == NULL)
                {
                    //WARNING("GreDrawStream: dcoDst has NULL pSurface\n");
                    goto exit;
                }

                palDst.ppalSet(pSurfDst->ppal());
                palDstDC.ppalSet(dcoDst.ppal());

                // we don't support monochrome destinations
                if(palSrc.bIsMonochrome())
                {
                    WARNING("GreDrawStream: palSrc.bIsMonochrome()\n");
                    goto exit;
                }
              
                bFoundTrg = TRUE;
            }
            break;

        case DS_SETSOURCEID: // set source

            {
                if(pvPrimStart != NULL) goto drawStream;

                dloSrc.vUnLock();
                dcoSrc.vUnlock();
                soSrc.vUnlock();

                pSurfSrc = NULL;
                
                DS_SETSOURCE *  cmd = (DS_SETSOURCE *) pul;

                commandSize = sizeof(*cmd);
    
                if(cjIn < commandSize || !bFoundTrg)
                {
                    WARNING("GreDrawStream: cjIn < commandSize || !bFoundTrg\n");
                    goto exit;
                }

#if 0
                // Old code to to allow source to be from HDC
                // We might want to support this in the future (source from
                // HDC)

                dcoSrc.vLock(cmd->hdc);
                
                if(!dcoSrc.bValid())
                {
                    WARNING("GreDrawStream: source is invalid\n");
                    goto exit;
                }

                xoSrc.vQuickInit(dcoSrc, WORLD_TO_DEVICE);

                if(!xoSrc.bIdentity())
                {
                    WARNING("GreDrawStream: source transform is not identity\n");
                    goto exit;
                }

                if(!dloSrc.bLock(dcoSrc))
                    goto exit;

                pSurfSrc = dcoSrc.pSurface();

                ASSERTGDI(pSurfSrc != NULL, "GreDrawSteam: unexpected NULL source in valid DC\n");

                // source must be different then target
                if (pSurfSrc == pSurfDst)
                    goto exit;

                if (!(pSurfSrc->bReadable() && (dcoDst.bDisplay() ? UserScreenAccessCheck() : TRUE)) &&
                    !((dcoSrc.bDisplay())  && ((dcoDst.bDisplay()) || UserScreenAccessCheck() )) )
                {
                    WARNING("GreDrawStream: faild screena access check\n");
                    goto exit;
                }

                palSrcDC.ppalSet(dcoSrc.ppal());
#endif
                
                soSrc.vLock((HSURF) ULongToHandle(cmd->hbm));
            
                if(!soSrc.bValid()) 
                {
                    WARNING("GreDrawStream: source is invalid\n");
                    goto exit;
                }

                pSurfSrc = soSrc.ps;

                palSrcDC.ppalSet(ppalDefault);

                palSrc.ppalSet(pSurfSrc->ppal());

                if(!palSrc.bValid())
                {
                    WARNING("GreDrawStream: source must have an associated palette\n");
                    goto exit;
                }

                if(palSrc.bIsMonochrome())
                {
                    WARNING("GreDrawStream: monochrome sources are not supported\n");
                    goto exit;
                }

                // source must be different then target and 32bpp for now
                if (pSurfSrc == pSurfDst || (pSurfSrc->iFormat() != BMF_32BPP))
                {
                    WARNING("GreDrawStream: source and destination surfaces must differ or the source is not 32 Bpp\n");
                    goto exit;
                }
                
                //
                // No ICM with BitBlt(), so pass NULL color transform to XLATEOBJ
                //

                if(!xlo.bInitXlateObj(NULL,                   // hColorTransform
                                     dcoDst.pdc->lIcmMode(), // ICM mode
                                     palSrc,
                                     palDst,
                                     palSrcDC,
                                     palDstDC,
                                     dcoDst.pdc->crTextClr(),
                                     dcoDst.pdc->crBackClr(),
                                     0))
                {
                    WARNING("GreDrawStream: unable to initialize source to destination xlo\n");
                    goto exit;
                }
                
                pxlo = xlo.pxlo();

            }
            break;

        case DS_NINEGRIDID:
            {
                commandSize = sizeof(DS_NINEGRID);

                DS_NINEGRID * cmd = (DS_NINEGRID *) pul;
                
                // validate nine grid
                
                #define DSDNG_MASK  0x007F      // move to wingdip.h
                
                if(cmd->ngi.flFlags & ~DSDNG_MASK)
                {
                    WARNING("GreDrawStream: unrecognized nine grid flags set\n");
                    goto exit;
                }

                if(pSurfSrc == NULL)
                {
                    WARNING("GreDrawStream: source not set before nine grid command\n");
                    goto exit;
                }

                if(cmd->rclSrc.left < 0 || cmd->rclSrc.top < 0 ||
                   cmd->rclSrc.right > pSurfSrc->sizl().cx ||
                   cmd->rclSrc.bottom > pSurfSrc->sizl().cy)
                {
                    WARNING("GreDrawStream: nine grid rclSrc not within bounds of source\n");
                    goto exit;
                }

                LONG  lSrcWidth = cmd->rclSrc.right - cmd->rclSrc.left;
                LONG  lSrcHeight = cmd->rclSrc.bottom - cmd->rclSrc.top;

                if(lSrcWidth <= 0 || lSrcHeight <= 0)
                {
                    WARNING("GreDrawStream: nine grid rclSrc is not well ordered\n");
                    goto exit;
                }

                if(!(cmd->ngi.flFlags & DSDNG_TRUESIZE))
                {
                    // NOTE: we have to check individual first then sum due to possible
                    //       numerical overflows that could occur in the sum that might
                    //       not be detected otherwise.

                    if(cmd->ngi.ulLeftWidth > lSrcWidth ||
                       cmd->ngi.ulRightWidth > lSrcWidth ||
                       cmd->ngi.ulTopHeight > lSrcHeight ||
                       cmd->ngi.ulBottomHeight > lSrcHeight ||
                       cmd->ngi.ulLeftWidth + cmd->ngi.ulRightWidth > lSrcWidth ||
                       cmd->ngi.ulTopHeight + cmd->ngi.ulBottomHeight > lSrcHeight)
                    {
                        WARNING("GreDrawStream: nine grid width is greater then rclSrc width\n");
                        goto exit;
                    }
                }

                if((cmd->ngi.flFlags & (DSDNG_TRANSPARENT | DSDNG_PERPIXELALPHA)) == (DSDNG_TRANSPARENT | DSDNG_PERPIXELALPHA))
                {
                    WARNING("GreDrawStream: nine grid attempt to set both transparency and per pixel alpha\n");
                    goto exit;
                }
                
                if(cmd->ngi.flFlags & DSDNG_TRANSPARENT)
                    cmd->ngi.crTransparent = ulGetNearestIndexFromColorref(
                        palSrc,
                        palSrcDC,
                        cmd->ngi.crTransparent,
                        SE_DO_SEARCH_EXACT_FIRST
                        );
                else if(cmd->ngi.flFlags & DSDNG_PERPIXELALPHA)
                {
                    bAlphaBlendPresent = TRUE;
                }

                if(pvPrimStart == NULL)
                {
                    pvPrimStart = (PVOID) pul;
                    erclDstBounds = cmd->rclDst;
                }
                else                
                    erclDstBounds += cmd->rclDst;

            }
            break;

#if 0
        case DS_BLTID:
            {
                commandSize = sizeof(DS_BLT);

                DS_BLT * cmd = (DS_BLT *) pul;
                
                if(cmd->flFlags & DSBLT_ALPHABLEND)
                {
                    bAlphaBlendPresent = TRUE;
                }
                
                if(pvPrimStart == NULL)
                {
                    pvPrimStart = (PVOID) pul;
                    erclDstBounds = cmd->rclDst;
                }
                else                
                    erclDstBounds += cmd->rclDst;
            }
            break;

        case DS_SETCOLORKEYID:
            {
                commandSize = sizeof(DS_SETCOLORKEY);

                if(pvPrimStart == NULL) pvPrimStart = (PVOID) pul;
                
                DS_SETCOLORKEY * cmd = (DS_SETCOLORKEY *) pul;
                
                cmd->crColorKey = ulGetNearestIndexFromColorref(
                    palSrc,
                    palSrcDC,
                    cmd->crColorKey,
                    SE_DO_SEARCH_EXACT_FIRST
                    );
            }
            break;

        case DS_SETBLENDID:
            {
                commandSize = sizeof(DS_SETBLEND);

                if(pvPrimStart == NULL) pvPrimStart = (PVOID) pul;
                
                DS_SETBLEND * cmd = (DS_SETBLEND *) pul;
                
            }
            break;
#endif

        default:
            goto exit;
        }

        cjIn -= commandSize;
        pul += commandSize / 4;
    
        if(cjIn == 0)
        {

drawStream:

            if(pvPrimStart != NULL && dcoDst.bValid() && pSurfSrc != NULL)
            {
                EXLATEOBJ           xloSrcToBGRA;
                EXLATEOBJ           xloDstToBGRA;
                EXLATEOBJ           xloBGRAToDst;
    
                dsi.dss.ulSize = sizeof(DRAWSTREAMINFO);
                dsi.dss.crColorKey = 0;
                dsi.dss.blendFunction.AlphaFormat = AC_SRC_ALPHA;
                dsi.dss.blendFunction.BlendFlags = 0;
                dsi.dss.blendFunction.SourceConstantAlpha = 255;
                dsi.dss.blendFunction.BlendOp = AC_SRC_OVER;
                dsi.bCalledFromBitBlt = FALSE;
                dsi.dss.ptlSrcOrigin.x = 0;
                dsi.dss.ptlSrcOrigin.y = 0;
    
                if(bAlphaBlendPresent)
                {
                    if(!xloSrcToBGRA.bInitXlateObj(
                            NULL,
                            DC_ICM_OFF,
                            palSrc,
                            palRGB,
                            palSrcDC,
                            palSrcDC,
                            0,
                            0,
                            0
                                        ))
                    {
                        WARNING("GreDrawStream: unable to initialize xloSrcToBGRA\n");
                        goto exit;
                    }
    
                    dsi.pxloSrcToBGRA = xloSrcToBGRA.pxlo();
                    
                    if(!xloDstToBGRA.bInitXlateObj(
                        NULL,
                        DC_ICM_OFF,
                        palDst,
                        palRGB,
                        palDstDC,
                        palDstDC,
                        0,
                        0,
                        0
                                        ))
                    {
                        WARNING("GreDrawStream: unable to initialize xloDstToBGRA\n");
                        goto exit;
                    }
    
                    dsi.pxloDstToBGRA = xloDstToBGRA.pxlo();
                    
                    if(!xloBGRAToDst.bInitXlateObj(
                        NULL,
                        DC_ICM_OFF,
                        palRGB,
                        palDst,
                        palDstDC,
                        palDstDC,
                        0,
                        0,
                        0
                                        ))
                    {
                        WARNING("GreDrawStream: unable to initialize xloBGRAToDst\n");
                        goto exit;
                    }

                    dsi.pxloBGRAToDst = xloBGRAToDst.pxlo();
                }
                else
                {
                    dsi.pxloBGRAToDst = NULL;
                    dsi.pxloDstToBGRA = NULL;
                    dsi.pxloSrcToBGRA = NULL;
                }
    
                if(!NtGdiDrawStreamInternal(dcoDst, xoDst, pSurfSrc, pxlo,
                                     (RECTL*) &erclDstClip,
                                     (RECTL*) &erclDstBounds,
                                     (LONG)((PBYTE) pul - (PBYTE) pvPrimStart),
                                     (LPSTR) pvPrimStart,
                                     &dsi))
                {
                    //WARNING("GreDrawStream: NtGdiDrawStreamInternal failed\n");
                    goto exit;
                }

                pvPrimStart = NULL;
                bAlphaBlendPresent = FALSE;
    
            }
            else
            {
                WARNING("GreDrawStream: !(pvPrimStart != NULL && dcoDst.bValid() && pSurfSrc != NULL)\n");

            }
        }


    }

    bRet = TRUE;
    
exit:

    dcoDst.vUnlock();
    dcoSrc.vUnlock();

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\engbrush.cxx ===
/******************************Module*Header*******************************\
* Module Name: engbrush.cxx
*
* Brush realization for the engine.
*
* Created: 13-May-1991 23:25:49
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

#if DBG
ULONG engbrushalloc = 0, engbrushcachecheck = 0;
ULONG engbrushcachegrabbed = 0, engbrushcachehit = 0;
#endif

/******************************Public*Routine******************************\
* EngRealizeBrush
*
* Realizes a brush for the engine simulations.
*
* We realize a brush by converting psoPattern to have the same bpp and color
* format as the destination surface.  We copy the monochrome mask unmodified.
*
* psoPattern is assumed never to be NULL.
*
* Returns: TRUE for success, FALSE for failure.
*
* History:
*  21-Nov-1993 -by- Michael Abrash [mikeab]
* Removed impossible case of psoPattern == NULL, cleaned up.
*
*  20-Jan-1992 -by- Donald Sidoroff [donalds]
* Tiled pattern and mask to DWORD boundaries
*
*  25-Apr-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL EngRealizeBrush(
BRUSHOBJ *pbo,
SURFOBJ  *psoTarget,
SURFOBJ  *psoPattern,
SURFOBJ  *psoMask,
XLATEOBJ *pxlo,
ULONG    iHatch)
{
    PSURFACE pSurfTarg = SURFOBJ_TO_SURFACE(psoTarget);
    PSURFACE pSurfPat  = SURFOBJ_TO_SURFACE(psoPattern);
    PSURFACE pSurfMsk  = SURFOBJ_TO_SURFACE(psoMask);
    ULONG ulSizeTotal;
    ULONG ulSizePat;
    ULONG cjScanPat, cjScanMsk;
    SIZEL sizlPat;
    SIZEL sizlMsk;
    LONG  cxPatRealized;
    LONG  cxMskRealized;
    ULONG iFormat;
    POINTL ptlSrc;
    RECTL rclDst;
    DEVBITMAPINFO dbmi;
    BOOL  bHalftoneTile = FALSE;

    ASSERTGDI(pbo->iSolidColor == 0xFFFFFFFF, "ERROR GDI iSolidColor");
    ASSERTGDI(pSurfTarg != NULL, "ERROR GDI EngRealizeBrush NULL psoTarg");
    ASSERTGDI(pSurfPat != NULL, "ERROR GDI EngRealizeBrush NULL psoPattern");
    ASSERTGDI(!(iHatch & RB_DITHERCOLOR),
              "ERROR GDI EngRealizeBrush RB_DITHERCOLOR set");

    //
    // Calculate the space needed for the pattern.
    //
    iFormat = pSurfTarg->iFormat();

    //
    // Check if they are having the engine simulate to a bitmap compatible
    // with their surface.  The brushobj has the device's surfobj in it
    // but we assume if they got here it's because they created a bitmap
    // compatible with thier format and
    // are drawing on it.  Maybe we should have the pvGetEngBrush pass
    // the pSurfTarg along so we know what it is here, because from
    // here we haven't got access to the real surfobj being painted on.
    //

    ASSERTGDI(pSurfPat->iType() == STYPE_BITMAP, "ERROR GDI EngRealizeBrush2");
    sizlPat = pSurfPat->sizl();

    PDEVICEHALFTONEINFO pDevHTInfo = NULL;

    PDEVOBJ po(pSurfTarg->hdev());

    // The following list shows the halftone dithering cell size mapped to
    // cxPattern x cyPattern in pDevHTInfo
    //
    // This is done only for 1bpp in the following code
    //
    // dither cell chosen at UI --> what we got from pDevHTInfo
    //
    // 2x2	--> 8x4
    // 4x4	--> 8x4
    // 6x6	--> 12x6
    // 8x8	--> 8x8
    // 10x10	--> 10x10
    // 12x12	--> 12x12
    // 14x14	--> 14x14
    // 16x16	--> 16x16
    // 91x91	--> 91x91
    //

    if ((po.pDevHTInfo() != NULL) || po.bEnableHalftone(NULL))
    {
         pDevHTInfo = (DEVICEHALFTONEINFO *)po.pDevHTInfo();
    }

    switch(iFormat)
    {
        case BMF_1BPP:
            ulSizePat = 1;
            if ((sizlPat.cx == 32) ||
                (sizlPat.cx == 16) ||
                (sizlPat.cx == 8))
            {
                cxPatRealized = 32;

                //
                // take the least common multiple
                // of 32(dword aligned) and pDevHTInfocxPattern
                //
                if (pDevHTInfo)
                {
                   switch (pDevHTInfo->cxPattern)
                   {
                      case 12:
                         cxPatRealized = 96;
                         bHalftoneTile = TRUE;
                         break;

                      case 10:
                         cxPatRealized = 160;
                         bHalftoneTile = TRUE;
                         break;

                      case 14:
                         cxPatRealized = 224;
                         bHalftoneTile = TRUE;
                         break;

                      case 91:
                         break;

                      default:
                         break;
                   }
                }

            }
            else
            {
                cxPatRealized = (sizlPat.cx + 63) & ~31;
            }
            break;
        case BMF_4BPP:
            ulSizePat = 4;
            if (sizlPat.cx == 8)
            {
                cxPatRealized = 8;
            }
            else
            {
                cxPatRealized = (sizlPat.cx + 15) & ~7;
            }
            break;
        case BMF_8BPP:
            ulSizePat = 8;
            cxPatRealized = (sizlPat.cx + 7) & ~3;
            break;
        case BMF_16BPP:
            ulSizePat = 16;
            cxPatRealized = (sizlPat.cx + 7) & ~3;
            break;
        case BMF_24BPP:
            ulSizePat = 24;
            cxPatRealized = (sizlPat.cx + 7) & ~3;
            break;
        case BMF_32BPP:
            ulSizePat = 32;
            cxPatRealized = sizlPat.cx;
            break;
        default:
            RIP("ERROR GDI EngRealizeBrush3");
    }

    //
    // Calculate the size to hold the pattern in the Target's format.
    //
    cjScanPat = (ulSizePat * cxPatRealized) >> 3;

    ulSizeTotal = sizeof(ENGBRUSH) + (ulSizePat = sizlPat.cy * cjScanPat);

    //
    // Calculate the additional space needed if we have a mask passed down.
    //
    if (pSurfMsk != NULL)
    {
        ASSERTGDI(pSurfMsk->iFormat() == BMF_1BPP, "ERROR GDI EngRealizeBrush4");
        ASSERTGDI(pSurfMsk->iType() == STYPE_BITMAP, "ERROR GDI EngRealizeBrush5");
        sizlMsk = pSurfMsk->sizl();
        if ((sizlMsk.cx == 32) ||
            (sizlMsk.cx == 16) ||
            (sizlMsk.cx == 8))
        {
            cxMskRealized = 32;
        }
        else
        {
            cxMskRealized = (sizlMsk.cx + 63) & ~31;
        }
        cjScanMsk = cxMskRealized >> 3;
        ulSizeTotal += sizlMsk.cy * cjScanMsk;
    }

    //
    // Allocate memory for the realization.
    //
    PENGBRUSH pengbrush;

#if DBG
    engbrushalloc++;
#endif

    //
    // If there's a cached ENGBRUSH, try to use it instead of allocating
    //
    if (gpCachedEngbrush != NULL)
    {

#if DBG
        engbrushcachecheck++;
#endif

        //
        // Try to grab the cached ENGBRUSH
        //
        if ((pengbrush =
                (PENGBRUSH) InterlockedExchangePointer((PVOID *)&gpCachedEngbrush,
                                              NULL))
                != NULL)
        {

#if DBG
            engbrushcachegrabbed++;
#endif

            //
            // Got the cached ENGBRUSH; see if it's big enough
            //
            // Note: -4 because we define the realization buffer start as aj[0]
            if (pengbrush->ulSizeGet() >= (sizeof(ENGBRUSH) - 4 + ulSizeTotal))
            {

#if DBG
                engbrushcachehit++;
#endif

                //
                // It's big enough, so we'll use it and we're done
                //
                goto BrushAllocated;
            }
            else
            {

                //
                // Not big enough; free it and do a normal allocation
                //
                VFREEMEM(pengbrush);
            }
        }
    }

    // Note: -4 because we define the realization buffer start as aj[0]
    if ((pengbrush = (PENGBRUSH)
            PALLOCMEM(ULONG(sizeof(ENGBRUSH) - 4 + ulSizeTotal),'rbeG'))
            == NULL)
    {
        WARNING("GDI EngRealizeBrush Couldn't allocate for engine realization");
        return(FALSE);
    }

BrushAllocated:

    EBRUSHOBJ *pebo = (EBRUSHOBJ *) pbo;

    //
    // Store the pointer to the realization in the brush.
    //
    pebo->pengbrush(pengbrush);

    //
    // Remember the size of the allocation, for caching.
    //
    pengbrush->ulSizeSet(sizeof(ENGBRUSH) - 4 + ulSizeTotal);

    //
    // Set up the Pat part. The pattern can never be NULL.
    //
    pengbrush->lDeltaPat = cjScanPat;
    pengbrush->cxPatR    = cxPatRealized;
    pengbrush->cxPat     = bHalftoneTile ? cxPatRealized : sizlPat.cx;
    pengbrush->cyPat     = sizlPat.cy;
    pengbrush->pjPat     = pengbrush->aj;
    pengbrush->iDitherFormat = iFormat;

    dbmi.iFormat    = iFormat;
    dbmi.cxBitmap   = cxPatRealized;
    dbmi.cyBitmap   = sizlPat.cy;
    dbmi.hpal       = 0;
    dbmi.fl         = BMF_TOPDOWN;

    SURFMEM SurfDimo;
    SurfDimo.bCreateDIB(&dbmi, pengbrush->pjPat);

    if (!SurfDimo.bValid())
    {
        // hmgr logs out of memory error
        return(FALSE);
    }

    ptlSrc.x = 0;
    ptlSrc.y = 0;

    rclDst.left = 0;
    rclDst.top = 0;
    rclDst.right = sizlPat.cx;
    rclDst.bottom = sizlPat.cy;

    // Below cases, we need halftoning for this brush.
    //
    // 1) Target surface is 1bpp, and this is pattern/bitmap brush, and the foreground
    //    and background are differrent
    // 2) Target surface is 4bpp, and ICM is enabled in system or apps, and this is NOT
    //    monochrone brush with same fore and background color.

    BOOL bSameColor = (((EBRUSHOBJ *)pbo)->crCurrentText() == ((EBRUSHOBJ *)pbo)->crCurrentBack());

    if (((iFormat == BMF_1BPP) && (iHatch >= HS_NULL) && !bSameColor)        // 1
                ||
        ((iFormat == BMF_4BPP) && (pebo->bIsAppsICM() || pebo->bIsHostICM()) // 2
         && !(bSameColor && (pebo->bIsMonochrome())))
       )
    {
        PALMEMOBJ palHatch;
        EXLATEOBJ exloHatch;
        PALETTE  *ppalOrg = NULL;

        // Special case to go thru halftone code

        POINTL ptl;
        ptl.x = 0; ptl.y = 0;
        RECTL rclSrc;

        rclSrc = rclDst;

        SurfDimo.ps->hdev(pSurfTarg->hdev());

        BOOL bHatch = (iHatch < HS_DDI_MAX);

        // If this is Hatch or monochrome brush, and ICM is enabled, ...

        if ((bHatch || pebo->bIsMonochrome()) &&
            (pebo->bIsAppsICM() || pebo->bIsHostICM()))
        {
            // Create temporary palette for hatch/mono brush from back/foregournd color
            // This is nessesary to let halftone bitblt work correctly.

            COLORREF aPalHatch[2];

            // If this is hatch brush, get foreground color from crRealized.
            // For monochrome brush, get from current text color.

            if (bHatch)
            {
                ICMMSG(("EngRealizeBrush called with hatch brush\n"));
                ICMMSG(("Forground color  = %x\n", pebo->crRealized()));
                ICMMSG(("Background color = %x\n", pebo->crCurrentBack()));

                // crCurrentBack goes to index 0
                // crRealized goes to index 1
                //
                // See brushddi.cxx : bGetRealizedBrush() for hatch brush case.

                aPalHatch[0] = pebo->crCurrentBack();
                aPalHatch[1] = pebo->crRealized();
            }
            else // if (pebo->bIsMonochorme())
            {
                ICMMSG(("EngRealizeBrush called with monochrome brush\n"));
                ICMMSG(("Forground color  = %x\n", pebo->crCurrentText()));
                ICMMSG(("Background color = %x\n", pebo->crCurrentBack()));

                // Text color goes to index 0.
                // Background color goes to index 1.
                //
                // See ylateobj.cxx : CreateXlateObject() when source is monochrome case.

                aPalHatch[0] = pebo->crCurrentText();
                aPalHatch[1] = pebo->crCurrentBack();
            }

            if (palHatch.bCreatePalette(PAL_INDEXED, 2, (PULONG) aPalHatch,
                                        0, 0, 0, PAL_FREE))
            {
                if (exloHatch.bInitXlateObj(
                                pebo->hcmXform(),
                                pebo->lIcmMode(),
                                palHatch.ppalGet(),
                                pebo->psoTarg()->ppal(),
                                pebo->palDC(),
                                pebo->palDC(),
                                pebo->crCurrentText(),
                                pebo->crCurrentBack(),
                                0x00FFFFFF))
                {
                    pxlo = exloHatch.pxlo();

                    //
                    // Halftone code always pick up palette from surface, if it exist,
                    // and the palette in monochrome bitmap is black/white, but here,
                    // text/background color must be used, so disable surface palette
                    // here by put null, so that halftone code will pick up right palette
                    // from XLATEOBJ.
                    //
                    ppalOrg = pSurfPat->ppal();
                    pSurfPat->ppal(NULL);
                }
                else
                {
                    WARNING1("EngRealizeBrush: failed to create xlate for ICM\n");
                }
            }
            else
            {
                WARNING1("EngRealizeBrush: failed to create palette for ICM\n");
            }
        }

        if ((iFormat == BMF_1BPP) && bHalftoneTile)
        {
            rclDst.right = cxPatRealized;

            EngHTBlt(
              SurfDimo.pSurfobj(),                 // Target surface
              pSurfPat->pSurfobj(),                // Source surface
              NULL,                                // mask surface
              (CLIPOBJ *) NULL,                    // Clip through this
              pxlo,                                // Color translation
              NULL,                                // pca
              &ptl,                                // pptlBrushOrg
              &rclDst,
              &rclSrc,
              NULL,
              BBPF_TILE_SRC,
              NULL);
        }
        else
        {
            while (rclDst.left != cxPatRealized)
            {
                EngStretchBlt(
                  SurfDimo.pSurfobj(),                 // Target surface
                  pSurfPat->pSurfobj(),                // Source surface
                  NULL,                                // mask surface
                  (CLIPOBJ *) NULL,                    // Clip through this
                  pxlo,                                // Color translation
                  NULL,                                // pca
                  &ptl,                                // pptlBrushOrg
                  &rclDst,
                  &rclSrc,
                  NULL,
                  HALFTONE);

                rclDst.left   = rclDst.right;
                rclDst.right += sizlPat.cx;
                if (rclDst.right > cxPatRealized)
                    rclDst.right = cxPatRealized;
            }
        }

        if (ppalOrg)
        {
            pSurfPat->ppal(ppalOrg);
        }
    }
    else  // normal cases
    {
        while (rclDst.left != cxPatRealized)
        {
           EngCopyBits(
              SurfDimo.pSurfobj(),                 // Target surface
              pSurfPat->pSurfobj(),                // Source surface
              (CLIPOBJ *) NULL,                    // Clip through this
              pxlo,                                // Color translation
              &rclDst,                             // Target offset and extent
              &ptlSrc);

           rclDst.left   = rclDst.right;
           rclDst.right += sizlPat.cx;
           if (rclDst.right > cxPatRealized)
               rclDst.right = cxPatRealized;
        }
    }

    //
    // Set up the Msk part.
    //
    if (pSurfMsk == (PSURFACE) NULL)
    {
        //
        // Flag that there's no mask.
        //
        pengbrush->pjMsk     = (PBYTE) NULL;
    }
    else
    {
        pengbrush->lDeltaMsk = cjScanMsk;
        pengbrush->cxMskR    = cxMskRealized;
        pengbrush->cxMsk     = sizlMsk.cx;
        pengbrush->cyMsk     = sizlMsk.cy;
        pengbrush->pjMsk     = pengbrush->aj + ulSizePat;

        dbmi.iFormat    = BMF_1BPP;
        dbmi.cxBitmap   = cxMskRealized;
        dbmi.cyBitmap   = sizlMsk.cy;
        dbmi.hpal       = (HPALETTE)0;
        dbmi.fl         = BMF_TOPDOWN;

        SURFMEM SurfDimo;
        SurfDimo.bCreateDIB(&dbmi, pengbrush->pjMsk);

        if (!SurfDimo.bValid())
        {
            // hmgr logs out of memory error
            return(FALSE);
        }

        ptlSrc.x = 0;
        ptlSrc.y = 0;

        rclDst.left = 0;
        rclDst.top = 0;
        rclDst.right = sizlMsk.cx;
        rclDst.bottom = sizlMsk.cy;

        while (rclDst.left != cxMskRealized)
        {
            EngCopyBits(
                        SurfDimo.pSurfobj(),   // target surface
                        pSurfMsk->pSurfobj(),   // source surface
                        (CLIPOBJ *) NULL,       // no clipping
                        NULL,                   // no color translation
                        &rclDst,                // target offset and extent
                        &ptlSrc                 // source start point
                       );

            rclDst.left   = rclDst.right;
            rclDst.right += sizlMsk.cx;
            if (rclDst.right > cxMskRealized)
            {
                rclDst.right = cxMskRealized;
            }
        }
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\drvsup.cxx ===
/******************************Module*Header*******************************\
* Module Name: drvsup.c                                                    *
*                                                                          *
* Copyright (c) 1990-1999 Microsoft Corporation                            *
*                                                                          *
* Display Driver management routines                                       *
*                                                                          *
* Andre Vachon -Andreva-                                                   *
\**************************************************************************/

#include "precomp.hxx"

// The declaration of AlignRects has been removed from usergdi.h
// and has been explicitly added here. [dchinn]
extern "C" {
BOOL
AlignRects(
    IN OUT LPRECT arc,
    IN DWORD cCount,
    IN DWORD iPrimary,
    IN DWORD dwFlags);
}

extern
VOID APIENTRY GreSuspendDirectDrawEx(
    HDEV    hdev,
    ULONG   fl
    );

extern
VOID APIENTRY GreResumeDirectDrawEx(
    HDEV    hdev,
    ULONG   fl
    );

#pragma hdrstop

#include <wdmguid.h>   // for GUID_DEVICE_INTERFACE_ARRIVAL/REMOVAL

#define INITGUID
#include <initguid.h>
#include "ntddvdeo.h"

#ifdef _HYDRA_

#include <regapi.h>
#include <winDDIts.h>
#include "muclean.hxx"
#include "winstaw.h"

extern PFILE_OBJECT G_RemoteVideoFileObject;
extern PFILE_OBJECT G_RemoteConnectionFileObject;
extern HANDLE       G_RemoteConnectionChannel;
extern PBYTE        G_PerformanceStatistics;
extern BOOL         G_fConsole;
extern BOOL         G_fDoubleDpi;
extern LPWSTR       G_DisplayDriverNames;

#endif

#if TEXTURE_DEMO

/*
 * Texture Demo
 */

ULONG gcTextures;                       // Count of textures
HDEV gahdevTexture[8];                  // Array of texture PDEVs
BOOL gbTexture = FALSE;                  // TRUE if we're to do the texture demo
HDEV ghdevTextureParent;                // Non-NULL if doing texture demo
LONG gcxTexture;                        // Texture size of TexEnablePDEV
LONG gcyTexture;

#define INDEX_DrvDemoTexture INDEX_DrvMovePanning

typedef struct _DEMOCOORDINATE
{
    float   fX;
    float   fY;
    float   fW;
    float   fU;
    float   fV;
    float   fZ;
} DEMOCOORDINATE;

typedef struct _DEMOQUAD
{
    DEMOCOORDINATE V0;
    DEMOCOORDINATE V1;
    DEMOCOORDINATE V2;
    DEMOCOORDINATE V3;
} DEMOQUAD;

BOOL APIENTRY DrvDemoTexture(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    DEMOQUAD   *pQuads,
    ULONG       cQuads
    );

typedef BOOL   (*PFN_DrvDemoTexture)(SURFOBJ*,SURFOBJ*,CLIPOBJ*,DEMOQUAD*,ULONG);

#endif // TEXTURE_DEMO

typedef enum _DISP_DRIVER_LOG {
    MsgInvalidConfiguration = 1,
    MsgInvalidDisplayDriver,
    MsgInvalidOldDriver,
    MsgInvalidDisplayMode,
    MsgInvalidDisplay16Colors,
    MsgInvalidUsingDefaultMode,
} DISP_DRIVER_LOG;

typedef enum _DISP_DRIVER_REGISTRY_TYPE {
    DispDriverRegGlobal,
    DispDriverRegHardwareProfile,
    DispDriverRegHardwareProfileCreate,
    DispDriverRegKey
} DISP_DRIVER_REGISTRY_TYPE;

typedef enum _GRAPHICS_STATE {
    GraphicsStateFull = 1,
    GraphicsStateNoAttach,
    GraphicsStateAttachDisconnect
} GRAPHICS_STATE;


#define DM_INTERNAL_VALID_FLAGS                                               \
    (DM_BITSPERPEL   | DM_PELSWIDTH | DM_PELSHEIGHT   | DM_DISPLAYFREQUENCY | \
     DM_DISPLAYFLAGS | DM_LOGPIXELS | DM_PANNINGWIDTH | DM_PANNINGHEIGHT    | \
     DM_DISPLAYORIENTATION                                                  )

#define DDML_DRIVER -4

BOOL              gbBaseVideo;
BOOL              gbUpdateMonitor;
BOOL              gbInvalidateDualView;
USHORT            gdmLogPixels;
ULONG             gcNextGlobalDeviceNumber;
ULONG             gcNextGlobalPhysicalOutputNumber;
ULONG             gcNextGlobalVirtualOutputNumber;
PGRAPHICS_DEVICE  gpGraphicsDeviceList;
PGRAPHICS_DEVICE  gpGraphicsDeviceListLast;
PGRAPHICS_DEVICE  gPhysDispVGA;  // VGA driver hack
GRAPHICS_DEVICE   gFullscreenGraphicsDevice;
GRAPHICS_DEVICE   gFeFullscreenGraphicsDevice;
// #if DBG
ULONG             gcFailedModeChanges = 0;
// #endif

PPALETTE DrvRealizeHalftonePalette(HDEV hdevPalette, BOOL bForce);



BOOL
DrvSetDisconnectedGraphicsDevice(
    BOOL bLocal);


VOID
DrvCleanupOneGraphicsDevice(PGRAPHICS_DEVICE pGraphicsDeviceList);


BOOL
DrvIsProtocolAlreadyKnown(VOID);

extern "C" USHORT gProtocolType;

ULONG gcRemoteNextGlobalDeviceNumber;
ULONG gcLocalNextGlobalDeviceNumber;
ULONG gcRemoteProtocols;
PGRAPHICS_DEVICE gpRemoteGraphicsDeviceList;
PGRAPHICS_DEVICE gpLocalGraphicsDeviceList;
PGRAPHICS_DEVICE gpRemoteGraphicsDeviceListLast;
PGRAPHICS_DEVICE gpLocalGraphicsDeviceListLast;
PGRAPHICS_DEVICE gpRemoteDiscGraphicsDevice;
PGRAPHICS_DEVICE gpLocalDiscGraphicsDevice;
ULONG gcLocalNextGlobalPhysicalOutputNumber = 1;
ULONG gcLocalNextGlobalVirtualOutputNumber = 1;
ULONG gcRemoteNextGlobalPhysicalOutputNumber = 1;
ULONG gcRemoteNextGlobalVirtualOutputNumber = 1;


#if MDEV_STACK_TRACE_LENGTH
LONG        glMDEVTrace = 0;
MDEVRECORD  gMDEVTrace[32];
const LONG  gcMDEVTraceLength = sizeof(gMDEVTrace)/sizeof(gMDEVTrace[0]);
#endif

//
// Global driver list.  This pointer points to the first driver in a
// singly linked list of drivers.
//
// We use this list to determine when we are called to load a driver to
// determine if the the driver image is already loaded.
// If the image is already loaded, we will just increment the reference count
// and then create a new PDEV.
//

PLDEV gpldevDrivers;

#if DBG
    #define TRACE_SWITCH(str) { if (GreTraceDisplayDriverLoad) {  KdPrint(str); } }
#else
    #define TRACE_SWITCH(str)
#endif

PUCHAR gpFullscreenFrameBufPtr;
ULONG  gpFullscreenFrameBufLength = 0;

int
ConvertOutputToOem(
    IN LPWSTR Source,
    IN int SourceLength,    // in chars
    OUT LPSTR Target,
    IN int TargetLength     // in chars
    )
/*
    Converts SourceLength Unicode characters from Source into
    not more than TargetLength Codepage characters at Target.
    Returns the number characters put in Target. (0 if failure)

    [ntcon\server\misc.c]
*/

{
    NTSTATUS Status;
    ULONG Length;

    // Can do this in place
    Status = RtlUnicodeToOemN(Target,
                              TargetLength,
                              &Length,
                              Source,
                              SourceLength * sizeof(WCHAR)
                             );
    if (NT_SUCCESS(Status)) {
        return Length;
    } else {
        return 0;
    }
}

/***************************************************************************\
* TranslateOutputToOem
*
* routine to translate console PCHAR_INFO to the ASCII from Unicode
*
* [ntcon\server\fe\direct2.c]
\***************************************************************************/

NTSTATUS
TranslateOutputToOem(
    OUT PCHAR_INFO OutputBuffer,
    IN  PCHAR_INFO InputBuffer,
    IN  DWORD Length
    )
{
    CHAR AsciiDbcs[2];
    ULONG NumBytes;

    while (Length--)
    {
        if (InputBuffer->Attributes & COMMON_LVB_LEADING_BYTE)
        {
            if (Length >= 2)    // Safe DBCS in buffer ?
            {
                Length--;
                NumBytes = sizeof(AsciiDbcs);
                NumBytes = ConvertOutputToOem(&InputBuffer->Char.UnicodeChar,
                                              1,
                                              &AsciiDbcs[0],
                                              NumBytes);
                OutputBuffer->Char.AsciiChar = AsciiDbcs[0];
                OutputBuffer->Attributes = InputBuffer->Attributes;
                OutputBuffer++;
                InputBuffer++;
                OutputBuffer->Char.AsciiChar = AsciiDbcs[1];
                OutputBuffer->Attributes = InputBuffer->Attributes;
                OutputBuffer++;
                InputBuffer++;
            }
            else
            {
                OutputBuffer->Char.AsciiChar = ' ';
                OutputBuffer->Attributes = InputBuffer->Attributes & ~COMMON_LVB_SBCSDBCS;
                OutputBuffer++;
                InputBuffer++;
            }
        }
        else if (! (InputBuffer->Attributes & COMMON_LVB_SBCSDBCS))
        {
            ConvertOutputToOem(&InputBuffer->Char.UnicodeChar,
                               1,
                               &OutputBuffer->Char.AsciiChar,
                               1);
            OutputBuffer->Attributes = InputBuffer->Attributes;
            OutputBuffer++;
            InputBuffer++;
        }
    }

    return STATUS_SUCCESS;
}

/***************************************************************************\
* NtGdiFullscreenControl
*
* routine to support console calls to the video driver
*
* 01-Sep-1995 andreva  Created
\***************************************************************************/

NTSTATUS
NtGdiFullscreenControl(
    IN FULLSCREENCONTROL FullscreenCommand,
    PVOID  FullscreenInput,
    DWORD  FullscreenInputLength,
    PVOID  FullscreenOutput,
    PULONG FullscreenOutputLength)
{

    NTSTATUS Status = STATUS_SUCCESS;

    ULONG BytesReturned;
    PVOID pCapBuffer = NULL;
    ULONG cCapBuffer = 0;
    ULONG ioctl = 0;

    //
    // If this is not CSR, then fail the API call.
    //

    if (PsGetCurrentProcess() != gpepCSRSS)
    {
        return STATUS_PRIVILEGE_NOT_HELD;
    }

    //
    // First validate the ioctl
    //

    switch(FullscreenCommand) {

    case FullscreenControlEnable:
        ioctl = IOCTL_VIDEO_ENABLE_VDM;
        TRACE_SWITCH(("Switching: FullscreenControlEnable\n"));
        break;

    case FullscreenControlDisable:
        ioctl = IOCTL_VIDEO_DISABLE_VDM;
        TRACE_SWITCH(("Switching: FullscreenControlDisable\n"));
        break;

    case FullscreenControlSetCursorPosition:
        if (gFeFullscreenGraphicsDevice.pDeviceHandle != NULL)
        {
            ioctl = IOCTL_FSVIDEO_SET_CURSOR_POSITION;
        }
        else
        {
            ioctl = IOCTL_VIDEO_SET_CURSOR_POSITION;
        }
        TRACE_SWITCH(("Switching: FullscreenControlSetCursorPosition\n"));
        break;

    case FullscreenControlSetCursorAttributes:
        ioctl = IOCTL_VIDEO_SET_CURSOR_ATTR;
        TRACE_SWITCH(("Switching: FullscreenControlSetCursorAttributes\n"));
        break;

    case FullscreenControlRegisterVdm:
        ioctl = IOCTL_VIDEO_REGISTER_VDM;
        TRACE_SWITCH(("Switching: FullscreenControlRegisterVdm\n"));
        break;

    case FullscreenControlSetPalette:
        ioctl = IOCTL_VIDEO_SET_PALETTE_REGISTERS;
        TRACE_SWITCH(("Switching: FullscreenControlSetPalette\n"));
        break;

    case FullscreenControlSetColors:
        ioctl = IOCTL_VIDEO_SET_COLOR_REGISTERS;
        TRACE_SWITCH(("Switching: FullscreenControlSetColors\n"));
        break;

    case FullscreenControlLoadFont:
        ioctl = IOCTL_VIDEO_LOAD_AND_SET_FONT;
        TRACE_SWITCH(("Switching: FullscreenControlLoadFont\n"));
        break;

    case FullscreenControlRestoreHardwareState:
        ioctl = IOCTL_VIDEO_RESTORE_HARDWARE_STATE;
        TRACE_SWITCH(("Switching: FullscreenControlRestoreHardwareState\n"));
        break;

    case FullscreenControlSaveHardwareState:
        ioctl = IOCTL_VIDEO_SAVE_HARDWARE_STATE;
        TRACE_SWITCH(("Switching: FullscreenControlSaveHardwareState\n"));
        break;


    case FullscreenControlCopyFrameBuffer:
    case FullscreenControlReadFromFrameBuffer:
    case FullscreenControlWriteToFrameBuffer:
    case FullscreenControlReverseMousePointer:
    case FullscreenControlCopyFrameBufferDB:
    case FullscreenControlWriteToFrameBufferDB:
    case FullscreenControlReverseMousePointerDB:

        // TRACE_SWITCH(("Switching: Fullscreen output command\n"));

        if (gFeFullscreenGraphicsDevice.pDeviceHandle != NULL)
        {
            /*
             * Console Full Screen Video driver is available.
             */
            switch(FullscreenCommand)
            {
            case FullscreenControlCopyFrameBufferDB:
                ioctl = IOCTL_FSVIDEO_COPY_FRAME_BUFFER;
                break;
            case FullscreenControlWriteToFrameBufferDB:
                ioctl = IOCTL_FSVIDEO_WRITE_TO_FRAME_BUFFER;
                break;
            case FullscreenControlReverseMousePointerDB:
                ioctl = IOCTL_FSVIDEO_REVERSE_MOUSE_POINTER;
                break;
            }
        }
        break;

    case FullscreenControlSetMode:
        TRACE_SWITCH(("Switching: Fullscreen setmode command\n"));
        break;


    case FullscreenControlSetScreenInformation:
        if (gFeFullscreenGraphicsDevice.pDeviceHandle != NULL)
        {
            ioctl = IOCTL_FSVIDEO_SET_SCREEN_INFORMATION;
        }
        else
        {
            return STATUS_NOT_IMPLEMENTED;
        }
        break;

    case FullscreenControlSpecificVideoControl:        // for specific NEC PC-98
        __try
        {
            ProbeForRead(FullscreenInput, sizeof(DWORD), sizeof(DWORD));
            RtlCopyMemory(&ioctl, FullscreenInput, sizeof(DWORD));

            FullscreenInput = (PVOID)((PBYTE)FullscreenInput + sizeof(DWORD));
            FullscreenInputLength -= sizeof(DWORD);
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            RIP("FullscreenControlSpecificVideoControl - error processing input buffer\n");
            return STATUS_NOT_IMPLEMENTED;
        }
        break;


    default:
        RIP("NtUserFullscreenControl: invalid IOCTL\n");
        return STATUS_NOT_IMPLEMENTED;

    }

    //
    // If this is a frame buffer function, that we can just deal with the
    // device directly, and not send any IOCTL to the device.
    //

    if (ioctl == 0)
    {
        CHAR Attribute;

        //
        // First get the frame buffer pointer for the device.
        //

        PUCHAR pFrameBuf = gpFullscreenFrameBufPtr;
        ULONG_PTR  FrameBufLen = (ULONG_PTR)gpFullscreenFrameBufLength;
        PCHAR_INFO pCharInfo;
        PCHAR_IMAGE_INFO pCharImageInfo;
        LPDEVMODEW pDevmode = gFullscreenGraphicsDevice.devmodeInfo;
        VIDEO_MODE VideoMode;
        BOOLEAN modeFound = FALSE;
        ULONG BytesReturned;
        ULONG i;


        //
        // Assume success for all these operations.
        //

        Status = STATUS_SUCCESS;

        switch(FullscreenCommand) {

        case FullscreenControlSetMode:

            //
            // Fullscreen VGA modes require us to call the miniport driver
            // directly.
            //
            // Lets check the VGA Device handle, which is in the first entry
            //

            if (gFullscreenGraphicsDevice.pDeviceHandle == NULL)
            {
                Status = STATUS_UNSUCCESSFUL;
            }
            else
            {
                //
                // NOTE We know that if there is a vgacompatible device, then
                // there are some text modes for it.
                //
                // NOTE !!!
                // As a hack, lets use the mode number we stored in the DEVMODE
                // a field we don't use
                //

                for (i = 0;
                     i < gFullscreenGraphicsDevice.cbdevmodeInfo;
                     i += sizeof(DEVMODEW), pDevmode += 1) {

                    //
                    // We don't probe the paramters since we are being
                    // called by CSR
                    //

                    if ((pDevmode->dmPelsWidth  == ((LPDEVMODEW) FullscreenInput)->dmPelsWidth) &&
                        (pDevmode->dmPelsHeight == ((LPDEVMODEW) FullscreenInput)->dmPelsHeight) &&
                        (pDevmode->dmDisplayFlags == ((LPDEVMODEW) FullscreenInput)->dmDisplayFlags) &&
                        (pDevmode->dmBitsPerPel == ((LPDEVMODEW) FullscreenInput)->dmBitsPerPel)
                       )
                    {
                        //
                        // FullscreenInput->dwOrientation is 0.
                        //

                        VideoMode.RequestedMode = (ULONG) pDevmode->dmOrientation;
                        modeFound = TRUE;
                        break;
                    }
                }

                if (modeFound == FALSE)
                {
                    RIP("ChangeDisplaySettings: Console passed in bad DEVMODE\n");

                    Status = STATUS_UNSUCCESSFUL;
                }
                else
                {
                    //
                    // We have the mode number.
                    // Call the driver to set the mode
                    //

                    Status = GreDeviceIoControl(gFullscreenGraphicsDevice.pDeviceHandle,
                                                IOCTL_VIDEO_SET_CURRENT_MODE,
                                                &VideoMode,
                                                sizeof(VideoMode),
                                                NULL,
                                                0,
                                                &BytesReturned);

                    if (NT_SUCCESS(Status))
                    {
                        //
                        // We also map the memory so we can use it to
                        // process string commands from the console
                        //

                        VIDEO_MEMORY FrameBufferMap;
                        VIDEO_MEMORY_INFORMATION FrameBufferInfo;

                        FrameBufferMap.RequestedVirtualAddress = NULL;

                        Status = GreDeviceIoControl(gFullscreenGraphicsDevice.pDeviceHandle,
                                                    IOCTL_VIDEO_MAP_VIDEO_MEMORY,
                                                    &FrameBufferMap,
                                                    sizeof(FrameBufferMap),
                                                    &FrameBufferInfo,
                                                    sizeof(FrameBufferInfo),
                                                    &BytesReturned);

                        if (NT_SUCCESS(Status))
                        {
                            //
                            // get address of frame buffer
                            //

                            gpFullscreenFrameBufPtr = (PUCHAR) FrameBufferInfo.FrameBufferBase;
                            gpFullscreenFrameBufLength = FrameBufferInfo.FrameBufferLength;

                            if (gFeFullscreenGraphicsDevice.pDeviceHandle != NULL)
                            {
                                FSVIDEO_MODE_INFORMATION FsVideoMode;
                                //
                                // get current video mode
                                //
                                Status = GreDeviceIoControl(gFullscreenGraphicsDevice.pDeviceHandle,
                                                            IOCTL_VIDEO_QUERY_CURRENT_MODE,
                                                            NULL,
                                                            0,
                                                            &FsVideoMode.VideoMode,
                                                            sizeof(FsVideoMode.VideoMode),
                                                            &BytesReturned);
                                if (NT_SUCCESS(Status))
                                {
                                    FsVideoMode.VideoMemory = FrameBufferInfo;

                                    //
                                    // set current vide mode to full screen video driver
                                    //
                                    Status = GreDeviceIoControl(gFeFullscreenGraphicsDevice.pDeviceHandle,
                                                                IOCTL_FSVIDEO_SET_CURRENT_MODE,
                                                                &FsVideoMode,
                                                                sizeof(FsVideoMode),
                                                                NULL,
                                                                0,
                                                                &BytesReturned);
                                    if (NT_SUCCESS(Status))
                                    {
                                    }
                                    else
                                    {
                                        RIP("FSVGA setmode: fullscreen MODESET failed\n");
                                        Status = STATUS_UNSUCCESSFUL;
                                    }
                                }
                            }
                        }
                        else
                        {

                            RIP("Fullscreen setmode: memory mapping failed\n");
                            Status = STATUS_UNSUCCESSFUL;
                        }

                    }
                    else
                    {

                        RIP("Fullscreen setmode: fullscreen MODESET failed\n");
                        Status = STATUS_UNSUCCESSFUL;
                    }
                }
            }

            break;


        case FullscreenControlCopyFrameBuffer:

            TRACE_SWITCH(("Switching: FullscreenControlCopyFrameBuffer\n"));

            if ( ((((ULONG_PTR)FullscreenInput) + FullscreenInputLength) < FrameBufLen) &&
                 ((((ULONG_PTR)FullscreenOutput) + FullscreenInputLength) < FrameBufLen) )
            {
                RtlMoveMemory(pFrameBuf + (ULONG_PTR)FullscreenOutput,
                              pFrameBuf + (ULONG_PTR)FullscreenInput,
                              FullscreenInputLength);
            }
            else
            {
                RIP("Fullscreen control - error processing input/output buffer\n");
            }
            break;

        case FullscreenControlCopyFrameBufferDB:

            TRACE_SWITCH(("Switching: FullscreenControlCopyFrameBufferDB\n"));

            {
                FSCNTL_SCREEN_INFO FsCntlSrc;
                FSCNTL_SCREEN_INFO FsCntlDest;
                ULONG_PTR offsetSrc, offsetDst, len;

                __try
                {
                    ProbeForRead(FullscreenInput, sizeof(FSCNTL_SCREEN_INFO), sizeof(USHORT));
                    RtlCopyMemory(&FsCntlSrc, FullscreenInput, sizeof(FSCNTL_SCREEN_INFO));

                    ProbeForRead(FullscreenOutput, sizeof(FSCNTL_SCREEN_INFO), sizeof(USHORT));
                    RtlCopyMemory(&FsCntlDest, FullscreenOutput, sizeof(FSCNTL_SCREEN_INFO));
                }
                __except (EXCEPTION_EXECUTE_HANDLER)
                {
                    RIP("Fullscreen control - error processing input/output buffer\n");
                }

                offsetDst = SCREEN_BUFFER_POINTER(0, FsCntlDest.Position.Y, FsCntlDest.ScreenSize.X, sizeof(VGA_CHAR));
                offsetSrc = SCREEN_BUFFER_POINTER(0, FsCntlSrc.Position.Y,  FsCntlSrc.ScreenSize.X,  sizeof(VGA_CHAR));
                len = FsCntlSrc.nNumberOfChars * sizeof(VGA_CHAR);
                if ( ((offsetDst+len) < FrameBufLen) &&
                     ((offsetSrc+len) < FrameBufLen) )
                {
                    RtlMoveMemory(pFrameBuf + offsetDst,
                                  pFrameBuf + offsetSrc,
                                  len);
                }
                else
                {
                    RIP("Fullscreen control - error processing input/output buffer\n");
                }

            }
            break;

        case FullscreenControlReadFromFrameBuffer:

            TRACE_SWITCH(("Switching: FullscreenControlReadFromFrameBuffer\n"));

            FullscreenInputLength = (FullscreenInputLength / 2) * 2;
            if ( ((((ULONG_PTR)FullscreenInput) + FullscreenInputLength) < FrameBufLen) )
            {
                __try
                {
                    ProbeForWrite(FullscreenOutput, sizeof(CHAR_INFO) * FullscreenInputLength/2, sizeof(UCHAR));

                    pFrameBuf += (ULONG_PTR) FullscreenInput;
                    pCharInfo = (PCHAR_INFO) FullscreenOutput;

                    while (FullscreenInputLength)
                    {
                        pCharInfo->Char.AsciiChar       = *pFrameBuf++;
                        pCharInfo->Attributes           = *pFrameBuf++;
                        FullscreenInputLength -= 2;
                        pCharInfo++;
                    }
                }
                __except (EXCEPTION_EXECUTE_HANDLER)
                {
                    RIP("Fullscreen control - error processing input/output buffer\n");
                }
            }
            else
            {
                RIP("Fullscreen control - error processing input/output buffer\n");
            }

            break;

        case FullscreenControlWriteToFrameBuffer:

            TRACE_SWITCH(("Switching: FullscreenControlWriteToFrameBuffer\n"));

            FullscreenInputLength = (FullscreenInputLength / 4) * 4;
            if ( ((((ULONG_PTR)FullscreenOutput) + FullscreenInputLength/2) < FrameBufLen) )
            {
                __try
                {
                    ProbeForRead(FullscreenInput, sizeof(CHAR_INFO) * FullscreenInputLength/4, sizeof(UCHAR));

                    pFrameBuf += (ULONG_PTR) FullscreenOutput;
                    pCharInfo = (PCHAR_INFO) FullscreenInput;

                    while (FullscreenInputLength)
                    {
                        *pFrameBuf++ = pCharInfo->Char.AsciiChar;
                        *pFrameBuf++ = (UCHAR) (pCharInfo->Attributes);
                        FullscreenInputLength -= 4;
                        pCharInfo++;
                    }
                }
                __except (EXCEPTION_EXECUTE_HANDLER)
                {
                    RIP("Fullscreen control - error processing input/output buffer\n");
                }
            }
            else
            {
                RIP("Fullscreen control - error processing input/output buffer\n");
            }

            break;

        case FullscreenControlWriteToFrameBufferDB:

            TRACE_SWITCH(("Switching: FullscreenControlWriteToFrameBufferDB\n"));

            {
                FSCNTL_SCREEN_INFO FsCntl;
                ULONG_PTR   offset;

                __try
                {
                    ProbeForRead(FullscreenOutput, sizeof(FSCNTL_SCREEN_INFO), sizeof(USHORT));
                    RtlCopyMemory(&FsCntl, FullscreenOutput, sizeof(FSCNTL_SCREEN_INFO));

                    ProbeForRead(FullscreenInput, sizeof(CHAR_IMAGE_INFO) * FsCntl.nNumberOfChars, sizeof(USHORT));
                }
                __except (EXCEPTION_EXECUTE_HANDLER)
                {
                    RIP("Fullscreen control - error processing input/output buffer\n");
                }

                offset = SCREEN_BUFFER_POINTER(FsCntl.Position.X,
                                               FsCntl.Position.Y,
                                               FsCntl.ScreenSize.X,
                                               sizeof(VGA_CHAR));
                if ((offset+FsCntl.nNumberOfChars*2) < FrameBufLen)
                {
                    pFrameBuf += offset;
                    pCharImageInfo = (PCHAR_IMAGE_INFO) FullscreenInput;

                    while (FsCntl.nNumberOfChars)
                    {
                        TranslateOutputToOem(&pCharImageInfo->CharInfo,
                                             &pCharImageInfo->CharInfo,
                                             1);
                        *pFrameBuf++ = pCharImageInfo->CharInfo.Char.AsciiChar;
                        *pFrameBuf++ = (UCHAR) (pCharImageInfo->CharInfo.Attributes);

                        FsCntl.nNumberOfChars--;
                        pCharImageInfo++;
                    }
                }
                else
                {
                    RIP("Fullscreen control - error processing input/output buffer\n");
                }

            }
            break;

        case FullscreenControlReverseMousePointer:

            TRACE_SWITCH(("Switching: FullscreenControlReverseMousePointer\n"));

            if ( (((ULONG_PTR)FullscreenInput) + 1) < FrameBufLen )
            {
                pFrameBuf += (ULONG_PTR) FullscreenInput;

                Attribute =  (*(pFrameBuf + 1) & 0xF0) >> 4;
                Attribute |= (*(pFrameBuf + 1) & 0x0F) << 4;
                *(pFrameBuf + 1) = Attribute;
            }
            else
            {
                RIP("Fullscreen control - error processing input/output buffer\n");
            }

            break;

        case FullscreenControlReverseMousePointerDB:

            TRACE_SWITCH(("Switching: FullscreenControlReverseMousePointerDB\n"));

            {
                FSVIDEO_REVERSE_MOUSE_POINTER MousePointer;
                ULONG_PTR offset;

                __try
                {
                    ProbeForRead(FullscreenInput, sizeof(FSVIDEO_REVERSE_MOUSE_POINTER), sizeof(USHORT));
                    RtlCopyMemory(&MousePointer, FullscreenInput, sizeof(FSVIDEO_REVERSE_MOUSE_POINTER));
                }
                __except (EXCEPTION_EXECUTE_HANDLER)
                {
                    RIP("Fullscreen control - error processing input/output buffer\n");
                }

                offset = SCREEN_BUFFER_POINTER(MousePointer.Screen.Position.X,
                                               MousePointer.Screen.Position.Y,
                                               MousePointer.Screen.ScreenSize.X,
                                               sizeof(VGA_CHAR));

                if ((offset+1) < FrameBufLen)
                {
                    pFrameBuf += offset;
                    Attribute =  (*(pFrameBuf + 1) & 0xF0) >> 4;
                    Attribute |= (*(pFrameBuf + 1) & 0x0F) << 4;
                    *(pFrameBuf + 1) = Attribute;
                }
                else
                {
                    RIP("Fullscreen control - error processing input/output buffer\n");
                }
            }
            break;
        }
    }
    else
    if (ioctl == IOCTL_FSVIDEO_COPY_FRAME_BUFFER)
    {
        PFSVIDEO_COPY_FRAME_BUFFER CopyFrameBuffer;

        cCapBuffer = sizeof(FSVIDEO_COPY_FRAME_BUFFER);
        pCapBuffer = PALLOCNOZ(cCapBuffer, GDITAG_FULLSCREEN);

        if (!pCapBuffer)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            CopyFrameBuffer = (PFSVIDEO_COPY_FRAME_BUFFER) pCapBuffer;
            __try
            {
                ProbeForRead(FullscreenInput, sizeof(FSCNTL_SCREEN_INFO), sizeof(USHORT));
                RtlCopyMemory(&CopyFrameBuffer->SrcScreen, FullscreenInput, sizeof(FSCNTL_SCREEN_INFO));

                ProbeForRead(FullscreenOutput, sizeof(FSCNTL_SCREEN_INFO), sizeof(USHORT));
                RtlCopyMemory(&CopyFrameBuffer->DestScreen, FullscreenOutput, sizeof(FSCNTL_SCREEN_INFO));
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                RIP("Fullscreen control - error processing input/output buffer\n");
            }

            Status = GreDeviceIoControl(gFeFullscreenGraphicsDevice.pDeviceHandle,
                                        ioctl,
                                        pCapBuffer,
                                        cCapBuffer,
                                        NULL,
                                        0,
                                        &BytesReturned);
        }
    }
    else
    if (ioctl == IOCTL_FSVIDEO_WRITE_TO_FRAME_BUFFER)
    {
        PFSVIDEO_WRITE_TO_FRAME_BUFFER WriteFrameBuffer;

        cCapBuffer = sizeof(FSVIDEO_WRITE_TO_FRAME_BUFFER) + FullscreenInputLength;
        pCapBuffer = PALLOCNOZ(cCapBuffer, GDITAG_FULLSCREEN);

        if (!pCapBuffer)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            WriteFrameBuffer = (PFSVIDEO_WRITE_TO_FRAME_BUFFER) pCapBuffer;
            __try
            {
                ProbeForRead(FullscreenInput, FullscreenInputLength, sizeof(USHORT));
                WriteFrameBuffer->SrcBuffer =
                    (PCHAR_IMAGE_INFO)((PBYTE)pCapBuffer + sizeof(FSVIDEO_WRITE_TO_FRAME_BUFFER));
                RtlCopyMemory(WriteFrameBuffer->SrcBuffer, FullscreenInput, FullscreenInputLength);

                ProbeForRead(FullscreenOutput, sizeof(FSCNTL_SCREEN_INFO), sizeof(USHORT));
                RtlCopyMemory(&WriteFrameBuffer->DestScreen, FullscreenOutput, sizeof(FSCNTL_SCREEN_INFO));
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                RIP("Fullscreen control - error processing input/output buffer\n");
            }

            Status = GreDeviceIoControl(gFeFullscreenGraphicsDevice.pDeviceHandle,
                                        ioctl,
                                        pCapBuffer,
                                        cCapBuffer,
                                        NULL,
                                        0,
                                        &BytesReturned);
        }
    }
    else
    if (ioctl == IOCTL_FSVIDEO_REVERSE_MOUSE_POINTER)
    {
        PFSVIDEO_REVERSE_MOUSE_POINTER MouseFrameBuffer;

        cCapBuffer = sizeof(FSVIDEO_REVERSE_MOUSE_POINTER);
        pCapBuffer = PALLOCNOZ(cCapBuffer, GDITAG_FULLSCREEN);

        if (!pCapBuffer)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            MouseFrameBuffer = (PFSVIDEO_REVERSE_MOUSE_POINTER) pCapBuffer;
            __try
            {
                ProbeForRead(FullscreenInput, sizeof(FSVIDEO_REVERSE_MOUSE_POINTER), sizeof(USHORT));
                RtlCopyMemory(MouseFrameBuffer, FullscreenInput, sizeof(FSVIDEO_REVERSE_MOUSE_POINTER));
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                RIP("Fullscreen control - error processing input/output buffer\n");
            }

            Status = GreDeviceIoControl(gFeFullscreenGraphicsDevice.pDeviceHandle,
                                        ioctl,
                                        pCapBuffer,
                                        cCapBuffer,
                                        NULL,
                                        0,
                                        &BytesReturned);
        }
    }
    else
    if (ioctl == IOCTL_FSVIDEO_SET_SCREEN_INFORMATION)
    {
        PFSVIDEO_SCREEN_INFORMATION ScreenInformation;

        cCapBuffer = sizeof(FSVIDEO_SCREEN_INFORMATION);
        pCapBuffer = PALLOCNOZ(cCapBuffer, GDITAG_FULLSCREEN);

        if (!pCapBuffer)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            ScreenInformation = (PFSVIDEO_SCREEN_INFORMATION) pCapBuffer;
            __try
            {
                ProbeForRead(FullscreenInput, sizeof(FSVIDEO_SCREEN_INFORMATION), sizeof(USHORT));
                RtlCopyMemory(ScreenInformation, FullscreenInput, sizeof(FSVIDEO_SCREEN_INFORMATION));
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                RIP("Fullscreen control - error processing input/output buffer\n");
            }

            Status = GreDeviceIoControl(gFeFullscreenGraphicsDevice.pDeviceHandle,
                                        ioctl,
                                        pCapBuffer,
                                        cCapBuffer,
                                        NULL,
                                        0,
                                        &BytesReturned);
        }
    }
    else
    if (ioctl == IOCTL_FSVIDEO_SET_CURSOR_POSITION)
    {
        PFSVIDEO_CURSOR_POSITION FsCursorPosition;

        cCapBuffer = sizeof(FSVIDEO_CURSOR_POSITION);
        pCapBuffer = PALLOCNOZ(cCapBuffer, GDITAG_FULLSCREEN);

        if (!pCapBuffer)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            FsCursorPosition = (PFSVIDEO_CURSOR_POSITION) pCapBuffer;
            __try
            {
                ProbeForRead(FullscreenInput, sizeof(FSVIDEO_CURSOR_POSITION), sizeof(USHORT));
                RtlCopyMemory(FsCursorPosition, FullscreenInput, sizeof(FSVIDEO_CURSOR_POSITION));
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                RIP("Fullscreen control - error processing input/output buffer\n");
            }

            Status = GreDeviceIoControl(gFeFullscreenGraphicsDevice.pDeviceHandle,
                                        ioctl,
                                        pCapBuffer,
                                        cCapBuffer,
                                        pCapBuffer,
                                        cCapBuffer,
                                        &BytesReturned);

            if (!NT_SUCCESS(Status))
            {
                /*
                 * If full screen video driver returns error,
                 * do calls VGA mini port driver on this.
                 */
                ioctl = IOCTL_VIDEO_SET_CURSOR_POSITION;
                Status = GreDeviceIoControl(gFullscreenGraphicsDevice.pDeviceHandle,
                                            ioctl,
                                            &FsCursorPosition->Coord,
                                            sizeof(VIDEO_CURSOR_POSITION),
                                            &FsCursorPosition->Coord,
                                            sizeof(VIDEO_CURSOR_POSITION),
                                            &BytesReturned);
            }

            if (cCapBuffer && FullscreenOutputLength && NT_SUCCESS(Status))
            {
                __try
                {
                    ProbeForWrite(FullscreenOutputLength, sizeof(ULONG), sizeof(UCHAR));
                    *FullscreenOutputLength = BytesReturned;

                    ProbeForWrite(FullscreenOutput, BytesReturned, sizeof(UCHAR));
                    RtlCopyMemory(FullscreenOutput, pCapBuffer, BytesReturned);
                }
                __except (EXCEPTION_EXECUTE_HANDLER)
                {
                    RIP("Fullscreen control - error processing output buffer\n");
                }
            }
        }
    }
    else
    {
        //
        // For all real operations, check the output buffer parameters
        //

        if ((FullscreenOutput == NULL) != (FullscreenOutputLength == NULL))
        {
            RIP("Fullscreen control - inconsistent output buffer information\n");
            Status = STATUS_INVALID_PARAMETER_4;
        }
        else
        {
            //
            // We must now capture the buffers so they can be safely passed down to the
            // video miniport driver
            //

            cCapBuffer = FullscreenInputLength;

            if (FullscreenOutputLength)
            {
                __try
                {
                    ProbeForRead(FullscreenOutputLength, sizeof(ULONG), sizeof(UCHAR));
                    cCapBuffer = max(cCapBuffer,*FullscreenOutputLength);
                }
                __except (EXCEPTION_EXECUTE_HANDLER)
                {
                    RIP("Fullscreen control - error processing input buffer\n");
                }
            }

            if (cCapBuffer)
            {
                pCapBuffer = PALLOCNOZ(cCapBuffer, GDITAG_FULLSCREEN);

                if (!pCapBuffer)
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
                else
                {
                    __try
                    {
                        ProbeForRead(FullscreenInput, FullscreenInputLength, sizeof(UCHAR));
                        RtlCopyMemory(pCapBuffer, FullscreenInput, FullscreenInputLength);
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER)
                    {
                        RIP("Fullscreen control - error processing input buffer\n");
                    }
                }
            }

            //
            // For now, the IOCTL will always be sent to the VGA compatible device.
            // We have a global for the handle to this device.
            //

            if (NT_SUCCESS(Status))
            {
                if (gFeFullscreenGraphicsDevice.pDeviceHandle != NULL &&
                     ioctl == IOCTL_VIDEO_SET_CURSOR_ATTR)
                {
                    Status = GreDeviceIoControl(gFeFullscreenGraphicsDevice.pDeviceHandle,
                                                ioctl,
                                                pCapBuffer,
                                                cCapBuffer,
                                                pCapBuffer,
                                                cCapBuffer,
                                                &BytesReturned);
                    if (!NT_SUCCESS(Status))
                    {
                        /*
                         * If full screen video driver returns error,
                         * do calls VGA mini port driver on this.
                         */
                        Status = GreDeviceIoControl(gFullscreenGraphicsDevice.pDeviceHandle,
                                                    ioctl,
                                                    pCapBuffer,
                                                    cCapBuffer,
                                                    pCapBuffer,
                                                    cCapBuffer,
                                                    &BytesReturned);
                    }

                }
                else
                {
                    Status = GreDeviceIoControl(gFullscreenGraphicsDevice.pDeviceHandle,
                                                ioctl,
                                                pCapBuffer,
                                                cCapBuffer,
                                                pCapBuffer,
                                                cCapBuffer,
                                                &BytesReturned);

                    TRACE_SWITCH(("Switching: FullscreenControl: IOCTL status is %08lx\n",
                                  Status));

                    if (cCapBuffer && FullscreenOutputLength && NT_SUCCESS(Status))
                    {
                        __try
                        {
                            *FullscreenOutputLength = BytesReturned;

                            ProbeForWrite(FullscreenOutput, *FullscreenOutputLength, sizeof(UCHAR));
                            RtlCopyMemory(FullscreenOutput, pCapBuffer, *FullscreenOutputLength);
                        }
                        __except (EXCEPTION_EXECUTE_HANDLER)
                        {
                            RIP("Fullscreen control - error processing output buffer\n");
                        }
                    }
                }
            }
        }
    }


    if (pCapBuffer)
    {
        VFREEMEM(pCapBuffer);
    }

    return (Status);
}

/**************************************************************************\
* DrvLogDisplayDriverEvent
*
* We will save a piece of data in the registry so that winlogon can find
* it and put up a popup if an error occured.
*
* CRIT not needed
*
* 03-Mar-1993 andreva created
\**************************************************************************/

VOID
DrvLogDisplayDriverEvent(
    DISP_DRIVER_LOG MsgType
    )
{
    HANDLE            hkRegistry;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING    RegistryPath;
    UNICODE_STRING    UnicodeString;

    NTSTATUS          Status;
    DWORD             dwValue = 1;

#ifdef _HYDRA_
    /*
     * Whatever happens on a Session, don't affect the console.
     */
    if ( !G_fConsole )
        return;
#endif

    RtlInitUnicodeString(&UnicodeString, L"");

    switch (MsgType)
    {
    case MsgInvalidUsingDefaultMode:

        //RtlInitUnicodeString(&UnicodeString, L"DefaultMode");
        break;

    case MsgInvalidDisplayDriver:

        //RtlInitUnicodeString(&UnicodeString, L"MissingDisplayDriver");
        break;

    case MsgInvalidOldDriver:

        RtlInitUnicodeString(&UnicodeString, L"OldDisplayDriver");
        break;

    case MsgInvalidDisplay16Colors:

        //RtlInitUnicodeString(&UnicodeString, L"16ColorMode");
        break;

    case MsgInvalidDisplayMode:

        //RtlInitUnicodeString(&UnicodeString, L"BadMode");
        break;

    case MsgInvalidConfiguration:

        //RtlInitUnicodeString(&UnicodeString, L"InvalidConfiguration");
        break;

    default:

        WARNING("DrvLogDisplayDriverEvent: Invalid error message\n");
        return;

    }

    if (UnicodeString.Length != 0) {

        RtlInitUnicodeString(&RegistryPath,
                             L"\\Registry\\Machine\\System\\CurrentControlSet\\"
                             L"Control\\GraphicsDrivers\\InvalidDisplay");

        InitializeObjectAttributes(&ObjectAttributes,
                                   &RegistryPath,
                                   OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                                   NULL,
                                   NULL);

        Status = ZwCreateKey(&hkRegistry,
                             MAXIMUM_ALLOWED,
                             &ObjectAttributes,
                             0L,
                             NULL,
                             REG_OPTION_VOLATILE,
                             NULL);

        if (NT_SUCCESS(Status))
        {
            //
            // Write the optional data value under the key.
            //

            (VOID) ZwSetValueKey(hkRegistry,
                                 &UnicodeString,
                                 0,
                                 REG_DWORD,
                                 &dwValue,
                                 sizeof(DWORD));

            (VOID)ZwCloseKey(hkRegistry);
        }
    }
}

/******************************Member*Function*****************************\
* bEARecovery
*
* This function checks to see if the EA Recovery mechanism is enabled
* in the registry.
*
\**************************************************************************/

#define EARecovery L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Watchdog\\Display"

BOOL bEARecovery(VOID)
{
    ULONG ulDefault = 0;
    ULONG ulEaRecovery = 0;
    ULONG ulFullRecovery = 0;
    RTL_QUERY_REGISTRY_TABLE queryTable[] =
    {
        {NULL, RTL_QUERY_REGISTRY_DIRECT, L"EaRecovery", &ulEaRecovery, REG_DWORD, &ulDefault, sizeof(ULONG)},
        {NULL, RTL_QUERY_REGISTRY_DIRECT, L"FullRecovery", &ulFullRecovery, REG_DWORD, &ulDefault, sizeof(ULONG)},
        {NULL, 0, NULL}
    };

    RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                           EARecovery,
                           queryTable,
                           NULL,
                           NULL);

    return ulEaRecovery;
}

extern PFN WatchdogTable[INDEX_LAST];

/******************************Member*Function*****************************\
* bFillWatchdogTable
*
* Fills the dispatch table called by the system with a set of routines
* which wrap the final driver entry points.  This is done to allow us to
* hook each of these calls.
*
\**************************************************************************/

BOOL bFillWatchdogTable(
PFN *Dst,
PFN *Src,
LDEVTYPE ldevType)
{
    ULONG i;

    //
    // This is required.  At least for the final entries in the
    // array which are the DX entry points.
    //

    RtlZeroMemory(Dst, INDEX_DD_LAST * sizeof(PFN));

    if (bEARecovery() && (ldevType == LDEV_DEVICE_DISPLAY)) {

        for (i=0; i<INDEX_LAST; i++) {

            if (*Src && WatchdogTable[i]) {
                *Dst = WatchdogTable[i];
            } else {
                *Dst = *Src;
            }

            Src++;
            Dst++;
        }

    } else {

        RtlCopyMemory(Dst, Src, INDEX_LAST * sizeof(PFN));
    }

    return TRUE;
}

/******************************Member*Function*****************************\
* bFillFunctionTable
*
* Fills the dispatch table of the LDEV with function pointers from the
* driver.
*
\**************************************************************************/

BOOL bFillFunctionTable(
PDRVFN  pdrvfn,
ULONG   cdrvfn,
PFN*    ppfnTable)
{
    //
    // fill with zero pointers to avoid possibility of accessing
    // incorrect fields later
    //

    RtlZeroMemory(ppfnTable, INDEX_LAST*sizeof(PFN));

    //
    // Copy driver functions into our table.
    //

    while (cdrvfn--)
    {
        //
        // Check the range of the index.
        //

        if (pdrvfn->iFunc >= INDEX_LAST)
        {
            return(FALSE);
        }

        //
        // Copy the pointer.
        //

        ppfnTable[pdrvfn->iFunc] = pdrvfn->pfn;
        pdrvfn++;
    }

    return(TRUE);
}

/******************************Member*Function*****************************\
* ldevbFillTable (ded)
*
* Fills the dispatch table of the LDEV with function pointers from the
* driver.  Checks that the required functions are present.
*
\**************************************************************************/

static const ULONG aiFuncRequired[] =
{
    INDEX_DrvEnablePDEV,
    INDEX_DrvCompletePDEV,
    INDEX_DrvDisablePDEV,
};

static const ULONG aiFuncPairs[][2] =
{
    {INDEX_DrvCreateDeviceBitmap, INDEX_DrvDeleteDeviceBitmap},
    {INDEX_DrvMovePointer,        INDEX_DrvSetPointerShape}
};

static const ULONG aiFuncRequiredFD[] =
{
    INDEX_DrvQueryFont,
    INDEX_DrvQueryFontTree,
    INDEX_DrvQueryFontData,
    INDEX_DrvQueryFontCaps,
    INDEX_DrvLoadFontFile,
    INDEX_DrvUnloadFontFile,
    INDEX_DrvQueryFontFile
};

BOOL
ldevFillTable(
    PLDEV pldev,
    DRVENABLEDATA *pded,
    LDEVTYPE ldt)
{
    //
    // Get local copies of ded info and a pointer to the dispatch table.
    //

    ULONG  cLeft     = pded->c;
    PDRVFN pdrvfn    = pded->pdrvfn;
    PFN   *ppfnTable = pldev->apfnDriver;

    //
    // Store the driver version in the LDEV
    //

    pldev->ulDriverVersion = pded->iDriverVersion;

    if (!bFillFunctionTable(pdrvfn, cLeft, ppfnTable))
    {
        ASSERTGDI(FALSE,"ldevFillTable: bogus function index\n");
        return(FALSE);
    }

    //
    // Check for required driver functions.
    //

    cLeft = sizeof(aiFuncRequired) / sizeof(ULONG);
    while (cLeft--)
    {
        if (ppfnTable[aiFuncRequired[cLeft]] == (PFN) NULL)
        {
            ASSERTGDI(FALSE,"ldevFillTable: a required function is missing from driver\n");
            return(FALSE);
        }
    }

    //
    // Check for required font functions.
    //

    if (pldev->ldevType == LDEV_FONT)
    {
        cLeft = sizeof(aiFuncRequiredFD) / sizeof(ULONG);
        while (cLeft--)
        {
            if (ppfnTable[aiFuncRequiredFD[cLeft]] == (PFN) NULL)
            {
                ASSERTGDI(FALSE,"FillTable(): a required FD function is missing\n");
                return(FALSE);
            }
        }
    }

    //
    // Check for functions that come in pairs.
    //

    cLeft = sizeof(aiFuncPairs) / sizeof(ULONG) / 2;
    while (cLeft--)
    {
        //
        // Make sure that either both functions are hooked or both functions
        // are not hooked.
        //

        if ((ppfnTable[aiFuncPairs[cLeft][0]] == (PFN) NULL)
            != (ppfnTable[aiFuncPairs[cLeft][1]] == (PFN) NULL))
        {
            ASSERTGDI(FALSE,"ldevFillTable: one of pair of functions is missing from driver\n");
            return(FALSE);
        }
    }

    //
    // The driver supplied function table looks good.  Create another
    // table which mirrors this one with new functions that can add
    // monitoring code.
    //

    if (!bFillWatchdogTable((PFN*)&pldev->apfn, (PFN*)&pldev->apfnDriver, ldt)) {

        return FALSE;
    }

    return(TRUE);
}

/******************************Member*Function*****************************\
* ldevLoadInternal
*
* Enable one of the statically linked font drivers via the LDEV.
*
\**************************************************************************/

PLDEV
ldevLoadInternal(
    PFN pfnEnable,
    LDEVTYPE ldt)
{
    GDIFunctionID(ldevLoadInternal);

    PLDEV pldev;

    TRACE_INIT(("ldevLoadInternal ENTERING\n"));

    GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);

    //
    // Allocate memory for the LDEV.
    //

    pldev = (PLDEV) PALLOCMEM(sizeof(LDEV), GDITAG_LDEV);

    if (pldev)
    {
        //
        // Call the Enable entry point.
        //

        DRVENABLEDATA ded;

        if ((!((* (PFN_DrvEnableDriver) pfnEnable) (ENGINE_VERSION,
                                                    sizeof(DRVENABLEDATA),
                                                    &ded))) ||
	    (!ldevFillTable(pldev, &ded, ldt)))
        {
            VFREEMEM(pldev);
            pldev = NULL;
        }
        else
        {
            pldev->ldevType = ldt;
	    pldev->cldevRefs = 1;
	    pldev->bThreadStuck = FALSE;

            //
            // Initialize the rest of the LDEV.
            //

            if (gpldevDrivers)
            {
                gpldevDrivers->pldevPrev = pldev;
            }

            pldev->pldevNext = gpldevDrivers;
            pldev->pldevPrev = NULL;

            gpldevDrivers = pldev;

            //
            // Since this driver is statically linked in, there is no name or
            // MODOBJ.
            //

            pldev->pGdiDriverInfo = NULL;

            TRACE_INIT(("ldevLoadInternal: SUCCESS loaded static driver (font or DDML)\n"));
        }
    }

    GreReleaseSemaphoreEx(ghsemDriverMgmt);

    return pldev;
}

/******************************Member*Function*****************************\
* ldevLoadImage
*
* Examines the list of loaded drivers and returns library handles (if any).
*
* Updates the ref cnt on driver usage.
*
* If the driver is not already loaded, a node is created and the dll is
* loaded in the kernel.
\**************************************************************************/

PLDEV
ldevLoadImage(
    LPWSTR   pwszDriver,
    BOOL     bImage,
    PBOOL    pbAlreadyLoaded,
    BOOL     LoadInSessionSpace)
{

    PSYSTEM_GDI_DRIVER_INFORMATION pGdiDriverInfo = NULL;
    PLDEV pldev = NULL;

    UNICODE_STRING usDriverName;
    PLDEV pldevList;

    NTSTATUS Status;
    BOOLEAN OldHardErrorMode;
    BOOL bSearchAgain, bLoadAgain;
    BOOL bResetDriverNameToSystem32;

    TRACE_INIT(("ldevLoadImage called on Image %ws\n", pwszDriver));

    *pbAlreadyLoaded = FALSE;

    //
    // Only append the .dll if it's NOT an image.
    //

    if (MakeSystemRelativePath(pwszDriver,
                               &usDriverName,
                               !bImage))
    {
        bSearchAgain = TRUE;

 searchagain:
        //
        // Check both list of drivers.
        //

        pldevList = gpldevDrivers;

        TRACE_INIT(("ldevLoadImage - search for existing image %ws\n",
                   usDriverName.Buffer));

        while (pldevList != NULL)
        {
            //
            // If there is a valid driver image, and if the types are compatible.
            // bImage == TRUE means load an image,  while bImage == FALSE means
            // anything else (for now)
            //

            if ((pldevList->pGdiDriverInfo) &&
                ((pldevList->ldevType == LDEV_IMAGE) == bImage))
            {
                //
                // Do a case insensitive compare since the printer driver name
                // can come from different locations.
                //

                if (RtlEqualUnicodeString(&(pldevList->pGdiDriverInfo->DriverName),
                                          &usDriverName,
                                          TRUE))
                {
                    //
                    // If it's already loaded, increment the ref count
                    // and return that pointer.
                    //

                    TRACE_INIT(("ldevLoadImage found image.  Inc ref count\n"));

                    pldevList->cldevRefs++;

                    *pbAlreadyLoaded = TRUE;

                    pldev = pldevList;
                    break;
                }
            }

            pldevList = pldevList->pldevNext;
        }

        if (pldev == NULL)
        {
            if (!LoadInSessionSpace)
            {
                // If not a session load see if the Driver is from the
                // \SystemRoot\System32\Drivers subdir. Ex dxapi.sys
                if (bSearchAgain)
                {
                    bSearchAgain = FALSE;
                    PWSTR pOldBuffer = usDriverName.Buffer;
                    bResetDriverNameToSystem32 = FALSE;
                    if (MakeSystemDriversRelativePath(pwszDriver,
                                                      &usDriverName,
                                                      !bImage))
                    {
                        bResetDriverNameToSystem32 = TRUE;
                        VFREEMEM(pOldBuffer);
                        goto searchagain;
                    }
                }

                if (bResetDriverNameToSystem32)
                {
                    PWSTR pOldBuffer = usDriverName.Buffer;
                    if (!MakeSystemRelativePath(pwszDriver,
                                                &usDriverName,
                                                !bImage))
                    {
                        goto done;
                    }
                    VFREEMEM(pOldBuffer);
                }
            }

            TRACE_INIT(("ldevLoadImage - attempting to load new image\n"));

            pGdiDriverInfo = (PSYSTEM_GDI_DRIVER_INFORMATION)
                PALLOCNOZ(sizeof(SYSTEM_GDI_DRIVER_INFORMATION), GDITAG_LDEV);

            pldev = (PLDEV) PALLOCMEM(sizeof(LDEV), GDITAG_LDEV);

            bLoadAgain = TRUE;

            if (pGdiDriverInfo && pldev)
            {
loadagain:
                pGdiDriverInfo->DriverName = usDriverName;

                //
                // We must disable hard error popups when loading drivers.
                // Otherwise we will deadlock since MM will directly try to put
                // up a popup.
                //
                // This will also stop us from automatically bugchecking when
                // an old driver is loaded, so we can try and recvoder from it.
                //
                // ISSUE: we want to put up our own popup if this occurs.
                // It needs to be done higher up when we have no locks held.
                //

                OldHardErrorMode = PsGetThreadHardErrorsAreDisabled(PsGetCurrentThread());
                PsSetThreadHardErrorsAreDisabled(PsGetCurrentThread(), TRUE);


                //
                // If we are loading a printer driver, we can be in the
                // context of any user process. This can cause problems
                // loading if the process is out of quota.
                //
                // There is also a security risk in that a non-based
                // printer driver gets temporarily mapped into the user
                // mode address space, and then copied down into the kernel.
                // Another thread in this process could modify the image
                // within this window by changing memory protections. So
                // we solve both the quota problem, and the security issue
                // by attaching to gpepCSRSS.
                //
                // NOTE: This problem exits on standard NT 4.0 as well.
                //
                if (gpepCSRSS == NULL) {
                    Status = STATUS_INVALID_PARAMETER;
                        }
                else {
                    KeAttachProcess( PsGetProcessPcb(gpepCSRSS));

                    if (LoadInSessionSpace) {
                        Status = ZwSetSystemInformation(SystemLoadGdiDriverInformation,
                                                pGdiDriverInfo,
                                                sizeof(SYSTEM_GDI_DRIVER_INFORMATION));
                    } else {
                        Status = ZwSetSystemInformation(SystemLoadGdiDriverInSystemSpace,
                                                pGdiDriverInfo,
                                                sizeof(SYSTEM_GDI_DRIVER_INFORMATION));
                    }
                    KeDetachProcess();
                }
                PsSetThreadHardErrorsAreDisabled(PsGetCurrentThread(), OldHardErrorMode);

                //
                // If we get an OBJECT_NAME_NOT_FOUND we handle it the
                // following way:
                //
                // (1) If its a session load then its an error.
                //
                // (2) If it is a non session load then we try again to load
                //     the driver from System32\Drivers subdirectory. We do
                //     this because DX can ask us to load dxapi.sys and
                //     it lives in drivers subdir.
                //
                // In general we should never get IMAGE_ALREADY_LOADED because
                // we check for loaded images above.
                //
                // If we do get this status we handle them in the following
                // manner:
                //
                // (1) If we get IMAGE_ALREADY_LOADED when LoadInSessionSpace
                //     is true it is an error. We fail the ldev creation. Why ?
                //     because the image may be loaded in another session
                //     space and not in ours.
                //        
                // (2) If we get IMAGE_ALREADY_LOADED when LoadInSessionSpace
                //     is false (i.e load in non session space) we will fail 
                //     to create the ldev for modules (dll/sys) that win32k.sys 
                //     does not statically link to. Why ? because such modules
                //     can get unloaded without win32k.sys knowing about it.
                //     By makeing sure we succeed only statically linked
                //     modules we are gauranteed they wont get unloaded
                //     behind our back because of our static link dependancy.
                //     This also means for such ldevs we cant unload them
                //     in ldevUnloadImage's ZwSetSystemInformation. A 
                //     bStaticImportLink BOOL has been added to the LDEV to
                //     handle this case.
                //

                if ((NT_SUCCESS( Status )))
                {
addstaticimport:
                    TRACE_INIT(("ldevLoadImage SUCCESS with HANDLE %08lx\n",
                               (ULONG_PTR)pGdiDriverInfo));

                    pldev->pGdiDriverInfo = pGdiDriverInfo;
                    pldev->bArtificialIncrement = FALSE;
		    pldev->cldevRefs = 1;
		    pldev->bThreadStuck = FALSE;

                    // Assume image for now.

                    pldev->ldevType = LDEV_IMAGE;

                    pldev->ulDriverVersion = (ULONG) -1;

                    if (gpldevDrivers)
                    {
                        gpldevDrivers->pldevPrev = pldev;
                    }

                    pldev->pldevNext = gpldevDrivers;
                    pldev->pldevPrev = NULL;

                    gpldevDrivers = pldev;

                    //
                    // We exit with all resources allocated, after leaving the
                    // semaphore.
                    //

                    return (pldev);
                }
                else
                {
                    if (!LoadInSessionSpace)
                    {
                        if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
                        {
                            if(bLoadAgain)
                            {
                                bLoadAgain = FALSE;

                                PWSTR pOldBuffer = usDriverName.Buffer;
                                if (MakeSystemDriversRelativePath(pwszDriver,
                                                                  &usDriverName,
                                                                  !bImage))
                                {
                                    VFREEMEM(pOldBuffer);
                                    goto loadagain;
                                }
                            }
                        }

                        if (Status == STATUS_IMAGE_ALREADY_LOADED)
                        {
                            //
                            // We allow this load to work only if the module is
                            // in win32k.sys static import lib list.
                            //

                            RTL_PROCESS_MODULES ModuleInformation;
                            DWORD               cbModuleInformation;
                            DWORD               ReturnedLength;
                            PRTL_PROCESS_MODULES pModuleInformation = 0;
                            DWORD                i;
                            ANSI_STRING          asDriver;
                            UNICODE_STRING       uTmp;
                            BOOL                 bFoundDriver = FALSE;
                            BOOL                 bFreeAsDriver = FALSE;
                            WCHAR                *pwszDriverFileName = 0;

                            pwszDriverFileName = wcsrchr(pwszDriver,L'\\');

                            if (pwszDriverFileName)
                                pwszDriverFileName++;
                            else
                                pwszDriverFileName = pwszDriver;

                            RtlInitUnicodeString(&uTmp, pwszDriverFileName);

                            Status = RtlUnicodeStringToAnsiString(&asDriver,&uTmp,TRUE);

                            //
                            // 1) Locate asDriver name in system Module list:
                            //

                            if (NT_SUCCESS(Status))
                            {
                                bFreeAsDriver = TRUE;

                                Status = ZwQuerySystemInformation(SystemModuleInformation,
                                                                  &ModuleInformation,
                                                                  sizeof(ModuleInformation),
                                                                  &ReturnedLength);
                                if (NT_SUCCESS(Status) || (Status == STATUS_INFO_LENGTH_MISMATCH))
                                {
                                    cbModuleInformation = offsetof(RTL_PROCESS_MODULES, Modules);
                                    cbModuleInformation += ModuleInformation.NumberOfModules * sizeof(RTL_PROCESS_MODULE_INFORMATION);

                                    pModuleInformation = (PRTL_PROCESS_MODULES)PALLOCNOZ(cbModuleInformation, 'pmtG');

                                    if (pModuleInformation)
                                    {
                                        Status = ZwQuerySystemInformation(SystemModuleInformation,
                                                                          pModuleInformation,
                                                                          cbModuleInformation,
                                                                          &ReturnedLength);
                                        if (NT_SUCCESS(Status))
                                        {
                                            for (i = 0; i < ModuleInformation.NumberOfModules; i++)
                                            {
                                                CHAR *FullPathName = (CHAR*)(pModuleInformation->Modules[i].FullPathName);
                                                USHORT OffsetToFileName = pModuleInformation->Modules[i].OffsetToFileName;

                                                if(!_strnicmp(&FullPathName[OffsetToFileName],
                                                             asDriver.Buffer,
                                                             asDriver.Length))
                                                {
                                                    bFoundDriver = TRUE;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            //
                            // 2) Found it in System Module list? then locate it in win32k.sys static import list
                            //

                            if (bFoundDriver)
                            {
                                bFoundDriver = FALSE;

                                PIMAGE_IMPORT_DESCRIPTOR ImportDescriptor;
                                ULONG                    ImportSize;
                                PSZ                      ImportName;

                                ImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)
                                    RtlImageDirectoryEntryToData(gpvWin32kImageBase,
                                                                 TRUE,
                                                                 IMAGE_DIRECTORY_ENTRY_IMPORT,
                                                                 &ImportSize);
                                while (ImportDescriptor &&
                                       ImportDescriptor->Name &&
                                       ImportDescriptor->OriginalFirstThunk)
                                {
                                    ImportName = (PSZ)((PCHAR)gpvWin32kImageBase +
                                                        ImportDescriptor->Name);

                                    if (!_strnicmp(ImportName,
                                                   asDriver.Buffer,
                                                   asDriver.Length))
                                    {
                                        bFoundDriver = TRUE;
                                        break;
                                    }

                                    ImportDescriptor += 1;
                                }
                            }

                            //
                            // 3) Found it in both system Module list and win32k.sys static import list ? 
                            //    then gather GDISystemInformation and add pldev to gpLdevList:

                            if (bFoundDriver)
                            {
                                PVOID ImageBaseAddress = pModuleInformation->Modules[i].ImageBase;
                                ULONG_PTR EntryPoint;
                                ULONG Size;

                                pGdiDriverInfo->ExportSectionPointer = (PIMAGE_EXPORT_DIRECTORY)
                                                RtlImageDirectoryEntryToData(ImageBaseAddress,
                                                                             TRUE,
                                                                             IMAGE_DIRECTORY_ENTRY_EXPORT,
                                                                             &Size);

                                PIMAGE_NT_HEADERS NtHeaders = RtlImageNtHeader(ImageBaseAddress);
                                EntryPoint = NtHeaders->OptionalHeader.AddressOfEntryPoint;
                                EntryPoint += (ULONG_PTR)ImageBaseAddress;

                                pGdiDriverInfo->ImageAddress = ImageBaseAddress; 
                                pGdiDriverInfo->SectionPointer = 0;
                                pGdiDriverInfo->EntryPoint = (PVOID)EntryPoint;

                            }

                            if (pModuleInformation)
                                VFREEMEM(pModuleInformation);
                            if (bFreeAsDriver)
                                RtlFreeAnsiString(&asDriver);

                            if (bFoundDriver)
                            {
                                pldev->bStaticImportLink = TRUE;
                                goto addstaticimport;
                            }
                        }
                    }

                    //
                    // Check the special return code from MmLoadSystemImage
                    // that indicates this is an old driver being linked
                    // against something else than win32k.sys
                    //
                    // If it is, call user to log the error.

                    if (Status == STATUS_PROCEDURE_NOT_FOUND)
                    {
                        DrvLogDisplayDriverEvent(MsgInvalidOldDriver);
                    }
                }
            }

            //
            // Either success due to a cached entry, or failiure.
            // In either case, we can free all the resources we allocatred.
            //

            if (pGdiDriverInfo)
                VFREEMEM(pGdiDriverInfo);

            if (pldev)
                VFREEMEM(pldev);

            pldev = NULL;

        }
done:
        VFREEMEM(usDriverName.Buffer);
    }

    TRACE_INIT(("ldevLoadImage %ws  with HANDLE %08lx\n",
                pldev ? L"SUCCESS" : L"FAILED", pldev));

    return (pldev);

}

/******************************Member*Function*****************************\
* ldevUnloadImage()
*
* Decrements the refcnt on driver usage.
* If the refcnt is zero {
*       Deletes an LDEV.  Disables and unloads the driver.
* }
\**************************************************************************/

VOID
ldevUnloadImage(
    PLDEV pldev)
{
    GDIFunctionID(ldevUnloadImage);

    LPWSTR  pDriverFile = NULL, pCopyDriverFile = NULL;
    ULONG   cbDriverFile;

    //
    // Hold the LDEV semaphore until after the module is unloaded.
    //

    GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);

    if (--pldev->cldevRefs == 0)
    {
        //
        // Make sure that there is exactly one reference to this LDEV.
        //

        TRACE_INIT(("ldevUnloadImage: ENTERING\n"));

        //
        // Call the driver unload routine if it exists.
        //

        PFN_DrvDisableDriver pfnDisableDriver =
            (PFN_DrvDisableDriver) pldev->apfn[INDEX_DrvDisableDriver];

        if (pfnDisableDriver)
        {
            (*pfnDisableDriver)();
        }

        //
        // If the module handle exits, need to unload the module.  (Does not exist
        // for the statically linked font drivers).
        //

        if (pldev->pGdiDriverInfo)
        {
            //
            // Tell the module to unload.
            //

            TRACE_INIT(("ldevUnloadImage called on Image %08lx,  %ws\n",
                       (ULONG_PTR) pldev, pldev->pGdiDriverInfo->DriverName.Buffer));

#ifdef _HYDRA_
            if( gpepCSRSS != NULL )
                KeAttachProcess( PsGetProcessPcb(gpepCSRSS));
#endif
            if (!(pldev->bStaticImportLink))
            {
                ZwSetSystemInformation(SystemUnloadGdiDriverInformation,
                                       &(pldev->pGdiDriverInfo->SectionPointer),
                                       sizeof(ULONG_PTR));
            }

#ifdef _HYDRA_
            if( gpepCSRSS != NULL )
                KeDetachProcess();
#endif

            //
            // If a printer driver is being unloaded, the spooler must be informed
            // so that it may perform driver upgrades.
            //

            if ((pldev->ldevType == LDEV_DEVICE_PRINTER) &&
                (pldev->bArtificialIncrement == FALSE))
            {
                // Copy the driver file name into a temp buffer
                // This will be used to notify the spooler of the driver unload
                // from outside the semaphore
                pDriverFile = pldev->pGdiDriverInfo->DriverName.Buffer;

                // Check for invalid printer driver names.
                if (pDriverFile && *pDriverFile)
                {
                   // Copy the driver name into another buffer.
                   cbDriverFile = (wcslen(pDriverFile) + 1) * sizeof(WCHAR);
                   pCopyDriverFile  = (LPWSTR) PALLOCMEM(cbDriverFile, 'lpsG');

                   if (pCopyDriverFile) {
                       memcpy(pCopyDriverFile, pDriverFile, cbDriverFile);
                   }
                }
            }

            //
            // Free the memory associate with the module
            //

            VFREEMEM(pldev->pGdiDriverInfo->DriverName.Buffer);
            VFREEMEM(pldev->pGdiDriverInfo);

        }

        //
        // Remove the ldev from the linker list
        //

        if (pldev->pldevNext)
        {
            pldev->pldevNext->pldevPrev = pldev->pldevPrev;
        }

        if (pldev->pldevPrev)
        {
            pldev->pldevPrev->pldevNext = pldev->pldevNext;
        }
        else
        {
            gpldevDrivers = pldev->pldevNext;
        }

        //
        // Free the ldev
        //

        VFREEMEM(pldev);
    }
    else
    {
        TRACE_INIT(("ldevUnloadImage - refcount decremented\n"));
    }

    GreReleaseSemaphoreEx(ghsemDriverMgmt);

    if (pCopyDriverFile)
    {
        GrePrinterDriverUnloadW(pCopyDriverFile);
        VFREEMEM(pCopyDriverFile);
    }

    return;
}

/******************************Member*Function*****************************\
* ldevLoadDriver
*
* Locate an existing driver or load a new one.  Increase its reference
* count.
*
\**************************************************************************/

PLDEV
ldevLoadDriver(
    LPWSTR pwszDriver,
    LDEVTYPE ldt)
{
    GDIFunctionID(ldevLoadDriver);

    NTSTATUS Status = STATUS_INSUFFICIENT_RESOURCES;
    PLDEV pldev;
    BOOL bLoaded;



    //
    // Check for a bogus driver name.
    //

    if ((pwszDriver == NULL) ||
        (*pwszDriver == L'\0'))
    {
        WARNING("ldevLoadDriver: bogus driver name\n");
        return NULL;
    }

#if DBG
    //
    // Check for bogus driver type
    //

    if ((ldt != LDEV_FONT) &&
        (ldt != LDEV_DEVICE_DISPLAY) &&
        (ldt != LDEV_DEVICE_PRINTER) &&
        (ldt != LDEV_DEVICE_MIRROR))
    {
        WARNING("ldevLoadDriver: bad LDEVTYPE\n");
        return NULL;
    }
#endif

    GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);

    pldev = ldevLoadImage(pwszDriver, FALSE, &bLoaded, TRUE);

    if (pldev)
    {
        if (bLoaded)
        {
            TRACE_INIT(("ldevLoadDriver: SUCCESS, Driver already loaded\n"));

            GreReleaseSemaphoreEx(ghsemDriverMgmt);
        }
        else
        {
            DRVENABLEDATA ded = {0,0,(DRVFN *) NULL};

            if ((pldev->pGdiDriverInfo->EntryPoint != NULL) &&
                ((PFN_DrvEnableDriver) pldev->pGdiDriverInfo->EntryPoint)(
                     ENGINE_VERSION, sizeof(DRVENABLEDATA), &ded) &&
                (ded.iDriverVersion <= ENGINE_VERSION) &&
                (ded.iDriverVersion >= ENGINE_VERSIONSUR) &&
		ldevFillTable(pldev, &ded, ldt))
            {

                //
                // Make sure the name and type of the ldev is initialized
                //

                pldev->ldevType = ldt;

                //
                // For printer drivers increment the refcnt to 2. This will keep
                // the drivers loaded until they are upgraded by the spooler. The
                // artificial increment will be undone when the spooler sends the
                // appropriate message.
                //

                if (ldt == LDEV_DEVICE_PRINTER)
                {
                    if (!pldev->bArtificialIncrement)
                    {
                        pldev->cldevRefs += 1;
                        pldev->bArtificialIncrement = TRUE;
                    }
                }

                GreReleaseSemaphoreEx(ghsemDriverMgmt);

#ifdef _HYDRA_
                /*
                 * For remote video driver, call connect entry point to pass the
                 * Client data and the thinwire cache data area pointer.
                 *
                 * Only do this once.  We don't support multiple drivers.
                 */

                    PFN_DrvConnect pConnectCall;

                    pConnectCall = (PFN_DrvConnect)((pldev->apfn[INDEX_DrvConnect]));

                    if ( pConnectCall ) {
                        ASSERT(gProtocolType != PROTOCOL_DISCONNECT);

                        BOOL Result;

                        Result = (*pConnectCall) (
                            G_RemoteConnectionChannel,
                            G_RemoteConnectionFileObject,
                            G_RemoteVideoFileObject,
                            G_PerformanceStatistics );
                        if ( !Result ) {
                            //
                            // Error exit path
                            //

                            ldevUnloadImage(pldev);

                            pldev = NULL;

                            TRACE_INIT(("LDEVREF::LDEVREF: CONNECT FAILIURE\n"));
                            return pldev;
                        }

                    }
#endif

                TRACE_INIT(("ldevLoadDriver: SUCCESS\n"));
            }
            else
            {
                GreReleaseSemaphoreEx(ghsemDriverMgmt);

                //
                // Error exit path
                //

                ldevUnloadImage(pldev);

                pldev = NULL;

                TRACE_INIT(("ldevLoadDriver: FAILURE\n"));
            }
        }
    }
    else
    {
        GreReleaseSemaphoreEx(ghsemDriverMgmt);
    }

    return pldev;
}

/******************************Member*Function*****************************\
* ldevArtificialDecrement
*
* Removes the artificial increment on printer drivers.
*
\**************************************************************************/

BOOL
ldevArtificialDecrement(
    LPWSTR pwszDriver)
{
    GDIFunctionID(ldevArtificialDecrement);

    PLDEV          pldev = NULL, pldevList;
    BOOL           bReturn = FALSE;
    UNICODE_STRING usDriverName;

    PSYSTEM_GDI_DRIVER_INFORMATION pGdiDriverInfo = NULL;

    //
    // Check for invalid driver name.
    //

    if (!pwszDriver || !*pwszDriver)
    {
        return bReturn;
    }

    TRACE_INIT(("ldevArtificialDecrement called on Image %ws\n", pwszDriver));

    //
    // Append .dll for printer drivers
    //

    if (MakeSystemRelativePath(pwszDriver,
                               &usDriverName,
                               TRUE))
    {
        //
        // Check both list of drivers.
        //

        GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);

        pldevList = gpldevDrivers;

        TRACE_INIT(("ldevArtificialDecrement - search for existing image %ws\n",
                   usDriverName.Buffer));

        while (pldevList != NULL)
        {
            //
            // Check for loaded printer drivers.
            //

            if ((pldevList->pGdiDriverInfo) &&
                (pldevList->ldevType == LDEV_DEVICE_PRINTER))
            {
                //
                // Do a case insensitive compare since the printer driver name
                // can come from different locations.
                //

                if (RtlEqualUnicodeString(&(pldevList->pGdiDriverInfo->DriverName),
                                          &usDriverName,
                                          TRUE))
                {
                    //
                    // If the driver is found and has an artificial increment on it,
                    // call ldevUnloadImage once and reset the bArtificialIncrement
                    // flag.
                    //

                    TRACE_INIT(("ldevArtificialIncrement found the driver.\n"));

                    if (pldevList->bArtificialIncrement)
                    {
                        pldev = pldevList;
                        pldev->bArtificialIncrement = FALSE;
                    }

                    break;
                }
            }

            pldevList = pldevList->pldevNext;
        }


        GreReleaseSemaphoreEx(ghsemDriverMgmt);

        VFREEMEM(usDriverName.Buffer);
    }

    if (pldev)
    {
        // Spooler will be sent a message when the driver is unloaded.
        ldevUnloadImage(pldev);
    }
    else
    {
        // Return TRUE if the driver is not loaded.
        bReturn = TRUE;
    }

    return bReturn;
}

/******************************Public*Routine******************************\
* EngLoadImage
*
* Loads an image that a display of printers driver can then call to execute
* code
*
\**************************************************************************/

HANDLE
APIENTRY
EngLoadImage(
    LPWSTR pwszDriver
    )
{
    GDIFunctionID(EngLoadImage);

    BOOL   bLoaded;
    HANDLE h;

    GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);

    h = ldevLoadImage(pwszDriver, TRUE, &bLoaded, TRUE);

    GreReleaseSemaphoreEx(ghsemDriverMgmt);

    return h;
}

/******************************Public*Routine******************************\
* EngFindImageProcAddress
*
* Returns the address of the specified functions in the module.
* Special DrvEnableDriver since it is the entry point.
*
\**************************************************************************/

typedef struct _NEWPROCADDRESS {
    LPSTR   lpstrName;
    PVOID   pvAddress;
} NEWPROCADDRESS;

// The following define expands 'NEWPROC(x)' to '"x", x':

#define NEWPROC(x) #x, x

// Table of Eng functions that are new since NT 4.0:

NEWPROCADDRESS gaNewProcAddresses[] = {
    NEWPROC(EngQueryPalette),
    NEWPROC(EngSaveFloatingPointState),
    NEWPROC(EngRestoreFloatingPointState),
    NEWPROC(EngSetPointerShape),
    NEWPROC(EngMovePointer),
    NEWPROC(EngSetPointerTag),
    NEWPROC(EngCreateEvent),
    NEWPROC(EngDeleteEvent),
    NEWPROC(EngMapEvent),
    NEWPROC(EngUnmapEvent),
    NEWPROC(EngSetEvent),
    NEWPROC(EngClearEvent),
    NEWPROC(EngReadStateEvent),
    NEWPROC(EngWaitForSingleObject),
    NEWPROC(EngDeleteWnd),
    NEWPROC(EngInitializeSafeSemaphore),
    NEWPROC(EngDeleteSafeSemaphore),
    NEWPROC(HeapVidMemAllocAligned),
    NEWPROC(VidMemFree),
    NEWPROC(EngAlphaBlend),
    NEWPROC(EngGradientFill),
    NEWPROC(EngStretchBltROP),
    NEWPROC(EngPlgBlt),
    NEWPROC(EngTransparentBlt),
    NEWPROC(EngControlSprites),
    NEWPROC(EngLockDirectDrawSurface),
    NEWPROC(EngUnlockDirectDrawSurface),
    NEWPROC(EngMapFile),
    NEWPROC(EngUnmapFile),
    NEWPROC(EngDeleteFile),
    NEWPROC(EngLpkInstalled),
    NEWPROC(BRUSHOBJ_hGetColorTransform),
    NEWPROC(XLATEOBJ_hGetColorTransform),
    NEWPROC(FONTOBJ_pjOpenTypeTablePointer),
    NEWPROC(FONTOBJ_pwszFontFilePaths),
    NEWPROC(FONTOBJ_pfdg),
    NEWPROC(FONTOBJ_pQueryGlyphAttrs),
    NEWPROC(STROBJ_fxCharacterExtra),
    NEWPROC(STROBJ_fxBreakExtra),
    NEWPROC(STROBJ_bGetAdvanceWidths),
    NEWPROC(STROBJ_bEnumPositionsOnly),
    NEWPROC(EngGetPrinterDriver),
    NEWPROC(EngMapFontFileFD),
    NEWPROC(EngUnmapFontFileFD),
    NEWPROC(EngQuerySystemAttribute),
    NEWPROC(HT_Get8BPPMaskPalette),
#if !defined(_GDIPLUS_)
    NEWPROC(EngGetTickCount),
    NEWPROC(EngFileWrite),
    NEWPROC(EngFileIoControl),
#endif
    NEWPROC(EngDitherColor),
    NEWPROC(EngModifySurface),
    NEWPROC(EngQueryDeviceAttribute),
    NEWPROC(EngHangNotification),
    NEWPROC(EngNineGrid),
};

PVOID
APIENTRY
EngFindImageProcAddress(
    HANDLE hModule,
    LPSTR lpProcName
    )
{
    PSYSTEM_GDI_DRIVER_INFORMATION pGdiDriverInfo;

    PULONG NameTableBase;
    USHORT  OrdinalNumber;
    PUSHORT NameOrdinalTableBase;
    ULONG NumberOfNames;
    PULONG AddressTableBase;
    ULONG i;

    if (!hModule)
    {
        // An 'hModule' of zero means that the driver wants to find
        // the address of a GDI 'Eng' function.  Note that this didn't
        // work in the final release of NT 4.0 (this routine would
        // access violate if passed an 'hModule' of zero), so drivers
        // must check GDI's engine version to make sure it's not 4.0,
        // before calling this function.
        //
        // Unfortunately, the Base can't handle loading of 'win32k.sys'
        // at the time of this writing, so we'll just special-case here
        // all the Eng functions that are new since 4.0.  This allows
        // drivers to take advantage of NT 4.0 SP3 call-backs when
        // running on SP3, but to still load and run NT 4.0 SP2.

        for (i=0; i < sizeof(gaNewProcAddresses)/sizeof(NEWPROCADDRESS); i++)
        {
            if (!strcmp(lpProcName, gaNewProcAddresses[i].lpstrName))
            {
                return gaNewProcAddresses[i].pvAddress;
            }
        }

        return NULL;

    } else {

        pGdiDriverInfo = ((PLDEV)hModule)->pGdiDriverInfo;
    }

    if (!strncmp(lpProcName,
                 "DrvEnableDriver",
                 strlen(lpProcName)))
    {
        return (pGdiDriverInfo->EntryPoint);
    }

    if (pGdiDriverInfo->ExportSectionPointer)
    {
        NameTableBase = (PULONG)((ULONG_PTR)pGdiDriverInfo->ImageAddress +
                        (ULONG)pGdiDriverInfo->ExportSectionPointer->AddressOfNames);
        NameOrdinalTableBase = (PUSHORT)((ULONG_PTR)pGdiDriverInfo->ImageAddress +
                        (ULONG)pGdiDriverInfo->ExportSectionPointer->AddressOfNameOrdinals);

        NumberOfNames = pGdiDriverInfo->ExportSectionPointer->NumberOfNames;

        AddressTableBase = (PULONG)((ULONG_PTR)pGdiDriverInfo->ImageAddress +
                           (ULONG_PTR)pGdiDriverInfo->ExportSectionPointer->AddressOfFunctions);

        for (i=0; i < NumberOfNames; i++)
        {
            if (!strncmp(lpProcName,
                          (PCHAR) (NameTableBase[i] + (ULONG_PTR)pGdiDriverInfo->ImageAddress),
                          strlen(lpProcName)))
            {
                OrdinalNumber = NameOrdinalTableBase[i];

                return ((PVOID) ((ULONG_PTR)pGdiDriverInfo->ImageAddress +
                                  AddressTableBase[OrdinalNumber]));
            }
        }
    }

    return NULL;
}

/******************************Public*Routine******************************\
* EngUnloadImage
*
* Unloads an image loaded using EngLoadImage.
*
\**************************************************************************/

VOID
APIENTRY
EngUnloadImage(
    HANDLE hModule
    )
{
    ldevUnloadImage((PLDEV)hModule);
}


/******************************Public*Routine******************************\
* EngHangNotification
*
* This is the engine entry point to notify system that the given device
* is no longer operable or responsive.
*
* hDev must always be a valid device.
*
* This call will return EHN_RESTORED if the device has been restored to
* working order or EHN_ERROR otherwise.
*
*
* History:
*  12-Sep-2000 -by- Jason Hartman jasonha
*   Wrote it.
\**************************************************************************/

ULONG
APIENTRY
EngHangNotification(
    HDEV hdev,
    PVOID Reserved
    )
{
    GDIFunctionID(EngHangNotification);

    ULONG   Result = EHN_ERROR;
    PDEVOBJ pdo(hdev);

    if (pdo.bValid())
    {
        PGRAPHICS_DEVICE        PhysDisp = pdo.ppdev->pGraphicsDevice;
        PIO_ERROR_LOG_PACKET    perrLogEntry;
        PCWSTR                  pwszDevice, pwszDesc;
        ULONG                   cbDevice, cbDesc;

        if (PhysDisp == (PGRAPHICS_DEVICE) DDML_DRIVER ||
            PhysDisp == NULL)
        {
            RIP("Invalid HDEV.\n");
            return Result;
        }

        DbgPrint("GDI: EngHangNotification: %ls is not responding.\n", PhysDisp->szWinDeviceName);

        pwszDevice = PhysDisp->szNtDeviceName;
        cbDevice = (wcslen(pwszDevice)+1)*sizeof(WCHAR);
        pwszDesc = PhysDisp->DeviceDescription;
        cbDesc = (wcslen(pwszDesc)+1)*sizeof(WCHAR);

        /*
         * Allocate an error packet, fill it out, and write it to the log.
         */
        perrLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(gpWin32kDriverObject,
                                    (UCHAR)(cbDevice + cbDesc + FIELD_OFFSET(IO_ERROR_LOG_PACKET, DumpData)));
        if (perrLogEntry)
        {
            perrLogEntry->ErrorCode = STATUS_INVALID_DEVICE_STATE;

            perrLogEntry->NumberOfStrings = 2;
            perrLogEntry->StringOffset = FIELD_OFFSET(IO_ERROR_LOG_PACKET, DumpData);
            RtlCopyMemory(perrLogEntry->DumpData, pwszDevice, cbDevice);
            RtlCopyMemory((PBYTE)perrLogEntry->DumpData + cbDevice, pwszDesc, cbDesc);

            IoWriteErrorLogEntry(perrLogEntry);
        }
        else
        {
            WARNING("Failed to create error log entry.\n");
        }

        if (PPFNVALID(pdo,ResetDevice) &&
            (*PPFNDRV(pdo,ResetDevice))(pdo.dhpdev(), NULL) == DRD_SUCCESS)
        {
            Result = EHN_RESTORED;
        }
        else
        {
            RIP("Unable to recover device.\n");
        }
    }

    return Result;
}


/******************************Public*Routine******************************\
* ldevGetDriverModes
*
* Loads the device driver long enough to pass the DrvGetModes call to it.
*
\**************************************************************************/

ULONG
ldevGetDriverModes(
    LPWSTR    pwszDriver,
    HANDLE    hDriver,
    PDEVMODEW *pdm
)
{
    PLDEV pldev;
    ULONG ulRet = 0;

    TRACE_INIT(("ldevGetDriverModes: Entering\n"));

    *pdm = NULL;

    //
    // Temporarily locate and load the driver.
    //

    pldev = ldevLoadDriver(pwszDriver, LDEV_DEVICE_DISPLAY);

    if (pldev)
    {
        //
        // Locate the function and call it.
        //

        PFN_DrvGetModes pfn = (PFN_DrvGetModes) pldev->apfn[INDEX_DrvGetModes];

        if (pfn != NULL)
        {
            ULONG cjSize;

            if (cjSize = (*pfn)(hDriver, 0, NULL)) { // get modelist size

                //
                // In NT4 we passed in a buffer of 64K.  In NT5 we try to
                // pass in a buffer size based on the number of modes the
                // driver will actually use.  However, some drivers are
                // buggy and don't properly return the amount of buffer
                // space they need.  So we'll always pass in a buffer
                // at least 64K in length.
                //

                if (pldev->ulDriverVersion < DDI_DRIVER_VERSION_NT5) {
                    cjSize = max(cjSize, 0x10000);
                }

                if (*pdm = (PDEVMODEW) PALLOCNOZ(cjSize, GDITAG_DRVSUP)) {
                    ulRet = (*pfn)(hDriver,cjSize,*pdm);
                } else {
                    WARNING("ldevGetDriverModes failed to alloc mem for mode list\n");
                }
            }
        }

        ldevUnloadImage(pldev);
    }

#define MAPDEVMODE_FLAGS    (DM_BITSPERPEL | DM_PELSWIDTH | \
    DM_PELSHEIGHT | DM_DISPLAYFREQUENCY | DM_DISPLAYFLAGS)

    if (ulRet)
    {
        if (((*pdm)->dmFields & MAPDEVMODE_FLAGS) != MAPDEVMODE_FLAGS)
        {
            ASSERTGDI(FALSE,"DrvGetModes did not set the dmFields value!\n");
            ulRet = 0;
        }
    }

    TRACE_INIT(("ldevGetDriverModes: Leaving\n"));

    //
    // Return the driver's result.
    //

    return(ulRet);
}

#define REGSTR_CCS      L"\\Registry\\Machine\\System\\CurrentControlSet"
#define REGSTR_HP_CCS   L"\\Hardware Profiles\\Current\\System\\CurrentControlSet"

/**************************************************************************\
* DrvGetRegistryHandleFromDeviceMap
*
* Gets the handle to the registry node for that driver.
*
* returns a HANDLE
*
*
* lpMatchString is passed in when the caller wants to make sure the device
* name (\Device\video0) matches a certain physical device in the registry
* (\Services\Weitekp9\Device0).  We call this routine in a loop with a
* specific lpMatchString to find that device in the list in DeviceMap.
*
* 30-Nov-1992 andreva created
\**************************************************************************/

HANDLE
DrvGetRegistryHandleFromDeviceMap(
    PGRAPHICS_DEVICE PhysDisp,
    DISP_DRIVER_REGISTRY_TYPE ParamType,
    PULONG pSubId,
    LPWSTR pDriverName,
    PNTSTATUS pStatus,
    USHORT ProtocolType)
{
    HANDLE hkRegistry = NULL;

    UNICODE_STRING    UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS          Status;
    HANDLE            handle;
    ULONG             cbStringSize;
    WCHAR *pdriverRegistryPath = NULL;
    WCHAR *pfullRegistryPath = NULL;
#ifdef _HYDRA_
    WCHAR *pTerminalServerVideoRegistryPath;
#endif


    TRACE_INIT(("Drv_Trace: GetHandleFromMap: Enter\n"));

    //
    // Initialize the handle
    //

    //
    // Start by opening the registry devicemap for video.
    //
#ifdef _HYDRA_
    if ((pTerminalServerVideoRegistryPath = (WCHAR*)PALLOCMEM(256*sizeof(WCHAR), 'pmtG')) == NULL)
    {
        if (pStatus)
            *pStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    /*
     * Look in TerminalServer VIDEO section for the video driver type as given by client.
     *
     */
    if (ProtocolType != PROTOCOL_CONSOLE &&
        ProtocolType != PROTOCOL_DISCONNECT) {

        UnicodeString.Buffer = pTerminalServerVideoRegistryPath;
        UnicodeString.Length = 0;
        UnicodeString.MaximumLength = 255;

        RtlAppendUnicodeToString(&UnicodeString,
                                 NTAPI_VIDEO_REG_NAME L"\\" );
        RtlAppendUnicodeToString(&UnicodeString,
                                 G_DisplayDriverNames);
    }
    else
#endif
    RtlInitUnicodeString(&UnicodeString,
                         L"\\Registry\\Machine\\Hardware\\DeviceMap\\Video");

    TRACE_INIT(("Video Registry path is %ws\n", UnicodeString.Buffer));

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                               NULL,
                               NULL);

    Status = ZwOpenKey(&handle, KEY_READ, &ObjectAttributes);

    if (NT_SUCCESS(Status))
    {
        pdriverRegistryPath = (WCHAR*)PALLOCMEM(2*256*sizeof(WCHAR), 'pmtG');
        
        if (pdriverRegistryPath == NULL)
        {
            if (pStatus)
                *pStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Exit;
        }
        
        pfullRegistryPath = pdriverRegistryPath + 256;

        RtlInitUnicodeString(&UnicodeString,
                             PhysDisp->szNtDeviceName);

        //
        // Get the name of the driver based on the device name.
        //

        Status = ZwQueryValueKey(handle,
                                 &UnicodeString,
                                 KeyValueFullInformation,
                                 pdriverRegistryPath,
                                 512,
                                 &cbStringSize);

        if (NT_SUCCESS(Status))
        {
            //
            // Look up in the registry for the kernel driver node (it
            // is a full path to the driver node) so we can get the
            // display driver info.
            //

            LPWSTR lpstrStart;
            LPWSTR lpstrDriverRegistryPath;
            LPWSTR lpstrEndPath;
            UNICODE_STRING FullRegistryPath;


            //
            // We can use wcsstr since we are guaranteed to find "Control" or 
            // "Services" in the string, and we won't run off the end of the 
            // string. Capitalize it so we don't have problems with different 
            // types of paths.
            //

            lpstrStart = (LPWSTR)((PUCHAR)pdriverRegistryPath +
                                 ((PKEY_VALUE_FULL_INFORMATION)pdriverRegistryPath)->DataOffset);

            // We only want RegKey here
            if (ParamType == DispDriverRegKey)
            {
                wcsncpy(pDriverName, lpstrStart, 127);
                ZwCloseKey(handle);
                if (pStatus)
                    *pStatus = Status;
                goto Exit;
            }

            while (*lpstrStart)
            {
                *lpstrStart = (USHORT)(toupper(*lpstrStart));
                lpstrStart++;
            }

            lpstrDriverRegistryPath = wcsstr((LPWSTR)((PUCHAR)pdriverRegistryPath +
                                                     ((PKEY_VALUE_FULL_INFORMATION)pdriverRegistryPath)->DataOffset),
                                             L"\\CONTROL\\");

            if (lpstrDriverRegistryPath == NULL) {

                lpstrDriverRegistryPath = wcsstr((LPWSTR)((PUCHAR)pdriverRegistryPath +
                                                         ((PKEY_VALUE_FULL_INFORMATION)pdriverRegistryPath)->DataOffset),
                                                 L"\\SERVICES");
            }

            //
            // Save the service name as the description in case it's needed
            // later
            //

            if (pDriverName)
            {
                LPWSTR pName = pDriverName;
                ULONG i = 31;
                HANDLE CommonSubkeyHandle;
                LPWSTR CommonSubkeyBuffer = NULL;
                LPWSTR pSubkeyBuffer = NULL;
                LONG BufferLen = 0, RegistryPathLen = 0;

                //
                // Get the registry path and find the last '\'
                //

                RegistryPathLen = wcslen((LPWSTR)((PUCHAR)pdriverRegistryPath +
                    ((PKEY_VALUE_FULL_INFORMATION)pdriverRegistryPath)->DataOffset));
                BufferLen = (max(RegistryPathLen + 6, 32) * sizeof(WCHAR));

                CommonSubkeyBuffer = (LPWSTR) PALLOCMEM(BufferLen, GDITAG_DRVSUP);

                if (CommonSubkeyBuffer) 
                {
                    RtlZeroMemory(CommonSubkeyBuffer, BufferLen);
                
                    wcscpy(CommonSubkeyBuffer, (LPWSTR)((PUCHAR)pdriverRegistryPath +
                        ((PKEY_VALUE_FULL_INFORMATION)pdriverRegistryPath)->DataOffset));

                    pSubkeyBuffer = CommonSubkeyBuffer + RegistryPathLen - 1;
    
                    while ((pSubkeyBuffer > CommonSubkeyBuffer) && 
                           (*pSubkeyBuffer != L'\\')) 
                    {
                        pSubkeyBuffer--;
                    }
    
                    if (*pSubkeyBuffer == L'\\')
                    {
                        pSubkeyBuffer++;
    
                        //
                        // Open the Video subkey
                        //
    
                        wcscpy(pSubkeyBuffer, L"Video");
    
                        RtlInitUnicodeString(&UnicodeString, CommonSubkeyBuffer);
    
                        InitializeObjectAttributes(&ObjectAttributes,
                                                   &UnicodeString,
                                                   OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                                   NULL,
                                                   NULL);
    
                        Status = ZwOpenKey(&CommonSubkeyHandle, 
                                           KEY_READ, 
                                           &ObjectAttributes);
    
                        if (NT_SUCCESS(Status))
                        {
                            ULONG cbLegacyRegistryPathSize;
    
                            //
                            // Get the service name
                            //
                            
                            RtlInitUnicodeString(&UnicodeString, L"Service");
                            
                            RtlZeroMemory(CommonSubkeyBuffer, BufferLen);
    
                            Status = ZwQueryValueKey(CommonSubkeyHandle,
                                                     &UnicodeString,
                                                     KeyValueFullInformation,
                                                     CommonSubkeyBuffer,
                                                     BufferLen,
                                                     &cbLegacyRegistryPathSize);
    
                            if (NT_SUCCESS(Status))
                            {
                                //
                                // Convert to upper chars ...
                                //
    
                                pSubkeyBuffer = CommonSubkeyBuffer;
    
                                while (*pSubkeyBuffer)
                                {
                                    *pSubkeyBuffer = (USHORT)(toupper(*pSubkeyBuffer));
                                    pSubkeyBuffer++;
                                }
    
                                //
                                // Copy the service name
                                //
    
                                pSubkeyBuffer = CommonSubkeyBuffer;
    
                                while ((i--) && (*pSubkeyBuffer != NULL))
                                {
                                    *pName++ = *pSubkeyBuffer++;
    
                                    if ((i == 28) && (_wcsnicmp(pDriverName, L"VGA", 3) == 0))
                                    {
                                        break;
                                    }
                                }
                            }
    
                            ZwCloseKey(CommonSubkeyHandle);
                        }
                    }
                    else
                    {
                        //
                        // This should not happen ...
                        //
    
                        ASSERTGDI(FALSE, "invalid registry key\n");
                    }

                    VFREEMEM(CommonSubkeyBuffer);
                }
                
                *pName = UNICODE_NULL;

                //
                // Make sure we do not set a remote device or the disconnect device as the VGA device.
                //

                if (!(PhysDisp->stateFlags &(DISPLAY_DEVICE_REMOTE | DISPLAY_DEVICE_DISCONNECT) ) ) {
                    gPhysDispVGA = PhysDisp;
                }
            }

            //
            // This sectione is for per Monitor settings.  Each monitor has UID.
            // So we save under Servive\XXXX\DeviceX\UID
            //

            if (pSubId)
            {
                swprintf(lpstrDriverRegistryPath+wcslen(lpstrDriverRegistryPath),
                         L"\\Mon%08X",
                         *pSubId);
            }

            //
            // Start composing the fully qualified path name.
            //

            FullRegistryPath.Buffer = pfullRegistryPath;
            FullRegistryPath.Length = 0;
            FullRegistryPath.MaximumLength = 255*sizeof(WCHAR);

            RtlAppendUnicodeToString(&FullRegistryPath, REGSTR_CCS);

            //
            // If we want the hardware profile, insert the hardware profile
            // in there
            //

            if ((ParamType == DispDriverRegHardwareProfile) ||
                (ParamType == DispDriverRegHardwareProfileCreate))
            {
                TRACE_INIT(("Drv_Trace: GetHandleFromMap: using a hardware profile\n"));
                RtlAppendUnicodeToString(&FullRegistryPath, REGSTR_HP_CCS);
            }

            //
            // If we have the create Options, we have to create the subkeys
            // otherwise, just open the key
            //

            InitializeObjectAttributes(&ObjectAttributes,
                                       &FullRegistryPath,
                                       OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                                       NULL,
                                       NULL);

            //
            // Check if the subkeys need to be created.
            //

            if (ParamType == DispDriverRegHardwareProfileCreate)
            {
                TRACE_INIT(("Drv_Trace: GetHandleFromMap: creating a hardware profile\n"));

                //
                // We are guaranteed to go through the loop at least once,
                // which will ensure the status is set properly.
                //
                // Basically, find the '\' replace it by NULL and add that
                // partial string to the full path (so we can create that
                // subkey), put back the '\' and keep on going for the next
                // string.  We must also add the end of the string.
                //

                do
                {
                    lpstrEndPath = wcschr(lpstrDriverRegistryPath + 1, L'\\');

                    if (lpstrEndPath != NULL)
                    {
                        *lpstrEndPath = UNICODE_NULL;
                    }

                    RtlAppendUnicodeToString(&FullRegistryPath,
                                             lpstrDriverRegistryPath);

                    //
                    // Close the previous key if necessary.
                    //

                    if (hkRegistry)
                    {
                        ZwCloseKey(hkRegistry);
                    }

                    //
                    // Create the Key.
                    //

                    Status = ZwCreateKey(&hkRegistry,
                                         (ACCESS_MASK) NULL,
                                         &ObjectAttributes,
                                         0,
                                         NULL,
                                         0,
                                         NULL);

                    if (!NT_SUCCESS(Status))
                    {
                        hkRegistry = NULL;
                        break;
                    }

                    //
                    // Check to see if we need to loop again.
                    //

                    if (lpstrEndPath == NULL)
                    {
                        break;
                    }
                    else
                    {
                        *lpstrEndPath = L'\\';
                        lpstrDriverRegistryPath = lpstrEndPath;
                    }


                } while(1);

                if (!NT_SUCCESS(Status))
                {
                    TRACE_INIT(("Drv_Trace: GetHandleFromMap: failed to create key\n"));
                }
            }
            else
            {
                RtlAppendUnicodeToString(&FullRegistryPath,
                                         lpstrDriverRegistryPath);

                Status = ZwOpenKey(&hkRegistry, KEY_READ, &ObjectAttributes);

                if (!NT_SUCCESS(Status))
                {
                    TRACE_INIT(("Drv_Trace: GetHandleFromMap: failed to open key\n"));

                    //
                    // We set this special status so the looping code in the
                    // video port can handle unconfigured devices properly
                    // (in the case where the second video card entry may not
                    // be present).
                    //

                    Status = STATUS_DEVICE_CONFIGURATION_ERROR;
                }
            }

            TRACE_INIT(("Drv_Trace: GetHandleFromMap: reg-key path =\n\t%ws\n",
                        pfullRegistryPath));
        }


        ZwCloseKey(handle);
    }

    if (!NT_SUCCESS(Status))
    {
        TRACE_INIT(("Drv_Trace: GetHandleFromMap: Error opening registry - status = %08lx\n",
                    Status));
    }

    if (pStatus)
    {
        *pStatus = Status;
    }

    TRACE_INIT(("Drv_Trace: GetHandleFromMap: Exit\n\n"));

Exit:

#ifdef _HYDRA_
    if (pTerminalServerVideoRegistryPath)
        VFREEMEM(pTerminalServerVideoRegistryPath);
#endif

    if (pdriverRegistryPath)
        VFREEMEM(pdriverRegistryPath);
    
    return hkRegistry;
}

/**************************************************************************\
* DrvPrepareForEARecovery
*
* Remove all devices other than the VGA device from the graphics
* device list.
*
* In multi-mon we could just disable the now "dead" display.  In single
* mon we need to disable the "high-res" display and switch to VGA.
*
* 27-Mar-2002 ericks created
\**************************************************************************/

VOID
DrvPrepareForEARecovery(
    VOID
    )

{
    ULONG ulBytes;

    if (gPhysDispVGA) {

        GreDeviceIoControl(gPhysDispVGA->pDeviceHandle,
                           IOCTL_VIDEO_PREPARE_FOR_EARECOVERY,
                           NULL,
                           0,
                           NULL,
                           0,
                           &ulBytes);
    }

    return;
}

/**************************************************************************\
* DrvGetDisplayDriverNames
*
* Get the display driver name out of the registry.
*
* 12-Jan-1994 andreva created
\**************************************************************************/

typedef struct _DRV_NAMES {
    ULONG            cNames;
    struct {
        HANDLE           hDriver;
        LPWSTR           lpDisplayName;
    } D[1];
} DRV_NAMES, *PDRV_NAMES;

PDRV_NAMES
DrvGetDisplayDriverNames(
    PGRAPHICS_DEVICE PhysDisp
    )
{
    DWORD      status;
    LPWSTR     lptmpdisplay;
    DWORD      cCountNames;
    DWORD      cCountNamesDevice;
    PDRV_NAMES lpNames = NULL;
    ULONG      cb = 0;
    ULONG      cbVga = 0;

    //
    // At this point, create the array, and put in the VGA driver
    // if necessary.  (We morphed this from the ModeX hack.)
    //

    if (PhysDisp->DisplayDriverNames)
    {
        //
        // Count the names in the list (first for PhysDisp)
        //

        cCountNames = 0;
        lptmpdisplay = PhysDisp->DisplayDriverNames;

        while (*lptmpdisplay != UNICODE_NULL)
        {
            cCountNames++;

            while (*lptmpdisplay != UNICODE_NULL)
            {
                lptmpdisplay++;
                cb += 2;
            }

            lptmpdisplay++;
            cb += 2;
        }

        //
        // Track the number of display driver names for the root device
        //

        cCountNamesDevice = cCountNames;

        //
        // Now if this PhysDisp is associated with the VGA, then add
        // the VGA display drivers as well.
        //

        if (PhysDisp->pVgaDevice &&
            gFullscreenGraphicsDevice.pDeviceHandle &&
            PhysDisp->pVgaDevice->DisplayDriverNames) {

            lptmpdisplay = PhysDisp->pVgaDevice->DisplayDriverNames;

            while (*lptmpdisplay != UNICODE_NULL)
            {
                cCountNames++;

                while (*lptmpdisplay != UNICODE_NULL)
                {
                    lptmpdisplay++;
                    cbVga += 2;
                }

                lptmpdisplay++;
                cbVga += 2;
            }
        }

        //
        // Alocate the names structure.
        //

	if (lpNames = (PDRV_NAMES) PALLOCNOZ(cb + cbVga + 2 + sizeof(DRV_NAMES) *
                                                      (cCountNames + 1),
                                             GDITAG_DRVSUP))
        {
            lptmpdisplay = (LPWSTR) (((PUCHAR)lpNames) +
                                     sizeof(DRV_NAMES) * (cCountNames + 1));

            RtlCopyMemory(lptmpdisplay,
                          PhysDisp->DisplayDriverNames,
                          cb + 2);

            if (cbVga) {

                RtlCopyMemory((LPWSTR)((ULONG_PTR)lptmpdisplay + cb),
                              PhysDisp->pVgaDevice->DisplayDriverNames,
			      cbVga + 2);
            }

            //
            // Set all the names pointers in the names structure
            //

            lpNames->cNames = 0;

            while (*lptmpdisplay != UNICODE_NULL)
            {
                lpNames->D[lpNames->cNames].lpDisplayName = lptmpdisplay;

                if (lpNames->cNames < cCountNamesDevice) {
                    lpNames->D[lpNames->cNames].hDriver = PhysDisp->pDeviceHandle;
                } else {
		    lpNames->D[lpNames->cNames].hDriver = PhysDisp->pVgaDevice->pDeviceHandle;

		    //
                    // For now, only return the first in the list of vga
                    // display driver names (vga.dll)
                    //

		    lpNames->cNames++;
                    break;
		}
                lpNames->cNames++;

                while (*lptmpdisplay != UNICODE_NULL)
                {
                    lptmpdisplay++;
                }
                lptmpdisplay++;
            }
	}
    }

    return lpNames;
}

//
// We need to update monitor PDOs whenever reenumaration of devices has been occured
// This function has to be called every time before PhysDisp->MonitorDevices is to be used
//
VOID UpdateMonitorDevices(VOID)
{
    PGRAPHICS_DEVICE   PhysDisp;
    ULONG numMonitorDevice, i;

    for (PhysDisp = gpGraphicsDeviceList;
         PhysDisp != NULL;
         PhysDisp = PhysDisp->pNextGraphicsDevice)
    {
        PVIDEO_MONITOR_DEVICE  pMonitorDevices = NULL;
        BOOL             bNoMonitor = TRUE;

        if ((PhysDisp->pDeviceHandle != NULL ) &&
            NT_SUCCESS(GreDeviceIoControl(PhysDisp->pDeviceHandle,
                                          IOCTL_VIDEO_ENUM_MONITOR_PDO,
                                          NULL,
                                          0,
                                          &pMonitorDevices,
                                          sizeof(PVOID),
                                          &numMonitorDevice))
           )
        {
            if (pMonitorDevices != NULL)
            {
                numMonitorDevice = 0;
                while (pMonitorDevices[numMonitorDevice].pdo != NULL)
                {
                    ObDereferenceObject(pMonitorDevices[numMonitorDevice].pdo);
                    numMonitorDevice++;
                }

                //
                // The buffer always grows
                //
                if (PhysDisp->numMonitorDevice < numMonitorDevice)
                {
                    if (PhysDisp->MonitorDevices)
                    {
                        VFREEMEM(PhysDisp->MonitorDevices);
                    }
                    PhysDisp->MonitorDevices = (PVIDEO_MONITOR_DEVICE)PALLOCMEM(sizeof(VIDEO_MONITOR_DEVICE) * numMonitorDevice,
                                                                          GDITAG_GDEVICE);
                    //
                    // If fail, do cleanup here
                    //
                    if (PhysDisp->MonitorDevices == NULL)
                    {
                        PhysDisp->numMonitorDevice = 0;

                        ExFreePool(pMonitorDevices);
                        return;
                    }
                }

                PhysDisp->numMonitorDevice = numMonitorDevice;

                for (i = 0; i < numMonitorDevice; i++)
                {
                    PhysDisp->MonitorDevices[i].flag   = 0;
                    if (pMonitorDevices[i].flag & VIDEO_CHILD_ACTIVE) {
                        PhysDisp->MonitorDevices[i].flag |= DISPLAY_DEVICE_ACTIVE;
                    }
                    if ((pMonitorDevices[i].flag & VIDEO_CHILD_DETACHED) == 0) {
                        PhysDisp->MonitorDevices[i].flag |= DISPLAY_DEVICE_ATTACHED;
                    }
                    if ((pMonitorDevices[i].flag & VIDEO_CHILD_NOPRUNE_FREQ) == 0) {
                        PhysDisp->MonitorDevices[i].flag |= DISPLAY_DEVICE_PRUNE_FREQ;
                    }
                    if ((pMonitorDevices[i].flag & VIDEO_CHILD_NOPRUNE_RESOLUTION) == 0) {
                        PhysDisp->MonitorDevices[i].flag |= DISPLAY_DEVICE_PRUNE_RESOLUTION;
                    }
                    PhysDisp->MonitorDevices[i].pdo    = pMonitorDevices[i].pdo;
                    PhysDisp->MonitorDevices[i].HwID   = pMonitorDevices[i].HwID;

                    bNoMonitor = FALSE;
                }

                ExFreePool(pMonitorDevices);
            }
        }

        if (bNoMonitor)
        {
            if (PhysDisp->MonitorDevices)
            {
                VFREEMEM(PhysDisp->MonitorDevices);
            }
            PhysDisp->numMonitorDevice = 0;
            PhysDisp->MonitorDevices = NULL;
        }
    }
}

VOID
dbgDumpDevmode(
    PDEVMODEW pdm
    )
{
    TRACE_INIT(("      Size        = %d\n",    pdm->dmSize));
    TRACE_INIT(("      Fields      = %08lx\n", pdm->dmFields));
    TRACE_INIT(("      XPosition   = %d\n",    pdm->dmPosition.x));
    TRACE_INIT(("      YPosition   = %d\n",    pdm->dmPosition.y));
    TRACE_INIT(("      Orientation = %d\n",    pdm->dmDisplayOrientation));
    TRACE_INIT(("      FixedOutput = %d\n",    pdm->dmDisplayFixedOutput));
    TRACE_INIT(("      XResolution = %d\n",    pdm->dmPelsWidth));
    TRACE_INIT(("      YResolution = %d\n",    pdm->dmPelsHeight));
    TRACE_INIT(("      Bpp         = %d\n",    pdm->dmBitsPerPel));
    TRACE_INIT(("      Frequency   = %d\n",    pdm->dmDisplayFrequency));
    TRACE_INIT(("      Flags       = %d\n",    pdm->dmDisplayFlags));
    TRACE_INIT(("      XPanning    = %d\n",    pdm->dmPanningWidth));
    TRACE_INIT(("      YPanning    = %d\n",    pdm->dmPanningHeight));
    TRACE_INIT(("      DPI         = %d\n",    pdm->dmLogPixels));
    TRACE_INIT(("      DriverExtra = %d",      pdm->dmDriverExtra));
    if (pdm->dmDriverExtra)
    {
        TRACE_INIT((" - %08lx %08lx\n",
                    *(PULONG)(((PUCHAR)pdm)+pdm->dmSize),
                    *(PULONG)(((PUCHAR)pdm)+pdm->dmSize + 4)));
    }
    else
    {
        TRACE_INIT(("\n"));
    }
}

#define NUM_DISPLAY_PARAMETERS   13
#define NUM_DISPLAY_DRIVER_EXTRA (NUM_DISPLAY_PARAMETERS - 1)

static
LPWSTR DefaultSettings[NUM_DISPLAY_PARAMETERS] = {
    L"DefaultSettings.BitsPerPel",
    L"DefaultSettings.XResolution",
    L"DefaultSettings.YResolution",
    L"DefaultSettings.VRefresh",
    L"DefaultSettings.Flags",
    L"DefaultSettings.XPanning",
    L"DefaultSettings.YPanning",
    L"DefaultSettings.Orientation",
    L"DefaultSettings.FixedOutput",
    L"Attach.RelativeX",
    L"Attach.RelativeY",
    L"Attach.ToDesktop",
    L"DefaultSettings.DriverExtra" // MUST be at the end
};

static
LPWSTR AttachedSettings[] = {
    L"Attach.PrimaryDevice",
    L"Attach.ToDesktop",
};

static
LPWSTR SoftwareSettings[] = {
    L"DriverDesc",
    L"InstalledDisplayDrivers",
    L"MultiDisplayDriver",
    L"MirrorDriver",
    L"VgaCompatible",
    L"Device Description",
    L"HardwareInformation.AdapterString",
    L"HardwareInformation.ChipType",
};

NTSTATUS
DrvDriverExtraCallback(
    PWSTR ValueName,
    ULONG ValueType,
    PVOID ValueData,
    ULONG ValueLength,
    PVOID Context,
    PVOID EntryContext)

{

    PDEVMODEW pdevmode = (PDEVMODEW) EntryContext;

    //
    // Put the driver extra data in the right place, if necessary.
    //

    pdevmode->dmDriverExtra = min(pdevmode->dmDriverExtra, (USHORT)ValueLength);

    RtlMoveMemory(pdevmode+1,
                  ValueData,
                  pdevmode->dmDriverExtra);

    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(ValueType);
    UNREFERENCED_PARAMETER(ValueName);
}

/**************************************************************************\
* DrvGetDisplayDriverParameters
*
* Reads the resolution parameters from the registry.
*
* NOTE:
* We assume the caller has initialized the DEVMODE to zero,
* and that the DEVMODE is the current size for the system.
* We only look at the dmDriverExtra field to determine any extra size.
* We do check the dmSize for debugging purposes.
*
* CRIT not needed
*
* 25-Jan-1995 andreva created
\**************************************************************************/

NTSTATUS
DrvGetDisplayDriverParameters(
    PGRAPHICS_DEVICE PhysDisp,
    PDEVMODEW        pdevmode,
    BOOL             bEmptyDevmode,
    BOOL             bFromMonitor
    )
{
    ULONG    i, k;
    NTSTATUS retStatus;
    HANDLE   hkRegistry;
    ULONG    attached = 0;

    DISP_DRIVER_REGISTRY_TYPE registryParam = DispDriverRegHardwareProfile;
    DWORD nullValue = 0;

    //
    // Our current algorithm is to save or get things from the hardware profile
    // first, and then try the global profile as a backup.
    //
    // NOTE ??? For saving, should we always back propagate the changes to the
    // global settings also ?  We do this at this point.
    //

    RTL_QUERY_REGISTRY_TABLE QueryTable[] = {

        {NULL, RTL_QUERY_REGISTRY_DIRECT, NULL, &pdevmode->dmBitsPerPel,
         REG_NONE, NULL, 0},

        {NULL, RTL_QUERY_REGISTRY_DIRECT, NULL, &pdevmode->dmPelsWidth,
         REG_NONE, NULL, 0},

        {NULL, RTL_QUERY_REGISTRY_DIRECT, NULL, &pdevmode->dmPelsHeight,
         REG_NONE, NULL, 0},

        {NULL, RTL_QUERY_REGISTRY_DIRECT, NULL, &pdevmode->dmDisplayFrequency,
         REG_NONE, NULL, 0},

        {NULL, RTL_QUERY_REGISTRY_DIRECT, NULL, &pdevmode->dmDisplayFlags,
         REG_NONE, NULL, 0},

        {NULL, RTL_QUERY_REGISTRY_DIRECT, NULL, &pdevmode->dmPanningWidth,
         REG_NONE, NULL, 0},

        {NULL, RTL_QUERY_REGISTRY_DIRECT, NULL, &pdevmode->dmPanningHeight,
         REG_NONE, NULL, 0},

        {NULL, RTL_QUERY_REGISTRY_DIRECT, NULL, &pdevmode->dmDisplayOrientation,
         REG_NONE, NULL, 0},

        {NULL, RTL_QUERY_REGISTRY_DIRECT, NULL, &pdevmode->dmDisplayFixedOutput,
         REG_NONE, NULL, 0},

        {NULL, RTL_QUERY_REGISTRY_DIRECT, NULL, &pdevmode->dmPosition.x,
         REG_NONE, NULL, 0},

        {NULL, RTL_QUERY_REGISTRY_DIRECT, NULL, &pdevmode->dmPosition.y,
         REG_NONE, NULL, 0},

        {NULL, RTL_QUERY_REGISTRY_DIRECT, NULL, &attached,
         REG_NONE, NULL, 0},

        // if the value is not there, we want the call to succeed anyway.
        // so specify a vlue that is NULL modulo 64K !

        {DrvDriverExtraCallback,      0, NULL, pdevmode,
         REG_DWORD, &nullValue, 0x10000},

        {NULL, 0, NULL}
    };

    TRACE_INIT(("Drv_Trace: GetDriverParams\n"));

    //
    // Special debug code to ensure that anyone who calls this API
    // knows what they are doing, and we don't end up in here with a
    // "random" devmode that does not ensure sizes.
    //

    ASSERTGDI(pdevmode->dmSize == 0xDDDD, "DEVMODE not set to DDDD\n");

    //
    // If there is no place for the Driver Extra data, don't ask for it.
    // This will just cause the code not to read that value
    //

    if (pdevmode->dmDriverExtra == 0)
    {
        QueryTable[NUM_DISPLAY_PARAMETERS - 1].Flags = 0;
        pdevmode->dmDriverExtra = 0;
    }

    //
    // We assume that the DEVMODE was previously zeroed out by the caller
    //

    retStatus = STATUS_SUCCESS;

    if (bEmptyDevmode)
    {
        //
        // We want an empty DEVMODE (except for the LogPixels).
        //

        TRACE_INIT(("Drv_Trace: GetDriverParams: Default (empty) DEVMODE\n"));

        RtlZeroMemory(pdevmode, sizeof(DEVMODEW));
    }
    else
    {

#if LATER
        //
        // Let's try to get the per-user settings first.
        //

        TRACE_INIT(("Drv_Trace: GetDriverParams: USER Settings\n"));

        for (i=0; i < NUM_DISPLAY_PARAMETERS; i++)
        {
            QueryTable[i].Name = DefaultSettings[i];
        }

        retStatus = RtlQueryRegistryValues(RTL_REGISTRY_USER,
                                           NULL,
                                           &QueryTable[0],
                                           NULL,
                                           NULL);
        if (!NT_SUCCESS(retStatus))

#endif

            TRACE_INIT(("Drv_Trace: GetDriverParams: Hardware Profile Settings\n"));

            for (i = 0; i < NUM_DISPLAY_PARAMETERS; i++)
                QueryTable[i].Name = (PWSTR)DefaultSettings[i];

            if (bFromMonitor)
            {
                //
                // We retrieve from per-monitor settings first, only if failed then we go to old registry
                // And if we have multiple active monitors, we pick the smaller mode
                //

                UpdateMonitorDevices();

                DEVMODEW tmpDevMode, pickedDevMode;

                // Save original pdevmode away.  We are using pdevmode to retrieve registry
                RtlCopyMemory(&tmpDevMode, pdevmode, sizeof(DEVMODEW));
                pdevmode->dmBitsPerPel = 0;
                pdevmode->dmPelsWidth  = 0;
                pdevmode->dmPelsHeight = 0;
                pdevmode->dmDisplayFrequency = 0;
                pdevmode->dmDisplayFlags = 0;
                pdevmode->dmPanningWidth = 0;
                pdevmode->dmPanningHeight = 0;
                pdevmode->dmPosition.x = 0;
                pdevmode->dmPosition.y = 0;
                pdevmode->dmDisplayOrientation = 0;
                pdevmode->dmDisplayFixedOutput = 0;
                RtlZeroMemory(&pickedDevMode, sizeof(DEVMODEW));

                k = PhysDisp->numMonitorDevice;
                for (i = 0; i < PhysDisp->numMonitorDevice; i++)
                {
                    if (IS_ATTACHED_ACTIVE(PhysDisp->MonitorDevices[i].flag))
                    {
                        hkRegistry = DrvGetRegistryHandleFromDeviceMap(PhysDisp,
                                                                       registryParam,
                                                                       &PhysDisp->MonitorDevices[i].HwID,
                                                                       NULL,
                                                                       NULL,
                                                                       gProtocolType);
                        if (hkRegistry)
                        {
                            retStatus = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                                               (PWSTR)hkRegistry,
                                                               &QueryTable[0],
                                                               NULL,
                                                               NULL);
                            ZwCloseKey(hkRegistry);
                        }
                        else
                            continue;

                        if (!NT_SUCCESS(retStatus))
                            continue;

                        if ((pdevmode->dmBitsPerPel == 0) ||
                            (pdevmode->dmPelsWidth  == 0) ||
                            (pdevmode->dmPelsHeight == 0)
                           )
                            continue;

                        //
                        // Pick the smallest mode
                        //
                        if (pickedDevMode.dmPelsWidth == 0 ||
                            pdevmode->dmPelsWidth < pickedDevMode.dmPelsWidth ||
                            (pdevmode->dmPelsWidth == pickedDevMode.dmPelsWidth &&
                             pdevmode->dmPelsHeight < pickedDevMode.dmPelsHeight)
                           )
                        {
                            k = i;
                            pickedDevMode.dmPelsWidth  = pdevmode->dmPelsWidth;
                            pickedDevMode.dmPelsHeight = pdevmode->dmPelsHeight;
                        }
                    }
                }

                // Restore original pdevmode
                pdevmode->dmDriverExtra = tmpDevMode.dmDriverExtra;
                pdevmode->dmBitsPerPel = tmpDevMode.dmBitsPerPel;
                pdevmode->dmPelsWidth  = tmpDevMode.dmPelsWidth;
                pdevmode->dmPelsHeight = tmpDevMode.dmPelsHeight;
                pdevmode->dmDisplayFrequency = tmpDevMode.dmDisplayFrequency;
                pdevmode->dmDisplayFlags = tmpDevMode.dmDisplayFlags;
                pdevmode->dmPanningWidth = tmpDevMode.dmPanningWidth;
                pdevmode->dmPanningHeight = tmpDevMode.dmPanningHeight;
                pdevmode->dmPosition.x = tmpDevMode.dmPosition.x;
                pdevmode->dmPosition.y = tmpDevMode.dmPosition.y;
                pdevmode->dmDisplayOrientation = tmpDevMode.dmDisplayOrientation;
                pdevmode->dmDisplayFixedOutput = tmpDevMode.dmDisplayFixedOutput;
            }

            if (k < PhysDisp->numMonitorDevice && bFromMonitor)
            {
                //
                // Come here if we succeed to get per monitor settings
                //
                retStatus = STATUS_UNSUCCESSFUL;

                hkRegistry = DrvGetRegistryHandleFromDeviceMap(PhysDisp,
                                                               registryParam,
                                                               &PhysDisp->MonitorDevices[k].HwID,
                                                               NULL,
                                                               NULL,
                                                               gProtocolType );
                if (hkRegistry)
                {
                    retStatus = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                                       (PWSTR)hkRegistry,
                                                       &QueryTable[0],
                                                       NULL,
                                                       NULL);
                    ZwCloseKey(hkRegistry);
                }
                if (!NT_SUCCESS(retStatus))
                {
                    ASSERTGDI(FALSE, "Failed to get Monitor Settings\n");
                    return retStatus;
                }
            }
            else
            {
                //
                // If we failed to get per monitor settings,
                // try the hardware profile first and see if we can get parameters
                // from that.  If that fails, fall back to getting the system
                // parameters.
                //

                for (k=1; k<=2; k++)
                {
                    hkRegistry = DrvGetRegistryHandleFromDeviceMap(PhysDisp,
                                                                   registryParam,
                                                                   NULL,
                                                                   NULL,
                                                                   NULL,
                                                                   gProtocolType);

                    if (hkRegistry == NULL)
                    {
                        TRACE_INIT(("Drv_Trace: GetDriverParams: failed - registry could not be opened\n"));
                        retStatus = STATUS_UNSUCCESSFUL;
                    }
                    else
                    {
                        retStatus = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                                           (PWSTR)hkRegistry,
                                                           &QueryTable[0],
                                                           NULL,
                                                           NULL);

                        ZwCloseKey(hkRegistry);
                    }

                    //
                    // If something failed for the hardware profile, try
                    // to get the global settings
                    // If everything is OK, just exit the loop
                    //

                    if (NT_SUCCESS(retStatus))
                    {
                        break;
                    }
                    else
                    {
                        TRACE_INIT(("Drv_Trace: GetDriverParams: get hardware profile failed - try global settings\n"));
                        registryParam = DispDriverRegGlobal;
                    }
                }
            }

        //
        // AndreVa - do we still need this information passed back to the
        // applet ?
        //

        //
        // Other common fields to the DEVMODEs
        //

        if (NT_SUCCESS(retStatus))
        {
            //
            // Lets check if the DEVMODE we got is all NULLs (like when
            // the driver just got installed).
            // If it is, the driver should be reconfigured
            //
            // We will only do this if we are NOT in BaseVideo, since the VGA
            // BaseVideo driver need not be configured.
            //

            if ((attached)                           &&
                (pdevmode->dmBitsPerPel        == 0) &&
                (pdevmode->dmPelsWidth         == 0) &&
                (pdevmode->dmPelsHeight        == 0) &&
                (pdevmode->dmDisplayFrequency  == 0) &&
                (pdevmode->dmDisplayFlags      == 0) &&
                (gbBaseVideo                   == FALSE))
            {
                DrvLogDisplayDriverEvent(MsgInvalidUsingDefaultMode);
            }
        }

    }

    //
    // Let's fill out all the other fields of the DEVMODE that ALWAYS
    // need to be initialized.
    //

    if (NT_SUCCESS(retStatus))
    {
        //
        // Set versions and size.
        //

        pdevmode->dmSpecVersion   = DM_SPECVERSION;
        pdevmode->dmDriverVersion = DM_SPECVERSION;
        pdevmode->dmSize          = sizeof(DEVMODEW);

        //
        // Currently, the logpixel value should not be changed on the fly.
        // So once it has been read out of the registry at boot time, keep
        // that same value and ignore the registry.
        //

        if (gdmLogPixels)
        {
            pdevmode->dmLogPixels = gdmLogPixels;
        }
        else
        {
            //
            // Get the devices pelDPI out of the registry
            //

            UNICODE_STRING    us;
            OBJECT_ATTRIBUTES ObjectAttributes;
            NTSTATUS          Status;
            HANDLE            hKey;
            DWORD             cbSize;
            BYTE              Buf[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(DWORD)];

            pdevmode->dmLogPixels = 96;

            //
            // Look in the Hardware Profile for the current font size.
            // If that fails, look in the global software location.
            //

            RtlInitUnicodeString(&us, L"\\Registry\\Machine\\System"
                                      L"\\CurrentControlSet\\Hardware Profiles"
                                      L"\\Current\\Software\\Fonts");

            InitializeObjectAttributes(&ObjectAttributes,
                                       &us,
                                       OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                                       NULL,
                                       NULL);

            Status = ZwOpenKey(&hKey, KEY_READ, &ObjectAttributes);

            if (!NT_SUCCESS(Status))
            {
                RtlInitUnicodeString(&us, L"\\Registry\\Machine\\Software"
                                          L"\\Microsoft\\Windows NT"
                                          L"\\CurrentVersion\\FontDPI");

                InitializeObjectAttributes(&ObjectAttributes,
                                           &us,
                                           OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                                           NULL,
                                           NULL);

                Status = ZwOpenKey(&hKey, KEY_READ, &ObjectAttributes);
            }

            if (NT_SUCCESS(Status))
            {
                RtlInitUnicodeString(&us, L"LogPixels");

                Status = ZwQueryValueKey(hKey,
                                         &us,
                                         KeyValuePartialInformation,
                                         (PKEY_VALUE_PARTIAL_INFORMATION)Buf,
                                         sizeof(Buf),
                                         &cbSize);

                if (NT_SUCCESS(Status))
                {
                    pdevmode->dmLogPixels =
                        *((PUSHORT)((PKEY_VALUE_PARTIAL_INFORMATION)Buf)->Data);
                }

                ZwCloseKey(hKey);
            }


            //
            // For non high-res mode, let's force small font size so
            // that various dialogs are not clipped out.
            //

            if (pdevmode->dmPelsHeight < 600)
            {
                pdevmode->dmLogPixels = 96;
            }

            gdmLogPixels = pdevmode->dmLogPixels;

        }

        //
        // Set all the appropriate DEVMODE flags.
        //

        pdevmode->dmFields = DM_INTERNAL_VALID_FLAGS;

        if (attached)
        {
            pdevmode->dmFields |= DM_POSITION;
        }

        if (pdevmode->dmDisplayFixedOutput != DMDFO_DEFAULT)
        {
            pdevmode->dmFields |= DM_DISPLAYFIXEDOUTPUT;
        }

        TRACE_INIT(("Drv_Trace: GetDriverParams: DEVMODE\n"));
        dbgDumpDevmode(pdevmode);


        if ((PhysDisp->stateFlags & DISPLAY_DEVICE_DISCONNECT) != 0 )
        {
            DEVMODEW disconnectDevmode;

            disconnectDevmode.dmFields = 0;
            UserGetDisconnectDeviceResolutionHint(&disconnectDevmode);
            if (disconnectDevmode.dmFields & DM_PELSWIDTH  && disconnectDevmode.dmFields & DM_PELSHEIGHT)
            {
                pdevmode->dmFields |=   DM_PELSWIDTH | DM_PELSHEIGHT;
                pdevmode->dmPelsWidth = disconnectDevmode.dmPelsWidth;
                pdevmode->dmPelsHeight = disconnectDevmode.dmPelsHeight;
            }
        }
    }
    else
    {
        TRACE_INIT(("Drv_Trace: GetSetParms: Get failed\n\n"));

    }

    TRACE_INIT(("Drv_Trace: GetDriverParams: Exit\n\n"));

    return (retStatus);
}

/**************************************************************************\
* DrvWriteDisplayDriverParameters
*
* Wites the resolution parameters to the registry.
*
* 13-Mar-1996 andreva created
\**************************************************************************/

NTSTATUS
DrvWriteDisplayDriverParameters(
    ULONG     RelativeTo,
    PWSTR     Path,
    PDEVMODEW pdevmode,
    BOOL      bDetach)
{
    ULONG    i;
    NTSTATUS retStatus = STATUS_SUCCESS;
    DWORD    data[NUM_DISPLAY_DRIVER_EXTRA];
    DWORD    numData = NUM_DISPLAY_DRIVER_EXTRA - 1;
    DWORD    dataval;

    //
    // If we are deteaching, shortcircuit and just write that value out.
    //

    if (bDetach)
    {
        dataval = 0;

        ASSERTGDI(pdevmode == NULL, "Detach should have NULL DEVMODE\n");

        return RtlWriteRegistryValue(RelativeTo,
                                     Path,
                                     (PWSTR)AttachedSettings[1],
                                     REG_DWORD,
                                     &dataval,
                                     sizeof(DWORD));
    }

    //
    // DM_POSITION determine whether or not we write the attach values
    //

    if (pdevmode->dmFields & DM_POSITION)
    {
        //
        // Determine what we want to set the attached value to.
        //

        dataval = 1;

        retStatus = RtlWriteRegistryValue(RelativeTo,
                                          Path,
                                          (PWSTR)AttachedSettings[1],
                                          REG_DWORD,
                                          &dataval,
                                          sizeof(DWORD));
    }
    else
    {
        //
        // Don't write the Position values if we are not attaching
        //

        numData -= 2;
    }


    //
    // Write all the reset of the data
    //

    data[0] = pdevmode->dmBitsPerPel;
    data[1] = pdevmode->dmPelsWidth;
    data[2] = pdevmode->dmPelsHeight;
    data[3] = pdevmode->dmDisplayFrequency;
    data[4] = pdevmode->dmDisplayFlags;
    data[5] = pdevmode->dmPanningWidth;
    data[6] = pdevmode->dmPanningHeight;
    data[7] = pdevmode->dmDisplayOrientation;
    data[8] = pdevmode->dmDisplayFixedOutput;
    data[9] = pdevmode->dmPosition.x;
    data[10]= pdevmode->dmPosition.y;

    for (i=0; NT_SUCCESS(retStatus) && (i < numData); i++)
    {
        retStatus = RtlWriteRegistryValue(RelativeTo,
                                          Path,
                                          (PWSTR)DefaultSettings[i],
                                          REG_DWORD,
                                          &data[i],
                                          sizeof(DWORD));
    }

    if (NT_SUCCESS(retStatus) && pdevmode->dmDriverExtra)
    {
        retStatus = RtlWriteRegistryValue(RelativeTo,
                                          Path,
                                          (PWSTR)DefaultSettings[NUM_DISPLAY_DRIVER_EXTRA],
                                          REG_BINARY,
                                          ((PUCHAR)pdevmode) + pdevmode->dmSize,
                                          pdevmode->dmDriverExtra);
    }

    return retStatus;
}

NTSTATUS
DrvUpdateDisplayDriverParameters(
    PGRAPHICS_DEVICE PhysDisp,
    LPDEVMODEW pdevmodeInformation,
    BOOL bDetach,
    BOOL bUpdateMonitors)
{
    HANDLE           hkRegistry;
    ULONG            i;
    NTSTATUS         retStatus = STATUS_UNSUCCESSFUL;
    DISP_DRIVER_REGISTRY_TYPE registryParam = DispDriverRegHardwareProfileCreate;

    //
    // Change the settings for the whole machine or for the user.
    //
    // CDS_GLOBAL is the default right now.
    // When we store the settings on a per-user basis, then this flag
    // will override that behaviour.
    //

    // if (ChangeGlobalSettings)
    {
        TRACE_INIT(("Drv_Trace: SetParms: Default Settings\n"));

        //
        // try the hardware profile first and see if we can get parameters
        // from that.  If that fails, fall back to getting the system
        // parameters.
        //

        while (1)
        {
            hkRegistry = DrvGetRegistryHandleFromDeviceMap(PhysDisp,
                                                           registryParam,
                                                           NULL,
                                                           NULL,
                                                           NULL,
                                                           gProtocolType);

            if (hkRegistry)
            {
                retStatus = DrvWriteDisplayDriverParameters(RTL_REGISTRY_HANDLE,
                                                            (LPWSTR) hkRegistry,
                                                            pdevmodeInformation,
                                                            bDetach);
                ZwCloseKey(hkRegistry);
            }

            if ( (NT_SUCCESS(retStatus)) ||
                 (registryParam != DispDriverRegHardwareProfileCreate) )
                break;

            registryParam = DispDriverRegGlobal;
       }
    }

    //
    // Update per-monitor setting
    //
    if (NT_SUCCESS(retStatus) && bUpdateMonitors)
    {
        UpdateMonitorDevices();

        for (i = 0; i < PhysDisp->numMonitorDevice; i++)
        {
            if (IS_ATTACHED_ACTIVE(PhysDisp->MonitorDevices[i].flag))
            {
                hkRegistry = DrvGetRegistryHandleFromDeviceMap(PhysDisp,
                                                               registryParam,
                                                               &PhysDisp->MonitorDevices[i].HwID,
                                                               NULL,
                                                               NULL,
                                                               gProtocolType);
                if (hkRegistry)
                {
                    // We don't need to check the status here.  Per adapter settings plays
                    // as a backup
                    DrvWriteDisplayDriverParameters(RTL_REGISTRY_HANDLE,
                                                    (LPWSTR) hkRegistry,
                                                    pdevmodeInformation,
                                                    bDetach);
                    ZwCloseKey(hkRegistry);
                }
            }
        }
    }

    TRACE_INIT(("Drv_Trace: SetParms: Exit\n\n"));

    return retStatus;
}

/**************************************************************************\
* DrvGetHdevName
*
* Returns the name of the device associated with an HDEV so GetMonitorInfo
* can return this information
*
* 07-Jul-1998 andreva created
\**************************************************************************/

BOOL
DrvGetHdevName(
    HDEV   hdev,
    PWCHAR DeviceName
    )
{
   PDEVOBJ pdo(hdev);

   RtlCopyMemory(DeviceName,
                 pdo.ppdev->pGraphicsDevice->szWinDeviceName,
                 sizeof(pdo.ppdev->pGraphicsDevice->szWinDeviceName));

   return TRUE;
}

/**************************************************************************\
* DrvGetDeviceFromName
*
* Given the name of a device, returns a pointer to a structure describing
* the device.
*
* Specifying NULL tells the system to return the information for the default
* device on which the application is running.
*
* returns a PGRAPHICS_DEVICE
*
* *** NOTE
* If the caller requests Exclusive access, the caller must call back and
* release the access once the device is no longer used.
*
* 31-May-1994 andreva created
\**************************************************************************/

PGRAPHICS_DEVICE
DrvGetDeviceFromName(
    PUNICODE_STRING pstrDeviceName,
    MODE            PreviousMode)
{
    ULONG              i = 0;
    NTSTATUS           status;
    PGRAPHICS_DEVICE   PhysDisp;
    PDEVICE_OBJECT     pDeviceObject = NULL;
    UNICODE_STRING     uCapturedString;
    UNICODE_STRING     uString;
    BOOL               fDisableSuccess;

    TRACE_INIT(("Drv_Trace: GetDev: Enter"));

    __try
    {
        if (PreviousMode == UserMode)
        {
            uCapturedString.Length = 0;


            if (pstrDeviceName)
            {
                ProbeForRead(pstrDeviceName, sizeof(UNICODE_STRING), sizeof(CHAR));
                uCapturedString = *pstrDeviceName;
            }

            if (uCapturedString.Length)
            {
                ProbeForRead(uCapturedString.Buffer,
                             uCapturedString.Length,
                             sizeof(BYTE));
            }
            else
            {

#if DONT_CHECKIN
                PDESKTOP pdesk = PtiCurrent()->rpdesk;
                PDISPLAYINFO pDispInfo;

                if (pdesk)
                {
                    //
                    // Special case for boot-up time.
                    //
                    pDispInfo = pdesk->pDispInfo;
                }
                else
                {
                    pDispInfo = G_TERM(pDispInfo);
                }

                RtlInitUnicodeString(&uCapturedString,
                                     pDispInfo->pDevInfo->szWinDeviceName);
#endif

            }
        }
        else
        {
            ASSERTGDI(pstrDeviceName >= (PUNICODE_STRING const)MM_USER_PROBE_ADDRESS,
                      "Bad kernel mode address\n");
            uCapturedString = *pstrDeviceName;
        }

        //
        // Look for an existing handle in our handle table.
        // Start by looking for the VGACOMPATIBLE string, which is
        // our VgaCompatible device
        //

        RtlInitUnicodeString(&uString, L"VGACOMPATIBLE");

        if (RtlEqualUnicodeString(&uCapturedString,
                                  &uString,
                                  TRUE))
        {
            PhysDisp = &gFullscreenGraphicsDevice;
        }
        else
        {
            for (PhysDisp = gpGraphicsDeviceList;
                 PhysDisp;
                 PhysDisp = PhysDisp->pNextGraphicsDevice)
            {


                RtlInitUnicodeString(&uString,
                                     &(PhysDisp->szWinDeviceName[0]));

                if (RtlEqualUnicodeString(&uCapturedString,
                                          &uString,
                                          TRUE))
                {
                    break;
                }
            }
        }

    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        PhysDisp = NULL;
    }


    if (PhysDisp == NULL)
    {
        WARNING("DrvGetDeviceFromName: Calling for a non-exsting device!");
        return NULL;
    }


    TRACE_INIT((" - Exit\n"));

    return PhysDisp;
}

/**************************************************************************\
* PruneModesByMonitors
*
* Read the EDID from regstry first.  Retrieve the Monitor capabilities.
* And prune mode list based on Monitor capability.
\**************************************************************************/

int compModeCap(LPMODECAP pModeCap1, LPMODECAP pModeCap2)
{
    if (pModeCap1->dmWidth != pModeCap2->dmWidth)
    {
        return (pModeCap1->dmWidth - pModeCap2->dmWidth);
    }
    return (pModeCap1->dmHeight - pModeCap2->dmHeight);
}

ULONG InsertModecapList(LPMODECAP pmc, LPMODECAP ModeCaps, ULONG numModeCaps)
{
    ULONG i;
    int comp = -1;
    for (i = 0; i < numModeCaps; i++)
    {
        comp = compModeCap(pmc, &ModeCaps[i]);
        if (comp > 0)
        {
            continue;
        }
        if (comp == 0)
        {
            //
            // For duplicated entries, pick the bigger one
            //
            if (ModeCaps[i].freq < pmc->freq)
            {
                ModeCaps[i].freq = pmc->freq;
                ModeCaps[i].MinVFreq = pmc->MinVFreq;
            }
            if (ModeCaps[i].MaxHFreq < pmc->MaxHFreq)
            {
                ModeCaps[i].MaxHFreq = pmc->MaxHFreq;
                ModeCaps[i].MinHFreq = pmc->MinHFreq;
            }
            return numModeCaps;
        }

        //
        // If buffer size reaches the limit, do nothing and return
        //
        if (numModeCaps >= MAX_MODE_CAPABILITY)
        {
            return numModeCaps;
        }

        RtlMoveMemory(&ModeCaps[i+1], &ModeCaps[i], (numModeCaps-i)*sizeof(MODECAP));
        ModeCaps[i] = *pmc;
        return (numModeCaps+1);
    }
    ModeCaps[numModeCaps] = *pmc;
    return (numModeCaps+1);
}

ULONG xwtol(LPWSTR wptr)
{
    for (ULONG v = 0;
         (*wptr >= L'0' && *wptr <= L'9') || *wptr == L' ';
         *wptr++)
    {
        if (*wptr != L' ')
            v = v*10 + (*wptr - L'0');
    }
    return v;
}

BOOL ParseModeCap(LPWSTR wstr, LPMODECAP pmc, BOOL bFreq)
{
    LPWSTR wptr1, wptr2, wptr3;
    ULONG v[4] = {0, 0xFFFFFFFF, 0, 0xFFFFFFFF}, i;
    for (wptr1 = wptr2 = wstr, i = 0;
         wptr2 != NULL && i < 4;
         wptr1 = wptr2+1, i++)
    {
        wptr2 = wcschr(wptr1, L',');
        if (wptr2 != NULL)
        {
            *wptr2 = 0;
        }
        if (bFreq)
        {
            wptr3 = wcschr(wptr1, L'-');
            if (wptr3 != NULL)
            {
                *wptr3 = 0;
                v[i] = xwtol(wptr1);
                wptr1 = wptr3+1;
            }
            else
            {
                v[i] = 0;
            }
            i++;
        }
        v[i] = xwtol(wptr1);
    }
    if (bFreq)
    {
        pmc->MinVFreq = max(pmc->MinVFreq, v[2]);
        pmc->freq     = min(pmc->freq, v[3]);
        pmc->MinHFreq = max(pmc->MinHFreq, v[0] * 1000);
        pmc->MaxHFreq = min(pmc->MaxHFreq, v[1] * 1000);
    }
    else
    {
        if (v[0] == 0 || v[1] == 0xFFFFFFFF)
        {
            return FALSE;
        }
        pmc->dmWidth  = v[0];
        pmc->dmHeight = v[1];
        pmc->freq = v[2];
    }
    return TRUE;
}

ULONG GetMonitorCapabilityFromInf(PDEVICE_OBJECT pdo, LPMODECAP ModeCaps)
{
    HANDLE          hkRegistry, hkRegistry1, hkRegistry2;

    if ( !NT_SUCCESS(IoOpenDeviceRegistryKey(pdo, PLUGPLAY_REGKEY_DRIVER, KEY_READ, &hkRegistry)) )
    {
        return 0;
    }

    ULONG               numModeCaps = 0;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    UNICODE_STRING      UnicodeString;

    RtlInitUnicodeString(&UnicodeString, L"MODES");
    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                               hkRegistry,
                               NULL);
    if ( NT_SUCCESS (ZwOpenKey(&hkRegistry1, KEY_READ, &ObjectAttributes)) )
    {
        WCHAR data[128], buf[128];
        ULONG i = 0, size;
        MODECAP mc;

        while (NT_SUCCESS(ZwEnumerateKey(hkRegistry1,
                                         i,
                                         KeyBasicInformation,
                                         data,
                                         sizeof(data),
                                         &size)))
        {
            i++;

            UnicodeString.Buffer        = ((PKEY_BASIC_INFORMATION) data)->Name;
            UnicodeString.Length        = (USHORT) ((PKEY_BASIC_INFORMATION) data)->NameLength;
            UnicodeString.MaximumLength = (USHORT) ((PKEY_BASIC_INFORMATION) data)->NameLength;

            //
            // 1024, 768
            //
            wcsncpy(buf, UnicodeString.Buffer, min(UnicodeString.Length, sizeof(buf))/sizeof(WCHAR));
            if (UnicodeString.Length < sizeof(buf) )
                buf[UnicodeString.Length/sizeof(WCHAR)] = 0;
            buf[sizeof(buf)/sizeof(WCHAR)-1] = 0;
            if (!ParseModeCap(buf, &mc, FALSE))
                continue;

            InitializeObjectAttributes(&ObjectAttributes,
                                       &UnicodeString,
                                       OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                                       hkRegistry1,
                                       NULL);

            if (NT_SUCCESS (ZwOpenKey(&hkRegistry2,
                                      MAXIMUM_ALLOWED,
                                      &ObjectAttributes)))
            {
                WCHAR modeStr[] = L"Mode1";
                BOOL  bSucceed = FALSE;

                for (ULONG j = 0; j < 9; j++)
                {
                    RtlInitUnicodeString(&UnicodeString, modeStr);

                    if (NT_SUCCESS(ZwQueryValueKey(hkRegistry2,
                                                   &UnicodeString,
                                                   KeyValueFullInformation,
                                                   data,
                                                   sizeof(data),
                                                   &size)) )
                    {
                        wcsncpy(buf,
                                (LPWSTR)((PBYTE)data + ((PKEY_VALUE_FULL_INFORMATION)data)->DataOffset),
                                sizeof(buf)/sizeof(WCHAR)-1);
                        //
                        // MinHFreq  MaxHFreq  MinVFreq  MaxVFreq
                        // 31.0    - 82.0,     55.0    - 100.0,   +,+
                        //
                        mc.MinVFreq = MIN_REFRESH_RATE;
                        mc.freq     = 0xFFFFFFFF;
                        mc.MinHFreq = 0;
                        mc.MaxHFreq = 0xFFFFFFFF;
                        if (ParseModeCap(buf, &mc, TRUE))
                        {
                            numModeCaps = InsertModecapList(&mc, ModeCaps, numModeCaps);
                        }

                        bSucceed = TRUE;
                    }
                    else if (bSucceed)
                    {
                        break;
                    }

                    modeStr[4]++;
                }
                ZwCloseKey(hkRegistry2);
            }
        }

        ZwCloseKey(hkRegistry1);
    }
    ZwCloseKey(hkRegistry);
    return numModeCaps;
}

BOOL GetRegEDID(PDEVICE_OBJECT pdo, PBYTE pBuffer, PBYTE *ppEdid)
{
    HANDLE   hkRegistry;
    NTSTATUS status;

    // Get EDID information from registry
    if ( !NT_SUCCESS(IoOpenDeviceRegistryKey(pdo, PLUGPLAY_REGKEY_DEVICE, KEY_READ, &hkRegistry)) )
    {
        TRACE_INIT(("Drv_Trace: GetMonitorCapability: Failed to retrieve EDID\n"));
        return FALSE;
    }

    UNICODE_STRING UnicodeString;
    ULONG cbSize;
    RtlInitUnicodeString(&UnicodeString, L"EDID");

    status = ZwQueryValueKey(hkRegistry,
                             &UnicodeString,
                             KeyValueFullInformation,
                             pBuffer,
                             400,
                             &cbSize);

    if (NT_SUCCESS(status))
    {
        if ( (((PKEY_VALUE_FULL_INFORMATION)pBuffer)->DataLength) < 256)
            status = STATUS_UNSUCCESSFUL;
        else
            *ppEdid = (PBYTE)(pBuffer + ((PKEY_VALUE_FULL_INFORMATION)pBuffer)->DataOffset);
    }
    (VOID)ZwCloseKey(hkRegistry);

    if (!NT_SUCCESS(status))
        return FALSE;

    return TRUE;
}

BOOL GetValuesFromInf(PDEVICE_OBJECT pdo, ULONG op, LPMODECAP pmc)
{
    if (op > 1)
        return FALSE;

    HANDLE  hkRegistry;
    static  LPWSTR ValueName[] = {
                L"PreferredMode",
                L"ClearType"
            };

    if ( !NT_SUCCESS(IoOpenDeviceRegistryKey(pdo, PLUGPLAY_REGKEY_DRIVER, KEY_READ, &hkRegistry)) )
        return FALSE;

    UNICODE_STRING  UnicodeString;
    WCHAR           data[128], buf[128];
    ULONG           size;

    // Assuming return failure
    BOOL bRet = FALSE;
    RtlInitUnicodeString(&UnicodeString, ValueName[op]);
    if (NT_SUCCESS(ZwQueryValueKey(hkRegistry,
                                   &UnicodeString,
                                   KeyValueFullInformation,
                                   data,
                                   sizeof(data),
                                   &size)) )
    {
        switch (op)
        {
        case 0:     // GetPreferredMode
            wcsncpy(buf,
                    (LPWSTR)((PBYTE)data + ((PKEY_VALUE_FULL_INFORMATION)data)->DataOffset),
                    sizeof(buf)/sizeof(WCHAR)-1);
            // 1024,768,60
            if (ParseModeCap(buf, pmc, FALSE))
            {
                if (pmc->dmWidth != 0 && pmc->dmHeight != 0 && pmc->freq != 0)
                    bRet = TRUE;
            }
            break;
        case 1:     // Get ClearType Capability
            pmc->dmWidth = *(PULONG) ( (PBYTE)data + ((PKEY_VALUE_FULL_INFORMATION)data)->DataOffset );
            bRet = TRUE;
            break;
        default:
            break;
        }
    }

    ZwCloseKey(hkRegistry);

    return bRet;
}

/**************************************************************************\
* GetDefaultFrequencyRange
*
* Routine Description:
*
*   Returns default frequency range for the monitor.
*
* Arguments:
*
*   pFrequencyRange - Points to storage for monitor frequency limits.
*
* Returns:
*
*   Default monitor frequency limits returned in pFrequencyRange.
*
* 08-Oct-1999 mmacie created
\**************************************************************************/

VOID
GetDefaultFrequencyRange(
    OUT PFREQUENCY_RANGE pFrequencyRange
    )
{
    ASSERT(NULL != pFrequencyRange);

    pFrequencyRange->ulMinVerticalRate   = MIN_REFRESH_RATE;
    pFrequencyRange->ulMaxVerticalRate   = 0xffffffff;
    pFrequencyRange->ulMinHorizontalRate = 0;
    pFrequencyRange->ulMaxHorizontalRate = 0xffffffff;
    pFrequencyRange->ulMinPixelClock     = 0;
    pFrequencyRange->ulMaxPixelClock     = 0xffffffff;
}

/**************************************************************************\
* GetMonitorCapability2
*
* Routine Description:
*
*   Parsing routine for EDID Version 2.
*
* Arguments:
*
*   pEdid2          - Points to EDID Version 2 data.
*   pModeCaps       - Points to storage for monitor cap details.
*   pFrequencyRange - Points to storage for monitor frequency limits.
*
* Returns:
*
*   Number of mode capabilites.
*   - Mode cap data returned in pModeCaps.
*   - Monitor frequency limits returned in pFrequencyRange.
*
* 21-Sep-1999 mmacie created
\**************************************************************************/

ULONG
GetMonitorCapability2(
    IN PEDID2 pEdid2,
    OUT PMODECAP pModeCaps,
    OUT PFREQUENCY_RANGE pFrequencyRange
    )
{
    ULONG ulNumberOfModeCaps;
    ULONG ulNumberOfLuminanceTables;
    ULONG ulNumberOfFrequencyRanges;
    ULONG ulNumberOfDetailTimingRanges;
    ULONG ulNumberOfTimingCodes;
    ULONG ulNumberOfDetailTimings;
    ULONG ulEdidOffset;
    ULONG ulTemp;

    ASSERT(NULL != pEdid2);
    ASSERT(NULL != pModeCaps);
    ASSERT(NULL != pFrequencyRange);
    ASSERT(0x20 == pEdid2->ucEdidVersionRevision);  // Make sure EDID Version 2

    //
    // Parse map of timings.
    //

    ulNumberOfLuminanceTables = (pEdid2->ucaMapOfTiming[0] & EDID2_MOT0_LUMINANCE_TABLE_MASK) >>
        EDID2_MOT0_LUMINANCE_TABLE_SHIFT;

    ulNumberOfFrequencyRanges = (pEdid2->ucaMapOfTiming[0] & EDID2_MOT0_FREQUENCY_RANGE_MASK) >>
        EDID2_MOT0_FREQUENCY_RANGE_SHIFT;

    ulNumberOfDetailTimingRanges = (pEdid2->ucaMapOfTiming[0] & EDID2_MOT0_DETAIL_TIMING_RANGE_MASK) >>
        EDID2_MOT0_DETAIL_TIMING_RANGE_SHIFT;

    ulNumberOfTimingCodes = (pEdid2->ucaMapOfTiming[1] & EDID2_MOT1_TIMING_CODE_MASK) >>
        EDID2_MOT1_TIMING_CODE_SHIFT;

    ulNumberOfDetailTimings = (pEdid2->ucaMapOfTiming[1] & EDID2_MOT1_DETAIL_TIMING_MASK) >>
        EDID2_MOT1_DETAIL_TIMING_SHIFT;

    TRACE_INIT(("win32k!GetMonitorCapability2: NumberOfLuminanceTables    = %lu\n", ulNumberOfLuminanceTables));
    TRACE_INIT(("win32k!GetMonitorCapability2: NumberOfFrequencyRanges    = %lu\n", ulNumberOfFrequencyRanges));
    TRACE_INIT(("win32k!GetMonitorCapability2: NumberOfDetailTimingRanges = %lu\n", ulNumberOfDetailTimingRanges));
    TRACE_INIT(("win32k!GetMonitorCapability2: NumberOfDetailTimingCodes  = %lu\n", ulNumberOfTimingCodes));
    TRACE_INIT(("win32k!GetMonitorCapability2: NumberOfDetailTimings      = %lu\n", ulNumberOfDetailTimings));

    //
    // Check for bad EDIDs.
    //

    if ((ulNumberOfLuminanceTables    > EDID2_MAX_LUMINANCE_TABLES) ||
        (ulNumberOfFrequencyRanges    > EDID2_MAX_FREQUENCY_RANGES) ||
        (ulNumberOfDetailTimingRanges > EDID2_MAX_DETAIL_TIMING_RANGES) ||
        (ulNumberOfTimingCodes        > EDID2_MAX_TIMING_CODES) ||
        (ulNumberOfDetailTimings      > EDID2_MAX_DETAIL_TIMINGS))
    {
        WARNING("Bad EDID2\n");
        GetDefaultFrequencyRange(pFrequencyRange);
        return 0;
    }

    ulEdidOffset = EDID2_LUMINANCE_TABLE_OFFSET;

    //
    // Move over luminance tables.
    //

    if (ulNumberOfLuminanceTables)
    {
        PUCHAR pucLuminanceTable;

        for (ulTemp = 0; ulTemp < ulNumberOfLuminanceTables; ulTemp++)
        {
            //
            // Check for bad EDIDs.
            //

            if (ulEdidOffset >= (sizeof (EDID2) - 1))
            {
                WARNING("Bad EDID2\n");
                GetDefaultFrequencyRange(pFrequencyRange);
                return 0;
            }

            pucLuminanceTable = (PUCHAR)pEdid2 + ulEdidOffset;

            ulEdidOffset += (((*pucLuminanceTable & EDID2_LT0_SUB_CHANNELS_FLAG) ? 3 : 1) *
                ((*pucLuminanceTable & EDID2_LT0_ENTRIES_MASK) >> EDID2_LT0_ENTRIES_SHIFT) + 1);
        }
    }

    //
    // Parse frequency ranges.
    //

    if (ulNumberOfFrequencyRanges)
    {
        PEDID2_FREQUENCY_RANGE pEdidRange;
        ULONG ulRate;

        //
        // Currently the mode prunning code cannot handle multiple
        // frequency ranges but EDID Version 2 can supply them.
        // We're hacking around here by merging all of them into a single
        // "super frequency range".
        //

        //
        // Make sure we pick up the first range.
        //

        pFrequencyRange->ulMinVerticalRate   = 0xffffffff;
        pFrequencyRange->ulMaxVerticalRate   = 0;
        pFrequencyRange->ulMinHorizontalRate = 0xffffffff;
        pFrequencyRange->ulMaxHorizontalRate = 0;
        pFrequencyRange->ulMinPixelClock     = 0xffffffff;
        pFrequencyRange->ulMaxPixelClock     = 0;

        for (ulTemp = 0; ulTemp < ulNumberOfFrequencyRanges; ulTemp++,
            ulEdidOffset += sizeof (EDID2_FREQUENCY_RANGE))
        {
            //
            // Check for bad EDIDs.
            //

            if (ulEdidOffset >= (sizeof (EDID2) - sizeof (EDID2_FREQUENCY_RANGE)))
            {
                WARNING("Bad EDID2\n");
                GetDefaultFrequencyRange(pFrequencyRange);
                return 0;
            }

            pEdidRange = (PEDID2_FREQUENCY_RANGE)((PUCHAR)pEdid2 + ulEdidOffset);

            ulRate = (ULONG)(pEdidRange->ucMinFrameFieldRateBits9_2) << 2;
            ulRate += (pEdidRange->ucFrameFieldLineRatesBits1_0 & 0xc0) >> 6;

            if (ulRate < pFrequencyRange->ulMinVerticalRate)
                pFrequencyRange->ulMinVerticalRate = ulRate;

            ulRate = (ULONG)(pEdidRange->ucMaxFrameFieldRateBits9_2) << 2;
            ulRate += (pEdidRange->ucFrameFieldLineRatesBits1_0 & 0x30) >> 4;

            if (ulRate > pFrequencyRange->ulMaxVerticalRate)
                pFrequencyRange->ulMaxVerticalRate = ulRate;

            ulRate = (ULONG)(pEdidRange->ucMinLineRateBits9_2) << 2;
            ulRate += (pEdidRange->ucFrameFieldLineRatesBits1_0 & 0x0c) >> 2;
            ulRate *= 1000;

            if (ulRate < pFrequencyRange->ulMinHorizontalRate)
                pFrequencyRange->ulMinHorizontalRate = ulRate;

            ulRate = (ULONG)(pEdidRange->ucMaxLineRateBits9_2) << 2;
            ulRate += (pEdidRange->ucFrameFieldLineRatesBits1_0 & 0x03);
            ulRate *= 1000;

            if (ulRate > pFrequencyRange->ulMaxHorizontalRate)
                pFrequencyRange->ulMaxHorizontalRate = ulRate;

            ulRate = (ULONG)((pEdidRange->ucPixelRatesBits11_8) & 0xf0) << 4;
            ulRate += pEdidRange->ucMinPixelRateBits7_0;
            ulRate *= 1000000;

            if (ulRate < pFrequencyRange->ulMinPixelClock)
                pFrequencyRange->ulMinPixelClock = ulRate;

            ulRate = (ULONG)((pEdidRange->ucPixelRatesBits11_8) & 0x0f) << 8;
            ulRate += pEdidRange->ucMaxPixelRateBits7_0;
            ulRate *= 1000000;

            if (ulRate > pFrequencyRange->ulMaxPixelClock)
                pFrequencyRange->ulMaxPixelClock = ulRate;

            //
            // Check for bad EDIDs.
            //

            if ((pFrequencyRange->ulMinVerticalRate   > pFrequencyRange->ulMaxVerticalRate) ||
                (pFrequencyRange->ulMinHorizontalRate > pFrequencyRange->ulMaxHorizontalRate) ||
                (pFrequencyRange->ulMinPixelClock     > pFrequencyRange->ulMaxPixelClock) ||
                (pFrequencyRange->ulMaxVerticalRate   < 60) ||
                (pFrequencyRange->ulMaxHorizontalRate < (60*480)) ||
                (pFrequencyRange->ulMaxPixelClock     < (60*480*640))
                )
            {
                WARNING("Bad EDID2\n");
                GetDefaultFrequencyRange(pFrequencyRange);
            }
        }
    }

    ulNumberOfModeCaps = 0;

    //
    // Parse detail timing ranges.
    //

    if (ulNumberOfDetailTimingRanges)
    {
        PEDID2_DETAIL_TIMING_RANGE pEdidRange;
        MODECAP modeCap;
        ULONG ulHorizontalTotal;
        ULONG ulVerticalTotal;
        ULONG ulPixelClock;

        //
        // Currently the mode prunning code cannot handle detailed
        // timing ranges but EDID Version 2 can supply them.
        // We're hacking around here by taking maximum values only.
        //

        modeCap.MinVFreq = MIN_REFRESH_RATE;
        modeCap.MinHFreq = 0;
        modeCap.MaxHFreq = 0xffffffff;

        for (ulTemp = 0; ulTemp < ulNumberOfDetailTimingRanges; ulTemp++,
            ulEdidOffset += sizeof (EDID2_DETAIL_TIMING_RANGE))
        {
            //
            // Check for bad EDIDs.
            //

            if (ulEdidOffset >= (sizeof (EDID2) - sizeof (EDID2_DETAIL_TIMING_RANGE)))
            {
                WARNING("Bad EDID2\n");
                GetDefaultFrequencyRange(pFrequencyRange);
                return 0;
            }

            pEdidRange = (PEDID2_DETAIL_TIMING_RANGE)((PUCHAR)pEdid2 + ulEdidOffset);

            modeCap.dmWidth = (ULONG)(pEdidRange->ucActiveHighBits & 0xf0) << 4;
            modeCap.dmWidth += pEdidRange->ucHorizontalActiveLowByte;

            modeCap.dmHeight = (ULONG)(pEdidRange->ucActiveHighBits & 0x0f) << 8;
            modeCap.dmHeight += pEdidRange->ucVerticalActiveLowByte;

            ulHorizontalTotal = (ULONG)(pEdidRange->ucMaxBlankHighBits & 0xf0) << 4;
            ulHorizontalTotal += pEdidRange->ucMaxHorizontalBlankLowByte + modeCap.dmWidth;

            ulVerticalTotal = (ULONG)(pEdidRange->ucMaxBlankHighBits & 0x0f) << 8;
            ulVerticalTotal += pEdidRange->ucMaxVerticalBlankLowByte + modeCap.dmHeight;

            //
            // Make sure we won't divide by zero in case of bad EDID.
            //

            if ((0 == ulHorizontalTotal) || (0 == ulVerticalTotal))
            {
                WARNING("Bad EDID2\n");
                GetDefaultFrequencyRange(pFrequencyRange);
                return 0;
            }

            ulPixelClock = (ULONG)(pEdidRange->usMaxPixelClock) * 10000;

            //
            // Calculate refresh rate rounding to the nearest integer.
            //

            modeCap.freq = (((10 * ulPixelClock) / (ulHorizontalTotal * ulVerticalTotal)) + 5) / 10;

            if (pEdidRange->ucFlags & EDID2_DT_INTERLACED)
                modeCap.freq /= 2;

            TRACE_INIT(("win32k!GetMonitorCapability2: Detailed range %lux%lu at %luHz\n",
                modeCap.dmWidth, modeCap.dmHeight, modeCap.freq));

            ulNumberOfModeCaps = InsertModecapList(&modeCap, pModeCaps, ulNumberOfModeCaps);
        }
    }

    //
    // Parse timing codes.
    //

    if (ulNumberOfTimingCodes)
    {
        PEDID2_TIMING_CODE pTimingCode;
        MODECAP modeCap;

        modeCap.MinVFreq = MIN_REFRESH_RATE;
        modeCap.MinHFreq = 0;
        modeCap.MaxHFreq = 0xffffffff;

        for (ulTemp = 0; ulTemp < ulNumberOfTimingCodes; ulTemp++,
            ulEdidOffset += sizeof (EDID2_TIMING_CODE))
        {
            //
            // Check for bad EDIDs.
            //

            if (ulEdidOffset >= (sizeof (EDID2) - sizeof (EDID2_TIMING_CODE)))
            {
                WARNING("Bad EDID2\n");
                GetDefaultFrequencyRange(pFrequencyRange);
                return 0;
            }

            pTimingCode = (PEDID2_TIMING_CODE)((PUCHAR)pEdid2 + ulEdidOffset);

            modeCap.dmWidth  = 16 * pTimingCode->ucHorizontalActive + 256;
            modeCap.dmHeight = (100 * modeCap.dmWidth) / pTimingCode->ucAspectRatio;
            modeCap.freq     = pTimingCode->ucRefreshRate;

            if (pTimingCode->ucFlags & EDID2_TC_INTERLACED)
                modeCap.freq /= 2;

            TRACE_INIT(("win32k!GetMonitorCapability2: Timing code %lux%lu at %luHz\n",
                modeCap.dmWidth, modeCap.dmHeight, modeCap.freq));

            ulNumberOfModeCaps = InsertModecapList(&modeCap, pModeCaps, ulNumberOfModeCaps);
        }
    }

    //
    // Parse detail timings.
    //

    if (ulNumberOfDetailTimings)
    {
        PEDID2_DETAIL_TIMING pDetailTiming;
        MODECAP modeCap;
        ULONG ulHorizontalTotal;
        ULONG ulVerticalTotal;
        ULONG ulPixelClock;

        modeCap.MinVFreq = MIN_REFRESH_RATE;
        modeCap.MinHFreq = 0;
        modeCap.MaxHFreq = 0xffffffff;

        for (ulTemp = 0; ulTemp < ulNumberOfDetailTimings; ulTemp++,
            ulEdidOffset += sizeof (EDID2_DETAIL_TIMING))
        {
            //
            // Check for bad EDIDs.
            //

            if (ulEdidOffset >= (sizeof (EDID2) - sizeof (EDID2_DETAIL_TIMING)))
            {
                WARNING("Bad EDID2\n");
                GetDefaultFrequencyRange(pFrequencyRange);
                return 0;
            }

            pDetailTiming = (PEDID2_DETAIL_TIMING)((PUCHAR)pEdid2 + ulEdidOffset);

            modeCap.dmWidth = (ULONG)(pDetailTiming->ucHorizontalHighBits & 0xf0) << 4;
            modeCap.dmWidth += pDetailTiming->ucHorizontalActiveLowByte;

            modeCap.dmHeight = (ULONG)(pDetailTiming->ucVerticalHighBits & 0xf0) << 4;
            modeCap.dmHeight += pDetailTiming->ucVerticalActiveLowByte;

            ulHorizontalTotal = (ULONG)(pDetailTiming->ucHorizontalHighBits & 0x0f) << 8;
            ulHorizontalTotal += pDetailTiming->ucHorizontalBlankLowByte + modeCap.dmWidth;

            ulVerticalTotal = (ULONG)(pDetailTiming->ucVerticalHighBits & 0x0f) << 8;
            ulVerticalTotal += pDetailTiming->ucVerticalBlankLowByte + modeCap.dmHeight;

            //
            // Make sure we won't divide by zero in case of bad EDID.
            //

            if ((0 == ulHorizontalTotal) || (0 == ulVerticalTotal))
            {
                WARNING("Bad EDID2\n");
                GetDefaultFrequencyRange(pFrequencyRange);
                return 0;
            }

            ulPixelClock = (ULONG)(pDetailTiming->usPixelClock) * 10000;

            //
            // Calculate refresh rate rounding to the nearest integer.
            //

            modeCap.freq = (((10 * ulPixelClock) / (ulHorizontalTotal * ulVerticalTotal)) + 5) / 10;

            if (pDetailTiming->ucFlags & EDID2_DT_INTERLACED)
                modeCap.freq /= 2;

            TRACE_INIT(("win32k!GetMonitorCapability2: Detailed timing %lux%lu at %luHz\n",
                modeCap.dmWidth, modeCap.dmHeight, modeCap.freq));

            ulNumberOfModeCaps = InsertModecapList(&modeCap, pModeCaps, ulNumberOfModeCaps);
        }
    }

    //
    // Define monitor frequency limits in case EDID didn't have it.
    //

    if (0 == ulNumberOfFrequencyRanges)
    {
        GetDefaultFrequencyRange(pFrequencyRange);
    }

    TRACE_INIT(("win32k!GetMonitorCapability2: MinVerticalRate   = %lu\n", pFrequencyRange->ulMinVerticalRate));
    TRACE_INIT(("win32k!GetMonitorCapability2: MaxVerticalRate   = %lu\n", pFrequencyRange->ulMaxVerticalRate));
    TRACE_INIT(("win32k!GetMonitorCapability2: MinHorizontalRate = %lu\n", pFrequencyRange->ulMinHorizontalRate));
    TRACE_INIT(("win32k!GetMonitorCapability2: MaxHorizontalRate = %lu\n", pFrequencyRange->ulMaxHorizontalRate));
    TRACE_INIT(("win32k!GetMonitorCapability2: MinPixelClock     = %lu\n", pFrequencyRange->ulMinPixelClock));
    TRACE_INIT(("win32k!GetMonitorCapability2: MaxPixelClock     = %lu\n", pFrequencyRange->ulMaxPixelClock));

    //
    // Cascade refresh rates.
    //

    for (ulTemp = ulNumberOfModeCaps; ulTemp > 1; ulTemp--)
    {
        if (pModeCaps[ulTemp - 2].freq < pModeCaps[ulTemp - 1].freq)
            pModeCaps[ulTemp - 2].freq = pModeCaps[ulTemp - 1].freq;
    }

    return ulNumberOfModeCaps;
}

/**************************************************************************\
* GetMonitorCapability1
*
* Routine Description:
*
*   Parsing routine for EDID Version 1.x
*
* Arguments:
*
*   pEdid           - Points to EDID Version 1 data.
*   pModeCaps       - Points to storage for monitor cap details.
*   pFrequencyRange - Points to storage for monitor frequency limits.
*
* Returns:
*
*   Number of mode capabilites.
*   - Mode cap data returned in pModeCaps.
*   - Monitor frequency limits returned in pFrequencyRange.
*
* 21-Sep-1999 dennyd created
\**************************************************************************/

ULONG
GetMonitorCapability1(
    IN PBYTE pEdid,
    OUT PMODECAP pModeCaps,
    OUT PFREQUENCY_RANGE pFrequencyRange
    )
{
    ULONG numModeCaps = 0;
    MODECAP mc;
    PBYTE ptr;
    BYTE c;
    int i;
    int r1[] = {1, 4, 5, 16}, r2[] = {1, 3, 4, 9};
    UCHAR ucaEdid1Header[] = {0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00};

    GetDefaultFrequencyRange(pFrequencyRange);

    //
    // Check if EDID Version 1.
    //

    for (i = 0; i < (sizeof (ucaEdid1Header) / sizeof (UCHAR)); i++)
    {
        if (pEdid[i] != ucaEdid1Header[i])
            return 0;
    }

    // Handle established timings
    MODECAP mcArray[] = {{1280, 1024, 75},
                         {1024, 768, 75}, {1024, 768, 70}, {1024, 768, 60}, {1024, 768, 87},
                         {800,  600, 75}, {800,  600, 72}, {800,  600, 60}, {800,  600, 56},
                         {640,  480, 75}, {640,  480, 72}, {640,  480, 67}, {640,  480, 60} };
    pEdid[0x24] = ((((pEdid[0x24] & 0xc0) >> 1) & 0x60) | (pEdid[0x24] & 0x1f)) & 0x7f;
    for (i = 0; i < 13; i++)
    {
        mcArray[i].MinVFreq = MIN_REFRESH_RATE;
        mcArray[i].MinHFreq = 0;
        mcArray[i].MaxHFreq = 0xFFFFFFFF;
        if ((pEdid[0x24-i/7] >> (i%7)) & 0x01)
            numModeCaps = InsertModecapList(&mcArray[i], pModeCaps, numModeCaps);
    }

    mc.MinVFreq = MIN_REFRESH_RATE;
    mc.MinHFreq = 0;
    mc.MaxHFreq = 0xFFFFFFFF;
    // Standard Timing
    for (i = 0, ptr = &pEdid[0x26]; i < 8; i++, ptr += 2)
    {
        if (*ptr == 0 || *ptr == 1)
            continue;

        mc.dmWidth = ((ULONG)ptr[0] + 31) << 3;
        c = (ptr[1] >> 6 ) & 0x03;
        mc.dmHeight = mc.dmWidth * r2[c] / r1[c];
        mc.freq = (ULONG)(ptr[1] & 0x3F) + 60;

        numModeCaps = InsertModecapList(&mc, pModeCaps, numModeCaps);
    }

    // Detailed timing/Monitor Descriptor
    for (int k = 0; k < 4; k++)
    {
        ptr = &pEdid[0x36+ 18*k];
        if ((ptr[0] != 0 || ptr[1] != 0) && ptr[4] != 0)
        {
            // Detailed timing Descriptor
            mc.dmWidth = (ULONG)ptr[2] + ((ULONG)(ptr[4]&0xF0)) * 0x10;
            mc.dmHeight = (ULONG)ptr[5] + ((ULONG)(ptr[7]&0xF0)) * 0x10;
            if (mc.dmWidth == 0 || mc.dmHeight == 0)
                continue;

            mc.freq = ((ULONG)ptr[0] + ((ULONG)ptr[1]) * 0x100) * 10000;
            mc.freq /= (mc.dmWidth + (ULONG)ptr[3] + ((ULONG)(ptr[4]&0x0F)) * 0x100) *
                       (mc.dmHeight+ (ULONG)ptr[6] + ((ULONG)(ptr[7]&0x0F)) * 0x100);
            // If it's interlaced mode
            if (ptr[17] & 0x80)
                mc.freq >>= 1;

            numModeCaps = InsertModecapList(&mc, pModeCaps, numModeCaps);
        }
        else if (ptr[3] == 0xFA)
        {
            // Monitor Descriptor--Standard Timing
            for (i = 0, ptr += 5; i < 6; i++, ptr += 2)
            {
                if (*ptr == 0 || *ptr == 1)
                    continue;

                mc.dmWidth = ((ULONG)ptr[0] + 31) << 3;
                c = (ptr[1] >> 6 ) & 0x03;
                mc.dmHeight = mc.dmWidth * r2[c] / r1[c];
                mc.freq = (ULONG)(ptr[1] & 0x3F) + 60;

                numModeCaps = InsertModecapList(&mc, pModeCaps, numModeCaps);
            }
        }
        else if (ptr[3] == 0xFD)
        {
            pFrequencyRange->ulMinVerticalRate   = (ULONG)ptr[5];
            pFrequencyRange->ulMaxVerticalRate   = (ULONG)ptr[6];
            pFrequencyRange->ulMinHorizontalRate = ((ULONG)ptr[7]) * 1000;
            pFrequencyRange->ulMaxHorizontalRate = ((ULONG)ptr[8]) * 1000;
            pFrequencyRange->ulMinPixelClock     = 0;
            pFrequencyRange->ulMaxPixelClock     = ((ULONG)ptr[9]) * 10000000;
        }
    }

    for (i = (int)numModeCaps-2; i >= 0; i--)
    {
        if (pModeCaps[i].freq < pModeCaps[i+1].freq)
            pModeCaps[i].freq = pModeCaps[i+1].freq;
    }

    return numModeCaps;
}

ULONG GetMonitorCapability(PDEVICE_OBJECT pdo, LPMODECAP ModeCaps, PFREQUENCY_RANGE pFrequencyRange)
{
    BYTE     pBuffer[512], *pEdid;
    ULONG    numModeCaps = 0;

    //
    // Predefine monitor frequency limits in case we won't get it.
    //

    GetDefaultFrequencyRange(pFrequencyRange);

    numModeCaps = GetMonitorCapabilityFromInf(pdo, ModeCaps);

    if (numModeCaps)
    {
        pFrequencyRange->ulMinVerticalRate   = ModeCaps[0].MinVFreq;
        pFrequencyRange->ulMaxVerticalRate   = ModeCaps[0].freq;
        return numModeCaps;
    }
    else
    {
        TRACE_INIT(("Drv_Trace: GetMonitorCapabilityFromInf: Failed to retrieve Monitor inf\n"));
    }

    if (GetRegEDID(pdo, pBuffer, &pEdid) == 0)
    {
        TRACE_INIT(("Drv_Trace: GetMonitorCapability: Failed to get EDID capability\n"));
        return 0;
    }

    //
    // Check if EDID Version 2.
    //

    if (0x20 == pEdid[0])
    {
        return GetMonitorCapability2((PEDID2)pEdid, ModeCaps, pFrequencyRange);
    }

    //
    // Otherwise always assume it's EDID 1.x
    //

    return GetMonitorCapability1(pEdid, ModeCaps, pFrequencyRange);
}

BOOL PruneMode(PDEVMODEW pdm, LPMODECAP pModeCaps, int numModeCaps, PFREQUENCY_RANGE pMaxFreqs, ULONG flag)
{
    ULONG f, f1, freq = pdm->dmDisplayFrequency;
    BOOL bSwapWH = FALSE;

    if (pdm->dmFields & DM_DISPLAYORIENTATION)
    {
        if (pdm->dmDisplayOrientation == DMDO_90 ||
            pdm->dmDisplayOrientation == DMDO_270)
        {
            bSwapWH = TRUE;
        }
    }

    //
    // For Inf, MaxFreq = {56, 0xFFFFFFFF, 0, 0xFFFFFFFF, 0, 0xFFFFFFFF}
    // The following block only effective to EDID
    //
    if (freq > 1 && (flag & DISPLAY_DEVICE_PRUNE_FREQ))        // Non Driver-default frequency
    {
        if (freq < pMaxFreqs->ulMinVerticalRate)
        {
            return TRUE;
        }

        if (freq > pMaxFreqs->ulMaxVerticalRate && freq > 61)
        {
            return TRUE;
        }

        f = (LONG)(freq * pdm->dmPelsHeight);
        if (f < pMaxFreqs->ulMinHorizontalRate && freq < 60)
        {
            return TRUE;
        }
        if (f > pMaxFreqs->ulMaxHorizontalRate && freq > 61)
        {
            return TRUE;
        }
        //
        // ISSUE: We should check against MinPixelClock too. Fix in NT 5.1.
        //
        if ((pdm->dmPelsWidth*f) > pMaxFreqs->ulMaxPixelClock)
        {
            return TRUE;
        }

        // 1.05 is a fudge factor that corrects for vetical retrace time.
        // From Win98
        f1 = f * ((pdm->dmPelsHeight > 600) ? 107 : 105) / 100;
    }

    MODECAP mc = {bSwapWH ? pdm->dmPelsHeight : pdm->dmPelsWidth,
                  bSwapWH ? pdm->dmPelsWidth  : pdm->dmPelsHeight, freq};
    LPMODECAP pModeCap;

    // Found weird case of 1200x1600
    if (numModeCaps && (flag & DISPLAY_DEVICE_PRUNE_RESOLUTION))
    {
        if (mc.dmHeight > pModeCaps[numModeCaps-1].dmHeight)
            return TRUE;
    }
    for (int i = 0; i < numModeCaps; i++)
    {
        int comp = compModeCap(&mc, &pModeCaps[i]);
        if (comp > 0)
        {
            if (i >= (numModeCaps-1))
            {
                if (flag & DISPLAY_DEVICE_PRUNE_RESOLUTION) {
                    return TRUE;
                }
            }
            else
                continue;
        }

        if (freq > 1 && (flag & DISPLAY_DEVICE_PRUNE_FREQ))        // Non Driver-default frequency
        {
            pModeCap = (comp == 0 || i == 0) ? &pModeCaps[i] : &pModeCaps[i-1];

            if (freq > pModeCap->freq && freq > 61 && (comp == 0 || i > 0))
            {
                return TRUE;
            }

            //
            // For EDID, pModeCap = {width, height, freq, 56, 0, 0xFFFFFFFF}.
            // So the following block of code is only effective for INF
            //
            if (freq < pModeCap->MinVFreq)
            {
                return TRUE;
            }
            if (f1 < pModeCap->MinHFreq && freq < 60)
            {
                return TRUE;
            }
            // Sometimes the fulge value downgrades maximum freq below 60, which will lead
            // all modes not supported.  Freq 60 has to be supported
            if (f1 > pModeCap->MaxHFreq && freq > 61)
            {
                return TRUE;
            }
        }

        return FALSE;
    }

    return TRUE;
}

//
// Return Value
//      Number of effective modes
//
ULONG PruneModesByMonitors(PGRAPHICS_DEVICE PhysDisp, ULONG numRawModes, PDEVMODEMARK pdevmodeMarks)
{
    PULONG pNumModeCaps;
    ULONG i, numEffectiveModes;
    PMODECAP pModeCaps = NULL;
    FREQUENCY_RANGE MaxFreqs =
    {
        MIN_REFRESH_RATE,           // This is to prune out interlaced modes
        0xffffffff,
        0,
        0xffffffff,
        0,
        0xffffffff
    };

    PhysDisp->stateFlags &= ~DISPLAY_DEVICE_MODESPRUNED;

    if (PhysDisp->numMonitorDevice == 0)
        return numRawModes;

    pNumModeCaps = (PULONG) PALLOCMEM((MAX_MODE_CAPABILITY * sizeof(MODECAP) + sizeof(ULONG)) * PhysDisp->numMonitorDevice,
                                    GDITAG_DEVMODE);
    if (pNumModeCaps == NULL)
        return numRawModes;
    pModeCaps = (PMODECAP)((PBYTE)pNumModeCaps + sizeof(ULONG) * PhysDisp->numMonitorDevice);

    TRACE_INIT(("Drv_Trace: PruneModesByMonitors: Enter-- Number of raw modes=%d\n", numRawModes));

    UpdateMonitorDevices();
    numEffectiveModes = 0;
    for (i = 0; i < PhysDisp->numMonitorDevice; i++)
    {
        pNumModeCaps[i] = 0;
        if (IS_ATTACHED_ACTIVE(PhysDisp->MonitorDevices[i].flag))
        {
            FREQUENCY_RANGE freqs;

            pNumModeCaps[i] = GetMonitorCapability((PDEVICE_OBJECT)PhysDisp->MonitorDevices[i].pdo, pModeCaps, &freqs);
            if (pNumModeCaps[i] == 0)
            {
                TRACE_INIT(("Drv_Trace: GetMonitorCapability Failed for device %08lx\n", PhysDisp->MonitorDevices[i].pdo));
            }

            //
            // Intersect frequency ranges for all display devices.
            //

            MaxFreqs.ulMinVerticalRate   = max(MaxFreqs.ulMinVerticalRate,   freqs.ulMinVerticalRate);
            MaxFreqs.ulMaxVerticalRate   = min(MaxFreqs.ulMaxVerticalRate,   freqs.ulMaxVerticalRate);
            MaxFreqs.ulMinHorizontalRate = max(MaxFreqs.ulMinHorizontalRate, freqs.ulMinHorizontalRate);
            MaxFreqs.ulMaxHorizontalRate = min(MaxFreqs.ulMaxHorizontalRate, freqs.ulMaxHorizontalRate);
            MaxFreqs.ulMinPixelClock     = max(MaxFreqs.ulMinPixelClock,     freqs.ulMinPixelClock);
            MaxFreqs.ulMaxPixelClock     = min(MaxFreqs.ulMaxPixelClock,     freqs.ulMaxPixelClock);
        }
        pModeCaps += pNumModeCaps[i];
        numEffectiveModes += pNumModeCaps[i];
    }

    // If get nothing to prune
    if (numEffectiveModes == 0)
    {
        VFREEMEM(pNumModeCaps);
        return numRawModes;
    }

    numEffectiveModes = 0;
    for ( ; numRawModes > 0; numRawModes--)
    {
        PDEVMODEW pdevMode = pdevmodeMarks[numRawModes-1].pDevMode;

        TRACE_INIT(("Drv_Trace:  PruneMode  Width=%d, Height=%d, Freq=%d\n",
                   pdevMode->dmPelsWidth, pdevMode->dmPelsHeight, pdevMode->dmDisplayFrequency));

        pModeCaps = (PMODECAP)((PBYTE)pNumModeCaps + sizeof(ULONG) * PhysDisp->numMonitorDevice);
        for (i = 0; i < PhysDisp->numMonitorDevice; i++)
        {
            if (pNumModeCaps[i] == 0)
                continue;
            if (PruneMode(pdevMode, pModeCaps, pNumModeCaps[i], &MaxFreqs, PhysDisp->MonitorDevices[i].flag))
            {
                TRACE_INIT(("---Pruned\n"));
                pdevmodeMarks[numRawModes-1].bPruned = TRUE;
                PhysDisp->stateFlags |= DISPLAY_DEVICE_MODESPRUNED;
                break;
            }
            pModeCaps += pNumModeCaps[i];
        }
        if (i == PhysDisp->numMonitorDevice)
            numEffectiveModes++;
    }

    TRACE_INIT(("Drv_Trace: PruneModesByMonitors: Effective Mode Number=%d\n", numEffectiveModes));

    VFREEMEM(pNumModeCaps);

    return numEffectiveModes;
}

BOOL CalculateDefaultPreferredModeFromEdid(PDEVICE_OBJECT pdo, LPMODECAP pmc)
{
    //
    // Try to set our default preferred mode to 800x600x60
    // We try 60Hz only to prevent some crappy EDID from screwing the screen
    // right after Setup, for example, some external LCDs.
    //
    FREQUENCY_RANGE MaxFreqs;
    PMODECAP pModeCaps = (PMODECAP) PALLOCMEM(MAX_MODE_CAPABILITY * sizeof(MODECAP), GDITAG_DEVMODE);
    BOOL     bGotMode = FALSE;

    if (pModeCaps == NULL)
    {
        return FALSE;
    }

    ULONG NumModeCaps = GetMonitorCapability(pdo, pModeCaps, &MaxFreqs);

    if (NumModeCaps)
    {
        DEVMODEW dm;
        ULONG Freqs[] = {85, 82, 75, 72, 70, 60};

        pmc->dmWidth  = dm.dmPelsWidth  = 800 ;
        pmc->dmHeight = dm.dmPelsHeight = 600 ;

        for (ULONG i = 0; i < sizeof(Freqs)/sizeof(ULONG); i++)
        {
            pmc->freq = dm.dmDisplayFrequency = Freqs[i];
            if (!PruneMode(&dm, pModeCaps, NumModeCaps, &MaxFreqs, DISPLAY_DEVICE_PRUNE_FREQ | DISPLAY_DEVICE_PRUNE_RESOLUTION))
            {
                bGotMode = TRUE;
                break;
            }
        }
    }
    VFREEMEM(pModeCaps);

    if (!bGotMode) {
        return FALSE;
    }
        
    TRACE_INIT(("win32k!GetPreferredModeFromEdid1: Detailed timing %lux%lu at %luHz\n",
               pmc->dmWidth, pmc->dmHeight, pmc->freq));

    return TRUE;
}

BOOL CalculatePreferredModeFromEdid1 (PBYTE pEdid, PDEVICE_OBJECT pdo, LPMODECAP pmc)
{
    PBYTE ptr = &pEdid[0x36];
    ULONG count, area;

    //
    // If EDID has preferrred mode bit
    // This function calculates a preferred mode based on the data in
    // the first detailed timing block. If that data indicates that we can do
    // 800x600x85hz, return that as the preferred mode. Otherwise, just
    // return FALSE indicating that we should fall back to normal default
    // behavior.
    //
    // Otherwise
    // This function returns the preferred mode from the first detailed timing
    // block in the EDID.
    //

    for (count = 0; count < 4; count++) {
        ptr += count * 18;
        if ((ptr[0] != 0 || ptr[1] != 0) && ptr[4] != 0) {
            pmc->dmWidth = (ULONG) ptr[2] + ((ULONG)(ptr[4] & 0xF0)) * 0x10;
            pmc->dmHeight = (ULONG) ptr[5] + ((ULONG)(ptr[7] & 0xF0)) * 0x10 ;
            pmc->freq = ((ULONG)ptr[0] + ((ULONG)ptr[1]) * 0x100) * 10000;
            area = (pmc->dmWidth + (ULONG)ptr[3] + ((ULONG)(ptr[4]&0x0F)) * 0x100) *
                   (pmc->dmHeight+ (ULONG)ptr[6] + ((ULONG)(ptr[7]&0x0F)) * 0x100);
            if (area == 0) {
                ASSERT (FALSE);
                return FALSE;
            }
            pmc->freq /= area;
            if ((pEdid[0x18] & 0x02)) {
                TRACE_INIT(("win32k!GetPreferredModeFromEdid1: Detailed timing %lux%lu at %luHz\n",
                           pmc->dmWidth, pmc->dmHeight, pmc->freq));
                return TRUE;
            }
            else
            {
                break;
            }
        }
    }

    return CalculateDefaultPreferredModeFromEdid(pdo, pmc);
}


BOOL CalculatePreferredModeFromEdid2 (PEDID2 pEdid2, PDEVICE_OBJECT pdo, LPMODECAP pmc)
{
    ULONG  ulEdidOffset = EDID2_LUMINANCE_TABLE_OFFSET,
           count;

    //
    // No detailed timing block
    //
    if ((pEdid2->ucaMapOfTiming[1] & EDID2_MOT1_DETAIL_TIMING_MASK) == 0) {
        return FALSE;
    }

    PUCHAR pucLuminanceTable = (PUCHAR)pEdid2 + ulEdidOffset;

    //
    // Luminance Table
    //
    ulEdidOffset += (((*pucLuminanceTable & EDID2_LT0_SUB_CHANNELS_FLAG) ? 3 : 1) *
                     (*pucLuminanceTable & EDID2_LT0_ENTRIES_MASK) + 1);

    //
    // Frequency Ranges
    //
    ulEdidOffset += ((pEdid2->ucaMapOfTiming[0] & EDID2_MOT0_FREQUENCY_RANGE_MASK) >>
                     EDID2_MOT0_FREQUENCY_RANGE_SHIFT) *
                    sizeof (EDID2_FREQUENCY_RANGE);

    //
    // Detailed Range Limits
    //
    ulEdidOffset += ((pEdid2->ucaMapOfTiming[0] & EDID2_MOT0_DETAIL_TIMING_RANGE_MASK) >>
                     EDID2_MOT0_DETAIL_TIMING_RANGE_SHIFT) *
                    sizeof(EDID2_DETAIL_TIMING_RANGE);

    //
    // Timing Codes
    //
    ulEdidOffset += ((pEdid2->ucaMapOfTiming[1] & EDID2_MOT1_TIMING_CODE_MASK) >>
                     EDID2_MOT1_TIMING_CODE_SHIFT) *
                    sizeof(EDID2_TIMING_CODE);

    ULONG ulNumberOfDetailTimings = (pEdid2->ucaMapOfTiming[1] & EDID2_MOT1_DETAIL_TIMING_MASK) >>
                                    EDID2_MOT1_DETAIL_TIMING_SHIFT;
    for (count = 0; count < ulNumberOfDetailTimings; count++)
    {
        ulEdidOffset += count*sizeof(EDID2_DETAIL_TIMING);
        if ((ulEdidOffset + sizeof(EDID2_DETAIL_TIMING)) >= sizeof (EDID2))
        {
            ASSERT(FALSE);
            return FALSE;
        }

        PEDID2_DETAIL_TIMING pDetailTiming = (PEDID2_DETAIL_TIMING)((PUCHAR)pEdid2 + ulEdidOffset);

        pmc->dmWidth = ((ULONG)(pDetailTiming->ucHorizontalHighBits & 0xf0) << 4) +
                       pDetailTiming->ucHorizontalActiveLowByte;

        pmc->dmHeight = ((ULONG)(pDetailTiming->ucVerticalHighBits & 0xf0) << 4) +
                        pDetailTiming->ucVerticalActiveLowByte;

        ULONG ulHorizontalTotal = ((ULONG)(pDetailTiming->ucHorizontalHighBits & 0x0f) << 8) +
                                  pDetailTiming->ucHorizontalBlankLowByte + pmc->dmWidth;

        ULONG ulVerticalTotal = ((ULONG)(pDetailTiming->ucVerticalHighBits & 0x0f) << 8) +
                                pDetailTiming->ucVerticalBlankLowByte + pmc->dmHeight;

        //
        // Make sure we won't divide by zero in case of bad EDID.
        //
        if ((0 == ulHorizontalTotal) || (0 == ulVerticalTotal))
        {
            ASSERT(FALSE);
            return FALSE;
        }

        //
        // Calculate refresh rate rounding to the nearest integer.
        //

        pmc->freq = ((((ULONG)(pDetailTiming->usPixelClock) * 100000) / (ulHorizontalTotal * ulVerticalTotal)) + 5) / 10;

        if (pDetailTiming->ucFlags & EDID2_DT_INTERLACED) {
            pmc->freq /= 2;
        }

        if (pEdid2->ucaMapOfTiming[0] & EDID2_MOT0_PREFFERED_MODE_FLAG)
        {
            TRACE_INIT(("win32k!GetPreferredModeFromEdid2: Detailed timing %lux%lu at %luHz\n",
                       pmc->dmWidth, pmc->dmHeight, pmc->freq));
            return TRUE;
        }
        else
        {
            break;
        }
    }

    return CalculateDefaultPreferredModeFromEdid(pdo, pmc);
}

BOOL GetPreferredModeFromEdid(PDEVICE_OBJECT pdo, LPMODECAP pmc)
{
    BYTE    pBuffer[512], *pEdid;
    if (!GetRegEDID(pdo, pBuffer, &pEdid))
        return FALSE;

    //
    // It's EDID2
    //
    if (0x20 == pEdid[0]) {
        return CalculatePreferredModeFromEdid2((PEDID2)pEdid, pdo, pmc);
    }

    if (pEdid[0] != 0 || pEdid[7] != 0) {
        return FALSE;
    }

    for (int i = 1; i < 7; i++)
    {
        if (pEdid[i] != 0xFF)
            return FALSE;
    }

    return (CalculatePreferredModeFromEdid1 (pEdid, pdo, pmc));
}

/***************************************************************************\
* DrvGetPreferredMode
*
* Routine that returns the prefered mode.
*
\***************************************************************************/

NTSTATUS
DrvGetPreferredMode(
    LPDEVMODEW       lpDevMode,
    PGRAPHICS_DEVICE PhysDisp
    )
{
    NTSTATUS retval = STATUS_INVALID_PARAMETER_1;
    DWORD    iModeNum;

    ASSERTGDI((lpDevMode != NULL), "Invalid lpDevMode\n");
    ASSERTGDI((PhysDisp != NULL), "Invalid PhysDisp\n");

    UpdateMonitorDevices();
    lpDevMode->dmPelsWidth = lpDevMode->dmPelsHeight = lpDevMode->dmDisplayFrequency = 0x7FFF;

    for (iModeNum = 0; iModeNum < PhysDisp->numMonitorDevice; iModeNum++)
    {
        if (IS_ATTACHED_ACTIVE(PhysDisp->MonitorDevices[iModeNum].flag))
        {
            MODECAP mc;
            if (!GetValuesFromInf((PDEVICE_OBJECT)PhysDisp->MonitorDevices[iModeNum].pdo, 0, &mc))
            {
                if (!GetPreferredModeFromEdid((PDEVICE_OBJECT)PhysDisp->MonitorDevices[iModeNum].pdo, &mc))
                {
                    lpDevMode->dmDisplayFrequency = 60;
                    continue;
                }
            }
            //
            // To be safe, always pick the smaller refresh rate
            //
            if (mc.freq < lpDevMode->dmDisplayFrequency)
                lpDevMode->dmDisplayFrequency = mc.freq;

            if (mc.dmWidth > lpDevMode->dmPelsWidth)
                continue;
            if (mc.dmWidth == lpDevMode->dmPelsWidth &&
                mc.dmHeight > lpDevMode->dmPelsHeight)
                continue;

            lpDevMode->dmPelsWidth = mc.dmWidth;
            lpDevMode->dmPelsHeight = mc.dmHeight;
            lpDevMode->dmFields = DM_PELSWIDTH | DM_PELSHEIGHT | DM_DISPLAYFREQUENCY;
        }
    }

    if (lpDevMode->dmPelsWidth == 0x7FFF)
        retval = STATUS_INVALID_PARAMETER_3;
    else
        retval = STATUS_SUCCESS;

    return retval;
}

/***************************************************************************\
* DrvBuildDevmodeList
*
* Builds the list of DEVMODEs for a particular GRAPHICS_DEVICE structure
*
* CRIT must be held before this call is made.
*
* History:
* 10-Mar-1996   andreva     Created.
\***************************************************************************/

VOID
DrvBuildDevmodeList(
    PGRAPHICS_DEVICE PhysDisp,
    BOOL bUpdateCache)
{
    GDIFunctionID(DrvBuildDevmodeList);

    ULONG      i, j;
    PDRV_NAMES lpNames = NULL;
    DWORD      cbOutputSize;
    LPDEVMODEW tmpBuffer;
    PUCHAR     reallocBuffer;


    //
    // check if the information is cached already
    // if not, then get the information from the drivers.
    //
    // NOTE : we may want to synchronize access to this list
    // of modes so that we can dynamically update the list
    // when plug - and - play arrives.
    //
    // NOTE : the list of text modes is built at boot time, and we depend
    // on that list being valid if the PhysDisp is returned.
    // see DrvInitConsole().
    //

    TRACE_INIT(("Drv_Trace: BuildDevmode: Enter"));

    // If HYDRA Remote session we don't want to cache the mode as
    // we can be in a reconnect with a different resolution.
    // It these case the driver's only mode has changed so
    // we want to query him to get latest valid mode
    //
    // bUpdateCache = TRUE only when display switching occured.  At this time,
    // we need to update mode list
    //

    if ((PhysDisp->stateFlags & DISPLAY_DEVICE_REMOTE) || bUpdateCache)
    {
       if ( (PhysDisp != &gFullscreenGraphicsDevice) &&
            ( (PhysDisp->cbdevmodeInfo != 0) && (PhysDisp->devmodeInfo != NULL)) )
       {
          if (PhysDisp->devmodeInfo)
          {
             VFREEMEM(PhysDisp->devmodeInfo);
             PhysDisp->devmodeInfo = NULL;
          }
          PhysDisp->cbdevmodeInfo = 0;
          if (PhysDisp->devmodeMarks)
          {
             VFREEMEM(PhysDisp->devmodeMarks);
             PhysDisp->devmodeMarks = NULL;
          }
       }
    }

    if ( (PhysDisp != &gFullscreenGraphicsDevice) &&
         (PhysDisp->cbdevmodeInfo == 0)           &&
         (PhysDisp->devmodeInfo == NULL) )
    {
        TRACE_INIT(("\nDrv_Trace: BuildDevmode: Rebuild List\n"));

        PhysDisp->numRawModes = 0;

        lpNames = DrvGetDisplayDriverNames(PhysDisp);

        if (lpNames)
        {
            for (i = 0; i < lpNames->cNames; i++)
            {

                cbOutputSize = ldevGetDriverModes(lpNames->D[i].lpDisplayName,
                                                  lpNames->D[i].hDriver,
                                                  &tmpBuffer);

                if (cbOutputSize)
                {
                    //
                    // create a new buffer copy the old data into it
                    // and append the new data at the end - we want
                    // a continuous buffer for all the data.
                    //

                    reallocBuffer = (PUCHAR) PALLOCNOZ(PhysDisp->cbdevmodeInfo + cbOutputSize,
                                                       GDITAG_DRVSUP);

                    if (reallocBuffer)
                    {
                        if (PhysDisp->cbdevmodeInfo)
                        {
                            //
                            // Copy the contents of the old buffer
                            // and free it
                            //

                            RtlCopyMemory(reallocBuffer,
                                          PhysDisp->devmodeInfo,
                                          PhysDisp->cbdevmodeInfo);

                            VFREEMEM(PhysDisp->devmodeInfo);
                        }

                        RtlCopyMemory(reallocBuffer +
                                          PhysDisp->cbdevmodeInfo,
                                      tmpBuffer,
                                      cbOutputSize);

                        PhysDisp->cbdevmodeInfo += cbOutputSize;
                        PhysDisp->devmodeInfo = (PDEVMODEW) reallocBuffer;
                    }
                    else
                    {
                        WARNING("failed realloc\n");
                    }
                }
                else
                {
                    WARNING("display driver not present\n");
                }

                if (tmpBuffer) {
                    VFREEMEM(tmpBuffer);
                }
            }

            VFREEMEM(lpNames);
        }

        if ( (PhysDisp->cbdevmodeInfo == 0) &&
             (PhysDisp->devmodeInfo == NULL) )
        {
            DrvLogDisplayDriverEvent(MsgInvalidDisplayDriver);
        }
        else
        {
            PDEVMODEW lpdm, lpdm1;
            for (i = 0, cbOutputSize = 0; cbOutputSize < PhysDisp->cbdevmodeInfo; i++)
            {
                lpdm = (LPDEVMODEW)(((LPBYTE)PhysDisp->devmodeInfo) + cbOutputSize);
                cbOutputSize += lpdm->dmSize + lpdm->dmDriverExtra;
            }

            PhysDisp->devmodeMarks = (PDEVMODEMARK)PALLOCMEM(i * sizeof(DEVMODEMARK),
                                                             GDITAG_DRVSUP);
            if (PhysDisp->devmodeMarks == NULL)
            {
                PhysDisp->cbdevmodeInfo = 0;
                VFREEMEM(PhysDisp->devmodeInfo);
                PhysDisp->devmodeInfo = NULL;
                WARNING("failed allocate lookside list\n");
                DrvLogDisplayDriverEvent(MsgInvalidDisplayDriver);
            }
            else
            {
                PhysDisp->numRawModes = i;
                for (i = 0, cbOutputSize = 0; cbOutputSize < PhysDisp->cbdevmodeInfo; i++)
                {
                    lpdm = (LPDEVMODEW)(((LPBYTE)PhysDisp->devmodeInfo) + cbOutputSize);

                    // jasonha 07/13/2001 Display Orientation Support
                    if (!(lpdm->dmFields & DM_DISPLAYORIENTATION))
                    {
                        lpdm->dmFields |= DM_DISPLAYORIENTATION;
                        if (lpdm->dmDisplayOrientation != 0)
                        {
                            WARNING("driver reported non-zero dmDisplayOrientation, but not DM_DISPLAYORIENTATION flag.\n");
                        }
                        lpdm->dmDisplayOrientation = DMDO_DEFAULT;
                    }
                    else if (lpdm->dmDisplayOrientation > DMDO_LAST)
                    {
                        WARNING("driver reported invalid dmDisplayOrientation.\n");
                        lpdm->dmDisplayOrientation = DMDO_DEFAULT;
                    }

                    // jasonha 09/17/2001 Display Fixed Output Support
                    if (!(lpdm->dmFields & DM_DISPLAYFIXEDOUTPUT))
                    {
                        if (lpdm->dmDisplayFixedOutput != 0)
                        {
                            WARNING("driver reported non-zero dmDisplayFixedOutput, but not DM_DISPLAYFIXEDOUTPUT flag.\n");
                        }
                        lpdm->dmDisplayFixedOutput = DMDFO_DEFAULT;
                    }
                    else if (lpdm->dmDisplayFixedOutput == DMDFO_DEFAULT ||
                             lpdm->dmDisplayFixedOutput > DMDFO_LAST)
                    {
                        WARNING("driver reported invalid dmDisplayFixedOutput.\n");
                        lpdm->dmFields &= ~DM_DISPLAYFIXEDOUTPUT;
                        lpdm->dmDisplayFixedOutput = DMDFO_DEFAULT;
                    }

                    PhysDisp->devmodeMarks[i].bPruned = FALSE;
                    PhysDisp->devmodeMarks[i].pDevMode = lpdm;
                    cbOutputSize += lpdm->dmSize + lpdm->dmDriverExtra;
                }

                // 11/26/98 Ignore miniport default refresh rate
                // But if the default rate is the only mode in the list, we still keep it
                // For example, VGA and mnmdd
                for (i = 1; i <= PhysDisp->numRawModes; i++)
                {
                    lpdm = PhysDisp->devmodeMarks[i-1].pDevMode;
                    if (lpdm->dmDisplayFrequency == 1)
                    {
                        for (j = 1; j <= PhysDisp->numRawModes; j++)
                        {
                            if (j == i)
                                continue;
                            lpdm1 = PhysDisp->devmodeMarks[j-1].pDevMode;
                            if (lpdm->dmBitsPerPel != lpdm1->dmBitsPerPel)
                                continue;
                            if (lpdm->dmPelsWidth != lpdm1->dmPelsWidth)
                                continue;
                            if (lpdm->dmPelsHeight != lpdm1->dmPelsHeight)
                                continue;
                            if ((lpdm->dmDisplayFlags & DMDISPLAYFLAGS_TEXTMODE) !=
                                (lpdm1->dmDisplayFlags & DMDISPLAYFLAGS_TEXTMODE))
                                continue;
                            if (lpdm->dmDisplayOrientation != lpdm1->dmDisplayOrientation)
                                continue;
                            if (lpdm->dmDisplayFixedOutput != lpdm1->dmDisplayFixedOutput)
                                continue;
                            // We find a duplicated mode, so cut off this mode
                            if (PhysDisp->numRawModes > i)
                                RtlMoveMemory(&PhysDisp->devmodeMarks[i-1],
                                              &PhysDisp->devmodeMarks[i],
                                              sizeof(DEVMODEMARK) * (PhysDisp->numRawModes-i));
                            PhysDisp->numRawModes--;
                            i--;
                            break;
                        }
                    }
                }

                if ((PhysDisp->stateFlags & DISPLAY_DEVICE_REMOTE) == 0 &&
                    (PhysDisp->stateFlags & DISPLAY_DEVICE_DISCONNECT) == 0 &&
                    (PhysDisp->stateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER) == 0)
                    cbOutputSize = PruneModesByMonitors(PhysDisp, PhysDisp->numRawModes, PhysDisp->devmodeMarks);

                if (cbOutputSize == 0)
                    DrvLogDisplayDriverEvent(MsgInvalidDisplayDriver);

                //
                // Expand all 32bpp modes to double the effective dots-per-inch.
                // Panning.cxx handles the actual downsizing.
                //

                if (G_fDoubleDpi)
                {
                    for (i = 0, cbOutputSize = 0; cbOutputSize < PhysDisp->cbdevmodeInfo; i++)
                    {
                        lpdm = (LPDEVMODEW)(((LPBYTE)PhysDisp->devmodeInfo) + cbOutputSize);
                        if (lpdm->dmBitsPerPel == 32)
                        {
                            lpdm->dmPelsWidth *= 2;
                            lpdm->dmPelsHeight *= 2;
                        }
                        cbOutputSize += lpdm->dmSize + lpdm->dmDriverExtra;
                    }
                }
            }
        }
    }
    else
    {
        TRACE_INIT((" - Use cache"));
    }

    TRACE_INIT((" - Exit\n"));

    return;
}

#define DIFF(x, y) ( ((x) >= (y)) ? ((x)-(y)) : ((y)-(x)) )

// Orientation Difference Table
//  Table lookup returns matching level for two dmDisplayOrientation values.
//  Lower number mean a better match.
//    Exact match     => 0
//    180 rotation    => 1
//    90/270 rotation => 2

DWORD dwOrientationDiffTable[4][4] = {
    { 0, 2, 1, 2},
    { 2, 0, 2, 1},
    { 1, 2, 0, 2},
    { 2, 1, 2, 0}
};

#define ORIENTATION_DIFF(x, y) dwOrientationDiffTable[y][x]

LPDEVMODEW GetClosestMode(PGRAPHICS_DEVICE PhysDisp, LPDEVMODEW pOrgDevMode, BOOL bPrune)
{
    DEVMODEW diffMode;
    LPDEVMODEW lpdm, lpModePicked = NULL, lpModeWanted = NULL;
    ULONG diff;

    diffMode.dmBitsPerPel = 0xFFFFFFFF;
    diffMode.dmPelsWidth  = 0xFFFFFFFF;
    diffMode.dmPelsHeight = 0xFFFFFFFF;
    diffMode.dmDisplayFrequency = 0xFFFFFFFF;
    diffMode.dmDisplayOrientation = 0xFFFFFFFF;
    diffMode.dmDisplayFixedOutput = 0xFFFFFFFF;

    if (pOrgDevMode->dmDisplayFrequency == 0)
        pOrgDevMode->dmDisplayFrequency = 60;
    if (pOrgDevMode->dmBitsPerPel == 0)
        pOrgDevMode->dmBitsPerPel = 32;
    if ( !(pOrgDevMode->dmFields & DM_DISPLAYORIENTATION) )
        pOrgDevMode->dmDisplayOrientation = DMDO_DEFAULT;
    if ( !(pOrgDevMode->dmFields & DM_DISPLAYFIXEDOUTPUT) )
        pOrgDevMode->dmDisplayFixedOutput = DMDFO_DEFAULT;


    //
    // Do 2 rounds of search.
    //   First round, only find smaller or exact mode.  Done if exact match.
    //   Second round is used done if:
    //     Orientation doesn't match or
    //     Mode is smalller than 640x480x60  (480x640x60 for rotated modes)
    //
    for (ULONG k = 0; k < 2; k++)
    {
        if (lpModeWanted &&
            diffMode.dmDisplayOrientation == 0 &&
            ((lpModeWanted->dmPelsWidth >= lpModeWanted->dmPelsHeight) ?
             (lpModeWanted->dmPelsWidth >= 640 &&
              lpModeWanted->dmPelsHeight>= 480) :
             (lpModeWanted->dmPelsWidth >= 480 &&
              lpModeWanted->dmPelsHeight>= 640)) &&
            lpModeWanted->dmDisplayFrequency >= 60)
        {
            break;
        }
        
        for (ULONG i = 0; i < PhysDisp->numRawModes; i++)
        {
            if (bPrune && PhysDisp->devmodeMarks[i].bPruned)
                continue;
            lpdm = PhysDisp->devmodeMarks[i].pDevMode;

            if (pOrgDevMode->dmFields & DM_DISPLAYORIENTATION)
            {
                diff = ORIENTATION_DIFF(pOrgDevMode->dmDisplayOrientation, lpdm->dmDisplayOrientation);

                if (diffMode.dmDisplayOrientation < diff) continue;

                if (diffMode.dmDisplayOrientation > diff)
                {
                    lpModePicked = lpdm;
                }
            }

            if (pOrgDevMode->dmPelsWidth && lpModePicked != lpdm)
            {
                diff = DIFF(pOrgDevMode->dmPelsWidth, lpdm->dmPelsWidth);
                if (diffMode.dmPelsWidth < diff)
                    continue;
                else if (diffMode.dmPelsWidth > diff)
                {
                    lpModePicked = lpdm;
                }
            }
            if (pOrgDevMode->dmPelsHeight && lpModePicked != lpdm)
            {
                diff = DIFF(pOrgDevMode->dmPelsHeight, lpdm->dmPelsHeight);
                if (diffMode.dmPelsHeight < diff)
                    continue;
                else if (diffMode.dmPelsHeight > diff)
                {
                    lpModePicked = lpdm;
                }
            }
            if (lpModePicked != lpdm)
            {
                diff = DIFF(pOrgDevMode->dmBitsPerPel, lpdm->dmBitsPerPel);
                if (diffMode.dmBitsPerPel < diff)
                    continue;
                else if (diffMode.dmBitsPerPel > diff)
                {
                    lpModePicked = lpdm;
                }
            }
            if (lpModePicked != lpdm)
            {
                diff = (pOrgDevMode->dmDisplayFixedOutput != lpdm->dmDisplayFixedOutput) ? 1 : 0;
                if (diffMode.dmDisplayFixedOutput < diff)
                    continue;
                else if (diffMode.dmDisplayFixedOutput > diff)
                {
                    lpModePicked = lpdm;
                }
            }
            if (lpModePicked != lpdm)
            {
                diff = DIFF(pOrgDevMode->dmDisplayFrequency, lpdm->dmDisplayFrequency);
                if (diffMode.dmDisplayFrequency < diff)
                    continue;
                else if (diffMode.dmDisplayFrequency > diff)
                {
                    lpModePicked = lpdm;
                }
            }

            // continue if we haven't found a better match
            if (lpModePicked != lpdm)
                continue;

            if (k == 0)
            {
                // skip larger or higher frequency modes (first round only)
                if (lpModePicked->dmPelsWidth  > pOrgDevMode->dmPelsWidth &&
                    pOrgDevMode->dmPelsWidth)
                    continue;
                if (lpModePicked->dmPelsHeight > pOrgDevMode->dmPelsHeight &&
                    pOrgDevMode->dmPelsHeight != 0)
                    continue;
                if (lpModePicked->dmDisplayFrequency > pOrgDevMode->dmDisplayFrequency)
                    continue;
            }
            
            lpModeWanted = lpModePicked;
            diffMode.dmDisplayOrientation = ORIENTATION_DIFF(pOrgDevMode->dmDisplayOrientation, lpdm->dmDisplayOrientation);
            diffMode.dmPelsWidth  = DIFF(pOrgDevMode->dmPelsWidth, lpdm->dmPelsWidth);
            diffMode.dmPelsHeight = DIFF(pOrgDevMode->dmPelsHeight, lpdm->dmPelsHeight);
            diffMode.dmBitsPerPel = DIFF(pOrgDevMode->dmBitsPerPel, lpdm->dmBitsPerPel);
            diffMode.dmDisplayFixedOutput = (pOrgDevMode->dmDisplayFixedOutput != lpdm->dmDisplayFixedOutput) ? 1 : 0;
            diffMode.dmDisplayFrequency = DIFF(pOrgDevMode->dmDisplayFrequency, lpdm->dmDisplayFrequency);
            
            if (diffMode.dmDisplayOrientation == 0 &&
                diffMode.dmBitsPerPel == 0 &&
                diffMode.dmPelsWidth  == 0 &&
                diffMode.dmPelsHeight == 0 &&
                diffMode.dmDisplayFixedOutput == 0 &&
                diffMode.dmDisplayFrequency == 0)
                break;
        }
    }

#if DBG
    if (lpModeWanted == NULL)
    {
        WARNING("Drv_Trace: GetClosestMode: The PhysDisp driver has Zero mode\n");
    }
#endif

    return lpModeWanted;
}

/***************************************************************************\
* ProbeAndCaptureDevmode
*
* Maps a partial DEVMODE (for example, may only contain width and height)
* to a complete DEVMODE that the kernel routines will like.
*
* CRIT need not be held when calling.
*
* History:
* 10-Mar-1996   andreva     Created.
\***************************************************************************/

NTSTATUS
DrvProbeAndCaptureDevmode(
    PGRAPHICS_DEVICE PhysDisp,
    PDEVMODEW *DestinationDevmode,
    BOOL      *bDetach,
    PDEVMODEW SourceDevmode,
    BOOL      bDefaultMode,
    MODE      PreviousMode,
    BOOL      bPrune,
    BOOL      bClosest,
    BOOL      bFromMonitor
    )
{
    NTSTATUS  ntRet = STATUS_UNSUCCESSFUL;
    BOOL      bRet = FALSE;
    BOOL      btmpError;
    ULONG     sourceSize;
    ULONG     sourceSizeExtra;
    ULONG     sizeExtra;
    PDEVMODEW matchedDevmode = NULL;
    PDEVMODEW partialDevmode;

    DWORD     tmpDisplayFlags = 0;
    DWORD     tmpPanningWidth = 0;
    DWORD     tmpPanningHeight = 0;
    DWORD     tmpPositionX = 0;
    DWORD     tmpPositionY = 0;
    BOOL      tmpPosition;
    BOOL      bOrientationSpecified = FALSE;
    BOOL      bFixedOutputSpecified = FALSE;


    TRACE_INIT(("Drv_Trace: CaptMatchDevmode: Entering\n"));

    *DestinationDevmode = NULL;
    *bDetach            = FALSE;


    if (SourceDevmode == NULL)
    {
        TRACE_INIT(("Drv_Trace: CaptMatchDevmode: Exit DEVMODE NULL\n\n"));
        return STATUS_SUCCESS;
    }

    TRACE_INIT(("\n"));
    TRACE_INIT(("    pDevMode %08lx\n", SourceDevmode));

    partialDevmode = (PDEVMODEW) PALLOCNOZ(sizeof(DEVMODEW) + MAXUSHORT,
                                           GDITAG_DEVMODE);

    if (partialDevmode == NULL)
    {
        TRACE_INIT(("Drv_Trace: CaptMatchDevmode: Could not allocate partial DEVMODE\n\n"));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Put everything in a try except so we can always reference the original
    // passed in structure.
    //

    __try
    {
        if (PreviousMode == UserMode)
        {
            ProbeForRead(SourceDevmode,
                         FIELD_OFFSET(DEVMODEW, dmFields),
                         sizeof(DWORD));
        }
        else
        {
            ASSERTGDI(SourceDevmode >= (PDEVMODEW const)MM_USER_PROBE_ADDRESS,
                      "Bad kernel mode address\n");
        }

        //
        // Capture these so that they don't change right after the probe.
        //

        sourceSize      = SourceDevmode->dmSize;
        sourceSizeExtra = SourceDevmode->dmDriverExtra;

        if (PreviousMode == UserMode)
        {
            ProbeForRead(SourceDevmode,
                         sourceSize + sourceSizeExtra,
                         sizeof(DWORD));
        }

        dbgDumpDevmode(SourceDevmode);

        if (SourceDevmode->dmFields == 0)
            bClosest = TRUE;

        //
        // At the introduction time of this API, the DEVMODE already contained
        // up to the dmDisplayFrequency field.  We will fail is the DEVMODE is
        // smaller than that.
        //

        if (sourceSize >= FIELD_OFFSET(DEVMODEW, dmICMMethod))
        {
            //
            // Determine if the position reflects a detach operation
            //
            // If the size of the rectangle is NULL, that means the device
            // needs to be detached from the desktop.
            //

            if ((SourceDevmode->dmFields & DM_POSITION)   &&
                (SourceDevmode->dmFields & DM_PELSWIDTH)  &&
                (SourceDevmode->dmPelsWidth == 0)         &&
                (SourceDevmode->dmFields & DM_PELSHEIGHT) &&
                (SourceDevmode->dmPelsHeight == 0))
            {
                *bDetach = TRUE;
                VFREEMEM(partialDevmode);
                return STATUS_SUCCESS;
            }

            //
            // Lets build a temporary DEVMODE that will contain the
            // "wished for" DEVMODE, based on matching from the registry.
            // Only match the basic devmode.  Other fields (optional ones
            // will be added later)
            //
            // NOTE special case VGA mode so that we don't try to match to the
            // current screen mode.
            //

            RtlZeroMemory(partialDevmode, sizeof(DEVMODEW));
            partialDevmode->dmSize = 0xDDDD;
            partialDevmode->dmDriverExtra = MAXUSHORT;

            if (PhysDisp == &gFullscreenGraphicsDevice)
            {
                //
                // We should never get called to probe the fullscreen modes
                // since they are only called by the console
                //

                ASSERTGDI(FALSE, "ProbeAndCaptureDEVMODE called with VGA device\n");
                VFREEMEM(partialDevmode);
                return STATUS_UNSUCCESSFUL;
            }
            else if (bDefaultMode)
            {
                //
                // We just want to pick the default mode from the driver.
                //
                // Leave the partial DEVMODE with all NULLs
                //

                DrvGetDisplayDriverParameters(PhysDisp,
                                              partialDevmode,
                                              TRUE,
                                              bFromMonitor);
            }
            else
            {
                if (!NT_SUCCESS(DrvGetDisplayDriverParameters(PhysDisp,
                                                              partialDevmode,
                                                              gbBaseVideo,
                                                              bFromMonitor)))
                {
                    partialDevmode->dmDriverExtra = 0;

                    /*
                     * If the above should fail (it seemed to under low memory conditions),
                     * then we'd better have a valid size or the following memory copies
                     * will be wrong.
                     */
                    partialDevmode->dmSize = sizeof(DEVMODEW);

                    // if (G_TERM(pDispInfo)->hdcScreen)
                    // {
                    //    //
                    //    // Use the caps as a guess for this.
                    //    //
                    //
                    //    WARNING("Drv_Trace: CaptMatchDevmode: Could not get current devmode\n");
                    //
                    //    partialDevmode->dmBitsPerPel =
                    //        GreGetDeviceCaps(G_TERM(pDispInfo)->hdcScreen, BITSPIXEL) *
                    //        GreGetDeviceCaps(G_TERM(pDispInfo)->hdcScreen, PLANES);
                    //    partialDevmode->dmPelsWidth  =
                    //        GreGetDeviceCaps(G_TERM(pDispInfo)->hdcScreen, HORZRES);
                    //    partialDevmode->dmPelsHeight =
                    //        GreGetDeviceCaps(G_TERM(pDispInfo)->hdcScreen, VERTRES);
                    //    partialDevmode->dmDisplayFrequency =
                    //        GreGetDeviceCaps(G_TERM(pDispInfo)->hdcScreen, VREFRESH);
                    // }
                }

                if ((SourceDevmode->dmFields & DM_BITSPERPEL) &&
                    (SourceDevmode->dmBitsPerPel != 0))
                {
                    partialDevmode->dmBitsPerPel = SourceDevmode->dmBitsPerPel;
                }

                if ((SourceDevmode->dmFields & DM_PELSWIDTH) &&
                    (SourceDevmode->dmPelsWidth != 0))
                {
                    partialDevmode->dmPelsWidth = SourceDevmode->dmPelsWidth;
                }

                if ((SourceDevmode->dmFields & DM_PELSHEIGHT) &&
                    (SourceDevmode->dmPelsHeight != 0))
                {
                    partialDevmode->dmPelsHeight = SourceDevmode->dmPelsHeight;
                }

                if ((SourceDevmode->dmFields & DM_DISPLAYFREQUENCY) &&
                    (SourceDevmode->dmDisplayFrequency != 0))
                {
                    partialDevmode->dmDisplayFrequency = SourceDevmode->dmDisplayFrequency;
                }
                else
                {
                    //
                    // Only use the registry refresh rate if we are going
                    // down in resolution.  If we are going up in resolution,
                    // we will want to pick the lowest refresh rate that
                    // makes sense.
                    //
                    // The exception to this is if we have resetting the mode
                    // to the regsitry mode (passing in all 0's), in which case
                    // we want exactly what is in the registry.
                    //

                    if ( ((SourceDevmode->dmPelsWidth != 0)  ||
                          (SourceDevmode->dmPelsHeight != 0)) )
                    {
                        partialDevmode->dmDisplayFrequency = 0;
                    }
                }
            }

            btmpError = FALSE;

            //
            // These fields are somewhat optional.
            // We capture them if they are valid.  Otherwise, they will
            // be initialized back to zero.
            //

            //
            // Pick whichever set of flags we can.  Source is first choice,
            // registry is second.
            //

            if (SourceDevmode->dmFields & DM_DISPLAYFLAGS)
            {
                if (SourceDevmode->dmDisplayFlags & (~DMDISPLAYFLAGS_VALID))
                {
                    btmpError = TRUE;
                }
                tmpDisplayFlags = SourceDevmode->dmDisplayFlags;
            }
            else if ((partialDevmode->dmFields & DM_DISPLAYFLAGS) &&
                       (partialDevmode->dmDisplayFlags &
                            (~DMDISPLAYFLAGS_VALID)))
            {
                tmpDisplayFlags = partialDevmode->dmDisplayFlags;
            }

            //
            // If the caller specified panning keep the value, unless it was
            // bigger than the resolution, which is an error.
            //
            // Otherwise, use the value from the registry if it makes sense
            // (i.e. panning is still smaller than the resolution).
            //

            if ((SourceDevmode->dmFields & DM_PANNINGWIDTH) &&
                (SourceDevmode->dmFields & DM_PANNINGHEIGHT))
            {
                if ((SourceDevmode->dmPanningWidth > partialDevmode->dmPelsWidth) ||
                    (SourceDevmode->dmPanningHeight > partialDevmode->dmPelsHeight))
                {
                    btmpError = TRUE;
                }
                tmpPanningWidth = SourceDevmode->dmPanningWidth;
                tmpPanningHeight = SourceDevmode->dmPanningHeight;
            }
            else if ((partialDevmode->dmFields & DM_PANNINGWIDTH)  &&
                     (partialDevmode->dmFields & DM_PANNINGHEIGHT) &&
                     (partialDevmode->dmPanningHeight < partialDevmode->dmPelsHeight) &&
                     (partialDevmode->dmPanningWidth < partialDevmode->dmPelsWidth))
            {
                tmpPanningWidth = partialDevmode->dmPanningWidth;
                tmpPanningHeight = partialDevmode->dmPanningHeight;
            }

            //
            // Check the orientation.
            //

            if (SourceDevmode->dmFields & DM_DISPLAYORIENTATION)
            {
                bOrientationSpecified = TRUE;
                partialDevmode->dmDisplayOrientation = SourceDevmode->dmDisplayOrientation;

                if (SourceDevmode->dmDisplayOrientation > DMDO_LAST)
                {
                    btmpError = TRUE;
                }
            }

            //
            // Check fixed output mode.
            //

            if (SourceDevmode->dmFields & DM_DISPLAYFIXEDOUTPUT)
            {
                partialDevmode->dmDisplayFixedOutput = SourceDevmode->dmDisplayFixedOutput;

                // DMDFO_DEFAULT means the first driver reported devmode
                // matching the other parameters is to be picked; so, in
                // that case bFixedOutputSpecified remains FALSE.
                if (SourceDevmode->dmDisplayFixedOutput != DMDFO_DEFAULT)
                {
                    bFixedOutputSpecified = TRUE;
                    if (SourceDevmode->dmDisplayFixedOutput > DMDFO_LAST)
                    {
                        btmpError = TRUE;
                    }
                }
            }

            //
            // Capture the position.
            //
            // If the size of the rectangle is NULL, that means the device
            // needs to be detached from the desktop.
            //

            if (SourceDevmode->dmFields & DM_POSITION)
            {
                tmpPosition = TRUE;
                tmpPositionX = SourceDevmode->dmPosition.x;
                tmpPositionY = SourceDevmode->dmPosition.y;
            }
            else
            {
                tmpPosition = partialDevmode->dmFields & DM_POSITION;
                tmpPositionX = partialDevmode->dmPosition.x;
                tmpPositionY = partialDevmode->dmPosition.y;
            }


            //
            // If the PhysDisp attaches to a device which removable, never put
            // the primary desktop on it.  And never put origin (0,0) on it
            //
            if (PhysDisp->stateFlags & DISPLAY_DEVICE_REMOVABLE)
            {
                if (tmpPosition &&
                    tmpPositionX == 0 &&
                    tmpPositionY == 0 )
                {
                    TRACE_INIT(("Drv_Trace: CaptMatchDevmode: User tried to put the primary desktop on a removable device.\n"));

                    VFREEMEM(partialDevmode);
                    return STATUS_UNSUCCESSFUL;
                }
            }

            if (btmpError == TRUE)
            {
                //
                // The panning values or the flags are invalid
                //

                RIP("Drv_Trace: CaptMatchDevmode: Invalid Optional DEVMODE fields\n");
            }
            else
            {
                //
                // Allocate enough memory so we can store the whole devmode.
                //

                sizeExtra = sourceSizeExtra;
                if (sizeExtra == 0)
                {
                    sizeExtra = partialDevmode->dmDriverExtra;
                }

                matchedDevmode = (PDEVMODEW) PALLOCMEM(sizeof(DEVMODEW) + sizeExtra,
                                                       GDITAG_DEVMODE);

                if (matchedDevmode)
                {
                    //
                    // Let's copy any DriverExtra information that the
                    // application may have passed down while we are still in
                    // the try\except.  If we fail the call later, the memory
                    // will get deallocated anyways.
                    //
                    // If the application did not specify any such data, then
                    // copy it from the registry.
                    //

                    if (sourceSizeExtra)
                    {
                        RtlCopyMemory(matchedDevmode + 1,
                                      (PUCHAR)SourceDevmode + sourceSize,
                                      sizeExtra);
                    }
                    else if (partialDevmode->dmDriverExtra)
                    {
                        RtlCopyMemory(matchedDevmode + 1,
                                      (PUCHAR)partialDevmode + partialDevmode->dmSize,
                                      sizeExtra);
                    }
                }
            }
        }

        TRACE_INIT(("Drv_Trace: CaptMatchDevmode: Capture Complete\n"));
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        WARNINGX(101);

        //
        // If we hit an exception, free the buffer we have allocated.
        //

        if (matchedDevmode)
        {
            VFREEMEM(matchedDevmode);
        }

        matchedDevmode = NULL;
    }

    //
    // This is our matching algorithm, based on requirements from Win95.
    //
    // As a rule, a value in the DEVMODE is only valid when BOTH the value is
    // non-zero, and the dmFields flag is set.  Otherwise, the value from the
    // registry must be used
    //
    // For X, Y and color depth, we will follow this rule.
    //
    // For the refresh rate, we are just trying to find something that works
    // for the screen.  We are far from guaranteed that the refresh rate in
    // the registry will be found for the X and Y we have since refresh rates
    // vary a lot from mode to mode.
    //
    // So if the value is not specifically set and we do not find the exact
    // value from the reigstry in the new resolution, Then we will try 60 Hz.
    // We just want to get something that works MOST of the time so that the
    // user does not get a mode that does not work.
    //
    // For the other fields (dmDisplayFlags, and panning), we just pass on what
    // the application specified, and it's up to the driver to parse those,
    // fields appropriatly.
    //

    //
    // Now lets enumerate all the DEVMODEs and see if we have one
    // that matches what we need.
    //

    if (matchedDevmode)
    {
        typedef enum {
            NO_MATCH,
            DEFAULT_MATCH,
            EXACT_MATCH
        } MatchLevel;

        PDEVMODEW          pdevmodeMatch = NULL;
        MatchLevel         eOrientationMatch = NO_MATCH;
        MatchLevel         eFixedOutputMatch = NO_MATCH;
        MatchLevel         eFrequencyMatch = NO_MATCH;
        BOOL               bExactMatch = FALSE;
        PDEVMODEW          pdevmodeInfo;

        TRACE_INIT(("Drv_Trace: CaptMatchDevmode: Start matching\n"));

        DrvBuildDevmodeList(PhysDisp, FALSE);

        pdevmodeInfo = PhysDisp->devmodeInfo;

        //
        // If we can not find a mode because the caller was asking for the
        // default mode, then just pick any 640x480 mode.
        // We are not worried about picking a nice default because the applet
        // generally takes care of that during configuration.
        //
        // In the case of hydra, the first mode in the driver is picked - why ?
        //
        // For mirroring, the mode for the primary device should be used.
        // A special error code will be used for that
        //

        if ((partialDevmode->dmBitsPerPel == 0) &&
            (partialDevmode->dmPelsWidth  == 0) &&
            (partialDevmode->dmPelsHeight == 0) &&
            (partialDevmode->dmDisplayOrientation == DMDO_DEFAULT))
        {
            WARNING("Drv_Trace: CaptMatchDevmode: DEFAULT DEVMODE picked\n");

            if (PhysDisp->stateFlags & (DISPLAY_DEVICE_DISCONNECT | DISPLAY_DEVICE_REMOTE))
            {
                //
                // Hydra only supports one mode.
                //

                if (PhysDisp->devmodeInfo)
                {
                    partialDevmode->dmBitsPerPel = PhysDisp->devmodeInfo->dmBitsPerPel;
                    partialDevmode->dmPelsWidth  = PhysDisp->devmodeInfo->dmPelsWidth;
                    partialDevmode->dmPelsHeight = PhysDisp->devmodeInfo->dmPelsHeight;
                    partialDevmode->dmDisplayFrequency = PhysDisp->devmodeInfo->dmDisplayFrequency;
                    partialDevmode->dmDisplayOrientation = PhysDisp->devmodeInfo->dmDisplayOrientation;
                    partialDevmode->dmDisplayFixedOutput = PhysDisp->devmodeInfo->dmDisplayFixedOutput;
                }
            }
            else if (PhysDisp->stateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER)
            {
                //
                // For the mirror driver:
                //   If we have no modes in the driver, fail.
                //   Otherwise, return the default mode the driver provides.
                //

                if (PhysDisp->cbdevmodeInfo == 0)
                {
                    ntRet = STATUS_INVALID_PARAMETER_MIX;
                }
            }
            else
            {
                partialDevmode->dmBitsPerPel       = 0;
                partialDevmode->dmPelsWidth        = 640;
                partialDevmode->dmPelsHeight       = 480;
                if (bClosest)
                {
                    LPDEVMODEW pdm = GetClosestMode(PhysDisp, partialDevmode, bPrune);
                    if (pdm != NULL)
                    {
                        partialDevmode->dmBitsPerPel = pdm->dmBitsPerPel;
                        partialDevmode->dmPelsWidth  = pdm->dmPelsWidth;
                        partialDevmode->dmPelsHeight = pdm->dmPelsHeight;
                        partialDevmode->dmDisplayFrequency = pdm->dmDisplayFrequency;
                        partialDevmode->dmDisplayOrientation = pdm->dmDisplayOrientation;
                        partialDevmode->dmDisplayFixedOutput = pdm->dmDisplayFixedOutput;
                    }
                }
            }
        }
        //
        // For mirror drivers:
        //   If the driver return no modes but something was specified in the
        //   registry, return that to the driver.
        //

        else if ((PhysDisp->stateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER) &&
                 (PhysDisp->cbdevmodeInfo == 0))
        {
            pdevmodeMatch = partialDevmode;

            ASSERTGDI(PhysDisp->cbdevmodeInfo == 0, "MIRROR driver must have no modes\n");
        }
        else if (bClosest)
        {
            LPDEVMODEW pdm = GetClosestMode(PhysDisp, partialDevmode, bPrune);
            if (pdm != NULL)
            {
                partialDevmode->dmBitsPerPel       = pdm->dmBitsPerPel;
                partialDevmode->dmPelsWidth        = pdm->dmPelsWidth;
                partialDevmode->dmPelsHeight       = pdm->dmPelsHeight;
                partialDevmode->dmDisplayFrequency = pdm->dmDisplayFrequency;
                partialDevmode->dmDisplayOrientation = pdm->dmDisplayOrientation;
                partialDevmode->dmDisplayFixedOutput = pdm->dmDisplayFixedOutput;
            }
        }


        for (ULONG i = 0; i < PhysDisp->numRawModes; i++)
        {
            if (bPrune && PhysDisp->devmodeMarks[i].bPruned)
                continue;
            pdevmodeInfo = PhysDisp->devmodeMarks[i].pDevMode;
            if (((partialDevmode->dmBitsPerPel == 0) ||
                 (partialDevmode->dmBitsPerPel == pdevmodeInfo->dmBitsPerPel)) &&
                (partialDevmode->dmPelsWidth  == pdevmodeInfo->dmPelsWidth)    &&
                (partialDevmode->dmPelsHeight == pdevmodeInfo->dmPelsHeight)   &&
                ((partialDevmode->dmDisplayOrientation == pdevmodeInfo->dmDisplayOrientation) ||
                 (
                  (eOrientationMatch != EXACT_MATCH) &&
                  !bOrientationSpecified &&
                  (
                   (eOrientationMatch != DEFAULT_MATCH) ||
                   (pdevmodeInfo->dmDisplayOrientation == DMDO_DEFAULT))
                )) &&
                (!bFixedOutputSpecified ||
                 (partialDevmode->dmDisplayFixedOutput == pdevmodeInfo->dmDisplayFixedOutput))
               )
            {
                //
                // Pick at least the first mode that matches the resolution
                // so that we at least have a chance at working.
                //
                // Then pick 60 Hz if we find it.
                //
                // Even better, pick the refresh that matches the current
                // refresh (we assume that what's in the registry has the
                // best chance of working.
                //

                if (pdevmodeMatch == NULL)
                {
                    pdevmodeMatch = pdevmodeInfo;
                }

                if ((eOrientationMatch == NO_MATCH) &&
                    (pdevmodeInfo->dmDisplayOrientation == DMDO_DEFAULT))
                {
                    pdevmodeMatch = pdevmodeInfo;

                    eOrientationMatch = DEFAULT_MATCH;
                    eFixedOutputMatch = NO_MATCH;
                    eFrequencyMatch = NO_MATCH;
                }

                if ((eOrientationMatch != EXACT_MATCH) &&
                    (partialDevmode->dmDisplayOrientation ==
                        pdevmodeInfo->dmDisplayOrientation))
                {
                    pdevmodeMatch = pdevmodeInfo;

                    eOrientationMatch = EXACT_MATCH;
                    eFixedOutputMatch = NO_MATCH;
                    eFrequencyMatch = NO_MATCH;
                }

                // Fixed Output setting only matches exactly when specified,
                //  but matches first when not specified (when field flag isn't
                //  set or dmDisplayFixedOutput == DMDFO_DEFAULT.)
                if ((eFixedOutputMatch != EXACT_MATCH) &&
                    (!bFixedOutputSpecified ||
                     (partialDevmode->dmDisplayFixedOutput ==
                        pdevmodeInfo->dmDisplayFixedOutput)
                   ))
                {
                    pdevmodeMatch = pdevmodeInfo;

                    eFixedOutputMatch = EXACT_MATCH;
                    eFrequencyMatch = NO_MATCH;
                }

                if ((eFrequencyMatch == NO_MATCH) &&
                    (pdevmodeInfo->dmDisplayFrequency == 60))
                {
                    pdevmodeMatch = pdevmodeInfo;

                    eFrequencyMatch = DEFAULT_MATCH;
                }

                if ((eFrequencyMatch != EXACT_MATCH) &&
                    (partialDevmode->dmDisplayFrequency ==
                        pdevmodeInfo->dmDisplayFrequency))
                {
                    //
                    // We found even better than 60 - an exact frequency match !
                    //

                    eFrequencyMatch = EXACT_MATCH;

                    pdevmodeMatch = pdevmodeInfo;

                    if (eOrientationMatch == EXACT_MATCH &&
                        eFixedOutputMatch == EXACT_MATCH)
                    {
                        bExactMatch = TRUE;
                        break;
                    }

                    //
                    // For now, we ignore these other fields since they
                    // considered optional.
                    //

                    // pdevmodeInfo->dmDisplayFlags;
                    // pdevmodeInfo->dmPanningWidth;
                    // pdevmodeInfo->dmPanningHeight;

                }
            }
        }

        //
        // Always set these flags since we initialize the values.
        // We need consistent flags all the time to avoid extra modesets
        //
        // Also, force font size to be static for now.
        //

        if (pdevmodeMatch != NULL)
        {
            RtlCopyMemory(matchedDevmode,
                          pdevmodeMatch,
                          pdevmodeMatch->dmSize);

            matchedDevmode->dmDriverExtra = (WORD) sizeExtra;
            matchedDevmode->dmLogPixels = (partialDevmode->dmLogPixels == 0) ?
                                          96 :
                                          partialDevmode->dmLogPixels;

            matchedDevmode->dmFields |= (DM_PANNINGHEIGHT |
                                         DM_PANNINGWIDTH  |
                                         DM_DISPLAYFLAGS  |
                                         DM_LOGPIXELS);

            //
            // Check that the display driver specified all the other
            // flags (res, color, frequency) properly.
            //

            if ((matchedDevmode->dmFields & DM_INTERNAL_VALID_FLAGS) !=
                     DM_INTERNAL_VALID_FLAGS)
            {
                RIP("Drv_Trace: CaptMatchDevmode: BAD DM FLAGS\n");
            }

            //
            // Extra flag that determines if we should set the attach or
            // detach flag
            //

            matchedDevmode->dmFields |= ((tmpPosition) ? DM_POSITION : 0);

            //
            // In the case of a good match, also use these extra values.
            //

            matchedDevmode->dmPosition.x    = tmpPositionX;
            matchedDevmode->dmPosition.y    = tmpPositionY;
            matchedDevmode->dmDisplayFlags  = tmpDisplayFlags;
            matchedDevmode->dmPanningWidth  = tmpPanningWidth;
            matchedDevmode->dmPanningHeight = tmpPanningHeight;
        }

        //
        // MAJOR optimization : Do not free the list at this point.
        // Many apps call EnumDisplaySettings, and for each mode call
        // ChangeDisplaySettings with it to see if it can be changed
        // dynamically.  When we free the list here, it causes us to recreate
        // the list for each mode we have in the list, which can take on
        // the order of 30 seconds if there are multiple display drivers
        // involved.
        // Even if we keep the list here, it should properly get freed
        // at the end of EnumDisplaySettings.
        //

        //
        // Exit path
        //

        if (pdevmodeMatch != NULL)
        {
            TRACE_INIT(("Drv_Trace: CaptMatchDevmode: Matched DEVMODE\n"));
            dbgDumpDevmode(matchedDevmode);

           *DestinationDevmode = matchedDevmode;

            ntRet = (bExactMatch) ? STATUS_SUCCESS :
                    (((eFrequencyMatch != EXACT_MATCH) &&
                      partialDevmode->dmDisplayFrequency) ?
                     STATUS_INVALID_PARAMETER :
                     ((eFrequencyMatch == EXACT_MATCH) ?
                      STATUS_SUCCESS :
                      STATUS_RECEIVE_PARTIAL));
        }
        else
        {
            VFREEMEM(matchedDevmode);
        }
    }

    VFREEMEM(partialDevmode);

    if (NT_SUCCESS(ntRet))
    {
        if (ntRet == STATUS_RECEIVE_PARTIAL)
        {
            TRACE_INIT(("Drv_Trace: CaptMatchDevmode: Exit partial success\n\n"));
        }
        else
        {
            TRACE_INIT(("Drv_Trace: CaptMatchDevmode: Exit exact success\n\n"));
        }
    }
    else
    {
        TRACE_INIT(("Drv_Trace: CaptMatchDevmode: Exit error\n\n"));
    }

    return (ntRet);
}

/***************************************************************************\
* DrvGetVideoPowerState
*
* History:
* 02-Dec-1996 AndreVa   Created.
\***************************************************************************/

NTSTATUS
DrvGetMonitorPowerState(
    PMDEV              pmdev,
    DEVICE_POWER_STATE PowerState)
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    VIDEO_POWER_STATE VideoPowerState = (VIDEO_POWER_STATE) PowerState;
    ULONG BytesReturned;
    ULONG i;

#ifdef _HYDRA_
   if (gProtocolType != PROTOCOL_CONSOLE ) {
      //
      // Don't Call this for remote video drivers
      //
      return STATUS_UNSUCCESSFUL;
   }
#endif

    for (i = 0; i < pmdev->chdev; i++)
    {
        PDEVOBJ pdo(pmdev->Dev[i].hdev);

        if ((pdo.ppdev->pGraphicsDevice->stateFlags & DISPLAY_DEVICE_DISCONNECT) != 0 ) {
            //
            // Don't Call this for disconnect drivers
            //
            ASSERT(pdo.ppdev->pGraphicsDevice->pDeviceHandle == NULL );
            continue;
        }

        Status = GreDeviceIoControl(pdo.ppdev->pGraphicsDevice->pDeviceHandle,
                                    IOCTL_VIDEO_GET_OUTPUT_DEVICE_POWER_STATE,
                                    &VideoPowerState,
                                    sizeof(VideoPowerState),
                                    NULL,
                                    0,
                                    &BytesReturned);

        if (!NT_SUCCESS(Status))
        {
            break;
        }
    }

    return Status;
}

/***************************************************************************\
* DrvSetVideoPowerState
*
* History:
* 02-Dec-1996 AndreVa   Created.
\***************************************************************************/

NTSTATUS
DrvSetMonitorPowerState(
    PMDEV              pmdev,
    DEVICE_POWER_STATE PowerState)
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    VIDEO_POWER_STATE VideoPowerState = (VIDEO_POWER_STATE) PowerState;
    ULONG BytesReturned;
    ULONG i;

#ifdef _HYDRA_
   if (gProtocolType != PROTOCOL_CONSOLE ) {
       //
       // Don't Call this for remote video drivers
       //
      return STATUS_UNSUCCESSFUL;
   }
#endif

    for (i = 0; i < pmdev->chdev; i++)
    {
        PDEVOBJ pdo(pmdev->Dev[i].hdev);

#ifdef _HYDRA_

        if (pdo.ppdev->pGraphicsDevice->stateFlags & DISPLAY_DEVICE_DISCONNECT) {
            //
            // Don't Call this for disconnect drivers
            //
            if (pdo.ppdev->pGraphicsDevice->pDeviceHandle) {
                TRACE_INIT(("DrvSetMonitorPowerState: Disconnect DD has a Device Handle = %p!\n",
                         pdo.ppdev->pGraphicsDevice->pDeviceHandle));
#if DBG
                DbgBreakPoint();
#endif
            }
            continue;
        }
#endif
        Status = GreDeviceIoControl(pdo.ppdev->pGraphicsDevice->pDeviceHandle,
                                    IOCTL_VIDEO_SET_OUTPUT_DEVICE_POWER_STATE,
                                    &VideoPowerState,
                                    sizeof(VideoPowerState),
                                    NULL,
                                    0,
                                    &BytesReturned);

        // !!! partial state problem ...

        if (!NT_SUCCESS(Status))
        {
            break;
        }
    }

    return Status;
}

/***************************************************************************\
* DrvQueryMDEVPowerState(
*
* History:
* 26-Jul-1998 AndreVa   Created.
\***************************************************************************/

BOOL
DrvQueryMDEVPowerState(
    PMDEV pmdev
    )
{
    ULONG i;
    HDEV hdev;

    for (i=0; i < pmdev->chdev; i++)
    {
        PDEVOBJ pdo(pmdev->Dev[i].hdev);

        if (pdo.ppdev->pGraphicsDevice->stateFlags & DISPLAY_DEVICE_POWERED_OFF)
        {
            TRACE_INIT(("Drv_Trace: DrvQueryMDEVPowerState is OFF\n"));
            return FALSE;
        }
    }

    TRACE_INIT(("Drv_Trace: DrvQueryMDEVPowerState is ON\n"));
    return TRUE;
}

VOID
DrvSetMDEVPowerState(
    PMDEV pmdev,
    BOOL On
    )
{
    TRACE_INIT(("Drv_Trace: DrvSetMDEVPowerState MDEV %p  %s\n",
                pmdev, On ? "ON" : "OFF"));

    ULONG i;
    HDEV hdev;

    for (i=0; i < pmdev->chdev; i++)
    {
        PDEVOBJ pdo(pmdev->Dev[i].hdev);

        if (On) {
            pdo.ppdev->pGraphicsDevice->stateFlags &= ~DISPLAY_DEVICE_POWERED_OFF;
        } else {
            pdo.ppdev->pGraphicsDevice->stateFlags |= DISPLAY_DEVICE_POWERED_OFF;
        }
    }
}

/***************************************************************************\
* DrvDisplaySwitchHandler()
*
* Return Value:
*   TRUE:  System needs to update to a new mode
*   FALSE: The current mode works fine
*
* History:
*   Dennyd  Created
\***************************************************************************/
#define PRUNEMODE_REGKEY  L"PruningMode"    // PruneMode Flag
#define PRUNEMODE_BUFSIZE (sizeof(KEY_VALUE_FULL_INFORMATION) + sizeof(PRUNEMODE_REGKEY) + sizeof(DWORD))

BOOL
DrvGetPruneFlag(PGRAPHICS_DEVICE PhysDisp)
{
    HANDLE  hkRegistry;
    DWORD   PrunningMode = 1;
    BYTE    buffer[PRUNEMODE_BUFSIZE];
    PKEY_VALUE_FULL_INFORMATION Information = (PKEY_VALUE_FULL_INFORMATION)buffer;
    ULONG   Length = PRUNEMODE_BUFSIZE;

    hkRegistry = DrvGetRegistryHandleFromDeviceMap(
                            PhysDisp,
                            DispDriverRegGlobal,
                            NULL,
                            NULL,
                            NULL,
                            gProtocolType);

    if (hkRegistry)
    {
        UNICODE_STRING UnicodeString;
        RtlInitUnicodeString(&UnicodeString, PRUNEMODE_REGKEY);

        if (NT_SUCCESS(ZwQueryValueKey(hkRegistry,
                                       &UnicodeString,
                                       KeyValueFullInformation,
                                       Information,
                                       Length,
                                       &Length)))
        {
            PrunningMode = *(LPDWORD) ((((PUCHAR)Information) +
                                       Information->DataOffset));
        }
        ZwCloseKey(hkRegistry);
    }
    return (PrunningMode != 0);
}

BOOL
DrvDisplaySwitchHandler(
    PVOID physDisp,                     // IN
    PUNICODE_STRING pstrDeviceName,     // OUT
    LPDEVMODEW pNewMode,                // OUT
    PULONG     pPrune                   // OUT
    )
{
    DEVMODEW srcMode;
    LPDEVMODEW lpModeWanted;
    PGRAPHICS_DEVICE PhysDisp = (PGRAPHICS_DEVICE)physDisp;
    ULONG i;
    BOOL uu, bPrune;

    TRACE_INIT(("DrvDisplaySwitchHandler: Enter\n"));

    gbUpdateMonitor = TRUE;
    UpdateMonitorDevices();

    //
    // On display switching, update mode list according to new active displays
    //
    DrvBuildDevmodeList(PhysDisp, TRUE);

    bPrune = DrvGetPruneFlag(PhysDisp);
    *pPrune = bPrune;

    //
    // Check if the mode in registry complies with the new mode list
    // This is neccessary because when the system was first setup, there is no reg value
    // under per monitor registry.
    //
    RtlZeroMemory(&srcMode, sizeof(DEVMODEW));
    srcMode.dmSize = sizeof(DEVMODEW);
    if (NT_SUCCESS (DrvProbeAndCaptureDevmode(PhysDisp,
                                              &lpModeWanted,
                                              &uu,
                                              &srcMode,
                                              FALSE,
                                              KernelMode,
                                              bPrune,
                                              TRUE,
                                              TRUE) )
       )
    {
        TRACE_INIT(("DrvDisplaySwitchHandler: Pick reg mode B=%d W=%d H=%d F=%d R=%lu\n",
                    lpModeWanted->dmBitsPerPel, lpModeWanted->dmPelsWidth, lpModeWanted->dmPelsHeight, lpModeWanted->dmDisplayFrequency, lpModeWanted->dmDisplayOrientation*90));

        RtlCopyMemory(pNewMode, lpModeWanted, sizeof(DEVMODEW));
        RtlInitUnicodeString(pstrDeviceName, &(PhysDisp->szWinDeviceName[0]));

        {
            //
            // If there is only one output device, update per monitor settings as well
            //
            ULONG activePdos = 0;
            for (i = 0; i < PhysDisp->numMonitorDevice; i++)
            {
                if (IS_ATTACHED_ACTIVE(PhysDisp->MonitorDevices[i].flag))
                {
                    activePdos++;
                }
            }
            DrvUpdateDisplayDriverParameters(PhysDisp, lpModeWanted, FALSE, (activePdos == 1));
        }

        VFREEMEM(lpModeWanted);

        return TRUE;
    }

    return FALSE;
}


PVOID
DrvWakeupHandler(
    HANDLE *ppdo        // OUT
    )
{
    PGRAPHICS_DEVICE PhysDisp;

    for (PhysDisp = gpGraphicsDeviceList;
         PhysDisp != NULL;
         PhysDisp = PhysDisp->pNextGraphicsDevice)
    {
        if (PhysDisp->stateFlags & DISPLAY_DEVICE_ACPI)
        {
            break;
        }
    }

    if (PhysDisp)
    {
        *ppdo = PhysDisp->pPhysDeviceHandle;
    }

    return (PVOID)PhysDisp;
}

/***************************************************************************\
*
* DrvSendPnPIrp
*
* History:
\***************************************************************************/

NTSTATUS
DrvSendPnPIrp(
    PDEVICE_OBJECT        pDeviceObject,
    DEVICE_RELATION_TYPE  relationType,
    PDEVICE_RELATIONS    *pDeviceRelations)
{
    NTSTATUS           status;
    PIRP               Irp;
    PIO_STACK_LOCATION IrpSp;
    KEVENT             event;
    IO_STATUS_BLOCK    IoStatusBlock;
    //
    // Anything else is illegal.
    //

    ASSERT(relationType == TargetDeviceRelation);

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    Irp = IoBuildSynchronousFsdRequest(IRP_MJ_PNP,
                                       pDeviceObject,
                                       NULL,
                                       0,
                                       NULL,
                                       &event,
                                       &IoStatusBlock);

    if (Irp == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Set the default error code.
    //

    Irp->IoStatus.Status = IoStatusBlock.Status = STATUS_NOT_SUPPORTED;

    IrpSp = IoGetNextIrpStackLocation(Irp);
    IrpSp->MajorFunction = IRP_MJ_PNP;
    IrpSp->MinorFunction = IRP_MN_QUERY_DEVICE_RELATIONS;

    IrpSp->Parameters.QueryDeviceRelations.Type = relationType;

    //
    // Call the filter driver.
    //

    status = IoCallDriver(pDeviceObject, Irp);

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

        status = IoStatusBlock.Status;

    }

    if (NT_SUCCESS(status))
    {
        *pDeviceRelations = (PDEVICE_RELATIONS) IoStatusBlock.Information;
    }

    return status;
}

/**************************************************************************\
* __EnumDisplayQueryRoutine
*
* Callback to get the display driver name.
*
* CRIT not needed
*
* 12-Jan-1994 andreva created
\**************************************************************************/

NTSTATUS
__DisplayDriverQueryRoutine(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext)
{
    //
    // If the context value is NULL and the entry type is correct, then store
    // the length of the value. Otherwise, copy the value to the specified
    // memory.
    //

    PGRAPHICS_DEVICE PhysDisp = (PGRAPHICS_DEVICE) Context;

    //
    // Include workaround for vendors that don't understand MULTI_SZ !
    //

    if (ValueType != REG_MULTI_SZ)
    {
          ASSERT(FALSE);
    }

    TRACE_INIT(("Drv_Trace: __DisplayDriverQueryRoutine MULTISZ %ws = %ws\n", ValueName, ValueData));

    if (!(PhysDisp->DisplayDriverNames = (LPWSTR) PALLOCNOZ(ValueLength + 2, GDITAG_DRVSUP)))
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(PhysDisp->DisplayDriverNames, ValueData, ValueLength);
    *((LPWSTR) (((PUCHAR)PhysDisp->DisplayDriverNames) + ValueLength)) = UNICODE_NULL;

    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(ValueName);
    UNREFERENCED_PARAMETER(EntryContext);
}

NTSTATUS
__EnumDisplayQueryRoutine(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext)
{
    //
    // If the context value is NULL and the entry type is correct, then store
    // the length of the value. Otherwise, copy the value to the specified
    // memory.
    //

    PGRAPHICS_DEVICE PhysDisp = (PGRAPHICS_DEVICE) Context;
    NTSTATUS status = STATUS_SUCCESS;

    //
    // If the value is a string with only a NULL value, then keep going
    // to the next possible string.
    // So only try to save the string for > 2 characters.
    //

    if (ValueLength > 2)
    {
        if (ValueType == REG_SZ)
        {
            if (PhysDisp->DeviceDescription == NULL)
            {
                TRACE_INIT(("Drv_Trace: __EnumDisplayQueryRoutine SZ %ws = %ws\n", ValueName, ValueData));

                if (PhysDisp->DeviceDescription = (LPWSTR) PALLOCNOZ(ValueLength, GDITAG_DRVSUP))
                {
                    RtlCopyMemory(PhysDisp->DeviceDescription, ValueData, ValueLength);
                }
                else
                {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        }
        else if (ValueType == REG_BINARY)
        {
            if (PhysDisp->DeviceDescription == NULL)
            {
                TRACE_INIT(("Drv_Trace: __EnumDisplayQueryRoutine BINARY %ws = %ws\n", ValueName, ValueData));

                if (PhysDisp->DeviceDescription = (LPWSTR) PALLOCNOZ(ValueLength + sizeof(WCHAR), GDITAG_DRVSUP))
                {
                    RtlCopyMemory(PhysDisp->DeviceDescription, ValueData, ValueLength);
                    *((LPWSTR)((LPBYTE)PhysDisp->DeviceDescription + ValueLength)) = UNICODE_NULL;
                }
                else
                {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        }
        else
        {
            ASSERTGDI(FALSE, "Drv_Trace: __EnumDisplayQueryRoutine: Invalid callout type\n");

            status = STATUS_SUCCESS;
        }
    }

    return status;

    UNREFERENCED_PARAMETER(ValueName);
    UNREFERENCED_PARAMETER(EntryContext);
}

/***************************************************************************\
* IsVgaDevice
*
* Determine if the given PhysDisp is for the VGA.
*
* 13-Oct-1999 ericks Created
\***************************************************************************/

BOOLEAN
IsVgaDevice(
    PGRAPHICS_DEVICE PhysDisp
    )

{
    BOOLEAN Result = FALSE;
    ULONG bytesReturned;
    NTSTATUS status;

    status = GreDeviceIoControl(PhysDisp->pDeviceHandle,
                                IOCTL_VIDEO_IS_VGA_DEVICE,
                                NULL,
                                0,
                                &Result,
                                sizeof(Result),
                                &bytesReturned);

    if (NT_SUCCESS(status)) {
        return Result;
    }

    return FALSE;
}

/**************************************************************************\
* DrvGetDeviceConfigurationInformation
*
* Get the registry parameters for the driver
*
* 30-Apr-1998 andreva created
\**************************************************************************/

VOID
DrvGetDeviceConfigurationInformation(
    PGRAPHICS_DEVICE PhysDisp,
    HANDLE hkRegistry,
    BOOL bIsPdo
    )
{
    NTSTATUS status;

    ULONG    defaultValue = 0;
    ULONG    multiDriver = 0;
    ULONG    mirroring = 0;
    ULONG    vgaCompat = 0;

    RTL_QUERY_REGISTRY_TABLE multiQueryTable[] = {
        {__EnumDisplayQueryRoutine,   RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_NOEXPAND,
         SoftwareSettings[0], NULL,         REG_NONE,  NULL,          0},
        {NULL, RTL_QUERY_REGISTRY_SUBKEY,
         L"Settings",         NULL,         REG_NONE,  NULL,          0},
        {__DisplayDriverQueryRoutine, RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_NOEXPAND,
         SoftwareSettings[1], NULL,         REG_NONE,  NULL,          0},
        {NULL, RTL_QUERY_REGISTRY_DIRECT,
         SoftwareSettings[2], &multiDriver, REG_DWORD, &defaultValue, 4},
        {NULL, RTL_QUERY_REGISTRY_DIRECT,
         SoftwareSettings[3], &mirroring,   REG_DWORD, &defaultValue, 4},
        {NULL, RTL_QUERY_REGISTRY_DIRECT,
         SoftwareSettings[4], &vgaCompat,   REG_DWORD, &defaultValue, 4},

        // Device Description is optional, for 4.0 legacy only

        {__EnumDisplayQueryRoutine,   RTL_QUERY_REGISTRY_NOEXPAND,
         SoftwareSettings[5], NULL,         REG_NONE,  NULL,          0},
        {__EnumDisplayQueryRoutine,   RTL_QUERY_REGISTRY_NOEXPAND,
         SoftwareSettings[6], NULL,         REG_NONE,  NULL,          0},
        {__EnumDisplayQueryRoutine,   RTL_QUERY_REGISTRY_NOEXPAND,
         SoftwareSettings[7], NULL,         REG_NONE,  NULL,          0},
        {NULL, 0, NULL}
    };

    status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                    (PWSTR)hkRegistry,
                                    bIsPdo ?
                                        &multiQueryTable[0] :
                                        &multiQueryTable[2],
                                    PhysDisp,
                                    NULL);

    if (NT_SUCCESS(status))

    {
        if (multiDriver)
            PhysDisp->stateFlags |= DISPLAY_DEVICE_MULTI_DRIVER;
        if (mirroring)
            PhysDisp->stateFlags |= DISPLAY_DEVICE_MIRRORING_DRIVER;

        //
        // We must determine which graphics device actually has the VGA resources
        //
        if (vgaCompat && IsVgaDevice(PhysDisp))
            PhysDisp->stateFlags |= DISPLAY_DEVICE_VGA_COMPATIBLE;

        TRACE_INIT(("DrvGetDeviceConfigurationInformation: Display driver is %sa multi display driver\n",
                     multiDriver ? "" : "NOT "));
        TRACE_INIT(("DrvGetDeviceConfigurationInformation: Display driver is %smirroring the desktop\n",
                    mirroring ? "" : "NOT "));
        TRACE_INIT(("DrvGetDeviceConfigurationInformation: Display driver is %sVga Compatible\n",
                    vgaCompat ? "" : "NOT "));
    }
    else
    {
        //
        //
        // An error occured - this device is miss-configured.
        //

        TRACE_INIT(("DrvGetDeviceConfigurationInformation: Device is misconfigured\n"));

        DrvLogDisplayDriverEvent(MsgInvalidConfiguration);


	if (PhysDisp->DisplayDriverNames)
        {
	    VFREEMEM(PhysDisp->DisplayDriverNames);
	    PhysDisp->DisplayDriverNames = NULL;
        }
        if (PhysDisp->DeviceDescription)
        {
            VFREEMEM(PhysDisp->DeviceDescription);
            PhysDisp->DeviceDescription = NULL;
        }
    }

    return;
}


/**************************************************************************\
* DrvSetSingleDisplay
*
* Remove all physical displays except for specified primary.
* If PhysDispPrimary == NULL, the list physical displays is 
* searched for the marked display and secondly any one.
*
* 25-May-2000 jasonha created 
\**************************************************************************/

BOOL bPrunedDisplayDevice = FALSE;  // Was a secondary display devcice rejected?

PGRAPHICS_DEVICE
DrvSetSingleDisplay(
    PGRAPHICS_DEVICE    PhysDispPrimary
    )
{
    GDIFunctionID(DrvSetSingleDisplay);

    PGRAPHICS_DEVICE    PhysDispTemp;
    PGRAPHICS_DEVICE    PhysDispPrev = NULL;
    PGRAPHICS_DEVICE    PhysDispNext = NULL;

    // Confirm the given primary is in the list
    // or identify the marked primary.
    for (PhysDispTemp = gpGraphicsDeviceList;
         PhysDispTemp != NULL;
         PhysDispTemp = PhysDispTemp->pNextGraphicsDevice)
    {
        if (! (PhysDispTemp->stateFlags & (DISPLAY_DEVICE_MIRRORING_DRIVER | DISPLAY_DEVICE_REMOTE | DISPLAY_DEVICE_DISCONNECT)))
        {
            if (PhysDispPrimary == NULL)
            {
                if (PhysDispTemp->stateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE)
                {
                    PhysDispPrimary = PhysDispTemp;
                    break;
                }
            }
            else
            {
                if (PhysDispTemp == PhysDispPrimary)
                {
                    break;
                }
            }
        }
    }

    // If we haven't identified a primary,
    // select any physical display.
    if (PhysDispPrimary == NULL)
    {
        for (PhysDispTemp = gpGraphicsDeviceList;
             PhysDispTemp != NULL;
             PhysDispTemp = PhysDispTemp->pNextGraphicsDevice)
        {
            if (! (PhysDispTemp->stateFlags & (DISPLAY_DEVICE_MIRRORING_DRIVER | DISPLAY_DEVICE_REMOTE | DISPLAY_DEVICE_DISCONNECT)))
            {
                PhysDispPrimary = PhysDispTemp;
                break;
            }
        }
    }

    // If we didn't find the specified primary or a 
    // suitable one, then there is nothing to do.
    if (PhysDispTemp == NULL)
    {
        return NULL;
    }

    // Remove all physical secondary displays
    PhysDispPrev = NULL;

    for (PhysDispTemp = gpGraphicsDeviceList;
         PhysDispTemp != NULL;
         PhysDispTemp = PhysDispNext)
    {
        PhysDispNext = PhysDispTemp->pNextGraphicsDevice;

        if (PhysDispTemp != PhysDispPrimary &&
            ! (PhysDispTemp->stateFlags & (DISPLAY_DEVICE_MIRRORING_DRIVER | DISPLAY_DEVICE_REMOTE | DISPLAY_DEVICE_DISCONNECT)))
        {
            ASSERTGDI(PhysDispTemp != gPhysDispVGA, "Removing VGA as a secondary.\n");
            bPrunedDisplayDevice = TRUE;

            // Remove from list
            if (PhysDispPrev == NULL)
            {
                gpGraphicsDeviceList = PhysDispTemp->pNextGraphicsDevice;
            }
            else
            {
                PhysDispPrev->pNextGraphicsDevice = PhysDispTemp->pNextGraphicsDevice;
            }

            if (PhysDispTemp == gpGraphicsDeviceListLast)
            {
                gpGraphicsDeviceListLast = PhysDispPrev;
            }

            // Cleanup any allocations
	    if (PhysDispTemp->DisplayDriverNames)
		VFREEMEM(PhysDispTemp->DisplayDriverNames);

            if (PhysDispTemp->DeviceDescription)
                VFREEMEM(PhysDispTemp->DeviceDescription);

            if (PhysDispTemp->MonitorDevices)
                VFREEMEM(PhysDispTemp->MonitorDevices);

            if (PhysDispTemp->devmodeInfo)
                VFREEMEM(PhysDispTemp->devmodeInfo);

            if (PhysDispTemp->devmodeMarks)
                VFREEMEM(PhysDispTemp->devmodeMarks);

            VFREEMEM(PhysDispTemp);

            // Reuse output numbers so next added display is in order.
            gcNextGlobalPhysicalOutputNumber--;
        }
        else
        {
            PhysDispPrev = PhysDispTemp;
        }
    }

    // Set Primary markings
    if (PhysDispPrimary)
    {
        PhysDispPrimary->stateFlags |= DISPLAY_DEVICE_PRIMARY_DEVICE;

        // Make sure this is display 1 for app compat.
        wcscpy(&(PhysDispPrimary->szWinDeviceName[0]),
                 L"\\\\.\\DISPLAY1");

        // If we loaded VGA and it is not the primary display, then
        // rename it to display 2.  It can't actually be referenced
        // from APIs, but we can keep the numbers in order.
        if (gPhysDispVGA && gPhysDispVGA != PhysDispPrimary)
        {
            // Rename VGA's WinDeviceName
            wcscpy(&(gPhysDispVGA->szWinDeviceName[0]),
                     L"\\\\.\\DISPLAY2");

            ASSERTGDI(gcNextGlobalPhysicalOutputNumber == 3,
                      "gcNextGlobalPhysicalOutputNumber != 3\n");
        }
        else
        {
            ASSERTGDI(gcNextGlobalPhysicalOutputNumber == 2,
                      "gcNextGlobalPhysicalOutputNumber != 2\n");
        }
    }

    return PhysDispPrimary;
}



/**************************************************************************\
* DrvUpdateVgaDevice
*
* Update the VGA graphics device in the machine.
*
* 01-Apr-1998 andreva created
\**************************************************************************/

PGRAPHICS_DEVICE
DrvUpdateVgaDevice()
{
    PGRAPHICS_DEVICE PhysDispIsVga;
    PGRAPHICS_DEVICE PhysDispMarkVga;
    PGRAPHICS_DEVICE PhysDispTmp;

    NTSTATUS         Status;
    VIDEO_NUM_MODES  NumModes;
    ULONG            NumModesLength = sizeof(NumModes);
    ULONG            cbBuffer;
    ULONG            BytesReturned;

    PVIDEO_MODE_INFORMATION lpModes;
    PVIDEO_MODE_INFORMATION pVideoModeSave;

    ULONG cTextModes     = 0;
    ULONG cGraphicsModes = 0;

    LPDEVMODEW pUsDevmode;
    LPDEVMODEW ptmpDevmode;
    LPDEVMODEMARK pUsDevmodeMark;

    BOOLEAN PrimaryExists = FALSE;
    BOOL    VGAInUse = FALSE;

    TRACE_INIT(("Drv_Trace: DrvUpdateVgaDevice: Finding VGA device\n"));

    //
    // Find the VGA compatible driver for the console.
    //
    // NOTE - These fullscreen modes are only supported on X86
    //

    //
    // Clear out the VGA, and the VGA flag of the parent if necessary
    //

    for (PhysDispTmp = gpGraphicsDeviceList;
         PhysDispTmp != NULL;
         PhysDispTmp = PhysDispTmp->pNextGraphicsDevice)
    {
        PhysDispTmp->pVgaDevice = NULL;

        if ((PhysDispTmp->stateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE) &&
            (PhysDispTmp != gPhysDispVGA)) {

            //
            // Determine if this device is currently a primary, and it
            // is not the VGA.  (The VGA may later be removed).
            //

            PrimaryExists = TRUE;
        }
    }

    //
    // If there is no primary device yet, lets choose the vga.
    //

    if (PrimaryExists == FALSE) {

        for (PhysDispTmp = gpGraphicsDeviceList;
             PhysDispTmp != NULL;
             PhysDispTmp = PhysDispTmp->pNextGraphicsDevice) {

            if (IsVgaDevice(PhysDispTmp)) {

                PhysDispTmp->stateFlags |= DISPLAY_DEVICE_PRIMARY_DEVICE;
                PrimaryExists = TRUE;

                break;
            }
        }
    }

    //
    // Find the VGA compatible device
    //

    for (PhysDispIsVga = gpGraphicsDeviceList;
         PhysDispIsVga != NULL;
         PhysDispIsVga = PhysDispIsVga->pNextGraphicsDevice)
    {
        //
        // The vga driver is here for compatibility.
        // Look for all other possibilities, and revert to VGA as a last
        // possibility
        //

        if (PhysDispIsVga == gPhysDispVGA)
        {
            continue;
        }

        if (PhysDispIsVga->stateFlags & DISPLAY_DEVICE_VGA_COMPATIBLE)
        {
            break;
        }
    }

    //
    // If no vga device was found, use the vga driver
    //

    if (PhysDispIsVga == NULL)
    {
        PhysDispIsVga = gPhysDispVGA;
    }

    //
    // On some machines, with TGA for example, it's possible to have no
    // VGA compatible device.
    //

    if (PhysDispIsVga == NULL)
    {
        return NULL;
    }

    //
    // Now determine if there is a duplicate device (like VGA)
    //
    // HACK - we only support the VGA as a duplicate device right now.
    // We need more info for cirrus + #9
    //
    // VGA is a duplicate if there is ANOTHER driver in the machine, excluding
    // for MIRROR DEVICES, Disconnected device and remote devices.  Personal 
    // Windows also requires the driver to be the VGA device driver.
    //

    PhysDispMarkVga = PhysDispIsVga;

    if (gPhysDispVGA)
    {
        PPDEV   ppdev;

        // Determine if VGA device is being used.
        // We have to hold ghsemDriverMgmt to be sure its
        // status doesn't change.

        GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);

        for (ppdev = gppdevList; ppdev != NULL; ppdev = ppdev->ppdevNext)
        {
            if (ppdev->pGraphicsDevice == gPhysDispVGA)
            {
                VGAInUse = TRUE;
                break;
            }
        }

        // If the VGA device's driver is non-VGA compatible
        // (DISPLAY_DEVICE_VGA_COMPATIBLE was not marked on
        // any device so
        //  PhysDispMarkVga = PhysDispIsVga = gPhysDispVGA),
        // then search for it so it may be marked as the VGA
        if (PhysDispMarkVga == gPhysDispVGA)
        {
            // Look for the real VGA device
            for (PhysDispMarkVga = gpGraphicsDeviceList;
                 PhysDispMarkVga != NULL;
                 PhysDispMarkVga = PhysDispMarkVga->pNextGraphicsDevice
                )
            {
                if ((PhysDispMarkVga != gPhysDispVGA) &&
                    ((PhysDispMarkVga->stateFlags & (DISPLAY_DEVICE_MIRRORING_DRIVER |
                                                     DISPLAY_DEVICE_DISCONNECT |
                                                     DISPLAY_DEVICE_REMOTE) ) == 0) &&
                    IsVgaDevice(PhysDispMarkVga)
                   )
                    break;
            }

            // If no real VGA device was found and
            // the VGA device isn't in use and
            // this is not Personal Windows, choose
            // any display to be marked as the VGA
            if (PhysDispMarkVga == NULL &&
                !VGAInUse &&
                !((USER_SHARED_DATA->NtProductType == NtProductWinNt) &&
                  (USER_SHARED_DATA->SuiteMask & (1 << Personal))))
            {
                for (PhysDispMarkVga = gpGraphicsDeviceList;
                     PhysDispMarkVga != NULL;
                     PhysDispMarkVga = PhysDispMarkVga->pNextGraphicsDevice
                    )
                {
                    if ((PhysDispMarkVga != gPhysDispVGA) &&
                        ((PhysDispMarkVga->stateFlags & (DISPLAY_DEVICE_MIRRORING_DRIVER |
                                                         DISPLAY_DEVICE_DISCONNECT |
                                                         DISPLAY_DEVICE_REMOTE) ) == 0)
                       )
                        break;
                }

            }

            // No real VGA device was found,
            // so we'll use VGA.sys device.
            if (PhysDispMarkVga == NULL)
            {
                PhysDispMarkVga = gPhysDispVGA;
            }
        }

        //
        // Remove the VGA.sys device from the list of devices if it is a duplicate.
        //

        if (gPhysDispVGA != PhysDispMarkVga)
        {
            //
            // Take this device out of the list.
            //
            // Handle the case where the device is already removed
            //

            if (gpGraphicsDeviceList == gPhysDispVGA)
            {
                gpGraphicsDeviceList = gPhysDispVGA->pNextGraphicsDevice;
            }
            else
            {
                PhysDispTmp = gpGraphicsDeviceList;

                while (PhysDispTmp)
                {
                    if (PhysDispTmp->pNextGraphicsDevice != gPhysDispVGA)
                    {
                        PhysDispTmp = PhysDispTmp->pNextGraphicsDevice;
                        continue;
                    }

                    PhysDispTmp->pNextGraphicsDevice = gPhysDispVGA->pNextGraphicsDevice;

                    if (PhysDispTmp->pNextGraphicsDevice == NULL)
                    {
                        gpGraphicsDeviceListLast = PhysDispTmp;
                    }

                    break;
                }
            }

            //
            // Mark the VGA as a VGA so we can do easy test later to match
            // graphics devices.
            //

            gPhysDispVGA->pVgaDevice = gPhysDispVGA;

            //
            // If VGA device is in use, replace all ppdev
            // references to it with the new device and
            // update state on new device.
            //

            if (VGAInUse)
            {
                DWORD VGATransferFlags = (DISPLAY_DEVICE_ATTACHED_TO_DESKTOP |
                                          DISPLAY_DEVICE_PRIMARY_DEVICE);

                PhysDispMarkVga->stateFlags |= gPhysDispVGA->stateFlags & VGATransferFlags;
                gPhysDispVGA->stateFlags &= ~VGATransferFlags;

                for (ppdev = gppdevList; ppdev != NULL; ppdev = ppdev->ppdevNext)
                {
                    if (ppdev->pGraphicsDevice == gPhysDispVGA)
                    {
                        ppdev->pGraphicsDevice = PhysDispMarkVga;
                    }
                }
            }
        }

        GreReleaseSemaphoreEx(ghsemDriverMgmt);
    }

    //
    // Save the VGA device
    //

    PhysDispMarkVga->pVgaDevice = PhysDispIsVga;

    //
    // Build the list of text modes for this device
    //

    TRACE_INIT(("Drv_Trace: LoadDriver: get text modes\n"));



    Status = GreDeviceIoControl(PhysDispIsVga->pDeviceHandle,
                                IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES,
                                NULL,
                                0,
                                &NumModes,
                                NumModesLength,
                                &BytesReturned);

    cbBuffer = NumModes.NumModes * NumModes.ModeInformationLength;

    if ( (NT_SUCCESS(Status)) &&
         (lpModes = (PVIDEO_MODE_INFORMATION)
              PALLOCMEM(cbBuffer, GDITAG_DRVSUP)) )
    {
        Status = GreDeviceIoControl(PhysDispIsVga->pDeviceHandle,
                                    IOCTL_VIDEO_QUERY_AVAIL_MODES,
                                    NULL,
                                    0,
                                    lpModes,
                                    cbBuffer,
                                    &BytesReturned);

        pVideoModeSave = lpModes;

        //
        // We will not support more than three text modes.
        // So just allocate enough for that.
        //


        if ((NT_SUCCESS(Status)) &&
            (pUsDevmode = (LPDEVMODEW)PALLOCMEM(3 * sizeof(DEVMODEW), GDITAG_DRVSUP)) &&
            (pUsDevmodeMark = (LPDEVMODEMARK)PALLOCMEM(3 * sizeof(DEVMODEMARK), GDITAG_DRVSUP)) )
        {
            TRACE_INIT(("Drv_Trace: LoadDriver: parsing fullscreen modes\n"));

            while (cbBuffer != 0)
            {
                if (lpModes->AttributeFlags & VIDEO_MODE_COLOR)
                {
                    if (lpModes->AttributeFlags & VIDEO_MODE_GRAPHICS)
                    {
                        if (cGraphicsModes)
                        {
                            goto ConsoleNextMode;
                        }

                        ptmpDevmode = pUsDevmode + 2;

                        //
                        // Make sure we have only one graphics mode
                        //

                        if (IsNEC_98)
                        {
                            if ((lpModes->VisScreenWidth != 640)  ||
                                (lpModes->VisScreenHeight != 480) ||
                                ((lpModes->NumberOfPlanes *
                                  lpModes->BitsPerPlane) != 8))
                            {
                                goto ConsoleNextMode;
                            }
                        }
                        else if ((lpModes->VisScreenWidth != 640)  ||
                                 (lpModes->VisScreenHeight != 480) ||
                                 ((lpModes->NumberOfPlanes *
                                   lpModes->BitsPerPlane) != 4))
                        {
                            goto ConsoleNextMode;
                        }

                        TRACE_INIT(("Drv_Trace: DrvInitConsole: VGA graphics mode\n"));
                        cGraphicsModes++;
                    }
                    else
                    {
                        ptmpDevmode = pUsDevmode + cTextModes;

                        //
                        // Make sure we have only 2 text modes
                        //

                        if (cTextModes == 2)
                        {
                            RIP("Drv_Trace: VGA compatible device has too many text modes\n");

                            goto ConsoleNextMode;
                        }

                        TRACE_INIT(("Drv_Trace: DrvInitConsole: VGA text mode\n"));
                        cTextModes++;
                    }

                    RtlZeroMemory(ptmpDevmode, sizeof(DEVMODEW));

                    if (!(lpModes->AttributeFlags & VIDEO_MODE_GRAPHICS))
                    {
                        ptmpDevmode->dmDisplayFlags = DMDISPLAYFLAGS_TEXTMODE;
                    }

                    memcpy(ptmpDevmode->dmDeviceName,
                           L"FULLSCREEN CONSOLE",
                           sizeof(L"FULLSCREEN CONSOLE"));

                    ptmpDevmode->dmSize = sizeof(DEVMODEW);
                    ptmpDevmode->dmSpecVersion = DM_SPECVERSION;
                    ptmpDevmode->dmDriverVersion = DM_SPECVERSION;

                    ptmpDevmode->dmPelsWidth =
                        lpModes->VisScreenWidth;
                    ptmpDevmode->dmPelsHeight =
                        lpModes->VisScreenHeight;
                    ptmpDevmode->dmBitsPerPel =
                        lpModes->NumberOfPlanes *
                        lpModes->BitsPerPlane;
                    ptmpDevmode->dmDisplayOrientation = DMDO_DEFAULT;
                    ptmpDevmode->dmDisplayFixedOutput = DMDFO_DEFAULT;

                    ptmpDevmode->dmFields = DM_BITSPERPEL       |
                                            DM_PELSWIDTH        |
                                            DM_PELSHEIGHT       |
                                            DM_DISPLAYFREQUENCY |
                                            DM_DISPLAYFLAGS     |
                                            DM_DISPLAYORIENTATION;

                    //
                    // NOTE !!!
                    // As a hack, lets store the mode number in
                    // a field we don't use
                    //

                    ptmpDevmode->dmOrientation =
                        (USHORT) lpModes->ModeIndex;
                }

ConsoleNextMode:
                cbBuffer -= NumModes.ModeInformationLength;
                lpModes = (PVIDEO_MODE_INFORMATION)
                    (((PUCHAR)lpModes) + NumModes.ModeInformationLength);
            }
        }

        VFREEMEM(pVideoModeSave);
    }

    //
    // if everything went OK with that, then we can save this
    // device as vga compatible !
    //
    // If no modes are available, do not setup this device.
    // Otherwise, EnumDisplaySettings will end up trying to get
    // the list of modes for this device, which it can not do.
    //


    if ((cGraphicsModes == 1) &&
        (cTextModes == 2))
    {
        UNICODE_STRING DeviceName;
        HANDLE         pDeviceHandle;
        PVOID          pFileObject;

        TRACE_INIT(("Drv_Trace: LoadDriver: saving VGA compatible device\n"));

        //
        // Copy the string and the handle ...
        //

        RtlCopyMemory(&gFullscreenGraphicsDevice,
                      PhysDispIsVga,
                      sizeof(GRAPHICS_DEVICE));

        //
        // 2 text modes + 1 graphics mode.
        //

        gFullscreenGraphicsDevice.cbdevmodeInfo = 3 * sizeof(DEVMODEW);
        gFullscreenGraphicsDevice.devmodeInfo   = pUsDevmode;
        gFullscreenGraphicsDevice.numRawModes = 3;
        gFullscreenGraphicsDevice.devmodeMarks  = pUsDevmodeMark;
        for (ULONG i = 0; i < 3; i++)
        {
            pUsDevmodeMark[i].bPruned = 0;
            pUsDevmodeMark[i].pDevMode = &pUsDevmode[i];
        }

        //
        // Write the name of the fullscreen device in the registry.
        //

        RtlInitUnicodeString(&DeviceName,
                             gFullscreenGraphicsDevice.szNtDeviceName);

        RtlWriteRegistryValue(RTL_REGISTRY_DEVICEMAP,
                              L"Video",
                              L"VgaCompatible",
                              REG_SZ,
                              DeviceName.Buffer,
                              DeviceName.Length + sizeof(UNICODE_NULL));

        //
        // Now create the FE fullscreen device.
        //

        RtlInitUnicodeString(&DeviceName, DD_FULLSCREEN_VIDEO_DEVICE_NAME);

        Status = IoGetDeviceObjectPointer(&DeviceName,
                                          (ACCESS_MASK) (0),
                                          (PFILE_OBJECT *) &pFileObject,
                                          (PDEVICE_OBJECT *) &pDeviceHandle);

        if (NT_SUCCESS(Status))
        {
            gFeFullscreenGraphicsDevice.hkClassDriverConfig = 0;
            gFeFullscreenGraphicsDevice.pDeviceHandle = pDeviceHandle;

            RtlCopyMemory(&gFeFullscreenGraphicsDevice,
                          DD_FULLSCREEN_VIDEO_DEVICE_NAME,
                          sizeof(DD_FULLSCREEN_VIDEO_DEVICE_NAME));
        }
    }

    //
    // Make VGA the head of list, so that VGA always get processed first upon mode change 
    // And make it "\\.\Display1" for compatibility purpose
    //
    if (PhysDispMarkVga != gpGraphicsDeviceList)
    {
        for (PhysDispTmp = gpGraphicsDeviceList;
             PhysDispTmp != NULL;
             PhysDispTmp = PhysDispTmp->pNextGraphicsDevice)
        {
            if (PhysDispTmp->pNextGraphicsDevice == PhysDispMarkVga)
            {
                break;
            }
        }

        ASSERTGDI (PhysDispTmp != NULL, "VGA device should alway be in gpGraphicsDeviceList chain\n");

        PhysDispTmp->pNextGraphicsDevice = PhysDispMarkVga->pNextGraphicsDevice;
        PhysDispMarkVga->pNextGraphicsDevice = gpGraphicsDeviceList;
        gpGraphicsDeviceList = PhysDispMarkVga;
        if (gpGraphicsDeviceListLast == PhysDispMarkVga)
            gpGraphicsDeviceListLast = PhysDispTmp;

    }
        
    if (wcscmp(gpGraphicsDeviceList->szWinDeviceName, L"\\\\.\\DISPLAY1") != 0)
    {
        for (PhysDispTmp = gpGraphicsDeviceList;
             PhysDispTmp != NULL;
             PhysDispTmp = PhysDispTmp->pNextGraphicsDevice)
        {
            if (wcscmp(PhysDispTmp->szWinDeviceName, L"\\\\.\\DISPLAY1") == 0)
            {
                wcscpy(PhysDispTmp->szWinDeviceName, gpGraphicsDeviceList->szWinDeviceName);
            }
        }
        wcscpy(gpGraphicsDeviceList->szWinDeviceName, L"\\\\.\\DISPLAY1");
    }

    return PhysDispMarkVga;
}


#ifdef IOCTL_VIDEO_USE_DEVICE_IN_SESSION

BOOL
bSetDeviceSessionUsage(
    PGRAPHICS_DEVICE PhysDisp,
    BOOL bEnable
    )
{
    GDIFunctionID(bSetDeviceSessionUsage);

    ASSERTGDI(PhysDisp != NULL, "NULL Graphics Device\n");

    BOOL    bRet;

    // Virtual devices (meta, mirror, remote, and disconnect) have the
    // capability of being used in multiple sessions since there is no
    // physical device.
    // NOTE: What are the implications for mirroring drivers?
    if (PhysDisp != (PGRAPHICS_DEVICE) DDML_DRIVER &&
        !(PhysDisp->stateFlags & (DISPLAY_DEVICE_MIRRORING_DRIVER | 
                                  DISPLAY_DEVICE_REMOTE | 
                                  DISPLAY_DEVICE_DISCONNECT)))
    {
        NTSTATUS                    Status;
        DWORD                       dwBytesReturned;
        VIDEO_DEVICE_SESSION_STATUS vdSessionStatus = { bEnable, FALSE };

        ASSERTGDI(PhysDisp->pDeviceHandle != NULL, "Physical device has NULL handle.");

        Status = GreDeviceIoControl(PhysDisp->pDeviceHandle,
                                    IOCTL_VIDEO_USE_DEVICE_IN_SESSION,
                                    &vdSessionStatus,
                                    sizeof(vdSessionStatus),
                                    &vdSessionStatus,
                                    sizeof(vdSessionStatus),
                                    &dwBytesReturned);

        if (NT_SUCCESS(Status))
        {
            if (!vdSessionStatus.bSuccess)
            {
                if (bEnable)
                {
                    DbgPrint("Trying to enable physical device already in use.\n");
                }
                else
                {
                    DbgPrint("Trying to disable physical device not enabled in this session.\n");
                }
            }

            bRet = vdSessionStatus.bSuccess;
        }
        else
        {
            WARNING("IOCTL_VIDEO_USE_DEVICE_IN_SESSION requested failed.");
            bRet = TRUE;
        }
    }
    else
    {
        bRet = TRUE;
    }

    return bRet;
}

#endif IOCTL_VIDEO_USE_DEVICE_IN_SESSION


extern "C"
VOID
CloseLocalGraphicsDevices()
{

  PGRAPHICS_DEVICE  PhysDisp = NULL;

  TRACE_INIT(("CloseLocalGraphicsDevices\n"));

  if (gpLocalGraphicsDeviceList == NULL) {
      TRACE_INIT(("CloseLocalGraphicsDevices - gpLocalGraphicsDeviceList is not st yet\n"));
      return;
  }

  for (PhysDisp = gpLocalGraphicsDeviceList;
       PhysDisp != NULL;
       PhysDisp = PhysDisp->pNextGraphicsDevice)
  {
      if (PhysDisp->pFileObject != NULL) {
          TRACE_INIT(("CloseLocalGraphicsDevices, Closing : %ws\n", PhysDisp->szNtDeviceName));
          ObDereferenceObject(PhysDisp->pFileObject);
          PhysDisp->pDeviceHandle = NULL;
          PhysDisp->pFileObject = NULL;
      }

  }

  // If there is a separate VGA device close it too

  if ( (gPhysDispVGA != NULL)  && (gPhysDispVGA->pFileObject != NULL) ) {
      ObDereferenceObject(gPhysDispVGA->pFileObject);
      gPhysDispVGA->pDeviceHandle = NULL;
      gPhysDispVGA->pFileObject = NULL;
  }
}

extern "C"
VOID
OpenLocalGraphicsDevices()
{

  UNICODE_STRING DeviceName;
  PGRAPHICS_DEVICE  PhysDisp = NULL;
  NTSTATUS status;
  BOOL bVgaDeviceInList = FALSE;

  TRACE_INIT(("OpenLocalGraphicsDevices\n"));

  if (gpLocalGraphicsDeviceList == NULL) {
      TRACE_INIT(("OpenLocalGraphicsDevices - gpLocalGraphicsDeviceList is not st yet\n"));
      return;
  }

  for (PhysDisp = gpLocalGraphicsDeviceList;
       PhysDisp != NULL;
       PhysDisp = PhysDisp->pNextGraphicsDevice)
  {
      if (PhysDisp->pFileObject == NULL) {

          TRACE_INIT(("OpenLocalGraphicsDevices opening : %ws\n", PhysDisp->szNtDeviceName));
          RtlInitUnicodeString(&DeviceName, PhysDisp->szNtDeviceName);
          status = IoGetDeviceObjectPointer(&DeviceName,
                                            (ACCESS_MASK) (0),
                                            (PFILE_OBJECT *) &PhysDisp->pFileObject,
                                            (PDEVICE_OBJECT *)&PhysDisp->pDeviceHandle);
          if (PhysDisp == gPhysDispVGA ) {
              bVgaDeviceInList = TRUE;
          }
          if (!NT_SUCCESS(status)) {
              TRACE_INIT(("OpenLocalGraphicsDevices failed with status %0x\n", status));
          }  else{
              TRACE_INIT(("OpenLocalGraphicsDevices OK\n"));
          }
      }

  }

  // If there is a separate VGA device, Open it too

  if (!bVgaDeviceInList && (gPhysDispVGA != NULL)) {
      RtlInitUnicodeString(&DeviceName, gPhysDispVGA->szNtDeviceName);
      status = IoGetDeviceObjectPointer(&DeviceName,
                                        (ACCESS_MASK) (0),
                                        (PFILE_OBJECT *) &gPhysDispVGA->pFileObject,
                                        (PDEVICE_OBJECT *)&gPhysDispVGA->pDeviceHandle);
      if (!NT_SUCCESS(status)) {
          TRACE_INIT(("OpenLocalGraphicsDevices failed to ope VGA device  with status %0x\n", status));
      }  else{
          TRACE_INIT(("OpenLocalGraphicsDevices, open VGA device OK\n"));
      }
  }
}

extern "C"
BOOL
DrvSetGraphicsDevices(PWSTR pDisplayDriverName)
{

    BOOL bLocal;


    if (gProtocolType == PROTOCOL_CONSOLE) {
        bLocal = TRUE;
    } else {
        bLocal = FALSE;
    }
    wcscpy(G_DisplayDriverNames, pDisplayDriverName);

    return (DrvUpdateGraphicsDeviceList(TRUE,FALSE,bLocal));

}

/**************************************************************************\
* DrvUpdateGraphicsDeviceList
*
* Update the list of devices in the PhysDisp linked list.
*
* This function return TRUE for SUCCESS
* If the functions returns FALSE, the it means the active HDEV should be
* disabled, and we should get called back With the parameter being set to TRUE.
*
* 09-Oct-1996 andreva created
* Updates the local graphics device list or the remote graphics device list.
* This function is called on InitVideo but also by xxxRemoteReconnect since
* At reconnect the list may change ( case of reconnecting a session with a
* client from a different protocol or case of reconnecting the console session
* to a remote client or reconnecting an inialy remote session to the local
* console video.
\**************************************************************************/

BOOL
DrvUpdateGraphicsDeviceList(
    BOOL bDefaultDisplayDisabled,
    BOOL bReenumerationNeeded,
    BOOL bLocal)
{
    ULONG              deviceNumber = 0;
    BOOL               newDevice = FALSE;
    WCHAR              devName[32];
    UNICODE_STRING     DeviceName;
    PDEVICE_OBJECT     pDeviceHandle = NULL;
    PVOID              pFileObject;

    PWSTR             *SymbolicLinkList;
    BOOL               bGotMonitorPdos;
    PDEVICE_RELATIONS  pDeviceRelations;

    NTSTATUS           status;
    PGRAPHICS_DEVICE   PhysDisp = NULL;
    HANDLE             hkRegistry = NULL;

    VIDEO_WIN32K_CALLBACKS videoCallback;
    ULONG                  bytesReturned;
    BOOL               bReturn = TRUE;


    TRACE_INIT(("Drv_Trace: DrvUpdateGraphicsDeviceList: Enter\n"));

    //
    // ISSUE - we don't handle deletions !!!
    //

    //
    // If the maximum value has increased for video device objects, then
    // go open the new ones.
    //
    if ( bLocal ) {
        gcNextGlobalDeviceNumber = gcLocalNextGlobalDeviceNumber;
        gpGraphicsDeviceList = gpLocalGraphicsDeviceList;
        gpGraphicsDeviceListLast =gpLocalGraphicsDeviceListLast;
        gcNextGlobalPhysicalOutputNumber = gcLocalNextGlobalPhysicalOutputNumber;
        gcNextGlobalVirtualOutputNumber = gcLocalNextGlobalVirtualOutputNumber;
        ULONG defaultValue = 0;

        RTL_QUERY_REGISTRY_TABLE QueryTable[] = {
            {NULL, RTL_QUERY_REGISTRY_DIRECT, L"MaxObjectNumber",
             &deviceNumber, REG_DWORD, &defaultValue, 4},
            {NULL, 0, NULL}
        };

        RtlQueryRegistryValues(RTL_REGISTRY_DEVICEMAP,
                               L"VIDEO",
                               &QueryTable[0],
                               NULL,
                               NULL);
    } else{
        gcNextGlobalDeviceNumber = gcRemoteNextGlobalDeviceNumber;
        gpGraphicsDeviceList = gpRemoteGraphicsDeviceList;
        gpGraphicsDeviceListLast =gpRemoteGraphicsDeviceListLast;
        gcNextGlobalPhysicalOutputNumber = gcRemoteNextGlobalPhysicalOutputNumber;
        gcNextGlobalVirtualOutputNumber = gcRemoteNextGlobalVirtualOutputNumber;

        //
        // If we don't yet have this protocol in our remote device list,
        // Set deviceNumber in a way that we'll iterate once to create
        // a GRAPHICS_DEVICE for it, otherwise set to zero so that we don't 
        // create a new GRAPHICS_DEVICE.
        //
        if (gProtocolType != PROTOCOL_DISCONNECT && !DrvIsProtocolAlreadyKnown()) {
            deviceNumber = gcRemoteProtocols;
        }
    }


    // IoGetDeviceInterfaces(GUID_DISPLAY_INTERFACE_STANDARD,
    //			     NULL,

    //                       0,
    //                       &SymbolicLinkList);


    while (gProtocolType != PROTOCOL_DISCONNECT && gcNextGlobalDeviceNumber <= deviceNumber)
    {
        TRACE_INIT(("Drv_Trace:DrvUpdateGraphicsDeviceList: Device %d\n", gcNextGlobalDeviceNumber));

        if (bDefaultDisplayDisabled == FALSE) {

            TRACE_INIT(("Drv_Trace:DrvUpdateGraphicsDeviceList: Exit RETRY\n\n"));

            return FALSE;
        }

        newDevice = TRUE;

        swprintf(devName,
                 L"\\Device\\Video%d",
                 gcNextGlobalDeviceNumber);

        RtlInitUnicodeString(&DeviceName, devName);

        TRACE_INIT(("Drv_Trace: \tNewDevice: Try creating device %ws\n",
                    devName));

        if ( !bLocal )
        {
            //
            // FOR HYDRA
            //

            pFileObject = (PFILE_OBJECT)G_RemoteVideoFileObject;
            pDeviceHandle = IoGetRelatedDeviceObject ((PFILE_OBJECT)pFileObject);

            if (pDeviceHandle) {
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_OBJECT_NAME_NOT_FOUND;
            }
            //deviceNumber = 0; //Only one display driver for remote sessions
        }
        else
        {
            //
            // Opening a new device will cause the Initialize
            // routine of a miniport driver to be called.
            // This may cause the driver to change some state, which could
            // affect the state of another driver on the same device
            // (opening the weitek driver if the vga is running.
            //
            // For that reason, the other device should be temporarily
            // closed down when we do the create, and then reinitialized
            // afterwards.
            //
            // Handle special case when we are opening initial device and
            // gpDispInfo->hDev does not exist yet.
            //

            status = IoGetDeviceObjectPointer(&DeviceName,
                                              (ACCESS_MASK) (0),
                                              (PFILE_OBJECT *) &pFileObject,
                                              &pDeviceHandle);
        }

        //
        // if we got a configuration error from the device (HwInitialize
        // routine failed, then just go on to the next device.
        //

        if (!NT_SUCCESS(status))
        {
            TRACE_INIT(("Drv_Trace: \tNewDevice: No such device - Status is %0x\n",status));

            //
            // For remote devices, we don't want to increment the Next device number
            // if we are not creating the device. The reason is that remote devices
            // do not have a fixed number and we  want to use a device number only
            // if we are really creating a remote device for it.

            if (bLocal) {
                gcNextGlobalDeviceNumber++;
                continue;
            }
            break;
        }

        //
        // Allocate a buffer if necessary:
        //

        if (PhysDisp == NULL)
        {
            PhysDisp = (PGRAPHICS_DEVICE) PALLOCMEM(sizeof(GRAPHICS_DEVICE),
                                                    GDITAG_GDEVICE);
        }

        if (PhysDisp)
        {
            PhysDisp->numMonitorDevice = 0;
            PhysDisp->MonitorDevices = NULL;
            PhysDisp->pDeviceHandle = (HANDLE) pDeviceHandle;
            PhysDisp->ProtocolType = gProtocolType;
            if (!bLocal) {
                PhysDisp->stateFlags |= DISPLAY_DEVICE_REMOTE;
            }

            if (bLocal) {
               PhysDisp->pFileObject = pFileObject;
            } else {
               PhysDisp->pFileObject = NULL;
            }

            bGotMonitorPdos = FALSE;

            if (bLocal)
            {
                //
                // Tell the video port driver about us so we can
                // do power management notifucations
                //
                RtlZeroMemory(&videoCallback, sizeof(VIDEO_WIN32K_CALLBACKS));
                videoCallback.PhysDisp = PhysDisp;
                videoCallback.Callout  = VideoPortCallout;

                status = GreDeviceIoControl(PhysDisp->pDeviceHandle,
                                            IOCTL_VIDEO_INIT_WIN32K_CALLBACKS,
                                            &videoCallback,
                                            sizeof(VIDEO_WIN32K_CALLBACKS),
                                            &videoCallback,
                                            sizeof(VIDEO_WIN32K_CALLBACKS),
                                            &bytesReturned);

                if (videoCallback.bACPI)
                {
                    PhysDisp->stateFlags |= DISPLAY_DEVICE_ACPI;
                }
                if (videoCallback.DualviewFlags & VIDEO_DUALVIEW_REMOVABLE)
                {
                    PhysDisp->stateFlags |= DISPLAY_DEVICE_REMOVABLE;
                }
                if (videoCallback.DualviewFlags & (VIDEO_DUALVIEW_PRIMARY | VIDEO_DUALVIEW_SECONDARY))
                {
                    PhysDisp->stateFlags |= DISPLAY_DEVICE_DUALVIEW;
                }

                PhysDisp->pPhysDeviceHandle = videoCallback.pPhysDeviceObject;

                ASSERT(NT_SUCCESS(status));
            }

            //
            // For a PnP Driver, get the PDO so we can enumerate the monitors
            //

            status = DrvSendPnPIrp(pDeviceHandle,
                                   TargetDeviceRelation,
                                   &pDeviceRelations);

            if (NT_SUCCESS(status))
            {
                PDEVICE_OBJECT pdoVideoChip = pDeviceRelations->Objects[0];
                PDEVICE_OBJECT pdoChild;
                PDEVICE_OBJECT *pActivePdos, *pPdos;
                ULONG_PTR      cCount = 0;
                ULONG          i;
                WCHAR          className[8];
                NTSTATUS       status2;

                ASSERTGDI(pDeviceRelations->Count == 1,
                          "TargetDeviceRelation should only get one PDO\n");

                //
                // Note: free with ExFreePool rather than GdiFreePool
                // because pDeviceRelations is allocated by IoAllocateIrp
                // (ntos\io\iosubs.c) in DrvSendPnPIrp.
                //

                ExFreePool(pDeviceRelations);

                //
                // In 5.0, the driver configuration data is stored under
                // Class\GUID\xxx
                //
                TRACE_INIT(("Drv_Trace: \tNewDevice: Get device Configuration from Class Key\n"));

                status = IoOpenDeviceRegistryKey(pdoVideoChip,
                                                 PLUGPLAY_REGKEY_DRIVER,
                                                 MAXIMUM_ALLOWED,
                                                 &hkRegistry);

                if (NT_SUCCESS(status))
                {
                    PVIDEO_MONITOR_DEVICE pMonitorDevices = NULL;
                    ULONG           numMonitorDevice = 0;

                    //
                    // Force all the monitors on this device to be enumerated.
                    //

                    if (bReenumerationNeeded) {
                        IoSynchronousInvalidateDeviceRelations(pdoVideoChip, BusRelations);
                    }

                    if (NT_SUCCESS(GreDeviceIoControl(pDeviceHandle,
                                                      IOCTL_VIDEO_ENUM_MONITOR_PDO,
                                                      NULL,
                                                      0,
                                                      &pMonitorDevices,
                                                      sizeof(PVOID),
                                                      &bytesReturned))
                        && pMonitorDevices != NULL)
                    {
                        bGotMonitorPdos = TRUE;

                        //
                        // Get the number of PDOs
                        //
                        numMonitorDevice = 0;
                        while (pMonitorDevices[numMonitorDevice].pdo != NULL)
                        {
                            ObDereferenceObject(pMonitorDevices[numMonitorDevice].pdo);
                            numMonitorDevice++;
                        }
                    }

                    //
                    // Create the standard graphics device
                    //
                    TRACE_INIT(("Drv_Trace: \tNewDevice: Get display Configuration from Class Key\n"));

                    DrvGetDeviceConfigurationInformation(PhysDisp, hkRegistry, TRUE);

                    //
                    // Per Monitor Settings
                    //
                    if (bGotMonitorPdos && numMonitorDevice)
                    {
                        PhysDisp->numMonitorDevice = numMonitorDevice;
                        PhysDisp->MonitorDevices = (PVIDEO_MONITOR_DEVICE)
                                                   PALLOCMEM(sizeof(VIDEO_MONITOR_DEVICE) * numMonitorDevice,
                                                             GDITAG_GDEVICE);
                        for (cCount = 0; cCount < numMonitorDevice; cCount++)
                        {
                            PhysDisp->MonitorDevices[cCount].flag   = 0;
                            if (pMonitorDevices[cCount].flag & VIDEO_CHILD_ACTIVE) {
                                PhysDisp->MonitorDevices[cCount].flag |= DISPLAY_DEVICE_ACTIVE;
                            }
                            if ((pMonitorDevices[cCount].flag & VIDEO_CHILD_DETACHED) == 0) {
                                PhysDisp->MonitorDevices[cCount].flag |= DISPLAY_DEVICE_ATTACHED;
                            }
                            if ((pMonitorDevices[cCount].flag & VIDEO_CHILD_NOPRUNE_FREQ) == 0) {
                                PhysDisp->MonitorDevices[cCount].flag |= DISPLAY_DEVICE_PRUNE_FREQ;
                            }
                            if ((pMonitorDevices[cCount].flag & VIDEO_CHILD_NOPRUNE_RESOLUTION) == 0) {
                                PhysDisp->MonitorDevices[cCount].flag |= DISPLAY_DEVICE_PRUNE_RESOLUTION;
                            }
                            PhysDisp->MonitorDevices[cCount].pdo    = pMonitorDevices[cCount].pdo;
                            PhysDisp->MonitorDevices[cCount].HwID   = pMonitorDevices[cCount].HwID;
                        }
                    }

                    if (bGotMonitorPdos)
                    {
                        ExFreePool(pMonitorDevices);
                    }

                    ZwCloseKey(hkRegistry);
                }

                ObDereferenceObject(pdoVideoChip);
            }
            else if ((PhysDisp->stateFlags & DISPLAY_DEVICE_DUALVIEW) &&
                     PhysDisp->pPhysDeviceHandle )
            {
                //
                // For Dualview secondary, there is no real PDO
                //
                status = IoOpenDeviceRegistryKey((PDEVICE_OBJECT)PhysDisp->pPhysDeviceHandle,
                                                 PLUGPLAY_REGKEY_DRIVER,
                                                 MAXIMUM_ALLOWED,
                                                 &hkRegistry);
                if (NT_SUCCESS(status))
                {
                    DrvGetDeviceConfigurationInformation(PhysDisp, hkRegistry, TRUE);
                    ZwCloseKey(hkRegistry);
                }
            }

            //
            // Do this here as this field must be initialized for the next
            // function call.
            //

            swprintf(&(PhysDisp->szNtDeviceName[0]),
                     L"\\Device\\Video%d",
                     gcNextGlobalDeviceNumber++);

            //
            // If the software key information could not be obtained,
            // try the legacy location
            // In 4.0, the driver configuration data was located in
            // <services>\DeviceX
            //

            if (!NT_SUCCESS(status))
            {
                TRACE_INIT(("Drv_Trace: \tNewDevice: Failed to get PDO device Configuration info\n"));

                hkRegistry = DrvGetRegistryHandleFromDeviceMap(
                                                   PhysDisp,
                                                   DispDriverRegGlobal,
                                                   NULL,
                                                   NULL,
                                                   &status,
                                                   gProtocolType);

                //
                // Start at entry 2 in the list because we want to skip the
                // subdirectory
                //

                if (NT_SUCCESS(status))
                {
                    DrvGetDeviceConfigurationInformation(PhysDisp, hkRegistry, FALSE);
                    ZwCloseKey(hkRegistry);
                }
            }

            //
            // VGA driver and other old, MS detected drivers may have no
            // description string.  Add *something*.
            //

            if ((NT_SUCCESS(status)) &&
                (PhysDisp->DeviceDescription == NULL))
            {
                if (PhysDisp->DeviceDescription = (LPWSTR) PALLOCNOZ(32, GDITAG_DRVSUP))
                {
                    hkRegistry = DrvGetRegistryHandleFromDeviceMap(
                                                       PhysDisp,
                                                       DispDriverRegGlobal,
                                                       NULL,
                                                       PhysDisp->DeviceDescription,
                                                       &status,
                                                       gProtocolType);
                    if (hkRegistry)
                    {
                        ZwCloseKey(hkRegistry);
                    }
                }
                else
                {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }

            if (PhysDisp->DeviceDescription == NULL) {
                WARNING("\nDisplay Device Description is NULL!\n");
            }


            //
            // If the device exists, keep it open and try the next one.
            // Here we give Mirroring driver different names.  Many applications assumes
            // "\\.\Display1" as their primary display.  But sometimes, mirroring driver
            // gets loaded first, thus makes the assumption go complete bogus.
            //

            if (PhysDisp->stateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER)
            {
                swprintf(&(PhysDisp->szWinDeviceName[0]),
                         L"\\\\.\\DISPLAYV%d",
                         gcNextGlobalVirtualOutputNumber++);
            }
            else
            {
                swprintf(&(PhysDisp->szWinDeviceName[0]),
                         L"\\\\.\\DISPLAY%d",
                         gcNextGlobalPhysicalOutputNumber++);
            }

            //
            // Link the new device at the end so we can enumerate
            // in the right order. For remote devices, link the 
            // device to the list only if everything worked fine.
            //
            if (bLocal || NT_SUCCESS(status)) {
                if (gpGraphicsDeviceList == NULL)
                {
                    gpGraphicsDeviceList = PhysDisp;
                    gpGraphicsDeviceListLast = PhysDisp;
                }
                else
                {
                    gpGraphicsDeviceListLast->pNextGraphicsDevice = PhysDisp;
                    gpGraphicsDeviceListLast = PhysDisp;
                }
                //
                // We have successfully installed a GRAPHICS_DEVICE for a new
                // remote protocol : increment known protocols count.
                //
                if (!bLocal) {
                    gcRemoteProtocols++;
                }
            } else {
                DrvCleanupOneGraphicsDevice(PhysDisp);
                gcNextGlobalPhysicalOutputNumber--;
                PhysDisp = NULL;
                bReturn = FALSE;
            }

            PhysDisp = NULL;
        }
    }

    //
    // Update the VGA device on the console.
    //

    if (bLocal && newDevice)
    {
        PGRAPHICS_DEVICE PhysDispVGA = DrvUpdateVgaDevice();

        if (gbBaseVideo)
        {
            DrvSetSingleDisplay(PhysDispVGA);
        }
    }


    // Create the entry for the Disconnect graphics device
    if (DrvSetDisconnectedGraphicsDevice(bLocal)) {
        TRACE_INIT(("DrvSetDisconnectedGraphicsDevice succeeded!\n"));
    }  else{
        TRACE_INIT(("DrvSetDisconnectedGraphicsDevice Failed!\n"));
    }

    // write any change back to device lists

    if ( bLocal ) {
         gcLocalNextGlobalDeviceNumber = gcNextGlobalDeviceNumber;
         gpLocalGraphicsDeviceList = gpGraphicsDeviceList;
         gpLocalGraphicsDeviceListLast = gpGraphicsDeviceListLast;
         gcLocalNextGlobalPhysicalOutputNumber = gcNextGlobalPhysicalOutputNumber;
         gcLocalNextGlobalVirtualOutputNumber = gcNextGlobalVirtualOutputNumber;
    } else{
         gcRemoteNextGlobalDeviceNumber = gcNextGlobalDeviceNumber;
         gpRemoteGraphicsDeviceList = gpGraphicsDeviceList;
         gpRemoteGraphicsDeviceListLast = gpGraphicsDeviceListLast;
         gcRemoteNextGlobalPhysicalOutputNumber = gcNextGlobalPhysicalOutputNumber;
         gcRemoteNextGlobalVirtualOutputNumber = gcNextGlobalVirtualOutputNumber;
    }

    TRACE_INIT(("DrvUpdateGraphicsDeviceList - gpGraphicsDeviceList : %x\n",gpGraphicsDeviceList));
    TRACE_INIT(("DrvUpdateGraphicsDeviceList - gpLocalGraphicsDeviceList : %x\n",gpLocalGraphicsDeviceList));
    TRACE_INIT(("DrvUpdateGraphicsDeviceList - gpRemoteGraphicsDeviceList : %x\n",gpRemoteGraphicsDeviceList));
    TRACE_INIT(("Drv_Trace:DrvUpdateGraphicsDeviceList: Exit\n\n"));

    return bReturn;
}

/***************************************************************************\
* DrvSetDisconnectedGraphicsDevice
* Creates an Entry for the disconnect grapgics device (either for the local
* or for the remote list.
\***************************************************************************/
BOOL
DrvSetDisconnectedGraphicsDevice(
    BOOL bLocal)
{
    const WCHAR        DisconnectDeviceName[] = L"\\Device\\Disc";
    NTSTATUS           status;
    PGRAPHICS_DEVICE   PhysDisp = NULL;
    HANDLE             hkRegistry = NULL;
    BOOL               bReturn = FALSE;

    TRACE_INIT(("Drv_Trace:DrvSetDisconnectedGraphicsDevice: \n"));

    if ((bLocal && gpLocalDiscGraphicsDevice != NULL  ) ||
        (!bLocal && gpRemoteDiscGraphicsDevice != NULL))
    {
        TRACE_INIT(("DrvSetDisconnectedGraphicsDevice - Device already set"));
        return TRUE;
    }

    //
    // Allocate a buffer .
    //

    PhysDisp = (PGRAPHICS_DEVICE) PALLOCMEM(sizeof(GRAPHICS_DEVICE),
                                                    GDITAG_GDEVICE);
    if (PhysDisp)
    {
        UNICODE_STRING DeviceName;

        //
        // Assign NtDeviceName as "\\Device\\Disc".
        // This has to be have an entry in DEVICEMAP\Video 
        //
        RtlInitUnicodeString(&DeviceName,
                             L"\\REGISTRY\\Machine\\System\\CurrentControlSet\\Services\\TSDDD\\Device0");
        RtlWriteRegistryValue(RTL_REGISTRY_DEVICEMAP,
                              L"VIDEO",
                              DisconnectDeviceName,
                              REG_SZ,
                              DeviceName.Buffer,
                              DeviceName.Length + sizeof(UNICODE_NULL));

        RtlCopyMemory(&(PhysDisp->szNtDeviceName[0]), DisconnectDeviceName, sizeof(DisconnectDeviceName));

        PhysDisp->numMonitorDevice = 0;
        PhysDisp->MonitorDevices = NULL;
        PhysDisp->stateFlags |= DISPLAY_DEVICE_DISCONNECT;
        PhysDisp->ProtocolType = PROTOCOL_DISCONNECT;


        // Read device Configuration from registry

        hkRegistry = DrvGetRegistryHandleFromDeviceMap(
                                          PhysDisp,
                                          DispDriverRegGlobal,
                                          NULL,
                                          NULL,
                                          &status,
                                          PROTOCOL_DISCONNECT);


        if (NT_SUCCESS(status))
        {
            DrvGetDeviceConfigurationInformation(PhysDisp, hkRegistry, FALSE);
            ZwCloseKey(hkRegistry);
            bReturn = TRUE;
        }

        //
        // If we haven't specified a device description set it to something.
        //

        if ((NT_SUCCESS(status)) &&
           (PhysDisp->DeviceDescription == NULL))
        {
            if (PhysDisp->DeviceDescription = (LPWSTR) PALLOCNOZ(32, GDITAG_DRVSUP))
            {
                hkRegistry = DrvGetRegistryHandleFromDeviceMap(PhysDisp,
                                                               DispDriverRegGlobal,
                                                               NULL,
                                                               PhysDisp->DeviceDescription,
                                                               &status,
                                                               PROTOCOL_DISCONNECT);
                if (hkRegistry)
                {
                    ZwCloseKey(hkRegistry);
                }
            }
            else
            {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if (!NT_SUCCESS(status))
           {
	     if (PhysDisp->DisplayDriverNames != NULL) {
		 VFREEMEM(PhysDisp->DisplayDriverNames);
             }
             VFREEMEM(PhysDisp);
             return FALSE;
           }

        //
        // Set WinDeviceName (name for extenal reference; usually \\.\DISPLAY#)
        //

        swprintf(&(PhysDisp->szWinDeviceName[0]),L"WinDisc");

        PhysDisp->pDeviceHandle = (HANDLE) NULL;

        //
        // Link the new device at the end so we can enumerate
        // in the right order.
        //

        if (gpGraphicsDeviceList == NULL)
        {
            gpGraphicsDeviceList = PhysDisp;
            gpGraphicsDeviceListLast = PhysDisp;
        }
        else
        {
            gpGraphicsDeviceListLast->pNextGraphicsDevice = PhysDisp;
            gpGraphicsDeviceListLast = PhysDisp;
        }

        if (bLocal)
        {
            gpLocalDiscGraphicsDevice = PhysDisp;
        }
        else
        {
            gpRemoteDiscGraphicsDevice = PhysDisp;
        }
    }

    return bReturn;
}

/***************************************************************************\
* DrvEnumDisplaySettings
*
* Routines that enumerate the list of modes available in the driver.
*
*             andreva       Created
\***************************************************************************/

NTSTATUS
DrvEnumDisplaySettings(
    PUNICODE_STRING pstrDeviceName,
    HDEV            hdevPrimary,
    DWORD           iModeNum,
    LPDEVMODEW      lpDevMode,
    DWORD           dwFlags)
{
    GDIFunctionID(DrvEnumDisplaySettings);

    NTSTATUS         retval = STATUS_INVALID_PARAMETER_1;
    PGRAPHICS_DEVICE PhysDisp = NULL;
    USHORT           DriverExtraSize;

    TRACE_INIT(("Drv_Trace: DrvEnumDisplaySettings\n"));

    //
    // Probe the DeviceName and the DEVMODE.
    //

    __try
    {
        ProbeForRead(lpDevMode, sizeof(DEVMODEW), sizeof(USHORT));

        DriverExtraSize = lpDevMode->dmDriverExtra;

        ProbeForWrite(lpDevMode,
                      sizeof(DEVMODEW) + DriverExtraSize,
                      sizeof(USHORT));


        if (lpDevMode->dmSize != sizeof(DEVMODEW))
        {
            return STATUS_BUFFER_TOO_SMALL;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        return GetExceptionCode();
    }

    if (pstrDeviceName)
    {
        PhysDisp = DrvGetDeviceFromName(pstrDeviceName, UserMode);
    }
    else
    {
        PDEVOBJ pdo(hdevPrimary);

        if (pdo.bValid())
        {
            PhysDisp = pdo.ppdev->pGraphicsDevice;
        }
    }

    if (PhysDisp)
    {
        //
        // -3 means we want the Monitor prefered DEVMODE
        //
        if (iModeNum == (DWORD) -3) // ENUM_MONITOR_PREFERED
        {
            retval = DrvGetPreferredMode(lpDevMode, PhysDisp);
        }

        //
        // -2 means we want the registry DEVMODE to do matching on the
        // client side.
        //

        else if (iModeNum == (DWORD) -2) // ENUM_REGISTRY_SETTINGS
        {
            PDEVMODEW pdevmode;

            TRACE_INIT(("DrvEnumDisp: -2 mode\n"));

            pdevmode = (PDEVMODEW) PALLOCMEM(sizeof(DEVMODEW) + MAXUSHORT,
                                                GDITAG_DEVMODE);

            if (pdevmode)
            {
                pdevmode->dmSize        = 0xDDDD;
                pdevmode->dmDriverExtra = MAXUSHORT;

                retval = DrvGetDisplayDriverParameters(PhysDisp,
                                                       pdevmode,
                                                       FALSE,
                                                       FALSE);

                if (NT_SUCCESS(retval))
                {
                    __try
                    {
                        DriverExtraSize = min(DriverExtraSize,
                                              pdevmode->dmDriverExtra);

                        RtlCopyMemory(lpDevMode + 1,
                                      pdevmode + 1,
                                      DriverExtraSize);

                        RtlCopyMemory(lpDevMode,
                                      pdevmode,
                                      sizeof(DEVMODEW));

                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        retval = STATUS_INVALID_PARAMETER_3;
                    }
                }
                VFREEMEM(pdevmode);
            }

        }
        //
        // -1 means returns the current device mode.
        // We store the full DEVMODE in the
        //

        else if (iModeNum == (DWORD) -1) // ENUM_CURRENT_SETTINGS
        {
            PPDEV ppdev;

            TRACE_INIT(("DrvEnumDisp: -1 mode\n"));

            //
            // Since we are accessing variable fields off of this device,
            // acquire the lock for them.
            //

            GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);

            //
            // Find the currently adtive PDEV on this device.
            //

            for (ppdev = gppdevList; ppdev != NULL; ppdev = ppdev->ppdevNext)
            {
                PDEVOBJ po((HDEV) ppdev);

                //
                // Also need to check VGA(alias) device
                //
                if (((po.ppdev->pGraphicsDevice == PhysDisp) ||
                    ((po.ppdev->pGraphicsDevice == PhysDisp->pVgaDevice) &&
                     (po.ppdev->pGraphicsDevice != NULL)))
                    && (!po.bDeleted()))
                {
                    __try
                    {
                        DriverExtraSize = min(DriverExtraSize,
                                              po.ppdev->ppdevDevmode->dmDriverExtra);

                        //
                        // We know the DEVMODE we called the driver with is of
                        // size sizeof(DEVMODEW)
                        //

                        RtlCopyMemory(lpDevMode + 1,
                                      po.ppdev->ppdevDevmode + 1,
                                      DriverExtraSize);

                        RtlCopyMemory(lpDevMode,
                                      po.ppdev->ppdevDevmode,
                                      sizeof(DEVMODEW));

                        retval = STATUS_SUCCESS;

                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        retval = STATUS_INVALID_PARAMETER_3;
                    }

                    break;
                }
            }

            GreReleaseSemaphoreEx(ghsemDriverMgmt);
        }
        else
        {
            //
            // We don't need synchronize access to the list of modes.
            // Who cares.
            //

            DrvBuildDevmodeList(PhysDisp, FALSE);

            //
            // now return the information
            //

            if ( (PhysDisp->cbdevmodeInfo == 0) ||
                 (PhysDisp->devmodeInfo == NULL) )
            {
                WARNING("EnumDisplaySettings PhysDisp is inconsistent\n");
                retval = STATUS_UNSUCCESSFUL;
            }
            else
            {
                LPDEVMODEW lpdm = NULL;
                DWORD      i, count;

                retval = STATUS_INVALID_PARAMETER_2;

                if (iModeNum < PhysDisp->numRawModes)
                {
                    if (dwFlags & EDS_RAWMODE)
                        lpdm = PhysDisp->devmodeMarks[iModeNum].pDevMode;
                    else
                    {
                        for (i = 0, count = 0; i < PhysDisp->numRawModes; i++)
                        {
                            if (PhysDisp->devmodeMarks[i].bPruned)
                                continue;
                            if (count == iModeNum)
                            {
                                lpdm = PhysDisp->devmodeMarks[i].pDevMode;
                                break;
                            }
                            count++;
                        }
                    }
                }

                if (lpdm)
                {
                    __try
                    {
                        DriverExtraSize = min(DriverExtraSize,
                                              lpdm->dmDriverExtra);

                        RtlZeroMemory(lpDevMode, sizeof(*lpDevMode));

                        //
                        // Check the size since the devmode returned
                        // by the driver can be smaller than the current
                        // size.
                        //

                        RtlCopyMemory(lpDevMode + 1,
                                      ((PUCHAR)lpdm) + lpdm->dmSize,
                                      DriverExtraSize);

                        RtlCopyMemory(lpDevMode,
                                      lpdm,
                                      min(sizeof(DEVMODEW), lpdm->dmSize));

                        retval = STATUS_SUCCESS;
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        retval = STATUS_INVALID_PARAMETER_3;
                    }
                }
            }

            //
            // As an acceleration, we will only free the list if the call
            // failed because "i" was too large, so that listing all the modes
            // does not require building the list each time.
            //

            if (retval == STATUS_INVALID_PARAMETER_2)
            {
                //
                // Free up the resources - as long as it's not the VGA.
                // Assume the VGA is always first
                //

                if (PhysDisp != &gFullscreenGraphicsDevice)
                {
                    PhysDisp->cbdevmodeInfo = 0;

                    if (PhysDisp->devmodeInfo)
                    {
                        VFREEMEM(PhysDisp->devmodeInfo);
                        PhysDisp->devmodeInfo = NULL;
                    }
                    if (PhysDisp->devmodeMarks)
                    {
                        VFREEMEM(PhysDisp->devmodeMarks);
                        PhysDisp->devmodeMarks = NULL;
                    }
                    PhysDisp->numRawModes = 0;
                }
            }
        }
    }

    //
    // Update the driver extra size
    //

    if (retval == STATUS_SUCCESS)
    {
        __try
        {
            lpDevMode->dmDriverExtra = DriverExtraSize;
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            retval = GetExceptionCode();
        }
    }

    return (retval);
}

/***************************************************************************\
*
* DrvEnumDisplayDevices
*
* History:
\***************************************************************************/

NTSTATUS
DrvEnumDisplayDevices(
    PUNICODE_STRING   pstrDeviceName,
    HDEV              hdevPrimary,
    DWORD             iDevNum,
    LPDISPLAY_DEVICEW lpDisplayDevice,
    DWORD             dwFlags,
    MODE              PreviousMode)
{
    PGRAPHICS_DEVICE  PhysDisp;
    ULONG             cbSize;
    ULONG             cCount = 0;
    PDEVICE_OBJECT    pdo = NULL;
    NTSTATUS          retStatus = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(dwFlags);
    UNREFERENCED_PARAMETER(hdevPrimary);

    if (pstrDeviceName == NULL)
    {
        //
        // Start enumerating at 0 ...
        //

        for (PhysDisp = gpGraphicsDeviceList;
             PhysDisp != NULL;
             PhysDisp = PhysDisp->pNextGraphicsDevice, cCount++)
        {
            //
            // Do not enumerate the disconnected DD for user mode callers.
            //
            if ((PreviousMode != KernelMode) &&
                (PhysDisp->stateFlags & DISPLAY_DEVICE_DISCONNECT))
            {
                cCount--;
                continue;
             }

            if (cCount == iDevNum)
                break;
        }

        if (PhysDisp == NULL)
        {
            return STATUS_UNSUCCESSFUL;
        }

        PDEVICE_RELATIONS  pDeviceRelations;

        //pDeviceHandle migth be NULL in the case of the disconnected DD which
        //has no associated miniport.

        if (PhysDisp->pPhysDeviceHandle) {
            pdo = (PDEVICE_OBJECT)PhysDisp->pPhysDeviceHandle;
        }
        else if ((PDEVICE_OBJECT)PhysDisp->pDeviceHandle != NULL) {
            if (NT_SUCCESS(DrvSendPnPIrp((PDEVICE_OBJECT)PhysDisp->pDeviceHandle,
                                         TargetDeviceRelation,
                                         &pDeviceRelations) )
               )
            {
                pdo = pDeviceRelations->Objects[0];
                ASSERTGDI(pDeviceRelations->Count == 1,
                          "TargetDeviceRelation should only get one PDO\n");

                ExFreePool(pDeviceRelations);
            }
        }else{
            TRACE_INIT(("DrvEnumDisplayDevices - processing the disconnected GRAPHICS_DEVICE\n"));
        }
    }
    else
    {
        UpdateMonitorDevices();

        PhysDisp = DrvGetDeviceFromName(pstrDeviceName, PreviousMode);
        if (PhysDisp == NULL)
            return STATUS_UNSUCCESSFUL;
        if (iDevNum >= PhysDisp->numMonitorDevice)
            return STATUS_UNSUCCESSFUL;
        pdo = (PDEVICE_OBJECT)PhysDisp->MonitorDevices[iDevNum].pdo;
    }

    //
    // We found the device, so the call will be successful unless
    // we except later on.
    //

    __try
    {
        PVOID pBuffer;
        NTSTATUS status;

        //
        // Capture the input buffer length
        //

        TRACE_INIT(("Drv_Trace: DrvEnumDisplayDevices %d\n", iDevNum));

        if (PreviousMode == UserMode)
        {
            cbSize = ProbeAndReadUlong(&(lpDisplayDevice->cb));
            ProbeForWrite(lpDisplayDevice, cbSize, sizeof(DWORD));
        }
        else
        {
            ASSERTGDI(lpDisplayDevice >= (LPDISPLAY_DEVICEW const)MM_USER_PROBE_ADDRESS,
                      "Bad kernel mode address\n");

            cbSize = lpDisplayDevice->cb;
        }

        RtlZeroMemory(lpDisplayDevice, cbSize);

        if (cbSize >= FIELD_OFFSET(DISPLAY_DEVICEW, DeviceName))
        {
            lpDisplayDevice->cb = FIELD_OFFSET(DISPLAY_DEVICEW, DeviceName);
        }
        if (cbSize >= FIELD_OFFSET(DISPLAY_DEVICEW, DeviceString))
        {
            lpDisplayDevice->cb = FIELD_OFFSET(DISPLAY_DEVICEW, DeviceString);

            if (pstrDeviceName == NULL)
                RtlCopyMemory(lpDisplayDevice->DeviceName,
                              PhysDisp->szWinDeviceName,
                              sizeof(PhysDisp->szWinDeviceName));
            else
                swprintf(lpDisplayDevice->DeviceName,
                         L"%ws\\Monitor%d",
                         PhysDisp->szWinDeviceName, iDevNum);
            lpDisplayDevice->DeviceName[31] = 0;
        }
        if (cbSize >= FIELD_OFFSET(DISPLAY_DEVICEW, StateFlags))
        {

            lpDisplayDevice->cb = FIELD_OFFSET(DISPLAY_DEVICEW, StateFlags);
            lpDisplayDevice->DeviceString[0] = 0;

            if (pstrDeviceName == NULL)
            {
                if (PhysDisp->DeviceDescription)
                    wcsncpy(lpDisplayDevice->DeviceString, PhysDisp->DeviceDescription, 127);
            }
            else if (pdo)
            {
                //
                // Get the name for this device.
                // Documentation says to try in a loop.
                //
                cCount = 256;
                while (1)
                {
                    pBuffer = PALLOCNOZ(cCount, 'ddeG');
                    if (pBuffer == NULL)
                    {
                        retStatus = STATUS_INSUFFICIENT_RESOURCES;
                        break;
                    }
                    status = IoGetDeviceProperty(pdo,
                                                 DevicePropertyDeviceDescription,
                                                 cCount,
                                                 pBuffer,
                                                 &cCount);
                    if (status == STATUS_BUFFER_TOO_SMALL)
                    {
                        VFREEMEM(pBuffer);
                        continue;
                    }
                    else if (status == STATUS_SUCCESS)
                    {
                        wcsncpy(lpDisplayDevice->DeviceString, (LPWSTR)pBuffer, 127);
                        VFREEMEM(pBuffer);
                        break;
                    }
                    VFREEMEM(pBuffer);
                    break;
                }
            }
            lpDisplayDevice->DeviceString[127] = 0;
        }
        if (cbSize >= FIELD_OFFSET(DISPLAY_DEVICEW, DeviceID))
        {
            lpDisplayDevice->cb = FIELD_OFFSET(DISPLAY_DEVICEW, DeviceID);

            if (pstrDeviceName == NULL)
                lpDisplayDevice->StateFlags = PhysDisp->stateFlags & 0x0FFFFFFF;
            else
                lpDisplayDevice->StateFlags = PhysDisp->MonitorDevices[iDevNum].flag & 0x0FFFFFFF;
        }

        if (cbSize >= FIELD_OFFSET(DISPLAY_DEVICEW, DeviceKey))
        {
            lpDisplayDevice->cb = FIELD_OFFSET(DISPLAY_DEVICEW, DeviceKey);

            lpDisplayDevice->DeviceID[0] = 0;

            if (pdo)
            {
                cCount = 256;
                while (1)
                {
                    pBuffer = PALLOCNOZ(cCount, 'ddeG');
                    if (pBuffer == NULL)
                    {
                        retStatus = STATUS_INSUFFICIENT_RESOURCES;
                        break;
                    }

                    status = IoGetDeviceProperty(pdo,
                                                 DevicePropertyHardwareID,
                                                 cCount,
                                                 pBuffer,
                                                 &cCount);
                    if (status == STATUS_BUFFER_TOO_SMALL)
                    {
                        VFREEMEM(pBuffer);
                        continue;
                    }
                    else if (status == STATUS_SUCCESS)
                    {
                        wcsncpy(lpDisplayDevice->DeviceID, (LPWSTR)pBuffer, 127);
                        VFREEMEM(pBuffer);
                        break;
                    }
                    VFREEMEM(pBuffer);
                    break;
                }
                // For Monitor devices, we will make the ID unique.
                // Applet and GDIs are expecting this behavior.
                if (pstrDeviceName != NULL)
                {
                    lpDisplayDevice->DeviceID[127] = 0;
                    cCount = wcslen(lpDisplayDevice->DeviceID)+1;
                    if (cCount < 126)
                    {
                        lpDisplayDevice->DeviceID[cCount-1] = L'\\';
                        status = IoGetDeviceProperty(pdo,
                                                     DevicePropertyDriverKeyName,
                                                     (127-cCount)*sizeof(WCHAR),
                                                     (PBYTE)(lpDisplayDevice->DeviceID+cCount),
                                                     &cCount);
                    }
                }
            }
            lpDisplayDevice->DeviceID[127] = 0;
        }
        if (cbSize >= sizeof(DISPLAY_DEVICEW))
        {
            lpDisplayDevice->cb = sizeof(DISPLAY_DEVICEW);

            lpDisplayDevice->DeviceKey[0] = 0;

            if (pstrDeviceName == NULL)
            {
                DrvGetRegistryHandleFromDeviceMap(PhysDisp, DispDriverRegKey, NULL, lpDisplayDevice->DeviceKey, NULL, gProtocolType);
            }
            else
            {
                NTSTATUS    Status;
                WCHAR       driverRegistryPath[127];

                Status = IoGetDeviceProperty(pdo,
                                 DevicePropertyDriverKeyName,
                                 127*sizeof(WCHAR),
                                 (PBYTE)driverRegistryPath,
                                 &cCount);
                if (NT_SUCCESS(Status))
                {
                    wcscpy(lpDisplayDevice->DeviceKey, REGSTR_CCS);
                    cCount = wcslen(lpDisplayDevice->DeviceKey);
                    wcsncpy(lpDisplayDevice->DeviceKey+cCount, L"\\Control\\Class\\", 127-cCount);
                    cCount = wcslen(lpDisplayDevice->DeviceKey);
                    wcsncpy(lpDisplayDevice->DeviceKey+cCount, driverRegistryPath, 127-cCount);
                }
            }
            lpDisplayDevice->DeviceKey[127] = 0;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        WARNINGX(100);
        retStatus = STATUS_UNSUCCESSFUL;
    }

    if (pstrDeviceName == NULL && pdo && (PhysDisp->pPhysDeviceHandle == NULL))
    {
        ObDereferenceObject(pdo);
    }

    return retStatus;
}


/******************************Public*Routine******************************\
* DrvGetDriverAccelerationsLevel()
*
* Reads the driver acceleration 'filter' level from the registry.  This
* values determines how we let the display driver do in terms of
* accelerations, where a value of 0 means full acceleration.
*
* 20-Aug-1998 -by- Hideyuki Nagase [hideyukn]
* Lifted it from AndrewGo's code.
\**************************************************************************/

#define ACCEL_REGKEY  L"Acceleration.Level"
#define CAPABLE_REGKEY  L"CapabilityOverride"    // Driver capable override
#define ACCEL_BUFSIZE (sizeof(KEY_VALUE_FULL_INFORMATION) + sizeof(ACCEL_REGKEY) + sizeof(DWORD))
#define CAPABLE_BUFSIZE (sizeof(KEY_VALUE_FULL_INFORMATION) + sizeof(CAPABLE_REGKEY) + sizeof(DWORD))

DWORD
DrvGetDriverAccelerationsLevel(
    PGRAPHICS_DEVICE pGraphicsDevice
)
{
    HANDLE                      hkRegistry;
    UNICODE_STRING              UnicodeString;
    DWORD                       dwReturn = DRIVER_ACCELERATIONS_INVALID;
    BYTE                        buffer[ACCEL_BUFSIZE];
    ULONG                       Length = ACCEL_BUFSIZE;
    PKEY_VALUE_FULL_INFORMATION Information = (PKEY_VALUE_FULL_INFORMATION) buffer;
    WCHAR                       aszValuename[] = ACCEL_REGKEY;

    if (pGraphicsDevice == (PGRAPHICS_DEVICE) DDML_DRIVER)
    {
        dwReturn = 0;
    }

    if (dwReturn == DRIVER_ACCELERATIONS_INVALID)
    {
        //
        // See adaptor specific setting first.
        //

        hkRegistry = DrvGetRegistryHandleFromDeviceMap(
                         pGraphicsDevice,
                         DispDriverRegGlobal,
                         NULL,
                         NULL,
                         NULL,
                         gProtocolType);

        if (hkRegistry)
        {
            RtlInitUnicodeString(&UnicodeString, aszValuename);

            if (NT_SUCCESS(ZwQueryValueKey(hkRegistry,
                                           &UnicodeString,
                                           KeyValueFullInformation,
                                           Information,
                                           Length,
                                           &Length)))
            {
                dwReturn = *(LPDWORD) ((((PUCHAR)Information) +
                                      Information->DataOffset));
            }

            ZwCloseKey(hkRegistry);
        }
    }

    if (dwReturn == DRIVER_ACCELERATIONS_INVALID)
    {
        //
        // If there is nothing specified, assume full acceleration.
        //

        dwReturn = DRIVER_ACCELERATIONS_FULL;
    }
    else if (dwReturn > DRIVER_ACCELERATIONS_NONE)
    {
        //
        // If there is something invalid value, assume no acceleration.
        //

        dwReturn = DRIVER_ACCELERATIONS_NONE;
    }

    if (G_fDoubleDpi)
    {
        //
        // Always set accelerations to 'none' when operating in double-the-
        // dpi mode, so that panning.cxx can create a virtual display
        // larger than the actual physical display.
        //

        dwReturn = DRIVER_ACCELERATIONS_NONE;
    }

    #if DBG
    if (pGraphicsDevice != (PGRAPHICS_DEVICE) DDML_DRIVER)
    {
        DbgPrint("GDI: DriverAccelerationLevel on %ws is %d\n",
              pGraphicsDevice->szWinDeviceName, dwReturn);
    }
    #endif

    return(dwReturn);
}

DWORD
DrvGetDriverCapableOverRide(
    PGRAPHICS_DEVICE pGraphicsDevice
)
{
    HANDLE                      hkRegistry;
    UNICODE_STRING              UnicodeString;
    DWORD                       dwReturn = DRIVER_CAPABLE_ALL;
    BYTE                        buffer[CAPABLE_BUFSIZE];
    ULONG                       ulLength = CAPABLE_BUFSIZE;
    ULONG                       ulActualLength;
    PKEY_VALUE_FULL_INFORMATION Information = (PKEY_VALUE_FULL_INFORMATION)buffer;
    WCHAR                       aszValuename[] = CAPABLE_REGKEY;

    if ( pGraphicsDevice == (PGRAPHICS_DEVICE)DDML_DRIVER )
    {
        return DRIVER_CAPABLE_ALL;
    }

    //
    // See adaptor specific setting first.
    //
    hkRegistry = DrvGetRegistryHandleFromDeviceMap(
                                                  pGraphicsDevice,
                                                  DispDriverRegGlobal,
                                                  NULL,
                                                  NULL,
                                                  NULL,
                                                  gProtocolType);

    if ( hkRegistry )
    {
        RtlInitUnicodeString(&UnicodeString, aszValuename);

        if ( NT_SUCCESS(ZwQueryValueKey(hkRegistry,
                                        &UnicodeString,
                                        KeyValueFullInformation,
                                        Information,
                                        ulLength,
                                        &ulActualLength)) )
        {
            dwReturn = *(LPDWORD)((((PUCHAR)Information)
                                   + Information->DataOffset));
        }

        ZwClose(hkRegistry);
    }

    #if DBG
    if ( pGraphicsDevice != (PGRAPHICS_DEVICE) DDML_DRIVER )
    {
        DbgPrint("GDI: DriverCapableOverride on %ws is %d\n",
                 pGraphicsDevice->szWinDeviceName, dwReturn);
    }
    #endif

    return(dwReturn);
}// DrvGetDriverCapableOverRide()

VOID
DrvUpdateAttachFlag(PGRAPHICS_DEVICE PhysDisp, DWORD attach)
{
    HANDLE hkRegistry = DrvGetRegistryHandleFromDeviceMap(PhysDisp,
                                                          DispDriverRegHardwareProfileCreate,
                                                          NULL,
                                                          NULL,
                                                          NULL,
                                                          gProtocolType);
    if (hkRegistry)
    {
        RtlWriteRegistryValue(RTL_REGISTRY_HANDLE,
                              (PCWSTR)hkRegistry,
                              (PWSTR)AttachedSettings[1],
                              REG_DWORD,
                              &attach,
                              sizeof(DWORD));
        ZwCloseKey(hkRegistry);
    }
}

/***************************************************************************\
*
* DrvEnableMDEV
*
* Enables a display MDEV.
*
* Should only be called from USER under the global CRIT
*
\***************************************************************************/

ULONG gtmpAssertModeFailed;

BOOL
DrvEnableDisplay(
    HDEV hdev
    )
{
    PDEVOBJ po(hdev);

    TRACE_INIT(("\nDrv_Trace: DrvEnableDisplay: Enter\n"));

    ASSERTGDI(po.bValid(), "HDEV failure\n");
    ASSERTGDI(po.bDisplayPDEV(), "HDEV is not a display device\n");
    ASSERTGDI(po.bDisabled(), "HDEV must be disabled to call enable\n");
    ASSERTGDI(po.ppdev->pGraphicsDevice, "HDEV must be on a device\n");

    //
    // Acquire the display locks here because we may get called from within
    // ChangeDisplaySettings to enable\disable a particular device when
    // creating the new HDEVs.
    //

    GreAcquireSemaphoreEx(ghsemShareDevLock, SEMORDER_SHAREDEVLOCK, NULL);
    GreAcquireSemaphoreEx(po.hsemDevLock(), SEMORDER_DEVLOCK, NULL);
    GreAcquireSemaphoreEx(po.hsemPointer(), SEMORDER_POINTER, po.hsemDevLock());
    GreEnterMonitoredSection(po.ppdev, WD_DEVLOCK);

    //
    // Enable the screen
    // Repeat the call until it works.
    //

    bSetDeviceSessionUsage(po.ppdev->pGraphicsDevice, TRUE);

    gtmpAssertModeFailed = 0;
    while (!((*PPFNDRV(po,AssertMode))(po.dhpdev(), TRUE)))
    {
        gtmpAssertModeFailed = 1;
    }

    //
    // Clear the PDEV for use
    //

    po.bDisabled(FALSE);

    GreExitMonitoredSection(po.ppdev, WD_DEVLOCK);
    GreReleaseSemaphoreEx(po.hsemPointer());
    GreReleaseSemaphoreEx(po.hsemDevLock());
    GreReleaseSemaphoreEx(ghsemShareDevLock);

    //
    // Allow DirectDraw to be reenabled.
    //

    GreResumeDirectDraw(hdev, FALSE);

    TRACE_INIT(("Drv_Trace: DrvEnableDisplay: Leave\n"));

    return TRUE;
}

BOOL
DrvEnableMDEV(
    PMDEV pmdev,
    BOOL bHardware
    )
{
    GDIFunctionID(DrvEnableMDEV);

    ULONG i;
    ERESOURCE_THREAD lockOwner;

    TRACE_INIT(("\nDrv_Trace: DrvEnableMDEV: Enter\n"));

    PDEVOBJ poParent(pmdev->hdevParent);

#if MDEV_STACK_TRACE_LENGTH
    LONG    lMDEVTraceEntry, lMDEVTraceEntryNext;
    ULONG   StackEntries, UserStackEntry;

    do
    {
        lMDEVTraceEntry = glMDEVTrace;
        lMDEVTraceEntryNext = lMDEVTraceEntry + 1;
        if (lMDEVTraceEntryNext >= gcMDEVTraceLength) lMDEVTraceEntryNext = 0;
    } while (InterlockedCompareExchange(&glMDEVTrace, lMDEVTraceEntryNext, lMDEVTraceEntry) != lMDEVTraceEntry);

    RtlZeroMemory(&gMDEVTrace[lMDEVTraceEntry],
                  sizeof(gMDEVTrace[lMDEVTraceEntry]));
    gMDEVTrace[lMDEVTraceEntry].pMDEV = pmdev;
    gMDEVTrace[lMDEVTraceEntry].API   = ((bHardware) ? DrvEnableMDEV_HWOn : DrvEnableMDEV_FromGRE);
    StackEntries = sizeof(gMDEVTrace[lMDEVTraceEntry].Trace)/sizeof(gMDEVTrace[lMDEVTraceEntry].Trace[0]);
    UserStackEntry = RtlWalkFrameChain((PVOID *)gMDEVTrace[lMDEVTraceEntry].Trace,
                                       StackEntries, 
                                       0);
    StackEntries -= UserStackEntry;
    RtlWalkFrameChain((PVOID *)&gMDEVTrace[lMDEVTraceEntry].Trace[UserStackEntry],
                      StackEntries,
                      1);
#endif

    for (i = 0; i < pmdev->chdev; i++)
    {
        PDEVOBJ po(pmdev->Dev[i].hdev);
        if (bHardware ||
            ((po.ppdev->pGraphicsDevice->stateFlags & DISPLAY_DEVICE_DUALVIEW) &&
             gbInvalidateDualView &&
             po.bDisabled())
           )
        {
            DrvEnableDisplay(po.hdev());
        }
    }

    //
    // Wait for the display to become available and unlock it.
    //

    GreAcquireSemaphoreEx(ghsemShareDevLock, SEMORDER_SHAREDEVLOCK, NULL);
    GreAcquireSemaphoreEx(poParent.hsemDevLock(), SEMORDER_DEVLOCK, NULL);
    GreAcquireSemaphoreEx(poParent.hsemPointer(), SEMORDER_POINTER, poParent.hsemDevLock());
    GreEnterMonitoredSection(poParent.ppdev, WD_DEVLOCK);

    if (bHardware)
    {
        poParent.bDisabled(FALSE);
    }

    //
    // Get the palette
    //

    XEPALOBJ pal(poParent.ppalSurf());
    ASSERTGDI(pal.bValid(), "EPALOBJ failure\n");

    if (pal.bIsPalManaged())
    {
        ASSERTGDI(PPFNVALID(poParent,SetPalette), "ERROR palette is not managed");

        (*PPFNDRV(poParent,SetPalette))(poParent.dhpdev(),
                                        (PALOBJ *) &pal,
                                        0,
                                        0,
                                        pal.cEntries());
    }
    else if (pmdev->chdev > 1)
    {
        //
        // Only for multi-monitor case.
        //

        PDEVOBJ pdoChild;

        for (i = 0; i < pmdev->chdev; i++)
        {
            pdoChild.vInit(pmdev->Dev[i].hdev);

            if (pdoChild.bIsPalManaged())
            {
                XEPALOBJ palChild(pdoChild.ppalSurf());

                // Don't use PPFNDRV(pdoChild,...) since need to send
                // this through DDML.

                pdoChild.pfnSetPalette()(pdoChild.dhpdevParent(),
                                         (PALOBJ *) &palChild,
                                         0,
                                         0,
                                         palChild.cEntries());

                break;
            }

            pdoChild.vInit(NULL);
        }

        // Even if parent is not pal-managed, but any of children are palette
        // managed, need to reset one of them (only 1 is enough, since
        // colour table is shared across all device palette)
        //
        // Realize halftone palette to secondary device

        if (pdoChild.bValid())
        {
            KdPrint(("GDI DDML: Primary is not 8bpp, but one of display is 8bpp\n"));

            if (!DrvRealizeHalftonePalette(pdoChild.hdev(),TRUE))
            {
                KdPrint(("GDI DDML: Failed to realize HT palette on secondary\n"));
            }
        }
    }

    GreExitMonitoredSection(poParent.ppdev, WD_DEVLOCK);
    GreReleaseSemaphoreEx(poParent.hsemPointer());
    GreReleaseSemaphoreEx(poParent.hsemDevLock());
    GreReleaseSemaphoreEx(ghsemShareDevLock);

    if (bHardware)
    {
        //
        // Allow DirectDraw to be reenabled.
        //

        GreResumeDirectDraw(pmdev->hdevParent, FALSE);
    }

    TRACE_INIT(("Drv_Trace: DrvEnableMDEV: Leave\n"));

    return TRUE;
}


/***************************************************************************\
*
* DrvDisableDisplay
*
* Disables a display device.
*
\***************************************************************************/

BOOL
DrvDisableDisplay(
    HDEV hdev,
    BOOL bClear
    )
{
    GDIFunctionID(DrvDisableDisplay);

    BOOL bRet;
    PDEVOBJ po(hdev);

    TRACE_INIT(("\nDrv_Trace: DrvDisableDisplay: Enter\n"));

    ASSERTGDI(po.bValid(), "HDEV failure\n");
    ASSERTGDI(po.bDisplayPDEV(), "HDEV is not a display device\n");
    ASSERTGDI(!po.bDisabled(), "HDEV must be enabled to call disable\n");

    //
    // Disable DirectDraw.
    //

    GreSuspendDirectDraw(hdev, FALSE);

    //
    // Acquire the display locks here because we may get called from within
    // ChangeDisplaySettings to enable\disable a particular device when
    // creating the new HDEVs.
    //

    GreAcquireSemaphoreEx(ghsemShareDevLock, SEMORDER_SHAREDEVLOCK, NULL);
    GreAcquireSemaphoreEx(po.hsemDevLock(), SEMORDER_DEVLOCK, NULL);
    GreAcquireSemaphoreEx(po.hsemPointer(), SEMORDER_POINTER, po.hsemDevLock());
    GreEnterMonitoredSection(po.ppdev, WD_DEVLOCK);

    if (bClear && !po.bDisabled()) {

        PDEV *pdev = (PDEV*)hdev;
        ERECTL erclDst(0,0,pdev->pSurface->sizl().cx, pdev->pSurface->sizl().cy);

        //
        // The display is about to be disabled, but some
        // display drivers don't blank the display.
        // We explicitly blank the display here.
        //

        (*(pdev->pSurface->pfnBitBlt()))(pdev->pSurface->pSurfobj(),
                                         (SURFOBJ *) NULL,
                                         (SURFOBJ *) NULL,
                                         NULL,
                                         NULL,
                                         &erclDst,
                                         (POINTL *)  NULL,
                                         (POINTL *)  NULL,
                                         NULL,
                                         NULL,
                                         0
                                         );
    }

    //
    // The device may have something going on, synchronize with it first
    //

    po.vSync(po.pSurface()->pSurfobj(), NULL, 0);

    //
    // Disable the screen
    //

    bRet = (*PPFNDRV(po,AssertMode))(po.dhpdev(), FALSE);

    if (bRet)
    {
        //
        // Mark the PDEV as disabled
        //

        bSetDeviceSessionUsage(po.ppdev->pGraphicsDevice, FALSE);

        po.bDisabled(TRUE);

        gtmpAssertModeFailed = 0;
    }
    else
    {
        gtmpAssertModeFailed = 1;
    }

    GreExitMonitoredSection(po.ppdev, WD_DEVLOCK);
    GreReleaseSemaphoreEx(po.hsemPointer());
    GreReleaseSemaphoreEx(po.hsemDevLock());
    GreReleaseSemaphoreEx(ghsemShareDevLock);

    if (!bRet)
    {
        //
        // We have to undo our 'GreSuspendDirectDraw' call:
        //

        GreResumeDirectDraw(hdev, FALSE);
    }

    TRACE_INIT(("Drv_Trace: DrvDisableDisplay: Leave\n"));

    return (bRet);
}


/***************************************************************************\
*
* DrvDisableMDEV
*
* Disables a display MDEV.
*
* Should only be called from USER under the global CRIT
*
\***************************************************************************/

BOOL
DrvDisableMDEV(
    PMDEV pmdev,
    BOOL bHardware
    )
{
    GDIFunctionID(DrvDisableMDEV);

    BOOL bSuccess = TRUE;

#if MDEV_STACK_TRACE_LENGTH
    LONG    lMDEVTraceEntry, lMDEVTraceEntryNext;
    ULONG   StackEntries, UserStackEntry;

    do
    {
        lMDEVTraceEntry = glMDEVTrace;
        lMDEVTraceEntryNext = lMDEVTraceEntry + 1;
        if (lMDEVTraceEntryNext >= gcMDEVTraceLength) lMDEVTraceEntryNext = 0;
    } while (InterlockedCompareExchange(&glMDEVTrace, lMDEVTraceEntryNext, lMDEVTraceEntry) != lMDEVTraceEntry);

    RtlZeroMemory(&gMDEVTrace[lMDEVTraceEntry],
                  sizeof(gMDEVTrace[lMDEVTraceEntry]));
    gMDEVTrace[lMDEVTraceEntry].pMDEV = pmdev;
    gMDEVTrace[lMDEVTraceEntry].API   = ((bHardware) ? DrvDisableMDEV_HWOff : DrvDisableMDEV_FromGRE);
    StackEntries = sizeof(gMDEVTrace[lMDEVTraceEntry].Trace)/sizeof(gMDEVTrace[lMDEVTraceEntry].Trace[0]);
    UserStackEntry = RtlWalkFrameChain((PVOID *)gMDEVTrace[lMDEVTraceEntry].Trace,
                                       StackEntries, 
                                       0);
    StackEntries -= UserStackEntry;
    RtlWalkFrameChain((PVOID *)&gMDEVTrace[lMDEVTraceEntry].Trace[UserStackEntry],
                      StackEntries,
                      1);
#endif

#if TEXTURE_DEMO
    if (ghdevTextureParent)
    {
        WARNING("DrvDisableDisplay: Refused by texture demo");
        return(FALSE);
    }
#endif

    TRACE_INIT(("\nDrv_Trace: DrvDisableMDEV: Enter\n"));

    PDEVOBJ poParent(pmdev->hdevParent);

    if (bHardware)
    {
        //
        // Disable DirectDraw.
        //

        GreSuspendDirectDraw(pmdev->hdevParent, FALSE);
    }

    //
    // Wait for the display to become available and unlock it.
    //

    GreAcquireSemaphoreEx(ghsemShareDevLock, SEMORDER_SHAREDEVLOCK, NULL);
    GreAcquireSemaphoreEx(poParent.hsemDevLock(), SEMORDER_DEVLOCK, NULL);
    GreAcquireSemaphoreEx(poParent.hsemPointer(), SEMORDER_POINTER, poParent.hsemDevLock());
    GreEnterMonitoredSection(poParent.ppdev, WD_DEVLOCK);

    ULONG i, j;

    for (i = 0; i < pmdev->chdev; i++)
    {
        //
        // If Dualview, disable the view anyway
        //
        if (bHardware ||
            ((((PDEV *) pmdev->Dev[i].hdev)->pGraphicsDevice->stateFlags & DISPLAY_DEVICE_DUALVIEW) &&
             gbInvalidateDualView)
           )
        {
            if ((bSuccess = DrvDisableDisplay(pmdev->Dev[i].hdev, !bHardware)) == FALSE)
            {
                break;
            }
        }
    }

    //
    // If we have a failure while disabling the device, try to reenable the
    // devices that were already disabled.
    //

    if (bSuccess == FALSE)
    {
        for (j = 0; j < i; j++)
        {
            if (bHardware ||
                ((((PDEV *)pmdev->Dev[i].hdev)->pGraphicsDevice->stateFlags & DISPLAY_DEVICE_DUALVIEW) &&
                 gbInvalidateDualView)
               )
            {
                while (DrvEnableDisplay(pmdev->Dev[j].hdev) == FALSE)
                {
                    ASSERTGDI(FALSE, "We are hosed in Disable MDEV - try again!\n");
                }
            }
        }
    }

    if (bSuccess)
    {
        if (bHardware)
        {
            poParent.bDisabled(TRUE);
        }
    }

    GreExitMonitoredSection(poParent.ppdev, WD_DEVLOCK);
    GreReleaseSemaphoreEx(poParent.hsemPointer());
    GreReleaseSemaphoreEx(poParent.hsemDevLock());
    GreReleaseSemaphoreEx(ghsemShareDevLock);

    if (!bSuccess)
    {
        //
        // We have to undo our 'GreSuspendDirectDraw' call:
        //

        GreResumeDirectDraw(pmdev->hdevParent, FALSE);
    }

    TRACE_INIT(("Drv_Trace: DrvDisableMDEV: Leave\n"));

    return(bSuccess);
}


/******************************************************************************
*
* DrvDestroyMDEV
*
* Deletes a display MDEV.
*
\***************************************************************************/

VOID
DrvDestroyMDEV(
    PMDEV pmdev
)
{
    GDIFunctionID(DrvDestroyMDEV);

    ULONG i;

    // WinBug #306290 2-8-2001 jasonha STRESS: GDI: Two PDEVs using same semaphore as their DevLock
    // WinBug #24003 7-24-2000 jasonha MULTIDISPLAY: Deadlock in DrvDestroyMDEV
    //   ghsemDriverManagement used to be held throughout DrvDestroyMDEV 
    //   even when calling vUnreferencePdev, which might acquire a device
    //   lock.  This would have been ok if the device had a unique device
    //   lock, but when changing from multiple displays to one display, the
    //   shared device lock is retained by the PDEVs no being freed.  If the
    //   new primary display grabs the device lock and then tries to grab
    //   ghsemDriverMgmt as in GreCreateDisplayDC we could deadlock.
    //   ghsemDriverMgmt only needs to be held during accesses to cPdevOpenRefs.

    TRACE_INIT(("\n\nDrv_Trace: DrvDestroyMDEV: Enter\n\n"));

    for (i = 0; i < pmdev->chdev; i++)
    {
        PDEVOBJ po(pmdev->Dev[i].hdev);

        // !!! What about outstanding bitmaps?

        GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);

        ASSERTGDI(!po.bDeleted(), "Deleting an already-deleted PDEV");

        // Decrease the OpenRefCount which will
        // mark the PDEV as being deleted so that we can also stop DrvEscape
        // calls from going down (ExtEscape ignores the 'bDisabled()' flag):

        if (--po.ppdev->cPdevOpenRefs == 0)
        {
            // The PDEV should already be disabled.
            // Otherwise, we have no way of detecting whether or not we are just
            // reducing the refcount on the PDEV or not.

            if (G_fConsole) {
                ASSERTGDI(po.bDisabled(), "Deleting an enabled PDEV");
            }
        }

        GreReleaseSemaphoreEx(ghsemDriverMgmt);

        // Once all the DCs open specifically on the PDEV (if there are any)
        // are destroyed, free the PDEV:

        po.vUnreferencePdev();
    }

    // If this is multimon system, destroy parent. Otherwise
    // just skip here, since parent is same as its children
    // in signle monitor system.

    if (pmdev->chdev > 1)
    {
        PDEVOBJ po(pmdev->hdevParent);

        // !!! What about outstanding bitmaps?

        GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);

        ASSERTGDI(!po.bDeleted(), "Deleting an already-deleted Parent PDEV");

        // Decrease the OpenRefCount which will
        // mark the PDEV as being deleted so that we can also stop DrvEscape
        // calls from going down (ExtEscape ignores the 'bDisabled()' flag):

        if (--po.ppdev->cPdevOpenRefs == 0)
        {
            // The PDEV should already be disabled.
            // Otherwise, we have no way of detecting whether or not we are just
            // reducing the refcount on the PDEV or not.

            if (G_fConsole) {
                ASSERTGDI(po.bDisabled(), "Deleting an enabled Parent PDEV");
            }
        }

        GreReleaseSemaphoreEx(ghsemDriverMgmt);

        // Once all the DCs open specifically on the PDEV (if there are any)
        // are destroyed, free the PDEV:

        po.vUnreferencePdev();
    }

    TRACE_INIT(("\n\nDrv_Trace: DrvDestroyMDEV: Leave\n\n"));
}

/******************************************************************************
*
* DrvBackoutMDEV
*
* This routine basically undoes all changes made by a ChangeDisplaySettings
* call.
*
\***************************************************************************/

VOID
DrvBackoutMDEV(
    PMDEV pmdev)
{
    GDIFunctionID(DrvBackoutMDEV);

    ULONG i;
    HDEV hdev;

    //
    // First disable all the HDEVs we created.
    //

    for (i = 0; i < pmdev->chdev; i++)
    {
        hdev = pmdev->Dev[i].hdev;
        PDEVOBJ po(hdev);

        if (po.ppdev->cPdevOpenRefs == 1)
        {
            if (!DrvDisableDisplay(hdev, FALSE))
            {
                ASSERTGDI(FALSE, "Failed Undoing CreateMDEV - we are hosed !!!\n");
            }
        }

        //
        // Remove the references so this object can go away
        //

        GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);

        po.ppdev->cPdevOpenRefs--;
        po.vUnreferencePdev();

        GreReleaseSemaphoreEx(ghsemDriverMgmt);
    }

    //
    // Restore the old HDEVs
    //

    for (i = 0; i < pmdev->chdev; i++)
    {
        if ((hdev = pmdev->Dev[i].Reserved) != NULL)
        {
            PDEVOBJ po(hdev);

            //
            // Reenable the display
            //

            if (po.ppdev->cPdevOpenRefs == 1)
            {
                if (!DrvEnableDisplay(hdev))
                {
                    ASSERTGDI(FALSE, "Failed Undoing CreateMDEV - we are hosed !!!\n");
                }
            }
        }
    }
}

//*****************************************************************************
//
// hCreateHDEV
//
// Creates a PDEV that the window manager will use to open display DCs.
// This call is made by the window manager to open a new display surface
// for use.  Any number of display surfaces may be open at one time.
//
//   pDesktopId      - Unique identifier to determine the Desktop the PDEV
//                     will be associated with.
//
//   flags
//
//      GCH_DEFAULT_DISPLAY
//                   - Whether or not this is the inital display device (on
//                     which the default bitmap will be located).
//
//      GCH_DDML
//                   - The name of the display is the DDML entrypoint
//
//      GCH_PANNING
//                   - The name of the display is the PANNING entrypoint
//
//*****************************************************************************

// !!! should be partly incorporate in PDEVOBJ::PDEVOBJ since many fields
// !!! are destroyed by that destructor

HDEV
hCreateHDEV(
    PGRAPHICS_DEVICE PhysDisp,
    PDRV_NAMES       lpDisplayNames,
    PDEVMODEW        pdriv,
    PVOID            pDesktopId,
    DWORD            dwOverride,
    DWORD            dwAccelLevel,
    BOOL             bNoDisable,
    FLONG            flags,
    HDEV            *phDevDisabled
)
{
    GDIFunctionID(hCreateHDEV);

    ULONG  i;
    PDEV  *ppdev;
    PDEV  *ppdevMatch = NULL;
    PLDEV  pldev;
    BOOL   bError = FALSE;

    //
    // Search through the entire PDEV cache to see if we have PDEVs on the
    // same device.  If any such a PDEV is active, we need to disable it.
    //
    // All see if a PDEV matches the given mode and is for the same device.
    // If so, simply return that.
    //
    // To be a Match, the PDEV has to match:
    // - The device
    // - The devmode (except for position)
    // - The desktop on which it is located
    //


    ASSERTGDI(lpDisplayNames != NULL, "NULL name to hCreateHDEV\n");

#if !defined(_GDIPLUS_)
    ASSERTGDI(PhysDisp != NULL,       "NULL physdisp to hCreateHDEV\n");
#endif

    *phDevDisabled = NULL;

    if (PhysDisp != (PGRAPHICS_DEVICE) DDML_DRIVER)
    {
        GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);

        for (ppdev = gppdevList; ppdev != NULL; ppdev = ppdev->ppdevNext)
        {
            PDEVOBJ po((HDEV) ppdev);
            PGRAPHICS_DEVICE pGraphicsDevice = po.ppdev->pGraphicsDevice;

            //
            // Check if we are on the same actual device.
            // We have to check the VGA device also, in case we are loading
            // the S3 driver dynamically, and the main PhysDisp became a
            // child physdisp on the fly.
            //
            // The VGA check is complex due to the following scenario:
            // - Machine boots in VGA, so the pdev is on the VGA device.
            // - The C&T driver is loaded on the fly, so the pVgaDevice becomes
            //   the C&T driver.
            // - We change the mode on the fly, so now we would like to diable
            //   the vga pdev. -->> check if our device and the pdev are both
            //                      on a VGA device.
            //

            if ((pGraphicsDevice != NULL)                           &&
                (pGraphicsDevice != (PGRAPHICS_DEVICE) DDML_DRIVER) &&
                ((PhysDisp == pGraphicsDevice) ||
                 (PhysDisp->pVgaDevice && pGraphicsDevice->pVgaDevice)))
            {
                po.ppdev->cPdevRefs++;
                GreReleaseSemaphoreEx(ghsemDriverMgmt);
                GreAcquireSemaphoreEx(ghsemShareDevLock, SEMORDER_SHAREDEVLOCK, NULL);
                GreAcquireSemaphoreEx(po.hsemDevLock(), SEMORDER_DEVLOCK, NULL);
                GreEnterMonitoredSection(po.ppdev, WD_DEVLOCK);

                //
                // If this is the matching device, just remember it here because
                // we have to check for all active PDEVs.
                // This also allows us to not disable\reenable the same device
                // if we were not switching.
                //
                // But for Dualview, always reset the mode
                //

		if ((((PhysDisp->stateFlags & DISPLAY_DEVICE_DUALVIEW) == 0) ||
		     (!gbInvalidateDualView) ||
                     (bNoDisable == TRUE)) &&
                    (!(po.bCloneDriver())) && /* don't pick clone pdev from cache */
                    (po.ppdev->pDesktopId == pDesktopId) &&
                    (po.ppdev->dwDriverCapableOverride == dwOverride) &&
                    (po.ppdev->dwDriverAccelerationLevel == dwAccelLevel) &&
                    RtlEqualMemory(pdriv, po.ppdev->ppdevDevmode, sizeof(DEVMODEW))
                   )
		{
		    ASSERTGDI(ppdevMatch==NULL,
			      "Multiple cached PDEV matching the current mode.\n");
                    po.vReferencePdev();
                    ppdevMatch = ppdev;
                }
                else
                {
                    //
                    // Don't disable the PDEV for an independant desktop open
                    //

                    if (bNoDisable == TRUE)
                    {
                        bError = TRUE;
                    }
                    else
                    {
                        //
                        // If there is an enabled PDEV in this same PhysDisp, then
                        // we must disable it.
                        // Only one HDEV per device at any one time.
                        //
                        // There may be multiple active in the case where outstanding
                        // Opens have been made (multiple display case only).
                        //

                        if (po.bDisabled() == FALSE)
                        {
                            ASSERTGDI(*phDevDisabled == NULL,
                                      "Multiple active PDEVs on same device\n");

                            TRACE_INIT(("hCreateHDEV: disabling ppdev %08lx\n", ppdev));

                            if (DrvDisableDisplay((HDEV) ppdev, FALSE))
                            {
                                *phDevDisabled = (HDEV) ppdev;
                            }
                            else
                            {
                                bError = TRUE;
                            }
                        }
                    }
                }

                GreExitMonitoredSection(po.ppdev, WD_DEVLOCK);
                GreReleaseSemaphoreEx(po.hsemDevLock());
                GreReleaseSemaphoreEx(ghsemShareDevLock);
                GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);
                po.vUnreferencePdev();
            }
        }

        GreReleaseSemaphoreEx(ghsemDriverMgmt);

        if (bError)
        {
            //
            // There was an error trying to disable the device.
            // return NULL;
            //

            if (ppdevMatch != NULL)
            {
                PDEVOBJ po((HDEV) ppdevMatch);

                po.vUnreferencePdev();
            }

            return NULL;
        }

        //
        // If we found a match, reenable and refcount the device, as necessary.
        //

        if (ppdevMatch)
        {
            TRACE_INIT(("hCreateHDEV: Found a ppdev cache match\n"));

            PDEVOBJ po((HDEV) ppdevMatch);

            //
            // Increment the Open count of the device
            //

            GreAcquireSemaphoreEx(ghsemShareDevLock, SEMORDER_SHAREDEVLOCK, NULL);
            GreAcquireSemaphoreEx(po.hsemDevLock(), SEMORDER_DEVLOCK, NULL);

            GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);

            po.ppdev->cPdevOpenRefs++;

            GreReleaseSemaphoreEx(ghsemDriverMgmt);

            GreEnterMonitoredSection(po.ppdev, WD_DEVLOCK);

            //
            // Check for Software panning modes.
            //

            //
            // If the Device was disabled, just reenable it.
            //

            if (po.bDisabled())
            {
                ASSERTGDI(po.ppdev->cPdevOpenRefs == 1,
                          "Inconsistent Open count on disabled PDEV\n");

                DrvEnableDisplay((HDEV) ppdevMatch);
            }

            //
            // Reset the offset appropriately.
            //

            GreExitMonitoredSection(po.ppdev, WD_DEVLOCK);
            GreReleaseSemaphoreEx(po.hsemDevLock());
            GreReleaseSemaphoreEx(ghsemShareDevLock);

            return((HDEV) ppdevMatch);
        }
    }

    //
    // No existing PDEV in our list.  Let's create a new one.
    //

    if (lpDisplayNames == NULL)
    {
        WARNING(("Drv_Trace: LoadDisplayDriver: Display driver list was not present.\n"));
    }

    //
    // Make a fake DC so we can pass in the needed info to vInitBrush.
    // We use allocation instead of stack since sizeof(DC) is about 1.5k
    // WINBUG 393269
    //

    DC *pdc = (DC*)PALLOCMEM(sizeof(DC), 'pmtG');

    if (pdc == NULL)
    {
        WARNING("hCreateHDEV: DC memory allocation failed\n");
        goto Exit;
    }

    for (i = 0; i < lpDisplayNames->cNames; i++)
    {
        //
        // Load the display driver image.
        //

        switch (flags)
        {
        case GCH_DEFAULT_DISPLAY:

            pldev = ldevLoadDriver(lpDisplayNames->D[i].lpDisplayName,
                                   LDEV_DEVICE_DISPLAY);
            break;

        case GCH_DDML:

            pldev = ldevLoadInternal((PFN)(lpDisplayNames->D[i].lpDisplayName),
                                     LDEV_DEVICE_META);
            break;

        case GCH_GDIPLUS_DISPLAY:

            pldev = ldevLoadInternal((PFN)(lpDisplayNames->D[i].lpDisplayName),
                                     LDEV_DEVICE_META);
            break;

        case GCH_MIRRORING:

            pldev = ldevLoadDriver(lpDisplayNames->D[i].lpDisplayName,
                                   LDEV_DEVICE_MIRROR);
            break;

        case GCH_PANNING:

            ASSERTGDI(FALSE, "Software Panning not implemented yet\n");
            pldev = NULL;
            break;

        default:

            ASSERTGDI(FALSE, "Unknown driver type\n");
            pldev = NULL;
            break;
        }

        if (pldev == NULL)
        {
            TRACE_INIT(("hCreateHDEV: failed ldevLoadDriver\n"));
        }
        else
        {
            bSetDeviceSessionUsage(PhysDisp, TRUE);

            PDEVOBJ po(pldev,
                       pdriv,
                       NULL,          // no logical address
                       NULL,          // no data file
                       lpDisplayNames->D[i].lpDisplayName,    // device name is the display driver name
                                      // necessary for hook drivers.
                       lpDisplayNames->D[i].hDriver,
                       NULL,          // no remote typeone info (this isn't font driver)
                       0,             // prmr.bValid() ? prmr.GdiInfo() : NULL,
                       0,             // prmr.bValid() ? prmr.pdevinfo() : NULL
                       FALSE,         // not UMPD driver
                       dwOverride,     // Capable Override
                       dwAccelLevel); // acceleration level.

            if (!po.bValid())
            {
                TRACE_INIT(("hCreateHDEV: PDEVOBJ::po failed\n"));
                bSetDeviceSessionUsage(PhysDisp, FALSE);
                ldevUnloadImage(pldev);
            }
            else
            {

#ifdef DDI_WATCHDOG

                //
                // Watchdog objects require DEVICE_OBJECT now and we are associating DEVICE_OBJECT
                // with PDEV here (i.e. we don't know DEVICE_OBJECT in PDEVOBJ::PDEVOBJ).
                // Beacuse of this we have to delay creation of watchdog objects till we get here.
                // It would be nice to keep all this stuff in PDEVOBJ::PDEVOBJ constructor.
                //

                //
                // Create watchdogs for display or mirror device.
                //

                if ((po.ppdev->pldev->ldevType == LDEV_DEVICE_DISPLAY) ||
                    (po.ppdev->pldev->ldevType == LDEV_DEVICE_MIRROR))
                {
                    if ((NULL == po.ppdev->pWatchdogContext) &&
                        (NULL == po.ppdev->pWatchdogData) && PhysDisp)
                    {
                        PDEVICE_OBJECT pDeviceObject;

                        pDeviceObject = (PDEVICE_OBJECT)(PhysDisp->pDeviceHandle);

                        if (pDeviceObject)
                        {
			    po.ppdev->pWatchdogContext = GreCreateWatchdogContext(
							     lpDisplayNames->D[i].lpDisplayName,
							     lpDisplayNames->D[i].hDriver,
							     &gpldevDrivers);

                            if (po.ppdev->pWatchdogContext)
                            {
                                po.ppdev->pWatchdogData = GreCreateWatchdogs(pDeviceObject,
                                                                             WD_NUMBER,
                                                                             DDI_TIMEOUT,
                                                                             WdDdiWatchdogDpcCallback,
                                                                             po.ppdev->pWatchdogContext);
                            }
                        }
                    }
                }

#endif  // DDI_WATCHDOG

                TRACE_INIT(("hCreateHDEV: about to call pr:bMakeSurface\n"));

                if (po.bMakeSurface())
                {
                #if DBG
                    //
                    // Check the surface created by driver is same as what we want.
                    //

                    if (po.pSurface() && pdriv && (flags == GCH_DEFAULT_DISPLAY))
                    {
                        if ((pdriv->dmPelsWidth  != (ULONG) po.pSurface()->sizl().cx) ||
                            (pdriv->dmPelsHeight != (ULONG) po.pSurface()->sizl().cy))
                        {
                            DbgPrint("hCreateHDEV() - DEVMODE %d,%d, SURFACE %d,%d\n",
                                      pdriv->dmPelsWidth, pdriv->dmPelsHeight,
                                      po.pSurface()->sizl().cx, po.pSurface()->sizl().cy);
                        }
                    }
                #endif // DBG
                    
                    //
                    // Realize the Gray pattern brush used for drag rectangles.
                    //

                    po.pbo()->vInit();

                    PBRUSH  pbrGrayPattern;

                    pbrGrayPattern = (PBRUSH)HmgShareCheckLock((HOBJ)ghbrGrayPattern,
                                                               BRUSH_TYPE);
                    pdc->pDCAttr = &pdc->dcattr;
                    pdc->crTextClr(0x00000000);
                    pdc->crBackClr(0x00FFFFFF);
                    pdc->lIcmMode(DC_ICM_OFF);        
                    pdc->hcmXform(NULL);
                    po.pbo()->vInitBrush(pdc,
                                         pbrGrayPattern,
                                         (XEPALOBJ) ppalDefault,
                                         (XEPALOBJ) po.ppdev->pSurface->ppal(),
                                         po.ppdev->pSurface);

                    DEC_SHARE_REF_CNT_LAZY0 (pbrGrayPattern);

                    //
                    // Now set the global default bitmaps pdev to equal
                    // that of our global display device.
                    //

                    PSURFACE pSurfDefault = SURFACE::pdibDefault;

                    if (pSurfDefault->hdev() == NULL)
                    {
                        pSurfDefault->hdev(po.hdev());
                    }

                    po.ppdev->pGraphicsDevice = PhysDisp;
                    po.ppdev->pDesktopId = pDesktopId;

                    //
                    // Keep the DEVMODE, if this is a real display device
                    //

                    if ((flags != GCH_DDML) && (flags != GCH_GDIPLUS_DISPLAY))
                    {
                        po.ppdev->ppdevDevmode = (PDEVMODEW)
                            PALLOCNOZ(pdriv->dmSize + pdriv->dmDriverExtra,
                                      GDITAG_DEVMODE);

                        if (po.ppdev->ppdevDevmode)
                        {
                            RtlMoveMemory(po.ppdev->ppdevDevmode,
                                          pdriv,
                                          pdriv->dmSize + pdriv->dmDriverExtra);

                            //
                            // At this moment, this device must be attached.  DM_POSITION indicates that
                            //
                            po.ppdev->ppdevDevmode->dmFields |= DM_POSITION;
                            DrvUpdateAttachFlag(PhysDisp, 1);
                        }
                        else
                        {
                            bError = TRUE;
                        }
                    }

                    //
                    // Mark the PDEV as now being ready for use.  This has to
                    // be one of the last steps, because GCAPS2_SYNCFLUSH and
                    // GCAPS2_SYNCTIMER asynchronously loop through the PDEV
                    // list and call the driver if 'bDisabled' is not set.
                    //

                    po.bDisabled(FALSE);

                    //
                    // Profile driver
                    //
                    // We can not profile meta (= DDML) driver, and while we
                    // are creating meta driver, we don't ssync'ed devlock
                    // with its children, so we can not call anything which
                    // will dispatch to its children.
                    //

                    if (!po.bMetaDriver())
                    {
                        po.vProfileDriver();
                    }

                    if (bError)
                    {
                        // There was an error of memory allocation.
                        po.vUnreferencePdev();
                        break;
                    }
                    VFREEMEM(pdc);
                    return(po.hdev());
                }
                else
                {
                    TRACE_INIT(("hCreateHDEV: bMakeSurface failed\n"));
                    bSetDeviceSessionUsage(PhysDisp, FALSE);
                }

                //
                // Destroy everything if something fails.
                // This will remove the Surface, PDEV and image.
                //

                po.vUnreferencePdev();
            }
        }
    }

Exit:    
    
    if (pdc)
        VFREEMEM(pdc);
        
    //
    // There was an error creating the new device.
    // Reenable the old one if we disabled it.
    //
    if (*phDevDisabled)
    {
        if ((PhysDisp->stateFlags & DISPLAY_DEVICE_DUALVIEW) == 0 || !gbInvalidateDualView)
        {
            DrvEnableDisplay(*phDevDisabled);
        }
    }

    return NULL;
}

#if TEXTURE_DEMO

DHPDEV TexEnablePDEV(
DEVMODEW *pdm,                  // Actually, the HDEV
LPWSTR    pwszLogAddress,
ULONG     cPat,
HSURF    *phsurfPatterns,
ULONG     cjCaps,
GDIINFO  *pdevcaps,
ULONG     cjDevInfo,
DEVINFO  *pdi,
HDEV      hdev,
LPWSTR    pwszDeviceName,
HANDLE    hDriver)
{
    HDEV hdevParent = (HDEV) pdm;

    PDEVOBJ poParent(hdevParent);
    PDEVOBJ po(hdev);

    pdevcaps->ulHorzRes = gcxTexture;
    pdevcaps->ulVertRes = gcyTexture;

    ghdevTextureParent = poParent.hdev();

    return(poParent.dhpdev());
}

HSURF TexEnableSurface(DHPDEV dhpdev)
{
    PDEVOBJ poPrimary(ghdevTextureParent);

    DEVLOCKOBJ dlo(poPrimary);

    HSURF hsurf = hsurfCreateCompatibleSurface(poPrimary.hdev(),
                                               poPrimary.pSurface()->iFormat(),
                                               poPrimary.bIsPalManaged()
                                                  ? NULL
                                                  : (HPALETTE) poPrimary.ppalSurf()->hGet(),
                                               512,
                                               512,
                                               TRUE);

    return(hsurf);
}

VOID TexDisablePDEV(DHPDEV dhpdev)
{
}

VOID TexCompletePDEV(
DHPDEV dhpdev,
HDEV   hdev)
{
}

VOID TexDisableSurface(DHPDEV dhpdev)
{
}

typedef struct _DEMOTEXTURE
{
    HDC         hdc;
    ULONG       iTexture;
    BOOL        bCopy;
    DEMOQUAD    Quad;
} DEMOTEXTURE;

BOOL
TexTexture(
VOID*   pvBuffer,
ULONG   cjBuffer)
{
    BOOL            bRet = FALSE;
    DEMOTEXTURE     tex;
    KFLOATING_SAVE  fsFpState;

    if (cjBuffer < sizeof(DEMOTEXTURE))
    {
        WARNING("TexTexture: Buffer too small");
        return(FALSE);
    }

    tex = *((DEMOTEXTURE*) pvBuffer);

    if (ghdevTextureParent == NULL)
    {
        WARNING1("TexTexture: Texturing not enabled");
        return(FALSE);
    }

    if (tex.iTexture >= gcTextures)
    {
        WARNING("TexTexture: Bad texture identifier");
        return(FALSE);
    }

    if (!NT_SUCCESS(KeSaveFloatingPointState(&fsFpState)))
    {
        WARNING("TexTexture: Couldn't save floating point state");
        return(FALSE);
    }

    DCOBJ dco(tex.hdc);
    if (dco.bValid())
    {
        DEVLOCKOBJ dlo(dco);
        if (dlo.bValid())
        {
            PDEVOBJ poParent(ghdevTextureParent);
            PDEVOBJ po(gahdevTexture[tex.iTexture]);

            if (1) // dco.pSurface()->hdev() == po.pSurface()->hdev())
            {
                ECLIPOBJ    eco;
                ERECTL      erclBig(-10000, -10000, 10000, 10000);

                eco.vSetup(dco.prgnEffRao(), erclBig);
                if (!eco.erclExclude().bEmpty())
                {
                    if (tex.bCopy)
                    {
                        ERECTL erclDst(0, 0, dco.pdc->sizl().cx, dco.pdc->sizl().cy);

                        PPFNGET(po, CopyBits, dco.pSurface()->flags())
                                    (dco.pSurface()->pSurfobj(),
                                     po.pSurface()->pSurfobj(),
                                     &eco,
                                     NULL,
                                     &erclDst,
                                     (POINTL*) &erclDst);
                        bRet = TRUE;
                    }
                    else
                    {
                        if (PPFNVALID(poParent, DemoTexture))
                        {
                            PPFNDRV(po, DemoTexture)(dco.pSurface()->pSurfobj(),
                                                     po.pSurface()->pSurfobj(),
                                                     &eco,
                                                     &tex.Quad,
                                                     1);
                            bRet = TRUE;
                        }
                        else
                        {
                            WARNING("TexTexture: DrvDemoTexture not hooked");
                        }
                    }
                }
            }
            else
            {
                WARNING("TexTexture: Mismatched HDEVs");
            }
        }
        else
        {
            WARNING("TexTexture: Bad devlock");
        }
    }
    else
    {
        WARNING("TexTexture: Bad DC");
    }

    KeRestoreFloatingPointState(&fsFpState);

    return(bRet);
}

HDC
hdcTexture(
ULONG   iTexture
)
{
    HDC hdc;
    HDEV hdev;

    hdc = 0;
    hdev = 0;

    if (iTexture == (ULONG) -1)
    {
        hdev = ghdevTextureParent;
    }
    else if (iTexture < gcTextures)
    {
        hdev = gahdevTexture[iTexture];
    }

    if (hdev != NULL)
    {
        hdc = GreCreateDisplayDC(hdev,
                                 DCTYPE_DIRECT,
                                 FALSE);
    }
    else
    {
        WARNING("hdcTexture: Bad parameter");
    }

    return(hdc);
}

HDEV
hCreateTextureHDEV(
    HDEV            hdevOwner
)
{
    PLDEV  pldev;

    PDEVOBJ poOwner(hdevOwner);

    pldev = (PLDEV) PALLOCMEM(sizeof(LDEV), GDITAG_LDEV);
    if (!pldev)
    {
        WARNING("hCreateTextureHDEV: LDEV alloc failed.");
        return(0);
    }

    RtlCopyMemory(pldev, poOwner.ppdev->pldev, sizeof(LDEV));

    pldev->apfn[INDEX_DrvEnablePDEV]       = (PFN) TexEnablePDEV;
    pldev->apfn[INDEX_DrvEnableSurface]    = (PFN) TexEnableSurface;
    pldev->apfn[INDEX_DrvCompletePDEV]     = (PFN) TexCompletePDEV;
    pldev->apfn[INDEX_DrvDisablePDEV]      = (PFN) TexDisablePDEV;
    pldev->apfn[INDEX_DrvDisableSurface]   = (PFN) TexDisableSurface;

    pldev->apfn[INDEX_DrvAssertMode]            = NULL;
    pldev->apfn[INDEX_DrvCreateDeviceBitmap]    = NULL;
    pldev->apfn[INDEX_DrvDeleteDeviceBitmap]    = NULL;
    pldev->apfn[INDEX_DrvSetPalette]            = NULL;
    pldev->apfn[INDEX_DrvSetPointerShape]       = NULL;
    pldev->apfn[INDEX_DrvSaveScreenBits]        = NULL;
    pldev->apfn[INDEX_DrvIcmSetDeviceGammaRamp] = NULL;
    pldev->apfn[INDEX_DrvGetDirectDrawInfo]     = NULL;

    PDEVOBJ po(pldev,
               (PDEVMODEW) hdevOwner,
               NULL,          // no logical address
               NULL,          // no data file
               NULL,          // device name is the display driver name
                              // necessary for hook drivers.
               NULL,          // driver handle
               NULL,
               poOwner.GdiInfo(),
               poOwner.pdevinfo());

    if (!po.bValid())
    {
        WARNING("hCreateTextureHDEV failed");
        return(0);
    }
    else
    {
        TRACE_INIT(("hCreateHDEV: about to call pr:bMakeSurface\n"));

        if (po.bMakeSurface())
        {
            //
            // Make a fake DC so we can pass in the needed info to vInitBrush.
            // Watch out that this is a bit big (about 1k of stack space).
            //

            DC dc;

            //
            // Realize the gray pattern brush used for drag rectangles.
            //

            po.pbo()->vInit();

            PBRUSH  pbrGrayPattern;

            pbrGrayPattern = (PBRUSH)HmgShareCheckLock((HOBJ)ghbrGrayPattern,
                                                       BRUSH_TYPE);

            dc.pDCAttr = &dc.dcattr;

            dc.crTextClr(0x00000000);
            dc.crBackClr(0x00FFFFFF);

            dc.lIcmMode(DC_ICM_OFF);

            dc.hcmXform(NULL);

            po.pbo()->vInitBrush(&dc,
                                 pbrGrayPattern,
                                 (XEPALOBJ) ppalDefault,
                                 (XEPALOBJ) po.ppdev->pSurface->ppal(),
                                 po.ppdev->pSurface);

            DEC_SHARE_REF_CNT_LAZY0 (pbrGrayPattern);

            //
            // Now set the global default bitmaps pdev to equal
            // that of our global display device.
            //

            PSURFACE pSurfDefault = SURFACE::pdibDefault;

            if (pSurfDefault->hdev() == NULL)
            {
                pSurfDefault->hdev(po.hdev());
            }

            po.ppdev->pGraphicsDevice = poOwner.ppdev->pGraphicsDevice;
            po.ppdev->pDesktopId = poOwner.ppdev->pDesktopId;

            po.bDisabled(FALSE);

            po.vProfileDriver();

            return(po.hdev());
        }
        else
        {
            TRACE_INIT(("hCreateHDEV: bMakeSurface failed\n"));
        }

        //
        // Destroy everything if something fails.
        // This will remove the Surface, PDEV and image.
        //

        po.vUnreferencePdev();
    }

    return NULL;
}


PMDEV
pmdevSetupTextureDemo(
PMDEV   pmdev)
{
    ULONG i;

    if ((gbTexture) && (pmdev) && (pmdev->chdev == 1))
    {
        PMDEV pmdevTmp;

        //
        // We allocate and copy too much, but we don't care ...
        //

        pmdevTmp = (PMDEV) PALLOCNOZ(sizeof(MDEV) * (pmdev->chdev + 8),
                                     GDITAG_DRVSUP);

        if (pmdevTmp)
        {
            PDEVOBJ poPrimary(pmdev->Dev[0].hdev);

            //
            // Copy the MDEV list
            //

            RtlMoveMemory(pmdevTmp, pmdev, sizeof(MDEV) * pmdev->chdev);

            //
            // Position the surfaces consecutively to the right of the primary.
            //

            LONG xLeft = pmdev->Dev[0].rect.left;
            LONG yTop  = pmdev->Dev[0].rect.bottom;

            //
            // Hard code them to 512x512.
            //

            for (i = 0; i < 3; i++)
            {
                //
                // Create a clone of the PDEV.
                //

                HDEV hdevTexture = hCreateTextureHDEV(poPrimary.hdev());
                if (!hdevTexture)
                {
                    //
                    // Delete all the hdevs we have created. and restore the old
                    // ones.
                    //

                    DrvBackoutMDEV(pmdev);
                    VFREEMEM(pmdev);
                    pmdev = NULL;
                    return(pmdev);
                }

                PDEVOBJ poTexture(hdevTexture);

                //
                // Point the surface's HDEV to its true owner, so that
                // software cursors work.  I hope.
                //

                poTexture.pSurface()->hdev(hdevTexture);

                gahdevTexture[i] = hdevTexture;

                poTexture.ppdev->ptlOrigin.x = xLeft;
                poTexture.ppdev->ptlOrigin.y = yTop;

                gcxTexture = 512;
                gcyTexture = 512;

                pmdevTmp->Dev[1 + i].hdev        = hdevTexture;
                pmdevTmp->Dev[1 + i].rect.left   = xLeft;
                pmdevTmp->Dev[1 + i].rect.top    = yTop;
                pmdevTmp->Dev[1 + i].rect.right  = xLeft + gcxTexture;
                pmdevTmp->Dev[1 + i].rect.bottom = yTop + gcyTexture;
                pmdevTmp->Dev[1 + i].Reserved    = NULL;

                pmdevTmp->chdev++;
                gcTextures++;

                yTop += gcyTexture;
            }

            VFREEMEM(pmdev);

            pmdev = pmdevTmp;
        }
        else
        {
            VFREEMEM(pmdevTmp);
        }
    }

    return(pmdev);
}

#endif // TEXTURE_DEMO

/***************************************************************************\
* DrvGetHDEV
*
* routine to find out HDEV for specified device name
*
* 01-Oct-1997 hideyukn  Created
\***************************************************************************/

HDEV DrvGetHDEV(
    PUNICODE_STRING pstrDeviceName)
{
    GDIFunctionID(DrvGetHDEV);

    HDEV hdev = NULL;

    if (pstrDeviceName)
    {
        PGRAPHICS_DEVICE PhysDisp;

        PhysDisp = DrvGetDeviceFromName(pstrDeviceName, KernelMode);

        if (PhysDisp)
        {
            PDEV *ppdev;
            PDEV *ppdevDisabled = NULL;

            GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);

            for (ppdev = gppdevList; ppdev != NULL; ppdev = ppdev->ppdevNext)
            {
                PDEVOBJ po((HDEV) ppdev);

                if ((po.ppdev->pGraphicsDevice != 0) &&
                    (po.ppdev->pGraphicsDevice == PhysDisp))
                {
                    if (!(po.bDisabled()))
                    {
                        po.ppdev->cPdevRefs++;
                        hdev = po.hdev();
                        break;
                    }
                    else if (ppdevDisabled == NULL)
                    {
                        //
                        // We found a matching PDEV but it is disabled. Save
                        // a pointer to it; in case we don't find an enabled
                        // PDEV we will use this:
                        //

                        ppdevDisabled = ppdev;
                    }
                }
            }

            if ((ppdev == NULL) && (ppdevDisabled != NULL))
            {
                //
                // We could not find a matching, enabled PDEV but did find a
                // matching disabled PDEV, so just use it:
                //

                PDEVOBJ po((HDEV) ppdevDisabled);

                po.ppdev->cPdevRefs++;
                hdev = po.hdev();
            }

            GreReleaseSemaphoreEx(ghsemDriverMgmt);
        }
    }

    return hdev;
}

/***************************************************************************\
* DrvReleaseHDEV
*
* routine to release an HDEV for specified device name
*
* 02-Mar-1999 a-oking   Created
\***************************************************************************/

void DrvReleaseHDEV(
    PUNICODE_STRING pstrDeviceName)
{
    if (pstrDeviceName)
    {
        PGRAPHICS_DEVICE PhysDisp;

        PhysDisp = DrvGetDeviceFromName(pstrDeviceName, KernelMode);

        if (PhysDisp)
        {
            PDEV *ppdev;

            GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);

            for (ppdev = gppdevList; ppdev != NULL; ppdev = ppdev->ppdevNext)
            {
                PDEVOBJ po((HDEV) ppdev);

                if ((po.ppdev->pGraphicsDevice != 0) &&
                    (po.ppdev->pGraphicsDevice == PhysDisp))
                {
                    po.ppdev->cPdevRefs--;
                    break;
                }
            }

            GreReleaseSemaphoreEx(ghsemDriverMgmt);
        }
    }

    return;
}


/***************************************************************************\
* DrvCreateCloneHDEV
*
* create clone of passed HDEV.
*
* 27-Feb-1998 hideyukn  Created
\***************************************************************************/

#define DRV_CLONE_DEREFERENCE_ORG  0x0001

HDEV DrvCreateCloneHDEV(
    HDEV  hdevOrg,
    ULONG ulFlags)
{
    GDIFunctionID(DrvCreateCloneHDEV);

    HDEV hdevClone = NULL;

    PDEVOBJ pdoOrg(hdevOrg);

    ASSERTGDI(!pdoOrg.bDisabled(), "DrvCreateCloneHDEV(): hdevOrg must be enabled");

    // Grab the SPRITELOCK.  This is important in case sprites are still
    // hooked at this point because the surface type and flags have been
    // altered by the sprite code, and unless we grab the SPRITELOCK here
    // they will be recorded incorrectly in the SPRITESTATE of the new PDEV
    // during the call to bSpEnableSprites.  See bug #266112 for details.

    SPRITELOCK slock(pdoOrg);

    // Create clone PDEVOBJ.

    PDEVOBJ pdoClone(hdevOrg,GCH_CLONE_DISPLAY);

    if (pdoClone.bValid())
    {
        BOOL bRet;

        //
        // Enable Sprites on new PDEV.
        //

        if (bSpEnableSprites(pdoClone.hdev()))
        {
            vEnableSynchronize(pdoClone.hdev());

            // Realize the Gray pattern brush used for drag rectangles.

            // Make a fake DC so we can pass in the needed info to vInitBrush.
            // Watch out that this is a bit big (about 1k of stack space).

            DC      dc;

            dc.pDCAttr = &dc.dcattr;
            dc.crTextClr(0x00000000);
            dc.crBackClr(0x00FFFFFF);
            dc.lIcmMode(DC_ICM_OFF);
            dc.hcmXform(NULL);

            PBRUSH  pbrGrayPattern = (PBRUSH)HmgShareCheckLock(
                                                  (HOBJ)ghbrGrayPattern,
                                                  BRUSH_TYPE);
            pdoClone.pbo()->vInit();
            pdoClone.pbo()->vInitBrush(&dc,
                                 pbrGrayPattern,
                                 (XEPALOBJ)ppalDefault,
                                 (XEPALOBJ)pdoClone.ppdev->pSurface->ppal(),
                                 pdoClone.ppdev->pSurface);

            DEC_SHARE_REF_CNT_LAZY0 (pbrGrayPattern);

            // Dereference original HDEV, if nessesary.

            if (ulFlags & DRV_CLONE_DEREFERENCE_ORG)
            {
                GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);

                ASSERTGDI(pdoOrg.ppdev->cPdevOpenRefs > 1,
                    "DrvCreateCloneHDEV: cPdevOpenRefs <= 1\n");
                ASSERTGDI(pdoOrg.ppdev->cPdevRefs > 1,
                    "DrvCreateCloneHDEV: cPdevRefs <= 1\n");

                pdoOrg.ppdev->cPdevOpenRefs--;
                pdoOrg.vUnreferencePdev();

                GreReleaseSemaphoreEx(ghsemDriverMgmt);
            }

            // Mirror the status.

            pdoClone.bDisabled(pdoOrg.bDisabled());

            // Obtain cloned HDEV handle.

            hdevClone = pdoClone.hdev();
        }
        else
        {
            pdoClone.vUnreferencePdev();
        }
    }

    return (hdevClone);
}

VOID
GetPrimaryAttachFlags(
    PGRAPHICS_DEVICE PhysDisp,
    PULONG           pPrimary,
    PULONG           pAttached
    )
{
    HANDLE           hkRegistry = NULL;
    ULONG            defaultValue = 0;
    USHORT usProtocolType;

    *pPrimary = *pAttached = 0;
    
    //
    // Get the attached and primary data, which is per config (or
    // also global if necessary.
    //

    RTL_QUERY_REGISTRY_TABLE AttachedQueryTable[] = {
                    {NULL, RTL_QUERY_REGISTRY_DIRECT, AttachedSettings[0],
                     pPrimary,                        REG_DWORD, &defaultValue, 4},
                    {NULL, RTL_QUERY_REGISTRY_DIRECT, AttachedSettings[1],
                     pAttached,                       REG_DWORD, &defaultValue, 4},
                    {NULL, 0, NULL}
    };

    if (PhysDisp->stateFlags & DISPLAY_DEVICE_DISCONNECT){
        usProtocolType = PROTOCOL_DISCONNECT;
    } else if (PhysDisp->stateFlags & DISPLAY_DEVICE_REMOTE) {
        usProtocolType = gProtocolType;
    } else {
        usProtocolType = PROTOCOL_CONSOLE;
    }

    hkRegistry = DrvGetRegistryHandleFromDeviceMap(PhysDisp,
                                                   DispDriverRegHardwareProfile,
                                                   NULL,
                                                   NULL,
                                                   NULL,
                                                   usProtocolType);
    if (hkRegistry)
    {
        RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                               (PWSTR)hkRegistry,
                               &AttachedQueryTable[0],
                               NULL,
                               NULL);

        ZwCloseKey(hkRegistry);
    }
    else
    {
        hkRegistry = DrvGetRegistryHandleFromDeviceMap(PhysDisp,
                                                       DispDriverRegGlobal,
                                                       NULL,
                                                       NULL,
                                                       NULL,
                                                       usProtocolType);
        if (hkRegistry)
        {
            RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                   (PWSTR)hkRegistry,
                                   &AttachedQueryTable[0],
                                   NULL,
                                   NULL);



            ZwCloseKey(hkRegistry);
        }
    }

    switch (gProtocolType) {
        case PROTOCOL_CONSOLE:
            if ((PhysDisp->stateFlags & DISPLAY_DEVICE_DISCONNECT) ||
                (PhysDisp->stateFlags & DISPLAY_DEVICE_REMOTE))
                *pAttached = 0;

            break;

        case PROTOCOL_DISCONNECT:
            if (!(PhysDisp->stateFlags & DISPLAY_DEVICE_DISCONNECT)){
                *pAttached = 0;
            } else{
                *pAttached = 1;
            }
            break;

        default:
            if (!(PhysDisp->stateFlags & DISPLAY_DEVICE_REMOTE) || (PhysDisp->ProtocolType != gProtocolType)){
                *pAttached = 0;
            } else{
                *pAttached = 1;
            }

    }

     TRACE_INIT(("Drv_Trace: DrvCreateMDEV: Display driver is %sprimary on the desktop\n",
                 *pPrimary ? "" : "NOT "));
     TRACE_INIT(("Drv_Trace: DrvCreateMDEV: Display driver is %sattached to the desktop\n",
                 *pAttached ? "" : "NOT "));
}

/***************************************************************************\
* DrvCreateMDEV
*
*  Initialize an MDEV structure
*
*
*             andreva       Created
\***************************************************************************/

PMDEV
DrvCreateMDEV(
    PUNICODE_STRING pstrDeviceName,
    LPDEVMODEW      lpdevmodeInformation,
    PVOID           pDesktopId,
    ULONG           ulFlags,
    PMDEV           pMdevOrg,
    MODE            PreviousMode,
    DWORD           PruneFlag,
    BOOL            bClosest
    )
{
    GDIFunctionID(DrvCreateMDEV);

    NTSTATUS  retStatus = STATUS_SUCCESS;
    BOOL      bAttachMirroring = FALSE;
    BOOL      displayInstalled = FALSE;
    BOOL      bLoad;
    PMDEV     pmdev;
    BOOL      bNoDisable = (ulFlags & GRE_DISP_CREATE_NODISABLE);
    BOOL      bModeChange = (pMdevOrg != NULL);
    BOOL      bPrune = (PruneFlag != GRE_RAWMODE);
    PGRAPHICS_DEVICE PhysDisp;

    TRACE_INIT(("\nDrv_Trace: DrvCreateMDEV: Enter\n"));

    GRAPHICS_STATE GraphicsState = GraphicsStateFull;

    if (pstrDeviceName)
    {
        //
        // Check if CreateDC on Dualview.
        // Since opening a DualView must affect the other view,
        // so if a Dualview is not opened in orginal MDEV, don't allow it to open
        //
        PhysDisp = DrvGetDeviceFromName(pstrDeviceName, PreviousMode);
        if (PhysDisp && (PhysDisp->stateFlags & DISPLAY_DEVICE_DUALVIEW))
        {
            PPDEV ppdev;

            for (ppdev = gppdevList; ppdev != NULL; ppdev = ppdev->ppdevNext)
            {
                PDEVOBJ po((HDEV) ppdev);
                if (po.ppdev->pGraphicsDevice == PhysDisp)
                {
                    break;
                }
            }
            if (ppdev == NULL)
                return NULL;
        }
    }

    //
    // First pass through the loop - find all the devices that should be
    // are atached.
    // If not attached devices, go through the loop again to find a default
    // device.
    // Thirdly - try to find any mirroring devices.
    //

    //
    // Allocate new MDEV (with zero initialization)
    //

    pmdev = (PMDEV) PALLOCMEM(sizeof(MDEV), GDITAG_DRVSUP);

    if (pmdev == NULL)
    {
        return NULL;
    }

    pmdev->chdev      = 0;
    pmdev->pDesktopId = pDesktopId;

    while (1)
    {
        BOOL             bMultiDevice = TRUE;
        HDEV             hDev;
        HDEV             hDevDisabled;
        PGRAPHICS_DEVICE PhysDispOfDeviceName = NULL;
        DWORD            devNum = 0;
        NTSTATUS         tmpStatus;

        HANDLE           hkRegistry = NULL;
        ULONG            defaultValue = 0;
        ULONG            attached = 0;
        ULONG            primary  = 0;
        PDRV_NAMES       lpDisplayNames;

        while (bMultiDevice &&
               (retStatus == STATUS_SUCCESS))
        {
            PhysDisp = NULL;
            hDev = NULL;
            hDevDisabled = NULL;

            if (pstrDeviceName && (PhysDispOfDeviceName == NULL))
            {
                PhysDispOfDeviceName = PhysDisp = DrvGetDeviceFromName(pstrDeviceName,
                                                                       PreviousMode);

                //
                // If we are under mode change, and device name specified. it
                // means caller want to change the mode for specified device
                // and leave other device as is. so we will still look for
                // other device in > 2 loops.
                //

                if (!bModeChange)
                {
                    bMultiDevice = FALSE;
                }
            }
            else
            {
                if (PhysDispOfDeviceName && bModeChange)
                {
                    //
                    // We are here when ...
                    //
                    //  + DrvCreateMDEV get called with specific device name,
                    //   AND
                    //  + During mode change.
                    //
                    // so get device from original MDEV instead of enumerate,
                    //

                    if (devNum < pMdevOrg->chdev)
                    {
                        hDev = pMdevOrg->Dev[devNum++].hdev;

                        PDEVOBJ pdo(hDev);

                        PhysDisp = pdo.ppdev->pGraphicsDevice;

                        //
                        // If this device is already attached (in 1st loop),
                        // don't need to attach again.
                        //

                        if (PhysDisp == PhysDispOfDeviceName)
                        {
                            continue;
                        }

                        //
                        // If we are in context of "adding mirroring driver"
                        // and this is mirroring
                        // device continue to add it, otherwise forget this.
                        //

                        if ((PhysDisp->stateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER) ?
                                (!bAttachMirroring) : bAttachMirroring)
                        {
                            continue;
                        }

                        //
                        // Increment the Open count of the device
                        //

                        GreAcquireSemaphoreEx(ghsemShareDevLock, SEMORDER_SHAREDEVLOCK, NULL);
                        GreAcquireSemaphoreEx(pdo.hsemDevLock(), SEMORDER_DEVLOCK, NULL);

                        GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);

                        pdo.ppdev->cPdevOpenRefs++;
                        pdo.ppdev->cPdevRefs++;

                        GreReleaseSemaphoreEx(ghsemDriverMgmt);

                        GreEnterMonitoredSection(pdo.ppdev, WD_DEVLOCK);

                        //
                        // If the Device was disabled, just reenable it.
                        // But for dualview, we want to delay the enable until new MDEV is created
                        //

                        if (pdo.bDisabled() &&
                            (((PhysDisp->stateFlags & DISPLAY_DEVICE_DUALVIEW) == 0) ||
                             !gbInvalidateDualView)
                           )
                        {
                            ASSERTGDI(pdo.ppdev->cPdevOpenRefs == 1,
                                     "Inconsistent Open count on disabled PDEV\n");

                            DrvEnableDisplay((HDEV) pdo.ppdev);
                        }

                        GreExitMonitoredSection(pdo.ppdev, WD_DEVLOCK);
                        GreReleaseSemaphoreEx(pdo.hsemDevLock());
                        GreReleaseSemaphoreEx(ghsemShareDevLock);

                        primary = (PhysDisp->stateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE) ? 1 : 0;
                        attached = 1; // since already attached.

                    }
                    else
                    {
                        break;
                    }
                }
                else
                {
                    DWORD cCount = 0;
                    for (PhysDisp = gpGraphicsDeviceList;
                         PhysDisp != NULL;
                         PhysDisp = PhysDisp->pNextGraphicsDevice, cCount++)
                    {
                        if (cCount == devNum)
                            break;
                    }
                    devNum++;

                    //
                    // For BaseVideo, on a default boot (as opposed to a test
                    // in the applet), just look for the VGA driver.
                    //

                    if (gbBaseVideo && PhysDisp)
                    {
                        PhysDisp = PhysDisp->pVgaDevice;

                        if (PhysDisp == NULL)
                        {
                            continue;
                        }
                    }
                }
            }

            if (PhysDisp == NULL) {
                break;
            }

            if (PruneFlag == GRE_DEFAULT) {
                bPrune = DrvGetPruneFlag(PhysDisp);
            }

            ASSERTGDI(PhysDisp, "Can not have NULL PhysDisp here\n");

            if (!hDev)
            {
                /*****************************************************************
                 *****************************************************************
                                     Get Device Information
                 *****************************************************************
                 *****************************************************************/

                TRACE_INIT(("\nDrv_Trace: DrvCreateMDEV: Trying to open device %ws \n", &(PhysDisp->szNtDeviceName[0])));

                GetPrimaryAttachFlags(PhysDisp, &primary, &attached);

                /*****************************************************************
                 *****************************************************************
                                      Load Display Drivers
                 *****************************************************************
                 *****************************************************************/

                //
                // Try to open the display driver associated to the kernel driver.
                //
                // We want to do this if we are looking for an attached device (taking
                // into account mirror devices properly) or if we are just looking
                // for any device.
                //

                if (GraphicsState == GraphicsStateFull)
                {
                    bLoad =  attached &&
                             ((PhysDisp->stateFlags &
                               DISPLAY_DEVICE_MIRRORING_DRIVER) ?
                                   bAttachMirroring :
                                   (!bAttachMirroring));
                }
                else if (GraphicsState == GraphicsStateNoAttach)
                {
                    if (PhysDisp->stateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER)
                    {
                        bLoad = (attached && bAttachMirroring);
                    }
                    else if (PhysDisp->stateFlags & DISPLAY_DEVICE_DISCONNECT)
                    {
                        bLoad = FALSE;
                    }
                    else
                    {
                        ASSERTGDI(displayInstalled || gProtocolType != PROTOCOL_DISCONNECT,
                                  "Failed to load disconnected driver while in disconnect mode.\n");

                        bLoad = (!displayInstalled && (gProtocolType != PROTOCOL_DISCONNECT));
                    }
                }
                else if (GraphicsState == GraphicsStateAttachDisconnect)
                {
                    if (PhysDisp->stateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER)
                    {
                        bLoad = (attached && bAttachMirroring);
                    }
                    else
                    {
                        bLoad = (!displayInstalled);
                    }
                }
                else
                {
                    bLoad =  (PhysDisp->stateFlags &
                              DISPLAY_DEVICE_MIRRORING_DRIVER) ?
                                  FALSE :
                                  (!displayInstalled);
                }

                if (bLoad &&
                    (lpDisplayNames = DrvGetDisplayDriverNames(PhysDisp)))
                {
                    PDEVMODEW  pdevmodeInformation;
                    DEVMODEW   sourceDevmodeInformation;
                    DWORD      dwAccelLevel;
                    DWORD      dwOverride;
                    BOOL       uu;
                    FLONG      flag = (PhysDisp->stateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER) ?
                               GCH_MIRRORING : GCH_DEFAULT_DISPLAY;

                    if (flag == GCH_DEFAULT_DISPLAY)
                    {
                        dwOverride = DrvGetDriverCapableOverRide(PhysDisp);
                        dwAccelLevel = DrvGetDriverAccelerationsLevel(PhysDisp);
                    }
                    else
                    {
                        dwOverride = DRIVER_CAPABLE_ALL;
                        dwAccelLevel = 0;
                    }

                    //
                    // We will try to load the driver using the information in the
                    // registry.  If it matches perfectly with a mode from the driver -
                    // great.  If it's a loose match, the we just give a warning.
                    //
                    // If that does not work, we will want to try the first mode
                    // in the list - which we get by matching with 0,0,0
                    //
                    // If that also fails, we want to boot with the default DEVMODE
                    // that we pass to the driver.
                    //

                    if (lpdevmodeInformation)
                    {
                        tmpStatus = DrvProbeAndCaptureDevmode(PhysDisp,
                                                              &pdevmodeInformation,
                                                              &uu,
                                                              lpdevmodeInformation,
                                                              FALSE,
                                                              PreviousMode,
                                                              bPrune,
                                                              bClosest,
                                                              FALSE);
                    }
                    else
                    {
                        RtlZeroMemory(&sourceDevmodeInformation, sizeof(DEVMODEW));
                        sourceDevmodeInformation.dmSize = sizeof(DEVMODEW);

                        tmpStatus = DrvProbeAndCaptureDevmode(PhysDisp,
                                                              &pdevmodeInformation,
                                                              &uu,
                                                              &sourceDevmodeInformation,
                                                              FALSE,
                                                              KernelMode,
                                                              bPrune,
                                                              bClosest,
                                                              FALSE);
                    }

                    if (tmpStatus == STATUS_RECEIVE_PARTIAL)
                    {
                        DrvLogDisplayDriverEvent(MsgInvalidDisplayMode);
                    }
                    else if (tmpStatus == STATUS_INVALID_PARAMETER_MIX)
                    {
                        ASSERTGDI(PhysDisp->stateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER,
                                  "Only mirror drivers can return this error code\n");

                        //
                        // In the case of mirroring, we want to use the same
                        // parameters as were provided for the main display.
                        // We do this by passing the HDEV of the device we are
                        // duplicating which will actually allow the driver to
                        // get all the details about the other device
                        //

                        PDEVOBJ pdo(pmdev->Dev[0].hdev);
                        PDEVMODEW pdm = pdo.ppdev->ppdevDevmode;

                        if (pdevmodeInformation &&
                            pdevmodeInformation != &sourceDevmodeInformation)
                        {
                            VFREEMEM(pdevmodeInformation);
                            pdevmodeInformation = NULL;
                        }
                        tmpStatus = DrvProbeAndCaptureDevmode(PhysDisp,
                                                              &pdevmodeInformation,
                                                              &uu,
                                                              pdm,
                                                              FALSE,
                                                              PreviousMode,
                                                              bPrune,
                                                              bClosest,
                                                              FALSE);
                    }

                    //
                    // hCreateHDEV will appropriately compare the current mode
                    // to the device, and disable the current PDEV if necessary
                    //

                    if (NT_SUCCESS(tmpStatus))
                    {
                        hDev = hCreateHDEV(PhysDisp,
                                           lpDisplayNames,
                                           pdevmodeInformation,
                                           pDesktopId,
                                           dwOverride,
                                           dwAccelLevel,
                                           bNoDisable,
                                           flag,
                                           &hDevDisabled);
                    }

                    //
                    // We failed to load a display driver with this devmode.
                    // Try to pick the first valid Devmode, unless the user
                    // requested a specific devmode.
                    //
                    // If it still fails, try 640x480x4 VGA mode.  We must get
                    // something to set
                    //

                    if (!(PhysDisp->stateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER) &&
                        (lpdevmodeInformation == NULL))
                    {
                        if (!hDev)
                        {
                            DrvLogDisplayDriverEvent(MsgInvalidDisplayMode);

                            //
                            // Free memory allocated by DrvProbeAndCaptureDevmode
                            //

                            if (pdevmodeInformation)
                            {
                                //
                                // Log an error saying the selected color or
                                // resolution is invalid.
                                //

                                if (pdevmodeInformation->dmBitsPerPel == 0x4)
                                {
                                    DrvLogDisplayDriverEvent(MsgInvalidDisplay16Colors);
                                }

                                if (pdevmodeInformation != &sourceDevmodeInformation)
                                {
                                    VFREEMEM(pdevmodeInformation);
                                    pdevmodeInformation = NULL;
                                }
                            }

                            TRACE_INIT(("Drv_Trace: DrvCreateMDEV: Trying first DEVMODE\n"));

                            RtlZeroMemory(&sourceDevmodeInformation, sizeof(DEVMODEW));
                            sourceDevmodeInformation.dmSize = sizeof(DEVMODEW);

                            if (NT_SUCCESS(DrvProbeAndCaptureDevmode(PhysDisp,
                                                                     &pdevmodeInformation,
                                                                     &uu,
                                                                     &sourceDevmodeInformation,
                                                                     TRUE,
                                                                     KernelMode,
                                                                     bPrune,
                                                                     bClosest,
                                                                     FALSE)))
                            {
                                hDev = hCreateHDEV(PhysDisp,
                                                   lpDisplayNames,
                                                   pdevmodeInformation,
                                                   pDesktopId,
                                                   dwOverride,
                                                   dwAccelLevel,
                                                   bNoDisable,
                                                   GCH_DEFAULT_DISPLAY,
                                                   &hDevDisabled);

                                //
                                // At last try 640x480x4bpp.  With Framebuf driver,
                                // 640x480x4 will never be picked by DrvProbeAndCapture().
                                // And it's very likely that the mode set can be failed.
                                //
                                if (hDev == NULL && pdevmodeInformation->dmBitsPerPel != 0x4)
                                {
                                    if (pdevmodeInformation &&
                                        pdevmodeInformation != &sourceDevmodeInformation)
                                    {
                                        VFREEMEM(pdevmodeInformation);
                                        pdevmodeInformation = NULL;
                                    }
                                    RtlZeroMemory(&sourceDevmodeInformation, sizeof(DEVMODEW));
                                    sourceDevmodeInformation.dmSize = sizeof(DEVMODEW);
                                    sourceDevmodeInformation.dmBitsPerPel = 0x4;
                                    sourceDevmodeInformation.dmPelsWidth  = 640;
                                    sourceDevmodeInformation.dmPelsHeight = 480;
                                    sourceDevmodeInformation.dmFields     = DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT;

                                    if (NT_SUCCESS(DrvProbeAndCaptureDevmode(PhysDisp,
                                                                             &pdevmodeInformation,
                                                                             &uu,
                                                                             &sourceDevmodeInformation,
                                                                             FALSE,
                                                                             KernelMode,
                                                                             bPrune,
                                                                             bClosest,
                                                                             FALSE)))
                                    {
                                        hDev = hCreateHDEV(PhysDisp,
                                                           lpDisplayNames,
                                                           pdevmodeInformation,
                                                           pDesktopId,
                                                           dwOverride,
                                                           dwAccelLevel,
                                                           bNoDisable,
                                                           GCH_DEFAULT_DISPLAY,
                                                           &hDevDisabled);
                                    }
                                }
                            }
                        }
                    }

                    if (!hDev)
                    {
                        //
                        // If no display driver initialized with the requested
                        // settings, put a message in the error log.
                        // (unless this was a change display settings call).
                        //

                        if (lpdevmodeInformation == NULL)
                        {
                            DrvLogDisplayDriverEvent(MsgInvalidDisplayDriver);
                        }
                    }

                    //
                    // Free memory allocated by DrvProbeAndCaptureDevmode
                    //

                    if (pdevmodeInformation &&
                        (pdevmodeInformation != &sourceDevmodeInformation))
                    {
                        VFREEMEM(pdevmodeInformation);
                    }

                    VFREEMEM(lpDisplayNames);
                }
            }

            if (hDev)
            {
                PMDEV     pmdevTmp;

                TRACE_INIT(("Drv_Trace: DrvCreateMDEV: Display Driver Loaded successfully\n"));

                //
                // We installed a display driver successfully, so we
                // know to exit out of the loop successfully.
                //

                displayInstalled = TRUE;

                //
                // Mark this device as being part of the primary device
                //

                if (primary)
                {
                    PhysDisp->stateFlags |= DISPLAY_DEVICE_PRIMARY_DEVICE;


                }
                else
                {
                    //
                    // Otherwise, mask off it, since if this physical display
                    // was primary previously, it still keeps it, so need to
                    // mask of it.
                    //

                    PhysDisp->stateFlags &= ~DISPLAY_DEVICE_PRIMARY_DEVICE;


                }

                // 
                // If we haven't found the previously enabled hdev for this device
                // look for it in the original mdev's list.
                //

                if (hDevDisabled == NULL && pMdevOrg != NULL)
                {
                    for (ULONG i = 0; i < pMdevOrg->chdev; i++)
                    {
                        PDEVOBJ po((HDEV) pMdevOrg->Dev[i].hdev);
                        PGRAPHICS_DEVICE pGraphicsDevice = po.ppdev->pGraphicsDevice;

                        if (PhysDisp == pGraphicsDevice)
                        {
                            hDevDisabled = pMdevOrg->Dev[i].hdev;
                        }
                    }
                }
                
                pmdev->Dev[pmdev->chdev].hdev     = hDev;
                pmdev->Dev[pmdev->chdev].Reserved = hDevDisabled;
                pmdev->chdev += 1;

                pmdevTmp = pmdev;

                //
                // We allocate and copy too much, but we don't care ...
                //

                pmdev = (PMDEV) PALLOCMEM(sizeof(MDEV) * (pmdevTmp->chdev + 1),
                                          GDITAG_DRVSUP);

                if (pmdev)
                {
                    //
                    // Compiler bug workaround MoveMemory instead of Copy
                    //

                    RtlMoveMemory(pmdev,
                                  pmdevTmp,
                                  sizeof(MDEV) * pmdevTmp->chdev);

                    VFREEMEM(pmdevTmp);
                }
                else
                {
                    //
                    // We will exit the loop since we had a memory
                    // allocation failure.
                    //

                    pmdev = pmdevTmp;
                    retStatus = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        }

        /*****************************************************************
         *****************************************************************
                            Handle loop exit conditions
         *****************************************************************
         *****************************************************************/

        //
        // If an error occured, we want to bring back the devices to their
        // normal state.
        //

        if (!NT_SUCCESS(retStatus))
        {
            break;
        }

        //
        // If there is no attached display drivers, then go to compatibility
        // mode and load any display device except Disconnect driver.
        // If still fails(only applies to local session, check it's headless
        // server and try to load Disconnect driver
        //

        if (!displayInstalled &&
            (GraphicsState == GraphicsStateFull))
        {
            TRACE_INIT(("\n\nDrv_Trace: No attached device: Look for any device except dummy driver.\n\n"));
            GraphicsState = GraphicsStateNoAttach;
            continue;
        }

        if (!displayInstalled &&
            (GraphicsState == GraphicsStateNoAttach) &&
            (gProtocolType == PROTOCOL_CONSOLE ))
        {
            TRACE_INIT(("\n\nDrv_Trace: No attached device: Look for any device including dummy driver.\n\n"));
            GraphicsState = GraphicsStateAttachDisconnect;
            continue;
        }

        //
        // If the display drivers have been installed, then look for the
        // Mirroring devices - as long as we are not in basevideo !
        //

        if (displayInstalled &&
            (bAttachMirroring == FALSE))
        {
            TRACE_INIT(("\n\nDrv_Trace: DrvCreateMDEV: Look for Mirroring drivers\n\n"));
            bAttachMirroring = TRUE;
            continue;
        }

        //
        // We must be done.  So if we did install the display driver, just
        // break out of this.
        //

        if (displayInstalled)
        {
            retStatus = STATUS_SUCCESS;
            break;
        }

        //
        // There are no devices we can work with in the registry.
        // We have a real failure and take appropriate action.
        //

        //
        // If we failed on the first driver, then we can assume their is no
        // driver installed.
        //

        if (devNum == 0)
        {
            WARNING("No kernel drivers initialized");
            retStatus = STATUS_DEVICE_DOES_NOT_EXIST;
            break;
        }

        //
        // If the display driver is not installed, then this is another
        // bad failure - report it.
        //

        if (!displayInstalled)
        {
            //This RIP is hit often in stress.
            //RIP("Drv_Trace: DrvCreateMDEV: No display drivers loaded");
            retStatus = STATUS_DRIVER_UNABLE_TO_LOAD;
            break;
        }

        //
        // Never get here !
        //

        retStatus = STATUS_UNSUCCESSFUL;
    }


    /*****************************************************************
     *****************************************************************
                     Check Flags and calculate rectangles
     *****************************************************************
     *****************************************************************/

    TRACE_INIT(("\nDrv_Trace: DrvCreateMDEV: Check flags and rectangles\n"));

    if (retStatus == STATUS_SUCCESS)
    {
        if (ulFlags & GRE_DISP_NOT_APARTOF_DESKTOP)
        {
            //
            // This MDEV is created for additional secondary use.
            // Don't change any attribute in PDEV based on this MDEV,
            // since these PDEV could be a part of other MDEV which
            // ,for example, represents current desktop.
            //
        }
        else
        {
            ULONG            i;
            LPRECT           pSrcRect = NULL;
            LPRECT           pDstRect = NULL;
            PGRAPHICS_DEVICE PhysDisp;
            ULONG            primary = 0;
            PGRAPHICS_DEVICE primaryPhysDisp = NULL;
            ULONG            size;

            //
            // Make sure there is only one primary.
            //

            for (i = 0; i < pmdev->chdev; i++)
            {
                PDEVOBJ pdo(pmdev->Dev[i].hdev);

                PhysDisp = pdo.ppdev->pGraphicsDevice;

                //
                // The first non-removable PhysDisp would be a primary candicate
                //
                if (PhysDisp->stateFlags & (DISPLAY_DEVICE_REMOVABLE | DISPLAY_DEVICE_MIRRORING_DRIVER))
                {
                    if (PhysDisp->stateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE)
                    {
                        TRACE_INIT(("Drv_Trace: DrvCreateMDEV: The primary desktop is on a removable or Mirror device.\n"));

                        PhysDisp->stateFlags &= ~DISPLAY_DEVICE_PRIMARY_DEVICE;
                    }
                }
                else
                {
                    if (primaryPhysDisp == NULL) {
                        primary = i;
                    }
                }

                if (PhysDisp->stateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE)
                {
                    if (primaryPhysDisp == NULL)
                    {
                        primaryPhysDisp = PhysDisp;
                        primary         = i;
                    }
                    else
                    {
                        ASSERTGDI(FALSE, "Two primary devices\n");

                        PhysDisp->stateFlags &=
                                ~DISPLAY_DEVICE_PRIMARY_DEVICE;

                        retStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
                    }
                }
            }

            //
            // Create a list of rects which we can align.
            //

            size = pmdev->chdev * sizeof(RECT);

            pSrcRect = (LPRECT) PALLOCNOZ(size, GDITAG_DRVSUP);
            pDstRect = (LPRECT) PALLOCNOZ(size, GDITAG_DRVSUP);

            if (pSrcRect && pDstRect)
            {
                ULONG ci = 0;

                for (i = 0; i < pmdev->chdev; i++)
                {
                    PDEVOBJ pdo(pmdev->Dev[i].hdev);
                    PDEVMODEW pdm = pdo.ppdev->ppdevDevmode;

                    //
                    // Reset the position rect with the real values.
                    //

                    (pSrcRect + i)->left   = pdm->dmPosition.x;
                    (pSrcRect + i)->top    = pdm->dmPosition.y;
                    (pSrcRect + i)->right  = pdm->dmPosition.x + pdm->dmPelsWidth;
                    (pSrcRect + i)->bottom = pdm->dmPosition.y + pdm->dmPelsHeight;

                    if (pdo.ppdev->pGraphicsDevice->stateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER)
                    {

                    }
                    else
                    {
                        //
                        // Find a primary if we don't already have one.
                        // The first device with 0,0 as the origin will be it.
                        //

                        if ( (primaryPhysDisp == NULL) &&
                             (pdm->dmPosition.x == 0)  &&
                             (pdm->dmPosition.y == 0) &&
                             ((pdo.ppdev->pGraphicsDevice->stateFlags & DISPLAY_DEVICE_REMOVABLE) == 0))
                        {
                            primary = i;
                            primaryPhysDisp = pdo.ppdev->pGraphicsDevice;
                        }

                        ci++;
                    }
                }

                RtlCopyMemory(pDstRect, pSrcRect, size);

                //
                // Set the primary
                //

                PDEVOBJ pdo(pmdev->Dev[primary].hdev);
                pdo.ppdev->pGraphicsDevice->stateFlags |= DISPLAY_DEVICE_PRIMARY_DEVICE;



                //
                // NOTE
                // CUDR_NOSNAPTOGRID == 1 in winuser.w
                //

                if (AlignRects(pDstRect, ci, primary, 1) == FALSE)
                {
                    //
                    // Devices could not be aligned.
                    //
                }

                if (!RtlEqualMemory(pDstRect, pSrcRect, ci * sizeof(RECT)))
                {
                    //
                    // Devices were repositioned
                    //

                    WARNING("GDI DDML: Device positions are adjusted");
                }

                //
                // Let's save all these rectangles
                //

                TRACE_INIT(("Drv_Trace: DrvCreateMDEV: Reseting device positions\n"));

                for (i = 0; i < pmdev->chdev; i++)
                {
                    PDEVOBJ pdo(pmdev->Dev[i].hdev);

                    TRACE_INIT(("\t%ws: ", pdo.ppdev->pGraphicsDevice->szNtDeviceName));

                    //
                    // Set the surface's origin
                    //

                    pdo.ppdev->ptlOrigin = *((PPOINTL) (pDstRect + i));

                    //
                    // Notify the surface's origin to driver.
                    //

                    if (PPFNDRV(pdo,Notify))
                    {
                        PPFNDRV(pdo,Notify)(pdo.pSurface()->pSurfobj(),
                                            DN_DEVICE_ORIGIN,
                                            (PVOID)(&(pdo.ppdev->ptlOrigin)));
                    }

                    //
                    // Save the rectangle back into the mdev structure.
                    //

                    pmdev->Dev[i].rect = *(pDstRect + i);

                #if DBG_BASIC
                    DbgPrint("GDI DDML: Device %d, position %d, %d, %d, %d, rotation %lu\n",
                                 i,
                                 pdo.pptlOrigin()->x,
                                 pdo.pptlOrigin()->y,
                                 pdo.pptlOrigin()->x +
                                     pdo.ppdev->ppdevDevmode->dmPelsWidth,
                                 pdo.pptlOrigin()->y +
                                     pdo.ppdev->ppdevDevmode->dmPelsHeight,
                                 pdo.ppdev->ppdevDevmode->dmDisplayOrientation * 90
                             );

                    if (pmdev->Dev[i].rect.left != pdo.pptlOrigin()->x)
                    {
                        DbgPrint("GDI DDML: Inconsistent rect left (%d) - origin left (%d)\n",
                                  pmdev->Dev[i].rect.left,pdo.pptlOrigin()->x);
                    }

                    if (pmdev->Dev[i].rect.top != pdo.pptlOrigin()->y)
                    {
                        DbgPrint("GDI DDML: Inconsistent rect top (%d) - origin top (%d)\n",
                                 pmdev->Dev[i].rect.top,pdo.pptlOrigin()->y);
                    }

                    if ((ULONG) pmdev->Dev[i].rect.right !=
                              pdo.pptlOrigin()->x + pdo.ppdev->ppdevDevmode->dmPelsWidth)
                    {
                        DbgPrint("GDI DDML: Inconsistent rect right (%d) - devmode right (%d)\n",
                                  pmdev->Dev[i].rect.right,
                                  pdo.pptlOrigin()->x + pdo.ppdev->ppdevDevmode->dmPelsWidth);
                    }

                    if ((ULONG) pmdev->Dev[i].rect.bottom !=
                              pdo.pptlOrigin()->y + pdo.ppdev->ppdevDevmode->dmPelsHeight)
                    {
                        DbgPrint("GDI DDML: Inconsistent rect bottom (%d) - devmode bottom (%d)\n",
                                  pmdev->Dev[i].rect.bottom,
                                  pdo.pptlOrigin()->y + pdo.ppdev->ppdevDevmode->dmPelsHeight);
                    }
                #endif
                }
            }

            if (pSrcRect)
            {
                VFREEMEM(pSrcRect);
            }

            if (pDstRect)
            {
                VFREEMEM(pDstRect);
            }
        }
    }

    if (!NT_SUCCESS(retStatus))
    {
        //
        // Delete all the hdevs we have created. and restore the old
        // ones.
        //

        DrvBackoutMDEV(pmdev);
        VFREEMEM(pmdev);
        pmdev = NULL;
    }

#if TEXTURE_DEMO
    pmdev = pmdevSetupTextureDemo(pmdev);
#endif

    //
    // Dump the MDEV structure.
    //

    TRACE_INIT(("DrvCreateMDEV: Resulting MDEV\n"));
    TRACE_INIT(("pmdev = %08lx\n", pmdev));

    if (pmdev)
    {
        ULONG i;

        for (i = 0; i < pmdev->chdev; i++)
        {
            TRACE_INIT(("\t[%d].hdev = %08lx\n", i, pmdev->Dev[i].hdev));
            TRACE_INIT(("\t[%d].rect = %d, %d, %d, %d,\n", i,
                        pmdev->Dev[i].rect.left,  pmdev->Dev[i].rect.top,
                        pmdev->Dev[i].rect.right, pmdev->Dev[i].rect.bottom));
        }
    }

    return (pmdev);
}

/***************************************************************************\
* DrvSetBaseVideo
*
*  Initialize the graphics components of the system
*
*             andreva       Created
\***************************************************************************/

VOID
DrvSetBaseVideo(
    BOOL bSet
    )
{
    gbBaseVideo = bSet;
}

/***************************************************************************\
* DrvCheckUpgradeSettings
*
*  Check first boot from upgrade.  If so, get last settings and move it
*  into normal setting registry.  Otherwise, check if have registry settings
*  already, if not, move preferred mode into normal setting registry.
*
*             dennyd       Created
\***************************************************************************/

DEFINE_GUID(GUID_DISPLAY_ADAPTER_INTERFACE, 0x5b45201d, 0xf2f2, 0x4f3b, 0x85, 0xbb, 0x30, 0xff, 0x1f, 0x95, 0x35, 0x99);

VOID
DrvCheckUpgradeSettings(VOID)
{
    PGRAPHICS_DEVICE  PhysDisp;
    PWSTR             SymbolicLinkList;
    UNICODE_STRING    SymbolicLinkName;
    HANDLE            hkRegistry = NULL;
    NTSTATUS          Status;
    USHORT            DualviewIndex;
    DEVMODEW          devMode;
    BOOL              bUpgraded;
    UNICODE_STRING    SubKeyName;
    HANDLE            hkSubKey = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    DWORD             UsePreferredMode;

    for (PhysDisp = gpGraphicsDeviceList;
         PhysDisp != NULL;
         PhysDisp = PhysDisp->pNextGraphicsDevice)
    {
        GUID Guid = GUID_DISPLAY_ADAPTER_INTERFACE;
        bUpgraded = FALSE;
        UsePreferredMode = 0;
        DualviewIndex = 0;

        if (PhysDisp->pPhysDeviceHandle == NULL)
            continue;
        
        //
        // Check if it's DualView second, assign an index to it
        //
        if (PhysDisp->stateFlags & DISPLAY_DEVICE_DUALVIEW)
        {
            PGRAPHICS_DEVICE  PhysDisp1;
            for (PhysDisp1 = gpGraphicsDeviceList;
                 PhysDisp1 != PhysDisp;
                 PhysDisp1 = PhysDisp1->pNextGraphicsDevice)
            {
                if ((PhysDisp->stateFlags & DISPLAY_DEVICE_DUALVIEW) &&
                    (PhysDisp->pPhysDeviceHandle == PhysDisp1->pPhysDeviceHandle))
                {
                    DualviewIndex++;
                }
            }
        }

        if (NT_SUCCESS(IoGetDeviceInterfaces(&Guid,
                                             (PDEVICE_OBJECT)PhysDisp->pPhysDeviceHandle,
                                             0,
                                             &SymbolicLinkList)) )
        {
            if (SymbolicLinkList[0] != L'\0')
            {
                WCHAR wstrSubKey[4];

                RtlInitUnicodeString(&SymbolicLinkName, SymbolicLinkList);

                if (NT_SUCCESS(IoOpenDeviceInterfaceRegistryKey(&SymbolicLinkName,
                                                                KEY_ALL_ACCESS,
                                                                &hkRegistry)))
                {
                    ULONG    defaultValue = 0, Attached;

                    //
                    // Read and delete the display settings
                    //

                    RtlZeroMemory(&devMode, sizeof(devMode));
                    swprintf(wstrSubKey, L"%d", DualviewIndex);

                    RTL_QUERY_REGISTRY_TABLE QueryTable[] =
                        {
                            {NULL, RTL_QUERY_REGISTRY_SUBKEY,
                             wstrSubKey,         NULL,         REG_NONE,  NULL,          0},
                            {NULL, RTL_QUERY_REGISTRY_DIRECT|RTL_QUERY_REGISTRY_DELETE, L"UsePreferredMode",
                             &UsePreferredMode, REG_DWORD, &defaultValue, 4},
                            {NULL, RTL_QUERY_REGISTRY_DIRECT|RTL_QUERY_REGISTRY_DELETE, DefaultSettings[0],
                             &devMode.dmBitsPerPel, REG_DWORD, &defaultValue, 4},
                            {NULL, RTL_QUERY_REGISTRY_DIRECT|RTL_QUERY_REGISTRY_DELETE, DefaultSettings[1],
                             &devMode.dmPelsWidth, REG_DWORD, &defaultValue, 4},
                            {NULL, RTL_QUERY_REGISTRY_DIRECT|RTL_QUERY_REGISTRY_DELETE, DefaultSettings[2],
                             &devMode.dmPelsHeight, REG_DWORD, &defaultValue, 4},
                            {NULL, RTL_QUERY_REGISTRY_DIRECT|RTL_QUERY_REGISTRY_DELETE, DefaultSettings[3],
                             &devMode.dmDisplayFrequency, REG_DWORD, &defaultValue, 4},
                            {NULL, RTL_QUERY_REGISTRY_DIRECT|RTL_QUERY_REGISTRY_DELETE, DefaultSettings[4],
                             &devMode.dmDisplayFlags, REG_DWORD, &defaultValue, 4},
                            {NULL, RTL_QUERY_REGISTRY_DIRECT|RTL_QUERY_REGISTRY_DELETE, DefaultSettings[7],
                             &devMode.dmDisplayOrientation, REG_DWORD, &defaultValue, 4},
                            {NULL, RTL_QUERY_REGISTRY_DIRECT|RTL_QUERY_REGISTRY_DELETE, DefaultSettings[8],
                             &devMode.dmDisplayFixedOutput, REG_DWORD, &defaultValue, 4},
                            {NULL, RTL_QUERY_REGISTRY_DIRECT|RTL_QUERY_REGISTRY_DELETE, DefaultSettings[9],
                             &devMode.dmPosition.x, REG_DWORD, &defaultValue, 4},
                            {NULL, RTL_QUERY_REGISTRY_DIRECT|RTL_QUERY_REGISTRY_DELETE, DefaultSettings[10],
                             &devMode.dmPosition.y, REG_DWORD, &defaultValue, 4},
                            {NULL, RTL_QUERY_REGISTRY_DIRECT|RTL_QUERY_REGISTRY_DELETE, DefaultSettings[11],
                             &Attached, REG_DWORD, &defaultValue, 4},
                            {NULL, 0, NULL}
                        };

                    if (NT_SUCCESS(RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                                      (PWSTR)hkRegistry,
                                                      &QueryTable[0],
                                                      NULL,
                                                      NULL)) &&
                        (devMode.dmPelsWidth != 0) &&
                        (!UsePreferredMode)
                       )
                    {
                        if (Attached) {
                            devMode.dmFields |= DM_POSITION;
                        }

                        DrvUpdateDisplayDriverParameters(PhysDisp,
                                                         &devMode,
                                                         (Attached == 0),
                                                         TRUE);
                        bUpgraded = TRUE;
                    }

                    //
                    // Delete the subkey containing the display settings
                    //

                    RtlInitUnicodeString(&SubKeyName, wstrSubKey);

                    InitializeObjectAttributes(&ObjectAttributes,
                                               &SubKeyName,
                                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                               hkRegistry,
                                               NULL);

                    if (NT_SUCCESS(ZwOpenKey(&hkSubKey,
                                             KEY_ALL_ACCESS,
                                             &ObjectAttributes))
                       )
                    {
                        ZwDeleteKey(hkSubKey);
                    }

                    //
                    // Close the device interface registry key
                    //

                    ZwClose(hkRegistry);
                }
            }
            ExFreePool((PVOID)SymbolicLinkList);
        }

        if (PhysDisp->stateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER) {
            continue;
        }

        //
        // Check if there are still registry settings.
        // If not, put preferred mode there.
        //

        PDEVMODEW pDevmode = (PDEVMODEW) PALLOCNOZ(sizeof(DEVMODEW) + MAXUSHORT,
                                                  GDITAG_DEVMODE);
        if (pDevmode == NULL) {
            continue;
        }

        RtlZeroMemory(pDevmode, sizeof(DEVMODEW));
        pDevmode->dmSize = 0xDDDD;
        pDevmode->dmDriverExtra = MAXUSHORT;

        if (UsePreferredMode ||
            (!bUpgraded &&
             (!NT_SUCCESS(DrvGetDisplayDriverParameters(PhysDisp,
                                                        pDevmode,
                                                        FALSE,
                                                        FALSE)) ||
              (pDevmode->dmPelsWidth == 0)
             )
            )
           )
        {
            RtlZeroMemory(pDevmode, sizeof(DEVMODEW));
            pDevmode->dmSize = sizeof(DEVMODEW);

            if (NT_SUCCESS(DrvGetPreferredMode(pDevmode, PhysDisp)))
            {
                pDevmode->dmBitsPerPel = 32;
                pDevmode->dmFields |= DM_BITSPERPEL;
                DrvUpdateDisplayDriverParameters(PhysDisp,
                                                 pDevmode,
                                                 FALSE,
                                                 TRUE);
            }
        }

        VFREEMEM(pDevmode);
    }
}

/***************************************************************************\
* DrvInitConsole
*
*  Initialize the graphics components of the system
*
*             andreva       Created
\***************************************************************************/

NTSTATUS
DrvInitConsole(
    BOOL bEnumerationNeeded)
{
    UNICODE_STRING    UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE            hkRegistry = NULL;
    NTSTATUS          Status;
    PGRAPHICS_DEVICE  PhysDisp;
    PVOID             RegistrationHandle;

    /*****************************************************************
     *****************************************************************
                              BaseVideo
     *****************************************************************
     *****************************************************************/

    //
    // Basevideo is considered a primary device in that the user will run
    // the vga driver.  This does override any other primary selection
    // the user may have put in the registry.
    //

    RtlInitUnicodeString(&UnicodeString,
                         L"\\Registry\\Machine\\System\\CurrentControlSet\\"
                         L"Control\\GraphicsDrivers\\BaseVideo");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                               NULL,
                               NULL);

    Status = ZwOpenKey(&hkRegistry,
                       KEY_READ,
                       &ObjectAttributes);
#ifdef _HYDRA_
    /*
     * No base video for WinStations
     */
    if ( !G_fConsole )
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
#endif


    if (NT_SUCCESS( Status))
    {
        TRACE_INIT(("Drv_Trace: DrvInitConsole: Basevideo - FOUND\n"));

        DrvSetBaseVideo(TRUE);

        if (hkRegistry)
            ZwCloseKey(hkRegistry);
    }
    else
    {
        TRACE_INIT(("Drv_Trace: DrvInitConsole: Basevideo - NOT FOUND\n"));

        DrvSetBaseVideo(FALSE);
    }

    /*****************************************************************
     *****************************************************************
                               Device List
     *****************************************************************
     *****************************************************************/


    RtlZeroMemory(&gFullscreenGraphicsDevice, sizeof(GRAPHICS_DEVICE));
    RtlZeroMemory(&gFeFullscreenGraphicsDevice, sizeof(GRAPHICS_DEVICE));

    //
    // Register for new device notifucations
    //
#if 0
    TRACE_INIT(("Drv_Trace: DrvInitConsole: Registering GUIDs\n"));

    _asm {int 3};

    Status = IoRegisterPlugPlayNotification (
                      EventCategoryDeviceInterfaceChange,
                      PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES,
                      (LPGUID) &GUID_DISPLAY_DEVICE_INTERFACE_STANDARD,
                      gpWin32kDriverObject,
                      (PDRIVER_NOTIFICATION_CALLBACK_ROUTINE)DrvNewDisplayDevice,
                      NULL,
                      &RegistrationHandle);

    if (!NT_SUCCESS(Status))
    {
        ASSERTGDI(FALSE, "IoRegisterPlugPlayNotification(display) failed");
        return;
    }

    Status = IoRegisterPlugPlayNotification (
                      EventCategoryDeviceInterfaceChange,
                      PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES,
                      (LPGUID) &GUID_DISPLAY_OUTPUT_INTERFACE_STANDARD,
                      gpWin32kDriverObject,
                      (PDRIVER_NOTIFICATION_CALLBACK_ROUTINE)DrvNewDisplayOutput,
                      NULL,
                      &RegistrationHandle);

    if (!NT_SUCCESS(Status))
    {
        ASSERTGDI(FALSE, "IoRegisterPlugPlayNotification(output) failed");
        return;
    }
#endif

    DrvUpdateGraphicsDeviceList(TRUE, bEnumerationNeeded, gProtocolType == PROTOCOL_CONSOLE);

    DrvCheckUpgradeSettings();

#if 0
    DrvGetMirrorDrivers();
#endif

    return STATUS_SUCCESS;
}

/***************************************************************************\
* DrvSetSharedDevLock
*
* routine to share devlock between parent and children.
*
* 05-Mar-1998 hideyukn  Created
\***************************************************************************/

VOID
DrvSetSharedDevLock(PMDEV pmdev)
{
    PDEVOBJ pdoParent(pmdev->hdevParent);

    // Parent's DEVLOCK should not be shared.

    ASSERTGDI(!pdoParent.bUseParentDevLock(),
              "DrvSetSharedDevLock():Parent PDEV has shared devlock\n");

    for (ULONG i = 0; i < pmdev->chdev; i++)
    {
        PDEVOBJ pdo(pmdev->Dev[i].hdev);

        // Set Parent PDEV as parent to each of the PDEVs that we'll manage.

        pdo.ppdev->ppdevParent = (PDEV *) pmdev->hdevParent;

        // Switch to use the shared DEVLOCK with parent.

        pdo.vUseParentDevLock();
    }
}

/***************************************************************************\
* DrvRealizeHalftonePalette
*
* routine to realize halftone palette onto given device.
*
* 22-Apr-1998 hideyukn  Created
\***************************************************************************/

PPALETTE gppalHalftone = NULL;
ULONG    gulPalTimeForDDML = 0;

PPALETTE
DrvRealizeHalftonePalette(HDEV hdevPalette, BOOL bForce)
{
    BOOL bRet = FALSE;

    PDEVOBJ pdoPalette(hdevPalette);
    XEPALOBJ palSurfObj(pdoPalette.ppalSurf());

    if (bForce || (gulPalTimeForDDML != palSurfObj.ulTime()))
    {
        //
        // Create display DC for palette device.
        //
        HDC hdcDevice = GreCreateDisplayDC(hdevPalette,DCTYPE_DIRECT,FALSE);

        if (hdcDevice)
        {
            if (gppalHalftone == NULL)
            {
                //
                // Create Win98 compatible halftone palette.
                //
                HPALETTE hPalette = GreCreateCompatibleHalftonePalette(hdcDevice);

                if (hPalette)
                {
                    EPALOBJ palObj(hPalette);

                    if (GreSetPaletteOwner(hPalette, OBJECT_OWNER_PUBLIC))
                    {
                        //
                        // Put it into Global variable.
                        //
                        gppalHalftone = palObj.ppalGet();
                    }
                    else
                    {
                        bDeletePalette((HPAL)hPalette,TRUE);
                    }
                }
                else
                {
                    WARNING("DrvRealizeHalftonePalette():Failed on GreCreateCompatibleHalftonePalette()");
                }
            }

            if (gppalHalftone)
            {
                //
                // Selet the global halftone palette into the palette device.
                //
                HPALETTE hPalOld = GreSelectPalette(hdcDevice,
                                                    (HPALETTE)gppalHalftone->hGet(),
                                                    TRUE); // ForceBackgound

                if (hPalOld)
                {
                    XEPALOBJ palHTObj(gppalHalftone);

                    //
                    // Strip translation table.
                    //
                    palHTObj.vMakeNoXlate();

                    //
                    // Realize halftone palette on device. (device palette might be changed)
                    //
                    if (GreRealizePalette(hdcDevice))
                    {
                        KdPrint(("DrvRealizeHalftonePalette():Device palette has been changed\n"));
                    }

                    //
                    // Update palette time.
                    //

                    gulPalTimeForDDML = palSurfObj.ulTime();

                    //
                    // Select back old one.
                    //
                    GreSelectPalette(hdcDevice,hPalOld,FALSE);

                    bRet = TRUE;
                }
                else
                {
                    WARNING("DrvRealizeHalftonePalette():Failed on GreSelectPalette()");
                }
            }
            else
            {
                WARNING("DrvRealizeHalftonePalette():gppalHalftone is NULL");
            }

            bDeleteDCInternal(hdcDevice,TRUE,FALSE);
        }
        else
        {
            WARNING("DrvRealizeHalftonePalette():Failed on GreCreateDisplayDC()");
        }
    }
    else
    {
        //
        // Realization is still effective.
        //

        bRet = TRUE;
    }

    //
    // If we could not have halftone palette, just use default palette.
    //

    return (bRet ? gppalHalftone : ppalDefault);
}

/***************************************************************************\
* DrvSetSharedPalette
*
* routine to share palette between parent and children.
*
* 22-Apr-1998 hideyukn  Created
\***************************************************************************/

BOOL MulSetPalette(DHPDEV,PALOBJ *,FLONG,ULONG,ULONG);

HDEV
DrvSetSharedPalette(PMDEV pmdev)
{
    HDEV hdevPalette = NULL;

    //
    // ToddLa's law - Palette should be shared with all paletaized monitors.
    //

    PDEVOBJ pdoParent(pmdev->hdevParent);

    //ASSERTGDI((PPFNDRV(pdoParent,SetPalette)) == MulSetPalette,
    //	     "DrvSetSharedPalette(): SetPalette != MulSetPalette\n");

    PPALETTE ppalShared = NULL;

    if (pdoParent.bIsPalManaged())
    {
        //
        // If parent is palette device, we shared it
        // with all paletaized children.
        //

        ppalShared = pdoParent.ppalSurf();

        //
        // Remember the hdev which owns palette.
        //

        hdevPalette = pdoParent.hdev();
    }

    for (UINT i = 0; i < pmdev->chdev; i++)
    {
        PDEVOBJ pdoChild(pmdev->Dev[i].hdev);

        if (pdoChild.bIsPalManaged())
        {
            //
            // Change pointer to DrvSetPalette to
            // DDML, so that palette can be changed
            // to a specific hdev, will be dispatch
            // to every paletaized device.
            //

            pdoChild.pfnSetPalette(MulSetPalette);

            if (ppalShared == NULL)
            {
                //
                // Parent is not palette device, but
                // this is palette device which we
                // encounter first in the children,
                // so we will share this palette.
                //

                ppalShared = pdoChild.ppalSurf();

                //
                // Remember the hdev which owns palette.
                //

                hdevPalette = pdoChild.hdev();
            }
            else if (pdoChild.ppalSurf() != ppalShared)
            {
                //
                // If the palette in hdev is already same as
                // parent (mostly it is primary device, if
                // primary is palette device.), don't
                // need to update it. Otherwise update it here.
                //

                XEPALOBJ palChild(pdoChild.ppalSurf());

                //
                // Set colour table to shared palette.
                //

                palChild.apalColorSet(ppalShared);
            }
        }
    }

    return (hdevPalette);
}

/***************************************************************************\
* DrvTransferGdiObjects()
*
* Transfer belonging gdi object from a hdev to other.
*
* 04-Jul-1998 hideyukn  Created
\***************************************************************************/

#define DRV_TRANS_DC_TYPE      0x0001
#define DRV_TRANS_SURF_TYPE    0x0002
#define DRV_TRANS_DRVOBJ_TYPE  0x0004
#define DRV_TRANS_WNDOBJ_TYPE  0x0008
#define DRV_TRANS_ALL_TYPE     0x000F
#define DRV_TRANS_TO_CLONE     0x1000

VOID
DrvTransferGdiObjects(HDEV hdevNew, HDEV hdevOld, ULONG ulFlags)
{
    //
    // 1) Change owner of DC_TYPE object.
    //
    // 2) Change owner of SURF_TYPE object.
    //
    //    + ATI driver, for example, creates engine
    //      bitmap for thier banking, off-screen
    //      bitmap and ..., so need to change owner
    //      of those bitmap to clone's hdev.
    //
    // 3) Change owner of DRVOBJ_TYPE object.
    //
    // 4) Exchange WNDOBJ.
    //

    PDEVOBJ pdoNew(hdevNew);
    PDEVOBJ pdoOld(hdevOld);

    ASSERTGDI(pdoNew.pSurface() == pdoOld.pSurface(),
              "DrvTransferGdiObjects():pSurface does not match\n");

    ASSERTGDI(pdoNew.dhpdev() == pdoOld.dhpdev(),
              "DrvTransferGdiObjects():dhpdev does not match\n");

    GreAcquireHmgrSemaphore();

    HOBJ hobj = 0;

    //
    // Transfer DC which own by hdevCloned to hdevClone.
    //

    if (ulFlags & DRV_TRANS_DC_TYPE)
    {
        PDC  pdc = NULL;
        hobj = 0;

        while (pdc = (DC*) HmgSafeNextObjt(hobj, DC_TYPE))
        {
            hobj = (HOBJ) pdc->hGet();

            if ((HDEV)pdc->ppdev() == hdevOld)
            {
                KdPrint(("Transfer DC %x - hdevNew %x hdevOld %x \n",
                          pdc->hGet(),hdevNew,hdevOld));

                pdc->ppdev((PDEV *)pdoNew.hdev());

                if (ulFlags & DRV_TRANS_TO_CLONE)
                {
                    pdc->fsSet(DC_IN_CLONEPDEV);
                }
                else
                {
                    pdc->fsClr(DC_IN_CLONEPDEV);
                }

                pdoNew.vReferencePdev();
                pdoOld.vUnreferencePdev();
            }
        }
    }

    //
    // Transfer surface which own by old pdev to new pdev.
    //

    if (ulFlags & DRV_TRANS_SURF_TYPE)
    {
        SURFACE *pSurface = NULL;
        hobj = 0;

        while (pSurface = (SURFACE*) HmgSafeNextObjt(hobj, SURF_TYPE))
        {
            hobj = (HOBJ) pSurface->hGet();

            if ((pSurface->hdev() == hdevOld) /* && pSurface->bDriverCreated() */)
            {
                KdPrint(("Transfer surface %x - hdevNew %x hdevOld %x \n",
                          pSurface->hGet(),hdevNew,hdevOld));

                pSurface->hdev(hdevNew);
            }
        }
    }

    //
    // Transfer DRVOBJ.
    //

    if (ulFlags & DRV_TRANS_DRVOBJ_TYPE)
    {
        DRVOBJ *pdrvo = NULL;
        hobj = 0;

        while (pdrvo = (DRVOBJ*) HmgSafeNextObjt(hobj, DRVOBJ_TYPE))
        {
            hobj = (HOBJ) pdrvo->hGet();

            if (pdrvo->hdev == hdevOld)
            {
                KdPrint(("Transfer drvobj %x - hdevNew %x hdevOld %x \n",
                          pdrvo->hGet(),hdevNew,hdevOld));

                pdrvo->hdev = hdevNew;
                pdoNew.vReferencePdev();
                pdoOld.vUnreferencePdev();
            }
        }
    }

    //
    // Transfer WNDOBJ.
    //
    if (ulFlags & DRV_TRANS_WNDOBJ_TYPE)
    {
        vTransferWndObjs(pdoNew.pSurface(),pdoOld.hdev(),pdoNew.hdev());
    }

    GreReleaseHmgrSemaphore();
}

/***************************************************************************\
* DrvEnableDirectDrawForModeChange()
*
* 01-Aug-1998 hideyukn  Created
\***************************************************************************/

VOID
DrvEnableDirectDrawForModeChange(
    HDEV *phdevList,
    BOOL  bAlloc
    )
{
    ASSERTGDI(GreIsSemaphoreOwnedByCurrentThread(ghsemShareDevLock),
          "ShareDevlock must be held be before calling EnableDirectDraw");

    ULONG chdev = (ULONG)(ULONG_PTR)(*phdevList);
    HDEV *phdev = phdevList + 1;

    for (ULONG i = 0; i < chdev; i++)
    {
        GreResumeDirectDraw(*phdev, FALSE);
        phdev++;
    }

    if (bAlloc)
    {
        VFREEMEM(phdevList);
    }
}

/***************************************************************************\
* DrvDisableDirectDrawForModeChange()
*
* 01-Aug-1998 hideyukn  Created
\***************************************************************************/

HDEV *
DrvDisableDirectDrawForModeChange(
    PMDEV pmdev1,
    PMDEV pmdev2,
    HDEV *phdevQuickList,
    ULONG chdevQuickList
    )
{
    HDEV  *phdevList, *phdev;
    ULONG  chdevList;

    ASSERTGDI(GreIsSemaphoreOwnedByCurrentThread(ghsemShareDevLock),
          "ShareDevlock must be held be before calling DisableDirectDraw");

    chdevList = pmdev1->chdev + pmdev2->chdev + 2;

    if (chdevQuickList >= chdevList)
    {
        phdevList = phdevQuickList;
    }
    else
    {
        phdevList = (HDEV *)PALLOCNOZ(chdevList * sizeof(HDEV), 'pmtG');

        if (phdevList == NULL)
        {
            return (NULL);
        }
    }

    phdev     = phdevList + 1;
    chdevList = 0;

    if (pmdev1->hdevParent)
    {
        *phdev = pmdev1->hdevParent;
        phdev++; chdevList++;
    }

    for (ULONG i = 0; i < pmdev1->chdev; i++)
    {
        *phdev = pmdev1->Dev[i].hdev;
        phdev++; chdevList++;
    }

    if (pmdev2->hdevParent)
    {
        *phdev = pmdev2->hdevParent;
        phdev++; chdevList++;
    }

    for (i = 0; i < pmdev2->chdev; i++)
    {
        *phdev = pmdev2->Dev[i].hdev;
        phdev++; chdevList++;
    }

    *phdevList = (HDEV)ULongToPtr( chdevList );

    for (i = 0; i < chdevList; i++)
    {
        PDEVOBJ pdo(phdevList[i+1]);

        // Devlock must *not* be held.

        pdo.vAssertNoDevLock();

        GreSuspendDirectDrawEx(phdevList[i+1], DXG_SR_DDRAW_MODECHANGE);
    }

    return (phdevList);
}

//
// This function checks which Dualview Views will be attached.  Then send a SWITCH_DUALVIEW
// notification to driver for setting of Video memory.
// It also checks if current DUALVIEW attachment state will be changed.  The caller can decide
// if a PDEV can be reused or not.
//
// Return Value:
//    DualviewNoSwitch:  The DUALVIEW attachment state remains same
//    DualviewSwitch:    The DUALVIEW attachment state will be changed.
//    DualviewFail:      The DUALVIEW attachment state will be changed.
//                       And related PhysDisps have outstanding refcount and may get reused later
//
typedef enum _DUALVIEW_STATE {
    DualviewNoSwitch = 0,
    DualviewSwitch,
    DualviewFail
} DUALVIEW_STATE;

DUALVIEW_STATE
CheckAndNotifyDualView(
    PUNICODE_STRING pstrDeviceName,
    PMDEV           pMdevOrg,
    MODE            PreviousMode
    )
{
    PGRAPHICS_DEVICE PhysDisp;
    ULONG            bResetAll, bytesReturned;
    ULONG            primary, attach = 0;
    ULONG            numDualViews = 0, i, j;
    BOOL	     bNoneToAttach = TRUE, bNoneAttached = TRUE;
    BOOL             bChangeDualviewState = FALSE, bHasOutstanding = FALSE;
    DUALVIEW_STATE   retVal;

    typedef struct
    {
        PGRAPHICS_DEVICE PhysDisp;
        ULONG       Attached;
        ULONG       ToAttach;
    } ATTACHPHYSDISP, *PATTACHPHYSDISP;
    
    for (PhysDisp = gpGraphicsDeviceList;
         PhysDisp != NULL;
         PhysDisp = PhysDisp->pNextGraphicsDevice)
    {
        if (PhysDisp->stateFlags & DISPLAY_DEVICE_DUALVIEW)
        {
            numDualViews++;
        }
    }

    if (numDualViews == 0)
	return DualviewNoSwitch;

    PATTACHPHYSDISP AttachPhysDisp = (PATTACHPHYSDISP) PALLOCMEM(sizeof(ATTACHPHYSDISP)*numDualViews, GDITAG_DRVSUP);

    if (AttachPhysDisp == NULL)
	return DualviewFail;


    numDualViews = 0;
    for (PhysDisp = gpGraphicsDeviceList;
         PhysDisp != NULL;
         PhysDisp = PhysDisp->pNextGraphicsDevice)
    {
        if (PhysDisp->stateFlags & (DISPLAY_DEVICE_MIRRORING_DRIVER | DISPLAY_DEVICE_DISCONNECT))
        {
            continue;
        }

        GetPrimaryAttachFlags(PhysDisp, &primary, &attach);
        if (attach)
        {
            bNoneToAttach = FALSE;
        }

        if (PhysDisp->stateFlags & DISPLAY_DEVICE_DUALVIEW)
        {
            AttachPhysDisp[numDualViews].PhysDisp = PhysDisp;
            AttachPhysDisp[numDualViews].ToAttach = (attach) ? 1 : 0;
            //
            // Check if the PhysDisp is already attached in pMdevOrg
            //
            AttachPhysDisp[numDualViews].Attached = 0;
            if (pMdevOrg)
            {
                for (i = 0; i < pMdevOrg->chdev; i++)
                {
                    PDEVOBJ po(pMdevOrg->Dev[i].hdev);
                    if ((po.ppdev->pGraphicsDevice) == PhysDisp)
                    {
                        AttachPhysDisp[numDualViews].Attached = 1;
                        bNoneAttached = FALSE;
                    }
                }
            }

            numDualViews++;
        }
    }

    //
    // A little patch for Attach flag from Registry.  If all of PhysDisp are NotAttach
    // in registry, CreateMDEV will pick the first PhysDisp to Attach.  It is a typical
    // situation right after clean setup.
    //
    if (bNoneToAttach)
    {
        for (PhysDisp = gpGraphicsDeviceList;
             PhysDisp != NULL;
             PhysDisp = PhysDisp->pNextGraphicsDevice)
        {
            if (!(PhysDisp->stateFlags & (DISPLAY_DEVICE_MIRRORING_DRIVER | DISPLAY_DEVICE_DISCONNECT)))
            {
                if (PhysDisp->stateFlags & DISPLAY_DEVICE_DUALVIEW)
                {
                    AttachPhysDisp[0].ToAttach = 1;
                }
                break;
            }
        }
    }

    if (!pstrDeviceName)
    {

        for (i = 0; i < numDualViews; i++)
        {
            if (AttachPhysDisp[i].Attached != AttachPhysDisp[i].ToAttach || pMdevOrg == NULL)
            {
                bChangeDualviewState = TRUE;
            }
        }
    }
    else
    {
        //
        // Never allow ChangeDisplaySettings("\\.\DisplayX") to attach/detach one of Dualview 
        //
        PhysDisp = DrvGetDeviceFromName(pstrDeviceName, PreviousMode);
        if (PhysDisp)
        {
            for (i = 0; i < numDualViews; i++)
            {
                if (PhysDisp == AttachPhysDisp[i].PhysDisp)
                {
                    if (AttachPhysDisp[i].Attached != AttachPhysDisp[i].ToAttach || pMdevOrg == NULL)
                    {
                        bChangeDualviewState = TRUE;
                        bHasOutstanding = TRUE;
		   }
                    break;
                }
            }
        }
    }

    if (bChangeDualviewState)
    {
        if (bHasOutstanding)
        {
	    retVal = DualviewFail;
            //
            // If we cannot change mode due to Dualview, restore the original 
            // attch state in case of surprise mode change later.  Since CPL
            // won't restore te attach flag.
            //
            if (pMdevOrg)
            {
                for (i = 0; i < numDualViews; i++) {
                    DrvUpdateAttachFlag(PhysDisp, AttachPhysDisp[i].Attached);
                }
            }
        }
        else
        {
            retVal = DualviewSwitch;
            //
            // Send driver the Dualview state change notification
            //
            if (!pstrDeviceName)
            {
                for (i = 0; i < numDualViews; i++) {
                    GreDeviceIoControl(AttachPhysDisp[i].PhysDisp->pDeviceHandle,
                                       IOCTL_VIDEO_SWITCH_DUALVIEW,
                                       &(AttachPhysDisp[i].ToAttach),
                                       sizeof(ULONG),
                                       NULL,
                                       0,
                                       &bytesReturned);
                }
            }
            else
            {
                ASSERTGDI(FALSE, "Trying to attach/detach a view by ChangeDisplaySettings(DisplayX)\n");
            }
        }
    }
    else {
        retVal = DualviewNoSwitch;
    }

    //
    // After sending the notification, the the driver may change mode list internally.
    // Force PhysDisp to update mode list here
    //
    for (i = 0; i < numDualViews; i++)
    {
	DrvBuildDevmodeList(AttachPhysDisp[i].PhysDisp, TRUE);
    }
    
    VFREEMEM(AttachPhysDisp);

    return retVal;
}

/***************************************************************************\
* DrvChangeDisplaySettings
*
* Routines to change the settings of a display device.
*
*             andreva       Created
\***************************************************************************/

BOOL MulEnableDriver(ULONG,ULONG,PDRVENABLEDATA);
BOOL PanEnableDriver(ULONG,ULONG,PDRVENABLEDATA);

LONG
DrvChangeDisplaySettings(
    PUNICODE_STRING pstrDeviceName,
    HDEV            hdevPrimary,
    LPDEVMODEW      lpDevMode,
    PVOID           pDesktopId,
    MODE            PreviousMode,
    BOOL            bUpdateRegistry,
    BOOL            bSetMode,
    PMDEV           pOrgMdev,
    PMDEV           *pNewMdev,
    DWORD           PruneFlag,
    BOOL            bTryClosest
    )
{
    GDIFunctionID(DrvChangeDisplaySettings);

    PGRAPHICS_DEVICE PhysDisp = NULL;
    UNICODE_STRING   DeviceName;
    PDEVMODEW        pdevmodeInformation = NULL;
    BOOL             bDetach;
    LONG             status = GRE_DISP_CHANGE_SUCCESSFUL;
    ULONG            defaultValue = 0;
    ULONG            disableAll;
    ULONG            i, j;
    PMDEV            pmdev;
    BOOL             bPrune = (PruneFlag != GRE_RAWMODE);
#if DBG
    ULONG            oldTrace;
#endif

    RTL_QUERY_REGISTRY_TABLE QueryTable[] =
    {
        {NULL, RTL_QUERY_REGISTRY_DIRECT, L"DisableAll", &disableAll,
         REG_DWORD, &defaultValue, 4},
        {NULL, 0, NULL}
    };

    TRACE_INIT(("Drv_Trace: DrvChangeDisplaySettings - Enter\n"));

    *pNewMdev = NULL;
    gbInvalidateDualView = FALSE;

    //
    // Let's find the device on which the operation must be performed.
    //

    if (pstrDeviceName)
    {
        PhysDisp = DrvGetDeviceFromName(pstrDeviceName, PreviousMode);

        if (PhysDisp == NULL)
        {
            TRACE_INIT(("Drv_Trace: DrvChangeDisplaySettings - Leave - Bad Device\n"));
            return GRE_DISP_CHANGE_BADPARAM;
        }
    }
    else
    {
        //
        // If (NULL, NULL) is passed in, then we want to change the
        // default desktop back to what it was ...
        // Otherwise, for compatibility, (NULL, DEVMODE) affect only the
        // primary device.
        //

        if (lpDevMode)
        {
            PDEVOBJ pdo(hdevPrimary);

            if (pdo.bValid())
            {
                PhysDisp = pdo.ppdev->pGraphicsDevice;
            }

            if (PhysDisp == NULL)
            {
                TRACE_INIT(("Drv_Trace: DrvChangeDisplaySettings - Leave - Bad Device\n"));
                return GRE_DISP_CHANGE_BADPARAM;
            }
        }
    }

    if (PhysDisp == (PGRAPHICS_DEVICE) DDML_DRIVER)
    {
        ASSERTGDI(FALSE, "Trying to change settings for DDML layer\n");
        return GRE_DISP_CHANGE_BADPARAM;
    }

    if (PhysDisp != NULL)
    {


        if (PruneFlag == GRE_DEFAULT)
            bPrune = DrvGetPruneFlag(PhysDisp);

        RtlInitUnicodeString(&DeviceName, PhysDisp->szWinDeviceName);
        pstrDeviceName = &DeviceName;

        if (lpDevMode != NULL)
        {
            #if DBG
            //
            // less debug output for DirectDraw :
            //

            oldTrace = GreTraceDisplayDriverLoad;

            if (!bUpdateRegistry && !bSetMode) {
                GreTraceDisplayDriverLoad &= 0xFFFFFFF0;
            }
            #endif

            //
            // Get the new DEVMODE.
            //

            if (!NT_SUCCESS(DrvProbeAndCaptureDevmode(PhysDisp,
                                                      &pdevmodeInformation,
                                                      &bDetach,
                                                      lpDevMode,
                                                      FALSE,
                                                      PreviousMode,
                                                      bPrune,
                                                      bTryClosest,
                                                      FALSE)))
            {
                TRACE_INIT(("Drv_Trace: DrvChangeDisplaySettings - Leave - Bad Devmode\n"));
                return GRE_DISP_CHANGE_BADMODE;
            }


            if (lpDevMode->dmFields == 0)
                bTryClosest = TRUE;

            #if DBG
            GreTraceDisplayDriverLoad = oldTrace;
            #endif
        }
        else{  // For registry settings, always use closest
            bTryClosest = TRUE;
        }
    }

    //
    // At this point we have validated all data.
    // So if the user just tested the mode, the call would now be successful
    //
    // Let's see if we actually need to do something with this mode.
    //

    //
    // Write the data to the registry.
    //
    // This is not supported for the vgacompatible device - so it should just fail.
    //

    if (bUpdateRegistry && (PhysDisp != NULL) && (gProtocolType == PROTOCOL_CONSOLE))
    {
        //
        // Check if the Administrator has disabled this privilege.
        // It is on by default.
        //

        disableAll = 0;

        RtlQueryRegistryValues(RTL_REGISTRY_CONTROL,
                               L"GraphicsDrivers\\PermanentSettingChanges",
                               &QueryTable[0],
                               NULL,
                               NULL);

        if (disableAll)
        {
            status = GRE_DISP_CHANGE_NOTUPDATED;
        }
        else
        {
            NTSTATUS retStatus = DrvUpdateDisplayDriverParameters(PhysDisp, pdevmodeInformation, bDetach, TRUE);

            if (!NT_SUCCESS(retStatus))
            {
                status = GRE_DISP_CHANGE_BADMODE;
                if (retStatus == STATUS_INVALID_PARAMETER_4)
                {
                    status = GRE_DISP_CHANGE_BADPARAM;
                }
            }
        }

        TRACE_INIT(("Drv_Trace: DrvChangeDisplaySettings - Save Params status %d\n", status));
    }

    //
    // Set the mode dynamically
    //

    if (bSetMode && (status == GRE_DISP_CHANGE_SUCCESSFUL))
    {
        ASSERTGDI(pOrgMdev == NULL || DrvQueryMDEVPowerState(pOrgMdev),
                  "DrvChangeDisplaySettings called with powered off MDEV.\n");

#if MDEV_STACK_TRACE_LENGTH
        LONG    lMDEVTraceEntry, lMDEVTraceEntryNext;
        ULONG   StackEntries, UserStackEntry;

        do
        {
            lMDEVTraceEntry = glMDEVTrace;
            lMDEVTraceEntryNext = lMDEVTraceEntry + 1;
            if (lMDEVTraceEntryNext >= gcMDEVTraceLength) lMDEVTraceEntryNext = 0;
        } while (InterlockedCompareExchange(&glMDEVTrace, lMDEVTraceEntryNext, lMDEVTraceEntry) != lMDEVTraceEntry);

        RtlZeroMemory(&gMDEVTrace[lMDEVTraceEntry],
                      sizeof(gMDEVTrace[lMDEVTraceEntry]));
        gMDEVTrace[lMDEVTraceEntry].pMDEV = pOrgMdev;
        gMDEVTrace[lMDEVTraceEntry].API   = DrvChangeDisplaySettings_SetMode;
        StackEntries = sizeof(gMDEVTrace[lMDEVTraceEntry].Trace)/sizeof(gMDEVTrace[lMDEVTraceEntry].Trace[0]);
        UserStackEntry = RtlWalkFrameChain((PVOID *)gMDEVTrace[lMDEVTraceEntry].Trace,
                                           StackEntries, 
                                           0);
        StackEntries -= UserStackEntry;
        RtlWalkFrameChain((PVOID *)&gMDEVTrace[lMDEVTraceEntry].Trace[UserStackEntry],
                          StackEntries,
                          1);
#endif

        //
        // First things first, acquire share dev lock.  This must
        // be acquired before any other dev locks are acquired.
        //

        GreAcquireSemaphoreEx(ghsemShareDevLock, SEMORDER_SHAREDEVLOCK, NULL);

        //
        // Check if there are restrictions on changing the resolution
        // dymanically
        // Restriction don't apply for booting the machine though ...
        //

        pmdev = NULL;
        status = GRE_DISP_CHANGE_FAILED;
        disableAll = 0;

        RtlQueryRegistryValues(RTL_REGISTRY_CONTROL,
                               L"GraphicsDrivers\\TemporarySettingChanges",
                               &QueryTable[0],
                               NULL,
                               NULL);

        if ((disableAll == 0) || (pOrgMdev == NULL))
        {
            //
            // Lets create a new MDEV
            //
            if (pOrgMdev)
            {
                PDEVOBJ pdoTmp(pOrgMdev->hdevParent);
                ASSERTGDI(pdoTmp.cPdevRefs() > 10,
                          "curent MDEV is not the main one !\n");

                //
                // Dualview preprocess.  We probe the registry first to see if
                // the second view is about to be attached.  The we notify the miniport
                // before the first PDEV is created.
                //
                // If DUALVIEW attachment state changes, all PDEVs has to be regenerated.
                // Even a PDEV with same settings cannot be reused.
                //
                // However, if there is D3D running, a PDEV cannot be simply regenerated
                // due to ALT-TAB feature (a PDEV has an extra refcount for D3D apps).  We
                // cannot do anything but fail
                //
                switch (CheckAndNotifyDualView(pstrDeviceName, pOrgMdev, PreviousMode))
                {
                case DualviewNoSwitch:
                    gbInvalidateDualView = FALSE;
                    break;
                case DualviewSwitch:
                    gbInvalidateDualView = TRUE;
                    bTryClosest = TRUE;
                    break;
                default:
                    GreReleaseSemaphoreEx(ghsemShareDevLock);
                    return GRE_DISP_CHANGE_BADDUALVIEW;
                }

                //
                // Disable current MDEV.
                //
                // FALSE here, means ONLY meta PDEV will be disabled in
                // multi monitor case. And hardware will not be disabled
                // in single monitor cases.
                //

                if (DrvDisableMDEV(pOrgMdev, FALSE))
                {
                    //
                    // Create new MDEV
                    //
                    // If we will create new HDEV which device is used
                    // in current (= old) MDEV. HDEV in old MDEV will
                    // be disabled, and stored in MDEV.Dev[x].Reserved
                    // for recover current config in error case later.
                    //

                    pmdev = DrvCreateMDEV(pstrDeviceName,
                                          pdevmodeInformation,
                                          pDesktopId,
                                          0,
                                          pOrgMdev,
                                          KernelMode,
                                          PruneFlag,
                                          bTryClosest);

                    if (!pmdev)
                    {

                        // At this point, we have failed to create MDEV based on
                        // new configuration, so status continue to keep
                        // GRE_DISP_CHANGE_FAILED. And re-enable original MDEV.
                        //

                        DrvEnableMDEV(pOrgMdev, FALSE);
                    }
                    else
                    {
                        //
                        // At this point, we have all the hdevs involved in the
                        // switch.
                        //
                        // On entering this functions
                        // pOrgMdev - list of original hdevs
                        // pmdev - list of new hdevs
                        //         reserved fields have the hdevs that were disabled
                        //
                        // On exit
                        // pmdev - list of old (permanent) and new hdevs for user
                        // pOrgMdev - unused
                        //

                        status = GRE_DISP_CHANGE_NO_CHANGE;

                        //
                        // Determine if anything changed in the two structures
                        //

                        if (pmdev->chdev != pOrgMdev->chdev)
                        {
                             status = GRE_DISP_CHANGE_SUCCESSFUL;
                        }
                        else
                        {
                            for (i=0 ; i <pmdev->chdev; i++)
                            {
                                if ((pmdev->Dev[i].hdev != pOrgMdev->Dev[i].hdev) ||
                                    (!RtlEqualMemory(&(pmdev->Dev[i].rect),
                                                     &(pOrgMdev->Dev[i].rect),
                                                     sizeof(RECT))))
                                {
                                    status = GRE_DISP_CHANGE_SUCCESSFUL;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                TRACE_INIT(("DrvChangeDisplaySettings - no original MDEV, create one\n"));

                //
                // Dualview preprocess.
                //
                CheckAndNotifyDualView(pstrDeviceName, NULL, PreviousMode);
                gbInvalidateDualView = TRUE;

                pmdev = DrvCreateMDEV(pstrDeviceName,
                                      pdevmodeInformation,
                                      pDesktopId,
                                      0,
                                      NULL,
                                      KernelMode,
                                      PruneFlag,
                                      bTryClosest);

                if (pmdev)
                {
                    status = GRE_DISP_CHANGE_SUCCESSFUL;
                }
            }
        }

        *pNewMdev = pmdev;

        //
        // If everything worked, but the two structures are not identical, do
        // the switching around.
        //
        // Handle the four seperate case :
        // 1-1, 1-many, many-1 and many-many
        //

        BOOL bSwitchError = FALSE;

        HDEV hdevTmp;
        HDEV hdevClone = NULL;
        HDEV hdevCloned = NULL;

        BOOL bSwitchParentAndChild = FALSE;
        BOOL bEnableClone = FALSE;

        if (status == GRE_DISP_CHANGE_SUCCESSFUL)
        {
            ULONG       iClonehdev = 0;
            HDEV       *phdevDDLock = NULL;
            HDEV        ahdevDDLockQuick[7];

            MULTIDEVLOCKOBJ mdloMdev;
            MULTIDEVLOCKOBJ mdloOrgMdev;

            HSEMAPHORE  hsemCloneHdevDevLock = NULL;
            HSEMAPHORE  hsemOrgMdevDevLock = NULL;
            HSEMAPHORE  hsemOrgMdevPointer = NULL;

            if (pOrgMdev)
            {
                BOOL bLockSemaphore = FALSE;

                //
                // Disable DirectDraw on both MDEV's. This must be done
                // before we acquire the Devlock.
                //
                phdevDDLock = DrvDisableDirectDrawForModeChange(
                                  pOrgMdev,pmdev,
                                  (HDEV *)ahdevDDLockQuick,
                                  sizeof(ahdevDDLockQuick)/sizeof(HDEV));

                if (phdevDDLock == NULL)
                {
                    bSwitchError = TRUE;
                }
                else
                {
                    //
                    // The following lock rules must be abided, otherwise deadlocks may
                    // arise:
                    //
                    // o  DevLock must be acquired after the ShareDevLock
                    // o  Pointer lock must be acquired after Devlock (GreSetPointer);
                    // o  RFont list lock must be acquired after Devlock (TextOut);
                    // o  Handle manager lock must be acquired after Devlock (old
                    //    CvtDFB2DIB);
                    // o  Handle manager lock must be acquired after Palette Semaphore
                    //    (GreSetPaletteEntries)
                    // o  Palette Semaphore must be acquired after Devlock (BitBlt)
                    // o  Palette Semaphore must be acquired after driver semaphore
                    //    (bDeletePalette)
                    //
                    // So we acquire locks in the following order (note that the
                    // vAssertDynaLock() routines should be modified if this list ever
                    // changes):
                    //

                    //
                    // At this point, we have *not* ssyned devlock for new MDEV, yet,
                    // so lock all children. During the mode change. we don't want to
                    // anything change in its children.
                    //

                    mdloOrgMdev.vInit(pOrgMdev);
                    mdloMdev.vInit(pmdev);

                    if (mdloMdev.bValid() && mdloOrgMdev.bValid())
                    {
                        PDEVOBJ pdoTmp;

                        pdoTmp.vInit(pOrgMdev->hdevParent);
                        hsemOrgMdevDevLock = pdoTmp.hsemDevLock();
                        hsemOrgMdevPointer = pdoTmp.hsemPointer();

                        //
                        // Lock the parent of MDEV.
                        //

                        GreAcquireSemaphoreEx(hsemOrgMdevDevLock, SEMORDER_DEVLOCK, NULL);

                        //
                        // Lock the pointer in old mdev's parent.
                        //

                        GreAcquireSemaphoreEx(hsemOrgMdevPointer, SEMORDER_POINTER, hsemOrgMdevDevLock);

                        //
                        // Lock the children in MDEVs
                        //

                        mdloOrgMdev.vLock(); // No drawing to any dynamic surfaces
                        mdloMdev.vLock();    // No drawing to any dynamic surfaces

                        // WinBug #301042 3-1-2001 jasonha
                        //   GDI: SPRITESTATE duplicated and inconsistent when cloning
                        //  When cloning is used two PDEV (and therefore two SPRITESTATEs)
                        //  try to manage the same display (psoScreen).  Hooking one
                        //  while 'Inside' the other will confuse the state.  Hooking
                        //  will only change if there are visible sprites; so we
                        //  will temporarily hide them all.  Later we will unhide all
                        //  sprites on the whichever MDEV will remain active.
                        //
                        // Hide all sprites
                        //

                        vSpHideSprites(pOrgMdev->hdevParent, TRUE);

                        //
                        // Fixup new and old MDEVs.
                        //

                        if ((pmdev->chdev == 1) && (pOrgMdev->chdev != 1))
                        {
                            //
                            // Many to 1
                            //

                            for (i=0 ; i <pOrgMdev->chdev; i++)
                            {
                                if (pOrgMdev->Dev[i].hdev == pmdev->Dev[0].hdev)
                                {
                                    TRACE_INIT(("DrvChangeDisplaySettings: creating clone\n"));

                                    //
                                    // DrvCreateCloneHDEV will creates exactly same HDEV with
                                    // different handle.
                                    //

                                    hdevClone = DrvCreateCloneHDEV(
                                                    pmdev->Dev[0].hdev,
                                                    DRV_CLONE_DEREFERENCE_ORG);

                                    if (hdevClone)
                                    {
                                        //
                                        // Replace the hdev with clone, and save original
                                        // into reserved fields for later to back out
                                        // mode change if error happens.
                                        //

                                        pOrgMdev->Dev[i].hdev = hdevClone;
                                        pOrgMdev->Dev[i].Reserved = pmdev->Dev[0].hdev;

                                        hdevCloned = pmdev->Dev[0].hdev;
                                        iClonehdev = i;
                                    }
                                    else
                                    {
                                        bSwitchError = TRUE;
                                    }

                                    //
                                    // Shouldn't be another same HDEV in MDEV,
                                    // so, just go out loop here...
                                    //

                                    break;
                                }
                            }
                        }
                        else if ((pmdev->chdev != 1) && (pOrgMdev->chdev == 1))
                        {
                            //
                            // 1 to Many
                            //

                            //
                            // [Case 1] - Attach new monitor, and some change has been made on existing
                            //
                            //    At this case, new MDEV will everything new HDEV, like...
                            //
                            //      Org MDEV - ATI:  800x600  8bpp             (HDEV is A)
                            //
                            //      New MDEV - ATI: 1024x768 24bpp             (HDEV is B)
                            //                 MGA: 1024x768 32bpp             (HDEV is C)
                            //                Parent: Created based on B and C (HDEV is D)
                            //    then,
                            //
                            //      1) mode change between "A" and "D".
                            //      2) flip handle (set "A" to where "D" is, and set "D" to where "A" is).
                            //
                            //    So that finally "A" becomes a parent of "B" and "C". then delete "D".
                            //
                            // [Case 2] - Attach new monitor.
                            //
                            //    At this case, new MDEV will contains previous HDEV, since original
                            //    monitor is nothing changed, so it looks like...
                            //
                            //      Org MDEV - ATI: 1024x768 24bpp             (HDEV is A)
                            //
                            //      New MDEV - ATI: 1024x768 24bpp             (HDEV is A)
                            //                 MGA: 1024x768 32bpp             (HDEV is C)
                            //                Parent: Created based on A and C (HDEV is D)
                            //
                            //     In this case, we can *not* mode change, because if we do mode
                            //    change between "A" and "D", then we flip the handle, "A"
                            //    becomes a parent of "A" and "C" (since when we create "D", it
                            //    children are "A" and "C". when we create parent, parent can know
                            //    and cache into thier local, who is thier children.
                            //    (see Multi.cxx MulEnablePDEV()) "A" can not be a parent of "A".
                            //
                            //     Thus, how we do there is just create a clone (= "B") of "A", and replace
                            //    "A" with "B" in new MDEV, so new MDEV will be like,
                            //
                            //      New MDEV - ATI: 1024x768 24bpp             (HDEV is B) (clone of A)
                            //                 MGA: 1024x768 32bpp             (HDEV is C)
                            //                Parent: Created based on B and C (HDEV is D)
                            //
                            //     Of course we can do notify to parent driver to one of thier
                            //    child "A" is replaced with "D" and do same for new MDEV, to
                            //    avoid to create clone. But it too complex to re-initialized
                            //    parent "A" based on "D" and "C", and what-else will problem later on.
                            //     So here we just create a clone, so that we can take a same
                            //    code path as 1) except create a clone, here.
                            //
                            //    Then, (actually here is same as case 1)
                            //
                            //      1) mode change between "A" and "D".
                            //      2) flip handle (set "A" to where "D" is, and set "D" to where "A" is).
                            //
                            //    So that finally "A" becomes a parent of "B" and "C". then delete "D".
                            //

                            //
                            // Do we have any re-used original HDEV in new MDEV ?
                            //

                            for (i=0 ; i <pmdev->chdev; i++)
                            {
                                if (pmdev->Dev[i].hdev == pOrgMdev->Dev[0].hdev)
                                {
                                    TRACE_INIT(("DrvChangeDisplaySettings: creating clone\n"));

                                    //
                                    // DrvCreateCloneHDEV will creates exactly same HDEV with
                                    // different handle.
                                    //

                                    hdevClone = DrvCreateCloneHDEV(
                                                    pOrgMdev->Dev[0].hdev,
                                                    DRV_CLONE_DEREFERENCE_ORG);

                                    if (hdevClone)
                                    {
                                        //
                                        // Replace the hdev with clone, and save original
                                        // into reserved fields for later to back out
                                        // mode change if error happens.
                                        //

                                        pmdev->Dev[i].hdev = hdevClone;
                                        pmdev->Dev[i].Reserved = pOrgMdev->Dev[0].hdev;

                                        hdevCloned = pOrgMdev->Dev[0].hdev;

                                        //
                                        // Later we need copy data to Clone from Cloned.
                                        //
                                        bEnableClone = TRUE;
                                    }
                                    else
                                    {
                                        bSwitchError = TRUE;
                                    }

                                    //
                                    // Shouldn't be another same HDEV in MDEV,
                                    // so, just go out loop here...
                                    //

                                    break;
                                }
                            }

                            if (bSwitchError == FALSE)
                            {
                                //
                                // We will switch between parent and children
                                //

                                bSwitchParentAndChild = TRUE;
                            }
                        }
                        else
                        {
                            //
                            // 1 to 1, Many to Many
                            //
                        }

                        if (hdevClone)
                        {
                            pdoTmp.vInit(hdevClone);
                            hsemCloneHdevDevLock = pdoTmp.hsemDevLock();

                            //
                            // If we creates any clone device, hold devlock here.
                            //

                            GreAcquireSemaphoreEx(hsemCloneHdevDevLock, SEMORDER_DEVLOCK, NULL);
                        }

                        if (bSwitchError == FALSE)
                        {
                            //
                            // Lock rest of semaphores which we should hold during mode change.
                            //

                            GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL); // No driver loading/unloading
                            GreAcquireSemaphoreEx(ghsemPalette, SEMORDER_DRIVERMGMT, NULL);    // No SaveDC/RestoreDC
                            GreAcquireSemaphoreEx(ghsemPublicPFT, SEMORDER_PUBLICPFT, NULL);  // Nobody else uses the font table
                            GreAcquireSemaphoreEx(ghsemRFONTList, SEMORDER_RFONTLIST, NULL);  // Nobody else uses the RFONT list

                            //
                            // Lock handle manager to prevent new handle being created, or
                            // deleting existing handle. so that we can safely walk through
                            // handle manager list.
                            //

                            GreAcquireHmgrSemaphore();

                            bLockSemaphore = TRUE;
                        }
                    }
                    else
                    {
                        bSwitchError = TRUE;
                    }
                }

                if (bSwitchError == FALSE)
                {
                    ASSERTGDI(bLockSemaphore == TRUE,
                        "DrvChangeDisplaySettings(): Semaphores is not locked\n");

                    //
                    // Do the mode change for children device.
                    //

                    if (pmdev->chdev == 1)
                    {
                        if (pOrgMdev->chdev == 1)
                        {
                            //
                            // 1 to 1
                            //

                            TRACE_INIT(("Drv_Trace: DrvChangeDisplaySettings: Mode Change 1 -> 1.\n"));

                            if (bDynamicModeChange(pOrgMdev->Dev[0].hdev,
                                                   pmdev->Dev[0].hdev) == TRUE)
                            {
                                hdevTmp               = pOrgMdev->Dev[0].hdev;
                                pOrgMdev->Dev[0].hdev = pmdev->Dev[0].hdev;
                                pmdev->Dev[0].hdev    = hdevTmp;
                            }
                            else
                            {
                                // Error occured
                                bSwitchError = TRUE;
                            }
                        }
                        else
                        {
                            //
                            // Many to 1
                            //

                            TRACE_INIT(("Drv_Trace: DrvChangeDisplaySettings: Mode Change Many -> 1.\n"));

                            if (bSwitchError == FALSE)
                            {
                            #ifdef DONT_CHECKIN
                                if (hdevClone)
                                {
                                    //
                                    // Transfer DC_TYPE objects to clone.
                                    //

                                    DrvTransferGdiObjects(pOrgMdev->Dev[iClonehdev].hdev,
                                                          pmdev->Dev[0].hdev,
                                                          DRV_TRANS_DC_TYPE |
                                                          DRV_TRANS_TO_CLONE);
                                }
                            #endif

                                if (bDynamicModeChange(pOrgMdev->hdevParent,
                                                       pmdev->Dev[0].hdev) == TRUE)
                                {
                                    hdevTmp              = pOrgMdev->hdevParent;
                                    pOrgMdev->hdevParent = pmdev->Dev[0].hdev;
                                    pmdev->Dev[0].hdev   = hdevTmp;

                                    if (hdevClone)
                                    {
                                        hdevCloned = hdevTmp;

                                    #ifdef DONT_CHECKIN
                                        //
                                        // Transfer back DC_TYPE objects in clone to original.
                                        //

                                        DrvTransferGdiObjects(pmdev->Dev[0].hdev,
                                                              pOrgMdev->Dev[iClonehdev].hdev,
                                                              DRV_TRANS_DC_TYPE);
                                    #endif
                                    }
                                }
                                else
                                {
                                    // Error occured
                                    bSwitchError = TRUE;
                                }
                            }
                        }
                    }
                    else
                    {
                        if (pOrgMdev->chdev == 1)
                        {
                            //
                            // 1 to Many
                            //

                            TRACE_INIT(("Drv_Trace: DrvChangeDisplaySettings: Mode Change 1 -> Many.\n"));
                        }
                        else
                        {
                            //
                            // Many to Many
                            //

                            TRACE_INIT(("Drv_Trace: DrvChangeDisplaySettings: Mode Change Many -> Many.\n"));

                            for (i=0 ; i <pmdev->chdev; i++)
                            {
                                PDEVOBJ pdo1(pmdev->Dev[i].hdev);

                                for (j=0 ; j <pOrgMdev->chdev; j++)
                                {
                                    PDEVOBJ pdo2(pOrgMdev->Dev[j].hdev);

                                    if (pdo1.ppdev->pGraphicsDevice == pdo2.ppdev->pGraphicsDevice)
                                    {
                                        if (pmdev->Dev[i].hdev == pOrgMdev->Dev[j].hdev)
                                        {
                                            // Same hdev, nothing need to do.
                                        }
                                        else if (bDynamicModeChange(pOrgMdev->Dev[j].hdev,
                                                                    pmdev->Dev[i].hdev) == TRUE)
                                        {
                                            hdevTmp               = pOrgMdev->Dev[j].hdev;
                                            pOrgMdev->Dev[j].hdev = pmdev->Dev[i].hdev;
                                            pmdev->Dev[i].hdev    = hdevTmp;
                                        }
                                        else
                                        {
                                            // Error occured
                                            bSwitchError = TRUE;
                                        }

                                        break;
                                    }
                                }
                            }
                        }
                    }

                    //
                    // Release handle manager lock.
                    //

                    GreReleaseHmgrSemaphore();

                    //
                    // Now, we are finished all mode changes for parent and children
                    // so we are safe to unlock it.
                    //

                    GreReleaseSemaphoreEx(ghsemRFONTList);
                    GreReleaseSemaphoreEx(ghsemPublicPFT);
                    GreReleaseSemaphoreEx(ghsemPalette);
                    GreReleaseSemaphoreEx(ghsemDriverMgmt);

                    //
                    // Mark as unlocked.
                    //

                    bLockSemaphore = FALSE;
                }
            }

            //
            // If we need to create a new parent and do a switch, now is
            // the time.
            //

            if (bSwitchError == FALSE)
            {
                //
                // Setup the parent hdev for old MDEV (if old MDEV is provided).
                //

                if (pOrgMdev)
                {
                    if (pOrgMdev->chdev == 1)
                    {
                        //
                        // 1 to 1, 1 to Many.
                        //

                        pOrgMdev->hdevParent = pOrgMdev->Dev[0].hdev;
                        pOrgMdev->Reserved   = pOrgMdev->Dev[0].Reserved; // actually not nessesary...
                    }
                    else
                    {
                        //
                        // Many to 1, Many to Many.
                        //
                    }
                }

                //
                // Setup the parent hdev for new MDEV.
                //

                if (pmdev->chdev == 1)
                {
                    //
                    // 1 to 1, Many to 1.
                    //

                    TRACE_INIT(("Drv_Trace: DrvCompleteMDEV: Single Device\n"));

                    pmdev->hdevParent = pmdev->Dev[0].hdev;
                    pmdev->Reserved   = pmdev->Dev[0].Reserved;
                }
                else
                {
                    //
                    // 1 to Many, Many to Many.
                    //

                    TRACE_INIT(("Drv_Trace: DrvChangeDisplaySettings: Create new Parent MDEV (Many/1 -> Many)\n"));

                    //
                    // If we have more than one device that is attached to the
                    // desktop, then we need to create the META structure for
                    // that device, initialize it, and use that as the primary
                    // device.
                    //

                    DRV_NAMES drvName;
                    HDEV hdevDisabled;

                    TRACE_INIT(("Drv_Trace: DrvCompleteMDEV: Create HMDEV\n"));

                    drvName.cNames             = 1;
                    drvName.D[0].hDriver       = NULL;
                    drvName.D[0].lpDisplayName = (LPWSTR)MulEnableDriver;

                    pmdev->hdevParent = hCreateHDEV((PGRAPHICS_DEVICE) DDML_DRIVER,
                                                    &drvName,
                                                    ((PDEVMODEW)(pmdev)),
                                                    pmdev->pDesktopId,
                                                    DRIVER_CAPABLE_ALL,
                                                    DRIVER_ACCELERATIONS_FULL,
                                                    TRUE, // ignored in this case
                                                    GCH_DDML,
                                                    &hdevDisabled);

                    if (!pmdev->hdevParent)
                    {
                        RIP("Drv_Trace: DrvCompleteMDEV: DDML failed");
                        bSwitchError = TRUE;
                    }
                    else
                    {
                        if (pOrgMdev != NULL)
                        {
                            PDEVOBJ pdoParent(pmdev->hdevParent);
                            HSEMAPHORE hsemParentDevLock = pdoParent.hsemDevLock();

                            //
                            // During the mode change devlock should be hold for parent
                            //

                            GreAcquireSemaphoreEx(hsemParentDevLock, SEMORDER_DEVLOCK, NULL);
                            GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);
                            GreAcquireSemaphoreEx(ghsemPalette, SEMORDER_PALETTE, NULL);
                            GreAcquireSemaphoreEx(ghsemPublicPFT, SEMORDER_PUBLICPFT, NULL);  // Nobody else uses the font table
                            GreAcquireSemaphoreEx(ghsemRFONTList, SEMORDER_RFONTLIST, NULL);
                            GreAcquireHmgrSemaphore();

                            if (bSwitchParentAndChild)
                            {
                                //
                                // Mode change between new parent (meta) HDEV and
                                // old HDEV, so that old HDEV becomes new parent
                                // (meta) HDEV which has children.
                                //

                                if (bDynamicModeChange(pOrgMdev->Dev[0].hdev,
                                                       pmdev->hdevParent) == TRUE)
                                {
                                    hdevTmp               = pmdev->hdevParent;
                                    pmdev->hdevParent     = pOrgMdev->Dev[0].hdev;
                                    pOrgMdev->hdevParent  = hdevTmp;
                                    pOrgMdev->Dev[0].hdev = hdevTmp;

                                    if (hdevClone)
                                    {
                                        hdevCloned = hdevTmp;
                                    }
                                }
                                else
                                {
                                    // Error occured
                                    bSwitchError = TRUE;
                                }
                            }
                            else
                            {
                                //
                                // Switch the mode between parents (DDML).
                                //


                                if (bDynamicModeChange(pOrgMdev->hdevParent,
                                                       pmdev->hdevParent) == TRUE)
                                {
                                    hdevTmp              = pOrgMdev->hdevParent;
                                    pOrgMdev->hdevParent = pmdev->hdevParent;
                                    pmdev->hdevParent    = hdevTmp;
                                }
                                else
                                {
                                    // Error occured
                                    bSwitchError = TRUE;
                                }
                            }

                            //
                            // Release semaphores.
                            //

                            GreReleaseHmgrSemaphore();
                            GreReleaseSemaphoreEx(ghsemRFONTList);
                            GreReleaseSemaphoreEx(ghsemPublicPFT);  // Nobody else uses the font table
                            GreReleaseSemaphoreEx(ghsemPalette);
                            GreReleaseSemaphoreEx(ghsemDriverMgmt);
                            GreReleaseSemaphoreEx(hsemParentDevLock);
                        }
                    }
                }
            }

            //
            // Below code is only for mode change case.
            //

            if (pOrgMdev)
            {
                //
                // Finalize clone hdev stuff (if created)
                //

                if ((bSwitchError == FALSE) && hdevClone && hdevCloned)
                {
                    PDEV *pdevNew = (PDEV *) hdevClone;
                    PDEV *pdevOld = (PDEV *) hdevCloned;

                    PDEVOBJ pdoNew(hdevClone);
                    PDEVOBJ pdoOld(hdevCloned);

                    ASSERTGDI(pdevOld->pSurface != NULL,
                        "DrvChangeDisplaySettings():Original has null surface\n");

                    ASSERTGDI(pdevNew->pSurface == pdevOld->pSurface,
                        "DrvChangeDisplaySettings():Clone has wrong surface\n");

                    ASSERTGDI(pdevNew->dhpdev == pdevOld->dhpdev,
                        "DrvChangeDisplaySettings():Clone has wrong dhpdev\n");

                    ASSERTGDI(!pdoOld.bCloneDriver(),
                        "DrvChangeDisplaySettings():Original should not marked as clone\n");

                    ASSERTGDI(pdoNew.bCloneDriver(),
                        "DrvChangeDisplaySettings():Clone should have marked as clone\n");

                    ASSERTGDI(pdevOld->pGraphicsDevice == pdevNew->pGraphicsDevice,
                        "DrvChangeDisplaySettings():Clone should have same graphics device\n");

                    if (bEnableClone)
                    {
                        //
                        // Inform the driver that the PDEV is complete.
                        //

                        TRACE_INIT(("DrvChangeDisplaySettings(): Enabling clone pdev\n"));

                        //
                        // Transfer device surface to clone from cloned PDEV.
                        //

                        pdevNew->pSurface = pdevOld->pSurface;

                        //
                        // Set new hdev into surface.
                        //

                        if (pdevNew->pSurface)
                        {
                            pdevNew->pSurface->hdev(pdoNew.hdev());
                        }

                        //
                        // Transsfer dhpdev from cloned to clone
                        //

                        pdevNew->dhpdev = pdevOld->dhpdev;

                        //
                        // Transfer DirectDraw driver state from cloned to clone.
                        //

                        DxDdDynamicModeChange(pdoOld.hdev(), pdoNew.hdev(), DXG_MODECHANGE_TRANSFER);

                        //
                        // Transfer other surface and other objects which own by hdevCloned to hdevClone.
                        //
                        //  Transfer the objects belonging to cloned pdev to clone,
                        // transfer between clone and cloned is completely seemless
                        // from driver. So we need to change owner of those object
                        // by ourselves.
                        //

                        DrvTransferGdiObjects(pdoNew.hdev(),pdoOld.hdev(),DRV_TRANS_ALL_TYPE);

                        //
                        // Invalidate surface in cloned pdev, so that this won't deleted.
                        //

                        pdevOld->pSurface = NULL;

                        //
                        // Invalidate dhpdev in cloned.
                        //

                        pdevOld->dhpdev = NULL;

                        //
                        // Now, clone device has everything grab from original, so
                        // mark original as clone, and mark clone as original.
                        //

                        pdoOld.bCloneDriver(TRUE);
                        pdoNew.bCloneDriver(FALSE);

                        //
                        // Disabling old pdev.
                        //

                        pdoOld.bDisabled(TRUE);

                        //
                        // call device driver to let them knows new hdev.
                        //

                        pdoNew.CompletePDEV(pdoNew.dhpdev(),pdoNew.hdev());

                        //
                        // Make sure pdoOld which going to be delete, does not have any reference.
                        //

                        // KdPrint(("GDI DDML: 1 to Many monitor video mode change\n"));
                        // KdPrint(("GDI DDML: Open ref count in ppdevOld = %d\n", pdevOld->cPdevOpenRefs));
                        // KdPrint(("GDI DDML: Pdev ref count in ppdevOld = %d\n", pdevOld->cPdevRefs));
                    }
                    else
                    {
                        TRACE_INIT(("DrvChangeDisplaySettings(): Disabling clone pdev\n"));

                        //
                        // Clone was created for temporary purpose.
                        //
                        // Invalidate surface in clone pdev, so that this won't deleted.
                        //

                        pdevNew->pSurface = NULL;

                        //
                        // Disable clone PDEV.
                        //                

                        pdoNew.bDisabled(TRUE);

                        // KdPrint(("GDI DDML: Many to 1 monitor video mode change\n"));
                        // KdPrint(("GDI DDML: Open ref count in ppdevOld = %d\n", pdevNew->cPdevOpenRefs));
                        // KdPrint(("GDI DDML: Pdev ref count in ppdevOld = %d\n", pdevNew->cPdevRefs));
                    }
                }

                //
                // Disable old parant pdev if its meta driver.
                // Since meta PDEV never be reused in new MDEV.
                //

                PDEVOBJ pdoOldParent(pOrgMdev->hdevParent);

                if (pdoOldParent.bMetaDriver())
                {
                    pdoOldParent.bDisabled(TRUE);
                }

                //
                // Reactivate sprites on whichever MDEV will be used
                //

                vSpHideSprites(((bSwitchError == FALSE) ? pmdev : pOrgMdev)->hdevParent, FALSE);

                //
                // If we hold clone's devlock, now safe to release.
                //

                if (hsemCloneHdevDevLock)
                {
                    GreReleaseSemaphoreEx(hsemCloneHdevDevLock);
                }

                //
                // Release MDEV's lock.
                //

                mdloMdev.vUnlock();
                mdloOrgMdev.vUnlock();
            }

            //
            // Finalize new MDEV.
            //

            if (bSwitchError == FALSE)
            {
                PDEVOBJ  poP(pmdev->hdevParent);

                if (pmdev->chdev != 1)
                {
                    HDEV hdevPalette;

                    //
                    // Do devlock sharing
                    //

                    DrvSetSharedDevLock(pmdev);

                    //
                    // Do palette sharing
                    //

                    hdevPalette = DrvSetSharedPalette(pmdev);

                    if (!poP.bIsPalManaged() && hdevPalette)
                    {
                        //
                        // If parent is not pal-managed, but if there is any
                        // pal-managed device, realize halftone palette on there.
                        //

                        DrvRealizeHalftonePalette(hdevPalette,TRUE);
                    }
                }
                else
                {
                    //
                    // For single monitor case, make sure ppdevParent points itself.
                    //

                    PPDEV    ppdev = (PPDEV) poP.hdev();
                    XEPALOBJ palObj(poP.ppalSurf());

                    if (ppdev->ppdevParent != ppdev)
                    {
                        WARNING("ChangeDisplaySettings: ppdev->parent != ppdev, fixing it\n");

                        ppdev->ppdevParent = ppdev;
                    }

                    //
                    // Correct palette pointer to driver entry.
                    //

                    poP.pfnSetPalette(PPFNDRV(poP, SetPalette));

                    //
                    // Unshared palette table entry.
                    //

                    palObj.apalResetColorTable();
                }
            }

            if (hsemOrgMdevDevLock)
            {
                ASSERTGDI(hsemOrgMdevPointer,
                          "DrvChangeDisplaySettings():Pointer Lock is NULL\n");

                if (bSwitchError == FALSE)
                {
                    PDEVOBJ pdoParent(pmdev->hdevParent);

                    //
                    // If mode change has been successfully done, make sure the primary
                    // devlock has not been changed through the mode change.
                    //

                    ASSERTGDI(hsemOrgMdevDevLock == pdoParent.hsemDevLock(),
                             "DrvChangeDisplaySettings():DevLock has been changed !\n");
                }

                //
                // Unlock the pointer
                //

                GreReleaseSemaphoreEx(hsemOrgMdevPointer);

                //
                // Unlock the parent of MDEV.
                //

                GreReleaseSemaphoreEx(hsemOrgMdevDevLock);
            }

            //
            // Resume DirectDraw, this can not do while devlock is hold
            //

            if (phdevDDLock)
            {
                DrvEnableDirectDrawForModeChange(
                        phdevDDLock,
                        phdevDDLock != ahdevDDLockQuick);
            }

            //
            // If we succeed, return the new data strucutre.
            //

            if (bSwitchError == FALSE)
            {
                PDEVOBJ pdo;

                //
                // Dump the old MDEV structure.
                //

                if (pOrgMdev != NULL)
                {
                    TRACE_INIT(("OLD pmdev = %08lx\n", pOrgMdev));

                    TRACE_INIT(("\tOLD hdevParent = %08lx\n", pOrgMdev->hdevParent));
                    TRACE_INIT(("\tOLD chdev      = %d\n",    pOrgMdev->chdev));

                    for (i = 0; i < pOrgMdev->chdev; i++)
                    {
                        pdo.vInit(pOrgMdev->Dev[i].hdev);

                        TRACE_INIT(("\tOLD [%d].hdev = %08lx\n", i, pOrgMdev->Dev[i].hdev));

                        ASSERTGDI(pdo.ppdev->pGraphicsDevice != (PGRAPHICS_DEVICE) DDML_DRIVER,
                                  "OLD MDEV has DDML_DRIVER as child hdev");

                        //
                        // Unmark old MDEV as part of the desktop.
                        // 

                        pdo.ppdev->pGraphicsDevice->stateFlags &= ~DISPLAY_DEVICE_ATTACHED_TO_DESKTOP;
                    }
                }

                //
                // Clear the primary flag
                //

                for (PGRAPHICS_DEVICE PhysDispTemp = gpGraphicsDeviceList;
                     PhysDispTemp != NULL;
                     PhysDispTemp = PhysDispTemp->pNextGraphicsDevice)
                {
                    PhysDispTemp->stateFlags &= ~DISPLAY_DEVICE_PRIMARY_DEVICE;
                }

                //
                // Dump the new MDEV structure.
                //

                TRACE_INIT(("NEW pmdev = %08lx\n", pmdev));

                TRACE_INIT(("\tNEW hdevParent = %08lx\n", pmdev->hdevParent));
                TRACE_INIT(("\tNEW chdev      = %d\n",    pmdev->chdev));

                for (i = 0; i < pmdev->chdev; i++)
                {
                    pdo.vInit(pmdev->Dev[i].hdev);
                    PDEVMODEW pdm = pdo.ppdev->ppdevDevmode;

                    TRACE_INIT(("\tNEW [%d].hdev = %08lx\n", i, pmdev->Dev[i].hdev));
                    TRACE_INIT(("\tNEW [%d].rect = %d, %d, %d, %d,\n", i,
                                pmdev->Dev[i].rect.left,  pmdev->Dev[i].rect.top,
                                pmdev->Dev[i].rect.right, pmdev->Dev[i].rect.bottom));

                    ASSERTGDI(pdo.ppdev->pGraphicsDevice != (PGRAPHICS_DEVICE) DDML_DRIVER,
                              "NEW MDEV has DDML_DRIVER as child hdev");

                    //
                    // Mark new MDEV as part of the desktop.
                    //

                    pdo.ppdev->pGraphicsDevice->stateFlags |= DISPLAY_DEVICE_ATTACHED_TO_DESKTOP;

                    //
                    // Adjust the position and mark the primary device
                    //

                    pdm->dmPosition.x = pmdev->Dev[i].rect.left;
                    pdm->dmPosition.y = pmdev->Dev[i].rect.top;

                    if ((pdm->dmPosition.x == 0) &&
                        (pdm->dmPosition.y == 0))
                    {
                        pdo.ppdev->pGraphicsDevice->stateFlags |= DISPLAY_DEVICE_PRIMARY_DEVICE;
                    }
                }

                //
                // Update the DeviceCaps for the new HDEV
                //

                GreUpdateSharedDevCaps(pmdev->hdevParent);
            }
            else
            {
                //
                // We had a problem with the mode switch.
                // Revert to the old configuration.
                //
                // We must make sure pOrgMdev is still what is
                // currently active.
                //
                // ISSUE: Is this multmon safe ?? shared devlock ??
                // ISSUE: Is this clone-pdev safe ?? (of course, no).

                DrvBackoutMDEV(pmdev);
                VFREEMEM(pmdev);
                *pNewMdev = NULL;

                if (pOrgMdev != NULL)
                {
                    DrvEnableMDEV(pOrgMdev, FALSE);
                }

                gcFailedModeChanges++;

                status = GRE_DISP_CHANGE_RESTART;
            }
        }
        else if (status == GRE_DISP_CHANGE_NO_CHANGE)
        {
            //
            // If nothing has been changed, just copy Parent HDEV from original.
            //

            pmdev->hdevParent = pOrgMdev->hdevParent;
            pmdev->Reserved   = pOrgMdev->Reserved;

            //
            // If parent HDEV is DDML, Increment OpenRef count. otheriwse parent
            // hdev is same as its child, so OpenRef is already incremented in
            // hCreateHDEV().
            //

            if (pmdev->chdev > 1)
            {
                GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);

                PDEVOBJ pdo(pmdev->hdevParent);

                pdo.ppdev->cPdevOpenRefs++;
                pdo.ppdev->cPdevRefs++;

                GreReleaseSemaphoreEx(ghsemDriverMgmt);
            }

            ASSERTGDI(pmdev->chdev == pOrgMdev->chdev,
                      "DrvChangeDisplaySettings():Status is no change, but chdev is different\n");
            ASSERTGDI(pmdev->pDesktopId == pOrgMdev->pDesktopId,
                      "DrvChangeDisplaySettings():Status is no change, but pDesktopId is different\n");
        }

        //
        // Reenable the HDEVs (whether we fail or succeed) so
        // DirectDraw and other functionality is reestablished.
        //
        // If the call succeeded, the destroy the old HDEVs
        //

        if (pOrgMdev)
        {
            if ( (status == GRE_DISP_CHANGE_SUCCESSFUL) ||
                 (status == GRE_DISP_CHANGE_NO_CHANGE) )
            {
                //
                // Enable new MDEV.
                //

                DrvEnableMDEV(pmdev, FALSE);

                //
                // ISSUE: Reset the state of the DISPLAY_DEVICE_ flags when we
                // destroy the pdev on the device.
                //

                if (status == GRE_DISP_CHANGE_SUCCESSFUL)
                {
                    //
                    //  When we are success to do mode change,
                    // In multi monitor system, it is possible
                    // to happen pOrgMdev still contains "enabled"
                    // device. Because ,for example, system has 2
                    // monitors attached, but only 1 monitor enabled,
                    // other one is disabled. so User decided to enable
                    // one and disable 'currently enabled' monitor.
                    //  In this case, we do '1 -> 1' mode change, since
                    // there is only 1 monitor before and after mode change.
                    // and CreateHDEV() only disable display when it is
                    // same pGraphicsDevice. thus this case, old display
                    // will be disabled.
                    //  So here, we scan hdev in Old MDEV, and if there is
                    // 'enabled' device which is not used in New MDEV, we
                    // disable it.
                    //

                    for (i = 0; i < pOrgMdev->chdev; i++)
                    {
                        PDEV *pdevOld = (PDEV *) pOrgMdev->Dev[i].hdev;

                        //
                        // Dualview has already been cleared and disabled
                        //
                        if ((pdevOld->pGraphicsDevice->stateFlags & DISPLAY_DEVICE_DUALVIEW) &&
                            gbInvalidateDualView)
                        {
                            continue;
                        }

                        for (j = 0; j < pmdev->chdev; j++)
                        {
                            PDEV *pdevNew = (PDEV *) pmdev->Dev[j].hdev;

                            //
                            // Don't disable this old pdev \ device if  we
                            // are still using it
                            //

                            if ((pdevOld->pGraphicsDevice ==
                                 pdevNew->pGraphicsDevice)
                                ||
                                (pdevOld->pGraphicsDevice->pVgaDevice &&
                                 pdevNew->pGraphicsDevice->pVgaDevice))
                            {
                                break;
                            }
                        }

                        if (j == pmdev->chdev)
                        {
                            DrvDisableDisplay(pOrgMdev->Dev[i].hdev, TRUE);
                        }
                    }
                }

                //
                // Get rid of old MDEV.
                //

                DrvDestroyMDEV(pOrgMdev);
            }
        }

        GreReleaseSemaphoreEx(ghsemShareDevLock);

        TRACE_INIT(("Drv_Trace: DrvChangeDisplaySettings - Mode Switch status %d\n", status));
    }

    if (pdevmodeInformation)
    {
        VFREEMEM(pdevmodeInformation);
    }

    TRACE_INIT(("Drv_Trace: DrvChangeDisplaySettings - Leave - status = %d\n", status));

    gbInvalidateDualView = FALSE;

    return status;
}

/***************************************************************************\
* DrvSetVideoParameters
*
* Routine used to pass video parameters structure down to video miniports.
*
*             ericks        Created
\***************************************************************************/

LONG
DrvSetVideoParameters(
    PUNICODE_STRING pstrDeviceName,
    HDEV            hdevPrimary,
    MODE            PreviousMode,
    PVOID           lParam
    )
{
    NTSTATUS status = GRE_DISP_CHANGE_BADPARAM;
    PGRAPHICS_DEVICE PhysDisp = NULL;

    if (pstrDeviceName)
    {
        PhysDisp = DrvGetDeviceFromName(pstrDeviceName, PreviousMode);

        if (PhysDisp == NULL)
        {
            TRACE_INIT(("Drv_Trace: DrvSetVideoParameters - Leave - Bad Device\n"));
            return GRE_DISP_CHANGE_BADPARAM;
        }
    }
    else
    {
        PDEVOBJ pdo(hdevPrimary);

        if (pdo.bValid())
        {
            PhysDisp = pdo.ppdev->pGraphicsDevice;
        }

        if (PhysDisp == NULL)
        {
            TRACE_INIT(("Drv_Trace: DrvSetVideoParameters - Leave - Bad Device\n"));
            return GRE_DISP_CHANGE_BADPARAM;
        }
    }

    if (PhysDisp == (PGRAPHICS_DEVICE) DDML_DRIVER)
    {
        ASSERTGDI(FALSE, "Trying to change TV settings for DDML layer\n");
        return GRE_DISP_CHANGE_BADPARAM;
    }

    if (PhysDisp != NULL) {

        ULONG bytesReturned;
        PVIDEOPARAMETERS CapturedData;

        CapturedData = (PVIDEOPARAMETERS) PALLOCNOZ(2 * sizeof(VIDEOPARAMETERS),
                                              GDITAG_DRVSUP);

        if (CapturedData == NULL) {
            return GRE_DISP_CHANGE_FAILED;
        }

        //
        // Make sure lParam is valid!
        //

        __try {
            ProbeForRead(lParam, sizeof(VIDEOPARAMETERS), sizeof(UCHAR));
            memcpy(CapturedData, lParam, sizeof(VIDEOPARAMETERS));
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            VFREEMEM(CapturedData);
            return GRE_DISP_CHANGE_BADPARAM;
        }

        status = GreDeviceIoControl(PhysDisp->pDeviceHandle,
                                    IOCTL_VIDEO_HANDLE_VIDEOPARAMETERS,
                                    CapturedData,
                                    sizeof(VIDEOPARAMETERS),
                                    CapturedData,
                                    sizeof(VIDEOPARAMETERS),
                                    &bytesReturned);


        if (status != NO_ERROR) {
            status = GRE_DISP_CHANGE_BADPARAM;
        } else {
            ASSERTGDI(bytesReturned == sizeof(VIDEOPARAMETERS),
                "DrvSetVideoParameters: Not enough data returned\n");
        }

        __try {
            memcpy(lParam, CapturedData, sizeof(VIDEOPARAMETERS));
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            status = GRE_DISP_CHANGE_BADPARAM;
        }

        VFREEMEM(CapturedData);
    }

    return status;
}

/***************************************************************************\
* NtGdiGetMonitorID
*
*  Return Monitor ID for the given HDC.
*
* 14-Dec-1998 hideyukn  Created
\***************************************************************************/

BOOL NtGdiGetMonitorID
(
    HDC    hdc,
    DWORD  dwSize,
    LPWSTR pszMonitorID
)
{
    BOOL   bRet = FALSE;
    NTSTATUS Status;

    DISPLAY_DEVICEW DisplayDevice;

    //
    // We don't want the session to switch from  local to remote or remote to local
    // while we are enumerating display device. Device lock won't prevent this from
    // hapening so we need to grab the User session switch lock.
    //

    Status = UserSessionSwitchEnterCrit();
    if (Status != STATUS_SUCCESS) {
        return FALSE;
    }

    XDCOBJ dco(hdc);


    if (dco.bValid())
    {
        PDEVOBJ    pdo(dco.hdev());
        DEVLOCKOBJ dlo(pdo);

        if (dlo.bValid())
        {
            PGRAPHICS_DEVICE pGraphicsDevice = NULL;

            if (pdo.bMetaDriver())
            {
                //
                // If this is meta driver, use primary.
                //
                PVDEV pvdev = (PVDEV) pdo.dhpdev();

                pGraphicsDevice = ((PPDEV)(pvdev->hdevPrimary))->pGraphicsDevice;
            }
            else
            {
                pGraphicsDevice = ((PPDEV)pdo.hdev())->pGraphicsDevice;
            }

            if (pGraphicsDevice)
            {
                UNICODE_STRING  DeviceName;
                NTSTATUS        NtStatus;

                RtlInitUnicodeString(&DeviceName, pGraphicsDevice->szWinDeviceName);

                DisplayDevice.cb = sizeof(DisplayDevice);

                //
                // Get monitor data attached to this display device.
                //
                NtStatus = DrvEnumDisplayDevices(&DeviceName,NULL,0,&DisplayDevice,NULL,KernelMode);

                if (NT_SUCCESS(NtStatus))
                {
                    bRet = TRUE;
                }
            }
        }

        dco.vUnlockFast();
    }

    if (bRet)
    {
        DWORD dwLenToBeCopied = (wcslen(DisplayDevice.DeviceID) + 1) * sizeof(WCHAR);

        if (dwLenToBeCopied <= dwSize)
        {
            __try
            {
                ProbeForWrite(pszMonitorID, dwSize, sizeof(BYTE));
                RtlCopyMemory(pszMonitorID,DisplayDevice.DeviceID,dwLenToBeCopied);
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(64);
                bRet = FALSE;
            }
        }
        else
        {
            bRet = FALSE;
        }
    }
    //
    // Release the session switch lock.
    //

    UserSessionSwitchLeaveCrit();
    return (bRet);
}

#ifdef _HYDRA_

//
//!!! Currently, the graphics device list (see drvsup.cxx) is allocated
//!!! per-Hydra session.  AndreVa has proposed that they be allocated
//!!! globally.  He's probably right, but until this changes we need to
//!!! clean them up during Hydra shutdown.
//!!!
//!!! To enable cleanup of the per-Hydra graphics device lists, define
//!!! _PER_SESSION_GDEVLIST_ in muclean.hxx.
//

#ifdef _PER_SESSION_GDEVLIST_

/******************************Public*Routine******************************\
* MultiUserDrvCleanupGraphicsDeviceList
*
* For MultiUserNtGreCleanup (Hydra) cleanup.
*
* Cleanup the graphics device list.
*
* History:
*  21-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID
DrvCleanupOneGraphicsDevice(PGRAPHICS_DEVICE PhysDispVictim)
{
    //
    // Delete the graphics device data buffers if they exist.
    //
    if (PhysDispVictim->devmodeInfo)
        VFREEMEM(PhysDispVictim->devmodeInfo);

    if (PhysDispVictim->devmodeMarks)
        VFREEMEM(PhysDispVictim->devmodeMarks);


    if (PhysDispVictim->DeviceDescription)
        VFREEMEM(PhysDispVictim->DeviceDescription);

    if (PhysDispVictim->DisplayDriverNames)
	VFREEMEM(PhysDispVictim->DisplayDriverNames);

    if (PhysDispVictim->MonitorDevices)
        VFREEMEM(PhysDispVictim->MonitorDevices);

    if (PhysDispVictim->pFileObject)
        ObDereferenceObject(PhysDispVictim->pFileObject);

    VFREEMEM(PhysDispVictim);
}

VOID
DrvCleanupGraphicsDeviceList(PGRAPHICS_DEVICE pGraphicsDeviceList)
{
    PGRAPHICS_DEVICE  PhysDispVictim;
    PGRAPHICS_DEVICE  PhysDispNext;

    //
    // Run the list and delete resources.
    //

    for (PhysDispVictim = pGraphicsDeviceList;
         PhysDispVictim != NULL;
         PhysDispVictim = PhysDispNext)
    {
        PhysDispNext = PhysDispVictim->pNextGraphicsDevice;

        //
        // Does this graphics device have a VGA device chained off of it
        // (and is it not self referential)?
        //

        if ((PhysDispVictim->pVgaDevice) &&
            (PhysDispVictim->pVgaDevice != PhysDispVictim) &&
            (PhysDispVictim->pVgaDevice != &gFullscreenGraphicsDevice) &&
            (PhysDispVictim->pVgaDevice != gPhysDispVGA))
        {
            DrvCleanupOneGraphicsDevice(PhysDispVictim->pVgaDevice);
        }

        if ((PhysDispVictim != &gFullscreenGraphicsDevice) &&
            (PhysDispVictim != gPhysDispVGA))
        {
            DrvCleanupOneGraphicsDevice(PhysDispVictim);
        }
    }
}

VOID
MultiUserDrvCleanupGraphicsDeviceList()
{

    // Cleanup local graphics device list

    DrvCleanupGraphicsDeviceList(gpLocalGraphicsDeviceList);
    gpLocalGraphicsDeviceList = NULL;


    // Cleanup remote  graphics device list

    DrvCleanupGraphicsDeviceList(gpRemoteGraphicsDeviceList);
    gpRemoteGraphicsDeviceList = NULL;


    gpGraphicsDeviceList = NULL;

    //
    // If WinStation, cleanup driver name allocated in
    // GreMultiUserInitSession (misc.cxx).
    //

    if (!G_fConsole)
    {
        //
        // If we never made it to GreMultiUserInitSession then don't
        // call FreePool on a static variable (look in misc.cxx)
        //

        if (G_DisplayDriverNames && G_RemoteVideoFileObject != NULL)
        {
            GdiFreePool(G_DisplayDriverNames);
        }
    }

    if (gPhysDispVGA)
    {
        DrvCleanupOneGraphicsDevice(gPhysDispVGA);
        gPhysDispVGA = NULL;
    }

    if (gFullscreenGraphicsDevice.devmodeInfo)
    {
        VFREEMEM(gFullscreenGraphicsDevice.devmodeInfo);
        gFullscreenGraphicsDevice.devmodeInfo = NULL;
    }

    if (gFullscreenGraphicsDevice.devmodeMarks)
    {
        VFREEMEM(gFullscreenGraphicsDevice.devmodeMarks);
        gFullscreenGraphicsDevice.devmodeMarks = NULL;
    }

}


BOOL
DrvIsProtocolAlreadyKnown(VOID)
{
    PGRAPHICS_DEVICE PhysDisp = gpGraphicsDeviceList;
    
    while (PhysDisp != NULL) {
        if (gProtocolType == PhysDisp->ProtocolType) {
            return TRUE;
        }
        PhysDisp = PhysDisp->pNextGraphicsDevice;
    }
    return FALSE;
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\engine.h ===
/******************************Module*Header*******************************\
* Module Name: engine.h
*
* This is the common include file for all GDI
*
* Copyright (c) 1993-1999 Microsoft Corporation
\**************************************************************************/

#include <stddef.h>
#include <string.h>
#include <stdarg.h>
#include <stdio.h>
#include <ntosp.h>
#include <zwapi.h>
#ifndef FAR
#define FAR
#endif
#include "w32p.h"
#include <windef.h>

typedef struct _LDEV LDEV, *PLDEV;

#define SESSION_POOL_MASK 32
extern BOOLEAN gIsTerminalServer;
extern DWORD gSessionPoolMask;

//
// Sundown: in GDI, there are lots of places SIZE_T are used as interchangeable
// as ULONG or UINT or LONG or INT.  On 64bit system, SIZE_T is int64 indeed.
// Since we are not making any GDI objects large objects right now, I just
// change all SIZE_T to ULONGSIZE_T here.
//
// The new type used is to easily identify the change later.
//
// Note: Must be defined before "hmgr.h" is included
//

#define ULONGSIZE_T ULONG


#include <winerror.h>
#include <wingdi.h>
#include <w32gdip.h>

// typedefs copied from winbase.h to avoid using nturtl.h
typedef struct _SECURITY_ATTRIBUTES *LPSECURITY_ATTRIBUTES;
#include <winuser.h>

#define _NO_COM                 // Avoid COM conflicts width ddrawp.h
#include <ddrawp.h>
#include <d3dnthal.h>

#include <dxmini.h>
#include <ddkmapi.h>
#include <ddkernel.h>

#include <winddi.h>
#include "ntgdistr.h"
#include "ntgdi.h"

#include <videoagp.h>
#include <agp.h>

#include "greold.h"
#include "gre.h"
#include "usergdi.h"


#include "debug.h"

#include "hmgshare.h"

#include "hmgr.h"
#include "mapfile.h"


#include "gdisplp.h"

#include "ntgdispl.h"

#if defined(_GDIPLUS_)
    #include "usermode.h"
#endif

#ifdef DDI_WATCHDOG

    #include "watchdog.h"

    //
    // Timeout after 10 seconds.
    //

    #define DDI_TIMEOUT     10000L

    //
    // We need DevLock and Pointer watchdogs per PDEVOBJ
    // (we'll need more for multi-threaded drivers).
    //

    #define WD_DEVLOCK      0
    #define WD_POINTER      1

    //
    // Number of watchdog objects per PDEVOBJ.
    //

    #define WD_NUMBER       2

    typedef struct _WATCHDOG_DATA
    {
        PKDPC pDpc;
        PDEFERRED_WATCHDOG pWatchdog;
    } WATCHDOG_DATA, *PWATCHDOG_DATA;

#endif  // DDI_WATCHDOG

// temporary typedef
typedef LPWSTR PWSZ;

/**************************************************************************\
 *
 * GLOBALS
 *
 * These are the extern definitions for all the globals defined in globals.c
 *
\**************************************************************************/

//
// shared memory
//
extern PGDI_SHARED_MEMORY gpGdiSharedMemory;
extern PDEVCAPS gpGdiDevCaps;

//
// global resources
//
extern HSEMAPHORE ghsemDriverMgmt;
extern HSEMAPHORE ghsemRFONTList;
extern HSEMAPHORE ghsemAtmfdInit;
extern HSEMAPHORE ghsemCLISERV;
extern HSEMAPHORE ghsemPalette;
extern HSEMAPHORE ghsemPublicPFT;
extern HSEMAPHORE ghsemGdiSpool;
extern HSEMAPHORE ghsemWndobj;
extern HSEMAPHORE ghsemGlyphSet;
extern HSEMAPHORE ghsemShareDevLock;
extern HSEMAPHORE ghsemPrintKView;

#define SEMORDER_SHAREDEVLOCK    50
#define SEMORDER_DEVLOCK        100
#define SEMORDER_POINTER        150
#define SEMORDER_DRIVERMGMT     200
#define SEMORDER_PALETTE        300
#define SEMORDER_PUBLICPFT      400
#define SEMORDER_RFONTLIST      500
#define SEMORDER_HMGR           600

//
// Track the owner of semaphores
//

#define OBJ_ENGINE_CREATED	0x0
#define OBJ_DRIVER_CREATED	0x1

//
// drawing
//
extern BYTE   gajRop3[];
extern BYTE   gaMix[];
extern POINTL gptl00;
extern ULONG  gaulConvert[7];
extern HBRUSH ghbrGrayPattern;


//
// font stuff
//
extern UNIVERSAL_FONT_ID gufiLocalType1Rasterizer;
extern USHORT gusLanguageID;             // System default language ID.
extern BOOL   gbDBCSCodePage;            // Is the system code page DBCS?
extern ULONG  gcTrueTypeFonts;
extern ULONG  gulFontInformation;
extern BYTE  gjCurCharset;
extern DWORD gfsCurSignature;
extern BOOL   gbGUISetup;

//
// USER global
//

extern PEPROCESS gpepCSRSS;

#define HOBJ_INVALID    ((HOBJ) 0)

DECLARE_HANDLE(HDSURF);
DECLARE_HANDLE(HDDB);
DECLARE_HANDLE(HDIB);
DECLARE_HANDLE(HDBRUSH);
DECLARE_HANDLE(HPATH);
DECLARE_HANDLE(HXFB);
DECLARE_HANDLE(HPAL);
DECLARE_HANDLE(HXLATE);
DECLARE_HANDLE(HFDEV);
DECLARE_HANDLE(HRFONT);
DECLARE_HANDLE(HPFT);
DECLARE_HANDLE(HPFEC);
DECLARE_HANDLE(HIDB);
DECLARE_HANDLE(HCACHE);
DECLARE_HANDLE(HEFS);
DECLARE_HANDLE(HPDEV);

#define HSURF_INVALID   ((HSURF)   HOBJ_INVALID)
#define HDSURF_INVALID  ((HDSURF)  HOBJ_INVALID)
#define HDDB_INVALID    ((HDDB)    HOBJ_INVALID)
#define HDIB_INVALID    ((HDIB)    HOBJ_INVALID)
#define HDBRUSH_INVALID ((HDBRUSH) HOBJ_INVALID)
#define HPATH_INVALID   ((HPATH)   HOBJ_INVALID)
#define HXFB_INVALID    ((HXFB)    HOBJ_INVALID)
#define HPAL_INVALID    ((HPAL)    HOBJ_INVALID)
#define HXLATE_INVALID  ((HXLATE)  HOBJ_INVALID)
#define HFDEV_INVALID   ((HFDEV)   HOBJ_INVALID)
#define HLFONT_INVALID  ((HLFONT)  HOBJ_INVALID)
#define HRFONT_INVALID  ((HRFONT)  HOBJ_INVALID)
#define HPFEC_INVALID ((HPFEC) HOBJ_INVALID)
#define HPFT_INVALID    ((HPFT)    HOBJ_INVALID)
#define HIDB_INVALID    ((HIDB)    HOBJ_INVALID)
#define HBRUSH_INVALID  ((HBRUSH)  HOBJ_INVALID)
#define HCACHE_INVALID  ((HCACHE)  HOBJ_INVALID)
#define HPEN_INVALID    ((HCACHE)  HOBJ_INVALID)
#define HEFS_INVALID    ((HEFS)    HOBJ_INVALID)

/**************************************************************************\
 *
 * Versionning macros
 *
 * The same number must be reflected in winddi.h
 *
\**************************************************************************/

//
// Get engine constants.
//
//  Engine
//  Version     Changes
//  -------     -------
//  10          Final release, Windows NT 3.1
//  10A         Beta DDK release, Windows NT 3.5
//                - ulVRefresh added to GDIINFO, and multiple desktops
//                  implemented for the Display Applet
//  10B         Final release, Windows NT 3.5
//                - ulDesktop resolutions and ulBltAlignment added to
//                  GDIINFO
//  SUR         First BETA, Windows NT SUR
//  SP3         NT 4.0, SP3
//                - exposes new EngSave/RestoreFloatingPointState, DDML,
//                  and EngFindImageProcAddress(0) support
//  50          Beta One, Windows NT 5.0
//  51          Beta One, Windows NT 5.1
//

#define ENGINE_VERSION10   0x00010000
#define ENGINE_VERSION10A  0x00010001
#define ENGINE_VERSION10B  0x00010002
#define ENGINE_VERSIONSUR  DDI_DRIVER_VERSION_NT4
#define ENGINE_VERSIONSP3  DDI_DRIVER_VERSION_SP3
#define ENGINE_VERSION50   DDI_DRIVER_VERSION_NT5
#define ENGINE_VERSION51   DDI_DRIVER_VERSION_NT5_01
#define ENGINE_VERSION51_SP1   DDI_DRIVER_VERSION_NT5_01_SP1

#define ENGINE_VERSION     ENGINE_VERSION51_SP1


/**************************************************************************\
 *
 * Memory allocation macros
 *
\**************************************************************************/

VOID    FreeObject(PVOID pvFree, ULONG ulType);
PVOID   AllocateObject(ULONG cBytes, ULONG ulType, BOOL bZero);

#define ALLOCOBJ(size,objt,b) AllocateObject((size), objt, b)
#define FREEOBJ(pv,objt)      FreeObject((pv),objt)

//
// GDI pool allocation
//

//
// Use Win32 pool functions.
//

#define GdiAllocPool            Win32AllocPool
#define GdiAllocPoolNonPaged    Win32AllocPoolNonPaged
#define GdiFreePool             Win32FreePool
#define GdiAllocPoolNonPagedNS  Win32AllocPoolNonPagedNS

// MM_POOL_HEADER_SIZE defined in w32\w32inc\usergdi.h
#define GDI_POOL_HEADER_SIZE    MM_POOL_HEADER_SIZE

__inline
PVOID
PALLOCMEM(
    ULONG size,
    ULONG tag)
{
    PVOID _pv = (PVOID) NULL;

    if (size)
    {
        _pv = GdiAllocPool(size, (ULONG) tag);
        if (_pv)
        {
            RtlZeroMemory(_pv, size);
        }
    }

    return _pv;
}
       
#define PALLOCNOZ(size,tag) ((size) ? GdiAllocPool((size), (ULONG) (tag)) : NULL)

#define VFREEMEM(pv)          GdiFreePool((PVOID)(pv))


#define PVALLOCTEMPBUFFER(size)     AllocFreeTmpBuffer(size)
#define FREEALLOCTEMPBUFFER(pv)     FreeTmpBuffer(pv)

//
// Macro to check memory allocation overflow.
//
#define BALLOC_OVERFLOW1(c,st)      (c > (MAXIMUM_POOL_ALLOC/sizeof(st)))
#define BALLOC_OVERFLOW2(c,st1,st2) (c > (MAXIMUM_POOL_ALLOC/(sizeof(st1)+sizeof(st2))))

//
//Sundown: this is to ensure we are safe to truncate an int64 into 32bits
//
#if DBG
#define ASSERT4GB(c)   ASSERTGDI((ULONGLONG)(c) < ULONG_MAX, "> 4gb\n")
#else
#define ASSERT4GB(c)
#endif


PVOID
AllocFreeTmpBuffer(
    ULONG size);

VOID
FreeTmpBuffer(
    PVOID pv);

#define GDITAG_LDEV                ('vdlG')    // Gldv
#define GDITAG_GDEVICE             ('vdgG')    // Ggdv
#define GDITAG_DRVSUP              ('srdG')    // Gdrs
#define GDITAG_DEVMODE             ('vedG')    // Gdev
#define GDITAG_TEMP                ('pmtG')    // Gtmp
#define GDITAG_FULLSCREEN          ('lufG')    // Gful
#define GDITAG_WATCHDOG            ('dwdG')    // Gdwd

//
// Error messages
//

#define SAVE_ERROR_CODE(x) EngSetLastError((x))

//
// WINBUG #83023 2-7-2000 bhouse Investigate removal of undef vToUNICODEN
// Old Comment:
//   - remove the undef when the define is removed from mapfile.h
//

#undef vToUNICODEN
#define vToUNICODEN( pwszDst, cwch, pszSrc, cch )                             \
    {                                                                         \
        RtlMultiByteToUnicodeN((LPWSTR)(pwszDst),(ULONG)((cwch)*sizeof(WCHAR)), \
               (PULONG)NULL,(PSZ)(pszSrc),(ULONG)(cch));                      \
        (pwszDst)[(cwch)-1] = 0;                                              \
    }

#define vToASCIIN( pszDst, cch, pwszSrc, cwch)                                \
    {                                                                         \
        RtlUnicodeToMultiByteN((PCH)(pszDst), (ULONG)(cch), (PULONG)NULL,     \
              (LPWSTR)(pwszSrc), (ULONG)((cwch)*sizeof(WCHAR)));                \
        (pszDst)[(cch)-1] = 0;                                                \
    }

#define TEXT_CAPTURE_BUFFER_SIZE 192 // Between 17 and 22 bytes per glyph are
                                     //   required for capturing a string, so
                                     //   this will allow strings of up to about
                                     //   size 8 to require no heap allocation


#define RETURN(x,y)   {WARNING((x)); return(y);}
#define DONTUSE(x) x=x

#define MIN(A,B)    ((A) < (B) ?  (A) : (B))
#define MAX(A,B)    ((A) > (B) ?  (A) : (B))
#define ABS(A)      ((A) <  0  ? -(A) : (A))
#define SIGNUM(A)   ((A > 0) - (A < 0))
#define MAX4(a, b, c, d)    max(max(max(a,b),c),d)
#define MIN4(a, b, c, d)    min(min(min(a,b),c),d)
#define ALIGN4(X) (((X) + 3) & ~3)
#define ALIGN8(X) (((X) + 7) & ~7)

#if defined(_WIN64)
    #define ALIGN_PTR(x) ALIGN8(x)
#else
    #define ALIGN_PTR(x) ALIGN4(x)
#endif


// SIZEOF_STROBJ_BUFFER(cwc)
//
// Calculates the dword-multiple size of the temporary buffer needed by
// the STROBJ vInit and vInitSimple routines, based on the count of
// characters.

#ifdef FE_SB
// for fontlinking we will also allocate room for the partitioning info

    #define SIZEOF_STROBJ_BUFFER(cwc)           \
        ALIGN_PTR((cwc) * (sizeof(GLYPHPOS)+sizeof(LONG)+sizeof(WCHAR)))
#else
    #define SIZEOF_STROBJ_BUFFER(cwc)           \
        ((cwc) * sizeof(GLYPHPOS))
#endif

//
// FIX point numbers must be 27.4
// The following macro checks that a FIX point number is valid
//

#define FIX_SHIFT  4L
#define FIX_FROM_LONG(x)     ((x) << FIX_SHIFT)
#define LONG_FLOOR_OF_FIX(x) ((x) >> FIX_SHIFT)
#define LONG_CEIL_OF_FIX(x)  LONG_FLOOR_OF_FIX(FIX_CEIL((x)))
#define FIX_ONE              FIX_FROM_LONG(1L)
#define FIX_HALF             (FIX_ONE/2)
#define FIX_FLOOR(x)         ((x) & ~(FIX_ONE - 1L))
#define FIX_CEIL(x)          FIX_FLOOR((x) + FIX_ONE - 1L)

typedef struct _VECTORL
{
    LONG    x;
    LONG    y;
} VECTORL, *PVECTORL;           /* vecl, pvecl */

typedef struct _VECTORFX
{
    FIX     x;
    FIX     y;
} VECTORFX, *PVECTORFX;         /* vec, pvec */

#define AVEC_NOT    0x01
#define AVEC_D      0x02
#define AVEC_S      0x04
#define AVEC_P      0x08
#define AVEC_DS     0x10
#define AVEC_DP     0x20
#define AVEC_SP     0x40
#define AVEC_DSP    0x80
#define AVEC_NEED_SOURCE  (AVEC_S | AVEC_DS | AVEC_SP | AVEC_DSP)
#define AVEC_NEED_PATTERN (AVEC_P | AVEC_DP | AVEC_SP | AVEC_DSP)

#define ROP4NEEDSRC(rop4)   \
    ((gajRop3[rop4 & 0x000000FF] | gajRop3[(rop4 >> 8) & 0x000000ff]) & AVEC_NEED_SOURCE)

#define ROP4NEEDPAT(rop4)   \
    ((gajRop3[rop4 & 0x000000FF] | gajRop3[(rop4 >> 8) & 0x000000ff]) & AVEC_NEED_PATTERN)

#define ROP4NEEDMASK(rop4)  \
    (((rop4) & 0xff) != (((rop4) >> 8) & 0xff))

typedef BOOL   (*PFN_DrvConnect)(HANDLE, PVOID, PVOID, PVOID);
typedef BOOL   (*PFN_DrvReconnect)(HANDLE, PVOID);
typedef BOOL   (*PFN_DrvDisconnect)(HANDLE, PVOID);
typedef BOOL   (*PFN_DrvShadowConnect)(PVOID, ULONG);
typedef BOOL   (*PFN_DrvShadowDisconnect)(PVOID, ULONG);
typedef VOID   (*PFN_DrvInvalidateRect)(PRECT);
typedef BOOL   (*PFN_DrvMovePointerEx)(SURFOBJ*,LONG,LONG,ULONG);
typedef BOOL   (*PFN_DrvDisplayIOCtl)(PVOID,ULONG);

BOOL OffStrokePath(PFN_DrvStrokePath,POINTL*,SURFOBJ*,PATHOBJ*,CLIPOBJ*,XFORMOBJ*,BRUSHOBJ*,POINTL*,LINEATTRS*,MIX);
BOOL OffFillPath(PFN_DrvFillPath,POINTL*,SURFOBJ*,PATHOBJ*,CLIPOBJ*,BRUSHOBJ*,POINTL*,MIX,FLONG);
BOOL OffStrokeAndFillPath(PFN_DrvStrokeAndFillPath,POINTL*,SURFOBJ*,PATHOBJ*,CLIPOBJ*,XFORMOBJ*,BRUSHOBJ*,LINEATTRS*,BRUSHOBJ*,POINTL*,MIX,FLONG);
BOOL OffPaint(PFN_DrvPaint,POINTL*,SURFOBJ*,CLIPOBJ*,BRUSHOBJ*,POINTL*,MIX);
BOOL OffBitBlt(PFN_DrvBitBlt,POINTL*,SURFOBJ*,POINTL*,SURFOBJ*,SURFOBJ*,CLIPOBJ*,XLATEOBJ*,RECTL*,POINTL*,POINTL*,BRUSHOBJ*,POINTL*,ROP4);
BOOL OffCopyBits(PFN_DrvCopyBits,POINTL*,SURFOBJ*,POINTL*,SURFOBJ*,CLIPOBJ*,XLATEOBJ*,RECTL*,POINTL*);
BOOL OffStretchBlt(PFN_DrvStretchBlt,POINTL*,SURFOBJ*,POINTL*,SURFOBJ*,SURFOBJ*,CLIPOBJ*,XLATEOBJ*,COLORADJUSTMENT*,POINTL*,RECTL*,RECTL*,POINTL*,ULONG);
BOOL OffStretchBltROP(PFN_DrvStretchBltROP,POINTL*,SURFOBJ*,POINTL*,SURFOBJ*,SURFOBJ*,CLIPOBJ*,XLATEOBJ*,COLORADJUSTMENT*,POINTL*,RECTL*,RECTL*,POINTL*,ULONG,BRUSHOBJ*,DWORD);
BOOL OffTextOut(PFN_DrvTextOut,POINTL*,SURFOBJ*,STROBJ*,FONTOBJ*,CLIPOBJ*,RECTL*,RECTL*,BRUSHOBJ*,BRUSHOBJ*,POINTL*,MIX);
BOOL OffLineTo(PFN_DrvLineTo,POINTL*,SURFOBJ*,CLIPOBJ*,BRUSHOBJ*,LONG,LONG,LONG,LONG,RECTL*,MIX);
BOOL OffTransparentBlt(PFN_DrvTransparentBlt,POINTL*,SURFOBJ*,POINTL*,SURFOBJ*,CLIPOBJ*,XLATEOBJ*,RECTL*,RECTL*,ULONG,ULONG);
BOOL OffAlphaBlend(PFN_DrvAlphaBlend,POINTL*,SURFOBJ*,POINTL*,SURFOBJ*,CLIPOBJ*,XLATEOBJ*,RECTL*,RECTL*,BLENDOBJ*);
BOOL OffPlgBlt(PFN_DrvPlgBlt,POINTL*,SURFOBJ*,POINTL*,SURFOBJ*,SURFOBJ*,CLIPOBJ*,XLATEOBJ*,COLORADJUSTMENT*,POINTL*,POINTFIX*,RECTL*,POINTL*,ULONG);
BOOL OffGradientFill(PFN_DrvGradientFill,POINTL*,SURFOBJ*,CLIPOBJ*,XLATEOBJ*,TRIVERTEX*,ULONG,VOID*,ULONG,RECTL*,POINTL*,ULONG);
BOOL OffDrawStream(PFN_DrvDrawStream,POINTL*,SURFOBJ*,SURFOBJ*,CLIPOBJ*,XLATEOBJ*,RECTL*,POINTL*,ULONG,PVOID,DSSTATE*);

/**************************************************************************\
 *
 * random prototypes internal to gdi
 *
\**************************************************************************/

HFONT hfontCreate(ENUMLOGFONTEXDVW * pelfw, LFTYPE lft, FLONG  fl, PVOID pvCliData);
BOOL  EngMapFontFileInternal(ULONG_PTR, PULONG *, ULONG *, BOOL);
BOOL  EngMapFontFileFDInternal(ULONG_PTR, PULONG *, ULONG *, BOOL);

BOOL  SimBitBlt(SURFOBJ *,SURFOBJ *,SURFOBJ *,
                CLIPOBJ *,XLATEOBJ *,
                RECTL *,POINTL *,POINTL *,
                BRUSHOBJ *,POINTL *,ROP4, PVOID);

BOOL
bDeleteDCInternal(
    HDC hdc,
    BOOL bForce,
    BOOL bProcessCleanup);

ULONG ulGetFontData(HDC, DWORD, DWORD, PVOID, ULONG);

VOID vCleanupSpool();

typedef struct tagREMOTETYPEONENODE REMOTETYPEONENODE;

typedef struct tagREMOTETYPEONENODE
{
    PDOWNLOADFONTHEADER    pDownloadHeader;
    FONTFILEVIEW           fvPFB;
    FONTFILEVIEW           fvPFM;
    REMOTETYPEONENODE      *pNext;
} REMOTETYPEONENODE,*PREMOTETYPEONENODE;

ULONG
cParseFontResources(
    HANDLE hFontFile,
    PVOID  **ppvResourceBases
    );

BOOL
MakeSystemRelativePath(
    LPWSTR pOriginalPath,
    PUNICODE_STRING pUnicode,
    BOOL bAppendDLL
    );

BOOL
MakeSystemDriversRelativePath(
    LPWSTR pOriginalPath,
    PUNICODE_STRING pUnicode,
    BOOL bAppendDLL
    );

BOOL
GreExtTextOutRect(
    HDC     hdc,
    LPRECT  prcl
    );

#define HTBLT_SUCCESS      1
#define HTBLT_NOTSUPPORTED 0
#define HTBLT_ERROR        -1

int EngHTBlt(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    PPOINTL          pptlBrushOrg,
    PRECTL           prclDest,
    PRECTL           prclSrc,
    PPOINTL          pptlMask,
    ULONG            uFlags,
    BLENDOBJ        *pBlendObj);

typedef struct _DRAWSTREAMINFO
{
    DSSTATE     dss;
    BOOL        bCalledFromBitBlt;
    PPOINTL     pptlDstOffset;
    XLATEOBJ *  pxloSrcToBGRA;
    XLATEOBJ *  pxloDstToBGRA;
    XLATEOBJ *  pxloBGRAToDst;
    ULONG       ulStreamLength;
    PVOID       pvStream;
} DRAWSTREAMINFO, *PDRAWSTREAMINFO;

BOOL GreExtTextOutWInternal(
    HDC     hdc,
    int     x,
    int     y,
    UINT    flOpts,
    LPRECT  prcl,
    LPWSTR  pwsz,
    int     cwc,
    LPINT   pdx,
    PVOID   pvBuffer,
    DWORD   dwCodePage
    );

BOOL
bDynamicModeChange(
    HDEV    hdevOld,
    HDEV    hdevNew
    );

HDEV
DrvGetHDEV(
    PUNICODE_STRING pusDeviceName
    );
void
DrvReleaseHDEV(
    PUNICODE_STRING pusDeviceName
    );


BOOL
bUMPD(
    HDC hdc
    );

HSURF
hsurfCreateCompatibleSurface(
    HDEV hdev,
    ULONG iFormat,
    HPALETTE hpal,
    int cx,
    int cy,
    BOOL bDriverCreatible
    );

HBITMAP
hbmSelectBitmap(
    HDC hdc,
    HBITMAP hbm,
    BOOL bDirectDrawOverride
    );

__inline ULONG wcslensafe( const WCHAR *pwcString )
{
    ULONG Length;

    ProbeForRead(pwcString, sizeof(WCHAR), sizeof(WCHAR));

    for (Length = 0; *pwcString; Length++)
    {
        pwcString += 1;
        ProbeForRead(pwcString, sizeof(WCHAR), sizeof(WCHAR));
    }

    return(Length);
}

BOOL
ldevArtificialDecrement(
    LPWSTR pwszDriver
    );

#define IS_USER_ADDRESS(x) (MM_LOWEST_USER_ADDRESS <= (x) && (x) <= MM_HIGHEST_USER_ADDRESS)


//
// ProbeAndWriteXXX macros to speed up performance [lingyunw]
//

/*
#define ProbeAndWriteBuffer(Dst, Src, Length) {                            \
    if (((ULONG_PTR)Dst + Length <= (ULONG_PTR)Dst) ||                     \
       ((ULONG_PTR)Dst >= (ULONG_PTR)MM_USER_PROBE_ADDRESS)) {             \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                \
    }                                                                      \
                                                                           \
    RtlCopyMemory(Dst, Src, Length);                                       \
}

#define ProbeAndWriteAlignedBuffer(Dst, Src, Length, Alignment) {       \
                                                                        \
    ASSERT(((Alignment) == 1) || ((Alignment) == 2) ||                  \
           ((Alignment) == 4) || ((Alignment) == 8) ||                  \
           ((Alignment) == 16));                                        \
                                                                        \
    if (((ULONG_PTR)Dst + Length <= (ULONG_PTR)Dst) ||                  \
        ((ULONG_PTR)Dst >= (ULONG_PTR) MM_USER_PROBE_ADDRESS)  ||       \
        ((((ULONG_PTR)Dst) & (Alignment - 1)) != 0))    {               \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;             \
    }                                                                   \
                                                                        \
    RtlCopyMemory(Dst, Src, Length);                                    \
}
*/

VOID ProbeAndWriteBuffer(PVOID Dst, PVOID Src, ULONG Length);

VOID ProbeAndWriteAlignedBuffer(PVOID Dst, PVOID Src, ULONG Length, ULONG Alignment);

#define ProbeAndReadBuffer(Dst, Src, Length)  {                         \
    if (((ULONG_PTR)Src + Length <= (ULONG_PTR)Src) ||                    \
        ((ULONG_PTR)Src + Length > (ULONG_PTR)MM_USER_PROBE_ADDRESS)) {           \
        *(PULONG) Dst = *(volatile ULONG * const)MM_USER_PROBE_ADDRESS; \
    }                                                                   \
                                                                        \
    RtlCopyMemory(Dst, Src, Length);                                    \
}

#define ProbeAndReadAlignedBuffer(Dst, Src, Length, Alignment)  {       \
                                                                        \
    ASSERT(((Alignment) == 1) || ((Alignment) == 2) ||                  \
           ((Alignment) == 4) || ((Alignment) == 8) ||                  \
           ((Alignment) == 16));                                        \
                                                                        \
    if (((ULONG_PTR)Src + Length <= (ULONG_PTR)Src) ||                    \
        ((ULONG_PTR)Src + Length > (ULONG_PTR)MM_USER_PROBE_ADDRESS) ||           \
        ((((ULONG_PTR)Src) & (Alignment - 1)) != 0))    {                            \
        *(PULONG) Dst = *(volatile ULONG * const)MM_USER_PROBE_ADDRESS; \
    }                                                                   \
                                                                        \
    RtlCopyMemory(Dst, Src, Length);                                    \
}

//
// Cleanup types.
//
// Value                    Description
// ----------------------   ---------------------------------------------
// CLEANUP_NONE             Default.  System is not doing cleanup.
//
// CLEANUP_PROCESS          Indicates system is doing process cleanup.
//
// CLEANUP_SESSION          Indicates system is doing session cleanup
//                          (i.e., Hydra shutdown).
//

typedef enum {
    CLEANUP_NONE,
    CLEANUP_PROCESS,
    CLEANUP_SESSION
} CLEANUPTYPE;

//
// Gre semaphores
//
// The GreXXXSemaphore functions are analogous to the EngXXXSemaphore functions
// in the DDI. However, this set is meant to be used by internal GDI code.
//
// They manipulate semaphores, which are re-entrant synchronization objects.
//

HSEMAPHORE GreCreateSemaphore();
HSEMAPHORE GreCreateSemaphoreInternal(ULONG CreateFlags);
VOID GreDeleteSemaphore(HSEMAPHORE);
VOID FASTCALL GreAcquireSemaphore(HSEMAPHORE);
VOID FASTCALL GreAcquireSemaphoreShared(HSEMAPHORE);
VOID FASTCALL GreReleaseSemaphore(HSEMAPHORE);

#define CHECK_SEMAPHORE_USAGE 0

#if CHECK_SEMAPHORE_USAGE
VOID GreCheckSemaphoreUsage();
#endif

#define VALIDATE_LOCKS 0
#if VALIDATE_LOCKS
VOID FASTCALL GreAcquireSemaphoreEx(HSEMAPHORE, ULONG, HSEMAPHORE);
VOID FASTCALL GreReleaseSemaphoreEx(HSEMAPHORE);
#else
#define GreAcquireSemaphoreEx(hsem, order, parent) GreAcquireSemaphore(hsem)
#define GreReleaseSemaphoreEx(hsem) GreReleaseSemaphore(hsem)
#endif

VOID GreAcquireHmgrSemaphore();
VOID GreReleaseHmgrSemaphore();

// Try not to use these two, okay? They peek into the internals
// of the PERESOURCE/CRITICAL_SECTION
BOOL GreIsSemaphoreOwned(HSEMAPHORE);
BOOL GreIsSemaphoreOwnedByCurrentThread(HSEMAPHORE);
BOOL GreIsSemaphoreSharedByCurrentThread(HSEMAPHORE);

// Non-tracked semaphores, for use by the Hydra cleanup
// semaphore-tracking code.
HSEMAPHORE GreCreateSemaphoreNonTracked();
VOID GreDeleteSemaphoreNonTracked(HSEMAPHORE);

//
// Gre fast mutexes
//
// The GreXXXFastMutex functions handle fast mutexes. These are like
// semaphores, but not re-entrant.
//

DECLARE_HANDLE(HFASTMUTEX);

HFASTMUTEX GreCreateFastMutex();
VOID GreAcquireFastMutex(HFASTMUTEX);
VOID GreReleaseFastMutex(HFASTMUTEX);
VOID GreDeleteFastMutex(HFASTMUTEX);

// Time functions
VOID GreQuerySystemTime(PLARGE_INTEGER);
VOID GreSystemTimeToLocalTime(PLARGE_INTEGER SystemTime, PLARGE_INTEGER LocalTime);

//struct to keep track of kernel views used by printing

typedef struct _FONTFILE_PRINTKVIEW
{
    HFF     hff;
    ULONG   iFile;
    ULONG   cPrint;
    PVOID   pKView;
    ULONG_PTR   iTTUniq;
    struct _FONTFILE_PRINTKVIEW   *pNext;
} FONTFILE_PRINTKVIEW, *PFONTFILE_PRINTKVIEW;

extern FONTFILE_PRINTKVIEW  *gpPrintKViewList;
void UnmapPrintKView(HFF hff);

// WINBUG #365390 4-10-2001 jasonha Need to get these constants from a header
// We need these constants but they are not defined in a header that we
// can include here in gre.
#ifndef CP_ACP
#define CP_ACP               0              /* default to ANSI code page */
#define CP_OEMCP             1              /* default to OEM  code page */
#define CP_MACCP             2              /* default to MAC  code page */
#define CP_SYMBOL            42             /* symbol translation from winnls.h */
#endif

#ifdef DDI_WATCHDOG

PVOID
GreCreateWatchdogContext(
    PWSTR pwszDriverName,
    HANDLE hDriver,
    PLDEV *ppldevDriverList
    );

VOID
GreDeleteWatchdogContext(
    PVOID pContext
    );

PWATCHDOG_DATA
GreCreateWatchdogs(
    PDEVICE_OBJECT pDeviceObject,
    ULONG ulNumberOfWatchdogs,
    LONG lPeriod,
    PKDEFERRED_ROUTINE dpcCallback,
    PVOID pvDeferredContext
    );

VOID
GreDeleteWatchdogs(
    PWATCHDOG_DATA pWatchdogData,
    ULONG ulNumberOfWatchdogs
    );

//
// This lock is used to control access to the watchdog's association list.
//

extern HFASTMUTEX gAssociationListMutex;

//
// Define watchdog macros to monitor time spent in display driver.
// If this time exceeds DDI_TIMEOUT we will blue screen machine with
// bugcheck code 0xEA (THREAD_STUCK_IN_DEVICE_DRIVER).
//

#define GreEnterMonitoredSection(ppdev, n)                                      \
{                                                                               \
    if ((ppdev)->pWatchdogData)                                                 \
    {                                                                           \
        WdEnterMonitoredSection((ppdev)->pWatchdogData[n].pWatchdog);           \
    }                                                                           \
}

#define GreExitMonitoredSection(ppdev, n)                                       \
{                                                                               \
    if ((ppdev)->pWatchdogData)                                                 \
    {                                                                           \
        WdExitMonitoredSection((ppdev)->pWatchdogData[n].pWatchdog);            \
    }                                                                           \
}

#define GreSuspendWatch(ppdev, n)                                               \
{                                                                               \
    if ((ppdev)->pWatchdogData)                                                 \
    {                                                                           \
        WdSuspendDeferredWatch((ppdev)->pWatchdogData[n].pWatchdog);            \
    }                                                                           \
}

#define GreResumeWatch(ppdev, n)                                                \
{                                                                               \
    if ((ppdev)->pWatchdogData)                                                 \
    {                                                                           \
        WdResumeDeferredWatch((ppdev)->pWatchdogData[n].pWatchdog, TRUE);       \
    }                                                                           \
}

#else

#define GreEnterMonitoredSection(ppdev, n)  NULL
#define GreExitMonitoredSection(ppdev, n)   NULL
#define GreSuspendWatch(ppdev, n)           NULL
#define GreResumeWatch(ppdev, n)            NULL

#endif  // DDI_WATCHDOG

//
// Draw stream prototyping work
//

BOOL GreDrawStream(HDC, ULONG, PVOID);

//
// Max surface width/height used in gre to quickly
// check the width/height overflow
//

#define MAX_SURF_WIDTH  ((ULONG_MAX - 15) >> 5)
#define MAX_SURF_HEIGHT  (ULONG_MAX >> 5)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\enumgdi.cxx ===
/******************************Module*Header*******************************\
* Module Name: enumgdi.cxx
*
* Enumeration routines.
*              hefs
* Created: 28-Mar-1992 16:18:45
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1992-199 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

// gaclrEnumColorTable
//
// Colors used for GreEnumPens and GreEnumBrushes.  This color table is
// set up so that:
//
//   - the first 2 entries are for monochrome devices
//
//   - the first 8 entries are for 8-color devices
//
//   - the first 16 are for 4 BPP color devices
//
//   - the first 20 are for 8 BPP and up color devices

static COLORREF
gaclrEnumColorTable[] = { 0x00000000,   // black
                          0x00ffffff,   // white        (monochrome)

                          0x000000ff,   // red
                          0x0000ff00,   // green
                          0x0000ffff,   // yellow
                          0x00ff0000,   // blue
                          0x00ff00ff,   // magenta
                          0x00ffff00,   // cyan         (EGA hi-intensity)

                          0x00808080,   // dark grey
                          0x00c0c0c0,   // light grey
                          0x00000080,   // red
                          0x00008000,   // green
                          0x00008080,   // yellow
                          0x00800000,   // blue
                          0x00800080,   // magenta
                          0x00808000,   // cyan         (EGA lo-intensity)

                          0x00c0dcc0,   // money green
                          0x00f0c8a4,   // cool blue
                          0x00f0fbff,   // off white
                          0x00a4a0a0    // med grey     (extra colors)
                        };

static ULONG gulEnumColorTableSize = sizeof(gaclrEnumColorTable) / sizeof(COLORREF);

#define ECT_1BPP    2       // use this many colors for 1 BPP
#define ECT_EGA     8       // use this many colors for EGA
#define ECT_4BPP    16      // use this many colors for 4 BPP
#define ECT_8BPP    min(gulEnumColorTableSize, 256) // use this many colors for 8 BPP


#define ENUM_FILTER_NONE            0
#define ENUM_FILTER_TT              1
#define ENUM_FILTER_NONTT           2

// gaulEnumPenStyles
//
// Pen styles used for GreEnumPens.

static ULONG
gaulPenStyles[] = { PS_SOLID,
                    PS_DASH,
                    PS_DOT,
                    PS_DASHDOT,
                    PS_DASHDOTDOT
                  };

static ULONG gulPenStylesTableSize = sizeof(gaulPenStyles) / sizeof(ULONG);


// gaulEnumBrushStyles
//
// Brush hatch styles used for GreEnumBrushes.

ULONG
gaulHatchStyles[] = { HS_HORIZONTAL,
                      HS_VERTICAL,
                      HS_FDIAGONAL,
                      HS_BDIAGONAL,
                      HS_CROSS,
                      HS_DIAGCROSS
                    };

static ULONG gulHatchStylesTableSize = sizeof(gaulHatchStyles) / sizeof(ULONG);


/******************************Public*Routine******************************\
* NtGdiEnumObjects()
*
*
* Returns:
*   Number of objects copied into the return buffer.  If buffer is NULL,
*   then the object capacity needed for the buffer is returned.  If an
*   error occurs, then ERROR is returned.
*
\**************************************************************************/

ULONG
APIENTRY
NtGdiEnumObjects(
    HDC   hdc,
    int   iObjectType,
    ULONG cjBuf,
    PVOID pvBuf
    )
{
    ULONG cRet = ERROR;

    if ( (cjBuf == 0) == (pvBuf == (PVOID) NULL) )
    {
        // Create and validate DC user object.

        DCOBJ dco(hdc);

        if (dco.bValid())
        {
            PDEVOBJ pdo(dco.hdev());

            // For color devices, we grab the colors out of the
            // gaclrEnumColorTable color table.  For better results, a
            // driver should implement DrvEnumObj.

            ULONG cclrDevice = pdo.GdiInfoNotDynamic()->ulNumColors;
            ULONG cObjects;

            //
            // Determine the number of colors to grab out of the table.
            //

            if ( cclrDevice >= ECT_8BPP )
                cclrDevice = ECT_8BPP;
            else if ( cclrDevice >= ECT_4BPP )
                cclrDevice = ECT_4BPP;
            else if ( cclrDevice >= ECT_EGA )
                cclrDevice = ECT_EGA;
            else if ( cclrDevice >= ECT_1BPP )
                cclrDevice = ECT_1BPP;


            switch (iObjectType)
            {
            case OBJ_PEN:
                cObjects = cjBuf / sizeof(LOGPEN);
                cRet = cclrDevice * gulPenStylesTableSize;

                break;

            case OBJ_BRUSH:
                cObjects = cjBuf / sizeof(LOGBRUSH);
                cRet = cclrDevice * (gulHatchStylesTableSize + 1); // the "1" is the solid brush

                break;

            default:
                WARNING("NtGdiEnumObjects(): bad object type\n");
                return cRet;
            }

            //
            // If the buffer is big enough, return the data
            //

            if (cObjects >= cRet)
            {
                __try
                {
                    ProbeForWrite(pvBuf, cjBuf, sizeof(DWORD));

                    COLORREF *pclr;
                    COLORREF *pclrEnd = gaclrEnumColorTable + cclrDevice;

                    PULONG pulPenStyle;
                    PULONG pulPenStyleEnd = gaulPenStyles + gulPenStylesTableSize;

                    PULONG pulHatchStyle;
                    PULONG pulHatchStyleEnd = gaulHatchStyles + gulHatchStylesTableSize;

                    PLOGPEN plpBuf = ((PLOGPEN)pvBuf);
                    PLOGBRUSH plbBuf = ((PLOGBRUSH)pvBuf);

                    switch (iObjectType)
                    {
                    case OBJ_PEN:

                        //
                        // Fill buffer will LOGPENs of all styles, in all colors.
                        //

                        for (pulPenStyle = gaulPenStyles; pulPenStyle < pulPenStyleEnd; pulPenStyle += 1)
                        {
                            for (pclr = gaclrEnumColorTable;
                                 pclr < pclrEnd;
                                 pclr += 1)
                            {
                                // Fill in the LOGPEN fields.

                                plpBuf->lopnWidth.x = 0;    // nominal width
                                plpBuf->lopnWidth.y = 0;    // ignored
                                plpBuf->lopnStyle   = (UINT) *pulPenStyle;
                                plpBuf->lopnColor   = *pclr;

                                // Next LOGPEN.

                                plpBuf += 1;
                            }
                        }

                        break;

                    case OBJ_BRUSH:

                        //
                        // Fill buffer will LOGBRUSHs of BS_SOLID style, in all colors.
                        //

                        for (pclr = gaclrEnumColorTable; pclr < pclrEnd; pclr += 1)
                        {
                            // Fill in the LOGBRUSH fields.

                            plbBuf->lbStyle   = BS_SOLID;
                            plbBuf->lbColor   = *pclr;
                            plbBuf->lbHatch   = 0;

                            // Next LOGBRUSH.

                            plbBuf += 1;
                        }

                        //
                        // Now fill the buffer with LOGBRUSHs of BS_HATCH, in all
                        // hatch styles and colors.
                        //

                        for (pulHatchStyle = gaulHatchStyles; pulHatchStyle < pulHatchStyleEnd; pulHatchStyle += 1)
                        {
                            for (pclr = gaclrEnumColorTable;
                                 pclr < pclrEnd;
                                 pclr += 1)
                            {
                                // Fill in the LOGBRUSH fields.

                                plbBuf->lbStyle   = BS_HATCHED;
                                plbBuf->lbColor   = *pclr;
                                plbBuf->lbHatch   = *pulHatchStyle;

                                // Next LOGBRUSH.

                                plbBuf += 1;
                            }
                        }

                        break;

                    default:
                        WARNING("NtGdiEnumObjects(): bad object type 2\n");
                    }
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    // SetLastError(GetExceptionCode());
                    cRet = ERROR;
                }
            }
            else if (cObjects)
            {
                //
                // If the buffer is not large enough (and it is not zero)
                // then return an error,
                //

                cRet = ERROR;
            }
        }
    }

    return cRet;
}

BOOL  bScanFamily(
    FHOBJ  *pfho1,  ULONG ulFilter1,
    FHOBJ  *pfho2,  ULONG ulFilter2,
    FHOBJ  *pfho3,  ULONG ulFilter3,
    EFSOBJ *pefsmo,
    ULONG  iEnumType,
    EFFILTER_INFO *peffi,
    PWSZ    pwszName
);

BOOL bScanFamilyAndFace(
    FHOBJ        *pfhoEngFamily,
    FHOBJ        *pfhoEngFace,
    FHOBJ        *pfhoDevFamily,
    FHOBJ        *pfhoDevFace,
    EFSOBJ       *pefsmo,
    ULONG        iEnumType,
    EFFILTER_INFO   *peffi,
    PWSZ         pwszName
);


#define EFS_DEFAULT     32

/******************************Public*Routine******************************\
* HEFS hefsEngineOnly
*
* Enumerates engine fonts only.
*
* PFEs are accumulated in an EFSTATE (EnumFont State) object.  If a non-NULL
* pwszName is specified, then only fonts that match the given name are added
* to the EFS.  If a NULL pwszFace is specified, then one font of each name is
* added to the EFS.
*
* If any of the filtering flags in the EFFILTER_INFO structure are specified,
* then PFEs are tested in additional filtering stages before they are added
* to the EFS.
*
* The EFS is allocated by this function.  It is the responsibility of the
* caller to ensure that the EFS is eventually freed.
*
* Returns:
*   Handle to allocated EFS object, HEFS_INVALID if an error occurs.
*
* History:
*
*  19-Aug-1996 -by- Xudong Wu  [TessieW]
* Add enumeration for Private PFT.
*
*  07-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

HEFS hefsEngineOnly (
    PWSZ  pwszName,              // enumerate this font family
    ULONG lfCharSet,
    ULONG iEnumType,            // TRUE if processing EnumFonts()
    EFFILTER_INFO *peffi,       // filtering information
    PUBLIC_PFTOBJ &pfto,        // public PFT user object
    PUBLIC_PFTOBJ &pftop,       // private PFT user object
    ULONG *pulCount
    )
{
// ulEnumFontOpen, the caller, has already grabbed the ghsemPublicPFT,
// so the font hash tables are stable.

// Create and validate FHOBJ for engine (family list).

    FHOBJ fhoEngineFamily(&pfto.pPFT->pfhFamily);

    if ( !fhoEngineFamily.bValid() )
    {
        WARNING("gdisrv!hefsEnumFontsState(): cannot lock engine font hash (family)\n");
        return HEFS_INVALID;
    }

// Create and validate FHOBJ for engine (face list).

    FHOBJ fhoEngineFace(&pfto.pPFT->pfhFace);

    if ( !fhoEngineFace.bValid() )
    {
        WARNING("gdisrv!hefsEnumFontsState(): cannot lock engine font hash (face)\n");
        return HEFS_INVALID;
    }

// For NULL pwszName, an example of each family needs to be enumerated.  In
// other words, we scan ACROSS the names.

    if (pwszName == (PWSZ) NULL)
    {
    // Allocate a new EFSTATE for the enumeration.  Use total number
    // of lists as a hint for the initial size.  This is reasonable
    // since we will probably enumerate back all of the list heads.

        EFSMEMOBJ efsmo(fhoEngineFamily.cLists(), iEnumType);

        if ( !efsmo.bValid() )
        {
            WARNING("win32k!GreEnumFontOpen(): could not allocate enumeration state\n");
            return HEFS_INVALID;
        }

    // Enumerate engine fonts in public PFT.
    // For Win3.1 compatability Non-TT,TT.

        if ( !bScanFamily(&fhoEngineFamily, ENUM_FILTER_NONTT, &fhoEngineFamily, ENUM_FILTER_TT,
                            (FHOBJ*)NULL, 0, &efsmo, iEnumType, peffi, NULL) )
        {
            return HEFS_INVALID;
        }

    // Scan through private PFT if gpPFTPrivate!=NULL

        if (pftop.pPFT != NULL)
        {
            FHOBJ fhoPrivateFamily(&pftop.pPFT->pfhFamily);

            if ( !fhoPrivateFamily.bValid() )
            {
                WARNING("win32k!hefsEngineOnly(): cannot lock private font hash (family)\n");
                return HEFS_INVALID;
            }

            if ( !bScanFamily(&fhoPrivateFamily, ENUM_FILTER_NONTT, &fhoPrivateFamily, ENUM_FILTER_TT,
                                (FHOBJ*)NULL, 0, &efsmo, iEnumType, peffi, NULL) )
            {
                return HEFS_INVALID;
            }
        }

        *pulCount = efsmo.cjEfdwTotal();

    // Keep the EFSTATE around.

        efsmo.vKeepIt();

    // Return the EFSOBJ handle.

        return efsmo.hefs();
    }

// For non-NULL pwszName, all the fonts of a particular family are enumerated.
// In other words, we scan DOWN a name.

    else
    {
    // Allocate a new EFSTATE.  Use a default size.

        EFSMEMOBJ efsmo(EFS_DEFAULT, iEnumType);

        if ( !efsmo.bValid() )
        {
            WARNING("gdisrv!hefsEnumFontsState(): could not allocate enumeration state\n");
            return HEFS_INVALID;
        }

        if (!bScanFamilyAndFace(&fhoEngineFamily, &fhoEngineFace, (FHOBJ*)NULL, (FHOBJ*)NULL,
                                    &efsmo, iEnumType, peffi,  pwszName))
        {
            return HEFS_INVALID;
        }


    // Scan through the Privat PFT with family name lists.

        if (pftop.pPFT != NULL)
        {
            FHOBJ fhoPrivateFamily(&pftop.pPFT->pfhFamily);
            FHOBJ fhoPrivateFace(&pftop.pPFT->pfhFace);

            if (!fhoPrivateFamily.bValid() || !fhoPrivateFace.bValid())
            {
                WARNING("win32k!hefsEngineOnly(): cannot lock private font hash\n");
                return HEFS_INVALID;
            }

            if (!bScanFamilyAndFace(&fhoPrivateFamily, &fhoPrivateFace, (FHOBJ*)NULL, (FHOBJ*)NULL,
                                        &efsmo, iEnumType, peffi, pwszName))
            {
                return HEFS_INVALID;
            }
        }


    // Repeat with the alternate facename (if any).  Since a LOGFONT can
    // map via the alternate facenames, it is appropriate to enumerate the
    // alternate facename fonts as if they really had this face name.

        PFONTSUB pfsub = pfsubAlternateFacename(pwszName);
        PWSZ pwszAlt = pfsub ? (PWSZ)pfsub->fcsAltFace.awch : NULL;

        if ( pwszAlt != (PWSZ) NULL )
        {
        // Enumerate engine fonts.

            if (!bScanFamilyAndFace(&fhoEngineFamily, &fhoEngineFace, (FHOBJ*)NULL, (FHOBJ*)NULL,
                                        &efsmo, iEnumType, peffi, pwszAlt))
            {
                return HEFS_INVALID;
            }


        // Enumerate the private fonts.

            if (pftop.pPFT != NULL)
            {
                 FHOBJ fhoPrivateFamily(&pftop.pPFT->pfhFamily);
                 FHOBJ fhoPrivateFace(&pftop.pPFT->pfhFace);

                 if (!fhoPrivateFamily.bValid() || !fhoPrivateFace.bValid())
                 {
                     WARNING("win32k!hefsEngineOnly(): cannot lock private font hash\n");
                     return HEFS_INVALID;
                 }

                 if (!bScanFamilyAndFace(&fhoPrivateFamily, &fhoPrivateFace, (FHOBJ*)NULL, (FHOBJ*)NULL,
                                             &efsmo, iEnumType, peffi, pwszAlt))
                 {
                     return HEFS_INVALID;
                 }
            }

        // Inform the enumeration state that an alternate name was used.

            efsmo.vUsedAltName(pfsub);
        }

        *pulCount = efsmo.cjEfdwTotal();

    // Keep the EFSTATE around.

        efsmo.vKeepIt();

    // Return the EFSOBJ handle.

        return efsmo.hefs();
    }
}


/******************************Public*Routine******************************\
* HEFS hefsDeviceAndEngine
*
* Enumerates device and engine fonts.
*
* PFEs are accumulated in an EFSTATE (EnumFont State) object.  If a non-NULL
* pwszName is specified, then only fonts that match the given name are added
* to the EFS.  If a NULL pwszFace is specified, then one font of each name is
* added to the EFS.
*
* If any of the filtering flags in the EFFILTER_INFO structure are specified,
* then PFEs are tested in additional filtering stages before they are added
* to the EFS.
*
* The EFS is allocated by this function.  It is the responsibility of the
* caller to ensure that the EFS is eventually freed.
*
* Returns:
*   Handle to allocated EFS object, HEFS_INVALID if an error occurs.
*
*
* History:
*
*  18-Sept-1996 -by- Xudong Wu [TessieW]
* Add the enumeration for private PFT.
*
*  07-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

HEFS hefsDeviceAndEngine (
    PWSZ  pwszName,              // enumerate this font family
    ULONG lfCharSet,
    ULONG iEnumType,
    EFFILTER_INFO *peffi,       // filtering information
    PUBLIC_PFTOBJ &pfto,        // public PFT user object
    PUBLIC_PFTOBJ &pftop,       // private PFT user object
    PFFOBJ &pffoDevice,         // PFFOBJ for device fonts
    PDEVOBJ &pdo,               // PDEVOBJ for device
    ULONG   *pulCount
    )
{
// ulEnumFontOpen, the caller, has already grabbed the ghsemPublicPFT,
// so the font hash tables are stable.

// Create and validate FHOBJ for device (family list).

    FHOBJ fhoDeviceFamily(&pffoDevice.pPFF->pfhFamily);

    if ( !fhoDeviceFamily.bValid() )
    {
        WARNING("gdisrv!hefsEnumFontsState(): cannot lock device font hash (family)\n");
        return HEFS_INVALID;
    }

// Create and validate FHOBJ for engine (family list).

    FHOBJ fhoEngineFamily(&pfto.pPFT->pfhFamily);

    if ( !fhoEngineFamily.bValid() )
    {
        WARNING("gdisrv!hefsEnumFontsState(): cannot lock engine font hash (family)\n");
        return HEFS_INVALID;
    }



// Create and validate FHOBJ for device (face list).

    FHOBJ fhoDeviceFace(&pffoDevice.pPFF->pfhFace);

    if ( !fhoDeviceFace.bValid() )
    {
        WARNING("gdisrv!hefsEnumFontsState(): cannot lock device font hash (face)\n");
        return HEFS_INVALID;
    }

// Create and validate FHOBJ for engine (face list).

    FHOBJ fhoEngineFace(&pfto.pPFT->pfhFace);

    if ( !fhoEngineFace.bValid() )
    {
        WARNING("gdisrv!hefsEnumFontsState(): cannot lock engine font hash (face)\n");
        return HEFS_INVALID;
    }



// For NULL pwszName, an example of each family needs to be enumerated.  In
// other words, we scan ACROSS the names.

    if (pwszName == (PWSZ) NULL)
    {
    // Allocate a new EFSTATE for the enumeration.  Use total number of lists
    // as a hint for the initial size.  This is reasonable since we will probably
    // enumerate back all of the list heads.

        ASSERTGDI(peffi->bNonTrueTypeFilter == FALSE, "ERROR not FALSE");

        EFSMEMOBJ efsmo(fhoDeviceFamily.cLists() + fhoEngineFamily.cLists(), iEnumType);

        if ( !efsmo.bValid() )
        {
            WARNING("gdisrv!hefsEnumFontsState(): could not allocate enumeration state\n");
            return HEFS_INVALID;
        }

        //
        // Enumerate device and engine fonts.
        //

        if (pdo.flTextCaps() & TC_RA_ABLE)
        {
            //
            // For Win3.1 compatability Enum Device,Non-TT,TT
            // This is for Displays and PaintJets under 3.1
            //

            if ( !bScanFamily(&fhoDeviceFamily, ENUM_FILTER_NONE, &fhoEngineFamily, ENUM_FILTER_NONTT,
                                    &fhoEngineFamily, ENUM_FILTER_TT, &efsmo, iEnumType, peffi, NULL) )
            {
                return HEFS_INVALID;
            }

        // scan through private PFT if gpPFTPrivate!=NULL

            if (pftop.pPFT != NULL)
            {
                FHOBJ fhoPrivateFamily(&pftop.pPFT->pfhFamily);

                if ( !fhoPrivateFamily.bValid() )
                {
                    WARNING("win32k!hefsDeviceAndEngine(): cannot lock private font hash (family)\n");
                    return HEFS_INVALID;
                }

                if ( !bScanFamily(&fhoPrivateFamily, ENUM_FILTER_NONTT, &fhoPrivateFamily, ENUM_FILTER_TT,
                                        (FHOBJ*)NULL, 0, &efsmo, iEnumType, peffi, NULL) )
                {
                    return HEFS_INVALID;
                }
            }
        }
#if 0

// If we ever need this, this is how Postscript should do it.  We would
// need to call the driver at Enable Printer time to see if it's Postscript
// and set a bit for quick checking here.

        else if (pdo.bPostScript())
        {
            //
            // For Win3.1 compatability Enum TT,Device,Non-TT,
            //

            if (!bScanFamily(&fhoEngineFamily, ENUM_FILTER_TT, &fhoDeviceFamily, ENUM_FILTER_NONE,
                                &fhoEngineFamily, ENUM_FILTER_NONTT, &efsmo, iEnumType, peffi, NULL) )
            {
                return HEFS_INVALID;
            }

            // scan throught private PFT if gpPFTPrivate!=NULL

            if (pftop.pPFT != NULL)
            {
                FHOBJ fhoPrivateFamily(&pftop.pPFT->pfhFamily);

                if ( !fhoPrivateFamily.bValid() )
                {
                    WARNING("win32k!hefsDeviceAndEngine(): cannot lock private font hash (family)\n");
                    return HEFS_INVALID;
                }

                if ( !bScanFamily(&fhoPrivateFamily, ENUM_FILTER_TT, &fhoPrivateFamily, ENUM_FILTER_NONTT,
                                        (FHOBJ*)NULL, 0, &efsmo, iEnumType, peffi, NULL) )
                {
                    return HEFS_INVALID;
                }
            }
        }
#endif
        else
        {
            //
            // Win3.1 compatability.
            // Enum Device, TT, Non-TT.
            //

            if ( !bScanFamily(&fhoDeviceFamily, ENUM_FILTER_NONE, &fhoEngineFamily, ENUM_FILTER_TT,
                                  &fhoEngineFamily, ENUM_FILTER_NONTT, &efsmo, iEnumType, peffi, NULL) )
            {
                return HEFS_INVALID;
            }

            if (pftop.pPFT != NULL)
            {
                FHOBJ fhoPrivateFamily(&pftop.pPFT->pfhFamily);

                if ( !fhoPrivateFamily.bValid() )
                {
                    WARNING("win32k!hefsDeviceAndEngine(): cannot lock private font hash (family)\n");
                    return HEFS_INVALID;
                }

                if ( !bScanFamily(&fhoPrivateFamily, ENUM_FILTER_TT, &fhoPrivateFamily, ENUM_FILTER_NONTT,
                                      (FHOBJ*)NULL, 0, &efsmo, iEnumType, peffi, NULL) )
                {
                    return HEFS_INVALID;
                }
            }
        }

        *pulCount = efsmo.cjEfdwTotal();

    // Keep the EFSTATE around.

        efsmo.vKeepIt();

    // Return the EFSOBJ handle.

        return efsmo.hefs();
    }
    else
    {
    // For non-NULL pwszName, all the fonts of a particular family are enumerated.
    // In other words, we scan DOWN a name.

    // Allocate a new EFSTATE.  Use a default size.

        EFSMEMOBJ efsmo(EFS_DEFAULT, iEnumType);

        if ( !efsmo.bValid() )
        {
            WARNING("gdisrv!hefsEnumFontsState(): could not allocate enumeration state\n");
            return HEFS_INVALID;
        }

    // Enumerate device and engine fonts.

        if (!bScanFamilyAndFace(&fhoEngineFamily, &fhoEngineFace, &fhoDeviceFamily, &fhoDeviceFace,
                                    &efsmo, iEnumType, peffi, pwszName))
        {
            return HEFS_INVALID;
        }

    // Enumerate the private fonts if any

        if (pftop.pPFT != NULL)
        {
            FHOBJ fhoPrivateFamily(&pftop.pPFT->pfhFamily);
            FHOBJ fhoPrivateFace(&pftop.pPFT->pfhFace);

            if (!fhoPrivateFamily.bValid() || !fhoPrivateFace.bValid())
            {
                WARNING("win32k!hefsDeviceAndEngine(): cannot lock private font hash\n");
                return HEFS_INVALID;
            }

            if (!bScanFamilyAndFace(&fhoPrivateFamily, &fhoPrivateFace, (FHOBJ*)NULL, (FHOBJ*)NULL,
                                        &efsmo, iEnumType, peffi, pwszName))
            {
                return HEFS_INVALID;
            }
        }

    // Repeat with the alternate facename (if any).  Since a LOGFONT can
    // map via the alternate facenames, it is appropriate to enumerate the
    // alternate facename fonts as if they really had this face name.
    //
    // However, to be Win 3.1 compatible, we will NOT do this if the device
    // is a non-display device.
    //
    // It appears that Windows 95 no longer does this.  Additionally, we need
    // to enumerate manufactured EE names (i.e. Arial Cyr, Arial Grk, etc)
    // on printer DC's as well now.  If we don't we break Word Perfect 94 a 16 bit
    // winstone application.
    //
    //
    //    if ( pdo.bDisplayPDEV() )
        {
            PFONTSUB pfsub = pfsubAlternateFacename(pwszName);
            PWSZ pwszAlt = pfsub ? (PWSZ)pfsub->fcsAltFace.awch : NULL;

            if ( pwszAlt != (PWSZ) NULL )
            {
            // Enumerate device and engine fonts.

                if (!bScanFamilyAndFace(&fhoEngineFamily, &fhoEngineFace, &fhoDeviceFamily, &fhoDeviceFace,
                                            &efsmo, iEnumType, peffi, pwszAlt))
                {
                    return HEFS_INVALID;
                }

            // Enumerate private fonts if any

                if (pftop.pPFT != NULL)
                {
                    FHOBJ fhoPrivateFamily(&pftop.pPFT->pfhFamily);
                    FHOBJ fhoPrivateFace(&pftop.pPFT->pfhFace);

                    if (!fhoPrivateFamily.bValid() || !fhoPrivateFace.bValid())
                    {
                        WARNING("win32k!hefsDeviceAndEngine(): cannot lock private font hash\n");
                        return HEFS_INVALID;
                    }

                    if (!bScanFamilyAndFace(&fhoPrivateFamily, &fhoPrivateFace, (FHOBJ*)NULL, (FHOBJ*)NULL,
                                                &efsmo, iEnumType, peffi, pwszAlt))
                    {
                        return HEFS_INVALID;
                    }
                }

            // Inform the enumeration state that an alternate name was used.

                efsmo.vUsedAltName(pfsub);
            }
        }

        *pulCount = efsmo.cjEfdwTotal();

    // Keep the EFSTATE around.

        efsmo.vKeepIt();

    // Return the EFSOBJ handle.

        return efsmo.hefs();
    }

}


/******************************Public*Routine******************************\
* ULONG ulEnumFontOpen
*
* First phase of the enumeration.  Fonts from the engine and device are
* chosen and saved in a EFSTATE (font enumeration state) object.  A handle
* to this object is passed back.  The caller can use this handle to
* initiate the second pass in which the data is sent back over the client
* server interface in chunks.
*
* This function is also responsible for determining what types of filters
* will be applied in choosing fonts for the enumeration.  Filters which
* are controllable are:
*
*   TrueType filtering      non-TrueType fonts are discarded
*
*   Raster filering         raster fonts are discarded
*
*   Aspect ratio filtering  fonts not matching resolution are discarded
*
* Returns:
*   EFS handle (as a ULONG) if successful, HEFS_INVALID (0) otherwise.
*
* Note:
*   The function may still return valid HEFS even if the EFSTATE is empty.
*
* History:
*  08-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

ULONG_PTR GreEnumFontOpen (
    HDC   hdc,                  // device to enumerate on
    ULONG iEnumType,            // EnumFonts, EnumFontFamilies or EnumFontFamiliesEx
    FLONG flWin31Compat,        // Win 3.1 compatibility flags
    ULONG cwchMax,              // maximum name length (for paranoid CSR code)
    PWSZ  pwszName,             // font name to enumerate
    ULONG lfCharSet,
    ULONG *pulCount
    )
{
    DONTUSE(cwchMax);

    HEFS hefsRet = HEFS_INVALID;

//
// Create and validate user object for DC.
//
    DCOBJ   dco(hdc);

    if(!dco.bValid())
    {
        WARNING("gdisrv!ulEnumFontOpen(): cannot access DC\n");
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);

        return ((ULONG_PTR) hefsRet);
    }

//
// Get PDEV user object.  We also need to make
// sure that we have loaded device fonts before we go off to the font mapper.
// This must be done before the semaphore is locked.
//
    PDEVOBJ pdo(dco.hdev());
    ASSERTGDI (
        pdo.bValid(),
        "gdisrv!ulEnumFontOpen(): cannot access PDEV\n");

    if (!pdo.bGotFonts())
        pdo.bGetDeviceFonts();

// Stabilize public PFT.

    SEMOBJ  so(ghsemPublicPFT);

// Compute font enumeration filter info.

    EFFILTER_INFO effi;

    effi.lfCharSetFilter    = lfCharSet;
    effi.bNonTrueTypeFilter = FALSE;

//
// If not raster capable, then use raster font filtering.
//
//
// If it weren't hacked, we might be able to get this info
// from GetDeviceCaps().  As it is, we will assume only
// plotters are non-raster capable.
//

    effi.bRasterFilter = (pdo.ulTechnology() == DT_PLOTTER);

    effi.bEngineFilter = (pdo.ulTechnology() == DT_CHARSTREAM);

//
// Aspect ratio filter (use device's logical x and y resolutions).
//
// Note: [Windows 3.1 compatiblity] Aspect ratio filtering is turned ON for
//       non-display devices.  This is because most printers in Win 3.1
//       do aspect ratio filtering.  And since the Win 3.1 DDI gives
//       enumeration to the drivers, display bitmap fonts usually are not
//       enumerated on these devices.  The NT DDI, however, gives the graphics
//       engine control over enumeration.  So we need to provide this
//       compatibility here.  Hopefully, all devices in Win3.1 do this
//       filtering, because we do now.
//
//       Note that we check the PDEV directly rather than the DC because
//       DCOBJ::bDisplay() is not TRUE for display ICs (just display DCs
//       which are DCTYPE_DIRECT).
//
    effi.bAspectFilter = (BOOL) ( (dco.pdc->flFontMapper() & ASPECT_FILTERING)
                                  || !pdo.bDisplayPDEV() );

    effi.ptlDeviceAspect.x = pdo.ulLogPixelsX();
    effi.ptlDeviceAspect.y = pdo.ulLogPixelsY();

//
// If set for TrueType only, use TrueType filtering.
//
    effi.bTrueTypeFilter = ((gulFontInformation & FE_FILTER_TRUETYPE) != 0);

//
// Set the Win3.1 compatibility flag.
//
    effi.bTrueTypeDupeFilter = (BOOL) (flWin31Compat & GACF_TTIGNORERASTERDUPE);

    // assume failure

    hefsRet = 0;

    {
        // Find the device PFF

        DEVICE_PFTOBJ pftoDevice;
        PFF *pPFF;
        if (pPFF = pftoDevice.pPFFGet(dco.hdev()))
        {
            PFFOBJ pffoDev(pPFF);
            if (pffoDev.bValid())
            {
                PUBLIC_PFTOBJ pftoPublic;
                PUBLIC_PFTOBJ pftoPrivate(gpPFTPrivate);

                hefsRet =
                    hefsDeviceAndEngine(
                            pwszName
                          , lfCharSet
                          , iEnumType
                          , &effi
                          , pftoPublic
                          , pftoPrivate
                          , pffoDev
                          , pdo
                          , pulCount
                          );
            }
            else
            {
                WARNING("ulEnumFontOpen: invalid pffoDev\n");
            }
        }
    }
    if (!hefsRet)
    {
        PUBLIC_PFTOBJ pftoPublic;
        PUBLIC_PFTOBJ pftoPrivate(gpPFTPrivate);

    // If no device font PFFOBJ was found, do enumeration without a PFFOBJ.
    // pulls all the fonts into an enumeration state.

        hefsRet = hefsEngineOnly(pwszName,
                                 lfCharSet,
                                 iEnumType,
                                 &effi,
                                 pftoPublic,
                                 pftoPrivate,
                                 pulCount);
    }

    return ((ULONG_PTR) hefsRet);
}

/******************************Public*Routine******************************\
* BOOL bEnumFontChunk
*
* Second phase of the enumeration.  HPFEs are pulled out of the enumeration
* state one-by-one, converted into an ENUMFONTDATA structure, and put into
* the return buffer.  The size of the return buffer is determined by the
* client side and determines the granularity of the "chunking".
*
* This function signals the client side that the enumeration data has been
* exhausted by returning FALSE.  Note that it is possible that in the pass
* pass through here that the EFSTATE may already be empty.  The caller must
* check both the function return value and the pcefdw value.
*
* Note:
*   Caller should set *pcefd to the capacity of the pefp buffer.
*   Upon return, iEnumType will set pefb.cefp to the number of
*   ENUMFONTDATA structures copied into the pefb.aefd array.
*
*   Also, pefdw is user memory, which might be asynchronously changed
*   at any time.  So, we cannot trust any values read from that buffer.
*
* Returns:
*   TRUE if there are more to go, FALSE otherwise,
*
* History:
*  08-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL bEnumFontChunk(
    HDC             hdc,        // device to enumerate on
    ULONG_PTR        idEnum,
    COUNT           cjEfdwTotal, // (in) capacity of buffer
    COUNT           *pcjEfdw,    // (out) number of ENUMFONTDATAs returned
    PENUMFONTDATAW  pefdw       // return buffer
    )
{
// Initialize position in buffer in which to copy data

    PENUMFONTDATAW   pefdwCur = pefdw;

// Validate DC and EnumFontState.  If either fail lock bug out.

    DCOBJ   dco(hdc);
    EFSOBJ efso((HEFS) idEnum);

    if ((!efso.bValid()) || (!dco.bValid()))
    {
        WARNING("gdisrv!bEnumFontChunk(): bad HEFS or DC handle\n");
        *pcjEfdw = 0;
        return FALSE;
    }

// since as of 4.0 we do not go through this a chunk at the time
// we must have

    ASSERTGDI(cjEfdwTotal == efso.cjEfdwTotal(),
        "efso.cjEfdwTotal() problem\n");

    ASSERTGDI(cjEfdwTotal >= efso.cefe() * CJ_EFDW0,
              "cjEfdwTotal NOT BIG enough \n");

// Counter to track number of ENUMFONTDATAW structures copied into buffer.

    COUNT    cjEfdwCopied = 0;
    EFENTRY *pefe;

// Before we access PFEs, grab the ghsemPublicPFT so no one can delete
// PFE while we are in the loop (note that PFEs can get deleted
// once we are outside of this--like between chunks!).

    SEMOBJ  so(ghsemPublicPFT);

// In each font file, try each font face
// We are sure that we will not overwrite the buffer because
// the size of buffer is big enough to take all the enumfont data.

    while((pefe = efso.pefeEnumNext()))
    {
    // Create a PFE Collect user object.  We're using real handle instead of
    // pointers because someone may have deleted by the time we get
    // around to enumerating.

    // Get the PFE through PFE Collect object.
    
        HPFECOBJ pfeco(pefe->hpfec);
        PFEOBJ  pfeo(pfeco.GetPFE(pefe->iFont));

        SIZE_T cjEfdwCur = 0;

    // Validate user object and copy data into buffer.  Because PFE
    // may have been deleted between chunks, we need to check validity.

        PWSZ  pwszFamilyOverride = NULL;
        BOOL  bCharSetOverride   = FALSE;
        ULONG lfCharSetOverride  = DEFAULT_CHARSET;

        if (efso.pwszFamilyOverride())
        {
            pwszFamilyOverride = efso.pwszFamilyOverride();

            if (pefe->fjOverride & FJ_CHARSETOVERRIDE)
            {
                bCharSetOverride = TRUE;
                lfCharSetOverride  = pefe->jCharSetOverride;
            }
            else
            {
                bCharSetOverride   = efso.bCharSetOverride();
                lfCharSetOverride  = (ULONG)efso.jCharSetOverride();
            }
        }
        else
        {
            if (pefe->fjOverride & FJ_FAMILYOVERRIDE)
            {
                pwszFamilyOverride = gpfsTable[pefe->iOverride].awchOriginal;
            }
            if (pefe->fjOverride & FJ_CHARSETOVERRIDE)
            {
                bCharSetOverride = TRUE;
                lfCharSetOverride  = pefe->jCharSetOverride;
            }
        }

        if
        (
            pfeo.bValid() &&
            (cjEfdwCur = cjCopyFontDataW(
                dco,
                pefdwCur,
                pfeo,
                pefe->efsty,
                pwszFamilyOverride,
                lfCharSetOverride,
                bCharSetOverride,
                efso.iEnumType()
            ))
        )
        {
	    cjEfdwCopied += (ULONG) cjEfdwCur;
            pefdwCur = (ENUMFONTDATAW *)((BYTE*)pefdwCur + cjEfdwCur);
        }
    }

    *pcjEfdw = cjEfdwCopied;

// we are done: pefe has to be zero:

    ASSERTGDI(!pefe, "not all fonts are enumerated yet\n");
    ASSERTGDI(cjEfdwCopied <= cjEfdwTotal, "cjEfdwCopied > cjEfdwTotal\n");

// true means success, it used to mean that there are more fonts to come for
// enumeration. Now, we do not do "chunking" any more. Assert above makes sure
// that this is the case [bodind]

    return TRUE;
}


/*************************Public*Routine********************************\
* BOOL  bScanTheList()
*
* Scan through the font hash table using the given filter mode
*
* History:
*
*  07-Nov-1996 -by- Xudong Wu [TessieW]
* Wrote it.
*
************************************************************************/

BOOL  bScanTheList(
    FHOBJ  *pfho,
    ULONG  ulFilter,
    EFSOBJ *pefsmo,
    ULONG  iEnumType,
    EFFILTER_INFO *peffi,
    PWSZ    pwszName
)
{
    BOOL bRet;

    if (pwszName)
    {
        bRet = pfho->bScanLists(pefsmo, pwszName, iEnumType, peffi);
    }
    else
    {
        BOOL    bTempFilter;
        if (ulFilter == ENUM_FILTER_TT)
        {
            bTempFilter = peffi->bTrueTypeFilter;
            peffi->bTrueTypeFilter = TRUE;
        }
        else if (ulFilter == ENUM_FILTER_NONTT)
        {
            peffi->bNonTrueTypeFilter = TRUE;
        }

        bRet = pfho->bScanLists(pefsmo, iEnumType, peffi);

        if (ulFilter == ENUM_FILTER_TT)
        {
            peffi->bTrueTypeFilter = bTempFilter;
        }
        else if (ulFilter == ENUM_FILTER_NONTT)
        {
            peffi->bNonTrueTypeFilter = FALSE;
        }
    }

    return bRet;
}


/*************************Public*Routine********************************\
* BOOL  bScanFamily()
*
* Scan through the family font hash table in the different filter
* order given by the input flag.
*
* History:
*
*  23-Oct-1996 -by- Xudong Wu [TessieW]
* Wrote it.
*
************************************************************************/

BOOL  bScanFamily(
    FHOBJ  *pfho1, ULONG ulFilter1,
    FHOBJ  *pfho2, ULONG ulFilter2,
    FHOBJ  *pfho3, ULONG ulFilter3,
    EFSOBJ *pefsmo,
    ULONG  iEnumType,
    EFFILTER_INFO *peffi,
    PWSZ    pwszName
)
{
    return
    (
       (!pfho1 || bScanTheList(pfho1, ulFilter1, pefsmo, iEnumType, peffi, pwszName))
        &&
       (!pfho2 || bScanTheList(pfho2, ulFilter2, pefsmo, iEnumType, peffi, pwszName))
        &&
       (!pfho3 || bScanTheList(pfho3, ulFilter3, pefsmo, iEnumType, peffi, pwszName))
    );
}


/*************************Public*Routine********************************\
* BOOL  bScanFamilyAndFace()
*
* Frist scan through the family font hash table. If no match is found,
* scan through the face font hash table.
*
* History:
*
*  23-Oct-1996 -by- Xudong Wu [TessieW]
* Wrote it.
*
************************************************************************/

BOOL bScanFamilyAndFace(
    FHOBJ    *pfhoEngFamily,
    FHOBJ    *pfhoEngFace,
    FHOBJ    *pfhoDevFamily,
    FHOBJ    *pfhoDevFace,
    EFSOBJ   *pefsmo,
    ULONG    iEnumType,
    EFFILTER_INFO   *peffi,
    PWSZ     pwszName
)
{
    BOOL bRet = FALSE;

    if (bScanFamily(pfhoDevFamily, ENUM_FILTER_NONE,
                        pfhoEngFamily, ENUM_FILTER_NONE,
                        (FHOBJ *) NULL,
                        0, pefsmo, iEnumType, peffi, pwszName))
    {
    // If list is empty, try the face name lists, else we are done

        if (pefsmo->bEmpty() )
        {
            bRet = bScanFamily(pfhoDevFace, ENUM_FILTER_NONE,
                               pfhoEngFace, ENUM_FILTER_NONE,
                               (FHOBJ*) NULL,
                               0, pefsmo, iEnumType, peffi, pwszName);
            #if DBG
            if (!bRet)
                WARNING("win32k!bScanFamilyAndFace(): scan face failed\n");
            #endif
        }
        else
        {
            bRet = TRUE;
        }

    }
    #if DBG
    else
    {
        WARNING("win32k!bScanFamilyAndFace(): scan family failed\n");
    }
    #endif

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\engline.cxx ===
/*************************************************************************\
* Module Name: EngLine.cxx
*
* EngLine for bitmap simulations
*
* Created: 5-Apr-91
* Author: Paul Butzi
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"
#include "engline.hxx"

/******************************Public*Routine******************************\
* BOOL bLines(pbmi, pptfxFirst, pptfxBuf, prun, cptfx, pls, prclClip,
*             apfn[], flStart, pchBits, lDelta)
*
* Computes the DDA for the line and gets ready to draw it.  Puts the
* pixel data into an array of strips, and calls a strip routine to
* do the actual drawing.
*
* Doing Lines Right
* -----------------
*
* In NT, all lines are given to the device driver in fractional
* coordinates, in a 28.4 fixed point format.  The lower 4 bits are
* fractional for sub-pixel positioning.
*
* Note that you CANNOT! just round the coordinates to integers
* and pass the results to your favorite integer Bresenham routine!!
* (Unless, of course, you have such a high resolution device that
* nobody will notice -- not likely for a display device.)  The
* fractions give a more accurate rendering of the line -- this is
* important for things like our Bezier curves, which would have 'kinks'
* if the points in its polyline approximation were rounded to integers.
*
* Unfortunately, for fractional lines there is more setup work to do
* a DDA than for integer lines.  However, the main loop is exactly
* the same (and can be done entirely with 32 bit math).
*
* Our Implementation
* ------------------
*
* We employ a run length slice algorithm: our DDA calculates the
* number of pixels that are in each row (or 'strip') of pixels.
*
* We've separated the running of the DDA and the drawing of pixels:
* we run the DDA for several iterations and store the results in
* a 'strip' buffer (which are the lengths of consecutive pixel rows of
* the line), then we crank up a 'strip drawer' that will draw all the
* strips in the buffer.
*
* We also employ a 'half-flip' to reduce the number of strip
* iterations we need to do in the DDA and strip drawing loops: when a
* (normalized) line's slope is more than 1/2, we do a final flip
* about the line y = (1/2)x.  So now, instead of each strip being
* consecutive horizontal or vertical pixel rows, each strip is composed
* of those pixels aligned in 45 degree rows.  So a line like (0, 0) to
* (128, 128) would generate only one strip.
*
* We also always draw only left-to-right.
*
* Style lines may have arbitrary style patterns.  We specially
* optimize the default patterns (and call them 'masked' styles).
*
* The DDA Derivation
* ------------------
*
* Here is how I like to think of the DDA calculation.
*
* We employ Knuth's "diamond rule": rendering a one-pixel-wide line
* can be thought of as dragging a one-pixel-wide by one-pixel-high
* diamond along the true line.  Pixel centers lie on the integer
* coordinates, and so we light any pixel whose center gets covered
* by the "drag" region (John D. Hobby, Journal of the Association
* for Computing Machinery, Vol. 36, No. 2, April 1989, pp. 209-229).
*
* We must define which pixel gets lit when the true line falls
* exactly half-way between two pixels.  In this case, we follow
* the rule: when two pels are equidistant, the upper or left pel
* is illuminated, unless the slope is exactly one, in which case
* the upper or right pel is illuminated.  (So we make the edges
* of the diamond exclusive, except for the top and left vertices,
* which are inclusive, unless we have slope one.)
*
* This metric decides what pixels should be on any line BEFORE it is
* flipped around for our calculation.  Having a consistent metric
* this way will let our lines blend nicely with our curves.  The
* metric also dictates that we will never have one pixel turned on
* directly above another that's turned on.  We will also never have
* a gap; i.e., there will be exactly one pixel turned on for each
* column between the start and end points.  All that remains to be
* done is to decide how many pixels should be turned on for each row.
*
* So lines we draw will consist of varying numbers of pixels on
* successive rows, for example:
*
*       ******
*             *****
*                  ******
*                        *****
*
* We'll call each set of pixels on a row a "strip".
*
* (Please remember that our coordinate space has the origin as the
* upper left pixel on the screen; postive y is down and positive x
* is right.)
*
* Device coordinates are specified as fixed point 28.4 numbers,
* where the first 28 bits are the integer coordinate, and the last
* 4 bits are the fraction.  So coordinates may be thought of as
* having the form (x, y) = (M/F, N/F) where F is the constant scaling
* factor F = 2^4 = 16, and M and N are 32 bit integers.
*
* Consider the line from (M0/F, N0/F) to (M1/F, N1/F) which runs
* left-to-right and whose slope is in the first octant, and let
* dM = M1 - M0 and dN = N1 - N0.  Then dM >= 0, dN >= 0 and dM >= dN.
*
* Since the slope of the line is less than 1, the edges of the
* drag region are created by the top and bottom vertices of the
* diamond.  At any given pixel row y of the line, we light those
* pixels whose centers are between the left and right edges.
*
* Let mL(n) denote the line representing the left edge of the drag
* region.  On pixel row j, the column of the first pixel to be
* lit is
*
*       iL(j) = ceiling( mL(j * F) / F)
*
* Since the line's slope is less than one:
*
*       iL(j) = ceiling( mL([j + 1/2] F) / F )
*
* Recall the formula for our line:
*
*       n(m) = (dN / dM) (m - M0) + N0
*
*       m(n) = (dM / dN) (n - N0) + M0
*
* Since the line's slope is less than one, the line representing
* the left edge of the drag region is the original line offset
* by 1/2 pixel in the y direction:
*
*       mL(n) = (dM / dN) (n - F/2 - N0) + M0
*
* From this we can figure out the column of the first pixel that
* will be lit on row j, being careful of rounding (if the left
* edge lands exactly on an integer point, the pixel at that
* point is not lit because of our rounding convention):
*
*       iL(j) = floor( mL(j F) / F ) + 1
*
*             = floor( ((dM / dN) (j F - F/2 - N0) + M0) / F ) + 1
*
*             = floor( F dM j - F/2 dM - N0 dM + dN M0) / F dN ) + 1
*
*                      F dM j - [ dM (N0 + F/2) - dN M0 ]
*             = floor( ---------------------------------- ) + 1
*                                   F dN
*
*                      dM j - [ dM (N0 + F/2) - dN M0 ] / F
*             = floor( ------------------------------------ ) + 1       (1)
*                                     dN
*
*             = floor( (dM j + alpha) / dN ) + 1
*
* where
*
*       alpha = - [ dM (N0 + F/2) - dN M0 ] / F
*
* We use equation (1) to calculate the DDA: there are iL(j+1) - iL(j)
* pixels in row j.  Because we are always calculating iL(j) for
* integer quantities of j, we note that the only fractional term
* is constant, and so we can 'throw away' the fractional bits of
* alpha:
*
*       beta = floor( - [ dM (N0 + F/2) - dN M0 ] / F )                 (2)
*
* so
*
*       iL(j) = floor( (dM j + beta) / dN ) + 1                         (3)
*
* for integers j.
*
* Note if iR(j) is the line's rightmost pixel on row j, that
* iR(j) = iL(j + 1) - 1.
*
* Similarly, rewriting equation (1) as a function of column i,
* we can determine, given column i, on which pixel row j is the line
* lit:
*
*                       dN i + [ dM (N0 + F/2) - dN M0 ] / F
*       j(i) = ceiling( ------------------------------------ ) - 1
*                                       dM
*
* Floors are easier to compute, so we can rewrite this:
*
*                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F
*       j(i) = floor( ----------------------------------------------- ) - 1
*                                       dM
*
*                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F - dM
*            = floor( ---------------------------------------------------- )
*                                       dM
*
*                     dN i + [ dM (N0 + F/2) - dN M0 - 1 ] / F
*            = floor( ---------------------------------------- )
*                                       dM
*
* We can once again wave our hands and throw away the fractional bits
* of the remainder term:
*
*       j(i) = floor( (dN i + gamma) / dM )                             (4)
*
* where
*
*       gamma = floor( [ dM (N0 + F/2) - dN M0 - 1 ] / F )              (5)
*
* We now note that
*
*       beta = -gamma - 1 = ~gamma                                      (6)
*
* To draw the pixels of the line, we could evaluate (3) on every scan
* line to determine where the strip starts.  Of course, we don't want
* to do that because that would involve a multiply and divide for every
* scan.  So we do everything incrementally.
*
* We would like to easily compute c , the number of pixels on scan j:
*                                  j
*
*    c  = iL(j + 1) - iL(j)
*     j
*
*       = floor((dM (j + 1) + beta) / dN) - floor((dM j + beta) / dN)   (7)
*
* This may be rewritten as
*
*    c  = floor(i    + r    / dN) - floor(i  + r  / dN)                 (8)
*     j          j+1    j+1                j    j
*
* where i , i    are integers and r  < dN, r    < dN.
*        j   j+1                   j        j+1
*
* Rewriting (7) again:
*
*    c  = floor(i  + r  / dN + dM / dN) - floor(i  + r  / dN)
*     j          j    j                          j    j
*
*
*       = floor((r  + dM) / dN) - floor(r  / dN)
*                 j                      j
*
* This may be rewritten as
*
*    c  = dI + floor((r  + dR) / dN) - floor(r  / dN)
*     j                j                      j
*
* where dI + dR / dN = dM / dN, dI is an integer and dR < dN.
*
* r  is the remainder (or "error") term in the DDA loop: r  / dN
*  j                                                      j
* is the exact fraction of a pixel at which the strip ends.  To go
* on to the next scan and compute c    we need to know r   .
*                                  j+1                  j+1
*
* So in the main loop of the DDA:
*
*    c  = dI + floor((r  + dR) / dN) and r    = (r  + dR) % dN
*     j                j                  j+1     j
*
* and we know r  < dN, r    < dN, and dR < dN.
*              j        j+1
*
* We have derived the DDA only for lines in the first octant; to
* handle other octants we do the common trick of flipping the line
* to the first octant by first making the line left-to-right by
* exchanging the end-points, then flipping about the lines y = 0 and
* y = x, as necessary.  We must record the transformation so we can
* undo them later.
*
* We must also be careful of how the flips affect our rounding.  If
* to get the line to the first octant we flipped about x = 0, we now
* have to be careful to round a y value of 1/2 up instead of down as
* we would for a line originally in the first octant (recall that
* "In the case where two pels are equidistant, the upper or left
* pel is illuminated...").
*
* To account for this rounding when running the DDA, we shift the line
* (or not) in the y direction by the smallest amount possible.  That
* takes care of rounding for the DDA, but we still have to be careful
* about the rounding when determining the first and last pixels to be
* lit in the line.
*
* Determining The First And Last Pixels In The Line
* -------------------------------------------------
*
* Fractional coordinates also make it harder to determine which pixels
* will be the first and last ones in the line.  We've already taken
* the fractional coordinates into account in calculating the DDA, but
* the DDA cannot tell us which are the end pixels because it is quite
* happy to calculate pixels on the line from minus infinity to positive
* infinity.
*
* The diamond rule determines the start and end pixels.  (Recall that
* the sides are exclusive except for the left and top vertices.)
* This convention can be thought of in another way: there are diamonds
* around the pixels, and wherever the true line crosses a diamond,
* that pel is illuminated.
*
* Consider a line where we've done the flips to the first octant, and the
* floor of the start coordinates is the origin:
*
*        +-----------------------> +x
*        |
*        | 0                     1
*        |     0123456789abcdef
*        |
*        |   0 00000000?1111111
*        |   1 00000000 1111111
*        |   2 0000000   111111
*        |   3 000000     11111
*        |   4 00000    ** 1111
*        |   5 0000       ****1
*        |   6 000           1***
*        |   7 00             1  ****
*        |   8 ?                     ***
*        |   9 22             3         ****
*        |   a 222           33             ***
*        |   b 2222         333                ****
*        |   c 22222       3333                    **
*        |   d 222222     33333
*        |   e 2222222   333333
*        |   f 22222222 3333333
*        |
*        | 2                     3
*        v
*        +y
*
* If the start of the line lands on the diamond around pixel 0 (shown by
* the '0' region here), pixel 0 is the first pel in the line.  The same
* is true for the other pels.
*
* A little more work has to be done if the line starts in the
* 'nether-land' between the diamonds (as illustrated by the '*' line):
* the first pel lit is the first diamond crossed by the line (pixel 1 in
* our example).  This calculation is determined by the DDA or slope of
* the line.
*
* If the line starts exactly half way between two adjacent pixels
* (denoted here by the '?' spots), the first pixel is determined by our
* round-down convention (and is dependent on the flips done to
* normalize the line).
*
* Last Pel Exclusive
* ------------------
*
* To eliminate repeatedly lit pels between continuous connected lines,
* we employ a last-pel exclusive convention: if the line ends exactly on
* the diamond around a pel, that pel is not lit.  (This eliminates the
* checks we had in the old code to see if we were re-lighting pels.)
*
* The Half Flip
* -------------
*
* To make our run length algorithm more efficient, we employ a "half
* flip".  If after normalizing to the first octant, the slope is more
* than 1/2, we subtract the y coordinate from the x coordinate.  This
* has the effect of reflecting the coordinates through the line of slope
* 1/2.  Note that the diagonal gets mapped into the x-axis after a half
* flip.
*
* How Many Bits Do We Need, Anyway?
* ---------------------------------
*
* Note that if the line is visible on your screen, you must light up
* exactly the correct pixels, no matter where in the 28.4 x 28.4 device
* space the end points of the line lie (meaning you must handle 32 bit
* DDAs, you can certainly have optimized cases for lesser DDAs).
*
* We move the origin to (floor(M0 / F), floor(N0 / F)), so when we
* calculate gamma from (5), we know that 0 <= M0, N0 < F.  And we
* are in the first octant, so dM >= dN.  Then we know that gamma can
* be in the range [(-1/2)dM, (3/2)dM].  The DDI guarantees us that
* valid lines will have dM and dN values at most 31 bits (unsigned)
* of significance.  So gamma requires 33 bits of significance (we store
* this as a 64 bit number for convenience).
*
* When running through the DDA loop, r  + dR can have a value in the
*                                     j
* range 0 <= r  < 2 dN; thus the result must be a 32 bit unsigned value.
*             j
*
* History:
*  4-May-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL bLines(
BMINFO*     pbmi,       // Info about pixel format
POINTFIX*   pptfxFirst, // Start of first line
POINTFIX*   pptfxBuf,   // Pointer to buffer of all remaining lines
RUN*        prun,       // Pointer to runs if doing complex clipping
ULONG       cptfx,      // Count of points in pptfxBuf or runs in prun
LINESTATE*  pls,        // Color and style info
RECTL*      prclClip,   // Clip rectangle if doing simple clipping
PFNSTRIP    *apfn,      // Array of strip functions
FLONG       flStart,    // Flags for each line
CHUNK*      pchBits,    // Pointer to bitmap
LONG        lDelta)     // Offset between rows of pixels (in CHUNKs)
{
    POINTFIX* pptfxBufEnd = pptfxBuf + cptfx;   // Last point in path record
    STYLEPOS  spThis;

    ULONG    M0;
    ULONG    dM;
    ULONG    N0;
    ULONG    dN;
    ULONG    dN_Original;
    ULONG    N1;
    ULONG    M1;
    FLONG    fl;
    LONG     x;
    LONG     y;
    LONGLONG eqGamma;
    LONGLONG eqBeta;
    ULONG    ulDelta;
    ULONG    x0;
    ULONG    y0;
    ULONG    x1;
    ULONG    x0_Original;
    ULONG    y0_Original;
    ULONG    x1_Original;
    POINTL   ptlStart;
    STRIP    strip;
    PFNSTRIP pfn;
    LONG*    plStripEnd;
    ULONGLONG euq;               // Temporary unsigned double-dword variable
    LONGLONG eq;                // Temporary signed double-dword variable

    do {

/***********************************************************************\
* Start the DDA calculations.                                           *
\***********************************************************************/

        M0 = (LONG) pptfxFirst->x;
        dM = (LONG) pptfxBuf->x;

        N0 = (LONG) pptfxFirst->y;
        dN = (LONG) pptfxBuf->y;

        fl = flStart;

        if ((LONG) dM < (LONG) M0)
        {
        // Ensure that we run left-to-right:

            register ULONG ulTmp;
            SWAPL(M0, dM, ulTmp);
            SWAPL(N0, dN, ulTmp);
            fl |= FL_FLIP_H;
        }

    // We now have a line running left-to-right from (M0, N0) to
    // (M0 + dM, N0 + dN):

        if ((LONG) dN < (LONG) N0)
        {
        // Line runs from bottom to top, so flip across y = 0:

            N0 = -(LONG) N0;
            dN = -(LONG) dN;
            fl |= FL_FLIP_V;
        }

    // Compute the deltas.  The DDI says we can never have a valid delta
    // with a magnitude more than 2^31 - 1, but the engine never actually
    // checks its transforms.  To ensure that we'll never puke on our shoes,
    // we check for that case and simply refuse to draw the line:

        dM -= M0;
        if ((LONG) dM < 0)
            goto Next_Line;

        dN -= N0;
        if ((LONG) dN < 0)
            goto Next_Line;

        if (dN >= dM)
        {
            if (dN == dM)
            {
            // Have to special case slopes of one:

                fl |= FL_FLIP_SLOPE_ONE;
            }
            else
            {
            // Since line has slope greater than 1, flip across x = y:

                register ULONG ulTmp;
                SWAPL(dM, dN, ulTmp);
                SWAPL(M0, N0, ulTmp);
                fl |= FL_FLIP_D;
            }
        }

        fl |= gaflRound[(fl & FL_ROUND_MASK) >> FL_ROUND_SHIFT];

        x = LFLOOR((LONG) M0);
        y = LFLOOR((LONG) N0);

        M0 = FXFRAC(M0);
        N0 = FXFRAC(N0);

        {
        // Calculate the remainder term [ dM * (N0 + F/2) - M0 * dN ]:

            eqGamma = Int32x32To64((LONG) dM, N0 + F/2);
            eq = Int32x32To64(M0, (LONG) dN);

            eqGamma -= eq;

            if (fl & FL_V_ROUND_DOWN)
                eqGamma -= 1L;            // Adjust so y = 1/2 rounds down

            eqGamma >>= FLOG2;

            eqBeta = ~eqGamma;
        }

/***********************************************************************\
* Figure out which pixels are at the ends of the line.                  *
\***********************************************************************/

    // Calculate x0, x1:

        N1 = FXFRAC(N0 + dN);
        M1 = FXFRAC(M0 + dM);

        x1 = LFLOOR(M0 + dM);

    // The toughest part of GIQ is determining the start and end pels.
    //
    // Our approach here is to calculate x0 and x1 (the inclusive start
    // and end columns of the line respectively, relative to our normalized
    // origin).  Then x1 - x0 + 1 is the number of pels in the line.  The
    // start point is easily calculated by plugging x0 into our line equation
    // (which takes care of whether y = 1/2 rounds up or down in value)
    // getting y0, and then undoing the normalizing flips to get back
    // into device space.
    //
    // We look at the fractional parts of the coordinates of the start and
    // end points, and call them (M0, N0) and (M1, N1) respectively, where
    // 0 <= M0, N0, M1, N1 < 16.  We plot (M0, N0) on the following grid
    // to determine x0:
    //
    //   +-----------------------> +x
    //   |
    //   | 0                     1
    //   |     0123456789abcdef
    //   |
    //   |   0 ........?xxxxxxx
    //   |   1 ..........xxxxxx
    //   |   2 ...........xxxxx
    //   |   3 ............xxxx
    //   |   4 .............xxx
    //   |   5 ..............xx
    //   |   6 ...............x
    //   |   7 ................
    //   |   8 ................
    //   |   9 ......**........
    //   |   a ........****...x
    //   |   b ............****
    //   |   c .............xxx****
    //   |   d ............xxxx    ****
    //   |   e ...........xxxxx        ****
    //   |   f ..........xxxxxx
    //   |
    //   | 2                     3
    //   v
    //
    //   +y
    //
    // This grid accounts for the appropriate rounding of GIQ and last-pel
    // exclusion.  If (M0, N0) lands on an 'x', x0 = 2.  If (M0, N0) lands
    // on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // For the end point, if (M1, N1) lands on an 'x', x1 =
    // floor((M0 + dM) / 16) + 1.  If (M1, N1) lands on a '.', x1 =
    // floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // Lines of exactly slope one require a special case for both the start
    // and end.  For example, if the line ends such that (M1, N1) is (9, 1),
    // the line has gone exactly through (8, 0) -- which may be considered
    // to be part of 'x' because of rounding!  So slopes of exactly slope
    // one going through (8, 0) must also be considered as belonging in 'x'.
    //
    // For lines that go left-to-right, we have the following grid:
    //
    //   +-----------------------> +x
    //   |
    //   | 0                     1
    //   |     0123456789abcdef
    //   |
    //   |   0 xxxxxxxx?.......
    //   |   1 xxxxxxx.........
    //   |   2 xxxxxx..........
    //   |   3 xxxxx...........
    //   |   4 xxxx............
    //   |   5 xxx.............
    //   |   6 xx..............
    //   |   7 x...............
    //   |   8 x...............
    //   |   9 x.....**........
    //   |   a xx......****....
    //   |   b xxx.........****
    //   |   c xxxx............****
    //   |   d xxxxx...........    ****
    //   |   e xxxxxx..........        ****
    //   |   f xxxxxxx.........
    //   |
    //   | 2                     3
    //   v
    //
    //   +y
    //
    // This grid accounts for the appropriate rounding of GIQ and last-pel
    // exclusion.  If (M0, N0) lands on an 'x', x0 = 0.  If (M0, N0) lands
    // on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // For the end point, if (M1, N1) lands on an 'x', x1 =
    // floor((M0 + dM) / 16) - 1.  If (M1, N1) lands on a '.', x1 =
    // floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // Lines of exactly slope one must be handled similarly to the right-to-
    // left case.

        if (fl & FL_FLIP_H)
        {
        // ---------------------------------------------------------------
        // Line runs right-to-left:  <----

        // Compute x1:

            if (N1 == 0)
            {
                if (LROUND(M1, fl & FL_H_ROUND_DOWN))
                {
                    x1++;
                }
            }
            else if (ABS((LONG) (N1 - F/2)) + M1 > F)
            {
                x1++;
            }

            if ((fl & (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                   == (FL_FLIP_SLOPE_ONE))
            {
            // Have to special-case diagonal lines going through our
            // the point exactly equidistant between two horizontal
            // pixels, if we're supposed to round x=1/2 down:

                if ((N1 > 0) && (M1 == N1 + 8))
                    x1++;

            // Don't you love special cases?  Is this a rhetorical question?

                if ((N0 > 0) && (M0 == N0 + 8))
                {
                    x0      = 2;
                    ulDelta = dN;
                    goto right_to_left_compute_y0;
                }
            }

        // Compute x0:

            x0      = 1;
            ulDelta = 0;
            if (N0 == 0)
            {
                if (LROUND(M0, fl & FL_H_ROUND_DOWN))
                {
                    x0      = 2;
                    ulDelta = dN;
                }
            }
            else if (ABS((LONG) (N0 - F/2)) + M0 > F)
            {
                x0      = 2;
                ulDelta = dN;
            }

        // Compute y0:

        right_to_left_compute_y0:

            y0 = 0;
            eq = eqGamma;
            eq += (LONGLONG) (ULONGLONG) ulDelta;
            if ((eq >> 32) >= 0)
            {
                if ((eq >> 32) > 0 || (ULONG) eq >= 2 * dM - dN)
                    y0 = 2;
                else if ((ULONG) eq >= dM - dN)
                    y0 = 1;
            }
        }
        else
        {
        // ---------------------------------------------------------------
        // Line runs left-to-right:  ---->
        //

        // Compute x1:

            x1--;

            if (M1 > 0)
            {
                if (N1 == 0)
                {
                    if (LROUND(M1, fl & FL_H_ROUND_DOWN))
                        x1++;
                }
                else if (ABS((LONG) (N1 - F/2)) <= (LONG) M1)
                {
                    x1++;
                }
            }

            if ((fl & (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                   == (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
            {
            // Have to special-case diagonal lines going through our
            // the point exactly equidistant between two horizontal
            // pixels, if we're supposed to round x=1/2 down:

                if ((M1 > 0) && (N1 == M1 + 8))
                    x1--;

                if ((M0 > 0) && (N0 == M0 + 8))
                {
                    x0 = 0;
                    goto left_to_right_compute_y0;
                }
            }

        // Compute x0:

            x0 = 0;
            if (M0 > 0)
            {
                if (N0 == 0)
                {
                    if (LROUND(M0, fl & FL_H_ROUND_DOWN))
                        x0 = 1;
                }
                else if (ABS((LONG) (N0 - F/2)) <= (LONG) M0)
                {
                    x0 = 1;
                }
            }

        // Compute y0:

        left_to_right_compute_y0:

            y0 = 0;
            if ((eqGamma>>32) >= 0 &&
                (ULONG) eqGamma >= dM - (dN & (-(LONG) x0)))
            {
                y0 = 1;
            }
        }

        y0_Original = y0;
        x0_Original = x0;
        x1_Original = x1;

        if ((LONG) x1 < (LONG) x0)
            goto Next_Line;

/***********************************************************************\
* Complex Clipping.                                                     *
\***********************************************************************/

        if (fl & FL_COMPLEX_CLIP)
        {
            dN_Original = dN;

        Continue_Complex_Clipping:

            if (fl & FL_FLIP_H)
            {
            // Line runs right-to-left <-----

                x0 = x1_Original - prun->iStop;
                x1 = x1_Original - prun->iStart;
            }
            else
            {
            // Line runs left-to-right ----->

                x0 = x0_Original + prun->iStart;
                x1 = x0_Original + prun->iStop;
            }

            prun++;

        // Reset some variables we'll nuke a little later:

            dN          = dN_Original;
            pls->spNext = pls->spComplex;

            euq = UInt32x32To64(x0, dN);
            euq += eqGamma;

            y0 = DIV(euq,dM);
        }

/***********************************************************************\
* Style calculations.                                                   *
\***********************************************************************/

        if (fl & FL_STYLED)
        {
            ULONG cpelStyleLine;     // # of style pels in entire line
            ULONG cpelStyleFromThis; // # of style pels from first pel of line
            STYLEPOS sp;             // Style state at x0

        // For those rare devices where xStep != yStep, for complex clipped
        // lines that are non-major styled and have multiple runs, we will
        // be doing more work than we have to:

            BOOL bOffStyled = FALSE;

            ULONG xStep = pls->xStep;
            ULONG yStep = pls->yStep;

            spThis = pls->spNext;

            if (fl & FL_FLIP_D)
            {
                register ULONG ulTmp;
                SWAPL(xStep, yStep, ulTmp);
            }

            if (xStep != yStep)
            {
                bOffStyled = UInt32x32To64(yStep, dN) > UInt32x32To64(xStep, dM);
            }

        // xStep is now the major style direction step size.

            if (bOffStyled)
            {
                ULONG y1_Original;

            // We need the original y1, so we simply compute it:

                euq = UInt32x32To64(x1_Original, dN);
                euq += eqGamma;
                y1_Original = DIV(euq,dM);

            // Our line is x-major but y-styled, or y-major and x-styled.
            // We use xStep as the style-major step size, so adjust it:

                xStep = yStep;

                pls->ulStepRun  = 0;
                pls->ulStepSide = xStep;
                pls->ulStepDiag = xStep;

                cpelStyleLine = (y1_Original - y0_Original + 1);

                if (fl & FL_FLIP_H)
                    cpelStyleFromThis = (y1_Original - y0 + 1);
                else
                    cpelStyleFromThis = (y0 - y0_Original);
            }
            else
            {
            // Our line is x-major and x-styled, or y-major and y-styled:

                pls->ulStepRun  = xStep;
                pls->ulStepSide = 0;
                pls->ulStepDiag = xStep;

                cpelStyleLine   = (x1_Original - x0_Original + 1);

                if (fl & FL_FLIP_H)
                    cpelStyleFromThis = (x1_Original - x0 + 1);
                else
                    cpelStyleFromThis = (x0 - x0_Original);
            }

        // Note: we may overflow here if step size is more than 15:

            sp          = pls->spNext + xStep * cpelStyleFromThis;
            pls->spNext = pls->spNext + xStep * cpelStyleLine;

        // Normalize (being sure to cast to unsigned values because
        // we want unsigned divides and positive results even if we
        // overflowed):

            if ((ULONG) sp >= (ULONG) pls->spTotal2)
                sp = (ULONG) sp % pls->spTotal2;

            if ((ULONG) pls->spNext >= (ULONG) pls->spTotal2)
                pls->spNext = (ULONG) pls->spNext % pls->spTotal2;

        // Since we always draw the line left-to-right, but styling is
        // always done in the direction of the original style, we have
        // to figure out where we are in the style array for the left
        // edge of this line:

            if (fl & FL_FLIP_H)
            {
            // Line originally ran right-to-left:

                sp = -sp;
                if (sp < 0)
                    sp += pls->spTotal2;

                pls->bIsGap   = !pls->bStartGap;
                pls->pspStart = &pls->aspRightToLeft[0];
                pls->pspEnd   = &pls->aspRightToLeft[pls->cStyle - 1];
            }
            else
            {
                pls->bIsGap   =  pls->bStartGap;
                pls->pspStart = &pls->aspLeftToRight[0];
                pls->pspEnd   = &pls->aspLeftToRight[pls->cStyle - 1];
            }

        // If the style array is of odd length, and we are on the second
        // (or fourth, or sixth...) pass of the style array, the sense
        // of the current array value is reversed (gap -> dash or dash
        // -> gap):

            if (sp >= pls->spTotal)
            {
                sp -= pls->spTotal;
                if (pls->cStyle & 1)
                    pls->bIsGap = !pls->bIsGap;
            }

        // Find our position in the style array:

            pls->psp = pls->pspStart;
            while (sp >= *pls->psp)
                sp -= *pls->psp++;

            ASSERTGDI(pls->psp <= pls->pspEnd, "Flew into NeverNeverLand");

            pls->spRemaining = *pls->psp - sp;

        // Our position in the style array tells us if we're currently
        // working on a gap or a dash:

            if ((pls->psp - pls->pspStart) & 1)
                pls->bIsGap = !pls->bIsGap;
        }

    // Flip back to device space:

        ptlStart.x = x + x0;
        ptlStart.y = y + y0;

        if (fl & FL_FLIP_D)
        {
            register LONG lTmp;
            SWAPL(ptlStart.x, ptlStart.y, lTmp);
        }

        if (fl & FL_FLIP_V)
        {
            ptlStart.y = -ptlStart.y;
        }

        if (2 * dN > dM)
        {
        // Do a half flip!

            fl |= FL_FLIP_HALF;

            eqBeta  = eqGamma;
            eqBeta -= (LONGLONG) (ULONGLONG) dM;

            dN = dM - dN;
            y0 = x0 - y0;       // Note this may overflow, but that's okay
        }

    // Now, run the DDA starting at (ptlStart.x, ptlStart.y)!

        strip.flFlips   = fl;
        pfn             = apfn[(fl & FL_STRIP_MASK) >> FL_STRIP_SHIFT];

        strip.iPixel    = ptlStart.x & pbmi->maskPixel;
        strip.lDelta    = lDelta;
        strip.pchScreen = pchBits + ptlStart.y * lDelta;

        if (pbmi->cShift < 0)
        {
        // 24bpp takes the address of the first byte:

            strip.pchScreen = (CHUNK*) ((BYTE*) strip.pchScreen + ptlStart.x * 3);
        }
        else
        {
        // All other formats take the address of the first dword:

            strip.pchScreen += (ptlStart.x >> pbmi->cShift);
        }

        plStripEnd = &strip.alStrips[STRIP_MAX];

    // Now calculate the DDA variables needed to figure out how many pixels
    // go in the very first strip:

        {
            register LONG* plStrip = &strip.alStrips[0];
            register LONG  cPels = x1 - x0 + 1;
            register LONG  i;
            register ULONG r;
            register ULONG dI;
            register ULONG dR;

            if (dN == 0)
                i = LONG_MAX;
            else
            {
                euq = UInt32x32To64(y0 + 1, dM);
                euq += eqBeta;

                i = DIVREM(euq, dN, &r) - x0 + 1;

                dI = dM / dN;
                dR = dM % dN;               // 0 <= dR < dN
            }

            ASSERTGDI(i > 0 && i <= LONG_MAX, "Weird start strip length");
            ASSERTGDI(cPels > 0, "Zero cPels");

/***********************************************************************\
* Run the DDA!                                                          *
\***********************************************************************/

            while(TRUE)
            {
                cPels -= i;
                if (cPels <= 0)
                    break;

                *plStrip++ = i;

                if (plStrip == plStripEnd)
                {
                    //Sundown: safe to truncate to LONG since will not exceed cPels
                    strip.cStrips = (LONG)(plStrip - &strip.alStrips[0]);
                    (*pfn)(&strip, pbmi, pls);
                    plStrip = &strip.alStrips[0];
                }

                i = dI;
                r += dR;

                if (r >= dN)
                {
                    r -= dN;
                    i++;
                }
            }

            *plStrip++ = cPels + i;

            //Sundown safe truncation.
            strip.cStrips = (LONG)(plStrip - &strip.alStrips[0]);
            (*pfn)(&strip, pbmi, pls);
        }

    Next_Line:

    // We're done with that run.  Figure out what to do next:

        if (fl & FL_COMPLEX_CLIP)
        {
            cptfx--;
            if (cptfx != 0)
                goto Continue_Complex_Clipping;

            break;
        }
        else
        {
            pptfxFirst = pptfxBuf;
            pptfxBuf++;
        }

    } while (pptfxBuf < pptfxBufEnd);

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\engstrps.cxx ===
/*************************************************************************\
* Module Name: engstrps.cxx
*
* Strip drawing for bitmap simulation
*
* Created: 5-Apr-91
* Author: Paul Butzi
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"
#include "engline.hxx"

/******************************Public*Routine******************************\
* VOID vStripSolidHorizontal(pstrip, pbmi, pls)
*
* Draws a near-horizontal line left to right.
*
* History:
*  22-Feb-1992 -by- J. Andrew Goossen [andrewgo]
* Changed a couple of things.
*
*  5-Apr-1991 -by- Paul Butzi [paulb]
* Wrote it.
\**************************************************************************/

VOID vStripSolidHorizontal(
STRIP*     pstrip,     // Indicates which pixels to light
BMINFO*    pbmi,       // Data and masks for bitmap format
LINESTATE* pls)        // Color and style state info about line
{
    ASSERTGDI(pstrip->cStrips > 0, "Non-positive count");

    LONG* plEnd = &pstrip->alStrips[pstrip->cStrips];
    LONG* pl    = &pstrip->alStrips[0];
    LONG iPixel = pstrip->iPixel;

    LONG cjDelta = pstrip->lDelta * (LONG)sizeof(CHUNK);

    if (pstrip->flFlips & FL_FLIP_V)
	cjDelta = -cjDelta;

    register CHUNK chAnd      = pls->chAnd;
    register CHUNK chXor      = pls->chXor;
    register CHUNK* pchScreen = pstrip->pchScreen;

    register ULONG cChunks;
    register CHUNK maskEnd;
    register CHUNK maskStart = pbmi->pamask[iPixel];

    do {
	iPixel += *pl;

	cChunks = iPixel >> pbmi->cShift;
	iPixel &= pbmi->maskPixel;
	maskEnd = ~(pbmi->pamask[iPixel]);

	if (cChunks == 0)
        {
            MASK mask = maskEnd & maskStart;

            *pchScreen = (*pchScreen & (chAnd | ~mask)) ^ (chXor & mask);
        }
	else
	{
            *pchScreen = (*pchScreen & (chAnd | ~maskStart)) ^
                         (chXor & maskStart);
            pchScreen++;

            for (; cChunks > 1; cChunks--)
            {
                *pchScreen = (*pchScreen & chAnd) ^ chXor;
                pchScreen++;
            }

            if (maskEnd != 0)
            {
                *pchScreen = (*pchScreen & (chAnd | ~maskEnd)) ^
                             (chXor & maskEnd);
            }
        }

    // Done with strip, make side step:

        maskStart  =  ~maskEnd;
        pchScreen = (CHUNK*) ((BYTE*) pchScreen + cjDelta);

    } while (++pl < plEnd);

    pstrip->iPixel = iPixel;
    pstrip->pchScreen = pchScreen;
}

/******************************Public*Routine******************************\
* VOID vStripSolidVertical(pstrip, pbmi, pls)
*
* Draws a near-vertical line left to right.
*
* History:
*  22-Feb-1992 -by- J. Andrew Goossen [andrewgo]
* Changed a couple of things.
*
*  5-Apr-1991 -by- Paul Butzi [paulb]
* Wrote it.
\**************************************************************************/

VOID vStripSolidVertical(
STRIP*     pstrip,     // Indicates which pixels to light
BMINFO*    pbmi,       // Data and masks for bitmap format
LINESTATE* pls)        // Color and style state info about line
{
    ASSERTGDI(pstrip->cStrips > 0, "Non-positive count");

    LONG* plEnd = &pstrip->alStrips[pstrip->cStrips];
    LONG* pl    = &pstrip->alStrips[0];

    LONG cjDelta = pstrip->lDelta * (LONG)sizeof(CHUNK);

    if (pstrip->flFlips & FL_FLIP_V)
	cjDelta = -cjDelta;

    LONG  iPixel      = pstrip->iPixel;
    CHUNK* pchScreen  = pstrip->pchScreen;
    CHUNK chXor       = pls->chXor;
    CHUNK chAnd       = pls->chAnd;

    do {
    // Paint strip:

        MASK maskXor = chXor &  pbmi->pamaskPel[iPixel];
        MASK maskAnd = chAnd | ~pbmi->pamaskPel[iPixel];
        LONG c = *pl;

        do {
            *pchScreen = (*pchScreen & maskAnd) ^ maskXor;
            pchScreen = (CHUNK*) ((BYTE*) pchScreen + cjDelta);

	} while (--c != 0);

    // Done with strip, make side step and recompute masks:

        iPixel++;
        pchScreen += (iPixel >> pbmi->cShift);
        iPixel    &= pbmi->maskPixel;

    } while (++pl < plEnd);

    pstrip->iPixel    = iPixel;
    pstrip->pchScreen = pchScreen;
}

/******************************Public*Routine******************************\
* VOID vStripSolidDiagonal(pstrip, pbmi, pls)
*
* Draws a near-diagonal line left to right.
*
* History:
*  11-May-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vStripSolidDiagonal(
STRIP*     pstrip,     // Indicates which pixels to light
BMINFO*    pbmi,       // Data and masks for bitmap format
LINESTATE* pls)        // Color and style state info about line
{
    ASSERTGDI(pstrip->cStrips > 0, "Non-positive count");

    LONG* plEnd = &pstrip->alStrips[pstrip->cStrips];
    LONG* pl    = &pstrip->alStrips[0];

    LONG cjDelta = pstrip->lDelta * (LONG)sizeof(CHUNK);

    if (pstrip->flFlips & FL_FLIP_V)
	cjDelta = -cjDelta;

    LONG  iPixel      = pstrip->iPixel;
    CHUNK* pchScreen  = pstrip->pchScreen;
    CHUNK chXor       = pls->chXor;
    CHUNK chAnd       = pls->chAnd;

    do {

    // Paint strip:

        register LONG c = *pl;
	while (TRUE)
	{
            MASK maskXor = chXor &  pbmi->pamaskPel[iPixel];
            MASK maskAnd = chAnd | ~pbmi->pamaskPel[iPixel];

            *pchScreen = (*pchScreen & maskAnd) ^ maskXor;

            if (--c == 0)
                break;

            iPixel++;
            pchScreen += (iPixel >> pbmi->cShift);
            iPixel    &= pbmi->maskPixel;
            pchScreen  = (CHUNK*) ((BYTE*) pchScreen + cjDelta);
        }

    // Do a side step:

        if (pstrip->flFlips & FL_FLIP_D)
            pchScreen = (CHUNK*) ((BYTE*) pchScreen + cjDelta);
        else
        {
            iPixel++;
            pchScreen += (iPixel >> pbmi->cShift);
            iPixel    &= pbmi->maskPixel;
        }
    } while (++pl < plEnd);

    pstrip->iPixel    = iPixel;
    pstrip->pchScreen = pchScreen;
}

/******************************Public*Routine******************************\
* VOID vStripStyledHorizontal(pstrip, pbmi, pls)
*
* Draws a styled near-horizontal line left to right.
*
* History:
*  22-Feb-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vStripStyledHorizontal(
STRIP*     pstrip,     // Indicates which pixels to light
BMINFO*    pbmi,       // Data and masks for bitmap format
LINESTATE* pls)        // Color and style state info about line
{
    ASSERTGDI(pstrip->cStrips > 0, "Non-positive count");

    LONG* plEnd = &pstrip->alStrips[pstrip->cStrips];
    LONG* pl    = &pstrip->alStrips[0];
    LONG iPixel = pstrip->iPixel;

    LONG cjDelta = pstrip->lDelta * (LONG)sizeof(CHUNK);

    if (pstrip->flFlips & FL_FLIP_V)
	cjDelta = -cjDelta;

    CHUNK*   pchScreen   = pstrip->pchScreen;
    CHUNK    chAnd       = pls->chAnd;
    CHUNK    chXor       = pls->chXor;
    BOOL     bIsGap      = pls->bIsGap;
    STYLEPOS spRemaining = pls->spRemaining;

    do {
        LONG ll = *pl;

        do {
            if (!bIsGap)
            {
                MASK maskXor = chXor &  pbmi->pamaskPel[iPixel];
                MASK maskAnd = chAnd | ~pbmi->pamaskPel[iPixel];

                *pchScreen = (*pchScreen & maskAnd) ^ maskXor;
            }

            iPixel++;
            pchScreen += iPixel >> pbmi->cShift;
            iPixel &= pbmi->maskPixel;

            spRemaining -= pls->ulStepRun;
            if (spRemaining <= 0)
            {
                if (++pls->psp > pls->pspEnd)
                    pls->psp = pls->pspStart;

                spRemaining += *pls->psp;
                bIsGap = !bIsGap;
            }

        } while (--ll != 0);

    // Done with strip, make side step:

        pchScreen = (CHUNK*) ((BYTE*) pchScreen + cjDelta);

        spRemaining -= pls->ulStepSide;
        if (spRemaining <= 0)
        {
            if (++pls->psp > pls->pspEnd)
                pls->psp = pls->pspStart;

            spRemaining += *pls->psp;
            bIsGap = !bIsGap;
        }
    } while (++pl != plEnd);

    pstrip->iPixel = iPixel;
    pstrip->pchScreen = pchScreen;

    pls->bIsGap       = bIsGap;
    pls->spRemaining  = spRemaining;
}

/******************************Public*Routine******************************\
* VOID vStripStyledVertical(pstrip, pbmi, pls)
*
* Draws a styled near-vertical line left to right.
*
* History:
*  22-Feb-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vStripStyledVertical(
STRIP*     pstrip,     // Indicates which pixels to light
BMINFO*    pbmi,       // Data and masks for bitmap format
LINESTATE* pls)        // Color and style state info about line
{
    ASSERTGDI(pstrip->cStrips > 0, "Non-positive count");

    LONG* plEnd = &pstrip->alStrips[pstrip->cStrips];
    LONG* pl    = &pstrip->alStrips[0];

    LONG cjDelta = pstrip->lDelta * (LONG)sizeof(CHUNK);

    if (pstrip->flFlips & FL_FLIP_V)
	cjDelta = -cjDelta;

    LONG     iPixel      = pstrip->iPixel;
    CHUNK*   pchScreen   = pstrip->pchScreen;
    CHUNK    chXor       = pls->chXor;
    CHUNK    chAnd       = pls->chAnd;
    BOOL     bIsGap      = pls->bIsGap;
    STYLEPOS spRemaining = pls->spRemaining;

    do {
    // Paint strip:

        MASK maskXor = chXor &  pbmi->pamaskPel[iPixel];
        MASK maskAnd = chAnd | ~pbmi->pamaskPel[iPixel];
        LONG c = *pl;

        do {
            if (!bIsGap)
                *pchScreen = (*pchScreen & maskAnd) ^ maskXor;

            pchScreen = (CHUNK*) ((BYTE*) pchScreen + cjDelta);

            spRemaining -= pls->ulStepRun;
            if (spRemaining <= 0)
            {
                if (++pls->psp > pls->pspEnd)
                    pls->psp = pls->pspStart;

                spRemaining += *pls->psp;
                bIsGap = !bIsGap;
            }
	} while (--c != 0);

    // Done with strip, make side step and recompute masks:

        iPixel++;
        pchScreen += (iPixel >> pbmi->cShift);
        iPixel    &= pbmi->maskPixel;

        spRemaining -= pls->ulStepSide;
        if (spRemaining <= 0)
        {
            if (++pls->psp > pls->pspEnd)
                pls->psp = pls->pspStart;

            spRemaining += *pls->psp;
            bIsGap = !bIsGap;
        }
    } while (++pl < plEnd);

    pstrip->iPixel    = iPixel;
    pstrip->pchScreen = pchScreen;

    pls->bIsGap       = bIsGap;
    pls->spRemaining  = spRemaining;
}

/******************************Public*Routine******************************\
* VOID vStripStyledDiagonal(pstrip, pbmi, pls)
*
* Draws a styled near-diagonal line left to right.
*
* History:
*  22-Feb-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vStripStyledDiagonal(
STRIP*     pstrip,     // Indicates which pixels to light
BMINFO*    pbmi,       // Data and masks for bitmap format
LINESTATE* pls)        // Color and style state info about line
{
    ASSERTGDI(pstrip->cStrips > 0, "Non-positive count");

    LONG* plEnd = &pstrip->alStrips[pstrip->cStrips];
    LONG* pl    = &pstrip->alStrips[0];

    LONG cjDelta = pstrip->lDelta * (LONG)sizeof(CHUNK);

    if (pstrip->flFlips & FL_FLIP_V)
	cjDelta = -cjDelta;

    LONG     iPixel      = pstrip->iPixel;
    CHUNK*   pchScreen   = pstrip->pchScreen;
    CHUNK    chXor       = pls->chXor;
    CHUNK    chAnd       = pls->chAnd;
    BOOL     bIsGap      = pls->bIsGap;
    STYLEPOS spRemaining = pls->spRemaining;

    do {

    // Paint strip:

        register LONG c = *pl;
	while (TRUE)
	{
            if (!bIsGap)
            {
                MASK maskXor = chXor &  pbmi->pamaskPel[iPixel];
                MASK maskAnd = chAnd | ~pbmi->pamaskPel[iPixel];

                *pchScreen = (*pchScreen & maskAnd) ^ maskXor;
            }

            if (--c == 0)
                break;

            spRemaining -= pls->ulStepDiag;
            if (spRemaining <= 0)
            {
                if (++pls->psp > pls->pspEnd)
                    pls->psp = pls->pspStart;

                spRemaining += *pls->psp;
                bIsGap = !bIsGap;
            }

            iPixel++;
            pchScreen += (iPixel >> pbmi->cShift);
            iPixel    &= pbmi->maskPixel;
            pchScreen  = (CHUNK*) ((BYTE*) pchScreen + cjDelta);
        }

    // Do a side step:

        spRemaining -= pls->ulStepRun;
        if (spRemaining <= 0)
        {
            if (++pls->psp > pls->pspEnd)
                pls->psp = pls->pspStart;

            spRemaining += *pls->psp;
            bIsGap = !bIsGap;
        }

        if (pstrip->flFlips & FL_FLIP_D)
            pchScreen = (CHUNK*) ((BYTE*) pchScreen + cjDelta);
        else
        {
            iPixel++;
            pchScreen += (iPixel >> pbmi->cShift);
            iPixel    &= pbmi->maskPixel;
        }
    } while (++pl < plEnd);

    pstrip->iPixel    = iPixel;
    pstrip->pchScreen = pchScreen;

    pls->bIsGap       = bIsGap;
    pls->spRemaining  = spRemaining;
}

/******************************Public*Routine******************************\
* VOID vStripSolidHorizontal24(pstrip, pbmi, pls)
*
* Draws a 24bpp near-horizontal line left to right.
*
* If 24bpp line performance is an issue, these routines can be rewritten
* to be a lot more complicated but take better advantage of 32-bit moves.
*
* History:
*  4-May-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vStripSolidHorizontal24(
STRIP*     pstrip,     // Indicates which pixels to light
BMINFO*    pbmi,       // Data and masks for bitmap format
LINESTATE* pls)        // Color and style state info about line
{
    DONTUSE(pbmi);

    ASSERTGDI(pstrip->cStrips > 0, "Non-positive count");

    LONG* plEnd = &pstrip->alStrips[pstrip->cStrips];
    LONG* pl    = &pstrip->alStrips[0];

    LONG cjDelta = pstrip->lDelta * (LONG)sizeof(CHUNK);

    if (pstrip->flFlips & FL_FLIP_V)
	cjDelta = -cjDelta;

    register CHUNK chAnd    = pls->chAnd;
    register CHUNK chXor    = pls->chXor;
    register BYTE* pjScreen = (BYTE*) pstrip->pchScreen;

    do {
        LONG c = *pl;

        do {
            *(pjScreen++) = (*pjScreen & (BYTE) (chAnd))
                                       ^ (BYTE) (chXor);
            *(pjScreen++) = (*pjScreen & (BYTE) (chAnd >> 8))
                                       ^ (BYTE) (chXor >> 8);
            *(pjScreen++) = (*pjScreen & (BYTE) (chAnd >> 16))
                                       ^ (BYTE) (chXor >> 16);

        } while (--c != 0);

        pjScreen += cjDelta;

    } while (++pl < plEnd);

    pstrip->pchScreen = (CHUNK*) pjScreen;
}

/******************************Public*Routine******************************\
* VOID vStripSolidVertical24(pstrip, pbmi, pls)
*
* Draws a 24bpp near-vertical line left to right.
*
* History:
*  4-May-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vStripSolidVertical24(
STRIP*     pstrip,     // Indicates which pixels to light
BMINFO*    pbmi,       // Data and masks for bitmap format
LINESTATE* pls)        // Color and style state info about line
{
    DONTUSE(pbmi);

    ASSERTGDI(pstrip->cStrips > 0, "Non-positive count");

    LONG* plEnd = &pstrip->alStrips[pstrip->cStrips];
    LONG* pl    = &pstrip->alStrips[0];

    LONG cjDelta = pstrip->lDelta * (LONG)sizeof(CHUNK);

    if (pstrip->flFlips & FL_FLIP_V)
	cjDelta = -cjDelta;

// Adjust because we always lay out 2 bytes before adding cjDelta:

    cjDelta -= 2;

    BYTE* pjScreen  = (BYTE*) pstrip->pchScreen;
    CHUNK chXor     = pls->chXor;
    CHUNK chAnd     = pls->chAnd;

    do {
    // Paint strip:

        LONG c = *pl;

        do {
            *(pjScreen++) = (*pjScreen & (BYTE) (chAnd))
                                       ^ (BYTE) (chXor);
            *(pjScreen++) = (*pjScreen & (BYTE) (chAnd >> 8))
                                       ^ (BYTE) (chXor >> 8);
            *(pjScreen)   = (*pjScreen & (BYTE) (chAnd >> 16))
                                       ^ (BYTE) (chXor >> 16);

            pjScreen += cjDelta;

        } while (--c != 0);

    // Done with strip, make side step:

        pjScreen += 3;

    } while (++pl < plEnd);

    pstrip->pchScreen = (CHUNK*) pjScreen;
}

/******************************Public*Routine******************************\
* VOID vStripSolidDiagonal24(pstrip, pbmi, pls)
*
* Draws a 24bpp near-diagonal line left to right.
*
* History:
*  4-May-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vStripSolidDiagonal24(
STRIP*     pstrip,     // Indicates which pixels to light
BMINFO*    pbmi,       // Data and masks for bitmap format
LINESTATE* pls)        // Color and style state info about line
{
    DONTUSE(pbmi);

    ASSERTGDI(pstrip->cStrips > 0, "Non-positive count");

    LONG* plEnd = &pstrip->alStrips[pstrip->cStrips];
    LONG* pl    = &pstrip->alStrips[0];

    LONG cjDelta = pstrip->lDelta * (LONG)sizeof(CHUNK);

    if (pstrip->flFlips & FL_FLIP_V)
	cjDelta = -cjDelta;

    BYTE* pjScreen = (BYTE*) pstrip->pchScreen;
    CHUNK chXor    = pls->chXor;
    CHUNK chAnd    = pls->chAnd;

    do {

    // Paint strip:

        register LONG c = *pl;
	while (TRUE)
	{
            *(pjScreen++) = (*pjScreen & (BYTE) (chAnd))
                                       ^ (BYTE) (chXor);
            *(pjScreen++) = (*pjScreen & (BYTE) (chAnd >> 8))
                                       ^ (BYTE) (chXor >> 8);
            *(pjScreen++) = (*pjScreen & (BYTE) (chAnd >> 16))
                                       ^ (BYTE) (chXor >> 16);

            if (--c == 0)
                break;

            pjScreen += cjDelta;
        }

        if (pstrip->flFlips & FL_FLIP_D)
            pjScreen += cjDelta - 3;

    } while (++pl < plEnd);

    pstrip->pchScreen = (CHUNK*) pjScreen;
}

/******************************Public*Routine******************************\
* VOID vStripStyledHorizontal24(pstrip, pbmi, pls)
*
* Draws a 24bpp styled near-horizontal line left to right.
*
* History:
*  22-Feb-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vStripStyledHorizontal24(
STRIP*     pstrip,     // Indicates which pixels to light
BMINFO*    pbmi,       // Data and masks for bitmap format
LINESTATE* pls)        // Color and style state info about line
{
    DONTUSE(pbmi);

    ASSERTGDI(pstrip->cStrips > 0, "Non-positive count");

    LONG* plEnd = &pstrip->alStrips[pstrip->cStrips];
    LONG* pl    = &pstrip->alStrips[0];

    LONG cjDelta = pstrip->lDelta * (LONG)sizeof(CHUNK);

    if (pstrip->flFlips & FL_FLIP_V)
	cjDelta = -cjDelta;

    CHUNK    chAnd       = pls->chAnd;
    CHUNK    chXor       = pls->chXor;
    BOOL     bIsGap      = pls->bIsGap;
    STYLEPOS spRemaining = pls->spRemaining;
    BYTE*    pjScreen    = (BYTE*) pstrip->pchScreen;

    do {
        LONG ll = *pl;

        do {
            if (bIsGap)
                pjScreen += 3;
            else
            {
                *(pjScreen++) = (*pjScreen & (BYTE) (chAnd))
                                           ^ (BYTE) (chXor);
                *(pjScreen++) = (*pjScreen & (BYTE) (chAnd >> 8))
                                           ^ (BYTE) (chXor >> 8);
                *(pjScreen++) = (*pjScreen & (BYTE) (chAnd >> 16))
                                           ^ (BYTE) (chXor >> 16);
            }

            spRemaining -= pls->ulStepRun;
            if (spRemaining <= 0)
            {
                if (++pls->psp > pls->pspEnd)
                    pls->psp = pls->pspStart;

                spRemaining += *pls->psp;
                bIsGap = !bIsGap;
            }

        } while (--ll != 0);

    // Done with strip, make side step:

        pjScreen += cjDelta;

        spRemaining -= pls->ulStepSide;
        if (spRemaining <= 0)
        {
            if (++pls->psp > pls->pspEnd)
                pls->psp = pls->pspStart;

            spRemaining += *pls->psp;
            bIsGap = !bIsGap;
        }
    } while (++pl != plEnd);

    pstrip->pchScreen = (CHUNK*) pjScreen;

    pls->bIsGap       = bIsGap;
    pls->spRemaining  = spRemaining;
}

/******************************Public*Routine******************************\
* VOID vStripStyledVertical24(pstrip, pbmi, pls)
*
* Draws a 24bpp styled near-vertical line left to right.
*
* History:
*  22-Feb-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vStripStyledVertical24(
STRIP*     pstrip,     // Indicates which pixels to light
BMINFO*    pbmi,       // Data and masks for bitmap format
LINESTATE* pls)        // Color and style state info about line
{
    DONTUSE(pbmi);

    ASSERTGDI(pstrip->cStrips > 0, "Non-positive count");

    LONG* plEnd = &pstrip->alStrips[pstrip->cStrips];
    LONG* pl    = &pstrip->alStrips[0];

    LONG cjDelta = pstrip->lDelta * (LONG)sizeof(CHUNK);

    if (pstrip->flFlips & FL_FLIP_V)
	cjDelta = -cjDelta;

    CHUNK    chXor       = pls->chXor;
    CHUNK    chAnd       = pls->chAnd;
    BOOL     bIsGap      = pls->bIsGap;
    STYLEPOS spRemaining = pls->spRemaining;
    BYTE*    pjScreen    = (BYTE*) pstrip->pchScreen;

    do {
    // Paint strip:

        LONG c = *pl;

        do {
            if (!bIsGap)
            {
                *(pjScreen++) = (*pjScreen & (BYTE) (chAnd))
                                           ^ (BYTE) (chXor);
                *(pjScreen++) = (*pjScreen & (BYTE) (chAnd >> 8))
                                           ^ (BYTE) (chXor >> 8);
                *(pjScreen)   = (*pjScreen & (BYTE) (chAnd >> 16))
                                           ^ (BYTE) (chXor >> 16);
                pjScreen -= 2;
            }
            pjScreen += cjDelta;

            spRemaining -= pls->ulStepRun;
            if (spRemaining <= 0)
            {
                if (++pls->psp > pls->pspEnd)
                    pls->psp = pls->pspStart;

                spRemaining += *pls->psp;
                bIsGap = !bIsGap;
            }
	} while (--c != 0);

    // Done with strip, make side step:

        pjScreen += 3;

        spRemaining -= pls->ulStepSide;
        if (spRemaining <= 0)
        {
            if (++pls->psp > pls->pspEnd)
                pls->psp = pls->pspStart;

            spRemaining += *pls->psp;
            bIsGap = !bIsGap;
        }
    } while (++pl < plEnd);

    pstrip->pchScreen = (CHUNK*) pjScreen;

    pls->bIsGap       = bIsGap;
    pls->spRemaining  = spRemaining;
}

/******************************Public*Routine******************************\
* VOID vStripStyledDiagonal24(pstrip, pbmi, pls)
*
* Draws a 24bpp styled near-diagonal line left to right.
*
* History:
*  22-Feb-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vStripStyledDiagonal24(
STRIP*     pstrip,     // Indicates which pixels to light
BMINFO*    pbmi,       // Data and masks for bitmap format
LINESTATE* pls)        // Color and style state info about line
{
    DONTUSE(pbmi);

    ASSERTGDI(pstrip->cStrips > 0, "Non-positive count");

    LONG* plEnd = &pstrip->alStrips[pstrip->cStrips];
    LONG* pl    = &pstrip->alStrips[0];

    LONG cjDelta = pstrip->lDelta * (LONG)sizeof(CHUNK);

    if (pstrip->flFlips & FL_FLIP_V)
	cjDelta = -cjDelta;

    CHUNK    chXor       = pls->chXor;
    CHUNK    chAnd       = pls->chAnd;
    BOOL     bIsGap      = pls->bIsGap;
    STYLEPOS spRemaining = pls->spRemaining;
    BYTE*    pjScreen    = (BYTE*) pstrip->pchScreen;

    do {

    // Paint strip:

        register LONG c = *pl;
	while (TRUE)
	{
            if (bIsGap)
                pjScreen += 3;
            else
            {
                *(pjScreen++) = (*pjScreen & (BYTE) (chAnd))
                                           ^ (BYTE) (chXor);
                *(pjScreen++) = (*pjScreen & (BYTE) (chAnd >> 8))
                                           ^ (BYTE) (chXor >> 8);
                *(pjScreen++) = (*pjScreen & (BYTE) (chAnd >> 16))
                                           ^ (BYTE) (chXor >> 16);
            }

            if (--c == 0)
                break;

            pjScreen += cjDelta;

            spRemaining -= pls->ulStepDiag;
            if (spRemaining <= 0)
            {
                if (++pls->psp > pls->pspEnd)
                    pls->psp = pls->pspStart;

                spRemaining += *pls->psp;
                bIsGap = !bIsGap;
            }
        }

    // Do a side step:

        spRemaining -= pls->ulStepRun;
        if (spRemaining <= 0)
        {
            if (++pls->psp > pls->pspEnd)
                pls->psp = pls->pspStart;

            spRemaining += *pls->psp;
            bIsGap = !bIsGap;
        }

        if (pstrip->flFlips & FL_FLIP_D)
            pjScreen += cjDelta - 3;

    } while (++pl < plEnd);

    pstrip->pchScreen = (CHUNK*) pjScreen;

    pls->bIsGap       = bIsGap;
    pls->spRemaining  = spRemaining;
}

PFNSTRIP gapfnStrip[] = {

    vStripSolidHorizontal,
    vStripSolidVertical,
    vStripSolidDiagonal,
    vStripSolidDiagonal,

    vStripStyledHorizontal,
    vStripStyledVertical,
    vStripStyledDiagonal,
    vStripStyledDiagonal,

    vStripSolidHorizontal24,
    vStripSolidVertical24,
    vStripSolidDiagonal24,
    vStripSolidDiagonal24,

    vStripStyledHorizontal24,
    vStripStyledVertical24,
    vStripStyledDiagonal24,
    vStripStyledDiagonal24
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\engstrok.cxx ===
/*************************************************************************\
* Module Name: EngStroke.c
*
* EngStrokePath for bitmap simulations, plus its kith.
*
* Created: 5-Apr-91
* Author: Paul Butzi
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"
#include "solline.hxx"
#include "engline.hxx"

// #define DEBUG_ENGSTROK

// Style array for alternate style (alternates one pixel on, one pixel off):

STYLEPOS gaspAlternateStyle[] = { 1 };

// Array to compute ROP masks:

LONG aiLineMix[] = {
    AND_ZERO   | XOR_ONE,
    AND_ZERO   | XOR_ZERO,
    AND_NOTPEN | XOR_NOTPEN,
    AND_NOTPEN | XOR_ZERO,
    AND_ZERO   | XOR_NOTPEN,
    AND_PEN    | XOR_PEN,
    AND_ONE    | XOR_ONE,
    AND_ONE    | XOR_PEN,
    AND_PEN    | XOR_ONE,
    AND_PEN    | XOR_ZERO,
    AND_ONE    | XOR_NOTPEN,
    AND_ONE    | XOR_ZERO,
    AND_PEN    | XOR_NOTPEN,
    AND_ZERO   | XOR_PEN,
    AND_NOTPEN | XOR_ONE,
    AND_NOTPEN | XOR_PEN
};

static CHUNK mask1[] = {
    0xffffffff, 0xffffff7f, 0xffffff3f, 0xffffff1f,
    0xffffff0f, 0xffffff07, 0xffffff03, 0xffffff01,
    0xffffff00, 0xffff7f00, 0xffff3f00, 0xffff1f00,
    0xffff0f00, 0xffff0700, 0xffff0300, 0xffff0100,
    0xffff0000, 0xff7f0000, 0xff3f0000, 0xff1f0000,
    0xff0f0000, 0xff070000, 0xff030000, 0xff010000,
    0xff000000, 0x7f000000, 0x3f000000, 0x1f000000,
    0x0f000000, 0x07000000, 0x03000000, 0x01000000,
    0x00000000,
};

static CHUNK mask4[] = {
    0xffffffff,
    0xffffff0f,
    0xffffff00,
    0xffff0f00,
    0xffff0000,
    0xff0f0000,
    0xff000000,
    0x0f000000,
    0x00000000,
};

static CHUNK mask8[] = {
    0xffffffff,
    0xffffff00,
    0xffff0000,
    0xff000000,
    0x00000000,
};

static CHUNK mask16[] = {
    0xffffffff,
    0xffff0000,
    0x00000000,
};

static CHUNK mask24[] = {
    0xffffff00,
    0x00ffffff,
    0x0000ffff,
    0x000000ff,
    0x00000000,
};

static CHUNK mask32[] = {
    0xffffffff,
    0x00000000,
};

static CHUNK maskpel1[] = {
    0x00000080, 0x00000040, 0x00000020, 0x00000010,
    0x00000008, 0x00000004, 0x00000002, 0x00000001,
    0x00008000, 0x00004000, 0x00002000, 0x00001000,
    0x00000800, 0x00000400, 0x00000200, 0x00000100,
    0x00800000, 0x00400000, 0x00200000, 0x00100000,
    0x00080000, 0x00040000, 0x00020000, 0x00010000,
    0x80000000, 0x40000000, 0x20000000, 0x10000000,
    0x08000000, 0x04000000, 0x02000000, 0x01000000,
    0x00000000,
};

static CHUNK maskpel4[] = {
    0x000000f0,
    0x0000000f,
    0x0000f000,
    0x00000f00,
    0x00f00000,
    0x000f0000,
    0xf0000000,
    0x0f000000,
    0x00000000,
};

static CHUNK maskpel8[] = {
    0x000000ff,
    0x0000ff00,
    0x00ff0000,
    0xff000000,
    0x00000000,
};

static CHUNK maskpel16[] = {
    0x0000ffff,
    0xffff0000,
    0x00000000,
};

static CHUNK maskpel24[] = {
    0x00000000,
    0x00000000,
    0xff000000,
    0xffff0000,
};

static CHUNK maskpel32[] = {
    0xffffffff,
    0x00000000,
};

// { Pointer to array of start masks,
//   Pointer to array of pixel masks,
//   # of pels per chunk (power of 2)
//   # of bits per pel
//   log2(pels per chunk)
//   pels per chunk - 1 }

BMINFO gabminfo[] = {
    { NULL,    NULL,        0,  0,  0,  0  },   // BMF_DEVICE
    { mask1,   maskpel1,    32, 1,  5,  31 },   // BMF_1BPP
    { mask4,   maskpel4,    8,  4,  3,  7  },   // BMF_4BPP
    { mask8,   maskpel8,    4,  8,  2,  3  },   // BMF_8BPP
    { mask16,  maskpel16,   2,  16, 1,  1  },   // BMF_16BPP
    { mask24,  maskpel24,   0,  0, -1,  0  },   // BMF_24BPP
    { mask32,  maskpel32,   1,  32, 0,  0  },   // BMF_32BPP
};

#if (BMF_1BPP != 1L)
error Invalid value for BMF_1BPP
#endif

#if (BMF_4BPP != 2L)
error Invalid value for BMF_4BPP
#endif

#if (BMF_8BPP != 3L)
error Invalid value for BMF_8BPP
#endif

#if (BMF_16BPP != 4L)
error Invalid value for BMF_16BPP
#endif

#if (BMF_24BPP != 5L)
error Invalid value for BMF_24BPP
#endif

#if (BMF_32BPP != 6L)
error Invalid value for BMF_32BPP
#endif



/******************************Public*Routine******************************\
* BOOL bStrokeCosmetic(pso, ppo, eco, pbo, pla, mix)
*
* Strokes the path.
*
* History:
*  20-Mar-1991 -by- Paul Butzi
* Wrote it.
\**************************************************************************/

BOOL bStrokeCosmetic(
SURFACE*   pSurf,
PATHOBJ*   ppo,
CLIPOBJ*   pco,
BRUSHOBJ*  pbo,
LINEATTRS* pla,
MIX        mix)
{
    STYLEPOS  aspLeftToRight[STYLE_MAX_COUNT];
    STYLEPOS  aspRightToLeft[STYLE_MAX_COUNT];
    LINESTATE ls;

// Verify that things are as they should be:

    ASSERTGDI(pbo->iSolidColor != 0xFFFFFFFF, "Expect solid cosmetic pen");
    ASSERTGDI(!(pla->fl & LA_GEOMETRIC) && !(ppo->fl & PO_BEZIERS),
              "Unprocessable path");

    FLONG fl = 0;

// Look after styling initialization:

    if (pla->fl & LA_ALTERNATE)
    {
        ls.bStartGap      = 0;                      // First pel is a dash
        ls.cStyle         = 1;                      // Size of style array
        ls.xStep          = 1;                      // x-styled step size
        ls.yStep          = 1;                      // y-styled step size
        ls.spTotal        = 1;                      // Sum of style array
        ls.spTotal2       = 2;                      // Twice the sum
        ls.aspRightToLeft = &gaspAlternateStyle[0]; // Right-to-left array
        ls.aspLeftToRight = &gaspAlternateStyle[0]; // Left-to-right array
        ls.spNext         = HIWORD(pla->elStyleState.l) & 1;
                                                    // Light first pixel if
                                                    //   a multiple of 2
        ls.xyDensity      = 1;                      // Each 'dot' is one pixel
                                                    //   long
        fl               |= FL_STYLED;
    }
    else if (pla->pstyle != (FLOAT_LONG*) NULL)
    {
        ASSERTGDI(pla->cstyle <= STYLE_MAX_COUNT, "Style array too large");

        {
            HDEV hdev = ((SURFACE *)pSurf)->hdev();

            if (hdev == 0)
            {
            // It is a pretty common mistake made by driver writers
            // (I've made it several times myself) to call EngStrokePath
            // on a temporary bitmap that it forgot to EngAssociateSurface.

                WARNING("Can't get at the physical device information!\n");
                WARNING("I'll bet the display/printer driver forgot to call");
                WARNING("EngAssociateSurface for a bitmap it created, and");
                WARNING("is now asking us to draw styled lines on it (we");
                WARNING("need the device's style information).\n");
                RIP("Please call EngAssociateSurface on the bitmap.");

            // Assume some defaults:

                ls.xStep     = 1;
                ls.yStep     = 1;
                ls.xyDensity = 3;
            }
            else
            {
            // We need the PDEV style information so that we can draw
            // the styles with the correct length dashes:

                PDEVOBJ po(hdev);

                ls.xStep     = po.xStyleStep();
                ls.yStep     = po.yStyleStep();
                ls.xyDensity = po.denStyleStep();

                ASSERTGDI(ls.xyDensity != 0,
                          "Invalid denStyleStep supplied by the device!");
            }
        }

        fl               |= FL_STYLED;
        ls.cStyle         = pla->cstyle;
        ls.bStartGap      = (pla->fl & LA_STARTGAP) > 0;
        ls.aspRightToLeft = aspRightToLeft;
        ls.aspLeftToRight = aspLeftToRight;

        FLOAT_LONG* pstyle  = pla->pstyle;
        STYLEPOS*   pspDown = &ls.aspRightToLeft[ls.cStyle - 1];
        STYLEPOS*   pspUp   = &ls.aspLeftToRight[0];

        ls.spTotal = 0;

        while (pspDown >= &ls.aspRightToLeft[0])
        {
            ASSERTGDI(pstyle->l > 0 && pstyle->l <= STYLE_MAX_VALUE,
                      "Illegal style array value");

            *pspDown    = pstyle->l * ls.xyDensity;
            *pspUp      = *pspDown;
            ls.spTotal += *pspDown;

            pspUp++;
            pspDown--;
            pstyle++;
        }

        ls.spTotal2 = 2 * ls.spTotal;

    // Compute starting style position (this is guaranteed not to overflow):

        ls.spNext = HIWORD(pla->elStyleState.l) * ls.xyDensity +
                    LOWORD(pla->elStyleState.l);

    // Do some normalizing:

        if (ls.spNext < 0)
        {
            RIP("Someone left style state negative");
            ls.spNext = 0;
        }

        if (ls.spNext >= ls.spTotal2)
            ls.spNext %= ls.spTotal2;
    }

    // Get device all warmed up and ready to go

    LONG   lOldStyleState = pla->elStyleState.l;
    ULONG  ulFormat       = pSurf->iFormat();
    LONG   lDelta         = pSurf->lDelta() / (LONG)sizeof(CHUNK);
    CHUNK* pchBits        = (CHUNK*)pSurf->pvScan0();

    BMINFO* pbmi = &gabminfo[ulFormat];
    CHUNK  chOriginalColor = pbo->iSolidColor;

    switch (ulFormat)
    {
    case BMF_1BPP:
        chOriginalColor |= (chOriginalColor << 1);
        chOriginalColor |= (chOriginalColor << 2);
        // fall thru
    case BMF_4BPP:
        chOriginalColor |= (chOriginalColor << 4);
        // fall thru
    case BMF_8BPP:
        chOriginalColor |= (chOriginalColor << 8);
        // fall thru
    case BMF_16BPP:
        chOriginalColor |= (chOriginalColor << 16);
        // fall thru
    case BMF_24BPP:
    case BMF_32BPP:
        break;
    default:
        RIP("Invalid bitmap format");
    }

    {
        // All ROPs are handled in a single pass.

        CHUNK achColor[4];

        achColor[AND_ZERO]   =  0;
        achColor[AND_PEN]    =  chOriginalColor;
        achColor[AND_NOTPEN] = ~chOriginalColor;
        achColor[AND_ONE]    =  0xffffffff;

        LONG iIndex = aiLineMix[mix & 0xf];

        ls.chAnd = achColor[(iIndex & 0xff)];
        ls.chXor = achColor[iIndex >> MIX_XOR_OFFSET];
    }

    // Figure out which set of strippers to use:

    LONG iStrip = (ulFormat == BMF_24BPP) ? 8 : 0;
    iStrip |= (fl & FL_STYLED) ? 4 : 0;

    PFNSTRIP* apfn = &gapfnStrip[iStrip];

    if ((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL))
    {
        // Handle complex clipping!

        BOOL bMore;
        union {
            BYTE     aj[sizeof(CLIPLINE) + (RUN_MAX - 1) * sizeof(RUN)];
            CLIPLINE cl;
        } cl;

        fl |= FL_COMPLEX_CLIP;

        ((ECLIPOBJ*) pco)->vEnumPathStart(ppo, pSurf, pla);

        do {
            bMore = ((ECLIPOBJ*) ((EPATHOBJ*)ppo)->pco)->bEnumPath(ppo,
                                   sizeof(cl), &cl.cl);

            if (cl.cl.c != 0)
            {
                if (fl & FL_STYLED)
                {
                    ls.spComplex = HIWORD(cl.cl.lStyleState) * ls.xyDensity
                                 + LOWORD(cl.cl.lStyleState);
                }
                if (!bLines(pbmi,
                            &cl.cl.ptfxA,
                            &cl.cl.ptfxB,
                            &cl.cl.arun[0],
                            cl.cl.c,
                            &ls,
                            (RECTL*) NULL,
                            apfn,
                            fl,
                            pchBits,
                            lDelta))
                    return(FALSE);
            }
        } while (bMore);
    }
    else
    {
        // Handle simple or trivial clipping!

        PATHDATA  pd;
        BOOL      bMore;
        ULONG     cptfx;
        POINTFIX  ptfxStartFigure;
        POINTFIX  ptfxLast;
        POINTFIX* pptfxFirst;
        POINTFIX* pptfxBuf;

        pd.flags = 0;
        ((EPATHOBJ*) ppo)->vEnumStart();

        do {
            bMore = ((EPATHOBJ*) ppo)->bEnum(&pd);

            cptfx = pd.count;
            if (cptfx == 0)
            {
                ASSERTGDI(!bMore, "Empty path record in non-empty path");
                break;
            }

            if (pd.flags & PD_BEGINSUBPATH)
            {
                ptfxStartFigure  = *pd.pptfx;
                pptfxFirst       = pd.pptfx;
                pptfxBuf         = pd.pptfx + 1;
                cptfx--;
            }
            else
            {
                pptfxFirst       = &ptfxLast;
                pptfxBuf         = pd.pptfx;
            }

            if (pd.flags & PD_RESETSTYLE)
                ls.spNext = 0;

            // We have to check for cptfx == 0 because the only point in the
            // subpath may have been the StartFigure point:

            if (cptfx > 0)
            {
                if (!bLines(pbmi,
                            pptfxFirst,
                            pptfxBuf,
                            (RUN*) NULL,
                            cptfx,
                            &ls,
                            NULL,
                            apfn,
                            fl,
                            pchBits,
                            lDelta))
                    return(FALSE);
            }

            ptfxLast = pd.pptfx[pd.count - 1];

            if (pd.flags & PD_CLOSEFIGURE)
            {
                if (!bLines(pbmi,
                            &ptfxLast,
                            &ptfxStartFigure,
                            (RUN*) NULL,
                            1,
                            &ls,
                            NULL,
                            apfn,
                            fl,
                            pchBits,
                            lDelta))
                    return(FALSE);
            }
        } while (bMore);

        if (fl & FL_STYLED)
        {
            // Save the style state:

            ULONG ulHigh = ls.spNext / ls.xyDensity;
            ULONG ulLow  = ls.spNext % ls.xyDensity;

            pla->elStyleState.l = MAKELONG(ulLow, ulHigh);
        }
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL EngStrokePath(pso, ppo, pco, pxo, pbo, pptlBrushOrg, pla, mix)
*
* Strokes the path.
*
* History:
*  5-Apr-1992 -by- J. Andrew Goossen
* Wrote it.
\**************************************************************************/

BOOL EngStrokePath(
SURFOBJ   *pso,
PATHOBJ   *ppo,
CLIPOBJ   *pco,
XFORMOBJ  *pxo,
BRUSHOBJ  *pbo,
PPOINTL    pptlBrushOrg,
PLINEATTRS pla,
MIX        mix)
{
    ASSERTGDI(pso != (SURFOBJ *) NULL, "EngStrokePath: surface\n");
    ASSERTGDI(ppo != (PATHOBJ *) NULL, "EngStrokePath: path\n");
    ASSERTGDI(pbo != (BRUSHOBJ *) NULL, "EngStrokePath: brushobj\n");

    PSURFACE pSurf = SURFOBJ_TO_SURFACE(pso);

    if (pla->fl & LA_GEOMETRIC)
    {
        // Handle wide lines, remembering that the widened bounds have
        // already been computed:

        if (!((EPATHOBJ*) ppo)->bWiden(pxo, pla))
            return(FALSE);

        return(EngFillPath(pSurf->pSurfobj(),
                           ppo,
                           pco,
                           pbo,
                           pptlBrushOrg,
                           mix,
                           WINDING));
    }

    if (ppo->fl & PO_BEZIERS)
        if (!((EPATHOBJ*) ppo)->bFlatten())
            return(FALSE);

    if (pSurf->iType() != STYPE_BITMAP)
    {
        // It's a cosmetic line to a device-managed surface.  The DDI
        // requires that the driver support DrvStrokePath for cosmetic
        // lines if it has any device-managed surfaces:

        PDEVOBJ po(pSurf->hdev());

        ASSERTGDI(PPFNVALID(po, StrokePath),
            "Driver must hook DrvStrokePath if it supports device-managed surfaces");

        return((*PPFNDRV(po, StrokePath))(pSurf->pSurfobj(),
                                          ppo,
                                          pco,
                                          pxo,
                                          pbo,
                                          pptlBrushOrg,
                                          pla,
                                          mix));
    }

    // Before we touch any bits, make sure the device is happy about it.
    {
        PDEVOBJ po(pSurf->hdev());
        po.vSync(pso,NULL, 0);
    }

    // If this is a single pixel wide solid color line
    // with trivial or simple clipping then call solid line routine:

    if (((mix & 0xFF) == R2_COPYPEN)                         &&
        ((pco == NULL) || (pco->iDComplexity != DC_COMPLEX)) &&
        (pla->pstyle == NULL)                                &&
        !(pla->fl & LA_ALTERNATE))
    {
        vSolidLine(pSurf,
                  ppo,
                  NULL,
                  pco,
                  pbo->iSolidColor);

        return(TRUE);
    }

    return(bStrokeCosmetic(pSurf, ppo, pco, pbo, pla, mix));
}

/******************************Public*Routine******************************\
* BOOL EngLineTo(pso, pco, pbo, x1, y1, x2, y2, prclBounds, mix)
*
* Draws a single solid integer-only cosmetic line.
*
* History:
*
*  12-Sept-1996 -by- Tom Zakrajsek
* Made it work for device managed surfaces.
*
*  4-June-1995 -by- J. Andrew Goossen
* Wrote it.
\**************************************************************************/

BOOL EngLineTo(
SURFOBJ   *pso,
CLIPOBJ   *pco,
BRUSHOBJ  *pbo,
LONG       x1,
LONG       y1,
LONG       x2,
LONG       y2,
RECTL     *prclBounds,
MIX        mix)
{
    GDIFunctionID(EngLineTo);
    ASSERTGDI(pso != (SURFOBJ *) NULL, "pso is NULL\n");

    BOOL bReturn;
    PSURFACE pSurf = SURFOBJ_TO_SURFACE(pso);
    LINEATTRS la;
    PATHOBJ* ppo;
    POINTFIX aptfx[2];

    bReturn = FALSE;

    aptfx[0].x = x1 << 4;
    aptfx[0].y = y1 << 4;
    aptfx[1].x = x2 << 4;
    aptfx[1].y = y2 << 4;

    if (pSurf->iType() != STYPE_BITMAP)
    {
        // Device managed surface

        {
            // Solid cosmetic lines have everything zeroed in the LINEATTRS:

            memset(&la, 0, sizeof(LINEATTRS));
            la.elWidth.l = 1;

            // Create a path that describes the line:

            ppo = EngCreatePath();
            if (ppo != NULL)
            {
                if (PATHOBJ_bMoveTo(ppo, aptfx[0]) &&
                    PATHOBJ_bPolyLineTo(ppo, &aptfx[1], 1))
                {
                    PDEVOBJ  pdo(pSurf->hdev());
                    ECLIPOBJ  eco;
                    RGNMEMOBJTMP rmoTmp;

                    // StrokePath is guaranteed not to get a NULL clip
                    // object, so construct a temporary one:

                    if (pco == NULL)
                    {
                        if (rmoTmp.bValid())
                        {
                            rmoTmp.vSet(prclBounds);
                            eco.vSetup(rmoTmp.prgnGet(),
                                       *(ERECTL *) prclBounds);

                            pco = &eco;
                        }
                    }

                    // Clip may still be NULL if RGNMEMOBJTMP constructor
                    // failed, so need to check:

                    if (pco)
                    {
                        bReturn = (*PPFNGET(pdo,StrokePath,pSurf->flags())) (
                                            pso,
                                            ppo,
                                            pco,
                                            NULL,   // pxo
                                            pbo,
                                            NULL,   // pptlBrush
                                            &la,
                                            mix);
                    }
                }

                EngDeletePath(ppo);
            }
        }
    }
    else
    {
        // Engine managed surface

        // Before we touch any bits, make sure the device is happy about it.
        {
            PDEVOBJ po(pSurf->hdev());
            po.vSync(pso,NULL,0);
        }

        if (((pco == NULL) || (pco->iDComplexity != DC_COMPLEX)) &&
            (mix == 0x0d0d))
        {
            // If this is a single pixel wide solid color line
            // with trivial or simple clipping then call solid line routine:

            vSolidLine(pSurf,
                      NULL,
                      aptfx,
                      pco,
                      pbo->iSolidColor);

            bReturn = TRUE;
        }
        else
        {
            // Solid cosmetic lines have everything zeroed in the LINEATTRS:

            memset(&la, 0, sizeof(LINEATTRS));

            // Create a path that describes the line:

            ppo = EngCreatePath();
            if (ppo != NULL)
            {
                if (PATHOBJ_bMoveTo(ppo, aptfx[0]) &&
                    PATHOBJ_bPolyLineTo(ppo, &aptfx[1], 1))
                {
                    bReturn = bStrokeCosmetic(pSurf, ppo, pco, pbo, &la, mix);
                }

                EngDeletePath(ppo);
            }
        }
    }

    return(bReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\fastfill.cxx ===
/******************************Module*Header*******************************\
* Module Name: ffillddi.cxx
*
*   routines for filling a polygon without building a region.
*
* Created: 12-Oct-1993 09:46:44
* Author:  Eric Kutter [erick]
*
* Copyright (c) 1993-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

extern ULONG aulShiftFormat[];
extern ULONG aulMulFormat[];

typedef VOID (*PFN_FF)(PRECTL,ULONG,PVOID);
typedef VOID (*PFN_FFROW)(LONG,PROW,ULONG,PVOID);

PFN_PATBLT apfnPatRect[][3] =
{
    { NULL,         NULL,         NULL         },
    { NULL,         NULL,         NULL         },
    { NULL,         NULL,         NULL         },
    { vPatCpyRect8, vPatNotRect8, vPatXorRect8 },
    { vPatCpyRect8, vPatNotRect8, vPatXorRect8 },
    { vPatCpyRect8, vPatNotRect8, vPatXorRect8 },
    { vPatCpyRect8, vPatNotRect8, vPatXorRect8 }
};

PFN_PATBLTROW apfnPatRow[][3] =
{
    { NULL,         NULL,         NULL         },
    { NULL,         NULL,         NULL         },
    { NULL,         NULL,         NULL         },
    { vPatCpyRow8, vPatNotRow8, vPatXorRow8 },
    { vPatCpyRow8, vPatNotRow8, vPatXorRow8 },
    { vPatCpyRow8, vPatNotRow8, vPatXorRow8 },
    { vPatCpyRow8, vPatNotRow8, vPatXorRow8 }
};

BOOL bEngFastFillEnum(
    EPATHOBJ &epo,
    PRECTL   prclClip,
    FLONG    flOptions,
    PFN_FF   pfn,
    PFN_FFROW pfnRow,
    PVOID    pv);


/******************************Public*Routine******************************\
* vPaintPath
*
*   fill a path - This dispatches through bEngFastFillEnum which calls
*   back to either vPaintPathEnum or vPaintPathEnumRow.  vPaintPathEnum
*   takes a list of rectangles, vPaintPathEnumRow takes a list of rows.
*
* History:
*  12-Oct-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

typedef struct _PPAINT_PATH
{
    PFN_SOLIDBLT   pfn;
    PFN_SOLIDBLTROW pfnRow;
    LONG         lDelta;
    ULONG        cShift;
    ULONG        iColor;
    PBYTE        pjBits;
} PAINT_PATH, *PPAINT_PATH;


VOID vPaintPathEnum(
    PRECTL prcl,
    ULONG  crcl,
    PVOID  pv)
{
    PPAINT_PATH ppp = (PPAINT_PATH)pv;


    (*ppp->pfn)(
            prcl,
            crcl,
            ppp->pjBits,
            ppp->lDelta,
            ppp->iColor,
            ppp->cShift);
}

VOID vPaintPathEnumRow(
    LONG   yTop,
    PROW   prow,
    ULONG  cptl,
    PVOID  pv)
{
    PPAINT_PATH ppp = (PPAINT_PATH)pv;

    (*ppp->pfnRow)(prow,cptl,yTop,ppp->pjBits,ppp->iColor,ppp->lDelta,ppp->cShift);
}

BOOL bPaintPath(
    SURFACE *pSurf,
    PATHOBJ *ppo,
    PRECTL  prclClip,
    ULONG   iColor,
    BOOL    bXor,
    FLONG   flOptions)
{
    PAINT_PATH pp;

// Get the shift for the format

    pp.cShift = aulShiftFormat[pSurf->iFormat()];

// Promote the color to 32 bits

    switch(pSurf->iFormat())
    {
    case BMF_1BPP:

        if (iColor)
            iColor = 0xFFFFFFFF;
        break;

    case BMF_4BPP:
        iColor = iColor | (iColor << 4);

    case BMF_8BPP:
        iColor = iColor | (iColor << 8);

    case BMF_16BPP:
        iColor = iColor | (iColor << 16);
    }

    if (bXor)
        if (pSurf->iFormat() == BMF_24BPP)
        {
            pp.pfn   = vSolidXorRect24;
            pp.pfnRow = vSolidXorRow24;
        }
        else
        {
            pp.pfn   = vSolidXorRect1;
            pp.pfnRow = vSolidXorRow1;
        }
    else
        if (pSurf->iFormat() == BMF_24BPP)
        {
            pp.pfn   = vSolidFillRect24;
            pp.pfnRow = vSolidFillRow24;
        }
        else
        {
            pp.pfn   = vSolidFillRect1;
            pp.pfnRow = vSolidFillRow1;
        }


    pp.pjBits = (PBYTE) pSurf->pvScan0();
    pp.iColor = iColor;
    pp.lDelta = pSurf->lDelta();

    return(bEngFastFillEnum(
        *(EPATHOBJ *)ppo,
        prclClip,
        flOptions,
        vPaintPathEnum,
        vPaintPathEnumRow,
        (PVOID)&pp));
}

/******************************Public*Routine******************************\
* vBrushPath
*
*   fill a path with a brush - This dispatches through bEngFastFillEnum which
*   calls back to either vBrushPathEnum or vBrushPathEnumRow.  vBrushPathEnum
*   takes a list of rectangles, vBrushPathEnumRow takes a list of rows.
*
* History:
*  12-Oct-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

typedef struct _PBRUSH_PATH
{
    PFN_PATBLT   pfn;
    PFN_PATBLTROW pfnRow;
    PATBLTFRAME pbf;

} BRUSH_PATH, *PBRUSH_PATH;


VOID vBrushPathEnum(
    PRECTL prcl,
    ULONG  crcl,
    PVOID  pv)
{
    PBRUSH_PATH pbp = (PBRUSH_PATH)pv;

    for (UINT i = 0; i < crcl; i++)
    {
        pbp->pbf.pvObj = (PVOID) prcl++;
        (*pbp->pfn)(&pbp->pbf);
    }
}

VOID vBrushPathEnumRow(
    LONG   yTop,
    PROW   prow,
    ULONG  cptl,
    PVOID  pv)
{
    PBRUSH_PATH pbp = (PBRUSH_PATH)pv;

    pbp->pbf.pvObj = (PVOID) prow;
    (*pbp->pfnRow)(&pbp->pbf,yTop,(INT)cptl);
}

BOOL bBrushPath(
    SURFACE  *pSurf,
    PATHOBJ  *ppo,
    PRECTL  prclClip,
    BRUSHOBJ *pbo,
    POINTL   *pptl,
    ULONG     iMode,
    FLONG     flOptions)
{
    BRUSH_PATH bp;

// Get the multiplier for the format

    bp.pbf.cMul      = aulMulFormat[pSurf->iFormat()];
    bp.pbf.pvTrg     = pSurf->pvScan0();
    bp.pbf.lDeltaTrg = pSurf->lDelta();
    bp.pbf.pvPat     = (PVOID) ((EBRUSHOBJ *) pbo)->pengbrush()->pjPat;
    bp.pbf.lDeltaPat = ((EBRUSHOBJ *) pbo)->pengbrush()->lDeltaPat;
    bp.pbf.cxPat     = ((EBRUSHOBJ *) pbo)->pengbrush()->cxPat * bp.pbf.cMul;
    bp.pbf.cyPat     = ((EBRUSHOBJ *) pbo)->pengbrush()->cyPat;
    bp.pbf.xPat      = pptl->x * bp.pbf.cMul;
    bp.pbf.yPat      = pptl->y;

// Weird: The following code checks for xPat<0 and yPat<0, but it
// doesn't check for xPat>=cxPat or yPat>=cyPat. Both cases are probably
// handled lower down the call chain, but I can't be sure. So I've left the
// code here (after correcting it).

    if (bp.pbf.xPat < 0)
        bp.pbf.xPat  = bp.pbf.cxPat-1 - ((-bp.pbf.xPat - 1) % bp.pbf.cxPat);

    if (bp.pbf.yPat < 0)
        bp.pbf.yPat  = bp.pbf.cyPat-1 - ((-bp.pbf.yPat - 1) % bp.pbf.cyPat);

    bp.pfn   = apfnPatRect[pSurf->iFormat()][iMode];
    bp.pfnRow = apfnPatRow[pSurf->iFormat()][iMode];

    return(bEngFastFillEnum(
        *(EPATHOBJ *)ppo,
        prclClip,
        flOptions,
        vBrushPathEnum,
        vBrushPathEnumRow,
        (PVOID)&bp));
}

/******************************Public*Routine******************************\
* vBrushPathN_8x8
*
*   fill a path with a brush - This dispatches through bEngFastFillEnum which
*   calls back to either vBrushPathEnum or vBrushPathEnumRow.  vBrushPathEnum
*   takes a list of rectangles, vBrushPathEnumRow takes a list of rows.
*
* History:
*  12-Oct-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

typedef struct _BRUSH_PATH_8x8
{
    PFN_PATBLT2 pfn;
    PATBLTFRAME pbf;

} BRUSH_PATH_8x8, *PBRUSH_PATH_8x8;

VOID vBrushPath4_8x8Enum(
    PRECTL prcl,
    ULONG  crcl,
    PVOID  pv)
{
    PBRUSH_PATH_8x8 pb8 = (PBRUSH_PATH_8x8)pv;

    pb8->pbf.pvObj = (PVOID) prcl;
    vPatCpyRect4_8x8(&pb8->pbf, (INT) crcl);
}

VOID vBrushPath8_8x8Enum(
    PRECTL prcl,
    ULONG  crcl,
    PVOID  pv)
{
    PBRUSH_PATH_8x8 pb8 = (PBRUSH_PATH_8x8)pv;

    pb8->pbf.pvObj = (PVOID) prcl;
    vPatCpyRect8_8x8(&pb8->pbf, (INT) crcl);
}

VOID vBrushPath4_8x8EnumRow(
    LONG   yTop,
    PROW   prow,
    ULONG  cptl,
    PVOID  pv)
{
    PBRUSH_PATH_8x8 pb8 = (PBRUSH_PATH_8x8)pv;

    pb8->pbf.pvObj = (PVOID) prow;
    vPatCpyRow4_8x8(&pb8->pbf, yTop,(INT) cptl);
}

VOID vBrushPath8_8x8EnumRow(
    LONG   yTop,
    PROW   prow,
    ULONG  cptl,
    PVOID  pv)
{
    PBRUSH_PATH_8x8 pb8 = (PBRUSH_PATH_8x8)pv;

    pb8->pbf.pvObj = (PVOID) prow;
    vPatCpyRow8_8x8(&pb8->pbf, yTop,(INT) cptl);
}


BOOL bBrushPathN_8x8(
    SURFACE  *pSurf,
    PATHOBJ  *ppo,
    PRECTL   prclClip,
    BRUSHOBJ *pbo,
    POINTL   *pptlBrush,
    ULONG     iFormat,
    FLONG     flOptions)
{
    BRUSH_PATH_8x8 b8;
    PFN_FF         pfnFF    = vBrushPath4_8x8Enum;
    PFN_FFROW      pfnFFRow = vBrushPath4_8x8EnumRow;

    b8.pbf.pvTrg = pSurf->pvScan0();
    b8.pbf.lDeltaTrg = pSurf->lDelta();
    b8.pbf.pvPat = (PVOID) ((EBRUSHOBJ *) pbo)->pengbrush()->pjPat;

// Force the X and Y pattern origin coordinates into the ranges 0-7 and 0-7,
// so we don't have to do modulo arithmetic all over again at a lower level

    b8.pbf.xPat = pptlBrush->x & 0x07;
    b8.pbf.yPat = pptlBrush->y & 0x07;

// if format ius 8BPP then use 8Bpp fill routines

    if (iFormat == BMF_8BPP) {
        pfnFF    = vBrushPath8_8x8Enum;
        pfnFFRow = vBrushPath8_8x8EnumRow;
    }

    return(bEngFastFillEnum(
        *(EPATHOBJ *)ppo,
        prclClip,
        flOptions,
        pfnFF,
        pfnFFRow,
        (PVOID)&b8));
}

/******************************Public*Routine******************************\
* EngFastFill()
*
*   Fill a path clipped to at most one rectangle.  If the fill is a mode
*   that this routine supports, the vBrushPath, bPaintPath, or vBrushPath_8x8
*   will be called.  This routines setup a filling structure and call
*   the path enumeration code.  The path enumeration code in turn, calls back
*   to a specific filling routine which fills either a list of rectangles
*   or a list of rows (left,right pairs).  If it is a convex polygon with less
*   than 40 points, bFastFill is used, otherwise the slower bFill is used.
*
* returns:
*   -1    if unsupported mode for fastfill, should breakup into a region
*   true  if the fill has been performed.
*   false an error occured
*
* History:
*  12-Oct-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

LONG EngFastFill(
    SURFOBJ  *pso,
    PATHOBJ  *ppo,
    PRECTL   prcl,
    BRUSHOBJ *pdbrush,
    POINTL   *pptlBrush,
    MIX       mix,
    FLONG     flOptions)
{
    PSURFACE pSurf = SURFOBJ_TO_SURFACE(pso);

    LONG lRes = -1;

    ROP4 rop4 = gaMix[(mix >> 8) & 0x0F];
    rop4 = rop4 << 8;
    rop4 = rop4 | ((ULONG) gaMix[mix & 0x0F]);

    if (pso->iType == STYPE_BITMAP)
    {
        switch (rop4)
        {
        case 0x0000:    // Black
            lRes = (LONG)bPaintPath(pSurf, ppo,prcl, 0, FALSE,flOptions);
            break;

        case 0x0F0F:    // Pn
            if (pdbrush->iSolidColor != 0xFFFFFFFF)
            {
                lRes = (LONG)bPaintPath(pSurf,ppo, prcl, ~pdbrush->iSolidColor, FALSE,flOptions);
            }
            else if (pSurf->iFormat() >= BMF_8BPP)
            {
                if (pvGetEngRbrush(pdbrush))    // Can we use this brush?
                {
                    if (((EBRUSHOBJ *) pdbrush)->pengbrush()->cxPat >= 4)
                    {
                        lRes = (LONG)bBrushPath(pSurf, ppo,prcl, pdbrush, pptlBrush, DPA_PATNOT,flOptions);
                    }
                }
            }

            break;

        case 0x5555:    // Dn
            lRes = (LONG)bPaintPath(pSurf, ppo,prcl, (ULONG)~0, TRUE,flOptions);
            break;

        case 0x5A5A:    // DPx
            if (pdbrush->iSolidColor != 0xFFFFFFFF)
            {
                lRes = (LONG)bPaintPath(pSurf, ppo,prcl, pdbrush->iSolidColor, TRUE,flOptions);
            }
            else if (pSurf->iFormat() >= BMF_8BPP)
            {
                if (pvGetEngRbrush(pdbrush))    // Can we use this brush?
                {
                    if (((EBRUSHOBJ *) pdbrush)->pengbrush()->cxPat >= 4)
                    {
                        lRes = (LONG)bBrushPath(pSurf, ppo, prcl, pdbrush, pptlBrush, DPA_PATXOR,flOptions);
                    }
                }
            }

            break;

        case 0xAAAA:    // D
            lRes = TRUE;
            break;

        case 0xF0F0:    // P
            if (pdbrush->iSolidColor != 0xFFFFFFFF)
            {
                lRes = (LONG)bPaintPath(pSurf, ppo,prcl, pdbrush->iSolidColor, FALSE,flOptions);
            }
            else if ( (pSurf->iFormat() == BMF_4BPP) ||
                      (pSurf->iFormat() == BMF_8BPP) )

            {

            // We only support 8x8 DIB4 patterns with SRCCOPY right now

                if (pvGetEngRbrush(pdbrush) != NULL)
                {
                    if ((((EBRUSHOBJ *) pdbrush)->pengbrush()->cxPat == 8) &&
                        (((EBRUSHOBJ *) pdbrush)->pengbrush()->cyPat == 8))
                    {
                        lRes = (LONG)bBrushPathN_8x8(
                                                     pSurf,
                                                     ppo,
                                                     prcl,
                                                     pdbrush,
                                                     pptlBrush,
                                                     pSurf->iFormat(),
                                                     flOptions
                                                    );

                    }
                }
            }
            else if (pSurf->iFormat() >= BMF_8BPP)
            {
                if (pvGetEngRbrush(pdbrush))    // Can we use this brush?
                {
                    if (((EBRUSHOBJ *) pdbrush)->pengbrush()->cxPat >= 4)
                    {
                        lRes = (LONG)bBrushPath(pSurf, ppo,prcl, pdbrush, pptlBrush, DPA_PATCOPY, flOptions);
                    }
                }
            }

            break;

        case 0xFFFF:    // White
            lRes = (LONG)bPaintPath(pSurf, ppo,prcl, (ULONG)~0, FALSE,flOptions);
            break;
        }
    }

    return(lRes);
}

/******************************Public*Routine******************************\
* bFastFill()
*
*   Fills a convex polygon quickly.  Calls pfnRow with lists of adjacent
*   rows, pfn if a verticle rectangle is found.
*
* returns:
*   true  if it is a simple polygon and has been drawn
*   false if it is too complex.
*
* History:
*  12-Oct-1993 -by-  Eric Kutter [erick]
* initial code stolen from s3 driver.
\**************************************************************************/

BOOL bMsg = FALSE;

BOOL bFastFill(
    LONG      cEdges,       // Includes close figure edge
    POINTFIX* pptfxFirst,
    PRECTL    prclClip,
    PFN_FF    pfn,
    PFN_FFROW pfnRow,
    PVOID     pv)
{
    LONG      cyTrapezoid;  // Number of scans in current trapezoid
    LONG      yStart;       // y-position of start point in current edge
    LONG      dM;           // Edge delta in FIX units in x direction
    LONG      dN;           // Edge delta in FIX units in y direction
    LONG      i;
    POINTFIX* pptfxLast;    // Points to the last point in the polygon array
    POINTFIX* pptfxTop;     // Points to the top-most point in the polygon
    POINTFIX* pptfxOld;     // Start point in current edge
    POINTFIX* pptfxScan;    // Current edge pointer for finding pptfxTop
    LONG      cScanEdges;   // Number of edges scanned to find pptfxTop
                            //  (doesn't include the closefigure edge)
    LONG      lQuotient;
    LONG      lRemainder;

    EDGEDATA  aed[2];       // DDA terms and stuff
    EDGEDATA* ped;

    pptfxScan = pptfxFirst;
    pptfxTop  = pptfxFirst;                 // Assume for now that the first
                                            //  point in path is the topmost
    pptfxLast = pptfxFirst + cEdges - 1;

    LONG yCurrent;

    // 'pptfxScan' will always point to the first point in the current
    // edge, and 'cScanEdges' will the number of edges remaining, including
    // the current one:

    cScanEdges = cEdges - 1;     // The number of edges, not counting close figure

    if ((pptfxScan + 1)->y > pptfxScan->y)
    {
        // Collect all downs:

        do {
            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        // Collect all ups:

        do {
            if (--cScanEdges == 0)
                goto SetUpForFillingCheck;
            pptfxScan++;
        } while ((pptfxScan + 1)->y <= pptfxScan->y);

        // Collect all downs:

        pptfxTop = pptfxScan;

        do {
            if ((pptfxScan + 1)->y > pptfxFirst->y)
                break;

            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        return(FALSE);
    }
    else
    {
        // Collect all ups:

        do {
            pptfxTop++;                 // We increment this now because we
                                        //  want it to point to the very last
                                        //  point if we early out in the next
                                        //  statement...
            if (--cScanEdges == 0)
                goto SetUpForFilling;
        } while ((pptfxTop + 1)->y <= pptfxTop->y);

        // Collect all downs:

        pptfxScan = pptfxTop;
        do {
            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        // Collect all ups:

        do {
            if ((pptfxScan + 1)->y < pptfxFirst->y)
                break;

            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y <= pptfxScan->y);

        return(FALSE);
    }

SetUpForFillingCheck:

    // We check to see if the end of the current edge is higher
    // than the top edge we've found so far:

    if ((pptfxScan + 1)->y < pptfxTop->y)
        pptfxTop = pptfxScan + 1;

SetUpForFilling:

    // Make sure we initialize the DDAs appropriately:

#define RIGHT 0
#define LEFT  1

    aed[LEFT].cy  = 0;
    aed[RIGHT].cy = 0;

    // For now, guess as to which is the left and which is the right edge:

    aed[LEFT].dptfx  = -(LONG) sizeof(POINTFIX);
    aed[RIGHT].dptfx = sizeof(POINTFIX);
    aed[LEFT].pptfx  = pptfxTop;
    aed[RIGHT].pptfx = pptfxTop;

// setup the rectangles for enumeration

    #define MAXROW 40
    RECTL  rclClip;

    ROW     arow[MAXROW];
    PROW    prow = arow;
    ULONG   crow = 0;
    LONG    yTop = 0;

    yCurrent = (pptfxTop->y + 15) >> 4;

    if (prclClip)
    {
        rclClip = *prclClip;
        if (rclClip.top > yCurrent)
            yCurrent = rclClip.top;

        if (yCurrent >= rclClip.bottom)
            return(TRUE);
    }
    else
    {
        rclClip.top    = NEG_INFINITY;
        rclClip.bottom = POS_INFINITY;
    }

// if there is clipping, remove all edges above rectangle

    if (prclClip)
    {
        for (LONG iEdge = 1; iEdge >= 0; iEdge--)
        {
            ped = &aed[iEdge];

            for (;;)
            {
                if (cEdges == 0)
                    return(TRUE);

            // find the next edge

                POINTFIX *pptfxNew = (POINTFIX*) ((BYTE*) ped->pptfx + ped->dptfx);

                if (pptfxNew < pptfxFirst)
                    pptfxNew = pptfxLast;
                else if (pptfxNew > pptfxLast)
                    pptfxNew = pptfxFirst;

            // we have found one that intersects the rect

                if ((pptfxNew->y >> 4) >= rclClip.top)
                    break;

            // the bottom is outside the cliprect, throw it away and get the next

                cEdges--;
                ped->pptfx = pptfxNew;
            };
        }
    }

// now do the real work.  We must loop through all edges.

NextEdge:

    // We loop through this routine on a per-trapezoid basis.

    for (LONG iEdge = 1; iEdge >= 0; iEdge--)
    {
        ped = &aed[iEdge];
        if (ped->cy == 0)
        {
            // Need a new DDA:

            do {
                cEdges--;
                if ((cEdges < 0) || (yCurrent >= rclClip.bottom))
                {
                // flush the batch
                    if (crow > 0)
                        (*pfnRow)(yTop,arow,crow,pv);

                    return(TRUE);
                }

                // Find the next left edge, accounting for wrapping:

                pptfxOld = ped->pptfx;
                ped->pptfx = (POINTFIX*) ((BYTE*) ped->pptfx + ped->dptfx);

                if (ped->pptfx < pptfxFirst)
                    ped->pptfx = pptfxLast;
                else if (ped->pptfx > pptfxLast)
                    ped->pptfx = pptfxFirst;

                // Have to find the edge that spans yCurrent:

                ped->cy = ((ped->pptfx->y + 15) >> 4) - yCurrent;

                // With fractional coordinate end points, we may get edges
                // that don't cross any scans, in which case we try the
                // next one:

            } while (ped->cy <= 0);

            // 'pptfx' now points to the end point of the edge spanning
            // the scan 'yCurrent'.

            dN = ped->pptfx->y - pptfxOld->y;
            dM = ped->pptfx->x - pptfxOld->x;

            ASSERTGDI(dN > 0, "Should be going down only");

            // Compute the DDA increment terms:

            if (dM < 0)
            {
                dM = -dM;
                if (dM < dN)                // Can't be '<='
                {
                    ped->dx       = -1;
                    ped->lErrorUp = dN - dM;
                }
                else
                {
                    QUOTIENT_REMAINDER(dM, dN, lQuotient, lRemainder);

                    ped->dx       = -lQuotient;     // - dM / dN
                    ped->lErrorUp = lRemainder;     // dM % dN
                    if (ped->lErrorUp > 0)
                    {
                        ped->dx--;
                        ped->lErrorUp = dN - ped->lErrorUp;
                    }
                }
            }
            else
            {
                if (dM < dN)                // Can't be '<='
                {
                    ped->dx       = 0;
                    ped->lErrorUp = dM;
                }
                else
                {
                    QUOTIENT_REMAINDER(dM, dN, lQuotient, lRemainder);

                    ped->dx       = lQuotient;      // dM / dN
                    ped->lErrorUp = lRemainder;     // dM % dN
                }
            }

            ped->lErrorDown = dN; // DDA limit
            ped->lError     = -1; // Error is initially zero (add dN - 1 for
                                  //  the ceiling, but subtract off dN so that
                                  //  we can check the sign instead of comparing
                                  //  to dN)

            ped->x = pptfxOld->x;
            yStart = pptfxOld->y;

            if ((yStart & 15) != 0)
            {
                // Advance to the next integer y coordinate

                for (i = 16 - (yStart & 15); i > 0; i--)
                {
                    ped->x      += ped->dx;
                    ped->lError += ped->lErrorUp;
                    if (ped->lError >= 0)
                    {
                        ped->lError -= ped->lErrorDown;
                        ped->x++;
                    }
                }
            }

            if ((ped->x & 15) != 0)
            {
                ped->lError -= ped->lErrorDown * (16 - (ped->x & 15));
                ped->x += 15;       // We'll want the ceiling in just a bit...
            }

            // Chop off those fractional bits:

            ped->x      >>= 4;
            ped->lError >>= 4;

        // advance to the top

            yStart = (yStart + 15) >> 4;

            if (yStart < rclClip.top)
            {
                LONG yDelta = rclClip.top - yStart;

            // if x must change, advance to the x by the height of the trap

                if (((ped->pptfx->y >> 4) >= rclClip.top) ||
                    ped->dx || ped->lErrorUp)
                {
                    ped->x += ped->dx * yDelta;

                    LONGLONG eqerr = Int32x32To64(ped->lErrorUp,yDelta);
                    eqerr += (LONGLONG) ped->lError;

                    if (eqerr >= 0)
                    {
                    // warning.  This divide is extremely expensive
                        // NTFIXED 269540 02-02-2000 pravins  GDI-some long
                        // wide geometric lines dont show up in dibsections
                        // We now shift eqerr by 31 bits to the right to see if
                        // the it cannot be just cast as a LONG.

                        if (eqerr >> 31)
                        {
                            // Cannot cast eqerr as a LONG
                            ULONG ulRemainder;
                            eqerr = DIVREM(eqerr,ped->lErrorDown,&ulRemainder);

                            ped->lError = ulRemainder - ped->lErrorDown;
                            ped->x += (LONG)eqerr + 1;
                        }
                        else
                        {
                            // Can cast eqerr as a LONG.
                            ped->x += (LONG) eqerr / ped->lErrorDown + 1;
                            ped->lError = (LONG) eqerr % ped->lErrorDown - ped->lErrorDown;
                        }
                    }
                    else
                        ped->lError = (LONG) eqerr;
                }

            #if DBG
                if (bMsg)
                {
                    DbgPrint("x = %ld, e = %ld, eU = %ld, eD = %ld, cy = %ld, yD = %ld\n",
                              ped->x,ped->lError,ped->lErrorUp, ped->lErrorDown,ped->cy,yDelta);
                    DbgPrint("ptfxold.y = 0x%lx, ptfx.y = 0x%lx, yStart = %ld, yCurrent = %ld\n",
                              pptfxOld->y,ped->pptfx->y,yStart,yCurrent);
                }
            #endif
            }
        }
    }

    cyTrapezoid = min(aed[LEFT].cy, aed[RIGHT].cy); // # of scans in this trap
    aed[LEFT].cy  -= cyTrapezoid;
    aed[RIGHT].cy -= cyTrapezoid;

// make sure we never go off the bottom

    if ((yCurrent + cyTrapezoid) > rclClip.bottom)
        cyTrapezoid = rclClip.bottom - yCurrent;

// If the left and right edges are vertical, simply output as a rectangle:

    if (((aed[LEFT].lErrorUp | aed[RIGHT].lErrorUp) == 0) &&
        ((aed[LEFT].dx       | aed[RIGHT].dx) == 0) &&
        (cyTrapezoid > 2))
    {
    // must flush any existing rows since rows must be contiguous

        if (crow)
        {
            (*pfnRow)(yTop,arow,crow,pv);
            prow = arow;
            crow = 0;
        }

        LONG xL = aed[LEFT].x;
        LONG xR = aed[RIGHT].x;

        if (xL != xR)
        {
            if (xL > xR)
            {
                LONG l = xL;
                xL = xR;
                xR = l;
            }

        // check if we are clipped

            RECTL rcl;
            rcl.top    = yCurrent;
            rcl.bottom = yCurrent+cyTrapezoid;

            if (prclClip)
            {
                rcl.left   = (xL >= rclClip.left)  ? xL : rclClip.left;
                rcl.right  = (xR <= rclClip.right) ? xR : rclClip.right;

                if (rcl.left < rcl.right)
                    (*pfn)(&rcl,1,pv);
            }
            else
            {
                rcl.left   = xL;
                rcl.right  = xR;
                (*pfn)(&rcl,1,pv);
            }
        }

        yCurrent += cyTrapezoid;

    // done with the current trapezoid

        goto NextEdge;
    }

// make sure we reset yTop when necessary

    if (crow == 0)
        yTop = yCurrent;

// now run the dda, anytime a row is empty, we need to flush the batch

    while (TRUE)
    {
        LONG lWidth = aed[RIGHT].x - aed[LEFT].x;

        if (lWidth > 0)
        {
        // handle the unclipped case quickly

            if (!prclClip)
            {
                prow->left   = aed[LEFT].x;
                prow->right  = aed[RIGHT].x;
                ++crow;
                ++prow;

            CheckForFlush:

                if (crow == MAXROW)
                {
                // flush the batch

                    (*pfnRow)(yTop,arow,crow,pv);
                    prow = arow;
                    crow = 0;
                    yTop = yCurrent + 1;
                }

            ContinueAfterZero:

                // Advance the right wall:

                aed[RIGHT].x      += aed[RIGHT].dx;
                aed[RIGHT].lError += aed[RIGHT].lErrorUp;

                if (aed[RIGHT].lError >= 0)
                {
                    aed[RIGHT].lError -= aed[RIGHT].lErrorDown;
                    aed[RIGHT].x++;
                }

                // Advance the left wall:

                aed[LEFT].x      += aed[LEFT].dx;
                aed[LEFT].lError += aed[LEFT].lErrorUp;

                if (aed[LEFT].lError >= 0)
                {
                    aed[LEFT].lError -= aed[LEFT].lErrorDown;
                    aed[LEFT].x++;
                }

                cyTrapezoid--;
                ++yCurrent;

                if (cyTrapezoid == 0)
                    goto NextEdge;

                continue;
            }
            else
            {
            // we are clipped.  Need to do some real work

                prow->left   = (aed[LEFT].x >= rclClip.left)  ? aed[LEFT].x : rclClip.left;
                prow->right  = (aed[RIGHT].x <= rclClip.right) ? aed[RIGHT].x : rclClip.right;

                if (prow->left < prow->right)
                {
                    ++crow;
                    ++prow;
                    goto CheckForFlush;
                }
                else
                {
                // NULL scan - we must flush the batch

                    if (crow)
                    {
                        (*pfnRow)(yTop,arow,crow,pv);
                        prow = arow;
                        crow = 0;
                    }

                    yTop = yCurrent+1;

                // check if we are donewith this trapezoid,
                // if the trap is fully left or fully right

                    if (((aed[LEFT].x < rclClip.left) &&
                         ((aed[LEFT].pptfx->x >> 4) < rclClip.left) &&
                         ((aed[RIGHT].pptfx->x >> 4) < rclClip.left)) ||
                        ((aed[LEFT].x  >= rclClip.right) &&
                         ((aed[LEFT].pptfx->x >> 4) >= rclClip.right) &&
                         ((aed[RIGHT].pptfx->x >> 4) >= rclClip.right)))
                    {
                        yCurrent += cyTrapezoid;

                        goto NextEdge;
                    }
                    goto ContinueAfterZero;
                }
            }

        }
        else if (lWidth == 0)
        {
        // NULL scan - we must flush the batch

            if (crow)
            {
                (*pfnRow)(yTop,arow,crow,pv);
                prow = arow;
                crow = 0;
            }

            yTop = yCurrent + 1;

            goto ContinueAfterZero;
        }
        else
        {
            #define SWAP(a, b, tmp) { tmp = a; a = b; b = tmp; }

            // We certainly don't want to optimize for this case because we
            // should rarely get self-intersecting polygons (if we're slow,
            // the app gets what it deserves):

            EDGEDATA edTmp;
            SWAP(aed[LEFT],aed[RIGHT],edTmp);

            continue;
        }
    }
}


/******************************Public*Routine******************************\
* bFill()
*
*   Fill a path the slow way.  This handles arbitrary paths, builds up a list
*   of rectangles, and calls pfn.
*
*   This code is very similar to RGNMEMOBJ::vCreate.
*
* History:
*  07-Oct-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL bFill(
    EPATHOBJ& po,
    PRECTL    prclClip,
    FLONG     flOptions,  // ALTERNATE or WINDING
    PFN_FF    pfn,
    PVOID     pv)
{
    EDGE AETHead;       // dummy head/tail node & sentinel for Active Edge Table
    EDGE *pAETHead;     // pointer to AETHead
    EDGE GETHead;       // dummy head/tail node & sentinel for Global Edge Table
    EDGE *pGETHead;     // pointer to GETHead
    EDGE aEdge[MAX_POINTS];

// Allocate memory for edge storage.

    BOOL bAlloc;
    EDGE *pFreeEdges;   // pointer to memory free for use to store edges

    if (po.cCurves <= MAX_POINTS)
    {
        pFreeEdges = &aEdge[0];
        bAlloc     = FALSE;
    }
    else
    {
        pFreeEdges = (PEDGE)PALLOCNOZ(sizeof(EDGE) * po.cCurves,'gdeG');
        if (pFreeEdges == (PEDGE)NULL)
            return(FALSE);
        bAlloc     = TRUE;
    }

// setup the rectangles for enumeration

    #define MAXRECT 20
    RECTL  arcl[MAXRECT];
    PRECTL prcl = arcl;
    ULONG  crcl = 0;
    RECTL  rclClip;
    RECTL rclBounds,*prclBounds;

    if (prclClip)
    {
        rclClip = *prclClip;

    // we'll pass this to vConstructGET which will clip edges to the top and
    // bottom of the clip rect

        rclBounds.top = prclClip->top << 4;          //we need GIQ coordinats
        rclBounds.bottom = prclClip->bottom << 4;
        prclBounds = &rclBounds;
    }
    else
    {
        rclClip.top    = NEG_INFINITY;
        rclClip.bottom = POS_INFINITY;
        prclBounds = NULL;
    }

// Construct the global edge list.

    pGETHead = &GETHead;
    vConstructGET(po, pGETHead, pFreeEdges,prclBounds);    // bad line coordinates or

    LONG yTop = NEG_INFINITY;   // scan line for which we're currently scanning

// Create an empty AET with the head node also a tail sentinel

    pAETHead = &AETHead;
    AETHead.pNext = pAETHead;   // mark that the AET is empty
    AETHead.Y = 0;              // used as a count for number of edges in AET
    AETHead.X = 0x7FFFFFFF;     // this is greater than any valid X value, so
                                //  searches will always terminate

// Loop through all the scans in the polygon, adding edges from the GET to
// the Active Edge Table (AET) as we come to their starts, and scanning out
// the AET at each scan into a rectangle list. Each time it fills up, the
// rectangle list is passed to the filling routine, and then once again at
// the end if any rectangles remain undrawn. We continue so long as there
// are edges to be scanned out.

    while ( 1 )
    {
    // Advance the edges in the AET one scan, discarding any that have
    // reached the end (if there are any edges in the AET)

        if (AETHead.pNext != pAETHead)
            vAdvanceAETEdges(pAETHead);

    // If the AET is empty, done if the GET is empty, else jump ahead to
    // the next edge in the GET; if the AET isn't empty, re-sort the AET

        if (AETHead.pNext == pAETHead)
        {
        // Done if there are no edges in either the AET or the GET

            if (GETHead.pNext == pGETHead)
                break;

        // There are no edges in the AET, so jump ahead to the next edge in
        // the GET.

            yTop = ((EDGE *)GETHead.pNext)->Y;

        }
        else
        {
        // Re-sort the edges in the AET by X coordinate, if there are at
        // least two edges in the AET (there could be one edge if the
        // balancing edge hasn't yet been added from the GET)

            if (((EDGE *)AETHead.pNext)->pNext != pAETHead)
                vXSortAETEdges(pAETHead);
        }

    // Move any new edges that start on this scan from the GET to the AET;
    // bother calling only if there's at least one edge to add

        if (((EDGE *)GETHead.pNext)->Y == yTop)
            vMoveNewEdges(pGETHead, pAETHead, yTop);

    // Scan the AET into region scans (there's always at least one
    // edge pair in the AET)

        EDGE *pCurrentEdge = AETHead.pNext;   // point to the first edge

        do {

        // The left edge of any given edge pair is easy to find; it's just
        // wherever we happen to be currently

            LONG iLeftEdge = (int)pCurrentEdge->X;

        // Find the matching right edge according to the current fill rule

            if ((flOptions & FP_WINDINGMODE) != 0)
            {
                LONG lWindingCount;

            // Do winding fill; scan across until we've found equal numbers
            // of up and down edges

                lWindingCount = pCurrentEdge->lWindingDirection;
                do {
                    pCurrentEdge = pCurrentEdge->pNext;
                    lWindingCount += pCurrentEdge->lWindingDirection;
                } while (lWindingCount != 0);

            }
            else
            {
            // Odd-even fill; the next edge is the matching right edge

                pCurrentEdge = pCurrentEdge->pNext;
            }

        // See if the resulting span encompasses at least one pixel, and
        // add it to the list of rectangles to draw if so

            if (iLeftEdge < pCurrentEdge->X)
            {
            // Add the rectangle representing the current edge pair

                if (prclClip)
                {
                    prcl->left   = (iLeftEdge >= rclClip.left)  ? iLeftEdge : rclClip.left;
                    prcl->right  = (pCurrentEdge->X <= rclClip.right) ? pCurrentEdge->X : rclClip.right;;
                    prcl->top    = yTop;
                    prcl->bottom = yTop+1;

                    if (prcl->left < prcl->right)
                    {
                        ++crcl;
                        ++prcl;
                    }
                }
                else
                {
                    prcl->left   = iLeftEdge;
                    prcl->right  = pCurrentEdge->X;
                    prcl->top    = yTop;
                    prcl->bottom = yTop+1;
                    ++crcl;
                    ++prcl;
                }

                if (crcl == MAXRECT)
                {
                // flush the batch

                    (*pfn)(arcl,crcl,pv);
                    prcl = arcl;
                    crcl = 0;
                }
            }
        } while ((pCurrentEdge = pCurrentEdge->pNext) != pAETHead);

        yTop++;    // next scan
    }

// flush the final batch
    if (crcl > 0)
        (*pfn)(arcl,crcl,pv);

    if (bAlloc)
        VFREEMEM(pFreeEdges);

    return(TRUE);
}

/******************************Member*Function*****************************\
* bEngFastFillEnum()
*
*   fill in the path.  If the path only has one sub path and fewer than 40
*   points, try bFastFill.  If we can't use bFastFill, do it the slow way
*   through bFill().
*
* History:
*  27-Sep-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

#define QUICKPOINTS 40

BOOL bEngFastFillEnum(
    EPATHOBJ &epo,
    PRECTL   prclClip,
    FLONG    flOptions,
    PFN_FF   pfn,
    PFN_FFROW pfnRow,
    PVOID    pv)
{
    PATHDATA pd;
    BOOL     bRes = FALSE;

// check if there is anything to do

    if (epo.cCurves < 2)
        return(TRUE);

// see if we can do it through fastfill

    epo.vEnumStart();

    if (epo.bEnum(&pd))
    {
        // if this ends the sub path, that means there is more than one sub path.
        // also don't handle if we can't copy points onto stack

        if (!(pd.flags & PD_ENDSUBPATH) && (epo.cCurves <= QUICKPOINTS))
        {
            POINTFIX aptfx[QUICKPOINTS];
            LONG cPoints;
            BOOL bMore;

            RtlCopyMemory(aptfx,pd.pptfx,(SIZE_T)pd.count*sizeof(POINTFIX));
            cPoints = pd.count;

            do {
                bMore = epo.bEnum(&pd);

                if (pd.flags & PD_BEGINSUBPATH)
                {
                    cPoints = 0;
                    break;
                }

                RtlCopyMemory(aptfx+cPoints,pd.pptfx,(SIZE_T)pd.count*sizeof(POINTFIX));
                cPoints += pd.count;

            } while(bMore);

            ASSERTGDI(cPoints <= QUICKPOINTS,"bFastFillWrapper - too many points\n");

            if (cPoints)
                bRes = bFastFill(cPoints,aptfx,prclClip,pfn,pfnRow,pv);
        }
    }
    else if (pd.count > 1)
    {
        bRes = bFastFill(pd.count,pd.pptfx,prclClip,pfn,pfnRow,pv);
    }
    else
    {
        bRes = TRUE;
    }

// did we succeed with fast fill?

    if (bRes == FALSE)
    {
        bRes = bFill(epo,prclClip,flOptions,pfn,pv);
    }

    return(bRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\flinkgdi.cxx ===
/*****************************************************************************
* Module Name: fontlink.cxx
*
* FontLink (EUDC) API's for NT graphics engine.
*
* History:
*
*  1-18-96 Gerrit van Wingerden   Moved to kernel mode.
*  1-14-96 Hideyuki Nagase        Add Font Association emulation features.
*  1-09-95 Hideyuki Nagase        Rewrote it for new fontlink features.
*  1-04-94 Hideyuki Nagase        Update for Daytona fontlink.
*  2-10-93 Gerrit van Wingerden   Wrote it.
*
* Copyright (c) 1993-1999 Microsoft Corporation
*****************************************************************************/

#include "precomp.hxx"

#ifdef FE_SB

LONG lNormAngle(LONG lAngle);
VOID vInitializeFontAssocStatus(VOID);

#define EUDC_USER_REGISTRY_KEY   \
     L"\\EUDC\\"
#define EUDC_SYSTEM_REGISTRY_KEY \
     L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\FontLink\\SystemLink"
#define FONT_ASSOC_REGISTRY_KEY \
     L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\FontAssoc"

#define DEFAULT_EUDC_FONT L"EUDC.TTE"

extern PFONT_ASSOC_SUB pFontAssocSubs;


HSEMAPHORE ghsemEUDC1;
HSEMAPHORE ghsemEUDC2;

// used to signal the EUDC API's that it is okay to change EUDC link data

// used to protects gappfeSysEUDC[] and gawcEUDCPath
//  - This mutex should be locked during referring above two values without
//   holding ghsemEUDC1. and updating above two data anytime.


// used to protects BaseFontListHead
//  - This mutex should be locked during referring above list without
//   holding ghsemEUDC1. and updating above list anytime.

LONG  gcEUDCCount   = 0;
BOOL  gbAnyLinkedFonts = FALSE;

// Global variables for System EUDC.


// FontLink Configuration value.

ULONG ulFontLinkControl = 0L;
ULONG ulFontLinkChange  = 0L;


// HPFE for system EUDC font.

PFE *gappfeSysEUDC[2] = { PPFENULL , PPFENULL };

// Path of system EUDC font

WCHAR gawcEUDCPath[MAX_PATH+1];

// QUICKLOOKUP for system EUDC font && TT System Font

QUICKLOOKUP gqlEUDC;
QUICKLOOKUP gqlTTSystem;

// System eudc uniq number

ULONG ulSystemEUDCTimeStamp = 0;

// FaceName eudc uniq number

ULONG ulFaceNameEUDCTimeStamp = 0;

// Global variables for FaceName EUDC.

// Count of face name links in the system
UINT  gcNumLinks = 0;

// Pointer to list of base font list

LIST_ENTRY BaseFontListHead = { (PLIST_ENTRY)&BaseFontListHead ,
                                (PLIST_ENTRY)&BaseFontListHead };

LIST_ENTRY NullListHead = { (PLIST_ENTRY)&NullListHead ,
                            (PLIST_ENTRY)&NullListHead };

WCHAR gawcSystemACP[10];

// Eudc Default Unicode codepoint

WCHAR EudcDefaultChar = 0x30fb;

RTL_QUERY_REGISTRY_TABLE SharedQueryTable[2];

extern BOOL bSetupDefaultFlEntry(VOID);
extern WCHAR gawcSystemDBCSFontPath[MAX_PATH];

//
// global EUDC debugging flags
//
#if DBG
FLONG gflEUDCDebug = 0x0000;
FLONG gflDumpDebug = 0x0000;
#endif


/*****************************************************************************
 * IsRegNameEqual (HANDLE hKey, HANDLE hKeyLink, BOOL *bIsEqual)
 *
 * Given two handles to registry keys,
 * return TRUE in bIsEqual if and only if the names of the paths are the same
 * (i.e., if the handles were created using ZwOpenKey (once without OBJ_OPENLINK
 * and once with), then the key is actually a symbolic link if this routine
 * returns FALSE in bIsEqual).
 *
 * If an error occurs (e.g., ZwQueryKey fails), this function returns the NTSTATUS.
 * If a memory allocation fails within this routine, this function returns 0.
 *
 * History:
 * 6-10-99  Donald Chinn
 *   Wrote it.
 *****************************************************************************/

NTSTATUS IsRegNameEqual (HANDLE hKey,
                         HANDLE hKeyLink,
                         BOOL *bIsEqual)

{
    NTSTATUS rv;
    PKEY_NAME_INFORMATION Buffer = NULL;
    PKEY_NAME_INFORMATION BufferLink = NULL;
    ULONG BufferSize, BufferLinkSize;
    WCHAR NameBuffer[MAX_PATH];
    WCHAR NameLinkBuffer[MAX_PATH];

    *bIsEqual = FALSE;

    // get the size of the return buffers so that we can allocate memory for them
    ZwQueryKey (hKey, KeyNameInformation, NULL, 0, &BufferSize);
    ZwQueryKey (hKeyLink, KeyNameInformation, NULL, 0, &BufferLinkSize);

    // Add space for a null character for each buffer
    BufferSize += sizeof(WCHAR);
    BufferLinkSize += sizeof(WCHAR);
    // Round BufferSize up to the nearest multiple of sizeof(DWORD)
    BufferSize = ((BufferSize + sizeof(DWORD) - 1) / sizeof(DWORD)) * sizeof(DWORD);

    if ((Buffer = (PKEY_NAME_INFORMATION) PALLOCMEM (BufferSize + BufferLinkSize, 'flnk')) == NULL)
    {
        rv = 0;
        goto done;
    }
    BufferLink = (PKEY_NAME_INFORMATION) ((PBYTE) Buffer + BufferSize);

    if (!NT_SUCCESS(rv = ZwQueryKey (hKey, KeyNameInformation,
                                     Buffer, BufferSize, &BufferSize)))
    {
        goto done;
    }
    Buffer->Name[Buffer->NameLength / sizeof(WCHAR)] = L'\0';
    
    if (!NT_SUCCESS(rv = ZwQueryKey (hKeyLink, KeyNameInformation,
                                BufferLink, BufferLinkSize, &BufferLinkSize)))
    {
        goto done;
    }
    BufferLink->Name[BufferLink->NameLength / sizeof(WCHAR)] = L'\0';

    *bIsEqual = (wcscmp (Buffer->Name, BufferLink->Name) ? FALSE : TRUE);

done:
    if (Buffer)
        VFREEMEM (Buffer);

    return rv;    
}


/*****************************************************************************
 * BOOL bNotIsKeySymbolicLink (WCHAR *RegistryPathBuffer,
 *                             HANDLE *phKey,
 *                             HANDLE *phKeyLink,
 *                             BOOL *pbIsEqual)
 *
 * Given an absolute path name in the registry,
 * return TRUE if the function completed successfully and
 * return FALSE otherwise.
 *
 * The function also returns two handles associated with the key
 * as parameters.  One is the handle returned from ZwOpenKey and
 * the other handle is the handle returned from ZwOpenKey when asked
 * to open it as a link.
 *
 * If the function succeeds, then pbIsEqual will contain TRUE
 * if the registry paths associated with the two handles are equal
 * (and FALSE otherwise).  pbIsEqual is TRUE exactly when the
 * registry key is not a symbolic link.
 *
 * History:
 * 6-10-99  Donald Chinn
 *   Wrote it.
 *****************************************************************************/
BOOL bNotIsKeySymbolicLink (WCHAR *RegistryPathBuffer,
                            HANDLE *phKey,
                            HANDLE *phKeyLink,
                            BOOL *pbIsEqual)
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING EUDCSubKey;
    BOOL bIsEqual = FALSE;

    *phKey = NULL;
    *phKeyLink = NULL;

    // set up the pathname
    RtlInitUnicodeString(&EUDCSubKey, RegistryPathBuffer);

    // Make sure the string is null-terminated
    EUDCSubKey.Buffer[MAX_PATH - 1] = L'\0';

    InitializeObjectAttributes (&ObjectAttributes, &EUDCSubKey,
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                NULL, NULL);
    if (!NT_SUCCESS(ZwOpenKey (phKey, KEY_ALL_ACCESS, &ObjectAttributes)))
        return FALSE;

    InitializeObjectAttributes (&ObjectAttributes, &EUDCSubKey,
                                OBJ_CASE_INSENSITIVE | OBJ_OPENLINK | OBJ_KERNEL_HANDLE,
                                NULL, NULL)
    if (!NT_SUCCESS(ZwOpenKey (phKeyLink, KEY_ALL_ACCESS, &ObjectAttributes)))
        return FALSE;

    // The key is a symbolic link exactly when the names of the keys are different
    if (!NT_SUCCESS(IsRegNameEqual (*phKey, *phKeyLink, pbIsEqual)))
    {
        return FALSE;
    }

    return TRUE;
}


/*****************************************************************************
 * VOID CleanUpEUDC()
 *
 * This function clean up EUDC when HYDRA shout down
 *
 * History
 *  8-26-98 Yung-Jen Tony Tsai
 * Wrote it.
 *****************************************************************************/

VOID CleanUpEUDC()
{
    // disable/unload system wide/facename eudc for current user.
    // clean up eudc links
    // on Hydra system, when the user/client goes away so does the gre
    // but the flag ulFontLinkChange is only set for FLINK_UNLOAD_FACENAME_USER
    // at this point. We need to set bit FLINK_UNLOAD_FACENAME_SYSTEM.

    SEMOBJ so(ghsemPublicPFT);

    PUBLIC_PFTOBJ pfto;  // access the public font table

    ulFontLinkChange |= FLINK_UNLOAD_FACENAME_SYSTEM;
    GreEnableEUDC(FALSE);

    if (gqlEUDC.puiBits)
    {
        VFREEMEM(gqlEUDC.puiBits);
        gqlEUDC.puiBits = NULL;
    }

    if (gqlTTSystem.puiBits)
    {

        VFREEMEM(gqlTTSystem.puiBits);
        gqlTTSystem.puiBits = NULL;

    }

    // Release Font Associate allocated memory
    if (bFinallyInitializeFontAssocDefault)
    {
        ULONG   iIndex;

        for( iIndex = 0; iIndex < NUMBER_OF_FONTASSOC_DEFAULT; iIndex++ )
        {
            if( (FontAssocDefaultTable[iIndex].ValidRegData) &&
                (FontAssocDefaultTable[iIndex].DefaultFontPathName[0] != L'\0') &&
                (FontAssocDefaultTable[iIndex].DefaultFontPFEs[PFE_NORMAL] != PPFENULL) )
            {
                QUICKLOOKUP * pql;

                {
                    PFEOBJ pfeo( FontAssocDefaultTable[iIndex].DefaultFontPFEs[PFE_NORMAL] );

                    pql = pfeo.pql();
                    if (pql->puiBits)
                    {
                        VFREEMEM(pql->puiBits);
                        pql->puiBits = NULL;
                    }

                    FontAssocDefaultTable[iIndex].DefaultFontPFEs[PFE_NORMAL] = PPFENULL;
                }
                    
                if (FontAssocDefaultTable[iIndex].DefaultFontPFEs[PFE_VERTICAL] != PPFENULL)
                {
                    PFEOBJ pfeov(FontAssocDefaultTable[iIndex].DefaultFontPFEs[PFE_VERTICAL]);

                    pql = pfeov.pql();
                    if (pql->puiBits)
                    {
                        VFREEMEM(pql->puiBits);
                        pql->puiBits = NULL;
                    }

                    FontAssocDefaultTable[iIndex].DefaultFontPFEs[PFE_VERTICAL] = PPFENULL;
                }

            }
        }

        for( iIndex = 0; iIndex < NUMBER_OF_FONTASSOC_DEFAULT; iIndex++ )
        {
            if( (FontAssocDefaultTable[iIndex].ValidRegData) &&
                (FontAssocDefaultTable[iIndex].DefaultFontPathName[0] != L'\0'))
            {
                pfto.bUnloadEUDCFont(FontAssocDefaultTable[iIndex].DefaultFontPathName);
                FontAssocDefaultTable[iIndex].DefaultFontPathName[0] = L'\0';
            }            
        }
    }

    if (pFontAssocSubs)
    {
        VFREEMEM( pFontAssocSubs );
        pFontAssocSubs = NULL;
    }
    
    if (gbSystemDBCSFontEnabled)
       pfto.bUnloadEUDCFont(gawcSystemDBCSFontPath);

}

/*****************************************************************************
 * VOID PFFOBJ::vGetEUDC(PEUDCLOAD)
 *
 * This function finds requested facename PFEs
 *
 * History
 *  4-14-95 Hideyuki Nagase
 * Wrote it.
 *****************************************************************************/

VOID PFFOBJ::vGetEUDC
(
    PEUDCLOAD pEudcLoadData
)
{
    ASSERTGDI(pEudcLoadData != NULL,"PFFOBJ::vGetEUDC() pEudcLoadData == NULL\n");

    //
    // Initialize return buffer with NULL.
    //

    pEudcLoadData->pppfeData[PFE_NORMAL]   = NULL;
    pEudcLoadData->pppfeData[PFE_VERTICAL] = NULL;

    if( pEudcLoadData->LinkedFace == NULL )
    {
        //
        // Linked face name is not specified. In this case if the font has 2 PFEs
        // we assume first entry is for Normal face, and 2nd is Verical face.
        //
        //
        // Fill it with normal face PFE.
        //
        pEudcLoadData->pppfeData[PFE_NORMAL] = ppfe(PFE_NORMAL);

        //
        // if this font has 2 PFEs, get 2nd PFE for vertical face. otherwise
        // use same PFE as normal face for Vertical face.
        //
        if( cFonts() == 2 )
            pEudcLoadData->pppfeData[PFE_VERTICAL] = ppfe(PFE_VERTICAL);
         else
            pEudcLoadData->pppfeData[PFE_VERTICAL] = ppfe(PFE_NORMAL);
    }
     else
    {
        //
        // Linked face name is specified, try to find out its PFE.
        //

        COUNT cFont;

        for( cFont = 0; cFont < cFonts(); cFont++ )
        {
            PFEOBJ pfeo(ppfe(cFont));
            PWSTR  pwszEudcFace = pfeo.pwszFamilyName();
            ULONG  iPfeOffset   = PFE_NORMAL;

            //
            // Is this a vertical face ?
            //
            if( pwszEudcFace[0] == (WCHAR) L'@' )
            {
                iPfeOffset = PFE_VERTICAL;
            }

            //
            // Is this a face that we want ?
            //
            if(pfeo.bCheckFamilyName(pEudcLoadData->LinkedFace,1))
            {
                //
                // Yes....., keep it.
                //
                pEudcLoadData->pppfeData[iPfeOffset] = pfeo.ppfeGet();

                //
                // if this is a PFE for Normal face, also keep it for Vertical face.
                // after this, this value might be over-written by CORRRCT vertical
                // face's PFE.
                //
                // NOTE :
                //  This code assume Normal face come faster than Vertical face...
                //
                if( iPfeOffset == PFE_NORMAL )
                {
                    pEudcLoadData->pppfeData[PFE_VERTICAL] = pfeo.ppfeGet();
                }
            }
        }
    }
}

/*****************************************************************************
 * BOOL bValidFontLinkParameter(PWSTR,PWSTR *)
 *
 * This function make sure the linked font parameter is valid or not.
 *
 * History
 *  3-29-95 Hideyuki Nagase
 * Wrote it.
 *****************************************************************************/

BOOL bValidFontLinkParameter
(
    PWSTR  LinkedFontName,
    PWSTR *LinkedFaceName
)
{
    PWSTR  lp = LinkedFontName;
    BOOL   bFound = FALSE;

    *LinkedFaceName = NULL;

    while( *lp )
    {
        if( *lp == L',' )
        {
            if(bFound)
            {
                *LinkedFaceName = NULL;
                return(FALSE);
            }
            else
            {
                *LinkedFaceName = lp + 1;
                *lp = (WCHAR)NULL;
                bFound = TRUE;
            }
        }
        lp++;
    }

   return(TRUE);
}

/******************************************************************************
 * BOOL bComputeQuickLookup( QUICKLOOKUP *pql, FD_GLYPHSET *pfdg, BOOL bSystemEUDC )
 *
 * This routine computes a quick lookup structure from an FD_GLYPHSET structure.
 *
 * History:
 *  7-7-93 Gerrit van Wingerden [gerritv]
 * Wrote it.
 *****************************************************************************/

#define uiMask2(X) (0xFFFFFFFF << (31-(X)))
#define uiMask1(X) (0xFFFFFFFF >> (X))

BOOL bComputeQuickLookup( QUICKLOOKUP *pql, PFE * pPFE, BOOL bSystemEUDC )
{
    WCRUN *pwcrun;
    WCHAR wcHigh = 0x0000;
    WCHAR wcLow = 0xFFFF;
    UINT ui;

// if this is not SystemEUDC and puiBits has pointer, the Lookup table
// was already initialized.

    PFEOBJ pfeObj(pPFE);
    if (!pfeObj.bValid())
        return FALSE;

    if (pql == NULL)
        pql = pfeObj.pql();

    if ( !bSystemEUDC && pql->puiBits )
        return (TRUE);

    PFD_GLYPHSET    pfdg;

    if(!(pfdg = pfeObj.pfdg()))
        return FALSE;

    pwcrun = pfdg->awcrun;

// first figure out the high and low glyphs for this font

    for( ui = 0; ui < pfdg->cRuns; ui++ )
    {
        if( wcLow > pwcrun[ui].wcLow )
        {
            wcLow = pwcrun[ui].wcLow;
        }

        if( wcHigh < pwcrun[ui].wcLow + pwcrun[ui].cGlyphs )
        {
            wcHigh = ( pwcrun[ui].wcLow + pwcrun[ui].cGlyphs - 1 );
        }
    }

    (*pql).wcLow = wcLow;
    (*pql).wcHigh = wcHigh;

// Now we need to allocate puiBits.  In the case of the system EUDC font will
// do this only once even though the glyph set can change dynamically.  This
// means we will always allocate 0xFFFF bits.  If *pql.puiBits != NULL then
// we assume the glyphset has been allocated before and leave it alone

    if( bSystemEUDC )
    {
    // see if already allocated before and if so don't allocate it again
    // we determine this by checking if *pql.auiBits is NULL or not
    // 8k * 8 = 64k, 64k glyphs
    // 8k == 8192
        if( (*pql).puiBits == NULL )
        {
            (*pql).puiBits = (UINT*)PALLOCMEM( 8192, 'flnk' );

        }
        else
        {
            RtlZeroMemory( (*pql).puiBits, 8192);
        }

        wcLow = 0;
    }
    else
    {
        (*pql).puiBits = (UINT*)PALLOCMEM((((wcHigh - wcLow + 1) + 31) / 32) * 4,'flnk');
    }

    if((*pql).puiBits == (UINT*) NULL)
    {
        WARNING("bComputeQuickLookup out of memory.\n");
        pfeObj.vFreepfdg();
        return(FALSE);
    }

    for( ui = 0; ui < pfdg->cRuns ; ui++ )
    {
        UINT uiFirst = ( pwcrun[ui].wcLow - wcLow ) / 32 ;
        UINT uiLast =  ( pwcrun[ui].wcLow - wcLow + pwcrun[ui].cGlyphs - 1 ) / 32;

        if( uiFirst == uiLast)
        {

            (*pql).puiBits[uiFirst] |= uiMask2(pwcrun[ui].cGlyphs-1) >>
                                    ( ( pwcrun[ui].wcLow - wcLow ) % 32 );
        }
        else
        {
            (*pql).puiBits[uiFirst] |= uiMask1((pwcrun[ui].wcLow - wcLow)%32);

            for( UINT uiRun = uiFirst+1; uiRun < uiLast; uiRun++ )
            {
                (*pql).puiBits[uiRun] = 0xFFFFFFFF;
            }

            (*pql).puiBits[uiLast] |=
                uiMask2((pwcrun[ui].wcLow - wcLow + pwcrun[ui].cGlyphs-1)%32);
        }
    }

    pfeObj.vFreepfdg();

    return(TRUE);
}

/******************************************************************************
 * BOOL bAppendSysDirectory( WCHAR *pwcTarget, WCHAR *pwcSource )
 *
 * Given a file name in pwcSource, this function appends it to the
 * appropirate directory and returns it into the buffer pointed to
 * by pwcTarget.  If the file already has a path it just copies
 * pwcSource to pwcTarget.
 * This function return FALSE when pwcTarget string is not eqaul to
 * pwcSource.
 *
 * History:
 *  8-30-93 Hideyuki Nagase [hideyukn]
 * Add code for searching path
 *
 *  3-23-93 Gerrit van Wingerden [gerritv]
 * Wrote it.
 *****************************************************************************/

BOOL bAppendSysDirectory( WCHAR *pwcTarget, WCHAR *pwcSource )
{
    WCHAR pwcTemp[MAX_PATH];

// Check it is file name only or full path name

    if( wcschr(pwcSource,L'\\') != NULL )
    {
        WCHAR *pSystemRoot;

    // full path.
    //
    // Catitalize path name.

        cCapString(pwcTarget,pwcSource,MAX_PATH);

    // The path contains %SYSTEMROOT% ?

        if( (pSystemRoot = wcsstr(pwcTarget,L"%SYSTEMROOT%")) != NULL )
        {
        // Yes,
        //
        // Replace %SystemRoot%\FileName with \SystemRoot\FileName.
        //         012345678901

            pSystemRoot[0] = L'\\';
            wcscpy(&(pSystemRoot[11]),&(pSystemRoot[12]));
        }
        else
        {
        // if the file format is "C:\....", we appen "\??\" to make NtPath.
        //                        0123

        // [note]
        //
        // for formal way... we need call RtlDosPathNameToNtPathName_U().
        // the function could not be called from kernel mode....
        //
            if((pwcTarget[1] == L':') && (pwcTarget[2] == L'\\'))
            {
                // keep a back up to pwcTemp.
                //
                wcscpy(pwcTemp,pwcTarget);

                // Put "\??\" first.
                //
                wcscpy(pwcTarget,L"\\??\\");

                // Put original path.
                //
                wcscat(pwcTarget,pwcTemp);
            }
            else
            {
                WARNING("bAppenSysDirectory():Need conversion (DosPath -> NtPath)\n");
            }
        }

        #if DBG
        DbgPrint("bAppenSysDirectory():Path --> %ws\n",pwcTarget);
        #endif

        return TRUE; // need to update registry.
    }
    else
    {
    // assume it is in the "fonts" directory
    
        wcscpy(pwcTemp, L"\\??\\");
        wcscat(pwcTemp, USER_SHARED_DATA->NtSystemRoot);
        wcscat(pwcTemp, L"\\fonts\\");
            
        wcscat(pwcTemp,pwcSource);
        cCapString(pwcTarget,pwcTemp,MAX_PATH);

        return(FALSE); // dont need to update
    }
}

#ifdef PORTABLE_WINDOWS_DIR
WCHAR *pwcFileIsUnderWindowsRoot( WCHAR *pwcTarget )
{
#ifdef FIX_THIS
    WCHAR awcWindowsRoot[MAX_PATH+1];
    UINT  WindowsRootLength;

    WindowsRootLength = GetSystemWindowsDirectoryW( awcWindowsRoot , MAX_PATH );

    if( wcsnicmp( awcWindowsRoot, pwcTarget, WindowsRootLength ) == 0 )
        return (pwcTarget + WindowsRootLength);

#endif
    return NULL;
}
#endif // PORTABLE_WINDOWS_DIR

/****************************************************************************
 * GetUserEUDCRegistryPath(LPWSTR,USHORT)
 *
 *  Get EUDC registry path for current loggedon user.
 *
 * History:
 *  9-Feb-1995 -by- Hideyuki Nagase [hideyukn]
 * Wrote it.
 ***************************************************************************/

VOID GetUserEUDCRegistryPath
(
    LPWSTR UserEUDCPathBuffer,
    USHORT UserEUDCPathLen
)
{
    UNICODE_STRING UserEUDCPath;
    UNICODE_STRING UserRegistryPath;

    UserEUDCPath.Length = 0;
    UserEUDCPath.MaximumLength = UserEUDCPathLen;
    UserEUDCPath.Buffer = UserEUDCPathBuffer;

// Get path of CurrentUser key.


    if(NT_SUCCESS(RtlFormatCurrentUserKeyPath(&UserRegistryPath)))
    {
    // Build path for EUDC data

        RtlAppendUnicodeStringToString(&UserEUDCPath,&UserRegistryPath);
        RtlAppendUnicodeToString(&UserEUDCPath,EUDC_USER_REGISTRY_KEY);
        RtlAppendUnicodeToString(&UserEUDCPath,gawcSystemACP);

        RtlFreeUnicodeString(&UserRegistryPath);

    }
    else
    {
        WARNING("GetUserEUDCRegistryPath():RtlFormatCurrentUserKeyPath\n");

    // just retuen default path..

        RtlAppendUnicodeToString(&UserEUDCPath,L"\\Registry\\User\\.DEFAULT");
        RtlAppendUnicodeToString(&UserEUDCPath,EUDC_USER_REGISTRY_KEY);
        RtlAppendUnicodeToString(&UserEUDCPath,gawcSystemACP);
    }
}


/******************************************************************************
 * bWriteUserSystemEUDCRegistry(LPWSTR)
 *
 *  Write system wide eudc font file path for request user.
 *
 * History:
 *  9-Feb-1995 -by- Hideyuki Nagase [hideyukn]
 * Wrote it.
 *****************************************************************************/

BOOL bWriteUserSystemEUDCRegistry
(
    LPWSTR DataBuffer,
    USHORT DataLen
)
{
    NTSTATUS NtStatus;
    WCHAR    RegistryPathBuffer[MAX_PATH];

    HANDLE hKey = NULL;
    HANDLE hKeyLink = NULL;
    BOOL bIsEqual = FALSE;

    // Get EUDC registry path for requested user

    GetUserEUDCRegistryPath(RegistryPathBuffer,sizeof(RegistryPathBuffer));

    // if the registry entry is a symbolic link, fail the call
    if (bNotIsKeySymbolicLink (RegistryPathBuffer, &hKey, &hKeyLink, &bIsEqual) &&
        bIsEqual)
    {
        // Write registry.
        NtStatus = RtlWriteRegistryValue( RTL_REGISTRY_ABSOLUTE,
                                          RegistryPathBuffer,
                                          L"SystemDefaultEUDCFont",
                                          REG_SZ,
                                          DataBuffer,
                                          DataLen * sizeof(WCHAR) );
    }
    else
    {
        NtStatus = (STATUS_SEVERITY_ERROR << 30);  // any non-zero error is sufficient
    }

    if (hKey)
        ZwClose (hKey);
    if (hKeyLink)
        ZwClose (hKeyLink);

    if(!NT_SUCCESS(NtStatus))
    {
        WARNING("bWriteUserSystemEUDCRegistry():fail\n");
        return(FALSE);
    }

    return(TRUE);
}

/******************************************************************************
 * bReadUserSystemEUDCRegistry(LPWSTR,USHORT)
 *
 *  Read system wide eudc font file path for request user.
 *
 * History:
 *  9-Feb-1995 -by- Hideyuki Nagase [hideyukn]
 * Wrote it.
 *****************************************************************************/

BOOL bReadUserSystemEUDCRegistry
(
    LPWSTR FilePathBuffer,
    USHORT FilePathLen
)
{
    NTSTATUS       NtStatus;
    WCHAR          NoExpandFilePathBuffer[MAX_PATH];
    WCHAR          RegistryPathBuffer[MAX_PATH];
    UNICODE_STRING FilePath;

    HANDLE hKey = NULL;
    HANDLE hKeyLink = NULL;
    BOOL bIsEqual = FALSE;


// Get EUDC registry path for requested user

    GetUserEUDCRegistryPath(RegistryPathBuffer,sizeof(RegistryPathBuffer));

    // if the registry entry is a symbolic link, fail the call
    if (bNotIsKeySymbolicLink (RegistryPathBuffer, &hKey, &hKeyLink, &bIsEqual) &&
        bIsEqual)
    {
        FilePath.Length = 0;
        FilePath.MaximumLength = sizeof(NoExpandFilePathBuffer);
        FilePath.Buffer = NoExpandFilePathBuffer;

        SharedQueryTable[0].QueryRoutine = NULL;
        SharedQueryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED |
                                    RTL_QUERY_REGISTRY_DIRECT;
        SharedQueryTable[0].Name = (PWSTR) L"SystemDefaultEUDCFont";
        SharedQueryTable[0].EntryContext = (PVOID) &FilePath;
        SharedQueryTable[0].DefaultType = REG_NONE;
        SharedQueryTable[0].DefaultData = NULL;
        SharedQueryTable[0].DefaultLength = 0;

        SharedQueryTable[1].QueryRoutine = NULL;
        SharedQueryTable[1].Flags = 0;
        SharedQueryTable[1].Name = NULL;

        // Read registry.

        NtStatus = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                          RegistryPathBuffer,
                                          SharedQueryTable,
                                          NULL,
                                          NULL);
    }
    else
    {
        NtStatus = (STATUS_SEVERITY_ERROR << 30);  // any non-zero error is sufficient
    }

    if (hKey)
        ZwClose (hKey);
    if (hKeyLink)
        ZwClose (hKeyLink);

    if(!NT_SUCCESS(NtStatus) || FilePath.Length == 0)
    {
        #if DBG
        DbgPrint("bReadUserSystemEUDCRegistry():fail NtStatus - %x\n",NtStatus);
        #endif

        if(NtStatus == STATUS_OBJECT_NAME_NOT_FOUND)
        {
            WCHAR *LastBackslash = NULL;

            //
            // if the user does not have EUDC\ActiveCodePage\SystemDefaultEUDCFont
            // key\value, we create the key and set the default value here..
            //
            // Create key.

            LastBackslash = wcsrchr(RegistryPathBuffer,L'\\');

            if(LastBackslash != NULL && _wcsicmp(LastBackslash+1,gawcSystemACP) == 0)
            {
                // Create HKEY_CURRENT_USER\EUDC key.

                *LastBackslash = L'\0';
                RtlCreateRegistryKey(RTL_REGISTRY_ABSOLUTE,RegistryPathBuffer);

                // Create HKEY_CURRENT_USER\EUDC\ActiveCodePage key.

                *LastBackslash = L'\\';
                RtlCreateRegistryKey(RTL_REGISTRY_ABSOLUTE,RegistryPathBuffer);

                // Set value.

                if(bWriteUserSystemEUDCRegistry(DEFAULT_EUDC_FONT,
                                                wcslen(DEFAULT_EUDC_FONT)+1) )
                {
                    //
                    // Initialize FilePath with default.
                    //

                    RtlInitUnicodeString(&FilePath,DEFAULT_EUDC_FONT);
                }
                 else goto ErrorReturn;
            }
             else goto ErrorReturn;
        }
         else goto ErrorReturn;
    }
     else
    {
        //
        // Make sure the null-terminate string
        //

        FilePath.Buffer[FilePath.Length/sizeof(WCHAR)] = L'\0';
    }

    wcsncpy(FilePathBuffer,FilePath.Buffer,FilePathLen);
    return(TRUE);

ErrorReturn:
    return(FALSE);
}

/*****************************************************************************
 * BOOL bKillEudcRFONTs( RFONT *prfntVictims )
 *
 * Given a linked list of EUDC RFONT this routine kills them all.
 *
 * History
 *  6-30-93 Gerrit van Wingerden
 * Wrote it.
 *****************************************************************************/

BOOL bKillEudcRFONTs( RFONT *prfntVictims )
{
    PRFONT prfnt;

    while( (prfnt = prfntVictims ) != (PRFONT) NULL )
    {
        prfntVictims = prfntVictims->rflPDEV.prfntNext;

        {
            RFONTTMPOBJ rfloVictim(prfnt);

        // Need this so we can remove this from the PFF's RFONT list.

            PFFOBJ pffo(prfnt->pPFF);

            ASSERTGDI(pffo.bValid(), "gdisrv!vKillEudcRFONTs: bad HPFF");

        // We pass in NULL for ppdo because we've already removed it from the
        // PDEV list.

            if( !rfloVictim.bDeleteRFONT((PDEVOBJ *) NULL, &pffo))
            {
                WARNING("Unable vKillEudcRFONTs unable to delete RFONT.\n");
                return(FALSE);
            }
        }
    }

    return(TRUE);
}

/*****************************************************************************
 * RFONT *prfntDeactivateEudcRFONTs(PFE **)
 *
 * Tracks down all the EUDC RFONTS in the system removes them from the active
 * and deactive lists and puts them on a list for deletion which it then
 * returns to the caller.
 *
 * The public font table semaphore must be held by the caller for this to work.
 *
 * History
 *  23-01-95 Hideyuki Nagase
 * Rewrote it.
 *
 *   2-10-93 Gerrit van Wingerden
 * Wrote it.
 *****************************************************************************/

VOID vDeactivateEudcRFONTsWorker
(
    PPFE  *appfe,
    PPFF  pPFF,
    RFONT **pprfntToBeKilled
)
{
    while(pPFF)
    {
        PFFOBJ pffo(pPFF);

    // Check if this font file is really loaded as EUDC font..

        if(pffo.bEUDC())
        {
            for( PRFONT prfnt = pffo.prfntList() ; prfnt != (PRFONT) NULL;  )
            {
                PRFONT prfntNext;

                {
                    RFONTTMPOBJ rflo(prfnt);
                    prfntNext = rflo.prflPFF()->prfntNext;
                }

                if( ( prfnt->ppfe == appfe[PFE_NORMAL]   ) ||
                    ( prfnt->ppfe == appfe[PFE_VERTICAL] )   )
                {
                    FLINKMESSAGE2(DEBUG_FONTLINK_UNLOAD,
                                  "Removing EUDC font %x.\n", prfnt);

                    RFONTTMPOBJ rfo(prfnt);

                    PDEVOBJ pdo(prfnt->hdevConsumer);
                    PRFONT prf;

                // remove it from the active or inactive list

                    if( prfnt->cSelected != 0 )
                    {
                        prf = pdo.prfntActive();
                        rfo.vRemove(&prf, PDEV_LIST);
                        pdo.prfntActive(prf);
                    }
                    else
                    {
                        prf = pdo.prfntInactive();
                        rfo.vRemove(&prf, PDEV_LIST);
                        pdo.prfntInactive(prf);
                        pdo.cInactive( pdo.cInactive()-1 );
                    }

                // add it to the kill list

                    rfo.vInsert( pprfntToBeKilled, PDEV_LIST );
                }

                prfnt = prfntNext;
            }
        }

        pPFF = pPFF->pPFFNext;
    }
}

RFONT *prfntDeactivateEudcRFONTs( PPFE *appfe )
{
    RFONT *prfntToBeKilled = PRFNTNULL;

    FLINKMESSAGE(DEBUG_FONTLINK_UNLOAD,"Deactivating EUDC RFONTs.\n");

    SEMOBJ so1(ghsemPublicPFT);
    SEMOBJ so2(ghsemRFONTList);

    COUNT cBuckets;
    PPFF  pPFF;

    PUBLIC_PFTOBJ pftoPublic;  // access the public font table

    for( cBuckets = 0; cBuckets < pftoPublic.cBuckets(); cBuckets++ )
    {
        if( (pPFF = pftoPublic.pPFF(cBuckets)) != NULL )
        {
            vDeactivateEudcRFONTsWorker( appfe, pPFF, &prfntToBeKilled );
        }
    }

    return(prfntToBeKilled);
}

/*****************************************************************************
 * BOOL bUnloadEudcFont( PFE ** )
 *
 * This function delete RFONTs and unload fontfile for specified PFE
 *
 * History:
 *  24-01-1995 -by- Hideyuki Nagase
 * Wrote it.
 *****************************************************************************/

BOOL bUnloadEudcFont( PFE **ppfe )
{
    WCHAR awcPathBuffer[MAX_PATH + 1];

    PUBLIC_PFTOBJ pfto;  // access the public font table

    PFEOBJ pfeo( ppfe[PFE_NORMAL] );
    PFFOBJ pffo( pfeo.pPFF() );

// get font file path.

    wcscpy(awcPathBuffer,pffo.pwszPathname());

    QUICKLOOKUP *pqlDelete;

// Progress Normal face..

    pqlDelete = pfeo.pql();

// if this is system wide eudc, won't need to free it.

    if( pqlDelete->puiBits != NULL )
    {
        VFREEMEM(pqlDelete->puiBits);
        pqlDelete->puiBits = NULL;
    }

    PFEOBJ pfeoVert( ppfe[PFE_VERTICAL] );

    if( pfeoVert.bValid() )
    {
        pqlDelete = pfeoVert.pql();

    // if this is system wide eudc, won't need to free it.

        if( pqlDelete->puiBits != NULL )
        {
            VFREEMEM(pqlDelete->puiBits);
            pqlDelete->puiBits = NULL;
        }
    }

// Deactivate all RFONT for this PFE

    PRFONT prfntToBeKilled = prfntDeactivateEudcRFONTs( ppfe );

// Kill all RFONT for this PFE

    if(!bKillEudcRFONTs( prfntToBeKilled ))
    {
        WARNING("bDeleteAllFlEntry():Can not kill Eudc RFONTs\n");
        return(FALSE);
    }

    //
    // Unload this font file.
    //
    //  if others link are using this font file, the font
    // is not unloaded here. At the last link that is using
    // this font, it will be really unloaded.
    //

    #if DBG
    if( gflEUDCDebug & DEBUG_FONTLINK_UNLOAD )
    {
        DbgPrint("Unloading... %ws\n",awcPathBuffer);
    }
    #endif

    if(!pfto.bUnloadEUDCFont(awcPathBuffer))
    {
        #if DBG
        DbgPrint("bDeleteAllFlEntry():Can not unload Eudc %ws\n",awcPathBuffer);
        #endif
        return(FALSE);
    }

    return(TRUE);
}

/*****************************************************************************
 * PFLENTRY FindBaseFontEntry(PWSTR)
 *
 * This function scan the base font list to find specified font is already
 * exist or not.
 *
 * Return.
 *  Exist     - Pointer to FLENTRY strucrure.
 *  Not exist - NULL
 *
 * History
 *  1-09-95 Hideyuki Nagase
 * Wrote it.
 *****************************************************************************/

PFLENTRY FindBaseFontEntry
(
    PWSTR BaseFontName
)
{
    PLIST_ENTRY p;
    PFLENTRY    pFlEntry;

    p = BaseFontListHead.Flink;
    pFlEntry = NULL;

    while( p != &BaseFontListHead )
    {
        pFlEntry = CONTAINING_RECORD(p,FLENTRY,baseFontList);

        #if DBG
        if( gflEUDCDebug & (DEBUG_FONTLINK_INIT) )
        {
            DbgPrint("%ws v.s. %ws\n",BaseFontName,pFlEntry->awcFaceName);
        }
        #endif

        //
        // if this is Vertical font name, compair without '@'
        //
        PWSTR pFaceName;
        PWSTR pBaseFaceName;

        pFaceName = ( (pFlEntry->awcFaceName[0] != L'@') ? &(pFlEntry->awcFaceName[0]) :
                                                           &(pFlEntry->awcFaceName[1])   );

        pBaseFaceName = ( (BaseFontName[0] != L'@') ? &BaseFontName[0] :
                                                      &BaseFontName[1]   );

        //
        // Compair font face name.
        //

        if( _wcsicmp(pBaseFaceName,pFaceName) == 0 )
        {
            //
            // Find it.
            //
            break;
        }

        //
        // try next.
        //

        p = p->Flink;
        pFlEntry = NULL;
    }

    return(pFlEntry);
}

/*****************************************************************************
 * PPFEDATA FindLinkedFontEntry(PLIST_ENTRY,PWSTR,PWSTR)
 *
 * This function scan the linked font list to find specified font is already
 * exist or not.
 *
 * Return.
 *  Exist     - Pointer to PPFEDATA strucrure.
 *  Not exist - NULL
 *
 * History
 *  1-09-95 Hideyuki Nagase
 * Wrote it.
 *****************************************************************************/

PPFEDATA FindLinkedFontEntry
(
    PLIST_ENTRY LinkedFontList,
    PWSTR       LinkedFontPath,
    PWSTR       LinkedFontFace
)
{
    PLIST_ENTRY p;
    PPFEDATA    ppfeData;

    p = LinkedFontList->Flink;
    ppfeData = NULL;

    while( p != LinkedFontList )
    {
        ppfeData = CONTAINING_RECORD(p,PFEDATA,linkedFontList);

        //
        // get PFE and PFF user object.
        //

        PFEOBJ pfeo( ppfeData->appfe[PFE_NORMAL] );
        PFFOBJ pffo( pfeo.pPFF() );

        #if DBG
        if( gflEUDCDebug & (DEBUG_FONTLINK_INIT) )
        {
            DbgPrint("%ws v.s. %ws\n",pffo.pwszPathname(),LinkedFontPath);
        }
        #endif

        //
        // compair file path
        //

        if( _wcsicmp( pffo.pwszPathname() , LinkedFontPath ) == 0 )
        {
            //
            // if facename of linked font is specified, check it also.
            //

            if( ((LinkedFontFace == NULL) &&
                 ((ppfeData->FontLinkFlag & FLINK_FACENAME_SPECIFIED) == 0)) ||
                ((LinkedFontFace != NULL ) &&
                 ((ppfeData->FontLinkFlag & FLINK_FACENAME_SPECIFIED) != 0) &&
                 ((_wcsicmp(pfeo.pwszFamilyName() , LinkedFontFace))== 0)
                )
              )
            {
                //
                // Find it.
                //
                break;
            }
        }

        //
        // try next.
        //

        p = p->Flink;
        ppfeData = NULL;
    }

    return(ppfeData);
}

/*****************************************************************************\
 * BOOL FindDefaultLinkedFontEntry
 *
 * This codepath check the passed facename is registered as Default link
 * facename in Default link table. if so, keep its facename for the facename.
 *
 * History
 *  1-14-96 Hideyuki Nagase
 * Wrote it.
 *****************************************************************************/

BOOL FindDefaultLinkedFontEntry
(
    PWSTR CandidateFaceName,
    PWSTR CandidatePathName
)
{
    BOOL bRet = FALSE;
    UINT iIndex;

    for( iIndex = 0; iIndex < NUMBER_OF_FONTASSOC_DEFAULT; iIndex++ )
    {
        //
        // Check the data can be read from registry or not.
        //
        if( FontAssocDefaultTable[iIndex].ValidRegData )
        {
            //
            // Check this path is not filled.
            //
            if( FontAssocDefaultTable[iIndex].DefaultFontPathName[0] == L'\0' )
            {
                //
                // Check the candidate is matched with the facename from registry.
                //
                if( _wcsicmp(CandidateFaceName,FontAssocDefaultTable[iIndex].DefaultFontFaceName) == 0 )
                {
                    //
                    // Mark the candidate path to default table. This font file will be RE-loaded
                    // EUDC font file when GreEnableEUDC() was called next time.
                    //
                    wcscpy(FontAssocDefaultTable[iIndex].DefaultFontPathName,CandidatePathName);

                    #if DBG
                    DbgPrint("GDISRV:FONTASSOC DEFAULT:%ws -> %ws\n",
                        FontAssocDefaultTable[iIndex].DefaultFontTypeID,
                        FontAssocDefaultTable[iIndex].DefaultFontPathName);
                    #endif

                    bRet |= TRUE;
                }
            }
        }
    }

    return (bRet);
}



/*****************************************************************************
 * VOID vLinkEudcPFEs(PFLENTRY)
 *
 *  This routine will find base font PFE from PFT, and set up Eudc data.
 *
 * History:
 *  24-Jan-1995 -by- Hideyuki Nagase
 * Wrote it.
 ****************************************************************************/

VOID vLinkEudcPFEsWorker
(
    PFLENTRY pFlEntry,
    PPFF     pPFF
)
{
    while(pPFF)
    {
        //
        // get PFF user object
        //

        PFFOBJ pffo(pPFF);

        //
        // if this font is loaded as EUDC, it can not be a BaseFont.
        //

        if( !pffo.bEUDC() )
        {
            for( COUNT c = 0 ; c < pffo.cFonts() ; c++ )
            {
                PFEOBJ   pfeo(pffo.ppfe(c));

                if( pfeo.bValid() )
                {
                    BOOL     bFound = FALSE;
                    PFLENTRY pFlEntrySelected = pFlEntry;

                    if( pFlEntrySelected )
                    {
                        bFound = pfeo.bCheckFamilyName(pFlEntrySelected->awcFaceName, 0);
                    }
                     else
                    {
                        
                        PWSZ pwszAlias = NULL;
                        BOOL bIsFamilyNameAlias = FALSE;


                        pwszAlias = pfeo.pwszFamilyNameAlias(&bIsFamilyNameAlias);
                        bFound =
                            ((pFlEntrySelected = FindBaseFontEntry(pwszAlias)) != NULL);

                        if (!bFound && bIsFamilyNameAlias)
                        {
                            pwszAlias += (wcslen(pwszAlias) + 1);
                            bFound = ((pFlEntrySelected =
                                    FindBaseFontEntry(pwszAlias)) != NULL);
                        }
                    }

                    if( bFound )
                    {
                        //
                        // set eudc list..
                        //

                        pfeo.vSetLinkedFontEntry( pFlEntrySelected );

                        #if DBG
                        if( gflEUDCDebug & DEBUG_FACENAME_EUDC )
                        {
                            PLIST_ENTRY p = pfeo.pGetLinkedFontList()->Flink;

                            DbgPrint("Found FaceName EUDC for %ws (%ws) is ",
                                      pfeo.pwszFamilyName(),pffo.pwszPathname());

                            while( p != &(pFlEntrySelected->linkedFontListHead) )
                            {
                                PPFEDATA ppfeData = CONTAINING_RECORD(p,PFEDATA,linkedFontList);
                                PFEOBJ pfeoTemp( ppfeData->appfe[PFE_NORMAL] );
                                PFFOBJ pffoTemp( pfeoTemp.pPFF() );

                                DbgPrint(" %ws ",pffoTemp.pwszPathname());

                                p = p->Flink;
                            }

                            DbgPrint("\n");
                        }
                        #endif
                    }
                     else
                    {
                        // mark the FaceNameEUDC pfe as NULL

                        pfeo.vSetLinkedFontEntry( NULL );
                    }
                }
            }
        }

        pPFF = pPFF->pPFFNext;
    }
}

VOID vLinkEudcPFEs
(
    PFLENTRY pFlEntry
)
{
    #if DBG
    if( gflEUDCDebug & DEBUG_FONTLINK_LOAD )
    {
        DbgPrint( "vLinkEudcPFEs():Linking All EUDC PFEs.\n");
    }
    #endif

    SEMOBJ so(ghsemPublicPFT);

    //
    // WE HAD BETTER USE FONTHASH TO SEARCH BASE FONT'S PFF.
    //

    COUNT cBuckets;
    PPFF  pPFF;

    //
    // get PFT user object.
    //

    PUBLIC_PFTOBJ pftoPublic;  // access the public font table

    for( cBuckets = 0; cBuckets < pftoPublic.cBuckets(); cBuckets++ )
    {
        if( (pPFF = pftoPublic.pPFF(cBuckets)) != NULL )
        {
            vLinkEudcPFEsWorker( pFlEntry, pPFF );
        }
    }

    DEVICE_PFTOBJ pftoDevice;  // access the public font table

    for( cBuckets = 0; cBuckets < pftoDevice.cBuckets(); cBuckets++ )
    {
        if( (pPFF = pftoDevice.pPFF(cBuckets)) != NULL )
        {
            vLinkEudcPFEsWorker( pFlEntry, pPFF );
        }
    }
}

/*****************************************************************************
 * VOID vUnlinkEudcRFONTs( PPFE * )
 *
 * This routine reset RFONT that has specified linked font.
 *
 * History:
 *  23-Jan-1995 -by- Hideyuki Nagase
 * Wrote it
 ****************************************************************************/

VOID vUnlinkEudcRFONTsWorker
(
    PPFE *appfe,
    PPFF pPFF
)
{
    while(pPFF)
    {
        PFFOBJ pffo(pPFF);

    // if this font is loaded as EUDC, it can not be a BaseFont.

        if( !pffo.bEUDC() )
        {
        // Unlink Eudc from the RFONTs if it has specified Eudc..

            for( PRFONT prfnt = pffo.prfntList() ; prfnt != (PRFONT) NULL;  )
            {
                PRFONT prfntNext;

                {
                    RFONTTMPOBJ rflo(prfnt);
                    prfntNext = rflo.prflPFF()->prfntNext;
                }

            // if this RFONT has Eudc font, search this Eudc..

                for( UINT ii = 0 ; ii < prfnt->uiNumLinks ; ii++ )
                {
                // Is this the Eudc RFONT that we want to remove?


                    if((prfnt->paprfntFaceName[ii] != NULL ) &&
                       (((prfnt->paprfntFaceName[ii])->ppfe == appfe[PFE_NORMAL])  ||
                        ((prfnt->paprfntFaceName[ii])->ppfe == appfe[PFE_VERTICAL])))
                    {

                        #if DBG
                        if( gflEUDCDebug & DEBUG_FONTLINK_UNLOAD )
                        {
                            DbgPrint("Removing face name EUDC pair %x -> %x\n",
                                             prfnt, prfnt->paprfntFaceName[ii]);
                        }
                        #endif

                        prfnt->paprfntFaceName[ii] = NULL;
                    }
                }

            // this RFONT's linked font array will be updated with new configuration
            // when this RFONT is used again (see vInitEUDC()).
            // and, if all Eudc font has been removed for this RFONT.
            // the array, its pointer and other information for Eudc will be
            // deleted/updated, vUnlinkEudcRFONTsAndPFEs() will be called instead
            // of this.

                prfnt->flEUDCState = 0;

                prfnt = prfntNext;
            }
        }

        pPFF = pPFF->pPFFNext;
    }
}

VOID vUnlinkEudcRFONTs
(
    PPFE *appfe
)
{
    FLINKMESSAGE(DEBUG_FONTLINK_UNLOAD,"vUnlinkEudcRFONTs():Unlinking EUDC RFONTs.\n");

    SEMOBJ so1(ghsemPublicPFT);
    SEMOBJ so2(ghsemRFONTList);

    COUNT cBuckets;
    PPFF  pPFF;

    PUBLIC_PFTOBJ pftoPublic;  // access the public font table

    for( cBuckets = 0; cBuckets < pftoPublic.cBuckets(); cBuckets++ )
    {
        if( (pPFF = pftoPublic.pPFF(cBuckets)) != NULL )
        {
            vUnlinkEudcRFONTsWorker(appfe,pPFF);
        }
    }

    DEVICE_PFTOBJ pftoDevice;  // access the public font table

    for( cBuckets = 0; cBuckets < pftoDevice.cBuckets(); cBuckets++ )
    {
        if( (pPFF = pftoDevice.pPFF(cBuckets)) != NULL )
        {
            vUnlinkEudcRFONTsWorker(appfe,pPFF);
        }
    }
}

/*****************************************************************************
 * VOID vUnlinkEudcRFONTsAndPFEs(PPFE *,PFLENTRY)
 *
 * This routine reset RFONT and PFE structure that has specified linked font.
 *
 * History:
 *  23-Jan-1995 -by- Hideyuki Nagase
 * Wrote it
 ****************************************************************************/

VOID vUnlinkEudcRFONTsAndPFEsWorker
(
    PPFE     *appfe,
    PFLENTRY pFlEntry,
    PPFF     pPFF
)
{
    while(pPFF)
    {
        PFFOBJ pffo(pPFF);

    // if this font is loaded as EUDC, it can not be a BaseFont.

        if( !pffo.bEUDC() )
        {
        // Unlink Eudc from the RFONTs if it has specified Eudc..

            for( PRFONT prfnt = pffo.prfntList() ; prfnt != (PRFONT) NULL;  )
            {
                PRFONT prfntNext;

                {
                    RFONTTMPOBJ rflo(prfnt);
                    prfntNext = rflo.prflPFF()->prfntNext;
                }

            // if this RFONT has Eudc font, search this Eudc..


                BOOL bFound = FALSE;

                for( UINT ii = 0 ; ii < prfnt->uiNumLinks ; ii++ )
                {
                // Is this the Eudc RFONT that we want to remove?

                    if(((prfnt->paprfntFaceName[ii]) != NULL ) &&
                       (((prfnt->paprfntFaceName[ii])->ppfe == appfe[PFE_NORMAL])  ||
                        ((prfnt->paprfntFaceName[ii])->ppfe == appfe[PFE_VERTICAL])))
                    {
                        #if DBG
                        if( gflEUDCDebug & DEBUG_FONTLINK_UNLOAD )
                        {
                            DbgPrint("Removing face name EUDC pair %x -> %x\n",
                                      prfnt, prfnt->paprfntFaceName[ii]);
                        }

                        //
                        // Invalidate it for checking.
                        //
                        prfnt->paprfntFaceName[ii] = NULL;
                        #endif

                        bFound = TRUE;
                        break;
                    }
                }

                if( bFound )
                {
                    #if DBG
                // make sure the linked font array is really empty.

                    for( UINT jj = 0; jj < prfnt->uiNumLinks ; jj++ )
                    {
                        if( prfnt->paprfntFaceName[jj] != NULL )
                        {
                            DbgPrint("vUnloadEudcRFONTsAndPFEs():*** Deleteing Eudc \
                                      array that has valid data\n");
                        }
                    }
                    #endif

                // if the linked RFONT table was allocated, free it here

                    if( prfnt->paprfntFaceName != prfnt->aprfntQuickBuff )
                        VFREEMEM( prfnt->paprfntFaceName );

                // we have no facename eudc for this RFONT.

                    prfnt->paprfntFaceName  = NULL;
                    prfnt->uiNumLinks       = 0;
                    prfnt->bFilledEudcArray = FALSE;
                    prfnt->ulTimeStamp      = 0L;
                }

                prfnt->flEUDCState = 0;

                prfnt = prfntNext;
            }

        // Unlink Eudcs from All PFEs that has Eudcs.

            for( COUNT c = 0 ; c < pffo.cFonts() ; c++ )
            {
                PFEOBJ pfeo(pffo.ppfe(c));

                if( pfeo.pGetLinkedFontEntry() == pFlEntry )
                {
                    FLINKMESSAGE2(DEBUG_FONTLINK_UNLOAD,
                                  "Removing face name PFE for %x (PFE)\n",pffo.ppfe(c));

                    pfeo.vSetLinkedFontEntry( NULL );
                }
            }
        }

        pPFF = pPFF->pPFFNext;
    }
}

VOID vUnlinkEudcRFONTsAndPFEs
(
    PPFE     *appfe,
    PFLENTRY pFlEntry
)
{
    FLINKMESSAGE(DEBUG_FONTLINK_UNLOAD,
                 "vUnlinkEudcRFONTsAndPFEs():Unlinking EUDC RFONTs ans PFEs.\n");

    SEMOBJ so1(ghsemPublicPFT);
    SEMOBJ so2(ghsemRFONTList);

    COUNT cBuckets;
    PPFF  pPFF;

// get PFT user object.

    PUBLIC_PFTOBJ pftoPublic;  // access the public font table

    for( cBuckets = 0; cBuckets < pftoPublic.cBuckets(); cBuckets++ )
    {
        if( (pPFF = pftoPublic.pPFF(cBuckets)) != NULL )
        {
            vUnlinkEudcRFONTsAndPFEsWorker(appfe,pFlEntry,pPFF);
        }
    }

    DEVICE_PFTOBJ pftoDevice;  // access the public font table

    for( cBuckets = 0; cBuckets < pftoDevice.cBuckets(); cBuckets++ )
    {
        if( (pPFF = pftoDevice.pPFF(cBuckets)) != NULL )
        {
            vUnlinkEudcRFONTsAndPFEsWorker(appfe,pFlEntry,pPFF);
        }
    }
}

/*****************************************************************************
 * VOID vUnlinkAllEudcRFONTsAndPFEs(BOOL,BOOL)
 *
 * This routine reset RFONT and PFE structure that has any linked font.
 *
 * History:
 *  23-Jan-1995 -by- Hideyuki Nagase
 * Wrote it
 ****************************************************************************/

VOID vUnlinkAllEudcRFONTsAndPFEsWorker
(
    BOOL bUnlinkSystem,
    BOOL bUnlinkFaceName,
    PPFF pPFF
)
{
    while(pPFF)
    {
        PFFOBJ pffo(pPFF);

    // if this font is loaded as EUDC, it can not be a BaseFont.

        if( !pffo.bEUDC() )
        {
        // Unlink Eudc from All RFONTs that has Eudc..


            for( PRFONT prfnt = pffo.prfntList() ; prfnt != (PRFONT) NULL;  )
            {
                PRFONT prfntNext;

                {
                    RFONTTMPOBJ rflo(prfnt);
                    prfntNext = rflo.prflPFF()->prfntNext;
                }

             // if this RFONT has system wide eudc, unlink it..


                if( bUnlinkSystem )
                {
                #if DBG
                    if( prfnt->prfntSysEUDC != (PRFONT) NULL  )
                    {
                        if( gflEUDCDebug & DEBUG_FONTLINK_UNLOAD )
                        {
                            DbgPrint("Removing system wide EUDC pair %x -> %x\n",
                                      prfnt, prfnt->prfntSysEUDC);
                        }

                        prfnt->prfntSysEUDC = NULL;
                    }
                 #else
                    prfnt->prfntSysEUDC = NULL;
                 #endif
                }


                 // if this RFONT has face name eudc, unlink it..


                 if( bUnlinkFaceName )
                 {
                  // NOTE :
                  //
                  // We will unlink the pointer to Rfont, even some of
                  // eudc link will valid (i.g. if we have on-bit of FONTLINK_SYSTEM in
                  // FontLinkChange value. the type of EUDC may not need to unlink.
                  // Because we should restructure the Rfonts array for following case,
                  // when even we want to only USER attribute EUDC....
                  //
                  // Before :
                  //  BaseFont->FaceNameEUDC(SYS)->FaceNameEUDC(USER)->FaceNameEUDC(SYS)
                  //
                  // After :
                  //  BaseFont -> FaceNameEUDC(SYS) -> FaceNameEUDC(SYS)
                  //

                    if( prfnt->paprfntFaceName != NULL )
                    {
                        for( UINT ii = 0 ; ii < prfnt->uiNumLinks ; ii++ )
                        {
                            #if DBG
                            if( prfnt->paprfntFaceName[ii] != NULL )
                            {
                                if( gflEUDCDebug & DEBUG_FONTLINK_UNLOAD )
                                {
                                    DbgPrint("Removing face name EUDC pair %x -> %x\n",
                                                      prfnt, prfnt->paprfntFaceName[ii]);
                                }
                                prfnt->paprfntFaceName[ii] = NULL;
                            }
                            #else
                            prfnt->paprfntFaceName[ii] = NULL;
                            #endif
                        }

                         if( prfnt->paprfntFaceName != prfnt->aprfntQuickBuff )
                             VFREEMEM( prfnt->paprfntFaceName );

                         prfnt->uiNumLinks = 0;
                         prfnt->paprfntFaceName = NULL;
                         prfnt->bFilledEudcArray = FALSE;
                         prfnt->ulTimeStamp = 0;
                     }
                 }

                 prfnt->flEUDCState = 0;
                 prfnt = prfntNext;
             }


             if( bUnlinkFaceName )
             {
                 for( COUNT c = 0 ; c < pffo.cFonts() ; c++ )
                 {
                     PFEOBJ pfeo(pffo.ppfe(c));

                     #if DBG
                     if( pfeo.pGetLinkedFontEntry() != NULL )
                     {
                         FLINKMESSAGE2(DEBUG_FONTLINK_UNLOAD,                   \
                                       "Removing face name PFE for %x (PFE)\n", \
                                       pffo.ppfe(c));



                         pfeo.vSetLinkedFontEntry( NULL );
                     }
                     #else
                     pfeo.vSetLinkedFontEntry( NULL );
                     #endif
                 }

             }
        }
        pPFF = pPFF->pPFFNext;
    }
}



VOID vUnlinkAllEudcRFONTsAndPFEs
(
    BOOL bUnlinkSystem,
    BOOL bUnlinkFaceName
)
{
    FLINKMESSAGE(DEBUG_FONTLINK_UNLOAD,
                 "vUnlinkAllEudcRFONTsAndPFEs():Unlinking All EUDC RFONTs and PFEs.\n");

    SEMOBJ so1(ghsemPublicPFT);
    SEMOBJ so2(ghsemRFONTList);

    COUNT cBuckets;
    PPFF  pPFF;

    //
    // get PFT user object.
    //

    PUBLIC_PFTOBJ pftoPublic;  // access the public font table

    for( cBuckets = 0; cBuckets < pftoPublic.cBuckets(); cBuckets++ )
    {
        if( (pPFF = pftoPublic.pPFF(cBuckets)) != NULL )
        {
            vUnlinkAllEudcRFONTsAndPFEsWorker(bUnlinkSystem,bUnlinkFaceName,pPFF);
        }
    }

    DEVICE_PFTOBJ pftoDevice;  // access the public font table

    for( cBuckets = 0; cBuckets < pftoDevice.cBuckets(); cBuckets++ )
    {
        if( (pPFF = pftoDevice.pPFF(cBuckets)) != NULL )
        {
            vUnlinkAllEudcRFONTsAndPFEsWorker(bUnlinkSystem,bUnlinkFaceName,pPFF);
        }
    }
}

/*****************************************************************************
 * BOOL bDeleteFlEntry(PWSTR,PWSTR,INT)
 *
 * This function delete base font and linked font pair from list.
 *
 * History
 *  1-09-95 Hideyuki Nagase
 * Wrote it.
 *****************************************************************************/

BOOL bDeleteFlEntry
(
    PWSTR    BaseFontName,
    PWSTR    LinkedFontPathAndName,
    INT      iFontLinkType    // FONTLINK_SYSTEM or FONTLINK_USER
)
{
    PFLENTRY pFlEntry = NULL;
    PPFEDATA ppfeData = NULL;
    PWSTR    LinkedFaceName = NULL;
    WCHAR    awcPathBuffer[MAX_PATH];
    WCHAR    LinkedFontName[LF_FACESIZE+MAX_PATH+1];

    //
    // Have a local copy...
    //

    wcscpy(LinkedFontName,LinkedFontPathAndName);

    //
    // Find ',' char from LinkedFontName
    //
    // Registry format :
    //
    // Type 1:
    //
    //  This format is for the specified Linked font contains only 1 font resource.
    //  Except Vertical "@" face font, such as TrueType font (not TTC), and Vector font.
    //
    //  BaseFontFaceName = REG_MULTI_SZ "FontPathFileName" , ...
    //
    // Type 2:
    //
    //  This format is for the specified Linked font contains more than 1 font resource,
    //  TTC TrueType font, and Bitmap font.
    //
    //  BaseFontFaceName = REG_MULTI_SZ "FontPathFileName,FontFaceNameInTheFile" , ...
    //
    // After calling ValidLinkedRegistry(), the ',' character is replaced with NULL if
    // found.
    //

    if( !bValidFontLinkParameter(LinkedFontName,&LinkedFaceName) )
    {
        #if DBG
        DbgPrint("Invalid Registry format - %ws\n",LinkedFontName);
        #endif
        return(FALSE);
    }

    //
    // Get full path name for this font file.
    //

    bAppendSysDirectory(awcPathBuffer, LinkedFontName);

    // If this file is being used as the system EUDC file then it can't be used
    // as a facename EUDC file.


    if( _wcsicmp(awcPathBuffer,gawcEUDCPath) == 0 )
    {
        #if DBG
        DbgPrint("%ws can't be unload as a facename link because it is the system \
                 EUDC file.\n", LinkedFontName);
        #endif
        return(FALSE);
    }

    //
    // Check base font list, To remove, the base font should be listed..
    //

    if( IsListEmpty( &BaseFontListHead )                       ||
        (pFlEntry = FindBaseFontEntry( BaseFontName )) == NULL    )
    {
        //
        // We can not find out this base font in current link list.
        //
        return(FALSE);
    }

    //
    // The Entry for this base font is already exist....
    //

    #if DBG
    //
    // The FLENTRY should have one or more PFEDATA.
    //
    if( IsListEmpty( &(pFlEntry->linkedFontListHead) ) )
    {
        DbgPrint("This FLENTRY has no PFEDATA (%ws)\n",pFlEntry->awcFaceName);
    }
    #endif

    //
    // Scan linked font list for this base font.
    // if this linked font is already listed, we do not add this.
    //

    if( (ppfeData = FindLinkedFontEntry( &(pFlEntry->linkedFontListHead) ,
                                         awcPathBuffer, LinkedFaceName )   ) == NULL )
    {
        #if DBG
        if( gflEUDCDebug & (DEBUG_FONTLINK_INIT|DEBUG_FONTLINK_LOAD|DEBUG_FACENAME_EUDC) )
        {
            DbgPrint("Can not find linked font %ws -> %ws\n",BaseFontName,LinkedFontName);
        }
        #endif
        return(FALSE);
    }

    //
    // Check we can really unload this eudc font.
    //

    if( ppfeData->FontLinkType == iFontLinkType )
    {
        //
        // Now we can find out target PFEDATA.
        //

        //
        // Remove the PFEDATA from current list.
        //

        RemoveEntryList( &(ppfeData->linkedFontList) );

        //
        // Decrement number of linked list count.
        //

        pFlEntry->uiNumLinks--;

        //
        // if there is no PFEDATA for this FLENTRY...
        //

        if( pFlEntry->uiNumLinks == 0 )
        {
            #if DBG
            if( gflEUDCDebug & DEBUG_FONTLINK_UNLOAD )
            {
                DbgPrint("Deleting FLENTRY for %ws\n",pFlEntry->awcFaceName);
            }

            if(!IsListEmpty(&(pFlEntry->linkedFontListHead)))
            {
                DbgPrint("bDeleteFlEntry():Deleting FLENTRY that has PFEDATA \
                          (%ws -> %ws)\n", BaseFontName,LinkedFontName);
            }
            #endif

            //
            // disable the link of this facename.
            //

            vUnlinkEudcRFONTsAndPFEs(ppfeData->appfe,pFlEntry);

            //
            // Remove this FLENTRY from BaseFontList.
            //

            RemoveEntryList( &(pFlEntry->baseFontList) );

            //
            // Free this FLENTRY.
            //

            VFREEMEM( pFlEntry );

            //
            // Decrement global base font number
            //

            gcNumLinks--;

            //
            // BaseFontList has been change, update TimeStamp
            //

            ulFaceNameEUDCTimeStamp++;
        }
         else
        {
            //
            // disable the link of this facename Eudc.
            //

            vUnlinkEudcRFONTs(ppfeData->appfe);

            //
            // Update time stamp for this facename link.
            //

            pFlEntry->ulTimeStamp++;
        }

        //
        // Unload this Eudc font.
        //

        if( !bUnloadEudcFont( ppfeData->appfe ) )
        {
        #if DBG
            DbgPrint("bDeleteFlEntry():bUnloadEudcFont() fail - %ws\n",LinkedFontName);
        #endif
        }

        #if DBG
        if( gflEUDCDebug & DEBUG_FONTLINK_UNLOAD )
        {
            PFEOBJ pfeo(ppfeData->appfe[PFE_NORMAL]);
            PFFOBJ pffo(pfeo.pPFF());

            DbgPrint("Deleting PFEDATA for %ws\n",pffo.pwszPathname());
        }
        #endif

        //
        // Free this PFEDATA.
        //

        VFREEMEM( ppfeData );

        return(TRUE);
    }
     else
    {
        return(FALSE);
    }
}


/*****************************************************************************
 * BOOL bAddFlEntry(PWSTR,PWSTR,INT,PFLENTRY *)
 *
 * This function add new base font and linked font pair into list.
 *
 * History
 *  1-09-95 Hideyuki Nagase
 * Wrote it.
 *****************************************************************************/

BOOL bAddFlEntry
(
    PWSTR    BaseFontName,
    PWSTR    LinkedFontPathAndName,
    INT      iFontLinkType,   // FONTLINK_SYSTEM or FONTLINK_USER
    INT      iPriority,
    PFLENTRY *ppFlEntry
)
{
    PFLENTRY pFlEntry = (PFLENTRY) NULL;
    PFLENTRY tempEntry = (PFLENTRY) NULL;
    PPFEDATA ppfeData = (PPFEDATA) NULL;
    PWSTR    LinkedFaceName = NULL;
    WCHAR    awcBuf[MAX_PATH + (MAX_PATH+LF_FACESIZE)];
    PWSTR    TempPathBuffer = (PWSTR) awcBuf;
    PWSTR    LinkedFontName = (PWSTR) &awcBuf[MAX_PATH];
    BOOL     bRet = FALSE;


    gbAnyLinkedFonts = TRUE;

    //
    // if ppFlEntry is presented, initialize with NULL.
    //

    if( ppFlEntry != NULL ) 
        *ppFlEntry = NULL;

    //
    // Have a local copy...
    //

    wcscpy(LinkedFontName,LinkedFontPathAndName);

    //
    // Find ',' char from LinkedFontName
    //
    // Registry format :
    //
    // Type 1:
    //
    //  This format is for the specified Linked font contains only 1 font resource.
    //  Except Vertical "@" face font, such as TrueType font (not TTC), and Vector font.
    //
    //  BaseFontFaceName = REG_MULTI_SZ "FontPathFileName" , ...
    //
    // Type 2:
    //
    //  This format is for the specified Linked font contains more than 1 font resource,
    //  TTC TrueType font, and Bitmap font.
    //
    //  BaseFontFaceName = REG_MULTI_SZ "FontPathFileName,FontFaceNameInTheFile" , ...
    //
    // After calling ValidLinkedRegistry(), the ',' character is replaced with NULL if
    // found.
    //

    if( !bValidFontLinkParameter(LinkedFontName,&LinkedFaceName) )
    {
        #if DBG
        DbgPrint("Invalid Registry format - %ws\n",LinkedFontName);
        #endif

        return bRet;
    }

    #if DBG
    if( gflEUDCDebug & DEBUG_FONTLINK_LOAD )
    {
        if( LinkedFaceName )
        {
            DbgPrint("FontFile - %ws : FontFace - %ws\n",LinkedFontName,LinkedFaceName);
        }
    }
    #endif

    //
    // Get full path name for this font file.
    //

    bAppendSysDirectory( TempPathBuffer, LinkedFontName );

    //
    // If this file is being used as the system EUDC file then it can't be used
    // as a facename EUDC file.
    //

    if( _wcsicmp(TempPathBuffer,gawcEUDCPath) == 0 )
    {
        #if DBG
        DbgPrint(
            "%ws can't be load as a facename link because it is the system EUDC file.\n",
             LinkedFontName
        );
        #endif
        
        return bRet;
    }

    //
    // Check base font list, it is a new one ?
    //

    if( !IsListEmpty( &BaseFontListHead )                      &&
        (pFlEntry = FindBaseFontEntry( BaseFontName )) != NULL    )
    {
        //
        // The Entry for this base font is already exist....
        //

        if( !IsListEmpty( &(pFlEntry->linkedFontListHead) ) )
        {
            //
            // Scan linked font list for this base font.
            // if this linked font is already listed, we do not add this.
            //

            if( FindLinkedFontEntry( &(pFlEntry->linkedFontListHead) ,
                                     TempPathBuffer , LinkedFaceName ) != NULL )
            {
                #if DBG
                DbgPrint("Dupulicate linked font - %ws\n",LinkedFontName);
                #endif

                return bRet;
            }
        }
    }

    {
        //
        // get and validate PFT user object
        //

        PUBLIC_PFTOBJ  pfto;          // access the public font table
        PPFE           appfeLink[2];  // temporary buffer
        LONG           cFonts;        // count of fonts
        EUDCLOAD       EudcLoadData;  // eudc load data

        //
        // parameter for PFTOBJ::bLoadFonts()
        //

        FLONG          flParam = PFF_STATE_EUDC_FONT;

        //
        // Fill up EudcLoadData structure
        //

        EudcLoadData.pppfeData  = (PPFE *) &appfeLink;
        EudcLoadData.LinkedFace = LinkedFaceName;

        //
        // if the FontLinkType is system, it should be a Permanent font.
        //

        if( iFontLinkType == FONTLINK_SYSTEM )
        {
            flParam |= PFF_STATE_PERMANENT_FONT;
        }


        if( pFlEntry == NULL )
        {
        // Allocate new FLENTRY..

            tempEntry = pFlEntry = (PFLENTRY) PALLOCNOZ( sizeof(FLENTRY), 'flnk' );

            if (!pFlEntry)
            {
                goto FreeMemAndExit;
            }

        }

        //
        // Allocate new PFEDATA...
        //

        ppfeData = (PPFEDATA) PALLOCNOZ(sizeof(PFEDATA), 'flnk' );

        if (!ppfeData)
        {
            goto FreeMemAndExit;
        }

        //
        // Load the linked font.
        //

        PFF *placeHolder;

        if( pfto.bLoadAFont( TempPathBuffer,
                             (PULONG) &cFonts,
                             flParam,
                             &placeHolder,
                             &EudcLoadData ) )
        {
            //
            // Check we really succeed to load requested facename font.
            //
            if(!bComputeQuickLookup( NULL, appfeLink[PFE_NORMAL], FALSE ))
            {
            //
            // Compute table for normal face
            //
                WARNING("Unable to compute QuickLookUp for face name link\n");

                pfto.bUnloadEUDCFont(TempPathBuffer);
    
                goto FreeMemAndExit;
            }
            
            //
            // Compute table for vertical face, if vertical face font is provided,
            //

            if( !bComputeQuickLookup( NULL, appfeLink[PFE_VERTICAL], FALSE ))
            {
                WARNING("Unable to compute QuickLookUp for face name link\n");

                pfto.bUnloadEUDCFont(TempPathBuffer);

                goto FreeMemAndExit;
            }

            if (tempEntry)
            {
    
                
            // Initialize number of linked font count.

                pFlEntry->uiNumLinks = 0;

            // Initialize link time stamp

                pFlEntry->ulTimeStamp = 0;

            // Copy base font name to buffer.

                wcscpy(pFlEntry->awcFaceName,BaseFontName);

            // Initialize linked font list for this base font.

                InitializeListHead( &(pFlEntry->linkedFontListHead) );

            // Add this entry to BaseFontList.

                InsertTailList( &BaseFontListHead , &(pFlEntry->baseFontList) );

            // Increment global base font number

                gcNumLinks++;

            // just notify new FLENTRY was allocated to caller

                if( ppFlEntry != NULL ) 
                    *(PFLENTRY *)ppFlEntry = pFlEntry;

            // BaseFontList has been change, update TimeStamp

                ulFaceNameEUDCTimeStamp++;
            }
                
            #if DBG
            if(gflEUDCDebug&(DEBUG_FONTLINK_LOAD|DEBUG_FONTLINK_INIT|DEBUG_FACENAME_EUDC))
            {
                DbgPrint("Allocate PFEDATA for %ws - %ws\n",BaseFontName,LinkedFontName);
            }
            #endif

            //
            // Set PFE for linked font into the structure.
            //

            ppfeData->appfe[PFE_NORMAL] = appfeLink[PFE_NORMAL];
            ppfeData->appfe[PFE_VERTICAL] = appfeLink[PFE_VERTICAL];

            //
            // Set FontLinkType.
            //

            ppfeData->FontLinkType = iFontLinkType;

            //
            // Set FontLinkFlag.
            //

            ppfeData->FontLinkFlag = 0L;

            if( EudcLoadData.LinkedFace )
                ppfeData->FontLinkFlag |= FLINK_FACENAME_SPECIFIED;

            //
            // Incremant number of linked font count for this base face name.
            //

            pFlEntry->uiNumLinks++;

            //
            // Update time stamp
            //

            pFlEntry->ulTimeStamp++;

            //
            // add pfe for this font our list of flinks
            //

            if( iPriority < 0 )
            {
            //
            // Insert end of this list.
            //

                InsertTailList(&(pFlEntry->linkedFontListHead),
                               &(ppfeData->linkedFontList) );
            }
            else // later if( iPriority == 0 )
            {
                //
                // Insert top of this list.
                //

                InsertHeadList(&(pFlEntry->linkedFontListHead),
                               &(ppfeData->linkedFontList));
            }

            bRet = TRUE;
        }
        else
        {
            #if DBG
            DbgPrint("Failed to load EUDC font - %ws\n",TempPathBuffer);
            #endif
        }
    }

FreeMemAndExit:

    if (!bRet)
    {
        if(tempEntry)
        {
            VFREEMEM(tempEntry);
        }
        
        if (ppfeData)
        {
            VFREEMEM(ppfeData);
        }
    }

    return(bRet);
}

/*****************************************************************************
 * BOOL bDeleteAllFlEntry(BOOL,BOOL)
 *
 * This function delete all linked font information including system wide eudc.
 *
 * History
 *  1-09-95 Hideyuki Nagase
 * Wrote it.
 *****************************************************************************/

BOOL bDeleteAllFlEntry
(
    BOOL bDeleteSystem,
    BOOL bDeleteFaceName
)
{
    BOOL bRet = TRUE;
    PFEDATA **UnloadBuffer;
    PFEDATA **UnloadBufferNew;
    ULONG NumUnload = 0;
    ULONG MaxUnload = 40;
    PFE *LocalppfeSysEUDC[2] = {NULL, NULL};

    //
    // make sure we are the only ones changing the EUDC data
    //

    GreAcquireSemaphore( ghsemEUDC1 );

    ASSERTGDI(gcEUDCCount >= 0, "gcEUDCCount < 0");

    if (gcEUDCCount > 0)
    {
        //
        // another EUDC API is currently in progress
        //

        FLINKMESSAGE(DEBUG_FONTLINK_LOAD|DEBUG_FONTLINK_UNLOAD,
         " another EUDC API is currently in progress. bDeleteAllFlEntry() is failed.\n");
        EngSetLastError(ERROR_LOCK_FAILED);
        GreReleaseSemaphore( ghsemEUDC1 );
        return(FALSE);
    }

    UnloadBuffer = (PFEDATA **)PALLOCNOZ(sizeof(PFEDATA *) * MaxUnload, 'dueG');
    if (!UnloadBuffer) {
        MaxUnload = 0;
    }

// disable the link of all facename and system wide eudc.

    vUnlinkAllEudcRFONTsAndPFEs(bDeleteSystem,bDeleteFaceName);

// if there is no system wife eudc font.. skip it.

    if( bDeleteSystem && IS_SYSTEM_EUDC_PRESENT() )
    {
    // Unload system wide eudc font

        LocalppfeSysEUDC[PFE_NORMAL] = gappfeSysEUDC[PFE_NORMAL];
        LocalppfeSysEUDC[PFE_VERTICAL] = gappfeSysEUDC[PFE_VERTICAL];

    // Clear global data.

        gappfeSysEUDC[PFE_NORMAL]   = NULL;
        gappfeSysEUDC[PFE_VERTICAL] = NULL;

        wcscpy(gawcEUDCPath,L"\0");

        ulSystemEUDCTimeStamp++;
    }

// if there is no facename eudc, just return here.

    if( bDeleteFaceName && !IsListEmpty(&BaseFontListHead) )
    {
        COUNT NumberOfLinks = gcNumLinks;

    // start to scan facename link list.

        PLIST_ENTRY p = BaseFontListHead.Flink;

        while( p != &BaseFontListHead )
        {
            PFLENTRY    pFlEntry;
            PLIST_ENTRY pDelete = p;
            ULONG       AlivePfeData = 0;

            pFlEntry = CONTAINING_RECORD(pDelete,FLENTRY,baseFontList);

        // if there is no linked font for this base face, try next base font.

            if(IsListEmpty(&(pFlEntry->linkedFontListHead)))
            {
                continue;
            }

        // get pointer to PFEDATA list.

            PLIST_ENTRY pp = pFlEntry->linkedFontListHead.Flink;

            FLINKMESSAGE2((DEBUG_FONTLINK_LOAD|DEBUG_FONTLINK_UNLOAD),
                          "Delete %ws link\n",pFlEntry->awcFaceName);

            while( pp != &(pFlEntry->linkedFontListHead) )
            {
                PPFEDATA     ppfeData;
                PLIST_ENTRY  ppDelete = pp;

                ppfeData = CONTAINING_RECORD(ppDelete,PFEDATA,linkedFontList);

            // Check Current FontLinkChange state to see if we can really unload
            // EUDC font.

                if( (ppfeData->FontLinkType == FONTLINK_SYSTEM &&
                     ulFontLinkChange & FLINK_UNLOAD_FACENAME_SYSTEM) ||
                    (ppfeData->FontLinkType == FONTLINK_USER   &&
                     ulFontLinkChange & FLINK_UNLOAD_FACENAME_USER))
                {
                // Remember PFE to unload font later.

                    if (MaxUnload == NumUnload) {
                        UnloadBufferNew = (PFEDATA **)PALLOCNOZ(sizeof(PFEDATA *) * MaxUnload + 10, 'dueG');
                        if (UnloadBufferNew) {
                            MaxUnload += 10;
                            memcpy(UnloadBufferNew, UnloadBuffer, sizeof(PFEDATA *) * NumUnload);
                            VFREEMEM(UnloadBuffer);
                            UnloadBuffer = UnloadBufferNew;
                        }
                    }
                    if (MaxUnload > NumUnload) 
                    {
                        UnloadBuffer[NumUnload++] = ppfeData;

                        pp = ppDelete->Flink;

                        // Delete this PFEDATA from this link list

                        RemoveEntryList(ppDelete);
                     } else {
                    // This PFEDATA is still valid...

                        AlivePfeData++;
                        pp = ppDelete->Flink;
                        bRet = FALSE;
                    }
                }
                else
                {
                // This PFEDATA is still valid...

                    AlivePfeData++;
                    pp = ppDelete->Flink;
                }
            }

        // next FLENTRY...

            p = pDelete->Flink;

            if( AlivePfeData == 0 )
            {
            // Delete this FLENTRY from link list

                RemoveEntryList(pDelete);

            // Free FLENTRY

                VFREEMEM(pDelete);

            // Decrement number of facename links

                gcNumLinks--;
            }
            else
            {
                if( pFlEntry->uiNumLinks != AlivePfeData )
                {
                // Update Timestamp for this

                    pFlEntry->ulTimeStamp++;

                // Update number of linked font.

                    pFlEntry->uiNumLinks = AlivePfeData;
                }
            }
        }

        if( NumberOfLinks != gcNumLinks )
        {
        // BaseFontList has been changed, update TimeStamp

            ulFaceNameEUDCTimeStamp++;
        }

        if( gcNumLinks != 0 )
        {
        // Connect to loaded PFEs for valid FLENTRY/PFEDATA.

            vLinkEudcPFEs(NULL);
        }
    }

    GreReleaseSemaphore( ghsemEUDC1 );

// if there is no system wide eudc font.. skip it.

    if( bDeleteSystem && 
       ((LocalppfeSysEUDC[PFE_NORMAL] != NULL) || (LocalppfeSysEUDC[PFE_VERTICAL] != NULL)))
    {
    // Unload system wide eudc font

        if( !bUnloadEudcFont( LocalppfeSysEUDC ) )
        {
            WARNING("bDeleteAllFlEntry():Can not unload system wide eudc\n");
        }
    }

    for (ULONG i = 0; i < NumUnload; i++) {
        if( !bUnloadEudcFont(UnloadBuffer[i]->appfe)) {
            WARNING("bDeleteAllFlEntry():Can not unload eudc\n");
        }
        VFREEMEM(UnloadBuffer[i]);
    }

    VFREEMEM(UnloadBuffer);

    return(bRet);
}

/*****************************************************************************
 * NTSTATUS BuildAndLoadLinkedFontRoutine(PWSTR,ULONG,PVOID,ULONG,PVOID,PVOID)
 *
 * This is a callback function that is called by RtlQueryRegistryValues()
 *
 * History
 *  1-09-95 Hideyuki Nagase
 * Wrote it.
 *****************************************************************************/
extern "C"
NTSTATUS
BuildAndLoadLinkedFontRoutine
(
    PWSTR ValueName,
    ULONG ValueType,
    PVOID ValueData,
    ULONG ValueLength,
    PVOID Context,
    PVOID EntryContext
)
{
    PWSTR FontPathName = (PWSTR) PALLOCNOZ((MAX_PATH+LF_FACESIZE)*sizeof(WCHAR),'flnk');

    if (FontPathName == NULL) {
        return (STATUS_NO_MEMORY);
    }

    #if DBG
    if( gflEUDCDebug & (DEBUG_FACENAME_EUDC|DEBUG_FONTLINK_INIT) )
    {
        DbgPrint("BaseFontName - %ws : LinkedFont - %ws\n",ValueName,ValueData);
    }
    #endif

// if this is a value for System EUDC, return here...

    if(_wcsicmp(ValueName,(PWSTR)L"SystemDefaultEUDCFont") == 0)
    {
        goto FreeMem;
    }

// Copy it to local buffer and make sure its null-termination.

    RtlMoveMemory(FontPathName,ValueData,ValueLength);
    FontPathName[ValueLength/sizeof(WCHAR)] = L'\0';

// Add base font and linked font pair into global list..

// Sundown: the 3rd parameter to bAddFlEntry is iFontlinkType int
    if(!bAddFlEntry(ValueName,(PWSTR)FontPathName,(INT)(ULONG_PTR)EntryContext,-1,NULL))
    {
        WARNING("BuildAndLoadLinkedFontRoutine():lAddFlEntry() fail\n");
    }

FreeMem:
    VFREEMEM(FontPathName);

// return STATUS_SUCCESS everytime,even we got error from above call, to
// get next enumuration.

    return(STATUS_SUCCESS);
}

/*****************************************************************************
 * NTSTATUS bAddAllFlEntryWorker(LPWSTR,INT)
 *
 *  This function load font and build link for eudc font according to registry.
 *
 * History
 *  1-09-95 Hideyuki Nagase
 * Wrote it.
 *****************************************************************************/

NTSTATUS bAddAllFlEntryWorker
(
    LPWSTR EUDCRegistryPath,
    INT    FontLinkType       // FONTLINK_SYSTEM or FONTLINK_USER
)
{
    NTSTATUS NtStatus;

    //
    // initialize/load face name eudc
    //

    SharedQueryTable[0].QueryRoutine = BuildAndLoadLinkedFontRoutine;
    SharedQueryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    SharedQueryTable[0].Name = (PWSTR)NULL;
    SharedQueryTable[0].EntryContext = (PVOID)(ULONG_PTR)FontLinkType;
    SharedQueryTable[0].DefaultType = REG_NONE;
    SharedQueryTable[0].DefaultData = NULL;
    SharedQueryTable[0].DefaultLength = 0;

    SharedQueryTable[1].QueryRoutine = NULL;
    SharedQueryTable[1].Flags = 0;
    SharedQueryTable[1].Name = (PWSTR)NULL;

    //
    // Enumurate registry values
    //

    NtStatus = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                      EUDCRegistryPath,
                                      SharedQueryTable,
                                      NULL,
                                      NULL);

    return(NtStatus);
}

/*****************************************************************************
 * BOOL bAddAllFlEntry(BOOL,BOOL,INT)
 *
 *  This function load font and build link for eudc font according to registry.
 *
 * History
 *  1-09-95 Hideyuki Nagase
 * Wrote it.
 *****************************************************************************/

BOOL bAddAllFlEntry
(
    BOOL bAddSystem,
    BOOL bAddFaceName
)
{
    NTSTATUS NtStatus;
    BOOL     bLoadSystem = FALSE;
    WCHAR    TempPathBuffer1[MAX_PATH];
    WCHAR    TempPathBuffer2[MAX_PATH];

    FLINKMESSAGE(DEBUG_FONTLINK_INIT|DEBUG_FONTLINK_LOAD,
                 "bAddAllFlEntry():Initializing EUDC data.\n");

    //
    // make sure we are the only ones changing the EUDC data
    //

    GreAcquireSemaphore( ghsemEUDC1 );

    ASSERTGDI(gcEUDCCount >= 0, "gcEUDCCount < 0");

    if (gcEUDCCount > 0)
    {
        //
        // another EUDC API is currently in progress
        //

        FLINKMESSAGE(DEBUG_FONTLINK_LOAD|DEBUG_FONTLINK_UNLOAD,
         " another EUDC API is currently in progress. bAddAllFlEntry() is failed.\n");            
        EngSetLastError(ERROR_LOCK_FAILED);          
        GreReleaseSemaphore( ghsemEUDC1 );
        return(FALSE);
    }

// initialize/load the system-wide ( all face-name EUDC font )

    if( bAddSystem && !IS_SYSTEM_EUDC_PRESENT() )
    {
        //
        // read registry data for System eudc
        //

        if(bReadUserSystemEUDCRegistry(TempPathBuffer1, MAX_PATH))
        {
            PPFE appfeSysEUDC[2];

            //
            // Search system-wide EUDC font. if the specified registry value does not
            // contain full path name.
            //
            // bAppendSysDirectory return TRUE, when we have to update registry data.
            // otherwise return FALSE.
            //
            // If the Eudc file is under Windows root directory (ex. WINNT) we want to
            // update registry data. because we might fail to load EUDC after user had
            // change System root with Disk Administrator.
            //

            if( bAppendSysDirectory(TempPathBuffer2,TempPathBuffer1) )
            {
            #ifdef PORTABLE_WINDOWS_DIR
                //
                // Update registry data.
                //

                LPWSTR pwcSavePath;

                //
                // if registry data contains full path, and the file is under windows
                // directory, replace the hardcodeed path with %SystemRoot%....
                //
                if((pwcSavePath = pwcFileIsUnderWindowsRoot(TempPathBuffer1) ) != NULL )
                {
                    WCHAR awcSystemEudcPath[MAX_PATH];

                    wcscpy( awcSystemEudcPath, L"%SystemRoot%" );
                    if( *pwcSavePath != L'\\' ) wcscat( awcSystemEudcPath, L"\\" );
                    wcscat( awcSystemEudcPath, pwcSavePath );

                    pwcSavePath = awcSystemEudcPath;

                    FLINKMESSAGE(DEBUG_FONTLINK_LOAD,
                                 "bAddAllFlEntry():Eudc Path %ws is Saved\n");

                    if(!bWriteUserSystemEUDCRegistry(pwcSavePath,wcslen(pwcSavePath)+1))
                    {
                        WARNING("Unable to write new link to registry.\n");
                    }
                }
            #else
                ;
            #endif
            }
            
            //
            // NOTE :
            //
            //  Currently Systen wide EUDC does not support Type 1 Registry format.
            // See description in bAddFlEntry().
            //

            //
            // get and validate PFT user object
            //

            PUBLIC_PFTOBJ  pfto;  // access the public font table

            ASSERTGDI (
                pfto.bValid(),
                "gdisrv!bAddAllFlEntry(): could not access the public font table\n"
            );

            {
                SEMOBJ so(ghsemPublicPFT);

                //
                // Check this font is already loaded as Eudc font or not.
                //

                if( !pfto.pPFFGet(TempPathBuffer2,
                                  wcslen(TempPathBuffer2) + 1, // cwc
                                  1,                           // cFiles
                                  NULL,                        // pdv
                                  0,                           // cjDV
                                  NULL,                        // pppPFE
                                  TRUE) )                      // bEudc
                {
                    EUDCLOAD EudcLoadData;

                    //
                    // fill up EUDCLOAD structure
                    //

                    EudcLoadData.pppfeData  = (PPFE *) &appfeSysEUDC;
                    EudcLoadData.LinkedFace = NULL;

                    //
                    // load this font as eudc font.
                    //

                    LONG cFonts;  // count of fonts
                    PFF *placeHolder;

                    bLoadSystem = pfto.bLoadAFont( (PWSZ) TempPathBuffer2,
                                                   (PULONG) &cFonts,
                                                    PFF_STATE_EUDC_FONT,
                                                    &placeHolder,
                                                    &EudcLoadData );
                }
                 else
                {
                    #if DBG
                    DbgPrint("bAddAllElEntry():%ws is loaded as EUDC already\n",
                             TempPathBuffer2);
                    #endif

                    bLoadSystem = FALSE;
                }
            }

            if( bLoadSystem )
            {
                //
                // Compute table besed on normal face
                //

                if(!bComputeQuickLookup( &gqlEUDC, appfeSysEUDC[PFE_NORMAL], TRUE ) )
                {
                    WARNING("Unable to compute QuickLookUp for system EUDC\n");

                //
                // Unload font..
                //

                    pfto.bUnloadEUDCFont(TempPathBuffer2);

                    gappfeSysEUDC[PFE_NORMAL] = NULL;
                    gappfeSysEUDC[PFE_VERTICAL] = NULL;

                    wcscpy(gawcEUDCPath,L"\0");
                }
                else
                {
                    //
                    // We believe that vertical face has same glyphset as normal face.
                    //

                    //
                    // Update system wide Eudc global data..
                    //
                    
                    gappfeSysEUDC[PFE_NORMAL]   = appfeSysEUDC[PFE_NORMAL];
                    gappfeSysEUDC[PFE_VERTICAL] = appfeSysEUDC[PFE_VERTICAL];

                    wcscpy(gawcEUDCPath,TempPathBuffer2);

                    //
                    // Update global eudc timestamp.
                    //

                    ulSystemEUDCTimeStamp++;
                }
            }
             else
            {
                //WARNING("Failed to load system wide EUDC font.\n");

                gappfeSysEUDC[PFE_NORMAL]   = PPFENULL;
                gappfeSysEUDC[PFE_VERTICAL] = PPFENULL;

                wcscpy(gawcEUDCPath,L"\0");
            }

            #if DBG
            if( gflEUDCDebug & (DEBUG_SYSTEM_EUDC|DEBUG_FONTLINK_INIT) )
            {
                DbgPrint("EUDC system wide %ws hpfe is %x vert hpfe is %x\n",
                          gawcEUDCPath, gappfeSysEUDC[PFE_NORMAL],
                         gappfeSysEUDC[PFE_VERTICAL]);
            }
            #endif
        }
        else
        {
            WARNING("GDISRV:Fail to read system wide eudc\n");
        }
    }

    if( bAddFaceName )
    {
        if( ulFontLinkChange & FLINK_LOAD_FACENAME_SYSTEM )
        {
            //
            // Call worker function.
            //

            NtStatus = bAddAllFlEntryWorker(EUDC_SYSTEM_REGISTRY_KEY,FONTLINK_SYSTEM);

            #if DBG
            if( !NT_SUCCESS(NtStatus) )
            {
                WARNING1("Face name eudc is disabled (FONTLINK_SYSTEM)\n");
            }
            #endif
        }

        if( ulFontLinkChange & FLINK_LOAD_FACENAME_USER )
        {
            HANDLE hKey = NULL;
            HANDLE hKeyLink = NULL;
            BOOL bIsEqual = FALSE;

            //
            // Get Registry path for Eudc..
            //

            GetUserEUDCRegistryPath(TempPathBuffer1,MAX_PATH);

            // if the registry entry is a symbolic link, fail the call
            if (bNotIsKeySymbolicLink (TempPathBuffer1, &hKey, &hKeyLink, &bIsEqual) &&
                bIsEqual)
            {
                //
                // Call worker function.
                //

                NtStatus = bAddAllFlEntryWorker(TempPathBuffer1,FONTLINK_USER);
            }
            else
            {
                NtStatus = (STATUS_SEVERITY_ERROR << 30);  // any non-zero error is sufficient
            }

            if (hKey)
                ZwClose (hKey);
            if (hKeyLink)
                ZwClose (hKeyLink);

            #if DBG
            if( !NT_SUCCESS(NtStatus) )
            {
                WARNING1("Face name eudc is disabled (FONTLINK_USER)\n");
            }
            #endif
        }

        //
        // Connect to loaded PFEs.
        //

        vLinkEudcPFEs(NULL);
    }

    GreReleaseSemaphore( ghsemEUDC1 );

    return(TRUE);
}



/*****************************************************************************
 * BOOL bInitializeEUDC(VOID)
 *
 * This is called once during win32k.sys initialization and initializes the
 * system EUDC information.  First it creates a FLINKOBJ and set ghflEUDC to
 * it.  Then it initializes the FLINKOBJ with information from the registry.
 * After that it loads all the EUDC fonts and sets up links between base
 * font PFE's and EUDC font pfe's.
 *
 * History
 *  1-09-95 Hideyuki Nagase
 * Rewrote it.
 *
 *  2-10-93 Gerrit van Wingerden
 * Wrote it.
 *****************************************************************************/

BOOL bInitializeEUDC(VOID)
{
    NTSTATUS NtStatus;

    FLINKMESSAGE(DEBUG_FONTLINK_INIT,
                 "bInitializeEUDC():Initializing EUDC data.\n");

    gawcEUDCPath[0] = L'\0';

// Set up Global EUDC semaphores

    if ( !(ghsemEUDC1 = GreCreateSemaphore()))
    {
        return FALSE;
    }

    if ( !(ghsemEUDC2 = GreCreateSemaphore()))
    {
        return FALSE;
    }

    // KeInitializeEvent( &gfmEUDC2, SynchronizationEvent, FALSE );

    // Set up EUDC QUICKLOOKUP Table

    gqlEUDC.puiBits = NULL;
    gqlEUDC.wcLow   = 1;
    gqlEUDC.wcHigh  = 0;

// Get Current codepage to access registry..

    USHORT usACP,usOEMCP;

    EngGetCurrentCodePage(&usOEMCP,&usACP);

// Convert Integer to Unicode string..

    UNICODE_STRING SystemACPString;

    SystemACPString.Length = 0;
    SystemACPString.MaximumLength = sizeof(gawcSystemACP);
    SystemACPString.Buffer = gawcSystemACP;

    RtlIntegerToUnicodeString( (int) usACP, 10, &SystemACPString );

    FLINKMESSAGE2(DEBUG_FONTLINK_INIT,"GDISRV:System ACP is %ws\n",gawcSystemACP);

// Read FontLink configuration value.

    SharedQueryTable[0].QueryRoutine = NULL;
    SharedQueryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED |
                                RTL_QUERY_REGISTRY_DIRECT;
    SharedQueryTable[0].Name = (PWSTR)L"FontLinkControl";
    SharedQueryTable[0].EntryContext = (PVOID) &ulFontLinkControl;
    SharedQueryTable[0].DefaultType = REG_DWORD;
    SharedQueryTable[0].DefaultData = 0;
    SharedQueryTable[0].DefaultLength = 0;

    SharedQueryTable[1].QueryRoutine = NULL;
    SharedQueryTable[1].Flags = 0;
    SharedQueryTable[1].Name = (PWSTR)NULL;

    NtStatus = RtlQueryRegistryValues(RTL_REGISTRY_WINDOWS_NT,
                                      L"FontLink",
                                      SharedQueryTable,
                                      NULL,
                                      NULL);

    if(!NT_SUCCESS(NtStatus))
    {
        // WARNING("Error reading FontLinkControl\n");
        ulFontLinkControl = 0L;
    }

    FLINKMESSAGE2(DEBUG_FONTLINK_CONTROL,
                  "win32ksys:FontLinkControl = %x\n",ulFontLinkControl);

// initialize Eudc default char code in Unicode.

    DWORD dwEudcDefaultChar;

    SharedQueryTable[0].Name = (PWSTR)L"FontLinkDefaultChar";
    SharedQueryTable[0].EntryContext = (PVOID) &dwEudcDefaultChar;

    NtStatus = RtlQueryRegistryValues(RTL_REGISTRY_WINDOWS_NT,
                                      L"FontLink",
                                      SharedQueryTable,
                                      NULL,
                                      NULL);

    if(!NT_SUCCESS(NtStatus))
    {
        // WARNING("Error reading FontLinkDefaultChar\n");
        EudcDefaultChar = 0x30fb;
    }
    else
    {
        EudcDefaultChar = (WCHAR)dwEudcDefaultChar;
    }

// initialize base font list

    InitializeListHead(&BaseFontListHead);

// if FontLink feature is disabled, nothing to do.....

    if( ulFontLinkControl & FLINK_DISABLE_FONTLINK )
    {
        return TRUE;
    }

// Load and setup SYSTEM Global facename EUDC data.

    ulFontLinkChange = FLINK_LOAD_FACENAME_SYSTEM   |
                       FLINK_UNLOAD_FACENAME_SYSTEM;

// Enable only FaceName (system common) EUDC.
    bAddAllFlEntry(FALSE,TRUE);

// After load system global EUDC, we will only allow to user to
// load/unload per user eudc configuration.

    ulFontLinkChange = FLINK_LOAD_FACENAME_USER   |
                       FLINK_UNLOAD_FACENAME_USER;

// Initialize font association scheme.

    vInitializeFontAssocStatus();

    return TRUE;
}



/*****************************************************************************\
 * GreEnableEUDC( BOOL bEnable )
 *
 * This routine enable/disable system wide/face name specific EUDCs
 *
 * History:
 *  23-Jan-1995 Hideyuki Nagase
 * Wrote it.
 *****************************************************************************/

BOOL GreEnableEUDC
(
    BOOL bEnableEUDC
)
{
    BOOL bRet = TRUE;

    //
    // This quick check for non-zero ghsemEUDC1 is a work around for hydra
    // cleanup assertions
    //

    if (!ghsemEUDC1 || !ghsemEUDC2)
    {
       return TRUE;
    }

    GreAcquireSemaphore( ghsemEUDC2 );

    if( bEnableEUDC )
    {
        //
        // if DefaultLink is ready to initalize and its is not initialized,
        // do the initialization.
        //

        if( (bReadyToInitializeFontAssocDefault == TRUE ) &&
            (bFinallyInitializeFontAssocDefault == FALSE)   )
        {
            //
            // Load default linked font and fill up nessesary data fields.
            //

            if( bSetupDefaultFlEntry()) {

                //
                // Yes, we finally initialized default link font successfully.
                //

                bFinallyInitializeFontAssocDefault = TRUE;
            }
        }
    }

    if( bEnableEUDC )
    {
        //
        // Enable EUDC link.
        //
        
        bRet = bAddAllFlEntry(TRUE,TRUE);

    }
    else
    {
        // Disable EUDC link.
        
        bRet = bDeleteAllFlEntry(TRUE,TRUE);
    }

    GreReleaseSemaphore( ghsemEUDC2 );

    return(bRet);
}

/*****************************************************************************\
 * GreEudcLoadLinkW(LPWSTR,COUNT,LPWSTR,COUNT,INT,INT)
 *
 * Establishes a font file as the source of EUDC glyphs for the system.  Any
 * subsequent TextOut or GetTextMetrics related calls will reflect this
 * change immediately.
 *
 * History:
 *  13-01-95 Hideyuki Nagase
 * Rewrote it.
 *  02-10-93 Gerrit van Wingerden
 * Wrote it.
 *****************************************************************************/

BOOL GreEudcLoadLinkW
(
    LPWSTR lpBaseFaceName,   // guaranteed to be NULL terminated
    COUNT  cwcBaseFaceName,
    LPWSTR lpEudcFontPath,   // guaranteed to be NULL terminated
    COUNT  cwcEudcFontPath,
    INT    iPriority,
    INT    iFontLinkType
)
{


    BOOL bRet = TRUE;

    ASSERTGDI(lpEudcFontPath != NULL,"GreEudcLoadLinkW():lpEudcFontPath == NULL\n");
    ASSERTGDI(cwcEudcFontPath != 0,"GreEudcLoadLinkW():cwcEudcFontPath == 0\n");

    FLINKMESSAGE(DEBUG_FONTLINK_LOAD,"GreEudcLoadLinkW\n");

    GreAcquireSemaphore( ghsemEUDC1 );
    
    //
    // if text related API's using EUDC characters are in progess we must
    // wait
    //

    ASSERTGDI(gcEUDCCount >= 0, "gcEUDCCount < 0");

    if (gcEUDCCount > 0)
    {
        #if DBG
        if( gflEUDCDebug & DEBUG_FONTLINK_LOAD )
        {
            DbgPrint("GreEudcLoadLinkW is waiting.\n");
        }
        #endif

        // When the last text related API using EUDC characters finishes it will
        // release us.

        EngSetLastError(ERROR_LOCK_FAILED);
        GreReleaseSemaphore( ghsemEUDC1 );
        return (FALSE);
    }

    // Is this a request to load system wide eudc ?

    if( lpBaseFaceName == NULL )
    {
        WCHAR awcSystemEudcPath[MAX_PATH+1];

        // Get full path name of the requested font..

        bAppendSysDirectory( awcSystemEudcPath , lpEudcFontPath );

        PPFE  appfeNew[2];

        {
            SEMOBJ  so(ghsemPublicPFT);

            // Get and validate PFT user object

            PUBLIC_PFTOBJ  pfto;

            ASSERTGDI(pfto.bValid(),
                      "GreLoadLinkW():could not access the public font table\n");

            // check this font file is loaded as eudc already.

            if( !pfto.pPFFGet(awcSystemEudcPath,
                              wcslen(awcSystemEudcPath) + 1, // cwc
                              1,                             // cFiles
                              NULL,                          // pdv
                              0,                             // cjDV
                              NULL,                          // pppPFF
                              TRUE) )                        // bEudc
            {
                EUDCLOAD EudcLoadData;

                // fill up EUDCLOAD structure

                EudcLoadData.pppfeData  = (PPFE *) &appfeNew;
                EudcLoadData.LinkedFace = NULL;

                // load font..

                ULONG cFonts;
                PFF   *placeHolder;

                bRet = pfto.bLoadAFont( awcSystemEudcPath,
                                        (PULONG) &cFonts,
                                        PFF_STATE_EUDC_FONT,
                                        &placeHolder,
                                        &EudcLoadData);
            }
             else
            {
                //
                // this font file is already loaded as EUDC..
                //

                #if DBG
                DbgPrint("GreLoadLinkW():%ws is loaded as EUDC already\n",
                         awcSystemEudcPath);
                #endif

                bRet = FALSE;
            }
        }

        if( bRet )
        {
            //
            // now we can load new system wide eudc font..
            // if we have system wide eudc font, deactivate and unload it..
            //

            if( IS_SYSTEM_EUDC_PRESENT() )
            {
                //
                // disable the link of all facename and system wide eudc.
                //

                vUnlinkAllEudcRFONTsAndPFEs(TRUE,FALSE);

                //
                // Unload system wide eudc font
                //

                bUnloadEudcFont( gappfeSysEUDC );
            }

            //
            // set new system wide eudc data to global variable.
            //
            
            gappfeSysEUDC[PFE_NORMAL]   = appfeNew[PFE_NORMAL];
            gappfeSysEUDC[PFE_VERTICAL] = appfeNew[PFE_VERTICAL];

            wcscpy(gawcEUDCPath,awcSystemEudcPath);

            //
            // Update global eudc timestamp.
            //

            ulSystemEUDCTimeStamp++;

            //
            // Finally compute the QuickLookup structure for the system EUDC font
            //

            if(!bComputeQuickLookup( &gqlEUDC, appfeNew[PFE_NORMAL], TRUE ))
            {
                WARNING("GreLoadLinkW:Unable to compute QuickLookUp for system EUDC\n");
            }


            //

            //
            // Update registry data.
            //

            LPWSTR pwcSavePath;

            #ifdef PORTABLE_WINDOWS_DIR
            if( ( pwcSavePath = pwcFileIsUnderWindowsRoot( gawcEUDCPath ) ) != NULL )
            #else
            if( FALSE )
            #endif
            {
                wcscpy( awcSystemEudcPath, L"%SystemRoot%" );
                if( *pwcSavePath != L'\\' ) wcscat( awcSystemEudcPath, L"\\" );
                wcscat( awcSystemEudcPath, pwcSavePath );

                pwcSavePath = awcSystemEudcPath;
            }
             else
            {
                pwcSavePath = gawcEUDCPath;
            }

            FLINKMESSAGE(DEBUG_FONTLINK_LOAD,"GreLoadLinkW():Eudc Path %ws is Saved\n");

            if( !bWriteUserSystemEUDCRegistry(pwcSavePath,wcslen(pwcSavePath)+1) )
            {
                WARNING("Unable to write new link to registry.\n");
            }
        }
         else
        {
            //
            // Fail to load ...
            //

            #if DBG
            DbgPrint("GreLoadLinkW():%ws is could not be loaded\n",awcSystemEudcPath);
            #endif
        }
    }
     else
    {
        PFLENTRY pFlEntry;

        //
        // if we got invalid fontlink type, just force change to FONTLINK_USER
        //

        if( (iFontLinkType != FONTLINK_SYSTEM) &&
            (iFontLinkType != FONTLINK_USER  )    )
        {
            iFontLinkType = FONTLINK_USER;
        }

        //
        // this is request for facename link.
        //

        bRet = bAddFlEntry(lpBaseFaceName,lpEudcFontPath,iFontLinkType,iPriority,
                           &pFlEntry);

        if( bRet )
        {
            //
            // check new FLENTRY is allocated or not.
            //

            if( pFlEntry != NULL )
            {
                //
                // if new FLENTRY is allocated, Update base font's PFE.
                // Connect to loaded PFEs.
                //
                vLinkEudcPFEs( pFlEntry );
            }
        }
    }

    GreReleaseSemaphore( ghsemEUDC1 );
    return(bRet);
}

/*****************************************************************************
 * GreEudcUnloadLinkW()
 *
 * Unloads the current system wide EUDC link.  Subsequent TextOut or
 * GetTextMetrics related calls will reflect this immediately.
 *
 * History
 *  26-01-95 Hideyuki Nagase
 * Rewrote it.
 *   4-01-93 Gerrit van Wingerden
 * Wrote it.
 *****************************************************************************/

BOOL GreEudcUnloadLinkW
(
    LPWSTR lpBaseFaceName,
    COUNT  cwcBaseFaceName,
    LPWSTR lpEudcFontPath,
    COUNT  cwcEudcFontPath
)
{
    BOOL bRet = TRUE;

    FLINKMESSAGE(DEBUG_FONTLINK_UNLOAD, "GreEudcUnloadLinkW()....\n");


    GreAcquireSemaphore( ghsemEUDC1 );

    //
    // if text related API's using EUDC characters are in progess we must
    // wait
    //

    ASSERTGDI(gcEUDCCount >= 0, "gcEUDCCount < 0");

    if (gcEUDCCount > 0)
    {
        #if DBG
        if( gflEUDCDebug & DEBUG_FONTLINK_LOAD )
        {
            DbgPrint("GreEudcLoadLinkW is waiting.\n");
        }
        #endif

        // When the last text related API using EUDC characters finishes it will
        // release us.

        EngSetLastError(ERROR_LOCK_FAILED);
        GreReleaseSemaphore( ghsemEUDC1 );
        return (FALSE);

    }

    //
    // Is this a request to load system wide eudc ?
    //

    if( lpBaseFaceName == NULL )
    {
        //
        // if we have system wide eudc font, deactivate and unload it..
        //

        if( IS_SYSTEM_EUDC_PRESENT() )
        {
            //
            // disable the link of all facename and system wide eudc.
            //

            vUnlinkAllEudcRFONTsAndPFEs(TRUE,FALSE);

            //
            // Unload system wide eudc font
            //

            bUnloadEudcFont( gappfeSysEUDC );

            //
            // set new system wide eudc data to global variable.
            //

            gappfeSysEUDC[PFE_NORMAL]   = NULL;
            gappfeSysEUDC[PFE_VERTICAL] = NULL;

            wcscpy(gawcEUDCPath,L"\0");

            //
            // Update global eudc timestamp.
            //

            ulSystemEUDCTimeStamp++;

            if( !bWriteUserSystemEUDCRegistry(L"\0",1) )
            {
                WARNING("Unable to write new link to registry.\n");
            }
        }
    }
     else
    {
        WCHAR awcBaseFaceName[LF_FACESIZE+MAX_PATH+1];
        WCHAR awcEudcFontPath[MAX_PATH+1];

        ASSERTGDI(lpBaseFaceName != NULL,"GreEudcLoadLinkW():lpBaseFaceName == NULL\n");
        ASSERTGDI(cwcBaseFaceName != 0,"GreEudcLoadLinkW():cwcBaseFaceName == 0\n");

        ASSERTGDI(lpEudcFontPath != NULL,"GreEudcLoadLinkW():lpEudcFontPath == NULL\n");
        ASSERTGDI(cwcEudcFontPath != 0,"GreEudcLoadLinkW():cwcEudcFontPath == 0\n");

        //
        // copy parameter to local buffer and make sure it is terminated bu NULL
        //

        RtlMoveMemory(awcBaseFaceName,lpBaseFaceName,(INT)cwcBaseFaceName*sizeof(WCHAR));
        awcBaseFaceName[cwcBaseFaceName] = L'\0';

        RtlMoveMemory(awcEudcFontPath,lpEudcFontPath,(INT)cwcEudcFontPath*sizeof(WCHAR));
        awcEudcFontPath[cwcEudcFontPath] = L'\0';

        //
        // this is a request for facename link Eudc.
        //

        bRet = bDeleteFlEntry(awcBaseFaceName,awcEudcFontPath,FONTLINK_USER);

        //
        // if above call is failed, try FONTLINK_SYSTEM....
        //

        if( !bRet )
            bRet = bDeleteFlEntry(awcBaseFaceName,awcEudcFontPath,FONTLINK_SYSTEM);
    }

    //
    // Let others use EUDC characters again
    //

    GreReleaseSemaphore( ghsemEUDC1 );
    return(bRet);
}

/*****************************************************************************
 * UINT GreEudcQuerySystemLinkW(LPWSTR,COUNT)
 *
 * EudcQueryLink
 *
 * History
 *  3-2-95 Hideyuki Nagase
 * Rewrote it.
 *  4-1-93 Gerrit van Wingerden
 * Wrote it.
 *****************************************************************************/

ULONG GreEudcQuerySystemLinkW
(
    LPWSTR lpwstrEudcFileStr,
    COUNT  cwcEudcFileStr
)
{
    UINT  uiRet = 0;

    ASSERTGDI(lpwstrEudcFileStr != NULL,
              "GreEudcQuerySystemLinkW():lpwstrEudcFileStr == NULL\n");
    ASSERTGDI(cwcEudcFileStr != 0,"GreEudcQuerySystemLinkW():cwcEudcFileStr == 0\n");

    RtlZeroMemory(lpwstrEudcFileStr,cwcEudcFileStr*sizeof(WCHAR));

    #if DBG
    if( gflEUDCDebug & DEBUG_FONTLINK_QUERY )
    {
        DbgPrint("Calling GreEudcQuerySystemLink\n");
    }
    #endif

    if( IS_SYSTEM_EUDC_PRESENT() )
    {
        GreAcquireSemaphore( ghsemEUDC1 );

        wcsncpy(lpwstrEudcFileStr, gawcEUDCPath,
                min((cwcEudcFileStr-1),(wcslen(gawcEUDCPath)+1)));

        uiRet = wcslen(lpwstrEudcFileStr) + 1;

        GreReleaseSemaphore( ghsemEUDC1 );
    }

    return(uiRet);
}

/*****************************************************************************
 * ULONG NtGdiGetEudcTimeStampEx
 *
 * Shared kernel mode entry point for GetEudcTimeStamp and GetEudcTimeStampEx
 *
 * History
 *  3-28-96 Gerrit van Wingerden [gerritv]
 * Wrote it.
 ****************************************************************************/

extern "C" ULONG NtGdiGetEudcTimeStampEx
(
    LPWSTR lpBaseFaceName,
    ULONG  cwcBaseFaceName,
    BOOL   bSystemTimeStamp
)
{
    WCHAR awcBaseFaceName[LF_FACESIZE+1];
    ULONG ulRet = 0;

    if(bSystemTimeStamp)
    {
        return(ulSystemEUDCTimeStamp);
    }
    else
    if((lpBaseFaceName == NULL) || (cwcBaseFaceName == 0))
    {
        return(ulFaceNameEUDCTimeStamp);
    }

    if(cwcBaseFaceName <= LF_FACESIZE)
    {

        __try
        {
            ProbeForRead(lpBaseFaceName,cwcBaseFaceName*sizeof(WCHAR),sizeof(WCHAR));
            RtlCopyMemory(awcBaseFaceName,lpBaseFaceName,
                          cwcBaseFaceName * sizeof(WCHAR));

            awcBaseFaceName[cwcBaseFaceName] = L'\0';
            ulRet = 0;

        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(3100);
        }

        if(ulRet)
        {
            GreAcquireSemaphore( ghsemEUDC1 );

            PFLENTRY pFlEntry;

            if( (pFlEntry = FindBaseFontEntry(awcBaseFaceName)) != NULL )
            {
                ulRet = pFlEntry->ulTimeStamp;
            }
            else
            {
                ulRet = 0;
            }

            GreReleaseSemaphore( ghsemEUDC1 );
        }
    }
    else
    {
        WARNING("NtGdiGetEudcTimeStampEx: Facename too big\n");
        EngSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(ulRet);
}


/******************************************************************************
 * VOID vDrawGlyph( BYTE, UINT, GLYPHPOS )
 *
 * This routine draws a single glyph to a monochrome bitmap.  It was stolen
 * from textblt.cxx and modified to be faster since clipping doesn't come in
 * to play in GetStringBitmapW.
 *
 * History:
 *  5-18-93 Gerrit van Wingerden [gerritv]
 * Wrote it.
 *****************************************************************************/

static const BYTE ajMask[8] = {0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE};

static
VOID vDrawGlyph(
     BYTE     *pjBits, // pointer to base of bitmap bits
     UINT     cjScan,  // size of a scan line
     GLYPHPOS *pgp     // glyph bits and location.
)
{
    GLYPHBITS *pgb = pgp->pgdf->pgb;

    ULONG cx = (ULONG) pgb->sizlBitmap.cx;
    ULONG cy = (ULONG) pgb->sizlBitmap.cy;
    if (cx == 0 || cy == 0)
        return;

    ULONG cjScanSrc = (cx + 7) >> 3;

    PBYTE pjSrcHolder = pgb->aj;

    ULONG xDst = pgp->ptl.x;
    ULONG yDst = pgp->ptl.y;

    PBYTE pjDstHolder  = pjBits;
    pjDstHolder += (yDst * cjScan );
    pjDstHolder += (xDst >> 3);

    // Set the source bits into the mono dib.
    // We can make use of the fact that either xSrcDib or xDstDib is 0.

    PBYTE pjDst;
    PBYTE pjSrc;
    if( !(xDst & 0x7) )
    {
    // Handle the simple case where xDib is byte-alligned

        do
        {
            ULONG cBytes = cx >> 3;

            pjSrc = pjSrcHolder;
            pjDst = pjDstHolder;

            pjSrcHolder += cjScanSrc;
            pjDstHolder += cjScan;

            while (cBytes--)
                *pjDst++ |= *pjSrc++;

            // Do the last partial byte.

            if (cx & 0x7)
                *pjDst |= *pjSrc & ajMask[cx & 0x7];
        } while (--cy);
    }
    else // if (xDstDib)
    {
    // Handle the case where xDstDib is not byte-aligned.

        int cShift = (int) xDst & 0x7;
        do
        {
            ULONG cBytes = ((xDst + cx) >> 3) - (xDst >> 3);

            pjSrc = pjSrcHolder;
            pjDst = pjDstHolder;

            pjSrcHolder += cjScanSrc;
            pjDstHolder += cjScan;

            WORD wSrc = (WORD) (*pjSrc++);
            while (cBytes--)
            {
            *pjDst++ |= (BYTE) (wSrc >> cShift);
            // don't read beyond src limit!
            if (pjSrc == pjSrcHolder)
                wSrc = (wSrc << 8);
            else
                wSrc = (wSrc << 8) | (WORD) (*pjSrc++);
            }

            // Do the last partial byte.
            if ((xDst + cx) & 0x7)
            *pjDst |= (BYTE) (wSrc >> cShift) & ajMask[(xDst+cx) & 0x7];
        } while (--cy);
    }
}

/******************************************************************************
 * VOID vStringBitmapTextOut( STROBJ, BYTE, UINT )
 *
 * This routine draws a STROBJ to a monochrome bitmap.  It is essentially
 * EngTextOut but much faster since it doesn't have to wory about opaqueing,
 * clipping, simulated rects, etc.
 *
 * History:
 *  9-19-95 Hideyuki Nagase [hideyukn]
 * Rewrote it.
 *
 *  5-18-93 Gerrit van Wingerden [gerritv]
 * Wrote it.
 *****************************************************************************/
static
VOID vStringBitmapTextOut(
    STROBJ *pstro,  // Pointer to STROBJ.
    BYTE   *pjBits, // Pointer to buffer to store glyph image.
    UINT    cjScan  // Size of buffer.
)
{
    BOOL     bMoreGlyphs;
    GLYPHPOS *pgp = (GLYPHPOS*)NULL;
 
    LONG xAdjust = ( pstro->rclBkGround.left > 0 ) ? 0 : pstro->rclBkGround.left;
    LONG yAdjust = pstro->rclBkGround.top;

    ((ESTROBJ*)pstro)->vEnumStart();

    if( pstro->pgp == (GLYPHPOS *) NULL )
    {
        ULONG cGlyph;
        bMoreGlyphs = STROBJ_bEnum(pstro,&cGlyph,&pgp);
    }
    else
    {
        pgp    = pstro->pgp;
        bMoreGlyphs = FALSE;
    }

    ASSERTGDI(bMoreGlyphs == FALSE,"vStringBitmapTextOut() bMoreGlyphs is TRUE.\n");

    // Saw this on FE stress
    // ASSERTGDI(pgp, "vStringBitmapTextOut() STROBJ_bEnum returns NULL pgp.\n");

    // fail textout if pgp == NULL
    if (pgp)
    {
        GLYPHBITS *pgb = pgp[0].pgdf->pgb;

        pgp[0].ptl.x += pgb->ptlOrigin.x - xAdjust;
        pgp[0].ptl.y += pgb->ptlOrigin.y - yAdjust;

        //
        // Blt the glyph into the bitmap
        //
        vDrawGlyph( pjBits, cjScan, &pgp[0] );
    }
}

/******************************************************************************
 * UINT GreGetStringBitmapW
 *
 * This routine does a kindof fast text out ( with restrictions ) to a monochrome
 * bitmap.
 *
 * History:
 *  9-19-95 Hideyuki Nagase [hideyukn]
 * Rewrote it.
 *
 *  5-18-93 Gerrit van Wingerden [gerritv]
 * Wrote it.
 *****************************************************************************/

UINT GreGetStringBitmapW(
    HDC            hdc,
    LPWSTR         pwsz,
    UINT           cwc,      // should be 1....
    LPSTRINGBITMAP lpSB,
    UINT           cj,
    UINT          *puiOffset // not used...
)
{
// Parameter check, early out...

    if( cwc != 1 )
    {
        WARNING("GreGetStringBitmap only works when char count is 1.\n");
        return(0);
    }

    if( puiOffset != 0 && *puiOffset != 0 )
    {
        WARNING("GreGetStringBitmap only works when offset is 0.\n");
        return(0);
    }

// Lock the DC and set the new attributes.

    DCOBJ dco(hdc);         // Lock the DC.

    if (!dco.bValid())      // Check if it's good.
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(0);
    }

// Get the transform from the DC.

    EXFORMOBJ xo(dco,WORLD_TO_DEVICE);


// we only allow identity transforms for GetStringBitmap

    if( !xo.bIdentity() )
    {
        WARNING("GreGetStringBitmap only works with identity WtoD xforms.\n");
        return(0);
    }


// Locate the font cache.

    RFONTOBJ rfo(dco,FALSE);

    if (!rfo.bValid())
    {
        WARNING("gdisrv!GreGetStringBitmap(): could not lock RFONTOBJ\n");
        return (0);
    }

// GetStringBitmap doesn't support vector fonts.

    if( rfo.bPathFont() )
    {
        WARNING("gdisrv!GetStringBitmap() : vector fonts aren't supported.\n");
        return(0);
    }


// GetStringBitmap doesn't support sny rotations.

    if((dco.pdc->lEscapement() | rfo.ulOrientation() ) != 0)
    {
        WARNING("gdisrv!GreGetStringBitmap(): Text isn't Horizontal.\n" );
        return(0);
    }

// Initialize ESTROBJ. Compute glyph layout positions.

    ESTROBJ to; to.vInitSimple(pwsz,cwc,dco,rfo,0L,0L,NULL);

    if (!to.bValid())
    {
        WARNING("gdisrv!GetStringBitmap() : could not lock ESTROBJ.\n");
        return(0);
    }


// Compute the target string rectangle.

    UINT uiWidth  = (UINT)( to.rclBkGround.right - to.rclBkGround.left );
    UINT uiHeight = (UINT)( to.rclBkGround.bottom - to.rclBkGround.top );


// Offset the width by the C space of the last character and the A space of
// the first character to get the true extent

    GLYPHDATA *pgd;
    EGLYPHPOS    *pg = (EGLYPHPOS*)to.pgpGet();

    pgd = pg->pgd();
    uiWidth +=  FXTOL(pgd->fxA);
    pg = &pg[to.cGlyphsGet()-1];
    pgd = pg->pgd();
    uiWidth +=  FXTOL((pgd->fxD-pgd->fxAB));


// compute width of scanline in bytes ( must be byte alligned )

    UINT  cjScan = (uiWidth + 7) / 8;
    UINT  cjSize = offsetof(STRINGBITMAP,ajBits) + (cjScan * uiHeight);
    PBYTE pjBits = lpSB->ajBits;


// If the user only want the size return now.
// And check the buffer is enough to store glyph image

    if( cj < cjSize ) return( cjSize );

// Clear the target buffer.

    RtlZeroMemory( pjBits, cjScan * uiHeight );

// Fill up its bitmap size...

    lpSB->uiHeight = uiHeight;
    lpSB->uiWidth  = uiWidth;


// adjust the baseline of the Sys EUDC for win 3.1 compatability

    POINTL   ptlBaseLineAdjust = {0,0};
    LONG     lFontType        = EUDCTYPE_BASEFONT;

    PRFONT pLinkedRfont = NULL;

// Is the character linked one ?

    if( to.bLinkedGlyphs() )
    {

    // Setup its font type...

        lFontType = *(LONG *)(to.plPartitionGet());

    // Get corresponding RFONT with current linked font.

        switch (lFontType)
        {
        case EUDCTYPE_SYSTEM_WIDE:
            pLinkedRfont = rfo.prfntSysEUDC();
            break;
        case EUDCTYPE_SYSTEM_TT_FONT:
            pLinkedRfont = rfo.prfntSystemTT();
            break;
        case EUDCTYPE_DEFAULT:
            pLinkedRfont = rfo.prfntDefEUDC();
            break;
        case EUDCTYPE_BASEFONT:
        // it's possible for this to be the case since the EUDC character
        // could have been a singular character or a blank character in which
        // case we will have already have set flags saying we have linked
        // glyphs but in actuality will grab the default glyph from the base font
            break;
        default:
            ASSERTGDI(lFontType >= EUDCTYPE_FACENAME,
                  "GDISRV:GreGetStringBitmapW() Error lFontType\n");
            pLinkedRfont = rfo.prfntFaceName(lFontType - EUDCTYPE_FACENAME);
            break;
        }

    // Is the RFONT is valid ?

        if( pLinkedRfont != NULL )
        {
            RFONTTMPOBJ rfoLink(pLinkedRfont);

            //
            // Compute baseline diffs.
            //
            // *** Base font Height == Linked font Height ***
            //
            //   Base font  EUDC font         Base font  EUDC font
            //
            //              -------
            //    -------   |     |            -------   -------
            //    |     |   |     |   ----->   |     |   |     |
            //    | 15  |   | 20  |            | 15  |   | 15  |
            //    |     |   |     |            |     |   |     |
            //  -------------------- BaseLine ---------------------
            //    |  5  |                      |  5  |   |  5  |
            //    -------                      -------   -------
            //
            // *** Base font Ascent >= Linked font Height ****
            //
            //   Base font  EUDC font         Base font  EUDC font
            //
            //    -------                      -------
            //    |     |                      |     |   -------
            //    |     |   -------   ----->   |     |   |     |
            //    | 20  |   | 10  |            | 20  |   | 15  |
            //    |     |   |     |            |     |   |     |
            //  -------------------- BaseLine ---------------------
            //    |  5  |   |  5  |            |  5  |
            //    -------   -------            -------
            //
            // *** Others ****
            //
            //  TBD.
            //
            if( rfo.fxMaxAscent() >= (rfoLink.fxMaxAscent() - rfoLink.fxMaxDescent()) )
            {
                ptlBaseLineAdjust.y = (rfoLink.fxMaxDescent() >> 4);
            }
             else
            {
                ptlBaseLineAdjust.y = (rfoLink.fxMaxAscent() - rfo.fxMaxAscent()) >> 4;
            }

            //
            // if we need to adjust baseline, force emulation....
            //
            if( ptlBaseLineAdjust.y ) to.pgpSet(NULL);

        }
    }

 // Set current font type.

    to.vFontSet(lFontType);

    RFONTTMPOBJ rfoLink(pLinkedRfont);

    if(pLinkedRfont)
    {
        to.prfntSet( &rfoLink );
    }

 // Set base line adjustment delta.

    to.ptlBaseLineAdjustSet( ptlBaseLineAdjust );

// Draw the glyph

    vStringBitmapTextOut( (STROBJ*)&to, pjBits, cjScan );

    return( cj );
}

BOOL bAdjusBaseLine(RFONTOBJ &rfoBase, RFONTOBJ &rfoLink, POINTL *pptlAdjustBaseLine)
{
    BOOL    bRet = FALSE;

// special case of the bitmap font, the heights are the same

    if ((rfoBase.fxMaxAscent() - rfoBase.fxMaxDescent()) ==
        (rfoLink.fxMaxAscent() - rfoLink.fxMaxDescent()))
    {
        pptlAdjustBaseLine->x  = FXTOLFLOOR((rfoBase.ptfxMaxAscent().x - rfoLink.ptfxMaxAscent().x));
        pptlAdjustBaseLine->y  = FXTOLFLOOR((rfoBase.ptfxMaxAscent().y - rfoLink.ptfxMaxAscent().y));

        if (pptlAdjustBaseLine->y || pptlAdjustBaseLine->x)
            bRet = TRUE;
    }

    return bRet;

}

/*******************************************************************************
 * void AdjustBoundingBox(RFONTOBJ&, RFONTOBJ&, POINTFIX*, ERECTL*)
 *
 * This function adjusts the baseline of the EUDC font in a way that is
 * Win 3.1 compatible according to the following rules:
 *
 *
 *  Base font Height == Linked font Height ***
 *
 *   Base font  EUDC font         Base font  EUDC font
 *
 ******************************************************************************/

void AdjustBoundingBox(
    RFONTOBJ &rfoBase,
    RFONTOBJ &rfoLink,
    FIX      *fxAdjustDeltaAsc, 
    FIX      *fxAdjustDeltaDsc,
    POINTFIX *ptfxDeltaAsc,
    POINTFIX *ptfxDeltaDsc
)
{


    FIX     fxDeltaDsc, fxDeltaAsc;

    fxDeltaDsc =  rfoBase.fxMaxDescent() - rfoLink.fxMaxDescent();

    fxDeltaAsc =  -(rfoBase.fxMaxAscent() - rfoLink.fxMaxAscent());

// There is no internal leading in base font, most likely BMP case.
// In this case we will adjust the baseline (the exact height match)
// so that it will not be necessary to adjust the bounding box

    if ((fxDeltaDsc + fxDeltaAsc) == 0)
        return;

    if (fxDeltaDsc < 0)
        fxDeltaDsc = 0;

    if(fxDeltaAsc < 0)
        fxDeltaAsc = 0;

    if(!fxDeltaAsc  && !fxDeltaDsc  )
        return;

// eAu = (0, -1)
// dA = eA * eAu = (x1, y1)
// dD = -eD * eDu = (x2, y2)

    if (fxDeltaDsc > *fxAdjustDeltaDsc)
    {
        *fxAdjustDeltaDsc = fxDeltaDsc;
        ptfxDeltaDsc->x  = -(rfoBase.ptfxMaxDescent().x - rfoLink.ptfxMaxDescent().x);
        ptfxDeltaDsc->y  = -(rfoBase.ptfxMaxDescent().y - rfoLink.ptfxMaxDescent().y);
    }

    if (fxDeltaAsc > *fxAdjustDeltaAsc)
    {
        *fxAdjustDeltaAsc = fxDeltaAsc;
        ptfxDeltaAsc->x  = -(rfoBase.ptfxMaxAscent().x - rfoLink.ptfxMaxAscent().x);
        ptfxDeltaAsc->y  = -(rfoBase.ptfxMaxAscent().y - rfoLink.ptfxMaxAscent().y);
    }

}



VOID ESTROBJ::vEudcOpaqueArea(POINTFIX *aptfxBackground, BOOL bComplexBackground )
{
    FIX         fxDeltaAsc = 0; 
    FIX         fxDeltaDsc = 0;
    POINTFIX    ptfxDeltaAsc = {0, 0};
    POINTFIX    ptfxDeltaDsc = {0, 0};

    for(LONG lFont = EUDCTYPE_BASEFONT ;
             lFont < (EUDCTYPE_FACENAME + (LONG) prfo->uiNumFaceNameLinks()) ;
             lFont++ )
    {
        RFONTTMPOBJ rfoLink;

        switch( lFont )
        {
        case EUDCTYPE_BASEFONT:

            break;

        case EUDCTYPE_SYSTEM_TT_FONT:

            if(cTTSysGlyphs)
            {
                rfoLink.vInit(prfo->prfntSystemTT());
                AdjustBoundingBox(*prfo,rfoLink, &fxDeltaAsc, &fxDeltaDsc, 
                        &ptfxDeltaAsc, &ptfxDeltaDsc);
            }
         break;

        case EUDCTYPE_SYSTEM_WIDE:

            if( cSysGlyphs )
            {
                rfoLink.vInit( prfo->prfntSysEUDC() );
                AdjustBoundingBox(*prfo,rfoLink, &fxDeltaAsc, &fxDeltaDsc, 
                        &ptfxDeltaAsc, &ptfxDeltaDsc);
            }

            break;

        case EUDCTYPE_DEFAULT:

            if( cDefGlyphs)
            {
                rfoLink.vInit( prfo->prfntDefEUDC() );
                AdjustBoundingBox(*prfo,rfoLink, &fxDeltaAsc, &fxDeltaDsc, 
                        &ptfxDeltaAsc, &ptfxDeltaDsc);
            }

            break;


        default:

            if( pacFaceNameGlyphs && pacFaceNameGlyphs[lFont-EUDCTYPE_FACENAME])
            {
                rfoLink.vInit(prfo->prfntFaceName(lFont - EUDCTYPE_FACENAME));
                AdjustBoundingBox(*prfo,rfoLink, &fxDeltaAsc, &fxDeltaDsc, 
                        &ptfxDeltaAsc, &ptfxDeltaDsc);
            }

            break;
        }
    }

    if (fxDeltaAsc || fxDeltaDsc)
    {
        LONG    lDeltaL, lDeltaR, lDeltaT, lDeltaB;
        RECTL   rclInflate = rclBkGround;

    // dLeft = min(x1, x2)
    // dRight = max(x1, x2)
    // dTop = min(y1, y2)
    // dBottom = max(y1, y2)
    

        lDeltaL = FXTOLFLOOR(min(ptfxDeltaAsc.x, ptfxDeltaDsc.x));
        lDeltaR = FXTOLCEILING(max(ptfxDeltaAsc.x, ptfxDeltaDsc.x));
        lDeltaT = FXTOLFLOOR(min(ptfxDeltaAsc.y, ptfxDeltaDsc.y));
        lDeltaB = FXTOLCEILING(max(ptfxDeltaAsc.y, ptfxDeltaDsc.y));

        rclInflate.left    += lDeltaL;
        rclInflate.right   += lDeltaR;
        rclInflate.top     += lDeltaT;
        rclInflate.bottom  += lDeltaB;

        if (rclInflate.top < rclBkGround.top)
            rclBkGround.top = rclInflate.top;
        if (rclInflate.bottom > rclBkGround.bottom)
            rclBkGround.bottom = rclInflate.bottom;
        if (rclInflate.left < rclBkGround.left)
            rclBkGround.left = rclInflate.left;
        if (rclInflate.right > rclBkGround.right)
            rclBkGround.right = rclInflate.right;

    // for the order of points in the bounding paralelogram look at textobj.cxx
    // we go around clockwise ie tl, tr, br, bl

        if (bComplexBackground)
        {
            if (fxDeltaAsc)
            {
                aptfxBackground[0].x += ptfxDeltaAsc.x;
                aptfxBackground[0].y += ptfxDeltaAsc.y;
                aptfxBackground[1].x += ptfxDeltaAsc.x;
                aptfxBackground[1].y += ptfxDeltaAsc.y;
            }
    
            if (fxDeltaDsc)
            {
                aptfxBackground[2].x += ptfxDeltaDsc.x;
                aptfxBackground[2].y += ptfxDeltaDsc.y;
                aptfxBackground[3].x += ptfxDeltaDsc.x;
                aptfxBackground[3].y += ptfxDeltaDsc.y;
            }

        }
    }

}

BOOL bOutOfBounds(STROBJ *pstro, RFONTOBJ *prfo)
{
    COUNT cGlyph;
    BOOL bMoreGlyphs;
    GLYPHPOS *pgp;
    BOOL bRet = FALSE;

    if((*((LONG*) &(prfo->pfdx()->eXY)) == 0 && *((LONG*)&(prfo->pfdx()->eYX)) == 0))
    {
    // fast out for horizontal cases
        return(FALSE);
    }

    do
    {
        bMoreGlyphs = STROBJ_bEnum(pstro,&cGlyph,&pgp);

        if(cGlyph)
        {
            LONG xL, xR, yT, yB;
            ULONG ii;
            for (ii=0; ii<cGlyph; ii++)
            {
            // for device font pgb will be NULL so don't do the check

                if(pgp[ii].pgdf->pgb)
                {
                    xL = pgp[ii].ptl.x + pgp[ii].pgdf->pgb->ptlOrigin.x;
                    xR = xL + pgp[ii].pgdf->pgb->sizlBitmap.cx;
                    yT = pgp[ii].ptl.y + pgp[ii].pgdf->pgb->ptlOrigin.y;
                    yB = yT + pgp[ii].pgdf->pgb->sizlBitmap.cy;

                    if( (xL < pstro->rclBkGround.left) ||
                       (xR > pstro->rclBkGround.right) ||
                       (yT < pstro->rclBkGround.top) ||
                       (yB > pstro->rclBkGround.bottom) )
                    {
                        bRet = TRUE;
                        break;
                    }
                }
            }
        }
    } while(bMoreGlyphs);

// reset it for the text out call

    STROBJ_vEnumStart(pstro);

    return(bRet);
}


/******************************************************************************
 * BOOL bProxyDrvTextOut()
 *
 * This routine takes the place of a DrvTextOut in the case when there are EUDC
 * characters in the ESTROBJ.  It partitions the call into mutliple DrvTextOut
 * calls, one for each font int the string.
 *
 * Partitioning information is stored in an array of LONGS in the RFONTOBJ.        
 * The i'th entry in the array tells what font the i'th glyph in the ESTROBJ
 * belongs to.
 *
 * History:
 *  7-14-93 Gerrit van Wingerden [gerritv]
 * Rewrote it to handle multiple face name links and just be better.
 *  2-10-93 Gerrit van Wingerden [gerritv]
 * Wrote it.
 *
 *****************************************************************************/

// This routine is used to partition calls to the driver if there are EUDC
// characters in the string.

BOOL bProxyDrvTextOut
(
    XDCOBJ&   dco,
    SURFACE  *pSurf,
    ESTROBJ&  to,
    ECLIPOBJ& co,
    RECTL    *prclExtra,
    RECTL    *prclBackground,
    BRUSHOBJ *pboFore,
    BRUSHOBJ *pboOpaque,
    POINTL   *pptlBrushOrg,
    RFONTOBJ& rfo,
    PDEVOBJ   *pdo,
    FLONG     flCaps,
    RECTL    *prclExclude
)
{
    RFONTOBJ *prfoSave;
    LONG *plPartition, *plPartitionEnd;
    COUNT cTotalGlyphs = 0;
    LONG lInflatedMax = 0;
    WCHAR *pwcPartition, *pwcTmp, *pwcSave, *pwcSource;
    ULONG cNumGlyphs = to.cGlyphsGet();
    POINTL ptlAdjustBaseLine;
    BOOL    bSkip = FALSE;

    prfoSave = to.prfo;

    BOOL bRet = TRUE;

    pwcPartition = to.pwcPartitionGet();

// now partition the EUDC glyphs by font

    pwcSave = to.pwszGet();

// set to NULL to force enumeration

    to.pgpSet( NULL );

// This code is only for NT bug #414953
// If the base font is stroke base then we would not allow to render the linked TT font

    if ((rfo.prfnt->flInfo & FM_INFO_TECH_STROKE) &&
         rfo.iGraphicsMode() == GM_COMPATIBLE)
    {
        if ((dco.pdc->lEscapement() != (LONG) rfo.prfnt->ulOrientation))
            bSkip = TRUE;
    }
       
// Turn off acclerators since we'll seriously munge the properties of the string object.
// also clear the ulCharInc value since the tga driver won't work properly if it's
// set

    to.flAccelSet( 0 );
    to.vClearCharInc();

    for(LONG lFont = EUDCTYPE_BASEFONT ;
             lFont < (EUDCTYPE_FACENAME + (LONG) rfo.uiNumFaceNameLinks()) ;
             lFont++ )
    {
        RFONTTMPOBJ rfoLink;
        RFONTOBJ   *prfoLink;
        UINT        ii;
        COUNT       cLinkedGlyphs;

        switch( lFont )
        {
        case EUDCTYPE_BASEFONT:

        // If there aren't any glyphs in the base font just draw the
        // opaque rectangle.  We must draw the opaque rectangle here
        // because the linked glyphs don't neccesarily fit into the
        // the opaque rectangle.  Passing such a rectangle to a driver
        // can cause unexpected results.

            cLinkedGlyphs = to.cSysGlyphsGet() + to.cDefGlyphsGet() +
              to.cTTSysGlyphsGet();

            for(  ii = 0; ii < rfo.uiNumFaceNameLinks(); ii++ )
            {
                cLinkedGlyphs += to.cFaceNameGlyphsGet( ii );
            }

            if( cLinkedGlyphs == cNumGlyphs )
            {

            // Draw the opaque rectangle here if there is one

                ASSERTGDI(prclExclude, "bProxyDrvTextOut: prclExclude is NULL\n");
                if(prclBackground != NULL)
                {
                    co.erclExclude().left =
                      max(prclExclude->left,prclBackground->left);

                    co.erclExclude().right =
                      min(prclExclude->right,prclBackground->right);

                    co.erclExclude().top =
                      max(prclExclude->top,prclBackground->top);
                    co.erclExclude().bottom =
                      min(prclExclude->bottom,prclBackground->bottom);
                }

            // if not clipped, Just paint the rectangle.

                if ((co.erclExclude().left < co.erclExclude().right) &&
                    (co.erclExclude().top < co.erclExclude().bottom) &&
                    prclBackground != NULL )
                {
                    INC_SURF_UNIQ(pSurf);

                    TextOutBitBlt
                    (
                        pSurf,
                        rfo,
                        (SURFOBJ *)  NULL,      // Source surface.
                        (SURFOBJ *)  NULL,      // Mask surface.
                        &co,                    // Clip object.
                        (XLATEOBJ *) NULL,      // Palette translation object.
                        prclBackground,         // Destination rectangle.
                        (POINTL *)  NULL,       // Source origin.
                        (POINTL *)  NULL,       // Mask origin.
                        (BRUSHOBJ *) pboOpaque, // Realized opaque brush.
                        pptlBrushOrg,           // brush origin
                        0x0000f0f0              // PATCOPY
                    );
                }

                co.erclExclude() = *prclExclude;

            // set prclBackground to NULL since we have just drawn it

                prclBackground = NULL;

                continue;
            }

            prfoLink = &rfo;


            FLINKMESSAGE(DEBUG_FONTLINK_TEXTOUT,"Doing base font.\n");
            break;

        case EUDCTYPE_SYSTEM_TT_FONT:

            if(bSkip || (to.cTTSysGlyphsGet() == 0))
            {
                continue;
            }

            rfoLink.vInit(rfo.prfntSystemTT());
            prfoLink = (RFONTOBJ *) &rfoLink;

         break;

        case EUDCTYPE_SYSTEM_WIDE:

            if(bSkip || (to.cSysGlyphsGet() == 0))
            {
                continue;
            }

            rfoLink.vInit( rfo.prfntSysEUDC() );
            prfoLink = (RFONTOBJ *) &rfoLink;

            break;

        case EUDCTYPE_DEFAULT:

            if(bSkip || (to.cDefGlyphsGet() == 0) )
            {
                continue;
            }

            rfoLink.vInit( rfo.prfntDefEUDC() );
            prfoLink = (RFONTOBJ *) &rfoLink;
            break;


        default:

            if( bSkip ||  (to.cFaceNameGlyphsGet( lFont-EUDCTYPE_FACENAME ) == 0) )
            {
                continue;
            }

            rfoLink.vInit(rfo.prfntFaceName(lFont - EUDCTYPE_FACENAME));
            prfoLink = (RFONTOBJ *) &rfoLink;
            break;
        }

    // Loop through all the glyphs in the TextObj using plPartition to
    // and construct a wchar array to match this textobj.

        for( plPartition = to.plPartitionGet(),plPartitionEnd = &plPartition[cNumGlyphs],
             pwcSource = pwcSave, pwcTmp = pwcPartition;
             plPartition < plPartitionEnd;
             plPartition += 1, pwcSource += 1 )
        {
            if( *plPartition == lFont )
            {
                *pwcTmp++ = *pwcSource;
            }
        }

    // Keep track of the total glyphs drawn so far so we know when we are doing
    // the last DrvTextOut.  On the last DrvTextOut draw prclExtra.

        cTotalGlyphs += (COUNT) ( pwcTmp - pwcPartition );

        to.cGlyphsSet( (LONG) ( pwcTmp - pwcPartition ));
        to.pwszSet( pwcPartition );

    // set the font type and reset cGlyphPosCopied to 0

        to.vFontSet( lFont );

        if (lFont != EUDCTYPE_BASEFONT)
        {
            if (bAdjusBaseLine(rfo, rfoLink, &ptlAdjustBaseLine))
            {
                to.ptlBaseLineAdjustSet(ptlAdjustBaseLine);
            }
        }

    // adjust the baseline of the Sys EUDC for win 3.1 compatability

        to.prfntSet( prfoLink );

    // some drivers dink with the BkGround rectangle (like the Cirrus driver )
    // so save a copy here and then restore it later to handle this situation

        to.vSaveBkGroundRect();

    // check this is a path draw or not.

        if( prfoLink->bPathFont() )
        {
            PATHMEMOBJ po;

            if( !po.bValid() )
            {
                SAVE_ERROR_CODE( ERROR_NOT_ENOUGH_MEMORY );
                bRet = FALSE;
            }
            else
            {
                if( !(prfoLink->bReturnsOutlines()) )
                {
                    //
                    // VECTOR FONT CASE
                    //
                    if( !to.bTextToPathWorkhorse(po) ||
                        !po.bSimpleStroke1( flCaps,
                                            pdo,
                                            pSurf,
                                            &co,
                                            pboFore,
                                            pptlBrushOrg,
                                            ( R2_COPYPEN | ( R2_COPYPEN << 8 ))
                                           ))
                    {
                    #if DBG
                        DbgPrint("ProxyDrvTextout:bTextToPath for vector font \
                                  failed(%d).\n", lFont);
                    #endif
                        bRet = FALSE;
                    }
                }
                 else
                {
                    //
                    // OUTLINE FONT CASE
                    //
                    if( !to.bTextToPathWorkhorse(po) ||
                       (( po.cCurves > 1 ) &&
                           !po.bSimpleFill( flCaps,
                                            pdo,
                                            pSurf,
                                            &co,
                                            pboFore,
                                            pptlBrushOrg,
                                            ( R2_COPYPEN | ( R2_COPYPEN << 8 )),
                                            WINDING
                                          )
                        )
                      )
                    {
                    #if DBG
                        DbgPrint("ProxyDrvTextout:bTextToPath for outline font    \
                                  failed(%d).\n",lFont);
                    #endif
                        bRet = FALSE;
                    }
                }
            }
        }
        else
        {
        // This is bad but we will peform a check to see if the linked glyphs
        // are out of bounds and if so fail the call.  There are several reasons
        // why this may happen (some understood and some not yet understood).  Since
        // we are so close to shipping it was better to do this rather than make
        // riskier fixes for the other problems.  I should point out a few things:
        //
        // 1) We only do this check on rotations that are not multiples of 90.
        //    These cases don't cause problem.  This also means we are only
        //    Slowing done non-common cases.  bOutOfBounds returns TRUE
        //    right away for horizontal text.
        // 2) It is always better to fail in this case since the alternative is
        //    is system crash (of course fixing the underlying problems is ideal.)
        // 3) These cases are not real world (i.e. they won't affect text in
        //    in real world scenarios) since they occur under extremely bizarre
        //    transforms and only in our test apps.
        // 4) I am documenting what I have found about the failure cases so far
        //    and fix these in 5.0

            if(!bOutOfBounds((STROBJ*) &to, prfoLink))
            {
                PFN_DrvTextOut pfnTextOut;
                pfnTextOut = pSurf->pfnTextOut();

                // this code correspond to what is done in GreExtTextOutWLocked()
                // see MSPaint, ClearType bug under 16bits colors #106984

                // If the pointer to the TextOut function points to SpTextOut then
                // we know that AntiAliased text can be handled and we can skip
                // the funny business in the else clause

                if (pfnTextOut == SpTextOut)
                {
                    if (prfoLink->prfnt->fobj.flFontType & (FO_GRAY16 | FO_CLEARTYPE_X))
                    {
                        pSurf->pdcoAA = &dco;
                    }
                }
                else
                {

                    if
                        (
                            (prfoLink->prfnt->fobj.flFontType & FO_GRAY16) &&
                            (!(dco.flGraphicsCaps() & GCAPS_GRAY16) ||
                              (prfoLink->prfnt->fobj.flFontType & FO_CLEARTYPE_X))
                        )
                    {

                    // Inform SpTextOut that this call came from GreExtTextOutW
                    // for the purpose of rendering anti aliased text on a device
                    // that does not support it. Remember to set this to zero
                    // before releasing the surface to other users.

                        if (pfnTextOut != EngTextOut)
                            pSurf->pdcoAA = &dco;

                        pfnTextOut = SpTextOut;
                    }
                } // if (pfnTextOut == SpTextOut) else

               prfoLink->PreTextOut(dco);

               //
               // WINBUG #214225: re-visit the issue that RFONT cache semaphore
               // is held too long period of time.
               // Release/acquire the base rfont semaphore before/after
               // the DrvTextOut call.
               // 
               {
                   PDEVOBJ po(pSurf->hdev());
                   BOOL  bAcquireSem = FALSE;

                   if (prfoLink != (&rfo) && po.bPrinter() && po.bUMPD())
                   {
                       if (rfo.prfnt->hsemCache != NULL &&
                           GreIsSemaphoreOwnedByCurrentThread(rfo.prfnt->hsemCache))
                       {
                           GreReleaseSemaphore(rfo.prfnt->hsemCache);
                           bAcquireSem = TRUE;
                       }
                   }

                   if(!((*pfnTextOut))
                      ( pSurf->pSurfobj(),
                       (STROBJ *) &to,
                       prfoLink->pfo(),
                       &co,
                       (cTotalGlyphs == cNumGlyphs ) ? prclExtra : NULL,
                       prclBackground,
                       pboFore,
                       pboOpaque,
                       pptlBrushOrg,
                       (R2_COPYPEN | (R2_COPYPEN << 8))
                       ))
                   {
                       #if DBG
                       DbgPrint("ProxyDrvTextout:DrvTextOut for bitmap font failed(%d).\n",
                                lFont);
                       #endif
                       bRet = FALSE;
                   }

                   if (bAcquireSem)
                   {
                       GreAcquireSemaphore(rfo.prfnt->hsemCache);
                   }
               }

               prfoLink->PostTextOut(dco);

                pSurf->pdcoAA = 0;  // clear AA state
            }

            // set this to NULL since we've already drawn it.

            prclBackground = NULL;
        }

        to.vRestoreBkGroundRect();
    }

// TextOut expects gpos and prfo to be correct so reset them

    to.pwszSet( pwcSave );
    to.prfo = prfoSave;

    return(bRet);
}


/******************************Public*Routine*****************************\
* NtGdiEnableEudc
*
* Enable or disable system wide and per-user Eudc information.
*
* History:
*  27-Mar-1996 by Gerrit van Wingerden [gerritv]
* Wrote it.
\*************************************************************************/

extern "C"
BOOL
APIENTRY
NtGdiEnableEudc(
    BOOL bEnable
)
{
    return(GreEnableEUDC(bEnable));
}

/******************************Public*Routine*****************************\
* NtGdiQuerySystemLink
*
* Queries system link information
*
* History:
*  27-Mar-1996 by Gerrit van Wingerden [gerritv]
* Wrote it.
\*************************************************************************/

extern "C"
UINT
APIENTRY
NtGdiEudcQuerySystemLink
(
    LPWSTR pszOut,
    UINT   cChar
)
{
    UINT   cRet = 0;
    PWCHAR pwsz_km = (PWCHAR)NULL;

    if ((cChar > 0) && (pszOut))
    {
        if (!BALLOC_OVERFLOW1(cChar,WCHAR))
        {
            pwsz_km = (WCHAR*) AllocFreeTmpBuffer(cChar * sizeof(WCHAR));
        }
    }

    if (pwsz_km)
    {
        cRet = GreEudcQuerySystemLinkW(pwsz_km,cChar);

        if ((cRet > 0) && (pszOut))
        {

            ASSERTGDI(cRet <= cChar, "GreEudcQuerySystemLinkW, cRet too big\n");
            __try
            {
                ProbeForWrite(pszOut,cRet * sizeof(WCHAR), sizeof(BYTE));
                RtlCopyMemory(pszOut,pwsz_km,cRet * sizeof(WCHAR));
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(3095);
                // SetLastError(GetExceptionCode());
                cRet = 0;
            }
        }

        FreeTmpBuffer(pwsz_km);
    }
    return(cRet);
}


/******************************Public*Routine*****************************\
* NtGdiEudcLoadUnloadLink
*
* Queries system link information
*
* History:
*  27-Mar-1996 by Gerrit van Wingerden [gerritv]
* Wrote it.
\*************************************************************************/

extern "C"
BOOL
APIENTRY
NtGdiEudcLoadUnloadLink(
    LPCWSTR pBaseFaceName,
    UINT   cwcBaseFaceName,
    LPCWSTR pEudcFontPath,
    UINT   cwcEudcFontPath,
    INT    iPriority,
    INT    iFontLinkType,
    BOOL   bLoadLink)
{
    WCHAR FaceNameBuffer[LF_FACESIZE+1];
    WCHAR *pPathBuffer;
    BOOL bRet = FALSE;

    if(cwcBaseFaceName > LF_FACESIZE || pEudcFontPath == NULL ||
       (cwcEudcFontPath == 0) || (cwcEudcFontPath > (MAX_PATH - 30)))
    {
        EngSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }


    pPathBuffer = (WCHAR*) AllocFreeTmpBuffer((cwcEudcFontPath+1) * sizeof(WCHAR));

    if(pPathBuffer)
    {
        __try
        {
            if(pBaseFaceName)
            {
                ProbeForRead(pBaseFaceName,cwcBaseFaceName,sizeof(WCHAR));
                RtlCopyMemory(FaceNameBuffer,pBaseFaceName,
                              cwcBaseFaceName*sizeof(WCHAR));

                FaceNameBuffer[cwcBaseFaceName] = (WCHAR) 0;
                pBaseFaceName = FaceNameBuffer;
            }

            ProbeForRead(pEudcFontPath,cwcEudcFontPath,sizeof(WCHAR));
            RtlCopyMemory(pPathBuffer,pEudcFontPath,
                          cwcEudcFontPath*sizeof(WCHAR));

            pPathBuffer[cwcEudcFontPath] = (WCHAR) 0;
            bRet = TRUE;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(3096);
        }

        if(bRet)
        {
            if(bLoadLink)
            {
                bRet = GreEudcLoadLinkW((LPWSTR) pBaseFaceName,
                                        cwcBaseFaceName,
                                        pPathBuffer,
                                        cwcEudcFontPath,
                                        iPriority,
                                        iFontLinkType);
            }
            else
            {
                bRet = GreEudcUnloadLinkW((LPWSTR)pBaseFaceName,
                                          cwcBaseFaceName,
                                          pPathBuffer,
                                          cwcEudcFontPath);
            }
        }
        FreeTmpBuffer(pPathBuffer);
    }

    return(bRet);
}

extern "C"
UINT
APIENTRY
NtGdiGetStringBitmapW(
    HDC hdc,
    LPWSTR pwsz,
    UINT cwc,
    BYTE *lpSB,
    UINT cj
    )
{
    WCHAR Character;
    LPSTRINGBITMAP OutputBuffer = NULL;
    UINT Status = 1;

    if(cwc != 1)
    {
        return(FALSE);
    }

    if(cj)
    {
        if(!(OutputBuffer = (LPSTRINGBITMAP) AllocFreeTmpBuffer(cj)))
        {
            Status = 0;
        }
    }

    if(Status)
    {
        __try
        {
            ProbeForRead(pwsz,sizeof(WCHAR), sizeof(WCHAR));
            Character = pwsz[0];
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(3099);
            Status = 0;
        }

        if(Status)
        {
            Status = GreGetStringBitmapW(hdc,
                                         &Character,
                                         1,
                                         (LPSTRINGBITMAP) OutputBuffer,
                                         cj,
                                         0);
        }

        if(Status && OutputBuffer)
        {
            __try
            {
                ProbeForWrite(lpSB,cj,sizeof(BYTE));
                RtlCopyMemory(lpSB,OutputBuffer,cj);
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(3100);
                Status = 0;
            }
        }
    }

    if(OutputBuffer)
    {
        FreeTmpBuffer(OutputBuffer);
    }


    return Status;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\fillddi.cxx ===
/******************************Module*Header*******************************\
* Module Name: fillddi.cxx
*
* Contains filling simulations code and help functions.
*
* Created: 04-Apr-1991 17:30:35
* Author: Wendy Wu [wendywu]
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

/******************************Member*Function*****************************\
* EngFillPath
*
*  This routine first converts the given pathobj to rgnmemobj then
*  calls EngPaint to fill.
*
* History:
*  07-Mar-1992 -by- Donald Sidoroff [donalds]
* Rewrote to call (Drv/Eng)Paint
*
*  13-Feb-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL EngFillPath(
 SURFOBJ  *pso,
 PATHOBJ  *ppo,
 CLIPOBJ  *pco,
 BRUSHOBJ *pbo,
 PPOINTL   pptlBrushOrg,
 MIX       mix,
 FLONG     flOptions
)
{
    GDIFunctionID(EngFillPath);
    ASSERTGDI(pso != (SURFOBJ *) NULL, "pso is NULL\n");
    ASSERTGDI(ppo != (PATHOBJ *) NULL, "ppo is NULL\n");
    ASSERTGDI(pco != (CLIPOBJ *) NULL, "pco is NULL\n");

    PSURFACE pSurf = SURFOBJ_TO_SURFACE(pso);
    PDEVOBJ po(pSurf->hdev());
    SUSPENDWATCH sw(po);

    ASSERTGDI(pco->iMode == TC_RECTANGLES, "Invalid clip object iMode");

// Check if we have to flatten any Beziers:

    if (ppo->fl & PO_BEZIERS)
        if (!((EPATHOBJ*) ppo)->bFlatten())
            return(FALSE);

// Before we touch any bits, make sure the device is happy about it.

    po.vSync(pso,&pco->rclBounds,0);

// check if we can try the fast fill.

    if (!( pSurf->flags() & HOOK_PAINT) &&
         (pco->iDComplexity != DC_COMPLEX))
    {
        PRECTL prclClip = NULL;

        if ((pco->iDComplexity == DC_RECT) ||
            (pco->fjOptions & OC_BANK_CLIP))
        {
            RECTFX rcfx = ((EPATHOBJ*)ppo)->rcfxBoundBox();

        // check the bound box, maybe it really is unclipped

            if ((pco->rclBounds.left   > (rcfx.xLeft          >> 4)) ||
                (pco->rclBounds.right  < ((rcfx.xRight  + 15) >> 4)) ||
                (pco->rclBounds.top    > (rcfx.yTop           >> 4)) ||
                (pco->rclBounds.bottom < ((rcfx.yBottom + 15) >> 4)))
            {
                prclClip = &pco->rclBounds;
            }
        }

    // -1 - couldn't handle, 0 error, 1 success

        LONG lRes = EngFastFill(pso,ppo,prclClip,pbo,pptlBrushOrg,mix,flOptions);
        if (lRes >= 0)
            return(lRes);
    }

// Convert path to region.

    RECTL Bounds,*pBounds;

    if( pco->iDComplexity != DC_TRIVIAL )
    {
        Bounds.top = (pco->rclBounds.top) << 4;
        Bounds.bottom = (pco->rclBounds.bottom) << 4;
        pBounds = &Bounds;
    }
    else
    {
        pBounds = NULL;
    }

    RGNMEMOBJTMP rmo(*((EPATHOBJ *)ppo), flOptions, pBounds);

    if (!rmo.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    if (rmo.iComplexity() == NULLREGION)
        return(TRUE);

// CLIPOBJ_bEnum will do the clipping if clipping is not complex.

    ERECTL erclClip(pco->rclBounds);

    if (pco->iDComplexity == DC_TRIVIAL)
    {
        ECLIPOBJ    ecoPath(rmo.prgnGet(), erclClip);
        if (ecoPath.erclExclude().bEmpty())
            return(TRUE);

        if (ecoPath.iDComplexity == DC_TRIVIAL)
            ecoPath.iDComplexity = DC_RECT;

    // Inc the target surface uniqueness

        INC_SURF_UNIQ(pSurf);

        BOOL    bRet;
        sw.Resume();
        
        bRet = EngPaint(
            pso,                                // Destination surface.
           &ecoPath,                            // Clip object.
            pbo,                                // Realized brush.
            pptlBrushOrg,                       // Brush origin.
            mix);                               // Mix mode.

        return(bRet);
    }

// Create a RGNMEMOBJ for bMerge since it will trash the target.

    RGNMEMOBJTMP rmoTrg;

    if (!rmoTrg.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

// Merge the region we just constructed with the clip region.

    if (!rmoTrg.bMerge(rmo, *((ECLIPOBJ *)pco), gafjRgnOp[RGN_AND]))
        return(FALSE);

    ERECTL  ercl;
    rmoTrg.vGet_rcl(&ercl);

    ercl *= ((ECLIPOBJ *)pco)->erclExclude();

    ECLIPOBJ co(rmoTrg.prgnGet(), ercl);

    if (co.erclExclude().bEmpty())
        return(TRUE);

    if (co.iDComplexity == DC_TRIVIAL)
        co.iDComplexity = DC_RECT;

// Inc the target surface uniqueness

    INC_SURF_UNIQ(pSurf);
    sw.Resume();

    sw.Resume();
    return(EngPaint(
        pso,                                // Destination surface.
       &co,                                 // Clip object.
        pbo,                                // Realized brush.
        pptlBrushOrg,                       // Brush origin.
        mix));                              // Mix mode.
}

/******************************Member*Function*****************************\
* EngStrokeAndFillPath
*
*  Engine simulation for stroking and filling the given path.
*
* History:
*  06-Apr-1992 -by- J. Andrew Goossen [andrewgo]
* Re-wrote it to do region subtraction.
*
*  02-Oct-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL EngStrokeAndFillPath(
SURFOBJ   *pso,
PATHOBJ   *ppo,
CLIPOBJ   *pco,
XFORMOBJ  *pxo,
BRUSHOBJ  *pboStroke,
LINEATTRS *pla,
BRUSHOBJ  *pboFill,
POINTL    *pptlBrushOrg,
MIX        mix,
FLONG      flOptions)
{
    BOOL bRet = FALSE;

    PSURFACE pSurf = SURFOBJ_TO_SURFACE(pso);

    MIX mixFill, mixStroke;

    mixFill = mixStroke = mix;

    if (!((EBRUSHOBJ *)pboFill)->bIsMasking())
    {
        mixFill = (mix & 0xff) | ((mix & 0xff) << 8);
    }

    if (!((EBRUSHOBJ *)pboStroke)->bIsMasking())
    {
        mixStroke = (mix & 0xff) | ((mix & 0xff) << 8);
    }

    ERECTL ercl;

    // If we're not doing a wide-line, or if we're doing a wide-line and
    // the mix is overwrite so we don't care about re-lighting pixels,
    // make two calls out of it:

    if (!(pla->fl & LA_GEOMETRIC) || ((mix & 0xFF) == R2_COPYPEN))
    {
        bRet = EngFillPath(pso,
                           ppo,
                           pco,
                           pboFill,
                           pptlBrushOrg,
                           mixFill,
                           flOptions) &&
               EngStrokePath(pso,
                             ppo,
                             pco,
                             pxo,
                             pboStroke,
                             pptlBrushOrg,
                             pla,
                             mixStroke);
        return(bRet);
    }

    // Okay, we have a wideline call with a weird mix mode.  Because part
    // of the wide-line overlaps part of the fill, we will convert both to
    // regions, and subtract them so that they won't overlap.

    // Convert the widened outline to a region.  We have to widen the path
    // before flattening it (for the fill) because the widener will produce
    // better looking wide curves that way:

    PATHMEMOBJ pmoStroke;

    if (!pmoStroke.bValid() ||
        !pmoStroke.bComputeWidenedBounds(*(EPATHOBJ*) ppo, pxo, pla) ||
        !pmoStroke.bWiden(*(EPATHOBJ*) ppo, pxo, pla))
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return(bRet);
    }

    // First flatten any curves and then convert the interior to a region:

    if (ppo->fl & PO_BEZIERS)
    {
        if (!((EPATHOBJ*) ppo)->bFlatten())
        {
            return(bRet);
        }
    }

    // Create the regions:

    RGNMEMOBJTMP rmoStroke(pmoStroke, WINDING);
    RGNMEMOBJTMP rmoFill(*((EPATHOBJ *)ppo), flOptions);
    RGNMEMOBJTMP rmoNewFill;

    if (rmoFill.bValid() &&
        rmoStroke.bValid() &&
        rmoNewFill.bValid() &&
        rmoNewFill.bMerge(rmoFill, rmoStroke, gafjRgnOp[RGN_DIFF]))
    {
        // Create a RGNMEMOBJ for bMerge since it will trash the target.

        RGNMEMOBJTMP rmoTrg;

        if (rmoTrg.bValid())
        {
            PDEVOBJ pdo(pSurf->hdev());

            // Paint the stroked outline:

            if (rmoStroke.iComplexity() != NULLREGION)
            {
                // Merge the outline region with the clip region:

                if (!rmoTrg.bMerge(rmoStroke, *((ECLIPOBJ *)pco), gafjRgnOp[RGN_AND]))
                {
                    bRet = FALSE;
                }
                else
                {
                    rmoTrg.vGet_rcl(&ercl);
                    ECLIPOBJ co(rmoTrg.prgnGet(), ercl);

                    if (co.erclExclude().bEmpty())
                    {
                        bRet = TRUE;
                    }
                    else
                    {
                        INC_SURF_UNIQ(pSurf);

                        bRet = EngPaint(
                                pso,
                                &co,
                                pboStroke,
                                pptlBrushOrg,
                                mixStroke);

                    }
                }
            }

            // Paint the filled interior:

            if ((bRet == TRUE) &&
                rmoNewFill.iComplexity() != NULLREGION)
            {
                // Merge the inside region with the clip region.

                if (!rmoTrg.bMerge(rmoNewFill, *((ECLIPOBJ *)pco), gafjRgnOp[RGN_AND]))
                {
                    bRet = FALSE;
                }
                else
                {
                    rmoTrg.vGet_rcl(&ercl);
                    ECLIPOBJ co(rmoTrg.prgnGet(), ercl);

                    if (co.erclExclude().bEmpty())
                    {
                        bRet = TRUE;
                    }
                    else
                    {
                        INC_SURF_UNIQ(pSurf);

                        bRet = EngPaint(pso,
                                        &co,
                                        pboFill,
                                        pptlBrushOrg,
                                        mixFill);
                    }
                }
            }
        }
    }

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\floodgdi.cxx ===
/******************************Module*Header*******************************\
* Module Name: floodgdi.cxx
*
* Contains FLOODFILL and its helper functions.
*
* Created: 20-May-1991 14:33:19
* Author: Wendy Wu [wendywu]
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

// Valid iMode for bExpandScanline().

#define EXPAND_MERGE_SCANLINE   1
#define EXPAND_SCRATCH_SCANLINE 0

// Valid iMode fore STACKMEMOBJ().

#define ALLOC_MERGE_SCANLINE   1
#define DONT_ALLOC_MERGE_SCANLINE 0


#define FLOOD_REGION_SIZE  (NULL_REGION_SIZE                                 + \
                           (NULL_SCAN_SIZE + (sizeof(INDEX_LONG) * 2)) * 200 + \
                            NULL_SCAN_SIZE)

typedef struct _SPAN
{
    LONG    xLeft;      // inclusive left
    LONG    xRight;     // exclusive right
}SPAN, *PSPAN;

class SCANLINE;
typedef SCANLINE *PSCANLINE ;

/*********************************Class************************************\
* class SCANLINE
*
* This variable length structure describes an area in a scanline which
* should be filled.
*
* History:
*  20-May-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

class SCANLINE
{
public:
    LONG        y;                  // y coordinate of this scanline
    COUNT       cSpans;             // number of spans
    ULONGSIZE_T      cjScanline;         // size in byte of this scanline
    PSCANLINE   psclBelow;          // -> the scanline below
    SPAN        aSpan[1];           // variable length of spans
};

#define SCANLINEHEADER_SIZE (sizeof(SCANLINE) - sizeof(SPAN))

// The stack is empty when psclTop->psclBelow points to psclTop itself.
// At this time, cjStack must be 0.

/*********************************Class************************************\
* class STACKOBJ
*
* Stack to hold SCANLINEs in the order of the flooding.
*
* History:
*  20-May-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

class STACKOBJ
{
public:
    ULONGSIZE_T      cjObj;              // size of the memory allocated
    ULONGSIZE_T      cjStack;            // size of the object used
    PSCANLINE   psclTop;            // -> the scanline at the top of the stack
    PSCANLINE   psclScratch;        // -> the sratch scanline
    PSCANLINE   psclMerge;          // -> the merging scanline
    PBYTE       pjStackBase;        // the base address of this stack

public:
    SCANLINE&   scl2ndTop()         { return(*(psclTop->psclBelow)); }
    BOOL        bValid()            { return(pjStackBase != (PBYTE)NULL); }
    LONG        yTop()              { return(psclTop->y); }
    LONG        y2ndTop()           { return((psclTop->psclBelow)->y); }
    BOOL        bEmpty()            { return(cjStack == 0); }
    BOOL        bNotEmpty()         { return(cjStack != 0); }
    BOOL        bMoreThanOneEntry() { return(psclTop->psclBelow != (PSCANLINE)NULL); }
    BOOL        bExpand(ULONGSIZE_T cj);
    BOOL        bExpandScanline(ULONGSIZE_T cj, ULONG iMode);
    VOID        vPop()
    {
        ASSERTGDI(bNotEmpty(), "Pop an empty stack");
        cjStack -= psclTop->cjScanline;
        psclTop = psclTop->psclBelow;
    }

    BOOL         bPushMergeScrScan();
    BOOL         bPopPushMergeScrScan()
    {
        vPop();
        return(bPushMergeScrScan());
    }

};

/*********************************Class************************************\
* class STACKMEMOBJ
*
* Memory object for STACKOBJ.
*
* History:
*  20-May-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

class STACKMEMOBJ : public STACKOBJ
{
public:
    STACKMEMOBJ(ULONGSIZE_T cj, ULONG iMode, LONG y, LONG xLeft, LONG xRight);
   ~STACKMEMOBJ();
};

#define SCRATCH_SCANLINE_SIZE   SCANLINEHEADER_SIZE + 20 * sizeof(SPAN)
#define MERGE_SCANLINE_SIZE     SCANLINEHEADER_SIZE + 20 * sizeof(SPAN)
#define SCANLINE_INC_SIZE       20 * sizeof(SPAN)
#define DOWNSTACK_SIZE          sizeof(STACKOBJ) + 2 * SCRATCH_SCANLINE_SIZE
#define UPSTACK_SIZE            sizeof(STACKOBJ) + 10 * SCRATCH_SCANLINE_SIZE
#define STACK_INC_SIZE          10 * SCRATCH_SCANLINE_SIZE

/*********************************Class************************************\
* class FLOODBM
*
* Contains information about FloodFill and the destination bitmap where
* it takes place.
*
* History:
*  20-May-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

class FLOODBM
{
public:
    ULONG iFormat;      // format of the bitmap
    RECTL rcl;          // clipping rectangle
    ULONG iColor;       // color passed in to ExtFloodFill
    DWORD iFillType;    // filling mode passed in to ExtFloodFill
    PBYTE pjBits;       // pointer to the current scanline
    FLONG flMask;       // mask of used bits

public:
    FLOODBM(ULONG _iFormat, RECTL& _rcl, ULONG _iColor,
             DWORD _iFillType, PBYTE _pjBits, PALETTE  *pPal);

   ~FLOODBM()          {}

    ULONG iColorGet(LONG x);
    VOID  vFindExtent(LONG x, LONG& xLeft, LONG& xRight);
    BOOL  bSearchAllSpans(LONG xLeft, LONG xRight, LONG& xLeftNew, LONG& xRightNew,
                          PBYTE pjStart, STACKOBJ& sto, PSCANLINE pscl);
    BOOL  bExtendScanline(STACKOBJ& st, STACKOBJ& stOp, LONG lyNxt,
                          PBYTE pjBitsCur, PBYTE pjBitsNxt);
};

/******************************Public*Routine******************************\
* FLOODBM::FLOODBM(
*
* History:
*  16-Aug-1994 -by-  Eric Kutter [erick]
* Made it out of line.
\**************************************************************************/

FLOODBM::FLOODBM(
    ULONG _iFormat,
    RECTL& _rcl,
    ULONG _iColor,
    DWORD _iFillType,
    PBYTE _pjBits,
    PALETTE  *pPal)
{
    iFormat = _iFormat;
    rcl = _rcl;
    iColor = _iColor;
    iFillType = _iFillType;
    pjBits = _pjBits;
    flMask = 0xffffffff;

    XEPALOBJ pal(pPal);

    if (pal.bValid())
    {
        if (pal.bIsRGB() || pal.bIsBGR())
            flMask =0xffffff;
        else if (pal.bIsBitfields())
            flMask = pal.flRed() | pal.flGre() | pal.flBlu();
    }
}

/******************************Member*Function*****************************\
* VOID vMergeSpans(pspnSrc1, pspnEndSrc1, pspnSrc2, pspnEndSrc2, pspnTrg)
*
*  Merge two arrays of spans together and store into the target span.
*
* History:
*  12-Jun-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

VOID vMergeSpans(PSPAN pspnSrc1, PSPAN pspnEndSrc1,
                 PSPAN pspnSrc2, PSPAN pspnEndSrc2, PSPAN pspnTrg)
{
    while((pspnSrc1 < pspnEndSrc1) && (pspnSrc2 < pspnEndSrc2))
    {
        if (pspnSrc1->xLeft < pspnSrc2->xLeft)
        {
            ASSERTGDI((pspnSrc1->xRight < pspnSrc2->xLeft),
                      "vMergeSpans walls overlapped\n");
            *pspnTrg++ = *pspnSrc1++;
        }
        else
        {
            ASSERTGDI((pspnSrc2->xRight < pspnSrc1->xRight),
                      "vMergeSpans walls overlapped\n");

            *pspnTrg++ = *pspnSrc2++;
        }
    }

    while (pspnSrc1 < pspnEndSrc1)
        *pspnTrg++ = *pspnSrc1++;

    while (pspnSrc2 < pspnEndSrc2)
        *pspnTrg++ = *pspnSrc2++;
}

/******************************Member*Function*****************************\
* STACKMEMOBJ::STACKMEMOBJ(cj, bMerge, y, xLeft, xRight)
*
*  Constructor.
*
* History:
*  08-Sep-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

STACKMEMOBJ::STACKMEMOBJ(ULONGSIZE_T cj, ULONG iMode, LONG y,
                         LONG xLeft, LONG xRight)
{
    psclMerge = (PSCANLINE)NULL;
    pjStackBase = (PBYTE)NULL;

    psclScratch = (PSCANLINE)PALLOCNOZ(SCRATCH_SCANLINE_SIZE, 'dlFG');

    if (psclScratch == (PSCANLINE)NULL)
    {
        return;
    }

    psclScratch->cjScanline = SCRATCH_SCANLINE_SIZE;
    psclScratch->cSpans = 0;

    if (iMode == ALLOC_MERGE_SCANLINE)
    {
        psclMerge = (PSCANLINE)PALLOCNOZ(MERGE_SCANLINE_SIZE, 'dlFG');
        if (psclMerge == (PSCANLINE)NULL)
            return;
        psclMerge->cjScanline = MERGE_SCANLINE_SIZE;
        psclMerge->cSpans = 0;
    }

    cjObj = cj;
    cjStack = sizeof(SCANLINE);
    pjStackBase = (PBYTE)PALLOCNOZ(cj, 'dlFG');
    if (pjStackBase == (PBYTE)NULL)
        return;

    psclTop = (PSCANLINE)pjStackBase;

    psclTop->y = y;
    psclTop->cSpans = 1;
    psclTop->cjScanline = sizeof(SCANLINE);
    psclTop->psclBelow = psclTop;
    psclTop->aSpan[0].xLeft = xLeft;
    psclTop->aSpan[0].xRight = xRight;
}

/******************************Member*Function*****************************\
* STACKMEMOBJ::~STACKMEMOBJ()
*
*  Destructor.
*
* History:
*  08-Sep-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

STACKMEMOBJ::~STACKMEMOBJ()
{
    if (pjStackBase != (PBYTE)NULL)
        VFREEMEM(pjStackBase);
    if (psclScratch != (PSCANLINE)NULL)
        VFREEMEM(psclScratch);
    if (psclMerge != (PSCANLINE)NULL)
        VFREEMEM(psclMerge);

    psclScratch = psclMerge = (PSCANLINE)NULL;
    pjStackBase = (PBYTE)NULL;
}

/******************************Member*Function*****************************\
* BOOL STACKOBJ::bPushMergeScrScan()
*
* Push the scanline pointed to by psclScratch onto the stack.  If the y
* of the given scanline is the same as the y of the scanline on top of the
* stack, merge them together.
*
* History:
*  06-Sep-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL STACKOBJ::bPushMergeScrScan()
{
// Get out of here if nothing to push.

    if (psclScratch->cSpans == 0)
        return(TRUE);

#ifdef DBG_FLOOD

    DbgPrint("bPushMergeScrScan: y = %ld, cSpans = %ld\n",
              psclScratch->y,psclScratch->cSpans);

    for (COUNT j = 0; j < psclScratch->cSpans; j++)
        DbgPrint("                 Left = %ld, Right = %ld\n",
                  psclScratch->aSpan[j].xLeft,psclScratch->aSpan[j].xRight);
#endif

    PSCANLINE psclNew = psclScratch;

    ULONGSIZE_T cjNew = SCANLINEHEADER_SIZE + (ULONGSIZE_T)psclNew->cSpans * sizeof(SPAN);
    ULONGSIZE_T cjInc = cjNew;

// If we'll have to do merge later on.  The cjInc is SCANLINEHEADER_SIZE
// bigger than the actual stack size increase after this function.  We
// might end up expanding the stack unnecessarily.  But it's OK since
// we're so close to use up our stack space and subsequent calls might
// cause stack expansion anyway.

    if ((cjStack + cjInc) > cjObj)
    {
        if (!bExpand(cjStack + cjNew))
            return(FALSE);
    }

    psclNew->psclBelow = psclTop;

// Check if merge is necessary.

    if (bNotEmpty())
    {
        if (yTop() == psclScratch->y)
        {
        // We have to do merge here.

            ASSERTGDI((psclMerge != (PSCANLINE)NULL),
                      "bPushMergeScrScan:invalid psclMerge");

            cjNew += psclTop->cjScanline - SCANLINEHEADER_SIZE;
            cjInc -= SCANLINEHEADER_SIZE;

            if (cjNew > psclMerge->cjScanline)
            {
                if (!bExpandScanline(cjNew, EXPAND_MERGE_SCANLINE))
                    return(FALSE);
            }

            ASSERTGDI((cjNew <= psclMerge->cjScanline),
                      "bPushMergeScrScan: did not alloc enough space\n");

            psclMerge->y = psclScratch->y;
            psclMerge->psclBelow = psclTop->psclBelow;
            psclMerge->cSpans = psclTop->cSpans + psclScratch->cSpans;

            vMergeSpans((PSPAN)&psclTop->aSpan[0].xLeft,
                        (PSPAN)&psclTop->aSpan[psclTop->cSpans].xLeft,
                        (PSPAN)&psclScratch->aSpan[0].xLeft,
                        (PSPAN)&psclScratch->aSpan[psclScratch->cSpans].xLeft,
                        (PSPAN)&psclMerge->aSpan[0].xLeft);

            psclNew = psclMerge;
        }
        else
        {
        // No merge is necessary.  Update pointers so we'll push to the
        // right spot.

            PBYTE pj = (PBYTE)psclTop + psclTop->cjScanline;
            psclTop = (PSCANLINE)pj;
        }
    }

    cjStack += cjInc;

    ASSERTGDI((cjStack <= cjObj),
              "bPushMergeScrScan: bExpand() failed to alloc enough space\n");

    ASSERTGDI((cjNew == (psclNew->cSpans * sizeof(SPAN) + SCANLINEHEADER_SIZE)),
              "bPushMergeScrScan: wrong cjNew\n");

    ASSERTGDI(((pjStackBase + cjStack) ==
               ((PBYTE)psclTop + cjNew)),
               "bPushMergeScrScan: stack error\n");

    psclNew->cjScanline = cjNew;
    RtlCopyMemory(psclTop, psclNew, cjNew);

    return(TRUE);
}

/******************************Member*Function*****************************\
* BOOL STACKOBJ::bExpand(cj)
*
*  Expand the stack to the given size plus a size defined as STACK_INC_SIZE.
*
* History:
*  08-Sep-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL STACKOBJ::bExpand(ULONGSIZE_T cj)
{
#ifdef DBG_FLOOD
    DbgPrint("Enter STACKOBJ::bExpand()\n");
#endif

    PBYTE pjStackBaseOld = pjStackBase;

    pjStackBase = (PBYTE)PALLOCNOZ(cj + STACK_INC_SIZE, 'dlFG');
    if (pjStackBase == (PBYTE)NULL)
        return(FALSE);

// Copy the contents of the old stack into the new one.

    RtlCopyMemory((PLONG)pjStackBase, (PLONG)pjStackBaseOld, cjStack);

    cjObj = cj + STACK_INC_SIZE;

// Update all the pointers in the stack.

    //Sundown: safe to truncate to ULONG since cjStack won't exceed 4gb
    PTRDIFF pdDiff = (ULONG)(pjStackBase - pjStackBaseOld);
    PBYTE pl = (PBYTE)psclTop + pdDiff;
    PSCANLINE pscl = psclTop = (PSCANLINE)pl;

    if (cjStack == 0)
    {
        psclTop->psclBelow = psclTop;
    }
    else
    {
        while (pscl->psclBelow != (PSCANLINE)pjStackBase)
        {
            pl = (PBYTE)pscl->psclBelow + pdDiff;
            pscl = (pscl->psclBelow = (PSCANLINE)pl);
        }
    }

// Free the old stack.

    VFREEMEM(pjStackBaseOld);
    return(TRUE);
}

/******************************Member*Function*****************************\
* BOOL STACKOBJ::bExpandScanline(cj, iMode)
*
*  Expand the stack.
*
* History:
*  08-Sep-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL STACKOBJ::bExpandScanline(ULONGSIZE_T cj, ULONG iMode)
{
#ifdef DBG_FLOOD
    DbgPrint("Enter STACKOBJ::bExpandScanline()\n");
#endif

    PSCANLINE pscl, psclNew;

    if (iMode == EXPAND_MERGE_SCANLINE)
        pscl = psclMerge;
    else
        pscl = psclScratch;

    ASSERTGDI((pscl != (PSCANLINE)NULL), "bExpandScanline: pscl is NULL");

// Allocate memory for the new scanline then copy the contents over.

    psclNew = (PSCANLINE)PALLOCNOZ((cj + SCANLINE_INC_SIZE), 'dlFG');
    if (psclNew == (PSCANLINE)NULL)
        return(FALSE);

    RtlCopyMemory(psclNew, pscl, pscl->cjScanline);

// Reflect the size of the new scanline and free the old scanline.

    psclNew->cjScanline = cj + SCANLINE_INC_SIZE;
    VFREEMEM(pscl);

// Store the pointer back into the stack.

    if (iMode == EXPAND_MERGE_SCANLINE)
        psclMerge = psclNew;
    else
        psclScratch = psclNew;

    return(TRUE);
}

/******************************Member*Function*****************************\
* ULONG FLOODBM::iColorGet(LONG x)
*
*  Get the color of the given x.  pjBits points to the first pel of the
*  y scanline.  iFormat gives the format of the bitmap.
*
* History:
*  13-Jun-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

ULONG FLOODBM::iColorGet(LONG x)
{
    ULONG ulColor;

    switch(iFormat)
    {
    case BMF_1BPP:
        ulColor = (ULONG) *(pjBits + (x >> 3));
        ulColor = ulColor >> (7 - (x & 7));
        return(ulColor & 1);

    case BMF_4BPP:
        ulColor = (ULONG) *(pjBits + (x >> 1));

        if (x & 1)
            return(ulColor & 15);
        else
            return(ulColor >> 4);

    case BMF_8BPP:
        return((ULONG) *(pjBits + x));

    case BMF_16BPP:
        return(((ULONG) *((PUSHORT) (pjBits + (x << 1)))) & flMask);

    case BMF_24BPP:
        {
            PBYTE   pjX = pjBits + (x * 3);
            ulColor = (ULONG) *(pjX + 2);
            ulColor <<= 8;
            ulColor |= ((ULONG) *(pjX + 1));
            ulColor <<= 8;
            return(ulColor | ((ULONG) *pjX));
        }

    case BMF_32BPP:
        return(((ULONG) *((PULONG) (pjBits + (x << 2)))) & flMask);

    default:
        RIP("iColorGet error\n");
    }
    return(0L);
}

/******************************Private*Routine*****************************\
* VOID FLOODBM::vFindExtent(x, xEnd, &xLeft, &xRight)
*
* Find the pixel extent in this scan that should be filled.
* x is the seed for this scan.
*
* History:
*  20-May-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

VOID FLOODBM::vFindExtent(LONG x, LONG& xLeft, LONG& xRight)
{
    LONG xLeftTemp = x - 1;
    LONG xRightTemp = x + 1;

    if (iFillType == FLOODFILLBORDER)
    {
        ASSERTGDI((iColorGet(x) != iColor),
                  "vFindExtent x has wrong color\n");

        while((xLeftTemp >= rcl.left) && (iColorGet(xLeftTemp) != iColor))
            xLeftTemp--;

        while((xRightTemp < rcl.right) && (iColorGet(xRightTemp) != iColor))
            xRightTemp++;
    }
    else
    {
        ASSERTGDI((iColorGet(x) == iColor),
                  "vFindExtent x has wrong color\n");

        while((xLeftTemp >= rcl.left) && (iColorGet(xLeftTemp) == iColor))
            xLeftTemp--;

        while((xRightTemp < rcl.right) && (iColorGet(xRightTemp) == iColor))
            xRightTemp++;
    }

    xLeft = xLeftTemp + 1;      // the extreme left pixel
    xRight = xRightTemp;        // the extreme right pixel

    ASSERTGDI((xLeft != xRight),"vFindExtent error\n");
}

/******************************Member*Function*****************************\
* BOOL FLOODBM::bSearchAllSpans(xLeft, xRight, xMax, pjStart, psclNew, pscl)
*
*  Search for all the spans between the given xLeft and xRight.
*
* History:
*  11-Jun-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL FLOODBM::bSearchAllSpans(LONG xLeft, LONG xRight,
                               LONG& xLeftNew, LONG& xRightNew,
                               PBYTE pjStart, STACKOBJ& sto, PSCANLINE pscl)
{
#ifdef DBG_FLOOD
    DbgPrint("bSearchAllSpans xLeft = %ld, xRight = %ld, pjStart = %ld\n",
              xLeft,xRight,pjStart);
#endif

    PSCANLINE psclNew = sto.psclScratch;    // We'll store the new scanline
                                            // at the location pointed to by
                                            // sto.psclScratch.
    LONG x = xLeft;
    COUNT cSpans = psclNew->cSpans;
    ULONGSIZE_T cjNew = SCANLINEHEADER_SIZE + (ULONGSIZE_T)cSpans * sizeof(SPAN);
                                        // size of scanline that has been used
    pjBits = pjStart;                   // update pointer to the current
                                        // scanline in the FLOODBM struct
    while (x < xRight)
    {
    // find the first pixel to fill.

        if (iFillType == FLOODFILLBORDER)
        {
            if (iColorGet(x) == iColor)
            {
                do { x++; }
                while ((x < xRight) && (iColorGet(x) == iColor));
            }
        }
        else
        {
            if (iColorGet(x) != iColor)
            {
                do { x++; }
                while ((x < xRight) && (iColorGet(x) != iColor));
            }
        }

        if (x == xRight)
            break;


    // Don't have to search for extent if we already know it.

        BOOL bNeedSearch = TRUE;

        if (pscl != (PSCANLINE)NULL)
        {
        // pscl points to a sorted list of spans that we found for this
        // scanline before.  See if x is within any of the spans.

            for (COUNT i = 0; i < pscl->cSpans; i++)
            {
                if (x >= pscl->aSpan[i].xLeft)
                {
                    if (x < pscl->aSpan[i].xRight)
                    {
                        x = pscl->aSpan[i].xRight;
                        bNeedSearch = FALSE;
                        break;
                    }
                }
                else break;
            }
        }

        if (bNeedSearch)
        {
        // sclNew contains an un-sorted list of spans that we just found
        // for this scanline.  See if x is within any of the spans.

            for (COUNT i = 0; i < psclNew->cSpans; i++)
            {
                if ((x >= psclNew->aSpan[i].xLeft) &&
                    (x < psclNew->aSpan[i].xRight))
                {
                    x = psclNew->aSpan[i].xRight;
                    bNeedSearch = FALSE;
                    break;
                }
            }

            if (bNeedSearch)
            {
            // Find the pixel boundary of the current span

                if ((cjNew += sizeof(SPAN)) > psclNew->cjScanline)
                {
                    if (!sto.bExpandScanline(cjNew, EXPAND_SCRATCH_SCANLINE))
                        return(FALSE);          // allocation failed

                    psclNew = sto.psclScratch;
                }

                ASSERTGDI((cjNew <= psclNew->cjScanline),
                          "bSearchAllSpans: did not alloc enough space\n");

                vFindExtent(x, psclNew->aSpan[psclNew->cSpans].xLeft,
                               psclNew->aSpan[psclNew->cSpans].xRight);

                x = psclNew->aSpan[psclNew->cSpans].xRight + 1;
                psclNew->cSpans++;
            }
        }
    }

    if (cSpans == psclNew->cSpans)
        xLeftNew = xRightNew = 0;
    else
    {
    // Store the new xLeft and xRight onto the stack.

        xLeftNew = psclNew->aSpan[cSpans].xLeft;
        xRightNew = psclNew->aSpan[psclNew->cSpans-1].xRight;

    // Sort the spans out.

        for (COUNT i = 0; i < (psclNew->cSpans - 1); i++)
        {
            LONG xMin = psclNew->aSpan[i].xLeft;
            ULONG iMin = i;

            for (COUNT j = i; j < psclNew->cSpans; j++)
            {
                if (psclNew->aSpan[j].xLeft < xMin)
                {
                    xMin = psclNew->aSpan[j].xLeft;
                    iMin = j;
                }
            }

        // Swap the first span with the span with the smallest x.

            if (i != iMin)
            {
                SPAN sp = psclNew->aSpan[i];
                psclNew->aSpan[i] = psclNew->aSpan[iMin];
                psclNew->aSpan[iMin] = sp;
            }
        }

#ifdef DBG_FLOOD
    DbgPrint("bSearchAllSpans xLeftNew = %ld, xRightNew = %ld\n",
              xLeftNew,xRightNew);
#endif
    }

    return(TRUE);
}

/******************************Private*Routine*****************************\
* BOOL FLOODBM::bExtendScanline(&sto, &stoOp, lyNxt, pjBitsCur, pjBitsNxt)
*
* Check if the next scanline is previously filled or is a boundary.  If not,
* find the span of the next scanline and search for any spillage.  Push
* the resultant spans onto the stack.
*
* History:
*  20-May-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL FLOODBM::bExtendScanline(STACKOBJ& sto, STACKOBJ& stoOp, LONG lyNext,
                               PBYTE pjBitsCurr, PBYTE pjBitsNext)
{
// For each span in the current scanline, find the spans for the next scanline.

    PSCANLINE pscl = sto.psclTop;            // top of current stack

// psclCurr and psclNext point to the scanlines we're about to extend
// to.  The space for these scanlines were allocated in STACKMEMOBJ()
// and are used over and over again in this routine so that reallocation
// is not needed every time we enter here.

    PSCANLINE psclCurr = stoOp.psclScratch;
    PSCANLINE psclNext = sto.psclScratch;
    psclNext->cSpans = psclCurr->cSpans = 0;
    psclCurr->y = pscl->y; psclNext->y = lyNext;
    PSCANLINE psclNextOld = (PSCANLINE)NULL;

// See if we've handled the next scanline before.  If we do, pass the
// structure to bSearchAllSpans() to eliminate searching for the same
// extents twice.  If the next scanline was dealt with before, its
// must be stored in the current stack at the 2nd entry from the top.

    if (sto.bMoreThanOneEntry() && (sto.y2ndTop() == lyNext))
        psclNextOld = &sto.scl2ndTop();

    BOOL bReturn = TRUE;

    for (COUNT i = 0; i < pscl->cSpans; i++)
    {
        LONG xLeft = pscl->aSpan[i].xLeft;
        LONG xRight = pscl->aSpan[i].xRight;
        LONG xLeftNew, xRightNew, xTemp;

        bReturn = bSearchAllSpans(xLeft, xRight, xLeftNew, xRightNew,
                                  pjBitsNext, sto, psclNextOld);

        if(!bReturn)
        {
            break; 
        }
       
        if (xLeftNew != xRightNew)
        {
search_left:
            if (xLeftNew < (xLeft - 1))
            {
            // Check for spillage on the left for the current scanline.

                xTemp = xLeft - 1;
                xLeft = xLeftNew;

                bReturn &= bSearchAllSpans(xLeft, xTemp, xLeftNew, xTemp,
                                           pjBitsCurr, stoOp, pscl);

                if(!bReturn) 
                {
                    break; 
                }

                if ((xLeftNew != xTemp) && (xLeftNew < (xLeft - 1)))
                {
                // Check for spillage on the left for the next scanline.

                    xTemp = xLeft - 1;
                    xLeft = xLeftNew;

                    bReturn &= bSearchAllSpans(xLeft, xTemp, xLeftNew, xTemp,
                                               pjBitsNext, sto, psclNextOld);

                    if(!bReturn)
                    {
                        break; 
                    }

                    if (xLeftNew != xTemp)
                        goto search_left;
                }
            }

search_right:

            if (xRightNew > (xRight + 1))
            {
            // Check for spillage on the right for the current scanline.

                xTemp = xRight + 1;
                xRight = xRightNew;

                bReturn &= bSearchAllSpans(xTemp, xRight, xLeftNew, xRightNew,
                                           pjBitsCurr, stoOp, pscl);
                if(!bReturn)
                {
                    break;
                }

                if ((xLeftNew != xRightNew) && (xRightNew > (xRight + 1)))
                {
                // Check for spillage on the right for the next scanline.

                    xTemp = xRight + 1;
                    xRight = xRightNew;

                    bReturn &= bSearchAllSpans(xTemp, xRight, xLeftNew,
                                xRightNew, pjBitsNext, sto, psclNextOld);
                    if(!bReturn)
                    {
                        break;
                    }

                    if (xLeftNew != xRightNew)
                        goto search_right;
                }
            }
        }
    }

// Push the newly found extents onto the stack.

    if( bReturn )
    {
        bReturn &= (stoOp.bPushMergeScrScan() & sto.bPopPushMergeScrScan());
    }

    return(bReturn);
}

/******************************Member*Function*****************************\
* BOOL RGNOBJ::bMergeScanline(&sto)
*
*  Merge a new scanline into the existing region.  This is used by
*  ExtFloodFill to construct regions.
*
* History:
*  31-May-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL RGNMEMOBJ::bMergeScanline(STACKOBJ& sto)
{
    PSCAN pscn;
    PSPAN pspn;
    COUNT cWalls;
    PSCANLINE psclNew = sto.psclTop;

#ifdef DBG_FLOOD

    DbgPrint("y = %ld, cSpans = %ld\n",psclNew->y,psclNew->cSpans);

    for (COUNT j = 0; j < psclNew->cSpans; j++)
        DbgPrint("  Left = %ld, Right = %ld\n",
                  psclNew->aSpan[j].xLeft,psclNew->aSpan[j].xRight);
#endif

    if (prgn->sizeRgn == NULL_REGION_SIZE)
    {
    // We just got the first scanline for this region.

        ULONGSIZE_T sizeRgn;

        if ((sizeRgn = NULL_REGION_SIZE + NULL_SCAN_SIZE + NULL_SCAN_SIZE +
                sizeof(INDEX_LONG) * (ULONGSIZE_T)(cWalls = psclNew->cSpans << 1)) >
             prgn->sizeObj)
        {
        // Hopefully this is big enough to avoid reallocation later on.

            if (!bExpand(sizeRgn + FLOOD_REGION_SIZE))
                return(FALSE);
        }

        prgn->sizeRgn = sizeRgn;
        prgn->cScans = 3;

        pscn = prgn->pscnHead();            // first scan
        pscn->yBottom = psclNew->y;

        pscn = pscnGet(pscn);               // second scan
        pscn->cWalls = cWalls;

        pscn->yTop = psclNew->y;
        pscn->yBottom = psclNew->y+1;
        pspn = (PSPAN)&psclNew->aSpan[0].xLeft;
        COUNT i;

        for (i = 0; i < cWalls; i+=2)
        {
            pscn->ai_x[i].x = pspn->xLeft;
            pscn->ai_x[i+1].x = pspn->xRight;
            pspn++;
        }
        pscn->ai_x[i].x = cWalls;           // This sets cWalls2

    // Fix the bounding box

        prgn->rcl.top = psclNew->y;
        prgn->rcl.bottom = psclNew->y+1;
        prgn->rcl.left = pscn->ai_x[0].x;
        prgn->rcl.right = pscn->ai_x[cWalls-1].x;
        ASSERTGDI((prgn->rcl.left < prgn->rcl.right), "bMergeScanline error");

        pscn = pscnGet(pscn);               // third scan
        pscn->cWalls = 0;
        pscn->yTop = psclNew->y+1;
        pscn->yBottom = POS_INFINITY;
        pscn->ai_x[0].x = 0;                // This sets cWalls

        prgn->pscnTail = pscnGet(pscn);
        return TRUE;
    }

// Check for nearly full region

    ULONGSIZE_T sizInc = NULL_SCAN_SIZE + sizeof(SPAN) * (ULONGSIZE_T)psclNew->cSpans;

    if (sizInc > prgn->sizeObj - prgn->sizeRgn)
    {
    // Lets expand it generously since this region is tossed when FloodFill
    // is done.

        if (!bExpand(prgn->sizeObj + sizInc + FLOOD_REGION_SIZE))
            return(FALSE);
    }

    pscn = prgn->pscnHead();
    PSCAN       pscnTail = prgn->pscnTail;
    PSCANLINE   pscl;

// Search for the scan that's right below the scanline to be merged in.

    while (psclNew->y > pscn->yTop)
        pscn = pscnGet(pscn);           // points to the next scan

    ASSERTGDI((pscn < pscnTail), "search has gone beyond the region\n");

    if (psclNew->y == pscn->yTop)
    {
    // We have to merge with the scan pointed to by pscn.

        if (pscn->yTop+1 != pscn->yBottom)
        {
            prgn->cScans += 1;          // adjust the bounding box
            prgn->rcl.bottom = psclNew->y+1;

            pscn->yTop = psclNew->y+1;  // adjust yTop of the to-be next scan
            pscl = psclNew;
        }
        else
        {
        // The scan is one pel high.  We'll prepare and store the resultant
        // scanline in the space pointed to by psclMerge.

            ASSERTGDI(!(pscn->cWalls & 1),"Odd Walls in bMergeScanline\n");
            PSCANLINE psclMerge = sto.psclScratch;

            psclMerge->y = pscn->yTop;
            psclMerge->cSpans = psclNew->cSpans + (pscn->cWalls >> 1);

        // If the space pointed to by psclMerge is not big enough for
        // the merged scanline, we have to expand it.

            sizInc -= NULL_SCAN_SIZE;   // don't need to store scan header
            ULONGSIZE_T sizeMerge = (ULONGSIZE_T)psclMerge->cSpans * sizeof(SPAN) +
                                    SCANLINEHEADER_SIZE;

            if (sizeMerge > psclMerge->cjScanline)
            {
                 if (!sto.bExpandScanline(sizeMerge, EXPAND_SCRATCH_SCANLINE))
                     return(FALSE);

                psclMerge = sto.psclScratch;
            }

            ASSERTGDI((sizeMerge <= psclMerge->cjScanline),
                      "bMergeScanline: did not alloc enough space\n");

        // Call the real merger.

            vMergeSpans((PSPAN)&pscn->ai_x[0].x,
                        (PSPAN)&pscn->ai_x[pscn->cWalls].x,
                        (PSPAN)&psclNew->aSpan[0].xLeft,
                        (PSPAN)&psclNew->aSpan[psclNew->cSpans].xLeft,
                        (PSPAN)&psclMerge->aSpan[0].xLeft);
            pscl = psclMerge;
        }
    }
    else                                    // psclNew->y < pscn->yTop
    {
    // The new scanline is above the scan pointed to by pscn.

        PSCAN pscnPrev = pscnGot(pscn);     // adjust yBottom of prev scan
        pscnPrev->yBottom = psclNew->y;

        prgn->cScans += 1;
        if (psclNew->y < prgn->rcl.top)     // adjust bounding box
            prgn->rcl.top = psclNew->y;

        pscl = psclNew;
    }

register    PLONG plDst = (PLONG)((PBYTE)pscnTail + sizInc);
register    PLONG plSrc = (PLONG)pscnTail;

    prgn->pscnTail = (PSCAN)plDst;  // update tail of scan

    while (plSrc > (PLONG)pscn)     // move the scans below to the right place
        *--plDst = *--plSrc;

    pscn->cWalls = pscl->cSpans << 1;
    pscn->yTop = pscl->y;
    pscn->yBottom = pscl->y+1;
    pspn = (PSPAN)&pscl->aSpan[0].xLeft;

// Fill in info for walls.

    cWalls = pscn->cWalls;
    COUNT i;

    for (i = 0; i < cWalls; i+=2)
    {
        pscn->ai_x[i].x = pspn->xLeft;
        pscn->ai_x[i+1].x = pspn->xRight;
        pspn++;
    }
    pscn->ai_x[i].x = cWalls;               // This sets cWalls2

// Recalculate xLeft and xRight in the bounding box.

    if (prgn->rcl.left > pscn->ai_x[0].x)
        prgn->rcl.left = pscn->ai_x[0].x;

    if (prgn->rcl.right < pscn->ai_x[cWalls-1].x)
        prgn->rcl.right = pscn->ai_x[cWalls-1].x;

    prgn->sizeRgn += sizInc;

    return(TRUE);
}

/******************************Public*Routine*****************************\
* BOOL NtGdiExtFloodFill (hdc,x,y,crColor,iFillType,pac)
*
* Fills an area with the current brush.  It begins at the given (x, y)
* point and continues in all directions.  If iFillType is
* FLOODFILLBORDER, the filling area is bounded by crColor.  If iFillType
* is FLOODFILLSURFACE, the filling area contains the color crColor.
*
* History:
*  Tue 10-Sep-1991 -by- Patrick Haluptzok [patrickh]
* put in different DIBMEMOBJ constructor, no more palette creation
*
*  Mon 24-Jun-1991 -by- Patrick Haluptzok [patrickh]
* Check for NULL brush, new brush constructor.
*
*  20-May-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\*************************************************************************/

BOOL
APIENTRY
NtGdiExtFloodFill(
    HDC      hdc,
    INT      x,
    INT      y,
    COLORREF crColor,
    UINT     iFillType
    )
{
    GDIFunctionID(NtGdiExtFloodFill);

    DCOBJ dco(hdc);

    if (!dco.bValidSurf())
    {
        if (!dco.bValid())
        {
            SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
            return(FALSE);
        }
        else
        {
            if (dco.fjAccum())
            {
                // Use the device's surface size to accumulate bounds.

                PDEVOBJ po(dco.hdev());
                ASSERTGDI(po.bValid(),"invalid pdev\n");

                SIZEL   sizl;

                // if there is no surface, use the dc size. This can happen
                // during metafiling.
                //
                // acquire the devlock to protect us from a dynamic mode
                // change happening while we're munging around in pSurface()

                GreAcquireSemaphoreEx(po.hsemDevLock(), SEMORDER_DEVLOCK, NULL);

                if (po.pSurface())
                    sizl = (po.pSurface())->sizl();
                else
                    sizl = dco.pdc->sizl();

                GreReleaseSemaphoreEx(po.hsemDevLock());

                ERECTL  ercl(0, 0, sizl.cx, sizl.cy);

                dco.vAccumulate(ercl);
            }
            return(TRUE);
        }
    }

    SYNC_DRAWING_ATTRS(dco.pdc);

// Lock the Rao region and surface, ensure VisRgn up to date.

    DEVLOCKOBJ dlo(dco);

    SURFACE *pSurf = dco.pSurface();

    if ((pSurf != NULL) && (pSurf->iType() == STYPE_DEVBITMAP))
    {
        //
        // Convert the DFB to a DIB.  FloodFills to DFBs are EXTREMELY
        // inefficient so this is how we prevent them.  If we don't do
        // this, every floodfill (no matter how big) requires copying
        // the entire DFB to a DIB and then copying the entire DIB back
        // to the DFB (and the floodfills tend to come many at a time).
        //

        if (bConvertDfbDcToDib(&dco))
        {
            pSurf = dco.pSurface();    // it might have changed
        }
        else
        {
            WARNING("bConvertDfbDcToDib failed\n");
        }
    }

// Transform (x,y) from world to device space.

    EPOINTL eptl(x,y);

    EXFORMOBJ xo(dco, WORLD_TO_DEVICE);

    if (!xo.bXform(eptl))
        return(FALSE);

// User objects for all our toys.

    PDEVOBJ pdo(pSurf->hdev());
    XEPALOBJ palSurf(pSurf->ppal());
    XEPALOBJ palDC(dco.ppal());

    ULONG iSolidColor;
    FLONG flColorType;

// If somebody wants to floodfill a printer, they're out of luck.  [EricK]

    if (dco.bPrinter())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        WARNING("FloodFill not allowed on this surface\n");
        return(FALSE);
    }

    if (dco.pdc->bIsCMYKColor() || dco.pdc->bIsDeviceICM())
    {
        // because, usually, CMYK color and device ICM is for Printer...

        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        WARNING("FloodFill not allowed with CMYK color or Device ICM context\n");
        return(FALSE);
    }

// Map required color from palette

    iSolidColor = ulGetNearestIndexFromColorref(palSurf, palDC, crColor);

    if (dco.pdc->bIsSoftwareICM())
    {
        flColorType = BR_HOST_ICM;
    }
    else
    {
        flColorType = 0;
    }

// Realize the brush

    EBRUSHOBJ *peboFill = dco.peboFill();

    if ((dco.ulDirty() & DIRTY_FILL) || (dco.pdc->flbrush() & DIRTY_FILL))
    {
        dco.ulDirtySub(DIRTY_FILL);
        dco.pdc->flbrushSub(DIRTY_FILL);

        peboFill->vInitBrush(dco.pdc,
                             dco.pdc->pbrushFill(),
                             palDC,
                             palSurf,
                             pSurf);
    }

    if (peboFill->bIsNull())
        return(TRUE);

    if (!dlo.bValid())
        return(dco.bFullScreen());

// Convert (x,y) to SCREEN coordinates.  Return FALSE if the given point
// is clipped out.

    eptl += dco.eptlOrigin();

    RGNOBJ  roRao(dco.prgnEffRao());

    if (roRao.bInside(&eptl) != REGION_POINT_INSIDE)
        return(FALSE);

    PBYTE pjBits;
    LONG xLeft, xRight, lDelta;
    ULONG iFormat;
    DEVBITMAPINFO dbmi;
    ERECTL  erclRao;
    SURFMEM dimo;

// Synchronize with the device driver before touching the device surface.

    {
        PDEVOBJ po(pSurf->hdev());
        po.vSync(pSurf->pSurfobj(),NULL,0);
    }

// Exclude the pointer before calling CopyBits so that pointer won't be
// copied.

    roRao.vGet_rcl((PRECTL)&erclRao);
    DEVEXCLUDEOBJ dxo(dco, &erclRao);
    

    // If the surface is not a bitmap, we will create a temporary
    // DIB, the size of the RaoRegion bounding box, to create the 
    // that's used to create the final painting region. When this is 
    // done we need to offset the RaoRegion, eptl and erclRao to 
    // correspond to the new coodinate system. We set the flag below to indicate 
    // we need to offset the resulting region back when drawing to 
    // the actual destination surface. This was done to fix bug #139701

    BOOL    bOffsetNeeded = FALSE; 
    POINTL  ptlOffset; 

    if ((pSurf->iType() != STYPE_BITMAP) || (roRao.iComplexity() == COMPLEXREGION))
    {
    // Allocate up an RGB palette and a DIB of the size of the RaoRegion.

    // Figure out what format the engine should use by looking at the
    // size of palette.  This is a clone from CreateCompatibleBitmap().

        dbmi.iFormat = iFormat = pSurf->iFormat();
        dbmi.cxBitmap = erclRao.right - erclRao.left;
        dbmi.cyBitmap = erclRao.bottom - erclRao.top;
        dbmi.hpal = 0;
        dbmi.fl = BMF_TOPDOWN;

        if (pSurf->bUMPD())
            dbmi.fl |= UMPD_SURFACE;

        dimo.bCreateDIB(&dbmi, (PVOID)NULL);

        if (!dimo.bValid())
        {
            SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
            return(FALSE);
        }

    // Copy the area as big as the size of the RaoRegion.

        BOOL bRes;

        ERECTL erclDIB; 
         
        erclDIB.left = 0; 
        erclDIB.top  = 0; 
        erclDIB.right= dbmi.cxBitmap;
        erclDIB.bottom = dbmi.cyBitmap;

        bRes = (*PPFNGET(pdo, CopyBits, pSurf->flags()))
                                (dimo.pSurfobj(),
                                 pSurf->pSurfobj(),
                                 (CLIPOBJ *) NULL,
                                 &xloIdent,
                                 (RECTL *) &erclDIB,
                                 (POINTL *) &erclRao);
        
    // Calculate the offset necessary to make all coordinated relative
    // to the DIB surface's coordinate system. 

        ptlOffset.x = -erclRao.left; 
        ptlOffset.y = -erclRao.top; 

        if ((bRes) && (roRao.iComplexity() == COMPLEXREGION))
        {
        // Color the boundary of the clip region so we don't flood over the
        // area outside.

            bRes = FALSE;
            RGNMEMOBJTMP rmoRaoBounds;
            RGNMEMOBJTMP rmoDiff;

            if (rmoRaoBounds.bValid() && rmoDiff.bValid())
            {
                rmoRaoBounds.vSet((RECTL *)&erclRao);
                if (rmoDiff.bMerge(rmoRaoBounds, roRao, gafjRgnOp[RGN_DIFF]))
                {
                // Make the resulting region's and the raoRectangle 
                // relative to the ccorinate system of the DIB

                    if(!rmoDiff.bOffset(&ptlOffset))
                        return(FALSE);                    

                    erclRao += ptlOffset; 

                // Fill the area outside the rao region but inside the
                // rao bounding box with the border color if in border mode.
                // Fill with a different than the surface color (1 if surface color
                // is an even index and 0 otherwise) if in surface mode.

                    ECLIPOBJ co(rmoDiff.prgnGet(), erclRao);
                    BBRUSHOBJ bo;

                    bo.flColorType = flColorType;
                    bo.pvRbrush    = (PVOID)NULL;

                    if (iFillType == FLOODFILLBORDER)
                    {
                        bo.iSolidColor = iSolidColor;

                        if (gbMultiMonMismatchColor)
                        {
                            bo.crRealized(crColor);
                            bo.crDCPalColor(crColor);
                        }
                    }
                    else // if (iFillType == FLOODFILLSURFACE)
                    {
                        bo.iSolidColor = ~iSolidColor & 1;

                        if (gbMultiMonMismatchColor)
                        {
                            // Get corresponding RGB value for iSolidColor.
                            //
                            // NOTE: Color will be quantaized by primary

                            ULONG ulRGB = ulIndexToRGB(palSurf,palDC,bo.iSolidColor);
                            bo.crRealized(ulRGB);
                            bo.crDCPalColor(ulRGB);
                        }
                    }

                    bRes = EngPaint(
                            dimo.pSurfobj(),                 // Destination surface
                            (CLIPOBJ *) &co,                 // Clip object
                            &bo,                             // Realized brush
                            (POINTL *) NULL,                 // Brush origin
                            ((R2_COPYPEN << 8) | R2_COPYPEN) // ROP
                            );
                }
            }
        }
        else
        {
        // Offset just the rectangle since the raoRegion is not
        // needed in this case

            erclRao += ptlOffset; 
        }

        if (!bRes)
        {
            return(FALSE);
        }

    // Make the flood point relative to the DIB's coordinates

        eptl.x += ptlOffset.x; 
        eptl.y += ptlOffset.y; 

    // Setup for the inversion of this offset when drawing to
    // the actual destination surface. 

        bOffsetNeeded = TRUE; 

        ptlOffset.x = -ptlOffset.x; 
        ptlOffset.y = -ptlOffset.y; 


        lDelta = dimo.ps->lDelta();
        pjBits = (PBYTE) dimo.ps->pvScan0();
    }
    else
    {
        pjBits  = (PBYTE) pSurf->pvScan0();
        lDelta  = pSurf->lDelta();
        iFormat = pSurf->iFormat();
    }

#if DEBUG_FLOOD
    DbgPrint("lDelta = %lx, pjBits = %lx, color = %lx\n",
              lDelta, pjBits, iSolidColor);
#endif

// Check if (x,y) is boundary color.  Return FALSE if the given point
// has the wrong color.

    PBYTE pjBitsY = pjBits + (lDelta * eptl.y);

    FLOODBM fd(iFormat, erclRao, iSolidColor, iFillType, pjBitsY, pSurf->ppal());

    ULONG iColorGivenPt = fd.iColorGet(eptl.x);

    if (((iFillType == FLOODFILLBORDER) && (iColorGivenPt == iSolidColor)) ||
        ((iFillType == FLOODFILLSURFACE) && (iColorGivenPt != iSolidColor)))
    {
        return(FALSE);
    }

// Find the extent of the span in the starting scanline.

    fd.vFindExtent(eptl.x, xLeft, xRight);

// Initialize the Up/Down stacks with the initial extents.

    STACKMEMOBJ stoUp(UPSTACK_SIZE, ALLOC_MERGE_SCANLINE, eptl.y, xLeft, xRight);
    if (!stoUp.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    STACKMEMOBJ stoDown(DOWNSTACK_SIZE, DONT_ALLOC_MERGE_SCANLINE, eptl.y,
                       xLeft, xRight);
    if (!stoDown.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    RGNMEMOBJTMP ro((ULONGSIZE_T)FLOOD_REGION_SIZE);
    if (!ro.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    BOOL bReturn = TRUE;
    LONG yBottom = erclRao.bottom-1;   // make bottom inclusive
    LONG yTop = erclRao.top;

    if (eptl.y < yBottom)
        bReturn &= fd.bExtendScanline(stoDown, stoUp, eptl.y+1, pjBitsY,
                                      pjBitsY+lDelta);
    else
        stoDown.vPop();

    if(bReturn) 
    {
        while (stoDown.bNotEmpty() || stoUp.bNotEmpty())
        {
            LONG y;
    
            if (stoDown.bNotEmpty())
            {
                if (!ro.bMergeScanline(stoDown))
                {
                    bReturn = FALSE;
                    break;
                }
    
            // Extend the scanline below
    
                if ((y = stoDown.yTop()) < yBottom)
                {
                    pjBitsY = pjBits + (lDelta * y);
                    if (!fd.bExtendScanline(stoDown, stoUp, y+1,
                                                  pjBitsY, pjBitsY+lDelta))
                    {
                        bReturn = FALSE;
                        break;
                    }
                }
                else
                    stoDown.vPop();     // hit border, pop the stack
            }
            else
            {
                bReturn &= ro.bMergeScanline(stoUp);
    
            // Extend the scanline above
    
                if ((y = stoUp.yTop()) > yTop)
                {
                    pjBitsY = pjBits + (lDelta * y);
                    if (!fd.bExtendScanline(stoUp, stoDown, y-1,
                                            pjBitsY, pjBitsY-lDelta))
                    {
                        bReturn = FALSE;
                        break;
                    }
                }
                else
                    stoUp.vPop();       // hit border, pop the stack
            }
        }
    }

    if ((bReturn) && (ro.iComplexity() != NULLREGION))
    {
    // Invert the offseting if necessary 

        if(bOffsetNeeded) 
        {
            if(!ro.bOffset(&ptlOffset))
                return FALSE; 
            erclRao += ptlOffset; 
        }

    // Accumulate bounds in device space.

        if (dco.fjAccum())
        {
            RECTL rcl;

            ro.vGet_rcl(&rcl);
            dco.vAccumulate(*((ERECTL *)&rcl));
        }

        MIX mix = peboFill->mixBest(dco.pdc->jROP2(), dco.pdc->jBkMode());

    // Inc the target surface uniqueness

        INC_SURF_UNIQ(pSurf);
        ECLIPOBJ co(ro.prgnGet(), erclRao);

    // Call Paint to draw to the destination surface.

        bReturn = EngPaint(
                        pSurf->pSurfobj(),
                        &co,
                        peboFill,
                        &dco.pdc->ptlFillOrigin(),
                        mix);
    }

    if (!bReturn)
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);

    return(bReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\fontddi.cxx ===
/******************************Module*Header*******************************\
* Module Name: fontddi.cxx
*
* Text and font DDI callback routines.
*
*  Tue 06-Jun-1995 -by- Andre Vachon [andreva]
* update: removed a whole bunch of dead stubs.
*
*  Fri 25-Jan-1991 -by- Bodin Dresevic [BodinD]
* update: filled out all stubs
*
* Copyright (c) 1991-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

/******************************Public*Routine******************************\
* ULONG FONTOBJ_cGetAllGlyphHandles (pfo,phgly)                            *
*                                                                          *
* phgly      Buffer for glyph handles.                                     *
*                                                                          *
* Used by the driver to download the whole font from the graphics engine.  *
*                                                                          *
* Warning:  The device driver must ensure that the buffer is big enough    *
*           to receive all glyph handles for a particular realized font.   *
*                                                                          *
* History:                                                                 *
*  25-Jan-1991 -by- Bodin Dresevic [BodinD]                                *
* Wrote it.                                                                *
\**************************************************************************/

ULONG
FONTOBJ_cGetAllGlyphHandles(
    FONTOBJ *pfo,
    PHGLYPH  phg)
{
    RFONTTMPOBJ rfto(PFO_TO_PRF(pfo));
    ASSERTGDI(rfto.bValid(), "gdisrv!FONTOBJ_cGetAllGlyphHandles(): bad pfo\n");

    return(rfto.chglyGetAllHandles(phg));
}

/******************************Public*Routine******************************\
* VOID FONTOBJ_vGetInfo (pfo,cjSize,pfoi)                                  *
*                                                                          *
* cjSize   Don't write more than this many bytes to the buffer.            *
* pfoi     Buffer with FO_INFO structure provided by the driver.           *
*                                                                          *
* Returns the info about the font to the driver's buffer.                  *
*                                                                          *
* History:                                                                 *
*  25-Jan-1991 -by- Bodin Dresevic [BodinD]                                *
* Wrote it.                                                                *
\**************************************************************************/

VOID
FONTOBJ_vGetInfo(
    FONTOBJ *pfo,
    ULONG cjSize,
    PFONTINFO pfi)
{
    RFONTTMPOBJ rfto(PFO_TO_PRF(pfo));
    ASSERTGDI(rfto.bValid(), "gdisrv!FONTOBJ_vGetInfo(): bad pfo\n");

    FONTINFO    fi;     // RFONTOBJ will write into this buffer

    rfto.vGetInfo(&fi);

    RtlCopyMemory((PVOID) pfi, (PVOID) &fi, (UINT) cjSize);
}

/******************************Public*Routine******************************\
* PXFORMOBJ FONTOBJ_pxoGetXform (pfo)                                      *
*                                                                          *
* History:                                                                 *
*  25-Mar-1991 -by- Bodin Dresevic [BodinD]                                *
* Wrote it.                                                                *
\**************************************************************************/

XFORMOBJ
*FONTOBJ_pxoGetXform(
    FONTOBJ *pfo)
{
    return ((XFORMOBJ *) (PVOID) &(PFO_TO_PRF(pfo))->xoForDDI);
}

/******************************Public*Routine******************************\
* FONTOBJ_pifi                                                             *
*                                                                          *
* Returns pointer to associated font metrics.                              *
*                                                                          *
* History:                                                                 *
*  Wed 04-Mar-1992 10:49:53 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

IFIMETRICS* FONTOBJ_pifi(FONTOBJ *pfo)
{
    RFONTTMPOBJ rfto(PFO_TO_PRF(pfo));
    ASSERTGDI(rfto.bValid(), "gdisrv!FONTOBJ_pifi(): bad pfo\n");

    PFEOBJ pfeo(rfto.ppfe());
    return(pfeo.bValid() ? pfeo.pifi() : (IFIMETRICS*) NULL);
}

/******************************Public*Routine******************************\
*
* APIENTRY FONTOBJ_pfdg
*
* returns pointer to pfdg
*
* History:
*  09-Jun-1997 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

FD_GLYPHSET * APIENTRY FONTOBJ_pfdg(FONTOBJ *pfo)
{
    return (PFO_TO_PRF(pfo)->pfdg);
}



/******************************Public*Routine******************************\
* FONTOBJ_cGetGlyphs
*
*
* History:
*  05-Jan-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

ULONG FONTOBJ_cGetGlyphs (
    FONTOBJ *pfo,
    ULONG   iMode,
    ULONG   cGlyph,     // requested # of hglyphs to be converted to ptrs
    PHGLYPH phg,        // array of hglyphs to be converted
    PVOID   *ppvGlyph    // driver's buffer receiving the pointers
    )
{
    DONTUSE(cGlyph);

    GLYPHPOS gp;
    gp.hg = *phg;

    RFONTTMPOBJ rfto(PFO_TO_PRF(pfo));
    ASSERTGDI(rfto.bValid(), "gdisrv!FONTOBJ_cGetGlyphs(): bad pfo\n");

    if ( !rfto.bInsertGlyphbitsLookaside(&gp, iMode))
        return 0;

    *ppvGlyph = (VOID *)(gp.pgdf);
    return 1;
}

/******************************Public*Routine******************************\
* FONTOBJ_pGetGammaTables
*
* History:
*  Thu 09-Feb-1995 06:54:54 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

GAMMA_TABLES*
FONTOBJ_pGetGammaTables(
    FONTOBJ *pfo)
{
    RFONTTMPOBJ rfo(PFO_TO_PRF(pfo));
    ASSERTGDI(rfo.bValid(), "FONTOBJ_pGetGammaTables bad pfo\n");
    return(&(rfo.gTables));
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   FONTOBJ_pvTrueTypeFontFile
*
* Routine Description:
*
*   This routine returns a kernel mode pointer to the start of a
*   font file. Despite the name of the routine, the font need not be
*   in the TrueType format.
*
*   GDI passes this call onto the font driver to do the detailed work.
*   The reason for this is that the file image can have the font file
*   image embedded in it in a non trivial way. An example of this would
*   be the *.ttc format for Far East Fonts. It is not reasonable to
*   expect this routine to be able to parse all file formats so that
*   resposibility is left to the font drivers.
*
* Arguments:
*
*   pfo - a 32-bit pointer to a FONTOBJ structure associated with a font
*       file.
*
*   pcjFile - the address of a 32-bit unsigend number that receives the
*       size of the view of the font file.
*
* Called by:
*
*   Printer Drivers in the context of a call to DrvTextOut
*
* Return Value:
*
*   If successful, this routine will return a kernel mode view of
*   a TrueType font file. If unsuccessful this routine returns NULL.
*
\**************************************************************************/

PVOID FONTOBJ_pvTrueTypeFontFile(
    FONTOBJ *pfo,
     ULONG  *pcjFile
    )
{
    void *pvRet = 0;
    *pcjFile = 0;

    RFONTTMPOBJ rfo(PFO_TO_PRF(pfo));
    if ( rfo.bValid() )
    {
        pvRet = rfo.pvFile( pcjFile );
    }
    return( pvRet );
}


PVOID
FONTOBJ_pvTrueTypeFontFileUMPD(
    FONTOBJ *pfo,
    ULONG   *pcjFile,
    PVOID   *ppBase
    )

{
    *ppBase = NULL;
    *pcjFile = 0;

    RFONTTMPOBJ rfo(PFO_TO_PRF(pfo));

    return rfo.bValid() ? rfo.pvFileUMPD(pcjFile, ppBase) : NULL;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   FONTOBJ_pjOpenTypeTablePointer
*
* Routine Description:
*
* Arguments:
*
* Called by:
*
* Return Value:
*
*   A pointer to a view of the table.
*
\**************************************************************************/

PBYTE FONTOBJ_pjOpenTypeTablePointer (
    FONTOBJ *pfo,
      ULONG  ulTag,
      ULONG *pcjTable
    )
{
    PBYTE pjTable = 0;

    RFONTTMPOBJ rfo(PFO_TO_PRF(pfo));
    if ( rfo.bValid() )
    {
        pjTable = rfo.pjTable( ulTag, pcjTable );
    }
    return( pjTable );
}

LPWSTR FONTOBJ_pwszFontFilePaths (FONTOBJ *pfo, ULONG *pcwc)
{
    LPWSTR pwsz =  NULL;
    *pcwc = 0;
    RFONTTMPOBJ rfo(PFO_TO_PRF(pfo));
    if ( rfo.bValid() )
    {
    // return 0 for memory fonts and temporary fonts added to dc's for printing

        if (!(rfo.prfnt->ppfe->pPFF->flState & (PFF_STATE_MEMORY_FONT | PFF_STATE_DCREMOTE_FONT)))
        {
            pwsz = rfo.prfnt->ppfe->pPFF->pwszPathname_;
            *pcwc = rfo.prfnt->ppfe->pPFF->cwc;
        }
    }
    return pwsz;
}

/******************************Public*Routine******************************\
* FONTOBJ_bQueryGlyphAttrs
*
* History:
*  Thu 21-May-1998 by Yung-Jen Tony Tsai [YungT]
* Wrote it.
\**************************************************************************/

PFD_GLYPHATTR  APIENTRY FONTOBJ_pQueryGlyphAttrs(
    FONTOBJ *pfo,
    ULONG   iMode
)
{

    RFONTTMPOBJ rfo(PFO_TO_PRF(pfo));
    if ( rfo.bValid() )
    {
        PDEVOBJ pdo( rfo.hdevProducer() );

        if (pdo.bValid() && PPFNVALID(pdo, QueryGlyphAttrs) )
        {

            return pdo.QueryGlyphAttrs(pfo, iMode);
        }
    }

    return( NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\fntxform.cxx ===
/******************************Module*Header*******************************\
* Module Name: fntxform.cxx
*
* Created: 02-Feb-1993 16:33:14
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1991-1999 Microsoft Corporation
\**************************************************************************/


#ifdef COMMENT_BLOCK

Author of these notes: BodinD

Differences between vector fonts and tt fonts in win31 + notes about what
nt does in these cases

1) Italicization

        for vector fonts it is done is device space (wrong)
        after notional to device transform has been applied

        for tt fonts it is done right, font is first italicized in notional
        space and then notional to device transform is applied.

        on NT I italicized both vector and tt fonts in notional space.

2) emboldening

        On NT I was able to fix vector fonts so as to shift
        the glyph in the direction of baseline (which may be different
        from x axis if esc != 0) thus preserving
        rotational invariance of emboldened vector fonts. (check it out, it is cool)

        for NT 5.0 we will have this also working for TT.

3) scaling properties under anisotropic page to device transform

        tt fonts scale ISOtropically which clearly is wrong for
        ANISOtropic page to device transform. The isotropic scaling factor
        for tt fonts is the ABSOLUTE VALUE value of the yy component
        of the page to device transform. From here it follows that
        tt fonts igore the request  to flip x and/or y axis
        and the text is always written left to right up side up.

        unlike tt fonts, vector fonts do scale ANISOtropically given
        the anisotropic page to device xform. The request to flip
        y axis  is ignored (like for tt fonts). If the tranform
        requests the flip of text in x axis, the text comes out GARBLED.
        (DavidW, please, give it a try)

        on NT I emulated this behavior in COMPATIBLE mode, execpt for the
        GARBLED "mode" for vector fonts. In ADVANCED mode I made both vt and tt
        fonts respect xform and behave in the same fashion wrt xforms.

4) interpretation of escapement and orientation

        in tt case escapement is intepreted as DEVICE space concept
        What this means is that after notional to world  and world to
        device scaling factors are applied the font is rotated in device space.
        (conceptually wrong but agrees with win31 spec).

        in vector font case escapement is intepreted as WORLD space concept
        font is first rotated in world space and then world (page) to device
        transform is applied.
        (conceptually correct but it disagrees with with win31 spec)

        on NT I went through excruiciating pain to emulate this behavior
        under COMPATIBLE  mode. In ADVANCED mode, vector and tt fonts
        behave the same and esc and orientation are interpreted as WORLD
        space concepts.


5) behavior in case of (esc != orientation)

        tt fonts set orientation = esc

        vector fonts snap orientation to the nearest multiple of
        90 degrees relative to orientation.
        (e.g. esc=300, or = -500 => esc = 300, or = - 600)
        (DavidW, please, give it a try, also please use anisotropic
        xform with window extents (-1,1))


        on NT we emulate this behavior for in COMPATIBLE mode,
        except for snapp orientation "fetature". The motivation is that
        apps will explicitely set orientation and escapement to differ
        by +/- 900, if they want it, rather than make use
        of "snapping feature". In advanced mode if esc!=orientation
        we use egg-shell algorithm to render text.




#endif COMMENT_BLOCK



#include "precomp.hxx"
#include "flhack.hxx"
// We include winuserp.h for the app compatibility #define GACF2_MSSHELLDLG
#include "winuserp.h"

//
// external procedures from draweng.cxx
//

extern BOOL gbShellFontCompatible;

EFLOAT efCos(EFLOAT x);
EFLOAT efSin(EFLOAT x);

/******************************Public*Routine******************************\
* lGetDefaultWorldHeight                                                   *
*                                                                          *
* "If lfHeight is zero, a reasonable default size is substituted."         *
* [SDK Vol 2]. Fortunately, the device driver is kind enough to            *
* suggest a nice height (in pixels). We shall return this suggestion       *
* in World corrdinates.                                                    *
*                                                                          *
* History:                                                                 *
*  Thu 23-Jul-1992 13:01:49 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

LONG
lGetDefaultWorldHeight(
    DCOBJ *pdco
    )
{
    LONG lfHeight;
    {
        PDEVOBJ pdo(pdco->hdev());
        if (!pdo.bValid())
        {
            RIP("gdisrv!MAPPER:MAPPER -- invalid DCOBJ\n");
            return(FM_EMERGENCY_DEFAULT_HEIGHT);
        }

        LFONTOBJ lfo(pdo.hlfntDefault());
        if (!lfo.bValid())
        {
            RIP("gdisrv!MAPPER::MAPPER -- invalid LFONTOBJ\n");
            return(FM_EMERGENCY_DEFAULT_HEIGHT);
        }

        lfHeight = lfo.plfw()->lfHeight;
    }

//
// Now I must transform this default height in pixels to a height
// in World coordinates. Then this default height must be written
// into the LFONTOBJ supplied by the DC.
//
    if (!pdco->pdc->bWorldToDeviceIdentity())
    {
    //
    // Calculate the scaling factor along the y direction
    // The correct thing to do might be to take the
    // scaling factor along the ascender direction [kirko]
    //
        EFLOAT efT;
        efT.eqMul(pdco->pdc->efM21(),pdco->pdc->efM21());

        EFLOAT efU;
        efU.eqMul(pdco->pdc->efM22(),pdco->pdc->efM22());

        efU.eqAdd(efU,efT);
        efU.eqSqrt(efU);

// at this point efU scales from world to device

        efT.vSetToOne();
        efU.eqDiv(efT,efU);

// at this point efU scales from device to world

        lfHeight =  lCvt(efU,FIX_FROM_LONG(lfHeight));
    }

// insure against a trivial default height

    if (lfHeight == 0)
    {
        return(FM_EMERGENCY_DEFAULT_HEIGHT);
    }

    //
    // This value should be the character height and not the CELL height for
    // Win 3.1 compatability.  Fine Windows apps like CA Super Project will
    // have clipped text if this isn't the case. [gerritv]
    //

    lfHeight *= -1;


    return(lfHeight);
}



/******************************Public*Routine******************************\
* vGetNtoW
*
* Calculates the notional to world transformation for fonts. This
* includes that funny factor of -1 for the different mapping modes
*
* Called by:
*   bGetNtoW                                            [FONTMAP.CXX]
*
* History:
*  Wed 15-Apr-1992 15:35:10 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

LONG lNormAngle(LONG lAngle);

VOID vGetNtoW
(
    MATRIX      *pmx,   // destination for transform
    LOGFONTW    *pelfw, // wish list
    IFIOBJ&     ifio,   // font to be used
    DCOBJ       *pdco
)
{
    LONG lAngle,lfHeight;
    EFLOAT efHeightScale,efWidthScale;

    lfHeight = pelfw->lfHeight;

    if (lfHeight == 0)
    {
        lfHeight = lGetDefaultWorldHeight(pdco);
    }
    ASSERTGDI(lfHeight,"gdisrv!vGetNtoW -- zero lfHeight\n");

// compute the height scale:

    {
        EFLOAT efHeightNum,efHeightDen;

        if (lfHeight > 0)
        {
            efHeightNum = lfHeight;
            efHeightDen = ifio.lfHeight();
        }
        else if (lfHeight < 0)
        {
            efHeightNum = -lfHeight;
            efHeightDen = (LONG) ifio.fwdUnitsPerEm();
        }
        efHeightScale.eqDiv(efHeightNum,efHeightDen);
    }

// compute the width scale:

    POINTL ptlRes;

    if (pelfw->lfWidth != 0)
    {
        EFLOAT efWidthNum,efWidthDen;

        ptlRes.x = ptlRes.y = 1;

        if (ifio.lfWidth() >= 0)
        {
            efWidthNum = (LONG) ABS(pelfw->lfWidth);
            efWidthDen = ifio.lfWidth();
            efWidthScale.eqDiv(efWidthNum,efWidthDen);
        }
        else
        {
            RIP("   gdisrv!vGetNtoW -- bad fwdAveCharWidth\n");
            efWidthScale = efHeightScale;
        }
    }
    else
    {
        ptlRes = *ifio.pptlAspect();
        efWidthScale = efHeightScale;
    }

// make sure that fonts look the same on printers of different resolutions:

    PDEVOBJ pdo(pdco->hdev());
    if (pdo.bValid())
    {
        if (pdo.ulLogPixelsX() != pdo.ulLogPixelsY())
        {
            ptlRes.y *= (LONG)pdo.ulLogPixelsX();
            ptlRes.x *= (LONG)pdo.ulLogPixelsY();
        }
    }
    else
    {
        RIP("gdisrv!bGetNtoW, pdevobj problem\n");
    }

    pmx->efM11.vSetToZero();
    pmx->efM12.vSetToZero();
    pmx->efM21.vSetToZero();
    pmx->efM22.vSetToZero();

// Get the orientation from the LOGFONT.  Win 3.1 treats the orientation
// as a rotation towards the negative y-axis.  We do the same, which
// requires adjustment for some map modes.

    lAngle = pelfw->lfOrientation;
    if (pdco->pdc->bYisUp())
        lAngle = 3600-lAngle;
    lAngle = lNormAngle(lAngle);

    switch (lAngle)
    {
    case 0 * ORIENTATION_90_DEG:

        pmx->efM11 = efWidthScale;
        pmx->efM22 = efHeightScale;

        if (!pdco->pdc->bYisUp())
        {
            pmx->efM22.vNegate();
        }
        break;

    case 1 * ORIENTATION_90_DEG:

        pmx->efM12 = efWidthScale;
        pmx->efM21 = efHeightScale;

        if (!pdco->pdc->bYisUp())
        {
            pmx->efM12.vNegate();
        }
        pmx->efM21.vNegate();
        break;

    case 2 * ORIENTATION_90_DEG:

        pmx->efM11 = efWidthScale;
        pmx->efM22 = efHeightScale;

        pmx->efM11.vNegate();
        if (pdco->pdc->bYisUp())
        {
            pmx->efM22.vNegate();
        }
        break;

    case 3 * ORIENTATION_90_DEG:

        pmx->efM12 = efWidthScale;
        pmx->efM21 = efHeightScale;

        if (pdco->pdc->bYisUp())
        {
            pmx->efM12.vNegate();
        }

        break;

    default:

        {
            EFLOATEXT efAngle = lAngle;
            efAngle /= (LONG) 10;

            EFLOAT efCosine = efCos(efAngle);
            EFLOAT efSine   = efSin(efAngle);

            pmx->efM11.eqMul(efWidthScale, efCosine);
            pmx->efM22.eqMul(efHeightScale,efCosine);

            pmx->efM12.eqMul(efWidthScale, efSine);
            pmx->efM21.eqMul(efHeightScale,efSine);
        }
        pmx->efM21.vNegate();
        if (!pdco->pdc->bYisUp())
        {
            pmx->efM12.vNegate();
            pmx->efM22.vNegate();
        }
        break;
    }

// adjust for non-square resolution:

    if (pdo.ulLogPixelsX() != pdo.ulLogPixelsY())
    {
        EFLOATEXT efTmp = (LONG)pdo.ulLogPixelsX();
        efTmp /= (LONG)pdo.ulLogPixelsY();

        if (pelfw->lfWidth == 0)
        {
            pmx->efM11 *= efTmp;
            pmx->efM21 *= efTmp;
        }
        else
        {
            pmx->efM12 /= efTmp;
            pmx->efM21 *= efTmp;
        }
    }

    EXFORMOBJ xoNW(pmx, DONT_COMPUTE_FLAGS);
    xoNW.vRemoveTranslation();
    xoNW.vComputeAccelFlags();
}

//
// galFloat -- an array of LONG's that represent the IEEE floating
//             point equivalents of the integers corresponding
//             to the indices
//

LONG
galFloat[] = {
    0x00000000, // = 0.0
    0x3f800000, // = 1.0
    0x40000000, // = 2.0
    0x40400000, // = 3.0
    0x40800000, // = 4.0
    0x40a00000, // = 5.0
    0x40c00000, // = 6.0
    0x40e00000, // = 7.0
    0x41000000  // = 8.0
};


LONG
galFloatNeg[] = {
    0x00000000, // =  0.0
    0xBf800000, // = -1.0
    0xC0000000, // = -2.0
    0xC0400000, // = -3.0
    0xC0800000, // = -4.0
    0xC0a00000, // = -5.0
    0xC0c00000, // = -6.0
    0xC0e00000, // = -7.0
    0xC1000000  // = -8.0
};


/******************************Public*Routine******************************\
* bGetNtoD
*
* Get the notional to device transform for the font drivers
*
* Called by:
*   PFEOBJ::bSetFontXform                               [PFEOBJ.CXX]
*
* History:
*  Tue 12-Jan-1993 11:58:41 by Kirk Olynyk [kirko]
* Added a quick code path for non-transformable (bitmap) fonts.
*  Wed 15-Apr-1992 15:09:22 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

BOOL
bGetNtoD(
    FD_XFORM    *pfdx,  // pointer to the buffer to recieve the
                        // notional to device transformation for the
                        // font driver.  There are a couple of
                        // important things to remember.  First,
                        // according to the conventions of the ISO
                        // committee, the coordinate space for notional
                        // (font designer) spaces are cartesian.
                        // However, due to a series of errors on my part
                        // [kirko] the convention that is used by the
                        // DDI is that the notional to device transformation
                        // passed over the DDI assumes that both the notional
                        // and the device space are anti-Cartesian, that is,
                        // positive y increases in the downward direction.
                        // The fontdriver assumes that
                        // one unit in device space corresponds to the
                        // distance between pixels. This is different from
                        // GDI's internal view, where one device unit
                        // corresponds to a sub-pixel unit.


    LOGFONTW *pelfw,    // points to the extended logical font defining
                        // the font that is requested by the application.
                        // Units are ususally in World coordinates.

    IFIOBJ&     ifio,   // font to be used

    DCOBJ       *pdco,  // the device context defines the transforms between
                        // the various coordinate spaces.

    POINTL* const pptlSim
    )
{
    MATRIX mxNW, mxND;

    if(( pptlSim->x ) && !ifio.bContinuousScaling())

    {
    //
    // This code path is for bitmap / non-scalable fonts. The notional
    // to device transformation is determined by simply looking up
    // the scaling factors for both the x-direction and y-direcion
    //

       #if DBG
        if (!(0 < pptlSim->x && pptlSim->x <= sizeof(galFloat)/sizeof(LONG)))
        {
            DbgPrint("\t*pptlSim = (%d,%d)\n",pptlSim->x,pptlSim->y);
            RIP("gre -- bad *pptlSim\n");

        //
        // bogus fix up for debugging purposes only
        //
            pptlSim->x = 1;
            pptlSim->y = 1;
        }
      #endif

        ULONG uAngle = 0;
        
        if( ifio.b90DegreeRotations() )
        {
            
            // If the WorldToDeive transform is not identity,
        // We have to consider WToD Xform for font orientation
        // This is only for Advanced Mode

            if(!(pdco->pdc->bWorldToDeviceIdentity()) )
            {
                INT s11,s12,s21,s22;
                EXFORMOBJ xo(*pdco,WORLD_TO_DEVICE);

            // Get Matrix element
            // lSignum() returns -1, if the element is minus value, otherwise 1

                s11 = (INT) xo.efM11().lSignum();
                s12 = (INT) xo.efM12().lSignum();
                s21 = (INT) xo.efM21().lSignum();
                s22 = (INT) xo.efM22().lSignum();

            // Check mapping mode

                if (pdco->pdc->bYisUp())
                {
                    s21 = -s21;
                    s22 = -s22;
                    uAngle = 3600 - lNormAngle( pelfw->lfOrientation );
                }
                 else
                {
                    uAngle = lNormAngle( pelfw->lfOrientation );
                }

           // Compute font orientation on distination device
           //
           // This logic depend on that -1 is represented as All bits are ON.

                uAngle = (ULONG)( lNormAngle
                                  (
                                      uAngle
                                         + (s12 &  900)
                                         + (s11 & 1800)
                                         + (s21 & 2700)
                                  ) / ORIENTATION_90_DEG
                                );
            }
             else
            {
                uAngle = (ULONG)(lNormAngle(pelfw->lfOrientation) /
                                 ORIENTATION_90_DEG );
            }
        }

        switch( uAngle )
        {
        case 0: // 0 Degrees
            SET_FLOAT_WITH_LONG(pfdx->eXX,galFloat[pptlSim->x]);
            SET_FLOAT_WITH_LONG(pfdx->eXY,galFloat[0         ]);
            SET_FLOAT_WITH_LONG(pfdx->eYX,galFloat[0         ]);
            SET_FLOAT_WITH_LONG(pfdx->eYY,galFloatNeg[pptlSim->y]);
            break;
        case 1: // 90 Degrees
            SET_FLOAT_WITH_LONG(pfdx->eYX,galFloatNeg[pptlSim->x]);
            SET_FLOAT_WITH_LONG(pfdx->eXX,galFloat[0         ]);
            SET_FLOAT_WITH_LONG(pfdx->eYY,galFloat[0         ]);
            SET_FLOAT_WITH_LONG(pfdx->eXY,galFloatNeg[pptlSim->y]);
            break;
        case 2: // 180 Degrees
            SET_FLOAT_WITH_LONG(pfdx->eXX,galFloatNeg[pptlSim->x]);
            SET_FLOAT_WITH_LONG(pfdx->eXY,galFloat[0         ]);
            SET_FLOAT_WITH_LONG(pfdx->eYX,galFloat[0         ]);
            SET_FLOAT_WITH_LONG(pfdx->eYY,galFloat[pptlSim->y]);
            break;
        case 3:  // 270 Degress
            SET_FLOAT_WITH_LONG(pfdx->eXY,galFloat[pptlSim->y]);
            SET_FLOAT_WITH_LONG(pfdx->eXX,galFloat[0         ]);
            SET_FLOAT_WITH_LONG(pfdx->eYY,galFloat[0         ]);
            SET_FLOAT_WITH_LONG(pfdx->eYX,galFloat[pptlSim->x]);
            break;
        default:
            WARNING("bGetNtoD():Invalid Angle\n");
            break;
        }
        return(TRUE);
    }

    vGetNtoW(&mxNW, pelfw, ifio, pdco);

    EXFORMOBJ xoND(&mxND, DONT_COMPUTE_FLAGS);

    if ( pdco->pdc->bWorldToDeviceIdentity() == FALSE)
    {
        if (!xoND.bMultiply(&mxNW,&pdco->pdc->mxWorldToDevice()))
        {
            return(FALSE);
        }

    //
    // Compensate for the fact that for the font driver, one
    // device unit corresponds to the distance between pixels,
    // whereas for the engine, one device unit corresponds to
    // 1/16'th the way between pixels
    //
        mxND.efM11.vDivBy16();
        mxND.efM12.vDivBy16();
        mxND.efM21.vDivBy16();
        mxND.efM22.vDivBy16();
    }
    else
    {
        mxND = mxNW;
    }

    SET_FLOAT_WITH_LONG(pfdx->eXX,mxND.efM11.lEfToF());
    SET_FLOAT_WITH_LONG(pfdx->eXY,mxND.efM12.lEfToF());
    SET_FLOAT_WITH_LONG(pfdx->eYX,mxND.efM21.lEfToF());
    SET_FLOAT_WITH_LONG(pfdx->eYY,mxND.efM22.lEfToF());

    return(TRUE);
}

/******************************Public*Routine******************************\
*
* bGetNtoW_Win31
*
* Computes notional to world transform for the compatible
* mode Basically, computes notional to device transform in
* win31 style using page to device transform (ignoring
* possibly exhistent world to page transform.  then page to
* device is factored out leaving us with win31 style crippled
* notional to world transform.  As to the page to device
* transform, either the one in the dc is used, or if this
* routine has a metafile client, then page to device
* transform of the recording device is used.  Metafile code
* stored this transform in the dc.
*
* Called by:
*   bGetNtoD_Win31                                      [FONTMAP.CXX]
*
* History:
*  24-Nov-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BOOL
bGetNtoW_Win31(
    MATRIX      *pmxNW, // store the result here
    LOGFONTW    *pelfw, // points to the extended logical font defining
                        // the font that is requested by the application.
                        // Units are ususally in World coordinates.

    IFIOBJ&     ifio,   // font to be used

    DCOBJ       *pdco,  // the device context defines the transforms between
                        // the various coordinate spaces.

    FLONG       fl,     // The flags supported are:
                        //
                        //     ND_IGNORE_ESC_AND_ORIENT
                        //
                        //         The presence of this flag indicates that
                        //         the escapement and orientation values
                        //         of the LOGFONT should be ignored.  This
                        //         is used for GetGlyphOutline which ignores
                        //         these values on Win 3.1.  Corel Draw 5.0
                        //         relies on this behavior to print rotated
                        //         text.
                        //
    BOOL     bIsLinkedFont  // is passed in as TRUE if the font is linked, FALSE otherwise
    )
{

    ASSERTGDI(
        (fl & ~(ND_IGNORE_ESC_AND_ORIENT | ND_IGNORE_MAP_MODE)) == 0,
        "gdisrv!NtoW_Win31 -- bad value for fl\n"
        );

    LONG   lfHeight;


    EFLOAT efHeightScale,
           efHeightNum,
           efHeightDen,
           efWidthScale,
           efWidthDen,
           efDefaultScale;

    ASSERTGDI(ifio.lfWidth(), "gdisrv!bGetNtoW_Win31, AvgChW\n");

    BOOL bUseMeta = pdco->pdc->bUseMetaPtoD();

    BOOL bDoXform = (!(fl & ND_IGNORE_MAP_MODE) &&
                      (bUseMeta || !pdco->pdc->bPageToDeviceScaleIdentity()));

    BOOL bPD11Is1 = TRUE;  // efPD11 == 1
    BOOL bPD22IsNeg    = FALSE; // efPD22 is negative

    EFLOATEXT efPD11;

    if ((lfHeight = pelfw->lfHeight) == 0)
    {
        lfHeight = lGetDefaultWorldHeight(pdco);
    }

    ASSERTGDI(lfHeight,"gdisrv!vGetNtoW -- zero lfHeight\n");


    // dchinn 9/16/98:
    // A fix to the Visual FoxPro 5.0 hcw.exe bug.  The bug is that the
    // dialog boxes in hcw.exe are designed with 8pt MS Shell Dlg
    // (at 96dpi, that's 11ppem), but the text in the dialog appears
    // as 12ppem in NT 5.  A possible contributing reason for this bug
    // is that the default shell dialog font in NT 4 is MS Sans Serif, which
    // is a bitmap font with only sizes 8, 10, 12, 14, 18, 24.  The default
    // shell dialog font for NT 5 is Microsoft Sans Serif, which is an OpenType
    // (TrueType) font.  Perhaps FoxPro somehow hardcodes 12ppem somewhere.
    // The fix here is that if the logfont is for the MS Shell Dlg at 12ppem
    // then we actually use an lfHeight of 11ppem.
    //
    // We only adjust for negative lfHeight because when lfHeight is negative,
    // the logfont is requesting an em height (as opposed to ascender plus
    // descender if lfHeight is positive).
    //
    // Well, change of heart, Lotus notes is asking for lfHeight == +15,
    // expecting to get the same size font as ms sans serif at lfHeight = -11;
    // so we have to adjust for positive lfHeights as well [bodind]
    //
    // Finally, this table of conversions below handles the case when
    // small fonts is set on the system (not large fonts)
    // (actually, it handles the lowest size for large fonts
    // and two smallest sizes for small fonts [bodind])


    if (gbShellFontCompatible &&
        !_wcsicmp(pelfw->lfFaceName, L"MS Shell Dlg") &&
        !bIsLinkedFont)  // don't do font size collapsing if dealing with a linked font
    {
        if (lfHeight > 0)
        {
	// sizes 12 and 13 are mapped to 14 because in bitmap font there is
	// no size smaller than 14. But we do not want to map everything from
	// 1 to 15 to 14 for tt, we only want to bump up as few sizes as needed to
	// get the backwards compat with nt 40 in the shell.

	    if ((lfHeight >= 12) && (lfHeight <= 15))
            {
		lfHeight = 14;	// same as -11 for ms sans serif
            }
            else if ((lfHeight > 15) && (lfHeight <= 19))
            {
		lfHeight = 16;	// same as -13 for ms sans serif
            }
        }
        else // lfHeight < 0
        {
	// sizes -9 and -10 are mapped to -11 because in bitmap font there is
	// no size smaller than -11.  But we do not want to map everything from
	// -11 to -15 to 14 for tt, we only want to bump up as few sizes as needed to
	// get the backwards compat with nt 40 in the shell.

            if ((lfHeight >= -12) && (lfHeight <= -9))
            {
                lfHeight = -11;  // fixes older version of outlook and janna contact dialogs
            }
            else if ((lfHeight > -16) && (lfHeight <= -13))
            {
                lfHeight = -13;  // just in case
            }
        }

    #if 0
      if (gbShellFontCompatible && !_wcsicmp(pelfw->lfFaceName, L"MS Shell Dlg") && ((lfHeight == -12) || (lfHeight == -14)
          || (lfHeight == -15) || (lfHeight == -17) || (lfHeight == -18) || (lfHeight > -11)
          || ((lfHeight > -24) && (lfHeight < -19))
          || ((lfHeight > -32) && (lfHeight < -24)) || (lfHeight < -32)
          ))
      {
         DbgPrint("\tNTFONT: MS Shell Dlg used at size %d ppem\n, dialog may be clipped",-lfHeight);
      }
    #endif
    }

    if (lfHeight > 0)
    {
        efHeightNum = (LONG)lfHeight;
        efHeightDen = (LONG)ifio.lfHeight();
    }
    else // lfHeight < 0
    {
        efHeightNum = (LONG)(-lfHeight);
        efHeightDen = (LONG) ifio.fwdUnitsPerEm();
    }

    efDefaultScale.eqDiv(efHeightNum,efHeightDen);

    pmxNW->efM22  = efDefaultScale;
    efHeightScale = efDefaultScale;

    if (bDoXform)
    {
        EFLOATEXT efPD22;

    // first check if hock wants us to use his page to device scale factors

        if (bUseMeta)
        {
            efPD11 = pdco->pdc->efMetaPtoD11();
            efPD22 = pdco->pdc->efMetaPtoD22();
        }
        else if (!pdco->pdc->bPageToDeviceScaleIdentity())
        {
            if (!pdco->pdc->bWorldToPageIdentity())
            {
            // need to compute page to device scaling coefficients
            // that will be used in computing crippled win31 style
            // notional to world scaling coefficients
            // This is because PtoD is not stored on the server side
            // any more. This somewhat slow code path is infrequent
            // and not perf critical

                EFLOATEXT efTmp;

                efPD11 = pdco->pdc->lViewportExtCx();
                efTmp = pdco->pdc->lWindowExtCx();
                efPD11.eqDiv(efPD11,efTmp);

                efPD22 = pdco->pdc->lViewportExtCy();
                efTmp = pdco->pdc->lWindowExtCy();
                efPD22.eqDiv(efPD22,efTmp);
            }
            else // page to device == world to device:
            {
                efPD11 = pdco->pdc->efM11();
                efPD22 = pdco->pdc->efM22();

            // Compensate for the fact that for the font driver, one
            // device unit corresponds to the distance between pixels,
            // whereas for the engine, one device unit corresponds to
            // 1/16'th the way between pixels

                efPD11.vDivBy16();
                efPD22.vDivBy16();

                ASSERTGDI(pdco->pdc->efM12().bIsZero(), "GDISRV: nonzero m12 IN WIN31 MODE\n");
                ASSERTGDI(pdco->pdc->efM21().bIsZero(), "GDISRV: nonzero m21 IN WIN31 MODE\n");
            }

        }
         #if DBG
        else
            RIP("gdisrv!ntow_win31\n");
        #endif

        bPD11Is1 = efPD11.bIs1();
        bPD22IsNeg = efPD22.bIsNegative();

        if (!efPD22.bIs1())
            efHeightScale.eqMul(efHeightScale,efPD22);

    // In win31 possible y flip or x flip on the text are not respected
    // so that signs do not make it into the xform

        efHeightScale.vAbs();
    }

    if (bPD22IsNeg)
    {
    // change the sign if necessary so that
    // pmxNW->efM22 * efPtoD22 == efHeightScale, which is enforced to be > 0

        pmxNW->efM22.vNegate();
    }


    PDEVOBJ pdo(pdco->hdev());
    if (!pdo.bValid())
    {
        RIP("gdisrv!bGetNtoW_Win31, pdevobj problem\n");
        return FALSE;
    }

// In the case that lfWidth is zero or in the MSBADWIDTH case we will need
// to adjust efWidthScale if VerRes != HorRez

    BOOL bMustCheckResolution = TRUE;

    if (pelfw->lfWidth)
    {
    // This makes no sense, but has to be here for win31 compatibility.
    // Win31 is computing the number of
    // pixels in x direction of the avgchar width scaled along y.
    // I find this a little bizzare [bodind]

        EFLOAT efAveChPixelWidth;
        efAveChPixelWidth = (LONG) ifio.fwdAveCharWidth();

    // take the resolution into account,

        #if 0

        if ((pdo.ulLogPixelsX() != pdo.ulLogPixelsY()) && !bUseMeta)
        {
            EFLOAT efTmp;
            efTmp = (LONG)pdo.ulLogPixelsY();
            efAveChPixelWidth.eqMul(efAveChPixelWidth,efTmp);
            efTmp = (LONG)pdo.ulLogPixelsX();
            efAveChPixelWidth.eqDiv(efAveChPixelWidth,efTmp);
        }

        #endif

        efWidthDen = efAveChPixelWidth; // save the result for later

        efAveChPixelWidth.eqMul(efAveChPixelWidth,efHeightScale);

        LONG lAvChPixelW, lReqPixelWidth;

    // requested width in pixels:

        EFLOAT efReqPixelWidth;
        lReqPixelWidth  = (LONG)ABS(pelfw->lfWidth);
        efReqPixelWidth = lReqPixelWidth;

        BOOL bOk = TRUE;

        if (bDoXform)
        {
            if (!bPD11Is1)
            {
                efReqPixelWidth.eqMul(efReqPixelWidth,efPD11);
                bOk =  efReqPixelWidth.bEfToL(lReqPixelWidth);
            }
            efReqPixelWidth.vAbs();
            if (lReqPixelWidth < 0)
                lReqPixelWidth = -lReqPixelWidth;
        }

    // win 31 does not allow tt fonts of zero width. This makes sense,
    // as we know rasterizer chokes on these.
    // Win31 does not allow fonts that are very wide either.
    // The code below is exactly what win31 is doing. Win31 has a bogus
    // criterion for determining a cut off for width.
    // Below this cut off, because of the  bug in win31 code,
    // the text goes from right to left.
    // For even smaller lfWidth
    // we get the expected "good" behavior. NT eliminates the Win31 bug
    // where for range of lfWidhts width scaling factor is negative.

        if
        (
            (
             efAveChPixelWidth.bEfToL(lAvChPixelW) &&
             (lAvChPixelW > 0)                     && // not too narrow !
             bOk                                   &&
             ((lReqPixelWidth / 256) < lAvChPixelW)   // bogus win31 criterion
            )
            ||
            ifio.bStroke()  // vector fonts can be arbitrarily wide or narrow
        )
        {
            bMustCheckResolution = FALSE;
            efWidthScale.eqDiv(efReqPixelWidth,efWidthDen);
        }
        /*
        else
        {
        //  win31 in either of these cases branches into MSFBadWidth case
        //  which is equivalent to setting lfWidth == 0 [bodind]
        }
        */
    }

    if (bMustCheckResolution)
    {
    // must compute width scale because it has not been
    // computed in lfWidth != 0 case

        if (ifio.bStroke())
        {
        // win31 behaves differently for vector fonts:
        // unlike tt fonts, vector fonts stretch along x, respecting
        // page to device xform. However, they ignore the request to flip
        // either x or y axis

            efWidthScale = efDefaultScale;
            if (!bPD11Is1)
            {
                efWidthScale.eqMul(efWidthScale,efPD11);
                efWidthScale.vAbs();
            }
        }
        else
        {
        // tt fonts make x scaling the same as y scaling,

            efWidthScale = efHeightScale;
        }

        POINTL ptlRes = *ifio.pptlAspect();

    // If VertRez != HorRez and we are using the default width we need to
    // adjust for the differences in resolution.
    // This is done in order to ensure that fonts look the same on printers
    // of different resolutions [bodind]

        if ((pdo.ulLogPixelsX() != pdo.ulLogPixelsY()) && !bUseMeta)
        {
            ptlRes.y *= (LONG)pdo.ulLogPixelsX();
            ptlRes.x *= (LONG)pdo.ulLogPixelsY();
        }

        if (ptlRes.x != ptlRes.y)
        {
            EFLOAT efTmp;
            efTmp = ptlRes.y;
            efWidthScale *= efTmp ;
            efTmp = ptlRes.x;
            efWidthScale /= efTmp;
        }

    }

// now that we have width scale we can compute pmxNW->efM11. We factor out
// (PtoD)11 out of width scale to obtain the effective NW x scale:

    if (!bPD11Is1)
        pmxNW->efM11.eqDiv(efWidthScale,efPD11);
    else
        pmxNW->efM11 = efWidthScale;

    pmxNW->efDx.vSetToZero();
    pmxNW->efDy.vSetToZero();
    pmxNW->efM12.vSetToZero();
    pmxNW->efM21.vSetToZero();

    EXFORMOBJ xoNW(pmxNW, DONT_COMPUTE_FLAGS);

// see if orientation angle has to be taken into account:

    if (ifio.bStroke())
    {
    // allow esc != orientation for vector fonts because win31 does it
    // also note that for vector fonts Orientation is treated as world space
    // concept, so we multiply here before applying world to device transform
    // while for tt fonts esc is treated as device space concept so that
    // this multiplication is occuring after world to page transform is applied

        if (pelfw->lfOrientation)
        {
            EFLOATEXT efAngle = pelfw->lfOrientation;
            efAngle /= (LONG) 10;

            MATRIX mxRot, mxTmp;

            mxRot.efM11 = efCos(efAngle);
            mxRot.efM22 = mxRot.efM11;
            mxRot.efM12 = efSin(efAngle);
            mxRot.efM21 = mxRot.efM12;
            mxRot.efM21.vNegate();
            mxRot.efDx.vSetToZero();
            mxRot.efDy.vSetToZero();

            mxTmp = *pmxNW;

            if (!xoNW.bMultiply(&mxTmp,&mxRot))
                return FALSE;
        }

    }

// take into account different orientation of y axes of notional
// and world spaces:

    pmxNW->efM12.vNegate();
    pmxNW->efM22.vNegate();

    xoNW.vComputeAccelFlags();

    return(TRUE);
}


/******************************Public*Routine******************************\
*
* BOOL bParityViolatingXform(DCOBJ  *pdco)
*
* History:
*  04-Jun-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL bParityViolatingXform(DCOBJ  *pdco)
{

    if (pdco->pdc->bWorldToPageIdentity())
    {
        if (pdco->pdc->bPageToDeviceScaleIdentity())
        {
        // identity except maybe for translations

            return FALSE;
        }

        return (pdco->pdc->efM11().lSignum() != pdco->pdc->efM22().lSignum());
    }
    else
    {
    // we are in the metafile code

        return( pdco->pdc->efMetaPtoD11().lSignum() != pdco->pdc->efMetaPtoD22().lSignum() );
    }
}





/******************************Public*Routine******************************\
*
* bGetNtoD_Win31
*
* Called by:
*   PFEOBJ::bSetFontXform                               [PFEOBJ.CXX]
*
* History:
*  Tue 12-Jan-1993 11:58:41 by Kirk Olynyk [kirko]
* Added a quick code path for non-transformable (bitmap) fonts.
*  30-Sep-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
bGetNtoD_Win31(
    FD_XFORM    *pfdx,  // pointer to the buffer to recieve the
                        // notional to device transformation for the
                        // font driver.  There are a couple of
                        // important things to remember.  First,
                        // according to the conventions of the ISO
                        // committee, the coordinate space for notional
                        // (font designer) spaces are cartesian.
                        // However, due to a series of errors on my part
                        // [kirko] the convention that is used by the
                        // DDI is that the notional to device transformation
                        // passed over the DDI assumes that both the notional
                        // and the device space are anti-Cartesian, that is,
                        // positive y increases in the downward direction.
                        // The fontdriver assumes that
                        // one unit in device space corresponds to the
                        // distance between pixels. This is different from
                        // GDI's internal view, where one device unit
                        // corresponds to a sub-pixel unit.

    LOGFONTW *pelfw,    // points to the extended logical font defining
                        // the font that is requested by the application.
                        // Units are ususally in World coordinates.

    IFIOBJ&     ifio,   // font to be used

    DCOBJ       *pdco,  // the device context defines the transforms between
                        // the various coordinate spaces.

    FLONG       fl,     // The flags supported are:
                        //
                        //     ND_IGNORE_ESC_AND_ORIENT
                        //
                        //         The presence of this flag indicates that
                        //         the escapement and orientation values
                        //         of the LOGFONT should be ignored.  This
                        //         is used for GetGlyphOutline which ignores
                        //         these values on Win 3.1.  Corel Draw 5.0
                        //         relies on this behavior to print rotated
                        //         text.
                        //
    POINTL * const pptlSim,
    BOOL     bIsLinkedFont  // is passed in as TRUE if the font is linked, FALSE otherwise
    )
{
    MATRIX mxNW, mxND;
    ASSERTGDI(
        (fl & ~(ND_IGNORE_ESC_AND_ORIENT | ND_IGNORE_MAP_MODE))== 0,
        "gdisrv!bGetNtoD_Win31 -- bad value for fl\n"
        );

    if((pptlSim->x) && !ifio.bContinuousScaling())
    {
    //
    // This code path is for bitmap / non-scalable fonts. The notional
    // to device transformation is determined by simply looking up
    // the scaling factors for both the x-direction and y-direcion
    //

       #if DBG
        if (!(0 < pptlSim->x && pptlSim->x <= sizeof(galFloat)/sizeof(LONG)))
        {
            DbgPrint("\t*pptlSim = (%d,%d)\n",pptlSim->x,pptlSim->y);
            RIP("gre -- bad *pptlSim\n");
        }
      #endif


    // Win3.1J ignore orientation anytime. But use escapement for rotate Glyph data.

    // If the font driver that this font provide , has not arbitality flag.
    // Angle should be 0 , 900 , 1800 or 2700
    // for Win31J compatibility

        ULONG uAngle = 0;

        if (gbDBCSCodePage)
        {
            if( ifio.b90DegreeRotations() )
            {
                if (pdco->pdc->bYisUp())
                    uAngle = (ULONG)(((3600-lNormAngle(pelfw->lfEscapement)) /
                                      ORIENTATION_90_DEG) % 4);
                 else
                    uAngle = (ULONG)( lNormAngle(pelfw->lfEscapement) /
                                     ORIENTATION_90_DEG );
            }
        }

        switch( uAngle )
        {
        case 0: // 0 Degrees
            SET_FLOAT_WITH_LONG(pfdx->eXX,galFloat[pptlSim->x]);
            SET_FLOAT_WITH_LONG(pfdx->eXY,galFloat[0         ]);
            SET_FLOAT_WITH_LONG(pfdx->eYX,galFloat[0         ]);
            SET_FLOAT_WITH_LONG(pfdx->eYY,galFloatNeg[pptlSim->y]);
            break;
        case 1: // 90 Degrees
            SET_FLOAT_WITH_LONG(pfdx->eYX,galFloatNeg[pptlSim->x]);
            SET_FLOAT_WITH_LONG(pfdx->eXX,galFloat[0         ]);
            SET_FLOAT_WITH_LONG(pfdx->eYY,galFloat[0         ]);
            SET_FLOAT_WITH_LONG(pfdx->eXY,galFloatNeg[pptlSim->y]);
            break;
        case 2: // 180 Degrees
            SET_FLOAT_WITH_LONG(pfdx->eXX,galFloatNeg[pptlSim->x]);
            SET_FLOAT_WITH_LONG(pfdx->eXY,galFloat[0         ]);
            SET_FLOAT_WITH_LONG(pfdx->eYX,galFloat[0         ]);
            SET_FLOAT_WITH_LONG(pfdx->eYY,galFloat[pptlSim->y]);
            break;
        case 3:  // 270 Degress
            SET_FLOAT_WITH_LONG(pfdx->eXY,galFloat[pptlSim->y]);
            SET_FLOAT_WITH_LONG(pfdx->eXX,galFloat[0         ]);
            SET_FLOAT_WITH_LONG(pfdx->eYY,galFloat[0         ]);
            SET_FLOAT_WITH_LONG(pfdx->eYX,galFloat[pptlSim->x]);
            break;
        default:
            WARNING("bGetNtoD_Win31():Invalid Angle\n");
            break;
        }

        return(TRUE);
    }

    if (!bGetNtoW_Win31(&mxNW, pelfw, ifio, pdco, fl, bIsLinkedFont))
        return FALSE;

    EXFORMOBJ xoND(&mxND, DONT_COMPUTE_FLAGS);

    if( (pdco->pdc->bWorldToDeviceIdentity() == FALSE) &&
        !(fl & ND_IGNORE_MAP_MODE) )
    {
        if (!xoND.bMultiply(&mxNW,&pdco->pdc->mxWorldToDevice()))
        {
            return(FALSE);
        }

    //
    // Compensate for the fact that for the font driver, one
    // device unit corresponds to the distance between pixels,
    // whereas for the engine, one device unit corresponds to
    // 1/16'th the way between pixels
    //
        mxND.efM11.vDivBy16();
        mxND.efM12.vDivBy16();
        mxND.efM21.vDivBy16();
        mxND.efM22.vDivBy16();
    }
    else
    {
        mxND = mxNW;
    }

    if (!ifio.bStroke())
    {
    // for tt fonts escapement and orientation are treated as
    // device space concepts. That is why for these fonts we apply
    // rotation by lAngle last

        LONG lAngle;


        if( ifio.b90DegreeRotations() )
        {
            lAngle = (LONG)( ( lNormAngle(pelfw->lfEscapement)
                           / ORIENTATION_90_DEG ) % 4 ) * ORIENTATION_90_DEG;
        }
        else // ifio.bArbXform() is TRUE
        {
            lAngle = pelfw->lfEscapement;
        }

        if(lAngle != 0 && (!(fl & ND_IGNORE_ESC_AND_ORIENT) || gbDBCSCodePage))
        {
            // more of win31 compatability: the line below would make sense
            // if this was y -> -y type of xform. But they also do it
            // for x -> -x xform. [bodind]

            if (bParityViolatingXform(pdco))
            {
                lAngle = -lAngle;
            }

            EFLOATEXT efAngle = lAngle;
            efAngle /= (LONG) 10;

            MATRIX mxRot, mxTmp;

            mxRot.efM11 = efCos(efAngle);
            mxRot.efM22 = mxRot.efM11;
            mxRot.efM12 = efSin(efAngle);
            mxRot.efM21 = mxRot.efM12;
            mxRot.efM12.vNegate();
            mxRot.efDx.vSetToZero();
            mxRot.efDy.vSetToZero();

            mxTmp = mxND;

            if (!xoND.bMultiply(&mxTmp,&mxRot))
                return FALSE;

        }
        
    // adjust for nonsquare resolution

        PDEVOBJ pdo(pdco->hdev());
        if (pdo.ulLogPixelsX() != pdo.ulLogPixelsY())
        {
            EFLOATEXT efTmp = (LONG)pdo.ulLogPixelsX();
            efTmp /= (LONG)pdo.ulLogPixelsY();
            MATRIX mxW2D = pdco->pdc->mxWorldToDevice();
            if(mxW2D.efM12.bIsZero() && mxW2D.efM21.bIsZero()){// for 1,4 -up printing
               mxND.efM12 /= efTmp;
               mxND.efM21 *= efTmp;
            }
            else{     // for 2, 6-up printing, i.e. 270 rotation
               mxND.efM11 *= efTmp;
               mxND.efM22 /= efTmp;
            }
        }
    }

    SET_FLOAT_WITH_LONG(pfdx->eXX,mxND.efM11.lEfToF());
    SET_FLOAT_WITH_LONG(pfdx->eXY,mxND.efM12.lEfToF());
    SET_FLOAT_WITH_LONG(pfdx->eYX,mxND.efM21.lEfToF());
    SET_FLOAT_WITH_LONG(pfdx->eYY,mxND.efM22.lEfToF());

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\fontgdip.cxx ===
/******************************Module*Header*******************************\
* Module Name: fontgdip.cxx
*
* Private font API entry points.
*
* Created: 26-Jun-1991 10:04:34
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"
LONG lNormAngle(LONG lAngle);

/******************************Public*Routine******************************\
*
* VOID vSetLOCALFONT(HLFONT hlf, PVOID pvCliData)
*
* Effects:
*  set the pointer to the memory shared between client and
*  kernel
*
* History:
*  18-Mar-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



VOID vSetLOCALFONT(HLFONT hlf, PVOID pvCliData)
{
    PENTRY pentry;
    UINT uiIndex = (UINT) HmgIfromH(hlf);
    pentry = &gpentHmgr[uiIndex];

    ASSERTGDI(uiIndex < gcMaxHmgr,"hfontcreate pentry > gcMaxHmgr");

    pentry->pUser = pvCliData;
}





/******************************Public*Routine******************************\
* GreSelectFont
*
* Server-side entry point for selecting a font into a DC.
*
* History:
*
*  Mon 18-Mar-1996 -by- Bodin Dresevic [BodinD]
* update: added ref counting in the kernel
*
*  22-Oct-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/


HFONT GreSelectFont(HDC hdc, HFONT hlfntNew)
{
    HLFONT hlfntOld = (HLFONT) 0;
    XDCOBJ dco(hdc);
    PLFONT plfnt;

    if (dco.bValid())
    {
    // Let us make sure it is ok to select this new font to a DC,
    // that is make sure that it is not marked deletable

        hlfntOld = (HLFONT)dco.pdc->plfntNew()->hGet();

        if ((HLFONT)hlfntNew != hlfntOld)
        {
        // Lock down the new logfont handle so as to get the pointer out
        // This also increments the reference count of the new font

            plfnt = (PLFONT)HmgShareCheckLock((HOBJ)hlfntNew, LFONT_TYPE);

        // What if this did not work?

            if (plfnt)
            {
            // if marked for deletion, refuse to select it in

                if (!(PENTRY_FROM_POBJ(plfnt)->Flags & HMGR_ENTRY_LAZY_DEL))
                {
                // undo the lock from when the brush was selected

                    DEC_SHARE_REF_CNT_LAZY_DEL_LOGFONT(dco.pdc->plfntNew());

                // set the new lfont:

                    dco.pdc->plfntNew(plfnt);
                    dco.pdc->hlfntNew((HLFONT)hlfntNew);

                    dco.ulDirtyAdd(DIRTY_CHARSET);

                // same as CLEAR_CACHED_TEXT(pdcattr);

                    dco.ulDirtySub(SLOW_WIDTHS);
                }
                else
                {
                    DEC_SHARE_REF_CNT_LAZY_DEL_LOGFONT(plfnt);
                    hlfntOld = 0;
                }
            }
            else
            {
                hlfntOld = 0;
            }
        }
        dco.vUnlockFast();
    }

#if DBG
    else
    {
        WARNING1("GreSelectFont passed invalid DC\n");
    }
#endif

// return old HLFONT

    return((HFONT)hlfntOld);
}

/******************************Public*Routine******************************\
* hfontCreate
*
* Creates the file with an LOGFONTW and a type.
*
* History:
*  Sun 13-Jun-1993 -by- Patrick Haluptzok [patrickh]
* Wrote it.
\**************************************************************************/

HFONT hfontCreate(ENUMLOGFONTEXDVW * pelfw, LFTYPE lft, FLONG  fl, PVOID pvCliData)
{
    HFONT hfReturn;

    TRACE_FONT(("hfontCreate: ENTERING, font name %ws\n", pelfw->elfEnumLogfontEx.elfLogFont.lfFaceName));

    if (pelfw &&
        pelfw->elfDesignVector.dvNumAxes <= MM_MAX_NUMAXES)
    {
    // We must Allocate - init object - add to hmgr table.
    // Otherwise possible crash if bad app uses newly created handle
    // before init finishes.

        ULONG cjElfw = offsetof(ENUMLOGFONTEXDVW,elfDesignVector) +
                       SIZEOFDV(pelfw->elfDesignVector.dvNumAxes) ;

        PLFONT plfnt = (PLFONT) ALLOCOBJ(offsetof(LFONT,elfw)+cjElfw,LFONT_TYPE,FALSE);

        if (plfnt != NULL)
        {
            plfnt->lft = lft;
            plfnt->fl = fl;
            plfnt->cjElfw_ = cjElfw;
            RtlCopyMemory(&plfnt->elfw, pelfw, cjElfw);
            plfnt->cMapsInCache = 0;

        // Add the upper case version of the facename to the LFONT.

            cCapString
            (
                plfnt->wcCapFacename,
                pelfw->elfEnumLogfontEx.elfLogFont.lfFaceName,
                LF_FACESIZE
            );

        // Normalize the orientation angle.  This saves the mapper from doing it.

            pelfw->elfEnumLogfontEx.elfLogFont.lfOrientation
            = lNormAngle(pelfw->elfEnumLogfontEx.elfLogFont.lfOrientation);

            hfReturn = (HFONT) HmgInsertObject((HOBJ)plfnt,0,LFONT_TYPE);

            if (hfReturn != (HFONT) 0)
            {
                vSetLOCALFONT((HLFONT)hfReturn, pvCliData);
                TRACE_FONT(("hfontCreate: SUCCESS\n"));
                return(hfReturn);
            }

            WARNING("hfontCreate failed HmgInsertObject\n");
            FREEOBJ(plfnt, LFONT_TYPE);
        }
    }
    else
    {
        WARNING("hfontCreate invalid parameter\n");
    }

    TRACE_FONT(("hfontCreate: FAILIURE\n"));

    return((HFONT) 0);
}


/******************************Public*Routine******************************\
* BOOL bDeleteFont
*
* Destroys the LFONT object identified by the handle, hlfnt.
*
* History:
*  Thu 10-Jun-1993 -by- Patrick Haluptzok [patrickh]
* Change deletion to check for other locks.
*
*  26-Feb-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL bDeleteFont(HLFONT hlfnt, BOOL bForceDelete)
{
    BOOL bRet = TRUE;
    PLFONT plfnt;
    BOOL   bDelete = TRUE;

    TRACE_FONT(("Entering bDeleteFont\n"
                "    hlfnt = %x, bForceDelete = %d\n", hlfnt, bForceDelete));

    HANDLELOCK LfontLock;

    //
    // Old comment from bodind:
    //    Isn't this operation incresing share ref count?
    //
    // This should be investigated.
    //

    LfontLock.bLockHobj((HOBJ)hlfnt, LFONT_TYPE);

    if (LfontLock.bValid())
    {
        POBJ pObj = LfontLock.pObj();
        ASSERTGDI(pObj->cExclusiveLock == 0,
            "deletefont - cExclusiveLock != 0\n");

    // if brush still in use mark for lazy deletion and return true

        if (LfontLock.ShareCount() > 0)
        {
            LfontLock.pentry()->Flags |= HMGR_ENTRY_LAZY_DEL;
            bDelete = FALSE;
        }

    // We always force delete of LOCALFONT client side structure
    // in the client side, therefore we can set the pointer to this
    // structure to zero

        LfontLock.pentry()->pUser = NULL;

    // Done

        LfontLock.vUnlock();
    }
    else
    {
        bRet    = FALSE;
        bDelete = FALSE;
    }

    if (bDelete)
    {
        if ((plfnt = (LFONT *) HmgRemoveObject((HOBJ)hlfnt, 0, 0, bForceDelete, LFONT_TYPE)) != NULL)
        {
            FREEOBJ(plfnt, LFONT_TYPE);
            bRet = TRUE;
        }
        else
        {
            WARNING1("bDeleteFont failed HmgRemoveObject\n");
            bRet = FALSE;
        }
    }

    TRACE_FONT(("Exiting bDeleteFont\n"
                "    return value = %d\n", bRet));
    return(bRet);
}

/******************************Public*Routine******************************\
* GreSetFontEnumeration
*
* Comments:
*   This function is intended as a private entry point for Control Panel.
*
\**************************************************************************/

ULONG APIENTRY NtGdiSetFontEnumeration(ULONG ulType)
{
    return (GreSetFontEnumeration(ulType));
}

ULONG GreSetFontEnumeration(ULONG ulType)
{
    ULONG ulOld;

    if (ulType & ~(FE_FILTER_TRUETYPE | FE_AA_ON  | FE_SET_AA |
                    FE_CT_ON | FE_SET_CT))
    {
        WARNING("GreSetFontEnumeration(): unknown ulType %ld\n");
    }

    ulOld = gulFontInformation;

    if(ulType & FE_SET_AA)
      gulFontInformation = (ulType & FE_AA_ON) | (ulOld & FE_CT_ON) | (ulOld & FE_FILTER_TRUETYPE);
    else if (ulType & FE_SET_CT)
      gulFontInformation = (ulType & FE_CT_ON) | (ulOld & FE_AA_ON) | (ulOld & FE_FILTER_TRUETYPE);
    else
      gulFontInformation = (ulType & FE_FILTER_TRUETYPE) | (ulOld & FE_AA_ON) |  (ulOld & FE_CT_ON);

    return ulOld;
}

ULONG GreSetFontContrast(ULONG ulContrast)
{
    ULONG ulOld;


    ulOld = gulGamma;
    gulGamma = ulContrast;

    return ulOld;
}

ULONG GreGetFontEnumeration(VOID)
{
    return gulFontInformation;
}

ULONG GreGetFontContrast(VOID)
{
    return gulGamma;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\fontmap.cxx ===
/******************************Module*Header*******************************\
* Module Name: fontmap.cxx                                                 *
*                                                                          *
* Routines for mapping fonts.                                              *
*                                                                          *
* Created: 17-Jun-1992 11:12:16                                            *
* Author: Kirk Olynyk [kirko]                                              *
*                                                                          *
* Copyright (c) 1992-1999 Microsoft Corporation                            *
\**************************************************************************/

#include "precomp.hxx"

extern "C" VOID vInitMapper();
extern "C" NTSTATUS DefaultFontQueryRoutine(IN PWSTR, IN ULONG, IN PVOID,
                                            IN ULONG, IN PVOID, IN PVOID);

#pragma alloc_text(INIT, vInitMapper)
#pragma alloc_text(INIT, DefaultFontQueryRoutine)

// external procedures from draweng.cxx

VOID   vArctan(EFLOAT, EFLOAT,EFLOAT&, LONG&);

// external procedure from FONTSUB.CXX

extern "C" FONTSUB * pfsubAlternateFacename(PWCHAR);

#ifdef LANGPACK
extern "C" BOOL EngLpkInstalled();
#endif


/*** globals defined in this module ***/

#if DBG
    #define DEBUG_SMALLSUBSTITUTION 0x80
     FLONG gflFontDebug = 0;

    PFE *ppfeBreak = 0;
    LONG lDevFontThresh = FM_DEVICE_FONTS_ARE_BETTER_BELOW_THIS_SIZE;
#endif

PWSZ gpwszDefFixedSysFaceName   = (PWSZ) L"FIXEDSYS";

#define WIN31_SMALL_WISH_HEIGHT 2
#define WIN31_SMALL_FONT_HEIGHT 3

PFE *gppfeMapperDefault = PPFENULL;     // set to something meaningfule
                                        // at boot by bInitSystemFont()
                                        // in stockfnt.cxx

// Storage for static globals in MAPPER

PDWORD MAPPER::SignatureTable;     // base of the signature table
PWCHAR MAPPER::FaceNameTable;      // base of the face name table
BYTE   MAPPER::DefaultCharset;     // default charset is equivilent to this


/******************************Public*Routine******************************\
* BYTE jMapCharset()
*
* This routine is stollen from Win95 code (converted from asm).
* It checks if a font supports a requested charset.
*
* History:
*   2-Jul-1997 -by- Yung-Jen Tony Tsai [yungt]
*  17-Jan-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


BYTE jMapCharset(BYTE lfCharSet, PFEOBJ &pfeo)
{
    BYTE    jCharSet;
    BYTE    jLinkedCharSet;
    BYTE *  ajCharSets;
    BYTE *  ajCharSetsEnd;
    BYTE *  pjCharSets;

    IFIMETRICS *pifi = pfeo.pifi();
    // if only one charset supported in a font, this is the best match to
    // the request that the font can offer.

    // the check for FM_INFO_TECH_TYPE1 is a temporary hack until
    // we add a new field to the IFI metrics for the Type1 font ID's
    // [gerritv] 8-23-95

    if (pifi->dpCharSets == 0)
    {
        return( pifi->jWinCharSet );
    }

    // this is what is meant by default_charset:

    if (lfCharSet == DEFAULT_CHARSET)
    {
        lfCharSet = MAPPER::DefaultCharset;
    }

    // if several charsets are supported, let us check out
    // if the requested one is one of them:

    ajCharSets = (BYTE *)pifi + pifi->dpCharSets;
    ajCharSetsEnd = ajCharSets + MAXCHARSETS;

    for (pjCharSets = ajCharSets; pjCharSets < ajCharSetsEnd; pjCharSets++)
    {
        if (*pjCharSets == lfCharSet)
        {
            return( lfCharSet );
        }
        if (*pjCharSets == DEFAULT_CHARSET) // terminator
        {

    // The charset did not support in base font.
    // We need to check the charset of linked font
    // If there is one, then we get it
    // otherwise, we return BaseFont.ajCharSets[0]
            jCharSet = ajCharSets[0];
            break;
        }
    }


    if (pfeo.pGetLinkedFontEntry())
    {
    // No charset in the base font matches the requested charset.
    // And this base font has lined font.  Then we should check
    // the charsets in the linked font to see if there is a
    // match there as well.

        PLIST_ENTRY p = pfeo.pGetLinkedFontList()->Flink;
        while ( p != pfeo.pGetLinkedFontList() )
        {
            PPFEDATA    ppfeData = CONTAINING_RECORD(p,PFEDATA,linkedFontList);
            PFEOBJ      pfeoEudc(ppfeData->appfe[PFE_NORMAL]);

            pifi = pfeoEudc.pifi();

            if (pifi->dpCharSets == 0 && pifi->jWinCharSet == lfCharSet)
            {
                return ( lfCharSet );
            }
        else if (pifi->dpCharSets)
            {
                ajCharSets = (BYTE *)pifi + pifi->dpCharSets;
                ajCharSetsEnd = ajCharSets + MAXCHARSETS;

                for (pjCharSets = ajCharSets; pjCharSets < ajCharSetsEnd; pjCharSets++)
                {
                    if (*pjCharSets == lfCharSet)
                    {
                        return ( lfCharSet );
                    }
                    if (*pjCharSets == DEFAULT_CHARSET) // terminator
                    {

                        break; // End of for loop
                    }
                }
            }
            p = p->Flink;
        }
    }

    return(jCharSet);

}

/******************************Public*Routine******************************\
*  GreGetCannonicalName(
*
*  The input is the zero terminated name of the form
*
*  foo_XXaaaYYbbb...ZZccc
*
*  where  XX,  YY,  ZZ are numerals (arbitrary number of them) and
*        aaa, bbb, ccc are not numerals, i.e. spaces, or another '_' signs or
*  letters with abbreviated axes names.
*
*  This face name will be considered equivalent to face name foo
*  with DESIGNVECTOR [XX,YY, ...ZZ], number of axes being determined
*  by number of numeral sequences.
*
*
* Effects:
*
* History:
*  25-Jun-1997 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


#define IS_DIGIT(x)   (((x) >= L'0') && ((x) <= L'9'))
#define GET_DIGIT(X)  ((X) - L'0')
#define WC_UNDERSCORE L'_'


VOID GreGetCannonicalName(
    WCHAR        *pwszIn,  // foo_XX_YY
    WCHAR        *pwszOut, // Cannonical and capitalized name FOO
    ULONG        *pcAxes,
    DESIGNVECTOR *pdv      // [XX,YY] on out
)
{
// The input is the zero terminated name of the form
//
// foo_XXaaaYYbbb...ZZccc
//
// where  XX,  YY,  ZZ are numerals (arbitrary number of them) and
//       aaa, bbb, ccc are not numerals, i.e. spaces, or another '_' signs or
// letters with abbreviated axes names.
//
// This face name will be considered equivalent to face name foo
// with DESIGNVECTOR [XX,YY, ...ZZ], number of axes being determined
// by number of numeral sequences.

    WCHAR *pwc;
    ULONG cAxes = 0;
    ULONG cwc;

    for
    (
        pwc = pwszIn ;
        (*pwc) && !((*pwc == WC_UNDERSCORE) && IS_DIGIT(pwc[1]));
        pwc++
    )
    {
        // do nothing;
    }

// copy out, zero terminate

// Sundown safe truncation
    cwc = (ULONG)(pwc - pwszIn);
    memcpy(pwszOut, pwszIn, cwc * sizeof(WCHAR));
    pwszOut[cwc] = L'\0';

// If we found at least one WC_UNDERSCORE followed by the DIGIT
// we have to compute DV. Underscore followed by the DIGIT is Adobe's rule

    if ((*pwc == WC_UNDERSCORE) && IS_DIGIT(pwc[1]))
    {
    // step to the next character behind undescore

        pwc++;

        while (*pwc)
        {
        // go until you hit the first digit

            for ( ; *pwc && !IS_DIGIT(*pwc) ; pwc++)
            {
                // do nothing
            }


            if (*pwc)
            {
            // we have just hit the digit

                ULONG dvValue = GET_DIGIT(*pwc);

            // go until you hit first nondigit or the terminator

                pwc++;

                for ( ; *pwc && IS_DIGIT(*pwc); pwc++)
                {
                    dvValue = dvValue * 10 + GET_DIGIT(*pwc);
                }

                pdv->dvValues[cAxes] = (LONG)dvValue;

            // we have just parsed a string of numerals

                cAxes++;
            }
        }
    }

// record the findings

    *pcAxes = cAxes;
    pdv->dvNumAxes = cAxes;
    pdv->dvReserved = STAMP_DESIGNVECTOR;
}





/******************************Member*Function*****************************\
* bInitMapper()
*
* This callback routine reads the default facename entries from the registry.
* The entries have a the following form:
*
* FontMapper
*   FaceName1 = REG_DWORD FontSignature1
*   FaceName2 = REG_DWORD FontSignature2
*   .........
*   Default   = REG_DWORD Charset equivilent to default charset
*
* The FontSignature entry has the following format:
*
*
*         |-----------------Used when fixed pitch is requested
*         ||--------------- Used when FF_ROMAN is requested
*         |||-------------- Used when vertical face is requested
*         |||-------------- Used as first choice for BM font
*         ||||------------- Used as second choice for BM font
*         ||||
*         ||||    |------- Bits 0-7 Charset
*         ||||    |
* YYYYYYYYXXXXYYYYXXXXXXXX
*
* The bits specified by Y's are unused.  Thus determine what face name is
* to be used by default, the mapper will create a signature based on pitch,
* family, charset, etc fields in the LOGFONT and then try to match it against
* the signature/facename pairs in the registry.  Putting these values in
* the registry makes it possible add extra entries for other charsets such
* as Shift-JIS and Big-5.
*
*
* History:
*  Thu 2-Jun-1994 16:42:11 by Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/

extern "C"
NTSTATUS
DefaultFontQueryRoutine
(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
)
{
    PREGREADER RegRead = (PREGREADER) Context;


    if( !_wcsicmp( ValueName, L"DEFAULT" ) )
    {
        // The value "Default" is a special case.
        // It doesn't refer to the facename and instead indicates
        // which charset the default charset is equivilent to.

        DWORD Data = *((DWORD*)ValueData);
        RegRead->DefaultCharset = (BYTE) Data;
    }
    else if( RegRead->NextValue == NULL )
    {
        //  If NextValue is NULL then this is the first pass
        //  of the enumeration and we are just figuring out
        //  the number of entries and size of buffer we
        //  will need.

        RegRead->TableSize += ( wcslen(ValueName) + 1 ) * sizeof(WCHAR);
        RegRead->NumEntries += 1;
    }
    else
    {
        // On this pass we are actually building up a table of
        // signtures and face names to match them.

        if( ValueType == REG_DWORD )
        {
            // move the font signature portion to the high word,
            // the low word will store the offset to the facename

            DWORD Data = (*((DWORD*)ValueData));

            Data |= ( RegRead->NextFaceName - RegRead->FaceNameBase ) << 16;

            *(RegRead->NextValue)++ = Data;

            //  We ignore the last character of the string
            //  if it is a number. This allows us to have
            //  multiple entries for the same face name like
            //  Roman0, Roman1, etc.

            UINT ValueLen = wcslen(ValueName);

            wcscpy( RegRead->NextFaceName, ValueName );

            if( ValueName[ValueLen-1] >= (WCHAR) '0' &&
                ValueName[ValueLen-1] <= (WCHAR) '9' )
            {
                ValueLen -= 1;
                (RegRead->NextFaceName)[ValueLen] = (WCHAR) 0;
            }

            RegRead->NextFaceName += ValueLen+1;

            // Finally update the number of entries

            RegRead->NumEntries += 1;
        }
        else
        {
            WARNING("DefaultFontQueryRoutine:invalid registry entry\n");
            return(!STATUS_SUCCESS);
        }
    }
    return( STATUS_SUCCESS );
}



/******************************Member*Function*****************************\
* vInitMapper()
*
* This funtion reads in the FontSignature/Default facenmame pairs from
* the registry.  The format of these pairs is described in the comment
* for the DefaultFontQueryRoutine function.  vInitMapper() is called once
* when winsrv is initialized.
*
* If there is an error in initialization the mapper can still work but just
* won't fill in default facenames properly and will perform considerably
* slower for requests in which no facename is specified or which an invalid
* facename is specified.
*
* History:
*  Thu 2-Jun-1994 16:42:11 by Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/

extern "C" VOID vInitMapper()
{
    RTL_QUERY_REGISTRY_TABLE QueryTable[2];
    DWORD Status;
    REGREADER RegRead;

    QueryTable[0].QueryRoutine = DefaultFontQueryRoutine;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = (PWSTR)NULL;
    QueryTable[0].EntryContext = NULL;
    QueryTable[0].DefaultType = REG_NONE;
    QueryTable[0].DefaultData = NULL;
    QueryTable[0].DefaultLength = 0;

    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = NULL;

    RegRead.NumEntries = 0;
    RegRead.TableSize = 0;
    RegRead.NextValue = NULL;

    MAPPER::SignatureTable = NULL;
    MAPPER::FaceNameTable = NULL;

    Status = RtlQueryRegistryValues(RTL_REGISTRY_WINDOWS_NT,
                                    L"FontMapper",
                                    QueryTable,
                                    &RegRead,
                                    NULL );

    if( NT_SUCCESS(Status) )
    {
        MAPPER::SignatureTable = (PDWORD)
            PALLOCMEM(RegRead.NumEntries * sizeof(DWORD) + RegRead.TableSize,'pamG');

        if( MAPPER::SignatureTable == NULL )
        {
            WARNING("vInitMapper:Unable to allocate enough memory\n");
            return;
        }

        // Set all the proper pointers in the REGREAD structure
        // for the next pass of the enumeration to use.

        RegRead.NextValue = MAPPER::SignatureTable;
        RegRead.FaceNameBase = (PWCHAR) &(MAPPER::SignatureTable[RegRead.NumEntries]);
        RegRead.NumEntries = 0;
        RegRead.NextFaceName = RegRead.FaceNameBase;

        // do the second pass of the enumeration

        Status = RtlQueryRegistryValues(RTL_REGISTRY_WINDOWS_NT,
                                        L"FontMapper",
                                        QueryTable,
                                        &RegRead,
                                        NULL );
        // we are done

        if( NT_SUCCESS(Status) )
        {
            MAPPER::FaceNameTable = RegRead.FaceNameBase;
            MAPPER::DefaultCharset = RegRead.DefaultCharset;

            return;
        }

        // else fall through to error warning and reset MAPPER::FaceNameTable

        VFREEMEM(MAPPER::SignatureTable);
        MAPPER::SignatureTable = NULL;
    }
    WARNING("vInitMapper:Error enumerating default face names\n");
}


/******************************Member*Function*****************************\
* PWSZ FindFaceName
*
* This routine takes a signature (described above)
* and tries to find a defualt facename that matches it.
* If it doesn't find a match if will return a pointer
* to an empty string.
*
* History:
*  Thu 2-Jun-1994 16:42:11 by Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/

PWSZ FindFaceName( DWORD Signature )
{
    PDWORD SigPtr;

    for( SigPtr = MAPPER::SignatureTable;
         SigPtr < (PDWORD) MAPPER::FaceNameTable;
         SigPtr += 1)
    {
        if( (*SigPtr & 0xFFFF ) == Signature )
        {
            return( MAPPER::FaceNameTable + (*SigPtr >> 16 & 0xFFFF ) );
        }
    }

    //  Return a pointer to an empty string. Nothing will match
    //  this causing us to fall through to a case where do a
    //  mapping which doesnt take face name into account.

    return( (PWSZ) L"" );
}



/******************************Member*Function*****************************\
* MAPPER::MAPPER()                                                         *
*                                                                          *
* History:                                                                 *
*  Tue 29-Dec-1992 09:22:31 by Kirk Olynyk [kirko]                         *
* Added back in the case for small font substitution.                      *
*                                                                          *
*  Fri 18-Dec-1992 22:43:09 -by- Charles Whitmer [chuckwh]                 *
* Slimmed it down by removing lots of structure copies.                    *
*                                                                          *
*  Tue 10-Dec-1991 12:45:41 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

MAPPER::MAPPER
(
      XDCOBJ       *pdcoSrc,         // current DC
      FLONG        *pflSim_,
      POINTL       *pptlSim_,
      FLONG        *pflAboutMatch_,
const ENUMLOGFONTEXDVW *pelfwWishSrc,    // wish list in World Coordinates
      PWSZ          pwszFaceName_,
      ULONG         ulMaxPenaltySrc, // pruning criteria
      BOOL          bIndexFont_,
      FLONG         flOptions = 0
)
{

    fl            = 0;
    ifio.vSet((IFIMETRICS*) NULL);
    pdco          = pdcoSrc;
    pelfwWish     = pelfwWishSrc;
    pwszFaceName  = pwszFaceName_;

// check if this face name might a long foo_XX_YY name of the instance

    ULONG cAxes;
    flMM = 0;

    GreGetCannonicalName(
        pwszFaceName_,  // foo_XX_YY
        this->awcBaseName, // Cannonical and capitalized name FOO
        &cAxes,
        &this->dvWish);

    ppfeMMInst    = NULL; // no instances found yet that match this instances base font

// if GreGetCannonicalName did not find any axes info in the name,
// but the design vector is specified explicitly we use it.
// If however, cAxes from the name is not zero, we ignore
// whatever may be specified in the design vector explicitely.

    if (cAxes == 0)
    {
        if (pelfwWish->elfDesignVector.dvNumAxes)
        {
            RtlCopyMemory(
                &this->dvWish,
                &pelfwWish->elfDesignVector,
                SIZEOFDV(pelfwWish->elfDesignVector.dvNumAxes)
                );
        }
        else
        {
            awcBaseName[0] = 0;
        }
    }
    else
    {
        flMM |= FLMM_DV_FROM_NAME;
    }

    ulMaxPenalty  =  ulMaxPenaltySrc;
    bIndexFont    = bIndexFont_;

    ASSERTGDI(pdco && pelfwWish,"Bad call to MAPPER\n");

    // to begin with use the lfCharSet value from the logfont, this may
    // be latter replaced by the value from [font substitutes]

    jMapCharSet = pelfwWish->elfEnumLogfontEx.elfLogFont.lfCharSet;

    {
        pflAboutMatch  = pflAboutMatch_;
        *pflAboutMatch = 0;

        ppfeBest       = (PFE*) NULL;
        ulBestTime     = ULONG_MAX;
        pflSimBest     = pflSim_;
        pptlSimBest    = pptlSim_;

        *pflSimBest    = 0;
        pptlSimBest->x = 1;
        pptlSimBest->y = 1;
    }

    // Is it a display DC or it's moral equivilent?

    fl |= pdco->bPrinter() ? 0 : FM_BIT_DISPLAY_DC;

    // Set the GM_COMPATIBLE bit.
    //
    // If we are playing a metafile , world to page transform may be set
    // even if the graphics mode is COMPATIBLE, in which case the mapping
    // will occur the same way as it would in the advanced mode case
    // [bodind].

    if
    (
        (pdco->pdc->iGraphicsMode() == GM_COMPATIBLE) &&
        (pdco->pdc->bWorldToPageIdentity() || !pdco->pdc->bUseMetaPtoD())
    )
    {
        fl |= FM_BIT_GM_COMPATIBLE;
    }
    else
    {
        // If you are in advanced mode, then ignore the windows
        // hack for stock fonts

        flOptions &= ~FM_BIT_PIXEL_COORD;
    }

    if (pelfwWish->elfEnumLogfontEx.elfLogFont.lfQuality == PROOF_QUALITY)
    {
        fl |= FM_BIT_PROOF_QUALITY;
    }

    //  The windows short circuit mapper doesn't get called
    //  when an a NULL facename is requested.  In this case
    //  windows goes to the long mapper where a true type font
    //  will win over a raster font for some reason if the weight
    //  requested is FW_BOLD or FW_NORMAL.  We on the other
    //  hand will give out a raster font in this case which
    //  causes CA Super Project to break.  We mark this case
    //  here and fail bFindBitmapFont font when it occurs. [gerritv]

    if( ( pelfwWish->elfEnumLogfontEx.elfLogFont.lfWeight == FW_NORMAL ) ||
        ( pelfwWish->elfEnumLogfontEx.elfLogFont.lfWeight == FW_BOLD ) )
    {
        fl |= FM_BIT_WEIGHT_NOT_FAST_BM;
    }

    //  If the requested facename is Ms Shell Dlg then we wont
    //  worry about charset. This is a hack to make the shell
    //  work with other versions of Ms Sans Serif
    //  such as Greek [gerritv]

    if( pwszFaceName[0] ==  U_LATIN_CAPITAL_LETTER_M &&
        pwszFaceName[1] ==  U_LATIN_CAPITAL_LETTER_S &&
        pwszFaceName[2] ==  U_SPACE                  &&
        pwszFaceName[3] ==  U_LATIN_CAPITAL_LETTER_S &&
        pwszFaceName[4] ==  U_LATIN_CAPITAL_LETTER_H &&
        pwszFaceName[5] ==  U_LATIN_CAPITAL_LETTER_E &&
        pwszFaceName[6] ==  U_LATIN_CAPITAL_LETTER_L &&
        pwszFaceName[7] ==  U_LATIN_CAPITAL_LETTER_L &&
        pwszFaceName[8] ==  U_SPACE                  &&
        pwszFaceName[9] ==  U_LATIN_CAPITAL_LETTER_D &&
        pwszFaceName[10] == U_LATIN_CAPITAL_LETTER_L &&
        pwszFaceName[11] == U_LATIN_CAPITAL_LETTER_G &&
        pwszFaceName[12] == U_NULL
      )
    {
        fl |= FM_BIT_MS_SHELL_DLG;
    }
    else if
    (
        // If the requested facename is 'system' then Windows 3.1
        // compatibilty requires that we treat this case specially

        pwszFaceName[0] ==  U_LATIN_CAPITAL_LETTER_S &&
        pwszFaceName[1] ==  U_LATIN_CAPITAL_LETTER_Y &&
        pwszFaceName[2] ==  U_LATIN_CAPITAL_LETTER_S &&
        pwszFaceName[3] ==  U_LATIN_CAPITAL_LETTER_T &&
        pwszFaceName[4] ==  U_LATIN_CAPITAL_LETTER_E &&
        pwszFaceName[5] ==  U_LATIN_CAPITAL_LETTER_M &&
        pwszFaceName[6] ==  U_NULL
    )
    {
        // record the fact that 'SYSTEM' has been requested

        fl |= FM_BIT_SYSTEM_REQUEST;

        // If the request was for a fixed pitch font, then the
        // application really wants 'FIXEDSYS' instead

        if ((pelfwWish->elfEnumLogfontEx.elfLogFont.lfPitchAndFamily & 0xF) == FIXED_PITCH)
        {
            pwszFaceName = gpwszDefFixedSysFaceName;
        }
    }
    else if
    (
        pwszFaceName[0] == U_LATIN_CAPITAL_LETTER_T &&
        pwszFaceName[1] == U_LATIN_CAPITAL_LETTER_M &&
        pwszFaceName[2] == U_LATIN_CAPITAL_LETTER_S &&
        pwszFaceName[3] == U_SPACE                  &&
        pwszFaceName[4] == U_LATIN_CAPITAL_LETTER_R &&
        pwszFaceName[5] == U_LATIN_CAPITAL_LETTER_M &&
        pwszFaceName[6] == U_LATIN_CAPITAL_LETTER_N &&
        pwszFaceName[7] == U_NULL
    )
    {
        fl |= FM_BIT_TMS_RMN_REQUEST;
    }
    else if
    (
        // If the user requests symbol then he can goof up
        // the character set. This was put in to allow
        // "Spyglass Plot" to work See Bug #18228

        pwszFaceName[0] == U_LATIN_CAPITAL_LETTER_S &&
        pwszFaceName[1] == U_LATIN_CAPITAL_LETTER_Y &&
        pwszFaceName[2] == U_LATIN_CAPITAL_LETTER_M &&
        pwszFaceName[3] == U_LATIN_CAPITAL_LETTER_B &&
        pwszFaceName[4] == U_LATIN_CAPITAL_LETTER_O &&
        pwszFaceName[5] == U_LATIN_CAPITAL_LETTER_L
    )
    {
        fl |= FM_BIT_CHARSET_ACCEPT;
    }
// If user requests vertical font. We have to map this logical font to vertical
// Physical font
    else if
    (
        pwszFaceName[0] == U_COMMERCIAL_AT
    )
    {
        fl |= FM_BIT_VERT_FACE_REQUEST;
    }

    // Copy over the requested sizes.  We will transform them to device
    // coordinates later if needed.

    lDevWishHeight = pelfwWish->elfEnumLogfontEx.elfLogFont.lfHeight;

    lDevWishWidth  = ABS( pelfwWish->elfEnumLogfontEx.elfLogFont.lfWidth );

    {
        // Lock the PDEV to get some important information

        PDEVOBJ pdo((HDEV)pdco->pdc->ppdev());

        ulLogPixelsX = pdo.ulLogPixelsX();
        ulLogPixelsY = pdo.ulLogPixelsY();

        fl |= (pdo.flTextCaps() & TC_RA_ABLE)       ? FM_BIT_DEVICE_RA_ABLE   : 0;
        fl |= (pdo.flTextCaps() & TC_CR_90)         ? FM_BIT_DEVICE_CR_90_ALL : 0;
        fl |= (pdo.cFonts())                        ? FM_BIT_DEVICE_HAS_FONTS : 0;
        fl |= (pdo.ulTechnology() == DT_PLOTTER)    ? FM_BIT_DEVICE_PLOTTER   : 0;
        fl |= (pdo.ulTechnology() == DT_CHARSTREAM) ? FM_BIT_DEVICE_ONLY      : 0;

        ASSERTGDI(
            !((pdo.ulTechnology() == DT_PLOTTER) &&
                           (pdo.flTextCaps() & TC_RA_ABLE)),
            "winsrv!I didn't anticipate a plotter "
            "that can handle bitmap fonts\n"
        );

        if (lDevWishHeight == 0)
        {
            //  "If lfHeight is zero, a reasonable default size is
            //  substituted." [SDK Vol 2].  Fortunately, the
            //  device driver is kind enough to suggest a nice
            //  height (in pixels).  We shall put this suggestion
            //  into lDefaultDeviceHeight
            //
            //  NOTE:
            //
            //  I have assumed that the suggested font height, as
            //  given in lDefaultDeviceHeight is in pixel units

            lDevWishHeight = pdo.pdevinfoNotDynamic()->lfDefaultFont.lfHeight;

            // Inform bCalculateWishCell that the height needs no transform.

            fl |= FM_BIT_HEIGHT;
        }
        // At this point the PDEVOBJ passes out of scope and unlocks the PDEV
    }
    if (lDevWishHeight < 0)
    {
        fl |= FM_BIT_USE_EMHEIGHT;
        lDevWishHeight *= -1;
    }

    // Cache the wish weight and assign default weight if
    // no weight specified.  (This way we don't have to
    // compute this each time in msCheckFont.  And we
    // can't modify pelfwWish directly because it is
    // declared "const").

    lWishWeight = (LONG) pelfwWish->elfEnumLogfontEx.elfLogFont.lfWeight;

    if( lWishWeight == FW_DONTCARE )
    {
        // if FW_DONTCARE then we compute penalities
        // slightly differently so we keep track of this

        fl |= FM_BIT_FW_DONTCARE ;

        lWishWeight = FW_NORMAL;
    }

    // If the caller did not provide a face name, we provide a default.

    if (pwszFaceName[0] == (WCHAR) 0)
    {
        bGetFaceName();
    }

    fl |= (flOptions & FM_ALLOWED_OPTIONS) | FM_BIT_STILL_ALIVE;
}

/******************************Member*Function*****************************\
* BOOL bGetFaceName()                                                      *
*                                                                          *
* Gets a face name when there is none                                      *
*                                                                          *
* Comments                                                                 *
*                                                                          *
*   you got here because no facename was provided by                       *
*   the user.  At this point we shall select the font                      *
*   based upon its height and pitch and family.  First                     *
*   we examine the height in device space.  If the                         *
*   height has been calculated already then the                            *
*   FM_BIT_HEIGHT bit will have been set and no                            *
*   calculation is needed.  Otherwise we must                              *
*   calculate the requested height in pixel unit.  We                      *
*   do this by calling off to                                              *
*   MAPPER::bCaluculateWishCell().  If this returns                        *
*   with FALSE then the transformation was not                             *
*   appropriate to a bitmap font and we can choose                         *
*   only from TrueType defaults.  If                                       *
*   MAPPER::bCalculateWishCell returns true then                           *
*   this->lDevWishHeight has been calculated.  At that                     *
*   point we must see if it is in the range where the                      *
*   'small' fonts should be used, otherwise we must                        *
*   default to the TrueType fonts.                                         *
*                                                                          *
* Returns:                                                                 *
*   The only situation for this function to return FALSE is if the         *
*   FM_BIT_DISABLE_TT_NAMES bit is set in the MAPPER state.  When this     *
*   bit is set, the function may fail to find a suitable new facename      *
*   (because the catch-all of the TT core facenames is turned off).        *
*                                                                          *
* History:                                                                 *
*                                                                          *
*  Thu 2-Jun-1994 16:42:11 by Gerrit van Wingerden [gerritv]               *
* Rewrote it to get default facenames from the registry                    *
*  Thu 11-Mar-1993 14:09:49 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

BOOL MAPPER::bGetFaceName()
{
    BYTE Charset;

    // if the default charset is specified then use the
    // registry entry to determine what it really means

    Charset = (jMapCharSet == DEFAULT_CHARSET) ?
                MAPPER::DefaultCharset : jMapCharSet;

    fl |= FM_BIT_CALLED_BGETFACENAME;

    // compute the signature of the desired font

    DWORD Signature = (DWORD) Charset;

    if(( pelfwWish->elfEnumLogfontEx.elfLogFont.lfPitchAndFamily & (LOGFONT_PITCH_SET) ) == FIXED_PITCH )
    {
        Signature |= DFS_FIXED_PITCH;
    }

    if(( pelfwWish->elfEnumLogfontEx.elfLogFont.lfPitchAndFamily & (FF_SET) ) == FF_ROMAN )
    {
        // the font family is only important for variable pitch fonts

        Signature |= DFS_FF_ROMAN;
    }
    else
    if(( pelfwWish->elfEnumLogfontEx.elfLogFont.lfPitchAndFamily & (LOGFONT_PITCH_SET) ) == DEFAULT_PITCH &&
       ( pelfwWish->elfEnumLogfontEx.elfLogFont.lfPitchAndFamily & (FF_SET) ) == FF_MODERN )
    {
        // Windows95 may sometimes chooses Courier instead of Courier New

        Signature |= DFS_FIXED_PITCH;
    }

    if( fl & FM_BIT_VERT_FACE_REQUEST )
    {
        Signature |= DFS_VERTICAL;
    }

    //  In the case of the ANSI character set, we need to
    //  consider the possibility of using one of the small
    //  bitmap fonts.  If this search is unsuccessful, we
    //  will fall into the default case, which chooses an
    //  appropriate TrueType font from the core set.
    //
    //  The following set of conditions check to see if
    //  the requested height is so small so as to make
    //  TrueType fonts look awful.  The only way to know
    //  is to calculate the wish cell by calling to
    //  bCalculateWishCell().
    //
    //  bCalculateWishCell() will return FALSE if the font
    //  request is not suitable for a bitmap font.  It
    //  turns out that this condition may be too
    //  stringent.  Win 3.1 compatibility forces us to
    //  choose "Courier New" as the default small fixed
    //  pitch font.  Thus, it is possible that
    //  bCalculateWishCell() would reject "Courier New" on
    //  the false premise that the transform is
    //  incompatible with all small fonts because they
    //  should be bitmap fonts.  In any case, I will go
    //  with the follwing conditions until I am proven
    //  wrong.  It is my belief that in such a case,
    //  "Courier New" will be picked up in the else
    //  clause.

    if
    (
        ( Charset == ANSI_CHARSET                                 ) &&
        (fl  & FM_BIT_DEVICE_RA_ABLE                              ) &&
        ((fl & FM_BIT_CELL) ? TRUE : bCalculateWishCell()         ) &&
        ((fl & FM_BIT_ORIENTATION) ? TRUE : bCalcOrientation()    ) &&
        (
            iOrientationDevice == 0 * ORIENTATION_90_DEG ||
            iOrientationDevice == 1 * ORIENTATION_90_DEG ||
            iOrientationDevice == 2 * ORIENTATION_90_DEG ||
            iOrientationDevice == 3 * ORIENTATION_90_DEG
        )
    )
    {
        // Note: If we break out of this switch, we will fall into
        // the TT case below.  We are writing it this way so that
        // we can bail out of the "small font" case and into the TT
        // case if we have to.

        PWSZ pwszBitmap;

        pwszBitmap = FindFaceName( Signature | DFS_BITMAP_A );

        // Try the first choice

        if ( bFindBitmapFont(pwszBitmap) )
        {
            pwszFaceName = pwszBitmap;
            #if DBG
            if (gflFontDebug & DEBUG_MAPPER)
            {
                DbgPrint("MAPPER::bGetFaceName() --> \"%ws\"\n", pwszFaceName);
            }
            #endif
            return( TRUE );
        }

        // The first choice doesn't cut it, try the second choice

        pwszBitmap = FindFaceName( Signature | DFS_BITMAP_B );

        if ( bFindBitmapFont(pwszBitmap) )
        {
            pwszFaceName = pwszBitmap;
            #if DBG
            if (gflFontDebug & DEBUG_MAPPER)
            {
                DbgPrint("MAPPER::bGetFaceName() --> \"%ws\"\n", pwszFaceName);
            }
            #endif
            return( TRUE );
        }

        // If we get to here, we couldn't find a suitable raster
        // small font.  If the FM_BIT_DISABLE_TT_NAMES flag is
        // set, return error.  Otherwise, fall into the TT facename
        // substitution code below in the default case.

        if (fl & FM_BIT_DISABLE_TT_NAMES)
        {
            #if DBG
            if (gflFontDebug & DEBUG_MAPPER)
            {
                DbgPrint("MAPPER::bGetFaceName() failed\n");
            }
            #endif
            return( FALSE );
        }
    }

    // find the face name

    PWSZ pwszTemp = FindFaceName( Signature );
    if (*pwszTemp || !(fl & FM_BIT_FACENAME_MATCHED))
    {
        // If a new name was found then it should be used. On the
        // other hand, if a new name was not found then we must check
        // to see if the face name as specified in the LOGFONT was
        // ever found in the font tables. If the original face name
        // was found then we should use it again, but this time
        // allow character set mismatches. If the original name was
        // not found in the font table then return a string of zero
        // length causing the font mapper to fall into the emergency
        // procedure.

        pwszFaceName = pwszTemp;
    }
    #if DBG
    if (gflFontDebug & DEBUG_MAPPER)
    {
        DbgPrint("MAPPER::bGetFaceName() --> \"%ws\"\n", pwszFaceName);
    }
    #endif

    return( TRUE );
}

/******************************Public*Routine******************************\
* BOOL MAPPER::bFindBitmapFont                                             *
*                                                                          *
* The purpose of this function is to determine whether a bitmap font       *
* with the given facename and EXACTLY the wish height exists.  The         *
* purpose is to support Windows 3.1 compatible "small font" behavior.      *
* The Win 3.1 short circuit mapper (written by DavidW) forces mapping to   *
* the either of the standard small fonts ("Small fonts" and "MS Serif")    *
* only if the exact height requested exists.                               *
*                                                                          *
* Returns:                                                                 *
*   TRUE if font found, otherwise FALSE.                                   *
*                                                                          *
* History:                                                                 *
*  21-Apr-1993 -by- Gilman Wong [gilmanw]                                  *
* Wrote it.                                                                *
\**************************************************************************/

BOOL MAPPER::bFindBitmapFont(PWSZ pwszFindFace)
{
    PFELINK     *ppfel;
    HASHBUCKET  *pbkt;
    FONTHASHTYPE fht;
    BOOL bRet = FALSE;


    // we need to fail at certain weights to insure Win 3.1 compatibility

    if( fl & FM_BIT_WEIGHT_NOT_FAST_BM )
    {
        return( FALSE );
    }

    // We are only going to check the family table.
    // This is a very specialized search, so if its
    // not there it shouldn't be anywhere!

    PUBLIC_PFTOBJ pfto;
    FHOBJ fho(&pfto.pPFT->pfhFamily);
    if (!fho.bValid())
    {
        return( bRet );
    }
    fht = fho.fht();

    pbkt = fho.pbktSearch(pwszFindFace,(UINT*)NULL);

    if (!pbkt)
    {
        FONTSUB* pfsub = pfsubAlternateFacename(pwszFindFace);

    // only check "old style substitutions"

        if (pfsub && (pfsub->fcsAltFace.fjFlags & FJ_NOTSPECIFIED))
        {
            pbkt = fho.pbktSearch((PWSZ)pfsub->fcsAltFace.awch,(UINT*)NULL);
        }
    }

    if (!pbkt)
    {
        return( bRet );
    }

    // Scan the PFE list for an exact height match.

    for (ppfel = pbkt->ppfelEnumHead; ppfel; ppfel = ppfel->ppfelNext)
    {
        PFEOBJ pfeo(ppfel->ppfe);
        IFIOBJ ifio(pfeo.pifi());

        if (ifio.bBitmap())
        {
            LONG lH;

            lH = (fl & FM_BIT_USE_EMHEIGHT) ?
                     (LONG) ifio.fwdUnitsPerEm() : ifio.lfHeight();
            if
            (
                lDevWishHeight == lH ||
                (      lDevWishHeight == WIN31_SMALL_WISH_HEIGHT
                    && lH == WIN31_SMALL_FONT_HEIGHT
                )
            )
            {
                if (lDevWishWidth == 0 || lDevWishWidth == ifio.lfWidth())
                {
                    return( TRUE );
                }
            }
        }
    }

    return( bRet );
}

/******************************Member*Function*****************************\
* BOOL MAPPER::bCalcOrientation()                                          *
*                                                                          *
* History:                                                                 *
*  Tue 23-Mar-1993 22:24:19 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

BOOL MAPPER::bCalcOrientation()
{
    INT s11,s12,s21,s22;

    if (fl & FM_BIT_GM_COMPATIBLE)
    {
        // Taken from bGetNtoD_Win31()

        iOrientationDevice = pelfwWish->elfEnumLogfontEx.elfLogFont.lfEscapement;
        if (iOrientationDevice != 0)
        {
            if ( (pdco->pdc->bWorldToPageIdentity()) &&
                 (!(pdco->pdc->bPageToDeviceScaleIdentity())) &&
                 (pdco->pdc->efM11().lSignum() !=
                  pdco->pdc->efM22().lSignum()) )
            {
                iOrientationDevice = -iOrientationDevice;
            }
        }
        fl |= FM_BIT_ORIENTATION;
        return( TRUE );
    }
    else if (pdco->pdc->bWorldToDeviceIdentity() || (fl & FM_BIT_PIXEL_COORD))
    {
        iOrientationDevice = pelfwWish->elfEnumLogfontEx.elfLogFont.lfOrientation;
        fl |= FM_BIT_ORIENTATION;
        return( TRUE );
    }

    EXFORMOBJ xo(*pdco, WORLD_TO_DEVICE);

    s11 = (INT) xo.efM11().lSignum();
    s12 = (INT) xo.efM12().lSignum();
    s21 = (INT) xo.efM21().lSignum();
    s22 = (INT) xo.efM22().lSignum();

    if (pdco->pdc->bYisUp())
    {
        s21 = -s21;
        s22 = -s22;
    }

    if (pelfwWish->elfEnumLogfontEx.elfLogFont.lfOrientation % 900)
    {
        return( FALSE );
    }

    if
    (
          (s11 - s22)       // Signs on diagonal must match.
        | (s12 + s21)       // Signs off diagonal must be opposite.
        | ((s11^s12^1)&1)   // Exactly one diagonal must be zero.
    )
    {
        return( FALSE );
    }

    iOrientationDevice =
        pelfwWish->elfEnumLogfontEx.elfLogFont.lfOrientation
        + (s12 &  900)
        + (s11 & 1800)
        + (s21 & 2700);

    if (iOrientationDevice >= 3600)
        iOrientationDevice -= 3600;

    fl |= FM_BIT_ORIENTATION;
    return( TRUE );
}

/******************************Member*Function*****************************\
* MAPPER::bCalculateWishCell                                               *
*                                                                          *
* Calculates either the 'ascent' vector or 'width' vector of the font      *
* in device space units. Then the equivalent 'height' and/or width         *
* is filled in the the MAPPER::elfWishDevice fields. The height and width  *
* are defined to be positive.                                              *
*                                                                          *
* Also computes the wished for orientation in device coordinates.          *
* This is needed whenever the cell is needed!                              *
*                                                                          *
* We use three flags which have the following meaning when set, and should *
* be used for no other purpose.                                            *
*                                                                          *
*   FM_BIT_CELL        Informs the world that bCalculateWishCell has       *
*                          been called in the past, and successfully       *
*                          transformed the height, width, and orientation  *
*                          to device space.   (OUTPUT)                     *
*                                                                          *
*   FM_BIT_BAD_WISH_CELL   A flag internal to this function to tell it     *
*                          that it has been called already and the         *
*                          calculation failed.  (INTERNAL)                 *
*                                                                          *
*   FM_BIT_HEIGHT          Informs this function that the height is        *
*                          already in device space.  (INPUT)               *
*                                                                          *
* History:                                                                 *
*  Fri 18-Dec-1992 02:51:39 -by- Charles Whitmer [chuckwh]                 *
* Rewrote.  Utilizing the assumption that it only gets called for raster   *
* fonts, I was able to delete hundreds of lines of complex code!           *
*                                                                          *
*  Mon 30-Dec-1991 14:35:22 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

LONG lNormAngle(LONG);

BOOL MAPPER::bCalculateWishCell()
{
    INT s11,s12,s21,s22;

    LONG lAngle = lNormAngle(pelfwWish->elfEnumLogfontEx.elfLogFont.lfOrientation);

    // If we've failed here before, it's no better now!

    if (fl & FM_BIT_BAD_WISH_CELL)
    {
        return( FALSE );
    }

    // Make sure we haven't been called before!

    ASSERTGDI
    (
        (fl & FM_BIT_CELL) == 0,
        "gdi!MAPPER::bCalculateWishCell: Useless call!\n"
    );

    // Handle the trivial case.

    if (pdco->pdc->bWorldToDeviceIdentity() || (fl & FM_BIT_PIXEL_COORD))
    {
        iOrientationDevice = lAngle;
        fl |= (FM_BIT_CELL | FM_BIT_HEIGHT | FM_BIT_WIDTH);
        return( TRUE );
    }

    // Locate our transform and examine the matrix.

    EXFORMOBJ xo(*pdco, WORLD_TO_DEVICE);

    s11 = (INT) xo.efM11().lSignum();
    s12 = (INT) xo.efM12().lSignum();
    s21 = (INT) xo.efM21().lSignum();
    s22 = (INT) xo.efM22().lSignum();

    // Change to an equivalent transform where the y axis goes down.
    // We remove a sign change from the matrix components that hit y.

    if (pdco->pdc->bYisUp())
    {
        s21 = -s21;
        s22 = -s22;
    }

    // If we are in GM_ADVANCED mode, make sure the orientation and transform
    // are consistent with a bitmap font.  In GM_COMPATIBLE mode, just ignore
    // it all.  Note that iOrientationDevice remains undefined in GM_COMPATIBLE
    // mode.

    if (!(fl & FM_BIT_GM_COMPATIBLE) && !(fl & FM_BIT_ORIENTATION))
    {
        //  Reject random orientations.  Even under simple
        //  scaling transforms, they don't transform well.
        //  (Assuming we're mapping to a raster font.)

        if (lAngle % 900)
        {
          #if DBG
            if (gflFontDebug & DEBUG_MAPPER)
            {
                DbgPrint(
                "\tMAPPER::bCalculateWishCell detected a bad orientation\n");
            }
          #endif
            fl |= FM_BIT_BAD_WISH_CELL;
            return( FALSE );
        }

        // Examine the transform to see if it's a simple multiple of 90
        // degrees rotation and perhaps some scaling.

        // Check for parity flipping transforms which are not allowed.
        // (That would require reflecting a bitmap, something we don't
        // consider likely.)  Also look for complex transforms.

        // If any of the terms we OR together are non-zero,
        // it's a bad transform.

        if (
            (s11 - s22)         // Signs on diagonal must match.
            | (s12 + s21)       // Signs off diagonal must be opposite.
            | ((s11^s12^1)&1)   // Exactly one diagonal must be zero.
           )
        {
            #if DBG
            if (gflFontDebug & DEBUG_MAPPER)
            {
                DbgPrint("\tMAPPER::bCalculateWishCell "
                    "detected a bad trasform -- returning FALSE");
                DbgPrint("{%d,%d,%d,%d}\n",s11,s12,s21,s22);
            }
            #endif
            fl |= FM_BIT_BAD_WISH_CELL;
            return( FALSE );
        }

        // Since we've normalized to a space where (0 -1) represents
        // a vector with a 90 degree orientation (like MM_TEXT) note
        // that the matrix that rotates us by positive 90 degrees is:
        //
        //            [ 0 -1 ]
        //     (0 -1) [      ] = (-1 0)
        //            [ 1  0 ]
        //
        // I.e. the one with M  < 0.  Knowing this, the rest is easy!
        //                    12

        iOrientationDevice =
              lAngle
            + (s12 &  900)
            + (s11 & 1800)
            + (s21 & 2700);

        // Note that only the single 0xFFFFFFFF term contributes above.

        if (iOrientationDevice >= 3600)
            iOrientationDevice -= 3600;

        fl |= FM_BIT_ORIENTATION;
    }

    // Transform the height to device coordinates.

    if (!(fl & FM_BIT_HEIGHT))
    {
        // lDevWishHeight = lCvt(s22 ? xo.efM22() : xo.efM21(),lDevWishHeight);

        if (s22)
            lDevWishHeight = lCvt(xo.efM22(),lDevWishHeight);
        else
            lDevWishHeight = lCvt(xo.efM21(),lDevWishHeight);

        if (lDevWishHeight < 0)
            lDevWishHeight = -lDevWishHeight;
        lDevWishHeight = LONG_FLOOR_OF_FIX(lDevWishHeight + FIX_HALF);
    }

    // Transform the width to device coordinates.

    if (pelfwWish->elfEnumLogfontEx.elfLogFont.lfWidth && !(fl & FM_BIT_WIDTH))
    {
        // lDevWishWidth = lCvt(s11 ? xo.efM11() : xo.efM12(),lDevWishWidth);

        if (s11)
            lDevWishWidth = lCvt(xo.efM11(),lDevWishWidth);
        else
            lDevWishWidth = lCvt(xo.efM12(),lDevWishWidth);

        if (lDevWishWidth < 0)
            lDevWishWidth = -lDevWishWidth;
        lDevWishWidth = LONG_FLOOR_OF_FIX(lDevWishWidth + FIX_HALF);
    }
    fl |= (FM_BIT_CELL | FM_BIT_HEIGHT | FM_BIT_WIDTH);
    return( TRUE );
}

/******************************Member*Function*****************************\
* MAPPER::bNearMatch                                                       *
*                                                                          *
* History:                                                                 *
*  24-Sept-1196  -by-  Xudong Wu  [TesieW]                                 *
* Add checking on Private/Embedded fonts                                   *
*  Tue 28-Dec-1993 09:39:24 by Kirk Olynyk [kirko]                         *
* Changed the way msCheckFamily works for the case when the physical       *
* font has FF_DONTCARE for the family                                      *
*  Fri 18-Dec-1992 23:19:09 -by- Charles Whitmer [chuckwh]                 *
* Simplified a lot of stuff and then pulled all the routines in line.      *
* We were spending an extra 12 instructions per part checked by having     *
* them out of line, which adds up to about half the time in this routine!  *
*  Tue 10-Dec-1991 11:33:28 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

extern PW32PROCESS gpidSpool; // global


int MAPPER::bNearMatch(PFEOBJ &pfeo, BYTE *pjCharSet, BOOL bEmergency)
{
    int iRet = FALSE;       // return value
    ULONG ul;               // Temp variable.
    BYTE jAsk, jHav;
    PFE *ppfeNew = pfeo.ppfeGet();

    // Clear the per-font status bits

    fl &= ~(FM_BIT_NO_MAX_HEIGHT | FM_BIT_SYSTEM_FONT);

    if (pfeo.ppfeGet() == gppfeMapperDefault)
    {
        fl |= FM_BIT_SYSTEM_FONT;
    }

    ifio.vSet(pfeo.pifi());
    if (pfeo.bDead())
    {
        // The font is in a "ready to die" state.  That is, the engine is
        // ready to delete the font, but has had to delay it until all
        // outstanding references (via RFONTs) has disappeared.  Meanwhile,
        // we must not allow enumeration or mapping to this font.

        #if DBG
        if (gflFontDebug & DEBUG_MAPPER)
        {
            DbgPrint(
        "msCheckFont is returning FM_REJECT because pfeo.bDead() is true\n");
        }
        #endif

        ulPenaltyTotal = FM_REJECT;
        return( iRet );
    }

    // private pfe NOT added by the current process.
    // spooler has the right to access all the fonts

    if (!pfeo.bEmbPvtOk() && (gpidSpool != (PW32PROCESS)W32GetCurrentProcess()))
    {
        ulPenaltyTotal = FM_REJECT;
        return( iRet );
    }

    // Skip the PFE_UFIMATCH fonts since they are added to the public font table temporarily
    // for remote printing. These PFEs should be mapped only by bFoundForcedMatch() calls.

    if (pfeo.bUFIMatchOnly())
    {
        ulPenaltyTotal = FM_REJECT;
        return( iRet );
    }

    // spooler has the right to access all the fonts

    if (pfeo.bPrivate() && (gpidSpool != (PW32PROCESS)W32GetCurrentProcess()))
    {
        // The font is embedded then it can only be seen if the call is
        // Win 3.1 compatible (i.e. called by ppfeGetAMatch), the
        // embedded bit is set in the caller's logical font, and the clients
        // PID or TID matches that embeded in the *.fot file.

        if (pfeo.bEmbedOk())
        {
            if (!(pelfwWish->elfEnumLogfontEx.elfLogFont.lfClipPrecision & CLIP_EMBEDDED))
            {
                #if DBG
                if (gflFontDebug & DEBUG_MAPPER)
                {
                    DbgPrint("msCheckFont is returning FM_REJECT\n");
                    DbgPrint("because the font is embedded\n\n");
                }
                #endif

                ulPenaltyTotal = FM_REJECT;
                return( iRet );
            }
        }
    }

    ulPenaltyTotal   = 0;

    // Assume be default that the font that is chosen will no have
    // any bold or italic simulations

    flSimulations    = 0;

    // Assume by default that if we happen to choose a bitmap font, there
    // will be no streching in either the height-direction or width-direction

    ptlSimulations.x = 1;
    ptlSimulations.y = 1;

    // At this point, the code used to have the following nice structure.  For
    // performance reasons, I pulled the code of each of these routines inline.
    // Even so, the functionality of each of the following sections should
    // remain clean and distinct.  [chuckwh]
    //
    //    if
    //    (
    //        (msCheckPitchAndFamily()) == MSTAT_NEAR &&
    //        (msCheckHeight()        ) == MSTAT_NEAR &&
    //        (msCheckAspect()        ) == MSTAT_NEAR &&
    //        (msCheckItalic()        ) == MSTAT_NEAR &&
    //        (msCheckWeight()        ) == MSTAT_NEAR &&
    //        (msCheckOutPrecision()  ) == MSTAT_NEAR &&
    //        (msCheckWidth()         ) == MSTAT_NEAR &&
    //        (msCheckOrientation(pfeo.iOrientation())) == MSTAT_NEAR
    //    )
    //    {
    //        return( MSTAT_NEAR );
    //    }
    //    return( MSTAT_FAR );

  MSBREAKPOINT("msCheckForMMFont");

    if ((fl & FM_BIT_BASENAME_MATCHED) && !(pfeo.pifi()->flInfo & FM_INFO_TECH_MM))
    {
        CHECKPRINT("CheckForMMFont", FM_REJECT );
        ulPenaltyTotal = FM_REJECT;
        return( iRet );
    }

// if glyph index font is required, but this font does not support it, reject it

  MSBREAKPOINT("msCheckForGlyphIndexFont");
    if (bIndexFont && !ppfeNew->pgiset)
    {
        CHECKPRINT("CheckForGlyphIndexFont", FM_REJECT );
        ulPenaltyTotal = FM_REJECT;
        return( iRet );
    }

  MSBREAKPOINT("msCheckPitch");
    {
        jHav = (BYTE) (ifio.lfPitchAndFamily() & LOGFONT_PITCH_SET);
        jAsk =
          (BYTE) (pelfwWish->elfEnumLogfontEx.elfLogFont.lfPitchAndFamily & LOGFONT_PITCH_SET);
        ul = 0;
        if (jAsk != DEFAULT_PITCH)
        {
            if (jAsk == FIXED_PITCH)
            {
                if (jHav & VARIABLE_PITCH)
                {
                    ul = FM_WEIGHT_PITCHFIXED;
                }
            }
            else if (!(jHav & VARIABLE_PITCH))
            {
                ul = FM_WEIGHT_PITCHVARIABLE;
            }
        }
        else if (jHav & FIXED_PITCH)
        {
            ul = FM_WEIGHT_DEFAULTPITCHFIXED;
        }
        if (ul)
        {
            CHECKPRINT("Pitch",ul);
            ulPenaltyTotal += ul;
            if (bNoMatch(ppfeNew))
            {
                return( iRet );
            }
        }
    }

  MSBREAKPOINT("msCheckFamily");
    {
        jHav = (BYTE)(ifio.lfPitchAndFamily() & FF_SET);
        jAsk = (BYTE)(pelfwWish->elfEnumLogfontEx.elfLogFont.lfPitchAndFamily & FF_SET);
        if (jAsk == FF_DONTCARE)
        {
            if (jMapCharSet == SYMBOL_CHARSET)
            {
                // If the application asked for the symbol character set
                // and did not specify a family preference
                // then we should arrange it so that the choice of fonts
                // is family neutral so I set the asked for family
                // to be equal to the family of the current candidate
                // font.

                jAsk = (BYTE)(ifio.lfPitchAndFamily() & FF_SET);
            }
            else
            {
                // If the application did not specify a family preference
                // then we shall pick one for it. Normally we choose
                // Swiss except for the case where the application
                // asked for "Tms Rmn" where we ask for a Roman (serifed)
                // font.

                if (jHav != FF_DONTCARE)
                {
                    //  I have decide to excecute this family proxy
                    //  request only in the case where the font doesn't
                    //  have a family of FF_DONTCARE.  The reason for this
                    //  is interesting.  Consider the case where a font,
                    //  for what ever reason, chooses to have FF_DONTCARE
                    //  for the family.  Of course this is a bug but what
                    //  can we do.  Anyway, an application enumerates the
                    //  fonts and gets back a logical font with
                    //  FF_DONTCARE for the family.  Then suppose the
                    //  application takes that font and uses it to create
                    //  a font of its own (this is what the ChooseFont
                    //  common dialog box does all the time).  Then we
                    //  have the situation, where the logical font and the
                    //  intended font both have FF_DONTCARE for their
                    //  chosen family.  If the statement below where
                    //  excecuted, the family request would be changed to
                    //  something that does not match the physical font.
                    //  Trouble will occur if there is another font around
                    //  with the same face name or family name.  You may
                    //  not get the font you wanted because we have
                    //  erroneously added a family mismatch penalty.  (See
                    //  Bug #4912)
                    //
                    //  Tue 28-Dec-1993 09:38:29 by Kirk Olynyk [kirko]

                    jAsk = (BYTE)((fl & FM_BIT_TMS_RMN_REQUEST) ? FF_ROMAN : FF_SWISS);
                }
            }
        }
        if (jAsk != jHav)
        {
            ul = 0;
            if (jHav)
            {
                if
                (
                    // Win 3.1 dogma -- Are jAsk and jHav on opposite sides of
                    // the FF_MODERN barrier? if so, a familiy match
                    // isn't likely

                    ((jAsk <= FF_MODERN) && (jHav  > FF_MODERN)) ||
                    ((jAsk  > FF_MODERN) && (jHav <= FF_MODERN))
                )
                {
                    ul += FM_WEIGHT_FAMILYUNLIKELY;
                }
                ul += FM_WEIGHT_FAMILY;
            }
            else
            {
                ul = FM_WEIGHT_FAMILYUNKNOWN;
            }
            if (ul)
            {
                CHECKPRINT("Family",ul);
                ulPenaltyTotal += ul;
                if (bNoMatch(ppfeNew))
                {
                    return( iRet );
                }
            }
        }
    }

  MSBREAKPOINT("msCheckCharSet");

    {
        if( (jMapCharSet != DEFAULT_CHARSET) &&
            (!( fl & FM_BIT_MS_SHELL_DLG ) ))
        {
            *pjCharSet = jMapCharset(jMapCharSet, pfeo);

            if (jMapCharSet != *pjCharSet)
            {
                if( fl & FM_BIT_CHARSET_ACCEPT )
                {
                    CHECKPRINT("CharSet",FM_WEIGHT_CHARSET);
                    ulPenaltyTotal += FM_WEIGHT_CHARSET;
                    if (bNoMatch(ppfeNew))
                    {
                        return( iRet );
                    }
                }
                else
                {
                    CHECKPRINT("CharSet", FM_REJECT );
                    ulPenaltyTotal = FM_REJECT;
                    return( iRet );
                }
            }
        }
        else
        {
        // we still want to call jMapCharset, except, we do not want to give a
        // big weight to the charset, the app does not care. We still want to give
        // a small preference to the one that matches MAPPER::DefaultCharSet

            *pjCharSet = jMapCharset(jMapCharSet, pfeo);

            if ((jMapCharSet == DEFAULT_CHARSET) && !(fl & FM_BIT_MS_SHELL_DLG))
            {
                if (MAPPER::DefaultCharset != *pjCharSet)
                {
                    CHECKPRINT("CharSet",1);
                    ulPenaltyTotal += 2;
                    if (bNoMatch(ppfeNew))
                    {
                        return( iRet );
                    }
                }
            }
        }

    }

  MSBREAKPOINT("msCheckFamilyName");

    if (bEmergency)
    {
    // we only check facename in case we are in vEmergency() loop,
    // else, face name match is guaranteed.

        BOOL bAliasMatch;

        if (!pfeo.bCheckFamilyName(pwszFaceName,0, &bAliasMatch))
        {
        // no facename match, add penalty

            CHECKPRINT("FamilyName",FM_WEIGHT_FACENAME);
            ulPenaltyTotal += FM_WEIGHT_FACENAME;
        }
        else
        {
            if (bAliasMatch)
            {
            // add a small penalty for matching alias, not the real name

                CHECKPRINT("Alias Match",FM_WEIGHT_DEVICE_ALIAS);
                ulPenaltyTotal += FM_WEIGHT_DEVICE_ALIAS;
            }
        }

        if (bNoMatch(ppfeNew))
        {
            return( iRet );
        }
    }

  MSBREAKPOINT("msCheckVertAttr");
    {
    // If requested font is vertlcal face font, We have to map it to vertical
    // face font
        if ( fl & FM_BIT_VERT_FACE_REQUEST )
        {
            if ( *ifio.pwszFamilyName() != U_COMMERCIAL_AT )
            {
                CHECKPRINT("VertAttr",FM_REJECT);
                ulPenaltyTotal = FM_REJECT;
                return(iRet);
            }
        }
        else
        if (*ifio.pwszFamilyName() == U_COMMERCIAL_AT)
        {
        // if the user hasn't requested a @face font then don't map to one

            CHECKPRINT("VertAttr",FM_REJECT);
            ulPenaltyTotal = FM_REJECT;
            return(iRet);
        }
    }

    MSBREAKPOINT("msCheckHeight");
    if (!ifio.bContinuousScaling())
    {
        if (!(fl & FM_BIT_CELL) && !bCalculateWishCell())
        {
            // The transform is incompatible with a raster font.

            ulPenaltyTotal = FM_REJECT;
            #if DBG
            if (gflFontDebug & DEBUG_MAPPER)
            {
                if (fl & FM_BIT_BAD_WISH_CELL)
                {
                    DbgPrint("\t\tFM_BIT_BAD_WISH_CELL\n");
                }
            }
            #endif
            CHECKPRINT("Height", FM_REJECT);
            return( iRet );
        }

        //    Raster fonts shall be used only in the case when
        //    the transformation from World to Device
        //    coordinates is a simple scale, and the orientation
        //    angle is along either the x or y-axis.
        //
        //    The physical height to compare against is either
        //    the cell height or em-height depending upon the
        //    sign of the LOGFONT::lfHeight field passed in by
        //    the application
        //
        //    differences of over a pixel are the only ones that
        //    count so, we count pixels instead of angstroms
        //
        //    Don't reject for the height penalty if the
        //    requested char set and physical font's char set
        //    are both symbol, or if the requested font is the
        //    system font since the system font is special.

        LONG
        lDevHeight =
            (fl & FM_BIT_USE_EMHEIGHT) ? ifio.fwdUnitsPerEm() : ifio.lfHeight();

        if  (
                lDevHeight < lDevWishHeight &&
                ifio.bIntegralScaling() &&
                !(fl & FM_BIT_PROOF_QUALITY) &&
                WIN31_BITMAP_HEIGHT_SCALING_CRITERIA(lDevWishHeight,lDevHeight)
            )
        {
            LONG lTemp = WIN31_BITMAP_HEIGHT_SCALING(lDevWishHeight,lDevHeight);

            ptlSimulations.y = min(WIN31_BITMAP_HEIGHT_SCALING_MAX,lTemp);
        }
        else
        {
            ptlSimulations.y = 1;
        }

        ul = 0;
        if (ptlSimulations.y > 1)
        {
            // Check to see if the height scaling is too gross according to
            // the Win31 criteria

            if (!(fl & FM_BIT_NO_MAX_HEIGHT))
            {
                if (WIN31_BITMAP_HEIGHT_SCALING_BAD(ptlSimulations.y,lDevHeight))
                {
                  #if DBG
                    // needed by CHECKPRINT macro
                    ulPenaltyTotal = FM_REJECT;
                  #endif
                    CHECKPRINT("Height (scaling too big)",FM_REJECT);
                    return( iRet );
                }
            }

            lDevHeight *= ptlSimulations.y;
            ul += (ULONG) ptlSimulations.y * FM_WEIGHT_INT_SIZE_SYNTH;

            // This next statement is found in the Win 3.1 code. Ours is not to
            // question why.

            ul |= (ULONG) (ptlSimulations.y-1)*WIN31_BITMAP_WIDTH_SCALING_MAX;
        }

        if (lDevWishHeight >= lDevHeight)
        {
            ul += FM_WEIGHT_HEIGHT * ((ULONG) (lDevWishHeight - lDevHeight));
        }
        else
        {
            //    Under Win 3.1 the only non-scalable device fonts
            //    we run into are those from the printer UniDriver.
            //    Unfortunately, this driver has a very different
            //    idea of how font mapping is done.  It allows the
            //    realized font to be one pel larger than the
            //    request with no penalty, but otherwise the penalty
            //    is fairly prohibitive.  I am not simulating that
            //    exactly here (since it would be impossible), but I
            //    do allow the off by one miss, and then impose a 20
            //    pel penalty.  I believe this will reduce by
            //    another order of magnitude the number of font
            //    mapping differences that remain.  [chuckwh]
            //    6/12/93.

            if
            (
              (fl & (FM_BIT_DEVICE_FONT+FM_BIT_GM_COMPATIBLE))
              == (FM_BIT_DEVICE_FONT+FM_BIT_GM_COMPATIBLE)
            )
            {
                if (lDevHeight - lDevWishHeight > 1)
                {
                  ul += FM_WEIGHT_HEIGHT *
                        (
                          (ULONG)
                          (
                           lDevHeight
                           - lDevWishHeight
                           + 5 * FM_PHYS_FONT_TOO_LARGE_FACTOR
                          )
                        );
                }
            }
            else
            {
                ul += FM_WEIGHT_HEIGHT *
                      (
                        (ULONG)
                        (
                         lDevHeight
                         - lDevWishHeight
                         + FM_PHYS_FONT_TOO_LARGE_FACTOR
                        )
                      );
            }
        }

        if (ul)
        {
            CHECKPRINT("Height",ul);
            ulPenaltyTotal += ul;
            if (bNoMatch(ppfeNew))
            {
                return( iRet );
            }
            if
            (
                ul >= FM_WEIGHT_FACENAME                            &&
                !(fl & (FM_BIT_NO_MAX_HEIGHT | FM_BIT_SYSTEM_FONT))
            )
            {
                return( iRet );
            }
        }
    }

  MSBREAKPOINT("msCheckAspect");
    // 1. Check if aspect ratio filtering is turned on.
    // 2. Do not check aspect ratio if not raster.
    // 3. Win 3.1 says that the system font cannot be rejected
    //    on the basis of the aspect ratio test
    // 4. Win 3.1 style aspect ratio test.  In Win 3.1, the X and Y
    //    resolutions are checked, not the actual aspect ratio.
    // 5. [GilmanW] 10-Jun-1992
    //    For 100% Windows 3.1 compatibility we should not check the true
    //    aspect ratio.
    //
    //    But as KirkO says, lets leave it for now, as long as we comment
    //    it.  So, unless you are KirkO or GilmanW, please don't remove
    //    this comment.

    if
    (
            (pdco->pdc->flFontMapper() & ASPECT_FILTERING)
         && (ifio.lfOutPrecision() == OUT_RASTER_PRECIS)
         && !(fl & FM_BIT_SYSTEM_FONT)
         && (
             (ulLogPixelsX != (ULONG) ifio.pptlAspect()->x)
             || (ulLogPixelsY != (ULONG) ifio.pptlAspect()->y)
            )
         && (
             (ulLogPixelsX * (ULONG) ifio.pptlAspect()->y)
             != (ulLogPixelsY * (ULONG) ifio.pptlAspect()->x)
            )
    )
    {
        CHECKPRINT("Aspect", FM_REJECT);
        ulPenaltyTotal = FM_REJECT;
        return( iRet );
    }

  MSBREAKPOINT("msCheckItalic");
    if (pelfwWish->elfEnumLogfontEx.elfLogFont.lfItalic)
    {
        // if you get here then the application wants an italicized font
        // if the non simulated font is italicized already then
        // then the penalty is zero.

        if (!ifio.bNonSimItalic())
        {
            if (ifio.bSimItalic())
            {
                flSimulations |= FO_SIM_ITALIC;
                ul = FM_WEIGHT_ITALICSIM;
            }
            else
            {
                ul = FM_WEIGHT_ITALIC;
            }
            CHECKPRINT("Italic",ul);
            ulPenaltyTotal += ul;
            if (bNoMatch(ppfeNew))
            {
                return( iRet );
            }
        }
    }
    else
    {
        // The application doesn't want italicization,
        // the normal font is its best shot

        if (ifio.bNonSimItalic())
        {
            CHECKPRINT("Italic",FM_WEIGHT_ITALIC);
            ulPenaltyTotal += FM_WEIGHT_ITALIC;
            if (bNoMatch(ppfeNew))
            {
                return( iRet );
            }
        }
    }

  MSBREAKPOINT("msCheckWeight");
    {
        LONG lPen;

        lPen  = ifio.lfNonSimWeight() - lWishWeight;

        if (fl & FM_BIT_FW_DONTCARE)
        {
            lPen = NT_FAST_DONTCARE_WEIGHT_PENALTY(ABS( lPen ));

            CHECKPRINT("Weight", (DWORD) lPen );
            ulPenaltyTotal += (DWORD) lPen;
            if (bNoMatch(ppfeNew))
            {
                return( iRet );
            }
        }
        else if (lPen != 0)
        {
            if (lPen < 0)
            {
               // non simulated font isn't bold enough -> try a simulation

                lPen = -lPen;

                if(  (WIN31_BITMAP_EMBOLDEN_CRITERIA(lPen)) &&
                     (ifio.pvSimBold() != NULL) )
                {
                    flSimulations |= FO_SIM_BOLD;
                    lPen -= FM_WEIGHT_SIMULATED_WEIGHT;
                }
            }

            lPen = NT_FAST_WEIGHT_PENALTY(lPen);

            CHECKPRINT("Weight",(DWORD) lPen );
            ulPenaltyTotal += (DWORD) lPen;
            if (bNoMatch(ppfeNew))
            {
                return( iRet );
            }
        }
    }

  MSBREAKPOINT("msCheckOutPrecision");

    if (!(fl & FM_BIT_DEVICE_FONT))
    {
        // If the device is a plotter then it can't do bitmap fonts
        //
        // If you get to here we are considering the suitability of
        // a non-device font for the current device. The only case
        // where this could be a problem is if the font is a raster
        // font and the device cannot handle raster fonts.
        //
        // I have assume that a plotter can never handle a raster font.
        // Other than that the a raster font is rejected if the device
        // does not set the TC_RA_ABLE bit and the font does not tell
        // you to ignore the TC_RA_ABLE bit.

        // bodind:
        // we need to eliminate raster fonts on non square resolution printers
        // you can not get any type of wysiwig with these

        if (ifio.lfOutPrecision() == OUT_RASTER_PRECIS)
        {
            if
            (
                (fl & FM_BIT_DEVICE_PLOTTER) || (pdco->flGraphicsCaps() & GCAPS_NUP) ||
                !(((fl & FM_BIT_DEVICE_RA_ABLE) && (ulLogPixelsX == ulLogPixelsY)) 
                    || ifio.bIGNORE_TC_RA_ABLE())
            )
            {
                ulPenaltyTotal = FM_REJECT;
                CHECKPRINT("OutPrecision", FM_REJECT);
                return( iRet );
            }
        }

        // We also want to reject non-True Type fonts if the
        // msCheckOutPrecision has
        // been set to OUT_TT_ONLY_PRECIS.  [gerritv]

        if (
             (pelfwWish->elfEnumLogfontEx.elfLogFont.lfOutPrecision == OUT_TT_ONLY_PRECIS) &&
             (ifio.lfOutPrecision() != OUT_OUTLINE_PRECIS)
        )
        {
            ulPenaltyTotal = FM_REJECT;
            CHECKPRINT("OutPrecision: font isn't True Type", FM_REJECT);
            return( iRet );
        }

        // new value, reject non ps fonts

        if (
             (pelfwWish->elfEnumLogfontEx.elfLogFont.lfOutPrecision == OUT_PS_ONLY_PRECIS) &&
             !(ifio.pifi->flInfo & FM_INFO_TECH_TYPE1))
        {
            ulPenaltyTotal = FM_REJECT;
            CHECKPRINT("OutPrecision: font isn't PostScript font", FM_REJECT);
            return( iRet );
        }
    }

    // If OUT_TT_PRECIS is used,
    // the mapper gives the slight preference to screen outline font over the
    // device font, everything else being equal. The example of
    // this sitation is arial font, which exists as screen tt font
    // as well as pcl printer device font. If the lfCharSet = 0,
    // weight etc all match, using OUT_SCREEN_OUTLINE_PRECIS would allow applications
    // to choose arial screen (tt) font over arial device.
    // This is important because arial tt will typically have a larger
    // character set and the apps will want to take advantage of it.
    // The difference between this flag and OUT_TT_ONLY_PRECIS is
    // that the latter one forces outline font on screen but does not
    // give preference to outline font over device font on device.
    // Another example might be Helvetica Type 1 font, and screen version
    // may have more glyphs than the small Helvetica built
    // into pscript printers. This of course assumes atm driver installed.
    // Also, setting this flag would pick tt symbol over bitmap symbol.

    if (
         ((pelfwWish->elfEnumLogfontEx.elfLogFont.lfOutPrecision == OUT_SCREEN_OUTLINE_PRECIS)
         // the following line will ensure that when user are not specifying lfOutPrecision, 
         // TrueType will be prefered when Lpk is installed. 
         // this will ensure correct font to be choosen in Arabic/Hebrew/Shaping printing
         // while still allowing application to specify exactely what lfOutPrecision they want
         // by selecting lfOutPrecision OUT_RASTER_PRECIS, OUT_DEVICE_PRECIS or OUT_PS_ONLY_PRECIS
            || ( EngLpkInstalled() && 
               (pelfwWish->elfEnumLogfontEx.elfLogFont.lfOutPrecision != OUT_RASTER_PRECIS) &&
               (pelfwWish->elfEnumLogfontEx.elfLogFont.lfOutPrecision != OUT_DEVICE_PRECIS) &&
               (pelfwWish->elfEnumLogfontEx.elfLogFont.lfOutPrecision != OUT_PS_ONLY_PRECIS))

        // gdi will map to tt, driver will do device font substitution when it
        // finds appropriate, i.e. when glyphs needed for printout exist
        // the device font that is being substituted

            || (pdco->flGraphicsCaps() & GCAPS_SCREENPRECISION)
         ) &&
         ((fl & FM_BIT_DEVICE_FONT) || (ifio.lfOutPrecision() != OUT_OUTLINE_PRECIS))
    )
    {
        CHECKPRINT("lfOutPrecision",(DWORD) FM_WEIGHT_FAVOR_TT);
        ulPenaltyTotal += FM_WEIGHT_FAVOR_TT;
        if (bNoMatch(ppfeNew))
        {
            return( iRet );
        }
    }

  MSBREAKPOINT("msCheckWidth");
    if (!ifio.bArbXforms() && !ifio.bAnisotropicScalingOnly())
    {
        // If the physical font is scalable. I make the bold assumption
        // that any width can be achieved through linear transformation.
        // This untrue but I will try to get away with this.
        //
        // [kirko] I believe that the correct thing to do is to compare
        // the ratio of the height to with of the request and compare it
        // with the ratio of the height to width of the font in design
        // space. Then assign a penalty based upon the difference.

        LONG lDevWidth = ifio.lfWidth();
        ptlSimulations.x = 1;

        if (pelfwWish->elfEnumLogfontEx.elfLogFont.lfWidth != 0)
        {
            if (!(fl & FM_BIT_CELL) && !bCalculateWishCell())
            {
                // The transform is incompatible with a raster font.

                ulPenaltyTotal = FM_REJECT;
                #if DBG
                if (gflFontDebug & DEBUG_MAPPER)
                {
                    if (fl & FM_BIT_BAD_WISH_CELL)
                    {
                        DbgPrint("\t\tFM_BIT_BAD_WISH_CELL\n");
                    }
                }
               #endif
                CHECKPRINT("Width", FM_REJECT);
                return( iRet );
            }

            if
            (
                ifio.bIntegralScaling() &&
                !(fl & FM_BIT_PROOF_QUALITY) &&
                WIN31_BITMAP_WIDTH_SCALING_CRITERIA(lDevWishWidth, lDevWidth)
            )
            {
               // set ptlSimulations.x

                LONG lTemp = WIN31_BITMAP_WIDTH_SCALING(lDevWishWidth,lDevWidth);

                ptlSimulations.x = min(WIN31_BITMAP_WIDTH_SCALING_MAX, lTemp);
            }
            else if (ifio.bIsotropicScalingOnly())
            {
                // For simple scaling fonts, the scaling is determined by the
                // ratio of the font space height to the device space height
                // request.

                ASSERTGDI(ifio.lfHeight(),"msCheckWidth finds lfHeight == 0\n");
                {
                    lDevWidth *= lDevWishHeight;
                    lDevWidth /= ifio.lfHeight();
                }
            }
            else
            {
                // nothing needs to be done
            }

            ul = 0;
            if (ptlSimulations.x > 1)
            {
                lDevWidth *= ptlSimulations.x;
                ul +=   (ULONG) ptlSimulations.x
                      * FM_WEIGHT_INT_SIZE_SYNTH;

                // Win 3.1 compatibility dictates the next statement

                ul |= (ULONG) (ptlSimulations.x - 1);

            }
            ul +=   FM_WEIGHT_FWIDTH
                  * (ULONG) ABS(lDevWishWidth - lDevWidth);

            if (ul)
            {
                CHECKPRINT("Width",ul);
                ulPenaltyTotal += ul;
                if (bNoMatch(ppfeNew))
                {
                    return( iRet );
                }
            }
        }
        else
        {
            // If you get to here then the application has specified a width
            // of zero.
            //
            // If the application asks for proof quality then no simulations
            // are allowed. No width penalty is assessed in the case where
            // the applicaition does not specify a width.

            if (ifio.bIntegralScaling() && !(fl & FM_BIT_PROOF_QUALITY))
            {
                // since no width has been specified we must do aspect
                // ratio matching Win 3.1 style [gerritv]

                ul = 0;
                ULONG ulDevAspect, ulFontAspect, ulFontAspectSave;

                // Since FontAspects and DevAspects will usually be one we will
                // introduce some fast cases to avoid extraneous multiplies and
                // divides

                BOOL bSpeedup = FALSE;

                if (ifio.pptlAspect()->x == ifio.pptlAspect()->y)
                {
                    if (ulLogPixelsX == ulLogPixelsY)
                    {
                        // this is the common case under which
                        // we can avoid many multiplies and divides.

                        bSpeedup = TRUE;
                    }

                }

                if (!bSpeedup)
                {
                    // this is taken straight from the Win 3.1 code

                    ulDevAspect = ( ulLogPixelsY * 100 ) / ulLogPixelsX;
                    ulFontAspectSave = ( ( ifio.pptlAspect()->x * 100 ) /
                                           ifio.pptlAspect()->y );
                    ulFontAspect = ulFontAspectSave / ptlSimulations.y;
                }

                if ((!bSpeedup) || (ptlSimulations.y != 1))
                {
                    if ( (bSpeedup) ||
                         WIN31_BITMAP_ASPECT_BASED_SCALING(ulDevAspect,ulFontAspect) )
                    {
                        // divide with rounding

                        if (bSpeedup)
                        {
                            ptlSimulations.x = ptlSimulations.y;
                        }
                        else
                        {
                            ptlSimulations.x = ulDevAspect / ulFontAspect;
                        }

                        // enforce maximum scalling factor

                        ptlSimulations.x =
                          min( WIN31_BITMAP_WIDTH_SCALING_MAX, ptlSimulations.x );

                        ul +=
                         WIN31_BITMAP_WIDTH_SCALING_PENALTY((ULONG)ptlSimulations.x);

                    }
                    else
                    {
                        ASSERTGDI(ptlSimulations.x == 1, "ptlSimulations.x != 1\n");
                    }

                    if
                    (
                        (!bSpeedup) || (ptlSimulations.x != ptlSimulations.y)
                    )
                    {
                        ulFontAspect = ulFontAspectSave *
                                       ptlSimulations.x / ptlSimulations.y;

                        ULONG ulTemp = (ULONG) ABS((LONG)(ulDevAspect - ulFontAspect));

                        ul += WIN31_BITMAP_ASPECT_MISMATCH_PENALTY( ulTemp );
                    }

                    if (ul)
                    {
                        CHECKPRINT("Width",ul);
                        ulPenaltyTotal += ul;
                        if (bNoMatch(ppfeNew))
                        {
                            return( iRet );
                        }
                    }
                }
                else
                {
                    // do nothing: no scaling means no penalty
                }
            }
        }
    }

  MSBREAKPOINT("msCheckScaling");
    if
    (
        (ptlSimulations.x > 1 || ptlSimulations.y > 1)
    )
    {
        // Following Win 3.1 we penalize if there is a scaling at all.  And there
        // is an additional penalty if the scaling of the height and width
        // directions are not the same.

        #if DBG
        ULONG ulTemp = ulPenaltyTotal;
        #endif

        // Penalize for scaling at all

        ulPenaltyTotal += FM_WEIGHT_SIZESYNTH;

        // Penalize even more if the scaling is anisotropic.
        // Win 3.1 uses the hard coded factor of 100 and so do we!

        if (ptlSimulations.x > ptlSimulations.y)
        {
            ulPenaltyTotal += (ULONG)
                FM_WEIGHT_FUNEVENSIZESYNTH * MULDIV(100, ptlSimulations.x, ptlSimulations.y);
        }
        else if ( ptlSimulations.x < ptlSimulations.y )
        {
            ulPenaltyTotal += (ULONG)
                FM_WEIGHT_FUNEVENSIZESYNTH * MULDIV(100, ptlSimulations.y, ptlSimulations.x);
        }

        CHECKPRINT("msCheckScaling",ulPenaltyTotal-ulTemp);
        if (bNoMatch(ppfeNew))
        {
            return( iRet );
        }
    }

  MSBREAKPOINT("msCheckOrientation");
    if (!ifio.bArbXforms())
    {
        // Either this matches or it doesn't. The penalty is either
        // maximally prohibitive or it is zero.
        //
        // Discussion:
        //
        // All vector fonts are assumed to be OK
        //
        // Raster Font are OK (1) The requested baseline
        // direction agrees with the direction of the raster
        // font (2) The transformation from world to device
        // coordinates is the combination of a scale and a
        // rotation by a multiple of 90 degrees.  This means
        // that we will reject if a reflection exists or if
        // there is shear.
        //
        // I shall make the assumption that raster fonts can be
        // used only in the case where the notional to device
        // transformation is a simple scale followed by a rotation
        // that is a multiple of 90 degrees.  This means that the
        // baseline in device space is along either the x-axis or
        // y-axis.  Moreover, the acender direction must be
        // perpendicular to the baseline.  There are a lot of
        // cases where this could happen.  For example, suppose
        // that the original orientation was alpha, and their was
        // a world to device transformation that was 90 degrees
        // minus alpha.  The resulting orientation would be along
        // one of the axes.  However, I will not check for such a
        // coincidence.  I will allow only cases where the
        // original orientation in world coordinates is a multiple
        // of 90 degrees, and the world to device transformation
        // is a simple combination of scales and rotations by 90
        // degrees.
        //
        // The orientation should have been computed when we
        // checked heights above.
        //
        // Under Win 3.1 we cannot reject a font because of orientation
        // mismatch if it the device is the screen

        if (!((fl & FM_BIT_GM_COMPATIBLE) && (fl & FM_BIT_DISPLAY_DC)))
        {
            ul = 1;

            if ((fl & FM_BIT_ORIENTATION) || bCalcOrientation())
            {
                ul = (ULONG) iOrientationDevice - pfeo.iOrientation();

                if (ul && (fl & FM_BIT_DEVICE_CR_90_ALL) && (fl & FM_BIT_DEVICE_FONT))
                {
                    if (ul > (ULONG) iOrientationDevice)
                    {
                        ul = (ULONG) (- (LONG) ul);
                    }
                    ul = ul % ORIENTATION_90_DEG;
                }

                if (ul && ifio.b90DegreeRotations())
                {
                    if (ul > (ULONG) iOrientationDevice)
                    {
                        ul = (ULONG) (- (LONG) ul);
                    }
                    ul = ul % ORIENTATION_90_DEG;
                }
            }
            if ( ul )
            {
                ulPenaltyTotal = FM_REJECT;
                CHECKPRINT("Orientation",FM_REJECT);
                return( iRet );
            }
        }
    }

  MSBREAKPOINT("msCheckAlias");
    {
        // Checks to see if the font is really an alias for a device font.
        //
        // Discussion:
        //
        // In the Win/WFW3.1 architecture, the device drivers get
        // a chance to do font mapping.  Some device drivers, like
        // the PostScript driver and the HP PCL drivers, allow
        // some of the device fonts to be aliased to other names.
        // For example, while the PostScript printer might
        // physically have a "Helvetica" font, the driver allows
        // "Helv", "Arial", and "Swiss" to be mapped to it (with
        // only a small penalty).  More precisely, "Helv" et.  al
        // are in the "Helvetica" equivalence class.
        //
        // We do not want such a font to be returned without error.
        // Otherwise, if we return this as an exact match, we will not
        // be able to map to REAL fonts that may exist in the engine.
        // For example, since "Arial" is in the equivalence class for
        // "Helvetica", without a penalty we may return "Helvetica" as
        // an exact match.  This shorts out the mapper before it can
        // get to the TrueType "Arial" that REALLY exists as an engine
        // font.  Therefore, we will impose a slight penalty for
        // aliased fonts.
        //
        //
        // If the FM_BIT_EQUIV_NAME bit is set, the font list we are
        // looking at is really an aliased font name for a device font.

        if (fl & FM_BIT_EQUIV_NAME)
        {
            ulPenaltyTotal += FM_WEIGHT_DEVICE_ALIAS;
            if ( bNoMatch(ppfeNew) )
            {
                return( iRet );
            }
        }
    }

// The last thing we do is always design vector.
// If everything else matchhes exactly but the design vector
// we will record the pfe and have the atm driver create the instance
// corresponding to this design vector.

  MSBREAKPOINT("msCheckDesignVector");

    {
        DESIGNVECTOR *pdv, *pdvWish;

        if (fl & FM_BIT_BASENAME_MATCHED)
        {
        // the name takes precedance, ie if we have explicit dv == [UU,VV]
        // as well as dv specified through font's family
        // name of the form foo_XX_YY, we ignore dv in ENUMLOGFONTEXDV
        // and use the one specified by the name, [XX,YY] in this case.

            pdvWish = &dvWish;
        }
        else
        {
            pdvWish = (DESIGNVECTOR *)&pelfwWish->elfDesignVector;
        }

        if (pdvWish->dvNumAxes)
        {
            pdv = ifio.pdvDesVect();

            if
            (
                pdv  && pdv->dvNumAxes                 &&
                (pdvWish->dvNumAxes == pdv->dvNumAxes) &&
                (ulPenaltyTotal <= 35000)
            )
            {
                ppfeMMInst = ppfeNew;
            }

            if
            (
                !pdv                                   ||
                (pdvWish->dvNumAxes != pdv->dvNumAxes) ||
                memcmp(pdvWish->dvValues, pdv->dvValues, pdv->dvNumAxes*sizeof(LONG))
            )
            {

                CHECKPRINT("DesignVector",FM_REJECT);
                ulPenaltyTotal = FM_REJECT;
                return(iRet);
            }


        }
    }

    // We are all done!

    return( TRUE );
}

/******************************Member*Function*****************************\
* IFIOBJ::lfOrientation                                                    *
*                                                                          *
* Returns the Orientation (angle of the baseline in tenths of degrees      *
* measured counter clockwise from the x-axis) in device space.             *
*                                                                          *
* History:                                                                 *
*  Thu 17-Dec-1992 16:22:56 -by- Charles Whitmer [chuckwh]                 *
* Changed the easy case to wierd bit manipulation.                         *
*                                                                          *
*  Tue 24-Sep-1991 10:54:24 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

LONG IFIOBJ::lfOrientation()
{
    INT sx = SIGNUM(pifi->ptlBaseline.x);
    INT sy = SIGNUM(pifi->ptlBaseline.y);

    if ((sx^sy)&1)      // I.e. if exactly one of them is zero...
    {
    // Return the following angles:
    //
    //   sx = 00000001 :    0
    //   sy = 00000001 :  900
    //   sx = FFFFFFFF : 1800
    //   sy = FFFFFFFF : 2700

        return( (sx & 1800) | (sy & 2700) | ((-sy) & 900) );
    }

   // Do the hard case.

    LONG lDummy;

    EFLOATEXT efltX(pifi->ptlBaseline.x);
    EFLOATEXT efltY(pifi->ptlBaseline.y);

    EFLOAT efltTheta;
    vArctan(efltX, efltY, efltTheta, lDummy);

    *(EFLOATEXT*) &efltTheta *= (LONG) 10;

    return( efltTheta.bEfToL(lDummy) ? lDummy : 0 );
}

/******************************Public*Routine******************************\
* MAPPER::bFoundExactMatch()                                               *
*                                                                          *
* This routine searches for a match to an extended logical font.           *
* It is assumed that the face name has infinite weight. Therefore          *
* the face name is searched for in the hash table that is provided by      *
* the caller. If the name is found, then the best match is searched for    *
* among the elements of the linked list of PFE's containing the same       *
* face name.                                                               *
*                                                                          *
* If the name is found, then the MAPFONT_FOUND_NAME flag is set in         *
* pflAboutMatch.  If the name was found by using facename substitution     *
* (ie., alternate facename), then the MAPFONT_ALTNAME_USED flag is also    *
* set.                                                                     *
*                                                                          *
* The return value of the function report whether the match was exact.     *
* This information is actually redundant. It could be retrived by          *
* looking at mapper.ulPenaltyTotal                                         *
*                                                                          *
* Important Operating Principles                                           *
*                                                                          *
*   1. The value pointed to pppfeRet is modified only if i) an the name    *
*      is matched, and ii) the match is better than any found previously   *
*                                                                          *
* History:                                                                 *
*  Fri 18-Dec-1992 04:57:29 -by- Charles Whitmer [chuckwh]                 *
* Rewrote it for performance.  One major change is that I only take the    *
* winning PFE and move it to the front of the list, rather than            *
* continually shuffling the list.  This cuts down overhead and should      *
* have about the same effect.                                              *
*                                                                          *
*  Wed 22-Apr-1992 10:47:50 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/


BOOL
MAPPER::bFoundExactMatch(
    FONTHASH **ppfh
    )
{
    PFELINK *ppfelBest = NULL, *ppfel;

    PWSZ         pwszTarg;

    HASHBUCKET  *apbkt[3];
    BYTE         ajCharSet[3];

    FONTHASHTYPE fht;
    int i,iBest;
    BOOL bRet = FALSE;
    BYTE jCharSet = DEFAULT_CHARSET;

    // This is returned as the *pflAboutMatch in the MAPPER class if and only
    // if we find a better match.  So we store it temporarily in this local
    // rather than set it directly.

    *pflAboutMatch &= ~MAPFONT_FOUND_NAME;

    FHOBJ fho(ppfh);
    if (!fho.bValid())
    {
        return( bRet );
    }
    fht = fho.fht();

    // Note well: mapper.pwszFaceName must ALWAYS be CAPITALIZED!

    pwszTarg = this->pwszFaceName;

    // Attempt to locate the name.

#define I_ORIGINAL  0
#define I_ALTERNATE 1
#define I_BASE 2

    apbkt[I_ORIGINAL] = apbkt[I_ALTERNATE] = apbkt[I_BASE] = NULL;
    ajCharSet[I_ORIGINAL]  =
    ajCharSet[I_BASE] =
    ajCharSet[I_ALTERNATE] = (BYTE)pelfwWish->elfEnumLogfontEx.elfLogFont.lfCharSet;

    FONTSUB* pfsub = pfsubGetFontSub(pwszTarg,
                       (BYTE)pelfwWish->elfEnumLogfontEx.elfLogFont.lfCharSet);

    if (pfsub)
    {
    // charsets specified or not in the substitution entry ?

        if (pfsub->fcsAltFace.fjFlags & FJ_NOTSPECIFIED)
        {
        // old style substitution, no charsets are specified
        // First search for the facename on the left hand side,
        // if not found search for the one on the right hand side.
        // In both cases use the original charset in the logfont.

            apbkt[I_ORIGINAL] = fho.pbktSearch(pwszTarg,(UINT*)NULL);
            apbkt[I_ALTERNATE] = fho.pbktSearch((PWSZ)pfsub->fcsAltFace.awch,(UINT*)NULL);
        }
        else
        {
        // charsets are specified in the font substitution entry.

        // When the charset requested in the logfont matches the one on
        // the left hand side of the substitution, we shall actually go
        // for the alternate facename and charset, without even looking
        // if the font with facename and charset specified on the left
        // hand side is installed on the system.
        // This is win95 behavior which actually makes some sense.

            apbkt[I_ALTERNATE] = fho.pbktSearch((PWSZ)pfsub->fcsAltFace.awch,(UINT*)NULL);
            ajCharSet[I_ALTERNATE] = pfsub->fcsAltFace.jCharSet;
        }
    }
    else
    {
        apbkt[I_ORIGINAL] = fho.pbktSearch(pwszTarg,(UINT*)NULL);
    }

// now search for the bucket corresponding to the cannonical name if any
// We will only do this for FAMILY i.e menu names, not for face names:

    if (awcBaseName[0] && (fht == FHT_FAMILY))
        apbkt[I_BASE] = fho.pbktSearch(this->awcBaseName,(UINT*)NULL, NULL, FALSE);

    if (!apbkt[I_ORIGINAL] && !apbkt[I_ALTERNATE] && !apbkt[I_BASE])
    {
        return( bRet );
    }

    // If we get to here,  we were able to find a hash bucket
    // of the correct name.

    *pflAboutMatch |= MAPFONT_FOUND_NAME;
    fl |= FM_BIT_FACENAME_MATCHED;

    // Scan the PFE list for the best match.

    for (i = 0; i < 3; i++)
    {
        if (!apbkt[i])
        {
            continue;
        }

        vResetCharSet(ajCharSet[i]);

        if (apbkt[i]->fl & HB_EQUIV_FAMILY)
        {
            fl |= FM_BIT_EQUIV_NAME;
        }
        else
        {
            fl &= ~FM_BIT_EQUIV_NAME;
        }

        if (i == I_BASE)
        {
            fl |= FM_BIT_BASENAME_MATCHED;
        }
        else
        {
            fl &= ~FM_BIT_BASENAME_MATCHED;
        }

        for
        (
            ppfelBest = NULL, ppfel = apbkt[i]->ppfelEnumHead;
            ppfel;
            ppfel = ppfel->ppfelNext
        )
        {
            #if DBG
            if (gflFontDebug & DEBUG_MAPPER && ppfel->ppfe == ppfeBreak)
            {
                DbgPrint("    **** breaking on ppfel = %-#8lx\n\n", ppfel);
                DbgBreakPoint();
            }
            #endif

            PFEOBJ pfeo(ppfel->ppfe);

            if (this->bNearMatch(pfeo,&jCharSet))
            {
                DUMP_CHOSEN_FONT(pfeo);
                iBest     = i;

                // remember the good one

                ppfelBest = ppfel;

                // remember the simulation information for the best font
                // choice to this time

                vSetBest(ppfel->ppfe, fl & FM_BIT_DEVICE_FONT, jCharSet);

                if (this->ulPenaltyTotal == 0)
                {
                    //  If the match was exact, return immediately unless
                    //  there this is a true type font and there are
                    //  rasterfonts of the same face name.  In this case
                    //  we must give the rasterfonts a chance since in the
                    //  event of a tie, the raster font must win to be Win
                    //  3.1 compatibile!

                    if( !( apbkt[i]->cRaster ) ||
                              ( pfeo.flFontType() & RASTER_FONTTYPE ))
                    {
                        bRet = TRUE;
                        break;
                    }

                    // we need to give the raster fonts a chance we do this
                    // by setting ulPenaltyTotal to 1.
                    // This way only an exact match will beat us out.

                    this->ulPenaltyTotal = 1;
                }

                // prune the search

                this->ulMaxPenalty = this->ulPenaltyTotal;
            }
            else
            {
                DUMP_REJECTED_FONT(pfeo);
            }

        }
        if (bRet == TRUE)
        {
            break;
        }
    }
    // Return a good one if we found it.

    if (ppfelBest)
    {
        // We found a better match, so better change the about flags.

        if (iBest == I_ALTERNATE || fht == FHT_FACE)
        {
            *pflAboutMatch |= MAPFONT_ALTFACE_USED;
        }

        //  record code page, needed for correct code page to
        //  unicode translation In case of single charset
        //  font, we always cheat and represent the font
        //  glyphset using ansi to unicode conversion using
        //  the current ansi code page, even though the
        //  underlining font may contain a symbol or an oem
        //  code page.  But we do not care, we just need to
        //  make the round trip a->u->a works for these fonts.
        //  Also we want the client side cacheing of char
        //  widths for GTE and GCW to work for these fonts.
    // there are two exceptions to this rule: 1) the default ansi code page is
    // not SBCS since this doesn't guarantee roundtrupe conversion and
    // 2) the charset of the font is DBCS

        ULONG ulCodePage;

    // the best charset so far is remembered in pflAboutMatch

        BYTE  jBestCharSet = (BYTE)(*pflAboutMatch >> 24);

        if
        (
            (jBestCharSet != OEM_CHARSET)             ||
            ppfelBest->ppfe->pifi->dpCharSets         ||
            (ppfelBest->ppfe->flPFE & PFE_DEVICEFONT) ||
            IS_ANY_DBCS_CHARSET(jBestCharSet)
        )
        {
            ulCodePage = ulCharsetToCodePage(jBestCharSet);
        }
        else
        {
        // just use 1252 if the default CP is not SBCS

            ulCodePage = (gbDBCSCodePage) ? 1252 : CP_ACP;
        }
        *pflAboutMatch |= (ulCodePage << 8);
    }
    fl &= ~FM_BIT_EQUIV_NAME;
    return( bRet );
}



/****************************************************************************
* MAPPER::bFoundForcedMatch( PUNIVERSAL_FONT_ID pufi )
*
* This routine forces mapping to a PFE identified by a UFI.  It will compute
* simulations to be performed on the font as well.

*  History:
*   Oct-21-97   by Xudong Wu  [tessiew]
*  Disable the ufi matching for device fonts
*   5/11/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*****************************************************************************/


BOOL MAPPER::bFoundForcedMatch(UNIVERSAL_FONT_ID *pufi)
{
    #if DBG
    if (gflFontDebug & DEBUG_MAPPER)
    {
        DbgPrint("MAPPER::bFoundForcedMatch: " );
        DbgPrint("CheckSum = %x Index = %d\n", pufi->CheckSum, pufi->Index );
    }
    #endif
    PFE *ppfe;

    // for device font, the ufi on the print server side
    // might not match the one on the client side
    // so we don't use the ufi-match on device fonts any more

    if(UFI_DEVICE_FONT(pufi))
    {
        ppfe = NULL;
    }
    else if(UFI_TYPE1_FONT(pufi))
    {
        DEVICE_PFTOBJ pftoDevice;
        FONTHASH **ppfh = (FONTHASH**) NULL;
        PFF *pPFF;

        if (pPFF = pftoDevice.pPFFGet(pdco->hdev()))
        {
            PFFOBJ pffo(pPFF);

            if (pffo.bValid())
            {
                ppfh = &pffo.pPFF->pfhFamily;
            }
        }

        if (ppfh == (FONTHASH**) NULL)
        {
            WARNING1("MAPPER::bFoundForcedMatch() -- invalid FONTHASH\n");
            return( FALSE );
        }

        // Prepare to enumerate through all the device fonts

        ENUMFHOBJ fho(ppfh);
        for (ppfe = fho.ppfeFirst(); ppfe; ppfe = fho.ppfeNext())
        {
            PFEOBJ pfeo(ppfe);

            if (UFI_SAME_FACE(pfeo.pUFI(), pufi))
            {
                if( pfeo.bDead() )
                {
                    WARNING("MAPPER::bFoundForcedMatch mapped to dead PFE\n");
                }
                else
                {
                    break;
                }
            }
        }
    }
    else
    {
        ppfe = ppfeGetPFEFromUFI(pufi,
                                 FALSE, // public font table
                                 TRUE); // check process

    }

    if ( ppfe == NULL )
    {
        WARNING1("MAPPER::bFoundForcedMatch unable to find forced match\n");
        return( FALSE );
    }

    // If we are here we found the right PFE,
    // now we need to compute ptlSim and flSim.

    ptlSimulations.x = 1;
    ptlSimulations.y = 1;
    flSimulations = 0;

    PFEOBJ pfeo(ppfe);

    ifio.vSet( pfeo.pifi() );

    // first compute any possible height simulations

    if (!ifio.bContinuousScaling())
    {
        LONG
        lDevHeight =
            (fl & FM_BIT_USE_EMHEIGHT) ? ifio.fwdUnitsPerEm() : ifio.lfHeight();
        if  (
                lDevHeight < lDevWishHeight &&
                ifio.bIntegralScaling() &&
                !(fl & FM_BIT_PROOF_QUALITY) &&
                WIN31_BITMAP_HEIGHT_SCALING_CRITERIA(lDevWishHeight,lDevHeight)
            )
        {
            LONG lTemp = WIN31_BITMAP_HEIGHT_SCALING(lDevWishHeight,lDevHeight);

            ptlSimulations.y = min(WIN31_BITMAP_HEIGHT_SCALING_MAX,lTemp);
        }
        else
        {
            ptlSimulations.y = 1;
        }
    }

    // next check for italic simulations

    if (pelfwWish->elfEnumLogfontEx.elfLogFont.lfItalic)
    {
    // if you get here then the application wants an italicized font

        if (!ifio.bNonSimItalic() && ifio.bSimItalic())
        {
            flSimulations |= FO_SIM_ITALIC;
        }
    }

    // bold simulations

    LONG lPen;

    lPen = ifio.lfNonSimWeight() - lWishWeight;

    if( !(fl & FM_BIT_FW_DONTCARE) && (lPen < 0 ) )
    {

         // non simulated font isn't bold enough -> try a simulation

        lPen = -lPen;

        if(  (WIN31_BITMAP_EMBOLDEN_CRITERIA(lPen)) &&
             (ifio.pvSimBold() != NULL) )
        {
            flSimulations |= FO_SIM_BOLD;
        }
    }

    // width simulations

    if (!ifio.bArbXforms() && !ifio.bAnisotropicScalingOnly())
    {
        LONG lDevWidth = ifio.lfWidth();
        ptlSimulations.x = 1;

        if (pelfwWish->elfEnumLogfontEx.elfLogFont.lfWidth != 0)
        {
            if( !(fl & FM_BIT_CELL) )
            {
                bCalculateWishCell();
            }

            if
            (
                ifio.bIntegralScaling() &&
                !(fl & FM_BIT_PROOF_QUALITY) &&
                WIN31_BITMAP_WIDTH_SCALING_CRITERIA(lDevWishWidth, lDevWidth)
            )
            {
               // set ptlSimulations.x

                LONG lTemp = WIN31_BITMAP_WIDTH_SCALING(lDevWishWidth,lDevWidth);

                ptlSimulations.x = min(WIN31_BITMAP_WIDTH_SCALING_MAX, lTemp);
            }
        }
        else
        {
            if (ifio.bIntegralScaling() && !(fl & FM_BIT_PROOF_QUALITY))
            {
                // since no width has been specified we must do aspect
                // ratio matching Win 3.1 style [gerritv]

                ULONG ulDevAspect, ulFontAspect, ulFontAspectSave;

                // Since FontAspects and DevAspects will usually be one we will
                // introduce some fast cases to avoid extraneous multiplies and
                // divides

                BOOL bSpeedup = FALSE;

                if (ifio.pptlAspect()->x == ifio.pptlAspect()->y)
                {
                    if (ulLogPixelsX == ulLogPixelsY)
                    {
                        // this is the common case under which
                        // we can avoid many multiplies and divides.

                        bSpeedup = TRUE;
                    }
                }

                if (!bSpeedup)
                {
                    // this is taken straight from the Win 3.1 code

                    ulDevAspect = ( ulLogPixelsY * 100 ) / ulLogPixelsX;

                    ulFontAspectSave = ( ( ifio.pptlAspect()->x * 100 ) /
                                           ifio.pptlAspect()->y );

                    ulFontAspect = ulFontAspectSave / ptlSimulations.y;
                }

                if ((!bSpeedup) || (ptlSimulations.y != 1))
                {
                    if
                    (
                         (bSpeedup) ||
                         WIN31_BITMAP_ASPECT_BASED_SCALING(ulDevAspect,ulFontAspect)
                    )
                    {
                        // divide with rounding

                        if (bSpeedup)
                        {
                            ptlSimulations.x = ptlSimulations.y;
                        }
                        else
                        {
                            ptlSimulations.x = ulDevAspect / ulFontAspect;
                        }

                        // enforce maximum scalling factor

                        ptlSimulations.x =
                          min( WIN31_BITMAP_WIDTH_SCALING_MAX, ptlSimulations.x );
                    }
                    else
                    {
                        ASSERTGDI(ptlSimulations.x == 1, "ptlSimulations.x != 1\n");
                    }
                }
            }
        }
    }

// need to do this here because vSetBest will update ptlSim and pflSim
// Another important point to note here is that the charset and code page
// needed for ansi to unicode conversion will remain uninitialized.
// I think that this is ok because for metafile spooled printing the text is
// always going to recorded as unicode so that this conversion will never
// have to be performed [bodind]

    vSetBest( ppfe, TRUE, DEFAULT_CHARSET );

    #if DBG
    if (gflFontDebug & DEBUG_MAPPER)
    {
        DbgPrint("MAPPER::bFoundForcedMatch: ppfeBest = %-#x\n", ppfeBest );
    }
    #endif
    return( TRUE );
}



/******************************Public*Routine******************************\
* ppfeGetAMatch                                                            *
*                                                                          *
* Returns the best fit to a wish defined by the application.               *
*                                                                          *
* History:                                                                 *
*  Wed 11-Dec-1991 09:32:11 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

PFE *ppfeGetAMatch (
    XDCOBJ&        dco,         // The DC defines all the relevant
                                // transformations and physical
                                // sizes to be used to determine
                                // the suitablity of a font

    ENUMLOGFONTEXDVW  *pelfwWishSrc,  // defines the font that is wished
                                // for by the application

    PWSZ  pwszFaceName,         // The sought name.

    ULONG ulMaxPenalty,         // a cutoff for the sum of all the
                                // individual penalties of each of the
                                // fields of the LOGFONT structure.
                                // If the sum of all the penalties
                                // associated with a physical font
                                // is greater than this cutoff, then
                                // the phyisical font is rejected
                                // as a potential match.

    FLONG fl,                   // This is a set of flags defining
                                // how mapping is to proceed and/or
                                // various parameters are to be
                                // interpreted. The flags that are
                                // supported are:
                                //
                                // FM_BIT_PIXEL_COORD
                                //
                                //  If this flag is not present, then the
                                //  dimensionful quantities in the
                                //  logical font are in world coordinates.
                                //  If this flag is present then the
                                //  dimensionful (length like) quantities
                                //  in the logical font are in pixel
                                //  coordinates (one unit = one pixel).
                                //  This bit is set only for stock
                                //  fonts, which are defined by the device
                                //  driver and are to be transformation
                                //  independent.

    FLONG *pflSim,              // a place to put the simulation
                                // flags.

    POINTL *pptlSim,            // this recieves the height- and width-
                                // scaling factor for bitmap fonts

    FLONG *pflAboutMatch,       // This returns information about how
                                // the match was achieved.  Flags
                                // supported are:
                                //
                                // MAPFONT_FOUND_NAME
                                //
                                //  This flag indicates that a facename
                                //  was found by the mapper.
                                //
                                // MAPFONT_ALTFACE_USED
                                //
                                //  This flag indicates that the facename
                                //  found was an alternate or substitute
                                //  facename.
    BOOL   bIndexFont_          //  font MUST support ETO_GLYPH_INDEX
)
{
    ASSERTGDI(!(fl & ~FM_BIT_PIXEL_COORD),"GDISRV!ppfeGetAMatch -- invalid fl\n");

    PPFEGETAMATCH_DEBUG_MACRO_1;

    MAPPER
        mapper(
            &dco
          , pflSim
          , pptlSim
          , pflAboutMatch
          , pelfwWishSrc
          , pwszFaceName
          , ulMaxPenalty
          , bIndexFont_
          , fl
            );

    // Currently there is no way for the MAPPER constructor
    // to fail.  In the future it may be able to fail and we
    // will need to check here.

    ASSERTGDI(mapper.bValid(),"GDISRV!ppfeGetAMatch -- invalid mapper\n");

    #if DBG
    if (gflFontDebug & DEBUG_DUMP_FHOBJ)
    {
        if (mapper.bDeviceFontsExist())
        {
            DEVICE_PFTOBJ pftoDevice;
            PFFOBJ pffo(pftoDevice.pPFFGet(dco.pdc->hdev()));
            if (pffo.bValid())
            {
                FHOBJ fhoFamily(&pffo.pPFF->pfhFamily);
                FHOBJ fhoFace(&pffo.pPFF->pfhFace);

                DbgPrint("\n\n\tDumping Device Family Names\n");
                fhoFamily.vPrint((VPRINT) DbgPrint);

                DbgPrint("\n\n\tDumping Device Face Names\n");
                fhoFace.vPrint((VPRINT) DbgPrint);
            }
        }
        else
        {
            DbgPrint("\n\tTHERE ARE NO DEVICE FONTS!\n\n");
        }
        PUBLIC_PFTOBJ pfto;
        FHOBJ fhoFamily(&pfto.pPFT->pfhFamily);
        FHOBJ fhoFace(&pfto.pPFT->pfhFace);

        DbgPrint("\n\n\tDumping Engine Family Names\n");
        fhoFamily.vPrint((VPRINT) DbgPrint);
        DbgPrint("\n\n\tDumping Engine Face   Names\n");
        fhoFace.vPrint((VPRINT) DbgPrint);
    }
    #endif

    UNIVERSAL_FONT_ID ufi;
    if( dco.pdc->bForcedMapping( &ufi ) )
    {
        // If we got here we are playing back an EMF spoolfile
        // which was generated on a remote machine.  We must do
        // forced mapping based on UFI's

        if( mapper.bFoundForcedMatch(&ufi) )
        {
            PPFEGETAMATCH_DEBUG_RETURN(mapper.ppfeRet());
        }
        else
        {
            WARNING1("ppfeGetAMatch: bFoundForceMatch "
                     "failed to find a match");
        }
    }

    // check the Private PFT before device and public PFT if gpPFTPrivate != NULL
    // We do not want to go through small font hack for private fonts.

    if (gpPFTPrivate && gpPFTPrivate->cFiles)
    {
        PUBLIC_PFTOBJ pftoPrivate(gpPFTPrivate);
        mapper.vNotDeviceFonts();   // put mapper in "check engine fonts" state

        if
        (
             mapper.bFoundExactMatch(&pftoPrivate.pPFT->pfhFamily) ||
             mapper.bFoundExactMatch(&pftoPrivate.pPFT->pfhFace)
        )
        {
            PPFEGETAMATCH_DEBUG_RETURN(mapper.ppfeRet());
        }
    }

    // check the device fonts first (if they exist)

    DEVICE_PFTOBJ pftoDevice;
    if (mapper.bDeviceFontsExist())
    {
        PFF *pPFF;

        // put mapper in "check device fonts" state

        mapper.vDeviceFonts();

        if (pPFF = pftoDevice.pPFFGet(dco.hdev()))
        {
            PFFOBJ pffo(pPFF);
            if (pffo.bValid())
            {
                if
                (
                    mapper.bFoundExactMatch(&pffo.pPFF->pfhFamily) ||
                    mapper.bFoundExactMatch(&pffo.pPFF->pfhFace)
                )
                {
                    PPFEGETAMATCH_DEBUG_RETURN(mapper.ppfeRet());
                }
            }
            if( mapper.bDeviceOnly() )
            {
                //
                // If the device insists that we use only its fonts then
                // we will do so. If the application requested a device
                // font then we will map to that font and that font
                // is contained in mapper.ppfeRet(). Otherwise, if the
                // application asked for a face name that is not contained
                // in the list of device fonts, then the current value
                // of mapper.ppfeRet() will be NULL. In that case we
                // will simply map to an arbitrary device font without
                // regard to the size requested by the application.
                // Caveat Emptor.
                //

                PFE *ppfeRet;

                ppfeRet = mapper.ppfeRet();

                if (ppfeRet == 0 || ppfeRet->pPFF != pPFF)
                {
                    *pflSim = 0;
                    *pflAboutMatch = 0;
                    pptlSim->x = pptlSim->y = 1;

                    FONTHASH **ppfh = &pffo.pPFF->pfhFamily;
                    ENUMFHOBJ fho(ppfh);
                    ppfeRet = fho.ppfeFirst();
                }

                PPFEGETAMATCH_DEBUG_RETURN( ppfeRet );
            }
        }
    }

    // If an exact match was not found check the Engine fonts

    PUBLIC_PFTOBJ pftoPublic;
    mapper.vNotDeviceFonts();   // put mapper in "check engine fonts" state
    if
    (
         mapper.bFoundExactMatch(&pftoPublic.pPFT->pfhFamily) ||
         mapper.bFoundExactMatch(&pftoPublic.pPFT->pfhFace)
    )
    {
        PPFEGETAMATCH_DEBUG_RETURN(mapper.ppfeRet());
    }

    // If you get here, and ppfeRet != 0 then then lfFaceName
    // has been matched by either the device or gdi.  In either
    // case, we terminate the search and return the best match
    // found.  This is somewhat incompatible with Windows 3.1
    // which considers FaceName less important that pitch
    // and family.  Windows 3.1 would continue the search over
    // all available fonts in order to get a better match.

    if (mapper.ppfeRet())
    {
        PPFEGETAMATCH_DEBUG_RETURN(mapper.ppfeRet());
    }

    // At this point we know that no exact match will be found
    // amongst the fonts installed on the system at this time.
    // We shall therefore try to see if this was a request for mm instance
    // for an mm font whose other instance is installed and create the
    // requested instance dynamically.
    // In the future we may exted this function to go out and search for the
    // font that has not been addfontresource'ed at this time
    // (perhaps by calling to font drivers, or maybe not)
    // and install it dynamically.

    PFE *ppfeRet = mapper.ppfeSynthesizeAMatch(pflSim, pflAboutMatch, pptlSim);

    if (ppfeRet)
    {
        PPFEGETAMATCH_DEBUG_RETURN(ppfeRet);
    }

    // If you get to here then the face name has not been found
    // in either the Device or GDI fonts. A font of a different
    // face name will have to be substituted. Try to match to a
    // Device font, but the match better be a good one!

    if (!(dco.flGraphicsCaps() & GCAPS_SCREENPRECISION))
    {
        if (mapper.bDeviceFontsExist())
        {
            mapper.vAttemptDeviceMatch();
            if (mapper.ppfeRet())
            {
                PPFEGETAMATCH_DEBUG_RETURN(mapper.ppfeRet());
            }
        }
    }
    // Well ... we are left with attempting to match to GDI fonts.
    // Since the original request face name was a flop,
    // I will attempt a suitable GDI FaceName.

    if( !(mapper.bCalled_bGetFaceName()))
    {
        #if DBG
        if (gflFontDebug & DEBUG_MAPPER)
            DbgPrint("\n\tAttempting to match to an"
                 " engine font of a different name\n");
        #endif
        mapper.bGetFaceName();
        mapper.vReset();
        mapper.vNotDeviceFonts();   // put mapper in "check engine fonts" state
        if
        (
            mapper.bFoundExactMatch(&pftoPublic.pPFT->pfhFamily) ||
            mapper.bFoundExactMatch(&pftoPublic.pPFT->pfhFace)
        )
        {
            PPFEGETAMATCH_DEBUG_RETURN(mapper.ppfeRet());
        }
        if (mapper.ppfeRet())
        {
            PPFEGETAMATCH_DEBUG_RETURN(mapper.ppfeRet());
        }
    }

    // Up until now we've reject fonts whose charset doesn't
    // match the requested charset even though the facename
    // matches.  At this point we allow for the possibility
    // of chosing a font whose charset doesn't match.  However,
    // we will make the penalty so high that for such a font that
    // if any other font exists whose charset does match,
    // it will alwats beat the font whose charset doesn't match.


    mapper.vAcceptDiffCharset();


    // We are in big trouble now! To recount the story to this point.
    // We have failed to match the facename against either the device
    // or engine fonts. Then we failed to match against any device font
    // even though we ignored the name. Finally, we could not match
    // default facenames against the GDI fonts.
    // Now we call the emergency routine that gets a font, any font.

    mapper.vEmergency();

    // Either vEmergency() got a font or it didn't. It doesn't matter,
    // we have no choice but to return at this point.

    PPFEGETAMATCH_DEBUG_RETURN(mapper.ppfeRet());
}
/******************************Member*Function*****************************\
* MAPPER::vAttemptDeviceMatch()                                            *
*                                                                          *
* Considers every device font and tries to find the best match.            *
* Facenames are ignored.                                                   *
*                                                                          *
* History:                                                                 *
*  Thu 11-Mar-1993 15:44:59 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

VOID MAPPER::vAttemptDeviceMatch()
{
    FONTHASH **ppfh      = (FONTHASH**) NULL;
    PFE       *ppfeRet   = (PFE*)       NULL;
    PFE       *ppfe;
    BYTE       jCharSet = DEFAULT_CHARSET;

    #if DBG
    if (gflFontDebug & DEBUG_MAPPER)
    {
        DbgPrint("\n\tMAPPER::vAtteptDeviceMatch()\n");
    }
    #endif

    // If the application asked for symbol then I will only allow GDI
    // to do font substitution. This request will probably end with
    // WingDings

    if (jMapCharSet == SYMBOL_CHARSET)
    {
        return;
    }

    DEVICE_PFTOBJ pftoDevice;
    PFF *pPFF;
    if (pPFF = pftoDevice.pPFFGet(pdco->hdev()))
    {
        PFFOBJ pffo(pPFF);

        if (pffo.bValid())
        {
            ppfh = &pffo.pPFF->pfhFamily;
        }
    }

    if (ppfh == (FONTHASH**) NULL)
    {
        RIP("MAPPER::vAttemptDeviceMatch() -- invalid FONTHASH\nReturning NULL");
        return;
    }

    // Set a very stringent pruning criteria!

    vReset(FM_WEIGHT_ITALIC-1);

    // reset the mapping information

    fl |= FM_BIT_DEVICE_FONT;

    // Prepare to enumerate through all the device fonts

    ENUMFHOBJ fho(ppfh);
    for (ppfe = fho.ppfeFirst(); ppfe; ppfe = fho.ppfeNext())
    {
        PFEOBJ pfeo(ppfe);

        if (this->bNearMatch(pfeo,&jCharSet))
        {
            DUMP_CHOSEN_FONT(pfeo);

            if (this->ulPenaltyTotal == 0)
            {
            // this is a slimey hack to get some excel scenario to work the same
            // way it does on NT as it does on Win 95.  In this scenario excel
            // is asking for Ms Sans Serif on an HP Laser 4Si.  On Win 95 this
            // maps to Arial.  However, on NT we map to Univers or some other
            // font before we can even look at Arial as a result what used to
            // print on 3 pages now prints on 6.  Since the scenario is used for
            // benchmarking this is undesireable. To fix this we penalize
            // any fonts that are not Arial so that we will at least look at Arial
            // and then choose it.

            // bad news, some customers rely on the first device font matched by bNearMatch()
            // for printing. Without the hack, it picks the first match and returns. With the
            // hack, it picks the last device font matched by bNearMatch() and returns.
            // in oder to make sure that the apps will still get the first device font matched by
            // bNearMatch(), we only update the ppfeBest if this->ulPenaltyTotal < this->ulMaxPenalty.

                if(_wcsicmp( pfeo.pwszFamilyName(), L"Arial"))
                {
                    this->ulPenaltyTotal += 1;
                }
                else
                {
                    vSetBest(ppfe, TRUE, jCharSet);
                    return;
                }
            }

            // keep the first device font that we picked

            if (this->ulPenaltyTotal < this->ulMaxPenalty)
            {
                vSetBest(ppfe, TRUE, jCharSet);
                this->ulMaxPenalty = this->ulPenaltyTotal;    // prune the search
            }
        }
        else
        {
            DUMP_REJECTED_FONT(pfeo);
        }
    }

    if (this->ppfeBest)
    {
        // record code page, needed for correct
        // code page to unicode translation

        *pflAboutMatch |= (ulCharsetToCodePage((UINT) (*pflAboutMatch >> 24)) << 8);
    }

    // If we still don't have a device font and this is the generic
    // printer driver then just take the first device font.
}

/******************************Public*Routine******************************\
* MAPPER::vEmergency                                                       *
*                                                                          *
*   Go through the Engine fonts without regard to name ...                 *
*                                                                          *
* History:                                                                 *
*  Fri 05-Mar-1993 08:44:38 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

VOID MAPPER::vEmergency()
{
    PFE *ppfe;
    BYTE jCharSet = DEFAULT_CHARSET;
    BYTE jMatchCharset = DEFAULT_CHARSET;

    #if DBG
    if (gflFontDebug & DEBUG_MAPPER)
    {
        WARNING("\n\tMAPPER::vEmergency\n");
    }
    #endif

    PUBLIC_PFTOBJ pftoPublic;
    vReset();
    fl &= ~FM_BIT_DEVICE_FONT;

    ENUMFHOBJ fho(&pftoPublic.pPFT->pfhFamily);
    for
    (
        ppfe = fho.ppfeFirst();
        ppfe;
        ppfe = fho.ppfeNext()
    )
    {
        PFEOBJ pfeo(ppfe);
        if (this->bNearMatch(pfeo,&jCharSet, TRUE)) // called from vEmergency
        {
            DUMP_CHOSEN_FONT(pfeo);
            vSetBest(ppfe, FALSE, jCharSet);

        // bNearMatch modifies jCharSet even if it doesn't find a match
        // so subsquent calls to bNearMatch could change jCharSet to
        // something else.  Save a copy for use down below.

            jMatchCharset = jCharSet;

            if (this->ulPenaltyTotal == 0)
            {
                *pflAboutMatch |= (ulCharsetToCodePage((UINT) jCharSet) << 8);
                return;
            }
            this->ulMaxPenalty = this->ulPenaltyTotal;    // prune the search
        }
        else
        {
            DUMP_REJECTED_FONT(pfeo);
        }
    }

    // We can actually improve it here.
    // If the device is not a plotter, then we can actually
    // give it any bitmap font.
    // We could attempt to match against any bitmap font.

    if (!this->ppfeBest)
    {
        this->ppfeBest = gppfeMapperDefault;
        this->ulBestTime = gppfeMapperDefault->ulTimeStamp;
    }

    // record the code page, needed for correct
    // code page to unicode translation

    *pflAboutMatch |= (ulCharsetToCodePage((UINT) jMatchCharset) << 8);
}



/******************************Public*Routine******************************\
*
* PFE * MAPPER::ppfeSynthesizeAMatch (FLONG *pflSim, FLONG *pflAboutMatch, POINTL *pptlSim)
*
*
* Effects: if no exact instance is found, install one on the fly
*
* History:
*  30-Jan-1998 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



PFE * MAPPER::ppfeSynthesizeAMatch (FLONG *pflSim, FLONG *pflAboutMatch, POINTL *pptlSim)
{
    PFE *ppfeRet = NULL;

    DESIGNVECTOR *pdvWish;           // dv of the instance we wish to load
    ULONG         cjDV;
    ULONG  cFonts = 0;                   // number of fonts faces loaded

// let us get the pdv:

    if (flMM & FLMM_DV_FROM_NAME) // we got the axes from the name
    {
    // the name takes precedance, ie if we have explicit dv == [UU,VV]
    // as well as dv specified through font's family
    // name of the form foo_XX_YY, we ignore dv in ENUMLOGFONTEXDV
    // and use the one specified by the name, [XX,YY] in this case.

        pdvWish = &dvWish;
    }
    else
    {
        pdvWish = (DESIGNVECTOR *)&pelfwWish->elfDesignVector;
    }

    cjDV = SIZEOFDV(pdvWish->dvNumAxes);

// for now we do this only if another instance is already loaded

    if (ppfeMMInst)
    {
    // get to the PFF of the other instance, need file path data

        PFFOBJ pffMMInst(ppfeMMInst->pPFF) ;

        PFF *pPFF; // placeholder for the returned PFF

        if (pffMMInst.bValid())
        {
        // need to initialize the private PFT if it is NULL, these on the fly
        // instances are always added to private table

            if (gpPFTPrivate == NULL)
            {
                if (!bInitPrivatePFT())
                {
                    return ppfeRet;
                }
            }

        // temp instances go to private table

            PUBLIC_PFTOBJ pfto(gpPFTPrivate);

            if (!pffMMInst.bMemFont())
            {
                if (!pfto.bLoadFonts( pffMMInst.pwszPathname(),
                                      pffMMInst.cSizeofPaths(),
                                      pffMMInst.cNumFiles(),
                                      pdvWish, cjDV,
                                      &cFonts,
                      PFF_STATE_SYNTH_FONT, // flPFF
                                      &pPFF,
                                      (FR_PRIVATE | FR_NOT_ENUM), // always
                                      TRUE,    // skip the check if already loaded
                                      NULL ) ) // peudc
                {
                    cFonts = 0;
                }

                if (cFonts)
                {
                    GreQuerySystemTime( &PFTOBJ::FontChangeTime );
                }
            }

        }
        else // memory fonts
        {
            RIP("MEMORY FONT CASE NOT IMPLEMENTED\n");
        }

    // now need to get to the pfe of the font that we just added:

        if (cFonts)
        {
            PFFOBJ pffoNewInst(pPFF);

            if (pffoNewInst.bValid())
            {
                if (cFonts == 1)
                {
                    ppfeRet = pffoNewInst.ppfe(0);
                }
                else
                {
                // this is either an mm font which has a weight axis,
                // so that normal and bold faces are returned or this is a
                // also a FE mm font, in which case there may be
                // horiz and vertical variances as well. Therefore, in this case
                // we shall have to do mini-mapping process in order to decide which
                // face to return among those returned by by DrvLoadFontFile.

                    ULONG iFound = 0;
                    ULONG iFace = 0;
                    LONG  lMinSoFar = LONG_MAX;

                    for (iFace = 0; iFace < cFonts; iFace++)
                    {
                        IFIMETRICS *pifi = pffoNewInst.ppfe(iFace)->pifi;

                        IFIOBJ ifio(pifi);

                        LONG lDiff = (LONG)pifi->usWinWeight - lWishWeight;
                        if (lDiff < 0)
                            lDiff = -lDiff;

                    // <= on the next line is important because foo and @foo have the same weight

                        if (lDiff <= lMinSoFar)
                        {
                            lMinSoFar = lDiff;

                        // If requested font is vertlcal face font, We have to map it to vertical
                        // face font

                            if (fl & FM_BIT_VERT_FACE_REQUEST)
                            {
                                if (*ifio.pwszFamilyName() == U_COMMERCIAL_AT)
                                {
                                    iFound = iFace;
                                }
                            }
                            else
                            {
                                if (*ifio.pwszFamilyName() != U_COMMERCIAL_AT)
                                {
                                    iFound = iFace;
                                }
                            }
                        }
                    }

                    ppfeRet = pffoNewInst.ppfe(iFound);
                }

            // now that we know that we are returning ok we need to
            // fill in other output fields:

                *pflSim = 0;

        IFIOBJ ifio(ppfeRet->pifi);

        // next check for italic simulations

                if (pelfwWish->elfEnumLogfontEx.elfLogFont.lfItalic)
                {
        // if you get here then the application wants an italicized font

                    if (!ifio.bNonSimItalic() && ifio.bSimItalic())
                    {
                        *pflSim |= FO_SIM_ITALIC;
                    }
        }

        // bold simulations

        LONG lPen;

        lPen = ifio.lfNonSimWeight() - lWishWeight;

        if (!(fl & FM_BIT_FW_DONTCARE) && (lPen < 0 ))
        {
        // non simulated font isn't bold enough -> try a simulation

            lPen = -lPen;

            if(  (WIN31_BITMAP_EMBOLDEN_CRITERIA(lPen)) &&
             (ifio.pvSimBold() != NULL) )
            {
            *pflSim |= FO_SIM_BOLD;
            }
        }

                UINT CharSet = pelfwWish->elfEnumLogfontEx.elfLogFont.lfCharSet;

                *pflAboutMatch = (FLONG)(CharSet << 24);
                *pflAboutMatch |= (ulCharsetToCodePage(CharSet) << 8);
                pptlSim->x = pptlSim->y = 1;
            }
        }
    }
    return ppfeRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\fntassoc.cxx ===
/***********************************************************************************
 * Module Name: fntassoc.cxx
 *
 * Font association routines.
 *
 * History
 *
 * 4-8-96 Gerrit van Wingerden  Moved code from flinkgdi.cxx
 *
 * Copyright (c) 1996-1999 Microsoft Corporation
 **********************************************************************************/

#include "precomp.hxx"

#ifdef FE_SB

#define FONT_ASSOCIATION_CHARSET_KEY     \
     L"FontAssoc\\Associated CharSet"
#define FONT_ASSOCIATION_DEFAULT_KEY     \
     L"FontAssoc\\Associated DefaultFonts"
#define FONT_ASSOCIATION_FONTS_KEY       \
     L"FontAssoc\\Associated Fonts"


// Font Association configuration value

UINT  fFontAssocStatus = 0x0;

//
// Fontfile path for AssocSystemFont in
//  KEY   : HKL\\SYSTEM\\CurrentControlSet\\Control\\FontAssoc\\Associated DefaultFonts
//  VALUE : AssocSystemFont
//
// This font is loaded at system initialization stage. and will be used to provide
// DBCS glyphs for System/Terminal/FixedSys/... This font should have all glyphs that
// will be used on current system locale
//
// This hehavior is described in ...
//  "Font Association for Far East implementation for Windows 95"
//   Revision : 1.02
//   Author   : WJPark,ShusukeU.
//

// Holds the path of the font the font used to provide glyphs to system,terminal,
// and fixedsys fonts.

WCHAR gawcSystemDBCSFontPath[MAX_PATH];

// Identifies the facename to use for DBCS glyphs.  This value comes out of the
// "FontPackage" value in AssociatedDefaultFonts key

WCHAR gawcSystemDBCSFontFaceName[LF_FACESIZE+1];

// Holds the pfe's (vertical and non-vertical) for the system DBCS font face name

PFE *gappfeSystemDBCS[2] = { PPFENULL , PPFENULL };

// set to TRUE if SystemDBCS font is enabled.

BOOL gbSystemDBCSFontEnabled = FALSE;

//
// Font association default link initialization value.
//
// This value never be TRUE, if FontAssociation features are disabled.
// And this value will be TRUE, if we suceed to read "Associated DefaultFonts"
// key and fill up FontAssocDefaultTable.
//
BOOL  bReadyToInitializeFontAssocDefault = FALSE;
//
// This value never be TRUE, if FontAssociation features are disabled.
// And this value also never be TRUE, no-user logged-on this window station.
// This value become TRUE at first time that GreEnableEUDC() is called.
// and this value is turned off when user logout.
//
BOOL  bFinallyInitializeFontAssocDefault = FALSE;

//
// Font Association default link configuration table
//
#define NUMBER_OF_FONTASSOC_DEFAULT    7
#define FF_DEFAULT                  0xFF

FONT_DEFAULTASSOC FontAssocDefaultTable[NUMBER_OF_FONTASSOC_DEFAULT] = {
   {FALSE, FF_DONTCARE, L"FontPackageDontCare", L"\0", L"\0", {PPFENULL,PPFENULL}},
   {FALSE, FF_ROMAN, L"FontPackageRoman", L"\0", L"\0" , {PPFENULL,PPFENULL}},
   {FALSE, FF_SWISS, L"FontPackageSwiss", L"\0", L"\0", {PPFENULL,PPFENULL}},
   {FALSE, FF_MODERN, L"FontPackageModern", L"\0", L"\0", {PPFENULL,PPFENULL}},
   {FALSE, FF_SCRIPT, L"FontPackageScript", L"\0", L"\0", {PPFENULL,PPFENULL}},
   {FALSE, FF_DECORATIVE, L"FontPackageDecorative", L"\0", L"\0", {PPFENULL,PPFENULL}},
   {FALSE, FF_DEFAULT, L"FontPackage", L"\0", L"\0", {PPFENULL,PPFENULL}}
};


// Is font association substitition turned on?

BOOL  bEnableFontAssocSubstitutes = FALSE;

// Pointer to Substitution table for font association.

ULONG ulNumFontAssocSubs = 0L;
PFONT_ASSOC_SUB pFontAssocSubs = (PFONT_ASSOC_SUB) NULL;

// definition is in flinkgdi.cxx

extern RTL_QUERY_REGISTRY_TABLE SharedQueryTable[2];

extern BOOL bAppendSysDirectory(WCHAR *pwcTarget, WCHAR *pwcSource);
extern BOOL bComputeQuickLookup(QUICKLOOKUP *pql, PFE *pPFE, BOOL bSystemEUDC);

/******************************Public*Routine******************************\
* NTSTATUS CountRegistryEntryCoutine(PWSTR,ULONG,PVOID,ULONG,PVOID,PVOID)
*
* History:
*  19-Jan-1996 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

extern "C"
NTSTATUS
CountRegistryEntryRoutine
(
    PWSTR ValueName,
    ULONG ValueType,
    PVOID ValueData,
    ULONG ValueLength,
    PVOID Context,
    PVOID EntryContext
)
{
    (*(ULONG *)EntryContext) += 1L;

    return( STATUS_SUCCESS );
}


/******************************Public*Routine******************************\
* NTSTATUS FontAssocCharsetRoutine(PWSTR,ULONG,PVOID,ULONG,PVOID,PVOID)
*
* History:
*  28-Aug-1995 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

extern "C"
NTSTATUS
FontAssocCharsetRoutine
(
    PWSTR ValueName,
    ULONG ValueType,
    PVOID ValueData,
    ULONG ValueLength,
    PVOID Context,
    PVOID EntryContext
)
{
    //
    // Only process follows if the data value is "YES"
    //
    if( _wcsicmp((LPWSTR) ValueData, (LPWSTR) L"YES" ) == 0)
    {
        //
        // Check ANSI charset association is enabled
        //
        if( _wcsicmp((LPWSTR) ValueName, (LPWSTR) L"ANSI(00)") == 0)
        {
            #if DBG
            DbgPrint("GDISRV:FONTASSOC CHARSET:Enable ANSI association\n");
            #endif
            fFontAssocStatus |= ANSI_ASSOC;
            return(STATUS_SUCCESS);
        }
        //
        // Check SYMBOL charset association is enabled
        //
         else if( _wcsicmp((LPWSTR) ValueName, (LPWSTR) L"SYMBOL(02)") == 0)
        {
            #if DBG
            DbgPrint("GDISRV:FONTASSOC CHARSET:Enable SYMBOL association\n");
            #endif
            fFontAssocStatus |= SYMBOL_ASSOC;
            return(STATUS_SUCCESS);
        }
        //
        // Check OEM charset association is enabled
        //
         else if( _wcsicmp((LPWSTR) ValueName, (LPWSTR) L"OEM(FF)") == 0)
        {
            #if DBG
            DbgPrint("GDISRV:FONTASSOC CHARSET:Enable OEM association\n");
            #endif
            fFontAssocStatus |= OEM_ASSOC;
            return(STATUS_SUCCESS);
        }
    }

    //
    //  return STATUS_SUCCESS everytime,even we got error from above call, to
    // get next enumuration.
    //

    return(STATUS_SUCCESS);
}

/******************************Public*Routine******************************\
* NTSTATUS FontAssocDefaultRoutine(PWSTR,ULONG,PVOID,ULONG,PVOID,PVOID)
*
* History:
*  14-Jan-1996 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

extern "C"
NTSTATUS
FontAssocDefaultRoutine
(
    PWSTR ValueName,
    ULONG ValueType,
    PVOID ValueData,
    ULONG ValueLength,
    PVOID Context,
    PVOID EntryContext
)
{
    UINT iIndex;

    if(_wcsicmp((LPWSTR)ValueName,L"AssocSystemFont") == 0)
    {
        bAppendSysDirectory(gawcSystemDBCSFontPath,(LPWSTR)ValueData);
        return(STATUS_SUCCESS);
    }
    else
    if(_wcsicmp((LPWSTR)ValueName,L"FontPackage") == 0)
    {
        cCapString(gawcSystemDBCSFontFaceName,(WCHAR*)ValueData,LF_FACESIZE);
        return(STATUS_SUCCESS);
    }



    for( iIndex = 0; iIndex < NUMBER_OF_FONTASSOC_DEFAULT; iIndex++ )
    {
        if(_wcsicmp((LPWSTR)ValueName,
                    FontAssocDefaultTable[iIndex].DefaultFontTypeID) == 0)
        {
        // Check if the registry has some data.

            if( *(LPWSTR)ValueData != L'\0' )
            {
                wcscpy(FontAssocDefaultTable[iIndex].DefaultFontFaceName,
                       (LPWSTR)ValueData);

                FontAssocDefaultTable[iIndex].ValidRegData = TRUE;

                #if DBG
                DbgPrint("GDISRV:FONTASSOC DEFAULT:%ws -> %ws\n",
                    FontAssocDefaultTable[iIndex].DefaultFontTypeID,
                    FontAssocDefaultTable[iIndex].DefaultFontFaceName);
                #endif                
            }

            return(STATUS_SUCCESS);
        }
    }

    #if DBG
    DbgPrint("GDISRV:FONTASSOC DEFAULT:%ws is invalid registry key\n",(LPWSTR)ValueName);
    #endif

    //
    //  return STATUS_SUCCESS everytime,even we got error to do next enumuration.
    //
    return(STATUS_SUCCESS);
}

/******************************Public*Routine******************************\
* NTSTATUS FontAssocFontsRoutine(PWSTR,ULONG,PVOID,ULONG,PVOID,PVOID)
*
* History:
*  19-Jan-1996 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

extern "C"
NTSTATUS
FontAssocFontsRoutine
(
    PWSTR ValueName,
    ULONG ValueType,
    PVOID ValueData,
    ULONG ValueLength,
    PVOID Context,
    PVOID EntryContext
)
{
    UINT iIndex = (*(UINT *)EntryContext);
    PFONT_ASSOC_SUB pfas = pFontAssocSubs + iIndex;

    ASSERTGDI(iIndex < ulNumFontAssocSubs,
              "GDIOSRV:FONTASSOC iIndex >= ulNumFontAssocSubs\n");

    //
    // Copy the registry data to local buffer..
    //
    cCapString(pfas->AssociatedName,(LPWSTR)ValueData,LF_FACESIZE+1);
    cCapString(pfas->OriginalName  ,(LPWSTR)ValueName,LF_FACESIZE+1);

    #if DBG
    pfas->UniqNo = iIndex;

    DbgPrint("GDISRV:FONTASSOC FontSubs %d %ws -> %ws\n",iIndex,
                                                         pfas->OriginalName,
                                                         pfas->AssociatedName);
    #endif

    //
    // for Next entry....
    //
    (*(UINT *)EntryContext) = ++iIndex;

    return (STATUS_SUCCESS);
}


/******************************Public*Routine******************************\
* VOID vInitializeFontAssocStatus()
*
* History:
*  28-Aug-1995 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

VOID vInitializeFontAssocStatus(VOID)
{
    NTSTATUS NtStatus;

// Read Font Association configuration value.

// Initialize "FontAssoc\Association CharSet" related.

    SharedQueryTable[0].QueryRoutine = FontAssocCharsetRoutine;
    SharedQueryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    SharedQueryTable[0].Name = (PWSTR)NULL;
    SharedQueryTable[0].EntryContext = (PVOID)NULL;
    SharedQueryTable[0].DefaultType = REG_NONE;
    SharedQueryTable[0].DefaultData = NULL;
    SharedQueryTable[0].DefaultLength = 0;

    SharedQueryTable[1].QueryRoutine = NULL;
    SharedQueryTable[1].Flags = 0;
    SharedQueryTable[1].Name = (PWSTR)NULL;

    fFontAssocStatus = 0;
    gawcSystemDBCSFontPath[0] = L'\0';

// Enumurate registry values

    NtStatus = RtlQueryRegistryValues(RTL_REGISTRY_CONTROL|RTL_REGISTRY_OPTIONAL,
                                      FONT_ASSOCIATION_CHARSET_KEY,
                                      SharedQueryTable,
                                      NULL,
                                      NULL);

    if(!NT_SUCCESS(NtStatus))
    {
        WARNING1("GDISRV:FontAssociation is disabled\n");

        fFontAssocStatus = 0;
    }

    gawcSystemDBCSFontFaceName[0] = 0;

// Initialize "FontAssoc\Association DefaultFonts" related.

    SharedQueryTable[0].QueryRoutine = FontAssocDefaultRoutine;

// Enumurate registry values

    NtStatus = RtlQueryRegistryValues(RTL_REGISTRY_CONTROL|RTL_REGISTRY_OPTIONAL,
                                      FONT_ASSOCIATION_DEFAULT_KEY,
                                      SharedQueryTable,
                                      NULL,
                                      NULL);

    if( !NT_SUCCESS(NtStatus) )
    {
        WARNING1("GDISRV:FontAssociation:Default table is not presented\n");

        bReadyToInitializeFontAssocDefault = FALSE;
    }
    else
    {
    // We succeeded to read registry and fill up FontAssocDefaultTable.

        bReadyToInitializeFontAssocDefault = TRUE;

    // try to load the system DBCS font if we detected the appropriate registry
    // entries

        if(gawcSystemDBCSFontPath[0] && gawcSystemDBCSFontFaceName[0])
        {
            PUBLIC_PFTOBJ  pfto;

            LONG cFonts;
            EUDCLOAD EudcLoadData;
            PFF      *placeHolder;
            
            EudcLoadData.pppfeData = gappfeSystemDBCS;
            EudcLoadData.LinkedFace = gawcSystemDBCSFontFaceName;

            if(pfto.bLoadAFont((PWSZ) gawcSystemDBCSFontPath,
                               (PULONG) &cFonts,
                               PFF_STATE_EUDC_FONT,
                               &placeHolder,
                               &EudcLoadData ))
            {
            // initialize quick lookup table if we successfully loaded the font

            // this must be NULL for bComputeQuickLookup

                gqlTTSystem.puiBits = NULL;


                if(bComputeQuickLookup(&gqlTTSystem, gappfeSystemDBCS[PFE_NORMAL], FALSE))
                {
                // now try the vertical face if one is provided

                    FLINKMESSAGE2(DEBUG_FONTLINK_INIT,
                                  "Loaded SystemDBCSFont %ws\n",
                                  gawcSystemDBCSFontPath);

                    gbSystemDBCSFontEnabled = TRUE;
                    gbAnyLinkedFonts = TRUE;

                }

                if(!gbSystemDBCSFontEnabled)
                {
                    WARNING("vInitializeFontAssocStatus: error creating \
                             quick lookup tables for SystemDBCSFont\n");

                    pfto.bUnloadEUDCFont(gawcSystemDBCSFontPath);
                }
            }
            else
            {
                WARNING("vInitializeFontAssocStatus: error loading SystemDBCSFont\n");
            }
        }
    }


// Initialize "Font Association\Fonts" related.

    bEnableFontAssocSubstitutes = FALSE;

    SharedQueryTable[0].QueryRoutine = CountRegistryEntryRoutine;
    SharedQueryTable[0].EntryContext = (PVOID)(&ulNumFontAssocSubs);

// Count the number of the registry entries.

//    NtStatus = RtlQueryRegistryValues(RTL_REGISTRY_CONTROL|RTL_REGISTRY_OPTIONAL,
//                                      FONT_ASSOCIATION_FONTS_KEY,
//                                      SharedQueryTable,
//                                      NULL,
//                                      NULL);

    ulNumFontAssocSubs = 0;

    if( NT_SUCCESS(NtStatus) && (ulNumFontAssocSubs != 0) )
    {
        #if DBG
        DbgPrint("GDISRV:FONTASSOC %d FontAssoc Substitution is found\n",
                 ulNumFontAssocSubs);
        #endif

    // Allocate lookaside table for fontassociation's substitution.

        pFontAssocSubs = (PFONT_ASSOC_SUB)
          PALLOCMEM(sizeof(FONT_ASSOC_SUB)*ulNumFontAssocSubs,'flnk');

        if( pFontAssocSubs != NULL )
        {
            UINT iCount = 0; // This will be used as Current Table Index.

            SharedQueryTable[0].QueryRoutine = FontAssocFontsRoutine;
            SharedQueryTable[0].EntryContext = (PVOID)(&iCount);

            NtStatus = RtlQueryRegistryValues(RTL_REGISTRY_CONTROL|RTL_REGISTRY_OPTIONAL,
                                              FONT_ASSOCIATION_FONTS_KEY,
                                              SharedQueryTable,
                                              NULL,
                                              NULL);

            if( !NT_SUCCESS(NtStatus) )
            {
                VFREEMEM( pFontAssocSubs );
                ulNumFontAssocSubs = 0L;
            }
             else
            {
                bEnableFontAssocSubstitutes = TRUE;
                gbAnyLinkedFonts = TRUE;
            }
        }
         else
        {
            ulNumFontAssocSubs = 0L;
        }
    }

    return;
}

/*****************************************************************************\
 * GreGetFontAssocStatus( BOOL bEnable )
 *
 * History:
 *  28-Aug-1995 -by- Hideyuki Nagase [hideyukn]
 * Wrote it.
 *****************************************************************************/

UINT GreGetFontAssocStatus(VOID)
{
    return(fFontAssocStatus);
}




/*****************************************************************************
 * BOOL bSetupDefaultFlEntry(BOOL,BOOL,INT)
 *
 *  This function load font and build link for eudc font according to
 * the default link table.
 *
 * History
 *  1-15-96 Hideyuki Nagase
 * Wrote it.
 *****************************************************************************/

BOOL bSetupDefaultFlEntry(VOID)
{
    UINT iIndex;
    UINT bRet = FALSE;

    //
    // get and validate PFT user object
    //
    PUBLIC_PFTOBJ  pfto;  // access the public font table

    ASSERTGDI(
        pfto.bValid(),
        "gdisrv!bSetupDefaultFlEntry(): could not access the public font table\n"
        );

    for( iIndex = 0; iIndex < NUMBER_OF_FONTASSOC_DEFAULT; iIndex++ )
    {
        //
        // Check the registry data and fontpath is valid ,and
        // this font is not loaded, yet.
        //
        if( (FontAssocDefaultTable[iIndex].ValidRegData) &&
            (FontAssocDefaultTable[iIndex].DefaultFontPathName[0] != L'\0') &&
            (FontAssocDefaultTable[iIndex].DefaultFontPFEs[PFE_NORMAL] == PPFENULL) )
        {
            PPFE     appfeLink[2];  // temporary buffer
            LONG     cFonts;        // count of fonts
            EUDCLOAD EudcLoadData;  // eudc load data
            PFF      *placeHolder;

            PWSZ     FontPathName = FontAssocDefaultTable[iIndex].DefaultFontPathName;

            //
            // Fill up EudcLoadData structure
            //
            EudcLoadData.pppfeData  = (PPFE *) &appfeLink;
            EudcLoadData.LinkedFace = FontAssocDefaultTable[iIndex].DefaultFontFaceName;

            //
            // Load the linked font.
            //
            if( pfto.bLoadAFont( FontPathName,
                                 (PULONG) &cFonts,
                                 (PFF_STATE_EUDC_FONT | PFF_STATE_PERMANENT_FONT),
                                 &placeHolder,
                                 &EudcLoadData ) )
            {
            //
            // Check we really succeed to load requested facename font.
            //
            //
            // Compute table for normal face
            //
               if(!bComputeQuickLookup(NULL, appfeLink[PFE_NORMAL], FALSE ))
               {
                   WARNING("Unable to compute QuickLookUp for default link\n");

               //
               // Unload the fonts.
               //
                   pfto.bUnloadEUDCFont(FontPathName);

               //
               // we got error during load, maybe font itself might be invalid,
               // just invalidate the pathname the default table.
               //
                   FontAssocDefaultTable[iIndex].DefaultFontPathName[0] = L'\0';

               //
               // Do next entry in default table.
               //
                   continue;
               }

               //
               // Compute table for vertical face, if vertical face font is provided,
               //

               if( !bComputeQuickLookup(NULL, appfeLink[PFE_VERTICAL], FALSE ))
               {
                   WARNING("Unable to compute QuickLookUp for default link\n");

               // Unload the fonts.
                    pfto.bUnloadEUDCFont(FontPathName);

               // we got error during load, maybe font itself might be invalid,
               // just invalidate the pathname the default table.

                    FontAssocDefaultTable[iIndex].DefaultFontPathName[0] = L'\0';

               // Do next entry in default table.

                    continue;
                }
                
                //
                // Finally, we keeps the PFEs in default array.
                //
                FontAssocDefaultTable[iIndex].DefaultFontPFEs[PFE_NORMAL] =
                  appfeLink[PFE_NORMAL];
                FontAssocDefaultTable[iIndex].DefaultFontPFEs[PFE_VERTICAL] =
                  appfeLink[PFE_VERTICAL];

                #if DBG
                DbgPrint("GDISRV:FONTASSOC DEFAULT:Load %ws for %ws\n",
                    FontAssocDefaultTable[iIndex].DefaultFontPathName,
                    FontAssocDefaultTable[iIndex].DefaultFontTypeID);
                #endif

             // We can load Associated font.

                bRet = TRUE;
            }
             else
            {
                #if DBG
                DbgPrint("Failed to load default link font. (%ws)\n",FontPathName);
                #endif

                //
                // we got error during load, maybe font itself might be invalid,
                // just invalidate the pathname the default table.
                //
                FontAssocDefaultTable[iIndex].DefaultFontPathName[0] = L'\0';

                //
                // Make sure the PFEs are invalid.
                //
                FontAssocDefaultTable[iIndex].DefaultFontPFEs[PFE_NORMAL]   = PPFENULL;
                FontAssocDefaultTable[iIndex].DefaultFontPFEs[PFE_VERTICAL] = PPFENULL;
            }
        }
    }

    return(bRet);
}


/*****************************************************************************\
 * PWSZ pwszFindFontAssocSubstitute(PWSZ)
 *
 * This codepath check the passed facename is registered as Default link
 * facename in Default link table. if so, keep its facename for the facename.
 *
 * History
 *  1-17-96 Hideyuki Nagase
 * Stolen from fontsub.cxx and adopt it.
 *****************************************************************************/

PWSZ pwszFindFontAssocSubstitute(PWSZ pwszOriginalName)
{
    PFONT_ASSOC_SUB pfas = pFontAssocSubs;
    PFONT_ASSOC_SUB pfasEnd = pFontAssocSubs + ulNumFontAssocSubs;
    WCHAR           awchCapName[LF_FACESIZE+1];

    //
    // Want case insensitive search, so capitalize the name.
    //
    cCapString(awchCapName, pwszOriginalName, LF_FACESIZE);

    //
    // Scan through the font substitution table for the key string.
    //

    for (; pfas < pfasEnd; pfas++)
    {

        if (!wcscmp(awchCapName,pfas->OriginalName))
        {
        // we found a facename match
            return(pfas->AssociatedName);
        }
    }

    //
    // Nothing found, so return NULL.
    //
    return ((PWCHAR) NULL);
}


/*****************************************************************************
 * ULONG NtGdiQueryFontAssocInfo
 *
 * Shared kernel mode entry point for QueryFontAssocStatus and
 * GetFontAssocStatus
 *
 * History
 *  6-12-96 Gerrit van Wingerden [gerritv]
 * Wrote it.
 ****************************************************************************/

#define GFA_NOT_SUPPORTED 0
#define GFA_SUPPORTED     1
#define GFA_DBCSFONT      2

extern "C" ULONG NtGdiQueryFontAssocInfo(HDC hdc)
{
// if hdc is NULL then just return fFontAssocStatus

    if(hdc == NULL)
    {
        return(fFontAssocStatus);
    }
    else
    {
    // for now eventually merge/share with NtGdiGetCharSet

        FLONG    flSim;
        POINTL   ptlSim;
        FLONG    flAboutMatch;
        PFE     *ppfe;

        DCOBJ dco (hdc);
        if (!dco.bValid())
        {
            SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
            return(GFA_NOT_SUPPORTED);
        }

        PDEVOBJ pdo(dco.hdev());
        ASSERTGDI(pdo.bValid(), "gdisrv!GetCharSet: bad pdev in dc\n");

        if (!pdo.bGotFonts())
          pdo.bGetDeviceFonts();

        LFONTOBJ lfo(dco.pdc->hlfntNew(), &pdo);

        if (dco.ulDirty() & DIRTY_CHARSET)
        {
        // force mapping

            if (!lfo.bValid())
            {
                WARNING("gdisrv!RFONTOBJ(dco): bad LFONT handle\n");
                return(GFA_NOT_SUPPORTED);
            }


        // Stabilize the public PFT for mapping.

            SEMOBJ  so(ghsemPublicPFT);

        // LFONTOBJ::ppfeMapFont returns a pointer to the physical font face and
        // a simulation type (ist)
        // also store charset to the DC

            ppfe = lfo.ppfeMapFont(dco, &flSim, &ptlSim, &flAboutMatch);

            ASSERTGDI(!(dco.ulDirty() & DIRTY_CHARSET),
                          "NtGdiGetCharSet, charset is dirty\n");

        }

        UINT Charset = (dco.pdc->iCS_CP() >> 16) & 0xFF;

        if (IS_ANY_DBCS_CHARSET( Charset ))
        {
            return GFA_DBCSFONT;
        }

        if (((Charset == ANSI_CHARSET)   && (fFontAssocStatus & ANSI_ASSOC))  ||
            ((Charset == OEM_CHARSET)    && (fFontAssocStatus & OEM_ASSOC))   ||
            ((Charset == SYMBOL_CHARSET) && (fFontAssocStatus & SYMBOL_ASSOC))  )
        {
            if(!(lfo.plfw()->lfClipPrecision & CLIP_DFA_OVERRIDE))
            {
                return(GFA_SUPPORTED);
            }
        }
        return(GFA_NOT_SUPPORTED);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\fntcache.cxx ===
/*****************************************************************************
* Module Name: fntcache.cxx
*
* Font Cahce API's for NT font engine.
*
* History:
*  4-15-99 We need to add the code for WTS (Hydra)
*  There are 3 major changes,
*  (1) We can not write to fntcache.dat in read mode. So we have modified the code
*  to make sure there there is no writing to fntcache in read mode.
*  (2) Implement a lock algorithm so than no remote session can open the fntcache.dat
*  during write mode of console.
*  (3) Check the time stamp of win32k.sys and atmfd.dll
*  4-3-98 Yung-Jen Tony Tsai   Wrote it.
*
* Copyright (c) 1998-1999 Microsoft Corporation
*****************************************************************************/

#include "precomp.hxx"
#include <ntverp.h>

FLONG       gflFntCacheState;
FNTCACHE    *gFntCache;
HSEMAPHORE  ghsemFntCache = NULL;

extern "C"          gbJpn98FixPitch;

extern BOOL         G_fConsole;

#define FNTCACHEPATH L"\\SystemRoot\\system32\\FNTCACHE.DAT"
#define WIN32KPATH  L"\\SystemRoot\\system32\\win32k.sys"
#define ATMFDPATH  L"\\SystemRoot\\system32\\atmfd.dll"
#define DISABLE_REMOTE_FONT_BOOT_CACHE  L"DisableRemoteFontBootCache"
#define LASTBOOTTIME_FONT_CACHE_STATE    L"LastBootTimeFontCacheState"
#define FNT_CACHE_EXTRA_SIZE (16*512)
#define RESERVE_LINKS        200

#if DBG
VOID DebugGreTrackRemoveMapView(PVOID ViewBase);

#define     FNTCACHE_DBG_LEVEL_0    0
#define     FNTCACHE_DBG_LEVEL_1    1
#define     FNTCACHE_DBG_LEVEL_2    2
#define     FNTCACHE_DBG_LEVEL_3    3

ULONG       gFntTest = FNTCACHE_DBG_LEVEL_3;

#define FNT_KdBreakPoint(d, s1)     \
{                                   \
    if (d >= gFntTest)              \
    {                               \
        DbgPrint s1;                \
                                    \
        if (d >= FNTCACHE_DBG_LEVEL_1)  \
            DbgBreakPoint();            \
    }                               \
}
#else

#define FNT_KdBreakPoint(d, s1)

#endif

extern "C" ULONG ComputeFileviewCheckSum(PVOID, ULONG);

#define FNTCacheFileCheckSum(pTableView, cjView)  ComputeFileviewCheckSum((PVOID)((PBYTE) pTableView + 4), (cjView -4))

#define FNTINDEX_INVALID 0xffffffff

ULONG   ComupteFNTCacheFastCheckSum(ULONG cwc, PWSZ pwsz, PFONTFILEVIEW *ppfv,ULONG cFiles, DESIGNVECTOR *pdv, ULONG cjDV);
VOID    SearchFNTCacheHlink(ULONG ulFastCheckSum, FNTHLINK **ppfntHLink, FNTCACHEHEADER *pTable);
BOOL    bFntCacheCreateHLink(ULONG ulFastCheckSum);
VOID    PutFNTCacheIFI(ULONG ulFastCheckSum, PBYTE pIfi, ULONG ulSize);
FNTHLINK * SearchFntCacheNewLink(ULONG ulFastCheckSum);
BOOL    bInitCacheTable(ULONG ulTTFonts, ULONG ulT1FOnts, LARGE_INTEGER FntRegLWT, LARGE_INTEGER T1RegLWT, ULONG CodePage);

// Here is only for performance evaluation
#define KEY_GRE_INITIALIZE  L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Gre_Initialize"
#define KEY_NT_CURRENTVERSION  L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion"

#define FNT_DISABLEFONTCACHE    L"DisableFontBootCache"
#define CURRENT_BUILDNUMBER     L"CurrentBuildNumber"


BOOL bQueryValueKey(PWSZ pwszValue, HANDLE RegistryKey, PKEY_VALUE_PARTIAL_INFORMATION ValueKeyInfo, ULONG ValueLength);
BOOL bOpenKey(PWSZ pwszKey, HANDLE *pRegistryKey);
VOID vUnmapFontCacheFile(VOID);

#define EXTRA_BUFFER 48
#define BUFF_LENGTH  (sizeof(KEY_VALUE_PARTIAL_INFORMATION) + EXTRA_BUFFER)

typedef union _KVINFO
{
    KEY_VALUE_PARTIAL_INFORMATION kv;
    BYTE                          aj[BUFF_LENGTH];
} KVINFO;


VOID vCleanUpFntCache(VOID)
{

    if (ghsemFntCache == NULL)
        return;

    HSEMAPHORE hsemTmp = ghsemFntCache;

    {
        SEMOBJ  so(ghsemFntCache);

        if (gFntCache)
        {
            if (gFntCache->pTable)
            {
                vUnmapFontCacheFile();
            }


            VFREEMEM((PVOID) gFntCache);
            gFntCache = NULL;
        }

        gflFntCacheState = 0;
        ghsemFntCache = NULL;
    }

// delete the semaphore, no longer needed

    GreDeleteSemaphore(hsemTmp);
}

BOOL bFntCacheDriverLWT( PCWSTR pcwFontDriverFileName, LARGE_INTEGER  *pLastWriteTime)
{
    UNICODE_STRING            UnicodeString;
    OBJECT_ATTRIBUTES         ObjectAttributes;
    NTSTATUS                  NtStatus;
    HANDLE                    FileHandle = 0;
    IO_STATUS_BLOCK           IoStatusBlock;
    FILE_BASIC_INFORMATION    FileBasicInfo;

    BOOL bRet = FALSE;

    pLastWriteTime->QuadPart = 0;

    RtlInitUnicodeString(&UnicodeString, pcwFontDriverFileName);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        0,
        0);

    NtStatus = IoCreateFile(
                   &FileHandle,
                   FILE_GENERIC_READ 
                    | FILE_GENERIC_EXECUTE
                    | SYNCHRONIZE,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   0,
                   FILE_ATTRIBUTE_NORMAL,
                   FILE_SHARE_READ,
                   FILE_OPEN,       // Flag for file open.
                   FILE_SYNCHRONOUS_IO_ALERT,
                   0,
                   0,
                   CreateFileTypeNone,
                   NULL,
                   IO_FORCE_ACCESS_CHECK |     // Ensure the user has access to the file
                   IO_NO_PARAMETER_CHECKING |  // All of the buffers are kernel buffers
                   IO_CHECK_CREATE_PARAMETERS);

    if (!NT_SUCCESS(NtStatus))
    {
        return(FALSE);
    }

// Get the time stamp

    NtStatus = ZwQueryInformationFile(
                   FileHandle,
                   &IoStatusBlock,
                   &FileBasicInfo,
                   sizeof(FileBasicInfo),
                   FileBasicInformation);

    ZwClose(FileHandle);

    if (NT_SUCCESS(NtStatus))
    {
        *pLastWriteTime = FileBasicInfo.LastWriteTime;
        bRet = TRUE;
    }

    return bRet;
}

VOID vGetFontDriverLWT(LARGE_INTEGER *pWin32kLWT, LARGE_INTEGER *pAtmfdLWT)
{
    LARGE_INTEGER  LastWriteTime;

    if (bFntCacheDriverLWT( WIN32KPATH, &LastWriteTime))
    {
        pWin32kLWT->QuadPart = LastWriteTime.QuadPart;
    }

    if (bFntCacheDriverLWT( ATMFDPATH, &LastWriteTime))
    {
        pAtmfdLWT->QuadPart = LastWriteTime.QuadPart;
    }
    
}

NTSTATUS GetGreRegKey(HANDLE *phkRegistry, ACCESS_MASK dwDesiredAccess, PCWSTR pcwsz)
{
    OBJECT_ATTRIBUTES           ObjectAttributes;
    UNICODE_STRING              UnicodeString;

    RtlInitUnicodeString(&UnicodeString, pcwsz);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    return ZwOpenKey(phkRegistry, dwDesiredAccess, &ObjectAttributes);
}

BOOL bSetFntCacheReg(PCWSTR pcwsz, DWORD dwValue)
{
    HANDLE                      hkRegistry;
    UNICODE_STRING              UnicodeString;
    NTSTATUS                    status;
    BOOL                        bRet = FALSE;

    status = GetGreRegKey(&hkRegistry, GENERIC_WRITE, KEY_GRE_INITIALIZE);

    if (NT_SUCCESS(status))
    {
        RtlInitUnicodeString(&UnicodeString, pcwsz);

        status = ZwSetValueKey(hkRegistry,
                               &UnicodeString,
                               0,
                               REG_DWORD,
                               &dwValue,
                               sizeof(DWORD));


        if (NT_SUCCESS(status))
            bRet = TRUE;
        else
            WARNING(" Failed to set DisableRemoteFontBootCache registry");

        ZwCloseKey(hkRegistry);
    }

    return bRet;
    
}

DWORD bQueryFntCacheReg (HANDLE  hkRegistry, PCWSTR pcwsz, DWORD *pdwDisableMode)
{
    UNICODE_STRING              UnicodeString;
    NTSTATUS                    status;
    DWORD                       Length;
    PKEY_VALUE_FULL_INFORMATION Information;
    BOOL                        bRet = FALSE;

    RtlInitUnicodeString(&UnicodeString, pcwsz);

    Length = sizeof(KEY_VALUE_FULL_INFORMATION) + (wcslen(pcwsz) + 1) * 2 +
             sizeof(DWORD);

    Information = (PKEY_VALUE_FULL_INFORMATION) PALLOCMEM(Length, 'CFTT');

    if (Information)
    {
        status = ZwQueryValueKey(hkRegistry,
                                 &UnicodeString,
                                 KeyValueFullInformation,
                                 Information,
                                 Length,
                                 &Length);

        if (NT_SUCCESS(status))
        {
            *pdwDisableMode = *(LPDWORD) ((((PUCHAR)Information) +
                                             Information->DataOffset));
            bRet = TRUE;
        }

        VFREEMEM(Information);
    }

    return bRet;
}

VOID vGetLastBootTimeStatus(void)
{
    HANDLE                      hkRegistry;
    NTSTATUS                    status;
    DWORD                       dwReg = 0;

    status = GetGreRegKey(&hkRegistry, GENERIC_READ, KEY_GRE_INITIALIZE);

    gFntCache->flPrevBoot = 0;

    if (NT_SUCCESS(status))
    {
        if (bQueryFntCacheReg(hkRegistry, LASTBOOTTIME_FONT_CACHE_STATE, &dwReg))
        {
            gFntCache->flPrevBoot = (FLONG) dwReg;
        }
        ZwCloseKey(hkRegistry);
    }

// If we are going to be opening the fntcache.dat in read mode than current boot time state
// will be the same as the previous boot time state. But flThisBoot will change
// if we will be opening the file CREATE (write) mode.

    gFntCache->flThisBoot = gFntCache->flPrevBoot;
}


/*****************************************************************************
 * BOOL bFntCacheDisabled()
 *
 * Tempary routine for performance evaluation
 *
 * History
 *  10-15-98 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

BOOL bFntCacheDisabled()
{
    HANDLE                      hkRegistry;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    UNICODE_STRING              UnicodeString;
    NTSTATUS                    status;
    DWORD                       Length;
    PKEY_VALUE_FULL_INFORMATION Information;
    DWORD                       dwDisableMode = 0;
    BOOL                        bRet = FALSE;


    status = GetGreRegKey(&hkRegistry, GENERIC_READ, KEY_GRE_INITIALIZE);

    if (NT_SUCCESS(status))
    {
    // let us check if somebody wanted to disable fontcache.dat by setting the
    // DisableFontBootCache in the registry:

        if (bQueryFntCacheReg(hkRegistry, L"DisableFontBootCache", &dwDisableMode))
        {
            if (dwDisableMode)
                bRet = TRUE;
        }

        if (!bRet && !G_fConsole)
        {
        // we may still want to disable the use of font cache for this remote hydra session.
        // We would do this if the console session is writing to the font cache at this time
        // (the console session would set the dwDisableMode to 1 in the registry so that
        // remote sessions do not try to access the cache)
        // or
        // if the font cache is in a suspcious state, so that whoever read from or wrote to
        // the cache before set the dwDisableMode to 1 in the registry

            if (bQueryFntCacheReg(hkRegistry, DISABLE_REMOTE_FONT_BOOT_CACHE, &dwDisableMode))
            {
                if (dwDisableMode)
                    bRet = TRUE;
            }
            else
            {
            // for some reason, to read the registry failed. So it would be safe to
            // disable the font cache.
                bRet = TRUE;
            }
        }

        ZwCloseKey(hkRegistry);
    }

    return bRet;
}

/*****************************************************************************
 * BOOL bFntCacheDisabled()
 *
 * This routine to get the registry only for JPN fix pitch compatible width
 *
 * History
 *  2-3-2000 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

VOID vGetJpn98FixPitch()
{
    HANDLE                      hkRegistry;
    NTSTATUS                    status;
    DWORD                       dwFixPitch = 0;
    
    status = GetGreRegKey(&hkRegistry, GENERIC_READ, KEY_GRE_INITIALIZE);

    if (NT_SUCCESS(status))
    {
        if (bQueryFntCacheReg(hkRegistry, L"Jpn98FixPitch", &dwFixPitch))
        {
            if (dwFixPitch)
                gbJpn98FixPitch = TRUE;
            else
                gbJpn98FixPitch = FALSE;
        }

        ZwCloseKey(hkRegistry);
    }
}


/*****************************************************************************
 * VOID    FntCacheHDEV()
 *
 * Cache the font driver handle, include TT, OT, BMP and VT
 *
 * History
 *  10-15-98 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

VOID    FntCacheHDEV(PPDEV hdev, ULONG ulDrv)
{
    // There is no cache
    if (!(gflFntCacheState & FNT_CACHE_MASK))
    {
        return;
    }

    ASSERTGDI (ulDrv && hdev, " Fnt Cache HDEV is wrong \n");

    if (ulDrv)
        gFntCache->hDev[ulDrv] = hdev;

}

/*****************************************************************************
 * extern "C" VOID    EngFntCacheFault(ULONG ulFastCheckSum, FLONG fl)
 *
 * Fault reprot for Engine font cache.
 *
 * History
 *  10-15-98 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

extern "C" VOID    EngFntCacheFault(ULONG ulFastCheckSum, FLONG fl)
{
    FNTHLINK        *pFntHlink = NULL;
    BOOL            bExcept = FALSE;

    // There is no cache
    if (ghsemFntCache == NULL)
        return;

    SEMOBJ          so(ghsemFntCache);

    if (!(gflFntCacheState & FNT_CACHE_MASK))
    {
        return;
    }

    BOOL    bUpdate = FALSE;

    switch (fl)
    {
        case ENG_FNT_CACHE_READ_FAULT:
        case ENG_FNT_CACHE_WRITE_FAULT:

        // if we have already marked the font cache as bad, do not need to do it again

            if (!(gFntCache->flThisBoot & FNT_CACHE_STATE_ERROR))
                bUpdate = TRUE;

            break;

        default:
            break;
    }

    if (bUpdate)
    {
    // we do need to mark the cache invalid

        gFntCache->flThisBoot |= FNT_CACHE_STATE_ERROR;
        bSetFntCacheReg (LASTBOOTTIME_FONT_CACHE_STATE, gFntCache->flThisBoot);
    }
}

/*****************************************************************************
 * VOID    PutFntCacheDrv(ULONG ulFastCheckSum, PPDEV hdev)
 *
 * Each font file is mapped to one font driver and cache it.
 *
 * History
 *  10-15-98 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

VOID    PutFntCacheDrv(ULONG ulFastCheckSum, PPDEV hdev)
{
    if (ghsemFntCache == NULL)
        return;

    SEMOBJ  so(ghsemFntCache);

    // There is no cache
    if (!(gflFntCacheState & FNT_CACHE_MASK))
    {
        return;
    }

    // No checksum mean nothing we can do
    if (ulFastCheckSum)
    {
        ULONG   i, ulMode;

        ulMode = FNT_DUMMY_DRV;

        // Serched the cached device handle
        for (i = FNT_TT_DRV; i <= FNT_OT_DRV; i++)
        {
            if (hdev == gFntCache->hDev[i])
            {
                ulMode = i;
                break;
            }
        }

    // some unknown font driver has been used for the system, and we will not cache it.
        if (ulMode == FNT_DUMMY_DRV)
            return;

        // We cached it when FNTCache is in write mode

        if (gflFntCacheState & FNT_CACHE_CREATE_MODE)
        {
            FNTHLINK        *pFntHlink = NULL;

            pFntHlink = SearchFntCacheNewLink(ulFastCheckSum);

            if (pFntHlink)
            {
            // If fast check sum is in conflict, we can not cache it.

                if (pFntHlink->ulDrvMode == FNT_DUMMY_DRV) // uninitialized link
                {
                    pFntHlink->ulDrvMode = ulMode;
                }
                else
                {
                // Ok, fast checksum conflict

                    WARNING("Checksum conflict in  PutFntCacheDrv");
                    pFntHlink->flLink |= FNT_CACHE_CHECKSUM_CONFLICT;
                }
            }
            else
            {
                gFntCache->flThisBoot |= FNT_CACHE_STATE_FULL;
            }

            gFntCache->bWrite = TRUE;
        }
        else
        {
            ASSERTGDI(gflFntCacheState & FNT_CACHE_LOOKUP_MODE,
                           "PutFntCacheDrv: gflFntCacheState\n");

        // attempting to write during the read mode.
        // This may happen if somebody overwrote the file in the fonts directory
        // without updating the [Fonts] section in the registry. In this (infrequent) case we
        // want to force the rebuild of the cache at the next boot time.

            gFntCache->flThisBoot |= FNT_CACHE_STATE_FULL;
        }
    }
}

VOID vUnmapFontCacheFile(VOID)
{
    NTSTATUS ntStatus;

    ASSERTGDI(gFntCache->pSection, "vUnmapFontCacheFile: gFntCache->pSection is NULL\n");
    ASSERTGDI(gFntCache->pTable, "vUnmapFontCacheFile: gFntCache->pTable is NULL\n");
    
#if defined(_GDIPLUS_)

    ntStatus = UnmapViewInProcessSpace(gFntCache->pTable);

#elif defined(_HYDRA_)

    // MmUnmapViewInSessionSpace is internally promoted to
    // MmUnmapViewInSystemSpace on non-Hydra systems.

    ntStatus = Win32UnmapViewInSessionSpace((PVOID) gFntCache->pTable );
#else
    ntStatus = MmUnmapViewInSystemSpace((PVOID)gFntCache->pTable)));
#endif

#if DBG
    if (!NT_SUCCESS(ntStatus))
        RIP(" Font cache file remove Map View failed \n");
#endif

#if DBG && defined(_HYDRA_)
    if ((!G_fConsole) && (NT_SUCCESS(ntStatus)))
    {
        DebugGreTrackRemoveMapView((PVOID) gFntCache->pTable);
    }
#endif

    DEREFERENCE_FONTVIEW_SECTION(gFntCache->pSection);

    gFntCache->pSection = NULL;
    gFntCache->pTable = NULL;

    return;
}

/*****************************************************************************
 * VOID  CloseFNTCache()
 *
 * Clean font cache after system boot
 *
 * History
 *  4-3-98 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

extern "C" VOID  CloseFNTCache()
{
// do paranoid check

    HSEMAPHORE hsemTmp = ghsemFntCache;

    if (ghsemFntCache == NULL)
        return;

    {
        SEMOBJ  so(ghsemFntCache);

        if (!(gflFntCacheState & FNT_CACHE_MASK))
        {
            gflFntCacheState = 0;
            return;
        }

        if (gflFntCacheState & FNT_CACHE_CREATE_MODE)
        {
        // Close the file, we are done recreating it

            if (gFntCache->pTable)
            {
                if (gFntCache->bWrite)
                {
                    gFntCache->pTable->ulTotalLinks = gFntCache->ulCurrentHlink;
                    gFntCache->pTable->cjDataUsed = (ULONG)(gFntCache->pCacheBuf - gFntCache->pCacheBufStart);
                    gFntCache->pTable->CheckSum = FNTCacheFileCheckSum(gFntCache->pTable, gFntCache->pTable->ulFileSize);
                }
            }
        }

        if (gFntCache->pTable)
        {
            vUnmapFontCacheFile();
        }

    // now that the file is closed set the registry to indicate that it is ok for remote
    // sessions to read from the cache file

        if (gflFntCacheState & FNT_CACHE_CREATE_MODE)
        {
            if (gFntCache->flPrevBoot != gFntCache->flThisBoot)
                bSetFntCacheReg(LASTBOOTTIME_FONT_CACHE_STATE, gFntCache->flThisBoot);

        // Unlock fnt cache file, say that it is ok to read from it

            bSetFntCacheReg(DISABLE_REMOTE_FONT_BOOT_CACHE, 0);
        }
        else
        {
            if (gFntCache->flThisBoot & (FNT_CACHE_STATE_ERROR | FNT_CACHE_STATE_FULL))
                bSetFntCacheReg(LASTBOOTTIME_FONT_CACHE_STATE, gFntCache->flThisBoot);
        }

        VFREEMEM((PVOID) gFntCache);
        gFntCache = NULL;

        gflFntCacheState = 0;
        ghsemFntCache = NULL;
    }

// delete the semaphore, no longer needed

    GreDeleteSemaphore(hsemTmp);
}

/*****************************************************************************
 * BOOL bReAllocCacheFile(ULONG ulSize)
 *
 * ReAlloc font cache buffer
 *
 * History
 *  10-14-98 modified [YungT]
 *  8-22-98 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

BOOL bReAllocCacheFile(ULONG ulSize)
{
    BOOL            bOK = FALSE;
    ULONG           ulSizeExtraOrg;
    ULONG           ulFileSizeOrg;
    ULONG           ulSizeExtra;
    ULONG           ulCurrentSize;
    ULONG           ulFileSize;
    DWORD           dpOffsetStart;
    FILEVIEW        FileView;

// OVERFLOW means that we would like to get a bigger cache file but the OS would not give it to us.
// In this case we just close the cache file, update the checksum (bWrite set to true) and
// let remote sessions that are to be started later use the partial cache file

    if (gFntCache->flThisBoot & FNT_CACHE_STATE_OVERFLOW)
    {
    // we tried this once before and it did not work, so we do not bother to do it again

        return bOK;
    }

    ulFileSizeOrg = gFntCache->pTable->ulFileSize;
    ulCurrentSize = (ULONG) (gFntCache->pCacheBufEnd - gFntCache->pCacheBuf);

// Calculate the extra cache we need

    ulSizeExtra = QWORD_ALIGN(ulSize - ulCurrentSize) + FNT_CACHE_EXTRA_SIZE;

    ulFileSize = ulFileSizeOrg + ulSizeExtra;

    dpOffsetStart = (DWORD) (gFntCache->pCacheBufStart - (PBYTE) gFntCache->pTable);

    if (gFntCache->pTable)
    {
       vUnmapFontCacheFile();
    }

    RtlZeroMemory(&FileView, sizeof(FILEVIEW));

    if (bMapFile(FNTCACHEPATH, &FileView, ulFileSize, NULL))
    {
        DWORD dpOffset;

        gFntCache->pTable = (FNTCACHEHEADER *) FileView.pvKView;
        gFntCache->pSection = FileView.pSection;

        gFntCache->pTable->ulFileSize = ulFileSize;
        gFntCache->pTable->cjDataExtra += ulSizeExtra;


        dpOffset = (ULONG)(gFntCache->pCacheBuf - gFntCache->pCacheBufStart);

    // Got a new Table and got to re-calculate the buffer end pointer

        gFntCache->pCacheBufStart = (PBYTE) gFntCache->pTable + dpOffsetStart;

        gFntCache->pCacheBuf = gFntCache->pCacheBufStart + dpOffset;

        gFntCache->pCacheBufEnd = gFntCache->pCacheBufStart + gFntCache->pTable->cjDataAll +
                                         gFntCache->pTable->cjDataExtra;

        bOK = TRUE;
    }
    else
    {
    // Something wrong, so we do not change anything

        RtlZeroMemory(&FileView, sizeof(FILEVIEW));

        if (bMapFile(FNTCACHEPATH, &FileView, ulFileSizeOrg, NULL))
        {
            gFntCache->pTable = (FNTCACHEHEADER *) FileView.pvKView;
            gFntCache->pSection = FileView.pSection;

        // we want the cache properly closed, with check sum recomputed etc.

            gFntCache->bWrite = TRUE;

        // Force rebuild on the next boot, but for this boot let remote sessions
        // use the partial cache file.

            gFntCache->flThisBoot |= (FNT_CACHE_STATE_OVERFLOW | FNT_CACHE_STATE_FULL);
        }
        else
        {
        // Something wrong here. We need to set it to no cache mode.

            WARNING("bReAllocCacheFile failed to allocate more buffer \n");
            gFntCache->flThisBoot |= FNT_CACHE_STATE_ERROR;
        }
    }

    return bOK;
}

/*****************************************************************************
 * ULONG QueryFontReg(PWCHAR pwcRegKeyPath, LARGE_INTEGER *pFontRegLastWriteTime)
 *
 * Helper function for query fonts information from TT and T1 fonts registry
 *
 * History
 *  4-3-98 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

BOOL QueryFontReg(PWCHAR pwcRegKeyPath, LARGE_INTEGER *pFontRegLastWriteTime, ULONG * pulFonts)
{
    NTSTATUS                Status;
    KEY_FULL_INFORMATION    KeyInfo;
    HANDLE                  hkey = NULL;
    DWORD                   Length;

    *pulFonts = 0;

    Status = GetGreRegKey(&hkey,KEY_READ, pwcRegKeyPath);

    if (NT_SUCCESS(Status))
    {

        // get the number of entries in the [Fonts] section and get the last write time
        Status = ZwQueryKey(hkey,
                            KeyFullInformation,
                            &KeyInfo,
                            sizeof(KeyInfo),
                            &Length);

        if (NT_SUCCESS(Status))
        {

        // for additional fonts that do not load from fonts section of the registry

            *pulFonts = KeyInfo.Values;
            pFontRegLastWriteTime->QuadPart =   KeyInfo.LastWriteTime.QuadPart;

            FNT_KdBreakPoint(FNTCACHE_DBG_LEVEL_0, (" %d items in Font key \n", *pulFonts));

        }

        ZwCloseKey(hkey);
    }

    return NT_SUCCESS(Status);
}

/*****************************************************************************
 * PVOID EngFntCacheAlloc(ULONG ulFastCheckSum, ULONG ulSize)
 *
 * Alloc the cached buffer for font driver
 *
 * History
 *  10-5-98 rewrite [YungT]
 *  8-22-98 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

extern "C"  PVOID EngFntCacheAlloc(ULONG ulFastCheckSum, ULONG ulSize)
{

    PVOID pvIfi = NULL;

    {
        if (ghsemFntCache == NULL)
            return pvIfi;

        SEMOBJ  so(ghsemFntCache);

        if (gflFntCacheState & FNT_CACHE_CREATE_MODE)
        {

            if ( (gFntCache->pCacheBuf + QWORD_ALIGN(ulSize) < gFntCache->pCacheBufEnd)
                || bReAllocCacheFile(ulSize))
            {
                FNTHLINK        *pFntHlink = NULL;

                if (pFntHlink = SearchFntCacheNewLink(ulFastCheckSum))
                {
                // If fast check sum is conflict, we can not cache it.

                   if (pFntHlink->cjData == 0 && pFntHlink->dpData == 0)
                   {
                        pvIfi = (PVOID) gFntCache->pCacheBuf;

                   // Gaurantee the cache pointer is at 8 byte boundary

                        gFntCache->pCacheBuf = gFntCache->pCacheBuf + QWORD_ALIGN(ulSize);
                        pFntHlink->cjData = ulSize;
                        pFntHlink->dpData = (DWORD) ((PBYTE) pvIfi - gFntCache->pCacheBufStart);
                    }
                    else
                    {
                        WARNING("Checksum conflict in  EngFntCacheAlloc");
                        pFntHlink->flLink |= FNT_CACHE_CHECKSUM_CONFLICT;
                    }

                    gFntCache->bWrite = TRUE;
                }
            }
        }
        else
        {
            ASSERTGDI(gflFntCacheState & FNT_CACHE_LOOKUP_MODE,
                      "EngFntCacheAlloc: gflFntCacheState\n");

        // During read mode, the remote session still wants to write into fntcache.dat.
        // This could happen if RemoteSession1 adds more fonts to both registry and on the disk.
        // Then later, the RemoteSession2 may attepmpt during its initialization to add these fonts
        // to the font cache, but we will reject this and ask that on the next boot the cache file
        // be rebuilt. also, the files could have been overwritten on the disk without
        // registry entries being updated, so we just force rebuild next time to be safe.

            gFntCache->flThisBoot |= FNT_CACHE_STATE_FULL;
        }
    }

    if (gFntCache->flThisBoot & FNT_CACHE_STATE_ERROR)
    {
        CloseFNTCache();
        pvIfi = NULL;
    }

    return pvIfi;
}

/*****************************************************************************
 * PVOID EngFntCacheLookUp(ULONG FastCheckSum, ULONG *pcjData)
 *
 * Lookup font cache
 *
 * History
 *  10-5-98 rewrite [YungT]
 *  8-22-98 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

extern "C" PVOID EngFntCacheLookUp(ULONG FastCheckSum, ULONG *pcjData)
{
    FNTHLINK   *pFntHlink;
    PBYTE       pCache = NULL;

    *pcjData = 0;
    pFntHlink = NULL;

    if (ghsemFntCache == NULL)
       return (PVOID) pCache;

    SEMOBJ  so(ghsemFntCache);

    if (gflFntCacheState & FNT_CACHE_LOOKUP_MODE)
    {
        if (gFntCache->pTable)
        {

        // Search the cache table

            SearchFNTCacheHlink( FastCheckSum, &pFntHlink, gFntCache->pTable);

            if(pFntHlink && !(pFntHlink->flLink & FNT_CACHE_CHECKSUM_CONFLICT))
            {

                *pcjData = pFntHlink->cjData;

                if (*pcjData)
                {
                    pCache = gFntCache->pCacheBufStart + pFntHlink->dpData;

                }
            }
            #if DBG
            else
            {
                if (pFntHlink && (pFntHlink->flLink & FNT_CACHE_CHECKSUM_CONFLICT))
                    WARNING("Catch the checksum conflict in EngFntCacheLookUp \n");
            }
            #endif
        }

    }

    return (PVOID) pCache;
}


/*****************************************************************************
 * VOID  InitNewCacheTable()
 *
 * Initialize font cache, open the fntcache,dat file and create hash table
 *
 * History
 *  4-3-98 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

BOOL  bInitCacheTable(ULONG ulTTFonts, ULONG ulT1Fonts, LARGE_INTEGER FntRegLWT, LARGE_INTEGER T1RegLWT, 
                       LARGE_INTEGER Win32kLWT, LARGE_INTEGER AtmfdLWT, ULONG CodePage)
{
    ULONG   ulSize, ulIfiSize;
    BOOL bOk = FALSE;
    ULONG   ulMaxFonts;
    FILEVIEW        FileView;

    ulMaxFonts = ulTTFonts + ulT1Fonts + RESERVE_LINKS;

    ulSize = SZ_FNTCACHE(ulMaxFonts) + SZ_FNTIFICACHE(ulTTFonts, ulT1Fonts);

    if (gFntCache->pTable)
    {
       vUnmapFontCacheFile();
    }

    RtlZeroMemory(&FileView, sizeof(FILEVIEW));

    if(bMapFile(FNTCACHEPATH, &FileView, ulSize, NULL))
    {
        gFntCache->pTable = (FNTCACHEHEADER *) FileView.pvKView;
        gFntCache->pSection = FileView.pSection;

        RtlFillMemory((PBYTE) gFntCache->pTable->aiBuckets,
                    FNTCACHE_MAX_BUCKETS * sizeof(DWORD), 0xFF);
        RtlZeroMemory((PBYTE) gFntCache->pTable->ahlnk,
                    ulMaxFonts * sizeof(FNTHLINK));

        gFntCache->pTable->ulCodePage = (ULONG) CodePage;
        gFntCache->pTable->ulMaxFonts = ulMaxFonts;
        gFntCache->pTable->ulTotalLinks = 0;
        gFntCache->pTable->CheckSum = 0;
        gFntCache->pTable->FntRegLWT.QuadPart = FntRegLWT.QuadPart;
        gFntCache->pTable->T1RegLWT.QuadPart = T1RegLWT.QuadPart;
        gFntCache->pTable->Win32kLWT.QuadPart = Win32kLWT.QuadPart;
        gFntCache->pTable->AtmfdLWT.QuadPart = AtmfdLWT.QuadPart;
        
        gFntCache->pTable->ulFileSize = ulSize;
        gFntCache->pTable->cjDataAll = SZ_FNTIFICACHE(ulTTFonts, ulT1Fonts);
        gFntCache->pTable->cjDataExtra = 0;
        gFntCache->pTable->cjDataUsed = 0;

        bOk = TRUE;
    }

    return bOk;
}

/*****************************************************************************
 * VOID  InitFNTCache()
 *
 * Initialize font cache, open the fntcache,dat file and create hash table
 *
 * History
 *  4-3-98 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

VOID  InitFNTCache()
{

    LARGE_INTEGER           FntRegLWT = { 0, 0};
    LARGE_INTEGER           T1RegLWT = { 0, 0};
    LARGE_INTEGER           Win32kLWT = { 0, 0};
    LARGE_INTEGER           AtmfdLWT = { 0, 0};

    ULONG                   ulTTFonts = 0;
    ULONG                   ulT1Fonts;
    ULONG                   ulSize = 0;
    BOOL                    bQryFntReg = FALSE;
    USHORT                  AnsiCodePage, OemCodePage;
    BOOL                    bLocked = TRUE;

// Initialize all the global variables

    gflFntCacheState = 0;

    ghsemFntCache = GreCreateSemaphore();

    if (ghsemFntCache == NULL)
    {
        goto CleanUp;
    }
    
// Only for performance evaluation.
    if (bFntCacheDisabled())
    {
        goto CleanUp;
    }

// Initialize and zero out all the memory
    gFntCache = (FNTCACHE *) PALLOCMEM(sizeof(FNTCACHE), 'CFTT');

// There is something wrong we can not allocate buf
    if (!gFntCache)
    {
        goto CleanUp;
    }
    
    if (G_fConsole)
        bLocked = bSetFntCacheReg(DISABLE_REMOTE_FONT_BOOT_CACHE, 1);

// If we can not lock the font cache file, 
// then we can not open it in console 

    if (!bLocked)
    {
        goto CleanUp;
    }

    gFntCache->pTable = NULL;
    gFntCache->ulCurrentHlink = 0;
    gFntCache->hDev[0] = 0;
    gFntCache->hDev[1] = 0;
    gFntCache->hDev[2] = 0;
    gFntCache->hDev[3] = 0;
    gFntCache->hDev[4] = 0;
    gFntCache->bWrite = FALSE;

    RtlGetDefaultCodePage(&AnsiCodePage,&OemCodePage);

 // Get the last boot time status

    vGetLastBootTimeStatus();

// Get LWT of font driver

    vGetFontDriverLWT(&Win32kLWT, &AtmfdLWT);

// now open the TT Fonts key :

    if (QueryFontReg(L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Fonts",
                            &FntRegLWT, &ulTTFonts))
    {
        ulTTFonts += FNTCACHE_EXTRA_LINKS;

    // now open the Type 1 Fonts key :
        if (QueryFontReg(L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Type 1 Installer\\Type 1 Fonts",
                            &T1RegLWT, &ulT1Fonts))
        {
            bQryFntReg = TRUE;
        }
    }

    {
        FILEVIEW FileView;

        RtlZeroMemory(&FileView, sizeof(FILEVIEW));

        if (bMapFile(FNTCACHEPATH, &FileView, 0, NULL))
        {
            gFntCache->pTable = (FNTCACHEHEADER *) FileView.pvKView;
            gFntCache->pSection = (FNTCACHEHEADER *) FileView.pSection;
        }

        if (gFntCache->pTable)
        {
            ULONG   ulCheckSum;
            BOOL    bCacheRead;
            BOOL    bCheckSum;

            bCacheRead = FALSE;
            bCheckSum = FALSE;

            // File did not change from last time boot.

            if (gFntCache->pTable->CheckSum && FileView.cjView == gFntCache->pTable->ulFileSize &&
                gFntCache->pTable->CheckSum == FNTCacheFileCheckSum(gFntCache->pTable, FileView.cjView) &&
                gFntCache->pTable->AtmfdLWT.QuadPart == AtmfdLWT.QuadPart && // current signature of atmfd
                gFntCache->pTable->ulCodePage == AnsiCodePage &&  // If locale changed, we need to re-create the cache
                !(gFntCache->flPrevBoot & FNT_CACHE_STATE_ERROR) && // No error at last boot time
                (!G_fConsole ||   // for remote session would not care about the registry update
                    (!(gFntCache->flPrevBoot & FNT_CACHE_STATE_FULL) &&
                     gFntCache->pTable->Win32kLWT.QuadPart == Win32kLWT.QuadPart && // check signature of win32k.sys
                     FntRegLWT.QuadPart == gFntCache->pTable->FntRegLWT.QuadPart &&  // Check date time of cache file
                     T1RegLWT.QuadPart == gFntCache->pTable->T1RegLWT.QuadPart
                    )
                )
            )
            {
                gflFntCacheState = FNT_CACHE_LOOKUP_M