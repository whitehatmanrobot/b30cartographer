// StartTraceAPI.cpp : Defines the entry point for the DLL application.
//
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#include "stdafx.h"

#pragma warning (disable : 4786)
#pragma warning (disable : 4275)

#include <iostream>
#include <strstream>
#include <fstream>
#include <string>
#include <sstream>
#include <map>
#include <ctime>
#include <list>


using namespace std;


#include <tchar.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>

#include <WTYPES.H>
#include "t_string.h"

#include "StructureWrappers.h"
#include "StructureWapperHelpers.h"
#include "ConstantMap.h" 
#include "TCOData.h"
#include "Persistor.h"
#include "Logger.h"
#include "Validator.h"
#include "Utilities.h"

#include "CollectionControl.h"



int StartTraceAPI
(
	IN LPTSTR lptstrAction,				// For logging only.
 	IN LPCTSTR lpctstrDataFile,			// For logging only.
	IN LPCTSTR lpctstrTCODetailFile,	// If valid we will log to it, can be NULL.
	IN bool bLogExpected,				// If true we log expected vs actual result.
	IN OUT TCOData *pstructTCOData,		// TCO test data.
	OUT int *pAPIReturn					// StartTrace API call return
)
{
	LPTSTR lpstrReturnedError = NULL;
	*pAPIReturn = -1;

	CLogger *pDetailLogger = NULL;

	int nResult = 0;

	// We only log if the test of "interest" is StartTrace.
	if (pstructTCOData->m_ulAPITest == TCOData::StartTraceTest)
	{
		nResult = 
			OpenLogFiles
			(	
				lpctstrTCODetailFile,
				pDetailLogger,
				&lpstrReturnedError
			);
	}
	
	if (FAILED(nResult))
	{
		delete pDetailLogger;
		//  Open log files sets error string plpstrReturnedError.

		LogSummaryBeforeCall
		(	
			pstructTCOData, 
			lpctstrDataFile,
			lptstrAction,
			_T("StartTrace"),
			bLogExpected
		);

		LogSummaryAfterCall
		(	
			pstructTCOData, 
			lpctstrDataFile,
			lptstrAction,
			nResult,
			lpstrReturnedError,
			bLogExpected
		);
		free(lpstrReturnedError);
		lpstrReturnedError = NULL;
		return nResult;
	}
			
	// This is our log file, not to be confused with the StartTrace
	// log file.
	if (pDetailLogger)
	{
		pDetailLogger->LogTCHAR(_T("\n-------------------------------------------------------\n"));
		pDetailLogger->LogTCHAR(_T("StartTraceAPI TCO test "));
		pDetailLogger->Flush();	
	}

	if (pDetailLogger)
	{
		pDetailLogger->LogTCHAR(pstructTCOData->m_lptstrShortDesc);
		int n = pDetailLogger->LogTCHAR(_T(" started at time "));
		time_t Time;
		time(&Time);
		pDetailLogger->LogTime(Time);
		pDetailLogger->LogTCHAR(_T(".\n"));
		pDetailLogger->Flush();
	}

	if (pstructTCOData->m_ulExpectedResult == ERROR_SUCCESS 
		&& pstructTCOData->m_ulAPITest != TCOData::OtherTest)
	{
		// We will verify that the LogFileName is valid if we expect the
		// call to succeed because it will fail if not a valid file.
		if (pstructTCOData->m_pProps && 
			pstructTCOData->m_pProps->LogFileName != NULL 
			&& _tcslen(pstructTCOData->m_pProps->LogFileName) > 0)
		{	
			// Verify file.
			HANDLE fileHandle = 
				CreateFile
				(
					pstructTCOData->m_pProps->LogFileName,
					GENERIC_READ | GENERIC_WRITE,
					FILE_SHARE_READ,
					NULL,
					OPEN_ALWAYS,
					FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING,
					NULL
				);

			if (fileHandle == INVALID_HANDLE_VALUE) 
			{
				DWORD dwError = HRESULT_FROM_WIN32(GetLastError());

				LPTSTR lptstrError  = DecodeStatus(dwError);

				t_string tsError;

				tsError = _T("StartTraceAPI error on CreateFile for ");
				tsError += pstructTCOData->m_pProps->LogFileName;
				tsError += _T(":  ");
				t_string tsError2;
				tsError2 = lptstrError;
				tsError += tsError2;
				
				free (lptstrError);
				lptstrError = NULL;

				if (pDetailLogger)
				{
					pDetailLogger->LogTCHAR(tsError.c_str());
					pDetailLogger->Flush();
				}
				
				delete pDetailLogger;

				LogSummaryBeforeCall
				(	
					pstructTCOData, 
					lpctstrDataFile,
					lptstrAction,
					_T("StartTrace"),
					bLogExpected
				);

				LogSummaryAfterCall
				(	
					pstructTCOData, 
					lpctstrDataFile,
					lptstrAction,
					*pAPIReturn,
					(TCHAR *) tsError.c_str(),
					bLogExpected
				);

				return dwError;
			}
			
			CloseHandle(fileHandle);
			// Delete the file so that we have a clean slate. 
			DeleteFile(pstructTCOData->m_pProps->LogFileName);
		}
		else
		{
			// File either null of empty.
			t_string tsError;

			tsError = _T("StartTraceAPI got null or empty LogFileName ");
			tsError += _T("from the TCO data file.\n");

			if (pDetailLogger)
			{
				pDetailLogger->LogTCHAR(tsError.c_str());
				pDetailLogger->Flush();
			}
			
			delete pDetailLogger;

			LogSummaryBeforeCall
			(	
				pstructTCOData, 
				lpctstrDataFile,
				lptstrAction,
				_T("StartTrace"),
				bLogExpected
			);

			LogSummaryAfterCall
			(	
				pstructTCOData, 
				lpctstrDataFile,
				lptstrAction,
				*pAPIReturn,
				(TCHAR *) tsError.c_str(),
				bLogExpected
			);

			return -1;
		}
	}

	BOOL bAdmin = IsAdmin();

	if (pDetailLogger)
	{
		// Log argument values before calling StartTrace.
		LogDetailBeforeCall
		(
			pDetailLogger,
			pstructTCOData,
			bAdmin
		);
	}

	LogSummaryBeforeCall
	(	
		pstructTCOData, 
		lpctstrDataFile,
		lptstrAction,
		_T("StartTrace"),
		bLogExpected
	);

	// Finally, make the dang API call!
	*pAPIReturn = 
		StartTrace
		(
			pstructTCOData->m_pTraceHandle, 
			pstructTCOData->m_lptstrInstanceName, 
			pstructTCOData->m_pProps
		);


	ULONG ulResult = pstructTCOData->m_ulExpectedResult == *pAPIReturn ? ERROR_SUCCESS : -1;

	bool bValid = true;

	if (ulResult != ERROR_SUCCESS && *pAPIReturn == ERROR_SUCCESS)
	{
		ulResult = *pAPIReturn;
	}
	else if (*pAPIReturn != ERROR_SUCCESS) 
	{
		lpstrReturnedError = DecodeStatus(*pAPIReturn);	
	}
	else if (pstructTCOData->m_ulAPITest == TCOData::StartTraceTest && 
			 pstructTCOData->m_lptstrValidator && 
			 _tcslen(pstructTCOData->m_lptstrValidator) > 0)
	{
		CValidator Validator;
			
		bool bValid = 
			Validator.Validate
			(
				pstructTCOData->m_pTraceHandle, 
				pstructTCOData->m_lptstrInstanceName, 
				pstructTCOData->m_pProps, 
				pstructTCOData->m_lptstrValidator
			);

		if (!bValid)
		{
			ulResult = -1;
			lpstrReturnedError = NewTCHAR(_T("Validation routine failed."));
		}
	}
		
	if (pDetailLogger)
	{
		LogDetailAfterCall
		(	pDetailLogger,
			pstructTCOData,
			&pstructTCOData->m_pProps,
			*pAPIReturn,
			lpstrReturnedError,
			bValid,
			bAdmin
		);
	}

	LogSummaryAfterCall
		(	
			pstructTCOData, 
			lpctstrDataFile,
			lptstrAction,
			*pAPIReturn,
			lpstrReturnedError,
			bLogExpected
		);

	free(lpstrReturnedError);
	lpstrReturnedError = NULL;
	
	delete pDetailLogger;

	return ulResult;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\logger\querytraceapi.cpp ===
// 
//
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#include "stdafx.h"

#pragma warning (disable : 4786)
#pragma warning (disable : 4275)

#include <iostream>
#include <strstream>
#include <fstream>
#include <string>
#include <sstream>
#include <map>
#include <ctime>
#include <list>


using namespace std;


#include <tchar.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>

#include <WTYPES.H>
#include "t_string.h"

#include "StructureWrappers.h"
#include "StructureWapperHelpers.h"
#include "ConstantMap.h" 
#include "TCOData.h"
#include "Persistor.h"
#include "Logger.h"
#include "Validator.h"
#include "Utilities.h"

#include "CollectionControl.h"
  
int QueryTraceAPI
(	
	IN LPTSTR lptstrAction,				// For logging only.
 	IN LPCTSTR lpctstrDataFile,			// For logging only.
	IN LPCTSTR lpctstrTCODetailFile,	// If valid we will log to it, can be NULL.
	IN bool bLogExpected,				// If true we log expected vs actual result.
	IN bool bUseTraceHandle,			// If true use the handle.
	IN OUT TCOData *pstructTCOData,		// TCO test data.
	OUT int *pAPIReturn					// QueryTrace API call return
)
{	
	// If bUseTracehandle is true we can check for differences in 
	// props.

	*pAPIReturn = -1;

	LPTSTR lptstrReturnedError = NULL;

	CLogger *pDetailLogger = NULL;

	int nResult = 0;

	// We only log if the test of "interest" is QueryTrace.
	if (pstructTCOData->m_ulAPITest == TCOData::QueryTraceTest)
	{
		nResult = 
			OpenLogFiles
			(	
				lpctstrTCODetailFile,
				pDetailLogger,
				&lptstrReturnedError
			);
	}

	if (FAILED(nResult))
	{
		delete pDetailLogger;
		//  Open log files sets error string plpstrReturnedError.

		LogSummaryBeforeCall
		(	
			pstructTCOData, 
			lpctstrDataFile,
			lptstrAction,
			_T("StartTrace"),
			bLogExpected
		);

		LogSummaryAfterCall
		(	
			pstructTCOData, 
			lpctstrDataFile,
			lptstrAction,
			nResult,
			lptstrReturnedError,
			bLogExpected
		);
		free (lptstrReturnedError);
		lptstrReturnedError = NULL;
		return nResult;
	}
			
	// This is our log file.
	if (pDetailLogger)
	{
		pDetailLogger->LogTCHAR(_T("\n-------------------------------------------------------\n"));
		pDetailLogger->LogTCHAR(_T("QueryTraceAPI TCO test "));
		pDetailLogger->Flush();	
	}

	if (pDetailLogger)
	{
		pDetailLogger->LogTCHAR(pstructTCOData->m_lptstrShortDesc);
		int n = pDetailLogger->LogTCHAR(_T(" started at time "));
		time_t Time;
		time(&Time);
		pDetailLogger->LogTime(Time);
		pDetailLogger->LogTCHAR(_T(".\n"));
		pDetailLogger->Flush();
	}

	BOOL bAdmin = IsAdmin();

	if (pDetailLogger)
	{
		// Log argument values before calling StopTrace.
		LogDetailBeforeCall
		(
			pDetailLogger,
			pstructTCOData,
			bAdmin
		);
	}

	CEventTraceProperties CProps (pstructTCOData->m_pProps);
	PEVENT_TRACE_PROPERTIES pProps = CProps.GetEventTracePropertiesInstance();
	free(pProps->LogFileName);
	free(pProps->LoggerName);
	pProps->LogFileName = (TCHAR *) malloc (sizeof(TCHAR) * MAX_STR);
	pProps->LoggerName = (TCHAR *) malloc (sizeof(TCHAR) * MAX_STR);

	LogSummaryBeforeCall
	(	
		pstructTCOData, 
		lpctstrDataFile,
		lptstrAction,
		_T("QueryTrace"),
		bLogExpected
	);

	*pAPIReturn = 
		QueryTrace
		( 
			bUseTraceHandle ? *pstructTCOData->m_pTraceHandle : NULL, 
			bUseTraceHandle ? NULL : pstructTCOData->m_lptstrInstanceName, 
			pProps);

	ULONG ulResult = pstructTCOData->m_ulExpectedResult == *pAPIReturn ? ERROR_SUCCESS : -1;

	if (ulResult != ERROR_SUCCESS && *pAPIReturn == ERROR_SUCCESS)
	{
		ulResult = *pAPIReturn;
	}
	else if (*pAPIReturn != ERROR_SUCCESS) 
	{
		lptstrReturnedError = DecodeStatus(*pAPIReturn);	
	}
	else if (pstructTCOData->m_ulAPITest == TCOData::QueryTraceTest &&
			 pstructTCOData->m_lptstrValidator &&
			 _tcslen(pstructTCOData->m_lptstrValidator) > 0)
	{
		CValidator Validator;
			
		bool bValid = 
			Validator.Validate
			(
				pstructTCOData->m_pTraceHandle, 
				pstructTCOData->m_lptstrInstanceName, 
				pstructTCOData->m_pProps, 
				pstructTCOData->m_lptstrValidator
			);

		if (!bValid)
		{
			ulResult = -1;
			lptstrReturnedError = NewTCHAR(_T("Validation routine failed."));
		}
	}

	bool bDiff = FALSE;
	if (bUseTraceHandle)
	{
		bDiff = 
			LogPropsDiff
			(
				NULL,
				pstructTCOData->m_pProps,
				pProps
			);
	}

	// If there were differences and 
	// *pAPIReturn == ERROR_SUCCESS == pstructTCOData->m_ulExpectedResult
	// we need to set return codes to indicate differences.  Look in detail
	// log for differences.
	if (bDiff &&
		*pAPIReturn == ERROR_SUCCESS &&
		pstructTCOData->m_ulExpectedResult == ERROR_SUCCESS)
	{
		free (lptstrReturnedError);
		lptstrReturnedError = NULL;
		*pAPIReturn = -1;
		lptstrReturnedError = 
			NewTCHAR(_T("Different values returned in EVENT_TRACE_PROPERTIES structure."));
	}

	if (pDetailLogger)
	{
		LogDetailAfterCall
		(	pDetailLogger,
			pstructTCOData,
			&pProps,
			*pAPIReturn,
			lptstrReturnedError,
			true,
			bAdmin,
			NULL,
			*pAPIReturn == ERROR_SUCCESS // Do not print out Props if not a good return.
		);	
	}

	if (bUseTraceHandle)
	{
		LogPropsDiff
			(
				pDetailLogger,
				pstructTCOData->m_pProps,
				pProps
			);
	}

	LogSummaryAfterCall
		(	
			pstructTCOData, 
			lpctstrDataFile,
			lptstrAction,
			*pAPIReturn,
			lptstrReturnedError,
			bLogExpected
		);
	
	free (lptstrReturnedError);
	lptstrReturnedError = NULL;

	delete pDetailLogger;

	if (pProps)
	{
		free(pProps->LoggerName);
		free(pProps->LogFileName);
	}
	free(pProps);	

	return ulResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\logger\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	TestStartTrace.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\logger\stoptraceapi.cpp ===
// 
//
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#include "stdafx.h"

#pragma warning (disable : 4786)
#pragma warning (disable : 4275)

#include <iostream>
#include <strstream>
#include <fstream>
#include <string>
#include <sstream>
#include <map>
#include <ctime>
#include <list>


using namespace std;


#include <tchar.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>

#include <WTYPES.H>
#include "t_string.h"

#include "StructureWrappers.h"
#include "StructureWapperHelpers.h"
#include "ConstantMap.h" 
#include "TCOData.h"
#include "Persistor.h"
#include "Logger.h"
#include "Validator.h"
#include "Utilities.h"

#include "CollectionControl.h"
  
int StopTraceAPI
(	
	IN LPTSTR lptstrAction,				// For logging only.	
	IN LPCTSTR lpctstrDataFile,			// For logging only.
	IN LPCTSTR lpctstrTCODetailFile,	// If valid we will log to it, can be NULL.
	IN bool bLogExpected,				// If true we log expected vs actual result.
	IN bool bUseTraceHandle,			// If true use the handle.
	IN OUT TCOData *pstructTCOData,		// TCO test data.
	OUT int *pAPIReturn					// StopTrace API call return
)
{	
	LPTSTR lpstrReturnedError = NULL;
	*pAPIReturn = -1;

	CLogger *pDetailLogger = NULL;

	int nResult = 0;

	// We only log if the test of "interest" is StopTrace.
	if (pstructTCOData->m_ulAPITest == TCOData::StopTraceTest)
	{
		nResult = 
			OpenLogFiles
			(	
				lpctstrTCODetailFile,
				pDetailLogger,
				&lpstrReturnedError
			);
	}

	if (FAILED(nResult))
	{
		delete pDetailLogger;
		//  Open log files sets error string plpstrReturnedError.
			
		LogSummaryBeforeCall
		(	
			pstructTCOData, 
			lpctstrDataFile,
			lptstrAction,
			_T("StopTrace"),
			bLogExpected
		);

		LogSummaryAfterCall
		(	
			pstructTCOData, 
			lpctstrDataFile,
			lptstrAction,
			nResult,
			lpstrReturnedError,
			bLogExpected
		);
		free(lpstrReturnedError);
		lpstrReturnedError = NULL;

		return nResult;
	}
			
	// This is our log file.
	if (pDetailLogger)
	{
		pDetailLogger->LogTCHAR(_T("\n-------------------------------------------------------\n"));
		pDetailLogger->LogTCHAR(_T("StopTraceAPI TCO test "));
		pDetailLogger->Flush();	
	}

	if (pDetailLogger)
	{
		pDetailLogger->LogTCHAR(pstructTCOData->m_lptstrShortDesc);
		int n = pDetailLogger->LogTCHAR(_T(" started at time "));
		time_t Time;
		time(&Time);
		pDetailLogger->LogTime(Time);
		pDetailLogger->LogTCHAR(_T(".\n"));
		pDetailLogger->Flush();
	}

	BOOL bAdmin = IsAdmin();

	if (pDetailLogger)
	{
		// Log argument values before calling StopTrace.
		LogDetailBeforeCall
		(
			pDetailLogger,
			pstructTCOData,
			bAdmin
		);
	}

	LogSummaryBeforeCall
		(	
			pstructTCOData, 
			lpctstrDataFile,
			lptstrAction,
			_T("StopTrace"),
			bLogExpected
		);

	*pAPIReturn = 
		StopTrace
		(
			bUseTraceHandle ? *pstructTCOData->m_pTraceHandle : NULL,
			bUseTraceHandle ? NULL : pstructTCOData->m_lptstrInstanceName, 
			pstructTCOData->m_pProps
		);

	
	ULONG ulResult = pstructTCOData->m_ulExpectedResult == *pAPIReturn ? ERROR_SUCCESS : -1;

	bool bValid = true;

	if (ulResult != ERROR_SUCCESS && *pAPIReturn == ERROR_SUCCESS )
	{
		ulResult = *pAPIReturn;
	}
	else if (*pAPIReturn != ERROR_SUCCESS) 
	{
		lpstrReturnedError = DecodeStatus(*pAPIReturn);	
	}
	else if (pstructTCOData->m_ulAPITest == TCOData::StopTraceTest &&
			 pstructTCOData->m_lptstrValidator &&
			 _tcslen(pstructTCOData->m_lptstrValidator) > 0)
	{
		CValidator Validator;
			
		bool bValid = 
			Validator.Validate
			(
				pstructTCOData->m_pTraceHandle, 
				pstructTCOData->m_lptstrInstanceName, 
				pstructTCOData->m_pProps, 
				pstructTCOData->m_lptstrValidator
			);

		if (!bValid)
		{
			ulResult = -1;
			lpstrReturnedError = NewTCHAR(_T("Validation routine failed."));
		}
	}
		

	if (pDetailLogger)
	{
		LogDetailAfterCall
		(	pDetailLogger,
			pstructTCOData,
			&pstructTCOData->m_pProps,
			*pAPIReturn,
			lpstrReturnedError,
			bValid,
			bAdmin
		);
	}


	LogSummaryAfterCall
		(
			pstructTCOData, 
			lpctstrDataFile,
			lptstrAction,
			*pAPIReturn,
			lpstrReturnedError,
			bLogExpected
		);
	

	free(lpstrReturnedError);
	lpstrReturnedError = NULL;

	delete pDetailLogger;

	return ulResult;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\logger\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__991FD5F0_FC29_11D2_8052_009027345EE2__INCLUDED_)
#define AFX_STDAFX_H__991FD5F0_FC29_11D2_8052_009027345EE2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// Insert your headers here
#ifndef NT5BUILD
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#include <stdio.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__991FD5F0_FC29_11D2_8052_009027345EE2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\logger\structurewapperhelpers.h ===
// StructureWapperHelpers.h
//
//////////////////////////////////////////////////////////////////////
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#if !defined(AFX_STRUCTUREWAPPERHELPERS_H__A349C060_ED4F_11D2_804A_009027345EE2__INCLUDED_)
#define AFX_STRUCTUREWAPPERHELPERS_H__A349C060_ED4F_11D2_804A_009027345EE2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

void LogFileModeOut(t_ostream &ros, ULONG LogFileMode);
void EnableFlagsOut(t_ostream &ros, ULONG EnableFlags);
void WnodeFlagsOut(t_ostream &ros, ULONG WnodeFlags);
void GUIDOut(t_ostream &ros, GUID Guid);
void LARGE_INTEGEROut(t_ostream &ros, LARGE_INTEGER Large);

void InitializeTCHARVar(t_string &rtsValue , void *pVar);
void InitializeEnumVar(t_string &rtsValue , void *pVar);
void InitializeHandleVar(t_string &rtsValue , void *pVar);
void InitializeULONGVar(t_string &rtsValue , void *pVar, bool bHex = false);
void InitializeLONGVar(t_string &rtsValue , void *pVar);
void InitializeGUIDVar(t_string &rtsValue , void *pVar);

t_istream &GetALine(t_istream &ris,TCHAR *tcBuffer, int nBufferSize);
t_ostream &PutALine(t_ostream &ros,const TCHAR *tcBuffer, int nBufferSize = -1);

t_istream &GetAChar(t_istream &ris,TCHAR &tc);

t_ostream &PutAULONGVar(t_ostream &ros, ULONG ul, bool bHex = false);
t_ostream &PutALONGVar(t_ostream &ros, LONG l, bool bHex = false);
t_ostream &PutADWORDVar(t_ostream &ros, DWORD dw);
t_ostream &PutAULONG64Var(t_ostream &ros, ULONG64 ul64);

BOOL wGUIDFromString(LPCTSTR lpsz, LPGUID pguid);

int case_insensitive_compare(t_string &r1, t_string &r2);
int case_insensitive_compare(TCHAR *p, t_string &r2);
int case_insensitive_compare(t_string &r1,TCHAR *p );
int case_insensitive_compare(TCHAR *p1,TCHAR *p2);





#endif // !defined(AFX_STRUCTUREWAPPERHELPERS_H__A349C060_ED4F_11D2_804A_009027345EE2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\logger\structurewrappers.h ===
// StructureWrappers.h: interface for the CStructureWrappers class.
//
//////////////////////////////////////////////////////////////////////
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#if !defined(AFX_STRUCTUREWRAPPERS_H__138A24E0_ED34_11D2_804A_009027345EE2__INCLUDED_)
#define AFX_STRUCTUREWRAPPERS_H__138A24E0_ED34_11D2_804A_009027345EE2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class CPersistor;
class CEventTraceProperties;

// Need to be declared before seen in class.  Well, duh!
t_ostream& operator<<
	(t_ostream &ros,const CEventTraceProperties &r);
t_istream& operator>>
	(t_istream &ris,CEventTraceProperties &r);


// The general methodology used here may seem clunky to
// a C programmer.  
// If you want to serialize an existing
// EVENT_TRACE_PROPERTIES instance use the Constructor
// "CEventTraceProperties(PEVENT_TRACE_PROPERTIES pProps)"
// to create a CEventTraceProperties instance, call
// Persist, and then destroy the CEventTraceProperties
// instance.
// If you want to de-deserialize an instance call the 
// Constructor "CEventTraceProperties()", call Persist,
// call GetEventTracePropertiesInstance, then destroy the
// CEventTraceProperties instance.
// The copy constructor and assignment operators are included
// only for completeness and it is anticipated that they
// will not be used.
// Using Persist for de-serialization assumes you have a valid
// stream which contains a serialized instance.   
class CEventTraceProperties 
{
private:
	friend t_ostream& operator<<
		(t_ostream &ros,const CEventTraceProperties &r);
	friend t_istream& operator>>
		(t_istream &ris,CEventTraceProperties &r);
	friend class CPersistor;

public:
	CEventTraceProperties();
	// This constructor creates a new EVENT_TRACE_PROPERTIES 
	// instance.
	CEventTraceProperties(PEVENT_TRACE_PROPERTIES pProps);
	virtual ~CEventTraceProperties();

	CEventTraceProperties(CEventTraceProperties &rhs);
	CEventTraceProperties &CEventTraceProperties::operator=
					(CEventTraceProperties &rhs);

	virtual HRESULT Persist (CPersistor &rPersistor);
	bool DeSerializationOK() {return m_bDeSerializationOK;}

	// Constructs an new EVENT_TRACE_PROPERTIES instance and
	// returns it.
	PEVENT_TRACE_PROPERTIES GetEventTracePropertiesInstance();
	bool IsNULL() {return m_bIsNULL;}

protected:
	bool m_bDeSerializationOK;
	bool m_bIsNULL;
	void Initialize(PEVENT_TRACE_PROPERTIES pProps);
	void InitializeMemberVar(TCHAR *ptszValue, int nVar);
	void *m_pVarArray[19];


	PEVENT_TRACE_PROPERTIES m_pProps;



};

#endif // !defined(AFX_STRUCTUREWRAPPERS_H__138A24E0_ED34_11D2_804A_009027345EE2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\logger\structurewapperhelpers.cpp ===
// StructureWapperHelpers.cpp
//
//////////////////////////////////////////////////////////////////////
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#include "stdafx.h"

#pragma warning (disable : 4786)
#pragma warning (disable : 4275)

#include <iostream>
#include <strstream>
#include <fstream>
#include <string>
#include <sstream>
#include <map>
#include <list>


using namespace std;

#include <tchar.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>


#include <WTYPES.H>
#include "t_string.h"


#include "Persistor.h"
#include "Logger.h"
#include "TCOData.h"
#include "Utilities.h"

#include "StructureWrappers.h"
#include "StructureWapperHelpers.h"
#include "ConstantMap.h"
  
extern CConstantMap g_ConstantMap;

static TCHAR g_tcNl = _T('\n');
static TCHAR g_tcCR = 0x0d;
static TCHAR g_tcLF = 0x0a;

#ifdef _UNICODE
static TCHAR g_tcDQuote[] = _T("\"");
static TCHAR g_atcNL[] = {0x0d, 0x0a, 0x00};
#else
static TCHAR g_atcNL[] = {g_tcNl};
static TCHAR g_tcDQuote = _T('"');
#endif


// Why we are not using formatted input:
#if 0
From:	Phil Lucido (Exchange) 
Sent:	Friday, April 16, 1999 10:34 AM
To:	Judy Powell
Cc:	Visual C++ Special Interest Group
Subject:	RE: Wide character output via wfstream from the "Standard Library" 
using VC 6 Enterprise Edition SP2 on NT4 SP4

It looks like our iostreams implementation for wide-char streams is actually wide-char 
in memory, multibyte chars on disk.  The reason you get an empty file is because wctomb 
is failing on 0xfeff.

This should work more like the stdio stuff, where a text mode wide-char stream writes 
multibyte chars to a file, but binary mode writes the raw unicode.

We get our C++ Library implementation from Dinkumware (P.J. Plauger).  I'll check with 
him to see about changing this implementation so binary mode wide-char iostream is 
compatible with wide-char stdio.

...Phil
#endif

//////////////////////////////////////////////////////////////////////
// Helpers
//////////////////////////////////////////////////////////////////////

void LogFileModeOut(t_ostream &ros, ULONG LogFileMode)
{
// EVENT_TRACE_FILE_MODE_NONE          0x0000  // logfile is off
// EVENT_TRACE_FILE_MODE_SEQUENTIAL    0x0001  // log sequentially
// EVENT_TRACE_FILE_MODE_CIRCULAR      0x0002  // log in circular manner
// EVENT_TRACE_FILE_MODE_NEWFILE       0x0004  // log to new file if full
// EVENT_TRACE_REAL_TIME_MODE          0x0100  // real time mode on
// EVENT_TRACE_DELAY_OPEN_FILE_MODE    0x0200  // delay opening file
// EVENT_TRACE_BUFFERING_MODE          0x0400  // buffering mode only

	t_string tsOut;
	
	// @#$ENUM: says that we are not storing a literal value. 
	tsOut = _T("\"LogFileMode:@#$ENUM:");
	PutALine(ros, tsOut.c_str());
	bool bFirstOut = true;

	// Values we anticipate.
	if (LogFileMode == 0)
	{
		tsOut = _T("0");
		PutALine(ros, tsOut.c_str());
		bFirstOut = false;
	}
	if (LogFileMode & EVENT_TRACE_FILE_MODE_NONE)
	{
		tsOut = _T("EVENT_TRACE_FILE_MODE_NONE");
		PutALine(ros, tsOut.c_str());
		bFirstOut = false;
	}
	if (LogFileMode & EVENT_TRACE_FILE_MODE_SEQUENTIAL)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FILE_MODE_SEQUENTIAL");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut =  _T("|EVENT_TRACE_FILE_MODE_SEQUENTIAL");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FILE_MODE_CIRCULAR");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut =  _T("|EVENT_TRACE_FILE_MODE_CIRCULAR");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (LogFileMode & EVENT_TRACE_FILE_MODE_NEWFILE)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FILE_MODE_NEWFILE");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FILE_MODE_NEWFILE");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (LogFileMode & EVENT_TRACE_REAL_TIME_MODE)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_REAL_TIME_MODE");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_REAL_TIME_MODE");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (LogFileMode & EVENT_TRACE_DELAY_OPEN_FILE_MODE)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_DELAY_OPEN_FILE_MODE");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_DELAY_OPEN_FILE_MODE");
			PutALine(ros, tsOut.c_str());
		}
	}

	if (LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_PRIVATE_LOGGER_MODE");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_PRIVATE_LOGGER_MODE");
			PutALine(ros, tsOut.c_str());
		}
	}

	if (LogFileMode & EVENT_TRACE_BUFFERING_MODE)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_BUFFERING_MODE");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_BUFFERING_MODE");
			PutALine(ros, tsOut.c_str());
		}
	}
	
	// A value we did not anticipate.

	ULONG uExpected = 
		EVENT_TRACE_FILE_MODE_NONE | 
		EVENT_TRACE_FILE_MODE_SEQUENTIAL | 
		EVENT_TRACE_FILE_MODE_CIRCULAR |
		EVENT_TRACE_FILE_MODE_NEWFILE |
		EVENT_TRACE_REAL_TIME_MODE |
		EVENT_TRACE_DELAY_OPEN_FILE_MODE |
		EVENT_TRACE_BUFFERING_MODE | 
		EVENT_TRACE_PRIVATE_LOGGER_MODE;

	if ((uExpected | LogFileMode) != uExpected)
	{
		if (bFirstOut)
		{
			tsOut = _T("@#$UNKNOWNVALUE:0x");
			PutALine(ros, tsOut.c_str());
			PutAULONGVar(ros, ~uExpected & LogFileMode, true);
		}
		else
		{
			tsOut = _T("|@#$UNKNOWNVALUE:0x");
			PutALine(ros, tsOut.c_str());
			PutAULONGVar(ros, ~uExpected & LogFileMode, true);
		}
	}

	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());
}

void EnableFlagsOut(t_ostream &ros, ULONG EnableFlags)
{
// EVENT_TRACE_FLAG_PROCESS            0x00000001  // process start & end
// EVENT_TRACE_FLAG_THREAD             0x00000002  // thread start & end
// EVENT_TRACE_FLAG_IMAGE_LOAD         0x00000004  // image load

// EVENT_TRACE_FLAG_DISK_IO            0x00000100  // physical disk IO
// EVENT_TRACE_FLAG_DISK_FILE_IO       0x00000200  // requires disk IO

// EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS 0x00001000  // all page faults
// EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS 0x00002000  // hard faults only

// EVENT_TRACE_FLAG_NETWORK_TCPIP      0x00010000  // tcpip send & receive
//
// Pre-defined Enable flags for everybody else
//
// EVENT_TRACE_FLAG_PRIVATE            0xC0000000  // Private buffering
// EVENT_TRACE_FLAG_EXTENSION          0x80000000  // indicates more flags
// EVENT_TRACE_FLAG_FORWARD_WMI        0x40000000  // Can forward to WMI
// EVENT_TRACE_FLAG_ENABLE_RESERVE1    0x20000000  // Reserved
// EVENT_TRACE_FLAG_ENABLE_RESERVE2    0x10000000  // Reserved

	t_string tsOut;

	// @#$ENUM: says that we are not storing a literal value. 
	tsOut =  _T("\"EnableFlags:@#$ENUM:");
	PutALine(ros, tsOut.c_str());
	bool bFirstOut = true;

	if (EnableFlags == 0)
	{
		tsOut = _T("0");
		PutALine(ros, tsOut.c_str());
		bFirstOut = false;
	}
	if (EnableFlags & EVENT_TRACE_FLAG_PROCESS)
	{
		tsOut = _T("EVENT_TRACE_FLAG_PROCESS");
		PutALine(ros, tsOut.c_str());
		bFirstOut = false;
	}
	if (EnableFlags & EVENT_TRACE_FLAG_THREAD)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_THREAD");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_THREAD");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (EnableFlags & EVENT_TRACE_FLAG_THREAD)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_THREAD");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_THREAD");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (EnableFlags & EVENT_TRACE_FLAG_IMAGE_LOAD)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_IMAGE_LOAD");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_IMAGE_LOAD");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (EnableFlags & EVENT_TRACE_FLAG_DISK_IO)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_DISK_IO");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_DISK_IO");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (EnableFlags & EVENT_TRACE_FLAG_DISK_FILE_IO)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_DISK_FILE_IO");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_DISK_FILE_IO");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (EnableFlags & EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (EnableFlags & EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (EnableFlags & EVENT_TRACE_FLAG_NETWORK_TCPIP)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_NETWORK_TCPIP");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_NETWORK_TCPIP");
			PutALine(ros, tsOut.c_str());
		}
	}
#if 0
	if (EnableFlags & EVENT_TRACE_FLAG_PRIVATE)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_PRIVATE");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_PRIVATE");
			PutALine(ros, tsOut.c_str());
		}
	}
#endif
	if (EnableFlags & EVENT_TRACE_FLAG_EXTENSION)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_EXTENSION");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_EXTENSION");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (EnableFlags & EVENT_TRACE_FLAG_FORWARD_WMI)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_FORWARD_WMI");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_FORWARD_WMI");
			PutALine(ros, tsOut.c_str());
		}
	}
#if 0
	if (EnableFlags & EVENT_TRACE_FLAG_ENABLE_RESERVE1)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_ENABLE_RESERVE1");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_ENABLE_RESERVE1");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (EnableFlags & EVENT_TRACE_FLAG_ENABLE_RESERVE2)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_ENABLE_RESERVE2");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_ENABLE_RESERVE2");
			PutALine(ros, tsOut.c_str());
		}
	}
#endif
	ULONG uExpected = 
		EVENT_TRACE_FLAG_PROCESS | 
		EVENT_TRACE_FLAG_THREAD | 
		EVENT_TRACE_FLAG_IMAGE_LOAD |
		EVENT_TRACE_FLAG_DISK_IO |
		EVENT_TRACE_FLAG_DISK_FILE_IO |
		EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS |
		EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS | 
		EVENT_TRACE_FLAG_NETWORK_TCPIP | 
		EVENT_TRACE_FLAG_EXTENSION |
		EVENT_TRACE_FLAG_FORWARD_WMI;

	if ((uExpected | EnableFlags) != uExpected)
	{
		if (bFirstOut)
		{
			tsOut = _T("@#$UNKNOWNVALUE:0x");
			PutALine(ros, tsOut.c_str());
			PutAULONGVar(ros, ~uExpected & EnableFlags, true);
		}
		else
		{
			tsOut = _T("|@#$UNKNOWNVALUE:0x");
			PutALine(ros, tsOut.c_str());
			PutAULONGVar(ros, ~uExpected & EnableFlags, true);
		}
	}
	
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());
}

// "Wnode.Flags:@#$ENUM:WNODE_FLAG_ALL_DATA"
void WnodeFlagsOut(t_ostream &ros, ULONG WnodeFlags)
{
	t_string tsOut;

	// @#$ENUM: says that we are not storing a literal value. 
	tsOut =  _T("\"Wnode.Flags:@#$ENUM:");
	PutALine(ros, tsOut.c_str());
	bool bFirstOut = true;

	if (WnodeFlags & WNODE_FLAG_TRACED_GUID)
	{
		if (bFirstOut)
		{
			tsOut = _T("WNODE_FLAG_TRACED_GUID");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|WNODE_FLAG_TRACED_GUID");
			PutALine(ros, tsOut.c_str());
		}
	}

	ULONG uExpected = 
		WNODE_FLAG_TRACED_GUID;

	if ((uExpected | WnodeFlags) != uExpected)
	{
		if (bFirstOut)
		{
			tsOut = _T("@#$UNKNOWNVALUE:0x");
			PutALine(ros, tsOut.c_str());
			PutAULONGVar(ros, ~uExpected & WnodeFlags, true);
		}
		else
		{
			tsOut = _T("|@#$UNKNOWNVALUE:0x");
			PutALine(ros, tsOut.c_str());
			PutAULONGVar(ros, ~uExpected & WnodeFlags, true);
		}
	}
	
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

}

// We print out a GUID in the form:
//  "{0000cbd1-0011-11d0-0d00-00aa006d010a}"
// typedef struct _GUID
// {
//    DWORD  Data1;
//    WORD   Data2;
//    WORD   Data3;
//    BYTE   Data4[8];
// } GUID;
// Data4 specifies an array of 8 bytes. The first 2 bytes contain 
// the third group of 4 hexadecimal digits. The remaining 6 bytes 
// contain the final 12 hexadecimal digits.  We have separate
// logic for acsii and unicode for Data4.
void GUIDOut(t_ostream &ros, GUID Guid)
{
	t_string tsOut;
	t_strstream strStream;

	strStream << _T("{");
	
	strStream.fill(_T('0'));
	strStream.width(8);
	strStream.flags(ros.flags() | ios_base::right);

	strStream << hex << Guid.Data1;

	strStream << _T("-");

	strStream.width(4);

	strStream << hex << Guid.Data2;

	strStream << _T("-");

	strStream << hex << Guid.Data3;

	strStream << _T("-");

	// Data4 specifies an array of 8 bytes. The first 2 bytes contain 
	// the third group of 4 hexadecimal digits. The remaining 6 bytes 
	// contain the final 12 hexadecimal digits. 

#ifndef _UNICODE
	int i;

	strStream.width(1);

	BYTE Byte;
	int Int;
	for (i = 0; i < 2; i++)
	{
		Byte = Guid.Data4[i];
		Byte = Byte >> 4;
		Int = Byte;
		strStream <<  hex << Int;
		Byte = Guid.Data4[i];
		Byte = 0x0f & Byte;
		Int = Byte;
		strStream << hex << Int;
	}

	strStream << _T("-");

	strStream.width(1);


	for (i = 2; i < 8; i++)
	{
		BYTE Byte = Guid.Data4[i];
		Byte = Byte >> 4;
		Int = Byte;
		strStream << hex << Int;
		Byte = Guid.Data4[i];
		Byte = 0x0f & Byte;
		Int = Byte;
		strStream << hex << Int;
	}
#else
	int i;

	for (i = 0; i < 2; i++)
	{
		TCHAR tc = Guid.Data4[i];
		// For some reason the width is reset each time through the 
		// loop to be one.
		strStream.width(2);
		strStream << hex << tc;
	}

	strStream << _T("-");
	
	BYTE Byte;
	strStream.width(1);
	for (i = 2; i < 8; i++)
	{
		Byte = Guid.Data4[i];
		Byte = Byte >> 4;
		strStream << hex << Byte;
		Byte = Guid.Data4[i];
		Byte = 0x0f & Byte;
		strStream << hex << Byte;
	}
#endif

	strStream << _T("}");

	strStream >> tsOut;

	PutALine(ros, tsOut.c_str() , -1);
}

void LARGE_INTEGEROut(t_ostream &ros, LARGE_INTEGER Large)
{
	t_string tsOut;
	tsOut = _T("{0x");
	PutALine(ros, tsOut.c_str() , -1);

	LONG Long = Large.u.HighPart;
	PutALONGVar(ros, Large.u.HighPart,true);

	DWORD DWord = Large.u.LowPart;
	PutADWORDVar(ros, DWord);

	tsOut = _T("}");
	PutALine(ros, tsOut.c_str() , -1);
	
}

void InitializeTCHARVar(t_string &rtsValue , void *pVar)
{
	TCHAR **pTCHAR = reinterpret_cast<TCHAR **> (pVar);
	if (rtsValue.length() > 0)
	{
		// Null string.
		if (case_insensitive_compare(rtsValue,_T("@#$STRING_NULL")) == 0)
		{
			*pTCHAR = NULL;
		}
		// Empty string.
		else if (case_insensitive_compare(rtsValue,_T("@#$STRING_EMPTY")) == 0)
		{
			*pTCHAR = NewTCHAR(_T(""));
		}
		else // Just a string.
		{
			*pTCHAR = NewTCHAR(rtsValue.c_str());
		}
	}
	else // Empty string.
	{
		*pTCHAR = NewTCHAR(_T(""));
	}
}

//"EVENT_TRACE_FILE_MODE_NEWFILE|EVENT_TRACE_REAL_TIME_MODE|@#$UNKNOWNVALUE:0x20"
//"EVENT_TRACE_FLAG_IMAGE_LOAD|EVENT_TRACE_FLAG_DISK_IO|@#$UNKNOWNVALUE:0x20"
void InitializeEnumVar(t_string &rtsValue , void *pVar)
{
	ULONG *pULong = reinterpret_cast<ULONG *> (pVar);
	*pULong = 0;

	int nEndPos;
	int nBegPos = 0;
	int nSubstrLen;

	t_string tsTemp;

	CONSTMAP::iterator Iterator;

	bool bDone = false;

	while (!bDone)
	{
		nEndPos = rtsValue.find(_T("|"), nBegPos); 

		if (nEndPos == t_string::npos)
		{
			bDone = true;
			nEndPos = rtsValue.length();
		}

		nSubstrLen = nEndPos - nBegPos;

		tsTemp = rtsValue.substr(nBegPos, nSubstrLen);

		Iterator = g_ConstantMap.m_Map.find(tsTemp);

		if (Iterator == g_ConstantMap.m_Map.end())
		{
			// Had better be @#$UNKNOWNVALUE:0x
			if (tsTemp.compare(0, 18, _T("@#$UNKNOWNVALUE:0x")) == 0)
			{		
				tsTemp = rtsValue.substr(nBegPos + 18);
				ULONG ulTemp;
				InitializeULONGVar(tsTemp , (void *) &ulTemp, true);
				*pULong |= ulTemp;
			}

		}
		else
		{
			*pULong |= (*Iterator).second; 
		}

		nBegPos = nEndPos + 1;
	}


}

// Expect HANDLEs to be in the form 0xnnnnnnnn
void InitializeHandleVar(t_string &rtsValue , void *pVar)
{
	HANDLE *pHandle = reinterpret_cast<HANDLE *> (pVar);
	HANDLE handle;

	t_strstream strStream;

	t_string tsTemp;
	tsTemp = rtsValue.substr(2);
	
	strStream << tsTemp;

	strStream >> handle;

	*pHandle = handle;

}

void InitializeULONGVar(t_string &rtsValue , void *pVar, bool bHex )
{
	ULONG *pULong = reinterpret_cast<ULONG *> (pVar);

	ULONG uLong;

	t_strstream strStream;
	
	strStream << rtsValue;

	if (bHex)
	{
		strStream >> hex >> uLong;
	}
	else
	{
		strStream >> uLong;
	}


	*pULong = uLong;
}

void InitializeLONGVar(t_string &rtsValue , void *pVar)
{
	LONG *pLong = reinterpret_cast<LONG *> (pVar);
	LONG Long;

	t_strstream strStream;
	
	strStream << rtsValue;

	strStream >> Long;

	*pLong = Long;

}

t_istream &GetAChar(t_istream &ris,TCHAR &tc)
{
#ifndef _UNICODE
	tc = ris.get();
	return ris;
#else
	char *pChar = (char *) &tc;
	
	pChar[0] = ris.get();
	pChar[1] = ris.get();

	return ris;

#endif
}


// See note at top of this file to understand why we are not using
// formatted input.
// We are reading in a wide character file one byte at a time and
// creating our two byte characters from each two byte sequence.
t_istream &GetALine(t_istream &ris,TCHAR *tcBuffer, int nBufferSize)
{
#ifndef _UNICODE
	t_istream &r = ris.getline(tcBuffer,nBufferSize - 1,_T('\n'));
	// Docs for getline say that it sould eat the new line.  It does
	// not, and it does even worse.  It returns a 0x0d which we delete.
	// This should work even when getline does
	// what the docs say it will.
	int n = _tcsclen(tcBuffer) - 1;

	if (tcBuffer[n] == 0x0d)
	{
		tcBuffer[n] = _T('\0');
	}

	return r;
#else
	char *pChar = (char *) tcBuffer;
	bool bSkipNext = false;
	bool bEOL = false;
	int intIn1;
	int intIn2;
	int i = 0;
	int count = 0;
	while (1)
	{
		intIn1 = ris.get();
		if (ris.eof())
		{
			break;
		}
		intIn2 = ris.get();
		
		if (intIn1 == 0x0d && intIn2 == 0x0)
		{
			// Found 0x0d so eat the 0x0a.
			intIn1 = ris.get();
			intIn2 = ris.get();
			tcBuffer[i / 2] = _T('\0');
			break;
		}
		else 
		{
			pChar[i++] = intIn1;
			pChar[i++] = intIn2;
		}
	}

	if (i == 0)
	{
		tcBuffer[0] = _T('\0');
	}

	return ris;

#endif

}

// See note at top of this file to understand why we are not using
// formatted input.
// We are writing out a wide character file one byte at a time.
// nBufferSize is the number of TCHARS not size in bytes.
// if nBufferSize == -1 tcBuffer better be a null terminated string.
// Will handle a unicode string with "proper" and "inproper" newlines. 
t_ostream &PutALine(t_ostream &ros,const TCHAR *tcBuffer, int nBufferSize)
{
#ifndef _UNICODE
//	return ros << tcBuffer;
	const char *pBuffer =  tcBuffer;
	int nSize = nBufferSize;
	if (nBufferSize == -1)
	{
		nSize = _tcsclen(tcBuffer);
	}

	for (int i = 0; i < nSize; i++)
	{
		int intOut = pBuffer[i];
		if (intOut == 0x0a && pBuffer[i - 1] != 0x0d)
		{
			ros.put(0x0d);
		}
		ros.put(intOut);
	}
	
	return ros;
#else
	char *pBuffer = (char *) tcBuffer;
	int nSize = nBufferSize;
	if (nBufferSize == -1)
	{
		nSize = _tcsclen(tcBuffer);
	}

	for (int i = 0; i < nSize * 2; i++)
	{
		int intOut = pBuffer[i];
		if (intOut == 0x0a && pBuffer[i - 2] != 0x0d)
		{
			ros.put(0x0d);
			ros.put(0x0);
		}
		ros.put(intOut);
	}
	
	return ros;
#endif

}

// Hex flavor not tested for non-unicode.
t_ostream &PutALONGVar(t_ostream &ros, LONG l, bool bHex)
{
#ifndef _UNICODE
	if (bHex)
	{
		TCHAR f = ros.fill(_T('0'));
		int w = ros.width(8);
		int fl =	ros.flags(ros.flags() | ios_base::right);
		ros << hex << l;
		ros.fill(f);
		ros.width(w);
		ros.flags(fl);

		return ros << dec;
	}
	else
	{
		return ros << l;
	}
#else

	t_string tsTemp;
	t_strstream strStream;
	
	if (bHex)
	{
		strStream.width(8);
		strStream.fill('0');
		strStream.flags(ios_base::right);
		strStream << hex << l;
	}
	else
	{
		strStream << l;
	}

	strStream >> tsTemp;

	PutALine(ros, tsTemp.c_str() , -1);

	return ros;
#endif
}

t_ostream &PutAULONG64Var(t_ostream &ros, ULONG64 ul64)
{
	ULONG *lArray = (ULONG *) &ul64;
	PutAULONGVar( ros, lArray[0], true);
	PutAULONGVar( ros, lArray[1], true);
	return ros;
}

t_ostream &PutAULONGVar(t_ostream &ros, ULONG ul, bool bHex)
{
#ifndef _UNICODE
	if (bHex)
	{
		TCHAR f = ros.fill(_T('0'));
		int w = ros.width(8);
		int fl =	ros.flags(ros.flags() | ios_base::right);
		ros << hex << ul;
		ros.fill(f);
		ros.width(w);
		ros.flags(fl);

		return ros << dec;
	}
	else
	{
		return ros << ul;
	}
#else

	t_string tsTemp;
	t_strstream strStream;

	if (bHex)
	{
		strStream.width(8);
		strStream.fill('0');
		strStream.flags(ios_base::right);
		strStream << hex << ul;
	}
	else
	{
		strStream << ul;
	}

	strStream >> tsTemp;

	PutALine(ros, tsTemp.c_str() , -1);

	return ros;
#endif
}

t_ostream &PutADWORDVar(t_ostream &ros, DWORD dw)
{
#ifndef _UNICODE
	TCHAR f = ros.fill(_T('0'));
	int w = ros.width(8);
	int fl =	ros.flags(ros.flags() | ios_base::right);
	ros << hex << dw;
	ros.fill(f);
	ros.width(w);
	ros.flags(fl);

	return ros << dec;
#else

	t_string tsTemp;
	t_strstream strStream;
	
	strStream.width(8);
	strStream.fill('0');
	strStream.flags(ios_base::right);
	strStream << hex << dw;
	
	strStream >> tsTemp;

	PutALine(ros, tsTemp.c_str() , -1);

	return ros;
#endif
}


void InitializeGUIDVar(t_string &rtsValue , void *pVar)
{
	GUID *pGUID = reinterpret_cast<GUID *> (pVar);
	if (rtsValue.length() > 0 && case_insensitive_compare(rtsValue,_T("@#$NA")) != 0)
	{
		wGUIDFromString(rtsValue.c_str(), pGUID);
	}
	else
	{
		RtlZeroMemory(pGUID, sizeof(GUID));
	}


}

// *** Following routine copied from WMI\MofCheck. to convert 
// a guid string to a GUID. 
// The routines below were blantenly stolen without remorse from the ole
// sources in \nt\private\ole32\com\class\compapi.cxx. They are copied here
// so that WMI doesn't need to load in ole32 only to convert a guid string
// into its binary representation.
//


//+-------------------------------------------------------------------------
//
//  Function:   HexStringToDword   (private)
//
//  Synopsis:   scan lpsz for a number of hex digits (at most 8); update lpsz
//              return value in Value; check for chDelim;
//
//  Arguments:  [lpsz]    - the hex string to convert
//              [Value]   - the returned value
//              [cDigits] - count of digits
//
//  Returns:    TRUE for success
//
//--------------------------------------------------------------------------

BOOL HexStringToDword(LPCTSTR lpsz, DWORD * RetValue,
                             int cDigits, WCHAR chDelim)
{
    int Count;
    DWORD Value;

    Value = 0;
    for (Count = 0; Count < cDigits; Count++, lpsz++)
    {
        if (*lpsz >= '0' && *lpsz <= '9')
            Value = (Value << 4) + *lpsz - '0';
        else if (*lpsz >= 'A' && *lpsz <= 'F')
            Value = (Value << 4) + *lpsz - 'A' + 10;
        else if (*lpsz >= 'a' && *lpsz <= 'f')
            Value = (Value << 4) + *lpsz - 'a' + 10;
        else
            return(FALSE);
    }
    *RetValue = Value;

    if (chDelim != 0)
        return *lpsz++ == chDelim;
    else
        return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   wUUIDFromString    (internal)
//
//  Synopsis:   Parse UUID such as 00000000-0000-0000-0000-000000000000
//
//  Arguments:  [lpsz]  - Supplies the UUID string to convert
//              [pguid] - Returns the GUID.
//
//  Returns:    TRUE if successful
//
//--------------------------------------------------------------------------
BOOL wUUIDFromString(LPCTSTR lpsz, LPGUID pguid)
{
        DWORD dw;

        if (!HexStringToDword(lpsz, &pguid->Data1, sizeof(DWORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(DWORD)*2 + 1;

        if (!HexStringToDword(lpsz, &dw, sizeof(WORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(WORD)*2 + 1;

        pguid->Data2 = (WORD)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(WORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(WORD)*2 + 1;

        pguid->Data3 = (WORD)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[0] = (BYTE)dw;
        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, '-'))
                return FALSE;
        lpsz += sizeof(BYTE)*2+1;

        pguid->Data4[1] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[2] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[3] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[4] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[5] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[6] = (BYTE)dw;
        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[7] = (BYTE)dw;

        return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   wGUIDFromString    (internal)
//
//  Synopsis:   Parse GUID such as {00000000-0000-0000-0000-000000000000}
//
//  Arguments:  [lpsz]  - the guid string to convert
//              [pguid] - guid to return
//
//  Returns:    TRUE if successful
//
//--------------------------------------------------------------------------
BOOL wGUIDFromString(LPCTSTR lpsz, LPGUID pguid)
{
    if (*lpsz == '{' )
        lpsz++;
    if(wUUIDFromString(lpsz, pguid) != TRUE)
        return FALSE;

    lpsz +=36;

    if (*lpsz == '}' )
        lpsz++;

    if (*lpsz != '\0')   // check for zero terminated string - test bug #18307
    {
       return FALSE;
    }

    return TRUE;
}

int case_insensitive_compare(t_string &r1, t_string &r2)
{

	t_string tsTemp1;
	t_string tsTemp2;
	tsTemp1 = r1.c_str();
	tsTemp2 = r2.c_str();

	int i;
	for (i = 0; i < tsTemp1.length(); i++)
	{
		tsTemp1.replace(i,1,1, toupper(tsTemp1[i]));
	}

	for (i = 0; i < tsTemp2.length(); i++)
	{
		tsTemp2.replace(i,1,1, toupper(tsTemp2[i]));
	}

	return tsTemp1.compare(tsTemp2);
}

int case_insensitive_compare(TCHAR *p, t_string &r2)
{ 
	if (p == NULL)
	{
		return -1;
	}

	t_string tsTemp; 
	tsTemp = p; 
	return case_insensitive_compare(tsTemp, r2);
}

int case_insensitive_compare(t_string &r1,TCHAR *p )
{ 
	if (p == NULL)
	{
		return 1;
	}

	t_string tsTemp; 
	tsTemp = p; 
	return case_insensitive_compare(r1, tsTemp);
}

int case_insensitive_compare(TCHAR *p1,TCHAR *p2)
{
	if (!p1 && !p2)
	{
		return 0;
	}
	else if (!p1)
	{
		return -1;
	} else if (!p2)
	{
		return 1;
	}

	int l1 = _tcslen(p1);
	int l2 = _tcslen(p2);

	int nCompare = _tcsnicmp(p1,p2,_MIN(l1,l2));

	if (nCompare == 0)
	{
		if (l1 == l2)
		{
			return 0;
		}
		else if (l1 < l2)
		{
			return -1;
		}
		else
		{
			return 1;
		}
	}
	else
	{
		return nCompare;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\logger\structurewrappers.cpp ===
// StructureWrappers.cpp: implementation of the CStructureWrappers class.
//
//////////////////////////////////////////////////////////////////////
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#include "stdafx.h"

#pragma warning (disable : 4786)
#pragma warning (disable : 4275)

#include <iosfwd> 
#include <iostream>
#include <fstream>
#include <string>
#include <map>
#include <list>


using namespace std;

#include <malloc.h>
#include <tchar.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>

#include <WTYPES.H>
#include "t_string.h"

#include "Persistor.h"
#include "Logger.h"
#include "TCOData.h"
#include "Utilities.h"

#include "StructureWrappers.h"
#include "StructureWapperHelpers.h"
#include "ConstantMap.h"


//////////////////////////////////////////////////////////////////////
// Wrappers that serialize and de-serialize Event Tracing Data 
// Structures.
//////////////////////////////////////////////////////////////////////
#define MAX_LINE 1024

static TCHAR g_tcNl = _T('\n');
static TCHAR g_tcCR = 0x0d;
static TCHAR g_tcLF = 0x0a;

#ifdef _UNICODE
static TCHAR g_tcDQuote[] = _T("\"");
static TCHAR g_atcNL[] = {0x0d, 0x0a, 0x00};
#else
static TCHAR g_atcNL[] = {g_tcNl};
static TCHAR g_tcDQuote = _T('"');
#endif

CConstantMap g_ConstantMap;

//////////////////////////////////////////////////////////////////////
// _EVENT_TRACE_PROPERTIES
//////////////////////////////////////////////////////////////////////

CEventTraceProperties::CEventTraceProperties()
{
	m_pProps = NULL;
	m_bIsNULL = true;
}

CEventTraceProperties::CEventTraceProperties
(PEVENT_TRACE_PROPERTIES pProps)
{
	Initialize(pProps);
}

CEventTraceProperties::~CEventTraceProperties()
{
	if (m_pProps)
	{
		free(m_pProps->LogFileName);
		m_pProps->LogFileName = NULL;
		free(m_pProps->LoggerName);
		m_pProps->LoggerName = NULL;
		free(m_pProps);
		m_pProps = NULL;
	}
	m_bIsNULL = true;

}

CEventTraceProperties::CEventTraceProperties(CEventTraceProperties &rhs)
{
	Initialize(rhs.m_pProps);

}

CEventTraceProperties &CEventTraceProperties::operator=
(CEventTraceProperties &rhs)
{
	if ( this != &rhs ) 
	{
    	delete this;
    	
		Initialize(rhs.m_pProps);
    }
    
	return *this;

}
#if 0
"_EVENT_TRACE_PROPERTIES Instance Begin"
"BufferSize:ULONG:32"
"MinimunBuffers:ULONG:2"
"MaximunBuffers:ULONG:3"
"MaximunFileSize:ULONG:4"
"LogFileMode:@#$ENUM:EVENT_TRACE_FILE_MODE_NEWFILE|EVENT_TRACE_REAL_TIME_MODE|@#$UNKNOWNVALUE:0x20"
"FlushTimer:ULONG:6"
"EnableFlags:@#$ENUM:EVENT_TRACE_FLAG_IMAGE_LOAD|EVENT_TRACE_FLAG_DISK_IO|@#$UNKNOWNVALUE:20"
"NumberOfBuffers:ULONG:8"
"FreeBuffers:ULONG:9"
"EventsLost:ULONG:10"
"BuffersWritten:ULONG:11"
"LogBuffersLost:ULONG:12"
"RealTimeBuffersLost:ULONG:13"
"AgeLimit:LONG:-14"
"LoggerThreadId:HANDLE:0000000F"
"LogFileName:TCHAR*:Log file name"
"LoggerName:TCHAR*:Logger name"
"_EVENT_TRACE_PROPERTIES Instance End"
#endif
void CEventTraceProperties::InitializeMemberVar(TCHAR *tcBuffer, int nVar)
{

	int nDebug = 0;
	if (nVar == 17 || nVar == 18)
	{
		nDebug = nVar;
	}

	t_string tsTemp;
	
	tsTemp = tcBuffer;

	int nPos = tsTemp.find(_T(":"), 0);

	// The first character in the type.
	int nPosType = nPos + 1;

	if (nPos == t_string::npos)
	{
		m_bDeSerializationOK = false;
		return;
	}

	nPos = tsTemp.find(_T(":"), nPos + 1);
	
	t_string tsType;

	tsType = tsTemp.substr(nPosType,nPos - nPosType);

	// The first chatacter in the value.
	++nPos;

	t_string tsValue;
	tsValue = tsTemp.substr(nPos, (tsTemp.length() - nPos) - 1);

	// a TCHAR * value
	if (tsType.compare(_T("TCHAR*")) == 0)
	{
		InitializeTCHARVar(tsValue ,m_pVarArray[nVar]);
	}
	// A #define value
	else if (tsType.compare(_T("@#$ENUM")) == 0)
	{
		InitializeEnumVar(tsValue , m_pVarArray[nVar]);
	}
	// A HEX
	else if (tsType.compare(_T("HANDLE")) == 0)
	{
		InitializeHandleVar(tsValue , m_pVarArray[nVar]);
	}
	// An unsigned value
	else if (tsType.compare(_T("ULONG")) == 0)
	{
		InitializeULONGVar(tsValue , m_pVarArray[nVar]);
	}
	// A long value
	else if (tsType.compare(_T("LONG")) == 0)
	{
		InitializeLONGVar(tsValue , m_pVarArray[nVar]);
	}
	// A long value
	else if (tsType.compare(_T("GUID")) == 0)
	{
		InitializeGUIDVar(tsValue , m_pVarArray[nVar]);
	}

}

void CEventTraceProperties::Initialize
(PEVENT_TRACE_PROPERTIES pProps)
{
	m_bDeSerializationOK = true;
	if (pProps == NULL)
	{
		m_pProps = NULL;
		m_bIsNULL = true;
	}

	m_pProps = (EVENT_TRACE_PROPERTIES *) malloc (sizeof(EVENT_TRACE_PROPERTIES));
	RtlZeroMemory(m_pProps, sizeof(EVENT_TRACE_PROPERTIES));
	*m_pProps = *pProps;
	
	m_pProps -> LogFileName = pProps -> LogFileName ? 
								NewTCHAR(pProps -> LogFileName) :
								NULL;
	m_pProps -> LoggerName = pProps -> LoggerName ?
								NewTCHAR(pProps -> LoggerName) :
								NULL;

	m_pProps -> Wnode.BufferSize = sizeof(*m_pProps);

	m_bIsNULL = false;

}

PEVENT_TRACE_PROPERTIES 
CEventTraceProperties::GetEventTracePropertiesInstance()
{
	if (m_pProps == NULL)
	{
		return NULL;
	}

	EVENT_TRACE_PROPERTIES *pProps = 
		(EVENT_TRACE_PROPERTIES *) malloc (sizeof(EVENT_TRACE_PROPERTIES));
	RtlZeroMemory(pProps, sizeof(EVENT_TRACE_PROPERTIES));

	*pProps = *m_pProps;
	
	pProps -> LogFileName = m_pProps -> LogFileName ? 
								NewTCHAR(m_pProps -> LogFileName) :
								NULL;
	pProps -> LoggerName = m_pProps -> LoggerName ?
								NewTCHAR(m_pProps -> LoggerName) :
								NULL;
	int n1 = sizeof(*pProps);
	int n2 = sizeof(EVENT_TRACE_PROPERTIES);

	pProps -> Wnode.BufferSize = sizeof(*pProps);
	
	return pProps;
}

HRESULT CEventTraceProperties::Persist (CPersistor &rPersistor)
{
	if (rPersistor.IsLoading())
	{
		rPersistor.Stream() >> *this;
	}
	else
	{
		rPersistor.Stream() << *this;
	}

	return S_OK;

}

t_ostream& operator<<(t_ostream &ros, const CEventTraceProperties &r)
{
	t_string tsOut;

	tsOut = _T("\"_EVENT_TRACE_PROPERTIES Instance Begin\"\n");
	PutALine(ros, tsOut.c_str());

// "Wnode.Guid:GUID:{0000cbd1-0011-11d0-0d00-00aa006d010a}"
// "Wnode.Flags:@#$ENUM:WNODE_FLAG_ALL_DATA"

	tsOut = _T("\"Wnode.Guid:GUID:");
	PutALine(ros, tsOut.c_str());
	GUIDOut(ros, r.m_pProps -> Wnode.Guid);
	tsOut = g_tcDQuote;
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

	WnodeFlagsOut(ros, r.m_pProps -> Wnode.Flags);

	tsOut = _T("\"BufferSize:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> BufferSize);
	tsOut = g_tcDQuote;
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

	tsOut = _T("\"MinimunBuffers:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> MinimumBuffers);
	tsOut = g_tcDQuote;
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

	tsOut = _T("\"MaximunBuffers:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> MaximumBuffers);
	tsOut = g_tcDQuote;
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

	tsOut = _T("\"MaximunFileSize:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> MaximumFileSize);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

	LogFileModeOut(ros, r.m_pProps -> LogFileMode );

	tsOut = _T("\"FlushTimer:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> FlushTimer);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

	EnableFlagsOut(ros,r.m_pProps -> EnableFlags);

//	ros << _T("\"NumberOfBuffers:ULONG:") << r.m_pProps -> NumberOfBuffers << g_tcDQuote << g_atcNL;

	tsOut = _T("\"NumberOfBuffers:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> NumberOfBuffers);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

//	ros << _T("\"FreeBuffers:ULONG:") << r.m_pProps -> FreeBuffers << g_tcDQuote << g_atcNL;

	tsOut = _T("\"FreeBuffers:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> FreeBuffers);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

//	ros << _T("\"EventsLost:ULONG:") << r.m_pProps -> EventsLost << g_tcDQuote << g_atcNL;

	tsOut = _T("\"EventsLost:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> EventsLost);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

//	ros << _T("\"BuffersWritten:ULONG:") << r.m_pProps -> BuffersWritten << g_tcDQuote << g_atcNL;

	tsOut = _T("\"BuffersWritten:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> BuffersWritten);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

//	ros << _T("\"LogBuffersLost:ULONG:") << r.m_pProps -> LogBuffersLost << g_tcDQuote << g_atcNL;

	tsOut = _T("\"LogBuffersLost:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> LogBuffersLost);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());


//	ros << _T("\"RealTimeBuffersLost:ULONG:") << r.m_pProps -> RealTimeBuffersLost << g_tcDQuote <<g_atcNL;

	tsOut = _T("\"RealTimeBuffersLost:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> RealTimeBuffersLost);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());
	
	
//	ros << _T("\"AgeLimit:LONG:") << r.m_pProps -> AgeLimit << g_tcDQuote <<g_atcNL;

	tsOut = _T("\"AgeLimit:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutALONGVar(ros, r.m_pProps -> AgeLimit);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

	// Handles are in hex.
//	ros << _T("\"LoggerThreadId:HANDLE:0x") << r.m_pProps -> LoggerThreadId << g_tcDQuote <<g_atcNL;

	tsOut = _T("\"LoggerThreadId:HANDLE:0x");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, (ULONG) r.m_pProps -> LoggerThreadId, true);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

//	ros << _T("\"LogFileName:TCHAR*:") << r.m_pProps -> LogFileName << g_tcDQuote <<g_atcNL;

	tsOut = _T("\"LogFileName:TCHAR*:");
	if (r.m_pProps -> LogFileName)
	{
		tsOut += r.m_pProps -> LogFileName;
	}
	tsOut += g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

//	ros << _T("\"LoggerName:TCHAR*:") << r.m_pProps -> LoggerName << g_tcDQuote <<g_atcNL;

	tsOut = _T("\"LoggerName:TCHAR*:");
	if (r.m_pProps -> LoggerName)
	{
		tsOut += r.m_pProps -> LoggerName;
	}
	tsOut += g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

	tsOut = _T("\"_EVENT_TRACE_PROPERTIES Instance End\"\n");
	PutALine(ros, tsOut.c_str());

	return ros;
}

t_istream& operator>>(t_istream &ris,CEventTraceProperties &r)
{
	r.m_bDeSerializationOK = true;

	// We are doing line oriented serailization and assume that
	// a line in the stream is 1024 or less TCHARS.
	TCHAR *ptcBuffer = (TCHAR *) malloc(MAX_LINE * sizeof(TCHAR));

	GetALine(ris, ptcBuffer,MAX_LINE);


	if (_tcscmp(ptcBuffer,_T("\"_EVENT_TRACE_PROPERTIES Instance NULL\"")) == 0)
	{
		r.~CEventTraceProperties();
		r.m_bDeSerializationOK = false;

		free(ptcBuffer);
		return ris;
	}

	if (_tcscmp(ptcBuffer,_T("\"_EVENT_TRACE_PROPERTIES Instance Begin\"")) != 0)
	{
		r.m_bDeSerializationOK = false;

		free(ptcBuffer);

		return ris;
	}

	r.~CEventTraceProperties();

	r.m_pProps = (EVENT_TRACE_PROPERTIES *) malloc (sizeof(EVENT_TRACE_PROPERTIES));
	RtlZeroMemory(r.m_pProps, sizeof(EVENT_TRACE_PROPERTIES));

	r.m_pProps->Wnode.BufferSize = sizeof(EVENT_TRACE_PROPERTIES);

// "Wnode.Guid:GUID:{0000cbd1-0011-11d0-0d00-00aa006d010a}"
// "Wnode.Flags:@#$ENUM:WNODE_FLAG_ALL_DATA"

	r.m_pVarArray[0] = &r.m_pProps->Wnode.Guid;
	r.m_pVarArray[1] = &r.m_pProps->Wnode.Flags;
	r.m_pVarArray[2] = &r.m_pProps->BufferSize;
	r.m_pVarArray[3] = &r.m_pProps->MinimumBuffers;
	r.m_pVarArray[4] = &r.m_pProps->MaximumBuffers;
	r.m_pVarArray[5] = &r.m_pProps->MaximumFileSize;
	r.m_pVarArray[6] = &r.m_pProps->LogFileMode;
	r.m_pVarArray[7] = &r.m_pProps->FlushTimer;
	r.m_pVarArray[8] = &r.m_pProps->EnableFlags;
	r.m_pVarArray[9] = &r.m_pProps->NumberOfBuffers;
	r.m_pVarArray[10] = &r.m_pProps->FreeBuffers;
	r.m_pVarArray[11] = &r.m_pProps->EventsLost;
	r.m_pVarArray[12] = &r.m_pProps->BuffersWritten;
	r.m_pVarArray[13] = &r.m_pProps->LogBuffersLost;
	r.m_pVarArray[14] = &r.m_pProps->RealTimeBuffersLost;
	r.m_pVarArray[15] = &r.m_pProps->AgeLimit;
	r.m_pVarArray[16] = &r.m_pProps->LoggerThreadId;
	r.m_pVarArray[17] = &r.m_pProps->LogFileName;
	r.m_pVarArray[18] = &r.m_pProps->LoggerName;


	int n = 0;
	while (n < 19 && GetALine(ris,ptcBuffer,MAX_LINE))
	{
		r.InitializeMemberVar(ptcBuffer,n++);
	}

	// Consume end of Props
	GetALine(ris,ptcBuffer,MAX_LINE);

	free(ptcBuffer);

	BOOL bHeapGood = HeapValidate(GetProcessHeap(), 0, NULL);

	return ris;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\logger\t_string.h ===
// t_string.h: interface for the t_string class.
//
//////////////////////////////////////////////////////////////////////
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#if !defined(AFX_T_STRING_H__32BF27CE_EAD9_11D2_9C53_00A0249F63EB__INCLUDED_)
#define AFX_T_STRING_H__32BF27CE_EAD9_11D2_9C53_00A0249F63EB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


#ifndef t_string

#ifndef _UNICODE
// Definitions for WC to MBCS and MBCS to WC routines that do the right thing
// if compiled non-UNICODE.
#define t_string string
#define t_fstream fstream
#define t_istream istream
#define t_ostream ostream
#define t_cout cout
#define t_cin cin
#define t_strstream strstream
#define t_strstreambuf strstreambuf
#define t_ctime ctime
#define t_cerr cerr

#else

// Definitions for WC to MBCS and MBCS to WC routines that do the right thing
// if compiled UNICODE.
#define t_string wstring
#define t_fstream fstream
#define t_istream istream
#define t_ostream ostream
#define t_cout wcout
#define t_cin wcin
#define t_strstream wstringstream
#define t_strstreambuf wstrstreambuf
#define t_ctime _wctime
#define t_cerr wcerr

#endif

#endif

// We do not need conversion routines if compiling under UNICODE
#define mbsrtowcs t_mbsrtowcs


#endif // !defined(AFX_T_STRING_H__32BF27CE_EAD9_11D2_9C53_00A0249F63EB__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\logger\t_string.cpp ===
//////////////////////////////////////////////////////////////////////
// Implementaion of WC to MBCS and MBCS to WC routines that do the 
// right thing if compiled non-UNICODE or UNICODE.
//////////////////////////////////////////////////////////////////////
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#include "stdafx.h"
#include "t_string.h"

//////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\logger\tcodata.h ===
#if !defined(AFX_TCODATA_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_)
#define AFX_TCODATA_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


struct TCOData
{
	LPTSTR m_lptstrShortDesc;
	LPTSTR m_lptstrLongDesc;
	ULONG m_ulExpectedResult;
	ULONG m_ulAPITest;
	LPTSTR m_lptstrExpectedResult;
	TRACEHANDLE *m_pTraceHandle;
	LPTSTR m_lptstrInstanceName;
	LPTSTR m_lptstrLoggerMode;	
	int m_nGuids;
	LPGUID m_lpguidArray;
	ULONG m_ulEnable;
	ULONG m_ulEnableFlag;
	ULONG m_ulEnableLevel;
	PEVENT_TRACE_PROPERTIES m_pProps;		
	LPTSTR m_lptstrValidator;
	enum 
	{ 
		OtherTest = 0,
		StartTraceTest = 1,
		StopTraceTest = 2,
		EnableTraceTest = 3,
		QueryTraceTest = 4,
		UpdateTraceTest = 5,
		QueryAllTracesTest = 6
	};

};

struct TCOFunctionalData
{
	int m_nProviders;
	LPTSTR *m_lptstrProviderArray;
	int m_nConsumers;
	LPTSTR *m_lptstrConsumerArray;
};


void FreeTCOData (TCOData *pstructTCOData);
void FreeTCOFunctionalData (TCOFunctionalData *pstructTCOFunctionalData);

int GetAllTCOData
(
	IN LPCTSTR lpctstrFile,
	OUT TCOData **pstructTCOData,
	OUT TCOFunctionalData **pstructTCOFunctionalData,
	OUT LPTSTR *plptstrErrorDesc, // Any error we had.
	IN bool bGetFunctionalData = true
);

int GetTCOData
(
	IN CPersistor &PersistorIn,
	OUT TCOData *pstructTCOData,
	OUT LPTSTR *plptstrErrorDesc // Any error we had.
);

int GetTCOData
(	IN CPersistor &PersistorIn,
	OUT LPTSTR *plptstrShortDesc,
	OUT LPTSTR *plptstrLongDesc,
	OUT ULONG *pExpectedResult,
	OUT LPTSTR *plptstrExpectedResult,
	OUT TRACEHANDLE **pTraceHandle,
	OUT LPTSTR *plptstrInstanceName,
	OUT LPTSTR *plptstrLoggerMode,
	OUT PEVENT_TRACE_PROPERTIES *pProps,
	OUT LPTSTR *plptstrValidator,
	OUT LPTSTR *plptstrErrorDesc // Any error we had.
);


int TCOFunctionalObjects
(	IN CPersistor &PersistorIn,
	IN OUT TCOFunctionalData *pstructTCOFunctionalData,
	OUT LPTSTR *plptstrErrorDesc // Any error we had.
);

#endif // !defined(AFX_TCODATA_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\logger\tcodata.cpp ===
// StartTrace.cpp : Defines the entry point for the DLL application.
//
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#include "stdafx.h"

#pragma warning (disable : 4786)
#pragma warning (disable : 4275)

#include <iostream>
#include <strstream>
#include <fstream>
#include <fcntl.h>
#include <io.h>
#include <string>
#include <sstream>
#include <map>
#include <list>


using namespace std;

#include <malloc.h>
#include <tchar.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>

#include <WTYPES.H>
#include "t_string.h"

#include "Persistor.h"
#include "Logger.h"
#include "TCOData.h"
#include "Utilities.h"
#include "StructureWrappers.h"
#include "StructureWapperHelpers.h"
#include "ConstantMap.h" 

#include "CollectionControl.h"
 
extern CConstantMap g_ConstantMap;

#define MAX_LINE 2048

int ParseGuids
(
	TCHAR *ptcBuffer, 
	TCOData *pstructTCOData, 
	LPTSTR *plptstrErrorDesc
);

int ParseExeData
(
	t_string &tsData, 
	int &nExes, 
	LPTSTR *&lptstrArray,
	LPTSTR *plptstrErrorDesc
);


// If an error occurs you users of this function must delete
// plptstrErrorDesc.  It will contain a string describing
// the error.
int GetAllTCOData
(
	IN LPCTSTR lpctstrFile,
	OUT TCOData **pstructTCOData,
	OUT TCOFunctionalData **pstructTCOFunctionalData,
	OUT LPTSTR *plptstrErrorDesc, // Any error we had.
	IN bool bGetFunctionalData
)
{
	*pstructTCOData = (TCOData *) malloc (sizeof(TCOData));
	RtlZeroMemory(*pstructTCOData , sizeof(TCOData));

	if (bGetFunctionalData)
	{
		*pstructTCOFunctionalData = (TCOFunctionalData *) malloc(sizeof(TCOFunctionalData));
		RtlZeroMemory(*pstructTCOFunctionalData , sizeof(TCOFunctionalData));
	}

	LPSTR lpstrFile;
#ifdef UNICODE
	lpstrFile = NewLPSTR(lpctstrFile);
#else
	lpstrFile = NewTCHAR(lpctstrFile);
#endif

	CPersistor PersistorIn
		(lpstrFile, 
		ios::in | 0x20, // ios::nocreate = 0x20 - cannot get to compile!!!
		true );

	HRESULT hr = PersistorIn.Open();

	if (FAILED(hr))
	{
		t_string tsTemp;
		tsTemp = _T("TCOData error:  Could not open file or file was not in correct character set (Unicode or ANSI) for file ");
		t_string tsFile;
#ifdef _UNICODE
		LPWSTR lpwstrTemp = NewLPWSTR(lpstrFile);
		tsFile = lpwstrTemp;
		free(lpwstrTemp);
#else
		tsFile = lpstrFile;
	
#endif
		tsTemp += tsFile;
		free (lpstrFile);
		lpstrFile = NULL;
		tsTemp += _T(".");
		*plptstrErrorDesc = NewTCHAR(tsTemp.c_str());
		return -1;
	}

	free (lpstrFile);
	lpstrFile = NULL;

	int nReturn = 
		GetTCOData
		(
			PersistorIn,
			*pstructTCOData,
			plptstrErrorDesc // Any error we had.
		);

	if (nReturn != ERROR_SUCCESS)
	{
		PersistorIn.Close();
		return nReturn;
	}

	if (bGetFunctionalData)
	{
		nReturn = 
			TCOFunctionalObjects
			(	
				PersistorIn,
				*pstructTCOFunctionalData,
				plptstrErrorDesc // Describes error this function had.
			);
	}


	PersistorIn.Close();
	return nReturn;

}

// If an error occurs you users of this function must delete
// plptstrErrorDesc.  It will contain a string describing
// the error.
int GetTCOData
(
	IN CPersistor &PersistorIn,
	OUT TCOData *pstructTCOData,
	OUT LPTSTR *plptstrErrorDesc // Any error we had.
)
{
	RtlZeroMemory(pstructTCOData , sizeof(TCOData));

	
	// We are doing line oriented serailization and assume that
	// a line in the stream is 1024 or less TCHARS.
	TCHAR *ptcBuffer = (TCHAR *) malloc(MAX_LINE * sizeof(TCHAR));

	*plptstrErrorDesc = NULL;

	// Short description
	GetALine(PersistorIn.Stream(),ptcBuffer, MAX_LINE);
	pstructTCOData->m_lptstrShortDesc = NewTCHAR(ptcBuffer);

	// Long description.
	GetALine(PersistorIn.Stream(),ptcBuffer, MAX_LINE);
	pstructTCOData->m_lptstrLongDesc = NewTCHAR(ptcBuffer);

	// Expected result had better be in the Constant map.
	// Constant map is used to map a string to an undsigned int.
	GetALine(PersistorIn.Stream(),ptcBuffer, MAX_LINE);
	t_string tsTemp;
	tsTemp = ptcBuffer;

	CONSTMAP::iterator Iterator;
	Iterator = g_ConstantMap.m_Map.find(tsTemp);

	// If you do not find your value in the map look in 
	// ConstantMap.cpp.  You probably forgot to add it;->
	if (Iterator == g_ConstantMap.m_Map.end())
	{
		*plptstrErrorDesc = NewTCHAR(_T("TCOData error:  Expected error is not in map"));
		free(ptcBuffer);
		return -1;
	}
	else
	{
		pstructTCOData->m_lptstrExpectedResult = NewTCHAR(ptcBuffer);
		pstructTCOData->m_ulExpectedResult = (*Iterator).second; 
	}

	// TraceHandle values are VALUE_VALID or VALUE_NULL
	GetALine(PersistorIn.Stream(),ptcBuffer, MAX_LINE);
	tsTemp = ptcBuffer;

	if (case_insensitive_compare(tsTemp,_T("VALUE_VALID")) == 0)
	{
		pstructTCOData->m_pTraceHandle = 
			(TRACEHANDLE *) malloc (sizeof(TRACEHANDLE));
		*pstructTCOData->m_pTraceHandle = NULL;
	}
	else if (case_insensitive_compare(tsTemp,_T("VALUE_NULL")) == 0)
	{
		pstructTCOData->m_pTraceHandle = (TRACEHANDLE *) NULL;
	}
	else
	{
		*plptstrErrorDesc = 
			NewTCHAR
			(_T("TCOData error:  Error in value of TraceHandle.  Valid values are \"VALUE_VALID\" or \"VALUE_NULL\"."));
		free(ptcBuffer);
		return -1;	
	}

	GetALine(PersistorIn.Stream(),ptcBuffer, MAX_LINE);
	tsTemp = ptcBuffer;
	InitializeTCHARVar(tsTemp , (void *) &pstructTCOData->m_lptstrInstanceName);

	// API test - valid values 0 - 6
	//  OtherTest = 0,
	//	StartTraceTest = 1,
	//	StopTraceTest = 2,
	//	EnableTraceTest = 3,
	//	QueryTraceTest = 4,
	//	UpdateTrace = 5,
	//	QueryAllTraces = 6
	GetALine(PersistorIn.Stream(),ptcBuffer, MAX_LINE);
	tsTemp = ptcBuffer;
	InitializeULONGVar(tsTemp , (void *) &pstructTCOData->m_ulAPITest);

	if (pstructTCOData->m_ulAPITest < 0 || pstructTCOData->m_ulAPITest > 6)
	{
		*plptstrErrorDesc = 
			NewTCHAR
			(_T("TCOData error:  Error in value of m_ulAPITest.  Valid values are 0 - 6.  See enum in TCOData.h"));
		free(ptcBuffer);
		return -1;	
	}

	// Valid values are KERNEL_LOGGER or PRIVATE_LOGGER
	GetALine(PersistorIn.Stream(),ptcBuffer, MAX_LINE);
	pstructTCOData->m_lptstrLoggerMode = NewTCHAR(ptcBuffer);


	// Enable is used for EnableTrace.
	GetALine(PersistorIn.Stream(),ptcBuffer, MAX_LINE);
	tsTemp = ptcBuffer;
	if (case_insensitive_compare(tsTemp.substr(0,7),_T("ENABLE:")) != 0)
	{
		*plptstrErrorDesc = 
			NewTCHAR
			(_T("TCOData error:  Enable: expected."));
		free(ptcBuffer);
		return -1;	
	}
	else
	{
		InitializeULONGVar(tsTemp.substr(7) , &pstructTCOData->m_ulEnable);
	}

	// EnableFlag is used for EnableTrace and is passed to the provider.
	GetALine(PersistorIn.Stream(),ptcBuffer, MAX_LINE);
	tsTemp = ptcBuffer;
	if (case_insensitive_compare(tsTemp.substr(0,11),_T("ENABLEFLAG:")) != 0)
	{
		*plptstrErrorDesc = 
			NewTCHAR
			(_T("TCOData error:  EnableFlag: expected."));
		free(ptcBuffer);
		return -1;	
	}
	else
	{
		InitializeHandleVar(tsTemp.substr(11) , &pstructTCOData->m_ulEnableFlag);
	}

	// EnableLevel is used for EnableTrace and is passed to the provider.
	GetALine(PersistorIn.Stream(),ptcBuffer, MAX_LINE);
	tsTemp = ptcBuffer;
	if (case_insensitive_compare(tsTemp.substr(0,12),_T("ENABLELEVEL:")) != 0)
	{
		*plptstrErrorDesc = 
			NewTCHAR
			(_T("TCOData error:  EnableLevel: expected."));
		free(ptcBuffer);
		return -1;	
	}
	else
	{
		InitializeHandleVar(tsTemp.substr(12) , &pstructTCOData->m_ulEnableLevel);
	}

	CEventTraceProperties cPropsIn;

	// This has to be mofified to allow a NULL strucutre.
	cPropsIn.Persist( PersistorIn);
	
	pstructTCOData->m_pProps = cPropsIn.GetEventTracePropertiesInstance();
	if (pstructTCOData->m_pProps &&
		case_insensitive_compare(tsTemp,_T("PRIVATE_LOGGER")) == 0)
	{
		pstructTCOData->m_pProps->LogFileMode = 
			pstructTCOData->m_pProps->LogFileMode | EVENT_TRACE_PRIVATE_LOGGER_MODE;
	}
	
	GetALine(PersistorIn.Stream(),ptcBuffer, MAX_LINE);
	int nReturn = ParseGuids(ptcBuffer, pstructTCOData, plptstrErrorDesc);

	if(nReturn != ERROR_SUCCESS)
	{
		return nReturn;
	}

	// Validator
	if (PersistorIn.Stream().eof() == false)
	{
		GetALine(PersistorIn.Stream(),ptcBuffer, MAX_LINE);
		pstructTCOData->m_lptstrValidator = NewTCHAR(ptcBuffer);
	}

	free(ptcBuffer);
	return 0;
}

// If an error occurs you users of this function must delete
// plptstrErrorDesc.  It will contain a string describing
// the error.
int TCOFunctionalObjects
(	IN CPersistor &PersistorIn,
	IN OUT TCOFunctionalData *pstructTCOFunctionalData,
	OUT LPTSTR *plptstrErrorDesc // Describes error this function had.
)
{
	// We are doing line oriented serailization and assume that
	// a line in the stream is 1024 or less TCHARS.
	TCHAR *ptcBuffer = (TCHAR *) malloc(MAX_LINE * sizeof(TCHAR));

	*plptstrErrorDesc = NULL;

	t_string tsTemp;
	t_string tsError;
	t_string tsSubstr;

	if (PersistorIn.Stream().eof() == false)
	{
		GetALine(PersistorIn.Stream(),ptcBuffer, MAX_LINE);
		tsTemp = ptcBuffer;
		tsSubstr = tsTemp.substr(0,9);
		if (case_insensitive_compare(tsSubstr,_T("provider:")) == 0)
		{
			tsSubstr = tsTemp.substr(9);
			int nReturn = 
				ParseExeData
				(
					tsSubstr, 
					pstructTCOFunctionalData->m_nProviders, 
					pstructTCOFunctionalData->m_lptstrProviderArray,
					plptstrErrorDesc
				);

			if (nReturn != ERROR_SUCCESS)
			{
				tsError = _T("Invalid providers argument: ");
				tsError += tsTemp;
				tsError += _T(".");
				*plptstrErrorDesc = NewTCHAR(tsError.c_str());
				free(ptcBuffer);
				return -1;
			}
		}
		else
		{
			tsError = _T("Invalid providers argument: ");
			tsError += tsTemp;
			tsError += _T(".");
			*plptstrErrorDesc = NewTCHAR(tsError.c_str());
			free(ptcBuffer);
			return -1;
		}
	}

	// We may have a DataProvider.  If not we us our default.
	if (PersistorIn.Stream().eof() == false)
	{
		GetALine(PersistorIn.Stream(),ptcBuffer, MAX_LINE);
		tsTemp = ptcBuffer;
		tsSubstr = tsTemp.substr(0,9);
		if (case_insensitive_compare(tsSubstr,_T("consumer:")) == 0)
		{
			tsSubstr = tsTemp.substr(9);
			int nReturn = 
				ParseExeData
				(
					tsSubstr, 
					pstructTCOFunctionalData->m_nConsumers, 
					pstructTCOFunctionalData->m_lptstrConsumerArray,
					plptstrErrorDesc
				);

			if (nReturn != ERROR_SUCCESS)
			{
				tsError = _T("Invalid consumers argument: ");
				tsError += tsTemp;
				tsError += _T(".");
				*plptstrErrorDesc = NewTCHAR(tsError.c_str());
				free(ptcBuffer);
				return -1;
			}
		}
		else
		{
			tsError = _T("Invalid consumers argument: ");
			tsError += tsTemp;
			tsError += _T(".");
			*plptstrErrorDesc = NewTCHAR(tsError.c_str());
			free(ptcBuffer);
			return -1;
		}
	}

	free(ptcBuffer);
	return 0;
}


void FreeTCOData (TCOData *pstructTCOData)
{
	if (!pstructTCOData)
	{
		return;
	}

	free(pstructTCOData->m_lptstrShortDesc);
	free(pstructTCOData->m_lptstrLongDesc);
	free(pstructTCOData->m_lptstrExpectedResult);
	free(pstructTCOData->m_pTraceHandle);
	free(pstructTCOData->m_lptstrInstanceName);
	free(pstructTCOData->m_lptstrLoggerMode);
	free(pstructTCOData->m_lpguidArray);
	if (pstructTCOData->m_pProps)
	{
		free(pstructTCOData->m_pProps->LoggerName);
		free(pstructTCOData->m_pProps->LogFileName);
	}
	free(pstructTCOData->m_pProps);		
	free(pstructTCOData->m_lptstrValidator);

	free(pstructTCOData);
}

void FreeTCOFunctionalData (TCOFunctionalData *pstructTCOFunctionalData)
{
	if (!pstructTCOFunctionalData)
	{
		return;
	}

	int i;
	TCHAR *pTemp;

	for (i = 0; i < pstructTCOFunctionalData->m_nProviders; i++)
	{
		pTemp = pstructTCOFunctionalData->m_lptstrProviderArray[i];
		free (pTemp);
	}
	 
	free (pstructTCOFunctionalData->m_lptstrProviderArray);

	for (i = 0; i < pstructTCOFunctionalData->m_nConsumers; i++)
	{
		pTemp = pstructTCOFunctionalData->m_lptstrConsumerArray[i];
		free (pTemp);
	}
	 
	free (pstructTCOFunctionalData->m_lptstrConsumerArray);

	free(pstructTCOFunctionalData);
}

int ParseExeData
(
	t_string &tsData, 
	int &nExes, 
	LPTSTR *&lptstrArray,
	LPTSTR *plptstrErrorDesc
)
{
	// Embedded " are not allowed in the command line.  Had to draw
	// the line somewhere.
	// Tokenize on "," and " at end of line.
	list <t_string> listExes;

	bool bDone = false;
	
	int nBeg = 0;
	int nFind = tsData.find(_T(","), nBeg);
	
	t_string tsExe;

	while (!bDone)
	{
		if (nFind != t_string::npos)
		{
			tsExe = tsData.substr(nBeg,nFind - nBeg);
			listExes.push_back(tsExe);
			tsExe.erase();
		}
		else
		{
			tsExe = tsData.substr(nBeg,t_string::npos);
			listExes.push_back(tsExe);
			bDone = true;
			tsExe.erase();
		}
		nBeg = nFind + 1;
		nFind = tsData.find(_T(","), nBeg);
	}

	// Allocate the Exe array
	nExes = listExes.size();
	lptstrArray = 
			(TCHAR **) malloc (sizeof(TCHAR *) * nExes);
	RtlZeroMemory
			(lptstrArray, 
			sizeof(sizeof(TCHAR *) * nExes));

	list<t_string>::iterator pListExes;

	int i = 0;

	for (pListExes = listExes.begin(); pListExes != listExes.end() ; ++pListExes)
	{
		tsExe = (*pListExes);
		lptstrArray[i++] = NewTCHAR(tsExe.c_str());
	}

	return ERROR_SUCCESS;
}


int ParseGuids
(
	TCHAR *ptcBuffer, 
	TCOData *pstructTCOData, 
	LPTSTR *plptstrErrorDesc
)
{

	// Is Wnode does not have a GUID put the first one from list in it.
	t_string tsTemp;
	tsTemp = ptcBuffer;

	if (case_insensitive_compare(tsTemp.substr(0,6),_T("guids:")) != 0)
	{
		tsTemp.erase();
		tsTemp = _T("Invalid Guids entry: ");
		tsTemp += ptcBuffer;
		tsTemp += _T(".");
		*plptstrErrorDesc = NewTCHAR(tsTemp.c_str());
		return -1;
	}

	// Count the commas
	int nFind = tsTemp.find(_T(','));

	t_string tsGuid;
	int nBeg = 6;

	if(nBeg == tsTemp.length())
	{
		pstructTCOData->m_nGuids = 0;
		pstructTCOData->m_lpguidArray = NULL;
		return 0;
	}

	// We only have one GUID.
	if (nFind == t_string::npos)
	{
		tsGuid = tsTemp.substr(nBeg,nFind - nBeg);
		// Allocate the GUID array
		pstructTCOData->m_nGuids = 1;
		pstructTCOData->m_lpguidArray = 
			(GUID *) malloc (sizeof(GUID) * pstructTCOData->m_nGuids);
		RtlZeroMemory
			(pstructTCOData->m_lpguidArray , 
			sizeof(sizeof(GUID) * pstructTCOData->m_nGuids));
		// Just one GUID, thank you.
		wGUIDFromString(tsGuid.c_str(), &pstructTCOData->m_lpguidArray[0]);
	
		return 0;
	}

	// We have more than one GUID.
	bool bDone = false;


	list <t_string> listGuids;

	while (!bDone)
	{
		if (nFind != t_string::npos)
		{
			tsGuid = tsTemp.substr(nBeg,nFind - nBeg);
			listGuids.push_back(tsGuid);
			tsGuid.erase();
		}
		else
		{
			tsGuid = tsTemp.substr(nBeg,t_string::npos);
			listGuids.push_back(tsGuid);
			bDone = true;
			tsGuid.erase();
		}
		nBeg = nFind + 1;
		nFind = tsTemp.find(',', nBeg);
	}

	// Allocate the GUID array
	pstructTCOData->m_nGuids = listGuids.size();
	pstructTCOData->m_lpguidArray = 
			(GUID *) malloc (sizeof(GUID) * pstructTCOData->m_nGuids);
	RtlZeroMemory
			(pstructTCOData->m_lpguidArray , 
			sizeof(sizeof(GUID) * pstructTCOData->m_nGuids));

	list<t_string>::iterator pListGuids;

	int i = 0;

	for (pListGuids = listGuids.begin(); pListGuids != listGuids.end() ; ++pListGuids)
	{
		tsGuid = (*pListGuids);
		wGUIDFromString(tsGuid.c_str(), &pstructTCOData->m_lpguidArray[i++]);
	}

	
	return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\logger\validator.h ===
#if !defined(AFX_Validator_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_)
#define AFX_Validator_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CValidator
{
public:
	CValidator();
	~CValidator();
	bool Validate
			(	TRACEHANDLE *pTraceHandle, 
				LPTSTR lptstrInstanceName, 
				PEVENT_TRACE_PROPERTIES	pProps, 
				LPTSTR lptstrValidator
			);

private:

};

#endif // !defined(AFX_Validator_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\logger\validator.cpp ===
// Validator.cpp: implementation of the CValidator class.
//
//////////////////////////////////////////////////////////////////////
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#include "stdafx.h"

#include <string>
#include <iosfwd> 
#include <iostream>
#include <fstream>
#include <ctime>
#include <list>

using namespace std;

#include <malloc.h>
#include <tchar.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>

#include <WTYPES.H>
#include "t_string.h"

#include "Persistor.h"
#include "Logger.h"
#include "TCOData.h"
#include "Utilities.h"
#include "StructureWrappers.h"
#include "StructureWapperHelpers.h"

#include "Validator.h"

#define DEFAULT_MIN_BUFFERS 2

CValidator::CValidator() 
{

}


CValidator::~CValidator()
{
	
}

bool CValidator::Validate
(
	TRACEHANDLE *pTraceHandle, 
	LPTSTR lptstrInstanceName, 
	PEVENT_TRACE_PROPERTIES	pProps, 
	LPTSTR lptstrValidator
)
{
	bool bReturn = true;

	if (case_insensitive_compare(lptstrValidator, _T("VALIDATION_1.1.1.10.5")))
	{
		bReturn = pProps->MinimumBuffers == DEFAULT_MIN_BUFFERS;	
		if (bReturn)
		{
			t_cout << _T("Validator passed.\n"); 
		}
		else
		{
			t_cout << _T("Validator failed.\n"); 
		}
	}

	return bReturn;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\logger\utilities.h ===
// Utilities.h: interface for the CUtilities class.
//
//////////////////////////////////////////////////////////////////////
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#if !defined(AFX_UTILITIES_H__C37E8DD0_ED3E_11D2_804A_009027345EE2__INCLUDED_)
#define AFX_UTILITIES_H__C37E8DD0_ED3E_11D2_804A_009027345EE2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

TCHAR *NewTCHAR(const TCHAR *ptcToCopy);

LPSTR NewLPSTR(LPCWSTR lpwstrToCopy);

LPWSTR NewLPWSTR(LPCSTR lpstrToCopy);

LPTSTR DecodeStatus(IN ULONG Status);

int GetFileList(LPTSTR lptstrPath, LPTSTR lptstrFileType, list<t_string> &rList);

BOOL IsAdmin();  // From Q118626

LPTSTR LPTSTRFromGuid(GUID Guid);

t_string ULONGVarToTString(ULONG ul, bool bHex);

ULONG InitializePropsArray
(PEVENT_TRACE_PROPERTIES &pPropsArray, int nInstances);

ULONG FreePropsArray
(PEVENT_TRACE_PROPERTIES &pPropsArray, int nInstances);

int LogDetailBeforeCall
(	CLogger *pDetailLogger,
	TCOData *pstructTCOData,
	BOOL bAdmin
);

int LogDetailAfterCall
(	CLogger *pDetailLogger,
	TCOData *pstructTCOData, 
	PEVENT_TRACE_PROPERTIES *pProps,
	ULONG ulResult,
	LPTSTR lpstrReturnedError,
	bool bValid,
	BOOL bAdmin,
	LPCTSTR lptstrBanner = NULL,
	bool bPrintProps = true
);

int LogSummaryBeforeCall
(	
	TCOData *pstructTCOData, 
	LPCTSTR lpctstrDataFile,
	LPCTSTR lptstrAction,
	LPCTSTR lptstrAPI,
	bool bLogExpected
);

int LogSummaryAfterCall
(	
	TCOData *pstructTCOData, 
	LPCTSTR lpctstrDataFile,
	LPCTSTR lptstrAction,
	ULONG ulActualResult,
	LPTSTR lptstrErrorDesc,
	bool bLogExpected				// If true we log expected vs actual result.
);

int OpenLogFiles
(	LPCTSTR lpctstrTCODetailFile,	
	CLogger *&pDetailLogger,
	LPTSTR *plpstrReturnedError
);

bool LogPropsDiff
(	CLogger *pDetailLogger,
	PEVENT_TRACE_PROPERTIES pProps1,
	PEVENT_TRACE_PROPERTIES pProps2
);

#define MAX_STR 1024

#endif // !defined(AFX_UTILITIES_H__C37E8DD0_ED3E_11D2_804A_009027345EE2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\logger\utilities.cpp ===
// Utilities.cpp: implementation of the CUtilities class.
//
//////////////////////////////////////////////////////////////////////
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#include "stdafx.h"

#pragma warning (disable : 4786)
#pragma warning (disable : 4275)

#include <iostream>
#include <strstream>
#include <fstream>
#include <string>
#include <sstream>
#include <map>
#include <list>

using namespace std;

#include <tchar.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>

#include <malloc.h>

#include <WTYPES.H>
#include "t_string.h"
#include <tchar.h>
#include <list>


#include "Persistor.h"
#include "Logger.h"

#include "StructureWrappers.h"
#include "StructureWapperHelpers.h"

#include "TCOData.h"
#include "Utilities.h"


//////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////

TCHAR *NewTCHAR(const TCHAR *ptcToCopy)
{
	if (ptcToCopy == NULL)
	{
		return NULL;
	}

	int nString = _tcsclen(ptcToCopy) + 1;
	int nTCHAR = sizeof(TCHAR);

	int nLen = nString * (nTCHAR); 

	TCHAR *pNew = (TCHAR*) malloc(nLen);

	_tcscpy(pNew,ptcToCopy);

	return pNew;
}

LPSTR NewLPSTR(LPCWSTR lpwstrToCopy)
{
	int nLen = (wcslen(lpwstrToCopy) + 1) * sizeof(WCHAR);
	LPSTR pNew = (char *)malloc( nLen );
   
	wcstombs(pNew, lpwstrToCopy, nLen);

	return pNew;
}

LPWSTR NewLPWSTR(LPCSTR lpstrToCopy)
{
	int nLen = (strlen(lpstrToCopy) + 1);
	LPWSTR pNew = (WCHAR *)malloc( nLen  * sizeof(WCHAR));
	mbstowcs(pNew, lpstrToCopy, nLen);

	return pNew;

}

LPTSTR DecodeStatus(IN ULONG Status)
{
	LPTSTR lptstrError = (LPTSTR) malloc (MAX_STR * (sizeof(TCHAR)));

    memset( lptstrError, 0, MAX_STR );

    FormatMessage(     
        FORMAT_MESSAGE_FROM_SYSTEM |     
        FORMAT_MESSAGE_IGNORE_INSERTS,    
        NULL,
        Status,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        lptstrError,
        MAX_STR,
        NULL );

	for (int i = 0; i < MAX_STR; i++)
	{
		if (lptstrError[i] == 0x0d)
		{
			lptstrError[i] = _T('\0');
			break;
		}
	}

    return lptstrError;
}

int GetFileList
(LPTSTR lptstrPath, LPTSTR lptstrFileType, list<t_string> &rList)
{
	t_string tsFind;

	tsFind = lptstrPath;
	tsFind += _T("\\");
	tsFind += lptstrFileType;


	WIN32_FIND_DATA wfdFile;
	HANDLE hFindHandle = 
		FindFirstFile(tsFind.c_str(), &wfdFile);

	if (hFindHandle == INVALID_HANDLE_VALUE)
	{
		return HRESULT_FROM_WIN32(GetLastError()); 
	}

	if ((_tcscmp(wfdFile.cFileName,_T(".")) != 0) &&
			(_tcscmp(wfdFile.cFileName,_T("..")) != 0))
	{
		tsFind = lptstrPath;
		tsFind += _T("\\");
		tsFind += wfdFile.cFileName;
		rList.push_back(tsFind);
		tsFind.erase();
	}

	while (FindNextFile(hFindHandle, &wfdFile))
	{
		if ((_tcscmp(wfdFile.cFileName,_T(".")) != 0) &&
			(_tcscmp(wfdFile.cFileName,_T("..")) != 0))
		{
			tsFind = lptstrPath;
			tsFind += _T("\\");
			tsFind += wfdFile.cFileName;
			rList.push_back(tsFind);
			tsFind.erase();
		}
	}

	FindClose(hFindHandle);

	return ERROR_SUCCESS;
} 

// From Q 118626
BOOL IsAdmin()
{
  HANDLE hAccessToken;
  UCHAR InfoBuffer[1024];
  PTOKEN_GROUPS ptgGroups = (PTOKEN_GROUPS)InfoBuffer;
  DWORD dwInfoBufferSize;
  PSID psidAdministrators;
  SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
  UINT x;
  BOOL bSuccess;

  if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE,
	 &hAccessToken )) {
	 if(GetLastError() != ERROR_NO_TOKEN)
		return FALSE;
	 //
	 // retry against process token if no thread token exists
	 //
	 if(!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY,
		&hAccessToken))
		return FALSE;
  }

  bSuccess = GetTokenInformation(hAccessToken,TokenGroups,InfoBuffer,
	 1024, &dwInfoBufferSize);

  CloseHandle(hAccessToken);

  if(!bSuccess )
	 return FALSE;

  if(!AllocateAndInitializeSid(&siaNtAuthority, 2,
	 SECURITY_BUILTIN_DOMAIN_RID,
	 DOMAIN_ALIAS_RID_ADMINS,
	 0, 0, 0, 0, 0, 0,
	 &psidAdministrators))
	 return FALSE;

// assume that we don't find the admin SID.
  bSuccess = FALSE;

  for(x=0;x<ptgGroups->GroupCount;x++)
  {
	 if( EqualSid(psidAdministrators, ptgGroups->Groups[x].Sid) )
	 {
		bSuccess = TRUE;
		break;
	 }

  }
  FreeSid(psidAdministrators);
  return bSuccess;
}

t_string GUIDToTString(GUID Guid)
{
	t_strstream strStream;
	t_string tsOut;

	strStream << _T("{");
	
	strStream.fill(_T('0'));
	strStream.width(8);
	strStream.flags(ios_base::right);

	strStream << hex << Guid.Data1;

	strStream << _T("-");

	strStream.width(4);

	strStream << hex << Guid.Data2;

	strStream << _T("-");

	strStream << hex << Guid.Data3;

	strStream << _T("-");

	// Data4 specifies an array of 8 bytes. The first 2 bytes contain 
	// the third group of 4 hexadecimal digits. The remaining 6 bytes 
	// contain the final 12 hexadecimal digits. 

#ifndef _UNICODE
	int i;

	strStream.width(1);

	BYTE Byte;
	int Int;
	for (i = 0; i < 2; i++)
	{
		Byte = Guid.Data4[i];
		Byte = Byte >> 4;
		Int = Byte;
		strStream <<  hex << Int;
		Byte = Guid.Data4[i];
		Byte = 0x0f & Byte;
		Int = Byte;
		strStream << hex << Int;
	}

	strStream << _T("-");

	strStream.width(1);


	for (i = 2; i < 8; i++)
	{
		BYTE Byte = Guid.Data4[i];
		Byte = Byte >> 4;
		Int = Byte;
		strStream << hex << Int;
		Byte = Guid.Data4[i];
		Byte = 0x0f & Byte;
		Int = Byte;
		strStream << hex << Int;
	}
#else
	int i;

	for (i = 0; i < 2; i++)
	{
		TCHAR tc = Guid.Data4[i];
		// For some reason the width is reset each time through the 
		// loop to be one.
		strStream.width(2);
		strStream << hex << tc;
	}

	strStream << _T("-");
	
	BYTE Byte;
	strStream.width(1);
	for (i = 2; i < 8; i++)
	{
		Byte = Guid.Data4[i];
		Byte = Byte >> 4;
		strStream << hex << Byte;
		Byte = Guid.Data4[i];
		Byte = 0x0f & Byte;
		strStream << hex << Byte;
	}
#endif

	strStream << _T("}");

	strStream >> tsOut;

	return tsOut;
}

LPTSTR LPTSTRFromGuid(GUID Guid)
{
	t_string tsGuid = GUIDToTString(Guid);
	return NewTCHAR(tsGuid.c_str());
}

t_string ULONGVarToTString(ULONG ul, bool bHex)
{
	t_string tsTemp;
	t_strstream strStream;

	if (bHex)
	{
		strStream.width(8);
		strStream.fill('0');
		strStream.flags(ios_base::right);
		strStream << hex << ul;
	}
	else
	{
		strStream << ul;
	}

	strStream >> tsTemp;

	if (bHex)
	{
		t_string tsHex;
		tsHex = _T("0x");
		tsHex += tsTemp;
		return tsHex;
	}
	else
	{
		return tsTemp;
	}
}

ULONG InitializePropsArray
(PEVENT_TRACE_PROPERTIES &pPropsArray, int nInstances)
{
	pPropsArray = 
		(PEVENT_TRACE_PROPERTIES) malloc 
		(sizeof(EVENT_TRACE_PROPERTIES) * nInstances);

	RtlZeroMemory(pPropsArray, sizeof(EVENT_TRACE_PROPERTIES) * nInstances);

	for (int i = 0; i < nInstances; i++)
	{
		pPropsArray[i].LoggerName = (TCHAR *) malloc (sizeof(TCHAR) * MAX_STR);
		RtlZeroMemory(pPropsArray[i].LoggerName, sizeof(TCHAR) * MAX_STR);
		pPropsArray[i].LogFileName = (TCHAR *) malloc (sizeof(TCHAR) * MAX_STR);
		RtlZeroMemory(pPropsArray[i].LogFileName, sizeof(TCHAR) * MAX_STR);
	}

	return 0;
}

ULONG FreePropsArray
(PEVENT_TRACE_PROPERTIES &pPropsArray, int nInstances)
{
	for (int i = 0; i < nInstances; i++)
	{
		free(pPropsArray[i].LoggerName);
		free(pPropsArray[i].LogFileName);
	}

	free(pPropsArray);

	return 0;
}

int OpenLogFiles
(	LPCTSTR lpctstrTCODetailFile,	
	CLogger *&pDetailLogger,
	LPTSTR *plpstrReturnedError
)
{
	HRESULT hr = S_OK;
	t_string tsError;

	if (lpctstrTCODetailFile)
	{
		// Open *our* logger file.
		pDetailLogger = new CLogger(lpctstrTCODetailFile, false);
		hr = pDetailLogger->GetOpenStatus();
		if (FAILED (hr))
		{
			tsError = _T("Could not open detail log file \"");
			tsError += lpctstrTCODetailFile;
			tsError += _T("\".");
			*plpstrReturnedError = NewTCHAR(tsError.c_str());
			return hr;
		}
	}

	return hr;
}




int LogDetailBeforeCall
(	CLogger *pDetailLogger,
	TCOData *pstructTCOData,
	BOOL bAdmin
)
{
	// Want to log the security context, user must have administrative priviledge!

	pDetailLogger->LogTCHAR(_T("----  Input Data ----\n"));
	pDetailLogger->LogTCHAR(_T("Description: "));
	pDetailLogger->LogTCHAR(pstructTCOData->m_lptstrLongDesc);
	pDetailLogger->LogTCHAR(_T("\n"));


	pDetailLogger->LogTCHAR(_T("User Security Context: "));
	if (bAdmin)
	{
		pDetailLogger->LogTCHAR(_T("Has administrative priviledge.\n"));
	}
	else
	{
		pDetailLogger->LogTCHAR(_T("Does not have administrative priviledge.\n"));
	}


	pDetailLogger->LogTCHAR(_T("LoggerType: "));
	pDetailLogger->LogTCHAR(pstructTCOData->m_lptstrLoggerMode);
	pDetailLogger->LogTCHAR(_T("\n"));

	pDetailLogger->LogTCHAR(_T("Enable: "));
	pDetailLogger->LogULONG(pstructTCOData->m_ulEnable);
	pDetailLogger->LogTCHAR(_T("\n"));

	pDetailLogger->LogTCHAR(_T("EnableFlag: "));
	pDetailLogger->LogULONG(pstructTCOData->m_ulEnableFlag);
	pDetailLogger->LogTCHAR(_T("\n"));

	pDetailLogger->LogTCHAR(_T("EnableLevel: "));
	pDetailLogger->LogULONG(pstructTCOData->m_ulEnableLevel);
	pDetailLogger->LogTCHAR(_T("\n"));

	pDetailLogger->LogTCHAR(_T("Expected Result: "));
	pDetailLogger->LogULONG(pstructTCOData->m_ulExpectedResult, true);
	pDetailLogger->LogTCHAR(_T("\n"));

	pDetailLogger->LogTCHAR(_T("Trace Handle: "));
	if (pstructTCOData->m_pTraceHandle == NULL)
	{
		pDetailLogger->LogULONG64(0, true);
	}
	else
	{
		pDetailLogger->LogULONG64(*pstructTCOData->m_pTraceHandle, true);
	}
	pDetailLogger->LogTCHAR(_T("\n"));

	pDetailLogger->LogTCHAR(_T("Instance Name: "));
	pDetailLogger->LogTCHAR(pstructTCOData->m_lptstrInstanceName);
	pDetailLogger->LogTCHAR(_T("\n"));

	pDetailLogger->LogEventTraceProperties(pstructTCOData->m_pProps);

	pDetailLogger->LogTCHAR(_T("Guids:"));

	LPTSTR lptstrGuid;

	if (pstructTCOData->m_pProps != 0)
	{
		for (int i = 0; i < pstructTCOData->m_nGuids; i++) 
		{
			lptstrGuid = LPTSTRFromGuid(pstructTCOData->m_lpguidArray[i]);
			pDetailLogger->LogTCHAR(lptstrGuid);
			free (lptstrGuid);
			lptstrGuid = NULL;
			if (pstructTCOData->m_nGuids > 1 
				&& i < pstructTCOData->m_nGuids - 1)
			{
				pDetailLogger->LogTCHAR(_T(","));
			}
		}
	}

	pDetailLogger->LogTCHAR(_T("\n"));
	pDetailLogger->Flush();

	return 0;
}


int LogDetailAfterCall
(	CLogger *pDetailLogger,
	TCOData *pstructTCOData, 
	PEVENT_TRACE_PROPERTIES *pProps,
	ULONG ulResult,
	LPTSTR lpstrReturnedError,
	bool bValid,
	BOOL bAdmin,
	LPCTSTR lptstrBanner,
	bool bPrintProps
)
{
	pDetailLogger->LogTCHAR(_T("----  Returned Values ----\n"));

	if (lptstrBanner)
	{
		pDetailLogger->LogTCHAR(lptstrBanner);
		pDetailLogger->LogTCHAR(_T("\n"));
	}

	if (!bAdmin && ulResult == ERROR_SUCCESS 
		&& ulResult == pstructTCOData->m_ulExpectedResult)
	{
		pDetailLogger->LogTCHAR(_T("Test: "));
		pDetailLogger->LogTCHAR(pstructTCOData->m_lptstrShortDesc);
		pDetailLogger->LogTCHAR(_T(" failed\n"));
		pDetailLogger->LogTCHAR(_T("SecurityContextError:  API should have failed because the user does not have administrative privledge.\n"));	
	}
	else if (ulResult == pstructTCOData->m_ulExpectedResult)
	{
		pDetailLogger->LogTCHAR(_T("Test: "));
		pDetailLogger->LogTCHAR(pstructTCOData->m_lptstrShortDesc);
		pDetailLogger->LogTCHAR(_T(" passed\n"));

	}
	else
	{
		pDetailLogger->LogTCHAR(_T("Test: "));
		pDetailLogger->LogTCHAR(pstructTCOData->m_lptstrShortDesc);
		pDetailLogger->LogTCHAR(_T(" failed\n"));
		pDetailLogger->LogTCHAR(_T("Expected result: "));
		pDetailLogger->LogULONG(pstructTCOData->m_ulExpectedResult, true);
		pDetailLogger->LogTCHAR(_T("\n"));
	}

	pDetailLogger->LogTCHAR(_T("Test result: "));
	pDetailLogger->LogULONG(ulResult, true);
	pDetailLogger->LogTCHAR(_T("\n"));

	if (ulResult && lpstrReturnedError)
	{
		pDetailLogger->LogTCHAR(_T("Error Description: "));
		pDetailLogger->LogTCHAR(lpstrReturnedError);
		pDetailLogger->LogTCHAR(_T("\n"));
	}

	pDetailLogger->LogTCHAR(_T("Trace Handle: "));
	if (pstructTCOData->m_pTraceHandle == NULL)
	{
		pDetailLogger->LogULONG64(0, true);
	}
	else
	{
		pDetailLogger->LogULONG64(*pstructTCOData->m_pTraceHandle, true);
	}
	pDetailLogger->LogTCHAR(_T("\n"));

	if (bPrintProps)
	{
		pDetailLogger->LogEventTraceProperties(*pProps);
		pDetailLogger->LogTCHAR(_T("-------------------------------------------------------\n"));

	}

	pDetailLogger->Flush();

	return 0;
}

int LogSummaryBeforeCall
(	
	TCOData *pstructTCOData, 
	LPCTSTR lpctstrDataFile,
	LPCTSTR lptstrAction,
	LPCTSTR lptstrAPI,
	bool bLogExpected
)
{
	t_cout << _T("\n") << lptstrAPI << _T(" called with TCOTest = ") 
		<< pstructTCOData->m_lptstrShortDesc << _T("\n");
	t_cout << _T("Action = ") << lptstrAction << _T("\n");
	if (lpctstrDataFile)
	{
		t_cout <<  _T("DataFile = ") << lpctstrDataFile  << _T("\n");
	}
	if (bLogExpected && pstructTCOData->m_lptstrLongDesc)
	{
		t_cout <<  _T("Description = ") << pstructTCOData->m_lptstrLongDesc << _T("\n");
	}

	return ERROR_SUCCESS;
}

int LogSummaryAfterCall
(	
	TCOData *pstructTCOData, 
	LPCTSTR lpctstrDataFile,
	LPCTSTR lptstrAction,
	ULONG ulActualResult,
	LPTSTR lptstrErrorDesc,
	bool bLogExpected
)
{
	t_string tsOut1;
	t_string tsOut2;

	tsOut1 = ULONGVarToTString(ulActualResult, true);
	tsOut2 = ULONGVarToTString(pstructTCOData->m_ulExpectedResult, true);

	if (ulActualResult == pstructTCOData->m_ulExpectedResult && bLogExpected)
	{
		t_cout << pstructTCOData->m_lptstrShortDesc << _T(" - Passed:  Actual result "); 
		t_cout << tsOut1 << _T(" = to expected result ") << tsOut2 << _T(".\n");
	}
	else if (ulActualResult != pstructTCOData->m_ulExpectedResult && bLogExpected)
	{
		t_cout << pstructTCOData->m_lptstrShortDesc << _T(" - Failed:  Actual result "); 
		t_cout << tsOut1 << _T(" not = to expected result ") << tsOut2 << _T(".\n");
	}
	else if (ulActualResult == ERROR_SUCCESS && !bLogExpected)
	{
		t_cout << pstructTCOData->m_lptstrShortDesc << _T(" - Passed.\n"); 
	}
	else if (ulActualResult != ERROR_SUCCESS && !bLogExpected)
	{
		t_cout << pstructTCOData->m_lptstrShortDesc << _T(" - Failed.\n"); 
	}

	if (lptstrErrorDesc && ulActualResult != pstructTCOData->m_ulExpectedResult)
	{
		t_cout << _T("Error: ") << lptstrErrorDesc << _T("\n"); 
	}

	return 0;
}

bool LogPropsDiff
(	CLogger *pDetailLogger,
	PEVENT_TRACE_PROPERTIES pProps1,
	PEVENT_TRACE_PROPERTIES pProps2
)
{
	bool bDiff = false;
	if (pDetailLogger)
	{
		pDetailLogger->LogTCHAR(_T("EVENT_TRACE_PROPERTIES data items which differ:\n"));
		pDetailLogger->Flush();
	}

    if (pProps1->BufferSize != pProps2->BufferSize)
	{
		if (pDetailLogger)
		{
			pDetailLogger->LogTCHAR(_T("  BufferSize\n"));
		}
		bDiff = true;
	}

	if (pProps1->MinimumBuffers != pProps2->MinimumBuffers)
	{
		if (pDetailLogger)
		{
			pDetailLogger->LogTCHAR(_T("  MinimumBuffers\n"));
		}
		bDiff = true;
	}
    
	if (pProps1->MaximumBuffers != pProps2->MaximumBuffers)
	{
		if (pDetailLogger)
		{
			pDetailLogger->LogTCHAR(_T("  MaximumBuffers\n"));
		}
		bDiff = true;
	}
  
	if (pProps1->MaximumFileSize != pProps2->MaximumFileSize)
	{
		if (pDetailLogger)
		{
			pDetailLogger->LogTCHAR(_T("  MaximumFileSize\n"));
		}
		bDiff = true;
	}

	if (pProps1->LogFileMode != pProps2->LogFileMode)
	{
		if (pDetailLogger)
		{
			pDetailLogger->LogTCHAR(_T("  LogFileMode\n"));
		}
		bDiff = true;
	}

	if (pProps1->FlushTimer != pProps2->FlushTimer)
	{
		if (pDetailLogger)
		{
			pDetailLogger->LogTCHAR(_T("  FlushTimer\n"));
		}
		bDiff = true;
	}

	if (pProps1->EnableFlags != pProps2->EnableFlags)
	{
		if (pDetailLogger)
		{
			pDetailLogger->LogTCHAR(_T("  EnableFlags\n"));
		}
		bDiff = true;
	}

	if (pProps1->AgeLimit != pProps2->AgeLimit)
	{
		if (pDetailLogger)
		{
			pDetailLogger->LogTCHAR(_T("  AgeLimit\n"));
		}
		bDiff = true;
	}

	if (!bDiff)
	{
		if (pDetailLogger)
		{
			pDetailLogger->LogTCHAR(_T("  None\n"));
		}
	}
		
	if (pDetailLogger)
	{
		pDetailLogger->Flush();
	}

	return bDiff;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\logger\updatetraceapi.cpp ===
// 
//
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#include "stdafx.h"

#pragma warning (disable : 4786)
#pragma warning (disable : 4275)

#include <iostream>
#include <strstream>
#include <fstream>
#include <string>
#include <sstream>
#include <map>
#include <ctime>
#include <list>


using namespace std;


#include <tchar.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>

#include <WTYPES.H>
#include "t_string.h"

#include "Persistor.h"
#include "Logger.h"
#include "TCOData.h"
#include "Utilities.h"

#include "StructureWrappers.h"
#include "StructureWapperHelpers.h"
#include "ConstantMap.h" 
#include "TCOData.h"
#include "Logger.h"
#include "Validator.h"

#include "CollectionControl.h"
  
int UpdateTraceAPI
(	
	IN LPTSTR lptstrAction,				// For logging only.
 	IN LPCTSTR lpctstrDataFile,			// For logging only.
	IN LPCTSTR lpctstrTCODetailFile,	// If valid we will log to it, can be NULL.
	IN bool bLogExpected,				// If true we log expected vs actual result.
	IN bool bUseTraceHandle,			// If true use the handle.
	IN OUT TCOData *pstructTCOData,		// TCO test data.
	OUT int *pAPIReturn					// UpdateTrace API call return
)
{	

	LPTSTR lptstrReturnedError = NULL;
	*pAPIReturn = -1;

	CLogger *pDetailLogger = NULL;

	int nResult = 0;

	// We only log if the test of "interest" is UpdateTrace.
	if (pstructTCOData->m_ulAPITest == TCOData::UpdateTraceTest)
	{
		nResult = 
			OpenLogFiles
			(	
				lpctstrTCODetailFile,
				pDetailLogger,
				&lptstrReturnedError
			);
	}
	
	if (FAILED(nResult))
	{
		delete pDetailLogger;
	
		//  Open log files sets error string lptstrReturnedError.
		LogSummaryBeforeCall
		(	
			pstructTCOData, 
			lpctstrDataFile,
			lptstrAction,
			_T("StopTrace"),
			bLogExpected
		);

		LogSummaryAfterCall
		(	
			pstructTCOData, 
			lpctstrDataFile,
			lptstrAction,
			nResult,
			lptstrReturnedError,
			bLogExpected
		);

		free(lptstrReturnedError);
		lptstrReturnedError = NULL;

		return nResult;
	}
			
	// This is our log file.
	if (pDetailLogger)
	{
		pDetailLogger->LogTCHAR(_T("\n-------------------------------------------------------\n"));
		pDetailLogger->LogTCHAR(_T("UpdateTraceAPI TCO test "));
		pDetailLogger->Flush();	
	}

	if (pDetailLogger)
	{
		pDetailLogger->LogTCHAR(pstructTCOData->m_lptstrShortDesc);
		int n = pDetailLogger->LogTCHAR(_T(" started at time "));
		time_t Time;
		time(&Time);
		pDetailLogger->LogTime(Time);
		pDetailLogger->LogTCHAR(_T(".\n"));
		pDetailLogger->Flush();
	}

	BOOL bAdmin = IsAdmin();

	if (pDetailLogger)
	{
		// Log argument values before calling StopTrace.
		LogDetailBeforeCall
		(
			pDetailLogger,
			pstructTCOData,
			bAdmin
		);
	}

	CEventTraceProperties CProps (pstructTCOData->m_pProps);
	PEVENT_TRACE_PROPERTIES pProps = CProps.GetEventTracePropertiesInstance();
	
	LogSummaryBeforeCall
	(	
		pstructTCOData, 
		lpctstrDataFile,
		lptstrAction,
		_T("UpdateTrace"),
		bLogExpected
	);

	*pAPIReturn = 
		ControlTrace
		( 
			bUseTraceHandle ? *pstructTCOData->m_pTraceHandle : NULL, 
			bUseTraceHandle ? NULL : pstructTCOData->m_lptstrInstanceName, 
			pProps,
			EVENT_TRACE_CONTROL_UPDATE
		);

	ULONG ulResult = pstructTCOData->m_ulExpectedResult == *pAPIReturn ? ERROR_SUCCESS : -1;

	if (ulResult != ERROR_SUCCESS && *pAPIReturn == ERROR_SUCCESS)
	{
		ulResult = *pAPIReturn;
	}
	else if (*pAPIReturn != ERROR_SUCCESS) 
	{
		lptstrReturnedError = DecodeStatus(*pAPIReturn);	
	}
	else if (pstructTCOData->m_ulAPITest == TCOData::UpdateTraceTest &&
			 pstructTCOData->m_lptstrValidator &&
			 _tcslen(pstructTCOData->m_lptstrValidator) > 0)
	{
		CValidator Validator;
			
		bool bValid = 
			Validator.Validate
			(
				pstructTCOData->m_pTraceHandle, 
				pstructTCOData->m_lptstrInstanceName, 
				pstructTCOData->m_pProps, 
				pstructTCOData->m_lptstrValidator
			);

		if (!bValid)
		{
			ulResult = -1;
			lptstrReturnedError = NewTCHAR(_T("Validation routine failed."));
		}
	}

	bool bDiff = 
		LogPropsDiff
		(
			NULL,
			pstructTCOData->m_pProps,
			pProps
		);
	
	// If there were differences and 
	// *pAPIReturn == ERROR_SUCCESS == pstructTCOData->m_ulExpectedResult
	// we need to set return codes to indicate differences.  Look in detail
	// log for differences.
	if (bDiff &&
		*pAPIReturn == ERROR_SUCCESS &&
		pstructTCOData->m_ulExpectedResult == ERROR_SUCCESS)
	{
		free (lptstrReturnedError);
		lptstrReturnedError = NULL;
		*pAPIReturn = -1;
		lptstrReturnedError = 
			NewTCHAR(_T("Different values returned in EVENT_TRACE_PROPERTIES structure."));
	}

	if (pDetailLogger)
	{
		LogDetailAfterCall
		(	pDetailLogger,
			pstructTCOData,
			&pProps,
			*pAPIReturn,
			lptstrReturnedError,
			true,
			bAdmin
		);
	}

	LogPropsDiff
	(
		pDetailLogger,
		pstructTCOData->m_pProps,
		pProps
	);

	LogSummaryAfterCall
	(
		pstructTCOData, 
		lpctstrDataFile,
		lptstrAction,
		*pAPIReturn,
		lptstrReturnedError,
		bLogExpected
	);
	
	delete pDetailLogger;

	free(lptstrReturnedError);
	lptstrReturnedError = NULL;

	if (pProps)
	{
		free(pProps->LoggerName);
		free(pProps->LogFileName);
	}

	free(pProps);	

	return ulResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\mcegen\mcegen.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <stdlib.h>

#include "wmium.h"

#if defined(_IA64_)

ERROR_DEVICE_GUID ErrorProcessorGuid = ERROR_PROCESSOR_GUID;
ERROR_DEVICE_GUID ErrorMemoryGuid = ERROR_MEMORY_GUID;
ERROR_DEVICE_GUID ErrorPciBusGuid = ERROR_PCI_BUS_GUID;
ERROR_DEVICE_GUID ErrorPciComponentGuid = ERROR_PCI_COMPONENT_GUID;
ERROR_DEVICE_GUID ErrorSystemEventLogGuid = ERROR_SYSTEM_EVENT_LOG_GUID;
ERROR_DEVICE_GUID ErrorSmbiosGuid = ERROR_SMBIOS_GUID;
ERROR_DEVICE_GUID ErrorPlatformSpecificGuid = ERROR_PLATFORM_SPECIFIC_GUID;
ERROR_DEVICE_GUID ErrorPlatformBusGuid = ERROR_PLATFORM_BUS_GUID;
ERROR_DEVICE_GUID ErrorPlatformHostControllerGuid = ERROR_PLATFORM_HOST_CONTROLLER_GUID;

#endif // _IA64_

UCHAR InvalidError[] =
{
0x08, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x02, 0x00, 0x00, 0x01,    0x40, 0x18, 0x00, 0x00,  
0x50, 0x53, 0x09, 0x00,    0x09, 0x05, 0x01, 0x20,    0x07, 0xc1, 0xd2, 0xa4,    0xb2, 0x40, 0xd4, 0x11,  
0xb1, 0x83, 0x00, 0xa0,    0xc9, 0xfc, 0x52, 0x7e,    0xf1, 0xfa, 0x29, 0xe4,    0xb7, 0x3c, 0xd4, 0x11,  
0xbc, 0xa7, 0x00, 0x80,    0xc7, 0x3c, 0x88, 0x81,    0x02, 0x00, 0x00, 0x00,    0x20, 0x15, 0x00, 0x00,  
0x17, 0x00, 0x00, 0x01,    0x00, 0x00, 0x00, 0x00,    0x00, 0x10, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x20, 0x11, 0xf2, 0xff,    0x00, 0x00, 0x00, 0x08,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x01, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x01, 0x07, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x47, 0x65, 0x6e, 0x75,    0x69, 0x6e, 0x65, 0x49,    0x6e, 0x74, 0x65, 0x6c,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x04, 0x06, 0x00, 0x07,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x1f, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x80, 0xf3, 0xc7, 0xe5,    0x65, 0x01, 0x00, 0xe0,    0xd1, 0x01, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0xea, 0x01, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x10, 0x58, 0xc1, 0x77,    0x00, 0x00, 0x00, 0x00,  
0x38, 0x06, 0x01, 0x01,    0x00, 0x00, 0x00, 0x00,    0x00, 0xe0, 0xfd, 0xff,    0xfb, 0x06, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0xd1, 0x01, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x80, 0x80, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x96, 0x02, 0x00, 0xc0,    0xff, 0xff, 0xff, 0xff,    0x90, 0x72, 0xda, 0xdc,    0x65, 0x01, 0x00, 0xe0,  
0x00, 0xc0, 0xfd, 0xff,    0xfb, 0x06, 0x00, 0x00,    0x88, 0xd6, 0xaa, 0x81,    0x00, 0x00, 0x00, 0xe0,  
0x01, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x18, 0x60, 0x2a, 0x08,    0x13, 0x10, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0xa0, 0x7a, 0x7e, 0x77,    0x00, 0x00, 0x00, 0x00,  
0x01, 0xad, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x07, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x80,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x78, 0xda, 0xdc,    0x65, 0x01, 0x00, 0xe0,  
0x00, 0x78, 0xda, 0xdc,    0x65, 0x01, 0x00, 0xe0,    0xb0, 0x4b, 0x74, 0xe5,    0x65, 0x01, 0x00, 0xe0,  
0x10, 0x5d, 0x79, 0x59,    0x00, 0xff, 0xff, 0xff,    0x47, 0x50, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x61, 0xc6, 0x50, 0x01,    0x00, 0x00, 0x10, 0x00,    0x61, 0xc6, 0x50, 0x01,    0x00, 0x00, 0x10, 0x00,  
0x34, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x04, 0x08, 0x00, 0x00,  
0xb0, 0x4b, 0x74, 0xe5,    0x65, 0x01, 0x00, 0xe0,    0xb8, 0x72, 0xda, 0xdc,    0x65, 0x01, 0x00, 0xe0,  
0xe0, 0xe4, 0xca, 0x86,    0x00, 0x00, 0x00, 0xe0,    0x40, 0xeb, 0xa7, 0xe5,    0x65, 0x01, 0x00, 0xe0,  
0xd8, 0xe4, 0xca, 0x86,    0x00, 0x00, 0x00, 0xe0,    0xb0, 0x72, 0xda, 0xdc,    0x65, 0x01, 0x00, 0xe0,  
0x60, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0xc0, 0x72, 0xda, 0xdc,    0x65, 0x01, 0x00, 0xe0,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x80, 0x00, 0x00,  
0xf8, 0xf0, 0xa7, 0xe5,    0x65, 0x01, 0x00, 0xe0,    0xdc, 0xe4, 0xca, 0x86,    0x00, 0x00, 0x00, 0xe0,  
0x10, 0x27, 0xba, 0x86,    0x00, 0x00, 0x00, 0xe0,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x28, 0x64, 0x00, 0x83,    0x00, 0x00, 0x00, 0xe0,    0xa0, 0x72, 0xda, 0xdc,    0x65, 0x01, 0x00, 0xe0,  
0xa0, 0x72, 0xda, 0xdc,    0x65, 0x01, 0x00, 0xe0,    0x47, 0xa0, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x60, 0xed, 0xa7, 0xe5,    0x65, 0x01, 0x00, 0xe0,    0x03, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x80, 0xed, 0xa7, 0xe5,    0x65, 0x01, 0x00, 0xe0,    0x18, 0x60, 0x2a, 0x08,    0x10, 0x10, 0x00, 0x00,  
0x11, 0x06, 0x00, 0x00,    0x00, 0x00, 0x00, 0x80,    0xf0, 0xef, 0xa7, 0xe5,    0x65, 0x01, 0x00, 0xe0,  
0x18, 0x60, 0x2a, 0x08,    0x10, 0x10, 0x00, 0x00,    0x07, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x40, 0x5f, 0xff, 0xff,    0x00, 0x00, 0x00, 0x80,  
0x80, 0xfe, 0xe7, 0xff,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x40, 0x2f, 0xff, 0xff,    0x00, 0x00, 0x00, 0x00,  
0xa0, 0xee, 0x07, 0x83,    0x00, 0x00, 0x00, 0xe0,    0x05, 0x7f, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x16, 0xf6, 0xd3, 0x0b,    0x85, 0x1f, 0x00, 0x00,    0x00, 0x00, 0x26, 0x83,    0x00, 0x00, 0x00, 0xe0,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0xa1, 0x00, 0x00, 0x00,    0x00, 0xff, 0xff, 0x1f,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x18, 0x60, 0x2a, 0x08,    0x10, 0x10, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x04, 0x08, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x80, 0xed, 0xa7, 0xe5,    0x65, 0x01, 0x00, 0xe0,    0xb0, 0x4b, 0x74, 0xe5,    0x65, 0x01, 0x00, 0xe0,  
0x34, 0x01, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x70, 0xed, 0xa7, 0xe5,    0x65, 0x01, 0x00, 0xe0,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x19, 0x01, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x10, 0x5d, 0x79, 0x59,    0x00, 0xff, 0xff, 0xff,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0xd0, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0xf0, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x30, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0xfc,    0xff, 0x0f, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0xc0, 0xfd, 0xff,    0xfb, 0x06, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0xad, 0x09, 0x83,    0x00, 0x00, 0x00, 0xe0,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0xf0, 0x89, 0xda, 0xdc,    0x65, 0x01, 0x00, 0xe0,    0x30, 0x87, 0xda, 0xdc,    0x65, 0x01, 0x00, 0xe0,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x88, 0xd6, 0xaa, 0x81,    0x00, 0x00, 0x00, 0xe0,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x3f, 0x03, 0x70, 0x02,    0x4c, 0x80, 0x09, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0xcc, 0x34, 0xf7, 0x0b,    0x85, 0x1f, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x11, 0x06, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x35, 0x22, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x35, 0x22, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x35, 0x22, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x35, 0x22, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x35, 0x22, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x35, 0x22, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x35, 0x22, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x35, 0x22, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x67, 0x72, 0x04, 0x00,    0x00, 0x00, 0x00, 0x00,    0x3e, 0x00, 0x01, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0xf8, 0xff, 0xff,    0xff, 0xff, 0xff, 0xff,    0x3e, 0x00, 0x01, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x78, 0x7b, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x3e, 0x00, 0x01, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x50, 0x52, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x3e, 0x00, 0x01, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x98, 0x3e, 0x93, 0x23,    0x00, 0x00, 0x00, 0x00,    0x3e, 0x00, 0x01, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0xf7, 0xfa, 0x29, 0xe4,    0xb7, 0x3c, 0xd4, 0x11,  
0xbc, 0xa7, 0x00, 0x80,    0xc7, 0x3c, 0x88, 0x81,    0x02, 0x00, 0x00, 0x00,    0xf8, 0x02, 0x00, 0x00,  
0xc0, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x07, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0xcf, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x04, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x01, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x86, 0x80, 0xe0, 0x84,    0x00, 0x00, 0x00, 0x00,    0x28, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x02, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x40, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x44, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0xcf, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x04, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x04, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x86, 0x80, 0xe1, 0x84,    0x00, 0x00, 0x00, 0x00,    0x28, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x02, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x80, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x84, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0xcf, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x04, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x10, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x01, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x86, 0x80, 0xcb, 0x84,    0x00, 0x00, 0x00, 0x00,    0x28, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x02, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x06, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x56, 0x01, 0x80, 0x22,    0x00, 0x00, 0x00, 0x00,  
0x44, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x1c, 0x00,    0x00, 0x00, 0x00, 0x00,  
0xcf, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x04, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x14, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x01, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x86, 0x80, 0xea, 0x84,    0x00, 0x00, 0x00, 0x00,    0x28, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x02, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x06, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x56, 0x01, 0xb0, 0x22,    0x00, 0x00, 0x00, 0x00,  
0x44, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0xcf, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x04, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x12, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x01, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x86, 0x80, 0xe6, 0x84,    0x00, 0x00, 0x00, 0x00,    0x28, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x02, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x06, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x46, 0x01, 0xb0, 0x02,    0x00, 0x00, 0x00, 0x00,  
0x44, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x40, 0x34, 0x70,    0x00, 0x00, 0x00, 0x00,  
0xcf, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x04, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x13, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x01, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x86, 0x80, 0xe6, 0x84,    0x00, 0x00, 0x00, 0x00,    0x28, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x02, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x06, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x46, 0x01, 0xb0, 0x02,    0x00, 0x00, 0x00, 0x00,  
0x44, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x40, 0xb4, 0x10,    0x00, 0x00, 0x00, 0x00,  
0xcf, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x03, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x86, 0x80, 0x00, 0x76,    0x00, 0x00, 0x00, 0x00,    0x28, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x01, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,  
0x06, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x0f, 0x00, 0x80, 0x02,    0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00  
};

#define GenerateMCEGuid { 0x3001bce4, 0xd9b6, 0x4167, { 0xb5, 0xe1, 0x39, 0xa7, 0x28, 0x59, 0xe2, 0x67 } }
GUID WmipGenerateMCEGuid = GenerateMCEGuid;

UCHAR Buffer[0x40000];

typedef struct
{
	ULONG Code;
	ULONG Count;
} THREADCONTROL, *PTHREADCONTROL;

ULONG GenerateMCE(
    PVOID Context
    )
{
	NTSTATUS Result;
	ULONG ResultSize;
	HANDLE Handle;
	ULONG Status;
	PERROR_RECORD_HEADER rh;
	PERROR_SECTION_HEADER sh;
	ULONG Size;
	ULONG MethodId;
	PTHREADCONTROL ThreadControl = (PTHREADCONTROL)Context;
	ULONG Code = ThreadControl->Code;
	ULONG Count = ThreadControl->Count;
	ULONG i;

	Status = WmiOpenBlock(&WmipGenerateMCEGuid,
						  0,
						  &Handle);

	if (Status == ERROR_SUCCESS)
	{
		rh = (PERROR_RECORD_HEADER)Buffer;
		rh->Id = 0x12345678;
		rh->Revision.Revision = 0x0200;

		rh->Valid.Valid = 0;
		rh->TimeStamp.TimeStamp = 0x2001031900165323;

		sh = (PERROR_SECTION_HEADER)((PUCHAR)rh + sizeof(ERROR_RECORD_HEADER));
		memset(sh, 0, sizeof(Buffer));
				
		sh->Revision.Revision = 0x0200;

		sh->RecoveryInfo.RecoveryInfo = 0;
		if ((Code >= 1000) && (Code <= 1999))
		{
			MethodId = 4;
			rh->ErrorSeverity = ErrorFatal;
		} else if ((Code >= 2000) && (Code <= 2999)) {
			MethodId = 2;                         // CMC
			rh->ErrorSeverity = ErrorCorrected;
			sh->RecoveryInfo.Corrected = 1;
		} else if ((Code >= 3000) && (Code <= 3999)) {
			MethodId = 3;                        // CPE
			rh->ErrorSeverity = ErrorCorrected;
			sh->RecoveryInfo.Corrected = 1;
		} else {
			MethodId = 1;
		}

		//
		// Mark as CPU 3
		//
		rh->TimeStamp.Reserved = 3;
		
		switch(Code)
		{
			//
			// Fatal SMBIOS Error
			//
			case 1001:
			case 2001:
			case 3001:
			{
				PERROR_SMBIOS s;

				sh->Length = sizeof(ERROR_SMBIOS);
				sh->Guid = ErrorSmbiosGuid;
						   
				s = (PERROR_SMBIOS)sh;
				s->Valid.Valid = 0;
				s->Valid.EventType = 1;
				s->EventType = 0xa0;
				
				break;
			}


			//
			// Fatal CPU Error: 2 cache 1 TLB and 2 Regfile
			//
			case 1002:
			case 2002:
			case 3002:
			{
				PERROR_PROCESSOR s;
				ULONG TotalSize;
				PERROR_MODINFO ModInfo;
				ERROR_CACHE_CHECK CacheCheck;
				ERROR_TLB_CHECK TlbCheck;

				TotalSize = sizeof(ERROR_PROCESSOR) +
							 5 * sizeof(ERROR_MODINFO) +
							 sizeof(ERROR_PROCESSOR_CPUID_INFO) +
							 sizeof(ERROR_PROCESSOR_STATIC_INFO);

				sh->Length = TotalSize;
				sh->Guid = ErrorProcessorGuid;
						   
				s = (PERROR_PROCESSOR)sh;
				s->Valid.CacheCheckNum = 2;
				s->Valid.TlbCheckNum = 1;
				s->Valid.RegFileCheckNum = 2;
				
				ModInfo = (PERROR_MODINFO)((PUCHAR)sh + sizeof(ERROR_PROCESSOR));

				//
				// One TLB error
				//
				TlbCheck.Level = 2;
				ModInfo->Valid.CheckInfo = 1;
				ModInfo->CheckInfo.CheckInfo = TlbCheck.TlbCheck;

				//
				// 2 cache errors
				//
				CacheCheck.Level = 1;
				ModInfo->Valid.CheckInfo = 1;
				ModInfo->CheckInfo.CheckInfo = CacheCheck.CacheCheck;
				ModInfo++;

				CacheCheck.Level = 2;
				ModInfo->Valid.CheckInfo = 1;
				ModInfo->CheckInfo.CheckInfo = CacheCheck.CacheCheck;
				ModInfo++;

				//
				// 2 RegFile errors
				//
				ModInfo++;
				
				ModInfo++;
				
								
				break;
			}

			//
			// Fatal CPU Error: 1 TLB
			//
			case 1003:
			case 2003:
			case 3003:
			{
				PERROR_PROCESSOR s;
				ULONG TotalSize;
				PERROR_MODINFO ModInfo;
				ERROR_CACHE_CHECK CacheCheck;
				ERROR_TLB_CHECK TlbCheck;

				TotalSize = sizeof(ERROR_PROCESSOR) +
							 1 * sizeof(ERROR_MODINFO) +
							 sizeof(ERROR_PROCESSOR_CPUID_INFO) +
							 sizeof(ERROR_PROCESSOR_STATIC_INFO);

				sh->Length = TotalSize;
				sh->Guid = ErrorProcessorGuid;
						   
				s = (PERROR_PROCESSOR)sh;
				s->Valid.TlbCheckNum = 1;
				
				ModInfo = (PERROR_MODINFO)((PUCHAR)sh + sizeof(ERROR_PROCESSOR));

				//
				// One TLB error
				//
				TlbCheck.Level = 2;
				ModInfo->Valid.CheckInfo = 1;
				ModInfo->CheckInfo.CheckInfo = TlbCheck.TlbCheck;				
								
				break;
			}

			//
			// Unknown PCI Bus
			//
			case 1004:
			case 2004:
			case 3004:
			{
				PERROR_PCI_BUS s;
				ULONG TotalSize;

				TotalSize = sizeof(ERROR_PCI_BUS);

				sh->Length = TotalSize;
				sh->Guid = ErrorPciBusGuid;
						   
				s = (PERROR_PCI_BUS)sh;
				s->Type.Type = 99;
				s->Valid.CmdType = 1;
				s->Valid.Address = 1;
				s->Valid.Id = 1;

				s->ErrorStatus.Status = 22;
				s->Address = 0x12345678;
				s->Data = 0x22;
				s->CmdType = 0x33;
				s->RequestorId = 0x5432123;
				s->ResponderId = 0x22233344;
				s->TargetId = 0x55555555;
				s->Id.BusNumber = 1;
				s->Id.SegmentNumber = 1;
				
				break;
			}
			
			//
			// Unknown and Missing PCI Bus
			//
			case 1005:
			case 2005:
			case 3005:
			{
				PERROR_PCI_BUS s;
				ULONG TotalSize;

				TotalSize = sizeof(ERROR_PCI_BUS);

				sh->Length = TotalSize;
				sh->Guid = ErrorPciBusGuid;
						   
				s = (PERROR_PCI_BUS)sh;
				s->Type.Type = 99;
				s->Valid.CmdType = 1;
				s->Valid.Address = 0;
				s->Valid.Id = 1;

				s->ErrorStatus.Status = 22;
				s->Address = 0x12345678;
				s->Data = 0x22;
				s->CmdType = 0x33;
				s->RequestorId = 0x5432123;
				s->ResponderId = 0x22233344;
				s->TargetId = 0x55555555;
				s->Id.BusNumber = 1;
				s->Id.SegmentNumber = 1;
				
				break;
			}
			
			//
			// PCI Bus parity error
			//
			case 1006:
			case 2006:
			case 3006:
			{
				PERROR_PCI_BUS s;
				ULONG TotalSize;

				TotalSize = sizeof(ERROR_PCI_BUS);

				sh->Length = TotalSize;
				sh->Guid = ErrorPciBusGuid;
						   
				s = (PERROR_PCI_BUS)sh;
				s->Type.Type = PciBusDataParityError;
				s->Valid.CmdType = 1;
				s->Valid.Address = 1;
				s->Valid.Id = 1;

				s->ErrorStatus.Status = 22;
				s->Address = 0x12345678;
				s->Data = 0x22;
				s->CmdType = 0x33;
				s->RequestorId = 0x5432123;
				s->ResponderId = 0x22233344;
				s->TargetId = 0x55555555;
				s->Id.BusNumber = 1;
				s->Id.SegmentNumber = 1;
				
				break;
			}
			
			//
			// Fatal System Eventlog
			//
			case 1007:
			case 2007:
			case 3007:
			{
				PERROR_SYSTEM_EVENT_LOG s;

				sh->Length = sizeof(ERROR_SYSTEM_EVENT_LOG);
				sh->Guid = ErrorSystemEventLogGuid;
						   
				s = (PERROR_SYSTEM_EVENT_LOG)sh;
				
				s->Valid.Valid = 0;
				s->RecordId = 0x1234;       
				s->RecordType = 1;
				s->TimeStamp = 0x031100;
				s->GeneratorId = 1;
				s->EVMRevision = 48;
				s->SensorType = 2;
				s->SensorNumber = 7;
				s->EventDir = 2;
				s->Data1 = 1;
				s->Data2 = 2;
				s->Data3 = 3;
				
				break;
			}

			//
			// memory 1_2_5_4
			//
			case 1008:
			case 2008:
			case 3008:
			{
				PERROR_MEMORY Memory;

				sh->Length = sizeof(ERROR_MEMORY);
				sh->Guid = ErrorMemoryGuid;
						   
				Memory = (PERROR_MEMORY)sh;

				Memory->Valid.Valid = 0;
				Memory->Valid.PhysicalAddress = 1;
				Memory->Valid.AddressMask = 1;
				Memory->Valid.Module = 1;
				Memory->Valid.Card = 1;
				
				Memory->ErrorStatus.Status = 0;
				Memory->PhysicalAddress = 0x87654321;
				Memory->PhysicalAddressMask = 0x3fff;
				Memory->ResponderId = 2;
				Memory->TargetId = 3;
				Memory->RequestorId = 4;
				Memory->BusSpecificData = 5;
				Memory->Node = 6;
				Memory->Card = 7;
				Memory->Bank = 8;
				Memory->Device = 9;
				Memory->Module = 10;
				Memory->Row = 11;
				Memory->Column = 12;
				Memory->BitPosition = 13;				
				
				break;
			}

			
			//
			// memory 1_2_5
			//
			case 1009:
			case 2009:
			case 3009:
			{
				PERROR_MEMORY Memory;

				sh->Length = sizeof(ERROR_MEMORY);
				sh->Guid = ErrorMemoryGuid;
						   
				Memory = (PERROR_MEMORY)sh;

				Memory->Valid.Valid = 0;
				Memory->Valid.PhysicalAddress = 1;
				Memory->Valid.AddressMask = 1;
				Memory->Valid.Module = 1;
				
				Memory->ErrorStatus.Status = 0;
				Memory->PhysicalAddress = 0x87654321;
				Memory->PhysicalAddressMask = 0x3fff;
				Memory->ResponderId = 2;
				Memory->TargetId = 3;
				Memory->RequestorId = 4;
				Memory->BusSpecificData = 5;
				Memory->Node = 6;
				Memory->Card = 7;
				Memory->Bank = 8;
				Memory->Device = 9;
				Memory->Module = 10;
				Memory->Row = 11;
				Memory->Column = 12;
				Memory->BitPosition = 13;				
				
				break;
			}

			//
			// memory 1_2
			//
			case 1010:
			case 2010:
			case 3010:
			{
				PERROR_MEMORY Memory;

				sh->Length = sizeof(ERROR_MEMORY);
				sh->Guid = ErrorMemoryGuid;
						   
				Memory = (PERROR_MEMORY)sh;

				Memory->Valid.Valid = 0;
				Memory->Valid.PhysicalAddress = 1;
				Memory->Valid.AddressMask = 1;
				
				Memory->ErrorStatus.Status = 0;
				Memory->PhysicalAddress = 0x87654321;
				Memory->PhysicalAddressMask = 0x3fff;
				Memory->ResponderId = 2;
				Memory->TargetId = 3;
				Memory->RequestorId = 4;
				Memory->BusSpecificData = 5;
				Memory->Node = 6;
				Memory->Card = 7;
				Memory->Bank = 8;
				Memory->Device = 9;
				Memory->Module = 10;
				Memory->Row = 11;
				Memory->Column = 12;
				Memory->BitPosition = 13;				
				
				break;
			}

			
			//
			// memory 
			//
			case 1011:
			case 2011:
			case 3011:
			{
				PERROR_MEMORY Memory;

				sh->Length = sizeof(ERROR_MEMORY);
				sh->Guid = ErrorMemoryGuid;
						   
				Memory = (PERROR_MEMORY)sh;

				Memory->Valid.Valid = 0;
				Memory->Valid.PhysicalAddress = 1;
				
				Memory->ErrorStatus.Status = 0;
				Memory->PhysicalAddress = 0x87654321;
				Memory->PhysicalAddressMask = 0x3fff;
				Memory->ResponderId = 2;
				Memory->TargetId = 3;
				Memory->RequestorId = 4;
				Memory->BusSpecificData = 5;
				Memory->Node = 6;
				Memory->Card = 7;
				Memory->Bank = 8;
				Memory->Device = 9;
				Memory->Module = 10;
				Memory->Row = 11;
				Memory->Column = 12;
				Memory->BitPosition = 13;				
				
				break;
			}


			//
			// 2 sections
			//
			case 1012:
			case 2012:
			case 3012:
			{
				PERROR_SMBIOS s2;
				PERROR_PLATFORM_SPECIFIC s;
				ULONG TotalSize;

				TotalSize = sizeof(ERROR_SMBIOS) + sizeof(ERROR_PLATFORM_SPECIFIC);
				sh->Length = sizeof(ERROR_PLATFORM_SPECIFIC);
				sh->Guid = ErrorPlatformSpecificGuid;

				s = (PERROR_PLATFORM_SPECIFIC)sh;
				s->Valid.Valid = 0;

				sh = (PERROR_SECTION_HEADER)( (PUCHAR)sh + sizeof(ERROR_PLATFORM_SPECIFIC));
				sh->Revision.Revision = 0x0200;
				sh->Length = sizeof(ERROR_SMBIOS);
				sh->Guid = ErrorSmbiosGuid;
				if ((MethodId >= 2) && (MethodId <= 3))
				{
					sh->RecoveryInfo.Corrected = 1;
				}
				
				s2 = (PERROR_SMBIOS)sh;
				s2->Valid.Valid = 0;
				s2->Valid.EventType = 1;
				s2->EventType = 0xa0;
				
				sh = (PERROR_SECTION_HEADER)( (PUCHAR)sh + sizeof(ERROR_SMBIOS));
				sh->Length = TotalSize;
				break;
			}
			
			//
			// PCI COmponent
			//
			case 1013:
			case 2013:
			case 3013:
			{
				PERROR_PCI_COMPONENT s;

				sh->Length = sizeof(ERROR_PCI_COMPONENT);
				sh->Guid = ErrorPciComponentGuid;

				s = (PERROR_PCI_COMPONENT)sh;
				s->Valid.Valid = 0;
				break;
			}
			
			case 1014:
			case 2014:
			case 3014:
			{
				PERROR_SMBIOS s;

				sh->Length = 0x186a0;
				sh->Guid = ErrorSmbiosGuid;
						   
				s = (PERROR_SMBIOS)sh;
				s->Valid.Valid = 0;
				s->Valid.EventType = 1;
				s->EventType = 0xa0;
				
				break;
			}

			//
			// Invalid
			//
			case 1015:
			case 2015:
			case 3015:
			{
				memcpy(Buffer, InvalidError, sizeof(InvalidError));
				Size = sizeof(InvalidError);
				goto SkipSize;
			}
			
			
			default:
			{
				*((PULONG)Buffer) = Code;
				Size = sizeof(Code);
				MethodId = 1;
				break;
			}
		}				

        if ( MethodId != 1 )    {
		    rh->Length = sizeof(ERROR_RECORD_HEADER) + sh->Length;				
		    Size = rh->Length;
        }
		
SkipSize:
		ResultSize = sizeof(Result);

		if (Count == 0)
		{
			Count = 0xffffffff;
		}
		
		for (i = 0; i < Count; i++)
		{
			ResultSize = sizeof(Result);
			Status = WmiExecuteMethod(Handle,
							  "SMBiosData",
							  MethodId,
							  Size,
							  Buffer,
							  &ResultSize,
							  &Result);


			if (Status == ERROR_SUCCESS)
			{
				if (ResultSize == sizeof(Result))
				{
					printf("MCEGen returned NTSTATUS %x\n", Result);
				}
			} else {
				printf("WmiExecuteMethod(%d) failed %d\n", Code, Status);
			}
		}
								  
		CloseHandle(Handle);
	} else {
		printf("WmiOpenBlock failed %d\n", Status);
	}
	return(0);
}

#if 0
ULONG DumpMCE(
    void
    )
{
	HANDLE Handle;
	GUID Guid = { 0x23602a8a,0xdadd,0x462f, { 0x9a,0xe5,0x30,0xfa,0x2c,0x37,0xdd,0x5b } };
	ULONG Status;
	ULONG SizeNeeded;

	Status = WmiOpenBlock(&Guid,
						  0,
						  &Handle);
	
	if (Status == ERROR_SUCCESS)
	{
		SizeNeeded = 0;
		Status = WmiQueryAllData(Handle,
								 &SizeNeeded,
								 NULL);
		if (Status == ERROR_BUFFER_TOO_SMALL)
		{
			Buffer = malloc(SizeNeeded);
			if (Buffer != NULL)
			{
				Status = WmiQueryAllData(Handle,
										 &SizeNeeded,
										 Buffer);
				if (Status == ERROR_SUCCESS)
				{
					Wnode = (PWNODE_ALL_DATA)Buffer;
					MCAData = (PMSMCAInfo_RawMCAData)OffsetToPtr(Wnode,
						                                         Wnode->
				}
			}
		}
	}
}
#endif

void Usage()
{
	printf("MCEGen <code> [<count> <threads>]\n\n");
	printf("    Generates a MCE exception. <code> specifies the type\n");
	printf("    of exception to generate\n\n");
	printf("        456   -   Hal generates a fatal MCA (Checked build required)\n");
	printf("        490   -   Hal generates a L1 1-bit ECC CMC (Checked build required)\n");
	printf("       1001/2001/3001 - Fatal/Corrected CMC/CPE SMBIOS MCE\n");
	printf("       1002/2002/3002 - Fatal/Corrected CMC/CPE Cache Level 1 MCE\n");
	printf("       1003/2003/3003 - Fatal/Corrected CMC/CPE TLB level 2 MCE\n");
	printf("       1004/2004/3004 - Fatal/Corrected CMC/CPE Unknown PCI Bus\n");
	printf("       1005/2005/3005 - Fatal/Corrected CMC/CPE Unknown PCI Bus\n");
	printf("       1006/2006/3006 - Fatal/Corrected CMC/CPE PCI Bus Parity Error\n");
	printf("       1007/2007/3007 - Fatal/Corrected CMC/CPE System Eventlog\n");
	printf("       1008/2008/3008 - Fatal/Corrected CMC/CPE Memory\n");
	printf("       1009/2009/3009 - Fatal/Corrected CMC/CPE Memory\n");
	printf("       1010/2010/3010 - Fatal/Corrected CMC/CPE Memory\n");
	printf("       1011/2011/3011 - Fatal/Corrected CMC/CPE Memory\n");
	printf("       1012/2012/3012 - Fatal/Corrected CMC/CPE SMBIOS and Platform Specific\n");
	printf("       1013/2013/3013 - Fatal/Corrected CMC/CPE PCI Component\n");
	printf("       1014/2014/3014 - Fatal/Corrected CMC/CPE SMBIOS (100KB in size)\n");
	printf("       1015/2015/3015 - Fatal/Corrected Invalid\n");
	
}

int _cdecl main(int argc, char *argv[])
{
	ULONG Status;
	ULONG Code, Threads, Count;
	HANDLE h;
	ULONG i;
	DWORD Id;
	
	if (argc < 2)
	{
		Usage();
	} else {
		Code = atoi(argv[1]);
		if (argc == 2) {
			THREADCONTROL ThreadControl;
			
			//
			// parameter is code number to generate MCE
			//
			ThreadControl.Count = 1;
			ThreadControl.Code = Code;
			GenerateMCE(&ThreadControl);
		} else {
			PHANDLE Events;
			
			if (argc >= 4)
			{
				//
				// specified multiple generation threads
				//
				Threads = atoi(argv[3]);			
			} else {
				Threads = 1;
			}
			
			//
			// Get number of MCE to generate
			//
			Count = atoi(argv[2]);

			Events = malloc(Threads * sizeof(HANDLE));
			for (i = 0; i < Threads; i++)
			{
				PTHREADCONTROL  ThreadControl;

				ThreadControl = malloc(sizeof(THREADCONTROL));
				ThreadControl->Count = Count;
				ThreadControl->Code = Code;
				Events[i] = CreateThread(NULL,
							 0,
							 GenerateMCE,
							 ThreadControl,
							 0,
							 &Id);
				if (Events[i] == NULL)
				{
					printf("CreateThread failed %d\n", GetLastError());					
				}
			}
			
			printf("Waiting for threads to complete\n");
			
			WaitForMultipleObjects(Threads, Events, TRUE, INFINITE);
		}
	}

	
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\perfhit\perfhit.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    perfhit.c

Abstract:

    test app

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#define INITGUID
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <stdlib.h>

#include <ntdddisk.h>
#include <ntddstor.h>

#include "wmium.h"

#define OffsetToPtr(Base, Offset) ((PBYTE)((PBYTE)Base + Offset))


ULONG InstanceCount;
PCHAR *InstanceNames;

ULONG SmartDisabled;

GUID SmartStatusGuid = WMI_DISK_FAILURE_PREDICT_STATUS_GUID;
GUID SmartDataGuid = WMI_DISK_FAILURE_PREDICT_DATA_GUID;
GUID SmartPerformFunction = WMI_DISK_FAILURE_PREDICT_FUNCTION_GUID;

// void AllowPerformanceHit([in] boolean Allow)
    #define AllowDisallowPerformanceHit                 1
		
// void EnableDisableHardwareFailurePrediction([in] boolean Enable)		
    #define EnableDisableHardwareFailurePrediction      2
		
// void EnableDisableFailurePredictionPolling(
//                               [in] uint32 Period,
//                               [in] boolean Enable)
    #define EnableDisableFailurePredictionPolling       3
		
// void GetFailurePredictionCapability([out] uint32 Capability)		
    #define GetFailurePredictionCapability              4
		
// void EnableOfflineDiags([out] boolean Success);		
    #define EnableOfflineDiags                          5
		
GUID SmartEventGuid = STORAGE_PREDICT_FAILURE_EVENT_GUID;

DEFINE_GUID(WmiScsiAddressGuid,
            0x53f5630f,
            0xb6bf,
            0x11d0,
            0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);

typedef ULONG (*THREADFUNC)(
    PVOID FirstTestNumber,
    PVOID LastTestNumber
    );


typedef struct
{
    THREADFUNC ThreadFunc;
    PVOID FirstTestNumber;
    PVOID LastTestNumber;
} LAUNCHCTX, *PLAUNCHCTX;

ULONG LaunchThreadProc(PVOID Context)
{
    PLAUNCHCTX LaunchCtx = (PLAUNCHCTX)Context;
    
    (*LaunchCtx->ThreadFunc)(LaunchCtx->FirstTestNumber, 
                             LaunchCtx->LastTestNumber);
		     
    return(0);
}

void LaunchThread(
    THREADFUNC ThreadFunc,
    PVOID FirstTestNumber,
    PVOID LastTestNumber
    )
{
    PLAUNCHCTX LaunchCtx;
    HANDLE ThreadHandle;
    
    LaunchCtx = (PLAUNCHCTX)malloc(sizeof(LAUNCHCTX));
    
    if (LaunchCtx != NULL)
    {
        LaunchCtx->ThreadFunc = ThreadFunc;
    	LaunchCtx->FirstTestNumber = FirstTestNumber;
	    LaunchCtx->LastTestNumber = LastTestNumber;
	
        ThreadHandle = CreateThread(NULL,
                                    0,
                                    LaunchThreadProc,
                                    LaunchCtx,
                                    0,
                                    NULL);
        if (ThreadHandle != NULL)
        {
            CloseHandle(ThreadHandle);
        }
    }
}

ULONG DetermineInstanceNames(
    LPGUID Guid,
    PULONG InstanceCount,
    PCHAR **InstanceNamePtrArray
	)
{
	WMIHANDLE Handle;
	ULONG status;
	ULONG bufferSize;
	PUCHAR buffer;
	ULONG i, iCount, linkage;
	PWNODE_ALL_DATA WAD;
	PCHAR *iNames;	
	PULONG pInstanceNameOffsets;
	PCHAR pName;
	PUSHORT pNameSize;
	
	status = WmiOpenBlock(Guid,
                          GENERIC_READ,
                          &Handle);
					  
    if (status != ERROR_SUCCESS)
	{
		printf("WmiOpenBlock(Statyus) => %d\n", status);
		return(status);
	}

	bufferSize = 0x1000;
	buffer = NULL;
	status = ERROR_INSUFFICIENT_BUFFER;
	
	while (status == ERROR_INSUFFICIENT_BUFFER)
	{
		if (buffer != NULL)
		{
			free(buffer);
		}
		
    	buffer = malloc(bufferSize);
		if (buffer == NULL)
		{
			status = ERROR_NOT_ENOUGH_MEMORY;
			break;
		}
		
		status = WmiQueryAllData(Handle,
                                 &bufferSize,
                                 buffer);
	}
	
	if (status == ERROR_SUCCESS)
	{
		WAD = (PWNODE_ALL_DATA)buffer;
		linkage = 0;				
		iCount = 0;
		do
		{
			WAD = (PWNODE_ALL_DATA)OffsetToPtr(WAD, linkage);
			linkage = WAD->WnodeHeader.Linkage;
			iCount++;

		} while (linkage != 0);

		
        iNames = malloc(iCount * sizeof(PCHAR));
		if (iNames == NULL)
		{
			status = ERROR_NOT_ENOUGH_MEMORY;
			return(status);
		}
		
		WAD = (PWNODE_ALL_DATA)buffer;
		linkage = 0;				
		i = 0;
		do
		{
			WAD = (PWNODE_ALL_DATA)OffsetToPtr(WAD, linkage);
			
			pInstanceNameOffsets = (PULONG)OffsetToPtr(WAD, WAD->OffsetInstanceNameOffsets);
			pNameSize = (PUSHORT)OffsetToPtr(WAD, *pInstanceNameOffsets);
			pName = (PCHAR)OffsetToPtr(pNameSize, sizeof(USHORT));
			
			iNames[i] = malloc(*pNameSize + 1);
			if (iNames[i] == NULL)
			{
				status = ERROR_NOT_ENOUGH_MEMORY;
				return(status);
			}
			memset(iNames[i], 0, *pNameSize + 1);
			memcpy(iNames[i], pName, *pNameSize);
			
			linkage = WAD->WnodeHeader.Linkage;
			i++;

		} while (linkage != 0);
		
	} else {
		printf("QAD(status) -> %d\n", status);
	}
	
	free(buffer);
	
	*InstanceCount = iCount;
	*InstanceNamePtrArray = iNames;
	
	return(ERROR_SUCCESS);
}
void Usage(void)
{
	printf("perfhit [perf | poll | hardware | offdiag] <enable> <period>\n");
}

typedef struct
{
	ULONG Period;
	BOOLEAN Enable;
} POLLONOFF, *PPOLLONOFF;


CHAR *FPMethod[] = 
{
	"FailurePredictionNone",
	"FailurePredictionIoctl",
	"FailurePredictionSmart",
	"FailurePredictionSense",
    "FailurePredictionUnknown"
};

int _cdecl main(int argc, char *argv[])
{
	ULONG status;
	ULONG i;
	WMIHANDLE Handle;
    ULONG len, j;
	BOOLEAN enable;
	ULONG inSize;
	PVOID inPtr;
	ULONG outSize;
	PVOID outPtr;
	POLLONOFF PollOnOff;
	ULONG operation;
	ULONG period;
	int argNeed;
	
	status = DetermineInstanceNames(&SmartStatusGuid,
		                            &InstanceCount,
                                    &InstanceNames);
								
    if (status != ERROR_SUCCESS)
	{
		printf("DetermineInstanceNames failed %d\n", status);
		return(status);
	}

	
	operation = 0;
	if (argc >= 2)
	{
		
		argNeed = 3;
		if (_stricmp(argv[1], "perf") == 0)
		{
			operation = AllowDisallowPerformanceHit;			
		}

		if (_stricmp(argv[1], "poll") == 0)
		{
            argNeed = 4;
			operation = EnableDisableFailurePredictionPolling;
		}
		
		if (_stricmp(argv[1], "hardware") == 0)
		{
			operation = EnableDisableHardwareFailurePrediction;
		}
		
		if (_stricmp(argv[1], "offdiag") == 0)
		{
			operation = EnableOfflineDiags;
			argNeed = 2;
		}		
	}
	
	if ((operation == 0) ||
        (argNeed != argc))
	{
		Usage();
		return(0);
	}
	
	period = 0;
	enable = FALSE;
	
	if (argNeed >= 3)
	{
    	enable = atoi(argv[2]);
	}
	
	if (argNeed == 4)
	{
		period = atoi(argv[3]);
	}
			
	printf("Operation %d(%d, %d)\n", operation, enable, period);
	
	outPtr = NULL;
	outSize = 0;
    if (operation == EnableDisableFailurePredictionPolling)
	{
		inSize = sizeof(POLLONOFF);
		inPtr = &PollOnOff;
		PollOnOff.Enable = enable;
		PollOnOff.Period = period;
	} else {
		inSize = sizeof(BOOLEAN);
		inPtr = &enable;
	}
	
	if (operation == EnableOfflineDiags)
	{
		inSize = 0;
		inPtr = &enable;
		outSize = sizeof(BOOLEAN);
		outPtr = &enable;
	}
						  
 	status = WmiOpenBlock((LPGUID)&SmartPerformFunction,
                              GENERIC_EXECUTE,
                              &Handle);
						  
    if (status != ERROR_SUCCESS)
	{
		printf("Open(function guid) -> %d\n", status);
		return(status);
	}
					  	
						  
	for (i = 0; i < InstanceCount; i++)
	{
		len = sizeof(ULONG);
   		status = WmiExecuteMethod(Handle,
                                  InstanceNames[i],
                                  GetFailurePredictionCapability,
                                  0,
                                  NULL,
                                  &len,
                                  &j);
							  
        if (status != ERROR_SUCCESS)
		{
			j = 4;
		}
		
		printf("Instance %d -> %s supports %s \n", i, InstanceNames[i], FPMethod[j]);
		
   		status = WmiExecuteMethod(Handle,
                                  InstanceNames[i],
                                  operation,
                                  inSize,
                                  inPtr,
                                  &outSize,
                                  outPtr);
							  
        if (status != STATUS_SUCCESS)							  
		{
			printf("perfhit %d failed\n", enable);
		}
		
	}
	
	WmiCloseBlock(Handle);
	
    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\umtrprov\constantmap.h ===
// ConstantMap.h: interface for the CConstantMap class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CONSTANTMAP_H__C5372480_EDF1_11D2_804A_009027345EE2__INCLUDED_)
#define AFX_CONSTANTMAP_H__C5372480_EDF1_11D2_804A_009027345EE2__INCLUDED_

#define UNICODE
#define _UNICODE

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

typedef pair<t_string, unsigned int> MAPPAIR;
typedef map<t_string, unsigned int> CONSTMAP;


class CConstantMap  
{
public:
	CConstantMap();
	virtual ~CConstantMap();
	CONSTMAP m_Map;
};

#endif // !defined(AFX_CONSTANTMAP_H__C5372480_EDF1_11D2_804A_009027345EE2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\umtrprov\constantmap.cpp ===
// ConstantMap.cpp: implementation of the CConstantMap class.
//
//////////////////////////////////////////////////////////////////////


#include "stdafx.h"

#pragma warning (disable : 4786)
#pragma warning (disable : 4275)

#include <iostream>
#include <fstream>
#include <string>
#include <map>
#include <list>


using namespace std;



#include <tchar.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>


#include <WTYPES.H>
#include "t_string.h"
#include "ConstantMap.h"
#include "Utilities.h"
#include "Persistor.h"
#include "StructureWrappers.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
   
CConstantMap::CConstantMap()
{
	MAPPAIR pair;

	pair.first = _T("EVENT_TRACE_TYPE_INFO");
	pair.second = EVENT_TRACE_TYPE_INFO;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_START");
	pair.second = EVENT_TRACE_TYPE_START;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_END");
	pair.second = EVENT_TRACE_TYPE_END;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_DC_START");
	pair.second = EVENT_TRACE_TYPE_DC_START;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_DC_END");
	pair.second = EVENT_TRACE_TYPE_DC_END;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_EXTENSION");
	pair.second = EVENT_TRACE_TYPE_EXTENSION;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_REPLY");
	pair.second = EVENT_TRACE_TYPE_REPLY;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_RESERVED7");
	pair.second = EVENT_TRACE_TYPE_RESERVED7;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_RESERVED8");
	pair.second = EVENT_TRACE_TYPE_RESERVED8;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_RESERVED9");
	pair.second = EVENT_TRACE_TYPE_RESERVED9;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_LOAD");
	pair.second = EVENT_TRACE_TYPE_LOAD;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_IO_READ");
	pair.second = EVENT_TRACE_TYPE_IO_READ;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_IO_WRITE");
	pair.second = EVENT_TRACE_TYPE_IO_WRITE;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_MM_TF");
	pair.second = EVENT_TRACE_TYPE_MM_TF;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_MM_DZF");
	pair.second = EVENT_TRACE_TYPE_MM_DZF;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_MM_COW");
	pair.second = EVENT_TRACE_TYPE_MM_COW;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_MM_GPF");
	pair.second = EVENT_TRACE_TYPE_MM_GPF;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_MM_HPF");
	pair.second = EVENT_TRACE_TYPE_MM_HPF;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_SEND");
	pair.second = EVENT_TRACE_TYPE_SEND;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_MM_HPF");
	pair.second = EVENT_TRACE_TYPE_MM_HPF;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_RECEIVE");
	pair.second = EVENT_TRACE_TYPE_RECEIVE;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_CONNECT");
	pair.second = EVENT_TRACE_TYPE_CONNECT;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_DISCONNECT");
	pair.second = EVENT_TRACE_TYPE_DISCONNECT;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_GUIDMAP");
	pair.second = EVENT_TRACE_TYPE_GUIDMAP;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_CONFIG");
	pair.second = EVENT_TRACE_TYPE_CONFIG;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_SIDINFO");
	pair.second = EVENT_TRACE_TYPE_SIDINFO;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_PROCESS");
	pair.second = EVENT_TRACE_FLAG_PROCESS;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_THREAD");
	pair.second = EVENT_TRACE_FLAG_THREAD;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_IMAGE_LOAD");
	pair.second = EVENT_TRACE_FLAG_IMAGE_LOAD;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_DISK_IO");
	pair.second = EVENT_TRACE_FLAG_DISK_IO;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_DISK_FILE_IO");
	pair.second = EVENT_TRACE_FLAG_DISK_FILE_IO;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS");
	pair.second = EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS");
	pair.second = EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_NETWORK_TCPIP");
	pair.second = EVENT_TRACE_FLAG_NETWORK_TCPIP;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_EXTENSION");
	pair.second = EVENT_TRACE_FLAG_EXTENSION;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_FORWARD_WMI");
	pair.second = EVENT_TRACE_FLAG_FORWARD_WMI;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FILE_MODE_NONE");
	pair.second = EVENT_TRACE_FILE_MODE_NONE;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FILE_MODE_SEQUENTIAL");
	pair.second = EVENT_TRACE_FILE_MODE_SEQUENTIAL;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FILE_MODE_CIRCULAR");
	pair.second = EVENT_TRACE_FILE_MODE_CIRCULAR;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FILE_MODE_NEWFILE");
	pair.second = EVENT_TRACE_FILE_MODE_NEWFILE;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_PRIVATE_LOGGER_MODE");
	pair.second = EVENT_TRACE_PRIVATE_LOGGER_MODE;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_REAL_TIME_MODE");
	pair.second = EVENT_TRACE_REAL_TIME_MODE;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_DELAY_OPEN_FILE_MODE");
	pair.second = EVENT_TRACE_DELAY_OPEN_FILE_MODE;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_BUFFERING_MODE");
	pair.second = EVENT_TRACE_BUFFERING_MODE;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_CONTROL_QUERY");
	pair.second = EVENT_TRACE_CONTROL_QUERY;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_CONTROL_STOP");
	pair.second = EVENT_TRACE_CONTROL_STOP;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_CONTROL_UPDATE");
	pair.second = EVENT_TRACE_CONTROL_UPDATE;
	m_Map.insert(pair);

	pair.first = _T("WNODE_FLAG_TRACED_GUID");
	pair.second = WNODE_FLAG_TRACED_GUID;
	m_Map.insert(pair);

	pair.first = _T("ERROR_SUCCESS");
	pair.second = ERROR_SUCCESS;
	m_Map.insert(pair);

	pair.first = _T("ERROR_INVALID_PARAMETER");
	pair.second = ERROR_INVALID_PARAMETER;
	m_Map.insert(pair);

	pair.first = _T("ERROR_INVALID_NAME");
	pair.second = ERROR_INVALID_NAME;
	m_Map.insert(pair);

	pair.first = _T("ERROR_BAD_LENGTH");
	pair.second = ERROR_BAD_LENGTH;
	m_Map.insert(pair);


	pair.first = _T("VALUE_NULL");
	pair.second = NULL;
	m_Map.insert(pair);

	pair.first = _T("VALUE_MAX_MEMORY");
	pair.second = 0;
	m_Map.insert(pair);

	pair.first = _T("VALUE_ZERO");
	pair.second = 0;
	m_Map.insert(pair);

}

CConstantMap::~CConstantMap()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\rcvevent\rcvevent.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <stdlib.h>

#include "wmium.h"

#define OffsetToPtr(Base, Offset) ((PBYTE)((PBYTE)Base + Offset))
//
// The routines below were blantenly stolen without remorse from the ole
// sources in \nt\private\ole32\com\class\compapi.cxx. They are copied here
// so that WMI doesn't need to load in ole32 only to convert a guid string
// into its binary representation.
//


//+-------------------------------------------------------------------------
//
//  Function:   HexStringToDword   (private)
//
//  Synopsis:   scan lpsz for a number of hex digits (at most 8); update lpsz
//              return value in Value; check for chDelim;
//
//  Arguments:  [lpsz]    - the hex string to convert
//              [Value]   - the returned value
//              [cDigits] - count of digits
//
//  Returns:    TRUE for success
//
//--------------------------------------------------------------------------
BOOL HexStringToDword(LPCSTR lpsz, DWORD * RetValue,
                             int cDigits, WCHAR chDelim)
{
    int Count;
    DWORD Value;

    Value = 0;
    for (Count = 0; Count < cDigits; Count++, lpsz++)
    {
        if (*lpsz >= '0' && *lpsz <= '9')
            Value = (Value << 4) + *lpsz - '0';
        else if (*lpsz >= 'A' && *lpsz <= 'F')
            Value = (Value << 4) + *lpsz - 'A' + 10;
        else if (*lpsz >= 'a' && *lpsz <= 'f')
            Value = (Value << 4) + *lpsz - 'a' + 10;
        else
            return(FALSE);
    }

    *RetValue = Value;
    
    if (chDelim != 0)
        return *lpsz++ == chDelim;
    else
        return TRUE;
}
//+-------------------------------------------------------------------------
//
//  Function:   wUUIDFromString    (internal)
//
//  Synopsis:   Parse UUID such as 00000000-0000-0000-0000-000000000000
//
//  Arguments:  [lpsz]  - Supplies the UUID string to convert
//              [pguid] - Returns the GUID.
//
//  Returns:    TRUE if successful
//
//--------------------------------------------------------------------------
BOOL wUUIDFromString(LPCSTR lpsz, LPGUID pguid)
{
        DWORD dw;

        if (!HexStringToDword(lpsz, &pguid->Data1, sizeof(DWORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(DWORD)*2 + 1;
        
        if (!HexStringToDword(lpsz, &dw, sizeof(WORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(WORD)*2 + 1;

        pguid->Data2 = (WORD)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(WORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(WORD)*2 + 1;

        pguid->Data3 = (WORD)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[0] = (BYTE)dw;
        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, '-'))
                return FALSE;
        lpsz += sizeof(BYTE)*2+1;

        pguid->Data4[1] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[2] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[3] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[4] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[5] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[6] = (BYTE)dw;
        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[7] = (BYTE)dw;

        return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   wGUIDFromString    (internal)
//
//  Synopsis:   Parse GUID such as {00000000-0000-0000-0000-000000000000}
//
//  Arguments:  [lpsz]  - the guid string to convert
//              [pguid] - guid to return
//
//  Returns:    TRUE if successful
//
//--------------------------------------------------------------------------
BOOL wGUIDFromString(LPCSTR lpsz, LPGUID pguid)
{
    DWORD dw;

    if (*lpsz == '{' )
        lpsz++;

    if(wUUIDFromString(lpsz, pguid) != TRUE)
        return FALSE;

    lpsz +=36;

    if (*lpsz == '}' )
        lpsz++;

    if (*lpsz != '\0')   // check for zero terminated string - test bug #18307
    {
       return FALSE;
    }

    return TRUE;
}


PTCHAR GuidToString(
    PTCHAR s,
    LPGUID piid
    )
{
    wsprintf(s, TEXT("%x-%x-%x-%x%x%x%x%x%x%x%x"),
               piid->Data1, piid->Data2, 
               piid->Data3,
               piid->Data4[0], piid->Data4[1],
               piid->Data4[2], piid->Data4[3],
               piid->Data4[4], piid->Data4[5],
               piid->Data4[6], piid->Data4[7]);

    return(s);
}

#if 0
void WackOnFile(void)
{
    ULONG Status;
    HANDLE FH;
    
    
        FH = CreateFile("e:\\foo.baz",
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
        
        if (FH != INVALID_HANDLE_VALUE)
    {
            Status = ERROR_SUCCESS;
        CloseHandle(FH);
    } else {
            Status = GetLastError();
    }
    
    printf("CreateFile --> %d\n", Status);
        
}

void CheckOwnPriv(
    void
	)
{
    UCHAR Buffer[4096];
    HANDLE TokenHandle;
    ULONG SizeNeeded;
    BOOL b;
    ULONG i;
    PTOKEN_PRIVILEGES TokenPrivInfo;

	if (! ImpersonateSelf(SecurityImpersonation))
	{
		printf("Impersonatself -> %d\n", GetLastError());
		return;
	}
	
    b = OpenThreadToken(GetCurrentThread(),
                    TOKEN_QUERY,
                    TRUE,
                &TokenHandle);
        
    if (! b)
    {
        printf("OpenThreadToken failed %d\n", GetLastError());
        return;
    }
    
    printf("OpenThreadToken succeeded\n");
    
    TokenPrivInfo = (PTOKEN_PRIVILEGES)Buffer;
    b = GetTokenInformation(TokenHandle,
                            TokenPrivileges,
                            TokenPrivInfo,
                            sizeof(Buffer),
                            &SizeNeeded);
    printf("GetTokenInformation(YokenPriv) -> %s (%d), sizeNeeded = %d\n", 
        b ? "TRUE" : "FALSE", GetLastError(),
            SizeNeeded);
		
    RevertToSelf();
    if (b)
    {
        printf("Priv count is %d\n", TokenPrivInfo->PrivilegeCount);
    	for (i = 0; i < TokenPrivInfo->PrivilegeCount; i++)
		{
			UCHAR PrivName[1024];
			ULONG SizePrivName = sizeof(PrivName);
			
			if ( ! LookupPrivilegeName(NULL, 
                                       &TokenPrivInfo->Privileges[i].Luid,
                                       PrivName,
                                       &SizePrivName))
            {
		        sprintf(PrivName, "[Error %d]", GetLastError());
			}
                                              
            printf("Priv %s %x%x has attr %x\n",
                   PrivName,
				   TokenPrivInfo->Privileges[i].Luid.HighPart,
				   TokenPrivInfo->Privileges[i].Luid.LowPart,
				   TokenPrivInfo->Privileges[i].Attributes);
		}
		printf("\n");
    }
}

PCHAR SidUsage[] = 
{
    "SidTypeZero",
    "SidTypeUser",
    "SidTypeGroup",
    "SidTypeDomain",
    "SidTypeAlias",
    "SidTypeWellKnownGroup",
    "SidTypeDeletedAccount",
    "SidTypeInvalid",
    "SidTypeUnknown",
    "SidTypeComputer",
};

void GetCallerInfo(BOOLEAN Impersonating)
{
    UCHAR Buffer[4096];
    PTOKEN_USER TokenUserInfo = (PTOKEN_USER)Buffer;
    PSID_AND_ATTRIBUTES SidAndAttributes = &TokenUserInfo->User;
    PSID Sid;
    HANDLE TokenHandle;
    ULONG SizeNeeded;
    BOOLEAN b;
    CHAR Name[MAX_PATH];
    CHAR Domain[MAX_PATH];
    ULONG NameSize = sizeof(Name);
    ULONG DomainSize = sizeof(Domain);
    SID_NAME_USE SidNameUse;
    ULONG i;
  
    PUCHAR SidBuffer;
    SID_IDENTIFIER_AUTHORITY    NtAuthority         = SECURITY_NT_AUTHORITY;
    PTOKEN_PRIVILEGES TokenPrivInfo;
    
    SidBuffer = malloc(RtlLengthRequiredSid( 1 ));
    RtlInitializeSid( SidBuffer, &NtAuthority, 1);
    *(RtlSubAuthoritySid( SidBuffer, 0 )) = SECURITY_LOCAL_SYSTEM_RID;
    
    b = OpenThreadToken(GetCurrentThread(),
                    TOKEN_QUERY,
                    TRUE,
                &TokenHandle);
        
    if (! b)
    {
        printf("OpenThreadToken failed %d\n", GetLastError());
        return;
    }
    
    printf("OpenThreadToken succeeded\n");
    
    TokenPrivInfo = (PTOKEN_PRIVILEGES)Buffer;
    b = GetTokenInformation(TokenHandle,
                            TokenPrivileges,
                            TokenPrivInfo,
                            sizeof(Buffer),
                            &SizeNeeded);
    printf("GetTokenInformation(YokenPriv) -> %s (%d), sizeNeeded = %d\n", 
        b ? "TRUE" : "FALSE", GetLastError(),
            SizeNeeded);
    if (b)
    {
		RpcRevertToSelf();
        printf("Priv count is %d\n", TokenPrivInfo->PrivilegeCount);
    	for (i = 0; i < TokenPrivInfo->PrivilegeCount; i++)
		{
			UCHAR PrivName[1024];
			ULONG SizePrivName = sizeof(PrivName);
			
			if ( ! LookupPrivilegeName(NULL, 
                                       &TokenPrivInfo->Privileges[i].Luid,
                                       PrivName,
                                       &SizePrivName))
            {
		        sprintf(PrivName, "[Error %d]", GetLastError());
			}
                                              
            printf("Priv %s %x%x has attr %x\n",
                   PrivName,
				   TokenPrivInfo->Privileges[i].Luid.HighPart,
				   TokenPrivInfo->Privileges[i].Luid.LowPart,
				   TokenPrivInfo->Privileges[i].Attributes);
		}
		printf("\n");
        RpcImpersonateClient(0);
    }
    
    
        
    b = GetTokenInformation(TokenHandle,
                            TokenUser,
                            TokenUserInfo,
                            sizeof(Buffer),
                            &SizeNeeded);
    printf("GetTokenInformation -> %s (%d), sizeNeeded = %d\n", 
        b ? "TRUE" : "FALSE", GetLastError(),
            SizeNeeded);
    if (b)
    {
        if (Impersonating)
        {
            RpcRevertToSelf();
        }
        Sid = SidAndAttributes->Sid;

        if (EqualSid(Sid, (PSID)SidBuffer) && GetLastError() == ERROR_SUCCESS)
    {
            printf("Called by LocalSystem !!\n");
    } else {
            printf("EqualSid %d\n", GetLastError());
    }

        b = LookupAccountSid(NULL,
                             Sid,
                             Name,
                             &NameSize,
                             Domain,
                             &DomainSize,
                             &SidNameUse);
    
        if (Impersonating)
    {
        RpcImpersonateClient(0);
    }
        if (b)
    {
            printf("Account: %s\\%s Type %s\n", Domain, Name, SidUsage[SidNameUse]);
    } else {
            printf("LookupAccountSid %d\n", GetLastError());
    }
    }
    CloseHandle(TokenHandle);
}
#endif

void EventCallbackRoutine(PWNODE_HEADER WnodeHeader, ULONG Context);

#define DATA_PROVIDER_PNPID_GUID \
    { 0xc7bf35d2,0xaadb,0x11d1, { 0xbf,0x4a,0x00,0xa0,0xc9,0x06,0x29,0x10 } }
GUID GuidXYZ = DATA_PROVIDER_PNPID_GUID;

ULONG EventsReceived;

void EventCallbackRoutine(PWNODE_HEADER WnodeHeader, ULONG Context)
{
    PWNODE_SINGLE_INSTANCE WnodeSI = (PWNODE_SINGLE_INSTANCE)WnodeHeader;
    PWNODE_HEADER Wnode = WnodeHeader;
    LPGUID EventGuid = &WnodeHeader->Guid;        
    CHAR s[MAX_PATH];
    ULONG Status;
    WMIHANDLE Handle;
#if 0
    GetCallerInfo(FALSE);
      
    RevertToSelf();
    
    GetCallerInfo(FALSE);
    WackOnFile();    

    Status = RpcImpersonateClient(0);
    printf("RpcImpersonateClient -> %d\n", Status);
    if (Status == ERROR_SUCCESS)
    {
        WmiOpenBlock(&GuidXYZ, GENERIC_READ, &Handle);
        GetCallerInfo(TRUE);
        WackOnFile();
        RpcRevertToSelf();
    }
#endif    
    EventsReceived++;

    printf("Receieved event for guid %s\n", GuidToString(s, EventGuid));
    
    printf("BufferSize = 0x%x\n", Wnode->BufferSize);
    printf("ProviderId = %x\n", Wnode->ProviderId);    // Provider Id of driver returning this buffer
    printf("Version = %x\n", Wnode->Version);           // Reserved
    printf("Linkage = %x\n", Wnode->Linkage);           // Linkage field reserved for WMI
    printf("ClientContext = %x\n", Wnode->ClientContext);
    printf("Flags = %x\n", Wnode->Flags);             // Flags, see below
    
    if (Wnode->Flags & WNODE_FLAG_SINGLE_INSTANCE)
    {
        printf("WNODE_SINGLE_INSTANCE\n");
    printf("OffsetInstanceName = %x\n", WnodeSI->OffsetInstanceName);
    printf("InstanceIndex = %x\n", WnodeSI->InstanceIndex);    // (Static Instance Names)

    printf("DataBlockOffset = %x\n", WnodeSI->DataBlockOffset);  // offset from beginning of WNODE to data block
    printf("SizeDataBlock = %x\n", WnodeSI->SizeDataBlock);    // Size of data block for instance


    }

	printf("\n%d events received\n", EventsReceived);
}

#if 0
#define WmiRpcProtocolSequence1 TEXT("ncacn_np")
#define WmiRpcProtocolSequence2 TEXT("ncalrpc")
#define MaxRpcCalls RPC_C_PROTSEQ_MAX_REQS_DEFAULT

void
CreateEndpoints(void)
{
    ULONG i;
    ULONG Status;
    CHAR UniqueEndpoint[MAX_PATH];
    SECURITY_DESCRIPTOR SD;
    
    InitializeSecurityDescriptor(&SD, SECURITY_DESCRIPTOR_REVISION);
    SetSecurityDescriptorDacl(&SD, TRUE, NULL, FALSE);
    
    for (i = 0; i < 20; i++)
    {
        sprintf(UniqueEndpoint, "TESTLRPCEP_%x", i);

        Status = RpcServerUseProtseqEp(WmiRpcProtocolSequence2,
                                               MaxRpcCalls,
                                               UniqueEndpoint,
                                               &SD);  // Security descriptor
                               
        if (Status != ERROR_SUCCESS)
    {
        printf("RpcServerUseProtseqEp failed %d\n", Status);
    }
    
    }

    for (i = 0; i < 20; i++)
    {
        sprintf(UniqueEndpoint, "\\pipe\\TESTEP_%x", i);

        Status = RpcServerUseProtseqEp(WmiRpcProtocolSequence1,
                                               MaxRpcCalls,
                                               UniqueEndpoint,
                                               &SD);  // Security descriptor
                               
        if (Status != ERROR_SUCCESS)
    {
        printf("RpcServerUseProtseqEp failed %d\n", Status);
    }
    
    }
}
#endif

PWNODE_HEADER EventPtrBuffer;
int _cdecl main(int argc, char *argv[])
{
    ULONG Status;
    GUID Guid;
    ULONG c,i;

#if 0
    c = 1;
    for (i = 0; i < 101; i++)
    {
        c += i;
    }
    printf("c = %d\n",c);
#endif	
    
    if ((argc != 2) && (argc != 3))
    {
        printf("getevent <guid>\n");
        return(0);
    }

#if 0
    CheckOwnPriv();    
    if (argc == 3)
    {
        printf("Creating endpoints\n");
        CreateEndpoints();
    }	
#endif    
    
    //
    // Parse the guid parameter
    if (! wGUIDFromString(argv[1], &Guid))
    {
        printf("Bad guid %s\n", argv[1]);
        return(0);
    }
    
    
    Status = WmiNotificationRegistration(&Guid,
                                     TRUE,
                                         EventCallbackRoutine,
                     0,
                                         NOTIFICATION_CALLBACK_DIRECT);
    if (Status != ERROR_SUCCESS)
    {
        printf("WMINotificationRegistration %d\n", Status);
        return(1);
    }

    // Loop forever receiving events
    while (1) Sleep(1000*1000);
    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\reducer\reducer.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    reducer.c

Abstract:

    Trace Reducer Tool

Author:

    08-Apr-1998 mraghu

Revision History:

--*/

//#define _UNICODE
//#define UNICODE
#include <stdlib.h>
#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <wtypes.h>
#include "cpdapi.h"

#define MAXSTR       1024
#define MAXLOGFILES    16

void ReducerUsage()
{
    printf("Usage: reducer [Options] <EtlFile1 EtlFile2 ...> | [-h | -help | -?]\n");
    printf("\t-out <filename> Output file name. Default is Workload.txt\n");
    printf("\t-h        \n");
    printf("\t-help        \n");
    printf("\t-?     Display usage information\n");

//    printf("\t-start <time-stamp>        Start Time\n");
//    printf("\t-end   <time-stamp>        End Time\n");
//    printf("\t       <time-stamp> can be found in tracedmp result\n");
//    printf("\n");
//    printf("\t-base                      Original reducer report (default report)\n");
//    printf("\t-file                      Hot File Report\n");
//    printf("\t-pf                        page fault report\n");
//    printf("\t    -summary processes     summary of faults per process (default PF report).\n");
//    printf("\t             modules       summary of faults per module.\n");
//    printf("\t    -process <image name>  rundown for specific process.\n");
//    printf("\t             all\n");
//    printf("\t    -module  <module name> rundown for specific modules.\n");
//    printf("\t             all\n");
//    printf("\t    -sort    ALL           sort by all fault total.\n");
//    printf("\t             HPF           sort by HPF fault total.\n");
//    printf("\t             TF            sort by TF  fault total.\n");
//    printf("\t             DZF           sort by DZF fault total.\n");
//    printf("\t             COW           sort by COW fault total.\n");
//    printf("\n");
//    printf("\tNote: (1) Cannot generate HotFile Report and PageFault Report\n");
//    printf("\t          at the same time\n");
//    printf("\t0x%08X,%d,\n", STATUS_SEVERITY_WARNING, RtlNtStatusToDosError(STATUS_SEVERITY_WARNING));
}

void stowc(char *str, WCHAR *wstr)
{
    int len, i;
    PUCHAR AnsiChar;

    len = strlen(str);
    for (i = 0; i < len; i++)
    {
        AnsiChar = &str[i];
        wstr[i]  = RtlAnsiCharToUnicodeChar(&AnsiChar);
    }
    wstr[len] = 0;
}

ULONGLONG
ParseTimeString(char * strTime)
{
#if 0
    CHAR          lstrTime[25];
    PCHAR         strYear, strMonth, strDate,
                  strHour, strMinute, strSecond, strMilliSecond;
    LARGE_INTEGER largeTime;
    FILETIME      localTime, stdTime;
    SYSTEMTIME    sysTime;

    if (strTime == NULL)
        return (ULONGLONG) 0;

    strcpy(lstrTime, strTime);

    strMonth = lstrTime;
    for (strDate = strMonth;
         *strDate && *strDate >= '0' && *strDate <= '9';
         strDate ++);
    *strDate = '\0';
    strDate ++;

    for (strYear = strDate;
         *strYear && *strYear >= '0' && *strYear <= '9';
         strYear ++);
    *strYear = '\0';
    strYear ++;

    for (strHour = strYear;
         *strHour && *strHour >= '0' && *strHour <= '9';
         strHour ++);
    *strHour = '\0';
    strHour ++;

    for (strMinute = strHour;
         *strMinute && *strMinute >= '0' && *strMinute <= '9';
         strMinute ++);
    *strMinute = '\0';
    strMinute ++;

    for (strSecond = strMinute;
         *strSecond && *strSecond >= '0' && *strSecond <= '9';
         strSecond ++);
    *strSecond = '\0';
    strSecond ++;

    for (strMilliSecond = strSecond;
         *strMilliSecond && *strMilliSecond >= '0' && *strMilliSecond <= '9';
         strMilliSecond ++);
    *strMilliSecond = '\0';
    strMilliSecond ++;

    sysTime.wYear         = atoi(strYear);
    sysTime.wMonth        = atoi(strMonth);
    sysTime.wDay          = atoi(strDate);
    sysTime.wHour         = atoi(strHour);
    sysTime.wMinute       = atoi(strMinute);
    sysTime.wSecond       = atoi(strSecond);
    sysTime.wMilliseconds = atoi(strMilliSecond);

    SystemTimeToFileTime(&sysTime, &localTime);
    LocalFileTimeToFileTime(&localTime, &stdTime);
    largeTime.HighPart = stdTime.dwHighDateTime;
    largeTime.LowPart  = stdTime.dwLowDateTime;
    return (ULONGLONG) largeTime.QuadPart;
#else
    ULONGLONG TimeStamp = 0;
    ULONG     i = 0;

    for (i = 0; strTime[i] != '\0'; i ++)
    {
        TimeStamp = TimeStamp * 10 + (strTime[i] - '0');
    }

    return TimeStamp;
#endif
}

VOID
ProcessTrace(
    IN ULONG      LogFileCount,
    IN LPCSTR   * LogFileName,
    IN ULONGLONG  StartTime,
    IN ULONGLONG  EndTime,
    IN ULONGLONG  DSStartTime,
    IN ULONGLONG  DSEndTime,
    IN ULONG      MoreFlags,
    IN PVOID      pUserContext,
    IN LPSTR      pOutFileName
    )
{
    // Call TraceLib and process it. 
    //
    TRACE_BASIC_INFO TraceBasicInfo;

    memset(&TraceBasicInfo, 0, sizeof(TRACE_BASIC_INFO));
    TraceBasicInfo.Flags        = TRACE_REDUCE | MoreFlags;
    TraceBasicInfo.LogFileName  = LogFileName; 
    TraceBasicInfo.LogFileCount = LogFileCount;
    TraceBasicInfo.pUserContext = pUserContext;
    TraceBasicInfo.StartTime    = StartTime;
    TraceBasicInfo.EndTime      = EndTime;
    TraceBasicInfo.DSStartTime  = DSStartTime;
    TraceBasicInfo.DSEndTime    = DSEndTime;

    TraceBasicInfo.ProcFileName = pOutFileName;
    InitTraceContext(&TraceBasicInfo);
    DeinitTraceContext(&TraceBasicInfo);
}
    
void __cdecl main(int argc ,char * argv[])
{
    LPCSTR   LogFileName = "C:\\perflogs\\perfdata_980406.blg";
    CHAR     TraceLogFile[MAXSTR];
    WCHAR    PerfLogFile[MAXSTR];
    BOOLEAN  bTrace  = FALSE;
    LPCSTR   EvmFile[MAXLOGFILES];
    ULONGLONG StartTime = 0, EndTime = 0;
    ULONG    i;
    ULONG    LogFileCount = 0;

    ULONG               flagsMore    = 0;
    PVOID               pUserContext = NULL;
    CPD_USER_CONTEXT_MM UserContextMM;

    UserContextMM.reportNow  = REPORT_SUMMARY_PROCESS;
    UserContextMM.sortNow    = REPORT_SORT_ALL;
    UserContextMM.strImgName = NULL;
    memset(&TraceLogFile, 0, sizeof(CHAR) * MAXSTR); 

    while (--argc > 0)
    {
        ++argv;
        if (**argv == '-' || **argv == '/')
        { 
            ** argv = '-';
            if (!_stricmp(argv[0], "-out"))
            {
                if (argc > 1)
                {
                    CHAR TempStr[MAXSTR];

                    strcpy(TempStr, argv[1]);
                    //stowc(argv[1], TempStr); 
                    ++argv; --argc;
                    _fullpath(TraceLogFile, TempStr, MAXSTR);
                    printf("Setting output file to: '%s'\n", TraceLogFile);
                    bTrace = TRUE;
                }
            }
            else if (!_stricmp(argv[0], "-start"))
            {
                if (argc > 1)
                {
                    flagsMore |= TRACE_DS_ONLY | TRACE_LOG_REPORT_BASIC;
                    StartTime  = ParseTimeString(argv[1]);
                    argc --; argv ++;
                }
            }
            else if (!_stricmp(argv[0], "-end"))
            {
                if (argc > 1)
                {
                    flagsMore |= TRACE_DS_ONLY | TRACE_LOG_REPORT_BASIC;
                    EndTime    = ParseTimeString(argv[1]);
                    argc --; argv ++;
                }
            }
            else if (!_stricmp(argv[0], "-base"))
            {
                flagsMore   |= TRACE_LOG_REPORT_BASIC;
            }
            else if (!_stricmp(argv[0], "-total"))
            {
                flagsMore   |= TRACE_LOG_REPORT_TOTALS;
            }
            else if (!_stricmp(argv[0], "-file"))
            {
                flagsMore   |= TRACE_LOG_REPORT_FILE;
                if (argc > 1 && argv[1][0] >= '0' && argv[1][0] <= '9')
                {
                    (ULONG) pUserContext = atoi(argv[1]);
                    argc --; argv ++;
                }
                else
                {
                    (ULONG) pUserContext = DEFAULT_FILE_REPORT_SIZE;
                }
            }
            else if (!_stricmp(argv[0], "-hpf"))
            {
                flagsMore   |= TRACE_LOG_REPORT_HARDFAULT;
            }
            else if (!_stricmp(argv[0], "-pf"))
            {
                flagsMore   |= TRACE_LOG_REPORT_MEMORY;
                pUserContext = (PVOID) & UserContextMM;
            }
            else if (!_stricmp(argv[0], "-summary"))
            {
                if (argc > 1)
                {
                    flagsMore   |= TRACE_LOG_REPORT_MEMORY;
                    pUserContext = (PVOID) & UserContextMM;

                    if (!_stricmp(argv[1], "processes"))
                    {
                        argc --; argv ++;
                        UserContextMM.reportNow = REPORT_SUMMARY_PROCESS;
                    }
                    else if (!_stricmp(argv[1], "modules"))
                    {
                        argc --; argv ++;
                        UserContextMM.reportNow = REPORT_SUMMARY_MODULE;
                    }
                }
            }

            else if (!_stricmp(argv[0], "-process"))
            {
                flagsMore   |= TRACE_LOG_REPORT_MEMORY;
                pUserContext = (PVOID) & UserContextMM;
                UserContextMM.reportNow = REPORT_LIST_PROCESS;

                if ((argc > 1) && (argv[1][0] != '-' || argv[1][0] != '/'))
                {
                    if (_stricmp(argv[1], "all"))
                    {
                        UserContextMM.strImgName =
                                malloc(sizeof(WCHAR) * (strlen(argv[1]) + 1));
                        if (UserContextMM.strImgName)
                        {
                            stowc(argv[1], UserContextMM.strImgName);
                        }
                    }
                    argc --; argv ++;
                }
            }
            else if (!_stricmp(argv[0], "-module"))
            {
                flagsMore   |= TRACE_LOG_REPORT_MEMORY;
                pUserContext = (PVOID) & UserContextMM;
                UserContextMM.reportNow = REPORT_LIST_MODULE;

                if ((argc > 1) && (argv[1][0] != '-' || argv[1][0] != '/'))
                {
                    if (_stricmp(argv[1], "all"))
                    {
                        UserContextMM.strImgName =
                                malloc(sizeof(WCHAR) * (strlen(argv[1]) + 1));
                        if (UserContextMM.strImgName)
                        {
                            stowc(argv[1], UserContextMM.strImgName);
                        }
                    }
                    argc --; argv ++;
                }
            }

            else if (!_stricmp(argv[0], "-sort"))
            {
                flagsMore   |= TRACE_LOG_REPORT_MEMORY;
                pUserContext = (PVOID) & UserContextMM;
 
                if ((argc > 1) && (argv[1][0] != '-' || argv[1][0] != '/'))
                {
                    if (!_stricmp(argv[1], "hpf"))
                    {
                        UserContextMM.sortNow = REPORT_SORT_HPF;
                    }
                    else if (!_stricmp(argv[1], "tf"))
                    {
                        UserContextMM.sortNow = REPORT_SORT_TF;
                    }
                    else if (!_stricmp(argv[1], "dzf"))
                    {
                        UserContextMM.sortNow = REPORT_SORT_DZF;
                    }
                    else if (!_stricmp(argv[1], "cow"))
                    {
                        UserContextMM.sortNow = REPORT_SORT_COW;
                    }
                    else
                    {
                        UserContextMM.sortNow = REPORT_SORT_ALL;
                    }
                    argc --; argv ++;
                }
            }
            else
            {
                goto Usage;
            }
        }
        else
        {
            LPCSTR pLogFile;

            pLogFile = malloc(sizeof(CHAR) * MAXSTR);
            RtlZeroMemory((char *) pLogFile, sizeof(CHAR) * MAXSTR);
            EvmFile[LogFileCount] = pLogFile;
            strcpy((char *) EvmFile[LogFileCount ++], argv[0]);
            bTrace = TRUE;

            printf("LogFile %s\n", (char *) EvmFile[LogFileCount - 1]);
        }
    }

    if (LogFileCount == 0)
    {
        goto Usage;
    }

    if (flagsMore == 0)
    {
        flagsMore |= TRACE_LOG_REPORT_BASIC;
    }

    if (   (flagsMore & TRACE_LOG_REPORT_MEMORY)
        && (flagsMore & TRACE_LOG_REPORT_FILE))
    {
        printf("Error: cannot generate HotFile report and PageFault report at the same time.\n");
        goto Cleanup;
    }

    if (bTrace)
    {
        ProcessTrace(LogFileCount, EvmFile, (ULONGLONG) 0, (ULONGLONG) 0,
                StartTime, EndTime, flagsMore, pUserContext, TraceLogFile);
    }

    for (i=0; i < LogFileCount; i++) 
    {
        free((char*)EvmFile[i]);
    }

    if (UserContextMM.strImgName)
    {
        free(UserContextMM.strImgName);
    }

Cleanup:
    return;

Usage:
    ReducerUsage();
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\testqm\testqm.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    wmisecur.c

Abstract:

    Wmi security tool

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#define INITGUID

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <stdlib.h>

#include <aclapi.h>

#include "wmium.h"



//
// The routines below were blantenly stolen without remorse from the ole
// sources in \nt\private\ole32\com\class\compapi.cxx. They are copied here
// so that WMI doesn't need to load in ole32 only to convert a guid string
// into its binary representation.
//


//+-------------------------------------------------------------------------
//
//  Function:   HexStringToDword   (private)
//
//  Synopsis:   scan lpsz for a number of hex digits (at most 8); update lpsz
//              return value in Value; check for chDelim;
//
//  Arguments:  [lpsz]    - the hex string to convert
//              [Value]   - the returned value
//              [cDigits] - count of digits
//
//  Returns:    TRUE for success
//
//--------------------------------------------------------------------------
BOOL HexStringToDword(LPCSTR lpsz, DWORD * RetValue,
                             int cDigits, WCHAR chDelim)
{
    int Count;
    DWORD Value;

    Value = 0;
    for (Count = 0; Count < cDigits; Count++, lpsz++)
    {
        if (*lpsz >= '0' && *lpsz <= '9')
            Value = (Value << 4) + *lpsz - '0';
        else if (*lpsz >= 'A' && *lpsz <= 'F')
            Value = (Value << 4) + *lpsz - 'A' + 10;
        else if (*lpsz >= 'a' && *lpsz <= 'f')
            Value = (Value << 4) + *lpsz - 'a' + 10;
        else
            return(FALSE);
    }

    *RetValue = Value;
    
    if (chDelim != 0)
        return *lpsz++ == chDelim;
    else
        return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   wUUIDFromString    (internal)
//
//  Synopsis:   Parse UUID such as 00000000-0000-0000-0000-000000000000
//
//  Arguments:  [lpsz]  - Supplies the UUID string to convert
//              [pguid] - Returns the GUID.
//
//  Returns:    TRUE if successful
//
//--------------------------------------------------------------------------
BOOL wUUIDFromString(LPCSTR lpsz, LPGUID pguid)
{
        DWORD dw;

        if (!HexStringToDword(lpsz, &pguid->Data1, sizeof(DWORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(DWORD)*2 + 1;
        
        if (!HexStringToDword(lpsz, &dw, sizeof(WORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(WORD)*2 + 1;

        pguid->Data2 = (WORD)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(WORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(WORD)*2 + 1;

        pguid->Data3 = (WORD)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[0] = (BYTE)dw;
        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, '-'))
                return FALSE;
        lpsz += sizeof(BYTE)*2+1;

        pguid->Data4[1] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[2] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[3] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[4] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[5] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[6] = (BYTE)dw;
        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[7] = (BYTE)dw;

        return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   wGUIDFromString    (internal)
//
//  Synopsis:   Parse GUID such as {00000000-0000-0000-0000-000000000000}
//
//  Arguments:  [lpsz]  - the guid string to convert
//              [pguid] - guid to return
//
//  Returns:    TRUE if successful
//
//--------------------------------------------------------------------------
BOOL wGUIDFromString(LPCSTR lpsz, LPGUID pguid)
{
    DWORD dw;

    if (*lpsz == '{' )
        lpsz++;

    if(wUUIDFromString(lpsz, pguid) != TRUE)
        return FALSE;

    lpsz +=36;

    if (*lpsz == '}' )
        lpsz++;

    if (*lpsz != '\0')   // check for zero terminated string - test bug #18307
    {
       return FALSE;
    }

    return TRUE;
}

UCHAR Buffer[4096];

int __cdecl main(int argc, char *argv[])
{
	WMIHANDLE Handle;
	GUID Guid;
	ULONG Size;
	ULONG Status;

	if (wGUIDFromString(argv[1], &Guid))
	{
		Status = WmiOpenBlock(&Guid, WMIGUID_QUERY, &Handle);
		if (Status == ERROR_SUCCESS)
		{
			Size = sizeof(Buffer);
			Status = WmiQueryAllDataMultiple(&Handle,
											 1,
											 &Size,
											 Buffer);
			if (Status == ERROR_SUCCESS)
			{
				printf("returned %d bytes\n", Size);
			}
		}
	}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\umtrprov\logger.cpp ===
// Logger.cpp: implementation of the CPersistor class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include <string>
#include <iosfwd> 
#include <iostream>
#include <fstream>
#include <ctime>
#include <list>
using namespace std;

#include <malloc.h>
#include <tchar.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>

#include <WTYPES.H>
#include "t_string.h"

#include "Persistor.h"

#include "Utilities.h"
#include "StructureWrappers.h"
#include "StructureWapperHelpers.h"

#include "Logger.h"


#ifdef _UNICODE
static TCHAR g_tcBeginFile[] = {0xfeff,0x0d, 0x0a};
static TCHAR g_atcNL[] = {0x0d, 0x0a, 0x00};
#endif

CLogger::CLogger(LPCTSTR lpctstrFileName, bool bAppend)
{
#ifdef _UNICODE
	m_sFileName = NewLPSTR((LPCWSTR) const_cast<LPTSTR>(lpctstrFileName));
#else
	m_sFileName = NewTCHAR(lpctstrFileName);
#endif

	m_pPersistor = new CPersistor(m_sFileName, ios::out, false);
	m_hr = m_pPersistor -> OpenLog(bAppend);
}

CLogger::~CLogger()
{
	free(m_sFileName);
	delete m_pPersistor;
}

int CLogger::LogTCHAR(LPCTSTR lpctstrOut)
{
	if (FAILED(m_hr))
	{
		return m_hr;
	}

	PutALine(m_pPersistor->Stream(), lpctstrOut, -1);

	return 0;
}

int CLogger::LogTime(time_t &Time)
{
	if (FAILED(m_hr))
	{
		return m_hr;
	}

	TCHAR tcArray[26];
	LPCTSTR lpctstrTime = t_ctime(&Time);
	_tcscpy(tcArray,lpctstrTime);
	tcArray[24] = _T('\0');
	TCHAR *p = tcArray;

	PutALine(m_pPersistor->Stream(), p, -1);

	return 0;
}

int CLogger::LogULONG(ULONG ul, bool bHex)
{
	if (FAILED(m_hr))
	{
		return m_hr;
	}
	
	if (bHex)
	{
		PutALine(m_pPersistor->Stream(), _T("0x"), -1);
	}

	PutAULONGVar(m_pPersistor->Stream(), ul, bHex);

	return 0;
}

int CLogger::LogULONG64(ULONG64 ul, bool bHex)
{
	if (FAILED(m_hr))
	{
		return m_hr;
	}
	
	if (bHex)
	{
		PutALine(m_pPersistor->Stream(), _T("0x"), -1);
	}

	PutAULONG64Var(m_pPersistor->Stream(), ul);

	return 0;
}

int CLogger::LogGUID(GUID Guid)
{
	if (FAILED(m_hr))
	{
		return m_hr;
	}

	GUIDOut(m_pPersistor->Stream(), Guid);

	return 0;
}

int CLogger::LogEventTraceProperties(PEVENT_TRACE_PROPERTIES pProps)
{
	if (FAILED(m_hr))
	{
		return m_hr;
	}

	if (pProps == NULL)
	{
		PutALine(m_pPersistor->Stream(),_T("_EVENT_TRACE_PROPERTIES Instance NULL\n"),-1);
		return 0;
	}

	CEventTraceProperties Props(pProps);

	m_pPersistor->Stream() << Props;

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\umtrprov\main.h ===
#ifndef _MAIN_H
#define _MAIN_H


#include "t_string.h"
#include "Utilities.h"
#include "Persistor.h"
#include "StructureWrappers.h"
#include "StructureWapperHelpers.h"
//#include "ConstantMap.h" 
//#include "TCOData.h"
#include "Logger.h"
//#include "Validator.h"

ULONG ProviderCallBack(WMIDPREQUESTCODE RequestCode,
    PVOID Context,
    OUT ULONG *InOutBufferSize,
    OUT PVOID Buffer);

void
InitializeRegisterTraceGuid( PREGISTER_TRACE_GUID RegisterTraceGuid );

ULONG
TraceEvents ( ULONG TraceMode, ULONG TraceGuid, ULONG Count);

ULONG
TraceEventInstances ( ULONG TraceMode, ULONG TraceGuid, ULONG Count);

//int InitializeLogging( LPCTSTR lpctstrTCOFile,	CLogger *&pLoggingInfo);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\umtrprov\logger.h ===
#if !defined(AFX_LOGGER_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_)
#define AFX_LOGGER_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_

#define UNICODE
#define _UNICODE

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CLogger
{
public:
	CLogger(LPCTSTR lpctstrFileName,  bool bAppend = true);
	~CLogger();
	int LogTCHAR(LPCTSTR lpctstrOut);
	int LogULONG(ULONG uLong, bool bHex = true);
	int LogULONG64(ULONG64 uLong64,  bool bHex = true);
	int LogGUID(GUID Guid);
	int LogEventTraceProperties(PEVENT_TRACE_PROPERTIES pProps);
	int LogTime(time_t &Time);
	void Flush() {m_pPersistor->Stream().flush();}
	HRESULT GetOpenStatus() {return m_hr;}
private:
	CPersistor *m_pPersistor;
	char *m_sFileName;
	HRESULT m_hr;
};

#endif // !defined(AFX_LOGGER_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\umtrprov\main.cpp ===
#define MAX_STR 256
#define MAX_GUIDS 10

#define _UNICODE
#define UNICODE

#include "stdafx.h"

#pragma warning (disable : 4786)
#pragma warning (disable : 4275)

#include <iostream>
#include <strstream>
#include <fstream>
#include <string>
#include <sstream>
#include <map>
#include <list>


using namespace std;


#include <tchar.h>
#include <process.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>

#include <WTYPES.H>

/*

#include "stdafx.h"

#include <string>
#include <iosfwd> 
#include <iostream>
#include <fstream>
#include <ctime>
#include <list>
using namespace std;
#include <malloc.h>
#include <windows.h>


#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <tchar.h>
#include <wmistr.h>
#include <objbase.h>
#include <initguid.h>
#include <evntrace.h>
*/
#include "struct.h"
#include "utils.h"
#include "Readfile.h"
#include "main.h"





TRACEHANDLE LoggerHandle = (TRACEHANDLE) 2;
ULONG TraceEventFlag = 0, EnableLevel = 0, EnableFlags = 0;
ULONG LoggerEnableLevel, LoggerEnableFlag;
ULONG TraceMode;
ULONG DataBlockSize = 0;
ULONG TraceEventInstanceFlag = 0;
PREGISTER_TRACE_GUID RegisterTraceGuid;
GUID TransactionGuid[12] =  {	{ 0xa7301ec8, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xa8558716, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xa9226a42, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xaa395d64, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xaa8ccfb2, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xaad4563e, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xab171816, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xab55153a, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xab84c442, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xabb210f0, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xabe1bff8, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xb01e8dee, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 } };


typedef struct _BLOCK1 {
    UCHAR                 EventChar;
	ULONG                 EventUlong;
} BLOCK1, *PBLOCK1;

typedef struct _EVENT_BLOCK1 {
    EVENT_TRACE_HEADER    Header;
	BLOCK1                Block1;
} EVENT_BLOCK1, *P_EVENT_BLOCK1;

typedef struct _EVENT_INSTANCE_BLOCK1 {
	EVENT_INSTANCE_HEADER Header;
	UCHAR				  EventChar;
	ULONG				  EventUlong;
} EVENT_INSTANCE_BLOCK1, *P_EVENT_INSTANCE_BLOCK1;

typedef struct _EVENT_BLOCK2 {
	EVENT_TRACE_HEADER Header;
	MOF_FIELD  MofField;
} EVENT_BLOCK2, *P_EVENT_BLOCK2;


BLOCK1 Block1;
EVENT_BLOCK1 EventBlock1;
EVENT_BLOCK2 EventBlock2;
EVENT_INSTANCE_BLOCK1 EventInstanceBlock1;
TRACE_GUID_REGISTRATION TraceGuidReg[MAX_GUIDS];

main(int argc, char* argv[])
{
	LPTSTR CommandFile;
	TRACEHANDLE RegistrationHandle;	
	ULONG Status;
	LPTSTR *commandLine;
	LPGUID pGuid;
	ULONG Count;
	ULONG GuidCount = 0;
	//CLogger *pLoggingInfo;
	LPCTSTR LogFileName;
	LPTSTR *targv;
	int i;
	

	pGuid = (LPGUID ) malloc(MAX_GUIDS * sizeof(GUID));
	CommandFile = (LPTSTR) malloc(sizeof(TCHAR)*MAX_STR);
	LogFileName = (LPCTSTR) malloc(sizeof(TCHAR)*MAX_STR);
	targv = (LPTSTR *) malloc(argc*sizeof(LPTSTR));
	for( i = 0; i < argc; i++ )
		targv[i] = (LPTSTR) malloc(sizeof(TCHAR)*MAX_STR);

	SplitCommandLine( GetCommandLine(), targv);
	for( i = 0; i < MAX_GUIDS; i++)
		TraceGuidReg[i].Guid = &TransactionGuid[i];
	Count = 1;
	while ( Count <= (argc-1) )
	{
		if ( !_tcsicmp(targv[Count], _T("-guids") )) 
		{
			Count++;
			if (Count <= argc) 
			{
				ConvertAsciiToGuid( targv[Count], &pGuid[GuidCount]);
				GuidCount++;
				Count++;
			}
			continue;
		}

		if( !_tcsicmp(targv[Count], _T("-file") ))
		{
			Count++;
			if ( Count <= argc)
			{
				CommandFile = targv[Count];
				Count++;
			}
			continue;
		}

		if( !_tcsicmp(targv[Count], _T("-flag") ))
		{
			Count++;
			if( Count <= argc)
			{
				LoggerEnableFlag = atoi(argv[Count]);
				Count++;
			}
			continue;
		}

		if( !_tcsicmp(targv[Count], _T("-level") ))
		{
			Count++;
			if( Count <= argc)
			{
				LoggerEnableLevel = atoi(argv[Count]);
				Count++;
			}
			continue;
		}

		if( !_tcsicmp(targv[Count], _T("-mode") ))
		{
			Count++;
			if( Count <= argc)
			{
				TraceMode = atoi(argv[Count]);
				Count++;
				continue;
			}
		}

		if( !_tcsicmp(targv[Count], _T("-TraceEventInstance") ))
		{
			Count++;
			TraceEventInstanceFlag = 1;
			continue;
		}

		if( !_tcsicmp(targv[Count], _T("-log") ))
		{
			Count++;
			if( Count <= argc )
			{
				//LogFileName = _T(argv[Count]);
				LogFileName = _T("C:\\");
				Count++;
				continue;
			}
		}

		Count++;
		continue;
	}
        
	Count = sizeof(REGISTER_TRACE_GUID);
	RegisterTraceGuid = (PREGISTER_TRACE_GUID ) malloc(sizeof(REGISTER_TRACE_GUID));
	RegisterTraceGuid->ControlGuid  = (LPGUID) malloc(sizeof(GUID));
	RegisterTraceGuid->MofImagePath = (TCHAR *) malloc (sizeof(TCHAR)*MAX_STR);
	RegisterTraceGuid->MofResourceName = (TCHAR *) malloc (sizeof(TCHAR)*MAX_STR);

	if( RegisterTraceGuid == NULL)
	{
		printf("\nGufooo");
		exit(0);
	}
	InitializeRegisterTraceGuid( RegisterTraceGuid );

	RegisterTraceGuid->UseMofPtrFlag = 0;
	RegisterTraceGuid->UseGuidPtrFlag = 0;
	
	Status = ReadInputFile( CommandFile, RegisterTraceGuid );


	if( RegisterTraceGuid->GuidCount != 0)
		RegisterTraceGuid->GuidCount = GuidCount;
	
	if( RegisterTraceGuid->CallBackFunction != 0)
		RegisterTraceGuid->CallBackFunction = ProviderCallBack;

	if( RegisterTraceGuid->TraceGuidReg != 0 )
		RegisterTraceGuid->TraceGuidReg = ( PTRACE_GUID_REGISTRATION) &TraceGuidReg[0];

	if( RegisterTraceGuid->RegistrationHandle != 0 )
		RegisterTraceGuid->RegistrationHandle = &RegistrationHandle;

	if( RegisterTraceGuid->GuidCount != 0 )
		RegisterTraceGuid->GuidCount = MAX_GUIDS;

	//InitializeLogging( LogFileName, pLoggingInfo);

	//if (pLoggingInfo)
	//{
		//pLoggingInfo->LogTCHAR(_T("\n*******************************************************\n"));
		//pLoggingInfo->LogTCHAR(_T("StartTraceAPI TCO test "));
		//pLoggingInfo->Flush();	
	//}



	Status = RegisterTraceGuids( ProviderCallBack,
								NULL, //Context
								pGuid,
								RegisterTraceGuid->GuidCount,
								RegisterTraceGuid->TraceGuidReg,
								RegisterTraceGuid->MofImagePath,
								RegisterTraceGuid->MofResourceName,
								RegisterTraceGuid->RegistrationHandle );

	if( RegisterTraceGuid->UnRegistrationHandle != 0 )
	{
		Status = UnregisterTraceGuids( (TRACEHANDLE) 0 );
		return;
	}

	if( Status == ERROR_SUCCESS)
	{
		Count = 0;
		do
		{
			if( (TraceEventFlag ) && ( TraceEventInstanceFlag) )
			{
				Status = TraceEventInstances( TraceMode, (Count%10), Count);
				Count++;
			}
			else if (TraceEventFlag)
			{
				Status = TraceEvents( TraceMode, (Count%10), (Count%100));
				Count++;
			}

		}while(1);
		Status = UnregisterTraceGuids( *(RegisterTraceGuid->RegistrationHandle));
	}
}


ULONG ProviderCallBack(WMIDPREQUESTCODE RequestCode,
    PVOID Context,
    ULONG *InOutBufferSize,
    PVOID Buffer)
{
	switch (RequestCode )
	{
		case WMI_ENABLE_EVENTS:
		{
			TraceEventFlag = 1;
            LoggerHandle = GetTraceLoggerHandle( Buffer );
            EnableLevel = GetTraceEnableLevel(LoggerHandle);
            EnableFlags = GetTraceEnableFlags(LoggerHandle);
			break;
		}
		
		case WMI_DISABLE_EVENTS:
		{
			TraceEventFlag = 0;
			break;
		}
	}
		return 0;
}


void
InitializeRegisterTraceGuid( PREGISTER_TRACE_GUID RegisterTraceGuid )
{
	//Initialize with some random values and then read from the input
	//file. If any of these parameters needs to be tested with 0, 
	//input files will set this as zero.
	if( RegisterTraceGuid )
	{
		RegisterTraceGuid->GuidCount = 0xa5;
		RegisterTraceGuid->CallBackFunction = (PVOID) 0xa5a5a5;
		RegisterTraceGuid->TraceGuidReg = (PTRACE_GUID_REGISTRATION) (0xa5a5a5);
		RegisterTraceGuid->RegistrationHandle = (PTRACEHANDLE) (0xa5a5a5);
		RegisterTraceGuid->UnRegistrationHandle = (PTRACEHANDLE) (0xa5a5a5);
	}

}

ULONG
TraceEvents ( ULONG TraceMode, ULONG TraceGuid, ULONG Count)
{
	ULONG Status;

	switch ( TraceMode )
	{
		case 0 :
		{
			if( RegisterTraceGuid->UseMofPtrFlag != 1)
			{
				EventBlock1.Header.Size = sizeof(EventBlock1);
				ULONG Temp = sizeof(Block1);
				EventBlock1.Header.Guid = TransactionGuid[TraceGuid];
				EventBlock1.Header.Flags = WNODE_FLAG_TRACED_GUID;
				if( RegisterTraceGuid->UseGuidPtrFlag == 1)
				{
					EventBlock1.Header.Flags |= WNODE_FLAG_USE_GUID_PTR;
					EventBlock1.Header.GuidPtr = (ULONGLONG) &TransactionGuid[TraceGuid];
				}
				EventBlock1.Block1.EventChar = (UCHAR) Count;
				EventBlock1.Block1.EventUlong = Count;
				Status = TraceEvent( LoggerHandle, (PEVENT_TRACE_HEADER) &EventBlock1);
			}
			else
			{
				EventBlock2.Header.Size = sizeof(EventBlock2);
				EventBlock2.Header.Flags = WNODE_FLAG_USE_MOF_PTR;
				EventBlock2.Header.Guid = TransactionGuid[TraceGuid];
				EventBlock2.Header.Flags |= WNODE_FLAG_TRACED_GUID;
				EventBlock2.MofField.DataPtr = (ULONGLONG) &Block1;
				EventBlock2.MofField.Length = sizeof(BLOCK1);
				if( RegisterTraceGuid->UseGuidPtrFlag == 1)
				{
					EventBlock2.Header.Flags |= WNODE_FLAG_USE_GUID_PTR;
					EventBlock2.Header.GuidPtr = (ULONGLONG) &TransactionGuid[TraceGuid];
				}
				Block1.EventChar = (UCHAR) Count;
				Block1.EventUlong = Count;
				Status = TraceEvent( LoggerHandle, (PEVENT_TRACE_HEADER) &EventBlock2);

			}
			break;
		}
	}
	return Status;

}


ULONG
TraceEventInstances ( ULONG TraceMode, ULONG TraceGuid, ULONG Count)
{
	ULONG Status;
	EVENT_INSTANCE_INFO InstanceInfo;
	switch ( TraceMode )
	{
		case 0 :
		{
			EventInstanceBlock1.Header.Size = sizeof(EventInstanceBlock1);
			EventInstanceBlock1.Header.Flags = WNODE_FLAG_TRACED_GUID;
			if( RegisterTraceGuid->UseMofPtrFlag == 1)
				EventInstanceBlock1.Header.Flags |= WNODE_FLAG_USE_MOF_PTR;
			EventInstanceBlock1.EventChar = (UCHAR) Count;
			EventInstanceBlock1.EventUlong = Count;
			Status = CreateTraceInstanceId( TraceGuidReg[TraceGuid].RegHandle,
											&InstanceInfo);
			if( Status == ERROR_SUCCESS )
				Status = TraceEventInstance( LoggerHandle, (PEVENT_INSTANCE_HEADER) &EventBlock1,
											 &InstanceInfo,
											 NULL);
			break;
		}
	}
	return Status;

}

/*
int InitializeLogging( LPCTSTR lpctstrTCOFile,	CLogger *&pLoggingInfo)
{
	HRESULT hr = S_OK;
//	t_string tsError;

	if (lpctstrTCOFile)
	{
		// Open *our* logger file.
		pLoggingInfo = new CLogger(lpctstrTCOFile, false);
		hr = pLoggingInfo->GetOpenStatus();
		if (FAILED (hr))
		{
//			tsError = _T("Could not open detail log file \"");
//			tsError += lpctstrTCOFile;
//			tsError += _T("\".");
			//*plpstrReturnedError = NewTCHAR(tsError.c_str());
			return hr;
		}
	}
	return hr;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\umtrprov\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	TestStartTrace.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\umtrprov\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__991FD5F0_FC29_11D2_8052_009027345EE2__INCLUDED_)
#define AFX_STDAFX_H__991FD5F0_FC29_11D2_8052_009027345EE2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// Insert your headers here
#ifndef NT5BUILD
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#include <stdio.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__991FD5F0_FC29_11D2_8052_009027345EE2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\umtrprov\persistor.cpp ===
// Persistor.cpp: implementation of the CPersistor class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include <string>
#include <iosfwd> 
#include <iostream>
#include <fstream>

using namespace std;

#include <WTYPES.H>
#include "t_string.h"

#include "Persistor.h"

#include "StructureWapperHelpers.h"



#ifdef _UNICODE
static TCHAR g_tcBeginFile[] = {0xfeff};
static TCHAR g_atcNL[] = {0x0d, 0x0a, 0x00};
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


CPersistor::CPersistor
(const char *pszFilename, int nMode, bool bLoading)
{
	m_sFilename = pszFilename;
	m_nMode = nMode;
	m_bLoading = bLoading;
	m_pfsFile = NULL;
	m_bFirst = true;
	m_pfsFile = NULL;
}

CPersistor::~CPersistor()
{
	Close();
}

HRESULT CPersistor::Close()
{
	if (m_pfsFile && m_pfsFile->is_open())
	{
#ifdef _UNICODE
		if (!m_bLoading)
		{
		
		}
#endif
		m_pfsFile->flush();
		m_pfsFile->close();
		delete m_pfsFile;
		m_pfsFile = NULL;
	}
	else if (m_pfsFile)
	{
		delete m_pfsFile;
		m_pfsFile = NULL;
	}

	return S_OK;

}

HRESULT CPersistor::Open()
{

	m_pfsFile = NULL;

	m_pfsFile = new t_fstream
				(m_sFilename.c_str(),m_nMode | ios_base::binary);

	if (m_pfsFile && m_pfsFile->fail())
	{
		return HRESULT_FROM_WIN32(GetLastError());
	}
	else
	{
#ifdef _UNICODE
		if (m_bFirst && !m_bLoading)
		{
			// To Do:  Need to write out here the UNICODE string.
			PutALine(*m_pfsFile, g_tcBeginFile, 1);
		}
		else if (m_bFirst)
		{
			// Need to skip over the UNICODE string.
			fpos_t p = m_pfsFile->tellp();
			if (p == (fpos_t) 0)
			{
				TCHAR tc;
				tc = Stream().peek();
				// Need to make sure that the file is unicode.
				if (tc != 0xff)
				{
					m_pfsFile ->close();
					delete m_pfsFile;
					m_pfsFile = NULL;
					return HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION);
				}
				
				TCHAR t;

				GetAChar(Stream(), t);
				
			}
		}
#else
		if (m_bFirst && m_bLoading)
		{
			// Need to make sure that the file is not unicode.
			int tc;
			tc = Stream().peek();
			if (tc == 0xff)
			{
				m_pfsFile ->close();
				delete m_pfsFile;
				m_pfsFile = NULL;
				return HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION);
			}
		}
#endif
		m_bFirst = false;
		return S_OK;
	}


}

// 
HRESULT CPersistor::OpenLog(bool bAppend)
{

	m_pfsFile = NULL;

	m_pfsFile = new t_fstream
		(m_sFilename.c_str(),m_nMode | ios_base::binary | (bAppend ?  ios::app : 0));

	if (m_pfsFile && m_pfsFile->fail())
	{
		return HRESULT_FROM_WIN32(GetLastError());
	}
	else
	{
#ifdef _UNICODE
		//m_pfsFile->seekp(ios::end);
		//fpos_t p = m_pfsFile->tellp();
		//if (p == (fpos_t) 0)
		//{
			PutALine(*m_pfsFile, g_tcBeginFile, 1);
		//}
#endif
		return S_OK;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\umtrprov\persistor.h ===
// Persistor.h: interface for the CPersistor class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PERSISTOR_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_)
#define AFX_PERSISTOR_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CPersistor  
{
public:
	virtual ~CPersistor();
	CPersistor(const char *pszFilename, int nMode, bool bLoading = true );
	HRESULT Close();
	HRESULT Open();
	// For logging support.  We only log out.
	HRESULT OpenLog(bool bAppend = true);
	t_fstream &Stream() {return *m_pfsFile;}
	bool IsLoading() {return m_bLoading;}
	const char* GetFilename() {return m_sFilename.c_str();} 
protected:
	t_fstream *m_pfsFile;
	bool m_bLoading;
	string m_sFilename;
	int m_nMode;
	bool m_bFirst;
};

#endif // !defined(AFX_PERSISTOR_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\umtrprov\struct.h ===
#define UNICODE
#define _UNICODE

#ifndef _STRUCT_H
#define _STRUCT_H

typedef struct _REGISTER_TRACE_GUID {

	LPGUID ControlGuid;
	LPTSTR MofImagePath;
	LPTSTR MofResourceName;
	ULONG GuidCount;
	PVOID CallBackFunction;
	PTRACE_GUID_REGISTRATION TraceGuidReg;
	PTRACEHANDLE RegistrationHandle;
	PTRACEHANDLE UnRegistrationHandle;
	PTRACEHANDLE GetTraceLoggerHandle;
	PTRACEHANDLE GetTraceEnableLevel;
	PTRACEHANDLE GetTraceEnableFlag;
	PTRACEHANDLE TraceHandle;
	ULONG UseMofPtrFlag;
	ULONG UseGuidPtrFlag;
} REGISTER_TRACE_GUID, *PREGISTER_TRACE_GUID;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\umtrprov\readfile.h ===
#define UNICODE
#define _UNICODE

#ifndef _READFILE_H
#define _READFILE_H
/*
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <tchar.h>
#include <wmistr.h>
#include <objbase.h>
#include <initguid.h>
#include <evntrace.h>

#include "struct.h"
#include "utils.h"
*/
#define MAX_STR 256


ULONG
ReadInputFile(LPTSTR InputFile, PREGISTER_TRACE_GUID RegisterTraceGuid);

BOOLEAN
ReadGuid( LPGUID ControlGuid );

BOOLEAN
ReadUlong( ULONG *GuidCount);

BOOLEAN
ReadString( TCHAR *String, ULONG StringLength);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\umtrprov\t_string.cpp ===
//////////////////////////////////////////////////////////////////////
// Implementaion of WC to MBCS and MBCS to WC routines that do the 
// right thing if compiled non-UNICODE or UNICODE.
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "t_string.h"

//////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\umtrprov\structurewapperhelpers.cpp ===
// StructureWapperHelpers.cpp
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#pragma warning (disable : 4786)
#pragma warning (disable : 4275)

#include <iostream>
#include <strstream>
#include <fstream>
#include <string>
#include <sstream>
#include <map>
#include <list>


using namespace std;

#include <tchar.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>


#include <WTYPES.H>
#include "t_string.h"
#include "Utilities.h"

#include "Persistor.h"

#include "StructureWrappers.h"
#include "StructureWapperHelpers.h"
#include "ConstantMap.h"
  
extern CConstantMap g_ConstantMap;

static TCHAR g_tcNl = _T('\n');
static TCHAR g_tcCR = 0x0d;
static TCHAR g_tcLF = 0x0a;

#ifdef _UNICODE
static TCHAR g_tcDQuote[] = _T("\"");
static TCHAR g_atcNL[] = {0x0d, 0x0a, 0x00};
#else
static TCHAR g_atcNL[] = {g_tcNl};
static TCHAR g_tcDQuote = _T('"');
#endif


// Why we are not using formatted input:
#if 0
From:	Phil Lucido (Exchange) 
Sent:	Friday, April 16, 1999 10:34 AM
To:	Judy Powell
Cc:	Visual C++ Special Interest Group
Subject:	RE: Wide character output via wfstream from the "Standard Library" 
using VC 6 Enterprise Edition SP2 on NT4 SP4

It looks like our iostreams implementation for wide-char streams is actually wide-char 
in memory, multibyte chars on disk.  The reason you get an empty file is because wctomb 
is failing on 0xfeff.

This should work more like the stdio stuff, where a text mode wide-char stream writes 
multibyte chars to a file, but binary mode writes the raw unicode.

We get our C++ Library implementation from Dinkumware (P.J. Plauger).  I'll check with 
him to see about changing this implementation so binary mode wide-char iostream is 
compatible with wide-char stdio.

...Phil
#endif

//////////////////////////////////////////////////////////////////////
// Helpers
//////////////////////////////////////////////////////////////////////

void LogFileModeOut(t_ostream &ros, ULONG LogFileMode)
{
// EVENT_TRACE_FILE_MODE_NONE          0x0000  // logfile is off
// EVENT_TRACE_FILE_MODE_SEQUENTIAL    0x0001  // log sequentially
// EVENT_TRACE_FILE_MODE_CIRCULAR      0x0002  // log in circular manner
// EVENT_TRACE_FILE_MODE_NEWFILE       0x0004  // log to new file if full
// EVENT_TRACE_REAL_TIME_MODE          0x0100  // real time mode on
// EVENT_TRACE_DELAY_OPEN_FILE_MODE    0x0200  // delay opening file
// EVENT_TRACE_BUFFERING_MODE          0x0400  // buffering mode only

	t_string tsOut;
	
	// @#$ENUM: says that we are not storing a literal value. 
	tsOut = _T("\"LogFileMode:@#$ENUM:");
	PutALine(ros, tsOut.c_str());
	bool bFirstOut = true;

	// Values we anticipate.
	if (LogFileMode == 0)
	{
		tsOut = _T("0");
		PutALine(ros, tsOut.c_str());
		bFirstOut = false;
	}
	if (LogFileMode & EVENT_TRACE_FILE_MODE_NONE)
	{
		tsOut = _T("EVENT_TRACE_FILE_MODE_NONE");
		PutALine(ros, tsOut.c_str());
		bFirstOut = false;
	}
	if (LogFileMode & EVENT_TRACE_FILE_MODE_SEQUENTIAL)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FILE_MODE_SEQUENTIAL");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut =  _T("|EVENT_TRACE_FILE_MODE_SEQUENTIAL");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FILE_MODE_CIRCULAR");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut =  _T("|EVENT_TRACE_FILE_MODE_CIRCULAR");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (LogFileMode & EVENT_TRACE_FILE_MODE_NEWFILE)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FILE_MODE_NEWFILE");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FILE_MODE_NEWFILE");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (LogFileMode & EVENT_TRACE_REAL_TIME_MODE)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_REAL_TIME_MODE");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_REAL_TIME_MODE");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (LogFileMode & EVENT_TRACE_DELAY_OPEN_FILE_MODE)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_DELAY_OPEN_FILE_MODE");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_DELAY_OPEN_FILE_MODE");
			PutALine(ros, tsOut.c_str());
		}
	}

	if (LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_PRIVATE_LOGGER_MODE");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_PRIVATE_LOGGER_MODE");
			PutALine(ros, tsOut.c_str());
		}
	}

	if (LogFileMode & EVENT_TRACE_BUFFERING_MODE)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_BUFFERING_MODE");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_BUFFERING_MODE");
			PutALine(ros, tsOut.c_str());
		}
	}
	
	// A value we did not anticipate.

	ULONG uExpected = 
		EVENT_TRACE_FILE_MODE_NONE | 
		EVENT_TRACE_FILE_MODE_SEQUENTIAL | 
		EVENT_TRACE_FILE_MODE_CIRCULAR |
		EVENT_TRACE_FILE_MODE_NEWFILE |
		EVENT_TRACE_REAL_TIME_MODE |
		EVENT_TRACE_DELAY_OPEN_FILE_MODE |
		EVENT_TRACE_BUFFERING_MODE | 
		EVENT_TRACE_PRIVATE_LOGGER_MODE;

	if ((uExpected | LogFileMode) != uExpected)
	{
		if (bFirstOut)
		{
			tsOut = _T("@#$UNKNOWNVALUE:0x");
			PutALine(ros, tsOut.c_str());
			PutAULONGVar(ros, ~uExpected & LogFileMode, true);
		}
		else
		{
			tsOut = _T("|@#$UNKNOWNVALUE:0x");
			PutALine(ros, tsOut.c_str());
			PutAULONGVar(ros, ~uExpected & LogFileMode, true);
		}
	}

	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());
}

void EnableFlagsOut(t_ostream &ros, ULONG EnableFlags)
{
// EVENT_TRACE_FLAG_PROCESS            0x00000001  // process start & end
// EVENT_TRACE_FLAG_THREAD             0x00000002  // thread start & end
// EVENT_TRACE_FLAG_IMAGE_LOAD         0x00000004  // image load

// EVENT_TRACE_FLAG_DISK_IO            0x00000100  // physical disk IO
// EVENT_TRACE_FLAG_DISK_FILE_IO       0x00000200  // requires disk IO

// EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS 0x00001000  // all page faults
// EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS 0x00002000  // hard faults only

// EVENT_TRACE_FLAG_NETWORK_TCPIP      0x00010000  // tcpip send & receive
//
// Pre-defined Enable flags for everybody else
//
// EVENT_TRACE_FLAG_PRIVATE            0xC0000000  // Private buffering
// EVENT_TRACE_FLAG_EXTENSION          0x80000000  // indicates more flags
// EVENT_TRACE_FLAG_FORWARD_WMI        0x40000000  // Can forward to WMI
// EVENT_TRACE_FLAG_ENABLE_RESERVE1    0x20000000  // Reserved
// EVENT_TRACE_FLAG_ENABLE_RESERVE2    0x10000000  // Reserved

	t_string tsOut;

	// @#$ENUM: says that we are not storing a literal value. 
	tsOut =  _T("\"EnableFlags:@#$ENUM:");
	PutALine(ros, tsOut.c_str());
	bool bFirstOut = true;

	if (EnableFlags == 0)
	{
		tsOut = _T("0");
		PutALine(ros, tsOut.c_str());
		bFirstOut = false;
	}
	if (EnableFlags & EVENT_TRACE_FLAG_PROCESS)
	{
		tsOut = _T("EVENT_TRACE_FLAG_PROCESS");
		PutALine(ros, tsOut.c_str());
		bFirstOut = false;
	}
	if (EnableFlags & EVENT_TRACE_FLAG_THREAD)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_THREAD");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_THREAD");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (EnableFlags & EVENT_TRACE_FLAG_THREAD)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_THREAD");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_THREAD");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (EnableFlags & EVENT_TRACE_FLAG_IMAGE_LOAD)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_IMAGE_LOAD");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_IMAGE_LOAD");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (EnableFlags & EVENT_TRACE_FLAG_DISK_IO)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_DISK_IO");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_DISK_IO");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (EnableFlags & EVENT_TRACE_FLAG_DISK_FILE_IO)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_DISK_FILE_IO");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_DISK_FILE_IO");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (EnableFlags & EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (EnableFlags & EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (EnableFlags & EVENT_TRACE_FLAG_NETWORK_TCPIP)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_NETWORK_TCPIP");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_NETWORK_TCPIP");
			PutALine(ros, tsOut.c_str());
		}
	}
#if 0
	if (EnableFlags & EVENT_TRACE_FLAG_PRIVATE)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_PRIVATE");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_PRIVATE");
			PutALine(ros, tsOut.c_str());
		}
	}
#endif
	if (EnableFlags & EVENT_TRACE_FLAG_EXTENSION)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_EXTENSION");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_EXTENSION");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (EnableFlags & EVENT_TRACE_FLAG_FORWARD_WMI)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_FORWARD_WMI");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_FORWARD_WMI");
			PutALine(ros, tsOut.c_str());
		}
	}
#if 0
	if (EnableFlags & EVENT_TRACE_FLAG_ENABLE_RESERVE1)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_ENABLE_RESERVE1");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_ENABLE_RESERVE1");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (EnableFlags & EVENT_TRACE_FLAG_ENABLE_RESERVE2)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_ENABLE_RESERVE2");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_ENABLE_RESERVE2");
			PutALine(ros, tsOut.c_str());
		}
	}
#endif
	ULONG uExpected = 
		EVENT_TRACE_FLAG_PROCESS | 
		EVENT_TRACE_FLAG_THREAD | 
		EVENT_TRACE_FLAG_IMAGE_LOAD |
		EVENT_TRACE_FLAG_DISK_IO |
		EVENT_TRACE_FLAG_DISK_FILE_IO |
		EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS |
		EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS | 
		EVENT_TRACE_FLAG_NETWORK_TCPIP | 
		EVENT_TRACE_FLAG_EXTENSION |
		EVENT_TRACE_FLAG_FORWARD_WMI;

	if ((uExpected | EnableFlags) != uExpected)
	{
		if (bFirstOut)
		{
			tsOut = _T("@#$UNKNOWNVALUE:0x");
			PutALine(ros, tsOut.c_str());
			PutAULONGVar(ros, ~uExpected & EnableFlags, true);
		}
		else
		{
			tsOut = _T("|@#$UNKNOWNVALUE:0x");
			PutALine(ros, tsOut.c_str());
			PutAULONGVar(ros, ~uExpected & EnableFlags, true);
		}
	}
	
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());
}

// "Wnode.Flags:@#$ENUM:WNODE_FLAG_ALL_DATA"
void WnodeFlagsOut(t_ostream &ros, ULONG WnodeFlags)
{
	t_string tsOut;

	// @#$ENUM: says that we are not storing a literal value. 
	tsOut =  _T("\"Wnode.Flags:@#$ENUM:");
	PutALine(ros, tsOut.c_str());
	bool bFirstOut = true;

	if (WnodeFlags & WNODE_FLAG_TRACED_GUID)
	{
		if (bFirstOut)
		{
			tsOut = _T("WNODE_FLAG_TRACED_GUID");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|WNODE_FLAG_TRACED_GUID");
			PutALine(ros, tsOut.c_str());
		}
	}

	ULONG uExpected = 
		WNODE_FLAG_TRACED_GUID;

	if ((uExpected | WnodeFlags) != uExpected)
	{
		if (bFirstOut)
		{
			tsOut = _T("@#$UNKNOWNVALUE:0x");
			PutALine(ros, tsOut.c_str());
			PutAULONGVar(ros, ~uExpected & WnodeFlags, true);
		}
		else
		{
			tsOut = _T("|@#$UNKNOWNVALUE:0x");
			PutALine(ros, tsOut.c_str());
			PutAULONGVar(ros, ~uExpected & WnodeFlags, true);
		}
	}
	
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

}

// We print out a GUID in the form:
//  "{0000cbd1-0011-11d0-0d00-00aa006d010a}"
// typedef struct _GUID
// {
//    DWORD  Data1;
//    WORD   Data2;
//    WORD   Data3;
//    BYTE   Data4[8];
// } GUID;
// Data4 specifies an array of 8 bytes. The first 2 bytes contain 
// the third group of 4 hexadecimal digits. The remaining 6 bytes 
// contain the final 12 hexadecimal digits.  We have separate
// logic for acsii and unicode for Data4.
void GUIDOut(t_ostream &ros, GUID Guid)
{
	t_string tsOut;
	t_strstream strStream;

	strStream << _T("{");
	
	strStream.fill(_T('0'));
	strStream.width(8);
	strStream.flags(ros.flags() | ios_base::right);

	strStream << hex << Guid.Data1;

	strStream << _T("-");

	strStream.width(4);

	strStream << hex << Guid.Data2;

	strStream << _T("-");

	strStream << hex << Guid.Data3;

	strStream << _T("-");

	// Data4 specifies an array of 8 bytes. The first 2 bytes contain 
	// the third group of 4 hexadecimal digits. The remaining 6 bytes 
	// contain the final 12 hexadecimal digits. 

#ifndef _UNICODE
	int i;

	strStream.width(1);

	BYTE Byte;
	int Int;
	for (i = 0; i < 2; i++)
	{
		Byte = Guid.Data4[i];
		Byte = Byte >> 4;
		Int = Byte;
		strStream <<  hex << Int;
		Byte = Guid.Data4[i];
		Byte = 0x0f & Byte;
		Int = Byte;
		strStream << hex << Int;
	}

	strStream << _T("-");

	strStream.width(1);


	for (i = 2; i < 8; i++)
	{
		BYTE Byte = Guid.Data4[i];
		Byte = Byte >> 4;
		Int = Byte;
		strStream << hex << Int;
		Byte = Guid.Data4[i];
		Byte = 0x0f & Byte;
		Int = Byte;
		strStream << hex << Int;
	}
#else
	int i;

	for (i = 0; i < 2; i++)
	{
		TCHAR tc = Guid.Data4[i];
		// For some reason the width is reset each time through the 
		// loop to be one.
		strStream.width(2);
		strStream << hex << tc;
	}

	strStream << _T("-");
	
	BYTE Byte;
	strStream.width(1);
	for (i = 2; i < 8; i++)
	{
		Byte = Guid.Data4[i];
		Byte = Byte >> 4;
		strStream << hex << Byte;
		Byte = Guid.Data4[i];
		Byte = 0x0f & Byte;
		strStream << hex << Byte;
	}
#endif

	strStream << _T("}");

	strStream >> tsOut;

	PutALine(ros, tsOut.c_str() , -1);
}

void LARGE_INTEGEROut(t_ostream &ros, LARGE_INTEGER Large)
{
	t_string tsOut;
	tsOut = _T("{0x");
	PutALine(ros, tsOut.c_str() , -1);

	LONG Long = Large.u.HighPart;
	PutALONGVar(ros, Large.u.HighPart,true);

	DWORD DWord = Large.u.LowPart;
	PutADWORDVar(ros, DWord);

	tsOut = _T("}");
	PutALine(ros, tsOut.c_str() , -1);
	
}

void InitializeTCHARVar(t_string &rtsValue , void *pVar)
{
	TCHAR **pTCHAR = reinterpret_cast<TCHAR **> (pVar);
	if (rtsValue.length() > 0)
	{
		// Null string.
		if (case_insensitive_compare(rtsValue,_T("@#$STRING_NULL")) == 0)
		{
			*pTCHAR = NULL;
		}
		// Empty string.
		else if (case_insensitive_compare(rtsValue,_T("@#$STRING_EMPTY")) == 0)
		{
			*pTCHAR = NewTCHAR(_T(""));
		}
		else // Just a string.
		{
			*pTCHAR = NewTCHAR(rtsValue.c_str());
		}
	}
	else // Empty string.
	{
		*pTCHAR = NewTCHAR(_T(""));
	}
}

//"EVENT_TRACE_FILE_MODE_NEWFILE|EVENT_TRACE_REAL_TIME_MODE|@#$UNKNOWNVALUE:0x20"
//"EVENT_TRACE_FLAG_IMAGE_LOAD|EVENT_TRACE_FLAG_DISK_IO|@#$UNKNOWNVALUE:0x20"
void InitializeEnumVar(t_string &rtsValue , void *pVar)
{
	ULONG *pULong = reinterpret_cast<ULONG *> (pVar);
	*pULong = 0;

	int nEndPos;
	int nBegPos = 0;
	int nSubstrLen;

	t_string tsTemp;

	CONSTMAP::iterator Iterator;

	bool bDone = false;

	while (!bDone)
	{
		nEndPos = rtsValue.find(_T("|"), nBegPos); 

		if (nEndPos == t_string::npos)
		{
			bDone = true;
			nEndPos = rtsValue.length();
		}

		nSubstrLen = nEndPos - nBegPos;

		tsTemp = rtsValue.substr(nBegPos, nSubstrLen);

		Iterator = g_ConstantMap.m_Map.find(tsTemp);

		if (Iterator == g_ConstantMap.m_Map.end())
		{
			// Had better be @#$UNKNOWNVALUE:0x
			if (tsTemp.compare(0, 18, _T("@#$UNKNOWNVALUE:0x")) == 0)
			{		
				tsTemp = rtsValue.substr(nBegPos + 18);
				ULONG ulTemp;
				InitializeULONGVar(tsTemp , (void *) &ulTemp, true);
				*pULong |= ulTemp;
			}

		}
		else
		{
			*pULong |= (*Iterator).second; 
		}

		nBegPos = nEndPos + 1;
	}


}

// Expect HANDLEs to be in the form 0xnnnnnnnn
void InitializeHandleVar(t_string &rtsValue , void *pVar)
{
	HANDLE *pHandle = reinterpret_cast<HANDLE *> (pVar);
	HANDLE handle;

	t_strstream strStream;

	t_string tsTemp;
	tsTemp = rtsValue.substr(2);
	
	strStream << tsTemp;

	strStream >> handle;

	*pHandle = handle;

}

void InitializeULONGVar(t_string &rtsValue , void *pVar, bool bHex )
{
	ULONG *pULong = reinterpret_cast<ULONG *> (pVar);

	ULONG uLong;

	t_strstream strStream;
	
	strStream << rtsValue;

	if (bHex)
	{
		strStream >> hex >> uLong;
	}
	else
	{
		strStream >> uLong;
	}


	*pULong = uLong;
}

void InitializeLONGVar(t_string &rtsValue , void *pVar)
{
	LONG *pLong = reinterpret_cast<LONG *> (pVar);
	LONG Long;

	t_strstream strStream;
	
	strStream << rtsValue;

	strStream >> Long;

	*pLong = Long;

}

t_istream &GetAChar(t_istream &ris,TCHAR &tc)
{
#ifndef _UNICODE
	tc = ris.get();
	return ris;
#else
	char *pChar = (char *) &tc;
	
	pChar[0] = ris.get();
	pChar[1] = ris.get();

	return ris;

#endif
}


// See note at top of this file to understand why we are not using
// formatted input.
// We are reading in a wide character file one byte at a time and
// creating our two byte characters from each two byte sequence.
t_istream &GetALine(t_istream &ris,TCHAR *tcBuffer, int nBufferSize)
{
#ifndef _UNICODE
	t_istream &r = ris.getline(tcBuffer,nBufferSize - 1,_T('\n'));
	// Docs for getline say that it sould eat the new line.  It does
	// not, and it does even worse.  It returns a 0x0d which we delete.
	// This should work even when getline does
	// what the docs say it will.
	int n = _tcsclen(tcBuffer) - 1;

	if (tcBuffer[n] == 0x0d)
	{
		tcBuffer[n] = _T('\0');
	}

	return r;
#else
	char *pChar = (char *) tcBuffer;
	bool bSkipNext = false;
	bool bEOL = false;
	int intIn1;
	int intIn2;
	int i = 0;
	int count = 0;
	while (1)
	{
		intIn1 = ris.get();
		if (ris.eof())
		{
			break;
		}
		intIn2 = ris.get();
		
		if (intIn1 == 0x0d && intIn2 == 0x0)
		{
			// Found 0x0d so eat the 0x0a.
			intIn1 = ris.get();
			intIn2 = ris.get();
			tcBuffer[i / 2] = _T('\0');
			break;
		}
		else 
		{
			pChar[i++] = intIn1;
			pChar[i++] = intIn2;
		}
	}

	if (i == 0)
	{
		tcBuffer[0] = _T('\0');
	}

	return ris;

#endif

}

// See note at top of this file to understand why we are not using
// formatted input.
// We are writing out a wide character file one byte at a time.
// nBufferSize is the number of TCHARS not size in bytes.
// if nBufferSize == -1 tcBuffer better be a null terminated string.
// Will handle a unicode string with "proper" and "inproper" newlines. 
t_ostream &PutALine(t_ostream &ros,const TCHAR *tcBuffer, int nBufferSize)
{
#ifndef _UNICODE
//	return ros << tcBuffer;
	const char *pBuffer =  tcBuffer;
	int nSize = nBufferSize;
	if (nBufferSize == -1)
	{
		nSize = _tcsclen(tcBuffer);
	}

	for (int i = 0; i < nSize; i++)
	{
		int intOut = pBuffer[i];
		if (intOut == 0x0a && pBuffer[i - 1] != 0x0d)
		{
			ros.put(0x0d);
		}
		ros.put(intOut);
	}
	
	return ros;
#else
	char *pBuffer = (char *) tcBuffer;
	int nSize = nBufferSize;
	if (nBufferSize == -1)
	{
		nSize = _tcsclen(tcBuffer);
	}

	for (int i = 0; i < nSize * 2; i++)
	{
		int intOut = pBuffer[i];
		if (intOut == 0x0a && pBuffer[i - 2] != 0x0d)
		{
			ros.put(0x0d);
			ros.put(0x0);
		}
		ros.put(intOut);
	}
	
	return ros;
#endif

}

// Hex flavor not tested for non-unicode.
t_ostream &PutALONGVar(t_ostream &ros, LONG l, bool bHex)
{
#ifndef _UNICODE
	if (bHex)
	{
		TCHAR f = ros.fill(_T('0'));
		int w = ros.width(8);
		int fl =	ros.flags(ros.flags() | ios_base::right);
		ros << hex << l;
		ros.fill(f);
		ros.width(w);
		ros.flags(fl);

		return ros << dec;
	}
	else
	{
		return ros << l;
	}
#else

	t_string tsTemp;
	t_strstream strStream;
	
	if (bHex)
	{
		strStream.width(8);
		strStream.fill('0');
		strStream.flags(ios_base::right);
		strStream << hex << l;
	}
	else
	{
		strStream << l;
	}

	strStream >> tsTemp;

	PutALine(ros, tsTemp.c_str() , -1);

	return ros;
#endif
}

t_ostream &PutAULONG64Var(t_ostream &ros, ULONG64 ul64)
{
	ULONG *lArray = (ULONG *) &ul64;
	PutAULONGVar( ros, lArray[0], true);
	PutAULONGVar( ros, lArray[1], true);
	return ros;
}

t_ostream &PutAULONGVar(t_ostream &ros, ULONG ul, bool bHex)
{
#ifndef _UNICODE
	if (bHex)
	{
		TCHAR f = ros.fill(_T('0'));
		int w = ros.width(8);
		int fl =	ros.flags(ros.flags() | ios_base::right);
		ros << hex << ul;
		ros.fill(f);
		ros.width(w);
		ros.flags(fl);

		return ros << dec;
	}
	else
	{
		return ros << ul;
	}
#else

	t_string tsTemp;
	t_strstream strStream;

	if (bHex)
	{
		strStream.width(8);
		strStream.fill('0');
		strStream.flags(ios_base::right);
		strStream << hex << ul;
	}
	else
	{
		strStream << ul;
	}

	strStream >> tsTemp;

	PutALine(ros, tsTemp.c_str() , -1);

	return ros;
#endif
}

t_ostream &PutADWORDVar(t_ostream &ros, DWORD dw)
{
#ifndef _UNICODE
	TCHAR f = ros.fill(_T('0'));
	int w = ros.width(8);
	int fl =	ros.flags(ros.flags() | ios_base::right);
	ros << hex << dw;
	ros.fill(f);
	ros.width(w);
	ros.flags(fl);

	return ros << dec;
#else

	t_string tsTemp;
	t_strstream strStream;
	
	strStream.width(8);
	strStream.fill('0');
	strStream.flags(ios_base::right);
	strStream << hex << dw;
	
	strStream >> tsTemp;

	PutALine(ros, tsTemp.c_str() , -1);

	return ros;
#endif
}


void InitializeGUIDVar(t_string &rtsValue , void *pVar)
{
	GUID *pGUID = reinterpret_cast<GUID *> (pVar);
	if (rtsValue.length() > 0 && case_insensitive_compare(rtsValue,_T("@#$NA")) != 0)
	{
		wGUIDFromString(rtsValue.c_str(), pGUID);
	}
	else
	{
		RtlZeroMemory(pGUID, sizeof(GUID));
	}


}

// *** Following routine copied from WMI\MofCheck. to convert 
// a guid string to a GUID. 
// The routines below were blantenly stolen without remorse from the ole
// sources in \nt\private\ole32\com\class\compapi.cxx. They are copied here
// so that WMI doesn't need to load in ole32 only to convert a guid string
// into its binary representation.
//


//+-------------------------------------------------------------------------
//
//  Function:   HexStringToDword   (private)
//
//  Synopsis:   scan lpsz for a number of hex digits (at most 8); update lpsz
//              return value in Value; check for chDelim;
//
//  Arguments:  [lpsz]    - the hex string to convert
//              [Value]   - the returned value
//              [cDigits] - count of digits
//
//  Returns:    TRUE for success
//
//--------------------------------------------------------------------------

BOOL HexStringToDword(LPCTSTR lpsz, DWORD * RetValue,
                             int cDigits, WCHAR chDelim)
{
    int Count;
    DWORD Value;

    Value = 0;
    for (Count = 0; Count < cDigits; Count++, lpsz++)
    {
        if (*lpsz >= '0' && *lpsz <= '9')
            Value = (Value << 4) + *lpsz - '0';
        else if (*lpsz >= 'A' && *lpsz <= 'F')
            Value = (Value << 4) + *lpsz - 'A' + 10;
        else if (*lpsz >= 'a' && *lpsz <= 'f')
            Value = (Value << 4) + *lpsz - 'a' + 10;
        else
            return(FALSE);
    }
    *RetValue = Value;

    if (chDelim != 0)
        return *lpsz++ == chDelim;
    else
        return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   wUUIDFromString    (internal)
//
//  Synopsis:   Parse UUID such as 00000000-0000-0000-0000-000000000000
//
//  Arguments:  [lpsz]  - Supplies the UUID string to convert
//              [pguid] - Returns the GUID.
//
//  Returns:    TRUE if successful
//
//--------------------------------------------------------------------------
BOOL wUUIDFromString(LPCTSTR lpsz, LPGUID pguid)
{
        DWORD dw;

        if (!HexStringToDword(lpsz, &pguid->Data1, sizeof(DWORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(DWORD)*2 + 1;

        if (!HexStringToDword(lpsz, &dw, sizeof(WORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(WORD)*2 + 1;

        pguid->Data2 = (WORD)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(WORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(WORD)*2 + 1;

        pguid->Data3 = (WORD)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[0] = (BYTE)dw;
        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, '-'))
                return FALSE;
        lpsz += sizeof(BYTE)*2+1;

        pguid->Data4[1] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[2] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[3] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[4] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[5] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[6] = (BYTE)dw;
        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[7] = (BYTE)dw;

        return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   wGUIDFromString    (internal)
//
//  Synopsis:   Parse GUID such as {00000000-0000-0000-0000-000000000000}
//
//  Arguments:  [lpsz]  - the guid string to convert
//              [pguid] - guid to return
//
//  Returns:    TRUE if successful
//
//--------------------------------------------------------------------------
BOOL wGUIDFromString(LPCTSTR lpsz, LPGUID pguid)
{
    if (*lpsz == '{' )
        lpsz++;
    if(wUUIDFromString(lpsz, pguid) != TRUE)
        return FALSE;

    lpsz +=36;

    if (*lpsz == '}' )
        lpsz++;

    if (*lpsz != '\0')   // check for zero terminated string - test bug #18307
    {
       return FALSE;
    }

    return TRUE;
}

int case_insensitive_compare(t_string &r1, t_string &r2)
{

	t_string tsTemp1;
	t_string tsTemp2;
	tsTemp1 = r1.c_str();
	tsTemp2 = r2.c_str();

	int i;
	for (i = 0; i < tsTemp1.length(); i++)
	{
		tsTemp1.replace(i,1,1, toupper(tsTemp1[i]));
	}

	for (i = 0; i < tsTemp2.length(); i++)
	{
		tsTemp2.replace(i,1,1, toupper(tsTemp2[i]));
	}

	return tsTemp1.compare(tsTemp2);
}

int case_insensitive_compare(TCHAR *p, t_string &r2)
{ 
	if (p == NULL)
	{
		return -1;
	}

	t_string tsTemp; 
	tsTemp = p; 
	return case_insensitive_compare(tsTemp, r2);
}

int case_insensitive_compare(t_string &r1,TCHAR *p )
{ 
	if (p == NULL)
	{
		return 1;
	}

	t_string tsTemp; 
	tsTemp = p; 
	return case_insensitive_compare(r1, tsTemp);
}

int case_insensitive_compare(TCHAR *p1,TCHAR *p2)
{
	if (!p1 && !p2)
	{
		return 0;
	}
	else if (!p1)
	{
		return -1;
	} else if (!p2)
	{
		return 1;
	}

	int l1 = _tcslen(p1);
	int l2 = _tcslen(p2);

	return (_tcsnicmp(p1,p2,_MIN(l1,l2)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\umtrprov\readfile.cpp ===
#define _UNICODE
#define UNICODE

#include "stdafx.h"

#pragma warning (disable : 4786)
#pragma warning (disable : 4275)

#include <iostream>
#include <strstream>
#include <fstream>
#include <string>
#include <sstream>
#include <map>
#include <list>


using namespace std;


#include <tchar.h>
#include <process.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>

#include <WTYPES.H>

/*

#include "stdafx.h"

#include <string>
#include <iosfwd> 
#include <iostream>
#include <fstream>
#include <ctime>
#include <list>
using namespace std;
#include <malloc.h>
#include <windows.h>


#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <tchar.h>
#include <wmistr.h>
#include <objbase.h>
#include <initguid.h>
#include <evntrace.h>
*/
#include "struct.h"
#include "utils.h"
#include "Readfile.h"
#include "main.h"





FILE *FileP;


LPGUID ControlGuid;

ULONG
ReadInputFile(LPTSTR InputFile, PREGISTER_TRACE_GUID RegisterTraceGuid)
{

	TCHAR *String;

	String = (TCHAR *) malloc( MAX_STR*sizeof(TCHAR) );
	String = (TCHAR *) malloc(100);
	if (InputFile == NULL )
		return 1;

	FileP = _tfopen(InputFile, _T("r"));
	if (FileP== NULL )
		return 1;

	//Now Read MofImagePath
	if( !ReadString ( (TCHAR *)RegisterTraceGuid->MofImagePath, MAX_STR) )
	{
		//Log here and then return
		return 1;
	}
	if ( !_tcsicmp(RegisterTraceGuid->MofImagePath, _T("NULL")  ))
		RegisterTraceGuid->MofImagePath = (TCHAR *) 0;

	//Now Read MofResourceName
	if( !ReadString ( (TCHAR *)RegisterTraceGuid->MofResourceName, MAX_STR) )
	{
		//Log here and then return
		return 1;
	}
	if ( !_tcsicmp(RegisterTraceGuid->MofResourceName, _T("NULL")  ))
		RegisterTraceGuid->MofResourceName = (TCHAR *) 0;

	//Now Read Call backfunction...
	if( !ReadString ( (TCHAR *)String, MAX_STR) )
	{	
		//This is optional input so can return success if it is not present
		return 0;
	}
	if ( !_tcsicmp(String, _T("NULL")  ))
		RegisterTraceGuid->CallBackFunction = (PVOID) 0;

	//Now Read TraceGuidReg.
	if( !ReadString ( (TCHAR *)String, MAX_STR) )
	{
		//This is optional input so can return success if it is not present
		return 0;
	}
	if ( !_tcsicmp(String, _T("NULL")  ))
		RegisterTraceGuid->TraceGuidReg = (PTRACE_GUID_REGISTRATION) 0;

	//Now Read Registration Handle.
	if( !ReadString ( (TCHAR *)String, MAX_STR) )
	{
		//This is optional input so can return success if it is not present
		return 0;
	}
	if ( !_tcsicmp(String, _T("NULL")  ))
		RegisterTraceGuid->RegistrationHandle = (PTRACEHANDLE) 0;

	//Now Read GuidCount
	//GuidCome will come from main process..But to test 0, this is required.
	if( !ReadString ( (TCHAR *)String, MAX_STR) )
	{
		//This is optional input so can return success if it is not present
		return 0;
	}
	if ( !_tcsicmp(String, _T("0000")  ))
		RegisterTraceGuid->GuidCount = 0;

	//Now Read Handle for  UnregisterTraceGuid
	if( !ReadString ( (TCHAR *)String, MAX_STR) )
	{
		//This is optional input so can return success if it is not present
		return 0;
	}
	if ( !_tcsicmp(String, _T("NULL")  ))
		RegisterTraceGuid->UnRegistrationHandle = (PTRACEHANDLE) 0;


	//Now Read Handle for  GetTraceLoggerHandle
	if( !ReadString ( (TCHAR *)String, MAX_STR) )
	{
		//This is optional input so can return success if it is not present
		return 0;
	}
	if ( !_tcsicmp(String, _T("NULL")  ))
		RegisterTraceGuid->GetTraceLoggerHandle = (PTRACEHANDLE) 0;

	//Now Read Handle for  GetTraceEnableLevel
	if( !ReadString ( (TCHAR *)String, MAX_STR) )
	{
		//This is optional input so can return success if it is not present
		return 0;
	}
	if ( !_tcsicmp(String, _T("NULL")  ))
		RegisterTraceGuid->GetTraceEnableLevel = (PTRACEHANDLE) 0;


	//Now Read Handle for  GetTraceEnableFlags
	if( !ReadString ( (TCHAR *)String, MAX_STR) )
	{
		//This is optional input so can return success if it is not present
		return 0;
	}
	if ( !_tcsicmp(String, _T("NULL")  ))
		RegisterTraceGuid->GetTraceEnableFlag = (PTRACEHANDLE) 0;

	//Now Read Handle for  UnregisterTraceGuid
	if( !ReadString ( (TCHAR *)String, MAX_STR) )
	{
		//This is optional input so can return success if it is not present
		return 0;
	}
	if ( !_tcsicmp(String, _T("NULL")  ))
		RegisterTraceGuid->TraceHandle = (PTRACEHANDLE) 0;


	//Now Read if Guid Ptr is TRUE
	if( !ReadString ( (TCHAR *)String, MAX_STR) )
	{
		//This is optional input so can return success if it is not present
		return 0;
	}
	if ( !_tcsicmp(String, _T("USE_GUID_PTR")  ))
		RegisterTraceGuid->UseGuidPtrFlag = 1;

		//Now Read if Mof Ptr is TRUE
	if( !ReadString ( (TCHAR *)String, MAX_STR) )
	{
		//This is optional input so can return success if it is not present
		return 0;
	}
	if ( !_tcsicmp(String, _T("USE_MOF_PTR")  ))
		RegisterTraceGuid->UseMofPtrFlag = 1;

	fclose( FileP );
	return 0;
}

BOOLEAN
ReadGuid( LPGUID Guid )
{

	TCHAR Temp[100];
	TCHAR arg[100];
	ULONG i;

	if( _fgetts(Temp, 100, FileP) != NULL )
	{
		_tcsncpy(arg, Temp, 37);
		arg[8] = 0;
		Guid->Data1 = ahextoi(arg);

		_tcsncpy(arg, &Temp[9], 4);
		arg[4] = 0;
		Guid->Data2 = (USHORT) ahextoi(arg);

		_tcsncpy(arg, &Temp[14], 4);
		arg[4] = 0;
		Guid->Data3 = (USHORT) ahextoi(arg);
		

        for (i=0; i<2; i++) 
		{
			_tcsncpy(arg, &Temp[19 + (i*2)], 2);
            arg[2] = 0;
            Guid->Data4[i] = (UCHAR) ahextoi(arg);
        }
        for (i=2; i<8; i++) 
		{
            _tcsncpy(arg, &Temp[20 + (i*2)], 2);
            arg[2] = 0;
            Guid->Data4[i] = (UCHAR) ahextoi(arg);
        }

	return true;
	}
	return false;
}

BOOLEAN
ReadUlong( ULONG *GuidCount)
{
	TCHAR Temp[100];

	if( _fgetts(Temp, 100, FileP) != NULL )
	{
		RemoveComment( Temp);
		Temp[4] = 0;
		*GuidCount = ahextoi(Temp);
		return true;
	}
	return false;
}


BOOLEAN
ReadString( TCHAR *String, ULONG StringLength)
{
	if( _fgetts(String, StringLength, FileP) != NULL)
	{
		RemoveComment( String);
		return true;
	}
	else
		return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\umtrprov\structurewrappers.h ===
// StructureWrappers.h: interface for the CStructureWrappers class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_STRUCTUREWRAPPERS_H__138A24E0_ED34_11D2_804A_009027345EE2__INCLUDED_)
#define AFX_STRUCTUREWRAPPERS_H__138A24E0_ED34_11D2_804A_009027345EE2__INCLUDED_


#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class CPersistor;
class CEventTraceProperties;

// Need to be declared before seen in class.  Well, duh!
t_ostream& operator<<
	(t_ostream &ros,const CEventTraceProperties &r);
t_istream& operator>>
	(t_istream &ris,CEventTraceProperties &r);


// The general methodology used here may seem clunky to
// a C programmer.  
// If you want to serialize an existing
// EVENT_TRACE_PROPERTIES instance use the Constructor
// "CEventTraceProperties(PEVENT_TRACE_PROPERTIES pProps)"
// to create a CEventTraceProperties instance, call
// Persist, and then destroy the CEventTraceProperties
// instance.
// If you want to de-deserialize an instance call the 
// Constructor "CEventTraceProperties()", call Persist,
// call GetEventTracePropertiesInstance, then destroy the
// CEventTraceProperties instance.
// The copy constructor and assignment operators are included
// only for completeness and it is anticipated that they
// will not be used.
// Using Persist for de-serialization assumes you have a valid
// stream which contains a serialized instance.   
class CEventTraceProperties 
{
private:
	friend t_ostream& operator<<
		(t_ostream &ros,const CEventTraceProperties &r);
	friend t_istream& operator>>
		(t_istream &ris,CEventTraceProperties &r);
	friend class CPersistor;

public:
	CEventTraceProperties();
	// This constructor creates a new EVENT_TRACE_PROPERTIES 
	// instance.
	CEventTraceProperties(PEVENT_TRACE_PROPERTIES pProps);
	virtual ~CEventTraceProperties();

	CEventTraceProperties(CEventTraceProperties &rhs);
	CEventTraceProperties &CEventTraceProperties::operator=
					(CEventTraceProperties &rhs);

	virtual HRESULT Persist (CPersistor &rPersistor);
	bool DeSerializationOK() {return m_bDeSerializationOK;}

	// Constructs an new EVENT_TRACE_PROPERTIES instance and
	// returns it.
	PEVENT_TRACE_PROPERTIES GetEventTracePropertiesInstance();
	bool IsNULL() {return m_bIsNULL;}

protected:
	bool m_bDeSerializationOK;
	bool m_bIsNULL;
	void Initialize(PEVENT_TRACE_PROPERTIES pProps);
	void InitializeMemberVar(TCHAR *ptszValue, int nVar);
	void *m_pVarArray[19];


	PEVENT_TRACE_PROPERTIES m_pProps;



};

#endif // !defined(AFX_STRUCTUREWRAPPERS_H__138A24E0_ED34_11D2_804A_009027345EE2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\umtrprov\structurewrappers.cpp ===
// StructureWrappers.cpp: implementation of the CStructureWrappers class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#pragma warning (disable : 4786)
#pragma warning (disable : 4275)

#include <iosfwd> 
#include <iostream>
#include <fstream>
#include <string>
#include <map>
#include <list>


using namespace std;

#include <malloc.h>
#include <tchar.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>

#include <WTYPES.H>
#include "t_string.h"
#include "Utilities.h"

#include "Persistor.h"

#include "StructureWrappers.h"
#include "StructureWapperHelpers.h"
#include "ConstantMap.h"


//////////////////////////////////////////////////////////////////////
// Wrappers that serialize and de-serialize Event Tracing Data 
// Structures.
//////////////////////////////////////////////////////////////////////
#define MAX_LINE 1024

static TCHAR g_tcNl = _T('\n');
static TCHAR g_tcCR = 0x0d;
static TCHAR g_tcLF = 0x0a;

#ifdef _UNICODE
static TCHAR g_tcDQuote[] = _T("\"");
static TCHAR g_atcNL[] = {0x0d, 0x0a, 0x00};
#else
static TCHAR g_atcNL[] = {g_tcNl};
static TCHAR g_tcDQuote = _T('"');
#endif

CConstantMap g_ConstantMap;

//////////////////////////////////////////////////////////////////////
// _EVENT_TRACE_PROPERTIES
//////////////////////////////////////////////////////////////////////

CEventTraceProperties::CEventTraceProperties()
{
	m_pProps = NULL;
	m_bIsNULL = true;
}

CEventTraceProperties::CEventTraceProperties
(PEVENT_TRACE_PROPERTIES pProps)
{
	Initialize(pProps);
}

CEventTraceProperties::~CEventTraceProperties()
{
	if (m_pProps)
	{
		free(m_pProps->LogFileName);
		m_pProps->LogFileName = NULL;
		free(m_pProps->LoggerName);
		m_pProps->LoggerName = NULL;
		free(m_pProps);
		m_pProps = NULL;
	}
	m_bIsNULL = true;

}

CEventTraceProperties::CEventTraceProperties(CEventTraceProperties &rhs)
{
	Initialize(rhs.m_pProps);

}

CEventTraceProperties &CEventTraceProperties::operator=
(CEventTraceProperties &rhs)
{
	if ( this != &rhs ) 
	{
    	delete this;
    	
		Initialize(rhs.m_pProps);
    }
    
	return *this;

}
#if 0
"_EVENT_TRACE_PROPERTIES Instance Begin"
"BufferSize:ULONG:32"
"MinimunBuffers:ULONG:2"
"MaximunBuffers:ULONG:3"
"MaximunFileSize:ULONG:4"
"LogFileMode:@#$ENUM:EVENT_TRACE_FILE_MODE_NEWFILE|EVENT_TRACE_REAL_TIME_MODE|@#$UNKNOWNVALUE:0x20"
"FlushTimer:ULONG:6"
"EnableFlags:@#$ENUM:EVENT_TRACE_FLAG_IMAGE_LOAD|EVENT_TRACE_FLAG_DISK_IO|@#$UNKNOWNVALUE:20"
"NumberOfBuffers:ULONG:8"
"FreeBuffers:ULONG:9"
"EventsLost:ULONG:10"
"BuffersWritten:ULONG:11"
"LogBuffersLost:ULONG:12"
"RealTimeBuffersLost:ULONG:13"
"AgeLimit:LONG:-14"
"LoggerThreadId:HANDLE:0000000F"
"LogFileName:TCHAR*:Log file name"
"LoggerName:TCHAR*:Logger name"
"_EVENT_TRACE_PROPERTIES Instance End"
#endif
void CEventTraceProperties::InitializeMemberVar(TCHAR *tcBuffer, int nVar)
{

	int nDebug = 0;
	if (nVar == 17 || nVar == 18)
	{
		nDebug = nVar;
	}

	t_string tsTemp;
	
	tsTemp = tcBuffer;

	int nPos = tsTemp.find(_T(":"), 0);

	// The first character in the type.
	int nPosType = nPos + 1;

	if (nPos == t_string::npos)
	{
		m_bDeSerializationOK = false;
		return;
	}

	nPos = tsTemp.find(_T(":"), nPos + 1);
	
	t_string tsType;

	tsType = tsTemp.substr(nPosType,nPos - nPosType);

	// The first chatacter in the value.
	++nPos;

	t_string tsValue;
	tsValue = tsTemp.substr(nPos, (tsTemp.length() - nPos) - 1);

	// a TCHAR * value
	if (tsType.compare(_T("TCHAR*")) == 0)
	{
		InitializeTCHARVar(tsValue ,m_pVarArray[nVar]);
	}
	// A #define value
	else if (tsType.compare(_T("@#$ENUM")) == 0)
	{
		InitializeEnumVar(tsValue , m_pVarArray[nVar]);
	}
	// A HEX
	else if (tsType.compare(_T("HANDLE")) == 0)
	{
		InitializeHandleVar(tsValue , m_pVarArray[nVar]);
	}
	// An unsigned value
	else if (tsType.compare(_T("ULONG")) == 0)
	{
		InitializeULONGVar(tsValue , m_pVarArray[nVar]);
	}
	// A long value
	else if (tsType.compare(_T("LONG")) == 0)
	{
		InitializeLONGVar(tsValue , m_pVarArray[nVar]);
	}
	// A long value
	else if (tsType.compare(_T("GUID")) == 0)
	{
		InitializeGUIDVar(tsValue , m_pVarArray[nVar]);
	}

}

void CEventTraceProperties::Initialize
(PEVENT_TRACE_PROPERTIES pProps)
{
	m_bDeSerializationOK = true;
	if (pProps == NULL)
	{
		m_pProps = NULL;
		m_bIsNULL = true;
	}

	m_pProps = (EVENT_TRACE_PROPERTIES *) malloc (sizeof(EVENT_TRACE_PROPERTIES));
	RtlZeroMemory(m_pProps, sizeof(EVENT_TRACE_PROPERTIES));
	*m_pProps = *pProps;
	
	m_pProps -> LogFileName = pProps -> LogFileName ? 
								NewTCHAR(pProps -> LogFileName) :
								NULL;
	m_pProps -> LoggerName = pProps -> LoggerName ?
								NewTCHAR(pProps -> LoggerName) :
								NULL;

	m_pProps -> Wnode.BufferSize = sizeof(*m_pProps);

	m_bIsNULL = false;

}

PEVENT_TRACE_PROPERTIES 
CEventTraceProperties::GetEventTracePropertiesInstance()
{
	if (m_pProps == NULL)
	{
		return NULL;
	}

	EVENT_TRACE_PROPERTIES *pProps = 
		(EVENT_TRACE_PROPERTIES *) malloc (sizeof(EVENT_TRACE_PROPERTIES));
	RtlZeroMemory(pProps, sizeof(EVENT_TRACE_PROPERTIES));

	*pProps = *m_pProps;
	
	pProps -> LogFileName = m_pProps -> LogFileName ? 
								NewTCHAR(m_pProps -> LogFileName) :
								NULL;
	pProps -> LoggerName = m_pProps -> LoggerName ?
								NewTCHAR(m_pProps -> LoggerName) :
								NULL;
	int n1 = sizeof(*pProps);
	int n2 = sizeof(EVENT_TRACE_PROPERTIES);

	pProps -> Wnode.BufferSize = sizeof(*pProps);
	
	return pProps;
}

HRESULT CEventTraceProperties::Persist (CPersistor &rPersistor)
{
	if (rPersistor.IsLoading())
	{
		rPersistor.Stream() >> *this;
	}
	else
	{
		rPersistor.Stream() << *this;
	}

	return S_OK;

}

t_ostream& operator<<(t_ostream &ros, const CEventTraceProperties &r)
{
	t_string tsOut;

	tsOut = _T("\"_EVENT_TRACE_PROPERTIES Instance Begin\"\n");
	PutALine(ros, tsOut.c_str());

// "Wnode.Guid:GUID:{0000cbd1-0011-11d0-0d00-00aa006d010a}"
// "Wnode.Flags:@#$ENUM:WNODE_FLAG_ALL_DATA"

	tsOut = _T("\"Wnode.Guid:GUID:");
	PutALine(ros, tsOut.c_str());
	GUIDOut(ros, r.m_pProps -> Wnode.Guid);
	tsOut = g_tcDQuote;
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

	WnodeFlagsOut(ros, r.m_pProps -> Wnode.Flags);

	tsOut = _T("\"BufferSize:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> BufferSize);
	tsOut = g_tcDQuote;
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

	tsOut = _T("\"MinimunBuffers:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> MinimumBuffers);
	tsOut = g_tcDQuote;
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

	tsOut = _T("\"MaximunBuffers:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> MaximumBuffers);
	tsOut = g_tcDQuote;
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

	tsOut = _T("\"MaximunFileSize:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> MaximumFileSize);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

	LogFileModeOut(ros, r.m_pProps -> LogFileMode );

	tsOut = _T("\"FlushTimer:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> FlushTimer);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

	EnableFlagsOut(ros,r.m_pProps -> EnableFlags);

//	ros << _T("\"NumberOfBuffers:ULONG:") << r.m_pProps -> NumberOfBuffers << g_tcDQuote << g_atcNL;

	tsOut = _T("\"NumberOfBuffers:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> NumberOfBuffers);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

//	ros << _T("\"FreeBuffers:ULONG:") << r.m_pProps -> FreeBuffers << g_tcDQuote << g_atcNL;

	tsOut = _T("\"FreeBuffers:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> FreeBuffers);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

//	ros << _T("\"EventsLost:ULONG:") << r.m_pProps -> EventsLost << g_tcDQuote << g_atcNL;

	tsOut = _T("\"EventsLost:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> EventsLost);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

//	ros << _T("\"BuffersWritten:ULONG:") << r.m_pProps -> BuffersWritten << g_tcDQuote << g_atcNL;

	tsOut = _T("\"BuffersWritten:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> BuffersWritten);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

//	ros << _T("\"LogBuffersLost:ULONG:") << r.m_pProps -> LogBuffersLost << g_tcDQuote << g_atcNL;

	tsOut = _T("\"LogBuffersLost:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> LogBuffersLost);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());


//	ros << _T("\"RealTimeBuffersLost:ULONG:") << r.m_pProps -> RealTimeBuffersLost << g_tcDQuote <<g_atcNL;

	tsOut = _T("\"RealTimeBuffersLost:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> RealTimeBuffersLost);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());
	
	
//	ros << _T("\"AgeLimit:LONG:") << r.m_pProps -> AgeLimit << g_tcDQuote <<g_atcNL;

	tsOut = _T("\"AgeLimit:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutALONGVar(ros, r.m_pProps -> AgeLimit);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

	// Handles are in hex.
//	ros << _T("\"LoggerThreadId:HANDLE:0x") << r.m_pProps -> LoggerThreadId << g_tcDQuote <<g_atcNL;

	tsOut = _T("\"LoggerThreadId:HANDLE:0x");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, (ULONG) r.m_pProps -> LoggerThreadId, true);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

//	ros << _T("\"LogFileName:TCHAR*:") << r.m_pProps -> LogFileName << g_tcDQuote <<g_atcNL;

	tsOut = _T("\"LogFileName:TCHAR*:");
	if (r.m_pProps -> LogFileName)
	{
		tsOut += r.m_pProps -> LogFileName;
	}
	tsOut += g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

//	ros << _T("\"LoggerName:TCHAR*:") << r.m_pProps -> LoggerName << g_tcDQuote <<g_atcNL;

	tsOut = _T("\"LoggerName:TCHAR*:");
	if (r.m_pProps -> LoggerName)
	{
		tsOut += r.m_pProps -> LoggerName;
	}
	tsOut += g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

	tsOut = _T("\"_EVENT_TRACE_PROPERTIES Instance End\"\n");
	PutALine(ros, tsOut.c_str());

	return ros;
}

t_istream& operator>>(t_istream &ris,CEventTraceProperties &r)
{
	r.m_bDeSerializationOK = true;

	// We are doing line oriented serailization and assume that
	// a line in the stream is 1024 or less TCHARS.
	TCHAR *ptcBuffer = (TCHAR *) malloc(MAX_LINE * sizeof(TCHAR));

	GetALine(ris, ptcBuffer,MAX_LINE);


	if (_tcscmp(ptcBuffer,_T("\"_EVENT_TRACE_PROPERTIES Instance NULL\"")) == 0)
	{
		r.~CEventTraceProperties();
		r.m_bDeSerializationOK = false;

		free(ptcBuffer);
		return ris;
	}

	if (_tcscmp(ptcBuffer,_T("\"_EVENT_TRACE_PROPERTIES Instance Begin\"")) != 0)
	{
		r.m_bDeSerializationOK = false;

		free(ptcBuffer);

		return ris;
	}

	r.~CEventTraceProperties();

	r.m_pProps = (EVENT_TRACE_PROPERTIES *) malloc (sizeof(EVENT_TRACE_PROPERTIES));
	RtlZeroMemory(r.m_pProps, sizeof(EVENT_TRACE_PROPERTIES));

	r.m_pProps->Wnode.BufferSize = sizeof(EVENT_TRACE_PROPERTIES);

// "Wnode.Guid:GUID:{0000cbd1-0011-11d0-0d00-00aa006d010a}"
// "Wnode.Flags:@#$ENUM:WNODE_FLAG_ALL_DATA"

	r.m_pVarArray[0] = &r.m_pProps->Wnode.Guid;
	r.m_pVarArray[1] = &r.m_pProps->Wnode.Flags;
	r.m_pVarArray[2] = &r.m_pProps->BufferSize;
	r.m_pVarArray[3] = &r.m_pProps->MinimumBuffers;
	r.m_pVarArray[4] = &r.m_pProps->MaximumBuffers;
	r.m_pVarArray[5] = &r.m_pProps->MaximumFileSize;
	r.m_pVarArray[6] = &r.m_pProps->LogFileMode;
	r.m_pVarArray[7] = &r.m_pProps->FlushTimer;
	r.m_pVarArray[8] = &r.m_pProps->EnableFlags;
	r.m_pVarArray[9] = &r.m_pProps->NumberOfBuffers;
	r.m_pVarArray[10] = &r.m_pProps->FreeBuffers;
	r.m_pVarArray[11] = &r.m_pProps->EventsLost;
	r.m_pVarArray[12] = &r.m_pProps->BuffersWritten;
	r.m_pVarArray[13] = &r.m_pProps->LogBuffersLost;
	r.m_pVarArray[14] = &r.m_pProps->RealTimeBuffersLost;
	r.m_pVarArray[15] = &r.m_pProps->AgeLimit;
	r.m_pVarArray[16] = &r.m_pProps->LoggerThreadId;
	r.m_pVarArray[17] = &r.m_pProps->LogFileName;
	r.m_pVarArray[18] = &r.m_pProps->LoggerName;


	int n = 0;
	while (n < 19 && GetALine(ris,ptcBuffer,MAX_LINE))
	{
		r.InitializeMemberVar(ptcBuffer,n++);
	}

	// Consume end of Props
	GetALine(ris,ptcBuffer,MAX_LINE);

	free(ptcBuffer);

	BOOL bHeapGood = HeapValidate(GetProcessHeap(), 0, NULL);

	return ris;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\umtrprov\umprovider.h ===
#ifndef _MAIN_H
#define _MAIN_H


#include "t_string.h"
#include "Utilities.h"
#include "Persistor.h"
#include "StructureWrappers.h"
#include "StructureWapperHelpers.h"
//#include "ConstantMap.h" 
//#include "TCOData.h"
#include "Logger.h"
//#include "Validator.h"

ULONG ProviderCallBack(WMIDPREQUESTCODE RequestCode,
    PVOID Context,
    OUT ULONG *InOutBufferSize,
    OUT PVOID Buffer);

void
InitializeRegisterTraceGuid( PREGISTER_TRACE_GUID RegisterTraceGuid );

ULONG
TraceEvents ( ULONG TraceMode, ULONG TraceGuid, ULONG Count);

ULONG
TraceEventInstances ( ULONG TraceMode, ULONG TraceGuid, ULONG Count);

//int InitializeLogging( LPCTSTR lpctstrTCOFile,	CLogger *&pLoggingInfo);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\umtrprov\structurewapperhelpers.h ===
// StructureWapperHelpers.h
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_STRUCTUREWAPPERHELPERS_H__A349C060_ED4F_11D2_804A_009027345EE2__INCLUDED_)

#define AFX_STRUCTUREWAPPERHELPERS_H__A349C060_ED4F_11D2_804A_009027345EE2__INCLUDED_


#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

void LogFileModeOut(t_ostream &ros, ULONG LogFileMode);
void EnableFlagsOut(t_ostream &ros, ULONG EnableFlags);
void WnodeFlagsOut(t_ostream &ros, ULONG WnodeFlags);
void GUIDOut(t_ostream &ros, GUID Guid);
void LARGE_INTEGEROut(t_ostream &ros, LARGE_INTEGER Large);

void InitializeTCHARVar(t_string &rtsValue , void *pVar);
void InitializeEnumVar(t_string &rtsValue , void *pVar);
void InitializeHandleVar(t_string &rtsValue , void *pVar);
void InitializeULONGVar(t_string &rtsValue , void *pVar, bool bHex = false);
void InitializeLONGVar(t_string &rtsValue , void *pVar);
void InitializeGUIDVar(t_string &rtsValue , void *pVar);

t_istream &GetALine(t_istream &ris,TCHAR *tcBuffer, int nBufferSize);
t_ostream &PutALine(t_ostream &ros,const TCHAR *tcBuffer, int nBufferSize = -1);

t_istream &GetAChar(t_istream &ris,TCHAR &tc);

t_ostream &PutAULONGVar(t_ostream &ros, ULONG ul, bool bHex = false);
t_ostream &PutALONGVar(t_ostream &ros, LONG l, bool bHex = false);
t_ostream &PutADWORDVar(t_ostream &ros, DWORD dw);
t_ostream &PutAULONG64Var(t_ostream &ros, ULONG64 ul64);

BOOL wGUIDFromString(LPCTSTR lpsz, LPGUID pguid);

int case_insensitive_compare(t_string &r1, t_string &r2);
int case_insensitive_compare(TCHAR *p, t_string &r2);
int case_insensitive_compare(t_string &r1,TCHAR *p );
int case_insensitive_compare(TCHAR *p1,TCHAR *p2);





#endif // !defined(AFX_STRUCTUREWAPPERHELPERS_H__A349C060_ED4F_11D2_804A_009027345EE2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\umtrprov\t_string.h ===
// t_string.h: interface for the t_string class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_T_STRING_H__32BF27CE_EAD9_11D2_9C53_00A0249F63EB__INCLUDED_)
#define AFX_T_STRING_H__32BF27CE_EAD9_11D2_9C53_00A0249F63EB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


#ifndef t_string

#ifndef _UNICODE
// Definitions for WC to MBCS and MBCS to WC routines that do the right thing
// if compiled non-UNICODE.
#define t_string string
#define t_fstream fstream
#define t_istream istream
#define t_ostream ostream
#define t_cout cout
#define t_cin cin
#define t_strstream strstream
#define t_strstreambuf strstreambuf
#define t_ctime ctime
#define t_cerr cerr

#else

// Definitions for WC to MBCS and MBCS to WC routines that do the right thing
// if compiled UNICODE.
#define t_string wstring
#define t_fstream fstream
#define t_istream istream
#define t_ostream ostream
#define t_cout wcout
#define t_cin wcin
#define t_strstream wstringstream
#define t_strstreambuf wstrstreambuf
#define t_ctime _wctime
#define t_cerr wcerr

#endif

#endif

// We do not need conversion routines if compiling under UNICODE
#define mbsrtowcs t_mbsrtowcs


#endif // !defined(AFX_T_STRING_H__32BF27CE_EAD9_11D2_9C53_00A0249F63EB__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\umtrprov\utilities.h ===
// Utilities.h: interface for the CUtilities class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UTILITIES_H__C37E8DD0_ED3E_11D2_804A_009027345EE2__INCLUDED_)
#define AFX_UTILITIES_H__C37E8DD0_ED3E_11D2_804A_009027345EE2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

TCHAR *NewTCHAR(const TCHAR *ptcToCopy);

LPSTR NewLPSTR(LPCWSTR lpwstrToCopy);

LPWSTR NewLPWSTR(LPCSTR lpstrToCopy);

LPTSTR DecodeStatus(IN ULONG Status);

int GetFileList(LPTSTR lptstrPath, LPTSTR lptstrFileType, list<t_string> &rList);

BOOL IsAdmin();  // From Q118626

LPTSTR LPTSTRFromGuid(GUID Guid);

t_string ULONGVarToTString(ULONG ul, bool bHex);

#endif // !defined(AFX_UTILITIES_H__C37E8DD0_ED3E_11D2_804A_009027345EE2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\umtrprov\utils.cpp ===
#include "utils.h"
#include "struct.h"
#include "Readfile.h"
ULONG ahextoi( TCHAR *s)
{
    int len;
    ULONG num, base, hex;

    len = _tcslen(s);
    hex = 0; base = 1; num = 0;
    while (--len >= 0) {
        if ( (s[len] == 'x' || s[len] == 'X') &&
             (s[len-1] == '0') )
            break;
        if (s[len] >= '0' && s[len] <= '9')
            num = s[len] - '0';
        else if (s[len] >= 'a' && s[len] <= 'f')
            num = (s[len] - 'a') + 10;
        else if (s[len] >= 'A' && s[len] <= 'F')
            num = (s[len] - 'A') + 10;
        else
            continue;

        hex += num * base;
        base = base * 16;
    }
    return hex;
}

void RemoveComment( TCHAR *String)
{
	ULONG i = 0;

	while( String[i] != 0 )
	{
		if( String[i] == '/' )
		{
			String[i] = 0;
			break;
		}
		i++;
	}
}

void
ConvertAsciiToGuid( TCHAR* arg, LPGUID Guid)
{

	ULONG i;
	TCHAR Temp[MAX_STR];

	_tcsncpy(Temp, arg, 37);
	Temp[8] = 0;
	Guid->Data1 = ahextoi(Temp);

	_tcsncpy(Temp, &arg[9], 4);
	Temp[4] = 0;
	Guid->Data2 = (USHORT) ahextoi(Temp);

	_tcsncpy(Temp, &arg[14], 4);
	Temp[4] = 0;
	Guid->Data3 = (USHORT) ahextoi(Temp);
		

	for (i=0; i<2; i++) 
	{
		_tcsncpy(Temp, &arg[19 + (i*2)], 2);
        Temp[2] = 0;
        Guid->Data4[i] = (UCHAR) ahextoi(Temp);
    }
    for (i=2; i<8; i++) 
	{
		_tcsncpy(Temp, &arg[20 + (i*2)], 2);
        Temp[2] = 0;
        Guid->Data4[i] = (UCHAR) ahextoi(Temp);
    }

}



void
SplitCommandLine( 
    LPTSTR CommandLine, 
    LPTSTR* pArgv 
    )
{

    LPTSTR arg;
    int i = 0;
    arg = _tcstok( CommandLine, _T(" \t"));
    while( arg != NULL ){
        _tcscpy(pArgv[i++], arg); 
        arg = _tcstok(NULL, _T(" \t"));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\umtrprov\umprovider.cpp ===
#define MAX_STR 256
#define MAX_GUIDS 10

#define _UNICODE
#define UNICODE

#include "stdafx.h"

#pragma warning (disable : 4786)
#pragma warning (disable : 4275)

#include <iostream>
#include <strstream>
#include <fstream>
#include <string>
#include <sstream>
#include <map>
#include <list>


using namespace std;


#include <tchar.h>
#include <process.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>

#include <WTYPES.H>

/*

#include "stdafx.h"

#include <string>
#include <iosfwd> 
#include <iostream>
#include <fstream>
#include <ctime>
#include <list>
using namespace std;
#include <malloc.h>
#include <windows.h>


#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <tchar.h>
#include <wmistr.h>
#include <objbase.h>
#include <initguid.h>
#include <evntrace.h>
*/
#include "struct.h"
#include "utils.h"
#include "Readfile.h"
#include "umprovider.h"





TRACEHANDLE LoggerHandle = (TRACEHANDLE) 2;
ULONG TraceEventFlag = 0, EnableLevel = 0, EnableFlags = 0;
ULONG LoggerEnableLevel, LoggerEnableFlag;
ULONG TraceMode;
ULONG DataBlockSize = 0;
ULONG TraceEventInstanceFlag = 0;
PREGISTER_TRACE_GUID RegisterTraceGuid;
GUID TransactionGuid[12] =  {	{ 0xa7301ec8, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xa8558716, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xa9226a42, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xaa395d64, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xaa8ccfb2, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xaad4563e, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xab171816, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xab55153a, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xab84c442, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xabb210f0, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xabe1bff8, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xb01e8dee, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 } };


typedef struct _BLOCK1 {
    UCHAR                 EventChar;
	ULONG                 EventUlong;
} BLOCK1, *PBLOCK1;

typedef struct _EVENT_BLOCK1 {
    EVENT_TRACE_HEADER    Header;
	BLOCK1                Block1;
} EVENT_BLOCK1, *P_EVENT_BLOCK1;

typedef struct _EVENT_INSTANCE_BLOCK1 {
	EVENT_INSTANCE_HEADER Header;
	UCHAR				  EventChar;
	ULONG				  EventUlong;
} EVENT_INSTANCE_BLOCK1, *P_EVENT_INSTANCE_BLOCK1;

typedef struct _EVENT_BLOCK2 {
	EVENT_TRACE_HEADER Header;
	MOF_FIELD  MofField;
} EVENT_BLOCK2, *P_EVENT_BLOCK2;


BLOCK1 Block1;
EVENT_BLOCK1 EventBlock1;
EVENT_BLOCK2 EventBlock2;
EVENT_INSTANCE_BLOCK1 EventInstanceBlock1;
TRACE_GUID_REGISTRATION TraceGuidReg[MAX_GUIDS];

main(int argc, char* argv[])
{
	LPTSTR CommandFile;
	TRACEHANDLE RegistrationHandle;	
	ULONG Status;
	LPTSTR *commandLine;
	LPGUID pGuid;
	ULONG Count;
	ULONG GuidCount = 0;
	//CLogger *pLoggingInfo;
	LPCTSTR LogFileName;
	LPTSTR *targv;
	int i;
	

	pGuid = (LPGUID ) malloc(MAX_GUIDS * sizeof(GUID));
	CommandFile = (LPTSTR) malloc(sizeof(TCHAR)*MAX_STR);
	LogFileName = (LPCTSTR) malloc(sizeof(TCHAR)*MAX_STR);
	targv = (LPTSTR *) malloc(argc*sizeof(LPTSTR));
	for( i = 0; i < argc; i++ )
		targv[i] = (LPTSTR) malloc(sizeof(TCHAR)*MAX_STR);

	SplitCommandLine( GetCommandLine(), targv);
	for( i = 0; i < MAX_GUIDS; i++)
		TraceGuidReg[i].Guid = &TransactionGuid[i];
	Count = 1;
	while ( Count <= (argc-1) )
	{
		if ( !_tcsicmp(targv[Count], _T("-guids") )) 
		{
			Count++;
			if (Count <= argc) 
			{
				ConvertAsciiToGuid( targv[Count], &pGuid[GuidCount]);
				GuidCount++;
				Count++;
			}
			continue;
		}

		if( !_tcsicmp(targv[Count], _T("-file") ))
		{
			Count++;
			if ( Count <= argc)
			{
				CommandFile = targv[Count];
				Count++;
			}
			continue;
		}

		if( !_tcsicmp(targv[Count], _T("-flag") ))
		{
			Count++;
			if( Count <= argc)
			{
				LoggerEnableFlag = atoi(argv[Count]);
				Count++;
			}
			continue;
		}

		if( !_tcsicmp(targv[Count], _T("-level") ))
		{
			Count++;
			if( Count <= argc)
			{
				LoggerEnableLevel = atoi(argv[Count]);
				Count++;
			}
			continue;
		}

		if( !_tcsicmp(targv[Count], _T("-mode") ))
		{
			Count++;
			if( Count <= argc)
			{
				TraceMode = atoi(argv[Count]);
				Count++;
				continue;
			}
		}

		if( !_tcsicmp(targv[Count], _T("-TraceEventInstance") ))
		{
			Count++;
			TraceEventInstanceFlag = 1;
			continue;
		}

		if( !_tcsicmp(targv[Count], _T("-log") ))
		{
			Count++;
			if( Count <= argc )
			{
				//LogFileName = _T(argv[Count]);
				LogFileName = _T("C:\\");
				Count++;
				continue;
			}
		}

		Count++;
		continue;
	}
        
	Count = sizeof(REGISTER_TRACE_GUID);
	RegisterTraceGuid = (PREGISTER_TRACE_GUID ) malloc(sizeof(REGISTER_TRACE_GUID));
	RegisterTraceGuid->ControlGuid  = (LPGUID) malloc(sizeof(GUID));
	RegisterTraceGuid->MofImagePath = (TCHAR *) malloc (sizeof(TCHAR)*MAX_STR);
	RegisterTraceGuid->MofResourceName = (TCHAR *) malloc (sizeof(TCHAR)*MAX_STR);

	if( RegisterTraceGuid == NULL)
	{
		printf("\nGufooo");
		exit(0);
	}
	InitializeRegisterTraceGuid( RegisterTraceGuid );

	RegisterTraceGuid->UseMofPtrFlag = 0;
	RegisterTraceGuid->UseGuidPtrFlag = 0;
	
	Status = ReadInputFile( CommandFile, RegisterTraceGuid );


	if( RegisterTraceGuid->GuidCount != 0)
		RegisterTraceGuid->GuidCount = GuidCount;
	
	if( RegisterTraceGuid->CallBackFunction != 0)
		RegisterTraceGuid->CallBackFunction = ProviderCallBack;

	if( RegisterTraceGuid->TraceGuidReg != 0 )
		RegisterTraceGuid->TraceGuidReg = ( PTRACE_GUID_REGISTRATION) &TraceGuidReg[0];

	if( RegisterTraceGuid->RegistrationHandle != 0 )
		RegisterTraceGuid->RegistrationHandle = &RegistrationHandle;

	if( RegisterTraceGuid->GuidCount != 0 )
		RegisterTraceGuid->GuidCount = MAX_GUIDS;

	//InitializeLogging( LogFileName, pLoggingInfo);

	//if (pLoggingInfo)
	//{
		//pLoggingInfo->LogTCHAR(_T("\n*******************************************************\n"));
		//pLoggingInfo->LogTCHAR(_T("StartTraceAPI TCO test "));
		//pLoggingInfo->Flush();	
	//}



	Status = RegisterTraceGuids( ProviderCallBack,
								NULL, //Context
								pGuid,
								RegisterTraceGuid->GuidCount,
								RegisterTraceGuid->TraceGuidReg,
								RegisterTraceGuid->MofImagePath,
								RegisterTraceGuid->MofResourceName,
								RegisterTraceGuid->RegistrationHandle );

	if( RegisterTraceGuid->UnRegistrationHandle != 0 )
	{
		Status = UnregisterTraceGuids( (TRACEHANDLE) 0 );
		return;
	}

	if( Status == ERROR_SUCCESS)
	{
		Count = 0;
		do
		{
			if( (TraceEventFlag ) && ( TraceEventInstanceFlag) )
			{
				Status = TraceEventInstances( TraceMode, (Count%10), Count);
				Count++;
			}
			else if (TraceEventFlag)
			{
				Status = TraceEvents( TraceMode, (Count%10), (Count%100));
				Count++;
			}

		}while(1);
		Status = UnregisterTraceGuids( *(RegisterTraceGuid->RegistrationHandle));
	}
}


ULONG ProviderCallBack(WMIDPREQUESTCODE RequestCode,
    PVOID Context,
    ULONG *InOutBufferSize,
    PVOID Buffer)
{
	switch (RequestCode )
	{
		case WMI_ENABLE_EVENTS:
		{
			TraceEventFlag = 1;
            LoggerHandle = GetTraceLoggerHandle( Buffer );
            EnableLevel = GetTraceEnableLevel(LoggerHandle);
            EnableFlags = GetTraceEnableFlags(LoggerHandle);
			break;
		}
		
		case WMI_DISABLE_EVENTS:
		{
			TraceEventFlag = 0;
			break;
		}
	}
		return 0;
}


void
InitializeRegisterTraceGuid( PREGISTER_TRACE_GUID RegisterTraceGuid )
{
	//Initialize with some random values and then read from the input
	//file. If any of these parameters needs to be tested with 0, 
	//input files will set this as zero.
	if( RegisterTraceGuid )
	{
		RegisterTraceGuid->GuidCount = 0xa5;
		RegisterTraceGuid->CallBackFunction = (PVOID) 0xa5a5a5;
		RegisterTraceGuid->TraceGuidReg = (PTRACE_GUID_REGISTRATION) (0xa5a5a5);
		RegisterTraceGuid->RegistrationHandle = (PTRACEHANDLE) (0xa5a5a5);
		RegisterTraceGuid->UnRegistrationHandle = (PTRACEHANDLE) (0xa5a5a5);
	}

}

ULONG
TraceEvents ( ULONG TraceMode, ULONG TraceGuid, ULONG Count)
{
	ULONG Status;

	switch ( TraceMode )
	{
		case 0 :
		{
			if( RegisterTraceGuid->UseMofPtrFlag != 1)
			{
				EventBlock1.Header.Size = sizeof(EventBlock1);
				ULONG Temp = sizeof(Block1);
				EventBlock1.Header.Guid = TransactionGuid[TraceGuid];
				EventBlock1.Header.Flags = WNODE_FLAG_TRACED_GUID;
				if( RegisterTraceGuid->UseGuidPtrFlag == 1)
				{
					EventBlock1.Header.Flags |= WNODE_FLAG_USE_GUID_PTR;
					EventBlock1.Header.GuidPtr = (ULONGLONG) &TransactionGuid[TraceGuid];
				}
				EventBlock1.Block1.EventChar = (UCHAR) Count;
				EventBlock1.Block1.EventUlong = Count;
				Status = TraceEvent( LoggerHandle, (PEVENT_TRACE_HEADER) &EventBlock1);
			}
			else
			{
				EventBlock2.Header.Size = sizeof(EventBlock2);
				EventBlock2.Header.Flags = WNODE_FLAG_USE_MOF_PTR;
				EventBlock2.Header.Guid = TransactionGuid[TraceGuid];
				EventBlock2.Header.Flags |= WNODE_FLAG_TRACED_GUID;
				EventBlock2.MofField.DataPtr = (ULONGLONG) &Block1;
				EventBlock2.MofField.Length = sizeof(BLOCK1);
				if( RegisterTraceGuid->UseGuidPtrFlag == 1)
				{
					EventBlock2.Header.Flags |= WNODE_FLAG_USE_GUID_PTR;
					EventBlock2.Header.GuidPtr = (ULONGLONG) &TransactionGuid[TraceGuid];
				}
				Block1.EventChar = (UCHAR) Count;
				Block1.EventUlong = Count;
				Status = TraceEvent( LoggerHandle, (PEVENT_TRACE_HEADER) &EventBlock2);

			}
			break;
		}
	}
	return Status;

}


ULONG
TraceEventInstances ( ULONG TraceMode, ULONG TraceGuid, ULONG Count)
{
	ULONG Status;
	EVENT_INSTANCE_INFO InstanceInfo;
	switch ( TraceMode )
	{
		case 0 :
		{
			EventInstanceBlock1.Header.Size = sizeof(EventInstanceBlock1);
			EventInstanceBlock1.Header.Flags = WNODE_FLAG_TRACED_GUID;
			if( RegisterTraceGuid->UseMofPtrFlag == 1)
				EventInstanceBlock1.Header.Flags |= WNODE_FLAG_USE_MOF_PTR;
			EventInstanceBlock1.EventChar = (UCHAR) Count;
			EventInstanceBlock1.EventUlong = Count;
			Status = CreateTraceInstanceId( TraceGuidReg[TraceGuid].RegHandle,
											&InstanceInfo);
			if( Status == ERROR_SUCCESS )
				Status = TraceEventInstance( LoggerHandle, (PEVENT_INSTANCE_HEADER) &EventBlock1,
											 &InstanceInfo,
											 NULL);
			break;
		}
	}
	return Status;

}

/*
int InitializeLogging( LPCTSTR lpctstrTCOFile,	CLogger *&pLoggingInfo)
{
	HRESULT hr = S_OK;
//	t_string tsError;

	if (lpctstrTCOFile)
	{
		// Open *our* logger file.
		pLoggingInfo = new CLogger(lpctstrTCOFile, false);
		hr = pLoggingInfo->GetOpenStatus();
		if (FAILED (hr))
		{
//			tsError = _T("Could not open detail log file \"");
//			tsError += lpctstrTCOFile;
//			tsError += _T("\".");
			//*plpstrReturnedError = NewTCHAR(tsError.c_str());
			return hr;
		}
	}
	return hr;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\umtrprov\utilities.cpp ===
// Utilities.cpp: implementation of the CUtilities class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#pragma warning (disable : 4786)
#pragma warning (disable : 4275)


#include <iostream>
#include <strstream>
#include <fstream>
#include <string>
#include <sstream>
#include <map>
#include <list>

using namespace std;

#include <tchar.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>

#include <malloc.h>

#include <WTYPES.H>
#include "t_string.h"
#include <tchar.h>
#include <list>


#include "Persistor.h"

#include "StructureWrappers.h"
#include "StructureWapperHelpers.h"

#include "Utilities.h"

#define MAX_STR 1024

//////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////

TCHAR *NewTCHAR(const TCHAR *ptcToCopy)
{
	if (ptcToCopy == NULL)
	{
		return NULL;
	}

	// This is a gross hack.  Need to pin down heap corruption.
	int nString = _tcsclen(ptcToCopy) + 100;
	int nTCHAR = sizeof(TCHAR);

	int nLen = nString * (nTCHAR); 

	TCHAR *pNew = (TCHAR*) malloc(nLen);

	_tcscpy(pNew,ptcToCopy);

	return pNew;
}

LPSTR NewLPSTR(LPCWSTR lpwstrToCopy)
{
	int nLen = (wcslen(lpwstrToCopy) + 1) * sizeof(WCHAR);
	LPSTR pNew = (char *)malloc( nLen );
   
	wcstombs(pNew, lpwstrToCopy, nLen);

	return pNew;
}

LPWSTR NewLPWSTR(LPCSTR lpstrToCopy)
{
	int nLen = (strlen(lpstrToCopy) + 1);
	LPWSTR pNew = (WCHAR *)malloc( nLen  * sizeof(WCHAR));
	mbstowcs(pNew, lpstrToCopy, nLen);

	return pNew;

}

LPTSTR DecodeStatus(IN ULONG Status)
{
	LPTSTR lptstrError = (LPTSTR) malloc (MAX_STR);

    memset( lptstrError, 0, MAX_STR );

    FormatMessage(     
        FORMAT_MESSAGE_FROM_SYSTEM |     
        FORMAT_MESSAGE_IGNORE_INSERTS,    
        NULL,
        Status,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        lptstrError,
        MAX_STR,
        NULL );

	for (int i = 0; i < MAX_STR; i++)
	{
		if (lptstrError[i] == 0x0d)
		{
			lptstrError[i] = _T('\0');
			break;
		}
	}

    return lptstrError;
}

int GetFileList
(LPTSTR lptstrPath, LPTSTR lptstrFileType, list<t_string> &rList)
{
	t_string tsFind;

	tsFind = lptstrPath;
	tsFind += _T("\\");
	tsFind += lptstrFileType;


	WIN32_FIND_DATA wfdFile;
	HANDLE hFindHandle = 
		FindFirstFile(tsFind.c_str(), &wfdFile);

	if (hFindHandle == INVALID_HANDLE_VALUE)
	{
		return HRESULT_FROM_WIN32(GetLastError()); 
	}

	if ((_tcscmp(wfdFile.cFileName,_T(".")) != 0) &&
			(_tcscmp(wfdFile.cFileName,_T("..")) != 0))
	{
		tsFind = lptstrPath;
		tsFind += _T("\\");
		tsFind += wfdFile.cFileName;
		rList.push_back(tsFind);
		tsFind.erase();
	}

	while (FindNextFile(hFindHandle, &wfdFile))
	{
		if ((_tcscmp(wfdFile.cFileName,_T(".")) != 0) &&
			(_tcscmp(wfdFile.cFileName,_T("..")) != 0))
		{
			tsFind = lptstrPath;
			tsFind += _T("\\");
			tsFind += wfdFile.cFileName;
			rList.push_back(tsFind);
			tsFind.erase();
		}
	}

	FindClose(hFindHandle);

	return ERROR_SUCCESS;
} 

// From Q 118626
BOOL IsAdmin()
{
  HANDLE hAccessToken;
  UCHAR InfoBuffer[1024];
  PTOKEN_GROUPS ptgGroups = (PTOKEN_GROUPS)InfoBuffer;
  DWORD dwInfoBufferSize;
  PSID psidAdministrators;
  SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
  UINT x;
  BOOL bSuccess;

  if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE,
	 &hAccessToken )) {
	 if(GetLastError() != ERROR_NO_TOKEN)
		return FALSE;
	 //
	 // retry against process token if no thread token exists
	 //
	 if(!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY,
		&hAccessToken))
		return FALSE;
  }

  bSuccess = GetTokenInformation(hAccessToken,TokenGroups,InfoBuffer,
	 1024, &dwInfoBufferSize);

  CloseHandle(hAccessToken);

  if(!bSuccess )
	 return FALSE;

  if(!AllocateAndInitializeSid(&siaNtAuthority, 2,
	 SECURITY_BUILTIN_DOMAIN_RID,
	 DOMAIN_ALIAS_RID_ADMINS,
	 0, 0, 0, 0, 0, 0,
	 &psidAdministrators))
	 return FALSE;

// assume that we don't find the admin SID.
  bSuccess = FALSE;

  for(x=0;x<ptgGroups->GroupCount;x++)
  {
	 if( EqualSid(psidAdministrators, ptgGroups->Groups[x].Sid) )
	 {
		bSuccess = TRUE;
		break;
	 }

  }
  FreeSid(psidAdministrators);
  return bSuccess;
}

t_string GUIDToTString(GUID Guid)
{
	t_strstream strStream;
	t_string tsOut;

	strStream << _T("{");
	
	strStream.fill(_T('0'));
	strStream.width(8);
	strStream.flags(ios_base::right);

	strStream << hex << Guid.Data1;

	strStream << _T("-");

	strStream.width(4);

	strStream << hex << Guid.Data2;

	strStream << _T("-");

	strStream << hex << Guid.Data3;

	strStream << _T("-");

	// Data4 specifies an array of 8 bytes. The first 2 bytes contain 
	// the third group of 4 hexadecimal digits. The remaining 6 bytes 
	// contain the final 12 hexadecimal digits. 

#ifndef _UNICODE
	int i;

	strStream.width(1);

	BYTE Byte;
	int Int;
	for (i = 0; i < 2; i++)
	{
		Byte = Guid.Data4[i];
		Byte = Byte >> 4;
		Int = Byte;
		strStream <<  hex << Int;
		Byte = Guid.Data4[i];
		Byte = 0x0f & Byte;
		Int = Byte;
		strStream << hex << Int;
	}

	strStream << _T("-");

	strStream.width(1);


	for (i = 2; i < 8; i++)
	{
		BYTE Byte = Guid.Data4[i];
		Byte = Byte >> 4;
		Int = Byte;
		strStream << hex << Int;
		Byte = Guid.Data4[i];
		Byte = 0x0f & Byte;
		Int = Byte;
		strStream << hex << Int;
	}
#else
	int i;

	for (i = 0; i < 2; i++)
	{
		TCHAR tc = Guid.Data4[i];
		// For some reason the width is reset each time through the 
		// loop to be one.
		strStream.width(2);
		strStream << hex << tc;
	}

	strStream << _T("-");
	
	BYTE Byte;
	strStream.width(1);
	for (i = 2; i < 8; i++)
	{
		Byte = Guid.Data4[i];
		Byte = Byte >> 4;
		strStream << hex << Byte;
		Byte = Guid.Data4[i];
		Byte = 0x0f & Byte;
		strStream << hex << Byte;
	}
#endif

	strStream << _T("}");

	strStream >> tsOut;

	return tsOut;
}

LPTSTR LPTSTRFromGuid(GUID Guid)
{
	t_string tsGuid = GUIDToTString(Guid);
	return NewTCHAR(tsGuid.c_str());
}

t_string ULONGVarToTString(ULONG ul, bool bHex)
{
	t_string tsTemp;
	t_strstream strStream;

	if (bHex)
	{
		strStream.width(8);
		strStream.fill('0');
		strStream.flags(ios_base::right);
		strStream << hex << ul;
	}
	else
	{
		strStream << ul;
	}

	strStream >> tsTemp;

	if (bHex)
	{
		t_string tsHex;
		tsHex = _T("0x");
		tsHex += tsTemp;
		return tsHex;
	}
	else
	{
		return tsTemp;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\umtrprov\utils.h ===
#define UNICODE
#define _UNICODE

#include <stdio.h>
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <tchar.h>
#include <wmistr.h>
#include <objbase.h>
#include <initguid.h>
#include <evntrace.h>

ULONG ahextoi( TCHAR *s);

void RemoveComment( TCHAR *String);
void ConvertAsciiToGuid( TCHAR *String, LPGUID Guid);
void SplitCommandLine( LPTSTR CommandLine, LPTSTR* pArgv);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    Common macros shared between cgen, whnt32, and whbase.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

SOURCES_USED=..\sources.inc

W32_SB=1

MAJORCOMP=windows

# BASE_INC_PATH must be before PROJECT_ROOT\win32\client as each dir has a
# vdm.h in it, and we want the one from BASE_INC_PATH.
INCLUDES=$(INCLUDES);..\inc;$(BASE_INC_PATH);$(PROJECT_ROOT)\win32\inc;$(PROJECT_ROOT)\win32\client
INCLUDES=$(INCLUDES);$(PROJECT_ROOT)\win32\winnls;$(PROJECT_ROOT)\ntdll\wow6432;$(WINDOWS_INC_PATH)
INCLUDES=$(INCLUDES);$(TERMSRV_INC_PATH);$(SDKTOOLS_INC_PATH);$(PROJECT_ROOT)\ntos\inc;$(DS_INC_PATH);

C_DEFINES=$(C_DEFINES) -D_USER32_ -DUNICODE -DUSE_MIRRORING

UMTYPE=windows

NTTARGETFILE0=thunks
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\cgen\cgenhdr.h ===
// Copyright (c) 1998-1999 Microsoft Corporation

#ifdef SORTPP_PASS
#define BUILD_WOW6432 1
#define USE_LPC6432 1
#endif

#if !defined(LANGPACK)
#define LANGPACK
#endif

#define ETW_WOW6432

#include <stddef.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h> 
#include <ntexapi.h>
#include <ntcsrdll.h>
#include <ntcsrsrv.h>
#include <vdm.h>
#include <ntwmi.h>

#include <windef.h>
#include <winbase.h>
#include <wincon.h>
#include <windef.h>
#include <winbase.h>
#include <winnls.h>
#include <basedll.h>
#include <nls.h>
#include <sxstypes.h>

#ifdef SORTPP_PASS
//Restore IN, OUT
#ifdef IN
#undef IN
#endif

#ifdef OUT
#undef OUT
#endif

#define IN __in
#define OUT __out
#endif

#include <ntwow64.h>    // from base\ntdll\wow6432
#include <ntwow64b.h>   // from base\win32\client
#include <ntwow64n.h>   // from base\win32\winnls

#undef NtGetTickCount   // a macro in sdkinc\ntexapi.h

ULONG
NTAPI
NtGetTickCount(
    VOID
    );

VOID Wow64Teb32(TEB * Teb);

#define SECURITY_WIN32
#include <sspi.h>   // from sdk\inc, defines SECURITY_STRING
#include <secpkg.h> // from sdk\inc, defines PSecurityUserData
#include <secint.h> // from sdk\inc
#if 0
#include <aup.h>    // from ds\security\base\lsa\inc
#include <spmlpc.h> // from ds\security\base\lsa\inc
#endif
#include <secext.h> // from sdk\inc, defines SEC_WINNT_AUTH_IDENTITY_EX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\wbemlib\useful.cpp ===
//***************************************************************************
//
//  Useful.CPP
//
//  Module: CDM Provider
//
//  Purpose: Useful classes
//
//  Copyright (c) 2000 Microsoft Corporation
//
//***************************************************************************

#include <objbase.h>
#include <wbemprov.h>

#include "debug.h"
#include "useful.h"
#include "wbemmisc.h"

void FreeTheBSTRArray(
    BSTR *Array,
	ULONG Size
    )
/*+++

Routine Description:

	This routine will free the contents of an array of BSTR and then
	the array itself
        
Arguments:

	Array is the array to be freed

	Size is the number of elements in the array
Return Value:

    HRESULT

---*/
{
	ULONG i;

	if (Array != NULL)
	{
		for (i = 0; i < Size; i++)
		{
			if (Array[i] != NULL)
			{
				SysFreeString(Array[i]);
			}
		}
		WmipFree(Array);
	}
}

CBstrArray::CBstrArray()
{
	Array = NULL;
	ListSize = 0xffffffff;
}

CBstrArray::~CBstrArray()
{
	ULONG i;
	
	if (Array != NULL)
	{
		for (i = 0; i < ListSize; i++)
		{
			if (Array[i] != NULL)
			{
				SysFreeString(Array[i]);
			}
		}
		WmipFree(Array);
	}

	ListSize = 0xffffffff;
}

HRESULT CBstrArray::Initialize(
    ULONG ListCount
    )
{
	HRESULT hr = WBEM_S_NO_ERROR;
	ULONG AllocSize;
	
	if (ListCount != 0)
	{
		AllocSize = ListCount * sizeof(BSTR *);
		Array = (BSTR *)WmipAlloc(AllocSize);
		if (Array != NULL)
		{
			memset(Array, 0, AllocSize);
			ListSize = ListCount;
		} else {
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	} else {
		ListSize = ListCount;
	}
	return(hr);
}

BOOLEAN CBstrArray::IsInitialized(
    )
{
	return( (Array != NULL) || (ListSize == 0) );
}

BSTR CBstrArray::Get(
    ULONG Index
    )
{
	WmipAssert(Index < ListSize);
	
	WmipAssert(IsInitialized());

	return(Array[Index]);
}

void CBstrArray::Set(
    ULONG Index,
    BSTR s				 
    )
{
	WmipAssert(Index < ListSize);
	
	WmipAssert(IsInitialized());

	Array[Index] = s;
}

ULONG CBstrArray::GetListSize(
    )
{
	WmipAssert(IsInitialized());

	return(ListSize);
}


CWbemObjectList::CWbemObjectList()
{
	//
	// Constructor, init internal values
	//
	List = NULL;
	RelPaths = NULL;
	ListSize = 0xffffffff;
}

CWbemObjectList::~CWbemObjectList()
{
	ULONG i;
	
	//
	// Destructor, free memory held by this class
	//
	
	if (List != NULL)
	{
		for (i = 0; i < ListSize; i++)
		{
			if (List[i] != NULL)
			{
				List[i]->Release();
			}
		}
		WmipFree(List);
	}
	List = NULL;

	if (RelPaths != NULL)
	{
		FreeTheBSTRArray(RelPaths, ListSize);
		RelPaths = NULL;
	}
	
	ListSize = 0xffffffff;
}

HRESULT CWbemObjectList::Initialize(
    ULONG NumberPointers
    )
{
	HRESULT hr;
	ULONG AllocSize;

	//
	// Initialize class by allocating internal list array
	//

	WmipAssert(List == NULL);

	if (NumberPointers != 0)
	{
		AllocSize = NumberPointers * sizeof(IWbemClassObject *);
		List = (IWbemClassObject **)WmipAlloc(AllocSize);
		if (List != NULL)
		{
			memset(List, 0, AllocSize);
			AllocSize = NumberPointers * sizeof(BSTR);
			
			RelPaths = (BSTR *)WmipAlloc(AllocSize);
			if (RelPaths != NULL)
			{
				memset(RelPaths, 0, AllocSize);
				ListSize = NumberPointers;
				hr = WBEM_S_NO_ERROR;
			} else {
				WmipDebugPrint(("CDMProv: Could not alloc memory for CWbemObjectList RelPaths\n"));
				hr = WBEM_E_OUT_OF_MEMORY;
			}
		} else {
			WmipDebugPrint(("CDMProv: Could not alloc memory for CWbemObjectList\n"));
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	} else {
		ListSize = NumberPointers;
		hr = WBEM_S_NO_ERROR;
	}
	
	return(hr);
}

ULONG CWbemObjectList::GetListSize(
    void
	)
{
	//
	// Accessor for list size
	//

	WmipAssert(IsInitialized());
	
	return(ListSize);
}

IWbemClassObject *CWbemObjectList::Get(
    ULONG Index
    )
{	IWbemClassObject *Pointer;
	
	WmipAssert(Index < ListSize);
	WmipAssert(IsInitialized());

	Pointer = List[Index];
	
	return(Pointer);
}


HRESULT CWbemObjectList::Set(
    IN ULONG Index,
	IN IWbemClassObject *Pointer
    )
{
	HRESULT hr;
	VARIANT v;

	WmipAssert(Pointer != NULL);
	
	WmipAssert(Index < ListSize);
	WmipAssert(IsInitialized());
	
	hr = WmiGetProperty(Pointer,
						L"__RelPath",
						CIM_REFERENCE,
						&v);
	if (hr == WBEM_S_NO_ERROR)
	{
		RelPaths[Index] = v.bstrVal;
		List[Index] = Pointer;		
	}
	return(hr);
}

BSTR /* NOFREE */ CWbemObjectList::GetRelPath(
    IN ULONG Index
	)
{
	WmipAssert(Index < ListSize);
	WmipAssert(IsInitialized());

	return(RelPaths[Index]);
}

BOOLEAN CWbemObjectList::IsInitialized(
    )
{
	return((ListSize == 0) ||
		   ((List != NULL) && (RelPaths != NULL)));
}


CValueMapping::CValueMapping(
)
{
	VariantInit(&Values);
	ValueMap = NULL;
}

CValueMapping::~CValueMapping(
)
{
	if (ValueMap != NULL)
	{
		WmipFree(ValueMap);
	}

	VariantClear(&Values);
}



HRESULT CValueMapping::EstablishByName(
    IWbemServices *pServices,
    PWCHAR ClassName,
    PWCHAR PropertyName
    )
{
	HRESULT hr;
	PWCHAR Names[2];
	VARTYPE Types[2];
	VARIANT v[2];
	VARTYPE IsValueMapArray, IsValuesArray;
	
	Names[0] = L"ValueMap";
	Types[0] = VT_BSTR;

	Names[1] = L"Values";
	Types[1] = VT_BSTR;
	hr = WmiGetQualifierListByName(pServices,
								   ClassName,
								   PropertyName,
								   2,
								   Names,
								   Types,
								   v);

	if (hr == WBEM_S_NO_ERROR)
	{
		IsValueMapArray = v[0].vt & VT_ARRAY;
		IsValuesArray = v[1].vt & VT_ARRAY;
		if (IsValueMapArray == IsValuesArray)
		{
			if (IsValueMapArray)
			{
				//
				// Qualifiers specified as arrays so we can just
				// set them up
				//
				hr = EstablishByArrays(&v[1],
									   &v[0]);
			} else {
				//
				// Qualifiers specified as scalars
				//
				hr = EstablishByScalars(v[1].bstrVal,
										v[0].bstrVal);
			}
		} else {
			//
			// Both must be an array or a scalar
			//
			hr = WBEM_E_FAILED;
		}

		VariantClear(&v[0]);
		VariantClear(&v[1]);
	}

	return(hr);
}

HRESULT CValueMapping::EstablishByScalars(
    BSTR vValues,
	BSTR vValueMap
	)
{
	HRESULT hr;
	PULONG Number;
	LONG Index;
	SAFEARRAYBOUND Bound;

	//
	// First, establish the ValueMap values
	//
	ValueMap = (PULONG64)WmipAlloc(sizeof(ULONG64));
	if (ValueMap != NULL)
	{
		*ValueMap = _wtoi(vValueMap);
		ValueMapElements = 1;
		
		//
		// Now build a safearray to store the Values element
		//
		ValuesLBound = 0;
		Bound.lLbound = ValuesLBound;
		Bound.cElements = 1;
		Values.parray = SafeArrayCreate(VT_BSTR,
										1,
										&Bound);
		if (Values.parray != NULL)
		{
			Values.vt = VT_BSTR | VT_ARRAY;
			Index = 0;
			hr = SafeArrayPutElement(Values.parray,
									 &Index,
									 vValues);
			if (hr != WBEM_S_NO_ERROR)
			{
				VariantClear(&Values);
			}
		}
		
	} else {
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	
	
	return(hr);
}

HRESULT CValueMapping::EstablishByArrays(
    VARIANT *vValues,
	VARIANT *vValueMap
    )
{
	HRESULT hr;
	BSTR s;
	LONG ValueMapLBound, ValueMapUBound;
	LONG ValuesUBound, ValuesElements;
	LONG Index;
	LONG i;
	
	//
	// Get the array sizes and ensure that they match
	//
	hr = WmiGetArraySize(vValueMap->parray,
						 &ValueMapLBound,
						 &ValueMapUBound,
						 &ValueMapElements);

	if (hr == WBEM_S_NO_ERROR)
	{
		hr = WmiGetArraySize(vValues->parray,
							 &ValuesLBound,
							 &ValuesUBound,
							 &ValuesElements);

		if (hr == WBEM_S_NO_ERROR)
		{
			if ((ValuesLBound == ValueMapLBound) &&
				(ValuesUBound == ValueMapUBound) &&
				(ValuesElements == ValueMapElements))
			{
				//
				// The ValueMap is balance with the values so parse the
				// valuemaps from strings to ulongs
				//
				ValueMap = (PULONG64)WmipAlloc(ValueMapElements * sizeof(ULONG64));
				if (ValueMap != NULL)
				{
					for (i = 0; i < ValueMapElements; i++)
					{
						Index = i + ValueMapLBound;
						hr = SafeArrayGetElement(vValueMap->parray,
												 &Index,
												 &s);
						if (hr == WBEM_S_NO_ERROR)
						{
							ValueMap[i] = _wtoi(s);
							SysFreeString(s);
						}
					}

					//
					// And assign Values to our class
					//
					Values = *vValues;
					VariantInit(vValues);
				} else {
					hr = WBEM_E_OUT_OF_MEMORY;
				}
			}					
		}
	}

	return(hr);
}

HRESULT CValueMapping::MapToString(
    IN ULONG64 Number,
    OUT BSTR *String
    )
{
	LONG i;
	WCHAR ss[MAX_PATH];
	LONG Index;
	HRESULT hr;

	//
	// Loop over all values and try to find a match
	//
	for (i = 0, hr = WBEM_E_FAILED;
		 (i < ValueMapElements) && (hr != WBEM_S_NO_ERROR);
		 i++)
	{
		if (Number == ValueMap[i])
		{
			//
			// We found something to map the value to
			//
			Index = i + ValuesLBound;
			hr = SafeArrayGetElement(Values.parray,
									 &Index,
									 String);
		}
	}

	if (hr != WBEM_S_NO_ERROR)
	{
		//
		// There was no match so we just leave the result as a number
		//
		wsprintfW(ss, L"%d", Number);
		*String = SysAllocString(ss);
		if (*String == NULL)
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	}
	
	return(hr);
}

HRESULT CValueMapping::MapToNumber(
    IN BSTR String,
    OUT PULONG64 Number
    )
{
	LONG i;
	BSTR s;
	LONG Index;
	HRESULT hr, hr2;

	for (i = 0, hr = WBEM_E_FAILED;
		 (i < ValueMapElements) && (hr != WBEM_S_NO_ERROR);
		 i++)
	{
		Index = i + ValuesLBound;
		hr2 = SafeArrayGetElement(Values.parray,
								 &Index,
								 &s);
		
		if (hr2 == WBEM_S_NO_ERROR)
		{
			if (_wcsicmp(s, String) == 0)
			{
				*Number = ValueMap[i];
				hr = WBEM_S_NO_ERROR;
			}
			SysFreeString(s);
		}
	}

	//
	// There was no match so we don't really have anything to map to
	//	
	
	return(hr);
}

HRESULT CValueMapping::MapVariantToNumber(
    VARIANT *v,
    CIMTYPE NewType
    )
{
	HRESULT hr;
	VARTYPE BaseType, IsArray;
	ULONG64 Number;
	VARTYPE NewVarType;
	WCHAR ss[MAX_PATH];
	
	BaseType = v->vt & ~VT_ARRAY;
	IsArray = v->vt & VT_ARRAY;
	
	WmipAssert(BaseType == VT_BSTR);
	
	if (IsArray == VT_ARRAY)
	{
		//
		// The variant is an array so we need to map each element in an
		// array
		//
		SAFEARRAYBOUND Bounds;
		SAFEARRAY *Array;
		ULONG Value;
		LONG UBound, LBound, Elements, Index;
		BSTR s;
		LONG i;

		hr = WmiGetArraySize(v->parray,
							 &LBound,
							 &UBound,
							 &Elements);
		if (hr == WBEM_S_NO_ERROR)
		{
			if ((NewType == (CIM_SINT64 | CIM_FLAG_ARRAY)) ||
		        (NewType == (CIM_UINT64 | CIM_FLAG_ARRAY)))
			{
				//
				// If we are mapping to a 64bit number we need to make
				// it into a string so setup as an safearray of strings
				//
				NewVarType = VT_BSTR | VT_ARRAY;
			} else {
				NewVarType = (VARTYPE)NewType;
			}
			
			Bounds.lLbound = LBound;
			Bounds.cElements = Elements;
			Array = SafeArrayCreate(NewVarType,
									1,
									&Bounds);
			
			if (Array != NULL)
			{
				for (i = 0;
					 (i < Elements) && (hr == WBEM_S_NO_ERROR);
					 i++)
				{
					Index = i + LBound;
					hr = SafeArrayGetElement(v->parray,
											 &Index,
											 &s);
					if (hr == WBEM_S_NO_ERROR)
					{
						hr = MapToNumber(s,
										 &Number);
						SysFreeString(s);
						
						if (hr == WBEM_S_NO_ERROR)
						{
							if (NewVarType == (VT_BSTR | VT_ARRAY))
							{
								//
								// Mapping to a 64bit number so convert
								// to string first
								//
								wsprintfW(ss, L"%d", Number);
								s = SysAllocString(ss);
								if (s != NULL)
								{
									hr = SafeArrayPutElement(Array,
										                     &Index,
										                     s);
									SysFreeString(s);
								} else {
									hr = WBEM_E_OUT_OF_MEMORY;
								}
							} else {
								hr = SafeArrayPutElement(Array,
														 &Index,
														 &Number);
							}
						}
					}
				}
				
				if (hr == WBEM_S_NO_ERROR)
				{
					VariantClear(v);
					v->vt = NewType | VT_ARRAY;
					v->parray = Array;
				} else {
					SafeArrayDestroy(Array);
				}
			}
		}

	} else {
		//
		// The variant is a scalar so we just need to map one thing
		//
		hr = MapToNumber(v->bstrVal,
						 &Number);
		if (hr == WBEM_S_NO_ERROR)
		{
			VariantClear(v);
			WmiSetNumberInVariant(v,
						          NewType,
           						  Number);
		}
	}
	return(hr);
}

HRESULT CValueMapping::MapVariantToString(
    VARIANT *v,
    CIMTYPE OldType
    )
{
	VARTYPE BaseType, IsArray;
	ULONG64 Number;
	BSTR s;
	HRESULT hr;
	LONG i;

	BaseType = v->vt & ~VT_ARRAY;
	IsArray = v->vt & VT_ARRAY;
	
	if (IsArray == VT_ARRAY)
	{
		//
		// The variant is an array so we need to map each element in an
		// array
		//
		SAFEARRAYBOUND Bounds;
		SAFEARRAY *Array;
		ULONG Value;
		LONG UBound, LBound, Elements, Index;

		hr = WmiGetArraySize(v->parray,
							 &LBound,
							 &UBound,
							 &Elements);
		if (hr == WBEM_S_NO_ERROR)
		{
			Bounds.lLbound = LBound;
			Bounds.cElements = Elements;
			Array = SafeArrayCreate(VT_BSTR,
									1,
									&Bounds);
			
			if (Array != NULL)
			{
				for (i = 0;
					 (i < Elements) && (hr == WBEM_S_NO_ERROR);
					 i++)
				{
					Index = i + LBound;

					if (BaseType == VT_BSTR)
					{
						//
						// If base type is a string then we assume that
						// we've got a 64bit number which is encoded as
						// a string. So we need to fish out the string
						// and convert it to a ULONG64
						//
						WmipAssert((OldType == (CIM_SINT64 | CIM_FLAG_ARRAY)) ||
								   (OldType == (CIM_UINT64 | CIM_FLAG_ARRAY)));
						
						hr = SafeArrayGetElement(v->parray,
												 &Index,
												 &s);
						if (hr == WBEM_S_NO_ERROR)
						{
							Number = _wtoi(s);
							SysFreeString(s);
						}
					} else {
						//
						// Otherwise the number is acutally encoded as
						// a number so fish out the number
						//
						Number = 0;
						hr = SafeArrayGetElement(v->parray,
												 &Index,
												 &Number);
					}
					
					if (hr == WBEM_S_NO_ERROR)
					{
						hr = MapToString(Number,
										 &s);
						if (hr == WBEM_S_NO_ERROR)
						{
							hr = SafeArrayPutElement(Array,
								                     &Index,
												     s);
							SysFreeString(s);
						}
					}
				}
				
				if (hr == WBEM_S_NO_ERROR)
				{
					VariantClear(v);
					v->vt = VT_BSTR | VT_ARRAY;
					v->parray = Array;
				} else {
					SafeArrayDestroy(Array);
				}
			}
		}

	} else {
		//
		// The variant is a scalar so we just need to map one thing
		//
        WmiGetNumberFromVariant(v,
								 OldType,
								 &Number);
		 
		hr = MapToString(Number,
						 &s);
		if (hr == WBEM_S_NO_ERROR)
		{
			VariantClear(v);
			v->vt = VT_BSTR;
			v->bstrVal = s;
		}
	}
	return(hr);
}

#ifndef HEAP_DEBUG
PVOID WmipAlloc(
    IN ULONG Size
    )
/*+++

Routine Description:

    Internal memory allocator
        
Arguments:

	Size is the number of bytes to allocate

Return Value:

	pointer to alloced memory or NULL

---*/
{
	return(LocalAlloc(LPTR, Size));
}

void WmipFree(
    IN PVOID Ptr
    )
/*+++

Routine Description:

    Internal memory deallocator
        
Arguments:

	Pointer to freed memory

Return Value:

    void

---*/
{
	WmipAssert(Ptr != NULL);
	LocalFree(Ptr);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\wbemlib\debug.cpp ===
//***************************************************************************
//
//  debug.CPP
//
//  Module: CDM Provider
//
//  Purpose: Debugging routines
//
//  Copyright (c) 2000 Microsoft Corporation
//
//***************************************************************************

#ifdef HEAP_DEBUG
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif
#include <windows.h>
#include <stdio.h>

#include "debug.h"


void __cdecl DebugOut(char *Format, ...)
{
    char Buffer[1024];
    va_list pArg;
    ULONG i;

    va_start(pArg, Format);
    i = _vsnprintf(Buffer, sizeof(Buffer), Format, pArg);
    OutputDebugString(Buffer);
}

#ifdef HEAP_DEBUG
PVOID MyHeap;

PVOID WmipAlloc(
    IN ULONG Size
    )
/*+++

Routine Description:

    Internal memory allocator
        
Arguments:

	Size is the number of bytes to allocate

Return Value:

	pointer to alloced memory or NULL

---*/
{
	PVOID p;
	
	if (MyHeap == NULL)
	{
        MyHeap = RtlCreateHeap(HEAP_GROWABLE |
							   HEAP_GENERATE_EXCEPTIONS |
							   HEAP_TAIL_CHECKING_ENABLED |
							   HEAP_FREE_CHECKING_ENABLED,
                                        NULL,
                                        0,
                                        0,
                                        NULL,
                                        NULL);
		if (MyHeap == NULL)
		{
			WmipDebugPrint(("CDMPROV: Could not create debug heap\n"));
			return(NULL);
		}
	}
	
	WmipAssert(RtlValidateHeap(MyHeap,
							   0,
							   NULL));
	
	p = RtlAllocateHeap(MyHeap,
						   0,
						   Size);

	return(p);
}

void WmipFree(
    IN PVOID Ptr
    )
/*+++

Routine Description:

    Internal memory deallocator
        
Arguments:

	Pointer to freed memory

Return Value:

    void

---*/
{
	WmipAssert(Ptr != NULL);
	WmipAssert(MyHeap != NULL);

	WmipAssert(RtlValidateHeap(MyHeap,
							   0,
							   NULL));
	RtlFreeHeap(MyHeap,
				0,
				Ptr);
}

void * __cdecl ::operator new(size_t Size)
{
	return(WmipAlloc(Size));
}

void __cdecl ::operator delete(void *Ptr)
{
	WmipFree(Ptr);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\wbemlib\cimmap.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cimmap.cpp
//
//
//  This file contains routines that will establish a mapping between
//  Wdm class instances and Cdm class instances. See
//  MapWdmClassToCimClass for more information.
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <wbemidl.h>

#include "debug.h"
#include "wbemmisc.h"
#include "useful.h"
#include "cimmap.h"

HRESULT WdmInstanceNameToPnPId(
    IWbemServices *pWdmServices,
    BSTR WdmInstanceName,
    VARIANT /* FREE */ *PnPId
    )
/*+++

Routine Description:

	This routine will convert a Wdm instance name into its
	corresponding pnp id
        
Arguments:

	pWdmServices is the pointer to the root\wmi namespace 

	WdmInstanceName

	*PnPId returns with the pnp id
		
Return Value:

    HRESULT

---*/
{
	WCHAR Query[2 * MAX_PATH];
	WCHAR s[MAX_PATH];
	BSTR sQuery;
	HRESULT hr;
	IEnumWbemClassObject *pWdmEnumInstances;
	IWbemClassObject *pWdmInstance;
	ULONG Count;
	BSTR sWQL;

	WmipAssert(pWdmServices != NULL);
	WmipAssert(WdmInstanceName != NULL);
	WmipAssert(PnPId != NULL);
	
	sWQL = SysAllocString(L"WQL");

	if (sWQL != NULL)
	{
		//
		// First get PnP id from Instance name from the MSWmi_PnPDeviceId
		// class (select * from MSWMI_PnPDeviceId where InstanceName =
		// "<WdmInstanceName>"
		//
		wsprintfW(Query,
				L"select * from MSWmi_PnPDeviceId where InstanceName = \"%ws\"",
				AddSlashesToStringW(s, WdmInstanceName));
		sQuery = SysAllocString(Query);
		if (sQuery != NULL)
		{
			hr = pWdmServices->ExecQuery(sWQL,
									sQuery,
									WBEM_FLAG_FORWARD_ONLY |
									WBEM_FLAG_ENSURE_LOCATABLE,
									NULL,
									&pWdmEnumInstances);

			if (hr == WBEM_S_NO_ERROR)
			{
				hr = pWdmEnumInstances->Next(WBEM_INFINITE,
											  1,
											  &pWdmInstance,
											  &Count);
				if ((hr == WBEM_S_NO_ERROR) &&
					(Count == 1))
				{
					hr = WmiGetProperty(pWdmInstance,
										L"PnPDeviceId",
										CIM_STRING,
										PnPId);

					pWdmInstance->Release();
				}

				pWdmEnumInstances->Release();
			} else {
				WmipDebugPrint(("CDMPROV: Query %ws failed %x\n",
								sQuery, hr));
			}
			
			SysFreeString(sQuery);
		} else {
			hr = WBEM_E_OUT_OF_MEMORY;
		}

		SysFreeString(sWQL);
	} else {
		hr  = WBEM_E_OUT_OF_MEMORY;
	}

	return(hr);
}

HRESULT FindCimClassByWdmInstanceName(
    IN IWbemServices *pWdmServices,
    IN IWbemServices *pCimServices,
    IN BSTR CimClassName,
    IN BSTR WdmInstanceName,
    OUT BSTR *PnPId,
    OUT BSTR /* FREE */ *CimRelPath
    )
/*+++

Routine Description:

	This routine will find the Cim class instance that corresponds to a
	particular Wdm class instance
        
Arguments:

	pWdmServices is the pointer to the root\wmi namespace
	
	pCdmServices is the pointer to the root\cimv2 namespace 

	CimClassName is the name of the cim class that the wdm instance
		would map to
		
	WdmInstanceName

    *PnPId returns with the PnP id for the device stack
    
	*CimRelPath returns with the relpath for the Cim instance
		
Return Value:

    HRESULT

---*/
{
	HRESULT hr;
	VARIANT v;
	IEnumWbemClassObject *pCimEnumInstances;
	IWbemClassObject *pCimInstance;
	ULONG Count;
	BSTR sWQL;

	WmipAssert(pWdmServices != NULL);
	WmipAssert(pCimServices != NULL);
	WmipAssert(CimClassName != NULL);
	WmipAssert(WdmInstanceName != NULL);
	WmipAssert(CimRelPath != NULL);
	
	sWQL = SysAllocString(L"WQL");

	if (sWQL != NULL)
	{

		// ****************************************************************
		// Note: Net cards need to do something similar. We get the
		// netcard address in class MSNDIS_???? and then get the CIM class
		// by matching the netcard addresses.
		// ****************************************************************
		
		//
		// First thing is to convert from an instance name to a pnpid
		//
		hr = WdmInstanceNameToPnPId(pWdmServices,
									WdmInstanceName,
									&v);

		if (hr == WBEM_S_NO_ERROR)
		{
			//
			// Next select * from CimClassName where PnPDeviceId = "<PnPDevice
			// Id from above>".
			//
			WCHAR Query[2 * MAX_PATH];
			WCHAR s[MAX_PATH];
			BSTR sQuery;

			wsprintfW(Query,
					  L"select * from %ws where PnPDeviceId = \"%ws\"",
					  CimClassName,
					  AddSlashesToStringW(s, v.bstrVal));
			*PnPId = v.bstrVal;

			sQuery = SysAllocString(Query);

			if (sQuery != NULL)
			{
				hr = pCimServices->ExecQuery(sWQL,
										sQuery,
										WBEM_FLAG_FORWARD_ONLY |
										WBEM_FLAG_ENSURE_LOCATABLE,
										NULL,
										&pCimEnumInstances);

				SysFreeString(sQuery);

				if (hr == WBEM_S_NO_ERROR)
				{
					hr = pCimEnumInstances->Next(WBEM_INFINITE,
												  1,
												  &pCimInstance,
												  &Count);
					if ((hr == WBEM_S_NO_ERROR) &&
						(Count == 1))
					{

						//
						// Finally grab the relpath from cim class and we're done
						//

						hr = WmiGetProperty(pCimInstance,
											L"__RELPATH",
											CIM_STRING,
											&v);

						if (hr == WBEM_S_NO_ERROR)
						{
							*CimRelPath = SysAllocString(v.bstrVal);
							if (*CimRelPath == NULL)
							{
								hr = WBEM_E_OUT_OF_MEMORY;
							}
							
							VariantClear(&v);
						}

						pCimInstance->Release();
					}

					pCimEnumInstances->Release();
				} else {
					WmipDebugPrint(("CDMPROV: Query %ws failed %x\n",
								Query, hr));
				}

			} else {
				hr = WBEM_E_OUT_OF_MEMORY;
			}		
		}
		
		SysFreeString(sWQL);
	} else {
		hr = WBEM_E_OUT_OF_MEMORY;
	}


	return(hr);
}

HRESULT GetEnumCount(
    IN IEnumWbemClassObject *pEnumInstances,
	OUT int *RelPathCount
    )
/*+++

Routine Description:

	This routine will return the count of instances in the enumeration
        
Arguments:

	pEnumInstance is the instance enumerator

	*RelPathCount returns the number of instances in the enumeration
		
Return Value:

    HRESULT

---*/
{
	ULONG Count;
	HRESULT hr;
	IWbemClassObject *pInstance;

	WmipAssert(pEnumInstances != NULL);
	WmipAssert(RelPathCount != NULL);
	
	*RelPathCount = 0;
	do
	{
		hr = pEnumInstances->Next(WBEM_INFINITE,
									 1,
									 &pInstance,
									 &Count);

		if ((hr == WBEM_S_NO_ERROR) &&
			(Count == 1))
		{
			(*RelPathCount)++;
			pInstance->Release();
		} else {
			if (hr == WBEM_S_FALSE)
			{
				hr = WBEM_S_NO_ERROR;
			}
			break;
		}
	} while (TRUE);
	
	return(hr);
}

HRESULT AllocateBstrArrays(
    ULONG Size,
    CBstrArray *WdmRelPaths,
    CBstrArray *CimRelPaths,
    CBstrArray *WdmInstanceNames,
    CBstrArray *PnPDeviceIds,
    CBstrArray *FriendlyName,
    CBstrArray *DeviceDesc
    )
{
	HRESULT hr;

	hr = WdmRelPaths->Initialize(Size);
	if (hr == WBEM_S_NO_ERROR)
	{
		hr = CimRelPaths->Initialize(Size);
		if (hr == WBEM_S_NO_ERROR)
		{
			hr = WdmInstanceNames->Initialize(Size);
			if (hr == WBEM_S_NO_ERROR)
			{
				hr = PnPDeviceIds->Initialize(Size);
				if (hr == WBEM_S_NO_ERROR)
				{
					hr = FriendlyName->Initialize(Size);
					if (hr == WBEM_S_NO_ERROR)
					{
						hr = DeviceDesc->Initialize(Size);
					}
				}
			}
		}
	}

	//
	// We don't worry about cleaning up in the case of a failure since
	// the destructors for CBstrArray will take care of that for us
	//
	
	return(hr);
}
						   
HRESULT GetDeviceProperties(
    IN IWbemContext *pCtx,
    IN IWbemServices *pWdmServices,
	IN PWCHAR InstanceName,
    OUT BSTR *FriendlyName,
    OUT BSTR *DeviceDesc
    )
{
	HRESULT hr, hrDontCare;
	VARIANT v;
	IWbemClassObject *pInstance;
	
	WmipAssert(pWdmServices != NULL);
	WmipAssert(InstanceName != NULL);
	WmipAssert(FriendlyName != NULL);
	WmipAssert(DeviceDesc != NULL);
	
	hr = GetInstanceOfClass(pCtx,
		                    pWdmServices,
							L"MSWmi_ProviderInfo",
							L"InstanceName",
							InstanceName,
							NULL,
							&pInstance);
	
	if (hr == WBEM_S_NO_ERROR)
	{
		hrDontCare = WmiGetProperty(pInstance,
							L"FriendlyName",
							CIM_STRING,
							&v);
		if (hrDontCare == WBEM_S_NO_ERROR)
		{
			*FriendlyName = v.bstrVal;
		} else {
			*FriendlyName = NULL;
		}

		hrDontCare = WmiGetProperty(pInstance,
							L"Description",
							CIM_STRING,
							&v);
		if (hrDontCare == WBEM_S_NO_ERROR)
		{
			*DeviceDesc = v.bstrVal;
		} else {
			*DeviceDesc = NULL;
		}

		pInstance->Release();
	}

	return(hr);
}


HRESULT MapWdmClassToCimClassViaPnpId(
    IWbemContext *pCtx,
    IN IWbemServices *pWdmServices,
    IN IWbemServices *pCimServices,
    IN BSTR WdmClassName,
    IN BSTR CimClassName,
    OUT CBstrArray *PnPDeviceIds,							  
    OUT CBstrArray *FriendlyName,							  
    OUT CBstrArray *DeviceDesc,							  
    OUT CBstrArray *WdmInstanceNames,							  
    OUT CBstrArray *WdmRelPaths,
    OUT CBstrArray *CimRelPaths,
    OUT int *RelPathCount
    )
/*+++

Routine Description:

	This routine will perform a mapping between the instances of WDM
	classes and Cim Classes
        
Arguments:

	pWdmServices

	pCdmServices

	WdmClassName

	CimClassName

	*PnPDeviceIds return with the an array of PnP device ids

	*WdmInstanceNames returns with an array of Wdm instnace names

	*WdmRelPaths returns with an array of relpaths to Wdm instances

	*CimRelpaths returns with an array of relapaths to Cim instance

	*RelPathCount returns with the count of instances that are mapped
	
Return Value:

    HRESULT

---*/
{
	IWbemClassObject *pWdmInstance;
	IEnumWbemClassObject *pWdmEnumInstances;
	HRESULT hr;
	int i, NumberWdmInstances;
	VARIANT v;
	ULONG Count;
	BSTR bstr1, bstr2;
	BSTR f,d;

	WmipAssert(pWdmServices != NULL);
	WmipAssert(pCimServices != NULL);
	WmipAssert(WdmClassName != NULL);
	WmipAssert(CimClassName != NULL);
	WmipAssert(RelPathCount != NULL);
	WmipAssert((PnPDeviceIds != NULL) && ( ! PnPDeviceIds->IsInitialized()));
	WmipAssert((FriendlyName != NULL) && ( ! FriendlyName->IsInitialized()));
	WmipAssert((DeviceDesc != NULL) && ( ! DeviceDesc->IsInitialized()));
	WmipAssert((WdmInstanceNames != NULL) && (! WdmInstanceNames->IsInitialized()));
	WmipAssert((WdmRelPaths != NULL) && ( ! WdmRelPaths->IsInitialized()));
	WmipAssert((CimRelPaths != NULL) && ( ! CimRelPaths->IsInitialized()));

	//
	// Get all instances of the Wdm Class
	//
	hr = pWdmServices->CreateInstanceEnum(WdmClassName,
										  WBEM_FLAG_USE_AMENDED_QUALIFIERS |
										  WBEM_FLAG_SHALLOW,
										  NULL,
										  &pWdmEnumInstances);

	if (hr == WBEM_S_NO_ERROR)
	{
		hr = GetEnumCount(pWdmEnumInstances,
						  RelPathCount);

		NumberWdmInstances = *RelPathCount;
		if (hr == WBEM_S_NO_ERROR)
		{
			hr = AllocateBstrArrays(NumberWdmInstances,
									WdmRelPaths,
									CimRelPaths,
									WdmInstanceNames,
									PnPDeviceIds,
								    FriendlyName,
								    DeviceDesc);
			
			if (hr == WBEM_S_NO_ERROR)
			{
				pWdmEnumInstances->Reset();
				i = 0;
				do
				{
					hr = pWdmEnumInstances->Next(WBEM_INFINITE,
												 1,
												 &pWdmInstance,
												 &Count);

					if ((hr == WBEM_S_NO_ERROR) &&
						(Count == 1) &&
						(i < NumberWdmInstances))
					{
						//
						// Lets get the instance name and then lookup the pnp
						// id for it
						//
						hr = WmiGetProperty(pWdmInstance,
											L"InstanceName",
											CIM_STRING,
											&v);

						if (hr == WBEM_S_NO_ERROR)
						{
							//
							// Remember wdm instnace name
							//
							WmipDebugPrint(("CDMPROV: Wdm InstanceName is %ws\n",
											v.bstrVal));
							WdmInstanceNames->Set(i, v.bstrVal);
							hr = FindCimClassByWdmInstanceName(pWdmServices,
								                               pCimServices,
								                               CimClassName,
								                               v.bstrVal,
								                               &bstr1,
								                               &bstr2);
							
							PnPDeviceIds->Set(i, bstr1);
							CimRelPaths->Set(i, bstr2);
							
							if (hr == WBEM_S_NO_ERROR)
							{
								//
								// Remember Wdm class relative path
								//
								WmipDebugPrint(("CDMPROV: Found CimRelPath %ws for Wdm class %ws\n",
												CimRelPaths->Get(i), WdmClassName))
								hr = WmiGetProperty(pWdmInstance,
									                L"__RELPATH",
													CIM_STRING,
													&v);
								if (hr == WBEM_S_NO_ERROR)
								{
									WdmRelPaths->Set(i, v.bstrVal);

									//
									// Now try to get FriendlyName and
									// DeviceDesc for the instance
									//
									hr = GetDeviceProperties(pCtx,
										                     pWdmServices,
										                     WdmInstanceNames->Get(i),
                                                             &f,
                                                             &d);
									
									if (hr == WBEM_S_NO_ERROR)
									{
										if (f != NULL)
										{
											FriendlyName->Set(i, f);
										}

										if (d != NULL)
										{
											DeviceDesc->Set(i, d);
										}
									}
									
									i++;
										                    
								}
							} else {
								//
								// We did not find a CIM class
								// to match our Wdm instance
								// names, so we decrement our
								// relpath count and continue
								// searching
								(*RelPathCount)--;
								if (*RelPathCount == 0)
								{
									hr = WBEM_E_NOT_FOUND;
								} else {
									hr = WBEM_S_NO_ERROR;
								}
							}
						}
						pWdmInstance->Release();
					} else {
						if (hr == WBEM_S_FALSE)
						{
							hr = WBEM_S_NO_ERROR;
						}
						break;
					}
				} while (hr == WBEM_S_NO_ERROR);				
			} else {
				hr = WBEM_E_OUT_OF_MEMORY;							
			}
		}
		pWdmEnumInstances->Release();
	}
	
	return(hr);
}

HRESULT FindRelPathByProperty(
    IN IWbemContext *pCtx,
	IN IWbemServices *pServices,
    IN BSTR ClassName,
    IN BSTR PropertyName,
    IN VARIANT *ValueToMatch,
    IN CIMTYPE CIMTypeToMatch,
    OUT VARIANT *RelPath
    )
{
	WCHAR PropertyValue[MAX_PATH];
	PWCHAR pv;
	HRESULT hr;
	IWbemClassObject *pInstance;
	
	WmipAssert(pServices != NULL);
	WmipAssert(ClassName != NULL);
	WmipAssert(PropertyName != NULL);
	WmipAssert(ValueToMatch != NULL);
	WmipAssert(RelPath != NULL);

	pv = PropertyValue;
	
	switch (ValueToMatch->vt)
	{
		
        case VT_I1:
        {
            wsprintfW(PropertyValue, L"%d", ValueToMatch->cVal);
            break;
        }
                            
        case VT_UI1:
        {
            wsprintfW(PropertyValue, L"%d", ValueToMatch->bVal);
            break;
        }
                            
        case VT_I2:
        {
            wsprintfW(PropertyValue, L"%d", ValueToMatch->iVal);
            break;
        }
                                                        
        case VT_UI2:
        {
            wsprintfW(PropertyValue, L"%d", ValueToMatch->uiVal);
            break;
        }
		

        case VT_UI4:
        {
            wsprintfW(PropertyValue, L"%d", ValueToMatch->ulVal);
            break;
        }
            
        case VT_I4:
        {
            wsprintfW(PropertyValue, L"%d", ValueToMatch->lVal);
            break;
        }

		case VT_BOOL:
		{
			pv = (ValueToMatch->boolVal == VARIANT_TRUE) ?
					                   L"TRUE":
				                       L"FALSE";
			break;
		}

		case VT_BSTR:
		{
			pv = ValueToMatch->bstrVal;
			break;
		}
		
		default:
		{
			WmipDebugPrint(("WMIMAP: Unable to map WDM to CIM for CIMTYPE/VT %d/%d\n",
							CIMTypeToMatch, ValueToMatch->vt));
			return(WBEM_E_FAILED);
		}
	}

	hr = GetInstanceOfClass(pCtx,
							pServices,
							ClassName,
							PropertyName,
							pv,
							NULL,
							&pInstance);
	
	if (hr == WBEM_S_NO_ERROR)
	{
		hr = WmiGetProperty(pInstance,
							L"__RELPATH",
							CIM_REFERENCE,
							RelPath);
		
		pInstance->Release();
	}
	
	return(hr);
}
    

HRESULT MapWdmClassToCimClassViaProperty(
    IN IWbemContext *pCtx,
	IN IWbemServices *pWdmServices,
	IN IWbemServices *pCimServices,
	IN BSTR WdmShadowClassName,
	IN BSTR WdmMappingClassName,
    IN OPTIONAL BSTR WdmMappingProperty,
	IN BSTR CimMappingClassName,
    IN OPTIONAL BSTR CimMappingProperty,
    OUT CBstrArray *WdmInstanceNames,
    OUT CBstrArray *WdmRelPaths,
    OUT CBstrArray *CimRelPaths,
    OUT int *RelPathCount
	)
{

	HRESULT hr;
	IEnumWbemClassObject *pWdmEnumInstances;
	int NumberWdmInstances;
    CBstrArray PnPDeviceIds, FriendlyName, DeviceDesc;
	CIMTYPE WdmCimType;
	VARIANT WdmProperty, WdmInstanceName;
	VARIANT CimRelPath, WdmRelPath;
	int i;
	IWbemClassObject *pWdmInstance;
	ULONG Count;
	
	WmipAssert(pWdmServices != NULL);
	WmipAssert(pCimServices != NULL);
	WmipAssert(WdmShadowClassName != NULL);
	WmipAssert(WdmMappingClassName != NULL);
	WmipAssert(WdmMappingProperty != NULL);
	WmipAssert(CimMappingClassName != NULL);
	WmipAssert(CimMappingProperty != NULL);

	//
	// We need to do a mapping from a WDM class to a CIM class. This is
	// done via a common property value within the CIM and WDM mapping
	// classes. If the WDM mapping and shadow classes are different
	// then it is assumed that they both report the same instance names
	//


	//
	// First thing is to enumerate all instances of the WDM mapping
	// class.
	//
	hr = pWdmServices->CreateInstanceEnum(WdmMappingClassName,
										  WBEM_FLAG_USE_AMENDED_QUALIFIERS |
										  WBEM_FLAG_SHALLOW,
										  NULL,
										  &pWdmEnumInstances);

	if (hr == WBEM_S_NO_ERROR)
	{
		hr = GetEnumCount(pWdmEnumInstances,
						  &NumberWdmInstances);

		if (hr == WBEM_S_NO_ERROR)
		{
			hr = AllocateBstrArrays(NumberWdmInstances,
									WdmRelPaths,
									CimRelPaths,
									WdmInstanceNames,
									&PnPDeviceIds,
								    &FriendlyName,
								    &DeviceDesc);
			
			if (hr == WBEM_S_NO_ERROR)
			{
				pWdmEnumInstances->Reset();
				i = 0;
				*RelPathCount = 0;
				do
				{
					VariantInit(&CimRelPath);
					VariantInit(&WdmRelPath);
					VariantInit(&WdmInstanceName);

					hr = pWdmEnumInstances->Next(WBEM_INFINITE,
												 1,
												 &pWdmInstance,
												 &Count);

					if ((hr == WBEM_S_NO_ERROR) &&
						(Count == 1) &&
						(i < NumberWdmInstances))
					{
						//
						// For each instance we try to find an instance
						// of a CIM class whose property matches that
						// of the WDM property. So first lets get the
						// WDM property
						//
						hr = pWdmInstance->Get(WdmMappingProperty,
											   0,
											   &WdmProperty,
											   &WdmCimType,
											   NULL);
						if (hr == WBEM_S_NO_ERROR)
						{
							hr = FindRelPathByProperty(pCtx,
								                       pCimServices,
								                       CimMappingClassName,
								                       CimMappingProperty,
								                       &WdmProperty,
								                       WdmCimType,
								                       &CimRelPath);
							if (hr == WBEM_S_NO_ERROR)
							{
								//
								// We found a mapping to a CIM class so
								// get the instance name of the mapping
								// class
								//
								hr = WmiGetProperty(pWdmInstance,
									                L"InstanceName",
									                CIM_STRING,
									                &WdmInstanceName);
								
								if (hr == WBEM_S_NO_ERROR)
								{
									//
									// Now finally we can get the
									// shadow class instance by means
									// of the instance name
									//
									hr = FindRelPathByProperty(pCtx,
										                       pWdmServices,
										                       WdmShadowClassName,
															   L"InstanceName",
										                       &WdmInstanceName,
										                       CIM_STRING,
										                       &WdmRelPath);
									if (hr == WBEM_S_NO_ERROR)
									{									
										CimRelPaths->Set(i, CimRelPath.bstrVal);
										VariantInit(&CimRelPath);
										WdmRelPaths->Set(i, WdmRelPath.bstrVal);
										VariantInit(&WdmRelPath);
										WdmInstanceNames->Set(i, WdmInstanceName.bstrVal);
										VariantInit(&WdmInstanceName);
										i++;
										(*RelPathCount)++;
									}
								}
								
							}
							VariantClear(&WdmProperty);
						}
						pWdmInstance->Release();											
					} else {
						if (hr == WBEM_S_FALSE)
						{
							hr = WBEM_S_NO_ERROR;
						}
						break;
					}

					VariantClear(&CimRelPath);
					VariantClear(&WdmRelPath);
					VariantClear(&WdmInstanceName);
					
				} while (hr == WBEM_S_NO_ERROR);				
			}
		}
		
		pWdmEnumInstances->Release();
	}
	return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\wmisecur\wmisecur.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    wmisecur.c

Abstract:

    Wmi security tool

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#define INITGUID

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <stdlib.h>

#include <aclapi.h>

#include "wmium.h"

#include "wmiumkm.h"

#define SE_WMIGUID_OBJECT 11
#define WMI_SECURITY_REGSTR "SYSTEM\\CurrentControlSet\\Control\\WMI\\Security"

#define WmipAllocEvent() CreateEvent(NULL, FALSE, FALSE, NULL)
#define WmipFreeEvent(EventHandle) CloseHandle(EventHandle)
HANDLE WmipKMHandle;
ULONG PrintSecurityString(LPSTR Guid);

ULONG WmipSendWmiKMRequest(
    ULONG Ioctl,
    PVOID Buffer,
    ULONG InBufferSize,
    ULONG MaxBufferSize,
    ULONG *ReturnSize
    )
/*+++

Routine Description:

    This routine does the work of sending WMI requests to the WMI kernel
    mode device.  Any retry errors returned by the WMI device are handled
    in this routine.

Arguments:

    Ioctl is the IOCTL code to send to the WMI device
    Buffer is the input and output buffer for the call to the WMI device
    InBufferSize is the size of the buffer passed to the device
    MaxBufferSize is the maximum number of bytes that can be written 
        into the buffer
    *ReturnSize on return has the actual number of bytes written in buffer

Return Value:

    ERROR_SUCCESS or an error code
---*/
{
    OVERLAPPED Overlapped;
    ULONG Status;
    BOOL IoctlSuccess;

    if (WmipKMHandle == NULL)
    {
        //
        // If device is not open for then open it now. The
        // handle is closed in the process detach dll callout (DlllMain)
        WmipKMHandle = CreateFile(WMIDataDeviceName,
                                      GENERIC_READ | GENERIC_WRITE,
                                      0,
                                      NULL,
                                      OPEN_EXISTING,
                                      FILE_ATTRIBUTE_NORMAL | 
                                      FILE_FLAG_OVERLAPPED,
                                      NULL);
        if (WmipKMHandle == (HANDLE)-1)
        {
            WmipKMHandle = NULL;
            return(GetLastError());
        }
    }
        
    Overlapped.hEvent = WmipAllocEvent();
    if (Overlapped.hEvent == NULL)
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    
    do 
    {
        IoctlSuccess = DeviceIoControl(WmipKMHandle,
                              Ioctl,
                              Buffer,
                              InBufferSize,
                              Buffer,
                              MaxBufferSize,
                              ReturnSize,
                              &Overlapped);
              
        if (GetLastError() == ERROR_IO_PENDING)
        {
            IoctlSuccess = GetOverlappedResult(WmipKMHandle,
                                               &Overlapped,
                                               ReturnSize,
                                               TRUE);
        }
        
        if (! IoctlSuccess)
        {
            Status = GetLastError();
        } else {
            Status = ERROR_SUCCESS;
        }
    } while (Status == ERROR_WMI_TRY_AGAIN);
    
    WmipFreeEvent(Overlapped.hEvent);
    return(Status);
}

#ifdef SET_SECURITY_BY_HANDLE    
ULONG WmipOpenKernelGuid(
    LPGUID Guid,
    ACCESS_MASK DesiredAccess,
    PHANDLE Handle
    )
{
    WMIOPENGUIDBLOCK WmiOpenGuidBlock;
    ULONG ReturnSize;
    ULONG Status;
    
    WmiOpenGuidBlock.Guid = *Guid;
    WmiOpenGuidBlock.DesiredAccess = DesiredAccess;
                          
    Status = WmipSendWmiKMRequest(IOCTL_WMI_OPEN_GUID,
                                  (PVOID)&WmiOpenGuidBlock,
                                  sizeof(WMIOPENGUIDBLOCK),
                                  sizeof(WMIOPENGUIDBLOCK),
                                  &ReturnSize);
                              
    if (Status == ERROR_SUCCESS)
    {
          *Handle = WmiOpenGuidBlock.Handle;
    } else {
        *Handle = NULL;
    }
    return(Status);                      
}
#endif

ULONG SetWmiGuidSecurityInfo(
    LPGUID Guid,
    SECURITY_INFORMATION SecurityInformation,
    PSID OwnerSid,
    PSID GroupSid,
    PACL Dacl,
    PACL Sacl
    )
{
    HANDLE Handle;
    ULONG Status;
#ifdef SET_SECURITY_BY_HANDLE    
    Status = WmipOpenKernelGuid(Guid,
                                WRITE_DAC | WRITE_OWNER,
                                &Handle);
                
    if (Status == ERROR_SUCCESS)
    {
        Status = SetSecurityInfo(Handle,
                                 SE_KERNEL_OBJECT,
                                 SecurityInformation,
                                 OwnerSid,
                                 GroupSid,
                                 Dacl,
                                 Sacl);
        CloseHandle(Handle);
    }
    
#else
    PCHAR GuidName;

    Status = UuidToString(Guid,
                          &GuidName);
           
    if (Status == ERROR_SUCCESS)
    {
        Status = SetNamedSecurityInfo(GuidName,
                                 SE_WMIGUID_OBJECT,
                                 SecurityInformation,
                                 OwnerSid,
                                 GroupSid,
                                 Dacl,
                                 Sacl);
        RpcStringFree(&GuidName);
    }
#endif
    return(Status);
}

ULONG GetWmiGuidSecurityInfo(
    LPGUID Guid,
    SECURITY_INFORMATION SecurityInformation,
    PSID *OwnerSid,
    PSID *GroupSid,
    PACL *Dacl,
    PACL *Sacl,
    PSECURITY_DESCRIPTOR *Sd
    )
{
    HANDLE Handle;
    ULONG Status;

#ifdef SET_SECURITY_BY_HANDLE    
    Status = WmipOpenKernelGuid(Guid,
                                READ_CONTROL,
                                &Handle);
            
    if (Status == ERROR_SUCCESS)
    {
        Status = GetSecurityInfo(Handle,
                                 SE_KERNEL_OBJECT,
                                 SecurityInformation,
                                 OwnerSid,
                                 GroupSid,
                                 Dacl,
                                 Sacl,
                                 Sd);
        CloseHandle(Handle);
    }
#else
    PCHAR GuidName;

    Status = UuidToString(Guid,
                          &GuidName);
           
    if (Status == ERROR_SUCCESS)
    {
        Status = GetNamedSecurityInfo(GuidName,
                                 SE_WMIGUID_OBJECT,
                                 SecurityInformation,
                                 OwnerSid,
                                 GroupSid,
                                 Dacl,
                                 Sacl,
                                 Sd);
                             
        RpcStringFree(&GuidName);

    }
#endif
    
    return(Status);
}



//
// The routines below were blantenly stolen without remorse from the ole
// sources in \nt\private\ole32\com\class\compapi.cxx. They are copied here
// so that WMI doesn't need to load in ole32 only to convert a guid string
// into its binary representation.
//


//+-------------------------------------------------------------------------
//
//  Function:   HexStringToDword   (private)
//
//  Synopsis:   scan lpsz for a number of hex digits (at most 8); update lpsz
//              return value in Value; check for chDelim;
//
//  Arguments:  [lpsz]    - the hex string to convert
//              [Value]   - the returned value
//              [cDigits] - count of digits
//
//  Returns:    TRUE for success
//
//--------------------------------------------------------------------------
BOOL HexStringToDword(LPCSTR lpsz, DWORD * RetValue,
                             int cDigits, WCHAR chDelim)
{
    int Count;
    DWORD Value;

    Value = 0;
    for (Count = 0; Count < cDigits; Count++, lpsz++)
    {
        if (*lpsz >= '0' && *lpsz <= '9')
            Value = (Value << 4) + *lpsz - '0';
        else if (*lpsz >= 'A' && *lpsz <= 'F')
            Value = (Value << 4) + *lpsz - 'A' + 10;
        else if (*lpsz >= 'a' && *lpsz <= 'f')
            Value = (Value << 4) + *lpsz - 'a' + 10;
        else
            return(FALSE);
    }

    *RetValue = Value;
    
    if (chDelim != 0)
        return *lpsz++ == chDelim;
    else
        return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   wUUIDFromString    (internal)
//
//  Synopsis:   Parse UUID such as 00000000-0000-0000-0000-000000000000
//
//  Arguments:  [lpsz]  - Supplies the UUID string to convert
//              [pguid] - Returns the GUID.
//
//  Returns:    TRUE if successful
//
//--------------------------------------------------------------------------
BOOL wUUIDFromString(LPCSTR lpsz, LPGUID pguid)
{
        DWORD dw;

        if (!HexStringToDword(lpsz, &pguid->Data1, sizeof(DWORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(DWORD)*2 + 1;
        
        if (!HexStringToDword(lpsz, &dw, sizeof(WORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(WORD)*2 + 1;

        pguid->Data2 = (WORD)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(WORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(WORD)*2 + 1;

        pguid->Data3 = (WORD)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[0] = (BYTE)dw;
        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, '-'))
                return FALSE;
        lpsz += sizeof(BYTE)*2+1;

        pguid->Data4[1] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[2] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[3] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[4] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[5] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[6] = (BYTE)dw;
        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[7] = (BYTE)dw;

        return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   wGUIDFromString    (internal)
//
//  Synopsis:   Parse GUID such as {00000000-0000-0000-0000-000000000000}
//
//  Arguments:  [lpsz]  - the guid string to convert
//              [pguid] - guid to return
//
//  Returns:    TRUE if successful
//
//--------------------------------------------------------------------------
BOOL wGUIDFromString(LPCSTR lpsz, LPGUID pguid)
{
    DWORD dw;

    if (*lpsz == '{' )
        lpsz++;

    if(wUUIDFromString(lpsz, pguid) != TRUE)
        return FALSE;

    lpsz +=36;

    if (*lpsz == '}' )
        lpsz++;

    if (*lpsz != '\0')   // check for zero terminated string - test bug #18307
    {
       return FALSE;
    }

    return TRUE;
}


ULONG RemoveWmiSD(
    LPGUID Guid
    )
{
    CHAR GuidName[35];
    HKEY RegistryKey;
    ULONG Status;
    
    Status = RegOpenKey(HKEY_LOCAL_MACHINE,
                            "System\\CurrentControlSet\\Control\\Wmi\\Security",
                            &RegistryKey);
    if (Status != ERROR_SUCCESS)
    {
        printf("RegOpenKey returned %d\n", Status);
        return(Status);
    }
        
    if (Guid != NULL)
    {
        wsprintf(GuidName, "%08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x",
                     Guid->Data1, Guid->Data2,
                     Guid->Data3,
                     Guid->Data4[0], Guid->Data4[1],
                     Guid->Data4[2], Guid->Data4[3],
                     Guid->Data4[4], Guid->Data4[5],
                     Guid->Data4[6], Guid->Data4[7]);
    } else {
        strcpy(GuidName, "00000000-0000-0000-0000000000000000");
    }
    
    RegDeleteValue(RegistryKey,
                   GuidName);
               
    RegCloseKey(RegistryKey);
    
    return(ERROR_SUCCESS);
}

void Usage(
    void
    )
{
    printf("wmisecur <guid> [owner | group | dacl | adacl] [parameters]\n");
    printf("    wmisecur <guid> owner <account name>\n");
    printf("        sets owner of guid to be <account name>\n\n");
    printf("    wmisecur <guid> group <account name>\n");
    printf("        sets group of guid to be <account name>\n\n");
    printf("    wmisecur <guid> dacl <account name> [allow | deny] <right1> <right2> ....\n");
    printf("        resets dacl to assign <right1>, <right2>, ... to <account name>\n\n");
    printf("    wmisecur <guid> adacl <account name> [allow | deny] <right1> <right2> ....\n");
    printf("        appends ace to dacl,<right1>, <right2>, ... assigned to <account name>\n\n");
    printf("    wmisecur <guid> query\n");
    printf("        queries and prints the security string\n\n");
    printf("    Rights: WMIGUID_QUERY\n");
    printf("            WMIGUID_SET\n");
    printf("            WMIGUID_NOTIFICATION\n");
    printf("            WMIGUID_READ_DESCRIPTION\n");
    printf("            WMIGUID_EXECUTE\n");
    printf("            TRACELOG_CREATE_REALTIME\n");
    printf("            TRACELOG_CREATE_ONDISK\n");
    printf("            TRACELOG_GUID_ENABLE\n");
    printf("            TRACELOG_ACCESS_KERNEL_LOGGER\n");
    printf("            TRACELOG_CREATE_INPROC\n");
    printf("            TRACELOG_ACCESS_REALTIME\n");
    printf("            READ_CONTROL\n");
    printf("            WRITE_DAC\n");
    printf("            WRITE_OWNER\n");
    printf("            DELETE\n");
    printf("            SYNCHRONIZE\n");
    printf("            ALL (all wmi specific rights)\n");
    printf("            ALLRIGHTS (STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL)\n");
}

typedef enum
{
    SetOwner,
    SetGroup,
    ResetDacl,
    AppendDacl,
    CopyDacl,
    QueryGuid
} OPERATION;

typedef enum
{
    Allow,
    Deny
} ALLOWORDENY;


ULONG SetOwnerOrGroup(
    OPERATION Operation,
    LPGUID Guid,
    PSID Sid
    )
{
    ULONG Status;
    
    if (Operation == SetOwner)
    {        
        Status = SetWmiGuidSecurityInfo(Guid,
                                        OWNER_SECURITY_INFORMATION,
                                        Sid,
                                        NULL,
                                        NULL,
                                        NULL);
    } else {
        Status = SetWmiGuidSecurityInfo(Guid,
                                        GROUP_SECURITY_INFORMATION,
                                        NULL,
                                        Sid,
                                        NULL,
                                        NULL);
    }
    return(Status);                                   
}
    
ULONG ResetOrAppendDacl(
    OPERATION Operation,
    LPGUID Guid,
    PSID Sid,
    ALLOWORDENY AllowOrDeny,
    ULONG Rights
    )
{
    ULONG Status;
    PSECURITY_DESCRIPTOR OldSD;
    PACL OldDacl, NewDacl;
    UCHAR NewDaclBuffer[512];
    
    NewDacl = (PACL)NewDaclBuffer;
    if ((Operation == AppendDacl) || (Operation == CopyDacl))
    {
        Status = GetWmiGuidSecurityInfo(Guid,
                                        DACL_SECURITY_INFORMATION,
                                        NULL,
                                        NULL,
                                        &OldDacl,
                                        NULL,
                                        &OldSD);
        if (Status != ERROR_SUCCESS)
        {
            return(Status);
        }
        
        memcpy(NewDacl, OldDacl, OldDacl->AclSize);
        LocalFree(OldSD);
        NewDacl->AclSize = sizeof(NewDaclBuffer);
    } else {
        RtlCreateAcl(NewDacl,
                     sizeof(NewDaclBuffer),
                     ACL_REVISION);
            
    }

    if (Operation != CopyDacl)
    {
        if (AllowOrDeny == Deny)
        {
            if (! AddAccessDeniedAce(NewDacl, 
                                 ACL_REVISION,
                                 Rights,
                                     Sid))
            {
                return(GetLastError());
            }
        } else {
            if (! AddAccessAllowedAce(NewDacl, 
                                     ACL_REVISION,
                                     Rights,
                                     Sid))
            {
                return(GetLastError());
            }
        }
    }
    
      Status = SetWmiGuidSecurityInfo(Guid,
                                        DACL_SECURITY_INFORMATION,
                                        NULL,
                                        NULL,
                                        NewDacl,
                                        NULL);
    
    
    return(Status);
}

BOOLEAN RightNameToDWord(
    PCHAR RightName,
    PDWORD RightDWord
    )
{
    *RightDWord = 0;
    if (_stricmp(RightName, "WMIGUID_QUERY") == 0)
    {
        *RightDWord = WMIGUID_QUERY;
    } else if (_stricmp(RightName, "WMIGUID_SET") == 0) {
        *RightDWord = WMIGUID_SET;
    } else if (_stricmp(RightName, "WMIGUID_NOTIFICATION") == 0) {
        *RightDWord = WMIGUID_NOTIFICATION;
    } else if (_stricmp(RightName, "WMIGUID_READ_DESCRIPTION") == 0) {
        *RightDWord = WMIGUID_READ_DESCRIPTION;
    } else if (_stricmp(RightName, "WMIGUID_EXECUTE") == 0) {
        *RightDWord = WMIGUID_EXECUTE;
    } else if (_stricmp(RightName, "TRACELOG_CREATE_REALTIME") == 0) {
        *RightDWord = TRACELOG_CREATE_REALTIME;
    } else if (_stricmp(RightName, "TRACELOG_CREATE_ONDISK") == 0) {
        *RightDWord = TRACELOG_CREATE_ONDISK;
    } else if (_stricmp(RightName, "TRACELOG_GUID_ENABLE") == 0) {
        *RightDWord = TRACELOG_GUID_ENABLE;
    } else if (_stricmp(RightName, "TRACELOG_ACCESS_KERNEL_LOGGER") == 0) {
        *RightDWord = TRACELOG_ACCESS_KERNEL_LOGGER;
    } else if (_stricmp(RightName, "TRACELOG_CREATE_INPROC") == 0) {
        *RightDWord = TRACELOG_CREATE_INPROC;
    } else if (_stricmp(RightName, "TRACELOG_ACCESS_REALTIME") == 0) {
        *RightDWord = TRACELOG_ACCESS_REALTIME;
    } else if (_stricmp(RightName, "READ_CONTROL") == 0) {
        *RightDWord = READ_CONTROL;
    } else if (_stricmp(RightName, "WRITE_DAC") == 0) {
        *RightDWord = WRITE_DAC;
    } else if (_stricmp(RightName, "WRITE_OWNER") == 0) {
        *RightDWord = WRITE_OWNER;
    } else if (_stricmp(RightName, "WRITE_DAC") == 0) {
        *RightDWord = WRITE_DAC;
    } else if (_stricmp(RightName, "DELETE") == 0) {
        *RightDWord = DELETE;
    } else if (_stricmp(RightName, "SYNCHRONIZE") == 0) {
        *RightDWord = SYNCHRONIZE;
    } else if (_stricmp(RightName, "ALL") == 0) {
        *RightDWord = WMIGUID_ALL_ACCESS;
    } else if (_stricmp(RightName, "ALLRIGHTS") == 0) {
        *RightDWord = STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL;
    } else {
        return(FALSE);
    }
    
    return(TRUE);
}


int __cdecl main(int argc, char *argv[])
{
    int i;
    ALLOWORDENY AllowOrDeny;
    OPERATION Operation;
    DWORD Rights;
    DWORD NewRight;
    PSID Sid;
    UCHAR SidBuffer[512];
    ULONG SidLength;
    GUID Guid;    
    CHAR ReferencedDomain[512];
    SID_NAME_USE SidNameUse;
    ULONG ReferencedDomainSize;
    ULONG Status;
    
    if (argc < 2)
    {
        Usage();
        return(0);
    }
    
    
    if (_stricmp(argv[2], "owner") == 0)
    {
        Operation = SetOwner;
    } else if (_stricmp(argv[2], "group") == 0) {
        Operation = SetGroup;
    } else if (_stricmp(argv[2], "dacl") == 0) {
        Operation = ResetDacl;
    }  else if (_stricmp(argv[2], "adacl") == 0) {
        Operation = AppendDacl;
    }  else if (_stricmp(argv[2], "copy") == 0) {
        Operation = CopyDacl;
    }  else if (_stricmp(argv[2], "query") == 0) {
        Operation = QueryGuid;
    } else {
        Usage();
        return(0);
    }
    
    //
    // Parse the guid parameter
    if (! wUUIDFromString(argv[1], &Guid))
    {
        printf("Bad guid %s\n", argv[1]);
        return(0);
    }
    
    if (Operation == QueryGuid)
    {
        if (PrintSecurityString(argv[1]))
            printf("Cannot find security set for given guid\n");
        return 0;
    }
    if (Operation == CopyDacl)
    {
        Status = ResetOrAppendDacl(Operation, &Guid, NULL, Allow, 0);
        printf("Status is %d\n", Status);
        return(Status);
    }
    
    if (_stricmp(argv[3], "LocalSystem") == 0)
    {
        //
		// This is a special SID we need to build by hand
		//
			
        //
        // Create SID for LocalSystem dynamically
		//
        Sid = (PSID)malloc(RtlLengthRequiredSid( 1 ));
        if (Sid != NULL)
        {
            SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
            RtlInitializeSid( Sid, &NtAuthority, 1);
            *(RtlSubAuthoritySid( Sid, 0 )) = SECURITY_LOCAL_SYSTEM_RID;
        } else {
            printf("Not enougfh memory for local system sid\n");
			return(ERROR_NOT_ENOUGH_MEMORY);
        }
        
    } else {    
        //
        // Parse the account name parameter
        Sid = (PSID)SidBuffer;
        SidLength = sizeof(SidBuffer);
        ReferencedDomainSize = sizeof(ReferencedDomain);
        if (! LookupAccountName(NULL,
                            argv[3],
                            Sid,
                            &SidLength,
                            ReferencedDomain,
                            &ReferencedDomainSize,
                            &SidNameUse))
        {
            printf("Error %d looking up account %s\n", GetLastError(), argv[3]);
            return(0);
        }
    }
                                    
    
    if ((Operation == SetOwner) ||
        (Operation == SetGroup))
    
    {
        Status = SetOwnerOrGroup(Operation, &Guid, Sid);
        printf("Status is %d\n", Status);
        if (Status == 0) {
            PrintSecurityString(argv[1]);
        }
    } else {
        if (argc < 4)
        {
            Usage();
            return(0);
        }
        
        if (_stricmp(argv[4], "allow") == 0)
        {
            AllowOrDeny = Allow;
        } else if (_stricmp(argv[4], "deny") == 0) {
            AllowOrDeny = Deny;
        } else {
            Usage();
            return(0);
        }
        
        Rights = 0;
        for (i = 5; i < argc; i++)
        {
            if (! RightNameToDWord(argv[i], &NewRight))
            {
                printf("Invalid right %s\n", argv[i]);
                return(0);
            }
            Rights |= NewRight;
        }
        Status = ResetOrAppendDacl(Operation, &Guid, Sid, AllowOrDeny, Rights);
        printf("Status is %d\n", Status);
        if (Status == 0) {
            PrintSecurityString(argv[1]);
        }
    }
}

ULONG
PrintSecurityString(LPSTR GuidStr)
{
    ULONG status;
    HKEY hKey;
    UCHAR buffer[1024];
    ULONG size, i;

    status = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                WMI_SECURITY_REGSTR,
                0L,
                KEY_QUERY_VALUE,
                &hKey);
    if (status != ERROR_SUCCESS)
        return status;
    size = 1024;
    status = RegQueryValueEx(
                hKey,
                GuidStr,
                NULL,
                NULL,
                buffer,
                &size);
    if (status != ERROR_SUCCESS) {
        RegCloseKey(hKey);
        return status;
    }
    printf("\nHKLM,\"%s\",\"%s\",0x00030003,\\\n",
        WMI_SECURITY_REGSTR, GuidStr);
    for (i=0; i<size; i++) {
        if ((i%16) == 0) {
            if (i>0)
                printf(",\\\n");
            printf("        ");
            printf("%02x", buffer[i]);
        }
        else
            printf(",%02x", buffer[i]);
    }
    printf("\n");
    RegCloseKey(hKey);
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\wbemlib\wbemmisc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       wbemmisc.cpp
//
//  Abstract:    Misc routines useful for interfacing with WBEM
//
//--------------------------------------------------------------------------

#include <objbase.h>
#include <windows.h>
#include <wbemidl.h>
#include <wbemtime.h>

#include <stdio.h>
#include <string.h>
#include <wchar.h>

#include "debug.h"
#include "useful.h"
#include "wbemmisc.h"


HRESULT GetMethodInParamInstance(
    IN IWbemServices *pServices,
	IN PWCHAR ClassName,
    IN BSTR MethodName,
    OUT IWbemClassObject **ppInParamInstance
	)
/*+++

Routine Description:

    This routine will return an instance object for a methods in
    parameter. WBEM requires that we go through this dance to get an
    instance object.
        
Arguments:

    pServices

    ClassName is the class containing the method

    MethodName is the name of the method

    *ppInParamInstance returns the instance object to fill with in
        parameters

Return Value:

	HRESULT

---*/
{
	HRESULT hr;
	IWbemClassObject *pClass;
	IWbemClassObject *pInParamClass;

	WmipAssert(pServices != NULL);
	WmipAssert(ClassName != NULL);
	WmipAssert(MethodName != NULL);
	WmipAssert(ppInParamInstance != NULL);
	
	hr = pServices->GetObject(ClassName,
								 0,
								 NULL,
								 &pClass,
								 NULL);
	if (hr == WBEM_S_NO_ERROR)
	{
		hr = pClass->GetMethod(MethodName,
									  0,
									  &pInParamClass,
									  NULL);
		if (hr == WBEM_S_NO_ERROR)
		{
			hr = pInParamClass->SpawnInstance(0,
											  ppInParamInstance);
			pInParamClass->Release();
		}
		pClass->Release();
	}
	
    return(hr);			
}


HRESULT WmiGetQualifier(
    IN IWbemQualifierSet *pIWbemQualifierSet,
    IN PWCHAR QualifierName,
    IN VARTYPE Type,
    OUT /* FREE */ VARIANT *Value
    )
/*+++

Routine Description:

    This routine will return the value for a specific qualifier
        
Arguments:

    pIWbemQualifierSet is the qualifier set object
        
    QualifierName is the name of the qualifier
        
    Type is the type of qualifier expected
        
    *Value returns with the value of the qualifier. Caller must call
		VariantClear

Return Value:

	HRESULT

---*/
{
    BSTR s;
    HRESULT hr;

    WmipAssert(pIWbemQualifierSet != NULL);
    WmipAssert(QualifierName != NULL);
    WmipAssert(Value != NULL);
    
    s = SysAllocString(QualifierName);
    if (s != NULL)
    {
        hr = pIWbemQualifierSet->Get(s,
                                0,
                                Value,
                                NULL);
                
        if ((Value->vt & ~CIM_FLAG_ARRAY) != Type)
        {
            hr = WBEM_E_FAILED;
			VariantClear(Value);
        }
        
        SysFreeString(s);
    } else {
        hr = WBEM_E_OUT_OF_MEMORY;
    }
    
    return(hr);
}

HRESULT GetListOfQualifiers(
    IN IWbemQualifierSet *pQualifiers,
    IN ULONG Count,
    IN PWCHAR *Names,
    IN VARTYPE *Types,
    OUT VARIANT /* FREE */ *Values,
    IN BOOLEAN AbortOnError
    )
{
	HRESULT hr;
	ULONG i,j;

	WmipAssert(pQualifiers != NULL);
	WmipAssert(Names != NULL);
	WmipAssert(Types != NULL);
	WmipAssert(Values != NULL);

	for (i = 0, hr = WBEM_S_NO_ERROR; (i < Count) && (hr == WBEM_S_NO_ERROR); i++)
	{
		hr = WmiGetQualifier(pQualifiers,
							 Names[i],
							 Types[i],
							 &Values[i]);

		if (hr != WBEM_S_NO_ERROR)
		{
			if (AbortOnError)
			{
				for (j = 0; j < i; j++)
				{
					VariantClear(&Values[j]);
				}
				break;
			} else {
				VariantInit(&Values[i]);
				hr = WBEM_S_NO_ERROR;
			}
		}
	}
	return(hr);
}

HRESULT WmiGetQualifierListByName(
    IN IWbemServices *pServices,
    IN PWCHAR ClassName,
    IN PWCHAR PropertyName,
    IN ULONG QualifierCount,
    IN PWCHAR *QualifierNames,
    IN VARTYPE *Types,
    OUT VARIANT /* FREE */ *Values
    )
/*+++

Routine Description:

    This routine will return the values for a list of qualifiers. If
    all qualifiers cannot be returned then none are.
        
Arguments:

	pServices is the IWbemServices pointer

	ClassName is the name of the class with qualifiers

	PropertyName is the name of the property with qualfiers. If NULL
		then class qualifiers are returned

	QualifierCount is the count of qualifers to get

	QualifierNames is an array contaiing names of qualifiers to get

	Types is an array of expected value types for the qualifiers

	Values is an array of variants that return with the qualifer values

Return Value:

	HRESULT

---*/
{
	HRESULT hr;
	IWbemClassObject *pClass;
	IWbemQualifierSet *pQualifiers;
	ULONG i, j;

	WmipAssert(pServices != NULL);
	WmipAssert(ClassName != NULL);
	WmipAssert(QualifierNames != NULL);
	WmipAssert(Types != NULL);
	WmipAssert(Values != NULL);
	
	//
	// Create the class so we can look at the properties
	//
	hr = pServices->GetObject(ClassName,
							  WBEM_FLAG_USE_AMENDED_QUALIFIERS,
							  NULL,
							  &pClass,
							  NULL);

	if (hr == WBEM_S_NO_ERROR)
	{
		if (PropertyName == NULL)
		{
			hr = pClass->GetQualifierSet(&pQualifiers);
		} else {
			hr = pClass->GetPropertyQualifierSet(PropertyName,
				                                 &pQualifiers);
		}
		
		if (hr == WBEM_S_NO_ERROR)
		{
			for (i = 0; (i < QualifierCount) && (hr == WBEM_S_NO_ERROR); i++)
			{
				hr = WmiGetQualifier(pQualifiers,
									 QualifierNames[i],
									 Types[i],
									 &Values[i]);
			}

			if (hr != WBEM_S_NO_ERROR)
			{
				for (j = 0; j < i; j++)
				{
					VariantClear(&Values[j]);
				}
			}
			
			pQualifiers->Release();
		}
		pClass->Release();
	}
	
	return(hr);
}



HRESULT WmiGetProperty(
    IN IWbemClassObject *pIWbemClassObject,
    IN PWCHAR PropertyName,
    IN CIMTYPE ExpectedCimType,
    OUT VARIANT /* FREE */ *Value
    )
/*+++

Routine Description:

    This routine will return the value for a specific property
        
Arguments:

    pIWbemQualifierSet is the qualifier set object
        
    PropertyName is the name of the property
        
    Type is the type of property expected
        
    *Value returns with the value of the property

Return Value:

	HRESULT

---*/
{
    HRESULT hr;
	CIMTYPE CimType;

    WmipAssert(pIWbemClassObject != NULL);
    WmipAssert(PropertyName != NULL);
    WmipAssert(Value != NULL);
    
	hr = pIWbemClassObject->Get(PropertyName,
                                0,
                                Value,
								&CimType,
                                NULL);

	//
	// Treat a NULL value for a property as an error
	//
	if (Value->vt == VT_NULL)
	{
		hr = WBEM_E_ILLEGAL_NULL;
		WmipDebugPrint(("CDMPROV: Property %ws is NULL\n",
						PropertyName));
	}
	
	//
	// Treat CIM_REFERENCE and CIM_STRING as interchangable
	//
	if ((ExpectedCimType == CIM_REFERENCE) &&
        (CimType == CIM_STRING))
	{
		ExpectedCimType = CIM_STRING;
	}
	
	if ((ExpectedCimType == CIM_STRING) &&
        (CimType == CIM_REFERENCE))
	{
		ExpectedCimType = CIM_REFERENCE;
	}
	
	if ((hr == WBEM_S_NO_ERROR) && (ExpectedCimType != CimType))
	{
		WmipDebugPrint(("CDMPROV: Property %ws was expected as %d but was got as %d\n",
						PropertyName,
						ExpectedCimType,
						CimType));
		WmipAssert(FALSE);
		hr = WBEM_E_FAILED;
		VariantClear(Value);
	}
        

    return(hr);
}


HRESULT WmiGetPropertyList(
    IN IWbemClassObject *pIWbemClassObject,
    IN ULONG PropertyCount,						   
    IN PWCHAR *PropertyNames,
    IN CIMTYPE *ExpectedCimType,
    OUT VARIANT /* FREE */ *Value
    )
/*+++

Routine Description:

    This routine will return the value for a specific property
        
Arguments:

    pIWbemQualifierSet is the qualifier set object
        
    PropertyNames is the name of the property
        
    Type is the type of property expected
        
    *Value returns with the value of the property

Return Value:

	HRESULT

---*/
{
	ULONG i,j;
	HRESULT hr;

	WmipAssert(pIWbemClassObject != NULL);
	WmipAssert(PropertyNames != NULL);
	WmipAssert(ExpectedCimType != NULL);
	WmipAssert(Value != NULL);

	
	for (i = 0, hr = WBEM_S_NO_ERROR;
		 (i < PropertyCount) && (hr == WBEM_S_NO_ERROR);
		 i++)
	{
		hr = WmiGetProperty(pIWbemClassObject,
							PropertyNames[i],
							ExpectedCimType[i],
							&Value[i]);
	}

	if (hr != WBEM_S_NO_ERROR)
	{
		for (j = 0; j < i; j++)
		{
			VariantClear(&Value[i]);
		}
	}
	return(hr);
}

HRESULT WmiGetPropertyByName(
    IN IWbemServices *pServices,
    IN PWCHAR ClassName,
    IN PWCHAR PropertyName,
    IN CIMTYPE ExpectedCimType,
    OUT VARIANT /* FREE */ *Value
    )
/*+++

Routine Description:

    This routine will return the value for a specific property within a
    class
        
Arguments:

	pServices is the IWbemServices for the namespace containing your
		class
	
    ClassName is the name of the class whose property you are
		interested in
        
    PropertyName is the name of the property
        
    Type is the type of property expected
        
    *Value returns with the value of the property

Return Value:

	HRESULT

---*/
{
	HRESULT hr;
	IWbemClassObject *pClass;

	WmipAssert(pServices != NULL);
	WmipAssert(ClassName != NULL);
	WmipAssert(PropertyName != NULL);
	WmipAssert(Value != NULL);
	
	//
	// Create the class so we can look at the properties
	//
	hr = pServices->GetObject(ClassName, 0, NULL, &pClass, NULL);

	if (hr == WBEM_S_NO_ERROR)
	{
		hr = WmiGetProperty(pClass,
							PropertyName,
							ExpectedCimType,
							Value);

		pClass->Release();
	}
	
	return(hr);
}


HRESULT WmiSetProperty(
    IN IWbemClassObject *pIWbemClassObject,
    IN PWCHAR PropertyName,
    IN VARIANT *Value
    )
/*+++

Routine Description:

    This routine will set the value of a property to something
        
Arguments:

	pIWbemClassObject is the object whose property is being set

	PropertyName is the name of the property being set

	Value is the value that the property is being set to

Return Value:

	HRESULT

---*/
{
	HRESULT hr;
	
    WmipAssert(pIWbemClassObject != NULL);
    WmipAssert(PropertyName != NULL);
    WmipAssert(Value != NULL);

	hr = pIWbemClassObject->Put(PropertyName,
						   0,
						   Value,
						   0);

	if (hr == WBEM_E_TYPE_MISMATCH)
	{
		WmipDebugPrint(("CDMPROV: Put %ws has wrong type %d\n",
						PropertyName, Value->vt));
		WmipAssert(FALSE);
	}
	
	return(hr);
}

HRESULT WmiSetPropertyList(
    IN IWbemClassObject *pIWbemClassObject,
    IN ULONG PropertyCount,
    IN PWCHAR *PropertyNames,
    IN VARIANT *Values
    )
/*+++

Routine Description:

    This routine will set the values of multiple properties to something
        
Arguments:

	pIWbemClassObject is the object whose property is being set

	PropertyCount is the number of properties to set

	PropertyNames is the names of the property being set

	Values is the value that the property is being set to

Return Value:

	HRESULT

---*/
{
	ULONG i;
	HRESULT hr = WBEM_S_NO_ERROR;

	WmipAssert(pIWbemClassObject != NULL);
	WmipAssert(PropertyNames != NULL);
	WmipAssert(Values != NULL);

	for (i = 0; (i < PropertyCount) && (hr == WBEM_S_NO_ERROR); i++)
	{		
		hr = WmiSetProperty(pIWbemClassObject,
							PropertyNames[i],
							&Values[i]);
	}
	
	return(hr);
}


PWCHAR AddSlashesToStringW(
    OUT PWCHAR SlashedNamespace,
    IN PWCHAR Namespace
    )
/*+++

Routine Description:

    This routine will convert ever \ in the string into \\. It needs to
    do this since WBEM will collapse \\ into \ sometimes.
        
Arguments:

    SlashedNamespace returns with string double slashed

    Namespace is the input string

Return Value:

	pointer to SlashedNamespace

---*/
{
    PWCHAR Return = SlashedNamespace;

	WmipAssert(SlashedNamespace != NULL);
	WmipAssert(Namespace != NULL);
	
    //
    // MOF likes the namespace paths to be C-style, that is to have a
    // '\\' instad of a '\'. So whereever we see a '\', we insert a
    // second one
    //
    while (*Namespace != 0)
    {
        if (*Namespace == L'\\')
        {
            *SlashedNamespace++ = L'\\';
        }
        *SlashedNamespace++ = *Namespace++;
    }
    *SlashedNamespace = 0;
    
    return(Return);
}

PWCHAR AddSlashesToStringExW(
    OUT PWCHAR SlashedNamespace,
    IN PWCHAR Namespace
    )
/*+++

Routine Description:

    This routine will convert ever \ in the string into \\ and " into
    \".  It needs to do this since WBEM will collapse \\ into \ sometimes.
        
Arguments:

    SlashedNamespace returns with string double slashed

    Namespace is the input string

Return Value:

	pointer to SlashedNamespace

---*/
{
    PWCHAR Return = SlashedNamespace;
    
	WmipAssert(SlashedNamespace != NULL);
	WmipAssert(Namespace != NULL);
	
    //
    // MOF likes the namespace paths to be C-style, that is to have a
    // '\\' instad of a '\'. So whereever we see a '\', we insert a
    // second one. We also need to add a \ before any ".
    //
    while (*Namespace != 0)
    {
        if ((*Namespace == L'\\') || (*Namespace == L'"'))
        {
            *SlashedNamespace++ = L'\\';
        }
		
        *SlashedNamespace++ = *Namespace++;
    }
    *SlashedNamespace = 0;
    
    return(Return);
}

HRESULT WmiConnectToWbem(
    IN PWCHAR Namespace,
    OUT IWbemServices **ppIWbemServices
    )
/*+++

Routine Description:

    This routine will establishes a connection to a WBEM namespace on
    the local machine.

Arguments:

	Namespace is the namespace to which to connect

	*ppIWbemServices returns with a IWbemServices * for the namespace

Return Value:

	HRESULT

---*/
{
    IWbemLocator *pIWbemLocator;
    DWORD hr;
    BSTR s;

	WmipAssert(Namespace != NULL);
    WmipAssert(ppIWbemServices != NULL);
    
    hr = CoCreateInstance(CLSID_WbemLocator,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          (LPVOID *) &pIWbemLocator);
    if (hr == S_OK)
    {
        s = SysAllocString(Namespace);
        if (s != NULL)
        {
			*ppIWbemServices = NULL;
			hr = pIWbemLocator->ConnectServer(s,
                            NULL,                           // Userid
                            NULL,                           // PW
                            NULL,                           // Locale
                            0,                              // flags
                            NULL,                           // Authority
                            NULL,                           // Context
                            ppIWbemServices
                           );
                       
			SysFreeString(s);
                             
		} else {
		    *ppIWbemServices = NULL;
			hr = WBEM_E_OUT_OF_MEMORY;
		}
		
        pIWbemLocator->Release();
    }
    
    return(hr);
}

HRESULT CreateInst(
	IN IWbemContext  *pCtx,
    IN IWbemServices * pNamespace,
    IN WCHAR * pwcClassName,
	OUT /* FREE */ IWbemClassObject ** pNewInst
)
/*+++

Routine Description:

    This routine will create a new instance for the specified class

Arguments:

	pNamespace is the IWbemServices * to the namespace in which the
		class lives

	*pNewinst returns with the new instance of the class

	pwcClassName has the name of the class whose instance is created

	pCtx is the context to use in creating the instance

Return Value:

	HRESULT

---*/
{   
    HRESULT hr;
    IWbemClassObject * pClass;
	
    hr = pNamespace->GetObject(pwcClassName, 0, pCtx, &pClass, NULL);
    if (hr != S_OK)
	{
        return WBEM_E_FAILED;
	}
	
    hr = pClass->SpawnInstance(0, pNewInst);
    pClass->Release();

	WmipDebugPrint(("CDMProv:: Created %ws as %p\n",
					pwcClassName, *pNewInst));

    return(hr);	
}

/* FREE */ BSTR GetCurrentDateTime(
    void
    )
{
	SYSTEMTIME SystemTime;
	WBEMTime WbemTime;

	GetSystemTime(&SystemTime);
	WbemTime = SystemTime;
	return(WbemTime.GetBSTR());
}


HRESULT WmiGetArraySize(
    IN SAFEARRAY *Array,
    OUT LONG *LBound,
    OUT LONG *UBound,
    OUT LONG *NumberElements
)
/*+++

Routine Description:

    This routine will information about the size and bounds of a single
    dimensional safe array.
        
Arguments:

    Array is the safe array
        
    *LBound returns with the lower bound of the array

    *UBound returns with the upper bound of the array
        
    *NumberElements returns with the number of elements in the array

Return Value:

    TRUE if successful else FALSE

---*/
{
    HRESULT hr;

    WmipAssert(Array != NULL);
    WmipAssert(LBound != NULL);
    WmipAssert(UBound != NULL);
    WmipAssert(NumberElements != NULL);
    
    //
    // Only single dim arrays are supported
    //
    WmipAssert(SafeArrayGetDim(Array) == 1);
    
    hr = SafeArrayGetLBound(Array, 1, LBound);
    
    if (hr == WBEM_S_NO_ERROR)
    {
        hr = SafeArrayGetUBound(Array, 1, UBound);
        *NumberElements = (*UBound - *LBound) + 1;
    }
    return(hr);
}

BOOLEAN IsUlongAndStringEqual(
    IN ULONG Number,
    IN PWCHAR String
    )
/*+++

Routine Description:

    This routine will convert the passed string to an integer and
    compare it to the passed integer value
        
Arguments:

	Number

	String

Return Value:

    TRUE if equal else FALSE

---*/
{
	ULONG SNumber;

	SNumber = _wtoi(String);
	return ( (Number == SNumber) ? TRUE : FALSE );
}

HRESULT LookupValueMap(
    IN IWbemServices *pServices,
    IN PWCHAR ClassName,
    IN PWCHAR PropertyName,					   
	IN ULONG Value,
    OUT /* FREE */ BSTR *MappedValue
	)
/*+++

Routine Description:

    This routine will lookup the string value corresponding to an
    integer valuemap
        
Arguments:

	pServices is the pointer to the namespace in which the class is
		locaed

	ClassName is the name of the class

	PropertyName is the name of the property

	Value is the value of the property and is used to look up the
		string that corresponsds to it

	*MappedValue returns a string that contains the string which the
		value maps to
		
Return Value:

    HRESULT

---*/
{
	PWCHAR Names[2];
	VARIANT QualifierValues[2];
	VARTYPE Types[2];
	HRESULT hr;
	BSTR s;
	LONG ValuesLBound, ValuesUBound, ValuesElements;
	LONG ValueMapLBound, ValueMapUBound, ValueMapElements;
	LONG i, Index;


	WmipAssert(pServices != NULL);
	WmipAssert(ClassName != NULL);
	WmipAssert(PropertyName != NULL);
	WmipAssert(MappedValue != NULL);
	
	//
	// Get the Values and ValueMap qualifiers so we can do the mapping
	//
	Names[0] = L"Values";
	Types[0] = VT_BSTR;
	
	Names[1] = L"ValueMap";
	Types[1] = VT_BSTR;
	
	hr = WmiGetQualifierListByName(pServices,
								   ClassName,
								   PropertyName,
								   2,
								   Names,
								   Types,
								   QualifierValues);
	if (hr == WBEM_S_NO_ERROR)
	{
		//
		// Now do a sanity check to make sure the values and valuemaps
		// have the same number of elements
		//

		if (QualifierValues[0].vt == QualifierValues[1].vt)
		{
			//
			// Values and ValueMap both agree that they are both
			// scalars or both arrays and are both strings
			//
			if (QualifierValues[0].vt & VT_ARRAY)
			{
				//
				// We have an array of thing to check for mapping.
				// First lets make sure that the arrays have identical
				// dimensions
				//
				hr = WmiGetArraySize(QualifierValues[0].parray,
									 &ValuesLBound,
									 &ValuesUBound,
									 &ValuesElements);

				if (hr == WBEM_S_NO_ERROR)
				{
					hr = WmiGetArraySize(QualifierValues[1].parray,
									 &ValueMapLBound,
									 &ValueMapUBound,
									 &ValueMapElements);

					if (hr == WBEM_S_NO_ERROR)
					{
						if ((ValuesLBound == ValueMapLBound) &&
						    (ValuesUBound == ValueMapUBound) &&
						    (ValuesElements == ValueMapElements))
						{
							for (i = 0; i < ValueMapElements; i++)
							{
								Index = i + ValueMapLBound;
								hr = SafeArrayGetElement(QualifierValues[1].parray,
														 &Index,
														 &s);
								if (hr == WBEM_S_NO_ERROR)
								{
									if (IsUlongAndStringEqual(Value,
															  s))
									{
										hr = SafeArrayGetElement(QualifierValues[0].parray,
																&Index,
																MappedValue);
										//
										// Make sure loop will
										// terminate
										i = ValueMapElements;
									}
									SysFreeString(s);
								}
							}
						} else {
							hr = WBEM_E_NOT_FOUND;
						}
					}
				}
				
			} else {
				//
				// We have scalars so this should make a fairly simple
				// mapping
				//
				if (IsUlongAndStringEqual(Value,
										  QualifierValues[1].bstrVal))
				{
					*MappedValue = SysAllocString(QualifierValues[0].bstrVal);
					if (*MappedValue == NULL)
					{
						hr = WBEM_E_OUT_OF_MEMORY;
					}
				} else {
					hr = WBEM_E_NOT_FOUND;
				}
			}
		} else {
			hr = WBEM_E_NOT_FOUND;
		}
		
		VariantClear(&QualifierValues[0]);
		VariantClear(&QualifierValues[1]);
	}
	
	return(hr);
}


HRESULT GetInstanceOfClass(
    IWbemContext *pCtx,
    IWbemServices *pServices,
    PWCHAR ClassName,
    PWCHAR PropertyName,
    PWCHAR PropertyValue,
    IEnumWbemClassObject **pEnum,
    IWbemClassObject **pInstance
    )
{
	BSTR sWQL, sQuery;
	WCHAR Query[2*MAX_PATH];
	IEnumWbemClassObject *pEnumInstances;
	WCHAR s[MAX_PATH];
	HRESULT hr;
	ULONG Count;
	
	sWQL = SysAllocString(L"WQL");

	if (sWQL != NULL)
	{
		//
		// First get PnP id from Instance name from the MSWmi_PnPDeviceId
		// class (select * from MSWMI_PnPDeviceId where InstanceName =
		// "<WdmInstanceName>"
		//
		if (PropertyName != NULL)
		{
			wsprintfW(Query,
					L"select * from %ws where %ws = \"%ws\"",
					ClassName,
					PropertyName,
					AddSlashesToStringW(s, PropertyValue));
		} else {
			wsprintfW(Query,
					L"select * from %ws",
					ClassName);

		}
		
		sQuery = SysAllocString(Query);
		if (sQuery != NULL)
		{
			hr = pServices->ExecQuery(sWQL,
									sQuery,
									WBEM_FLAG_FORWARD_ONLY |
									WBEM_FLAG_ENSURE_LOCATABLE,
									pCtx,
									&pEnumInstances);

			if (hr == WBEM_S_NO_ERROR)
			{
				if (pEnum == NULL)
				{
					hr = pEnumInstances->Next(WBEM_INFINITE,
												  1,
												  pInstance,
												  &Count);
					pEnumInstances->Release();
				} else {
					*pEnum = pEnumInstances;
				}
			}
			SysFreeString(sQuery);
		} else {
			hr = WBEM_E_OUT_OF_MEMORY;
		}
		SysFreeString(sWQL);
	} else {
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	return(hr);
}


VARTYPE WmiVarTypeForCimType(
    CIMTYPE CimType
    )
{
    VARTYPE vt;
    
    //
    // Most things match their CIM types, except those below
    vt = (VARTYPE)CimType;
    
    switch(CimType)
    {
        case CIM_UINT32:                        
        case CIM_UINT8:
        case CIM_SINT8:
        {
            vt = VT_I4;
            break;
        }
                        
        case CIM_CHAR16:
        case CIM_UINT16:
        {
            vt = VT_I2;
            break;
        }
                                                                            
        {
            vt = VT_I4;
            break;
        }
                            
        case CIM_STRING:
        case CIM_DATETIME:
        case CIM_SINT64:
        case CIM_UINT64:
        {
            vt = VT_BSTR;
            break;
        }
        
        case CIM_OBJECT:
        {
            vt = VT_UNKNOWN;
            break;
        }
        
        case CIM_BOOLEAN:
        {
            vt = VT_BOOL;
            break;
        }
        
        
    }
    return(vt); 
}


void WmiGetNumberFromVariant(
    VARIANT *v,
    CIMTYPE VType,
    ULONG64 *Number
    )
{
	if ((VType == CIM_SINT64) || (VType == CIM_UINT64))
	{
		WmipAssert(v->vt == VT_BSTR);
		*Number = _wtoi(v->bstrVal);
	} else {
		*Number = 0;
		switch (v->vt)
		{
			case VT_UI1:
			{
				*Number = (ULONG64)v->bVal;
				break;
			}

			case VT_I1:
			{
				*Number = (ULONG64)v->cVal;
				break;
			}

			case VT_I2:
			{
				*Number = (ULONG64)v->iVal;
				break;
			}

			case VT_UI2:
			{
				*Number = (ULONG64)v->uiVal;
				break;
			}

			case VT_UI4:
			{
				*Number = (ULONG64)v->ulVal;
				break;
			}

			case VT_I4:
			{
				*Number = (ULONG64)v->lVal;
				break;
			}
			
			default:
			{
				WmipAssert(FALSE);
				*Number = (ULONG64)v->lVal;
				break;
			}
		}
	}
}

HRESULT WmiSetNumberInVariant(
    VARIANT *v,
    CIMTYPE VType,
    ULONG64 Number
    )
{
	HRESULT hr = WBEM_S_NO_ERROR;
	
	switch (VType)
	{
        case CIM_UINT8:
        case CIM_SINT8:
        case CIM_UINT32:
        case CIM_SINT32:
        {
            v->vt = VT_I4;
			v->lVal = (LONG)Number;
            break;
        }
                        
        case CIM_CHAR16:
        case CIM_UINT16:
        {
            v->vt = VT_I2;
			v->iVal = (SHORT)Number;
            break;
        }

        case CIM_SINT64:
        case CIM_UINT64:
        {
			WCHAR ss[MAX_PATH];
			BSTR s;
			
            v->vt = VT_BSTR;
			wsprintfW(ss, L"%d", Number);
			s = SysAllocString(ss);
			if (s != NULL)
			{
				v->bstrVal = s;
			} else {
				hr = WBEM_E_OUT_OF_MEMORY;
			}
			
            break;
        }

		default:
		{
			WmipAssert(FALSE);
			break;
		}
		
	}
	return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\cgen\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.plt

WHNT32TABSRC=..\..\ntos\ke\services.tab
WHNT32TAB=..\whnt32\$(O)\whnt32.tab
NT32TAB=..\whnt32\$(O)\kesvc.tab

#
# bash the 64-bit-targetted C compiler so it preprocesses using the
# 32-bit defines as we want 32-bit type information
#
!if $(IA64)
WOW64_COMPILER_FLAGS=$(CXX_COMPILER_FLAGS:_WIN64=_WIN32) -DSORTPP_PASS -DGUID_DEFINED
WOW64_COMPILER_FLAGS=$(WOW64_COMPILER_FLAGS:_M_IA64=_M_X86)
WOW64_COMPILER_FLAGS=$(WOW64_COMPILER_FLAGS:_IA64_=_X86_)
WOW64_COMPILER_FLAGS=$(WOW64_COMPILER_FLAGS:DIA64=DX86)
WOW64_COMPILER_FLAGS=$(WOW64_COMPILER_FLAGS) /U_WIN64 /Di386=1 /DBUILD_WOW6432
WOW6432_PREPROCESSOR_FLAGS=$(C_PREPROCESSOR_FLAGS:_WIN64=_WIN32)
WOW6432_PREPROCESSOR_FLAGS=$(WOW6432_PREPROCESSOR_FLAGS:_M_IA64=_M_X86)
WOW6432_PREPROCESSOR_FLAGS=$(WOW6432_PREPROCESSOR_FLAGS:_IA64_=_X86_)
WOW6432_PREPROCESSOR_FLAGS=$(WOW6432_PREPROCESSOR_FLAGS:DIA64=DX86)
WOW6432_PREPROCESSOR_FLAGS=/U_WIN64 /Di386=1 /DBUILD_WOW6432 $(WOW6432_PREPROCESSOR_FLAGS)
!elseif $(AMD64)
WOW64_COMPILER_FLAGS=$(CXX_COMPILER_FLAGS:_WIN64=_WIN32) -DSORTPP_PASS -DGUID_DEFINED
WOW64_COMPILER_FLAGS=$(WOW64_COMPILER_FLAGS:_M_AMD64=_M_X86)
WOW64_COMPILER_FLAGS=$(WOW64_COMPILER_FLAGS:_AMD64_=_X86_)
WOW64_COMPILER_FLAGS=$(WOW64_COMPILER_FLAGS:DAMD64=DX86)
WOW64_COMPILER_FLAGS=$(WOW64_COMPILER_FLAGS) /U_WIN64 /Di386=1 /DBUILD_WOW6432
WOW6432_PREPROCESSOR_FLAGS=$(C_PREPROCESSOR_FLAGS:_WIN64=_WIN32)
WOW6432_PREPROCESSOR_FLAGS=$(WOW6432_PREPROCESSOR_FLAGS:_M_AMD64=_M_X86)
WOW6432_PREPROCESSOR_FLAGS=$(WOW6432_PREPROCESSOR_FLAGS:_AMD64_=_X86_)
WOW6432_PREPROCESSOR_FLAGS=$(WOW6432_PREPROCESSOR_FLAGS:DAMD64=DX86)
WOW6432_PREPROCESSOR_FLAGS=/U_WIN64 /Di386=1 /DBUILD_WOW6432 $(WOW6432_PREPROCESSOR_FLAGS)
!else
!error no target cpu.
!endif

!if "$(WOW64_DEBUG_THUNKGEN)" == "1"
SORTPP_FLAGS=$(SORTPP_FLAGS) -l
!else
SORTPP_FLAGS=$(SORTPP_FLAGS)
!endif

PPMFILE=$(O)\winincs.ppm
NT32HDR=$(O)\nt32.h

CXX_COMPILER_NAME=$(CXX_COMPILER_NAME) $(WOW64_COMPILER_FLAGS) -noHRESULT -DIN=__in -DOUT=__out

$(WHNT32TAB): $(WHNT32TABSRC)
    @echo Creating $(WHNT32TAB) from $(WHNT32TABSRC)
    copy $(WHNT32TABSRC)+..\..\ntdll\wow6432\ntwow64.tab $(O)\whnt32.tmp
    $(C_PREPROCESSOR_NAME) $(WOW6432_PREPROCESSOR_FLAGS) $(O)\whnt32.tmp > $(WHNT32TAB)
    del $(O)\whnt32.tmp

$(NT32TAB): $(WHNT32TABSRC)
    $(C_PREPROCESSOR_NAME) $(WOW6432_PREPROCESSOR_FLAGS) $(WHNT32TABSRC) > $(NT32TAB)

$(O)\winincs.pp: winincs.cpp cgenhdr.h
    $(CXX_COMPILER_NAME) /C @<<$(O)\cl.rsp /E /FC winincs.cpp >$(O)\winincs2.pp
$(WOW64_COMPILER_FLAGS: =
)
<<NOKEEP
    idlclean.exe $(O)\winincs2.pp $(O)\winincs2.cpp
    $(CXX_COMPILER_NAME) @<<cl.rsp /E /FC $(O)\winincs2.cpp >$(O)\winincs.pp
$(WOW64_COMPILER_FLAGS: =
)
<<NOKEEP

$(PPMFILE): $(O)\winincs.pp
   sortpp.exe $(SORTPP_FLAGS) -m$(PPMFILE) $(O)\winincs.pp

$(NT32HDR): $(PPMFILE)
   gennt32t.exe $(PPMFILE) >$(NT32HDR)

thunks: $(WHNT32TAB) $(NT32HDR) $(PPMFILE) $(NT32TAB)

cleanfiles:
    -del $(O)\winincs.pp
    -del $(O)\winincs2.pp
    -del $(WHNT32TAB)
    -del $(NT32TAB)
    -del $(PPMFILE)
    -del $(NT32HDR)

clean: cleanfiles thunks
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\cgen\winincs.cpp ===
#include "cgenhdr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\cgen\winbld.c ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
// This file is used to verify that winincs.c can be successfully compiled
// by the x86 C compiler.  Do do that, we must undefine __in and __out
#define __in
#define __out
#pragma warning(disable:4049)
#include "winincs.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\cpu\amd64\context\ia6432.h ===
#ifndef __IA64_WOW64EXTS32__
#define __IA64_WOW64EXTS32__

#define _CROSS_PLATFORM_
#define WOW64EXTS_386

#if !defined(_X86_)
    #error This file can only be included for x86 build
#else

/* include headers as if the platform were ia64, 
   because we need 64-bit stuff for context conversion */

#undef _X86_
#define _AMD64_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#undef _AMD64_
#define _X86_

/* 32-bit stuff for context conversion are defined here */
#include <wow64.h>
#include <wow64cpu.h>
#include <vdmdbg.h>
#include <amd64cpu.h>


/* these are defined in nti386.h, since we only included ntia64.h (in nt.h), 
   we have to define these. */
#define SIZE_OF_FX_REGISTERS        128

typedef struct _FXSAVE_FORMAT {
    USHORT  ControlWord;
    USHORT  StatusWord;
    USHORT  TagWord;
    USHORT  ErrorOpcode;
    ULONG   ErrorOffset;
    ULONG   ErrorSelector;
    ULONG   DataOffset;
    ULONG   DataSelector;
    ULONG   MXCsr;
    ULONG   Reserved2;
    UCHAR   RegisterArea[SIZE_OF_FX_REGISTERS];
    UCHAR   Reserved3[SIZE_OF_FX_REGISTERS];
    UCHAR   Reserved4[224];
    UCHAR   Align16Byte[8];
} FXSAVE_FORMAT, *PFXSAVE_FORMAT_WX86;

#endif

#endif __IA64_WOW64EXTS32__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\cpu\amd64\context\context.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    context.c

Abstract:

    Context conversion routines for ia64 hardware to ia32 context records

Author:

    03-Feb-2000 Charles Spriakis - Intel (v-cspira)

Revision History:

--*/


#define _WOW64CPUAPI_

#ifdef _X86_
#include "ia6432.h"
#else

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "wow64.h"
#include "wow64cpu.h"
#include "amd64cpu.h"

#endif

//
// This is to prevent this library from linking to wow64 to use wow64!Wow64LogPrint
//
#if defined(LOGPRINT)
#undef LOGPRINT
#endif
#define LOGPRINT(_x_)   CpupDebugPrint _x_


VOID
CpupDebugPrint(
    IN ULONG_PTR Flags,
    IN PCHAR Format,
    ...);

ASSERTNAME;

VOID
Wow64CtxFromIa64(
    IN ULONG Ia32ContextFlags,
    IN PCONTEXT ContextIa64,
    IN OUT PCONTEXT32 ContextX86
    )
/*++

Routine Description:

    This function copies the context from an ia64 context record into
    the context of an ia32 record (based on the hardware iVE register
    mappings). This function is ment to be easily usabale by various
    get/set context routines (such as those exported by wow64cpu.dll).

Arguments:

    Ia32ContextFlags - Specifies which ia32 context to copy

    ContextIa64 - Supplies an the ia64 context buffer that is the source
                  for the copy into the ia32 context area

    ContextX86 - This is an X86 context which will receive the context
                 information from the ia64 context record passed in above

Return Value:

    None.  

--*/

{

#if 0

    FLOAT128 tmpFloat[NUMBER_OF_387REGS];

    if (Ia32ContextFlags & CONTEXT_IA64) {
        LOGPRINT((ERRORLOG, "Wow64CtxFromIa64: Request with ia64 context flags (0x%x) FAILED\n", Ia32ContextFlags));
        ASSERT((Ia32ContextFlags & CONTEXT_IA64) == 0);
    }

    if ((Ia32ContextFlags & CONTEXT32_CONTROL) == CONTEXT32_CONTROL) {
        //
        // And the control stuff
        //
        ContextX86->Ebp    = (ULONG)ContextIa64->IntTeb;
        ContextX86->SegCs  = KGDT_R3_CODE|3;
        ContextX86->Eip    = (ULONG)ContextIa64->StIIP;
        ContextX86->SegSs  = KGDT_R3_DATA|3;
        ContextX86->Esp    = (ULONG)ContextIa64->IntSp;
        ContextX86->EFlags = (ULONG)ContextIa64->Eflag;
    }

    if ((Ia32ContextFlags & CONTEXT32_INTEGER)  == CONTEXT32_INTEGER) {
        //
        // Now for the integer state...
        //
        ContextX86->Edi = (ULONG)ContextIa64->IntT6;
        ContextX86->Esi = (ULONG)ContextIa64->IntT5;
        ContextX86->Ebx = (ULONG)ContextIa64->IntT4;
        ContextX86->Edx = (ULONG)ContextIa64->IntT3;
        ContextX86->Ecx = (ULONG)ContextIa64->IntT2;
        ContextX86->Eax = (ULONG)ContextIa64->IntV0;
    }

    if ((Ia32ContextFlags & CONTEXT32_SEGMENTS) == CONTEXT32_SEGMENTS) {
        //
        // These are constants (and constants are used on ia32->ia64
        // transition, not saved values) so make our life easy...
        //
        ContextX86->SegGs = KGDT_R3_DATA|3;
        ContextX86->SegEs = KGDT_R3_DATA|3;
        ContextX86->SegDs = KGDT_R3_DATA|3;
        ContextX86->SegSs = KGDT_R3_DATA|3;
        ContextX86->SegFs = KGDT_R3_TEB|3;
        ContextX86->SegCs = KGDT_R3_CODE|3;
    }

    if ((Ia32ContextFlags & CONTEXT32_EXTENDED_REGISTERS) == CONTEXT32_EXTENDED_REGISTERS) {

        PFXSAVE_FORMAT_WX86 xmmi = (PFXSAVE_FORMAT_WX86) ContextX86->ExtendedRegisters;

        LOGPRINT((TRACELOG, "Wow64CtxFromIa64: Request to convert extended fp registers\n"));

        xmmi->ControlWord   = (USHORT)(ContextIa64->StFCR & 0xffff);
        xmmi->StatusWord    = (USHORT)(ContextIa64->StFSR & 0xffff);
        xmmi->TagWord       = (USHORT)(ContextIa64->StFSR >> 16) & 0xffff;
        xmmi->ErrorOpcode   = (USHORT)(ContextIa64->StFIR >> 48);
        xmmi->ErrorOffset   = (ULONG) (ContextIa64->StFIR & 0xffffffff);
        xmmi->ErrorSelector = (ULONG) (ContextIa64->StFIR >> 32);
        xmmi->DataOffset    = (ULONG) (ContextIa64->StFDR & 0xffffffff);
        xmmi->DataSelector  = (ULONG) (ContextIa64->StFDR >> 32);
        xmmi->MXCsr         = (ULONG) (ContextIa64->StFCR >> 32) & 0xffff;

        //
        // Copy over the FP registers.  Even though this is the new
        // FXSAVE format with 16-bytes for each register, need to
        // convert from spill/fill format to 80-byte double extended format
        //
        Wow64CopyIa64FromSpill((PFLOAT128) &(ContextIa64->FltT2),
                               (PFLOAT128) xmmi->RegisterArea,
                               NUMBER_OF_387REGS);

        //
        // Rotate the registers appropriately
        //
        Wow64RotateFpTop(ContextIa64->StFSR, (PFLOAT128) xmmi->RegisterArea);

        //
        // Finally copy the xmmi registers
        //
        Wow64CopyXMMIFromIa64Byte16(&(ContextIa64->FltS4),
                                    xmmi->Reserved3,
                                    NUMBER_OF_XMMI_REGS);
    }

    if ((Ia32ContextFlags & CONTEXT32_FLOATING_POINT) == CONTEXT32_FLOATING_POINT) {

        LOGPRINT((TRACELOG, "Wow64CtxFromIa64: Request to convert fp registers\n"));

        //
        // Copy over the floating point status/control stuff
        //
        ContextX86->FloatSave.ControlWord   = (ULONG)(ContextIa64->StFCR & 0xffff);
        ContextX86->FloatSave.StatusWord    = (ULONG)(ContextIa64->StFSR & 0xffff);
        ContextX86->FloatSave.TagWord       = (ULONG)(ContextIa64->StFSR >> 16) & 0xffff;
        ContextX86->FloatSave.ErrorOffset   = (ULONG)(ContextIa64->StFIR & 0xffffffff);
        ContextX86->FloatSave.ErrorSelector = (ULONG)(ContextIa64->StFIR >> 32);
        ContextX86->FloatSave.DataOffset    = (ULONG)(ContextIa64->StFDR & 0xffffffff);
        ContextX86->FloatSave.DataSelector  = (ULONG)(ContextIa64->StFDR >> 32);

        //
        // Copy over the FP registers into temporary space
        // Even though this is the new
        // FXSAVE format with 16-bytes for each register, need to
        // convert from spill/fill format to 80-byte double extended format
        //
        Wow64CopyIa64FromSpill((PFLOAT128) &(ContextIa64->FltT2),
                               (PFLOAT128) tmpFloat,
                               NUMBER_OF_387REGS);
        //
        // Rotate the registers appropriately
        //
        Wow64RotateFpTop(ContextIa64->StFSR, tmpFloat);

        //
        // And put them in the older FNSAVE format (packed 10 byte values)
        //
        Wow64CopyFpFromIa64Byte16(tmpFloat,
                                  ContextX86->FloatSave.RegisterArea,
                                  NUMBER_OF_387REGS);
    }

    if ((Ia32ContextFlags & CONTEXT32_DEBUG_REGISTERS) == CONTEXT32_DEBUG_REGISTERS) {
        LOGPRINT((TRACELOG, "Wow64CtxFromIa64: Request to convert debug registers\n"));
    }

    ContextX86->ContextFlags = Ia32ContextFlags;

#endif

}

VOID
Wow64CtxToIa64(
    IN ULONG Ia32ContextFlags,
    IN PCONTEXT32 ContextX86,
    IN OUT PCONTEXT ContextIa64
    )
/*++

Routine Description:

    This function copies the context from an ia32 context record into
    the context of an ia64 record (based on the hardware iVE register
    mappings). This function is ment to be easily usabale by various
    get/set context routines (such as those exported by wow64cpu.dll).

Arguments:

    Ia32ContextFlags - Specifies which ia32 context to copy

    ContextX86 - Supplies an the X86 context buffer that is the source
                  for the copy into the ia64 context area

    ContextIa64 - This is an ia64 context which will receive the context
                 information from the x86 context record passed in above

Return Value:

    None.

--*/

{

#if 0

    FLOAT128 tmpFloat[NUMBER_OF_387REGS];

    if (Ia32ContextFlags & CONTEXT_IA64) {
        LOGPRINT((ERRORLOG, "Wow64CtxToIa64: Request with ia64 context flags (0x%x) FAILED\n", Ia32ContextFlags));
        ASSERT((Ia32ContextFlags & CONTEXT_IA64) == 0);
    }

    if ((Ia32ContextFlags & CONTEXT32_CONTROL) == CONTEXT32_CONTROL) {
        //
        // And the control stuff
        //
        ContextIa64->IntTeb = ContextX86->Ebp;
        ContextIa64->StIIP = ContextX86->Eip;
        ContextIa64->IntSp = ContextX86->Esp;
        ContextIa64->Eflag = ContextX86->EFlags;

        //
        // The segments (cs and ds) are a constant, so reset them.
        // gr17 has LDT and TSS, so might as well reset
        // all of them while we're at it...
        // These values are forced in during a transition (see simulate.s)
        // so there is no point to trying to get cute and actually
        // pass in the values from the X86 context record
        //
        ContextIa64->IntT8 = ((KGDT_LDT|3) << 32) 
                           | ((KGDT_R3_DATA|3) << 16)
                           | (KGDT_R3_CODE|3);

    }

    if ((Ia32ContextFlags & CONTEXT32_INTEGER)  == CONTEXT32_INTEGER) {
        //
        // Now for the integer state...
        //
         ContextIa64->IntT6 = ContextX86->Edi;
         ContextIa64->IntT5 = ContextX86->Esi;
         ContextIa64->IntT4 = ContextX86->Ebx;
         ContextIa64->IntT3 = ContextX86->Edx;
         ContextIa64->IntT2 = ContextX86->Ecx;
         ContextIa64->IntV0 = ContextX86->Eax;
    }

    if ((Ia32ContextFlags & CONTEXT32_SEGMENTS) == CONTEXT32_SEGMENTS) {
        //
        // These are constants (and constants are used on ia32->ia64
        // transition, not saved values) so make our life easy...
        // These values are forced in during a transition (see simulate.s)
        // so there is no point to trying to get cute and actually
        // pass in the values from the X86 context record
        //
        ContextIa64->IntT7 =  ((KGDT_R3_DATA|3) << 48)
                           | ((KGDT_R3_TEB|3) << 32)
                           | ((KGDT_R3_DATA|3) << 16)
                           | (KGDT_R3_DATA|3);
    }

    if ((Ia32ContextFlags & CONTEXT32_EXTENDED_REGISTERS) == CONTEXT32_EXTENDED_REGISTERS) {
        PFXSAVE_FORMAT_WX86 xmmi = (PFXSAVE_FORMAT_WX86) ContextX86->ExtendedRegisters;

        LOGPRINT((TRACELOG, "Wow64CtxToIa64: Request to convert extended fp registers\n"));

        //
        // And copy over the floating point status/control stuff
        //
        ContextIa64->StFCR = (ContextIa64->StFCR & 0xffffffffffffe040i64) |
                             (xmmi->ControlWord & 0xffff) |
                             ((xmmi->MXCsr & 0xffff) << 32);

        ContextIa64->StFSR = (ContextIa64->StFSR & 0xffffffff00000000i64) | 
                             (xmmi->StatusWord & 0xffff) | 
                             ((xmmi->TagWord & 0xffff) << 16);

        ContextIa64->StFIR = (xmmi->ErrorOffset & 0xffffffff) | 
                             (xmmi->ErrorSelector << 32);

        ContextIa64->StFDR = (xmmi->DataOffset & 0xffffffff) | 
                             (xmmi->DataSelector << 32);

        // 
        // Rotate registers back
        //
        {
            ULONGLONG RotateFSR = (NUMBER_OF_387REGS - 
                                   ((ContextIa64->StFSR >> 11) & 0x7)) << 11;
            Wow64RotateFpTop(RotateFSR, (PFLOAT128) xmmi->RegisterArea);
        }

        // Copy over the FP registers.  Even though this is the new
        // FXSAVE format with 16-bytes for each register, need to
        // convert to spill/fill format from 80-byte double extended format
        //
        Wow64CopyIa64ToFill((PFLOAT128) xmmi->RegisterArea,
                            (PFLOAT128) &(ContextIa64->FltT2),
                            NUMBER_OF_387REGS);

        //
        // Copy over the xmmi registers and convert them into a format
        // that spill/fill can use
        //
        Wow64CopyXMMIToIa64Byte16(xmmi->Reserved3, 
                                  &(ContextIa64->FltS4), 
                                  NUMBER_OF_XMMI_REGS);
    }

    if ((Ia32ContextFlags & CONTEXT32_FLOATING_POINT) == CONTEXT32_FLOATING_POINT) {
        LOGPRINT((TRACELOG, "Wow64CtxToIa64: Request to convert fp registers\n"));
        //
        // Copy over the floating point status/control stuff
        // Leave the MXCSR stuff alone
        //
        ContextIa64->StFCR = (ContextIa64->StFCR & 0xffffffffffffe040i64) | 
                             (ContextX86->FloatSave.ControlWord & 0xffff);

        ContextIa64->StFSR = (ContextIa64->StFSR & 0xffffffff00000000i64) | 
                             (ContextX86->FloatSave.StatusWord & 0xffff) | 
                             ((ContextX86->FloatSave.TagWord & 0xffff) << 16);

        ContextIa64->StFIR = (ContextX86->FloatSave.ErrorOffset & 0xffffffff) | 
                             (ContextX86->FloatSave.ErrorSelector << 32);

        ContextIa64->StFDR = (ContextX86->FloatSave.DataOffset & 0xffffffff) | 
                             (ContextX86->FloatSave.DataSelector << 32);


        //
        // Copy over the FP registers from packed 10-byte format
        // to 16-byte format
        //
        Wow64CopyFpToIa64Byte16(ContextX86->FloatSave.RegisterArea,
                                tmpFloat,
                                NUMBER_OF_387REGS);

        // 
        // Rotate registers back
        //
        {
            ULONGLONG RotateFSR = (NUMBER_OF_387REGS - 
                                   ((ContextIa64->StFSR >> 11) & 0x7)) << 11;
            Wow64RotateFpTop(RotateFSR, tmpFloat);
        }

        //
        // Now convert from 80 byte extended format to fill/spill format
        //
        Wow64CopyIa64ToFill((PFLOAT128) tmpFloat,
                            (PFLOAT128) &(ContextIa64->FltT2),
                            NUMBER_OF_387REGS);
    }

    if ((Ia32ContextFlags & CONTEXT32_DEBUG_REGISTERS) == CONTEXT32_DEBUG_REGISTERS) {
        LOGPRINT((TRACELOG, "Wow64CtxToIa64: Request to convert debug registers\n"));
    }
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\cpu\amd64\context\suspend.c ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name: 

    suspend.c

Abstract:
    
    This module implements CpuSuspendThread, CpuGetContext and CpuSetContext.

Author:

    16-Dec-1999  SamerA

Revision History:

--*/

#define _WOW64CPUAPI_


#ifdef _X86_
#include "ia6432.h"
#else
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntos.h>
#include "wow64.h"
#include "wow64cpu.h"
#include "amd64cpu.h"
#endif

#include <stdio.h>
#include <stdarg.h>

//
// This is to prevent this library from linking to wow64 to use wow64!Wow64LogPrint
//
#if defined(LOGPRINT)
#undef LOGPRINT
#endif
#define LOGPRINT(_x_)   CpupDebugPrint _x_


ASSERTNAME;

#define DECLARE_CPU         \
    PCPUCONTEXT cpu = (PCPUCONTEXT)Wow64TlsGetValue(WOW64_TLS_CPURESERVED)


ULONG_PTR ia32ShowContext = 0;

VOID
CpupDebugPrint(
    IN ULONG_PTR Flags,
    IN PCHAR Format,
    ...)
{
    va_list ArgList;
    int BytesWritten;
    CHAR Buffer[ 512 ];

    if ((ia32ShowContext & Flags) || (Flags == ERRORLOG))
    {
        va_start(ArgList, Format);
        BytesWritten = _vsnprintf(Buffer,
                                  sizeof(Buffer) - 1,
                                  Format,
                                  ArgList);
        if (BytesWritten > 0)
        {
            DbgPrint(Buffer);
        }
        va_end(ArgList);
    }
    
    return;
}


VOID
CpupPrintContext(
    IN PCHAR str,
    IN PCPUCONTEXT cpu
    )
/*++

Routine Description:

    Print out the ia32 context based on the passed in cpu context

Arguments:

    str - String to print out as a header
    cpu - Pointer to the per-thread wow64 ia32 context.

Return Value:

    none

--*/

{

    DbgPrint(str);
    DbgPrint("Context addr(0x%p): EIP=0x%08x\n", &(cpu->Context), cpu->Context.Eip);
    DbgPrint("Context EAX=0x%08x, EBX=0x%08x, ECX=0x%08x, EDX=0x%08x\n",
                        cpu->Context.Eax,
                        cpu->Context.Ebx,
                        cpu->Context.Ecx,
                        cpu->Context.Edx);

    DbgPrint("Context ESP=0x%08x, EBP=0x%08x, ESI=0x%08x, EDI=0x%08x\n",
                        cpu->Context.Esp,
                        cpu->Context.Ebp,
                        cpu->Context.Esi,
                        cpu->Context.Edi);

    try {

        //
        // The stack may not yet be fully formed, so don't
        // let a missing stack cause the process to abort
        //

        DbgPrint("Context stack=0x%08x 0x%08x 0x%08x 0x%08x\n",
                        *((PULONG) cpu->Context.Esp),
                        *(((PULONG) cpu->Context.Esp) + 1),
                        *(((PULONG) cpu->Context.Esp) + 2),
                        *(((PULONG) cpu->Context.Esp) + 3));

    } except ((GetExceptionCode() == STATUS_ACCESS_VIOLATION)?1:0) {

        //
        // Got an access violation, so don't print any of the stack
        //

        DbgPrint("Context stack: Can't get stack contents\n");
    }

    DbgPrint("Context EFLAGS=0x%08x\n", cpu->Context.EFlags);
}

WOW64CPUAPI
NTSTATUS
CpuSuspendThread(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    OUT PULONG PreviousSuspendCount OPTIONAL)
/*++

Routine Description:

    This routine is entered while the target thread is actually suspended, however, it's 
    not known if the target thread is in a consistent state relative to
    the CPU.    

Arguments:

    ThreadHandle          - Handle of target thread to suspend
    ProcessHandle         - Handle of target thread's process 
    Teb                   - Address of the target thread's TEB
    PreviousSuspendCount  - Previous suspend count

Return Value:

    NTSTATUS.

--*/
{
    return STATUS_SUCCESS;
}


NTSTATUS CpupReadBuffer(
    IN HANDLE ProcessHandle,
    IN PVOID Source,
    OUT PVOID Destination,
    IN ULONG Size)
/*++

Routine Description:

    This routine setup the arguments for the remoted  SuspendThread call.
    
Arguments:

    ProcessHandle  - Target process handle to read data from
    Source         - Target base address to read data from
    Destination    - Address of buffer to receive data read from the specified address space
    Size           - Size of data to read

Return Value:

    NTSTATUS.

--*/
{
    return NtReadVirtualMemory(ProcessHandle,
                               Source,
                               Destination,
                               Size,
                               NULL);
}

NTSTATUS
CpupWriteBuffer(
    IN HANDLE ProcessHandle,
    IN PVOID Target,
    IN PVOID Source,
    IN ULONG Size)
/*++

Routine Description:

    Writes data to memory taken into consideration if the write is cross-process
    or not
    
Arguments:

    ProcessHandle  - Target process handle to write data into
    Target         - Target base address to write data at
    Source         - Address of contents to write in the specified address space
    Size           - Size of data to write
    
Return Value:

    NTSTATUS.

--*/
{
    return NtWriteVirtualMemory(ProcessHandle,
                                Target,
                                Source,
                                Size,
                                NULL);
}

NTSTATUS
GetContextRecord(
    IN PCPUCONTEXT cpu,
    IN OUT PCONTEXT32 Context
    )
/*++

Routine Description:

    Retrevies the context record of the specified CPU

Arguments:

    cpu     - CPU to retreive the context record for.
    Context - IN/OUT pointer to CONTEXT32 to fill in.  Context->ContextFlags
              should be used to determine how much of the context to copy.

Return Value:

    None.

--*/

{


    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG ContextFlags;
    
#if 0

    try 
    {
        ContextFlags = Context->ContextFlags;
        if (ContextFlags & CONTEXT_IA64)
        {
            LOGPRINT((ERRORLOG, "CpuGetContext: Request for ia64 context (0x%x) being FAILED\n", ContextFlags));
            ASSERT((ContextFlags & CONTEXT_IA64) == 0);
        }

        if ((ContextFlags & CONTEXT32_CONTROL) == CONTEXT32_CONTROL) 
        {
            //
            // i386 control registers are:
            // ebp, eip, cs, eflag, esp and ss
            //
            Context->Ebp = cpu->Context.Ebp;
            Context->Eip = cpu->Context.Eip;
            Context->SegCs = KGDT_R3_CODE|3;   // Force reality
            Context->EFlags = cpu->Context.EFlags;
            Context->Esp = cpu->Context.Esp;
            Context->SegSs = KGDT_R3_DATA|3;   // Force reality
        }

        if ((ContextFlags & CONTEXT32_INTEGER)  == CONTEXT32_INTEGER)
        {
            //
            // i386 integer registers are:
            // edi, esi, ebx, edx, ecx, eax
            //
            Context->Edi = cpu->Context.Edi;
            Context->Esi = cpu->Context.Esi;
            Context->Ebx = cpu->Context.Ebx;
            Context->Edx = cpu->Context.Edx;
            Context->Ecx = cpu->Context.Ecx;
            Context->Eax = cpu->Context.Eax;
        }

        if ((ContextFlags & CONTEXT32_SEGMENTS) == CONTEXT32_SEGMENTS) 
        {
            //
            // i386 segment registers are:
            // ds, es, fs, gs
            // And since they are a constant, force them to be the right values
            //
            Context->SegDs = KGDT_R3_CODE|3;
            Context->SegEs = KGDT_R3_CODE|3;
            Context->SegFs = KGDT_R3_TEB|3;
            Context->SegGs = KGDT_R3_CODE|3;
        }

        if ((ContextFlags & CONTEXT32_FLOATING_POINT) == CONTEXT32_FLOATING_POINT) 
        {
            //
            // For the ISA transition routine, these floats need to be
            // in the ExtendedRegister area. So grab the values requested
            // from that area
            //
            PFXSAVE_FORMAT_WX86 xmmi = (PFXSAVE_FORMAT_WX86) &(cpu->Context.ExtendedRegisters[0]);

            LOGPRINT((TRACELOG, "CpuGetContext: Request to get float registers(0x%x)\n", ContextFlags));

            //
            // Start by grabbing the status/control portion
            //
            Context->FloatSave.ControlWord = xmmi->ControlWord;
            Context->FloatSave.StatusWord = xmmi->StatusWord;
            Context->FloatSave.TagWord = xmmi->TagWord;
            Context->FloatSave.ErrorOffset = xmmi->ErrorOffset;
            Context->FloatSave.ErrorSelector = xmmi->ErrorSelector;
            Context->FloatSave.DataOffset = xmmi->DataOffset;
            Context->FloatSave.DataSelector = xmmi->DataSelector;

            //
            // Now get the packed 10-byte fp data registers
            //
            Wow64CopyFpFromIa64Byte16(&(xmmi->RegisterArea[0]),
                                      &(Context->FloatSave.RegisterArea[0]),
                                      NUMBER_OF_387REGS);
        }

        if ((ContextFlags & CONTEXT32_DEBUG_REGISTERS) == CONTEXT32_DEBUG_REGISTERS) 
        {
            LOGPRINT((TRACELOG, "CpuGetContext: Request to get debug registers(0x%x)\n", ContextFlags));
            Context->Dr0 = cpu->Context.Dr0;
            Context->Dr1 = cpu->Context.Dr1;
            Context->Dr2 = cpu->Context.Dr2;
            Context->Dr3 = cpu->Context.Dr3;
            Context->Dr6 = cpu->Context.Dr6;
            Context->Dr7 = cpu->Context.Dr7;
        }

        if ((ContextFlags & CONTEXT32_EXTENDED_REGISTERS) == CONTEXT32_EXTENDED_REGISTERS) 
        {
            LOGPRINT((TRACELOG, "CpuGetContext: Request to get Katmai registers(0x%x)\n", ContextFlags));
            
            RtlCopyMemory(&(Context->ExtendedRegisters[0]),
                          &(cpu->Context.ExtendedRegisters[0]),
                          MAXIMUM_SUPPORTED_EXTENSION);
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        NtStatus = GetExceptionCode();
    }

    if (ia32ShowContext & LOG_CONTEXT_GETSET) 
    {
        CpupPrintContext("Getting ia32 context: ", cpu);
    }

#endif

    return NtStatus;
}

NTSTATUS
CpupGetContext(
    IN OUT PCONTEXT32 Context
    )
/*++

Routine Description:

    This routine extracts the context record for the currently executing thread. 

Arguments:

    Context  - Context record to fill

Return Value:

    NTSTATUS.

--*/
{
    DECLARE_CPU;

    return GetContextRecord(cpu, Context);
}


NTSTATUS
CpupGetContextThread(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    IN OUT PCONTEXT32 Context)
/*++

Routine Description:

    This routine extract the context record of any thread. This is a generic routine.
    When entered, if the target thread isn't the current thread, then it should be 
    guaranteed that the target thread is suspended at a proper CPU state.

Arguments:

    ThreadHandle   - Target thread handle to retreive the context for
    ProcessHandle  - Open handle to the process that the thread runs in
    Teb            - Pointer to the target's thread TEB
    Context        - Context record to fill                 

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    CONTEXT ContextEM;
    PCPUCONTEXT CpuRemoteContext;
    CPUCONTEXT CpuContext;


    ContextEM.ContextFlags = CONTEXT_FULL;
    NtStatus = NtGetContextThread(ThreadHandle,
                                  &ContextEM);

#if 0

    if (!NT_SUCCESS(NtStatus))
    {
        LOGPRINT((ERRORLOG, "CpupGetContextThread: NtGetContextThread (%lx) failed - %lx\n", 
                  ThreadHandle, NtStatus));
        return NtStatus;
    }

    if (ContextEM.StIPSR & (1i64 << PSR_IS))
    {
        Wow64CtxFromIa64(Context->ContextFlags, &ContextEM, Context);
                    
        LOGPRINT((TRACELOG, "Getting context while thread is executing 32-bit instructions - %lx\n", NtStatus));
    }
    else
    {
        LOGPRINT((TRACELOG, "Getting context while thread is executing 64-bit instructions\n"));
        NtStatus = CpupReadBuffer(ProcessHandle,
                                  ((PCHAR)Teb + FIELD_OFFSET(TEB, TlsSlots[WOW64_TLS_CPURESERVED])),
                                  &CpuRemoteContext,
                                  sizeof(CpuRemoteContext));

        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = CpupReadBuffer(ProcessHandle,
                                      CpuRemoteContext,
                                      &CpuContext,
                                      sizeof(CpuContext));

            if (NT_SUCCESS(NtStatus))
            {
                NtStatus = GetContextRecord(&CpuContext, Context);
            }
            else
            {
                LOGPRINT((ERRORLOG, "CpupGetContextThread: Couldn't read CPU context %lx - %lx\n", 
                          CpuRemoteContext, NtStatus));

            }
        }
        else
        {
            LOGPRINT((ERRORLOG, "CpupGetContextThread: Couldn't read CPU context address - %lx\n", 
                      NtStatus));
        }
    }

#endif

    return NtStatus;
}



WOW64CPUAPI
NTSTATUS  
CpuGetContext(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    OUT PCONTEXT32 Context)
/*++

Routine Description:

    Extracts the cpu context of the specified thread.
    When entered, it is guaranteed that the target thread is suspended at 
    a proper CPU state.

Arguments:

    ThreadHandle   - Target thread handle to retreive the context for
    ProcessHandle  - Open handle to the process that the thread runs in
    Teb            - Pointer to the target's thread TEB
    Context        - Context record to fill                 

Return Value:

    NTSTATUS.

--*/
{
    if (NtCurrentThread() == ThreadHandle)
    {
        return CpupGetContext(Context);
    }

    return CpupGetContextThread(ThreadHandle,
                                ProcessHandle,
                                Teb,
                                Context);
}


NTSTATUS
SetContextRecord(
    IN PCPUCONTEXT cpu,
    IN OUT PCONTEXT32 Context
    )
/*++

Routine Description:

    Update the CPU's register set for the specified CPU.

Arguments:

    cpu     - CPU to update its registers
    Context - IN pointer to CONTEXT32 to use.  Context->ContextFlags
              should be used to determine how much of the context to update.

Return Value:

    None.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG ContextFlags;

#if 0
    
    try 
    {
        ContextFlags = Context->ContextFlags;
        if (ContextFlags & CONTEXT_IA64) 
        {
            LOGPRINT((ERRORLOG, "CpuSetContext: Request with ia64 context (0x%x) FAILED\n", ContextFlags));
            ASSERT((ContextFlags & CONTEXT_IA64) == 0);
        }

        if ((ContextFlags & CONTEXT32_CONTROL) == CONTEXT32_CONTROL) 
        {
            //
            // i386 control registers are:
            // ebp, eip, cs, eflag, esp and ss
            //
            cpu->Context.Ebp = Context->Ebp;
            cpu->Context.Eip = Context->Eip;
            cpu->Context.SegCs = KGDT_R3_CODE|3;   // Force Reality
            cpu->Context.EFlags = Context->EFlags;
            cpu->Context.Esp = Context->Esp;
            cpu->Context.SegSs = KGDT_R3_DATA|3;   // Force Reality
        }

        if ((ContextFlags & CONTEXT32_INTEGER)  == CONTEXT32_INTEGER)
        {
            //
            // i386 integer registers are:
            // edi, esi, ebx, edx, ecx, eax
            //
            cpu->Context.Edi = Context->Edi;
            cpu->Context.Esi = Context->Esi;
            cpu->Context.Ebx = Context->Ebx;
            cpu->Context.Edx = Context->Edx;
            cpu->Context.Ecx = Context->Ecx;
            cpu->Context.Eax = Context->Eax;
        }

        if ((ContextFlags & CONTEXT32_SEGMENTS) == CONTEXT32_SEGMENTS) 
        {
            //
            // i386 segment registers are:
            // ds, es, fs, gs
            // And since they are a constant, force them to be the right values
            //
            cpu->Context.SegDs = KGDT_R3_DATA|3;
            cpu->Context.SegEs = KGDT_R3_DATA|3;
            cpu->Context.SegFs = KGDT_R3_TEB|3;
            cpu->Context.SegGs = KGDT_R3_DATA|3;
        }

        if ((ContextFlags & CONTEXT32_FLOATING_POINT) == CONTEXT32_FLOATING_POINT) 
        {
            //
            // For the ISA transition routine, these floats need to be
            // in the ExtendedRegister area. So put the values requested
            // into that area
            //
            PFXSAVE_FORMAT_WX86 xmmi = (PFXSAVE_FORMAT_WX86) &(cpu->Context.ExtendedRegisters[0]);

            LOGPRINT((TRACELOG, "CpuSetContext: Request to set float registers(0x%x)\n", ContextFlags));

            //
            // Start by grabbing the status/control portion
            //
            xmmi->ControlWord = (USHORT) (Context->FloatSave.ControlWord & 0xFFFF);
            xmmi->StatusWord = (USHORT) (Context->FloatSave.StatusWord & 0xFFFF);
            xmmi->TagWord = (USHORT) (Context->FloatSave.TagWord & 0xFFFF);
            xmmi->ErrorOffset = Context->FloatSave.ErrorOffset;
            xmmi->ErrorSelector = Context->FloatSave.ErrorSelector;
            xmmi->DataOffset = Context->FloatSave.DataOffset;
            xmmi->DataSelector = Context->FloatSave.DataSelector;

            //
            // Now get the packed 10-byte fp data registers and convert
            // them into the 16-byte format used by FXSAVE (and the
            // ISA transition routine)
            //
            Wow64CopyFpToIa64Byte16(&(Context->FloatSave.RegisterArea[0]),
                                    &(xmmi->RegisterArea[0]),
                                    NUMBER_OF_387REGS);
        }

        if ((ContextFlags & CONTEXT32_DEBUG_REGISTERS) == CONTEXT32_DEBUG_REGISTERS)
        {
            LOGPRINT((TRACELOG, "CpuSetContext: Request to set debug registers(0x%x)\n", ContextFlags));
            cpu->Context.Dr0 = Context->Dr0;
            cpu->Context.Dr1 = Context->Dr1;
            cpu->Context.Dr2 = Context->Dr2;
            cpu->Context.Dr3 = Context->Dr3;
            cpu->Context.Dr6 = Context->Dr6;
            cpu->Context.Dr7 = Context->Dr7;
        }

        if ((ContextFlags & CONTEXT32_EXTENDED_REGISTERS) == CONTEXT32_EXTENDED_REGISTERS) 
        {
            LOGPRINT((TRACELOG, "CpuSetContext: Request to set Katmai registers(0x%x)\n", ContextFlags));
            RtlCopyMemory(&(cpu->Context.ExtendedRegisters[0]),
                          &(Context->ExtendedRegisters[0]),
                          MAXIMUM_SUPPORTED_EXTENSION);
        }

        //
        // Whatever they passed in before, it's an X86 context now...
        //
        cpu->Context.ContextFlags = ContextFlags;
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        NtStatus = GetExceptionCode();
    }


    if (ia32ShowContext & LOG_CONTEXT_GETSET) 
    {
        CpupPrintContext("Setting ia32 context: ", cpu);
    }

#endif

    return NtStatus;
}

NTSTATUS
CpupSetContext(
    IN OUT PCONTEXT32 Context
    )
/*++

Routine Description:

    This routine sets the context record for the currently executing thread. 

Arguments:

    Context  - Context record to fill 

Return Value:

    NTSTATUS.

--*/
{
    DECLARE_CPU;

    return SetContextRecord(cpu, Context);
}



NTSTATUS
CpupSetContextThread(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    IN OUT PCONTEXT32 Context)
/*++

Routine Description:

    This routine sets the context record of any thread. This is a generic routine.
    When entered, if the target thread isn't the currently executing thread, then it should be 
    guaranteed that the target thread is suspended at a proper CPU state.

Arguments:

    ThreadHandle   - Target thread handle to retreive the context for
    ProcessHandle  - Open handle to the process that the thread runs in
    Teb            - Pointer to the target's thread TEB
    Context        - Context record to set

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    CONTEXT ContextEM;
    PCPUCONTEXT CpuRemoteContext;
    CPUCONTEXT CpuContext;


    
    ContextEM.ContextFlags = CONTEXT_FULL;
    NtStatus = NtGetContextThread(ThreadHandle,
                                  &ContextEM);
#if 0

    if (!NT_SUCCESS(NtStatus))
    {
        LOGPRINT((ERRORLOG, "CpupGetContextThread: NtGetContextThread (%lx) failed - %lx\n", 
                  ThreadHandle, NtStatus));

        return NtStatus;
    }

    if (ContextEM.StIPSR & (1i64 << PSR_IS))
    {
        Wow64CtxToIa64(Context->ContextFlags, Context, &ContextEM);
        NtStatus = NtSetContextThread(ThreadHandle, &ContextEM);
        LOGPRINT((TRACELOG, "Setting context while thread is executing 32-bit instructions - %lx\n", NtStatus));
    }
    else
    {
        LOGPRINT((TRACELOG, "Setting context while thread is executing 64-bit instructions\n"));
        NtStatus = CpupReadBuffer(ProcessHandle,
                                  ((PCHAR)Teb + FIELD_OFFSET(TEB, TlsSlots[WOW64_TLS_CPURESERVED])),
                                  &CpuRemoteContext,
                                  sizeof(CpuRemoteContext));

        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = CpupReadBuffer(ProcessHandle,
                                      CpuRemoteContext,
                                      &CpuContext,
                                      sizeof(CpuContext));

            if (NT_SUCCESS(NtStatus))
            {    
                NtStatus = SetContextRecord(&CpuContext, Context);

                if (NT_SUCCESS(NtStatus))
                {
                    NtStatus = CpupWriteBuffer(ProcessHandle,
                                               CpuRemoteContext,
                                               &CpuContext,
                                               sizeof(CpuContext));
                }
                else
                {
                    LOGPRINT((ERRORLOG, "CpupSetContextThread: Couldn't read CPU context %lx - %lx\n", 
                              CpuRemoteContext, NtStatus));
                }
            }
        }
        else
        {
            LOGPRINT((ERRORLOG, "CpupSetContextThread: Couldn't read CPU context address - %lx\n", 
                      NtStatus));

        }
    }

#endif

    return NtStatus;
}


WOW64CPUAPI
NTSTATUS
CpuSetContext(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    PCONTEXT32 Context)
/*++

Routine Description:

    Sets the cpu context for the specified thread.
    When entered, if the target thread isn't the currently executing thread, then it is 
    guaranteed that the target thread is suspended at a proper CPU state.

Arguments:

    ThreadHandle   - Target thread handle to retreive the context for
    ProcessHandle  - Open handle to the process that the thread runs in
    Teb            - Pointer to the target's thread TEB
    Context        - Context record to set

Return Value:

    NTSTATUS.

--*/
{
    if (NtCurrentThread() == ThreadHandle)
    {
        return CpupSetContext(Context);
    }
    
    return CpupSetContextThread(ThreadHandle,
                                ProcessHandle,
                                Teb,
                                Context);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\cpu\amd64\cpu\common.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    common.c

Abstract:

    Platform independent functions for the WOW64 cpu component.

Author:

    05-June-1998 BarryBo

--*/

#define _WOW64CPUAPI_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "wow64.h"
#include "wow64cpu.h"

ASSERTNAME;

//
// Define the length of the history buffer. A length of zero means no
// history is being kept.
//

#if defined(WOW64_HISTORY)

ULONG HistoryLength;

#endif

NTSTATUS
CpupReadRegistryDword (
    IN HANDLE RegistryHandle,
    IN PWSTR ValueName,
    OUT PDWORD RegistryDword)
/*++

Routine Description:

    Check the registry for the given registry value name and if it
    exists, copy the DWORD associated into the variable supplied by the caller

Arguments:

    RegistryHandle - Contains an open handle to a registry key
    ValueName      - The name of the registry value to look up
    RegistryDword  - If the lookup was successful, this gets the DWORD value
                     that was associated with the registry name. If the
                     lookup was unsuccessful, this value is unchanged.

Return Value:

    NTSTATUS - Result of the NT Quesry Value Key.

--*/

{

    NTSTATUS st;

    UNICODE_STRING KeyName;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    WCHAR Buffer[100];
    ULONG ResultLength;

    RtlInitUnicodeString(&KeyName, ValueName);
    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)Buffer;
    st = NtQueryValueKey(RegistryHandle,
                                 &KeyName,
                                 KeyValuePartialInformation,
                                 KeyValueInformation,
                                 sizeof(Buffer),
                                 &ResultLength);

    if (NT_SUCCESS(st) && (KeyValueInformation->Type == REG_DWORD)) {

        //
        // We found a valid registry value name and it is holding a DWORD
        // so grab the associated value and pass it back to the caller
        //

        *RegistryDword = *(DWORD *)(KeyValueInformation->Data);
    }

    return st;
}

#if defined(WOW64_HISTORY)

VOID
CpupCheckHistoryKey (
    IN PWSTR pImageName,
    OUT PULONG pHistoryLength
    )

/*++

Routine Description:

    Checks if the registry if service history should be enabled. A missing
    key means disable.

Arguments:

    pImageName - the name of the image. DO NOT SAVE THIS POINTER. The contents
                 are freed up by wow64.dll when we return from the call

    pHistoryLength - size of history buffer. If history is not enabled,
                 returns zero

Return Value:

    None

--*/

{

    UNICODE_STRING KeyName;
    OBJECT_ATTRIBUTES ObjA;

    NTSTATUS st;

    DWORD EnableHistory = FALSE;        // assume disabled
    HANDLE hKey = NULL;                 // non-null means we have an open key

    LOGPRINT((TRACELOG, "CpupCheckHistoryKey(%ws) called.\n", pImageName));

    //
    // Initialize the size of the histry buffer assuming no history buffer
    //

    *pHistoryLength = 0;

    //
    // Check in the HKLM area...
    //

    RtlInitUnicodeString(&KeyName, CPUHISTORY_MACHINE_SUBKEY);
    InitializeObjectAttributes(&ObjA, &KeyName, OBJ_CASE_INSENSITIVE, NULL, NULL);
    st = NtOpenKey(&hKey, KEY_READ, &ObjA);

    if (NT_SUCCESS(st)) {

        //
        // Have subkey path, now look for specific values
        // First the program name, then the generic enable/disable key
        // as the program name key takes priority if it exists
        //

        st = CpupReadRegistryDword(hKey, pImageName, &EnableHistory);
        if (STATUS_OBJECT_NAME_NOT_FOUND == st) {

            //
            // No image name was found, so see
            // if the generic enable was in the registry
            //

            st = CpupReadRegistryDword(hKey, CPUHISTORY_ENABLE, &EnableHistory);

            //
            // If there is a problem with the generic enable, then that means
            // history is not enabled. No need to check the status returned.
            //
        }

        //
        // If we have a history buffer request, then find out the size
        // of the buffer
        //

        if (EnableHistory) {
            
            //
            // pHistoryLength is a pointer to a ULONG so make
            // sure we can stuff a DWORD into it via the 
            // CpupReadRegistryDword() function
            //

            WOWASSERT(sizeof(ULONG) == sizeof(DWORD));

            //
            // Now get the size of the history area
            //

            st = CpupReadRegistryDword(hKey, CPUHISTORY_SIZE, pHistoryLength);

            //
            // If there is a problem with the size entry, then that means
            // we should use the minimum size which we check for anyway
            // below. Thus, no need to check the returned status.
            //
            // And a reality check
            //
            // Make sure we have at least a minimum number of entries for the
            // history buffer if it is enabled
            //

            if (*pHistoryLength < CPUHISTORY_MIN_SIZE) {
                *pHistoryLength = CPUHISTORY_MIN_SIZE;
            }
        }
    }

    if (hKey) {
        NtClose(hKey);
    }

    LOGPRINT((TRACELOG, "CpupCheckHistoryKey() Enabled: %d, Length: %d.\n", EnableHistory, *pHistoryLength));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\cpu\amd64\dbgexts\w64cpuex.cpp ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    w64cpuex.cpp

Abstract:

    Debugger extension DLL for debugging the CPU

Author:

    27-Sept-1999 BarryBo

Revision History:


--*/

#define _WOW64CPUDBGAPI_
#define DECLARE_CPU_DEBUGGER_INTERFACE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <dbgeng.h>
#include <ntosp.h>

#if defined _X86_
#define WOW64EXTS_386
#endif

#include "wow64.h"
#include "wow64cpu.h"
#include "amd64cpu.h"

// Safe release and NULL.

#define EXT_RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)

#define CONTEXT_OFFSET FIELD_OFFSET(TEB64, TlsSlots[WOW64_TLS_CPURESERVED])


CPUCONTEXT            LocalCpuContext;
PWOW64GETCPUDATA      CpuGetData;
PDEBUG_ADVANCED       g_ExtAdvanced;
PDEBUG_CLIENT         g_ExtClient;
PDEBUG_CONTROL        g_ExtControl;
PDEBUG_DATA_SPACES    g_ExtData;
PDEBUG_REGISTERS      g_ExtRegisters;
PDEBUG_SYMBOLS        g_ExtSymbols;
PDEBUG_SYSTEM_OBJECTS g_ExtSystem;
void
ExtRelease(void)
{
    g_ExtClient = NULL;
    EXT_RELEASE(g_ExtAdvanced);
    EXT_RELEASE(g_ExtControl);
    EXT_RELEASE(g_ExtData);
    EXT_RELEASE(g_ExtRegisters);
    EXT_RELEASE(g_ExtSymbols);
    EXT_RELEASE(g_ExtSystem);
}

// Queries for all debugger interfaces.
HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Status;

    if ((Status = Client->QueryInterface(__uuidof(IDebugAdvanced),
                                         (void **)&g_ExtAdvanced)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugControl),
                                         (void **)&g_ExtControl)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                         (void **)&g_ExtData)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugRegisters),
                                         (void **)&g_ExtRegisters)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols),
                                         (void **)&g_ExtSymbols)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                         (void **)&g_ExtSystem)) != S_OK)
    {
        goto Fail;
    }

    g_ExtClient = Client;

    return S_OK;

 Fail:
    ExtRelease();
    return Status;
}
// Normal output.
void __cdecl
ExtOut(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_NORMAL, Format, Args);
    va_end(Args);
}

// Error output.
void __cdecl
ExtErr(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);
}

// Warning output.
void __cdecl
ExtWarn(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_WARNING, Format, Args);
    va_end(Args);
}

// Verbose output.
void __cdecl
ExtVerb(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_VERBOSE, Format, Args);
    va_end(Args);
}

WOW64CPUDBGAPI VOID
CpuDbgInitEngapi(
    PWOW64GETCPUDATA lpGetData
    )
{
    CpuGetData = lpGetData;
}


HRESULT
EngGetContextThread(
    IN OUT PCONTEXT32 Context)
/*++

Routine Description:

    This routine extract the context record of any thread. This is a generic routine.
    When entered, if the target thread isn't the current thread, then it should be 
    guaranteed that the target thread is suspended at a proper CPU state.

Arguments:

    Context        - Context record to fill                 

Return Value:

    HRESULT.

--*/
{
    HRESULT hr;
    NTSTATUS NtStatus;
    ULONG64 CpuRemoteContext;
    ULONG64 Teb;
    CPUCONTEXT CpuContext;

    hr = g_ExtSystem->GetCurrentThreadTeb(&Teb);
    if (FAILED(hr)) {
        return hr;
    }

    hr = g_ExtData->ReadVirtual(Teb + CONTEXT_OFFSET,
                                &CpuRemoteContext,
                                sizeof(CpuRemoteContext),
                                NULL);
  
    if (FAILED(hr)) {
        return hr;
    }
    hr = g_ExtData->ReadVirtual(CpuRemoteContext,
                                &CpuContext,
                                sizeof(CpuContext),
                                NULL);
    if (FAILED(hr)) {
        return hr;
    }
    
    NtStatus = GetContextRecord(&CpuContext, Context);
    if (!NT_SUCCESS(NtStatus)) {
        return E_FAIL;
    }
    return hr;
}


WOW64CPUDBGAPI BOOL
CpuDbgGetRemoteContext(
    PDEBUG_CLIENT Client,
    PVOID CpuData
    )
{
    BOOL bRet = FALSE;
    HRESULT hr;
    CONTEXT Context;

    hr = ExtQuery(Client);
    if (FAILED(hr)) {
        return FALSE;
    }
    LocalCpuContext.Context.ContextFlags = CONTEXT32_FULL;
    hr = EngGetContextThread(&LocalCpuContext.Context);
    if (FAILED(hr)) {
        goto Done;
    }

    bRet = TRUE;
Done:
    ExtRelease();
    return bRet;
}

HRESULT
EngSetContextThread(
    IN OUT PCONTEXT32 Context)
/*++

Routine Description:

    This routine sets the context record of any thread. This is a generic routine.
    When entered, if the target thread isn't the currently executing thread, then it should be 
    guaranteed that the target thread is suspended at a proper CPU state.

Arguments:

    Context        - Context record to set

Return Value:

    HRESULT.

--*/
{
    HRESULT hr;
    NTSTATUS NtStatus;
    ULONG64 CpuRemoteContext;
    ULONG64 Teb;
    CPUCONTEXT CpuContext;

    hr = g_ExtSystem->GetCurrentThreadTeb(&Teb);
    if (FAILED(hr)) {
        return hr;
    }

    hr = g_ExtData->ReadVirtual(Teb + CONTEXT_OFFSET,
                                &CpuRemoteContext,
                                sizeof(CpuRemoteContext),
                                NULL);

    if (FAILED(hr)) {
        return hr;
    }
    hr = g_ExtData->ReadVirtual(CpuRemoteContext,
                                &CpuContext,
                                sizeof(CpuContext),
                                NULL);
    if (FAILED(hr)) {
        return hr;
    }
    NtStatus = SetContextRecord(&CpuContext, Context);
    if (!NT_SUCCESS(NtStatus)) {
        return E_FAIL;
    }
    hr = g_ExtData->WriteVirtual(CpuRemoteContext,
                                 &CpuContext,
                                 sizeof(CpuContext),
                                 NULL);
    return hr;
}


WOW64CPUDBGAPI BOOL
CpuDbgSetRemoteContext(
    PDEBUG_CLIENT Client
    )
{
    BOOL bRet = FALSE;
    HRESULT hr;
    NTSTATUS Status;
    CONTEXT Context;

    hr = ExtQuery(Client);
    if (FAILED(hr)) {
        return FALSE;
    }

    LocalCpuContext.Context.ContextFlags = CONTEXT32_FULL;
    hr = EngSetContextThread(&LocalCpuContext.Context);
    if (FAILED(hr)) {
        ExtOut("CpuDbgSetRemoteContext:  Error %x writing CPU context\n", hr);
        goto Done;
    }

    bRet = TRUE;
Done:
    ExtRelease();
    return bRet;
}

WOW64CPUDBGAPI BOOL
CpuDbgGetLocalContext(
    PDEBUG_CLIENT Client,
    PCONTEXT32 Context
    )
{
    return NT_SUCCESS(GetContextRecord(&LocalCpuContext,
                                       Context));
}

WOW64CPUDBGAPI BOOL
CpuDbgSetLocalContext(
    PDEBUG_CLIENT Client,
    PCONTEXT32 Context
    )
{
    return NT_SUCCESS(SetContextRecord(&LocalCpuContext,
                                       Context));
}


WOW64CPUDBGAPI VOID
CpuDbgFlushInstructionCacheWithHandle(
    HANDLE Process,
    PVOID Addr,
    DWORD Length
    )
{
    
    NtFlushInstructionCache((HANDLE)Process, Addr, Length);
}


WOW64CPUDBGAPI VOID
CpuDbgFlushInstructionCache(
    PDEBUG_CLIENT Client,
    PVOID Addr,
    DWORD Length
    )
{
    HRESULT hr;
    ULONG64 Process;

    hr = ExtQuery(Client);
    if (FAILED(hr)) {
        return;
    }
    hr = g_ExtSystem->GetCurrentProcessHandle(&Process);
    if (FAILED(hr)) {
        ExtOut("CpuDbgFlushInstructionCache: failed to get Process Handle!\n");
        return;
    }
    CpuDbgFlushInstructionCacheWithHandle((HANDLE)Process, Addr, Length);
    ExtRelease();
}


VOID SetEax(ULONG ul) {
    LocalCpuContext.Context.Eax = ul;
}
VOID SetEbx(ULONG ul) {
    LocalCpuContext.Context.Ebx = ul;
}
VOID SetEcx(ULONG ul) {
    LocalCpuContext.Context.Ecx = ul;
}
VOID SetEdx(ULONG ul) {
    LocalCpuContext.Context.Edx = ul;
}
VOID SetEsi(ULONG ul) {
    LocalCpuContext.Context.Esi = ul;
}
VOID SetEdi(ULONG ul) {
    LocalCpuContext.Context.Edi = ul;
}
VOID SetEbp(ULONG ul) {
    LocalCpuContext.Context.Ebp = ul;
}
VOID SetEsp(ULONG ul) {
    LocalCpuContext.Context.Esp = ul;
}
VOID SetEip(ULONG ul) {
    LocalCpuContext.Context.Eip = ul;
}
VOID SetEfl(ULONG ul) {
    LocalCpuContext.Context.EFlags = ul;
}

ULONG GetEax(VOID) {
    return LocalCpuContext.Context.Eax;
}
ULONG GetEbx(VOID) {
    return LocalCpuContext.Context.Ebx;
}
ULONG GetEcx(VOID) {
    return LocalCpuContext.Context.Ecx;
}
ULONG GetEdx(VOID) {
    return LocalCpuContext.Context.Edx;
}
ULONG GetEsi(VOID) {
    return LocalCpuContext.Context.Esi;
}
ULONG GetEdi(VOID) {
    return LocalCpuContext.Context.Edi;
}
ULONG GetEbp(VOID) {
    return LocalCpuContext.Context.Ebp;
}
ULONG GetEsp(VOID) {
    return LocalCpuContext.Context.Esp;
}
ULONG GetEip(VOID) {
    return LocalCpuContext.Context.Eip;
}
ULONG GetEfl(VOID) {
    return LocalCpuContext.Context.EFlags;
}

CPUREGFUNCS CpuRegFuncs[] = {
    { "Eax", SetEax, GetEax },
    { "Ebx", SetEbx, GetEbx },
    { "Ecx", SetEcx, GetEcx },
    { "Edx", SetEdx, GetEdx },
    { "Esi", SetEsi, GetEsi },
    { "Edi", SetEdi, GetEdi },
    { "Ebp", SetEbp, GetEbp },
    { "Esp", SetEsp, GetEsp },
    { "Eip", SetEip, GetEip },
    { "Efl", SetEfl, GetEfl },
    { NULL, NULL, NULL}
};

WOW64CPUDBGAPI PCPUREGFUNCS
CpuDbgGetRegisterFuncs(
    void
    )
{
    return CpuRegFuncs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\cpu\amd64\inc\amd64cpu.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    amd64cpu.h

Abstract:

    This module contains the AMD64 platfrom specific cpu information.

Author:

    David N. Cutler (davec) 21-Feb-2001

--*/

#ifndef _AMD64CPU_INCLUDE
#define _AMD64CPU_INCLUDE

#ifdef __cplusplus
extern "C" {
#endif

//
// 32-bit Cpu context.
//

#pragma pack(push, 4)

typedef struct _CpuContext {
    CONTEXT32   Context;
    WOW64SERVICE_BUF Wow64Service[1];
} CPUCONTEXT, *PCPUCONTEXT;

#pragma pack(pop)

NTSTATUS
GetContextRecord (
    IN PCPUCONTEXT cpu,
    IN OUT PCONTEXT32 Context
    );

NTSTATUS
SetContextRecord (
    IN PCPUCONTEXT cpu,
    IN OUT PCONTEXT32 Context
    );

NTSTATUS
CpupGetContextThread (
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    IN OUT PCONTEXT32 Context
    );

NTSTATUS
CpupSetContextThread(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    IN OUT PCONTEXT32 Context
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\cpu\ia64\cpu\common.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    common.c

Abstract:

    Platform independent functions for the WOW64 cpu component.

Author:

    05-June-1998 BarryBo

--*/

#define _WOW64CPUAPI_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "wow64.h"
#include "wow64cpu.h"

ASSERTNAME;

//
// Define the length of the history buffer. A length of zero means no
// history is being kept.
//

#if defined(WOW64_HISTORY)

ULONG HistoryLength;

#endif

NTSTATUS
CpupReadRegistryDword (
    IN HANDLE RegistryHandle,
    IN PWSTR ValueName,
    OUT PDWORD RegistryDword)
/*++

Routine Description:

    Check the registry for the given registry value name and if it
    exists, copy the DWORD associated into the variable supplied by the caller

Arguments:

    RegistryHandle - Contains an open handle to a registry key
    ValueName      - The name of the registry value to look up
    RegistryDword  - If the lookup was successful, this gets the DWORD value
                     that was associated with the registry name. If the
                     lookup was unsuccessful, this value is unchanged.

Return Value:

    NTSTATUS - Result of the NT Quesry Value Key.

--*/

{

    NTSTATUS st;

    UNICODE_STRING KeyName;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    WCHAR Buffer[100];
    ULONG ResultLength;

    RtlInitUnicodeString(&KeyName, ValueName);
    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)Buffer;
    st = NtQueryValueKey(RegistryHandle,
                                 &KeyName,
                                 KeyValuePartialInformation,
                                 KeyValueInformation,
                                 sizeof(Buffer),
                                 &ResultLength);

    if (NT_SUCCESS(st) && (KeyValueInformation->Type == REG_DWORD)) {

        //
        // We found a valid registry value name and it is holding a DWORD
        // so grab the associated value and pass it back to the caller
        //

        *RegistryDword = *(DWORD *)(KeyValueInformation->Data);
    }

    return st;
}

#if defined(WOW64_HISTORY)

VOID
CpupCheckHistoryKey (
    IN PWSTR pImageName,
    OUT PULONG pHistoryLength
    )

/*++

Routine Description:

    Checks if the registry if service history should be enabled. A missing
    key means disable.

Arguments:

    pImageName - the name of the image. DO NOT SAVE THIS POINTER. The contents
                 are freed up by wow64.dll when we return from the call

    pHistoryLength - size of history buffer. If history is not enabled,
                 returns zero

Return Value:

    None

--*/

{

    UNICODE_STRING KeyName;
    OBJECT_ATTRIBUTES ObjA;

    NTSTATUS st;

    DWORD EnableHistory = FALSE;        // assume disabled
    HANDLE hKey = NULL;                 // non-null means we have an open key

    LOGPRINT((TRACELOG, "CpupCheckHistoryKey(%ws) called.\n", pImageName));

    //
    // Initialize the size of the histry buffer assuming no history buffer
    //

    *pHistoryLength = 0;

    //
    // Check in the HKLM area...
    //

    RtlInitUnicodeString(&KeyName, CPUHISTORY_MACHINE_SUBKEY);
    InitializeObjectAttributes(&ObjA, &KeyName, OBJ_CASE_INSENSITIVE, NULL, NULL);
    st = NtOpenKey(&hKey, KEY_READ, &ObjA);

    if (NT_SUCCESS(st)) {

        //
        // Have subkey path, now look for specific values
        // First the program name, then the generic enable/disable key
        // as the program name key takes priority if it exists
        //

        st = CpupReadRegistryDword(hKey, pImageName, &EnableHistory);
        if (STATUS_OBJECT_NAME_NOT_FOUND == st) {

            //
            // No image name was found, so see
            // if the generic enable was in the registry
            //

            st = CpupReadRegistryDword(hKey, CPUHISTORY_ENABLE, &EnableHistory);

            //
            // If there is a problem with the generic enable, then that means
            // history is not enabled. No need to check the status returned.
            //
        }

        //
        // If we have a history buffer request, then find out the size
        // of the buffer
        //

        if (EnableHistory) {
            
            //
            // pHistoryLength is a pointer to a ULONG so make
            // sure we can stuff a DWORD into it via the 
            // CpupReadRegistryDword() function
            //

            WOWASSERT(sizeof(ULONG) == sizeof(DWORD));

            //
            // Now get the size of the history area
            //

            st = CpupReadRegistryDword(hKey, CPUHISTORY_SIZE, pHistoryLength);

            //
            // If there is a problem with the size entry, then that means
            // we should use the minimum size which we check for anyway
            // below. Thus, no need to check the returned status.
            //
            // And a reality check
            //
            // Make sure we have at least a minimum number of entries for the
            // history buffer if it is enabled
            //

            if (*pHistoryLength < CPUHISTORY_MIN_SIZE) {
                *pHistoryLength = CPUHISTORY_MIN_SIZE;
            }
        }
    }

    if (hKey) {
        NtClose(hKey);
    }

    LOGPRINT((TRACELOG, "CpupCheckHistoryKey() Enabled: %d, Length: %d.\n", EnableHistory, *pHistoryLength));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\cpu\amd64\cpu\cpumain.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    cpumain.c

Abstract:

    This module contains the platform specific entry points for the AMD64
    WOW cpu.

Author:

    David N. Cutler (davec) 20-Feb-2001

Environment:

    User mode.

--*/

#define _WOW64CPUAPI_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntosp.h>
#include "wow64.h"
#include "wow64cpu.h"
#include "amd64cpu.h"

ASSERTNAME;

//
// Declarations external functions.
//

VOID
RunSimulatedCode (
    VOID
    );

VOID
ReturnFromSimulatedCode (
    VOID
    );


VOID
CpupCheckHistoryKey (
    IN PWSTR pImageName,
    OUT PULONG pHistoryLength
    );

#if 0

VOID
CpupPrintContext (
    IN PCHAR str,
    IN PCPUCONTEXT cpu
    );

#endif

WOW64CPUAPI
NTSTATUS
CpuProcessInit (
    IN PWSTR pImageName,
    IN PSIZE_T pCpuThreadSize
    )

/*++

Routine Description:

    Per-process initialization code

Arguments:

    pImageName       - IN pointer to the name of the image
    pCpuThreadSize   - OUT ptr to number of bytes of memory the CPU
                       wants allocated for each thread.

Return Value:

    NTSTATUS.

--*/

{

#if 0

    PVOID pv;
    NTSTATUS Status;
    SIZE_T Size;
    ULONG OldProtect;

    //
    // See if we are keeping a history of the service calls
    // for this process. A length of 0 means no history.
    //

#if defined(WOW64_HISTORY)

    CpupCheckHistoryKey(pImageName, &HistoryLength);

    
    //
    // Allow us to make sure the cpu thread data is 16-byte aligned
    //

    *pCpuThreadSize = sizeof(CPUCONTEXT) + 16 + (HistoryLength * sizeof(WOW64SERVICE_BUF));

#else

    *pCpuThreadSize = sizeof(CPUCONTEXT) + 16;

#endif

    LOGPRINT((TRACELOG, "CpuProcessInit() sizeof(CPUCONTEXT) is %d, total size is %d\n", sizeof(CPUCONTEXT), *pCpuThreadSize));


    Status = NtProtectVirtualMemory(NtCurrentProcess(),
                                    &pv,
                                    &Size,
                                    PAGE_EXECUTE_READWRITE,
                                    &OldProtect);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

#endif

    return STATUS_SUCCESS;
}


WOW64CPUAPI
NTSTATUS
CpuProcessTerm(
    HANDLE ProcessHandle
    )

/*++

Routine Description:

    Per-process termination code.  Note that this routine may not be called,
    especially if the process is terminated by another process.

Arguments:

    ProcessHandle - Called only for the current process. 
                    NULL - Indicates the first call to prepare for termination. 
                    NtCurrentProcess() - Indicates the actual that will terminate everything.

Return Value:

    NTSTATUS.

--*/

{
    return STATUS_SUCCESS;
}

WOW64CPUAPI
NTSTATUS
CpuThreadInit (
    PVOID pPerThreadData
    )

/*++

Routine Description:

    Per-thread termination code.

Arguments:

    pPerThreadData  - Pointer to zero-filled per-thread data with the
                      size returned from CpuProcessInit.

Return Value:

    NTSTATUS.

--*/

{

#if 0

    PUCHAR Gdt;
    PCPUCONTEXT cpu;
    PTEB32 Teb32 = NtCurrentTeb32();
    PFXSAVE_FORMAT_WX86 xmmi;

    //
    // The ExtendedRegisters array is used to save/restore the floating
    // pointer registers between ia32 and ia64. Alas, this structure
    // has an offset of 0x0c in the ia32 CONTEXT record. There are
    // two ways to clean this up. (1) Put padding in the CPUCONTEXT of
    // wow64. (2) Just put the CPUCONTEXT structure on a 0x04 aligned boundary
    // The choice made was to go with (1) and add padding to the
    // CPUCONTEXT structure. Don't forget to pack(4) that puppy...
    //
    cpu = (PCPUCONTEXT) ((((UINT_PTR) pPerThreadData) + 15) & ~0xfi64);

    // For the ISA transition routine, floats are saved in the
    // ExtendedRegisters area. Make it easy to access.
    //
    xmmi = (PFXSAVE_FORMAT_WX86) &(cpu->Context.ExtendedRegisters[0]);


    //
    // This entry is used by the ISA transition routine. It is assumed
    // that the first entry in the cpu structure is the ia32 context record
    //
    Wow64TlsSetValue(WOW64_TLS_CPURESERVED, cpu);

    //
    // This tls entry is used by the transition routine. The transition
    // routine only works with the FXSAVE format. This points to that
    // structure in the x86 context.
    //
    Wow64TlsSetValue(WOW64_TLS_EXTENDED_FLOAT, xmmi);

#if defined(WOW64_HISTORY)
    //
    // Init the pointer to the service history area
    //
    if (HistoryLength) {
        Wow64TlsSetValue(WOW64_TLS_LASTWOWCALL, &(cpu->Wow64Service[0]));
    } 
#endif

    //
    // Initialize the 32-to-64 function pointer.
    //

    Teb32->WOW32Reserved = PtrToUlong(IA32ReturnFromSimulatedCode);

    //
    // Initialize the remaining nonzero CPU fields
    // (Based on ntos\ke\i386\thredini.c and ntos\rtl\i386\context.c)
    //
    cpu->Context.SegCs=KGDT_R3_CODE|3;
    cpu->Context.SegDs=KGDT_R3_DATA|3;
    cpu->Context.SegEs=KGDT_R3_DATA|3;
    cpu->Context.SegSs=KGDT_R3_DATA|3;
    cpu->Context.SegFs=KGDT_R3_TEB|3;
    cpu->Context.EFlags=0x202;    // IF and intel-reserved set, all others clear
    cpu->Context.Esp=(ULONG)Teb32->NtTib.StackBase-sizeof(ULONG);

    //
    // The ISA transition routine only uses the extended FXSAVE area
    // These values come from ...\ke\i386\thredini.c to match the i386
    // initial values
    //
    xmmi->ControlWord = 0x27f;     
    xmmi->MXCsr = 0x1f80;
    xmmi->TagWord = 0xffff;

    //
    // The ISA transisiton code assumes that Context structure is
    // 4 bytes after the pointer saved in TLS[1] (TLS_CPURESERVED)
    // This is done to make the alignment of the ExtendedRegisters[] array
    // in the CONTEXT32 structure be aligned on a 16-byte boundary.
    //

    WOWASSERT(((UINT_PTR) &(cpu->Context)) == (((UINT_PTR) cpu) + 4));
    
    //
    // Make sure this value is 16-byte aligned
    //

    WOWASSERT(((FIELD_OFFSET(CPUCONTEXT, Context) + FIELD_OFFSET(CONTEXT32, ExtendedRegisters)) & 0x0f) == 0);

#endif

    return STATUS_SUCCESS;
}

WOW64CPUAPI
NTSTATUS
CpuThreadTerm (
    VOID
    )

/*++

Routine Description:

    This routine is called at thread termination.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS.

--*/

{

    return STATUS_SUCCESS;
}

WOW64CPUAPI
VOID
CpuSimulate (
    VOID
    )

/*++

Routine Description:

    This routine starts the execution of 32-bit code. The 32-bit context
    is assumed to have been previously initialized.

Arguments:

    None.

Return Value:

    None - this function never returns.

--*/

{

#if 0

    PCPUCONTEXT cpu = (PCPUCONTEXT)Wow64TlsGetValue(WOW64_TLS_CPURESERVED);

    //
    // Loop continuously starting 32-bit execution, responding to system
    // calls, and restarting 32-bit execution.
    //

    while (1) {
        if (ia32ShowContext & LOG_CONTEXT_SYS) {
            CpupPrintContext("Before Simulate: ", cpu);
        }

        //
        // Call into 32-bit code.
        //
        // This returns when a system service thunk gets called.
        //
        // The 32-bit context is a passed via TLS_CPURESERVED.
        //
        // The low level code is dependant on &cpu and &(cpu->Context)
        // being equal. It is passed on the side because it needs
        // to be preserved across ia32 transition. The TLS registers
        // are preserved, but little else is.
        //
        
        RunSimulatedCode(&cpu->GdtDescriptor);

        if (ia32ShowContext & LOG_CONTEXT_SYS) {
            CpupPrintContext("After Simulate: ", cpu);
        }

#if defined(WOW64_HISTORY)

        if (HistoryLength) {
            PWOW64SERVICE_BUF SrvPtr = (PWOW64SERVICE_BUF) Wow64TlsGetValue(WOW64_TLS_LASTWOWCALL);

            // We defined that we are always pointing to the last one, so
            // increment in preparation for the next entry
            SrvPtr++;

            if (SrvPtr > &(cpu->Wow64Service[HistoryLength - 1])) {
                SrvPtr = &(cpu->Wow64Service[0]);
            }

            SrvPtr->Api = cpu->Context.Eax;
            try {
                SrvPtr->RetAddr = *(((PULONG)cpu->Context.Esp) + 0);
                SrvPtr->Arg0 = *(((PULONG)cpu->Context.Esp) + 1);
                SrvPtr->Arg1 = *(((PULONG)cpu->Context.Esp) + 2);
                SrvPtr->Arg2 = *(((PULONG)cpu->Context.Esp) + 3);
                SrvPtr->Arg3 = *(((PULONG)cpu->Context.Esp) + 4);
            }
            except ((GetExceptionCode() == STATUS_ACCESS_VIOLATION)?1:0) {
                // Do nothing, leave the values alone
                LOGPRINT((TRACELOG, "CpuSimulate() saw excpetion while copying stack info to trace area\n"));
            }

            Wow64TlsSetValue(WOW64_TLS_LASTWOWCALL, SrvPtr);
        }

#endif      // defined(WOW64_HISTORY)

            

        //
        // Have WOW64 call the thunk
        //

        cpu->Context.Eax = Wow64SystemService(cpu->Context.Eax,
                                              &cpu->Context);
        //
        // Re-simulate.  Any/all of the 32-bit CONTEXT may have changed
        // as a result of the system service call, so assume nothing.
        //
    }

#endif

    return;
}

WOW64CPUAPI
VOID
CpuResetToConsistentState (
    IN PEXCEPTION_POINTERS pExceptionPointers
    )

/*++

Routine Description:

    After an exception occurs, WOW64 calls this routine to give the CPU
    a chance to clean itself up and recover the CONTEXT32 at the time of
    the fault.

    CpuResetToConsistantState() needs to:

    0) Check if the exception was from ia32 or ia64

    If exception was ia64, do nothing and return
    If exception was ia32, needs to:
    1) Needs to copy  CONTEXT eip to the TLS (WOW64_TLS_EXCEPTIONADDR)
    2) reset the CONTEXT struction to be a valid ia64 state for unwinding
        this includes:
    2a) reset CONTEXT ip to a valid ia64 ip (usually
         the destination of the jmpe)
    2b) reset CONTEXT sp to a valid ia64 sp (TLS
         entry WOW64_TLS_STACKPTR64)
    2c) reset CONTEXT gp to a valid ia64 gp 
    2d) reset CONTEXT teb to a valid ia64 teb 
    2e) reset CONTEXT psr.is  (so exception handler runs as ia64 code)


Arguments:

    pExceptionPointers  - 64-bit exception information

Return Value:

    None.

--*/

{

#if 0

    PCPUCONTEXT cpu = (PCPUCONTEXT)Wow64TlsGetValue(WOW64_TLS_CPURESERVED);

    PVOID StackPtr64 = Wow64TlsGetValue(WOW64_TLS_STACKPTR64);

    LOGPRINT((TRACELOG, "CpuResetToConsistantState(%p)\n", pExceptionPointers));

    //
    // First, clear out the WOW64_TLS_STACKPTR64 so subsequent
    // exceptions won't adjust native sp.
    //

    Wow64TlsSetValue(WOW64_TLS_STACKPTR64, 0);

    //
    // Now decide if we were running as ia32 or ia64...
    //

#if 0

    if (pExceptionPointers->ContextRecord->StIPSR & (1i64 << PSR_IS)) {

        //
        // Grovel the IA64 pExceptionPointers->ContextRecord and
        // stuff the ia32 context back into the cpu->Context.
        //

        Wow64CtxFromIa64(CONTEXT32_FULL,
                         pExceptionPointers->ContextRecord,
                         &cpu->Context);
        
        //
        // Now set things up so we can let the ia64 exception handler do the
        // right thing
        //

        //
        // Hang onto the actual exception address (used when we
        // pass control back to the ia32 exception handler)
        //

        Wow64TlsSetValue(WOW64_TLS_EXCEPTIONADDR, (PVOID)pExceptionPointers->ContextRecord->StIIP);

        //
        // Let the ia64 exception handler think the exception happened
        // in the CpuSimulate transition code. We do this by setting
        // the exception ip to the address pointed to by the jmpe (and the
        // corresponding GP), setting the stack to the same as it was at the
        // time of the br.ia and making sure any other ia64 "saved" registers
        // are replaced (such as the TEB)
        //

        pExceptionPointers->ContextRecord->IntSp = (ULONGLONG)StackPtr64;

        pExceptionPointers->ContextRecord->StIIP= (((PPLABEL_DESCRIPTOR)ReturnFromSimulatedCode)->EntryPoint);
        pExceptionPointers->ContextRecord->IntGp = (((PPLABEL_DESCRIPTOR)ReturnFromSimulatedCode)->GlobalPointer);

        pExceptionPointers->ContextRecord->IntTeb = (ULONGLONG) NtCurrentTeb();

        //
        // Don't forget to make the next run be an ia64 run...
        // So clear the psr.is bit (for ia64 code) and the psr.ri bit
        // (so instructions start at the first bundle).
        //

        pExceptionPointers->ContextRecord->StIPSR &= ~(1i64 << PSR_IS);
        pExceptionPointers->ContextRecord->StIPSR &= ~(3i64 << PSR_RI);

        //
        // Now that we've cleaned up the context record, let's
        // clean up the exception record too.
        //
        pExceptionPointers->ExceptionRecord->ExceptionAddress = (PVOID) pExceptionPointers->ContextRecord->StIIP;
        
        //
        // We should never be putting in a null value here
        //

        WOWASSERT(pExceptionPointers->ContextRecord->IntSp);
    }

#endif

#endif

    return;
}

WOW64CPUAPI
ULONG
CpuGetStackPointer (
    VOID
    )

/*++

Routine Description:

    This routine returns the current 32-bit stack pointer value.

Arguments:

    None.

Return Value:

    The current value of the 32-bit stack pointer is returned.

--*/

{

    PCPUCONTEXT cpu = (PCPUCONTEXT)Wow64TlsGetValue(WOW64_TLS_CPURESERVED);

    return cpu->Context.Esp;
}

WOW64CPUAPI
VOID
CpuSetStackPointer (
    IN ULONG Value
    )
/*++

Routine Description:

    This routine sets the 32-bit stack pointer value.

Arguments:

    Value - Supplies the 32-bit stack pointer value.

Return Value:

    None.

--*/

{

    PCPUCONTEXT cpu = (PCPUCONTEXT)Wow64TlsGetValue(WOW64_TLS_CPURESERVED);

    cpu->Context.Esp = Value;
    return;
}

WOW64CPUAPI
VOID
CpuResetFloatingPoint(
    VOID
    )
/*++

Routine Description:

    Modifies the floating point state to reset it to a non-error state

Arguments:

    None.

Return Value:

    None.

--*/

{

    PCPUCONTEXT cpu = (PCPUCONTEXT)Wow64TlsGetValue(WOW64_TLS_CPURESERVED);

    return;
}

WOW64CPUAPI
VOID
CpuSetInstructionPointer (
    IN ULONG Value
    )

/*++

Routine Description:

    This routine sets the 32-bit instruction pointer value.

Arguments:

    Value - Supplies the 32-bit instruction pointer value.

Return Value:

    None.

--*/

{

    PCPUCONTEXT cpu = (PCPUCONTEXT)Wow64TlsGetValue(WOW64_TLS_CPURESERVED);

    cpu->Context.Eip = Value;
    return;
}

WOW64CPUAPI
VOID
CpuNotifyDllLoad (
    IN LPWSTR DllName,
    IN PVOID DllBase,
    IN ULONG DllSize
    )

/*++

Routine Description:

    This routine is called when the application successfully loads a DLL.

Arguments:

    DllName - Supplies a pointer to the name of the DLL.

    DllBase - Supplies the base address of the DLL.

    DllSize - Supplies the size of the DLL.

Return Value:

    None.

--*/

{

#if defined(DBG)

    LPWSTR tmpStr;

    //
    // Log name of DLL, its base address, and size.
    //

    tmpStr = DllName;
    try {
        if ((tmpStr == NULL) || (*tmpStr == L'\0')) {
            tmpStr = L"<Unknown>";
        }

    } except ((GetExceptionCode() == STATUS_ACCESS_VIOLATION) ? 1 : 0) {
        tmpStr = L"<Unknown>";
    }

    LOGPRINT((TRACELOG, "CpuNotifyDllLoad(\"%ws\", 0x%p, %d) called\n", tmpStr, DllBase, DllSize));

#endif

    return;
}

WOW64CPUAPI
VOID
CpuNotifyDllUnload (
    IN PVOID DllBase
    )

/*++

Routine Description:

    This routine get called when the application unloads a DLL.

Arguments:

    DllBase - Supplies the base address of the DLL.

Return Value:

    None.

--*/

{

    LOGPRINT((TRACELOG, "CpuNotifyDllUnLoad(%p) called\n", DllBase));
    return;
}
  
WOW64CPUAPI
VOID
CpuFlushInstructionCache (
    IN PVOID BaseAddress,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine flushes the specified range of addreses from the instruction
    cache.

Arguments:

    BaseAddress - Supplies the starting address of the range to flush.

    Length - Supplies number of bytes to flush.

Return Value:

    None.

--*/

{
    
    NtFlushInstructionCache(NtCurrentProcess(), BaseAddress, Length);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\cpu\ia64\bintrans\cpumain.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    cpumain.c

Abstract:

    Main entrypoints for IA64 ia64bt.dll. This code is really a dummy
    and a user can put in a real dll at a later date. As long as the
    entry points exist, we are fine. It is delay loaded by
    wow64cpu depending on whether the binary translation code is
    enabled.

Author:

    22-August-2000 v-cspira (Charles Spirakis)

Revision History:

--*/

#define _WOW64BTAPI_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntosp.h>
#include <kxia64.h>
#include "wow64.h"
#include "wow64cpu.h"
#include "ia64cpu.h"
#include "bintrans.h"

ASSERTNAME;


WOW64BTAPI
NTSTATUS
BTCpuProcessInit(
    PWSTR   pImageName,
    PSIZE_T pCpuThreadSize
    )
/*++

Routine Description:

    Per-process initialization code

Arguments:

    pImageName       - IN the name of the image. The memory for this
                       is freed after the call, so if the callee wants
                       to keep the name around, they need to allocate space
                       and copy it. DON'T SAVE THE POINTER!

    pCpuThreadSize   - OUT ptr to number of bytes of memory the CPU
                       wants allocated for each thread.

Return Value:

    NTSTATUS.

--*/
{
    return STATUS_NOT_IMPLEMENTED;
}


WOW64BTAPI
NTSTATUS
BTCpuProcessTerm(
    HANDLE ProcessHandle
    )
/*++

Routine Description:

    Per-process termination code.  Note that this routine may not be called,
    especially if the process is terminated by another process.

Arguments:

    None.

Return Value:

    NTSTATUS.

--*/
{
    return STATUS_NOT_IMPLEMENTED;
}


WOW64BTAPI
NTSTATUS
BTCpuThreadInit(
    PVOID pPerThreadData
    )
/*++

Routine Description:

    Per-thread termination code.

Arguments:

    pPerThreadData  - Pointer to zero-filled per-thread data with the
                      size returned from CpuProcessInit.

Return Value:

    NTSTATUS.

--*/
{
    return STATUS_NOT_IMPLEMENTED;
}


WOW64BTAPI
NTSTATUS
BTCpuThreadTerm(
    VOID
    )
/*++

Routine Description:

    Per-thread termination code.  Note that this routine may not be called,
    especially if the thread is terminated abnormally.

Arguments:

    None.

Return Value:

    NTSTATUS.

--*/
{
    return STATUS_NOT_IMPLEMENTED;
}


WOW64BTAPI
VOID
BTCpuSimulate(
    VOID
    )
/*++

Routine Description:

    Call 32-bit code.  The CONTEXT32 has already been set up to go.

Arguments:

    None.

Return Value:

    None.  Never returns.

--*/
{
}

WOW64BTAPI
VOID
BTCpuResetFloatingPoint(
    VOID
    )
/*++

Routine Description:

    Modifies the floating point state to reset it to a non-error state

Arguments:

    None.

Return Value:

    None.

--*/
{
}

WOW64BTAPI
VOID
BTCpuResetToConsistentState(
    PEXCEPTION_POINTERS pExceptionPointers
    )
/*++

Routine Description:

    After an exception occurs, WOW64 calls this routine to give the CPU
    a chance to clean itself up and recover the CONTEXT32 at the time of
    the fault.

    CpuResetToConsistantState() needs to:

    0) Check if the exception was from ia32 or ia64

    If exception was ia64, do nothing and return
    If exception was ia32, needs to:
    1) Needs to copy  CONTEXT eip to the TLS (WOW64_TLS_EXCEPTIONADDR)
    2) reset the CONTEXT struction to be a valid ia64 state for unwinding
        this includes:
    2a) reset CONTEXT ip to a valid ia64 ip (usually
         the destination of the jmpe)
    2b) reset CONTEXT sp to a valid ia64 sp (TLS
         entry WOW64_TLS_STACKPTR64)
    2c) reset CONTEXT gp to a valid ia64 gp 
    2d) reset CONTEXT teb to a valid ia64 teb 
    2e) reset CONTEXT psr.is  (so exception handler runs as ia64 code)


Arguments:

    pExceptionPointers  - 64-bit exception information

Return Value:

    None.

--*/
{
}


WOW64BTAPI
ULONG
BTCpuGetStackPointer(
    VOID
    )
/*++

Routine Description:

    Returns the current 32-bit stack pointer value.

Arguments:

    None.

Return Value:

    Value of 32-bit stack pointer.

--*/
{
    return 0;
}


WOW64BTAPI
VOID
BTCpuSetStackPointer(
    ULONG Value
    )
/*++

Routine Description:

    Modifies the current 32-bit stack pointer value.

Arguments:

    Value   - new value to use for 32-bit stack pointer.

Return Value:

    None.

--*/
{
}


WOW64BTAPI
VOID
BTCpuSetInstructionPointer(
    ULONG Value
    )
/*++

Routine Description:

    Modifies the current 32-bit instruction pointer value.

Arguments:

    Value   - new value to use for 32-bit instruction pointer.

Return Value:

    None.

--*/
{
}


WOW64BTAPI
VOID
BTCpuNotifyDllLoad(
    LPWSTR DllName,
    PVOID DllBase,
    ULONG DllSize
    )
/*++

Routine Description:

    This routine get notified when application successfully load a dll.

Arguments:

    DllName - Name of the Dll the application has loaded.
    DllBase - BaseAddress of the dll.
    DllSize - size of the Dll.

Return Value:

    None.

--*/
{
}

WOW64BTAPI
VOID
BTCpuNotifyDllUnload(
    PVOID DllBase
    )
/*++

Routine Description:

    This routine get notified when application unload a dll.

Arguments:

    DllBase - BaseAddress of the dll.

Return Value:

    None.

--*/
{
}
  
WOW64BTAPI
VOID
BTCpuFlushInstructionCache (
    PVOID BaseAddress,
    ULONG Length
    )
/*++

Routine Description:

    The CPU needs to flush its cache around the specified address, since
    some external code has altered the specified range of addresses.

Arguments:

    BaseAddress - start of range to flush
    Length      - number of bytes to flush

Return Value:

    None.

--*/
{
}

WOW64BTAPI
NTSTATUS
BTCpuGetContext(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    OUT PCONTEXT32 Context)
/*++

Routine Description:

    Extracts the cpu context of the specified thread.
    When entered, it is guaranteed that the target thread is suspended at
    a proper CPU state.

Arguments:

    ThreadHandle   - Target thread handle to retreive the context for
    ProcessHandle  - Open handle to the process that the thread runs in
    Teb            - Pointer to the target's thread TEB
    Context        - Context record to fill

Return Value:

    NTSTATUS.

--*/
{
    return STATUS_NOT_IMPLEMENTED;
}

WOW64BTAPI
NTSTATUS
BTCpuSetContext(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    PCONTEXT32 Context)
/*++

Routine Description:

    Sets the cpu context for the specified thread.
    When entered, if the target thread isn't the currently executing thread, the
n it is
    guaranteed that the target thread is suspended at a proper CPU state.

Arguments:

    ThreadHandle   - Target thread handle to retreive the context for
    ProcessHandle  - Open handle to the process that the thread runs in
    Teb            - Pointer to the target's thread TEB
    Context        - Context record to set

Return Value:

    NTSTATUS.

--*/
{
    return STATUS_NOT_IMPLEMENTED;
}

WOW64BTAPI
NTSTATUS
BTCpuSuspendThread(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    OUT PULONG PreviousSuspendCount OPTIONAL)
/*++

Routine Description:

    This routine is entered while the target thread is actually suspended, howev
er, it's
    not known if the target thread is in a consistent state relative to
    the CPU.

Arguments:

    ThreadHandle          - Handle of target thread to suspend
    ProcessHandle         - Handle of target thread's process
    Teb                   - Address of the target thread's TEB
    PreviousSuspendCount  - Previous suspend count

Return Value:

    NTSTATUS.

--*/
{
    return STATUS_NOT_IMPLEMENTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\cpu\ia64\context\ia6432.h ===
#ifndef __IA64_WOW64EXTS32__
#define __IA64_WOW64EXTS32__

#define _CROSS_PLATFORM_
#define WOW64EXTS_386

#if !defined(_X86_)
    #error This file can only be included for x86 build
#else

/* include headers as if the platform were ia64, 
   because we need 64-bit stuff for context conversion */

#undef _X86_
#define _IA64_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#undef _IA64_
#define _X86_
#include <kxia64.h>

/* 32-bit stuff for context conversion are defined here */
#include <wow64.h>
#include <wow64cpu.h>
#include <vdmdbg.h>
#include <ia64cpu.h>



/* these are defined in nti386.h, since we only included ntia64.h (in nt.h), 
   we have to define these. */
#define SIZE_OF_FX_REGISTERS        128

typedef struct _FXSAVE_FORMAT {
    USHORT  ControlWord;
    USHORT  StatusWord;
    USHORT  TagWord;
    USHORT  ErrorOpcode;
    ULONG   ErrorOffset;
    ULONG   ErrorSelector;
    ULONG   DataOffset;
    ULONG   DataSelector;
    ULONG   MXCsr;
    ULONG   Reserved2;
    UCHAR   RegisterArea[SIZE_OF_FX_REGISTERS];
    UCHAR   Reserved3[SIZE_OF_FX_REGISTERS];
    UCHAR   Reserved4[224];
    UCHAR   Align16Byte[8];
} FXSAVE_FORMAT, *PFXSAVE_FORMAT_WX86;

#endif

#endif __IA64_WOW64EXTS32__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\cpu\ia64\bintrans\bintrans.h ===
/*++
                                                                                
Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    bintrans.h

Abstract:
    
    Header for calling bintrans.dll if it exists
    
Author:

    22-Aug-2000 v-cspira (charles spirakis)

--*/

#ifndef _BINTRANS_INCLUDE
#define _BINTRANS_INCLUDE

#ifdef __cplusplus
extern "C" {
#endif

#if !defined(_WOW64BTAPI_)
#define WOW64BTAPI  DECLSPEC_IMPORT
#else
#define WOW64BTAPI
#endif

//
// Cache manipulation functions and Dll notification
//
WOW64BTAPI VOID BTCpuFlushInstructionCache ( PVOID BaseAddress, ULONG Length );
WOW64BTAPI VOID BTCpuNotifyDllLoad ( LPWSTR DllName, PVOID DllBase, ULONG DllSize );
WOW64BTAPI VOID BTCpuNotifyDllUnload ( PVOID DllBase  );


//
// Init and term APIs
//
WOW64BTAPI NTSTATUS BTCpuProcessInit(PWSTR pImageName, PSIZE_T pCpuThreadDataSize);
WOW64BTAPI NTSTATUS BTCpuProcessTerm(HANDLE ProcessHandle);
WOW64BTAPI NTSTATUS BTCpuThreadInit(PVOID pPerThreadData);
WOW64BTAPI NTSTATUS BTCpuThreadTerm(VOID);


 

//
// Execution
//
WOW64BTAPI VOID BTCpuSimulate(VOID);

//
// Exception handling, context manipulation
//
WOW64BTAPI VOID  BTCpuResetToConsistentState(PEXCEPTION_POINTERS pExecptionPointers);
WOW64BTAPI VOID  BTCpuResetFloatingPoint(VOID);
WOW64BTAPI ULONG BTCpuGetStackPointer(VOID);
WOW64BTAPI VOID  BTCpuSetStackPointer(ULONG Value);
WOW64BTAPI VOID  BTCpuSetInstructionPointer(ULONG Value);

WOW64BTAPI
NTSTATUS
BTCpuSuspendThread(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    OUT PULONG PreviousSuspendCount OPTIONAL);

WOW64BTAPI
NTSTATUS
BTCpuGetContext(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    OUT PCONTEXT32 Context);

WOW64BTAPI
NTSTATUS
BTCpuSetContext(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    PCONTEXT32 Context);

#ifdef __cplusplus
}
#endif

#endif  //_BINTRANS_INCLUDE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\cpu\ia64\context\context.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    context.c

Abstract:

    Context conversion routines for ia64 hardware to ia32 context records

Author:

    03-Feb-2000 Charles Spriakis - Intel (v-cspira)

Revision History:

--*/


#define _WOW64CPUAPI_

#ifdef _X86_
#include "ia6432.h"
#else

#define _NTDDK_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "wow64.h"
#include "wow64cpu.h"
#include "ia64cpu.h"

#include <kxia64.h>

#endif

//
// This is to prevent this library from linking to wow64 to use wow64!Wow64LogPrint
//
#if defined(LOGPRINT)
#undef LOGPRINT
#endif
#define LOGPRINT(_x_)   CpupDebugPrint _x_

VOID
CpupDebugPrint(
    IN ULONG_PTR Flags,
    IN PCHAR Format,
    ...);

BOOL
MapDbgSlotIa64ToX86(
    UINT    Slot,
    ULONG64 Ipsr,
    ULONG64 DbD,
    ULONG64 DbD1,
    ULONG64 DbI,
    ULONG64 DbI1,
    ULONG*  Dr7,
    ULONG*  Dr);

void
MapDbgSlotX86ToIa64(
    UINT     Slot,
    ULONG    Dr7,
    ULONG    Dr,
    ULONG64* Ipsr,
    ULONG64* DbD,
    ULONG64* DbD1,
    ULONG64* DbI,
    ULONG64* DbI1);


ASSERTNAME;


VOID
Wow64CtxFromIa64(
    IN ULONG Ia32ContextFlags,
    IN PCONTEXT ContextIa64,
    IN OUT PCONTEXT32 ContextX86
    )
/*++

Routine Description:

    This function copies the context from an ia64 context record into
    the context of an ia32 record (based on the hardware iVE register
    mappings). This function is ment to be easily usabale by various
    get/set context routines (such as those exported by wow64cpu.dll).

Arguments:

    Ia32ContextFlags - Specifies which ia32 context to copy

    ContextIa64 - Supplies an the ia64 context buffer that is the source
                  for the copy into the ia32 context area

    ContextX86 - This is an X86 context which will receive the context
                 information from the ia64 context record passed in above

Return Value:

    None.  

--*/
{
    FLOAT128 tmpFloat[NUMBER_OF_387REGS];

    if (Ia32ContextFlags & CONTEXT_IA64) {
        LOGPRINT((ERRORLOG, "Wow64CtxFromIa64: Request with ia64 context flags (0x%x) FAILED\n", Ia32ContextFlags));
        ASSERT((Ia32ContextFlags & CONTEXT_IA64) == 0);
    }

    if ((Ia32ContextFlags & CONTEXT32_CONTROL) == CONTEXT32_CONTROL) {
        //
        // And the control stuff
        //
        ContextX86->Ebp    = (ULONG)ContextIa64->IntTeb;
        ContextX86->SegCs  = KGDT_R3_CODE|3;
        ContextX86->Eip    = (ULONG)ContextIa64->StIIP;
        ContextX86->SegSs  = KGDT_R3_DATA|3;
        ContextX86->Esp    = (ULONG)ContextIa64->IntSp;
        ContextX86->EFlags = (ULONG)ContextIa64->Eflag;
    }

    if ((Ia32ContextFlags & CONTEXT32_INTEGER)  == CONTEXT32_INTEGER) {
        //
        // Now for the integer state...
        //
        ContextX86->Edi = (ULONG)ContextIa64->IntT6;
        ContextX86->Esi = (ULONG)ContextIa64->IntT5;
        ContextX86->Ebx = (ULONG)ContextIa64->IntT4;
        ContextX86->Edx = (ULONG)ContextIa64->IntT3;
        ContextX86->Ecx = (ULONG)ContextIa64->IntT2;
        ContextX86->Eax = (ULONG)ContextIa64->IntV0;
    }

    if ((Ia32ContextFlags & CONTEXT32_SEGMENTS) == CONTEXT32_SEGMENTS) {
        //
        // These are constants (and constants are used on ia32->ia64
        // transition, not saved values) so make our life easy...
        //
        ContextX86->SegGs = KGDT_R3_DATA|3;
        ContextX86->SegEs = KGDT_R3_DATA|3;
        ContextX86->SegDs = KGDT_R3_DATA|3;
        ContextX86->SegSs = KGDT_R3_DATA|3;
        ContextX86->SegFs = KGDT_R3_TEB|3;
        ContextX86->SegCs = KGDT_R3_CODE|3;
    }

    if ((Ia32ContextFlags & CONTEXT32_EXTENDED_REGISTERS) == CONTEXT32_EXTENDED_REGISTERS) {

        PFXSAVE_FORMAT_WX86 xmmi = (PFXSAVE_FORMAT_WX86) ContextX86->ExtendedRegisters;

        LOGPRINT((TRACELOG, "Wow64CtxFromIa64: Request to convert extended fp registers\n"));

        xmmi->ControlWord   = (USHORT)(ContextIa64->StFCR & 0xffff);
        xmmi->StatusWord    = (USHORT)(ContextIa64->StFSR & 0xffff);
        xmmi->TagWord       = (USHORT)(ContextIa64->StFSR >> 16) & 0xffff;
        xmmi->ErrorOpcode   = (USHORT)(ContextIa64->StFIR >> 48);
        xmmi->ErrorOffset   = (ULONG) (ContextIa64->StFIR & 0xffffffff);
        xmmi->ErrorSelector = (ULONG) (ContextIa64->StFIR >> 32);
        xmmi->DataOffset    = (ULONG) (ContextIa64->StFDR & 0xffffffff);
        xmmi->DataSelector  = (ULONG) (ContextIa64->StFDR >> 32);
        xmmi->MXCsr         = (ULONG) (ContextIa64->StFCR >> 32) & 0xffff;

        //
        // Copy over the FP registers.  Even though this is the new
        // FXSAVE format with 16-bytes for each register, need to
        // convert from spill/fill format to 80-bit double extended format
        //
        Wow64CopyIa64FromSpill((PFLOAT128) &(ContextIa64->FltT2),
                               (PFLOAT128) xmmi->RegisterArea,
                               NUMBER_OF_387REGS);

        //
        // Rotate the registers appropriately
        //
        Wow64RotateFpTop(ContextIa64->StFSR, (PFLOAT128) xmmi->RegisterArea);

        //
        // Finally copy the xmmi registers
        //
        Wow64CopyXMMIFromIa64Byte16(&(ContextIa64->FltS4),
                                    xmmi->Reserved3,
                                    NUMBER_OF_XMMI_REGS);
    }

    if ((Ia32ContextFlags & CONTEXT32_FLOATING_POINT) == CONTEXT32_FLOATING_POINT) {

        LOGPRINT((TRACELOG, "Wow64CtxFromIa64: Request to convert fp registers\n"));

        //
        // Copy over the floating point status/control stuff
        //
        ContextX86->FloatSave.ControlWord   = (ULONG)(ContextIa64->StFCR & 0xffff);
        ContextX86->FloatSave.StatusWord    = (ULONG)(ContextIa64->StFSR & 0xffff);
        ContextX86->FloatSave.TagWord       = (ULONG)(ContextIa64->StFSR >> 16) & 0xffff;
        ContextX86->FloatSave.ErrorOffset   = (ULONG)(ContextIa64->StFIR & 0xffffffff);
        ContextX86->FloatSave.ErrorSelector = (ULONG)(ContextIa64->StFIR >> 32);
        ContextX86->FloatSave.DataOffset    = (ULONG)(ContextIa64->StFDR & 0xffffffff);
        ContextX86->FloatSave.DataSelector  = (ULONG)(ContextIa64->StFDR >> 32);

        //
        // Copy over the FP registers into temporary space
        // Even though this is the new
        // FXSAVE format with 16-bytes for each register, need to
        // convert from spill/fill format to 80-bit double extended format
        //
        Wow64CopyIa64FromSpill((PFLOAT128) &(ContextIa64->FltT2),
                               (PFLOAT128) tmpFloat,
                               NUMBER_OF_387REGS);
        //
        // Rotate the registers appropriately
        //
        Wow64RotateFpTop(ContextIa64->StFSR, tmpFloat);

        //
        // And put them in the older FNSAVE format (packed 10 byte values)
        //
        Wow64CopyFpFromIa64Byte16(tmpFloat,
                                  ContextX86->FloatSave.RegisterArea,
                                  NUMBER_OF_387REGS);
    }

    if ((Ia32ContextFlags & CONTEXT32_DEBUG_REGISTERS) == CONTEXT32_DEBUG_REGISTERS) {
        // Ia64 -> X86
        BOOL Valid = TRUE;

        LOGPRINT((TRACELOG, "Wow64CtxFromIa64: Request to convert debug registers\n"));

#if 0 // XXX olegk - enable after clarifying problems with exceptions

        Valid &= MapDbgSlotIa64ToX86(0, ContextIa64->StIPSR, ContextIa64->DbD0, ContextIa64->DbD1, ContextIa64->DbI0, ContextIa64->DbI1, &ContextX86->Dr7, &ContextX86->Dr0);
        Valid &= MapDbgSlotIa64ToX86(1, ContextIa64->StIPSR, ContextIa64->DbD2, ContextIa64->DbD3, ContextIa64->DbI2, ContextIa64->DbI3, &ContextX86->Dr7, &ContextX86->Dr1);
        Valid &= MapDbgSlotIa64ToX86(2, ContextIa64->StIPSR, ContextIa64->DbD4, ContextIa64->DbD5, ContextIa64->DbI4, ContextIa64->DbI5, &ContextX86->Dr7, &ContextX86->Dr2);
        Valid &= MapDbgSlotIa64ToX86(3, ContextIa64->StIPSR, ContextIa64->DbD6, ContextIa64->DbD7, ContextIa64->DbI6, ContextIa64->DbI7, &ContextX86->Dr7, &ContextX86->Dr3);

        if (!Valid) {
            LOGPRINT((ERRORLOG, "Wasn't able to map IA64 debug registers consistently!\n"));
        }
#endif // XXX olegk
    }

    ContextX86->ContextFlags = Ia32ContextFlags;
}

VOID
Wow64CtxToIa64(
    IN ULONG Ia32ContextFlags,
    IN PCONTEXT32 ContextX86,
    IN OUT PCONTEXT ContextIa64
    )
/*++

Routine Description:

    This function copies the context from an ia32 context record into
    the context of an ia64 record (based on the hardware iVE register
    mappings). This function is ment to be easily usabale by various
    get/set context routines (such as those exported by wow64cpu.dll).

Arguments:

    Ia32ContextFlags - Specifies which ia32 context to copy

    ContextX86 - Supplies an the X86 context buffer that is the source
                  for the copy into the ia64 context area

    ContextIa64 - This is an ia64 context which will receive the context
                 information from the x86 context record passed in above

Return Value:

    None.

--*/
{
    FLOAT128 tmpFloat[NUMBER_OF_387REGS];

    if (Ia32ContextFlags & CONTEXT_IA64) {
        LOGPRINT((ERRORLOG, "Wow64CtxToIa64: Request with ia64 context flags (0x%x) FAILED\n", Ia32ContextFlags));
        ASSERT((Ia32ContextFlags & CONTEXT_IA64) == 0);
    }

    if ((Ia32ContextFlags & CONTEXT32_CONTROL) == CONTEXT32_CONTROL) {
        //
        // And the control stuff
        //
        ContextIa64->IntTeb = ContextX86->Ebp;
        ContextIa64->StIIP = ContextX86->Eip;
        ContextIa64->IntSp = ContextX86->Esp;
        ContextIa64->Eflag = ContextX86->EFlags;

        //
        // The segments (cs and ds) are a constant, so reset them.
        // gr17 has LDT and TSS, so might as well reset
        // all of them while we're at it...
        // These values are forced in during a transition (see simulate.s)
        // so there is no point to trying to get cute and actually
        // pass in the values from the X86 context record
        //
        ContextIa64->IntT8 = ((KGDT_LDT|3) << 32) 
                           | ((KGDT_R3_DATA|3) << 16)
                           | (KGDT_R3_CODE|3);

    }

    if ((Ia32ContextFlags & CONTEXT32_INTEGER) == CONTEXT32_INTEGER) {
        //
        // Now for the integer state...
        //
        ContextIa64->IntT6 = ContextX86->Edi;
        ContextIa64->IntT5 = ContextX86->Esi;
        ContextIa64->IntT4 = ContextX86->Ebx;
        ContextIa64->IntT3 = ContextX86->Edx;
        ContextIa64->IntT2 = ContextX86->Ecx;
        ContextIa64->IntV0 = ContextX86->Eax;
    }

    if ((Ia32ContextFlags & CONTEXT32_SEGMENTS) == CONTEXT32_SEGMENTS) {
        //
        // These are constants (and constants are used on ia32->ia64
        // transition, not saved values) so make our life easy...
        // These values are forced in during a transition (see simulate.s)
        // so there is no point to trying to get cute and actually
        // pass in the values from the X86 context record
        //
        ContextIa64->IntT7 =  ((KGDT_R3_DATA|3) << 48)
                           | ((KGDT_R3_TEB|3) << 32)
                           | ((KGDT_R3_DATA|3) << 16)
                           | (KGDT_R3_DATA|3);
    }

    if ((Ia32ContextFlags & CONTEXT32_EXTENDED_REGISTERS) == CONTEXT32_EXTENDED_REGISTERS) {
        PFXSAVE_FORMAT_WX86 xmmi = (PFXSAVE_FORMAT_WX86) ContextX86->ExtendedRegisters;

        LOGPRINT((TRACELOG, "Wow64CtxToIa64: Request to convert extended fp registers\n"));

        //
        // And copy over the floating point status/control stuff
        //
        ContextIa64->StFCR = (ContextIa64->StFCR & 0xffffffffffffe040i64) |
                             (xmmi->ControlWord & 0xffff) |
                             ((xmmi->MXCsr & 0xffff) << 32);

        ContextIa64->StFSR = (ContextIa64->StFSR & 0xffffffff00000000i64) | 
                             (xmmi->StatusWord & 0xffff) | 
                             ((xmmi->TagWord & 0xffff) << 16);

        ContextIa64->StFIR = (xmmi->ErrorOffset & 0xffffffff) | 
                             (xmmi->ErrorSelector << 32);

        ContextIa64->StFDR = (xmmi->DataOffset & 0xffffffff) | 
                             (xmmi->DataSelector << 32);

        //
        // Don't touch the original ia32 context. Make a copy.
        //
        memcpy(tmpFloat, xmmi->RegisterArea, 
               NUMBER_OF_387REGS * sizeof(FLOAT128));

        // 
        // Rotate registers back since st0 is not necessarily f8
        //
        {
            ULONGLONG RotateFSR = (NUMBER_OF_387REGS - 
                                   ((ContextIa64->StFSR >> 11) & 0x7)) << 11;
            Wow64RotateFpTop(RotateFSR, tmpFloat);
        }

        //
        // Copy over the FP registers.  Even though this is the new
        // FXSAVE format with 16-bytes for each register, need to
        // convert to spill/fill format from 80-bit double extended format
        //
        Wow64CopyIa64ToFill((PFLOAT128) tmpFloat,
                            (PFLOAT128) &(ContextIa64->FltT2),
                            NUMBER_OF_387REGS);

        //
        // Copy over the xmmi registers and convert them into a format
        // that spill/fill can use
        //
        Wow64CopyXMMIToIa64Byte16(xmmi->Reserved3, 
                                  &(ContextIa64->FltS4), 
                                  NUMBER_OF_XMMI_REGS);
    }

    if ((Ia32ContextFlags & CONTEXT32_FLOATING_POINT) == CONTEXT32_FLOATING_POINT) {
        LOGPRINT((TRACELOG, "Wow64CtxToIa64: Request to convert fp registers\n"));

        //
        // Copy over the floating point status/control stuff
        // Leave the MXCSR stuff alone
        //
        ContextIa64->StFCR = (ContextIa64->StFCR & 0xffffffffffffe040i64) | 
                             (ContextX86->FloatSave.ControlWord & 0xffff);

        ContextIa64->StFSR = (ContextIa64->StFSR & 0xffffffff00000000i64) | 
                             (ContextX86->FloatSave.StatusWord & 0xffff) | 
                             ((ContextX86->FloatSave.TagWord & 0xffff) << 16);

        ContextIa64->StFIR = (ContextX86->FloatSave.ErrorOffset & 0xffffffff) | 
                             (ContextX86->FloatSave.ErrorSelector << 32);

        ContextIa64->StFDR = (ContextX86->FloatSave.DataOffset & 0xffffffff) | 
                             (ContextX86->FloatSave.DataSelector << 32);


        //
        // Copy over the FP registers from packed 10-byte format
        // to 16-byte format
        //
        Wow64CopyFpToIa64Byte16(ContextX86->FloatSave.RegisterArea,
                                tmpFloat,
                                NUMBER_OF_387REGS);

        // 
        // Rotate registers back since st0 is not necessarily f8
        //
        {
            ULONGLONG RotateFSR = (NUMBER_OF_387REGS - 
                                   ((ContextIa64->StFSR >> 11) & 0x7)) << 11;
            Wow64RotateFpTop(RotateFSR, tmpFloat);
        }

        //
        // Now convert from 80 bit extended format to fill/spill format
        //
        Wow64CopyIa64ToFill((PFLOAT128) tmpFloat,
                            (PFLOAT128) &(ContextIa64->FltT2),
                            NUMBER_OF_387REGS);
    }

    if ((Ia32ContextFlags & CONTEXT32_DEBUG_REGISTERS) == CONTEXT32_DEBUG_REGISTERS) {
        LOGPRINT((TRACELOG, "Wow64CtxToIa64: Request to convert debug registers\n"));

#if 0 // XXX olegk - enable after clarifying exception problems
        //ContextIa64->ContextFlags |= CONTEXT_DEBUG;

        // X86 -> Ia64
        MapDbgSlotX86ToIa64(0, ContextX86->Dr7, ContextX86->Dr0, &ContextIa64->StIPSR, &ContextIa64->DbD0, &ContextIa64->DbD1, &ContextIa64->DbI0, &ContextIa64->DbI1);
        MapDbgSlotX86ToIa64(1, ContextX86->Dr7, ContextX86->Dr1, &ContextIa64->StIPSR, &ContextIa64->DbD2, &ContextIa64->DbD3, &ContextIa64->DbI2, &ContextIa64->DbI3);
        MapDbgSlotX86ToIa64(2, ContextX86->Dr7, ContextX86->Dr2, &ContextIa64->StIPSR, &ContextIa64->DbD4, &ContextIa64->DbD5, &ContextIa64->DbI4, &ContextIa64->DbI5);
        MapDbgSlotX86ToIa64(3, ContextX86->Dr7, ContextX86->Dr3, &ContextIa64->StIPSR, &ContextIa64->DbD6, &ContextIa64->DbD7, &ContextIa64->DbI6, &ContextIa64->DbI7);
#endif // XXX olegk
    }
}

//
// The ia64 world uses ldfe, stfe to read/write the fp registers. These
// instructions ld/st 16 bytes at a time. Thus, the fp registers are
// packed in 16byte chunks. Alas, the ia32 world uses 10bytes per fp register
// and packs those together (as part of fnstore). So... Need to convert between
// the ia64 packed values and the ia32 packed values. Hence these
// two routines and their weird sounding names.
//

//
// This allows the compiler to be more efficient in copying 10 bytes
// without over copying...
//
#pragma pack(push, 2)
typedef struct _ia32fpbytes {
    ULONG significand_low;
    ULONG significand_high;
    USHORT exponent;
} IA32FPBYTES, *PIA32FPBYTES;
#pragma pack(pop)

VOID
Wow64CopyFpFromIa64Byte16(
    IN PVOID Byte16Fp,
    IN OUT PVOID Byte10Fp,
    IN ULONG NumRegs)
{
    ULONG i;
    PIA32FPBYTES from, to;

    from = (PIA32FPBYTES) Byte16Fp;
    to = (PIA32FPBYTES) Byte10Fp;

    for (i = 0; i < NumRegs; i++) {
        *to = *from;
        from = (PIA32FPBYTES) (((UINT_PTR) from) + 16);
        to = (PIA32FPBYTES) (((UINT_PTR) to) + 10);
    }
}

VOID
Wow64CopyFpToIa64Byte16(
    IN PVOID Byte10Fp,
    IN OUT PVOID Byte16Fp,
    IN ULONG NumRegs)
{
    ULONG i;
    PIA32FPBYTES from, to;  // UNALIGNED

    from = (PIA32FPBYTES) Byte10Fp;
    to = (PIA32FPBYTES) Byte16Fp;

    for (i = 0; i < NumRegs; i++) {
        *to = *from;
        from = (PIA32FPBYTES) (((UINT_PTR) from) + 10);
        to = (PIA32FPBYTES) (((UINT_PTR) to) + 16);
    }
}

//
// Alas, nothing is easy. The ia32 xmmi instructions use 16 bytes and pack
// them as nice 16 byte structs. Unfortunately, ia64 handles it as 2 8-byte
// values (using just the mantissa part). So, another conversion is required
//
VOID
Wow64CopyXMMIToIa64Byte16(
    IN PVOID ByteXMMI,
    IN OUT PVOID Byte16Fp,
    IN ULONG NumRegs)
{
    ULONG i;
    UNALIGNED ULONGLONG *from;
    ULONGLONG *to;

    from = (PULONGLONG) ByteXMMI;
    to = (PULONGLONG) Byte16Fp;

    //
    // although we have NumRegs xmmi registers, each register is 16 bytes
    // wide. This code does things in 8-byte chunks, so total
    // number of times to do things is 2 * NumRegs...
    //
    NumRegs *= 2;

    for (i = 0; i < NumRegs; i++) {
        *to++ = *from++;        // Copy over the mantissa part
        *to++ = 0x1003e;        // Force the exponent part
                                // (see ia64 eas, ia32 FP section - 6.2.7
                                // for where this magic number comes from)
    }
}

VOID
Wow64CopyXMMIFromIa64Byte16(
    IN PVOID Byte16Fp,
    IN OUT PVOID ByteXMMI,
    IN ULONG NumRegs)
{
    ULONG i;
    ULONGLONG *from;
    UNALIGNED ULONGLONG *to;

    from = (PULONGLONG) Byte16Fp;
    to = (PULONGLONG) ByteXMMI;

    //
    // although we have NumRegs xmmi registers, each register is 16 bytes
    // wide. This code does things in 8-byte chunks, so total
    // number of times to do things is 2 * NumRegs...
    //
    NumRegs *= 2;

    for (i = 0; i < NumRegs; i++) {
        *to++ = *from++;        // Copy over the mantissa part
        from++;                 // Skip over the exponent part
    }
}

VOID
Wow64RotateFpTop(
    IN ULONGLONG Ia64_FSR,
    IN OUT FLOAT128 UNALIGNED *ia32FxSave)
/*++

Routine Description:

    On transition from ia64 mode to ia32 (and back), the f8-f15 registers
    contain the st[0] to st[7] fp stack values. Alas, these values don't
    map one-one, so the FSR.top bits are used to determine which ia64
    register has the top of stack. We then need to rotate these registers
    since ia32 context is expecting st[0] to be the first fp register (as
    if FSR.top is zero). This routine only works on full 16-byte ia32
    saved fp data (such as from ExtendedRegisters - the FXSAVE format).
    Other routines can convert this into the older FNSAVE format.

Arguments:

    Ia64_FSR - The ia64 FSR register. Has the FSR.top needed for this routine

    ia32FxSave - The ia32 fp stack (in FXSAVE format). Each ia32 fp register
                 uses 16 bytes.

Return Value:

    None.  

--*/
{
    ULONG top = (ULONG) ((Ia64_FSR >> 11) & 0x7);

    if (top) {
        FLOAT128 tmpFloat[NUMBER_OF_387REGS];
        ULONG i;
        for (i = 0; i < NUMBER_OF_387REGS; i++) {
            tmpFloat[i] = ia32FxSave[i];
        }

        for (i = 0; i < NUMBER_OF_387REGS; i++) {
            ia32FxSave[i] = tmpFloat[(i + top) % NUMBER_OF_387REGS];
        }
    }
}

//
// And now for the final yuck... The ia64 context for floating point
// is saved/loaded using spill/fill instructions. This format is different
// than the 10-byte fp format so we need a conversion routine from spill/fill
// to/from 10byte fp
//

VOID
Wow64CopyIa64FromSpill(
    IN PFLOAT128 SpillArea,
    IN OUT FLOAT128 UNALIGNED *ia64Fp,
    IN ULONG NumRegs)
/*++

Routine Description:

    This function copies fp values from the ia64 spill/fill format
    into the ia64 80-bit format. The exponent needs to be adjusted
    according to the EAS (5-12) regarding Memory to Floating Point
    Register Data Translation in the ia64 floating point chapter

Arguments:

    SpillArea - The ia64 area that has the spill format for fp

    ia64Fp - The location which will get the ia64 fp in 80-bit
             double-extended format

    NumRegs - Number of registers to convert

Return Value:

    None.

--*/
{
    ULONG i;

    for (i = 0; i < NumRegs; i++) {
        ULONG64 Sign = ((SpillArea->HighPart & (1i64 << 17)) != 0);
        ULONG64 Significand = SpillArea->LowPart; 
        ULONG64 Exponent = SpillArea->HighPart & 0x1ffff; 

        if (Exponent && Significand) 
        {
            if (Exponent == 0x1ffff) // NaNs and Infinities
            {   
                Exponent = 0x7fff;
            }
            else 
            {
                ULONG64 Rebias = 0xffff - 0x3fff;
                Exponent -= Rebias;
            }
        }

        ia64Fp->HighPart = (Sign << 15) | Exponent;
        ia64Fp->LowPart = Significand;

        ia64Fp++;
        SpillArea++;
    }
}

VOID
Wow64CopyIa64ToFill(
    IN FLOAT128 UNALIGNED *ia64Fp,
    IN OUT PFLOAT128 FillArea,
    IN ULONG NumRegs)
/*++

Routine Description:

    This function copies fp values from the ia64 80-bit format
    into the fill/spill format used by the os for save/restore
    of the ia64 context. The only magic here is putting back some
    values that get truncated when converting from spill/fill to 
    80-bits. The exponent needs to be adjusted according to the
    EAS (5-12) regarding Memory to Floating Point Register Data
    Translation in the ia64 floating point chapter

Arguments:

    ia64Fp - The ia64 fp in 80-bit double-extended format

    FillArea - The ia64 area that will get the fill format for fp
                  for the copy into the ia64 context area

    NumRegs - Number of registers to convert

Return Value:

    None.

--*/
{
    ULONG i;

    for (i = 0; i < NumRegs; i++) {
        ULONG64 Sign = ((ia64Fp->HighPart & (1i64 << 15)) != 0);
        ULONG64 Significand = ia64Fp->LowPart; 
        ULONG64 Exponent = ia64Fp->HighPart & 0x7fff;

        if (Exponent && Significand) 
        {
            if (Exponent == 0x7fff) // Infinity
            {
                Exponent = 0x1ffff;
            }
            else 
            {
                ULONGLONG Rebias = 0xffff-0x3fff;
                Exponent += Rebias;
            }
        }

        FillArea->LowPart = Significand;
        FillArea->HighPart = (Sign << 17) | Exponent;

        ia64Fp++;
        FillArea++;
    }
}

//
// Debug registers conversion
//

// XXX olegk - uncrease to 4 in future 
// (and then remove appropriate check at MapDbgSlotIa64ToX86)
#define IA64_REG_MAX_DATA_BREAKPOINTS 2

// Debug register flags.
#define IA64_DBR_RDWR           0xC000000000000000ui64
#define IA64_DBR_RD             0x8000000000000000ui64
#define IA64_DBR_WR             0x4000000000000000ui64
#define IA64_DBR_EXEC           0x8000000000000000ui64
#define IA64_DBG_MASK_MASK      0x00FFFFFFFFFFFFFFui64
#define IA64_DBG_REG_PLM_USER   0x0800000000000000ui64
#define IA64_DBG_REG_PLM_ALL    0x0F00000000000000ui64

#define X86_DR7_LOCAL_EXACT_ENABLE 0x100

ULONG 
MapDbgSlotIa64ToX86_GetSize(ULONG64 Db1, BOOL* Valid)
{
    ULONG64 Size = (~Db1 & IA64_DBG_MASK_MASK);
    if (Size > 3)
    {
        *Valid = FALSE;
    }
    return (ULONG)Size;
}

void 
MapDbgSlotIa64ToX86_InvalidateAddr(ULONG64 Db, BOOL* Valid)
{
    if (Db != (ULONG64)(ULONG)Db) 
    {
        *Valid = FALSE;
    }
}

ULONG
MapDbgSlotIa64ToX86_ExecTypeSize(
    UINT     Slot,
    ULONG64  Db,
    ULONG64  Db1,
    BOOL* Valid)
{
    ULONG TypeSize;

    if (!(Db1 >> 63)) 
    {
        *Valid = FALSE;
    }

    TypeSize = (MapDbgSlotIa64ToX86_GetSize(Db1, Valid) << 2); 
    MapDbgSlotIa64ToX86_InvalidateAddr(Db, Valid);
   
    return TypeSize;
}

ULONG
MapDbgSlotIa64ToX86_DataTypeSize(
    UINT     Slot,
    ULONG64  Db,
    ULONG64  Db1,
    BOOL* Valid)
{
    ULONG TypeSize = (ULONG)(Db1 >> 62);

    if ((TypeSize != 1) && (TypeSize != 3))
    {
        *Valid = FALSE;
    }

    TypeSize |= (MapDbgSlotIa64ToX86_GetSize(Db1, Valid) << 2); 
    MapDbgSlotIa64ToX86_InvalidateAddr(Db, Valid);
    
    return TypeSize;
}

BOOL
MapDbgSlotIa64ToX86(
    UINT    Slot,
    ULONG64 Ipsr,
    ULONG64 DbD,
    ULONG64 DbD1,
    ULONG64 DbI,
    ULONG64 DbI1,
    ULONG*  Dr7,
    ULONG*  Dr)
{
    BOOL DataValid = TRUE, ExecValid = TRUE, Valid = TRUE;
    ULONG DataTypeSize, ExecTypeSize;

    // XXX olegk - remove this after IA64_REG_MAX_DATA_BREAKPOINTS will be changed to 4
    if (Slot >= IA64_REG_MAX_DATA_BREAKPOINTS) 
    {
        return TRUE;
    }

    DataTypeSize = MapDbgSlotIa64ToX86_DataTypeSize(Slot, DbD, DbD1, &DataValid);
    ExecTypeSize = MapDbgSlotIa64ToX86_ExecTypeSize(Slot, DbI, DbI1, &ExecValid);
    
    if (DataValid)
    {
        if (!ExecValid)
        {
            *Dr = (ULONG)DbD;
            *Dr7 |= (X86_DR7_LOCAL_EXACT_ENABLE |
                     (1 << Slot * 2) |
                     (DataTypeSize << (16 + Slot * 4)));
            return !DbI && !DbI1;
        }
    }
    else if (ExecValid)
    {
        *Dr = (ULONG)DbI;
        *Dr7 |= (X86_DR7_LOCAL_EXACT_ENABLE |
                 (1 << Slot * 2) |
                 (ExecTypeSize << (16 + Slot * 4)));
        return !DbD && !DbD1;
    }
    
    *Dr7 &= ~(X86_DR7_LOCAL_EXACT_ENABLE |  
              (0xf << (16 + Slot * 4)) | 
              (1 << Slot * 2));

    if (!DbD && !DbD1 && !DbI && !DbI1)
    {
        *Dr = 0;
        return TRUE;
    }
     
    *Dr = ~(ULONG)0;

    return FALSE;
}

void
MapDbgSlotX86ToIa64(
    UINT     Slot,
    ULONG    Dr7,
    ULONG    Dr,
    ULONG64* Ipsr,
    ULONG64* DbD,
    ULONG64* DbD1,
    ULONG64* DbI,
    ULONG64* DbI1)
{
    UINT TypeSize;
    ULONG64 Control;

    if (!(Dr7 & (1 << Slot * 2)))
    {
        return;
    }

    if (Dr == ~(ULONG)0) 
    {
        return;
    }

    TypeSize = Dr7 >> (16 + Slot * 4);

    Control = (IA64_DBG_REG_PLM_USER | IA64_DBG_MASK_MASK) & 
              ~(ULONG64)(TypeSize >> 2);

    switch (TypeSize & 0x3) 
    {
    case 0x0: // Exec
        *DbI1 = Control | IA64_DBR_EXEC;        
        *DbI = Dr;
        break;
    case 0x1: // Write
        *DbD1 = Control | IA64_DBR_WR;
        *DbD = Dr;
        break;
    case 0x3: // Read/Write
        *DbD1 = Control | IA64_DBR_RD | IA64_DBR_WR;
        *DbD = Dr;
        break;
    default:
        return;
    }
    *Ipsr |= (1i64 << PSR_DB); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\cpu\ia64\context\suspend.c ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name: 

    suspend.c

Abstract:
    
    This module implements CpuSuspendThread, CpuGetContext and CpuSetContext.

Author:

    16-Dec-1999  SamerA

Revision History:

--*/

#define _WOW64CPUAPI_


#ifdef _X86_
#include "ia6432.h"
#else
#define _NTDDK_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntos.h>
#include "wow64.h"
#include "wow64cpu.h"
#include "ia64cpu.h"
#endif

#include <stdio.h>
#include <stdarg.h>

//
// This is to prevent this library from linking to wow64 to use wow64!Wow64LogPrint
//
#if defined(LOGPRINT)
#undef LOGPRINT
#endif
#define LOGPRINT(_x_)   CpupDebugPrint _x_


ASSERTNAME;

#define DECLARE_CPU         \
    PCPUCONTEXT cpu = (PCPUCONTEXT)Wow64TlsGetValue(WOW64_TLS_CPURESERVED)


ULONG_PTR ia32ShowContext = 0;

VOID
CpupDebugPrint(
    IN ULONG_PTR Flags,
    IN PCHAR Format,
    ...)
{
    va_list ArgList;
    int BytesWritten;
    CHAR Buffer[ 512 ];

    if ((ia32ShowContext & Flags) || (Flags == ERRORLOG))
    {
        va_start(ArgList, Format);
        BytesWritten = _vsnprintf(Buffer,
                                  sizeof(Buffer) - 1,
                                  Format,
                                  ArgList);
        if (BytesWritten > 0)
        {
            DbgPrint(Buffer);
        }
        va_end(ArgList);
    }
    
    return;
}


VOID
CpupPrintContext(
    IN PCHAR str,
    IN PCPUCONTEXT cpu
    )
/*++

Routine Description:

    Print out the ia32 context based on the passed in cpu context

Arguments:

    str - String to print out as a header
    cpu - Pointer to the per-thread wow64 ia32 context.

Return Value:

    none

--*/
{
    DbgPrint(str);
    DbgPrint("Context addr(0x%p): EIP=0x%08x\n", &(cpu->Context), cpu->Context.Eip);
    DbgPrint("Context EAX=0x%08x, EBX=0x%08x, ECX=0x%08x, EDX=0x%08x\n",
                        cpu->Context.Eax,
                        cpu->Context.Ebx,
                        cpu->Context.Ecx,
                        cpu->Context.Edx);
    DbgPrint("Context ESP=0x%08x, EBP=0x%08x, ESI=0x%08x, EDI=0x%08x\n",
                        cpu->Context.Esp,
                        cpu->Context.Ebp,
                        cpu->Context.Esi,
                        cpu->Context.Edi);
    try {
        //
        // The stack may not yet be fully formed, so don't
        // let a missing stack cause the process to abort
        //
        DbgPrint("Context stack=0x%08x 0x%08x 0x%08x 0x%08x\n",
                        *((PULONG) cpu->Context.Esp),
                        *(((PULONG) cpu->Context.Esp) + 1),
                        *(((PULONG) cpu->Context.Esp) + 2),
                        *(((PULONG) cpu->Context.Esp) + 3));
    }
    except ((GetExceptionCode() == STATUS_ACCESS_VIOLATION)?1:0) {
        //
        // Got an access violation, so don't print any of the stack
        //
        DbgPrint("Context stack: Can't get stack contents\n");
    }

    DbgPrint("Context EFLAGS=0x%08x\n", cpu->Context.EFlags);
}

WOW64CPUAPI
NTSTATUS
CpuSuspendThread(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    OUT PULONG PreviousSuspendCount OPTIONAL)
/*++

Routine Description:

    This routine is entered while the target thread is actually suspended, however, it's 
    not known if the target thread is in a consistent state relative to
    the CPU.    

Arguments:

    ThreadHandle          - Handle of target thread to suspend
    ProcessHandle         - Handle of target thread's process 
    Teb                   - Address of the target thread's TEB
    PreviousSuspendCount  - Previous suspend count

Return Value:

    NTSTATUS.

--*/
{
    return STATUS_SUCCESS;
}


NTSTATUS CpupReadBuffer(
    IN HANDLE ProcessHandle,
    IN PVOID Source,
    OUT PVOID Destination,
    IN ULONG Size)
/*++

Routine Description:

    This routine setup the arguments for the remoted  SuspendThread call.
    
Arguments:

    ProcessHandle  - Target process handle to read data from
    Source         - Target base address to read data from
    Destination    - Address of buffer to receive data read from the specified address space
    Size           - Size of data to read

Return Value:

    NTSTATUS.

--*/
{
    return NtReadVirtualMemory(ProcessHandle,
                               Source,
                               Destination,
                               Size,
                               NULL);
}

NTSTATUS
CpupWriteBuffer(
    IN HANDLE ProcessHandle,
    IN PVOID Target,
    IN PVOID Source,
    IN ULONG Size)
/*++

Routine Description:

    Writes data to memory taken into consideration if the write is cross-process
    or not
    
Arguments:

    ProcessHandle  - Target process handle to write data into
    Target         - Target base address to write data at
    Source         - Address of contents to write in the specified address space
    Size           - Size of data to write
    
Return Value:

    NTSTATUS.

--*/
{
    return NtWriteVirtualMemory(ProcessHandle,
                                Target,
                                Source,
                                Size,
                                NULL);
}

NTSTATUS
GetContextRecord(
    IN PCPUCONTEXT cpu,
    IN OUT PCONTEXT32 Context
    )
/*++

Routine Description:

    Retrevies the context record of the specified CPU

Arguments:

    cpu     - CPU to retreive the context record for.
    Context - IN/OUT pointer to CONTEXT32 to fill in.  Context->ContextFlags
              should be used to determine how much of the context to copy.

Return Value:

    None.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG ContextFlags;
    

    try 
    {
        ContextFlags = Context->ContextFlags;
        if (ContextFlags & CONTEXT_IA64)
        {
            LOGPRINT((ERRORLOG, "CpuGetContext: Request for ia64 context (0x%x) being FAILED\n", ContextFlags));
            ASSERT((ContextFlags & CONTEXT_IA64) == 0);
        }

        if ((ContextFlags & CONTEXT32_CONTROL) == CONTEXT32_CONTROL) 
        {
            //
            // i386 control registers are:
            // ebp, eip, cs, eflag, esp and ss
            //
            Context->Ebp = cpu->Context.Ebp;
            Context->Eip = cpu->Context.Eip;
            Context->SegCs = KGDT_R3_CODE|3;   // Force reality
            Context->EFlags = SANITIZE_X86EFLAGS(cpu->Context.EFlags);
            Context->Esp = cpu->Context.Esp;
            Context->SegSs = KGDT_R3_DATA|3;   // Force reality
        }

        if ((ContextFlags & CONTEXT32_INTEGER)  == CONTEXT32_INTEGER)
        {
            //
            // i386 integer registers are:
            // edi, esi, ebx, edx, ecx, eax
            //
            Context->Edi = cpu->Context.Edi;
            Context->Esi = cpu->Context.Esi;
            Context->Ebx = cpu->Context.Ebx;
            Context->Edx = cpu->Context.Edx;
            Context->Ecx = cpu->Context.Ecx;
            Context->Eax = cpu->Context.Eax;
        }

        if ((ContextFlags & CONTEXT32_SEGMENTS) == CONTEXT32_SEGMENTS) 
        {
            //
            // i386 segment registers are:
            // ds, es, fs, gs
            // And since they are a constant, force them to be the right values
            //
            Context->SegDs = KGDT_R3_CODE|3;
            Context->SegEs = KGDT_R3_CODE|3;
            Context->SegFs = KGDT_R3_TEB|3;
            Context->SegGs = KGDT_R3_CODE|3;
        }

        if ((ContextFlags & CONTEXT32_EXTENDED_REGISTERS) == CONTEXT32_EXTENDED_REGISTERS) 
        {
            LOGPRINT((TRACELOG, "CpuGetContext: Request to get Katmai registers(0x%x)\n", ContextFlags));
            
            RtlCopyMemory(&(Context->ExtendedRegisters[0]),
                          &(cpu->Context.ExtendedRegisters[0]),
                          MAXIMUM_SUPPORTED_EXTENSION);
        }

        if ((ContextFlags & CONTEXT32_FLOATING_POINT) == CONTEXT32_FLOATING_POINT) 
        {
            //
            // For the ISA transition routine, these floats need to be
            // in the ExtendedRegister area. So grab the values requested
            // from that area
            //
            PFXSAVE_FORMAT_WX86 xmmi = (PFXSAVE_FORMAT_WX86) &(cpu->Context.ExtendedRegisters[0]);

            LOGPRINT((TRACELOG, "CpuGetContext: Request to get float registers(0x%x)\n", ContextFlags));

            //
            // Start by grabbing the status/control portion
            //
            Context->FloatSave.ControlWord = xmmi->ControlWord;
            Context->FloatSave.StatusWord = xmmi->StatusWord;
            Context->FloatSave.TagWord = xmmi->TagWord;
            Context->FloatSave.ErrorOffset = xmmi->ErrorOffset;
            Context->FloatSave.ErrorSelector = xmmi->ErrorSelector;
            Context->FloatSave.DataOffset = xmmi->DataOffset;
            Context->FloatSave.DataSelector = xmmi->DataSelector;

            //
            // Now get the packed 10-byte fp data registers
            //
            Wow64CopyFpFromIa64Byte16(&(xmmi->RegisterArea[0]),
                                      &(Context->FloatSave.RegisterArea[0]),
                                      NUMBER_OF_387REGS);

            //
            // For performance reasons, the PCPU context leaves the
            // fp registers un-rotated. So we need to rotate them now
            // to make it follow the proper FSAVE fotmat
            //
            Wow64RotateFpTop(xmmi->StatusWord, (PFLOAT128) &(Context->FloatSave.RegisterArea[0]));
        }

        if ((ContextFlags & CONTEXT32_DEBUG_REGISTERS) == CONTEXT32_DEBUG_REGISTERS) 
        {
            LOGPRINT((TRACELOG, "CpuGetContext: Request to get debug registers(0x%x)\n", ContextFlags));
            Context->Dr0 = cpu->Context.Dr0;
            Context->Dr1 = cpu->Context.Dr1;
            Context->Dr2 = cpu->Context.Dr2;
            Context->Dr3 = cpu->Context.Dr3;
            Context->Dr6 = cpu->Context.Dr6;
            Context->Dr7 = cpu->Context.Dr7;
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        NtStatus = GetExceptionCode();
    }

    if (ia32ShowContext & LOG_CONTEXT_GETSET) 
    {
        CpupPrintContext("Getting ia32 context: ", cpu);
    }

    return NtStatus;
}

NTSTATUS
CpupGetContext(
    IN OUT PCONTEXT32 Context
    )
/*++

Routine Description:

    This routine extracts the context record for the currently executing thread. 

Arguments:

    Context  - Context record to fill

Return Value:

    NTSTATUS.

--*/
{
    DECLARE_CPU;

    return GetContextRecord(cpu, Context);
}


NTSTATUS
CpupGetContextThread(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    IN OUT PCONTEXT32 Context)
/*++

Routine Description:

    This routine extract the context record of any thread. This is a generic routine.
    When entered, if the target thread isn't the current thread, then it should be 
    guaranteed that the target thread is suspended at a proper CPU state.

Arguments:

    ThreadHandle   - Target thread handle to retreive the context for
    ProcessHandle  - Open handle to the process that the thread runs in
    Teb            - Pointer to the target's thread TEB
    Context        - Context record to fill                 

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    CONTEXT ContextEM;
    PCPUCONTEXT CpuRemoteContext;
    CPUCONTEXT CpuContext;


    ContextEM.ContextFlags = CONTEXT_FULL | CONTEXT_DEBUG;
    NtStatus = NtGetContextThread(ThreadHandle,
                                  &ContextEM);

    if (!NT_SUCCESS(NtStatus))
    {
        LOGPRINT((ERRORLOG, "CpupGetContextThread: NtGetContextThread (%lx) failed - %lx\n", 
                  ThreadHandle, NtStatus));
        return NtStatus;
    }

    if (ContextEM.StIPSR & (1i64 << PSR_IS))
    {
        Wow64CtxFromIa64(Context->ContextFlags, &ContextEM, Context);
                    
        LOGPRINT((TRACELOG, "Getting context while thread is executing 32-bit instructions - %lx\n", NtStatus));
    }
    else
    {
        LOGPRINT((TRACELOG, "Getting context while thread is executing 64-bit instructions\n"));
        NtStatus = CpupReadBuffer(ProcessHandle,
                                  ((PCHAR)Teb + FIELD_OFFSET(TEB, TlsSlots[WOW64_TLS_CPURESERVED])),
                                  &CpuRemoteContext,
                                  sizeof(CpuRemoteContext));

        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = CpupReadBuffer(ProcessHandle,
                                      CpuRemoteContext,
                                      &CpuContext,
                                      sizeof(CpuContext));

            if (NT_SUCCESS(NtStatus))
            {
                NtStatus = GetContextRecord(&CpuContext, Context);
            }
            else
            {
                LOGPRINT((ERRORLOG, "CpupGetContextThread: Couldn't read CPU context %lx - %lx\n", 
                          CpuRemoteContext, NtStatus));

            }
        }
        else
        {
            LOGPRINT((ERRORLOG, "CpupGetContextThread: Couldn't read CPU context address - %lx\n", 
                      NtStatus));
        }
    }

    return NtStatus;
}



WOW64CPUAPI
NTSTATUS  
CpuGetContext(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    OUT PCONTEXT32 Context)
/*++

Routine Description:

    Extracts the cpu context of the specified thread.
    When entered, it is guaranteed that the target thread is suspended at 
    a proper CPU state.

Arguments:

    ThreadHandle   - Target thread handle to retreive the context for
    ProcessHandle  - Open handle to the process that the thread runs in
    Teb            - Pointer to the target's thread TEB
    Context        - Context record to fill                 

Return Value:

    NTSTATUS.

--*/
{
    if (NtCurrentThread() == ThreadHandle)
    {
        return CpupGetContext(Context);
    }

    return CpupGetContextThread(ThreadHandle,
                                ProcessHandle,
                                Teb,
                                Context);
}


NTSTATUS
SetContextRecord(
    IN PCPUCONTEXT cpu,
    IN OUT PCONTEXT32 Context
    )
/*++

Routine Description:

    Update the CPU's register set for the specified CPU.

Arguments:

    cpu     - CPU to update its registers
    Context - IN pointer to CONTEXT32 to use.  Context->ContextFlags
              should be used to determine how much of the context to update.

Return Value:

    None.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG ContextFlags;

    
    try 
    {
        ContextFlags = Context->ContextFlags;
        if (ContextFlags & CONTEXT_IA64) 
        {
            LOGPRINT((ERRORLOG, "CpuSetContext: Request with ia64 context (0x%x) FAILED\n", ContextFlags));
            ASSERT((ContextFlags & CONTEXT_IA64) == 0);
        }

        if ((ContextFlags & CONTEXT32_CONTROL) == CONTEXT32_CONTROL) 
        {
            //
            // i386 control registers are:
            // ebp, eip, cs, eflag, esp and ss
            //
            cpu->Context.Ebp = Context->Ebp;
            cpu->Context.Eip = Context->Eip;
            cpu->Context.SegCs = KGDT_R3_CODE|3;   // Force Reality
            cpu->Context.EFlags = SANITIZE_X86EFLAGS(Context->EFlags);
            cpu->Context.Esp = Context->Esp;
            cpu->Context.SegSs = KGDT_R3_DATA|3;   // Force Reality
        }

        if ((ContextFlags & CONTEXT32_INTEGER)  == CONTEXT32_INTEGER)
        {
            //
            // i386 integer registers are:
            // edi, esi, ebx, edx, ecx, eax
            //
            cpu->Context.Edi = Context->Edi;
            cpu->Context.Esi = Context->Esi;
            cpu->Context.Ebx = Context->Ebx;
            cpu->Context.Edx = Context->Edx;
            cpu->Context.Ecx = Context->Ecx;
            cpu->Context.Eax = Context->Eax;
        }

        if ((ContextFlags & CONTEXT32_SEGMENTS) == CONTEXT32_SEGMENTS) 
        {
            //
            // i386 segment registers are:
            // ds, es, fs, gs
            // And since they are a constant, force them to be the right values
            //
            cpu->Context.SegDs = KGDT_R3_DATA|3;
            cpu->Context.SegEs = KGDT_R3_DATA|3;
            cpu->Context.SegFs = KGDT_R3_TEB|3;
            cpu->Context.SegGs = KGDT_R3_DATA|3;
        }

        //
        // To follow the way ia32 does get/set context, you need to make sure
        // that the older FP context is saved second. That way if both
        // old and new context is passed in, the old takes precedence
        // This happens, for example, when handling an FP exception... The
        // exception handler says both context is available, and older programs
        // only clean up the older FP area...
        //
        if ((ContextFlags & CONTEXT32_EXTENDED_REGISTERS) == CONTEXT32_EXTENDED_REGISTERS) 
        {
            LOGPRINT((TRACELOG, "CpuSetContext: Request to set Katmai registers(0x%x)\n", ContextFlags));
            RtlCopyMemory(&(cpu->Context.ExtendedRegisters[0]),
                          &(Context->ExtendedRegisters[0]),
                          MAXIMUM_SUPPORTED_EXTENSION);
        }

        if ((ContextFlags & CONTEXT32_FLOATING_POINT) == CONTEXT32_FLOATING_POINT) 
        {
            //
            // For the ISA transition routine, these floats need to be
            // in the ExtendedRegister area. So put the values requested
            // into that area
            //
            PFXSAVE_FORMAT_WX86 xmmi = (PFXSAVE_FORMAT_WX86) &(cpu->Context.ExtendedRegisters[0]);

            LOGPRINT((TRACELOG, "CpuSetContext: Request to set float registers(0x%x)\n", ContextFlags));

            //
            // Start by grabbing the status/control portion
            //
            xmmi->ControlWord = (USHORT) (Context->FloatSave.ControlWord & 0xFFFF);
            xmmi->StatusWord = (USHORT) (Context->FloatSave.StatusWord & 0xFFFF);
            xmmi->TagWord = (USHORT) (Context->FloatSave.TagWord & 0xFFFF);
            xmmi->ErrorOffset = Context->FloatSave.ErrorOffset;
            xmmi->ErrorSelector = Context->FloatSave.ErrorSelector;
            xmmi->DataOffset = Context->FloatSave.DataOffset;
            xmmi->DataSelector = Context->FloatSave.DataSelector;

            //
            // Now get the packed 10-byte fp data registers and convert
            // them into the 16-byte format used by FXSAVE (and the
            // ISA transition routine)
            //
            Wow64CopyFpToIa64Byte16(&(Context->FloatSave.RegisterArea[0]),
                                    &(xmmi->RegisterArea[0]),
                                    NUMBER_OF_387REGS);

            //
            // For performance reasons, the PCPU context leaves the
            // fp registers un-rotated. So we need to rotate them back
            // now into the optimized format used for isa transisions
            //
            {
                ULONGLONG RotateFSR = (NUMBER_OF_387REGS -
                                       ((xmmi->StatusWord >> 11) & 0x7)) << 11;
                Wow64RotateFpTop(RotateFSR, (PFLOAT128) &(xmmi->RegisterArea[0]));
            }
        }

        if ((ContextFlags & CONTEXT32_DEBUG_REGISTERS) == CONTEXT32_DEBUG_REGISTERS)
        {
            LOGPRINT((TRACELOG, "CpuSetContext: Request to set debug registers(0x%x)\n", ContextFlags));
            cpu->Context.Dr0 = Context->Dr0;
            cpu->Context.Dr1 = Context->Dr1;
            cpu->Context.Dr2 = Context->Dr2;
            cpu->Context.Dr3 = Context->Dr3;
            cpu->Context.Dr6 = Context->Dr6;
            cpu->Context.Dr7 = Context->Dr7;
        }

        //
        // Whatever they passed in before, it's an X86 context now...
        //
        cpu->Context.ContextFlags = ContextFlags;
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        NtStatus = GetExceptionCode();
    }


    if (ia32ShowContext & LOG_CONTEXT_GETSET) 
    {
        CpupPrintContext("Setting ia32 context: ", cpu);
    }

    return NtStatus;
}

NTSTATUS
CpupSetContext(
    IN OUT PCONTEXT32 Context
    )
/*++

Routine Description:

    This routine sets the context record for the currently executing thread. 

Arguments:

    Context  - Context record to fill 

Return Value:

    NTSTATUS.

--*/
{
    DECLARE_CPU;

    return SetContextRecord(cpu, Context);
}



NTSTATUS
CpupSetContextThread(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    IN OUT PCONTEXT32 Context)
/*++

Routine Description:

    This routine sets the context record of any thread. This is a generic routine.
    When entered, if the target thread isn't the currently executing thread, then it should be 
    guaranteed that the target thread is suspended at a proper CPU state.

Arguments:

    ThreadHandle   - Target thread handle to retreive the context for
    ProcessHandle  - Open handle to the process that the thread runs in
    Teb            - Pointer to the target's thread TEB
    Context        - Context record to set

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    CONTEXT ContextEM;
    PCPUCONTEXT CpuRemoteContext;
    CPUCONTEXT CpuContext;

    ContextEM.ContextFlags = CONTEXT_FULL | CONTEXT_DEBUG;
    NtStatus = NtGetContextThread(ThreadHandle,
                                  &ContextEM);

    if (!NT_SUCCESS(NtStatus))
    {
        LOGPRINT((ERRORLOG, "CpupGetContextThread: NtGetContextThread (%lx) failed - %lx\n", 
                  ThreadHandle, NtStatus));

        return NtStatus;
    }

    if (ContextEM.StIPSR & (1i64 << PSR_IS))
    {
        Wow64CtxToIa64(Context->ContextFlags, Context, &ContextEM);
        NtStatus = NtSetContextThread(ThreadHandle, &ContextEM);
        LOGPRINT((TRACELOG, "Setting context while thread is executing 32-bit instructions - %lx\n", NtStatus));
    }
    else
    {
        LOGPRINT((TRACELOG, "Setting context while thread is executing 64-bit instructions\n"));
        NtStatus = CpupReadBuffer(ProcessHandle,
                                  ((PCHAR)Teb + FIELD_OFFSET(TEB, TlsSlots[WOW64_TLS_CPURESERVED])),
                                  &CpuRemoteContext,
                                  sizeof(CpuRemoteContext));

        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = CpupReadBuffer(ProcessHandle,
                                      CpuRemoteContext,
                                      &CpuContext,
                                      sizeof(CpuContext));

            if (NT_SUCCESS(NtStatus))
            {    
                NtStatus = SetContextRecord(&CpuContext, Context);

                if (NT_SUCCESS(NtStatus))
                {
                    NtStatus = CpupWriteBuffer(ProcessHandle,
                                               CpuRemoteContext,
                                               &CpuContext,
                                               sizeof(CpuContext));
                }
                else
                {
                    LOGPRINT((ERRORLOG, "CpupSetContextThread: Couldn't read CPU context %lx - %lx\n", 
                              CpuRemoteContext, NtStatus));
                }
            }
        }
        else
        {
            LOGPRINT((ERRORLOG, "CpupSetContextThread: Couldn't read CPU context address - %lx\n", 
                      NtStatus));

        }
    }

    return NtStatus;
}


WOW64CPUAPI
NTSTATUS
CpuSetContext(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    PCONTEXT32 Context)
/*++

Routine Description:

    Sets the cpu context for the specified thread.
    When entered, if the target thread isn't the currently executing thread, then it is 
    guaranteed that the target thread is suspended at a proper CPU state.

Arguments:

    ThreadHandle   - Target thread handle to retreive the context for
    ProcessHandle  - Open handle to the process that the thread runs in
    Teb            - Pointer to the target's thread TEB
    Context        - Context record to set

Return Value:

    NTSTATUS.

--*/
{
    if (NtCurrentThread() == ThreadHandle)
    {
        return CpupSetContext(Context);
    }
    
    return CpupSetContextThread(ThreadHandle,
                                ProcessHandle,
                                Teb,
                                Context);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\cpu\ia64\dbgexts\w64cpuex.cpp ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    w64cpuex.cpp

Abstract:

    Debugger extension DLL for debugging the CPU

Author:

    27-Sept-1999 BarryBo

Revision History:


--*/

#define _WOW64CPUDBGAPI_
#define DECLARE_CPU_DEBUGGER_INTERFACE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <dbgeng.h>
#include <ntosp.h>

#if defined _X86_
#define WOW64EXTS_386
#endif

#include "wow64.h"
#include "wow64cpu.h"
#include "ia64cpu.h"

// Safe release and NULL.

#define EXT_RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)

#define CONTEXT_OFFSET FIELD_OFFSET(TEB64, TlsSlots[WOW64_TLS_CPURESERVED])


CPUCONTEXT            LocalCpuContext;
PWOW64GETCPUDATA      CpuGetData;
PDEBUG_ADVANCED       g_ExtAdvanced;
PDEBUG_CLIENT         g_ExtClient;
PDEBUG_CONTROL        g_ExtControl;
PDEBUG_DATA_SPACES    g_ExtData;
PDEBUG_REGISTERS      g_ExtRegisters;
PDEBUG_SYMBOLS        g_ExtSymbols;
PDEBUG_SYSTEM_OBJECTS g_ExtSystem;
void
ExtRelease(void)
{
    g_ExtClient = NULL;
    EXT_RELEASE(g_ExtAdvanced);
    EXT_RELEASE(g_ExtControl);
    EXT_RELEASE(g_ExtData);
    EXT_RELEASE(g_ExtRegisters);
    EXT_RELEASE(g_ExtSymbols);
    EXT_RELEASE(g_ExtSystem);
}

// Queries for all debugger interfaces.
HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Status;

    if ((Status = Client->QueryInterface(__uuidof(IDebugAdvanced),
                                         (void **)&g_ExtAdvanced)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugControl),
                                         (void **)&g_ExtControl)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                         (void **)&g_ExtData)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugRegisters),
                                         (void **)&g_ExtRegisters)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols),
                                         (void **)&g_ExtSymbols)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                         (void **)&g_ExtSystem)) != S_OK)
    {
        goto Fail;
    }

    g_ExtClient = Client;

    return S_OK;

 Fail:
    ExtRelease();
    return Status;
}
// Normal output.
void __cdecl
ExtOut(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_NORMAL, Format, Args);
    va_end(Args);
}

// Error output.
void __cdecl
ExtErr(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);
}

// Warning output.
void __cdecl
ExtWarn(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_WARNING, Format, Args);
    va_end(Args);
}

// Verbose output.
void __cdecl
ExtVerb(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_VERBOSE, Format, Args);
    va_end(Args);
}

WOW64CPUDBGAPI VOID
CpuDbgInitEngapi(
    PWOW64GETCPUDATA lpGetData
    )
{
    CpuGetData = lpGetData;
}


HRESULT
EngGetContextThread(
    IN OUT PCONTEXT32 Context)
/*++

Routine Description:

    This routine extract the context record of any thread. This is a generic routine.
    When entered, if the target thread isn't the current thread, then it should be 
    guaranteed that the target thread is suspended at a proper CPU state.

Arguments:

    Context        - Context record to fill                 

Return Value:

    HRESULT.

--*/
{
    HRESULT hr;
    NTSTATUS NtStatus;
    CONTEXT ContextEM;
    ULONG64 CpuRemoteContext;
    ULONG64 Teb;
    CPUCONTEXT CpuContext;

    ContextEM.ContextFlags = CONTEXT_FULL;
    
    hr = g_ExtSystem->GetCurrentThreadTeb(&Teb);
    if (FAILED(hr)) {
        return hr;
    }

    hr = g_ExtData->ReadVirtual(Teb + CONTEXT_OFFSET,
                                &CpuRemoteContext,
                                sizeof(CpuRemoteContext),
                                NULL);
  
    if (FAILED(hr)) {
        return hr;
    }
    hr = g_ExtData->ReadVirtual(CpuRemoteContext,
                                &CpuContext,
                                sizeof(CpuContext),
                                NULL);
    if (FAILED(hr)) {
        return hr;
    }
    
    NtStatus = GetContextRecord(&CpuContext, Context);
    if (!NT_SUCCESS(NtStatus)) {
        return E_FAIL;
    }
    return hr;
}


WOW64CPUDBGAPI BOOL
CpuDbgGetRemoteContext(
    PDEBUG_CLIENT Client,
    PVOID CpuData
    )
{
    BOOL bRet = FALSE;
    HRESULT hr;
    CONTEXT Context;

    hr = ExtQuery(Client);
    if (FAILED(hr)) {
        return FALSE;
    }
    LocalCpuContext.Context.ContextFlags = CONTEXT32_FULLFLOAT;
    hr = EngGetContextThread(&LocalCpuContext.Context);
    if (FAILED(hr)) {
        goto Done;
    }

    bRet = TRUE;
Done:
    ExtRelease();
    return bRet;
}

HRESULT
EngSetContextThread(
    IN OUT PCONTEXT32 Context)
/*++

Routine Description:

    This routine sets the context record of any thread. This is a generic routine.
    When entered, if the target thread isn't the currently executing thread, then it should be 
    guaranteed that the target thread is suspended at a proper CPU state.

Arguments:

    Context        - Context record to set

Return Value:

    HRESULT.

--*/
{
    HRESULT hr;
    NTSTATUS NtStatus;
    CONTEXT ContextEM;
    ULONG64 CpuRemoteContext;
    ULONG64 Teb;
    CPUCONTEXT CpuContext;

    ContextEM.ContextFlags = CONTEXT_FULL;
    
    hr = g_ExtAdvanced->SetThreadContext(&ContextEM, sizeof(ContextEM));
    
    hr = g_ExtSystem->GetCurrentThreadTeb(&Teb);
    if (FAILED(hr)) {
        return hr;
    }

    hr = g_ExtData->ReadVirtual(Teb + CONTEXT_OFFSET,
                                &CpuRemoteContext,
                                sizeof(CpuRemoteContext),
                                NULL);

    if (FAILED(hr)) {
        return hr;
    }
    hr = g_ExtData->ReadVirtual(CpuRemoteContext,
                                &CpuContext,
                                sizeof(CpuContext),
                                NULL);
    if (FAILED(hr)) {
        return hr;
    }
    NtStatus = SetContextRecord(&CpuContext, Context);
    if (!NT_SUCCESS(NtStatus)) {
        return E_FAIL;
    }
    hr = g_ExtData->WriteVirtual(CpuRemoteContext,
                                 &CpuContext,
                                 sizeof(CpuContext),
                                 NULL);
    return hr;
}


WOW64CPUDBGAPI BOOL
CpuDbgSetRemoteContext(
    PDEBUG_CLIENT Client
    )
{
    BOOL bRet = FALSE;
    HRESULT hr;
    NTSTATUS Status;
    CONTEXT Context;

    hr = ExtQuery(Client);
    if (FAILED(hr)) {
        return FALSE;
    }

    LocalCpuContext.Context.ContextFlags = CONTEXT32_FULLFLOAT;
    hr = EngSetContextThread(&LocalCpuContext.Context);
    if (FAILED(hr)) {
        ExtOut("CpuDbgSetRemoteContext:  Error %x writing CPU context\n", hr);
        goto Done;
    }

    bRet = TRUE;
Done:
    ExtRelease();
    return bRet;
}

WOW64CPUDBGAPI BOOL
CpuDbgGetLocalContext(
    PDEBUG_CLIENT Client,
    PCONTEXT32 Context
    )
{
    return NT_SUCCESS(GetContextRecord(&LocalCpuContext,
                                       Context));
}

WOW64CPUDBGAPI BOOL
CpuDbgSetLocalContext(
    PDEBUG_CLIENT Client,
    PCONTEXT32 Context
    )
{
    return NT_SUCCESS(SetContextRecord(&LocalCpuContext,
                                       Context));
}


WOW64CPUDBGAPI VOID
CpuDbgFlushInstructionCacheWithHandle(
    HANDLE Process,
    PVOID Addr,
    DWORD Length
    )
{
    
    NtFlushInstructionCache((HANDLE)Process, Addr, Length);
}


WOW64CPUDBGAPI VOID
CpuDbgFlushInstructionCache(
    PDEBUG_CLIENT Client,
    PVOID Addr,
    DWORD Length
    )
{
    HRESULT hr;
    ULONG64 Process;

    hr = ExtQuery(Client);
    if (FAILED(hr)) {
        return;
    }
    hr = g_ExtSystem->GetCurrentProcessHandle(&Process);
    if (FAILED(hr)) {
        ExtOut("CpuDbgFlushInstructionCache: failed to get Process Handle!\n");
        return;
    }
    CpuDbgFlushInstructionCacheWithHandle((HANDLE)Process, Addr, Length);
    ExtRelease();
}


VOID SetEax(ULONG ul) {
    LocalCpuContext.Context.Eax = ul;
}
VOID SetEbx(ULONG ul) {
    LocalCpuContext.Context.Ebx = ul;
}
VOID SetEcx(ULONG ul) {
    LocalCpuContext.Context.Ecx = ul;
}
VOID SetEdx(ULONG ul) {
    LocalCpuContext.Context.Edx = ul;
}
VOID SetEsi(ULONG ul) {
    LocalCpuContext.Context.Esi = ul;
}
VOID SetEdi(ULONG ul) {
    LocalCpuContext.Context.Edi = ul;
}
VOID SetEbp(ULONG ul) {
    LocalCpuContext.Context.Ebp = ul;
}
VOID SetEsp(ULONG ul) {
    LocalCpuContext.Context.Esp = ul;
}
VOID SetEip(ULONG ul) {
    LocalCpuContext.Context.Eip = ul;
}
VOID SetEfl(ULONG ul) {
    LocalCpuContext.Context.EFlags = ul;
}

ULONG GetEax(VOID) {
    return LocalCpuContext.Context.Eax;
}
ULONG GetEbx(VOID) {
    return LocalCpuContext.Context.Ebx;
}
ULONG GetEcx(VOID) {
    return LocalCpuContext.Context.Ecx;
}
ULONG GetEdx(VOID) {
    return LocalCpuContext.Context.Edx;
}
ULONG GetEsi(VOID) {
    return LocalCpuContext.Context.Esi;
}
ULONG GetEdi(VOID) {
    return LocalCpuContext.Context.Edi;
}
ULONG GetEbp(VOID) {
    return LocalCpuContext.Context.Ebp;
}
ULONG GetEsp(VOID) {
    return LocalCpuContext.Context.Esp;
}
ULONG GetEip(VOID) {
    return LocalCpuContext.Context.Eip;
}
ULONG GetEfl(VOID) {
    return LocalCpuContext.Context.EFlags;
}

CPUREGFUNCS CpuRegFuncs[] = {
    { "Eax", SetEax, GetEax },
    { "Ebx", SetEbx, GetEbx },
    { "Ecx", SetEcx, GetEcx },
    { "Edx", SetEdx, GetEdx },
    { "Esi", SetEsi, GetEsi },
    { "Edi", SetEdi, GetEdi },
    { "Ebp", SetEbp, GetEbp },
    { "Esp", SetEsp, GetEsp },
    { "Eip", SetEip, GetEip },
    { "Efl", SetEfl, GetEfl },
    { NULL, NULL, NULL}
};

WOW64CPUDBGAPI PCPUREGFUNCS
CpuDbgGetRegisterFuncs(
    void
    )
{
    return CpuRegFuncs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\cpu\ia64\inc\ia64bt.h ===
/*++
                                                                                
Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    bintrans.h

Abstract:
    
    Header for calling bintrans.dll if it exists
    
Author:

    22-Aug-2000 v-cspira (charles spirakis)

--*/

#ifndef _BINTRANS_INCLUDE
#define _BINTRANS_INCLUDE

#ifdef __cplusplus
extern "C" {
#endif


//
// Create the typedefs for the functions we can import from the bintrans
// dll. These functions are duplicates of the wow64cpu export list for both
// what they do and te parameters they take. Any changes to the wow64cpu
// list should also update these typedefs
//

//
// Cache manipulation functions and Dll notification
//
typedef VOID (*PFNCPUFLUSHINSTRUCTIONCACHE)( PVOID BaseAddress, ULONG Length );
typedef VOID (*PFNCPUNOTIFYDLLLOAD)( LPWSTR DllName, PVOID DllBase, ULONG DllSize );
typedef VOID (*PFNCPUNOTIFYDLLUNLOAD)( PVOID DllBase  );

//
// Init and term APIs
//
typedef NTSTATUS (*PFNCPUPROCESSINIT)(PWSTR pImageName, PSIZE_T pCpuThreadDataSize);
typedef NTSTATUS (*PFNCPUPROCESSTERM)(HANDLE ProcessHandle);
typedef NTSTATUS (*PFNCPUTHREADINIT)(PVOID pPerThreadData);
typedef NTSTATUS (*PFNCPUTHREADTERM)(VOID);


//
// Execution
//
typedef VOID (*PFNCPUSIMULATE)(VOID);

//
// Exception handling, context manipulation
//
typedef VOID  (*PFNCPURESETTOCONSISTENTSTATE)(PEXCEPTION_POINTERS pExecptionPointers);
typedef ULONG (*PFNCPUGETSTACKPOINTER)(VOID);
typedef VOID  (*PFNCPUSETSTACKPOINTER)(ULONG Value);
typedef VOID  (*PFNCPUSETINSTRUCTIONPOINTER)(ULONG Value);
typedef VOID  (*PFNCPUSETFLOATINGPOINT)(VOID);

typedef NTSTATUS (*PFNCPUSUSPENDTHREAD)( IN HANDLE ThreadHandle, IN HANDLE ProcessHandle, IN PTEB Teb, OUT PULONG PreviousSuspendCount OPTIONAL);

typedef NTSTATUS (*PFNCPUGETCONTEXT)( IN HANDLE ThreadHandle, IN HANDLE ProcessHandle, IN PTEB Teb, OUT PCONTEXT32 Context);

typedef NTSTATUS (*PFNCPUSETCONTEXT)( IN HANDLE ThreadHandle, IN HANDLE ProcessHandle, IN PTEB Teb, PCONTEXT32 Context);

//
// Need the entry point names as well
// This is what needs to be exported from the binary translation dll
// The LdrGetProcedureAddress() uses Ansi, so these are ansi too
//
// NOTE: the order of these strings must match the order
// of the corresponding functions in the _bintrans structure below
//
PUCHAR BtImportList[] = {
    "BTCpuProcessInit",
    "BTCpuProcessTerm",
    "BTCpuThreadInit",
    "BTCpuThreadTerm",
    "BTCpuSimulate",
    "BTCpuGetStackPointer",
    "BTCpuSetStackPointer",
    "BTCpuSetInstructionPointer",
    "BTCpuResetFloatingPoint",
    "BTCpuSuspendThread",
    "BTCpuGetContext",
    "BTCpuSetContext",
    "BTCpuResetToConsistentState",
    "BTCpuFlushInstructionCache",
    "BTCpuNotifyDllLoad",
    "BTCpuNotifyDllUnload"
};

//
// NOTE: The order of entries in this structure MUST match the
// order of entries listed above. This structure gets cast
// into a PVOID struction to be filled in and we iterate though the
// names above to do it...
//
typedef struct _bintrans {
    PFNCPUPROCESSINIT           BtProcessInit;
    PFNCPUPROCESSTERM           BtProcessTerm;
    PFNCPUTHREADINIT            BtThreadInit;
    PFNCPUTHREADTERM            BtThreadTerm;

    PFNCPUSIMULATE              BtSimulate;

    PFNCPUGETSTACKPOINTER       BtGetStack;
    PFNCPUSETSTACKPOINTER       BtSetStack;
    PFNCPUSETINSTRUCTIONPOINTER BtSetEip;
    PFNCPUSETFLOATINGPOINT      BtResetFP;

    PFNCPUSUSPENDTHREAD         BtSuspend;
    PFNCPUGETCONTEXT            BtGetContext;
    PFNCPUSETCONTEXT            BtSetContext;

    PFNCPURESETTOCONSISTENTSTATE BtReset;

    PFNCPUFLUSHINSTRUCTIONCACHE BtFlush;
    PFNCPUNOTIFYDLLLOAD         BtDllLoad;
    PFNCPUNOTIFYDLLUNLOAD       BtDllUnload;

} BINTRANS;


//
// The binary translator is enabled by a key in the registry
// The key is in HKLM, and there are subkeys for enabling (1)
//
// No subkey area and/or no enable key means don't use the binary translator.
//
// The path must be specified and is used to load the dll. Thus, the dll can
// actually have any name as long as the path is right and the export list
// is correct.
//
// Individual apps can be listed here with a DWORD subkey. A
// value of 1 says use btrans, and a value of 0 says don't. No value says
// use the global enable/disable to decide
//
// 
//
#define BTKEY_SUBKEY L"Software\\Microsoft\\Wow64\\Bintrans"

#define BTKEY_MACHINE_SUBKEY    L"\\Registry\\Machine\\Software\\Microsoft\\Wow64\\Bintrans"
#define BTKEY_ENABLE    L"Enable"
#define BTKEY_PATH      L"Path"


#ifdef __cplusplus
}
#endif

#endif  //_BINTRANS_INCLUDE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\cpu\ia64\cpu\ia64\simulate.s ===
//++
//
// Copyright (c) 1998  Microsoft Corporation
//
// Module Name:
//
//    simulate.s
//
// Abstract:
//
//    This module implements calls from 64-bit code to 32-bit.
//    Much of this was lifted from the IA64 port of Wx86 on IA64 NT4.
//    (Thanks Charles!)
//
// Author:
//
//    Barry Bond (barrybo)  5-June-98
//
// Environment:
//
//    User-mode.
//
// Revision History:
//
//--

#include "ksia64.h"

// See cpumain.c CpuThreadInit if you change this!!!
#define OFFSET_FloatScratch 944

        .file       "simulate.s"
         
//++
//
//RunSimulatedCode
//
// Routine Description:
//
//     Run simulation of 32-bit code.  Returns when the simulated code makes
//     an API call.
//
// Arguments:
//
//     in0 = pGdtDescriptor   - start of descriptors to use for the call
//
// Return Value:
//
//     None.  pContext updated.
//
//--

        NESTED_ENTRY(RunSimulatedCode)
        NESTED_SETUP(1, 9, 0, 0)
        //
        // Reminder - NESTED_ENTRY and NESTED_SETUP use loc0 and loc1
        // to save away the ar.pfs and ar.rp...
        //

        //
        // For SEH, need to do a call, so save things
        //
        // Register cleanup is handled via the alternate entry point
        // (on return from ia32 execution)
        //
        // The assembler automatically creates SEH info for most mov's that 
        // are done in the prologue
        //

        mov     loc5 = pr
        mov     loc2 = ar.lc
        mov     loc4 = ar.fpsr
        mov     loc6 = teb
        mov     loc7 = gp

        //
        // Force the assembler to view this as a variable sized frame
        //
        .vframe loc3
        mov     loc3 = sp
        ;;

        //
        // And we need to save the float registers f16-f31 as well
        // Toss them on the memory stack...
        //
        // Done this way in the hopes the assembler will be able to
        // create the appropriate SEH for fp spills relative to the memory
        // stack...
        //

        //
        // Create space for the spill of the floating point registers
        // Saving 16 fp registers (each taking 16 bytes), plus the required
        // extra 16 bytes for a standard procedure call
        //
        adds    sp = -((16 * 16) + 16), sp
        ;;
        add     r31 = 16, sp            // Skip over the proc call dead space
        add     r30 = 32, sp
        ;;

        stf.spill [r31] = f16, 32       // Everything stays 16-byte aligned
        stf.spill [r30] = f17, 32
        ;;

        stf.spill [r31] = f18, 32
        stf.spill [r30] = f19, 32
        ;;

        stf.spill [r31] = f20, 32
        stf.spill [r30] = f21, 32
        ;;

        stf.spill [r31] = f22, 32
        stf.spill [r30] = f23, 32
        ;;

        stf.spill [r31] = f24, 32
        stf.spill [r30] = f25, 32
        ;;

        stf.spill [r31] = f26, 32
        stf.spill [r30] = f27, 32
        ;;

        stf.spill [r31] = f28, 32
        stf.spill [r30] = f29, 32
        ;;

        stf.spill [r31] = f30, 32
        stf.spill [r30] = f31
        ;;

        //
        // At this point r31 should equal the original sp...
        // Where's that assembly ASSERT() when you need it?
        //

        PROLOGUE_END

        //
        // r23 is not used during setup of the iVE, so pass the GDT info
        // via that register. It will be trashed by iVE execution,but
        // we don't need it again after we setup the ia32 registers
        //
        // The ia32 context is pointerd to by TLS[1] and the floating
        // point scratch area is pointed to by TLS[6]
        //
        // Ideally we would use preserved registers for these two arguments
        // and pass them in to this routine to be saved (avoiding sideband args)
        // Not only would it be better coding style, but it would be faster
        // too. Alas, exception handling and preserved registers is not
        // well understood by me yet, so do it this way and go for
        // performance later on...
        //
        mov     r23 = in0
        ;;

        br.call.sptk b0 = ProcessUserIA
        ;;

        mov     ar.fpsr = loc4
        mov     ar.lc = loc2
        mov     teb = loc6
        mov     gp = loc7
        mov     pr = loc5, -1

        //
        // sp should be OK based on ProcessUserIA doing a save/restore
        // of sp in the TLS area
        //
        add     r31 = 16, sp           // Prepare for refilling of preserved fp
        add     r30 = 32, sp
        ;;

        ldf.fill f16 = [r31], 32      // Skip over saves done by r30...
        ldf.fill f17 = [r30], 32      // Skip over saves done by r31
        ;;

        ldf.fill f18 = [r31], 32
        ldf.fill f19 = [r30], 32
        ;;

        ldf.fill f20 = [r31], 32
        ldf.fill f21 = [r30], 32
        ;;

        ldf.fill f22 = [r31], 32
        ldf.fill f23 = [r30], 32
        ;;

        ldf.fill f24 = [r31], 32
        ldf.fill f25 = [r30], 32
        ;;

        ldf.fill f26 = [r31], 32
        ldf.fill f27 = [r30], 32
        ;;

        ldf.fill f28 = [r31], 32
        ldf.fill f29 = [r30], 32
        ;;

        ldf.fill f30 = [r31], 32
        ldf.fill f31 = [r30]
        ;;

        // Once again, r31 should equal the old sp at this point...

        // The safe way of making sure we put the stack back where it belongs
        mov sp = loc3

        //
        // r8 (return register) is pointing to address after jmpe instruction
        //
        NESTED_RETURN
        NESTED_EXIT(RunSimulatedCode)

//++
//
//ProcessUserIA
//
// Routine Description:
//
//     Make the mode transitions to and from IA32.
//     an API call.
//
// Arguments:
//
//     TLS[1] = pContext    - 32-bit CONTEXT to use for the call
//     TLS[6] = FXSAVE area - Location of fp registers to load/store
//                            ideally we would use s0 for these two
//     r23 = pGdtDescriptor - address of GDT descriptor (others follow it in memory)
//
// Return Value:
//
//     None.  pContext updated.
//
// Notes:
//
//     RunSimulatedCode has preserved all EM registers that will be
//     destroyed by the br.ia.
//
//--
        LEAF_ENTRY(ProcessUserIA)
        LEAF_SETUP(0,96,0,0)
        PROLOGUE_END

        // Address of TLS[1]
        add  r19 = TeDeallocationStack + 8 + (1 * 8), teb

        // Address of TLS[6]
        add  r22 = TeDeallocationStack + 8 + (6 * 8), teb
        ;;

        // Get the contents of TLS[0] - pointer to CPUCONTEXT
        ld8  r19 = [r19]

        // Get the contents of TLS[6] - pointer to ExtendedRegisters[0]
        ld8  r22 = [r22]

        //
        // Load iA state for iVE. Since working with flat 32 in NT,
        // much of the state is a constant
        //
        movl r16 = (_DataSelector << 48) | (_FsSelector << 32) | (_DataSelector << 16) | _DataSelector
        movl r17 = (_LdtSelector << 32) | (_DataSelector << 16) | _CodeSelector
        ;;

        //
        //  load up descriptor registers
        //
        ld8    r31   = [r23], 8     // load GDT Descriptor registers
        ;;
        ld8    r30   = [r23], 8     // LDT Descriptor is 8 bytes after
        ;;
        ld8    r28    = [r23]       // FS Descriptor is 8 bytes after

        //
        // Since CSD and SSD are in AR registers and since they are saved
        // on context switches, dont need to reload them...
        // SSD and CSD are in ar26 and ar25 respectively
        //
        // DSD and ESD are the same as SSD, technically GSD can be ignored
        //
        mov r24    =   rSSD         // ES Descriptor
        mov r27    =   rSSD         // DS Descriptor
        mov r29    =   rSSD         // GS Descriptor
        ;;


        //
        // Now fill in the regular registers based on the context passed in
        // including ESP and EIP
        //
        // Given Merced can only send out 2 memory ops on the bus at one time,
        // and we're doing three or four ops per stop bit, 
        // this code is not optimized for speed...
        //
        add r23 = 160, r19              // Edi is 160 bytes into CPUCONTEXT
                                        // (with 4 byte padding before CONTEST32) 
        add r32 = 160, r22              // Location of XMMI (low) in FXSAVE
        add r33 = 176, r22              // Location of XMMI (high) in FXSAVE
        add r34 = 32, r22               // Location of st[0] in FXSAVE format
                                        // And r22 points to the fp control
        ;;

        ld2 r39 = [r22], 2              // Get Control Word (fcw)
        ld4 r15 = [r23], 4              // Start copying the int registers (edi)
        ;;

        ld2 r40 = [r22], 2              // Get Status Word (fsw)
        ld4 r14 = [r23], 4              // esi
        ld8 r35 = [r32], 32             // Get low mantissa
        ld8 r36 = [r33], 32             // Get high mantissa
        ;;

        ld2 r41 = [r22], 4              // Tag Word (ftw) (and jump over fop)
        ld4 r11 = [r23], 4              // ebx
        ldfe f8 = [r34], 16             // Load the 387 registers - st[0]
        setf.sig f16 = r35              // low is on the even regs
        setf.sig f17 = r36              // high is on the odd regs
        ld8 r37 = [r32], 32
        ld8 r38 = [r33], 32
        ;;

        ld8 r20 = [r22], 8              // Get all of fir
        ld4 r10 = [r23], 4              // edx
        ldfe f9 = [r34], 16             // Now st[1]
        setf.sig f18 = r37
        setf.sig f19 = r38
        ld8 r35 = [r32], 32
        ld8 r36 = [r33], 32
        ;;

        ld8 r3 = [r22], 8               // Get all of fdr
        dep r44 = r41, r40, 16, 16      // Put tag in the second 16 bits
        mov ia32fir = r20               // Put fir in the proper place
        ld4 r9 = [r23], 4               // ecx
        ldfe f10 = [r34], 16            // Now st[2]
        setf.sig f20 = r35
        setf.sig f21 = r36
        ld8 r37 = [r32], 32
        ld8 r38 = [r33], 32
        ;;

        ld2 r42 = [r22]                 // Get MXCSR
        mov ia32fdr = r3                // Put fdr in the proper place
        ld4 r8 = [r23], 4               // eax
        ldfe f11 = [r34], 16            // Now st[3]
        setf.sig f22 = r37              // low side of xmmi
        setf.sig f23 = r38              // high side of xmmi
        ld8 r35 = [r32], 32             // Get even mantissa
        ld8 r36 = [r33], 32             // Get odd mantissa

        //
        // Get the address of TEB64 TLS entry 0
        // so we can save the ia64 stack pointer
        // Note: teb is r13 which is also rBP... Make sure
        // we do this math before trashing r13!
        //
        add  r19 = TeDeallocationStack+8 + (0 * 8), teb
        ;;

        dep r47 = r42, r44, 32, 6       // Put the MXCSR status in fsw
        extr.u r45 = r42, 7, 9          // Get the bits for the control word
        ld4 r13 = [r23], 4              // ebp *NOTE* trahes ia64 teb pointer
        ldfe f12 = [r34], 16            // Now st[4]
        setf.sig f24 = r35              // low side of xmmi
        setf.sig f25 = r36              // high side of xmmi
        ld8 r37 = [r32], 32             // Get even mantissa
        ld8 r38 = [r33], 32             // Get odd mantissa
        ;;

        dep r46 = r45, r39, 39, 9       // Put in the MXCSR control word
        mov ia32fsr = r47               // And store status and tag and mscxr
        ld4 r2 = [r23], 8               // Get the EIP and skip to the EFlags
        ldfe f13 = [r34], 16            // Now st[5]
        setf.sig f26 = r37              // low side of xmmi
        setf.sig f27 = r38              // high side of xmmi
        ld8 r35 = [r32], 32             // Get even mantissa
        ld8 r36 = [r33], 32             // Get odd mantissa
        ;;

        mov ia32fcr = r46               // Put fcw in the proper place
        mov r18 = sp                    // Hang onto the ia64 stack pointer
        ld4 r3 = [r23], 4               // Get Eflags
        ldfe f14 = [r34], 16            // Now st[6]
        setf.sig f28 = r35              // low side of xmmi
        setf.sig f29 = r36              // high side of xmmi
        ld8 r37 = [r32], 32             // Get even mantissa
        ld8 r38 = [r33], 32             // Get odd mantissa
        ;;

        ld4 sp = [r23]                  // esp
        ldfe f15 = [r34]                // Now st[7]
        setf.sig f30 = r37              // low side of xmmi
        setf.sig f31 = r38              // high side of xmmi

        //
        // Put the eflags value in the right register
        //
        mov ia32eflag = r3
        ;;

        //
        // The eas says we should flushrs one cycle before the br.ia... So...
        //
        flushrs
    	
        //
        // Get the branch address (saved in r2 above)
        //
        mov b7 = r2

        //
        // Store the old sp into the tls. This is used as a flag for the
        // exception handler to indicate we are running on the ia32 stack
        // and will be force-fed into the dispatch for CpuReset() call...
        //
        st8 [r19] = r18
        ;;

        br.ia.sptk   b7
        ;;
    	
        //
        // The jmpe from IA code needs to get back here to
        // properly uncover the stack.  
        //
        .align 16

        ALTERNATE_ENTRY(ReturnFromSimulatedCode)

        mov r20 = kteb
        ;;

        // Address of TLS[1]
        add  r19 = TeDeallocationStack + 8 + (1 * 8), r20

        // Address of TLS[6]
        add  r22 = TeDeallocationStack + 8 + (6 * 8), r20
        ;;

        // Get the contents of TLS[1] - the pointer to the CPUCONTEXT structure
        ld8  r19 = [r19]

        // Get the contents of TLS[6] - pointer to ExtendedRegisters[0]
        ld8  r22 = [r22]
        ;;

        //
        // Do we need to preserve any of the ia32 floating point registers?
        // Depends on the ia32 software convention... Are floats saved
        // across calls?
        //
        mov r3 = ia32eflag              // get eflags
        add r23 = 160, r19              // Edi is 160 bytes in (see above)
        add r18 = 32, r22               // st[0] is 32 bytes into FXSAVE area
                                        // r16/r17 are descriptors. We don't
                                        // save them, so use them
        add r16 = 160, r22              // Get the the XMMI even regs
        add r17 = 176, r22              // Get the the XMMI odd regs 
                                        // And r22 points to the fp control
        ;;

        mov r19 = ia32fsr               // Get fsr (and tag)
        mov r20 = ia32fcr               // Get fcr
        mov r2 = ia32fir                // Get the fir
        ;;

        st2 [r22] = r20, 2              // Save the control register
        extr.u r21 = r19, 16, 16        // Get the tag bits
        st4 [r23] = r15, 4              // So start copying back edi
        extr.u r24 = r19, 32, 6         // r24 isn't saved. Get mxcsr status
        extr.u r25 = r20, 39, 9         // r25 isn't saved. Get mxcsr control
        ;;

        st2 [r22] = r19, 2              // Save the fsr
        mov r20 = ia32fdr               // Get the fdr
        shl r15 = r25, 7                // Create space for the mxcsr status
        st4 [r23] = r14, 4              // esi

        getf.sig r28 = f16              // r28 isn't saved. get xmmi low
        getf.sig r29 = f17              // r29 isn't saved. get xmmi high
        ;;

        st2 [r22] = r21, 4              // Save the tag
        st4 [r23] = r11, 4              // ebx
        dep r25 = r24, r15, 0, 7        // Create mxcsr word

        stfe [r18] = f8, 16             // and save the fp registers
        st8 [r16] = r28, 32             // and save the xmmi low
        st8 [r17] = r29, 32             // and save the xmmi high
        getf.sig r30 = f18              // r30 isn't saved. get xmmi low
        getf.sig r31 = f19              // r31 isn't saved. get xmmi high
        ;;

        st8 [r22] = r2, 8               // Save fir
        st4 [r23] = r10, 4              // edx

        stfe [r18] = f9, 16
        st8 [r16] = r30, 32             // and save the xmmi low
        st8 [r17] = r31, 32             // and save the xmmi high
        getf.sig r28 = f20              // get xmmi low
        getf.sig r29 = f21              // get xmmi high
        ;;

        //
        // Get the return address from the ia32 stack and hang onto it
        // Add 4 to ESP while we're at it so the ia32 stack is pointing
        // after the return address
        //
        ld4 r2 = [rEsp], 4
        st4 [r23] = r9, 4               // ecx
        st8 [r22] = r20, 8              // Save fdr

        stfe [r18] = f10, 16
        st8 [r16] = r28, 32             // and save the xmmi low
        st8 [r17] = r29, 32             // and save the xmmi high
        getf.sig r30 = f22              // get xmmi low
        getf.sig r31 = f23              // get xmmi high
        ;;

        st4 [r23] = r8, 4               // eax
        st4 [r22] = r25                 // Save away the mxcsr

        stfe [r18] = f11, 16
        st8 [r16] = r30, 32             // and save the xmmi low
        st8 [r17] = r31, 32             // and save the xmmi high
        getf.sig r28 = f24              // get xmmi low
        getf.sig r29 = f25              // get xmmi high
        ;;

        st4 [r23] = r13, 4              // ebp

        stfe [r18] = f12, 16
        st8 [r16] = r28, 32             // and save the xmmi low
        st8 [r17] = r29, 32             // and save the xmmi high
        getf.sig r30 = f26              // get xmmi low
        getf.sig r31 = f27              // get xmmi high
        ;;

        mov teb = kteb                  // The teb is r13 which is also ebp
        st4 [r23] = r2, 8               // Store return addr as new EIP

        stfe [r18] = f13, 16
        st8 [r16] = r30, 32             // and save the xmmi low
        st8 [r17] = r31, 32             // and save the xmmi high
        getf.sig r28 = f28              // get xmmi low
        getf.sig r29 = f29              // get xmmi high
        ;;

        // Address of TLS[0]
        add  r19 = TeDeallocationStack+8 + (0 * 8), teb
        st4 [r23] = r3, 4               // Store the eflags

        stfe [r18] = f14, 16
        st8 [r16] = r28, 32             // and save the xmmi low
        st8 [r17] = r29, 32             // and save the xmmi high
        getf.sig r30 = f30              // get xmmi low
        getf.sig r31 = f31              // get xmmi high
        ;;

        ld8 r20 = [r19]                 // Get the old stack
        st4 [r23] = rEsp

        stfe [r18] = f15
        st8 [r16] = r30                 // and save the xmmi low
        st8 [r17] = r31                 // and save the xmmi high

        //
        // Make the return value from this function be the address
        // after the jmpe
        //
        mov r8 = r1
        ;;

        //
        // Put back the saved stack value
        //
        mov sp = r20

        //
        // And set the flag that says we don't need to swap stacks in
        // case of an exception
        //
        st8 [r19] = r0
        ;;

        LEAF_RETURN
        LEAF_EXIT(ProcessUserIA)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\cpu\ia64\cpu\cpumain.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    cpumain.c

Abstract:

    Main entrypoints for IA64 wow64cpu.dll using the iVE for emulation

Author:

    05-June-1998 BarryBo

Revision History:

    9-Aug-1999 [askhalid] added CpuNotifyDllLoad and CpuNotifyDllUnload

--*/

#define _WOW64CPUAPI_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntosp.h>
#include <kxia64.h>
#include "wow64.h"
#include "wow64cpu.h"
#include "ia64cpu.h"
#include "ia64bt.h"

ASSERTNAME;


extern ULONG_PTR ia32ShowContext;

BINTRANS BtFuncs;

//
// These are to help recover the 64-bit context when an exception happens in
// the 64-bit land and there is no debugger attached initially
//
EXCEPTION_RECORD RecoverException64;
CONTEXT RecoverContext64;

#define DECLARE_CPU         \
    PCPUCONTEXT cpu = (PCPUCONTEXT)Wow64TlsGetValue(WOW64_TLS_CPURESERVED)

// Declarations for things in *\simulate.s
extern VOID RunSimulatedCode(PULONGLONG pGdtDescriptor);
extern VOID ReturnFromSimulatedCode(VOID);

// 6 bytes is enough for JMPE+absolute32
UCHAR IA32ReturnFromSimulatedCode[6];

VOID
InitializeGdtEntry (
    OUT PKGDTENTRY GdtEntry,
    IN ULONG Base,
    IN ULONG Limit,
    IN USHORT Type,
    IN USHORT Dpl,
    IN USHORT Granularity
    );

VOID
InitializeXDescriptor (
    OUT PKXDESCRIPTOR Descriptor,
    IN ULONG Base,
    IN ULONG Limit,
    IN USHORT Type,
    IN USHORT Dpl,
    IN USHORT Granularity
    );

VOID
CpupPrintContext (
    IN PCHAR str,
    IN PCPUCONTEXT cpu
    );

VOID
CpupCheckHistoryKey (
    IN PWSTR pImageName,
    OUT PULONG pHistoryLength
    );

VOID
BTCheckRegistry(
    IN PWSTR pImageName
    )
/*++

Routine Description:

    Check if the registry says to use the binary translation dll. If the
    binary translation code is to be used, this function will fill in the
    BtFuncs structure.  That structure will either have all entry points
    filled in, or it will all be NULL. This is required as the regular
    CPU code will call based on NULL or non-NULL for each entry.

Arguments:

    pImageName - the name of the image. DO NOT SAVE THIS POINTER. The contents
                 are freed up by wow64.dll when we return from the call

Return Value:

    None.

--*/
{
    UNICODE_STRING KeyName;
    OBJECT_ATTRIBUTES ObjA;

    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    WCHAR Buffer[400];
    ULONG ResultLength;

    NTSTATUS st;

    HANDLE hKey = NULL;                 // non-null means we have an open key
    PVOID DllBase = NULL;               // non-null means we have a dll loaded

    ULONG clearBtFuncs = TRUE;          // Assume we need to clear func array
    ULONG tryDll = FALSE;               // Assume no dll available
    
    LOGPRINT((TRACELOG, "BTCheckRegistry(%ws) called.\n", pImageName));

    LOGPRINT((TRACELOG, "&(BtImportList[0]) is %p, &BtFuncs is %p\n", &(BtImportList[0]), &BtFuncs));
    LOGPRINT((TRACELOG, "sizeof(BtImportList) is %d, sizeof(BtFuncs) is %d\n", sizeof(BtImportList), sizeof(BtFuncs)));

    //
    // BtImportList has pointers to strings for entry points
    // BtFuncs has pointers to pointers for the actual entry point
    // Thus, they should be the same size (since they both
    // contain pointers)
    //
    ASSERT(sizeof(BtImportList) == sizeof(BtFuncs));

    if (sizeof(BtImportList) != sizeof(BtFuncs)) {
        //
        // Oops, something wrong with structures in ia64bt.h
        // Don't try and call the binary translator
        //
        LOGPRINT((ERRORLOG, "BTCheckRegistry exit due to struct size mismatch.\n"));
        goto cleanup;
    }

    //
    // Check in the HKLM area, save checking HKCU first for another time
    //
    RtlInitUnicodeString(&KeyName, BTKEY_MACHINE_SUBKEY);
    InitializeObjectAttributes(&ObjA, &KeyName, OBJ_CASE_INSENSITIVE, NULL, NULL);
    st = NtOpenKey(&hKey, KEY_READ, &ObjA);

    if (NT_SUCCESS(st)) {
        //
        // Have subkey path, now look for specific values
        // First the program name, then the generic enable/disable key
        // the program name key takes priority if it exists
        //
        RtlInitUnicodeString(&KeyName, pImageName);
        KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)Buffer;
        st = NtQueryValueKey(hKey,
                             &KeyName,
                             KeyValuePartialInformation,
                             KeyValueInformation,
                             sizeof(Buffer),
                             &ResultLength);
        if (NT_SUCCESS(st)) {
            //
            // Found something, so either yes/no. Don't check generic enable
            //
            if (KeyValueInformation->Type == REG_DWORD &&
                *(DWORD *)(KeyValueInformation->Data)) {
                // Is enabled, so fall through to the Path check
                LOGPRINT((TRACELOG, "BTCheckRegistry found process key\n"));
            }
            else {
                // Is not enabled, so we are done
                LOGPRINT((TRACELOG, "BTCheckRegistry exit due to PROCESS name entry is disabled in registry\n"));
                goto cleanup;
            }
        }
        else {
            //
            // No program name, so now search for the generic enable
            //
            RtlInitUnicodeString(&KeyName, BTKEY_ENABLE);
            KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)Buffer;
            st = NtQueryValueKey(hKey,
                                 &KeyName,
                                 KeyValuePartialInformation,
                                 KeyValueInformation,
                                 sizeof(Buffer),
                                 &ResultLength);
            if (NT_SUCCESS(st) &&
                KeyValueInformation->Type == REG_DWORD &&
                *(DWORD *)(KeyValueInformation->Data)) {
                    // Generic enable so fall though to the path check
                LOGPRINT((TRACELOG, "BTCheckRegistry found generic enable key\n"));
            }
            else {
                LOGPRINT((TRACELOG, "BTCheckRegistry exit due to missing or disabled ENABLE entry in registry\n"));
                goto cleanup;
            }
        }

        //
        // Found an enable key, now get the dll name/path
        //

        RtlInitUnicodeString(&KeyName, BTKEY_PATH);
        KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)Buffer;
        st = NtQueryValueKey(hKey,
                                 &KeyName,
                                 KeyValuePartialInformation,
                                 KeyValueInformation,
                                 sizeof(Buffer),
                                 &ResultLength);
        if (NT_SUCCESS(st) && (KeyValueInformation->Type == REG_SZ)) {
            //
            // Ok, we have a path, lets try and open the dll
            // We are done with the registry for now...
            //
            LOGPRINT((TRACELOG, "BTCheckRegistry found path key (%p)\n", &(KeyValueInformation->Data)));
            tryDll = TRUE;
        }
        else {
            LOGPRINT((TRACELOG, "BTCheckRegistry exit due to missing or invalid PATH entry in registry\n"));
        }
    }
    else {
        LOGPRINT((TRACELOG, "BTCheckRegistry exit due to no registry subkeys\n"));
        hKey = NULL;
    }

    if (tryDll) {
        UNICODE_STRING DllName;
        ANSI_STRING ProcName;
        INT i, NumImports;

        PVOID *pFuncWalk;
        PUCHAR pImportWalk;

        //
        // path should be in KeyValueInformation (data area) which should still
        // be available from above, open the dll and grab the exports
        // if there is anything that goes wrong here, close it
        // up and assume no binary translator
        //
        
        RtlInitUnicodeString(&DllName, (PWSTR) &(KeyValueInformation->Data));
        st = LdrLoadDll(NULL, NULL, &DllName, &DllBase);

        if (NT_SUCCESS(st)) {

            NumImports = sizeof(BtImportList) / sizeof(CHAR *);
            pFuncWalk = (PVOID *) &BtFuncs;

            for (i = 0; i < NumImports; i++) {
                //
                // Get the entry points
                //
                pImportWalk = BtImportList[i];
                RtlInitAnsiString(&ProcName, pImportWalk);
                st = LdrGetProcedureAddress(DllBase,
                                                  &ProcName,
                                                  0,
                                                  pFuncWalk);
        
                if (!NT_SUCCESS(st) || !pFuncWalk) {
                    LOGPRINT((TRACELOG, "BTCheckRegistry exit due to missing entry point (%p <%s>) in bintrans dll\n", pImportWalk, pImportWalk));
                    goto cleanup;
                }
                pFuncWalk++;
            }

            //
            // Made it through the for loop, so I guess this means we have
            // an entry for each one
            //
            clearBtFuncs = FALSE;
        }
        else {
            LOGPRINT((TRACELOG, "BTCheckRegistry exit due to can't load bintrans dll\n"));
        }
    }

cleanup:
    if (hKey) {
        NtClose(hKey);
    }

    if (clearBtFuncs) {
        //
        // Make sure the wow64cpu procedures don't try to use a partial
        // binary translation dll. All or nothing - give them nothing...
        //
        RtlZeroMemory(&BtFuncs, sizeof(BtFuncs));

        if (tryDll && DllBase) {
            // Unload the dll since we are not using it
        }
    }
}


WOW64CPUAPI
NTSTATUS
CpuProcessInit(
    PWSTR   pImageName,
    PSIZE_T pCpuThreadSize
    )
/*++

Routine Description:

    Per-process initialization code

Arguments:

    pImageName       - IN pointer to the name of the image
    pCpuThreadSize   - OUT ptr to number of bytes of memory the CPU
                       wants allocated for each thread.

Return Value:

    NTSTATUS.

--*/
{
    PVOID pv;
    NTSTATUS Status;
    SIZE_T Size;
    ULONG OldProtect;

    
    //
    // Indicate that this is Microsoft CPU
    //
    Wow64GetSharedInfo()->CpuFlags = 'sm';

    //
    // On process init, see if we should be calling the bintrans code
    // do this by checking for a specific registry key
    //

    // do registry check
    // need to pass the image name for a per-process check
    BTCheckRegistry(pImageName);

    if (BtFuncs.BtProcessInit) {
        Status = (BtFuncs.BtProcessInit)(pImageName, pCpuThreadSize);
        if (NT_SUCCESS(Status)) {
            return Status;
        }
        else {
            //
            // The binary translator failed, let the iVE try
            // and make sure we don't call the binary translator again
            //
            LOGPRINT((TRACELOG, "CpuProcessInit(): BtProcessInit returned 0x%x. Trying the iVE.\n", Status));

            RtlZeroMemory(&BtFuncs, sizeof(BtFuncs));
        }
    }

#if defined(WOW64_HISTORY)
    //
    // See if we are keeping a history of the service calls
    // for this process. A length of 0 means no history.
    //
    CpupCheckHistoryKey(pImageName, &HistoryLength);

    
    //
    // Allow us to make sure the cpu thread data is 16-byte aligned
    //
    *pCpuThreadSize = sizeof(CPUCONTEXT) + 16 + (HistoryLength * sizeof(WOW64SERVICE_BUF));

#else

    *pCpuThreadSize = sizeof(CPUCONTEXT) + 16;

#endif

    LOGPRINT((TRACELOG, "CpuProcessInit() sizeof(CPUCONTEXT) is %d, total size is %d\n", sizeof(CPUCONTEXT), *pCpuThreadSize));


    IA32ReturnFromSimulatedCode[0] = 0x0f;    // JMPE relative (1st byte)
    IA32ReturnFromSimulatedCode[1] = 0xb8;    // JMPE          (2nd byte)
    *(PULONG)&IA32ReturnFromSimulatedCode[2] =
        (ULONG)(((PPLABEL_DESCRIPTOR)ReturnFromSimulatedCode)->EntryPoint);

    pv = (PVOID)IA32ReturnFromSimulatedCode;
    Size = sizeof(IA32ReturnFromSimulatedCode);
    Status = NtProtectVirtualMemory(NtCurrentProcess(),
                                    &pv,
                                    &Size,
                                    PAGE_EXECUTE_READWRITE,
                                    &OldProtect);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    return STATUS_SUCCESS;
}


WOW64CPUAPI
NTSTATUS
CpuProcessTerm(
    HANDLE ProcessHandle
    )
/*++

Routine Description:

    Per-process termination code.  Note that this routine may not be called,
    especially if the process is terminated by another process.

Arguments:

    ProcessHandle - The handle of the process being terminated

Return Value:

    NTSTATUS.

--*/
{
    if (BtFuncs.BtProcessTerm) {
        return (BtFuncs.BtProcessTerm)(ProcessHandle);
    }

    return STATUS_SUCCESS;
}


WOW64CPUAPI
NTSTATUS
CpuThreadInit(
    PVOID pPerThreadData
    )
/*++

Routine Description:

    Per-thread termination code.

Arguments:

    pPerThreadData  - Pointer to zero-filled per-thread data with the
                      size returned from CpuProcessInit.

Return Value:

    NTSTATUS.

--*/
{
    PUCHAR Gdt;
    PCPUCONTEXT cpu;
    PTEB32 Teb32 = NtCurrentTeb32();
    PFXSAVE_FORMAT_WX86 xmmi;

    if (BtFuncs.BtThreadInit) {
        return (BtFuncs.BtThreadInit)(pPerThreadData);
    }

    //
    // The ExtendedRegisters array is used to save/restore the floating
    // pointer registers between ia32 and ia64. Alas, this structure
    // has an offset of 0x0c in the ia32 CONTEXT record. There are
    // two ways to clean this up. (1) Put padding in the CPUCONTEXT of
    // wow64. (2) Just put the CPUCONTEXT structure on a 0x04 aligned boundary
    // The choice made was to go with (1) and add padding to the
    // CPUCONTEXT structure. Don't forget to pack(4) that puppy...
    //
    cpu = (PCPUCONTEXT) ((((UINT_PTR) pPerThreadData) + 15) & ~0xfi64);

    // For the ISA transition routine, floats are saved in the
    // ExtendedRegisters area. Make it easy to access.
    //
    xmmi = (PFXSAVE_FORMAT_WX86) &(cpu->Context.ExtendedRegisters[0]);


    //
    // This entry is used by the ISA transition routine. It is assumed
    // that the first entry in the cpu structure is the ia32 context record
    //
    Wow64TlsSetValue(WOW64_TLS_CPURESERVED, cpu);

    //
    // This tls entry is used by the transition routine. The transition
    // routine only works with the FXSAVE format. This points to that
    // structure in the x86 context.
    //
    Wow64TlsSetValue(WOW64_TLS_EXTENDED_FLOAT, xmmi);

#if defined(WOW64_HISTORY)
    //
    // Init the pointer to the service history area
    //
    if (HistoryLength) {
        Wow64TlsSetValue(WOW64_TLS_LASTWOWCALL, &(cpu->Wow64Service[0]));
    } 
#endif

    //
    // When we have the iVE, we have hardware to do unaligned
    // accesses. So, enable the hardware... (psr.ac is a per-thread resource)
    //
    __rum (1i64 << PSR_AC);

    //
    // Initialize the 32-to-64 function pointer.
    //
    Teb32->WOW32Reserved = PtrToUlong(IA32ReturnFromSimulatedCode);

    //
    // Initialize the remaining nonzero CPU fields
    // (Based on ntos\ke\i386\thredini.c and ntos\rtl\i386\context.c)
    //
    cpu->Context.SegCs=KGDT_R3_CODE|3;
    cpu->Context.SegDs=KGDT_R3_DATA|3;
    cpu->Context.SegEs=KGDT_R3_DATA|3;
    cpu->Context.SegSs=KGDT_R3_DATA|3;
    cpu->Context.SegFs=KGDT_R3_TEB|3;
    cpu->Context.EFlags=0x202;    // IF and intel-reserved set, all others clear
    cpu->Context.Esp=(ULONG)Teb32->NtTib.StackBase-sizeof(ULONG);

    //
    // The ISA transition routine only uses the extended FXSAVE area
    // These values come from ...\ke\i386\thredini.c to match the i386
    // initial values
    //
    xmmi->ControlWord = 0x27f;
    xmmi->MXCsr = 0x1f80;
    xmmi->TagWord = 0xffff;

    //
    // The ISA transisiton code assumes that Context structure is
    // 4 bytes after the pointer saved in TLS[1] (TLS_CPURESERVED)
    // This is done to make the alignment of the ExtendedRegisters[] array
    // in the CONTEXT32 structure be aligned on a 16-byte boundary.
    //
    WOWASSERT(((UINT_PTR) &(cpu->Context)) == (((UINT_PTR) cpu) + 4));
    
    //
    // Make sure this value is 16-byte aligned
    //
    WOWASSERT(((FIELD_OFFSET(CPUCONTEXT, Context) + FIELD_OFFSET(CONTEXT32, ExtendedRegisters)) & 0x0f) == 0);

    //
    // Make sure these values are 8-byte aligned
    //
    WOWASSERT((FIELD_OFFSET(CPUCONTEXT, Gdt) & 0x07) == 0);
    WOWASSERT((FIELD_OFFSET(CPUCONTEXT, GdtDescriptor) & 0x07) == 0);
    WOWASSERT((FIELD_OFFSET(CPUCONTEXT, LdtDescriptor) & 0x07) == 0);
    WOWASSERT((FIELD_OFFSET(CPUCONTEXT, FsDescriptor) & 0x07) == 0);
    

    //
    // Initialize each required Gdt entry
    //

    Gdt = (PUCHAR) &cpu->Gdt;
    InitializeGdtEntry((PKGDTENTRY)(Gdt + KGDT_R3_CODE), 0,
        (ULONG)-1, TYPE_CODE_USER, DPL_USER, GRAN_PAGE);
    InitializeGdtEntry((PKGDTENTRY)(Gdt + KGDT_R3_DATA), 0,
        (ULONG)-1, TYPE_DATA_USER, DPL_USER, GRAN_PAGE);

    //
    // Set user TEB descriptor
    //
    InitializeGdtEntry((PKGDTENTRY)(Gdt + KGDT_R3_TEB), PtrToUlong(Teb32),
        sizeof(TEB32)-1, TYPE_DATA_USER, DPL_USER, GRAN_BYTE);

    //
    // The FS descriptor for ISA transitions. This needs to be in
    // unscrambled format
    //
    InitializeXDescriptor((PKXDESCRIPTOR)&(cpu->FsDescriptor), PtrToUlong(Teb32),
        sizeof(TEB32)-1, TYPE_DATA_USER, DPL_USER, GRAN_BYTE);

    //
    // Setup ISA transition GdtDescriptor - needs to be unscrambled
    // But according to the seamless EAS, only the base and limit
    // are actually used...
    //
    InitializeXDescriptor((PKXDESCRIPTOR)&(cpu->GdtDescriptor), PtrToUlong(Gdt),
        GDT_TABLE_SIZE-1, TYPE_LDT, DPL_USER, GRAN_BYTE);

    return STATUS_SUCCESS;
}


WOW64CPUAPI
NTSTATUS
CpuThreadTerm(
    VOID
    )
/*++

Routine Description:

    Per-thread termination code.  Note that this routine may not be called,
    especially if the thread is terminated abnormally.

Arguments:

    None.

Return Value:

    NTSTATUS.

--*/
{
    if (BtFuncs.BtThreadTerm) {
        return (BtFuncs.BtThreadTerm)();
    }

    return STATUS_SUCCESS;
}


WOW64CPUAPI
VOID
CpuSimulate(
    VOID
    )
/*++

Routine Description:

    Call 32-bit code.  The CONTEXT32 has already been set up to go.

Arguments:

    None.

Return Value:

    None.  Never returns.

--*/
{
    DECLARE_CPU;

    if (BtFuncs.BtSimulate) {
        (BtFuncs.BtSimulate)();
        return;
    }

    while (1) {
        if (ia32ShowContext & LOG_CONTEXT_SYS) {
            CpupPrintContext("Before Simulate: ", cpu);
        }


        //
        // The low level ISA transition code now uses the
        // ExtendedRegister (FXSAVE) format for saving/restoring
        // of ia64 registers.  Thus there is no longer a need
        // to copy the packed-10 byte formats any longer.
        //
        // NOTE: The Get/Set routines (in suspend.c) copy to/from
        // the extended registers when doing old FP get/set. This keeps
        // the older stuff and the extended registers in sync. If code
        // bypasses the standard get/set context routines, there will
        // be a problem with floating point.
        //

        //
        // Call into 32-bit code.  This returns when a system service thunk
        // gets called.
        // cpu->Context is a passed on the side via TLS_CPURESERVED
        // It is passed on the side because it needs
        // to be preserved across ia32 transition. The TLS registers
        // are preserved, but little else is.
        //
        
        RunSimulatedCode(&cpu->GdtDescriptor);

        if (ia32ShowContext & LOG_CONTEXT_SYS) {
            CpupPrintContext("After Simulate: ", cpu);
        }

#if defined(WOW64_HISTORY)
        if (HistoryLength) {
            PWOW64SERVICE_BUF SrvPtr = (PWOW64SERVICE_BUF) Wow64TlsGetValue(WOW64_TLS_LASTWOWCALL);

            // We defined that we are always pointing to the last one, so
            // increment in preparation for the next entry
            SrvPtr++;

            if (SrvPtr > &(cpu->Wow64Service[HistoryLength - 1])) {
                SrvPtr = &(cpu->Wow64Service[0]);
            }

            SrvPtr->Api = cpu->Context.Eax;
            try {
                SrvPtr->RetAddr = *(((PULONG)cpu->Context.Esp) + 0);
                SrvPtr->Arg0 = *(((PULONG)cpu->Context.Esp) + 1);
                SrvPtr->Arg1 = *(((PULONG)cpu->Context.Esp) + 2);
                SrvPtr->Arg2 = *(((PULONG)cpu->Context.Esp) + 3);
                SrvPtr->Arg3 = *(((PULONG)cpu->Context.Esp) + 4);
            }
            except ((GetExceptionCode() == STATUS_ACCESS_VIOLATION)?1:0) {
                // Do nothing, leave the values alone
                LOGPRINT((TRACELOG, "CpuSimulate() saw excpetion while copying stack info to trace area\n"));
            }

            Wow64TlsSetValue(WOW64_TLS_LASTWOWCALL, SrvPtr);
        }
#endif      // defined(WOW64_HISTORY)

            

        //
        // Have WOW64 call the thunk
        //
        cpu->Context.Eax = Wow64SystemService(cpu->Context.Eax,
                                              &cpu->Context);
        //
        // Re-simulate.  Any/all of the 32-bit CONTEXT may have changed
        // as a result of the system service call, so assume nothing.
        //
    }
}

WOW64CPUAPI
VOID
CpuResetToConsistentState(
    PEXCEPTION_POINTERS pExceptionPointers
    )
/*++

Routine Description:

    After an exception occurs, WOW64 calls this routine to give the CPU
    a chance to clean itself up and recover the CONTEXT32 at the time of
    the fault.

    CpuResetToConsistantState() needs to:

    0) Check if the exception was from ia32 or ia64

    If exception was ia64, do nothing and return
    If exception was ia32, needs to:
    1) Needs to copy  CONTEXT eip to the TLS (WOW64_TLS_EXCEPTIONADDR)
    2) reset the CONTEXT struction to be a valid ia64 state for unwinding
        this includes:
    2a) reset CONTEXT ip to a valid ia64 ip (usually
         the destination of the jmpe)
    2b) reset CONTEXT sp to a valid ia64 sp (TLS
         entry WOW64_TLS_STACKPTR64)
    2c) reset CONTEXT gp to a valid ia64 gp 
    2d) reset CONTEXT teb to a valid ia64 teb 
    2e) reset CONTEXT psr.is  (so exception handler runs as ia64 code)


Arguments:

    pExceptionPointers  - 64-bit exception information

Return Value:

    None.

--*/
{
    DECLARE_CPU;
    PVOID StackPtr64 = Wow64TlsGetValue(WOW64_TLS_STACKPTR64);

    LOGPRINT((TRACELOG, "CpuResetToConsistantState(%p)\n", pExceptionPointers));

    if (BtFuncs.BtReset) {
        (BtFuncs.BtReset)(pExceptionPointers);
        return;
    }

    //
    // Save the last exception and context records.
    //
    memcpy (&RecoverException64,
            pExceptionPointers->ExceptionRecord,
            sizeof (RecoverException64));

    memcpy (&RecoverContext64,
            pExceptionPointers->ContextRecord,
            sizeof (RecoverContext64));

    //
    // First, clear out the WOW64_TLS_STACKPTR64 so subsequent
    // exceptions won't adjust native sp.
    //
    Wow64TlsSetValue(WOW64_TLS_STACKPTR64, 0);

    //
    // Now decide if we were running as ia32 or ia64...
    //

    if (pExceptionPointers->ContextRecord->StIPSR & (1i64 << PSR_IS)) {
        CONTEXT32 tmpCtx;

        //
        // Grovel the IA64 pExceptionPointers->ContextRecord and
        // stuff the ia32 context back into the cpu->Context.
        // For performance reasons, the PCPU context doesn't
        // follow the FXSAVE format (isa transition requirement). So
        // since the Wow64CtxFromIa64() returns a vaild ia32 context
        // need to use the SetContextRecord() routine to convert from
        // the valid ia32 context to the context used internally...
        //
        Wow64CtxFromIa64(CONTEXT32_FULLFLOAT,
                         pExceptionPointers->ContextRecord,
                         &tmpCtx);
        SetContextRecord(cpu, &tmpCtx);
        
        //
        // Now set things up so we can let the ia64 exception handler do the
        // right thing
        //

        //
        // Hang onto the actual exception address (used when we
        // pass control back to the ia32 exception handler)
        //
        Wow64TlsSetValue(WOW64_TLS_EXCEPTIONADDR, (PVOID) pExceptionPointers->ContextRecord->StIIP);

        //
        // Let the ia64 exception handler think the exception happened
        // in the CpuSimulate transition code. We do this by setting
        // the exception ip to the address pointed to by the jmpe (and the
        // corresponding GP), setting the stack to the same as it was at the
        // time of the br.ia and making sure any other ia64 "saved" registers
        // are replaced (such as the TEB)
        //
        pExceptionPointers->ContextRecord->IntSp = (ULONGLONG)StackPtr64;

         pExceptionPointers->ContextRecord->StIIP= (((PPLABEL_DESCRIPTOR)ReturnFromSimulatedCode)->EntryPoint);
        pExceptionPointers->ContextRecord->IntGp = (((PPLABEL_DESCRIPTOR)ReturnFromSimulatedCode)->GlobalPointer);

        pExceptionPointers->ContextRecord->IntTeb = (ULONGLONG) NtCurrentTeb();

        //
        // Don't forget to make the next run be an ia64 run...
        // So clear the psr.is bit (for ia64 code) and the psr.ri bit
        // (so instructions start at the first bundle).
        //
        pExceptionPointers->ContextRecord->StIPSR &= ~(1i64 << PSR_IS);
        pExceptionPointers->ContextRecord->StIPSR &= ~(3i64 << PSR_RI);

        //
        // Now that we've cleaned up the context record, let's
        // clean up the exception record too.
        //
        pExceptionPointers->ExceptionRecord->ExceptionAddress = (PVOID) pExceptionPointers->ContextRecord->StIIP;
        
        //
        // We should never be putting in a null value here
        //
        WOWASSERT(pExceptionPointers->ContextRecord->IntSp);
    }
}


WOW64CPUAPI
ULONG
CpuGetStackPointer(
    VOID
    )
/*++

Routine Description:

    Returns the current 32-bit stack pointer value.

Arguments:

    None.

Return Value:

    Value of 32-bit stack pointer.

--*/
{
    DECLARE_CPU;

    if (BtFuncs.BtGetStack) {
        return (BtFuncs.BtGetStack)();
    }


    return cpu->Context.Esp;
}


WOW64CPUAPI
VOID
CpuSetStackPointer(
    ULONG Value
    )
/*++

Routine Description:

    Modifies the current 32-bit stack pointer value.

Arguments:

    Value   - new value to use for 32-bit stack pointer.

Return Value:

    None.

--*/
{
    DECLARE_CPU;

    if (BtFuncs.BtSetStack) {
        (BtFuncs.BtSetStack)(Value);
        return;
    }

    cpu->Context.Esp = Value;
}


WOW64CPUAPI
VOID
CpuResetFloatingPoint(
    VOID
    )
/*++

Routine Description:

    Modifies the floating point state to reset it to a non-error state

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_CPU;
    PFXSAVE_FORMAT_WX86 xmmi;

    if (BtFuncs.BtResetFP) {
        (BtFuncs.BtResetFP)();
        return;
    }

    xmmi = (PFXSAVE_FORMAT_WX86) &(cpu->Context.ExtendedRegisters[0]);

    //
    // The jmpe instruction takes a fault if the fsr.es bit is set
    // regardless whether the fcr is set or not. We need to make sure
    // the excpetion handling code in ia32trap.c doesn't think this 
    // is an actual ia32 exception. We can do this by either
    // reseting the fcr (so the code sees no unmasked exceptions and
    // realizes it is a spurious fp exception) or we need to clear
    // the fsr.es bit manually
    //
    //
    // The problem with masking out just the ES bit, is that we end up
    // in an inconsistent state (fcr says exceptions, fsr error bits
    // say excpetion except for es bit. Next time anyone reads the fsr
    // register (either ia32, context switch, or debugger), we will
    // get es set back to 1 and start taking exceptions again...
    //
    // So only viable choice is to reset the fcr...
    //

    cpu->Context.FloatSave.ControlWord = xmmi->ControlWord = 0x37f;

}

WOW64CPUAPI
VOID
CpuSetInstructionPointer(
    ULONG Value
    )
/*++

Routine Description:

    Modifies the current 32-bit instruction pointer value.

Arguments:

    Value   - new value to use for 32-bit instruction pointer.

Return Value:

    None.

--*/
{
    DECLARE_CPU;

    if (BtFuncs.BtSetEip) {
        (BtFuncs.BtSetEip)(Value);
        return;
    }

    cpu->Context.Eip = Value;
}


VOID
InitializeGdtEntry (
    OUT PKGDTENTRY GdtEntry,
    IN ULONG Base,
    IN ULONG Limit,
    IN USHORT Type,
    IN USHORT Dpl,
    IN USHORT Granularity
    )

/*++

Routine Description:

    This function initializes a GDT entry.  Base, Limit, Type (code,
    data), and Dpl (0 or 3) are set according to parameters.  All other
    fields of the entry are set to match standard system values.

Arguments:

    GdtEntry - GDT descriptor to be filled in.

    Base - Linear address of the first byte mapped by the selector.

    Limit - Size of the selector in pages.  Note that 0 is 1 page
            while 0xffffff is 1 megapage = 4 gigabytes.

    Type - Code or Data.  All code selectors are marked readable,
            all data selectors are marked writeable.

    Dpl - User (3) or System (0)

    Granularity - 0 for byte, 1 for page

Return Value:

    Pointer to the GDT entry.

--*/

{
    GdtEntry->LimitLow = (USHORT)(Limit & 0xffff);
    GdtEntry->BaseLow = (USHORT)(Base & 0xffff);
    GdtEntry->HighWord.Bytes.BaseMid = (UCHAR)((Base & 0xff0000) >> 16);
    GdtEntry->HighWord.Bits.Type = Type;
    GdtEntry->HighWord.Bits.Dpl = Dpl;
    GdtEntry->HighWord.Bits.Pres = 1;
    GdtEntry->HighWord.Bits.LimitHi = (Limit & 0xf0000) >> 16;
    GdtEntry->HighWord.Bits.Sys = 0;
    GdtEntry->HighWord.Bits.Reserved_0 = 0;
    GdtEntry->HighWord.Bits.Default_Big = 1;
    GdtEntry->HighWord.Bits.Granularity = Granularity;
    GdtEntry->HighWord.Bytes.BaseHi = (UCHAR)((Base & 0xff000000) >> 24);
}


VOID
InitializeXDescriptor (
    OUT PKXDESCRIPTOR Descriptor,
    IN ULONG Base,
    IN ULONG Limit,
    IN USHORT Type,
    IN USHORT Dpl,
    IN USHORT Granularity
    )

/*++

Routine Description:

    This function initializes a unscrambled Descriptor.
    Base, Limit, Type (code, data), and Dpl (0 or 3) are set according
    to parameters.  All other fields of the entry are set to match
    standard system values.
    The Descriptor will be initialized to 0 first, and then setup as requested

Arguments:

    Descriptor - descriptor to be filled in.

    Base - Linear address of the first byte mapped by the selector.

    Limit - Size of the selector in pages.  Note that 0 is 1 page
            while 0xffffff is 1 megapage = 4 gigabytes.

    Type - Code or Data.  All code selectors are marked readable,
            all data selectors are marked writeable.

    Dpl - User (3) or System (0)

    Granularity - 0 for byte, 1 for page

Return Value:

    Pointer to the Descriptor

--*/

{
    Descriptor->Words.DescriptorWords = 0;

    Descriptor->Words.Bits.Base = Base;
    Descriptor->Words.Bits.Limit = Limit;
    Descriptor->Words.Bits.Type = Type;
    Descriptor->Words.Bits.Dpl = Dpl;
    Descriptor->Words.Bits.Pres = 1;
    Descriptor->Words.Bits.Default_Big = 1;
    Descriptor->Words.Bits.Granularity = Granularity;
}

WOW64CPUAPI
VOID
CpuNotifyDllLoad(
    LPWSTR DllName,
    PVOID DllBase,
    ULONG DllSize
    )
/*++

Routine Description:

    This routine get notified when application successfully load a dll.

Arguments:

    DllName - Name of the Dll the application has loaded.
    DllBase - BaseAddress of the dll.
    DllSize - size of the Dll.

Return Value:

    None.

--*/
{

#if defined(DBG)
    LPWSTR tmpStr;
#endif

    if (BtFuncs.BtDllLoad) {
        (BtFuncs.BtDllLoad)(DllName, DllBase, DllSize);
        return;
    }

    //
    // this is a no-op for the IA64 CPU
    //

#if defined(DBG)

    tmpStr = DllName;

    try {
        //
        // See if we got passed in a legit name
        //
        if ((tmpStr == NULL) || (*tmpStr == L'\0')) {
            tmpStr = L"<Unknown>";
        }
    }
    except ((GetExceptionCode() == STATUS_ACCESS_VIOLATION)?1:0) {
        tmpStr = L"<Unknown>";
    }

    LOGPRINT((TRACELOG, "CpuNotifyDllLoad(\"%ws\", 0x%p, %d) called\n", tmpStr, DllBase, DllSize));
#endif

}

WOW64CPUAPI
VOID
CpuNotifyDllUnload(
    PVOID DllBase
    )
/*++

Routine Description:

    This routine get notified when application unload a dll.

Arguments:

    DllBase - BaseAddress of the dll.

Return Value:

    None.

--*/
{
    if (BtFuncs.BtDllUnload) {
        (BtFuncs.BtDllUnload)(DllBase);
        return;
    }
    //
    // this is a no-op for the IA64 CPU
    //
    LOGPRINT((TRACELOG, "CpuNotifyDllUnLoad(%p) called\n", DllBase));
}
  
WOW64CPUAPI
VOID
CpuFlushInstructionCache (
    PVOID BaseAddress,
    ULONG Length
    )
/*++

Routine Description:

    The CPU needs to flush its cache around the specified address, since
    some external code has altered the specified range of addresses.

Arguments:

    BaseAddress - start of range to flush
    Length      - number of bytes to flush

Return Value:

    None.

--*/
{
    
    if (BtFuncs.BtFlush) {
        (BtFuncs.BtFlush)(BaseAddress, Length);
        return;
    }
    NtFlushInstructionCache(NtCurrentProcess(), BaseAddress, Length);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\cpu\ia64\inc\ia64cpu.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    ia64cpu.h

Abstract:

    Structures and types shared between the IA64 CPU and its debugger
    extensions.

Author:

    27-Sept-1999 BarryBo

Revision History:
    9-Aug-1999 [askhalid] added WOW64IsCurrentProcess

--*/

#ifndef _IA64CPU_INCLUDE
#define _IA64CPU_INCLUDE

#ifdef __cplusplus
extern "C" {
#endif

// flags used by ia32ShowContext
#define LOG_CONTEXT_SYS     1
#define LOG_CONTEXT_GETSET  2

#define GDT_ENTRIES 24
#define GDT_TABLE_SIZE  (GDT_ENTRIES<<3)

// Each 387 register takes 1 ia64 fp register
#define NUMBER_OF_387REGS       8

// Each XMMI register takes 2 ia64 fp registers
#define NUMBER_OF_XMMI_REGS     8

// Sanitize x86 eflags
#define SANITIZE_X86EFLAGS(efl)  ((efl & 0x003e0dd7L) | (0x202L))

/*
** The order of this structure is very important. The Reserved space at
** the beginnig allows the ExtendedRegisters[] array in the CONTEXT32 structure
** to be aligned properly.
**
** There are constants in the ISA transisiton code that are dependant on
** the offsets in this structure. If you make changes here, you must
** make changes to the cpu\ia64\simulate.s code at the very least
*/
#pragma pack(push, 4)
typedef struct _CpuContext {
    DWORD       Reserved;
    CONTEXT32   Context;

    //
    // Because the sizeof(CONTEXT32) struct above is 4 bytes short of
    // being divisible by 16, the padding allows the following
    // fields to be on 8 byte boundaries. If they are not, we will
    // do misaligned accesses on isa transisitons and we will 
    // see ASSERTS in the cpumain.c code (CpuThreadInit()).
    //

    ULONGLONG   Gdt[GDT_ENTRIES];
    ULONGLONG   GdtDescriptor;
    ULONGLONG   LdtDescriptor;
    ULONGLONG   FsDescriptor;

#if defined(WOW64_HISTORY)

    //
    // This MUST be the last entry in the CPUCONTEXT structure
    // The size is actually allocated based on a registry entry
    // and is appended to the sizeof the CPUCONTEXT structure as reported
    // back in CpuProcessInit()
    //
    WOW64SERVICE_BUF Wow64Service[1];
#endif          // defined WOW64_HISTORY

} CPUCONTEXT, *PCPUCONTEXT;
#pragma pack(pop)


//
// GDT Entry
//

#ifndef WOW64EXTS_386
typedef struct _KGDTENTRY {
    USHORT  LimitLow;
    USHORT  BaseLow;
    union {
        struct {
            UCHAR   BaseMid;
            UCHAR   Flags1;     // Declare as bytes to avoid alignment
            UCHAR   Flags2;     // Problems.
            UCHAR   BaseHi;
        } Bytes;
        struct {
            ULONG   BaseMid : 8;
            ULONG   Type : 5;
            ULONG   Dpl : 2;
            ULONG   Pres : 1;
            ULONG   LimitHi : 4;
            ULONG   Sys : 1;
            ULONG   Reserved_0 : 1;
            ULONG   Default_Big : 1;
            ULONG   Granularity : 1;
            ULONG   BaseHi : 8;
        } Bits;
    } HighWord;
} KGDTENTRY, *PKGDTENTRY;
#endif

#define TYPE_TSS    0x01  // 01001 = NonBusy TSS
#define TYPE_LDT    0x02  // 00010 = LDT

//
// UnScrambled Descriptor format
//
typedef struct _KDESCRIPTOR_UNSCRAM {
    union {
        ULONGLONG  DescriptorWords;
        struct {
            ULONGLONG   Base : 32;
            ULONGLONG   Limit : 20;
            ULONGLONG   Type : 5;
            ULONGLONG   Dpl : 2;
            ULONGLONG   Pres : 1;
            ULONGLONG   Sys : 1;
            ULONGLONG   Reserved_0 : 1;
            ULONGLONG   Default_Big : 1;
            ULONGLONG   Granularity : 1;
         } Bits;
    } Words;
} KXDESCRIPTOR, *PKXDESCRIPTOR;

#define TYPE_CODE_USER                0x1B // 0x11011 = Code, Readable, Accessed
#define TYPE_DATA_USER                0x13 // 0x10011 = Data, ReadWrite, Accessed

#define DESCRIPTOR_EXPAND_DOWN        0x14
#define DESCRIPTOR_DATA_READWRITE     (0x8|0x2) // Data, Read/Write

#define DPL_USER    3
#define DPL_SYSTEM  0

#define GRAN_BYTE   0
#define GRAN_PAGE   1

#define SELECTOR_TABLE_INDEX 0x04


//
// Now define the API's used to convert IA64 hardware into ia32 context
//
VOID Wow64CtxFromIa64(
    IN ULONG Ia32ContextFlags,
    IN PCONTEXT ContextIa64,
    IN OUT PCONTEXT32 ContextX86);

VOID Wow64CtxToIa64(
    IN ULONG Ia32ContextFlags,
    IN PCONTEXT32 ContextX86,
    IN OUT PCONTEXT ContextIa64);

VOID Wow64CopyFpFromIa64Byte16(
    IN PVOID Byte16Fp,
    IN OUT PVOID Byte10Fp,
    IN ULONG NumRegs);

VOID Wow64CopyFpToIa64Byte16(
    IN PVOID Byte10Fp,
    IN OUT PVOID Byte16Fp,
    IN ULONG NumRegs);

VOID Wow64CopyXMMIToIa64Byte16(
    IN PVOID ByteXMMI,
    IN OUT PVOID Byte16Fp,
    IN ULONG NumRegs);

VOID Wow64CopyXMMIFromIa64Byte16(
    IN PVOID Byte16Fp,
    IN OUT PVOID ByteXMMI,
    IN ULONG NumRegs);

VOID
Wow64RotateFpTop(
    IN ULONGLONG Ia64_FSR,
    IN OUT FLOAT128 UNALIGNED *ia32FxSave);

VOID Wow64CopyIa64ToFill(
    IN FLOAT128 UNALIGNED *ia64Fp,
    IN OUT PFLOAT128 FillArea,
    IN ULONG NumRegs);

VOID Wow64CopyIa64FromSpill(
    IN PFLOAT128 SpillArea,
    IN OUT FLOAT128 UNALIGNED *ia64Fp,
    IN ULONG NumRegs);

// The following ptototypes are to be used only by the cpu debugger extension
NTSTATUS
GetContextRecord(
    IN PCPUCONTEXT cpu,
    IN OUT PCONTEXT32 Context
    );
NTSTATUS
SetContextRecord(
    IN PCPUCONTEXT cpu,
    IN OUT PCONTEXT32 Context
    );
NTSTATUS
CpupGetContextThread(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    IN OUT PCONTEXT32 Context);
NTSTATUS
CpupSetContextThread(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    IN OUT PCONTEXT32 Context);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\dbgexts\wow64\filever.h ===
#ifndef __WOW64_EXTS_FILEVER_H__
#define __WOW64_EXTS_FILEVER_H__

/*
VOID PrintFileType(DWORD lBinaryType);
VOID PrintFileAttributes(DWORD dwAttr);
VOID PrintFileSizeAndDate(WIN32_FIND_DATA *pfd);
VOID PrintFileVersion(LPTSTR szFileName);

BOOL FListFiles(LPTSTR szDir, LPTSTR szPat);
DWORD MyGetBinaryType(LPTSTR szFileName);
VOID __cdecl PrintErrorMessage(DWORD dwError, LPTSTR szFmt, ...);
*/

#define FA_DIR(_x)    ((_x) & FILE_ATTRIBUTE_DIRECTORY)

// filever cmd line flags
#define FSTR_RECURSE    0x0001
#define FSTR_VERBOSE    0x0002
#define FSTR_EXESONLY   0x0004
#define FSTR_SHORTNAME  0x0008
#define FSTR_BAREFORMAT 0x0010
#define FSTR_PRINTDIR   0x0020
#define FSTR_NOATTRS    0x0040
#define FSTR_NODATETIME 0x0080
#ifdef DEBUG
#define FSTR_DEBUG      0x8000
#endif


// used by filever
#define PrintFlagsMap(_structname, _flags) \
    for(iType = 0; iType < sizeof(_structname)/sizeof(TypeTag); iType++) \
    { \
        if((_flags) & _structname[iType].dwTypeMask) \
            ExtOut(" %s", _structname[iType].szFullStr); \
    }

#define PrintFlagsVal(_structname, _flags) \
    for(iType = 0; iType < sizeof(_structname)/sizeof(TypeTag); iType++) \
    { \
        if((_flags) == _structname[iType].dwTypeMask) \
        { \
            ExtOut(" %s", _structname[iType].szFullStr); \
            break; \
        } \
    }


// PrintFileAttr struct
typedef struct _FileAttr
{
    DWORD dwAttr;
    TCHAR ch;
} FileAttr;

// MyGetBinaryType exe type defines
#define NE_UNKNOWN  0x0     /* Unknown (any "new-format" OS) */
#define NE_OS2      0x1     /* Microsoft/IBM OS/2 (default)  */
#define NE_WINDOWS  0x2     /* Microsoft Windows */
#define NE_DOS4     0x3     /* Microsoft MS-DOS 4.x */
#define NE_DEV386   0x4     /* Microsoft Windows 386 */

// MyGetBinaryType return values
enum {
    // SCS_32BIT_BINARY,
    // SCS_DOS_BINARY,
    // SCS_WOW_BINARY,
    // SCS_PIF_BINARY,
    // SCS_POSIX_BINARY,
    // SCS_OS216_BINARY,
    SCS_32BIT_BINARY_INTEL = SCS_OS216_BINARY + 1,
    SCS_32BIT_BINARY_MIPS,
    SCS_32BIT_BINARY_ALPHA,
    SCS_32BIT_BINARY_PPC,
    SCS_32BIT_BINARY_AXP64,
    SCS_32BIT_BINARY_IA64
};
#define SCS_UNKOWN      (DWORD)-1

static const TCHAR   *szType[] = {
    "W32    ",
    "DOS    ",
    "W16    ",
    "PIF    ",
    "PSX    ",
    "OS2    ",
    "W32i   ",
    "W32m   ",
    "W32a   ",
    "W32p   ",
    "W32a64 ",
    "W32i64 ",
};

CONST static TCHAR *VersionKeys[] =
{
    TEXT("CompanyName"),
    TEXT("FileDescription"),
    TEXT("InternalName"),
    TEXT("OriginalFilename"),
    TEXT("ProductName"),
    TEXT("ProductVersion"),
    TEXT("FileVersion"),
    TEXT("LegalCopyright"),
    TEXT("LegalTrademarks"),
    TEXT("PrivateBuild"),
    TEXT("SpecialBuild"),
    TEXT("Comments")
};

// languages map
typedef struct _LangTag {
	WORD		wLangId;
	LPSTR		szName;
	LPSTR		szDesc;
	LPSTR		szKey;
} LangTag;

CONST static LangTag ltLang[] =
{
	{0x0406,"Danish","Danish","DAN"},
	{0x0413,"Dutch","Dutch (Standard)","NLD"},
	{0x0813,"Dutch","Belgian (Flemish)","NLB"},
	{0x0409,"English","American","ENU"},
	{0x0809,"English","British","ENG"},
	{0x0c09,"English","Australian","ENA"},
	{0x1009,"English","Canadian","ENC"},
	{0x1409,"English","New Zealand","ENZ"},
	{0x1809,"English","Ireland","ENI"},
	{0x040b,"Finnish","Finnish","FIN"},
	{0x040c,"French","French (Standard)","FRA"},
	{0x080c,"French","Belgian","FRB"},
	{0x0c0c,"French","Canadian","FRC"},
	{0x100c,"French","Swiss","FRS"},
	{0x0407,"German","German (Standard)","DEU"},
	{0x0807,"German","Swiss","DES"},
	{0x0c07,"German","Austrian","DEA"},
	{0x040f,"Icelandic","Icelandic","ISL"},
	{0x0410,"Italian","Italian (Standard)","ITA"},
	{0x0810,"Italian","Swiss","ITS"},
	{0x0414,"Norwegian","Norwegian (Bokmal)","NOR"},
	{0x0814,"Norwegian","Norwegian (Nynorsk)","NON"},
	{0x0416,"Portuguese","Portuguese (Brazilian)","PTB"},
	{0x0816,"Portuguese","Portuguese (Standard)","PTG"},
	{0x041D,"Swedish","Swedish","SVE"},
	{0x040a,"Spanish","Spanish (Standard/Traditional)","ESP"},
	{0x080a,"Spanish","Mexican","ESM"},
	{0x0c0a,"Spanish","Spanish (Modern)","ESN"},
	{0x041f,"Turkish","TRK","TRK"},
	{0x0415,"Polish","PLK","PLK"},
	{0x0405,"Czech","CSY","CSY"},
	{0x041b,"Slovak","SKY","SKY"},
	{0x040e,"Hungarian","HUN","HUN"},
	{0x0419,"Russian","RUS","RUS"},
	{0x0408,"Greek","ELL","ELL"},
	{0x0804,"Chinese","CHS","CHS"},
	{0x0404,"Taiwan","CHT","CHT"},
	{0x0411,"Japan","JPN","JPN"},
	{0x0412,"Korea","KOR","KOR"}
};

// languages map
typedef struct _CharSetTag {
	WORD		wCharSetId;
	LPSTR		szDesc;
} CharSetTag;

CONST static CharSetTag ltCharSet[] =
{
	{0, "7-bit ASCII"},
	{932, "Windows, Japan (Shift  JIS X-0208)"},
	{949, "Windows, Korea (Shift  KSC 5601)"},
	{950, "Windows, Taiwan (GB5)"},
	{1200, "Unicode"},
	{1250, "Windows, Latin-2 (Eastern European)"},
	{1251, "Windows, Cyrillic"},
	{1252, "Windows, Multilingual"},
	{1253, "Windows, Greek"},
	{1254, "Windows, Turkish"},
	{1255, "Windows, Hebrew"},
	{1256, "Windows, Arabic"}
};

typedef struct  _ffTypeTag {
    DWORD   dwTypeMask;
    LPSTR   szTypeStr;
    LPSTR   szFullStr;
} TypeTag;

// file flags map

TypeTag  ttFileFlags[]= {
    { VS_FF_DEBUG,       "D",   "debug"},
    { VS_FF_PRERELEASE,  "P",   "prerelease"},
    { VS_FF_PATCHED,     "A",   "patched"},
    { VS_FF_PRIVATEBUILD,"I",   "private"},
    { VS_FF_INFOINFERRED,"F",   "infoInferred"},
    { VS_FF_SPECIALBUILD,"S",   "special"}
};

// file OS map

TypeTag ttFileOsHi[] = {
    { VOS_DOS,          "DOS",  "MS-DOS"},
    { VOS_OS216,        "O16",  "OS2/16"},
    { VOS_OS232,        "O32",  "OS2/32"},
    { VOS_NT,           "NT",   "NT"},
};

TypeTag ttFileOsLo[] = {
    { VOS__WINDOWS16,   "Win16","Win16"},
    { VOS__PM16,        "PM16", "PM16"},
    { VOS__PM32,        "PM32", "PM32"},
    { VOS__WINDOWS32,   "Win32","Win32"}
};

// type map
TypeTag  ttFType[] = {
    { VFT_APP,          "APP",  "App"},
    { VFT_DLL,          "DLL",  "Dll"},
    { VFT_DRV,          "DRV",  "Driver"},
    { VFT_FONT,         "FNT",  "Font"},
    { VFT_VXD,          "VXD",  "VXD"},
    { VFT_STATIC_LIB,   "LIB",  "lib"}
};

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_DRV ----- */
TypeTag ttFTypeDrv[] = {
	{ VFT2_DRV_PRINTER, "", "PrinterDrv"},
	{ VFT2_DRV_KEYBOARD, "", "KeyBoardDrv"},
	{ VFT2_DRV_LANGUAGE, "", "LangDrv"},
	{ VFT2_DRV_DISPLAY, "", "DisplayDrv"},
	{ VFT2_DRV_MOUSE, "", "MouseDrv"},
	{ VFT2_DRV_NETWORK, "", "NetworkDrv"},
	{ VFT2_DRV_SYSTEM, "", "SystemDrv"},
	{ VFT2_DRV_INSTALLABLE, "", "InstallableDrv"},
	{ VFT2_DRV_SOUND, "", "SoundDrv"},
	{ VFT2_DRV_COMM, "", "CommDrv"}
};

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_FONT ----- */
TypeTag ttFTypeFont[] = {
	{ VFT2_FONT_RASTER, "", "Raster"},
	{ VFT2_FONT_VECTOR, "", "Vectore"},
	{ VFT2_FONT_TRUETYPE, "", "Truetype"}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\dbgexts\wow64\filever.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windowsx.h>
#include <stdio.h>
#include <stdlib.h>
#include <dbgeng.h>

#if defined _X86_
#define WOW64EXTS_386
#endif

#include <wow64.h>
#include <wow64exts.h>
#include "filever.h"


// filever help function

VOID
PrintFileType(DWORD lBinaryType)
{
    LPCTSTR szFmtFileType = "   - ";

    if(lBinaryType < (sizeof(szType) / sizeof(szType[0])))
        szFmtFileType = szType[lBinaryType];
    ExtOut("%s", szFmtFileType);
}

VOID
PrintFileAttributes(DWORD dwAttr)
{
    DWORD   dwT;
    static const FileAttr attrs[] =
       {{FILE_ATTRIBUTE_DIRECTORY, 'd'},
        {FILE_ATTRIBUTE_READONLY,  'r'},
        {FILE_ATTRIBUTE_ARCHIVE,   'a'},
        {FILE_ATTRIBUTE_HIDDEN,    'h'},
        {FILE_ATTRIBUTE_SYSTEM,    's'} };
    TCHAR   szAttr[(sizeof(attrs) / sizeof(attrs[0])) + 1];

    for(dwT = 0; dwT < (sizeof(attrs) / sizeof(attrs[0])); dwT++)
        szAttr[dwT] = (dwAttr & attrs[dwT].dwAttr) ? attrs[dwT].ch : '-';
    szAttr[dwT] = 0;

    ExtOut("%s ", szAttr);
}

VOID
PrintFileSizeAndDate(WIN32_FIND_DATA *pfd)
{
    FILETIME    ft;
    SYSTEMTIME  st = {0};
    TCHAR       szSize[15];

    szSize[0] = 0;
    if(FileTimeToLocalFileTime(&pfd->ftLastWriteTime, &ft) &&
        FileTimeToSystemTime(&ft, &st))
    {
        TCHAR       szVal[15];
        NUMBERFMT   numfmt = {0, 0, 3, "", ",", 0};

        wsprintf(szVal, "%ld", pfd->nFileSizeLow); //$ SPEED
        GetNumberFormat(GetUserDefaultLCID(), 0, szVal, &numfmt, szSize, 15);
    }

    ExtOut(" %10s %02d-%02d-%02d", szSize, st.wMonth, st.wDay, st.wYear);
}

VOID
PrintFileVersion(VS_FIXEDFILEINFO *vs, DWORD dwLang)
{
    INT                 iType;
    TCHAR               szBuffer[100];

    dwLang = LOWORD(dwLang);

    szBuffer[0] = 0;
    for(iType = 0; iType < sizeof(ttFType) / sizeof(TypeTag); iType++)
    {
        if(vs->dwFileType == ttFType[iType].dwTypeMask)
        {
            ExtOut("%3.3s ", ttFType[iType].szTypeStr);
            break;
        }
    }
    if(iType == (sizeof(ttFType) / sizeof(TypeTag)))
        ExtOut("  - ");

    for(iType = 0; iType < sizeof(ltLang) / sizeof(LangTag); iType++)
    {
        if(dwLang == ltLang[iType].wLangId)
        {
            ExtOut("%3.3s ", ltLang[iType].szKey);
            break;
        }
    }
    if(iType == (sizeof(ltLang) / sizeof(LangTag)))
        ExtOut("  - ");

    wsprintf(szBuffer, "%u.%u.%u.%u %s",
             HIWORD(vs->dwFileVersionMS),
             LOWORD(vs->dwFileVersionMS),
             HIWORD(vs->dwFileVersionLS),
             LOWORD(vs->dwFileVersionLS),
             vs->dwFileFlags & VS_FF_DEBUG ? "dbg" : "shp");
    
    ExtOut(" %18.18s", szBuffer);
}


DWORD
MyGetBinaryType(PSTR szFileName)
{
    HANDLE              hFile;
    DWORD               cbRead;
    IMAGE_DOS_HEADER    img_dos_hdr;
    PIMAGE_OS2_HEADER   pimg_os2_hdr;
    IMAGE_NT_HEADERS    img_nt_hdrs;
    DWORD               lFileType = SCS_UNKOWN;

    if((hFile = CreateFile(szFileName, GENERIC_READ, FILE_SHARE_READ, NULL,
        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0)) == INVALID_HANDLE_VALUE)
            goto err;

    if(!ReadFile(hFile, &img_dos_hdr, sizeof(img_dos_hdr), &cbRead, NULL))
        goto err;

    if(img_dos_hdr.e_magic != IMAGE_DOS_SIGNATURE)
        goto err;
    lFileType = SCS_DOS_BINARY;

    if(SetFilePointer(hFile, img_dos_hdr.e_lfanew, 0, FILE_BEGIN) == -1)
        goto err;
    if(!ReadFile(hFile, &img_nt_hdrs, sizeof(img_nt_hdrs), &cbRead, NULL))
        goto err;
    if((img_nt_hdrs.Signature & 0xffff) == IMAGE_OS2_SIGNATURE)
    {
        pimg_os2_hdr = (PIMAGE_OS2_HEADER)&img_nt_hdrs;
        switch(pimg_os2_hdr->ne_exetyp)
        {
        case NE_OS2:
            lFileType = SCS_OS216_BINARY;
            break;
        case NE_DEV386:
        case NE_WINDOWS:
            lFileType = SCS_WOW_BINARY;
            break;
        case NE_DOS4:
        case NE_UNKNOWN:
        default:
            // lFileType = SCS_DOS_BINARY;
            break;
        }
    }
    else if(img_nt_hdrs.Signature == IMAGE_NT_SIGNATURE)
    {
        switch(img_nt_hdrs.OptionalHeader.Subsystem)
        {
        case IMAGE_SUBSYSTEM_OS2_CUI:
            lFileType = SCS_OS216_BINARY;
            break;
        case IMAGE_SUBSYSTEM_POSIX_CUI:
            lFileType = SCS_POSIX_BINARY;
            break;
        case IMAGE_SUBSYSTEM_NATIVE:
        case IMAGE_SUBSYSTEM_WINDOWS_GUI:
        case IMAGE_SUBSYSTEM_WINDOWS_CUI:
        default:
            switch(img_nt_hdrs.FileHeader.Machine)
            {
            case IMAGE_FILE_MACHINE_I386:
                lFileType = SCS_32BIT_BINARY_INTEL;
                break;
            case IMAGE_FILE_MACHINE_R3000:
            case IMAGE_FILE_MACHINE_R4000:
                lFileType = SCS_32BIT_BINARY_MIPS;
                break;
            case IMAGE_FILE_MACHINE_ALPHA:
                lFileType = SCS_32BIT_BINARY_ALPHA;
                break;
            case IMAGE_FILE_MACHINE_ALPHA64:
                lFileType = SCS_32BIT_BINARY_AXP64;
                break;
            case IMAGE_FILE_MACHINE_IA64:
                lFileType = SCS_32BIT_BINARY_IA64;
                break;
            case IMAGE_FILE_MACHINE_POWERPC:
                lFileType = SCS_32BIT_BINARY_PPC;
                break;
            default:
            case IMAGE_FILE_MACHINE_UNKNOWN:
                lFileType = SCS_32BIT_BINARY;
                break;
            }
            break;
        }
    }

err:
    if(hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    return lFileType;
}

VOID
PrintFixedFileInfo(LPSTR FileName, LPVOID lpvData, BOOL Verbose)
{
    VS_FIXEDFILEINFO    *pvs;
    LPVOID              lpInfo;
    TCHAR               key[80];
    DWORD               dwLength, Btype;
    DWORD               *pdwTranslation;
    UINT                i, iType, cch, uLen;
    DWORD               dwDefLang = 0x409;
    HANDLE              hf;
    WIN32_FIND_DATA     fd;


        
    if (!VerQueryValue(lpvData, "\\", (LPVOID*)&pvs, &uLen) || pvs == NULL) {
        ExtOut("VerQueryValue failed!\n");
        return;
    }

    if(!VerQueryValue(lpvData, "\\VarFileInfo\\Translation", (PVOID*)&pdwTranslation, &uLen))
    {
        pdwTranslation = &dwDefLang;
        uLen = sizeof(DWORD);
    }

    hf = FindFirstFile(FileName, &fd);
    if (hf == INVALID_HANDLE_VALUE) {
	ExtOut("FindFirstFile %s failed, gle %d\n", FileName, GetLastError());
	return;
    }
    PrintFileAttributes(fd.dwFileAttributes);
    Btype = MyGetBinaryType(FileName);
    PrintFileType(Btype);
    PrintFileVersion(pvs ,*pdwTranslation);
    PrintFileSizeAndDate(&fd);
    ExtOut("\n");
    
    if (!Verbose) {
        return;
    }

    while(uLen)
    {
        // Language
        ExtOut("\tLanguage\t0x%04x", LOWORD(*pdwTranslation));
        if(VerLanguageName(LOWORD(*pdwTranslation), key, sizeof(key) / sizeof(TCHAR))) {
            ExtOut(" (%s)", key);
        }
        ExtOut("\n");

        // CharSet
        ExtOut("\tCharSet\t\t0x%04x", HIWORD(*pdwTranslation));
        for(iType = 0; iType < sizeof(ltCharSet)/sizeof(CharSetTag); iType++)
        {
            if(HIWORD(*pdwTranslation) == ltCharSet[iType].wCharSetId)
            ExtOut(" %s", ltCharSet[iType].szDesc);
        }
        ExtOut("\n");

    tryagain:
        wsprintf(key, "\\StringFileInfo\\%04x%04x\\",
            LOWORD(*pdwTranslation), HIWORD(*pdwTranslation));

        lstrcat(key, "OleSelfRegister");
        ExtOut("\t%s\t%s\n", "OleSelfRegister",
            VerQueryValue(lpvData, key, &lpInfo, &cch) ? "Enabled" : "Disabled");

        for(i = 0; i < (sizeof(VersionKeys) / sizeof(VersionKeys[0])); i++)
        {
            wsprintf(key, "\\StringFileInfo\\%04x%04x\\",
                LOWORD(*pdwTranslation), HIWORD(*pdwTranslation));
            lstrcat(key, VersionKeys[i]);

            if(VerQueryValue(lpvData, key, &lpInfo, &cch))
            {
                lstrcpy(key, VersionKeys[i]);
                key[15] = 0;
                ExtOut("\t%s\t%s\n", key, lpInfo);
            }
        }

        // if the Lang is neutral, go try again with the default lang
        // (this seems to work with msspell32.dll)
        if(LOWORD(*pdwTranslation) == 0)
        {
            pdwTranslation = &dwDefLang;
            goto tryagain;
        }

        uLen -= sizeof(DWORD);
        pdwTranslation++;
        ExtOut("\n");
    }


    ExtOut("\tVS_FIXEDFILEINFO:\n");
    ExtOut("\tSignature:\t%08.8lx\n", pvs->dwSignature);
    ExtOut("\tStruc Ver:\t%08.8lx\n", pvs->dwStrucVersion);
    ExtOut("\tFileVer:\t%08.8lx:%08.8lx (%d.%d:%d.%d)\n",
        pvs->dwFileVersionMS, pvs->dwFileVersionLS,
        HIWORD(pvs->dwFileVersionMS), LOWORD(pvs->dwFileVersionMS),
        HIWORD(pvs->dwFileVersionLS), LOWORD(pvs->dwFileVersionLS));
    ExtOut("\tProdVer:\t%08.8lx:%08.8lx (%d.%d:%d.%d)\n",
        pvs->dwProductVersionMS, pvs->dwProductVersionLS,
        HIWORD(pvs->dwProductVersionMS), LOWORD(pvs->dwProductVersionMS),
        HIWORD(pvs->dwProductVersionLS), LOWORD(pvs->dwProductVersionLS));

    ExtOut("\tFlagMask:\t%08.8lx\n", pvs->dwFileFlagsMask);
    ExtOut("\tFlags:\t\t%08.8lx", pvs->dwFileFlags);
    PrintFlagsMap(ttFileFlags, pvs->dwFileFlags);

    ExtOut("\n\tOS:\t\t%08.8lx", pvs->dwFileOS);
    PrintFlagsVal(ttFileOsHi, pvs->dwFileOS & 0xffff000);
    PrintFlagsVal(ttFileOsLo, LOWORD(pvs->dwFileOS));

    ExtOut("\n\tFileType:\t%08.8lx", pvs->dwFileType);
    PrintFlagsVal(ttFType, pvs->dwFileType);

    ExtOut("\n\tSubType:\t%08.8lx", pvs->dwFileSubtype);
    if(pvs->dwFileType == VFT_FONT)
    {
        PrintFlagsVal(ttFTypeFont, pvs->dwFileSubtype);
    }
    else if(pvs->dwFileType == VFT_DRV)
    {
        PrintFlagsVal(ttFTypeDrv, pvs->dwFileSubtype);
    }
    ExtOut("\n\tFileDate:\t%08.8lx:%08.8lx\n", pvs->dwFileDateMS, pvs->dwFileDateLS);
}

HRESULT
FindFullImage32Name(
    ULONG64 DllBase,
    PSTR NameBuffer,
    ULONG NameBufferSize
    )
{
    PPEB32 peb32;
    PLIST_ENTRY32 LdrHead32, LdrNext32;
    PLDR_DATA_TABLE_ENTRY32 LdrEntry32;
    LDR_DATA_TABLE_ENTRY32 LdrEntryData32;
    LDR_DATA_TABLE_ENTRY LdrEntryData;
    SIZE_T Length;
    ULONG TempPtr32;
    UNICODE_STRING TempCopy;

    HRESULT Status = E_FAIL;
    
    Status=GetPeb32Addr((ULONG64*)&peb32);
    if (FAILED(Status)) {
        goto QUIT;
    }
    
    Status = g_ExtData->ReadVirtual((ULONG64)&(peb32->Ldr),
                                    &TempPtr32,
                                    sizeof(ULONG),
                                    NULL);
    if (FAILED(Status)) {
        goto QUIT;
    }
    LdrHead32 = &((PPEB_LDR_DATA32)TempPtr32)->InLoadOrderModuleList;

    Status = g_ExtData->ReadVirtual((ULONG64)&(LdrHead32->Flink),
                                    &TempPtr32,
                                    sizeof(ULONG),
                                    NULL);
    if (FAILED(Status)) {
        goto QUIT;
    }
    
    LdrNext32 = (PLIST_ENTRY32)TempPtr32;

    while( LdrNext32 != LdrHead32) {
        LdrEntry32 = CONTAINING_RECORD(LdrNext32,LDR_DATA_TABLE_ENTRY32,InLoadOrderLinks);
        Status = g_ExtData->ReadVirtual((ULONG64)LdrEntry32,
                                        &LdrEntryData32,
                                        sizeof(LdrEntryData32),
                                        NULL);
        if (FAILED(Status)) {
            break;
        }
    
        if ((ULONG64)LdrEntryData32.DllBase == DllBase) {
            RtlZeroMemory(&LdrEntryData, sizeof(LDR_DATA_TABLE_ENTRY));
            
            UStr32ToUStr(&LdrEntryData.FullDllName, &LdrEntryData32.FullDllName);
            
            Length = LdrEntryData.FullDllName.MaximumLength;
            if (Length > NameBufferSize) {
                Status = STATUS_NO_MEMORY;
                break;
            }

            TempCopy = LdrEntryData.FullDllName;
            TempCopy.Buffer = (PWSTR)RtlAllocateHeap(RtlProcessHeap(), 0, Length);

            if (TempCopy.Buffer == NULL) {
                Status = STATUS_NO_MEMORY;
                break;
            }
            
            Status = g_ExtData->ReadVirtual((ULONG64)LdrEntryData.FullDllName.Buffer,
                                            TempCopy.Buffer,
                                            (ULONG)Length,
                                            NULL);
            if (FAILED(Status)) {
                RtlFreeUnicodeString(&TempCopy);
                break;
            }


            wcstombs(NameBuffer, TempCopy.Buffer, NameBufferSize );
            break;
        }
        
        LdrNext32 = (PLIST_ENTRY32)LdrEntryData32.InLoadOrderLinks.Flink;
        Status = E_FAIL;

    }

QUIT:
    return Status;

}

HRESULT
FindFullImage64Name(
    ULONG64 DllBase,
    PSTR NameBuffer,
    ULONG NameBufferSize
    )
{
    PPEB64 peb64;
    PLIST_ENTRY LdrHead64, LdrNext64;
    PLDR_DATA_TABLE_ENTRY LdrEntry64;
    LDR_DATA_TABLE_ENTRY LdrEntryData64;
    
    SIZE_T Length;
    ULONG64 TempPtr64;
    HRESULT Status =E_FAIL;
    
    Status=GetPeb64Addr((ULONG64*)&peb64);
    if (FAILED(Status)) {
        goto QUIT;
    }
    
    Status = g_ExtData->ReadVirtual((ULONG64)&peb64->Ldr,
                                    &TempPtr64,
                                    sizeof(TempPtr64),
                                    NULL);
    if (FAILED(Status)) {
        goto QUIT;
    }
    
    LdrHead64 = &((PPEB_LDR_DATA)TempPtr64)->InLoadOrderModuleList;
    
    Status = g_ExtData->ReadVirtual((ULONG64)&LdrHead64->Flink,
                                    &TempPtr64,
                                    sizeof(TempPtr64),
                                    NULL);
    if (FAILED(Status)) {
        goto QUIT;
    }
    
    LdrNext64 = (PLIST_ENTRY)TempPtr64;

    while( LdrNext64 != LdrHead64) {
        LdrEntry64 = CONTAINING_RECORD(LdrNext64,LDR_DATA_TABLE_ENTRY,InLoadOrderLinks);
        Status = g_ExtData->ReadVirtual((ULONG64)LdrEntry64,
                                        &LdrEntryData64,
                                        sizeof(LdrEntryData64),
                                        NULL);
        if (FAILED(Status)) {
            break;
        }
    
        if ((ULONG64)LdrEntryData64.DllBase == DllBase) {
            
            Length = LdrEntryData64.FullDllName.MaximumLength;
            if (Length > NameBufferSize) {
                Status= STATUS_NO_MEMORY;
                break;
            } 

	    Status = g_ExtData->ReadVirtual((ULONG64)LdrEntryData64.FullDllName.Buffer,
					    NameBuffer,
                                            (ULONG)Length,
                                            NULL);
	    break;
        }
        
        LdrNext64 = (PLIST_ENTRY)LdrEntryData64.InLoadOrderLinks.Flink;
        Status = E_FAIL;

    }
QUIT:    
    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\dbgexts\wow64\wrapper.cpp ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    wrapper.c

Abstract:
    
    wrapper extension commands
    
    1-July-2000    t-tcheng

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windowsx.h>
#include <stdio.h>
#include <stdlib.h>
#include <dbgeng.h>

#if defined _X86_
#define WOW64EXTS_386
#endif

#include <wow64.h>
#include <wow64exts.h>

#define DECLARE_CPU_DEBUGGER_INTERFACE
#include <wow64cpu.h>

#define EXTDEFINE32(name, command)                                 \
        DEFINE_FORWARD_ENGAPI(name, ExtExecute(""#command"", MACHINE_TYPE32) )
                                       

#define EXTDEFINE64(name, command)                                 \
        DEFINE_FORWARD_ENGAPI(name, ExtExecute(""#command"", MACHINE_TYPE64) )                               
        

/*
    sw -- switch between 32-bit and 64-bit mode
*/
DECLARE_ENGAPI(sw)
{
    ULONG OldEffectiveProcessorType;
    PVOID CpuData=NULL;
    INIT_ENGAPI;

    Status = g_ExtControl->GetEffectiveProcessorType(&OldEffectiveProcessorType);
    if (FAILED(Status)) {
        ExtOut("sw: Error 0x%x while GetEffectiveProcessorType.\n", Status);
    }
    if (OldEffectiveProcessorType == MACHINE_TYPE32) {
        Status = g_ExtControl->SetEffectiveProcessorType(MACHINE_TYPE64);
        if (FAILED(Status)) {
            ExtOut("sw: Error 0x%x while SetEffectiveProcessorType.\n", Status);
          
        }
        ExtOut("Switched to IA64 mode.\n");
    } else {
        if (!(*g_pfnCpuDbgGetRemoteContext)(g_ExtClient, (PVOID)CpuData)) {
            ExtOut("The current thread doesn't have an x86 context.\n");
            EXIT_ENGAPI;
        }

        Status = g_ExtControl->SetEffectiveProcessorType(MACHINE_TYPE32);
        if (FAILED(Status)) {
            ExtOut("sw: Error 0x%x while SetEffectiveProcessorType.\n", Status);
          
        }
        ExtOut("Switched to IA32 mode.\n");
    }

    EXIT_ENGAPI;
}


/*
    k -- Output both 32-bit and 64-bit stack trace
*/

DECLARE_ENGAPI(k)
{
    ULONG OldEffectiveProcessorType, NewMachine;
    PDEBUG_CONTROL savedControl;
    CHAR buffer[MAX_BUFFER_SIZE];    
    PVOID CpuData = NULL;
    INIT_ENGAPI;
    

    Status = g_ExtControl->GetEffectiveProcessorType(&OldEffectiveProcessorType);
    if (FAILED(Status)) {
        ExtOut("!k: Error 0x%x while GetEffectiveProcessorType.\n", Status);
        EXIT_ENGAPI;
    }
    
    NewMachine = (OldEffectiveProcessorType == MACHINE_TYPE32)
              ? MACHINE_TYPE64 : MACHINE_TYPE32;
       
    savedControl = g_ExtControl;

    ExtOut("Walking %d-bit Stack... \n", (NewMachine == MACHINE_TYPE32)
                ? 64 : 32);
    
    sprintf(buffer, "k %s", ArgumentString);

    Status = g_ExtControl->Execute(DEBUG_OUTCTL_AMBIENT,buffer,0);
    if (FAILED(Status)) {
        ExtOut("!k: Error 0x%x while Execute.\n", Status);
        EXIT_ENGAPI;
    }
    
    g_ExtControl = savedControl;

    Status = g_ExtControl->SetEffectiveProcessorType(NewMachine);
    if (FAILED(Status)) {
        ExtOut("!k: Error 0x%x while SetEffectiveProcessorType.\n", Status);
        EXIT_ENGAPI;
    }
    
    ExtOut("Walking %d-bit Stack... \n", (NewMachine == MACHINE_TYPE32)
                ? 32 : 64);

    if (NewMachine == MACHINE_TYPE32 && 
       !(*g_pfnCpuDbgGetRemoteContext)(g_ExtClient, (PVOID)CpuData)) {
        ExtOut("No 32-bit context available!\n");
        EXIT_ENGAPI;
    }
    Status = g_ExtControl->Execute(DEBUG_OUTCTL_AMBIENT,buffer,0);
    if (FAILED(Status)) {
        ExtOut("!k: Error 0x%x while Execute.\n", Status);
        EXIT_ENGAPI;
    }
    g_ExtControl = savedControl;
    g_ExtControl->SetEffectiveProcessorType(OldEffectiveProcessorType);
    EXIT_ENGAPI;
}


void ExtExecute(PCSTR command, ULONG MachineType)
{
    ULONG OldEffectiveProcessorType;
    CHAR buffer[MAX_BUFFER_SIZE];
    PDEBUG_CONTROL savedControl;
    PVOID CpuData = NULL;
    HRESULT Status;

    // save g_ExtControl, because it will be released after calling Execute
    savedControl = g_ExtControl;

    Status = g_ExtControl->GetEffectiveProcessorType(&OldEffectiveProcessorType);
    if (FAILED(Status)) {
        ExtOut("!%s: Error 0x%x while GetEffectiveProcessorType.\n",command, Status);
        return;
    }
    
    if ((OldEffectiveProcessorType == MACHINE_TYPE64) &&
        (command[0]=='r' || command[0]=='k' || command[0]=='u') &&
        !(*g_pfnCpuDbgGetRemoteContext)(g_ExtClient, (PVOID)CpuData)) {
        
        ExtOut("The current thread doesn't have an x86 context.\n");
        goto EXIT;
    }


    
    Status = g_ExtControl->SetEffectiveProcessorType(MachineType);
    if (FAILED(Status)) {
        ExtOut("!%s: Error 0x%x while SetEffectiveProcessorType.\n",command, Status);
        goto EXIT;
    }
    sprintf(buffer, "%s %s",command, ArgumentString);
    
    Status = g_ExtControl->Execute(DEBUG_OUTCTL_AMBIENT,buffer,0);
    if (FAILED(Status)) {
        ExtOut("!%s: Error 0x%x while Execute.\n",command, Status);
        goto EXIT;
    }

EXIT:    
    Status = savedControl->SetEffectiveProcessorType(OldEffectiveProcessorType);
    if (FAILED(Status)) {
        ExtOut("!%s: Error 0x%x while SetEffectiveProcessorType.\n",command, Status);
    }
}

EXTDEFINE32(r,r)
EXTDEFINE32(u,u)
EXTDEFINE32(t,t)
EXTDEFINE32(p,p)
EXTDEFINE32(tr,tr)
EXTDEFINE32(pr,pr)
EXTDEFINE32(bp,bp)
EXTDEFINE32(bl,bl)
EXTDEFINE32(be,be)
EXTDEFINE32(bd,bd)
EXTDEFINE32(bc,bc)
EXTDEFINE32(kb,kb)

EXTDEFINE32(r32,r)
EXTDEFINE32(bp32,bp)
EXTDEFINE32(k32,k)

EXTDEFINE64(r64,r)
EXTDEFINE64(bp64,bp)
EXTDEFINE64(k64,k)

DECLARE_ENGAPI(tlog)
{
    char *pchCmd;
    ULONG TraceCount,i;
    char buffer[MAX_BUFFER_SIZE];
    ULONG OldRadix = 0;
    BOOL DumpReg = FALSE;
    PDEBUG_CONTROL savedControl;
    DEBUG_VALUE pdValue;
    INIT_ENGAPI;
    while (*ArgumentString && isspace(*ArgumentString)) {
        ArgumentString++;
    }
    pchCmd = ArgumentString;
    
    if ((*pchCmd == '-' || *pchCmd == '/') && 
       (*(pchCmd+1) == 'r' || *(pchCmd+1) == 'R'))  { 
        pchCmd +=2;
        while (*pchCmd && isspace(*pchCmd)) {
           pchCmd++;
        }
        DumpReg = TRUE;
    }
    
    g_ExtControl->GetRadix(&OldRadix);
    if (FAILED(Status)) {
        ExtOut("!tlog: Error 0x%x while GetRadix.\n", Status);
        goto EXIT;
    }
    
    g_ExtControl->SetRadix(10);
    if (FAILED(Status)) {
        ExtOut("!tlog: Error 0x%x while SetRadix.\n", Status);
        goto EXIT;
    }

    g_ExtControl->Evaluate(pchCmd, DEBUG_VALUE_INT32, &pdValue, NULL);
    if (FAILED(Status)) {
        ExtOut("!tlog Usage: tlog <-r> [count] [file].\n", Status);
        goto EXIT;
    }
    TraceCount = pdValue.I32;

    if (TraceCount ==0) {
        ExtOut("Invalid Trace Count\n", pchCmd, Status);
        goto EXIT;
    }
    
    //
    // skip to the next token
    //
    while (*pchCmd && !isspace(*pchCmd)) {
        pchCmd++;
    }
    while (*pchCmd && isspace(*pchCmd)) {
        pchCmd++;
    }

    if (DumpReg) {
        savedControl = g_ExtControl;
        sprintf(buffer, ".logopen %s;", pchCmd);
        Status = g_ExtControl->Execute(DEBUG_OUTCTL_AMBIENT,buffer,0);
        if (FAILED(Status)) {
            ExtOut("!tlog: Error 0x%x while Execute.\n", Status);
            goto EXIT;
        }
        for (i=1; i<=TraceCount; i++) {
            g_ExtControl = savedControl;
            Status = g_ExtControl->Execute(DEBUG_OUTCTL_AMBIENT,"t;r;",0);
            if (FAILED(Status)) {
                ExtOut("!tlog: Error 0x%x while Execute.\n", Status);
                goto EXIT;
            }
        }
        g_ExtControl = savedControl;
        Status = g_ExtControl->Execute(DEBUG_OUTCTL_AMBIENT,".logclose",0);
        if (FAILED(Status)) {
            ExtOut("!tlog: Error 0x%x while Execute.\n", Status);
            goto EXIT;
        }

    } else {
        if (*pchCmd) {
            sprintf(buffer, ".logopen %s;t %d;.logclose", pchCmd, (ULONG)TraceCount+1);
        } else {
            sprintf(buffer, "t %d", (ULONG)TraceCount, pchCmd);
        }

        Status = g_ExtControl->Execute(DEBUG_OUTCTL_AMBIENT,buffer,0);
        if (FAILED(Status)) {
            ExtOut("!tlog: Error 0x%x while Execute.\n", Status);
            goto EXIT;
        }
    }
    
EXIT:    
    if (OldRadix) {
        g_ExtControl->SetRadix(OldRadix);
        if (FAILED(Status)) {
            ExtOut("!tlog: Error 0x%x while SetRadix.\n", Status);
        }
    }

    EXIT_ENGAPI;
}



DECLARE_ENGAPI(filever)
{
    char              *pchCmd;
    LPVOID            lpVersionInfo;
    HANDLE            FileHandle = NULL;
    HANDLE            MappingHandle = NULL;
    HINSTANCE         hinst;
    HRSRC             hVerRes;
    VERHEAD           *pVerHead;
    BOOL              bResult = FALSE;
    ULONG64           offset, DllBase;
    UINT              uLen;
    char              NameBuffer[256];
    BOOL              Verbose=FALSE;
    
    INIT_ENGAPI;
    
    Status = S_OK;
    pchCmd = ArgumentString;
    while (*pchCmd && isspace(*pchCmd)) {
        pchCmd++;
    }
    
    if ((*pchCmd == '-' || *pchCmd == '/') && 
       (*(pchCmd+1) == 'v' || *(pchCmd+1) == 'V'))  { 
        pchCmd +=2;
        while (*pchCmd && isspace(*pchCmd)) {
           pchCmd++;
        }
        Verbose = TRUE;
    }
    
    offset = GETEXPRESSION(pchCmd);
    if (offset) {
        Status = g_ExtSymbols->GetModuleByOffset(offset, 0, NULL, &DllBase);
        Status = FindFullImage64Name(DllBase, 
                                   NameBuffer,
                                   256);
        if (Status !=S_OK) {
            Status = FindFullImage32Name(DllBase, 
                                         NameBuffer,
                                         256);
            if (Status!=S_OK) {
                ExtOut("GetImageName failed\n");
                goto Cleanup;
            }

        } 
        ExtOut("ImageFile= %s\n", NameBuffer);
        pchCmd = NameBuffer;
        
    }

    FileHandle = CreateFile(pchCmd,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            0,
                            NULL);
        
    if (FileHandle == INVALID_HANDLE_VALUE)  {
        ExtOut("Open Image File failed!\n");
        goto Cleanup;
    }

    MappingHandle = CreateFileMapping(FileHandle,
                                      NULL,
                                      PAGE_READONLY,
                                      0,
                                      0,
                                      NULL);
    if (MappingHandle == NULL) {
        goto Cleanup;
    }

    DllBase = (ULONG64)MapViewOfFileEx( MappingHandle,
                               FILE_MAP_READ,
                               0,
                               0,
                               0,
                               NULL
                             );

    if (DllBase == NULL) {
        goto Cleanup;
    }

    
    hinst = (HMODULE)(DllBase | 0x00000001);
    
    hVerRes = FindResource(hinst, MAKEINTRESOURCE(VS_VERSION_INFO), VS_FILE_INFO);
    if (hVerRes == NULL) {
        goto Cleanup;
    }
    pVerHead = (VERHEAD*)LoadResource(hinst, hVerRes);
    if (pVerHead == NULL) {
        goto Cleanup;
    }

    lpVersionInfo = GlobalAllocPtr(GHND, pVerHead->wTotLen + pVerHead->wTotLen/2);

    if (lpVersionInfo == NULL) {
        goto Cleanup;
    }

    memcpy(lpVersionInfo, (PVOID)pVerHead, pVerHead->wTotLen);
    
    PrintFixedFileInfo(pchCmd, lpVersionInfo, Verbose);
    
Cleanup:
    if (FileHandle)
        CloseHandle(FileHandle);
    if (MappingHandle)
        CloseHandle(MappingHandle);
    if (DllBase && (!offset))
        UnmapViewOfFile((PVOID)DllBase);
    if (lpVersionInfo)
        GlobalFreePtr(lpVersionInfo);

    EXIT_ENGAPI;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\dbgexts\wow64\wow64exts.cpp ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    wow64exts.cpp

Abstract:

    Debugger extensions for wow64.

Author:

    29-Oct-1998 mzoran

Revision History:

    3-Aug-1999 askhalid   Added disassembler support. Output routine is exposed to outside.
    1-Jul-2000 t-tcheng   Switch to new debugger engine 
--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <dbgeng.h>
#include <stdio.h>
#include <stdlib.h>

#if defined _X86_
#define WOW64EXTS_386
#endif

#include <wow64t.h>
#include <wow64.h>
#include <wow64warn.h>
#include "wow64exts.h"

#define DECLARE_CPU_DEBUGGER_INTERFACE
#include <wow64cpu.h>

PDEBUG_ADVANCED       g_ExtAdvanced;
PDEBUG_CLIENT         g_ExtClient;
PDEBUG_CONTROL        g_ExtControl;
PDEBUG_DATA_SPACES    g_ExtData;
PDEBUG_REGISTERS      g_ExtRegisters;
PDEBUG_SYMBOLS        g_ExtSymbols;
PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

#pragma warning(disable : 4003) //disable not enough arguments for macro.

LPSTR ArgumentString;

#define TRUNK32(z) (ULONG)PtrToUlong((PVOID)z)
#define OFFSET(type, field) ((ULONG_PTR)(&((type *)0)->field))

W64CPUGETREMOTE  g_pfnCpuDbgGetRemoteContext = NULL;
W64CPUSETREMOTE  g_pfnCpuDbgSetRemoteContext = NULL;
W64CPUGETLOCAL   g_pfnCpuDbgGetLocalContext = NULL;
W64CPUSETLOCAL   g_pfnCpuDbgSetLocalContext = NULL;
W64CPUFLUSHCACHE   g_pfnCpuDbgFlushInstructionCache = NULL;
W64CPUFLUSHCACHEWH g_pfnCpuDbgFlushInstructionCacheWithHandle = NULL;

HMODULE 
LoadCpuExtensionDll (
    IN PCHAR ModuleName,
    IN OUT PCHAR FileName)
{
    HMODULE CpuExtDll = NULL;
    IDebugClient *DebugClient;
    PDEBUG_CONTROL2 DebugControl;
    HRESULT Hr;
    ULONG TargetMachine;

    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) == S_OK)
    {
        //
        // Get the architecture type.
        //

        if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                       (void **)&DebugControl)) == S_OK)
        {
            ULONG Platform, MajorVer, MinorVer, SrvPack, StringUsed;
            CHAR  BuildString[100];
            if ((Hr = DebugControl->GetActualProcessorType(
                                         &TargetMachine)) == S_OK)
            {
                switch (TargetMachine)
                {
                case IMAGE_FILE_MACHINE_IA64:
                    strcpy(FileName, "\\w64cpuex.dll");
                    break;

                case IMAGE_FILE_MACHINE_AMD64:
                    strcpy(FileName, "\\wamd64cpuex.dll");
                    break;

                default:
                    ExtOut("Architecture %lx is not supported by Wow64.\n",
                           TargetMachine);
                    Hr = E_FAIL;
                    break;
                }
                DebugControl->Release();
            }
        }

        DebugClient->Release();
    }

    if (Hr == S_OK)
    {
        CpuExtDll = LoadLibraryA(ModuleName);
    }

    return CpuExtDll;
}

BOOL
ProcessAttach(
     HINSTANCE DLL,
     DWORD Reason,
     LPVOID Reserved
     )
{

  CHAR szModule[MAX_BUFFER_SIZE];
  CHAR *filename;
  HMODULE CpuExtDll = NULL;


  DisableThreadLibraryCalls(DLL);

  if (GetModuleFileNameA(DLL, szModule,  MAX_BUFFER_SIZE)) {

      filename = strrchr(szModule, '\\');
      if (filename && !_strnicmp(filename, "\\wow64exts.dll", 40)) {

          CpuExtDll = LoadCpuExtensionDll (szModule, filename);

          if (CpuExtDll) {
              g_pfnCpuDbgGetRemoteContext = (W64CPUGETREMOTE)
                                            GetProcAddress(CpuExtDll,
                                                           "CpuDbgGetRemoteContext");
              g_pfnCpuDbgGetLocalContext  = (W64CPUGETLOCAL)
                                            GetProcAddress(CpuExtDll,
                                                           "CpuDbgGetLocalContext");
              g_pfnCpuDbgSetRemoteContext = (W64CPUSETREMOTE)
                                            GetProcAddress(CpuExtDll,
                                                           "CpuDbgSetRemoteContext");
              g_pfnCpuDbgSetLocalContext  = (W64CPUSETLOCAL)
                                            GetProcAddress(CpuExtDll,
                                                           "CpuDbgSetLocalContext");
              g_pfnCpuDbgFlushInstructionCache = 
                  (W64CPUFLUSHCACHE)GetProcAddress(CpuExtDll,
                                              "CpuDbgFlushInstructionCache");
              g_pfnCpuDbgFlushInstructionCacheWithHandle = 
                  (W64CPUFLUSHCACHEWH)GetProcAddress(CpuExtDll,
                                          "CpuDbgFlushInstructionCacheWithHandle");
          }
      }
  }
  return (CpuExtDll && 
          g_pfnCpuDbgFlushInstructionCacheWithHandle &&
          g_pfnCpuDbgFlushInstructionCache &&
          g_pfnCpuDbgSetLocalContext &&
          g_pfnCpuDbgSetRemoteContext &&
          g_pfnCpuDbgGetLocalContext &&
          g_pfnCpuDbgGetRemoteContext);
  
  
}


BOOL
WINAPI
DllMain(
  HINSTANCE DLL,       // handle to DLL module
  DWORD Reason,        // reason for calling function
  LPVOID Reserved      // reserved
  )
{
  switch(Reason) {
  case DLL_PROCESS_ATTACH:
     return ProcessAttach(DLL, Reason, Reserved);
  default:
     return TRUE;
  }
}

HRESULT
GetPeb64Addr(OUT ULONG64 * Peb64
             )
{
    return g_ExtSystem->GetCurrentProcessPeb(Peb64);
}


HRESULT
GetTeb64Addr(OUT ULONG64 * Teb64
             )
{
    return g_ExtSystem->GetCurrentThreadTeb(Teb64);
}

HRESULT
GetTeb32Addr(OUT ULONG64 * Teb32
             )
{

   HRESULT Status;
   ULONG64    Teb64;
   
   Status = g_ExtSystem->GetCurrentThreadTeb(&Teb64);
   if (FAILED(Status)) {
       ExtOut("GetTeb32Addr failed!\n");
       return Status;
   }
   
   *Teb32 = 0;
   return  g_ExtData->ReadVirtual((ULONG64)Teb64+OFFSET(TEB,NtTib.ExceptionList),
                                   Teb32,
                                   sizeof(ULONG),
                                   NULL);
}

HRESULT
GetPeb32Addr(OUT ULONG64 * Peb32
             )
{

   HRESULT Status;
   ULONG64    Teb32;
   

   Status = GetTeb32Addr(&Teb32);
   if (FAILED(Status)) {
       ExtOut("GetTeb32Addr failed!\n");
       return Status;
   }
   
   *Peb32 = 0;
   Status = g_ExtData->ReadVirtual((ULONG64)Teb32+OFFSET(TEB32,ProcessEnvironmentBlock),
                                   Peb32,
                                   sizeof(ULONG),
                                   NULL);
   return Status;

}

//
// This macro gets used four times to defined the following functions.
// HRESULT GetPeb64(OUT PPEB Peb64);
// HRESULT GetPeb32(OUT PPEB32 Peb32);
// HRESULT GetTeb64(OUT PTEB Teb64);
// HRESULT GetTeb32(OUT PTEB32 Teb32);
//

#define DEFINE_GET_FUNC(name, type)                     \
HRESULT                                                 \
Get##name##(OUT P##type name                           \
            )                                           \
{                                                       \
                                                        \
   HRESULT Status;                                      \
   ULONG64 name##Addr;                                  \
                                                        \
   Status = Get##name##Addr(&##name##Addr);             \
                                                        \
   if (FAILED(Status)) {                                \
      ExtOut("Get "#type" failed!\n");                  \
      return Status;                                    \
                                                        \
   }                                                    \
   return   g_ExtData->ReadVirtual(name##Addr,          \
                                   name##,              \
                                   sizeof(##type##),    \
                                   NULL);               \
                                                        \
                                                        \
}                                                       \

DEFINE_GET_FUNC(Peb64,PEB)
DEFINE_GET_FUNC(Peb32,PEB32)
DEFINE_GET_FUNC(Teb64,TEB)
DEFINE_GET_FUNC(Teb32,TEB32)


VOID
PrintTls(VOID) {

   HRESULT Status;
   TEB Teb;

   Status = GetTeb64(&Teb);

   if (FAILED(Status)) {
      ExtOut("Could not get the teb, error 0x%X\n", Status);
   }

   ExtOut("\n");
   ExtOut("Wow64 TLS slots:\n\n");
   ExtOut("WOW64_TLS_STACKPTR64:       0x%16.16I64X\n", Teb.TlsSlots[WOW64_TLS_STACKPTR64]);
   ExtOut("WOW64_TLS_CPURESERVED:      0x%16.16I64X\n", Teb.TlsSlots[WOW64_TLS_CPURESERVED]);
   ExtOut("WOW64_TLS_INCPUSIMULATION:  0x%16.16I64X\n", Teb.TlsSlots[WOW64_TLS_INCPUSIMULATION]);
   ExtOut("WOW64_TLS_TEMPLIST:         0x%16.16I64X\n", Teb.TlsSlots[WOW64_TLS_TEMPLIST]);
   ExtOut("WOW64_TLS_EXCEPTIONADDR:    0x%16.16I64X\n", Teb.TlsSlots[WOW64_TLS_EXCEPTIONADDR]);
   ExtOut("WOW64_TLS_USERCALLBACKDATA: 0x%16.16I64X\n", Teb.TlsSlots[WOW64_TLS_USERCALLBACKDATA]);
   ExtOut("WOW64_TLS_EXTENDED_FLOAT:   0x%16.16I64X\n", Teb.TlsSlots[WOW64_TLS_EXTENDED_FLOAT]);
   ExtOut("WOW64_TLS_APCLIST:          0x%16.16I64X\n", Teb.TlsSlots[WOW64_TLS_APCLIST]);
   ExtOut("WOW64_TLS_FILESYSREDIR:     0x%16.16I64X\n", Teb.TlsSlots[WOW64_TLS_FILESYSREDIR]);
   ExtOut("WOW64_TLS_LASTWOWCALL:      0x%16.16I64X\n", Teb.TlsSlots[WOW64_TLS_LASTWOWCALL]);
   ExtOut("WOW64_TLS_WOW64INFO:        0x%16.16I64X\n", Teb.TlsSlots[WOW64_TLS_WOW64INFO]);
   ExtOut("\n");

}

VOID
PrintStructAddress(VOID) {

   HRESULT Status;
   TEB Teb;
   TEB32 Teb32;

   PTEB pTeb;
   PTEB32 pTeb32;
   PPEB pPeb;
   PPEB32 pPeb32;

   ExtOut("\n");
   ExtOut("Address of important WOW64 structures:\n\n");

   Status = GetPeb64Addr((PULONG64)&pPeb);
   if (FAILED(Status)) {
      ExtOut("Could not get the address of the 64bit PEB, error 0x%X\n", Status);
   }
   else {
      ExtOut("PEB64: 0x%X\n", PtrToUlong(pPeb));
   }

   Status = GetPeb32Addr((PULONG64)&pPeb32);
   if (FAILED(Status)) {
      ExtOut("Could not get the address of the 32bit PEB, error 0x%X\n", Status);
   }
   else {
      ExtOut("PEB32: 0x%X\n", pPeb32);
   }


   Status = GetTeb64Addr((PULONG64)&pTeb);
   if (FAILED(Status)) {
      ExtOut("Could not get the address of the 64bit TEB, error 0x%X\n", Status);
   }
   else {
      ExtOut("TEB64: 0x%X\n", PtrToUlong(pTeb));
   }

   Status = GetTeb32Addr((PULONG64)&pTeb32);
   if (FAILED(Status)) {
      ExtOut("Could not get the address of the 32bit TEB, error 0x%X\n", Status);
   }
   else {
      ExtOut("TEB32: 0x%X\n", pTeb32);
   }

   Status = GetTeb64(&Teb);
   if (FAILED(Status)) {
      ExtOut("Could not get information for 64bit stack, error 0x%X\n", Status);
   }
   else {
      ExtOut("STACK64: BASE: 0x%X LIMIT: 0x%X DEALLOC: 0x%X\n",
                    PtrToUlong(Teb.NtTib.StackBase),
                    PtrToUlong(Teb.NtTib.StackLimit),
                    PtrToUlong(Teb.DeallocationStack));
   }

   Status = GetTeb32(&Teb32);
   if (FAILED(Status)) {
      ExtOut("Could not get information for 32bit stack, error 0x%X\n");
   }
   else {
      ExtOut("STACK32: BASE: 0x%X LIMIT: 0x%X DEALLOC: 0x%X\n",
                    Teb32.NtTib.StackBase,
                    Teb32.NtTib.StackLimit,
                    Teb32.DeallocationStack);
   }

   ExtOut("\n");

}

WCHAR GetUStrBuffer[1024];

WCHAR *GetUS(WCHAR *Buffer,
             ULONG Length,
             BOOL Normalize,
             ULONG Base) {

   HRESULT Status;

   RtlZeroMemory(GetUStrBuffer, sizeof(GetUStrBuffer));

   Length = (ULONG)min(Length, sizeof(GetUStrBuffer) - sizeof(UNICODE_NULL));

   if (Normalize) {
      Buffer = (WCHAR *)((PBYTE)Buffer + Base);
   }

   Status = g_ExtData->ReadVirtual((ULONG64)Buffer ,
                                   GetUStrBuffer,
                                   Length,
                                   NULL);

   if (FAILED(Status)) {
      swprintf(GetUStrBuffer, L"Unable to read string, status 0x%X", Status);
   }

   return GetUStrBuffer;

}

#define GETUS(ustr, normalize, base) \
    GetUS((WCHAR*)((ustr).Buffer), (ustr).Length, normalize, PtrToUlong((PVOID)base))



VOID
Help(
    VOID
    )
{

   ExtOut("Wow64 debugger extensions: \n\n");
   ExtOut("help:          Prints this help message.\n");
   ExtOut("k <count>:     Combined 32/64 stack trace(no parameters).\n");
   ExtOut("kb <count>:    Combined 32/64 stack trace(with parameters).\n");
   ExtOut("straddr:       Dumps the address of important wow64 structures.\n");
   ExtOut("tls:           Dumps the WOW64 TLS slots.\n");
   ExtOut("ctx(addr):     Dump an x86 CONTEXT.\n");
   ExtOut("u:             Unassemble x86 code.\n");
   ExtOut("r:             Dump or modify registers.\n");
   ExtOut("bp:            Set x86 breakpoint.\n");
   ExtOut("bc:            Clear x86 breakpoint.\n");
   ExtOut("bl:            List x86 breakpoints.\n");
   ExtOut("be:            Enable x86 breakpoint.\n");
   ExtOut("bd:            Disable x86 breakpoint.\n");
   ExtOut("t <count>:     x86 trace on next 'g'.\n");
   ExtOut("tr <count>:    x86 trace with regs on next 'g'.\n");
   ExtOut("p <count>:     x86 step on next 'g'.\n");
   ExtOut("pr <count>:    x86 step with regs on next 'g'.\n");
   ExtOut("tlog <-r> [count] [file]  "              );
   ExtOut("               single-step 'count' instructions and log to a file.\n");
   ExtOut("lf:            Dump/Set log flags.\n");
   ExtOut("l2f:           Enable logging to file .\n");
   ExtOut("\n");
   ExtOut("New Commands:\n");
   ExtOut("sw:            Switch between 32-bit and 64-bit mode .\n");
   ExtOut("filever [-v] <address>|<pathname>:\n");
   ExtOut("               Dumps file version info.\n");
   ExtOut("\n");
   ExtOut("Tentative Commands:\n");
   ExtOut("bp32           set x86 breakpoint\n");
   ExtOut("bp64           set ia64 breakpoint\n");
   ExtOut("r32            Dump or modify x86 registers (if context available)\n");
   ExtOut("r64            Dump or modify ia64 registers\n");
   ExtOut("k32            Dumps x86 stack trace (if context available)\n");
   ExtOut("k64            Dumps ia64 stack trace\n");
   ExtOut("u32            Unassemble x86 code (if possible)\n");
   ExtOut("u64            Unassemble ia64 code (if possible)\n");
   ExtOut("\n");


}





DEFINE_FORWARD_ENGAPI(help, Help())

DEFINE_FORWARD_ENGAPI(tls, PrintTls())
DEFINE_FORWARD_ENGAPI(straddr, PrintStructAddress())



DECLARE_ENGAPI(ctx)
{
    PVOID Address;
    int i;
    ULONG EFlags;
    char *pchCmd;
    CONTEXT32 Context;
    char Buffer[256];

    INIT_ENGAPI;

    //
    // advance to first token, expecting address of context
    //
    pchCmd = ArgumentString;
    while (*pchCmd && isspace(*pchCmd)) {
        pchCmd++;
    }

    Status = TryGetExpr(pchCmd, (ULONG_PTR *)&Address);
    if (FAILED(Status)) {
        ExtOut("Invalid Expression '%s' Status %x\n", pchCmd, Status);
        EXIT_ENGAPI;
    }


    Status = g_ExtData->ReadVirtual((ULONG64)Address, &Context, sizeof(Context), NULL);
    if (FAILED(Status)) {
        ExtOut("Unable to read Context %x Status %x\n",
                Address,
                Status
                );
        EXIT_ENGAPI;
    }

    //
    // we make the gross assumption that we have enuf space in
    // Buffer to do three lines of output!
    //

    i = sprintf(Buffer,
                "eax=%08x ebx=%08x ecx=%08x edx=%08x esi=%08x edi=%08x\n",
                Context.Eax,
                Context.Ebx,
                Context.Ecx,
                Context.Edx,
                Context.Esi,
                Context.Edi
                );


    EFlags = Context.EFlags;

    i += sprintf(Buffer + i,
                 "eip=%08x esp=%08x ebp=%08x iopl=%x "
                 "%s %s %s %s %s %s %s %s\n",
                 Context.Eip,
                 Context.Esp,
                 Context.Ebp,
                 (EFlags & (BIT12 | BIT13)) >> 12,
                 (EFlags & BIT11) ? "ov" : "nv",
                 (EFlags & BIT10) ? "dn" : "up",
                 (EFlags & BIT9) ? "ei" : "di",
                 (EFlags & BIT7) ? "ng" : "pl",
                 (EFlags & BIT6) ? "zr" : "nz",
                 (EFlags & BIT4) ? "ac" : "na",
                 (EFlags & BIT2) ? "po" : "pe",
                 (EFlags & BIT0) ? "cy" : "nc"
                 );

    i += sprintf(Buffer+i,
                "cs=%04x  ss=%04x  ds=%04x  es=%04x  fs=%04x  gs=%04x  efl=%08x\n",
                Context.SegCs,
                Context.SegSs,
                Context.SegDs,
                Context.SegEs,
                Context.SegFs,
                Context.SegGs,
                EFlags
                );

    ExtOut(Buffer);
    EXIT_ENGAPI;
}

ULONG_PTR
GETEXPRESSION(char * expr)
{
    HRESULT hr = S_OK;
    DEBUG_VALUE IntVal;
    hr = g_ExtControl->Evaluate((PSTR)expr, 
                                DEBUG_VALUE_INT64,
                                &IntVal, 
                                NULL);
    if (hr == S_OK) {
        return (ULONG_PTR)IntVal.I64;
    } else {
        return (ULONG_PTR)NULL;
    }
}

/*
 * Does a plain old GetExpression under a try-except
 */
HRESULT
TryGetExpr(
    PSTR  Expression,
    PULONG_PTR pValue
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    __try {
        *pValue = GETEXPRESSION(Expression);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    return Status;
}

extern "C" HRESULT CALLBACK
DebugExtensionInitialize(PULONG Version, PULONG Flags)
{
    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;
    return S_OK;
}

extern "C" void CALLBACK
DebugExtensionUninitialize(void)
{
    //g_ExcepCallbacks.Uninitialize();
    //g_FnProfCallbacks.Uninitialize();
}


// Queries for all debugger interfaces.
HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Status;

    if ((Status = Client->QueryInterface(__uuidof(IDebugAdvanced),
                                         (void **)&g_ExtAdvanced)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugControl),
                                         (void **)&g_ExtControl)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                         (void **)&g_ExtData)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugRegisters),
                                         (void **)&g_ExtRegisters)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols),
                                         (void **)&g_ExtSymbols)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                         (void **)&g_ExtSystem)) != S_OK)
    {
        goto Fail;
    }

    g_ExtClient = Client;

    return S_OK;

 Fail:
    ExtRelease();
    return Status;
}
void
ExtRelease(void)
{
    g_ExtClient = NULL;
    EXT_RELEASE(g_ExtAdvanced);
    EXT_RELEASE(g_ExtControl);
    EXT_RELEASE(g_ExtData);
    EXT_RELEASE(g_ExtRegisters);
    EXT_RELEASE(g_ExtSymbols);
    EXT_RELEASE(g_ExtSystem);
}

// Normal output.
void __cdecl
ExtOut(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_NORMAL, Format, Args);
    va_end(Args);
}

// Error output.
void __cdecl
ExtErr(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);
}

// Warning output.
void __cdecl
ExtWarn(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_WARNING, Format, Args);
    va_end(Args);
}

// Verbose output.
void __cdecl
ExtVerb(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_VERBOSE, Format, Args);
    va_end(Args);
}


/* 
    Wow64extsfn

Abstract
    
    This export function is called from debugger engine 
    to handle cpu-specific issues -- flushing cpu instruction cache,
    retrieving and setting context when switching between 32-bit
    and 64-bit mode

Arguments:
    ActionCode = WOW64EXTS_FLUSH_CACHE_WITH_HANDLE
        Arg1 - the current process handle
        Arg2 - Starting Address
        Arg3 - Length of bytes to flush
    ( This action is called only when a trace/step breakpoint is inserted,
      there is no debug client, so process handle is needed. )        
        
    
    ActionCode = WOW64EXTS_FLUSH_CACHE
        Arg1 - the current process handle
        Arg2 - Starting Address
        Arg3 - Length of bytes to flush
        
    ActionCode = WOW64EXTS_GET_CONTEXT
        Arg1 - Debug Client 
        Arg2 - retrieved Context 
        
    ActionCode = WOW64EXTS_SET_CONTEXT
        Arg1 - Debug Client 
        Arg2 - Context to set
        
*/

extern "C" 
void CALLBACK 
Wow64extsfn(
    IN ULONG64 ActionCode,
    ULONG64 Arg1,
    ULONG64 Arg2,
    ULONG64 Arg3)

{
    PVOID CpuData = NULL;
    
    if (ActionCode == WOW64EXTS_FLUSH_CACHE_WITH_HANDLE)  {
        (*g_pfnCpuDbgFlushInstructionCacheWithHandle)((HANDLE)Arg1,
                                              (PVOID)Arg2,
                                              (DWORD)Arg3);
        return;
    }

    ExtQuery((PDEBUG_CLIENT)Arg1);

    switch(ActionCode) {
    case WOW64EXTS_FLUSH_CACHE:
        (*g_pfnCpuDbgFlushInstructionCache)((PDEBUG_CLIENT)Arg1,
                                    (PVOID)Arg2,
                                    (DWORD)Arg3);
        break;
    
    case WOW64EXTS_GET_CONTEXT:
        (*g_pfnCpuDbgGetRemoteContext)((PDEBUG_CLIENT)Arg1, 
                               (PVOID)CpuData);
        ((PCONTEXT32)Arg2)->ContextFlags=CONTEXT32_FULLFLOAT;
        (*g_pfnCpuDbgGetLocalContext)((PDEBUG_CLIENT)Arg1, 
                              (PCONTEXT32)Arg2);
        break;
    
    case WOW64EXTS_SET_CONTEXT:
        (*g_pfnCpuDbgSetLocalContext)((PDEBUG_CLIENT)Arg1,
                              (PCONTEXT32)Arg2);
        (*g_pfnCpuDbgSetRemoteContext)((PDEBUG_CLIENT)Arg1);
        break;
    }
    ExtRelease();
    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\dbgexts\wow64\log.cpp ===
/*++                 

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    log.c

Abstract:
    
    This module contains debugger extensions to control logging in a Wow64
    process.

Author:

    07-Oct-1999   SamerA

Revision History:
    
    3-Jul-2000  t-tcheng    switch to new debugger engine 
    
--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <dbgeng.h>
#include <stdio.h>
#include <stdlib.h>

#if defined _X86_
#define WOW64EXTS_386
#endif 

#include <wow64.h>
#include "wow64exts.h"

#define DECLARE_CPU_DEBUGGER_INTERFACE
#include <wow64cpu.h>


typedef struct _LogFlagName
{
    UINT_PTR Value;
    PSZ Name;
    PSZ Description;
} LogFlagName, *PLogFlagName;
 
LogFlagName LogFlags[] = 
{
    {LF_ERROR,       "LF_ERROR"       , "Log error messages"},
    {LF_TRACE,       "LF_TRACE"       , "Log trace messages"},
    {LF_NTBASE_NAME, "LF_NTBASE_NAME" , "Log NT base API names"},
    {LF_NTBASE_FULL, "LF_NTBASE_FULL" , "Log NT base API names and parameters"},
    {LF_WIN32_NAME,  "LF_WIN32_NAME"  , "Log WIN32 API names"},
    {LF_WIN32_FULL,  "LF_WIN32_FULL"  , "Log WIN32 API names and parameters"},
    {LF_NTCON_NAME,  "LF_NTCON_NAME"  , "Log Console API names"},
    {LF_NTCON_FULL,  "LF_NTCON_FULL"  , "Log Console API names and parameters"},
    {LF_BASE_NAME,   "LF_BASE_NAME"   , "Log Base/NLS API names"},
    {LF_BASE_FULL,   "LF_BASE_FULL"   , "Log Base/NLS API names and parameters"},
    {LF_EXCEPTION,   "LF_EXCEPTION"   , "Log exceptions that happen while reading parameters off the 32-bit stack"},
    {LF_CONSOLE,     "LF_CONSOLE"     , "Log to console debugger window"},
};



VOID
LogFlagsHelp(
    VOID)
{
    ULONG i=0;

    ExtOut("Usage:!lf <flags>\n");
    ExtOut("Valid logging flags are :\n");
    while (i < (sizeof(LogFlags) / sizeof(LogFlagName)))
    {
        ExtOut("%-16s - 0x%-8lx : %s\n",
                      LogFlags[i].Name,
                      LogFlags[i].Value,
                      LogFlags[i].Description);
        i++;
    }
}



VOID 
LogToFileHelp(
    VOID)
{
    ExtOut("Usage:!l2f <filename>\n");

    return;
}



DECLARE_ENGAPI(lf)
/*++

Routine Description:

    This routine sets/dumps the wow64 logging flags.
    
    Called as :
    
    !lf <optional flags>

Arguments:

    none
    
Return Value:

    none
    
--*/
{
    NTSTATUS NtStatus;
    UINT_PTR Flags;
    ULONG_PTR Ptr;
    ULONG NewFlags, i=0;
    HANDLE Process;
    INIT_ENGAPI;

    Status = g_ExtSystem->GetCurrentProcessHandle((PULONG64)&Process);
    Status = TryGetExpr("wow64log!wow64logflags", &Ptr);
    if ((FAILED(Status)) || (!Ptr))
    {
        ExtOut("Wow64log.dll isn't loaded. To enable full Wow64 logging, copy wow64log.dll to your system32 dir and restart the app.\n");
        ExtOut("Only LF_ERROR is enabled\n");
        EXIT_ENGAPI;
    }

    Status = g_ExtData->ReadVirtual((ULONG64)Ptr, &Flags, sizeof(UINT_PTR), NULL);
    if (FAILED(Status)) 
    {
        ExtOut("Couldn't read Wow64log!Wow64LogFlags - %lx\n", Status);
        EXIT_ENGAPI;
    }



    //
    // Read expression and set the value
    //
    if (ArgumentString && *ArgumentString) 
    {
        if (strstr(ArgumentString, "-?") ||
            strstr(ArgumentString, "help")) 
        {
            LogFlagsHelp();
            EXIT_ENGAPI;
        }

        sscanf( ArgumentString, "%lx", &NewFlags );

        if (!NewFlags) 
        {
            // Make sure it's a valid input
            while (*ArgumentString) 
            {
                if (!((*ArgumentString >= '0') &&  (*ArgumentString <= '9') ||
                      (*ArgumentString >= 'a') &&  (*ArgumentString <= 'f') ||
                      (*ArgumentString >= 'A') &&  (*ArgumentString <= 'F')))
                {
                    EXIT_ENGAPI;
                }
                ArgumentString++;
            }
        }

        Flags = NewFlags;
        Status = g_ExtData->WriteVirtual((ULONG64)Ptr, &Flags, sizeof(ULONG_PTR), NULL);
        if (FAILED(Status)) 
        {
            ExtOut("Couldn't write log flags [%lx] - %lx\n", Ptr, Status);
        }
    }
    else
    {
        ExtOut("Wow64 Log Flags = %I64x:\n", Flags);
        if (!Flags) 
        {
            ExtOut("No Flags\n");
        }
        else
        {
            while (i < (sizeof(LogFlags) / sizeof(LogFlagName)))
            {
                if (Flags & LogFlags[i].Value)
                {
                    ExtOut("%s\n", LogFlags[i].Name);
                }
                i++;
            }
        }
    }

    EXIT_ENGAPI;
}




DECLARE_ENGAPI(l2f)
/*++

Routine Description:

    This routine enable wow64 logging to file.
    
    Called as :
    
    !l2f <optional filename>

Arguments:

    none
    
Return Value:

    none
    
--*/
{
    HANDLE LogFileHandle, TargetHandle;
    ULONG_PTR Ptr;
    UNICODE_STRING NtFileName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS NtStatus;
    WCHAR FileName_U[ MAX_PATH ];
    POBJECT_NAME_INFORMATION ObjectNameInfo = (POBJECT_NAME_INFORMATION) FileName_U;
    HANDLE Process;
    INIT_ENGAPI;

    Status = g_ExtSystem->GetCurrentProcessHandle((PULONG64)&Process);

    //
    // check if the target process has already opened a logfile
    //
    Status = TryGetExpr("wow64log!wow64logfilehandle", &Ptr);
    if ((FAILED(Status)) || (!Ptr)) 
    {
        ExtOut("Wow64log.dll isn't loaded. To enable Wow64 file-logging, copy wow64log.dll to your system32 dir and restart the app.\n");
        EXIT_ENGAPI;
    }

    Status = g_ExtData->ReadVirtual((ULONG64)Ptr, 
                                   &LogFileHandle, 
                                   sizeof(HANDLE), 
                                   NULL);
    if (FAILED(Status)) 
    {
        ExtOut("Couldn't retreive Wow64LogFileHandle - %lx\n", Status);
        EXIT_ENGAPI;
    }


    //
    // Create the file
    //
    if ((ArgumentString) &&
        (*ArgumentString) &&
        (LogFileHandle == INVALID_HANDLE_VALUE))
    {
        if (strstr(ArgumentString, "-?") ||
            strstr(ArgumentString, "help")) 
        {
            LogToFileHelp();
            EXIT_ENGAPI;
        }


        if (!MultiByteToWideChar(CP_ACP,
                                 0,
                                 ArgumentString,
                                 -1,
                                 FileName_U,
                                 sizeof(FileName_U)/sizeof(WCHAR)))
        {
            ExtOut("Couldn't convert %s to unicode\n", ArgumentString);
            EXIT_ENGAPI;
        }


        if(!RtlDosPathNameToNtPathName_U(FileName_U, &NtFileName,NULL,NULL)) 
        {
            ExtOut("Couldn't convert %s to NT style pathname\n", ArgumentString);
            EXIT_ENGAPI;
        }

        InitializeObjectAttributes(&ObjectAttributes,
                                   &NtFileName,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        //
        // Open a new file (truncate to zero if exists)
        //
        NtStatus = NtCreateFile(&LogFileHandle,
                                SYNCHRONIZE | GENERIC_WRITE,
                                &ObjectAttributes,
                                &IoStatusBlock,
                                NULL,
                                0,
                                FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                FILE_OVERWRITE_IF,
                                FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                                NULL,
                                0);

        RtlFreeHeap(RtlProcessHeap(), 0, NtFileName.Buffer);

        if(!NT_SUCCESS(NtStatus)) 
        {
            ExtOut("Couldn't create %s - %lx\n", ArgumentString, NtStatus);
            EXIT_ENGAPI;
        }

        //
        // Let's duplicate the file handle into the debuggee
        //
        if (!DuplicateHandle(GetCurrentProcess(),
                             LogFileHandle,
                             Process,
                             &TargetHandle,
                             0,
                             FALSE,
                             DUPLICATE_SAME_ACCESS))
        {
            ExtOut("Couldn't duplicate handle into debuggee - GetLastError=%lx\n", GetLastError());
            EXIT_ENGAPI;
        }

        CloseHandle(LogFileHandle);

        Status = g_ExtData->WriteVirtual((ULONG64)Ptr, &TargetHandle, sizeof(HANDLE), NULL);
        if (FAILED(Status)) 
        {
            ExtOut("Couldn't write logfile handle - %lx\n", Status);
        }
    }
    else
    {
        LogToFileHelp();

        if (LogFileHandle != INVALID_HANDLE_VALUE)
        {
            if (DuplicateHandle(Process, 
                                LogFileHandle,
                                GetCurrentProcess(), 
                                &TargetHandle,
                                0, 
                                FALSE,
                                DUPLICATE_SAME_ACCESS))
            {
                NtStatus = NtQueryObject(TargetHandle,
                                         ObjectNameInformation,
                                         ObjectNameInfo,
                                         sizeof(FileName_U),
                                         NULL);

                CloseHandle(TargetHandle);
                if (NT_SUCCESS(NtStatus))
                {
                    ExtOut("Log file name : %ws\n",
                                  ObjectNameInfo->Name.Buffer ? ObjectNameInfo->Name.Buffer : L"None");
                }
                else
                {
                    ExtOut("Couldn't retreive log file name - %lx\n", NtStatus);
                }
            }
        }

    }

    EXIT_ENGAPI;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\dbgexts\wow64\wow64exts.h ===
#ifndef __WOW64_EXTS_HH__
#define __WOW64_EXTS_HH__


/*++                 

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    wow64exts.h

Abstract:
    
    header file for Debugger extensions for wow64.

Author:

    ATM Shafiqul Khalid   [ASKHALID]      3-Aug-1998

Revision History:

    Tim Cheng   [t-tcheng]                3-Jul-2000
--*/

//
//  functions shared between  C and  C++ codes.
//

#ifdef __cplusplus
extern "C" {
#endif

/* Masks for bits 0 - 32. */
#define BIT0         0x1
#define BIT1         0x2
#define BIT2         0x4
#define BIT3         0x8
#define BIT4        0x10
#define BIT5        0x20
#define BIT6        0x40
#define BIT7        0x80
#define BIT8       0x100
#define BIT9       0x200
#define BIT10      0x400
#define BIT11      0x800
#define BIT12     0x1000
#define BIT13     0x2000
#define BIT14     0x4000
#define BIT15     0x8000
#define BIT16    0x10000
#define BIT17    0x20000
#define BIT18    0x40000
#define BIT19    0x80000
#define BIT20   0x100000
#define BIT21   0x200000
#define BIT22   0x400000
#define BIT23   0x800000
#define BIT24  0x1000000
#define BIT25  0x2000000
#define BIT26  0x4000000
#define BIT27  0x8000000
#define BIT28 0x10000000
#define BIT29 0x20000000
#define BIT30 0x40000000
#define BIT31 0x80000000

#define MAX_BUFFER_SIZE 1000

#define WOW64EXTS_FLUSH_CACHE       0
#define WOW64EXTS_GET_CONTEXT       1
#define WOW64EXTS_SET_CONTEXT       2
#define WOW64EXTS_FLUSH_CACHE_WITH_HANDLE   3

#define NUMBER_OF_387REGS       8
#define NUMBER_OF_XMMI_REGS     8
#define SIZE_OF_FX_REGISTERS        128

#define MACHINE_TYPE32 IMAGE_FILE_MACHINE_I386
#if defined(_AXP64_)
#define MACHINE_TYPE64 IMAGE_FILE_MACHINE_AXP64
#else
#define MACHINE_TYPE64 IMAGE_FILE_MACHINE_IA64
#endif


typedef BOOL (*W64CPUGETREMOTE)(PDEBUG_CLIENT, PVOID);
typedef BOOL (*W64CPUSETREMOTE)(PDEBUG_CLIENT);
typedef BOOL (*W64CPUGETLOCAL)(PDEBUG_CLIENT, PCONTEXT32);
typedef BOOL (*W64CPUSETLOCAL)(PDEBUG_CLIENT, PCONTEXT32);
typedef BOOL (*W64CPUFLUSHCACHE)(PDEBUG_CLIENT, PVOID, DWORD);
typedef BOOL (*W64CPUFLUSHCACHEWH)(HANDLE, PVOID, DWORD);

extern W64CPUGETREMOTE  g_pfnCpuDbgGetRemoteContext;

typedef struct tagVERHEAD {
    WORD wTotLen;
    WORD wValLen;
    WORD wType;         /* always 0 */
    WCHAR szKey[(sizeof("VS_VERSION_INFO")+3)&~03];
    VS_FIXEDFILEINFO vsf;
} VERHEAD ;


//
// New-style dbgeng APIs use DECLARE_ENGAPI/INIT_ENGAPI macros
//
#define DECLARE_ENGAPI(name) \
HRESULT CALLBACK name(PDEBUG_CLIENT Client, PCSTR Args)

#define INIT_ENGAPI \
    HRESULT Status;                            \
    if ((Status = ExtQuery(Client)) != S_OK) { \
        return Status;                         \
    }                                          \
    ArgumentString = (LPSTR)Args;

#define EXIT_ENGAPI {ExtRelease();  return Status;}

#define DEFINE_FORWARD_ENGAPI(name, forward) \
DECLARE_ENGAPI(name)                         \
{                                            \
   INIT_ENGAPI;                              \
   forward;                                  \
   EXIT_ENGAPI;                              \
}                                            


// Safe release and NULL.
#define EXT_RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)


// Global variables initialized by query.
extern PDEBUG_ADVANCED       g_ExtAdvanced;
extern PDEBUG_CLIENT         g_ExtClient;
extern PDEBUG_CONTROL        g_ExtControl;
extern PDEBUG_DATA_SPACES    g_ExtData;
extern PDEBUG_REGISTERS      g_ExtRegisters;
extern PDEBUG_SYMBOLS        g_ExtSymbols;
extern PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

extern LPSTR ArgumentString;

// Queries for all debugger interfaces.
HRESULT ExtQuery(PDEBUG_CLIENT Client);

// Cleans up all debugger interfaces.
void ExtRelease(void);

// Normal output.
void __cdecl ExtOut(PCSTR Format, ...);
// Error output.
void __cdecl ExtErr(PCSTR Format, ...);
// Warning output.
void __cdecl ExtWarn(PCSTR Format, ...);
// Verbose output.
void __cdecl ExtVerb(PCSTR Format, ...);


HRESULT
TryGetExpr(
    PSTR  Expression,
    PULONG_PTR pValue
    );


ULONG_PTR 
GETEXPRESSION(char *);

HRESULT
GetPeb64Addr(OUT ULONG64* Peb64);

HRESULT
GetPeb32Addr(OUT ULONG64* Peb32);
             
HRESULT
FindFullImage32Name(
    ULONG64 DllBase,
    PSTR NameBuffer,
    ULONG NameBufferSize
    );

HRESULT
FindFullImage64Name(
    ULONG64 DllBase,
    PSTR NameBuffer,
    ULONG NameBufferSize
    );

VOID 
PrintFixedFileInfo(
    LPSTR  FileName,
    LPVOID lpvData,
    BOOL   Verbose
    );

#ifdef __cplusplus
}
#endif

#endif //__WOW64_EXTS_HH__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\inc\regremap.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    regredir.h

Abstract:

    This module define the APis to redirect 32bit registry calls. All 32bit wow process must 
    use following set of wowregistry APIs to manipulate registry so that 32-bit and 64-bit registry 
    can co exist in the same system registry.

Author:

    ATM Shafiqul Khalid (askhalid) 15-Oct-1999

Revision History:

--*/

#ifndef _REGREDIR_H_
#define _REGREDIR_H_

#if _MSC_VER > 1000
#pragma once
#endif


#ifdef __cplusplus
extern "C" {
#endif

typedef CCHAR KPROCESSOR_MODE;

//
// Nt level registry API calls
//

#define REG_OPAQUE_ATTRIB_MIRROR 0x00000001    // need to see the 64 bit side
#define REG_OPAQUE_ATTRIB_REAL   0x00000002    // this is real value
#define DONT_CREATE_DEST_KEY     0x00000004    // Suync only if destination key exist
#define SKIP_SPECIAL_CASE        0x00000008    // Skip special case

#define MAX_KEY_BUFF_LEN STATIC_UNICODE_BUFFER_LENGTH*4

 
 

typedef struct {
    DWORD dwSignature;
    DWORD dwAttribute;
} REG_OPAQUE_VALUE;

typedef struct {
    POBJECT_ATTRIBUTES  pObjectAddress;  // pointer to the object that that has been patched using this one
    PUNICODE_STRING     p64bitName;      // pointer to the correct unicode object name
    HANDLE              RootDirectory;   // handle to the root directory in case different handle need to pass
    UNICODE_STRING      PatchedName;      // pointer to the buffer holding patched name
    PVOID               pThis;           // pointer to this object to avoid multiple free
    SIZE_T              Len;           // Length of this memory segment including buffer at the end;
} PATCHED_OBJECT_ATTRIB, *PPATCHED_OBJECT_ATTRIB;

BOOL
IsUnderWow64 ();

BOOL
UpdateKeyTag (
    HKEY hBase,
    DWORD dwAttribute
    );

NTSTATUS
RemapNtCreateKey(
    OUT PHANDLE phPatchedHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG TitleIndex,
    IN PUNICODE_STRING Class OPTIONAL,
    IN ULONG CreateOptions,
    OUT PULONG Disposition OPTIONAL
    );

NTSTATUS
Wow64NtCreateKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG TitleIndex,
    IN PUNICODE_STRING Class OPTIONAL,
    IN ULONG CreateOptions,
    OUT PULONG Disposition OPTIONAL
    );

NTSTATUS
Wow64NtDeleteKey(
    IN HANDLE KeyHandle
    );


NTSTATUS
Wow64NtDeleteValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName
    );

NTSTATUS
Wow64NtEnumerateKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );


NTSTATUS
Wow64NtEnumerateValueKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSTATUS
Wow64NtFlushKey(
    IN HANDLE KeyHandle
    );

NTSTATUS
Wow64NtInitializeRegistry(
    IN USHORT BootCondition
    );

NTSTATUS
Wow64NtNotifyChangeKey(
    IN HANDLE KeyHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG CompletionFilter,
    IN BOOLEAN WatchTree,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    IN BOOLEAN Asynchronous
    );

NTSTATUS
Wow64NtNotifyChangeMultipleKeys(
    IN HANDLE MasterKeyHandle,  		
    IN ULONG Count,
    IN OBJECT_ATTRIBUTES SlaveObjects[],
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG CompletionFilter,
    IN BOOLEAN WatchTree,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    IN BOOLEAN Asynchronous
    );

NTSTATUS
Wow64NtLoadKey(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN POBJECT_ATTRIBUTES SourceFile
    );

NTSTATUS
Wow64NtLoadKey2(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN POBJECT_ATTRIBUTES SourceFile,
    IN ULONG Flags
    );

NTSTATUS
Wow64NtOpenKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSTATUS
Wow64NtQueryKey(
    IN HANDLE KeyHandle,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSTATUS
Wow64NtQueryValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSTATUS
Wow64NtQueryMultipleValueKey(
    IN HANDLE KeyHandle,
    IN PKEY_VALUE_ENTRY ValueEntries,
    IN ULONG EntryCount,
    OUT PVOID ValueBuffer,
    IN OUT PULONG BufferLength,
    OUT OPTIONAL PULONG RequiredBufferLength
    );

NTSTATUS
Wow64NtReplaceKey(
    IN POBJECT_ATTRIBUTES NewFile,
    IN HANDLE             TargetHandle,
    IN POBJECT_ATTRIBUTES OldFile
    );

NTSTATUS
Wow64NtRestoreKey(
    IN HANDLE KeyHandle,
    IN HANDLE FileHandle,
    IN ULONG  Flags
    );

NTSTATUS
Wow64NtSaveKey(
    IN HANDLE KeyHandle,
    IN HANDLE FileHandle
    );

NTSTATUS
Wow64NtSaveMergedKeys(
    IN HANDLE HighPrecedenceKeyHandle,
    IN HANDLE LowPrecedenceKeyHandle,
    IN HANDLE FileHandle
    );

NTSTATUS
Wow64NtSetValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN ULONG TitleIndex OPTIONAL,
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize
    );

NTSTATUS
Wow64NtUnloadKey(
    IN POBJECT_ATTRIBUTES TargetKey
    );

NTSTATUS
Wow64NtSetInformationKey(
    IN HANDLE KeyHandle,
    IN KEY_SET_INFORMATION_CLASS KeySetInformationClass,
    IN PVOID KeySetInformation,
    IN ULONG KeySetInformationLength
    );

NTSTATUS 
Wow64NtClose(
    IN HANDLE Handle
    );

VOID
DisplayCallParam ( 
    char *strCallLoc, 
    POBJECT_ATTRIBUTES ObjectAttributes 
    );

NTSTATUS
Wow64NtQueryOpenSubKeys(
    IN POBJECT_ATTRIBUTES TargetKey,
    OUT PULONG  HandleCount
    );

 

BOOL
IsIsnNode (
   PWCHAR wStr,
   PWCHAR *pwStrIsn
   );

NTSTATUS
CreatePathFromInsNode(
   PWCHAR wStr,
   PWCHAR wStrIsn
   );

 

NTSTATUS
OpenIsnNodeByObjectAttributes  (
    POBJECT_ATTRIBUTES ObjectAttributes,
    ACCESS_MASK DesiredAccess,
    PHANDLE phPatchedHandle
    );

int  
Regwcsnicmp(
    const WCHAR * first, 
    const WCHAR * last, 
    size_t count
    );

BOOL
SyncRegCreateKey (
    HANDLE hBase,
    PWCHAR AbsPath, 
    DWORD Flag
    );

BOOL
NtSyncNode (
    HANDLE hBase,
    PWCHAR AbsPath,
    BOOL bForceSync
    );
BOOL
IsOnReflectionList (
    PWCHAR Path
    );
BOOL
NtSyncNodeOpenCreate (
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
NTSTATUS 
ObjectAttributesToKeyName (
    POBJECT_ATTRIBUTES ObjectAttributes,
    PWCHAR AbsPath,
    DWORD  AbsPathLenIn,
    BOOL *bPatched,
    DWORD *ParentLen
    );

NTSTATUS
Wow64NtSetSecurityObject (
    IN HANDLE Handle,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    );

void
CleanupReflector (
    DWORD dwFlag
    );

PWCHAR
wcsistr(
    PWCHAR string1,
    PWCHAR string2
    );

#ifdef __cplusplus
}
#endif //__cplusplus

#endif // _REGREDIR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\inc\thnkhlpr.h ===
/*++
                                                                                
Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    thnkhlpr.h

Abstract:
    
    Header for thunk helper functions.
    
Author:

    19-Jul-1998 BarryBo

Revision History:

--*/

// Determines if a pointer points to a item or is a special value. 
// If it is a special value it should be copied without dereferencing.
#define WOW64_ISPTR(a) ((void *)a != NULL)

//
//  Helper thunk functions called by all the thunks to thunk common types.
//

NT32SIZE_T*
Wow64ShallowThunkSIZE_T64TO32(
     OUT NT32SIZE_T *dst,
     IN PSIZE_T src 
     );

PSIZE_T
Wow64ShallowThunkSIZE_T32TO64(
     OUT PSIZE_T dst,
     IN NT32SIZE_T *src
     );

#define Wow64ThunkSIZE_T32TO64(src) \
     (SIZE_T)(src)

#define Wow64ThunkSIZE_T64TO32(src) \
     (NT32SIZE_T)min((src), 0xFFFFFFFF)

#define Wow64ShallowThunkUnicodeString32TO64(dst, src) \
     ((PUNICODE_STRING)(dst))->Length = ((NT32UNICODE_STRING *)(src))->Length; \
     ((PUNICODE_STRING)(dst))->MaximumLength = ((NT32UNICODE_STRING *)(src))->MaximumLength; \
     ((PUNICODE_STRING)(dst))->Buffer = (PWSTR)((NT32UNICODE_STRING *)(src))->Buffer;

#define Wow64ShallowThunkUnicodeString64TO32(dst, src) \
     ((NT32UNICODE_STRING *)(dst))->Length = ((PUNICODE_STRING)(src))->Length; \
     ((NT32UNICODE_STRING *)(dst))->MaximumLength = ((PUNICODE_STRING)(src))->MaximumLength; \
     ((NT32UNICODE_STRING *)(dst))->Buffer = (NT32PWSTR)((PUNICODE_STRING)(src))->Buffer;

#define Wow64ShallowThunkAllocUnicodeString32TO64(src) \
     Wow64ShallowThunkAllocUnicodeString32TO64_FNC((NT32UNICODE_STRING *)(src))

PUNICODE_STRING
Wow64ShallowThunkAllocUnicodeString32TO64_FNC(
    IN NT32UNICODE_STRING *src
    );

#define Wow64ShallowThunkAllocSecurityDescriptor32TO64(src) \
    Wow64ShallowThunkAllocSecurityDescriptor32TO64_FNC((NT32SECURITY_DESCRIPTOR *)(src))

PSECURITY_DESCRIPTOR
Wow64ShallowThunkAllocSecurityDescriptor32TO64_FNC(
    IN NT32SECURITY_DESCRIPTOR *src
    );

#define Wow64ShallowThunkAllocSecurityTokenProxyData32TO64(src) \
    Wow64ShallowThunkAllocSecurityTokenProxyData32TO64_FNC((NT32SECURITY_TOKEN_PROXY_DATA *)(src))

PSECURITY_TOKEN_PROXY_DATA
Wow64ShallowThunkAllocSecurityTokenProxyData32TO64_FNC(
    IN NT32SECURITY_TOKEN_PROXY_DATA *src
    );

#define Wow64ShallowThunkAllocSecurityQualityOfService32TO64(src) \
    Wow64ShallowThunkAllocSecurityQualityOfService32TO64_FNC((NT32SECURITY_QUALITY_OF_SERVICE *)(src)) 

PSECURITY_QUALITY_OF_SERVICE
Wow64ShallowThunkAllocSecurityQualityOfService32TO64_FNC(
    IN NT32SECURITY_QUALITY_OF_SERVICE *src
    );

#define Wow64ShallowThunkAllocObjectAttributes32TO64(src) \
    Wow64ShallowThunkAllocObjectAttributes32TO64_FNC((NT32OBJECT_ATTRIBUTES *)(src)) 

POBJECT_ATTRIBUTES
Wow64ShallowThunkAllocObjectAttributes32TO64_FNC(
    IN NT32OBJECT_ATTRIBUTES *src
    );

ULONG 
Wow64ThunkAffinityMask64TO32(
    IN ULONG_PTR Affinity64
    );

ULONG_PTR
Wow64ThunkAffinityMask32TO64(
    IN ULONG Affinity32
    );

VOID WriteReturnLengthSilent(PULONG ReturnLength, ULONG Length);
VOID WriteReturnLengthStatus(PULONG ReturnLength, NTSTATUS *pStatus, ULONG Length);

VOID
Wow64RedirectFileName(
    IN OUT WCHAR *Name,
    IN OUT ULONG *Length
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\inc\va.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    va.h

Abstract:

    Include file for the helpers for the virtual memory thunks on platforms
    where page size is not equal to 4K.

Author:

    Dave Hastings (daveh) creation-date 26-Feb-1996

Revision History:


--*/

//
// Don't want to include anything unless SOFTWARE_4K_PAGESIZE is enabled.
//
#ifdef SOFTWARE_4K_PAGESIZE


//
// Constants
//
#define INTEL_PAGESIZE 0x1000
#ifdef _ALPHA_
#define NATIVE_PAGESIZE 0x2000
#endif

#ifdef _WHNT32_C_
#define NtAllocateVirtualMemory(a,b,c,d,e,f) VaAllocateVirtualMemory(a,b,c,d,e,f)
#define NtFreeVirtualMemory(a,b,c,d) VaFreeVirtualMemory(a,b,c,d)
#define NtProtectVirtualMemory(a,b,c,d,e) VaProtectVirtualMemory(a,b,c,d,e)
#define NtQueryVirtualMemory(a,b,c,d,e,f) VaQueryVirtualMemory(a,b,c,d,e,f)
#define NtMapViewOfSection(a,b,c,d,e,f,g,h,i,j) VaMapViewOfSection(a,b,c,d,e,f,g,h,i,j)
#define NtUnmapViewOfSection(a,b) VaUnmapViewOfSection(a,b)
#endif

//
// Useful macros
//
#define INTEL_PAGEROUND(a) (a & ~(INTEL_PAGESIZE - 1))
#define INTEL_PAGEMASK(a) (a & (INTEL_PAGESIZE - 1))
#define NATIVE_PAGEROUND(a) (a & ~(NATIVE_PAGESIZE - 1))
#define NATIVE_PAGEMASK(a) (a & (NATIVE_PAGESIZE - 1))

#define VaNextNode(n) n->Next

typedef ULONG_PTR  STATE;
typedef PULONG_PTR PSTATE;
typedef ULONG      PROT;
typedef PULONG     PPROT;

#if DBG
#define ASSRT(e) if (!(e)) {                       \
    DbgBreakPoint();                                   \
}
#else
#define ASSRT(e)
#endif

//
// Value used to mark allocation sentinels.  This is put in both
// the IntelState field of the sentinal
//
// Things to know about sentinels
//
// IntelState == VA_SENTINEL
// IntelEnd == 0
// State == Intel ending address
// Protect = Sentinel Flags
//
// The above have to be true for the sentinels to be inserted into the
// list and function correctly.  There are sentinels only at the beginning
// of a memory allocation.
//
#define VA_SENTINEL 0xFFFFFFFF

// Sentinal flags in NativeProtect
#define VA_MAPFILE  0x80000000

//
// Structure to track the state of the virtual address space
// An instance of this inclusively describes a portion of the
// address space 
//

typedef struct _VANODE {
    struct _VANODE *Prev;
    struct _VANODE *Next;
    PUCHAR Start;
    PUCHAR End;
    STATE State;
    STATE IntelState;
    PROT Protection;
    PROT IntelProtection;
} VANODE, *PVANODE;

//
// structure used to figure out how to satisfy the requested memory function
//
typedef enum _MEMACTION {
    CallSystem,
    FillMem,
    None
} MEMACTION, *PMEMACTION;

typedef struct _MEMCHUNK {
    PUCHAR Start;
    PUCHAR End;
    STATE  State;
    PROT   Protection;
    MEMACTION Action;
} MEMCHUNK, *PMEMCHUNK;
//
// Functions called by the thunks
//

BOOLEAN VaInit();

NTSTATUS
VaAllocateVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG_PTR ZeroBits,
    IN OUT PSIZE_T RegionSize,
    IN ULONG AllocationType,
    IN ULONG Protect
    );

NTSTATUS
VaFreeVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG FreeType
    );

NTSTATUS
VaQueryVirtualMemory(
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress,
    IN MEMORY_INFORMATION_CLASS MemoryInformationClass,
    OUT PVOID MemoryInformation,
    IN ULONG MemoryInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

NTSTATUS 
VaProtectVirtualMemory(
     IN HANDLE ProcessHandle,
     IN OUT PVOID *BaseAddress,
     IN OUT PSIZE_T RegionSize,
     IN ULONG NewProtect,
     OUT PULONG OldProtect
     );

NTSTATUS
VaMapViewOfSection(
    IN HANDLE SectionHandle,
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG_PTR ZeroBits,
    IN SIZE_T CommitSize,
    IN OUT PLARGE_INTEGER SectionOffset OPTIONAL,
    IN OUT PSIZE_T ViewSize,
    IN SECTION_INHERIT InheritDisposition,
    IN ULONG AllocationType,
    IN ULONG Protect
    );

NTSTATUS
VaUnmapViewOfSection(
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress
    );

//
// Internal functions used to implement the above
//
BOOL
VaQueryIntelPages(
    IN PVOID Address,
    OUT PULONG NumberOfPages,
    OUT PSTATE IntelState,
    OUT PPROT IntelProtection,
    OUT PSTATE NativeState,
    OUT PPROT NativeProtection
    );

BOOL
VaRecordMemoryOperation(
    PVOID IntelStart,
    PVOID IntelEnd,
    STATE State,
    PROT  Protection,
    PMEMCHUNK Pages,
    ULONG Number
    );

PVANODE
VaFindNode(
    PVOID Address
    );
    
PVANODE
VaRemoveNode(
    PVANODE VaNode
    );
    
PVANODE
VaInsertNode(
    PVANODE VaNode
    );
    
BOOL
VaGetAllocationInformation(
    PUCHAR Address,
    PUCHAR *IntelBase,
    PULONG NumberOfPages,
    PSTATE IntelState,
    PPROT IntelProtection
    );
    
VOID
VaDeleteRegion(
    PCHAR Start,
    PCHAR End
    );

PVANODE
VaFindSentinel(
    PCHAR Address
    );

PVANODE
VaFindContainingSentinel(
    PCHAR Address
    );
    
PVANODE
VaInsertSentinel(
    PVANODE VaNode
    );

void 
VaAddMemoryRecords(
    HANDLE ProcessHandle,
    LPVOID lpvAddress
    );

#ifdef DBG
VOID VaDumpNode(PVANODE);
VOID VaDumpList();
VOID 
VaDumpState(
    STATE State
    );
VOID
VaDumpProtection(
    PROT Protection
    );
#endif

#endif // SOFTWARE_4K_PAGESIZE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\inc\wow64.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    wow64.h

Abstract:

    Public header for wow64.dll

Author:

    11-May-1998 BarryBo

Revision History:
    9-Aug-1999 [askhalid] added WOW64IsCurrentProcess

--*/

#ifndef _WOW64_INCLUDE
#define _WOW64_INCLUDE

//
// Make wow64.dll exports __declspec(dllimport) when this header is included
// by non-wow64 components
//
#if !defined(_WOW64DLLAPI_)
#define WOW64DLLAPI DECLSPEC_IMPORT
#else
#define WOW64DLLAPI
#endif

// crank down some warnings
#pragma warning(4:4312)   // conversion to type of greater size


// pull in typedefs for TEB32, PEB32, etc.
#include "wow64t.h"

#include <setjmp.h>
#include <windef.h>

// wow64log constatns
#include "wow64log.h"

//wow64 regremaping
#include "regremap.h"

//
// Enable the wow64 history mechanism
// Eventually, this may only be enabled for debug builds, but for
// now, enable all the time
//
#define WOW64_HISTORY

//
// define a datatype corresponding to the 32-bit machine's CONTEXT
//
#include "wx86nt.h"
#define CONTEXT32 CONTEXT_WX86
#define PCONTEXT32 PCONTEXT_WX86
#define CONTEXT32_CONTROL CONTEXT_CONTROL_WX86
#define CONTEXT32_INTEGER CONTEXT_INTEGER_WX86
#define CONTEXT32_SEGMENTS CONTEXT_SEGMENTS_WX86
#define CONTEXT32_FLOATING_POINT CONTEXT_FLOATING_POINT_WX86
#define CONTEXT32_EXTENDED_REGISTERS CONTEXT_EXTENDED_REGISTERS_WX86
#define CONTEXT32_DEBUG_REGISTERS CONTEXT_DEBUG_REGISTERS_WX86
#define CONTEXT32_FULL CONTEXT_FULL_WX86
#define CONTEXT32_FULLFLOAT (CONTEXT_FULL_WX86|CONTEXT32_FLOATING_POINT|CONTEXT32_EXTENDED_REGISTERS)

#if defined(_AXP64_)
// Enable 4k page emulation in software.  IA64 does it in h/w with OS support.
#define SOFTWARE_4K_PAGESIZE 1
#endif

typedef enum _WOW64_API_ERROR_ACTION {
    ApiErrorNTSTATUS,           //Return exception code as return value
    ApiErrorNTSTATUSTebCode,    //Some as above with SetLastError on exception code
    ApiErrorRetval,             //Return a constant parameter
    ApiErrorRetvalTebCode       //Some as above with SetLastError on exception code
} WOW64_API_ERROR_ACTION, *PWOW64_API_ERROR_ACTION;

// This structure describes what action should occure when thunks hit an unhandled exception.
typedef struct _WOW64_SERVICE_ERROR_CASE {
    WOW64_API_ERROR_ACTION ErrorAction;
    LONG ErrorActionParam;
} WOW64_SERVICE_ERROR_CASE, *PWOW64_SERVICE_ERROR_CASE;

// This is an extension of KSERVICE_TABLE_DESCRIPTOR
typedef struct _WOW64SERVICE_TABLE_DESCRIPTOR {
    PULONG_PTR Base;
    PULONG Count;
    ULONG Limit;
#if defined(_IA64_)
    LONG TableBaseGpOffset;
#endif
    PUCHAR Number;
    WOW64_API_ERROR_ACTION DefaultErrorAction;  //Action if ErrorCases is NULL.
    LONG DefaultErrorActionParam;               //Action parameter if ErrorCases is NULL.
    PWOW64_SERVICE_ERROR_CASE ErrorCases;
} WOW64SERVICE_TABLE_DESCRIPTOR, *PWOW64SERVICE_TABLE_DESCRIPTOR;

// Used to log hit counts for APIs.
typedef struct _WOW64SERVICE_PROFILE_TABLE WOW64SERVICE_PROFILE_TABLE;
typedef struct _WOW64SERVICE_PROFILE_TABLE *PWOW64SERVICE_PROFILE_TABLE;

typedef struct _WOW64SERVICE_PROFILE_TABLE_ELEMENT {
    PWSTR ApiName;
    SIZE_T HitCount;
    PWOW64SERVICE_PROFILE_TABLE SubTable;
    BOOLEAN ApiEnabled;
} WOW64SERVICE_PROFILE_TABLE_ELEMENT, *PWOW64SERVICE_PROFILE_TABLE_ELEMENT;

typedef struct _WOW64SERVICE_PROFILE_TABLE {
    PWSTR TableName;           //OPTIONAL
    PWSTR FriendlyTableName;   //OPTIONAL
    CONST PWOW64SERVICE_PROFILE_TABLE_ELEMENT ProfileTableElements;
    SIZE_T NumberProfileTableElements;
} WOW64SERVICE_PROFILE_TABLE, *PWOW64SERVICE_PROFILE_TABLE;

typedef struct _WOW64_SYSTEM_INFORMATION {
  SYSTEM_BASIC_INFORMATION BasicInfo;
  SYSTEM_PROCESSOR_INFORMATION ProcessorInfo;
  ULONG_PTR RangeInfo;
} WOW64_SYSTEM_INFORMATION, *PWOW64_SYSTEM_INFORMATION;

//
// Indices for API thunks.
//
#define WHNT32_INDEX        0   // ntoskrnl
#define WHCON_INDEX         1   // console (replaces LPC calls)
#define WHWIN32_INDEX       2   // win32k
#define WHBASE_INDEX        3   // base/nls (replaces LPC calls)
#define MAX_TABLE_INDEX     4


//
// Logging mechanism.  Usage:
//  LOGPRINT((verbosity, format, ...))
//
#define LOGPRINT(args)  Wow64LogPrint args
#define ERRORLOG    LF_ERROR    // Always output to debugger.  Use for *unexpected*
                                // errors only
#define TRACELOG    LF_TRACE    // application trace information
#define INFOLOG     LF_TRACE    // misc. informational log
#define VERBOSELOG  LF_NONE     // practically never output to debugger

#if DBG
#define WOW64DOPROFILE
#endif

void
WOW64DLLAPI
Wow64LogPrint(
   UCHAR LogLevel,
   char *format,
   ...
   );



//
// WOW64 Assertion Mechanism.  Usage:
//  - put an ASSERTNAME macro at the top of each .C file
//  - WOW64ASSERT(expression)
//  - WOW64ASSERTMSG(expression, message)
//
//

VOID
WOW64DLLAPI
Wow64Assert(
    IN CONST PSZ exp,
    OPTIONAL IN CONST PSZ msg,
    IN CONST PSZ mod,
    IN LONG LINE
    );

#if DBG

#undef ASSERTNAME
#define ASSERTNAME static CONST PSZ szModule = __FILE__;

#define WOWASSERT(exp)                                  \
    if (!(exp)) {                                          \
        Wow64Assert( #exp, NULL, szModule, __LINE__);   \
    }

#define WOWASSERTMSG(exp, msg)                          \
    if (!(exp)) {                                          \
        Wow64Assert( #exp, msg, szModule, __LINE__);    \
    }

#else   // !DBG

#define WOWASSERT(exp)
#define WOWASSERTMSG(exp, msg)

#endif  // !DBG

#define WOWASSERT_PTR32(ptr) WOWASSERT((ULONGLONG)ptr < 0xFFFFFFFF)

WOW64DLLAPI
PVOID
Wow64AllocateHeap(
    SIZE_T Size
    );

WOW64DLLAPI
VOID
Wow64FreeHeap(
    PVOID BaseAddress
    );


//
// 64-to-32 callback support for usermode APCs
//

// A list of these sits inside WOW64_TLS_APCLIST
typedef struct tagUserApcList {
    struct tagUserApcList *Next;
    jmp_buf     JumpBuffer;
    PCONTEXT32  pContext32;
} USER_APC_ENTRY, *PUSER_APC_ENTRY;

BOOL
WOW64DLLAPI
WOW64IsCurrentProcess (
    HANDLE hProcess
    );

NTSTATUS
Wow64WrapApcProc(
    IN OUT PVOID *pApcProc,
    IN OUT PVOID *pApcContext
    );


typedef struct UserCallbackData {
    jmp_buf JumpBuffer;
    PVOID   PreviousUserCallbackData;
    PVOID   OutputBuffer;
    ULONG   OutputLength;
    NTSTATUS Status;
    PVOID   UserBuffer;
} USERCALLBACKDATA, *PUSERCALLBACKDATA;

ULONG
Wow64KiUserCallbackDispatcher(
    PUSERCALLBACKDATA pUserCallbackData,
    ULONG ApiNumber,
    ULONG ApiArgument,
    ULONG ApiSize
    );

NTSTATUS
Wow64NtCallbackReturn(
    PVOID OutputBuffer,
    ULONG OutputLength,
    NTSTATUS Status
    );

BOOL 
Wow64IsModule32bitHelper(
    HANDLE ProcessHandle,
    IN ULONG64 DllBase);

BOOL
Wow64IsModule32bit(
    IN PCLIENT_ID ClientId,
    IN ULONG64 DllBase);

NTSTATUS
Wow64SkipOverBreakPoint(
    IN PCLIENT_ID ClientId,
    IN PEXCEPTION_RECORD ExceptionRecord);

NTSTATUS
Wow64GetThreadSelectorEntry(
    IN HANDLE ThreadHandle,
    IN OUT PVOID DescriptorTableEntry,
    IN ULONG Length,
    OUT PULONG ReturnLength OPTIONAL);

//
// Thread Local Storage (TLS) support.  TLS slots are statically allocated.
//
#define WOW64_TLS_STACKPTR64        0   // contains 64-bit stack ptr when simulating 32-bit code
#define WOW64_TLS_CPURESERVED       1   // per-thread data for the CPU simulator
#define WOW64_TLS_INCPUSIMULATION   2   // Set when inside the CPU
#define WOW64_TLS_TEMPLIST          3   // List of memory allocated in thunk call.
#define WOW64_TLS_EXCEPTIONADDR     4   // 32-bit exception address (used during exception unwinds)
#define WOW64_TLS_USERCALLBACKDATA  5   // Used by win32k callbacks
#define WOW64_TLS_EXTENDED_FLOAT    6   // Used in ia64 to pass in floating point
#define WOW64_TLS_APCLIST	        7	// List of outstanding usermode APCs
#define WOW64_TLS_FILESYSREDIR	    8	// Used to enable/disable the filesystem redirector
#define WOW64_TLS_LASTWOWCALL	    9	// Pointer to the last wow call struct (Used when wowhistory is enabled)
#define WOW64_TLS_WOW64INFO        10   // Wow64Info address (structure shared between 32-bit and 64-bit code inside Wow64).

// VOID Wow64TlsSetValue(DWORD dwIndex, LPVOID lpTlsValue);
#define Wow64TlsSetValue(dwIndex, lpTlsValue)   \
    NtCurrentTeb()->TlsSlots[dwIndex] = lpTlsValue;

// LPVOID Wow64TlsGetValue(DWORD dwIndex);
#define Wow64TlsGetValue(dwIndex)               \
    (NtCurrentTeb()->TlsSlots[dwIndex])

//
// 32-to-64 thunk routine
//
LONG
WOW64DLLAPI
Wow64SystemService(
    IN ULONG ServiceNumber,
    IN PCONTEXT32 Context32
    );

//
// Wow64RaiseException
//
WOW64DLLAPI
NTSTATUS
Wow64RaiseException(
    IN DWORD InterruptNumber,
    IN OUT PEXCEPTION_RECORD ExceptionRecord);


//
// Helper routines, called from the thunks
//

#define CHILD_PROCESS_SIGNATURE     0xff00ff0011001100
typedef struct _ChildProcessInfo {
    ULONG_PTR   Signature;
    PPEB32      pPeb32;
    SECTION_IMAGE_INFORMATION ImageInformation;
    ULONG_PTR   TailSignature;
} CHILD_PROCESS_INFO, *PCHILD_PROCESS_INFO;

PVOID
WOW64DLLAPI
Wow64AllocateTemp(
    SIZE_T Size
    );

NTSTATUS
WOW64DLLAPI
Wow64QueryBasicInformationThread(
    IN HANDLE Thread,
    OUT PTHREAD_BASIC_INFORMATION ThreadInfo
    );

WOW64DLLAPI
NTSTATUS
Wow64NtCreateThread(
   OUT PHANDLE ThreadHandle,
   IN ACCESS_MASK DesiredAccess,
   IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
   IN HANDLE ProcessHandle,
   OUT PCLIENT_ID ClientId,
   IN PCONTEXT ThreadContext,
   IN PINITIAL_TEB InitialTeb,
   IN BOOLEAN CreateSuspended
   );

WOW64DLLAPI
NTSTATUS
Wow64NtTerminateThread(
    HANDLE ThreadHandle,
    NTSTATUS ExitStatus
    );

NTSTATUS
Wow64ExitThread(
    HANDLE ThreadHandle,
    NTSTATUS ExitStatus
    );

VOID
Wow64BaseFreeStackAndTerminate(
    IN PVOID OldStack,
    IN ULONG ExitCode
    );

VOID
Wow64BaseSwitchStackThenTerminate (
    IN PVOID StackLimit,
    IN PVOID NewStack,
    IN ULONG ExitCode
    );

NTSTATUS
Wow64NtContinue(
    IN PCONTEXT ContextRecord,  // really a PCONTEXT32
    IN BOOLEAN TestAlert
    );

NTSTATUS
WOW64DLLAPI
Wow64SuspendThread(
    IN HANDLE ThreadHandle,
    OUT PULONG PreviousSuspendCount OPTIONAL
    );

NTSTATUS
WOW64DLLAPI
Wow64GetContextThread(
     IN HANDLE ThreadHandle,
     IN OUT PCONTEXT ThreadContext // really a PCONTEXT32
     );

NTSTATUS
WOW64DLLAPI
Wow64SetContextThread(
     IN HANDLE ThreadHandle,
     IN PCONTEXT ThreadContext // really a PCONTEXT32
     );

NTSTATUS
Wow64KiRaiseException(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN BOOLEAN FirstChance
    );

ULONG
Wow64SetupApcCall(
    IN ULONG NormalRoutine,
    IN PCONTEXT32 NormalContext,
    IN ULONG Arg1,
    IN ULONG Arg2
    );

VOID
ThunkExceptionRecord64To32(
    IN  PEXCEPTION_RECORD   pRecord64,
    OUT PEXCEPTION_RECORD32 pRecord32
    );

BOOLEAN
Wow64NotifyDebugger(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN BOOLEAN FirstChance
    );

VOID
Wow64SetupExceptionDispatch(
    IN PEXCEPTION_RECORD32 pRecord32,
    IN PCONTEXT32 pContext32
    );

VOID
Wow64NotifyDebuggerHelper(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN BOOLEAN FirstChance
    );

NTSTATUS
Wow64InitializeEmulatedSystemInformation(
    VOID
    );

PWOW64_SYSTEM_INFORMATION
Wow64GetEmulatedSystemInformation(
    VOID
    );

PWOW64_SYSTEM_INFORMATION
Wow64GetRealSystemInformation(
     VOID
     );

VOID
Wow64Shutdown(
     HANDLE ProcessHandle
     );

// Defines the argsize of the emulated machine
#define ARGSIZE 4

VOID
ThunkPeb64ToPeb32(
    IN PPEB Peb64,
    OUT PPEB32 Peb32
    );


extern RTL_CRITICAL_SECTION HandleDataCriticalSection;

#endif  // _WOW64_INCLUDE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\inc\wow64log.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    wow64.h

Abstract:

    Public header for wow64log.dll

Author:

    3-Oct-1999   SamerA

Revision History:

--*/

#ifndef _WOW64LOG_INCLUDE
#define _WOW64LOG_INCLUDE

//
// Make wow64log.dll exports __declspec(dllimport) when this header is included
// by non-wow64 components
//
#if !defined(_WOW64LOGAPI_)
#define WOW64LOGAPI DECLSPEC_IMPORT
#else
#define WOW64LOGAPI
#endif


#define WOW64LOGOUTPUT(_x_)     Wow64LogMessage _x_


//
// Log flags
//
#define LF_NONE                0x00000000
#define LF_ERROR               0x00000001
#define LF_TRACE               0x00000002
#define LF_NTBASE_NAME         0x00000004
#define LF_NTBASE_FULL         0x00000008
#define LF_WIN32_NAME          0x00000010
#define LF_WIN32_FULL          0x00000020
#define LF_NTCON_NAME          0x00000040
#define LF_NTCON_FULL          0x00000080
#define LF_BASE_NAME           0x00000100
#define LF_BASE_FULL           0x00000200
#define LF_EXCEPTION           0x40000000
#define LF_CONSOLE             0x80000000

#define LF_NTBASE_ENABLED(x)   ((x) & (LF_NTBASE_NAME | LF_NTBASE_FULL))
#define LF_WIN32_ENABLED(x)    ((x) & (LF_WIN32_NAME | LF_WIN32_FULL))
#define LF_NTCON_ENABLED(x)    ((x) & (LF_NTCON_NAME | LF_NTCON_FULL))
#define LF_BASE_ENABLED(x)     ((x) & (LF_BASE_NAME | LF_BASE_FULL))


//
// Log a thunked API
//
typedef struct _THUNK_LOG_CONTEXT
{
    PULONG Stack32;
    UINT_PTR TableNumber;
    UINT_PTR ServiceNumber;
    BOOLEAN ServiceReturn;
    ULONG_PTR ReturnResult;
} THUNK_LOG_CONTEXT, *PTHUNK_LOG_CONTEXT;




WOW64LOGAPI
NTSTATUS
Wow64LogInitialize (
    VOID
    );

WOW64LOGAPI
NTSTATUS
Wow64LogSystemService(
    IN PTHUNK_LOG_CONTEXT LogContext);

WOW64LOGAPI
NTSTATUS
Wow64LogMessage(
    IN UINT_PTR Flags,
    IN PSZ Format,
    IN ...);

WOW64LOGAPI
NTSTATUS
Wow64LogMessageArgList(
    IN UINT_PTR Flags,
    IN PSZ Format,
    IN va_list ArgList);


WOW64LOGAPI
NTSTATUS
Wow64LogTerminate(
    VOID);

typedef NTSTATUS (*PFNWOW64LOGINITIALIZE)(VOID);
typedef NTSTATUS (*PFNWOW64LOGSYSTEMSERVICE)(IN PTHUNK_LOG_CONTEXT LogContext);
typedef NTSTATUS (*PFNWOW64LOGMESSAGEARGLIST)(IN UINT_PTR Flags,
                                              IN PSZ Format,
                                              IN va_list ArgList);
typedef NTSTATUS (*PFNWOW64LOGTERMINATE)(VOID);


#endif // _WOW64LOG_INCLUDE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\inc\wx86nt.h ===
/*++ BUILD Version: 0002     Increment this if a change has global effects


Module Name:

    wx86nt.h

Abstract:

    defines Nt i386 specific data structures (from nti386)


Revision History:

--*/

#ifndef _WX86NT_
#define _WX86NT_

// Size of Global Descriptor Table
#define  GDT_SIZE  4096    // big enough...
#define  IDT_SIZE  (8*256)

//
// Rename some of the platform dependent datatypes,
// so that we can access the i386 form on risc.
//
#ifndef _X86_
#define _X86_
#endif

#ifndef _FLOATING_SAVE_AREA
#define _FLOATING_SAVE_AREA _FLOATING_SAVE_AREA_WX86
#define FLOATING_SAVE_AREA FLOATING_SAVE_AREA_WX86
#define PFLOATING_SAVE_AREA PFLOATING_SAVE_AREA_WX86
#endif

#define _CONTEXT _CONTEXT_WX86
#define CONTEXT CONTEXT_WX86
#define PCONTEXT PCONTEXT_WX86
#define FXSAVE_FORMAT FXSAVE_FORMAT_WX86
#define PFXSAVE_FORMAT PFXSAVE_FORMAT_WX86


#ifdef _X86_

//
// Disable these two pramas that evaluate to "sti" "cli" on x86 so that driver
// writers to not leave them inadvertantly in their code.
//

#if !defined(MIDL_PASS)
#if !defined(RC_INVOKED)

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4164)   // disable C4164 warning so that apps that
                                // build with /Od don't get weird errors !
#ifdef _M_IX86
#pragma function(_enable)
#pragma function(_disable)
#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4164)   // reenable C4164 warning
#endif

#endif
#endif



//
//  Define the size of the 80387 save area, which is in the context frame.
//

#define SIZE_OF_80387_REGISTERS      80

//
// The following flags control the contents of the CONTEXT structure.
//

#if !defined(RC_INVOKED)

#define CONTEXT_i386    0x00010000    // this assumes that i386 and
#define CONTEXT_i486    0x00010000    // i486 have identical context records


#endif

#define MAXIMUM_SUPPORTED_EXTENSION     512

typedef struct _FLOATING_SAVE_AREA {
    DWORD   ControlWord;
    DWORD   StatusWord;
    DWORD   TagWord;
    DWORD   ErrorOffset;
    DWORD   ErrorSelector;
    DWORD   DataOffset;
    DWORD   DataSelector;
    BYTE    RegisterArea[SIZE_OF_80387_REGISTERS];
    DWORD   Cr0NpxState;
} FLOATING_SAVE_AREA;

typedef FLOATING_SAVE_AREA *PFLOATING_SAVE_AREA;

//
// Context Frame
//
//  This frame has a several purposes: 1) it is used as an argument to
//  NtContinue, 2) is is used to constuct a call frame for APC delivery,
//  and 3) it is used in the user level thread creation routines.
//
//  The layout of the record conforms to a standard call frame.
//

typedef struct _CONTEXT {

    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a threads context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //

    DWORD ContextFlags;

    //
    // This section is specified/returned if CONTEXT_DEBUG_REGISTERS is
    // set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT
    // included in CONTEXT_FULL.
    //

    DWORD   Dr0;
    DWORD   Dr1;
    DWORD   Dr2;
    DWORD   Dr3;
    DWORD   Dr6;
    DWORD   Dr7;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_FLOATING_POINT.
    //

    FLOATING_SAVE_AREA FloatSave;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_SEGMENTS.
    //

    DWORD   SegGs;
    DWORD   SegFs;
    DWORD   SegEs;
    DWORD   SegDs;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_INTEGER.
    //

    DWORD   Edi;
    DWORD   Esi;
    DWORD   Ebx;
    DWORD   Edx;
    DWORD   Ecx;
    DWORD   Eax;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_CONTROL.
    //

    DWORD   Ebp;
    DWORD   Eip;
    DWORD   SegCs;              // MUST BE SANITIZED
    DWORD   EFlags;             // MUST BE SANITIZED
    DWORD   Esp;
    DWORD   SegSs;

    //
    // This section is specified/returned if the ContextFlags word
    // contains the flag CONTEXT_EXTENDED_REGISTERS.
    // The format and contexts are processor specific
    //

    BYTE    ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];

} CONTEXT;



typedef CONTEXT *PCONTEXT;

// begin_ntminiport

#endif //_X86_

//
// Define the size of FP registers in the FXSAVE format
//
#define SIZE_OF_FX_REGISTERS        128

//
// Format of data for fxsave/fxrstor instruction
//

#include "pshpack1.h"

#ifndef WOW64EXTS_386

#ifndef _NTDBG_
typedef struct _FXSAVE_FORMAT {
    USHORT  ControlWord;
    USHORT  StatusWord;
    USHORT  TagWord;
    USHORT  ErrorOpcode;
    ULONG   ErrorOffset;
    ULONG   ErrorSelector;
    ULONG   DataOffset;
    ULONG   DataSelector;
    ULONG   MXCsr;
    ULONG   Reserved2;
    UCHAR   RegisterArea[SIZE_OF_FX_REGISTERS];
    UCHAR   Reserved3[SIZE_OF_FX_REGISTERS];
    UCHAR   Reserved4[224];
    UCHAR   Align16Byte[8];
} FXSAVE_FORMAT, *PFXSAVE_FORMAT;
#endif

#endif 

#include "poppack.h"

#define KGDT_R0_DATA    16
#define KGDT_R3_CODE    24
#define KGDT_R3_DATA    32
#define KGDT_TSS        40
#define KGDT_R0_PCR     48
#define KGDT_R3_TEB     56
#define KGDT_VDM_TILE   64
#define KGDT_LDT        72
#define KGDT_DF_TSS     80
#define KGDT_NMI_TSS    88


//
// Stop the renaming so that the risc datatypes
// are accessible by their normal names
//
#undef _FLOATING_SAVE_AREA
#undef FLOATING_SAVE_AREA
#undef PFLOATING_SAVE_AREA
#undef _CONTEXT
#undef CONTEXT
#undef PCONTEXT
#undef FXSAVE_FORMAT
#undef PFXSAVE_FORMAT


//
// set up the i386 CONTEXT bits for the ContextFlags
// warning: this MUST match nti386.h
//
#define CONTEXT_CONTROL_WX86             (CONTEXT_i386 | 0x00000001L) // SS:SP, CS:IP, FLAGS, BP
#define CONTEXT_INTEGER_WX86             (CONTEXT_i386 | 0x00000002L) // AX, BX, CX, DX, SI, DI
#define CONTEXT_SEGMENTS_WX86            (CONTEXT_i386 | 0x00000004L) // DS, ES, FS, GS
#define CONTEXT_FLOATING_POINT_WX86      (CONTEXT_i386 | 0x00000008L) // 387 state
#define CONTEXT_DEBUG_REGISTERS_WX86     (CONTEXT_i386 | 0x00000010L) // DB 0-3,6,7
#define CONTEXT_EXTENDED_REGISTERS_WX86  (CONTEXT_i386 | 0x00000020L) // cpu specific extensions
#define CONTEXT_FULL_WX86                (CONTEXT_CONTROL_WX86 | CONTEXT_INTEGER_WX86 | CONTEXT_SEGMENTS_WX86)
#undef _X86_

#endif /* _WX86NT_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\inc\wow64warn.h ===
/*++
                                                                                
Copyright (c) 1998 Microsoft Corporation

Module Name:

    wow64warn.h

Abstract:
    
    Global warning flags for wow64 project.
    
Author:

    5-Jan-1999 mzoran

Revision History:

--*/

// Make the compiler more struct.
#pragma warning(1:4033)   // function must return a value
#pragma warning(1:4035)   // no return value
// #pragma warning(1:4701)   // local may be used w/o init
#pragma warning(1:4702)   // Unreachable code
#pragma warning(1:4705)   // Statement has no effect
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\inc\wow64cpu.h ===
/*++
                                                                                
Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    wow64cpu.h

Abstract:
    
    Public header for wow64.dll
    
Author:

    24-May-1998 BarryBo

Revision History:
    8-9-99 [askhalid] added CpuNotifyDllLoad and CpuNotifyDllUnload.

--*/

#ifndef _WOW64CPU_INCLUDE
#define _WOW64CPU_INCLUDE

#ifdef __cplusplus
extern "C" {
#endif

//
// Make wow64cpu.dll exports __declspec(dllimport) when this header is included
// by non-wow64cpu components
//
#if !defined(_WOW64CPUAPI_)
#define WOW64CPUAPI DECLSPEC_IMPORT
#else
#define WOW64CPUAPI
#endif

#if !defined(_WOW64CPUDBGAPI_)
#define WOW64CPUDBGAPI DECLSPEC_IMPORT
#else
#define WOW64CPUDBGAPI
#endif


//
// Cache manipulation functions and Dll notification
//
WOW64CPUAPI VOID CpuFlushInstructionCache ( PVOID BaseAddress, ULONG Length );
WOW64CPUAPI VOID CpuNotifyDllLoad ( LPWSTR DllName, PVOID DllBase, ULONG DllSize );
WOW64CPUAPI VOID CpuNotifyDllUnload ( PVOID DllBase  );


//
// Init and term APIs
//
WOW64CPUAPI NTSTATUS CpuProcessInit(PWSTR pImageName, PSIZE_T pCpuThreadDataSize);
WOW64CPUAPI NTSTATUS CpuProcessTerm(HANDLE ProcessHandle);
WOW64CPUAPI NTSTATUS CpuThreadInit(PVOID pPerThreadData);
WOW64CPUAPI NTSTATUS CpuThreadTerm(VOID);


 

//
// Execution
//
WOW64CPUAPI VOID CpuSimulate(VOID);

//
// Exception handling, context manipulation
//
WOW64CPUAPI VOID  CpuResetToConsistentState(PEXCEPTION_POINTERS pExecptionPointers);
WOW64CPUAPI ULONG CpuGetStackPointer(VOID);
WOW64CPUAPI VOID  CpuSetStackPointer(ULONG Value);
WOW64CPUAPI VOID  CpuSetInstructionPointer(ULONG Value);
WOW64CPUAPI VOID  CpuResetFloatingPoint(VOID);

WOW64CPUAPI
NTSTATUS
CpuSuspendThread(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    OUT PULONG PreviousSuspendCount OPTIONAL);

WOW64CPUAPI
NTSTATUS
CpuGetContext(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    OUT PCONTEXT32 Context);

WOW64CPUAPI
NTSTATUS
CpuSetContext(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    PCONTEXT32 Context);


#if defined(DECLARE_CPU_DEBUGGER_INTERFACE)
//
// APIs required to be exported from a CPU debugger extension DLL.  The
// extension DLL may also export other NTSD extension exports which
// may be called directly from NTSD.  The APIs below are called from
// wow64exts.dll as worker routines to help the common debugging code.
//
// The CPU extension DLL must be named w64cpuex.dll.
//
typedef PVOID (*PWOW64GETCPUDATA)(HANDLE hProcess, HANDLE hThread);

WOW64CPUDBGAPI VOID CpuDbgInitEngapi(PWOW64GETCPUDATA lpGetCpuData);
WOW64CPUDBGAPI BOOL CpuDbgGetRemoteContext(PDEBUG_CLIENT Client, PVOID CpuData);
WOW64CPUDBGAPI BOOL CpuDbgSetRemoteContext(PDEBUG_CLIENT Client);   // push local context back remote
WOW64CPUDBGAPI BOOL CpuDbgGetLocalContext(PDEBUG_CLIENT Client, PCONTEXT32 Context);  // fetch context from the cache
WOW64CPUDBGAPI BOOL CpuDbgSetLocalContext(PDEBUG_CLIENT Client, PCONTEXT32 Context);  // push context to the cache
WOW64CPUDBGAPI VOID CpuDbgFlushInstructionCache(PDEBUG_CLIENT Client, PVOID Addr, DWORD Length);
WOW64CPUDBGAPI VOID CpuDbgFlushInstructionCacheWithHandle(HANDLE Process,PVOID Addr,DWORD Length);

typedef struct tagCpuRegFuncs {
    LPCSTR RegName;
    void (*SetReg)(ULONG);
    ULONG (*GetReg)(VOID);
} CPUREGFUNCS, *PCPUREGFUNCS;

WOW64CPUDBGAPI PCPUREGFUNCS CpuDbgGetRegisterFuncs(void);
#endif  // DECLARE_CPU_DEBUGGER_INTERFACE

#if defined(WOW64_HISTORY)

//
// The service history is enabled via a key in the registry.
//
// The key is in HKLM, and there are subkeys for enabling (1)
//
// No subkey area and/or no enable key means don't use the binary translator.
//
// Individual apps can be listed here with a DWORD subkey. A
// value of 1 says use history, and a value of 0 says don't. No value says
// use the global enable/disable to decide
//
//
//

#define CPUHISTORY_SUBKEY       L"Software\\Microsoft\\Wow64\\ServiceHistory"
#define CPUHISTORY_MACHINE_SUBKEY L"\\Registry\\Machine\\Software\\Microsoft\\Wow64\\ServiceHistory"
#define CPUHISTORY_ENABLE       L"Enable"
#define CPUHISTORY_SIZE         L"Size"
#define CPUHISTORY_MIN_SIZE     5

//
// Args are spelled out this way so the dt command in the debugger will show
// all args
//

typedef struct _Wow64Service_Buf {
    DWORD Api;
    DWORD RetAddr;
    DWORD Arg0;
    DWORD Arg1;
    DWORD Arg2;
    DWORD Arg3;
} WOW64SERVICE_BUF, *PWOW64SERVICE_BUF;

extern ULONG HistoryLength;

#endif

#ifdef __cplusplus
}
#endif

#endif  //_WOW64CPU_INCLUDE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\compiler\compilep.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    compilep.h

Abstract:

    This module is the private include file for the compiler.

Author:

    Dave Hastings (daveh) creation-date 09-Jul-1994

Revision History:


--*/

PENTRYPOINT
Compile(
    PENTRYPOINT ContainingEntrypoint,
    PVOID Eip
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\analysis\analysis.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    analysis.c

Abstract:

    This module contains the main file of the analysis
    module.

Author:

    Ori Gershony (t-orig) creation-date 6-July-1995

Revision History:

      24-Aug-1999 [askhalid] copied from 32-bit wx86 directory and make work for 64bit.


--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wx86.h>
#include <wx86nt.h>
#include <wx86cpu.h>
#include <cpuassrt.h>
#include <threadst.h>
#include <instr.h>
#include <analysis.h>
#include <decoder.h>
#include <frag.h>
#include <config.h>
#include <compiler.h>

ASSERTNAME;

 

//
// Macro to determine when to stop looking ahead during compilation.
//
#define STOP_DECODING(inst)     (Fragments[inst.Operation].Flags & OPFL_STOP_COMPILE)

//
// Map a REG_ constant (offset into cpu struct) into register bit map
// used by instruction data.
//
const DWORD MapRegNumToRegBits[0x1e] =
    {REGEAX, REGECX, REGEDX, REGEBX, REGESP, REGEBP, REGESI, REGEDI,
     0, 0, 0, 0, 0, 0,
     REGAX, REGCX, REGDX, REGBX, REGSP, REGBP, REGSI, REGDI,
     REGAL, REGCL, REGDL, REGBL, REGAH, REGCH, REGDH, REGBH };


ULONG
LocateEntryPoints(
    PINSTRUCTION InstructionStream,
    ULONG NumberOfInstructions
    )
/*++

Routine Description:

    This function scans the InstructionStream and marks instructions
    which begin entrypoint.  An instruction begins an entrypoint if its
    EntryPoint field has a different value than the previous instruction's
    value.  No instruction will have a NULL pointer.

    Note that in this pass, the EntryPoint field does *not* point to an
    ENTRYPOINT structure... it is only a marker.

Arguments:

    IntelStart -- The intel address of the first instruction in the stream

    IntelStart -- The last byte of the last intel instruction in the stream

Return Value:

    Count of EntryPoints located.
    
--*/
{
    ULONG i, j, intelDest;
    ULONG EntryPointCounter;
    ULONG IntelStart;
    ULONG IntelEnd;

    if (CompilerFlags & COMPFL_SLOW) {
        //
        // The compiler is supposed to generate slowmode code.  Each
        // x86 instruction gets its own ENTRYPOINT
        //
        EntryPointCounter=1;
        for (i=0; i<NumberOfInstructions; i++) {
            //
            // Mark all instructions which don't correspond to 0-byte NOPs
            // following optimized instructions as starting EntryPoints.
            //
            if (InstructionStream[i].Size) {
                EntryPointCounter++;
            }
            InstructionStream[i].EntryPoint = (PENTRYPOINT)EntryPointCounter;
        }

    } else {

        //
        // Find all instructions which need Entrypoints.
        //     Performance is O(n^2) in the worst case, although
        //     it will be typically much closer to O(n)
        //
        //  Instructions which mark the starts of Entrypoints have
        //  their .EntryPoint pointer set to non-NULL.  Instructions which
        //  don't require entrypoints have it set to NULL;
        //

        IntelStart = InstructionStream[0].IntelAddress;
        IntelEnd = IntelStart +
                   InstructionStream[NumberOfInstructions-1].IntelAddress +
                   InstructionStream[NumberOfInstructions-1].Size;

        //
        // The first instruction always gets an entrypoint
        //
        InstructionStream[0].EntryPoint = (PENTRYPOINT)1;

        //
        // Visit each instruction in turn
        //
        for (i=0; i<NumberOfInstructions; i++) {

            if (((i+1) < NumberOfInstructions) &&
                (Fragments[InstructionStream[i].Operation].Flags & OPFL_END_NEXT_EP)) {
                //
                // This instruction marks the end of an Entrypoint.  The next
                // instruction gets a new Entrypoint.
                //
                CPUASSERT(i < CpuInstructionLookahead-1 && i < NumberOfInstructions-1);
                InstructionStream[i+1].EntryPoint = (PENTRYPOINT)1;
            }

            // Now see if it is a direct control transfer instruction with a
            // destination that lies within this instruction stream.  If it is,
            // we want to create an Entry Point at the destination so that the
            // control transfer will be compiled directly to the patched form,
            // and won't have to be patched later.
            //
            if (Fragments[InstructionStream[i].Operation].Flags & OPFL_CTRLTRNS) {
                //
                // The instruction is a direct control-transfer.  If the
                // destination is within the InstructionStream, create an
                // Entrypoint at the destination.
                //

                if (InstructionStream[i].Operand1.Type == OPND_IMM ||
                    InstructionStream[i].Operand1.Type == OPND_NOCODEGEN) {
                    // Get the intel destination from the instruction structure.
                    intelDest = InstructionStream[i].Operand1.Immed;
                } else {
                    CPUASSERT(InstructionStream[i].Operand1.Type == OPND_ADDRREF );
                    // A FAR instruction - Operand1 is a ptr to a SEL:OFFSET pair
                    intelDest = *(UNALIGNED PULONG)(InstructionStream[i].Operand1.Immed);
                }

                // Get the intel destination from the instruction structure.
                // It is always an immediate with direct control transfers.
                
                if ((intelDest >= IntelStart) && (intelDest <= IntelEnd)) {
                    //
                    // Destination of the control-transfer is within the
                    // instructionstream.  Find the destination instruction.
                    //
                    if (intelDest > InstructionStream[i].IntelAddress) {
                        //
                        // The dest. address is at a higher address.
                        //
                        for (j=i+1; j<NumberOfInstructions; ++j) {
                            if (InstructionStream[j].IntelAddress == intelDest) {
                                break;
                            }
                        }
                    } else {
                        //
                        // The dest. address is at a lower address.
                        //
                        for (j=i; j>0; --j) {
                            if (InstructionStream[j].IntelAddress == intelDest) {
                                break;
                            }
                        }
                    }

                    //
                    // An exact match may not be found in the event that the
                    // app is punning (either a real pun or the app is jumping
                    // into the middle of an optimized instruction).  In
                    // either of the cases, defer entrypoint creation until
                    // the branch is actually taken.
                    //
                    if (j >= 0 && j < NumberOfInstructions) {
                        //
                        // Exact match was found.  Create an Entrypoint.
                        //
                        InstructionStream[j].EntryPoint = (PENTRYPOINT)1;
                    }
                }
            }  // if OPFL_CTRLTRNS
        } // for ()

        //
        // Convert the EntryPoint field from NULL/non-NULL to a unique
        // value for each range of instructions.
        //
        EntryPointCounter=1;
        i=0;
        while (i<NumberOfInstructions) {
            //
            // This instruction marks the beginning of a basic block
            //
            InstructionStream[i].EntryPoint = (PENTRYPOINT)EntryPointCounter;
            j=i+1;
            while (j < NumberOfInstructions) {
                if ((j >= NumberOfInstructions) ||
                    (InstructionStream[j].Size && InstructionStream[j].EntryPoint)) {
                    //
                    // Either ran out of instructions, or encountered an instruction
                    // which marks the start of the next basic block.  Note that
                    // 0-byte NOP instructions are not allowed to start basic blocks
                    // as that violates the rules of OPT_ instructions.
                    //
                    break;
                }
                InstructionStream[j].EntryPoint = (PENTRYPOINT)EntryPointCounter;
                j++;
            }
            EntryPointCounter++;
            i = j;
        }
    } // if not COMPFL_SLOW

    //
    // At this point, EntryPointCounter holds the number of EntryPoints
    // plus one, because we started the counter at 1, not 0.  Correct
    // that now.
    //
    EntryPointCounter--;

    return EntryPointCounter;
}


VOID
UpdateRegs(
    PINSTRUCTION pInstr,
    POPERAND Operand
    )
/*++
                                                                
Routine Description:

    Updates the list of registers referenced and/or modified based on the
    Operand.

Arguments:

    pInstr -- the instruction to examine

    Operand -- the operand of the instruction to examine

Return Value:

    return-value - none

--*/
{
    switch (Operand->Type) {
    case OPND_NOCODEGEN:
    case OPND_REGREF:
    if (Operand->Reg != NO_REG) {
        pInstr->RegsSet |= MapRegNumToRegBits[Operand->Reg];
    }
        break;

    case OPND_REGVALUE:
    if (Operand->Reg != NO_REG) {
        pInstr->RegsNeeded |= MapRegNumToRegBits[Operand->Reg];
    }
        break;

    case OPND_ADDRREF:
    case OPND_ADDRVALUE8:
    case OPND_ADDRVALUE16:
    case OPND_ADDRVALUE32:
        if (Operand->Reg != NO_REG) {
            pInstr->RegsNeeded |= MapRegNumToRegBits[Operand->Reg];
        }
        if (Operand->IndexReg != NO_REG) {
            pInstr->RegsNeeded |= MapRegNumToRegBits[Operand->IndexReg];
        }
        break;

    default:
        break;
    }
}


VOID
CacheIntelRegs(
    PINSTRUCTION InstructionStream,
    ULONG numInstr)
/*++
                                                                
Routine Description:

    This function deterimes what x86 registers, if any, can be cached in
    RISC preserved registers.

Arguments:

    InstructionStream -- The instruction stream returned by the decoder

    numInstr -- The length of InstructionStream

Return Value:

    return-value - none

--*/
{
    PINSTRUCTION pInstr;
    BYTE RegUsage[REGCOUNT];
    DWORD RegsToCache;
    int i;
    PENTRYPOINT PrevEntryPoint;

    //
    // Calculate the RegsSet and RegsNeeded for the bottommost instruction
    //
    pInstr = &InstructionStream[numInstr-1];
    pInstr->RegsSet = Fragments[pInstr->Operation].RegsSet;
    PrevEntryPoint = pInstr->EntryPoint;
    UpdateRegs(pInstr, &pInstr->Operand1);
    UpdateRegs(pInstr, &pInstr->Operand2);
    UpdateRegs(pInstr, &pInstr->Operand3);

    //
    // For each 32-bit register used as a parameter to this instruction,
    // set the usage count to 1.
    //
    for (i=0; i<REGCOUNT; ++i) {
        if (pInstr->RegsNeeded & (REGMASK<<(REGSHIFT*i))) {
            RegUsage[i] = 1;
        } else {
            RegUsage[i] = 0;
        }
    }

    //
    // Loop over instruction stream from bottom to top, starting at the
    // second-to-last instruction
    //
    for (pInstr--; pInstr >= InstructionStream; pInstr--) {

        //
        // Calculate the RegsSet and RegsNeeded values for this instruction
        //
        pInstr->RegsSet = Fragments[pInstr->Operation].RegsSet;
        UpdateRegs(pInstr, &pInstr->Operand1);
        UpdateRegs(pInstr, &pInstr->Operand2);
        UpdateRegs(pInstr, &pInstr->Operand3);

        RegsToCache = 0;

        if (PrevEntryPoint != pInstr->EntryPoint) {

            //
            // The current instruction marks the end of an Entrypoint.
            //
            PrevEntryPoint = pInstr->EntryPoint;

            //
            // For all x86 registers which have been read more than once
            // but not modified in the basic block, load them into the
            // cache before executing the first instruction in the basic
            // block.
            //
            for (i=0; i<REGCOUNT; ++i) {
                if (RegUsage[i] > 1) {
                    RegsToCache |= (REGMASK<<(REGSHIFT*i));
                }
            }

            //
            // Reset the RegUsage[] array to indicate no registers are
            // cached.
            //
            RtlZeroMemory(RegUsage, REGCOUNT);

        } else {

            //
            // For each 32-bit x86 register modified by this instruction,
            // update the caching info.
            //
            for (i=0; i<REGCOUNT; ++i) {
                DWORD RegBits = pInstr->RegsSet & (REGMASK<<(REGSHIFT*i));
                if (RegBits) {
                    //
                    // The ith 32-bit x86 register has been modified by this
                    // instruction
                    //
                    if (RegUsage[i] > 1) {
                        //
                        // There is more than one consumer of the modified
                        // value so it is worth caching.
                        //
                        RegsToCache |= RegBits;
                    }

                    //
                    // Since this x86 register was dirtied by this instruction,
                    // it usage count must be reset to 0.
                    //
                    RegUsage[i] = 0;
                }
            }
        }

        //
        // Update the list of x86 registers which can be loaded into
        // cache registers before the next instruction executes.
        //
        pInstr[1].RegsToCache |= RegsToCache;

        //
        // For each 32-bit register used as a parameter to this instruction,
        // bump the usage count.
        //
        for (i=0; i<REGCOUNT; ++i) {
            if (pInstr->RegsNeeded & (REGMASK<<(REGSHIFT*i))) {
                RegUsage[i]++;
            }
        }
    }
}


VOID
OptimizeInstructionStream(
    PINSTRUCTION IS,
    ULONG numInstr
    )
/*++
                                                                
Routine Description:

    This function performs various optimization on the instruction stream
    retured by the decoder.

Arguments:

    IS -- The instruction stream returned by the decoder

    numInstr -- The length of IS

Return Value:

    return-value - none

--*/
{
    ULONG i;

    CPUASSERTMSG(numInstr, "Cannot optimize 0-length instruction stream");

    //
    // Pass 1: Optimize x86 instruction stream, replacing single x86
    //         instructions with special-case instructions, and replacing
    //         multiple x86 instructions with single special-case OPT_
    //         instructions
    //
    for (i=0; i<numInstr; ++i) {

        switch  (IS[i].Operation) {
        case OP_Push32:
            if (i < numInstr-2
                && IS[i].Operand1.Type == OPND_REGVALUE){

                if (IS[i].Operand1.Reg == GP_EBP) {
                    // OP_OPT_SetupStack --
                    //      push ebp
                    //      mov ebp, esp
                    //      sub esp, x
                    if ((IS[i+1].Operation == OP_Mov32) &&
                        (IS[i+1].Operand1.Type == OPND_REGREF) &&
                        (IS[i+1].Operand1.Reg == GP_EBP) &&
                        (IS[i+1].Operand2.Type == OPND_REGVALUE) &&
                        (IS[i+1].Operand2.Reg == GP_ESP) &&
                        (IS[i+2].Operation == OP_Sub32) &&
                        (IS[i+2].Operand1.Type == OPND_REGREF) &&
                        (IS[i+2].Operand1.Reg == GP_ESP) &&
                        (IS[i+2].Operand2.Type == OPND_IMM)){

                        IS[i].Operation = OP_OPT_SetupStack;
                        IS[i].Operand1.Type = OPND_IMM;
                        IS[i].Operand1.Immed = IS[i+2].Operand2.Immed;
                        IS[i].Size += IS[i+1].Size + IS[i+2].Size;
                        IS[i].Operand2.Type = OPND_NONE;
                        IS[i+1].Operation = OP_Nop;
                        IS[i+1].Operand1.Type = OPND_NONE;
                        IS[i+1].Operand2.Type = OPND_NONE;
                        IS[i+1].Size = 0;
                        IS[i+2].Operation = OP_Nop;
                        IS[i+2].Operand1.Type = OPND_NONE;
                        IS[i+2].Operand2.Type = OPND_NONE;
                        IS[i+2].Size = 0;
                        i+=2;
                        break;
                    }
                } else if (IS[i].Operand1.Reg == GP_EBX) {
                    // OP_OPT_PushEbxEsiEdi --
                    //      push ebx
                    //      push esi
                    //      push edi
                    if ((IS[i+1].Operation == OP_Push32) &&
                        (IS[i+1].Operand1.Type == OPND_REGVALUE) &&
                        (IS[i+1].Operand1.Reg == GP_ESI) &&
                        (IS[i+2].Operation == OP_Push32) &&
                        (IS[i+2].Operand1.Type == OPND_REGVALUE) &&
                        (IS[i+2].Operand1.Reg == GP_EDI)){

                        IS[i].Operation = OP_OPT_PushEbxEsiEdi;
                        IS[i].Size += IS[i+1].Size + IS[i+2].Size;
                        IS[i].Operand1.Type = OPND_NONE;
                        IS[i].Operand2.Type = OPND_NONE;
                        IS[i+1].Operation = OP_Nop;
                        IS[i+1].Operand1.Type = OPND_NONE;
                        IS[i+1].Operand2.Type = OPND_NONE;
                        IS[i+1].Size = 0;
                        IS[i+2].Operation = OP_Nop;
                        IS[i+2].Operand1.Type = OPND_NONE;
                        IS[i+2].Operand2.Type = OPND_NONE;
                        IS[i+2].Size = 0;
                        i+=2;
                        break;
                    }
                }
            }

            //
            // It is not one of the other special PUSH sequences, so see
            // if there are two consecutive PUSHes to merge together.  Note:
            // If the second PUSH references ESP, the two cannot be merged
            // because the value is computed before 4 is subtracted from ESP.
            //  ie. the following is disallowed:
            //        PUSH EAX
            //        PUSH ESP  ; second operand to Push2 would have been
            //                  ; built before the PUSH EAX was executed.
            //
            if (i < numInstr-1 &&
                !IS[i].FsOverride &&
                !IS[i+1].FsOverride &&
                IS[i+1].Operation == OP_Push32 &&
                IS[i+1].Operand1.Reg != GP_ESP &&
                IS[i+1].Operand1.IndexReg != GP_ESP) {

                IS[i].Operation = OP_OPT_Push232;
                IS[i].Operand2 = IS[i+1].Operand1;
                IS[i].Size += IS[i+1].Size;
                IS[i+1].Operation = OP_Nop;
                IS[i+1].Operand1.Type = OPND_NONE;
                IS[i+1].Size = 0;
                i++;
            }

            break;

        case OP_Pop32:
            // OP_OPT_PopEdiEsiEbx
            //      pop edi
            //      pop esi
            //      pop ebx
            if (i < numInstr-2 &&
                (IS[i].Operand1.Type == OPND_REGREF) &&
                (IS[i].Operand1.Reg == GP_EDI) &&
                (IS[i+1].Operation == OP_Pop32) &&
                (IS[i+1].Operand1.Type == OPND_REGREF) &&
                (IS[i+1].Operand1.Reg == GP_ESI) &&
                (IS[i+2].Operation == OP_Pop32) &&
                (IS[i+2].Operand1.Type == OPND_REGREF) &&
                (IS[i+2].Operand1.Reg == GP_EBX)){

                IS[i].Operation = OP_OPT_PopEdiEsiEbx;
                IS[i].Size += IS[i+1].Size + IS[i+2].Size;
                IS[i].Operand1.Type = OPND_NONE;
                IS[i].Operand2.Type = OPND_NONE;
                IS[i+1].Operation = OP_Nop;
                IS[i+1].Operand1.Type = OPND_NONE;
                IS[i+1].Operand2.Type = OPND_NONE;
                IS[i+1].Size = 0;
                IS[i+2].Operation = OP_Nop;
                IS[i+2].Operand1.Type = OPND_NONE;
                IS[i+2].Operand2.Type = OPND_NONE;
                IS[i+2].Size = 0;
                i+=2;
            } else if (i < numInstr-1 &&
                !IS[i].FsOverride &&
                !IS[i].FsOverride &&
                IS[i].Operand1.Type == OPND_REGREF &&
                IS[i+1].Operation == OP_Pop32 &&
                IS[i+1].Operand1.Type == OPND_REGREF) {

                // Fold the two POPs together.  Both operands are REGREF,
                // so there is no problem with interdependencies between
                // memory touched by the first POP modifying the address
                // of the second POP.  ie. the following is not merged:
                //              POP EAX
                //              POP [EAX]   ; depends on results of first POP
                IS[i].Operation = OP_OPT_Pop232;
                IS[i].Operand2 = IS[i+1].Operand1;
                IS[i].Size += IS[i+1].Size;
                IS[i+1].Operation = OP_Nop;
                IS[i+1].Operand1.Type = OPND_NONE;
                IS[i+1].Size = 0;
                i++;
            }
            break;

        case OP_Xor32:
        case OP_Sub32:
            if (IS[i].Operand1.Type == OPND_REGREF &&
                IS[i].Operand2.Type == OPND_REGVALUE &&
                IS[i].Operand1.Reg == IS[i].Operand2.Reg) {
                // Instruction is XOR samereg, samereg  (ie. XOR EAX, EAX),
                //  or SUB samereg, samereg             (ie. SUB ECX, ECX).
                // Emit OP_OPT_ZERO32 samereg
                IS[i].Operand2.Type = OPND_NONE;
                IS[i].Operation = OP_OPT_ZERO32;
            }
            break;

        case OP_Test8:
            if (IS[i].Operand1.Type == OPND_REGVALUE &&
                IS[i].Operand2.Type == OPND_REGVALUE &&
                IS[i].Operand1.Reg == IS[i].Operand2.Reg) {
                // Instruction is TEST samereg, samereg (ie. TEST EAX, EAX)
                // Emit OP_OPT_FastTest8/16/32
                IS[i].Operand1.Type = OPND_REGVALUE;
                IS[i].Operand2.Type = OPND_NONE;
                IS[i].Operation = OP_OPT_FastTest8;
            }
            break;

        case OP_Test16:
            if (IS[i].Operand1.Type == OPND_REGVALUE &&
                IS[i].Operand2.Type == OPND_REGVALUE &&
                IS[i].Operand1.Reg == IS[i].Operand2.Reg) {
                // Instruction is TEST samereg, samereg (ie. TEST EAX, EAX)
                // Emit OP_OPT_FastTest8/16/32
                IS[i].Operand1.Type = OPND_REGVALUE;
                IS[i].Operand2.Type = OPND_NONE;
                IS[i].Operation = OP_OPT_FastTest16;
            }
            break;

        case OP_Test32:
            if (IS[i].Operand1.Type == OPND_REGVALUE &&
                IS[i].Operand2.Type == OPND_REGVALUE &&
                IS[i].Operand1.Reg == IS[i].Operand2.Reg) {
                // Instruction is TEST samereg, samereg (ie. TEST EAX, EAX)
                // Emit OP_OPT_FastTest8/16/32
                IS[i].Operand1.Type = OPND_REGVALUE;
                IS[i].Operand2.Type = OPND_NONE;
                IS[i].Operation = OP_OPT_FastTest32;
            }
            break;

        case OP_Cmp32:
            if (i<numInstr+1 && IS[i+1].Operation == OP_Sbb32 &&
                IS[i+1].Operand1.Type == OPND_REGREF &&
                IS[i+1].Operand2.Type == OPND_REGVALUE &&
                IS[i+1].Operand1.Reg == IS[i+1].Operand2.Reg) {
                // The two instructions are:
                //     CMP anything1, anything2
                //     SBB samereg, samereg
                // The optimized instruction is:
                //     Operation = either CmpSbb32 or CmpSbbNeg32
                //     Operand1  = &samereg  (passed as REGREF)
                //     Operand2  = anything1 (passed as ADDRVAL32 or REGVAL)
                //     Operand3  = anything2 (passed as ADDRVAL32 or REGVAL)
                IS[i].Operand3 = IS[i].Operand2;
                IS[i].Operand2 = IS[i].Operand1;
                IS[i].Operand1 = IS[i+1].Operand1;
                if (i<numInstr+2 && IS[i+2].Operation == OP_Neg32 &&
                    IS[i+2].Operand1.Type == OPND_REGREF &&
                    IS[i+2].Operand1.Reg == IS[i+1].Operand1.Reg) {
                    // The third instruction is NEG samereg, samereg
                    IS[i].Operation = OP_OPT_CmpSbbNeg32;
                    IS[i+2].Operation = OP_Nop;
                    IS[i+2].Operand1.Type = OPND_NONE;
                    IS[i+2].Operand2.Type = OPND_NONE;
                    IS[i+2].Size = 0;
                } else {
                    IS[i].Operation = OP_OPT_CmpSbb32;
                }
                IS[i+1].Operation = OP_Nop;
                IS[i+1].Operand1.Type = OPND_NONE;
                IS[i+1].Operand2.Type = OPND_NONE;
                IS[i+1].Size = 0;
                i++;
            }
            break;

        case OP_Cwd16:
            if (i<numInstr+1 && IS[i+1].Operation == OP_Idiv16) {
                IS[i].Operation = OP_OPT_CwdIdiv16;
                IS[i].Operand1 = IS[i+1].Operand1;
                IS[i].Size += IS[i+1].Size;
                IS[i+1].Operation = OP_Nop;
                IS[i+1].Operand1.Type = OPND_NONE;
                IS[i+1].Size = 0;
                i++;
            }
            break;

        case OP_Cwd32:
            if (i<numInstr+1 && IS[i+1].Operation == OP_Idiv32) {
                IS[i].Operation = OP_OPT_CwdIdiv32;
                IS[i].Operand1 = IS[i+1].Operand1;
                IS[i].Size += IS[i+1].Size;
                IS[i+1].Operation = OP_Nop;
                IS[i+1].Operand1.Type = OPND_NONE;
                IS[i+1].Size = 0;
                i++;
            }
            break;

        case OP_FP_FNSTSW:
            if (i<numInstr+1 && IS[i+1].Operation == OP_Sahf &&
                IS[i].Operand1.Type == OPND_REGREF &&
                IS[i].Operand1.Reg == GP_AX) {

                // Replace FNSTSW AX / SAHF by one instruction
                IS[i].Operation = OP_OPT_FNSTSWAxSahf;
                IS[i].Operand1.Type = OPND_NONE;
                IS[i].Size += IS[i+1].Size;
                IS[i+1].Operation = OP_Nop;
                IS[i+1].Size = 0;
                i++;
            }
            break;

        case OP_FP_FSTP_STi:
            if (IS[i].Operand1.Immed == 0) {
                IS[i].Operand1.Type = OPND_NONE;
                IS[i].Operation = OP_OPT_FSTP_ST0;
            }
            break;

        }
    }
}


VOID
OptimizeIntelFlags(
    PINSTRUCTION IS,
    ULONG numInstr
    )
/*++
                                                                
Routine Description:

    This function analysis x86 flag register usage and switches instructions
    to use NoFlags versions if possible.

Arguments:

    IS -- The instruction stream returned by the decoder

    numInstr -- The length of IS

Return Value:

    return-value - none

--*/
{
    USHORT FlagsNeeded;     // flags required to execute current x86 instr
    USHORT FlagsToGenerate; // flags which current x86 instr must generate
    PFRAGDESCR pFragDesc;   // ptr to Fragments[] array for current instr
    ULONG i;                // instruction index
    BOOL fPassNeeded = TRUE;// TRUE if the outer loop needs to loop once more
    ULONG PassNumber = 0;   // number of times outer loop has looped
    PENTRYPOINT pEPDest;    // Entrypoint for destination of a ctrl transfer
    USHORT KnownFlagsNeeded[MAX_INSTR_COUNT]; // flags needed for each instr

    while (fPassNeeded) {

        //
        // This loop is executed at most two times.  The second pass is only
        // required if there is a control-transfer instruction whose
        // destination is within the Instruction Stream and at a lower
        // Intel address  (ie. a backwards JMP).
        //
        fPassNeeded = FALSE;
        PassNumber++;
        CPUASSERT(PassNumber <= 2);

        //
        // Iterate over all x86 instructions decoded, from bottom to top,
        // propagating flags info up.  Start off by assuming all x86 flags
        // must be up-to-date at the end of the last basic block.
        //
        FlagsNeeded = ALLFLAGS;
        i = numInstr;
        do {
            i--;
            pFragDesc = &Fragments[IS[i].Operation];

            //
            // Calculate what flags will need to be computed by this
            // instruction and ones before this.
            //
            KnownFlagsNeeded[i] = FlagsNeeded | pFragDesc->FlagsNeeded;
            FlagsToGenerate = FlagsNeeded & pFragDesc->FlagsSet;

            //
            // Calculate what flags this instruction will need to have
            // computed before it can be executed.
            //
            FlagsNeeded = (FlagsNeeded & ~FlagsToGenerate) |
                           pFragDesc->FlagsNeeded;

            if (pFragDesc->Flags & OPFL_CTRLTRNS) {
                ULONG IntelDest = IS[i].Operand1.Immed;

                //
                // For control-transfer instructions, FlagsNeeded also includes
                // the flags required for the destination of the transfer.
                //
                if (IS[0].IntelAddress <= IntelDest &&
                    i > 0 && IS[i-1].IntelAddress >= IntelDest) {
                    //
                    // The destination of the control-transfer is at a lower
                    // address in the Instruction Stream.
                    //

                    if (PassNumber == 1) {
                        //
                        // Need to make a second pass over the flags
                        // optimizations in order to determine what flags are
                        // needed for the destination address.
                        //
                        fPassNeeded = TRUE;
                        FlagsNeeded = ALLFLAGS; // assume all flags are needed
                    } else {
                        ULONG j;
                        USHORT NewFlagsNeeded;

                        //
                        // Search for the IntelDest within the Instruction
                        // Stream.  IntelDest may not be found if there is
                        // a pun.
                        //
                        NewFlagsNeeded = ALLFLAGS;  // assume there is a pun
                        for (j=0; j < i; ++j) {
                            if (IS[j].IntelAddress == IntelDest) {
                                NewFlagsNeeded = KnownFlagsNeeded[j];
                                break;
                            }
                        }

                        FlagsNeeded |= NewFlagsNeeded;
                    }
                } else if (IS[i+1].IntelAddress <= IntelDest &&
                           IntelDest <= IS[numInstr-1].IntelAddress) {
                    //
                    // The destination of the control-transfer is at a higher
                    // address in the Instruction Stream.  Pick up the
                    // already-computed FlagsNeeded for the destination.
                    //
                    ULONG j;
                    USHORT NewFlagsNeeded = ALLFLAGS;   // assume a pun

                    for (j=i+1; j < numInstr; ++j) {
                        if (IS[j].IntelAddress == IntelDest) {
                            NewFlagsNeeded = KnownFlagsNeeded[j];
                            break;
                        }
                    }

                    FlagsNeeded |= NewFlagsNeeded;

                } else {
                    //
                    // Destination of the control-transfer is unknown.  Assume
                    // the worst:  all flags are required.
                    //
                    FlagsNeeded = ALLFLAGS;
                }
            }

            if (!(FlagsToGenerate & pFragDesc->FlagsSet) &&
                (pFragDesc->Flags & OPFL_HASNOFLAGS)) {
                //
                // This instruction is not required to generate any flags, and
                // it has a NOFLAGS version.  Update the flags that need to be
                // computed by instructions before this one, and modify the
                // Operation number to point at the NoFlags fragment.
                //
                FlagsToGenerate &= pFragDesc->FlagsSet;
                if (pFragDesc->Flags & OPFL_ALIGN) {
                    IS[i].Operation += 2;
                } else {
                    IS[i].Operation ++;
                }

                if (IS[i].Operation == OP_OPT_ZERONoFlags32) {
                    //
                    // Special-case this to be a "mov [value], zero" so it is
                    // inlined.
                    //
                    IS[i].Operation = OP_Mov32;
                    IS[i].Operand2.Type = OPND_IMM;
                    IS[i].Operand2.Immed = 0;
                }
            }
        } while (i);
    }
}

VOID
DetermineEbpAlignment(
    PINSTRUCTION InstructionStream,
    ULONG numInstr
    )
/*++
                                                                
Routine Description:

    For each instruction in InstructionStream[], sets Instruction->EbpAligned
    based on whether EBP is assumed to be DWORD-aligned or not.  EBP is
    assumed to be DWORD-aligned if a "MOV EBP, ESP" instruction is seen, and
    it is assumed to become unaligned at the first instruction which is
    flagged as modifying EBP.

Arguments:

    InstructionStream -- The instruction stream returned by the decoder

    numInstr -- The length of InstructionStream

Return Value:

    return-value - none

--*/
{
    ULONG i;
    BOOL EbpAligned = FALSE;

    for (i=0; i<numInstr; ++i) {
        if (InstructionStream[i].RegsSet & REGEBP) {
            //
            // This instruction modified EBP
            //
            if (InstructionStream[i].Operation == OP_OPT_SetupStack ||
                InstructionStream[i].Operation == OP_OPT_SetupStackNoFlags ||
                (InstructionStream[i].Operation == OP_Mov32 &&
                 InstructionStream[i].Operand2.Type == OPND_REGVALUE &&
                 InstructionStream[i].Operand2.Reg == GP_ESP)) {
                //
                // The instruction is either "MOV EBP, ESP" or one of the
                // SetupStack fragments (which contains a "MOV EBP, ESP")
                // assume Ebp is aligned from now on.
                //
                EbpAligned = TRUE;
            } else {
                EbpAligned = FALSE;
            }
        }

        InstructionStream[i].EbpAligned = EbpAligned;
    }
}

ULONG
GetInstructionStream(
    PINSTRUCTION InstructionStream,
    PULONG NumberOfInstructions,
    PVOID pIntelInstruction,
    PVOID pLastIntelInstruction
)
/*++
                                                                
Routine Description:

    Returns an instruction stream to the compiler.  The instruction
    stream is terminated either when the buffer is full, or when
    we reach a control transfer instruction.

Arguments:

    InstructionStream -- A pointer to the buffer where the decoded
        instructions are stored.

    NumberOfInstructions -- Upon entry, this variable contains the
        maximal number of instructions the buffer can hold.  When
        returning, it contains the actual number of instructions
        decoded.

    pIntelInstruction -- A pointer to the first real intel instruction
        to be decoded.

    pLastIntelInstruction -- A pointer to the last intel instruction to be
        compiled, 0xffffffff if not used.

Return Value:

    Number of entrypoints required to describe the decoded instruction
    stream.

--*/
{
    ULONG numInstr=0;
    ULONG maxBufferSize;
    ULONG cEntryPoints;

    maxBufferSize = (*NumberOfInstructions);

    //
    // Zero-fill the InstructionStream.  The decoder depends on this.
    //
    RtlZeroMemory(InstructionStream, maxBufferSize*sizeof(INSTRUCTION));

#if DBG
    //
    // Do a little analysis on the address we're about to decode.  If
    // the address is part of a non-x86 image, log that to the debugger.
    // That probably indicates a thunking problem.  If the address is not
    // part of an image, warn that the app is running generated code.
    //
    try {
        USHORT Instr;

        //
        // Try to read the instruction about to be executed.  If we get
        // an access violation, use 0 as the value of the instruction.
        //
        Instr = 0;

        //
        // Ignore BOP instructions - we assume we know what's going on with
        // them.
        //
        if (Instr != 0xc4c4) {

            NTSTATUS st;
            MEMORY_BASIC_INFORMATION mbi;

            st = NtQueryVirtualMemory(NtCurrentProcess(),
                                      pIntelInstruction,
                                      MemoryBasicInformation,
                                      &mbi,
                                      sizeof(mbi),
                                      NULL);
            if (NT_SUCCESS(st)) {
                PIMAGE_NT_HEADERS Headers;

                Headers = RtlImageNtHeader(mbi.AllocationBase);
                if (!Headers || Headers->FileHeader.Machine != IMAGE_FILE_MACHINE_I386) {
                    LOGPRINT((TRACELOG, "CPU Analysis warning:  jumping from Intel to non-intel code at 0x%X\r\n", pIntelInstruction));
                }
            } else {
                // Eip isn't pointing anywhere???
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        ;
    }
#endif  //DBG

    while (numInstr < maxBufferSize) {

        DecodeInstruction ((DWORD) (ULONGLONG)pIntelInstruction, InstructionStream+numInstr);
        if ((STOP_DECODING(InstructionStream[numInstr])) ||
            (pIntelInstruction >= pLastIntelInstruction)) {

            // We reached a control transfer instruction
            numInstr++;
            (*NumberOfInstructions) = numInstr;
            break; // SUCCESS
        }
        pIntelInstruction = (PVOID) ((ULONGLONG)pIntelInstruction + (InstructionStream+numInstr)->Size);

        numInstr++;
    }

    //
    // Optimize x86 code by merging x86 instructions into meta-instructions
    // and cleaning up special x86 idioms.
    //
    if (!(CompilerFlags & COMPFL_SLOW)) {
        OptimizeInstructionStream (InstructionStream, numInstr);
    }

    //
    // Determine where all basic blocks are by filling in the EntryPoint
    // field in each instruction.  This must be done after
    // OptimizeInstructionStream() runs so that EntryPoints don't fall
    // into the middle of meta-instructions.
    //
    cEntryPoints = LocateEntryPoints(InstructionStream, numInstr);

    //
    // Perform optimizations which require knowledge of EntryPoints
    //
    if (numInstr > 2 && !(CompilerFlags & COMPFL_SLOW)) {
        if (!CpuDisableNoFlags) {
            OptimizeIntelFlags(InstructionStream, numInstr);
        }

        if (!CpuDisableRegCache) {
            CacheIntelRegs(InstructionStream, numInstr);
        }

        if (!CpuDisableEbpAlign) {
            DetermineEbpAlignment(InstructionStream, numInstr);
        }
    }

    return cEntryPoints;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\compiler\compile.c ===
/*++    

Copyright (c) 1996  Microsoft Corporation

Module Name:

    compile.c

Abstract:

    This module contains code to put the fragments into the translation
    cache.

Author:

    Dave Hastings (daveh) creation-date 27-Jun-1995

Revision History:

    Dave Hastings (daveh) 16-Jan-1996
        Move operand handling into fragment library
        
Notes:
    We don't yet have any code to handle processor errata

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#define _WX86CPUAPI_

#include <wx86.h>
#include <wx86nt.h>
#include <wx86cpu.h>
#include <cpuassrt.h>
#include <config.h>
#include <instr.h>
#include <threadst.h>
#include <frag.h>
#include <analysis.h>
#include <entrypt.h>
#include <compilep.h>
#include <compiler.h>
#include <tc.h>
#include <mrsw.h>
#include <stdio.h>
#include <stdlib.h>

ASSERTNAME;

#if _ALPHA_
    #define MAX_RISC_COUNT  32768
#else
    #define MAX_RISC_COUNT  16384
#endif

DWORD TranslationCacheFlags;        // indicates what kind of code is in the TC

#ifdef CODEGEN_PROFILE
DWORD EPSequence;
#endif

//
// This is guaranteed only to be accessed by a single thread at a time.
//
INSTRUCTION InstructionStream[MAX_INSTR_COUNT];
ULONG NumberOfInstructions;


PENTRYPOINT
CreateEntryPoints(
    PENTRYPOINT ContainingEntrypoint,
    PBYTE EntryPointMemory
    )
/*++

Routine Description:

    This function takes the InstructionStream and creates entrypoints
    from the information computed by LocateEntrypoints().

    Entrypoints are then added into the Red/Black tree.

Arguments:

    ContainingEntrypoint -- entrypoint which describes this range of intel
                            code already

    EntryPointMemory -- pre-allocated Entrypoint memory
    
Return Value:

    The Entry Point corresponding to the first instruction
    
--*/
{
    ULONG i, j, intelDest;
    PEPNODE EP;
    PENTRYPOINT EntryPoint;
    PENTRYPOINT PrevEntryPoint;
#ifdef CODEGEN_PROFILE
    ULONG CreateTime;
    
    CreateTime = GetCurrentTime();
    EPSequence++;
#endif

    //
    // Performance is O(n) always.
    //

    i=0;
    PrevEntryPoint = InstructionStream[0].EntryPoint;
    while (i<NumberOfInstructions) {

        //
        // This loop skips from entrypoint to entrypoint.
        //
        CPUASSERT(i == 0 || InstructionStream[i-1].EntryPoint != PrevEntryPoint);

        //
        // Get an entrypoint node from the EntryPointMemory allocated by
        // our caller.
        //
        if (ContainingEntrypoint) {
            EntryPoint = (PENTRYPOINT)EntryPointMemory;
            EntryPointMemory+=sizeof(ENTRYPOINT);
        } else {
            EP = (PEPNODE)EntryPointMemory;
            EntryPoint = &EP->ep;
            EntryPointMemory+=sizeof(EPNODE);
        }

        //
        // Find the next entrypoint and the RISC address of the next
        // instruction which begins an entrypoint.  Each instruction
        // in that range contains a pointer to the containing Entrypoint.
        //
        for (j=i+1; j<NumberOfInstructions; ++j) {
            if (InstructionStream[j].EntryPoint != PrevEntryPoint) {
                PrevEntryPoint = InstructionStream[j].EntryPoint;
                break;
            }
            InstructionStream[j].EntryPoint = EntryPoint;
        }

        //
        // Fill in the Entrypoint structure
        //
#ifdef CODEGEN_PROFILE        
        EntryPoint->SequenceNumber = EPSequence;
        EntryPoint->CreationTime = CreateTime;
#endif
        EntryPoint->intelStart = (PVOID)InstructionStream[i].IntelAddress;
        if (j < NumberOfInstructions) {
            EntryPoint->intelEnd = (PVOID)(InstructionStream[j].IntelAddress-1);
        } else {
            ULONG Prev;

            for (Prev=j-1; InstructionStream[Prev].Size == 0; Prev--)
               ;
            EntryPoint->intelEnd = (PVOID)(InstructionStream[Prev].IntelAddress +
                                           InstructionStream[Prev].Size - 1);
        }
        InstructionStream[i].EntryPoint = EntryPoint;

        if (ContainingEntrypoint) {
            //
            // Link this sub-entrypoint into the containing entrypoint
            //
            EntryPoint->SubEP = ContainingEntrypoint->SubEP;
            ContainingEntrypoint->SubEP = EntryPoint;

        } else {
            INT RetVal;

            //
            // Insert it into the EP tree
            //
            EntryPoint->SubEP = NULL;
            RetVal = insertEntryPoint(EP);
            CPUASSERT(RetVal==1);

        }

        //
        // Advance to the next instruction which contains an
        // Entrypoint.
        //
        i=j;
    }

    if (ContainingEntrypoint) {
        // Indicate that the Entrypoints are present
        EntrypointTimestamp++;
    }

    return InstructionStream[0].EntryPoint;
}


PENTRYPOINT
Compile(
    PENTRYPOINT ContainingEntrypoint,
    PVOID Eip
    )
/*++

Routine Description:

    This function puts together code fragments to execute the Intel
    code stream at Eip.  It gets a stream of pre-decoded instructions
    from the code analysis module.

Arguments:

    ContaingingEntrypoint -- If NULL, there is no entrypoint which already
                             describes the Intel address to be compiled.
                             Otherwise, this entrypoint describes the
                             Intel address.  The caller ensures that the
                             Entrypoint->intelStart != Eip.
    Eip -- Supplies the location to compile from
    
Return Value:

    pointer to the entrypoint for the compiled code
    
--*/
{

    ULONG NativeSize, InstructionSize, IntelSize, OperationSize;
    PCHAR CodeLocation, CurrentCodeLocation;
    ULONG i;
    PENTRYPOINT Entrypoint;
    INT RetVal;
    PVOID StopEip;
    DWORD cEntryPoints;
    PBYTE EntryPointMemory;
    DWORD EPSize;

#if defined(_ALPHA_)
    ULONG ECUSize, ECUOffset;
#endif
#if DBG
    DWORD OldEPTimestamp;
#endif
    DECLARE_CPU;

    if (ContainingEntrypoint) {
        //
        // See if the entrypoint exactly describes the x86 address
        //
        if (ContainingEntrypoint->intelStart == Eip) {
            return ContainingEntrypoint;
        }

        //
        // No need to compile past the end of the current entrypoint
        //
        StopEip = ContainingEntrypoint->intelEnd;

        //
        // Assert that the ContainingEntrypoint is actually an EPNODE.
        //
        CPUASSERTMSG( ((PEPNODE)ContainingEntrypoint)->intelColor == RED ||
                      ((PEPNODE)ContainingEntrypoint)->intelColor == BLACK,
                     "ContainingEntrypoint is not an EPNODE!");
    } else {
        //
        // Find out if there is a compiled block following this one
        //
        Entrypoint = GetNextEPFromIntelAddr(Eip);
        if (Entrypoint == NULL) {
            StopEip = (PVOID)0xffffffff;
        } else {
            StopEip = Entrypoint->intelStart;
        }
    }

    //
    // Get the stream of instructions to compile.
    // If the Trap Flag is set, then compile only one instruction
    //
    if (cpu->flag_tf) {
        NumberOfInstructions = 1;
    } else {
        NumberOfInstructions = CpuInstructionLookahead;
    }
 

    cEntryPoints = GetInstructionStream(InstructionStream,
                                        &NumberOfInstructions,
                                        Eip,
                                        StopEip
                                        );

    //
    // Pre-allocate enough space from the Translation Cache to store
    // the compiled code.
    //
    CodeLocation = AllocateTranslationCache(MAX_RISC_COUNT);

    //
    // Allocate memory for all of the Entrypoints.  This must be done
    // after the Translation Cache allocation, in case that allocation
    // caused a cache flush.
    //
    

    if (ContainingEntrypoint) {
        EPSize = cEntryPoints * sizeof(ENTRYPOINT);
    } else {
        EPSize = cEntryPoints * sizeof(EPNODE);
    }
    EntryPointMemory = (PBYTE)EPAlloc(EPSize);


    if (!EntryPointMemory) {
        //
        // Either failed to commit extra pages of memory to grow Entrypoint
        // memory, or there are so many entrypoints that the the reserved
        // size has been exceeded.  Flush the Translation Cache, which will
        // free up memory, then try the allocation again.
        //
        FlushTranslationCache(0, 0xffffffff);
        EntryPointMemory = (PBYTE)EPAlloc(EPSize);
        if (!EntryPointMemory) {
            //
            // We've tried our hardest, but there simply isn't any
            // memory available.  Time to give up.
            //
            RtlRaiseStatus(STATUS_NO_MEMORY);
        }

        //
        // Now that the cache has been flushed, CodeLocation is invalid.
        // re-allocate from the Translation Cache.  We know that
        // the cache was just flushed, so it is impossible for the cache
        // to flush again, which would invalidate EntryPointMemory.
        //
#if DBG
        OldEPTimestamp = EntrypointTimestamp;
#endif
        CodeLocation = AllocateTranslationCache(MAX_RISC_COUNT);

        CPUASSERTMSG(EntrypointTimestamp == OldEPTimestamp,
                     "Unexpected Translation Cache flush!");
    }

    //
    // Fill in the IntelStart, IntelEnd, and update
    // InstructionStream[]->EntryPoint
    //
    CreateEntryPoints(ContainingEntrypoint, EntryPointMemory);

    //
    // Generate RISC code from the x86 code
    //
    NativeSize = PlaceInstructions(CodeLocation, cEntryPoints);

    //
    // Give back the unused part of the Translation Cache
    //
    FreeUnusedTranslationCache(CodeLocation + NativeSize);
        
    //    
    // Flush the information to the instruction cache
    //
    NtFlushInstructionCache(NtCurrentProcess(), CodeLocation, NativeSize);

    //
    // Update the flags indicating what kind of code is in the TC
    //
    TranslationCacheFlags |= CompilerFlags;



    return (PENTRYPOINT)EntryPointMemory;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\compiler\mrsw.c ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    mrsw.c

Abstract:

    This module implements a multiple reader single write synchronization
    method.
    
Author:

    Dave Hastings (daveh) creation-date 26-Jul-1995

Revision History:


--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "wx86.h"
#include "wx86nt.h"
#include "cpuassrt.h"
#include "config.h"
#include "mrsw.h"
#include "cpumain.h"
#include "atomic.h"

ASSERTNAME;

MRSWOBJECT MrswEP; // Entrypoint MRSW synchronization object
MRSWOBJECT MrswTC; // Translation cache MRSW synchronization object
MRSWOBJECT MrswIndirTable; // Indirect Control Transfer Table synchronization object

BOOL
MrswInitializeObject(
    PMRSWOBJECT Mrsw
    )
/*++

Routine Description:

    This routine initializes the fields of Mrsw to their default values,
    and creates the events.

Arguments:

    Mrsw -- Supplies a pointer to an MRSWOBJECT to initialize
    
Return Value:

    TRUE on success, FALSE on failure.

--*/
{
    NTSTATUS Status;

    //
    // Initialize the counters
    //
    ZeroMemory(Mrsw, sizeof(MRSWOBJECT));
    
    //
    // Create the ReaderEvent and WriterEvent
    //

    Status = NtCreateEvent(&Mrsw->ReaderEvent,
                           EVENT_ALL_ACCESS,
                           NULL,              // POBJECT_ATTRIBUTES
                           NotificationEvent, // ManualReset
                           FALSE);            // InitialState
    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    Status = NtCreateEvent(&Mrsw->WriterEvent,
                           EVENT_ALL_ACCESS,
                           NULL,              // POBJECT_ATTRIBUTES
                           SynchronizationEvent, // AutoReset
                           FALSE);            // InitialState
    if (!NT_SUCCESS(Status)) {
        NtClose(Mrsw->ReaderEvent);
        return FALSE;
    }
    return TRUE;
}

VOID
PossibleMrswTimeout(
    PMRSWOBJECT Mrsw
    )
/*++

Routine Description:

    This function is called whenever an Mrsw function times out.  It prompts
    the user, and if the user chooses Retry, the Mrsw function re-waits.
    If the user chooses Cancel, the CPU will attempt to launch NTSD and break
    into the debugger.

Arguments:

    Mrsw -- Supplies the Mrsw which may have a deadlock
    
Return Value:

--*/
{
    NTSTATUS Status;
    ULONG ErrorResponse;

    LOGPRINT((ERRORLOG, "WX86CPU: Possible deadlock in Mrsw %x\n", Mrsw));
    Status = NtRaiseHardError(
                            STATUS_POSSIBLE_DEADLOCK | 0x10000000,
                            0,
                            0,
                            NULL,
                            OptionRetryCancel,
                            &ErrorResponse);
    if (!NT_SUCCESS(Status) || ErrorResponse == ResponseCancel) {
        DbgBreakPoint();
    }
}


VOID
MrswWriterEnter(
    PMRSWOBJECT Mrsw
    )
/*++

Routine Description:

    This function causes the caller to enter the Mrsw as the (single) writer.

Arguments:

    Mrsw -- Supplies the Mrsw to enter
    
Return Value:

--*/
{
    DWORD dwCounters;
    MRSWCOUNTERS Counters;
    NTSTATUS r;

    //
    // reset the reader event so that any readers that find the 
    // WriterCount > 0 will actually wait.  We have to do that now,
    // because if we wait, the reader might wait on the event before we
    // got it reset.
    //
    r= NtClearEvent(Mrsw->ReaderEvent);
    if (!NT_SUCCESS(r)) {
#if DBG
        LOGPRINT((ERRORLOG, "WX86CPU: Got status %x from NtClearEvent\n", r));
#endif
        RtlRaiseStatus(r);
    }
    
    //
    // Get the counters and increment the writer count
    // This is done atomically
    //
    dwCounters = MrswFetchAndIncrementWriter((DWORD *)&(Mrsw->Counters));
    Counters = *(PMRSWCOUNTERS)&dwCounters;
    CPUASSERTMSG(Counters.WriterCount != 0, "WriterCount overflowed");

    //
    // If there is a writer or a reader already, wait for them to finish
    //
    if ( (Counters.WriterCount > 1) || (Counters.ReaderCount) ) {
        NTSTATUS r;

        // Ensure We are not about to wait on ourselves.
        CPUASSERTMSG(Mrsw->WriterThreadId != ProxyGetCurrentThreadId(),
                     "MrswWriterEnter() called twice by the same thread");

        for (;;) {
            r = NtWaitForSingleObject(
                Mrsw->WriterEvent,
                FALSE,
                &MrswTimeout
                );
            if (r == STATUS_TIMEOUT) {
                PossibleMrswTimeout(Mrsw);
            } else if (NT_SUCCESS(r)) {
                break;
            } else {
#if DBG
                LOGPRINT((ERRORLOG, "WX86CPU: Got status %x from NtWaitForCriticalSection\n", r));
#endif
                RtlRaiseStatus(r);
            }
        }
    }

#if DBG
    CPUASSERTMSG(Mrsw->WriterThreadId == 0, "Another writer still is active.");
    Mrsw->WriterThreadId = ProxyGetCurrentThreadId();
#endif
}

VOID
MrswWriterExit( 
    PMRSWOBJECT Mrsw
    )
/*++

Routine Description:

    This function causes the caller to exit the Mrsw.  It will restart the
    next writer if there is one, or the readers if there are any

Arguments:

    Mrsw -- Supplies the Mrsw to exit
    
Return Value:


--*/
{
    DWORD dwCounters;
    MRSWCOUNTERS Counters;

    // Ensure we are the active writer
    CPUASSERTMSG(Mrsw->WriterThreadId == ProxyGetCurrentThreadId(),
                 "MrswWriterExit: current thread is not the writer");

    //
    // Decrement the count of writers
    //
#if DBG
    //
    // Set the thread id to 0 first, so if another writer comes along,
    // we don't zero out its thread id.
    //
    Mrsw->WriterThreadId = 0;
#endif
    dwCounters = MrswFetchAndDecrementWriter((DWORD *)&(Mrsw->Counters));
    Counters = *(PMRSWCOUNTERS)&dwCounters;

    CPUASSERTMSG(Counters.WriterCount != 0xffff, "Writer underflow");

    //
    // Start a waiting writer if there is one.  If there is no writer
    // start the waiting readers
    //
    if (Counters.WriterCount) {

        NtSetEvent(Mrsw->WriterEvent, NULL);

    } else {

        NtSetEvent(Mrsw->ReaderEvent, NULL);
    }
}

VOID
MrswReaderEnter(
    PMRSWOBJECT Mrsw
    )
/*++

Routine Description:

    This function causes the caller to enter the Mrsw as a reader.

Arguments:

    Mrsw -- Supplies the Mrsw to enter
    
Return Value:


--*/
{
    DWORD dwCounters;
    MRSWCOUNTERS Counters;

    for (;;) {
        //
        // Increment the count of readers.  If a writer is active, DO NOT
        // increment the read count.  In that case, we must block until the
        // writer is done, then try again.
        //
        dwCounters = MrswFetchAndIncrementReader((DWORD *)&(Mrsw->Counters));
        Counters = *(PMRSWCOUNTERS)&dwCounters;
        CPUASSERTMSG(Counters.WriterCount || Counters.ReaderCount != 0,
                     "Reader underflow");

        if (Counters.WriterCount) {
            NTSTATUS r;

            // Ensure we are not about to wait on ourselves.
            CPUASSERTMSG(Mrsw->WriterThreadId != ProxyGetCurrentThreadId(),
                         "MRSWReaderEnter(): Thread already has write lock");

            //
            // There is a writer, wait for it to finish
            //
            for (;;) {
                r = NtWaitForSingleObject(
                    Mrsw->ReaderEvent,
                    FALSE,
                    &MrswTimeout
                    );
                if (r == STATUS_TIMEOUT) {
                    PossibleMrswTimeout(Mrsw);
                } else if (NT_SUCCESS(r)) {
                    break;
                } else {
#if DBG
                    LOGPRINT((ERRORLOG, "WX86CPU: Got status %x from NtWaitForCriticalSection\n", r));
#endif
                    RtlRaiseStatus(r);
                }
            }
        } else {
            //
            // No writer, so MrswFetchAndIncrementReader() incremented the
            // reader count - OK to exit out of the loop.
            //
            break;
        }
    }
}

VOID
MrswReaderExit(
    PMRSWOBJECT Mrsw
    )
/*++

Routine Description:

    This function causes the caller to exit the Mrsw.  If this was the last
    reader, it will restart the a writer if there is one.

Arguments:

    Mrsw -- Supplies the Mrsw to exit
    
Return Value:


--*/
{
    DWORD dwCounters;
    MRSWCOUNTERS Counters;

    //
    // Decrement the count of active readers
    //
    dwCounters = MrswFetchAndDecrementReader((DWORD *)&(Mrsw->Counters));
    Counters = *(PMRSWCOUNTERS)&dwCounters;
    CPUASSERTMSG(Counters.ReaderCount != 0xffff, "Reader underflow");

    if (Counters.WriterCount) {

        if (Counters.ReaderCount == 0) {
            //
            // This thread is the last reader, and there is a writer
            // waiting.  Start the writer.
            //
            NtSetEvent(Mrsw->WriterEvent, NULL);
        }

    } else {
        //
        // There are no waiting readers and no writers, so do nothing.
        //
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\compiler\dumpcd.c ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation

Module Name:

    dumpcd.c

Abstract:

    This module dumps the contents of the 
    entrypoint tree and translation cache to a file.

Author:

    Dave Hastings (daveh) creation-date 02-May-1996

Revision History:


--*/

#ifdef CODEGEN_PROFILE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <entrypt.h>
#include <coded.h>

extern PEPNODE intelRoot;
extern EPNODE _NIL;

ULONG ProfileFlags = 0;

BOOL
ProcessEntrypoint(
    PENTRYPOINT Entrypoint
    );


#define CODE_BUFFER_SIZE 8184
UCHAR IntelCodeBuffer[CODE_BUFFER_SIZE];
ULONG NativeCodeBuffer[CODE_BUFFER_SIZE];

#define STACK_DEPTH 200

ULONG DumpStack[STACK_DEPTH];
ULONG DumpStackTop;

#define STACK_RESET()   DumpStackTop=0;

#define PUSH(x) {                                               \
    if (DumpStackTop == STACK_DEPTH-1) {                        \
        CHAR ErrorString[80];                                   \
        sprintf(ErrorString, "Error: Dump stack overflow\n");   \
        OutputDebugString(ErrorString);                         \
        goto Exit;                                              \
    } else {                                                    \
        DumpStack[DumpStackTop] = x;                            \
        DumpStackTop++;                                         \
    }                                                           \
}

#define POP(x) {                                                \
    if (DumpStackTop == 0) {                                    \
        CHAR ErrorString[80];                                   \
        sprintf(ErrorString, "Error: Dump stack underflow\n");  \
        OutputDebugString(ErrorString);                         \
        goto Exit;                                              \
    } else {                                                    \
        DumpStackTop--;                                         \
        x = DumpStack[DumpStackTop];                            \
    }                                                           \
}


BOOL CpuCodegenProfile = FALSE;
PCHAR CpuCodegenProfilePath = NULL;
HANDLE CpuCodegenProfileFile = INVALID_HANDLE_VALUE;

//
// Code Description file state
//
ULONG CurrentFileLocation;
ULONG CodeDescriptionFlags = 0;

VOID
InitCodegenProfile(
    VOID
    )
/*++

Routine Description:

    This routine gets the configuration information from the registry
    and creates the file to put the profile data into.

Arguments:

    None.
    
Return Value:

    None.

--*/
{
    LONG RetVal;
    DWORD KeyType;
    DWORD ProfileEnabled;
    DWORD BufferSize;
    CHAR FileName[MAX_PATH];
    LPTSTR CommandLine;
    CODEDESCRIPTIONHEADER Header;
    ULONG CommandLineLength;
    ULONG BytesWritten;
    BOOL Success;
    HKEY Key;
    
    //
    // Find out if codegen profiling is enabled.  If there is a problem
    // with the value in the registry, we will be disabled by default.
    //
    
    RetVal = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        "System\\CurrentControlSet\\Control\\Wx86",
        0,        
        KEY_READ,
        &Key
        );

    BufferSize = sizeof(ProfileEnabled);
    
    RetVal = RegQueryValueEx(
        Key,
        "CpuCodegenProfile",
        NULL,
        &KeyType,
        (PVOID)&ProfileEnabled,
        &BufferSize
        );
    
    if ((RetVal != ERROR_SUCCESS) || (KeyType != REG_DWORD)) {
        OutputDebugString("Wx86Cpu: No CpuCodegenProfile value, or wrong type\n");
        return;
    }
    
    CpuCodegenProfile = ProfileEnabled;
    
    //
    // Get the path to store the datafile to.
    // First we get the size of the string (and verify that it is a string)
    // Then we get the actual string.
    //
    BufferSize = 0;
    RetVal = RegQueryValueEx(
        Key,
        "CpuCodegenProfilePath",
        NULL,
        &KeyType,
        (PVOID)&ProfileEnabled,
        &BufferSize
        );
        
    if ((RetVal != ERROR_MORE_DATA) || (KeyType != REG_SZ)) {
        OutputDebugString("Wx86Cpu: Problem with CpuCodegenProfilePath\n");
        CpuCodegenProfile = FALSE;
        return;
    }
    
    CpuCodegenProfilePath = HeapAlloc(GetProcessHeap(), 0, BufferSize);
    
    if (CpuCodegenProfilePath == NULL) {
        OutputDebugString("Wx86Cpu: Can't allocate CpuCodegenProfilePath\n");
        CpuCodegenProfile = FALSE;
        return;
    }
    
    RetVal = RegQueryValueEx(
        Key,
        "CpuCodegenProfilePath",
        NULL,
        &KeyType,
        CpuCodegenProfilePath,
        &BufferSize
        );
        
    if ((RetVal != ERROR_SUCCESS) || (KeyType != REG_SZ)) {
        //
        // Something really bad just happened.  Don't do the profiling
        //
        OutputDebugString("Wx86Cpu: Inexplicable problem with CpuCodegenProfilePath\n");
        HeapFree(GetProcessHeap(), 0, CpuCodegenProfilePath);
        CpuCodegenProfile = FALSE;
        return;
    }
    
    //
    // Create file for the data
    //
    RetVal = GetTempFileName(CpuCodegenProfilePath, "prf", 0, FileName);
    
    if (RetVal == 0) {
        OutputDebugString("Wx86Cpu: GetTempFileName failed\n");
        HeapFree(GetProcessHeap(), 0, CpuCodegenProfilePath);
        CpuCodegenProfile = FALSE;
        return;
    }
    
    CpuCodegenProfileFile = CreateFile(
        FileName,
        GENERIC_WRITE,
        0,
        NULL,
        TRUNCATE_EXISTING,
        FILE_ATTRIBUTE_COMPRESSED,
        NULL
        );
        
    if (CpuCodegenProfileFile == INVALID_HANDLE_VALUE) {
        OutputDebugString("Wx86Cpu: Unable to create profile file\n");
        HeapFree(GetProcessHeap(), 0, CpuCodegenProfilePath);
        CpuCodegenProfile = FALSE;
        return;
    }
    
    //
    // Write the file header to the file
    //
    CommandLine = GetCommandLine();
    CommandLineLength = strlen(CommandLine) + 1;
    Header.CommandLineOffset = sizeof(CODEDESCRIPTIONHEADER);
    Header.NextCodeDescriptionOffset = ((sizeof(CODEDESCRIPTIONHEADER) + 
         CommandLineLength) + 3) & ~3;
    Header.DumpFileRev = CODEGEN_PROFILE_REV;
    Header.StartTime = GetCurrentTime();
    
    Success = WriteFile(
        CpuCodegenProfileFile, 
        &Header, 
        sizeof(Header), 
        &BytesWritten,
        NULL
        );
        
    if (!Success || (BytesWritten != sizeof(Header))) {
        OutputDebugString("Wx86Cpu: Failed to write profile header\n");
        CloseHandle(CpuCodegenProfileFile);
        HeapFree(GetProcessHeap(), 0, CpuCodegenProfilePath);
        CpuCodegenProfile = FALSE;
        return;
    }
    
    Success = WriteFile(
        CpuCodegenProfileFile,
        CommandLine,
        CommandLineLength,
        &BytesWritten,
        NULL
        );
        
    if (!Success || (BytesWritten != CommandLineLength)) {
        OutputDebugString("Wx86Cpu: Failed to write profile header\n");
        CloseHandle(CpuCodegenProfileFile);
        HeapFree(GetProcessHeap(), 0, CpuCodegenProfilePath);
        CpuCodegenProfile = FALSE;
        return;
    }
    
    //
    // Set the file position for the first code description
    //
    CurrentFileLocation = SetFilePointer(
        CpuCodegenProfileFile,
        Header.NextCodeDescriptionOffset,
        NULL,
        FILE_BEGIN
        );
        
    if (CurrentFileLocation != Header.NextCodeDescriptionOffset) {
        OutputDebugString("Wx86Cpu: failed to update file position\n");
        CloseHandle(CpuCodegenProfileFile);
        HeapFree(GetProcessHeap(), 0, CpuCodegenProfilePath);
        CpuCodegenProfile = FALSE;
        return;
    }
}

VOID
TerminateCodegenProfile(
    VOID
    )
/*++

Routine Description:

    This function put in the terminating record and closes the file.

Arguments:

    None
    
Return Value:

    None.

--*/
{
    CODEDESCRIPTION CodeDescription;
    BOOL Success;
    ULONG BytesWritten;
    CHAR ErrorString[80];
    
    if (!CpuCodegenProfile) {
        return;
    }
    CodeDescription.NextCodeDescriptionOffset = 0xFFFFFFFF;
    CodeDescription.TypeTag = PROFILE_TAG_EOF;
    CodeDescription.CreationTime = GetCurrentTime();
    
    Success = WriteFile(
        CpuCodegenProfileFile,
        &CodeDescription,
        sizeof(CODEDESCRIPTION),
        &BytesWritten,
        NULL
        );
    if (!Success || (BytesWritten != sizeof(CODEDESCRIPTION))) {
        sprintf(
            ErrorString,
            "Error:  Could not write termination record, %lu\n",
            ProxyGetLastError()
            );
        OutputDebugString(ErrorString);
    }
    
    CpuCodegenProfile = FALSE;
    CloseHandle(CpuCodegenProfileFile);
    
}

VOID 
DumpCodeDescriptions(
    BOOL TCFlush
    )
/*++

Routine Description:

    This routine dumps out the entrypoints, and the corresponding code
    to a file in binary form.

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    PEPNODE NextEntrypoint;
    EPNODE Entrypoint;
    ULONG Epcount = 0;
    
    if (!CpuCodegenProfile) {
        return;
    }
    
    //
    // Get the root of the entrypoint tree
    //
    NextEntrypoint = intelRoot;
    
    //
    // Initialize stack
    //
    STACK_RESET();
    PUSH(0);
    
    //
    // iterate over every entrypoint
    //
    while (NextEntrypoint != NULL) {
        Entrypoint = *NextEntrypoint;
        
        //
        // Process the top level entrypoint
        //
        if (!ProcessEntrypoint(&Entrypoint.ep)){
            goto Exit;
        }
                
        //
        // Process the sub entrypoints
        //
        while (Entrypoint.ep.SubEP) {
            Entrypoint.ep = *Entrypoint.ep.SubEP;
            
            //
            // Write the sub-entrypoint to the file
            //
            if (!ProcessEntrypoint(&Entrypoint.ep)){
                goto Exit;
            }
        }
            
        //
        // Set up for future iterations
        //
        if (Entrypoint.intelRight != &_NIL) {
            PUSH((ULONG)Entrypoint.intelRight);
        }
        
        if (Entrypoint.intelLeft != &_NIL) {
            PUSH((ULONG)Entrypoint.intelLeft);
        }
        
        POP((ULONG)NextEntrypoint);
    }
    
Exit: ;
    if (TCFlush) {
        CODEDESCRIPTION CodeDescription;
        ULONG NextCodeDescriptionOffset;
        BOOL Success;
        ULONG BytesWritten;
        CHAR ErrorString[80];
        
        NextCodeDescriptionOffset = (CurrentFileLocation + sizeof(CODEDESCRIPTION)) & ~3;
        CodeDescription.TypeTag = PROFILE_TAG_TCFLUSH;
        CodeDescription.NextCodeDescriptionOffset = NextCodeDescriptionOffset;
        CodeDescription.CreationTime = GetCurrentTime();
        
        Success = WriteFile(
            CpuCodegenProfileFile,
            &CodeDescription,
            sizeof(CODEDESCRIPTION),
            &BytesWritten,
            NULL
            );
        if (!Success || (BytesWritten != sizeof(CODEDESCRIPTION))) {
            sprintf(
                ErrorString,
                "Error:  Could not write code description, %lu\n",
                ProxyGetLastError()
                );
            OutputDebugString(ErrorString);
            return;
        }
        
        CurrentFileLocation = SetFilePointer(
            CpuCodegenProfileFile,
            NextCodeDescriptionOffset,
            NULL,
            FILE_BEGIN
            );
            
        if (CurrentFileLocation != (ULONG)NextCodeDescriptionOffset) {
            sprintf(ErrorString, "Error:  SetFilePointer didn't work\n");
            OutputDebugString(ErrorString);
            return;
        }
    }    
}

BOOL
ProcessEntrypoint(
    PENTRYPOINT Entrypoint
    )
/*++

Routine Description:

    This routine writes the description for this entrypoint to the file.

Arguments:

    Entrypoint -- Supplies the entrypoint to describe
    File -- Supplies the file to write to
    
Return Value:

    True for success, False for failure
    
--*/
{
    ULONG NativeCodeLength, IntelCodeLength;
    CODEDESCRIPTION CodeDescription;
    ULONG NextCodeDescriptionOffset;
    NTSTATUS Status;
    BOOL Success;
    ULONG BytesWritten;
    CHAR ErrorString[80];
    
    //
    // Create the code description
    //
    NativeCodeLength = ((ULONG)Entrypoint->nativeEnd - (ULONG)Entrypoint->nativeStart + 4) & ~3;
    IntelCodeLength = (ULONG)Entrypoint->intelEnd - (ULONG)Entrypoint->intelStart + 1;
    CodeDescription.NativeCodeOffset = CurrentFileLocation + sizeof(CODEDESCRIPTION);
    CodeDescription.IntelCodeOffset = CodeDescription.NativeCodeOffset + NativeCodeLength;
    NextCodeDescriptionOffset = (CodeDescription.IntelCodeOffset + 
        IntelCodeLength + 3) & ~3;
    CodeDescription.NextCodeDescriptionOffset = NextCodeDescriptionOffset;
    CodeDescription.IntelAddress = (ULONG)Entrypoint->intelStart;
    CodeDescription.NativeAddress = (ULONG)Entrypoint->nativeStart;
    CodeDescription.SequenceNumber = Entrypoint->SequenceNumber;
    CodeDescription.ExecutionCount = Entrypoint->ExecutionCount;
    CodeDescription.IntelCodeSize = IntelCodeLength;
    CodeDescription.NativeCodeSize = NativeCodeLength;
    CodeDescription.TypeTag = PROFILE_TAG_CODEDESCRIPTION;
    CodeDescription.CreationTime = Entrypoint->CreationTime;
        
    //
    // Verify that we can get all of the Intel and Native code
    //
    if (
        (IntelCodeLength / sizeof(IntelCodeBuffer[1]) > CODE_BUFFER_SIZE) ||
        (NativeCodeLength) && (NativeCodeLength / sizeof(NativeCodeBuffer[1]) > CODE_BUFFER_SIZE)
    ) {
        sprintf(ErrorString, "Error: Code buffers not big enough:N %lx:I %lx\n", NativeCodeLength, IntelCodeLength);
        OutputDebugString(ErrorString);
        return FALSE;
    }
    
    //
    // Get the native code
    //
    if (NativeCodeLength) {
        memcpy(NativeCodeBuffer, Entrypoint->nativeStart, NativeCodeLength);
    }    
    
    //
    // Get the Intel code
    //
    try {
        memcpy(IntelCodeBuffer, Entrypoint->intelStart, IntelCodeLength);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // Apparently the intel code is no longer there.  This happens
        // if a dll gets unloaded
        //
        IntelCodeLength = 0;
        CodeDescription.IntelCodeSize = 0;
        CodeDescription.IntelCodeOffset = CodeDescription.NativeCodeOffset + NativeCodeLength;
        NextCodeDescriptionOffset = (CodeDescription.IntelCodeOffset + 
            IntelCodeLength + 3) & ~3;
        CodeDescription.NextCodeDescriptionOffset = NextCodeDescriptionOffset;
    }
    
    //
    // Write code description to disk
    //
    Success = WriteFile(
        CpuCodegenProfileFile,
        &CodeDescription,
        sizeof(CODEDESCRIPTION),
        &BytesWritten,
        NULL
        );
    if (!Success || (BytesWritten != sizeof(CODEDESCRIPTION))) {
        sprintf(
            ErrorString,
            "Error:  Could not write code description, %lu\n",
            ProxyGetLastError()
            );
        OutputDebugString(ErrorString);
        return FALSE;
    }
    
    //
    // Write Native code to disk
    //
    if (NativeCodeLength) {
        Success = WriteFile(
            CpuCodegenProfileFile,
            NativeCodeBuffer,
            NativeCodeLength,
            &BytesWritten,
            NULL
            );
        if (!Success || (BytesWritten != NativeCodeLength)) {
            sprintf(
                ErrorString,
                "Error:  Could not write native code, %lu\n",
                ProxyGetLastError()
                );
            OutputDebugString(ErrorString);
            return FALSE;
        }
    }
    
    //
    // Write Intel code to disk
    //
    if (IntelCodeLength) {
        Success = WriteFile(
            CpuCodegenProfileFile,
            IntelCodeBuffer,
            IntelCodeLength,
            &BytesWritten,
            NULL
            );
        if (!Success || (BytesWritten != IntelCodeLength)) {
            sprintf(
                ErrorString,
                "Error:  Could not write native code, %lu\n",
                ProxyGetLastError()
                );
            OutputDebugString(ErrorString);
            return FALSE;
        }
    }
    Success = WriteFile(
        CpuCodegenProfileFile,
        IntelCodeBuffer,
        IntelCodeLength,
        &BytesWritten,
        NULL
        );
    if (!Success || (BytesWritten != IntelCodeLength)) {
        sprintf(
            ErrorString,
            "Error:  Could not write native code, %lu\n",
            ProxyGetLastError()
            );
        OutputDebugString(ErrorString);
        return FALSE;
    }
    
    //
    // Update file pointer position
    // 
    CurrentFileLocation = SetFilePointer(
        CpuCodegenProfileFile,
        NextCodeDescriptionOffset,
        NULL,
        FILE_BEGIN
        );
        
    if (CurrentFileLocation != (ULONG)NextCodeDescriptionOffset) {
        sprintf(ErrorString, "Error:  SetFilePointer didn't work\n");
        OutputDebugString(ErrorString);
        return FALSE;
    }
    
    return TRUE;
}

VOID
DumpAllocFailure(
    VOID
    )
/*++

Routine Description:

    This routine adds an allocation failure record to the profile dump.

Arguments:

    None.
    
Return Value:

    None.

--*/
{
    CODEDESCRIPTION CodeDescription;
    BOOL Success;
    ULONG BytesWritten;
    CHAR ErrorString[80];
    ULONG NextCodeDescriptionOffset;

    if (!CpuCodegenProfile) {
        return;
    }
    NextCodeDescriptionOffset = CurrentFileLocation + sizeof(CODEDESCRIPTION);
    CodeDescription.NextCodeDescriptionOffset = NextCodeDescriptionOffset;
    CodeDescription.TypeTag = PROFILE_TAG_TCALLOCFAIL;
    CodeDescription.CreationTime = GetCurrentTime();
    
    Success = WriteFile(
        CpuCodegenProfileFile,
        &CodeDescription,
        sizeof(CODEDESCRIPTION),
        &BytesWritten,
        NULL
        );
    if (!Success || (BytesWritten != sizeof(CODEDESCRIPTION))) {
        sprintf(
            ErrorString,
            "Error:  Could not write termination record, %lu\n",
            ProxyGetLastError()
            );
        OutputDebugString(ErrorString);
    }
    
    //
    // Update file pointer position
    // 
    CurrentFileLocation = SetFilePointer(
        CpuCodegenProfileFile,
        NextCodeDescriptionOffset,
        NULL,
        FILE_BEGIN
        );
        
    if (CurrentFileLocation != (ULONG)NextCodeDescriptionOffset) {
        sprintf(ErrorString, "Error:  SetFilePointer didn't work\n");
        OutputDebugString(ErrorString);
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\compiler\simulate.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    simulate.c

Abstract:

    This module contains the code that drives the intel instruction
    execution process.

Author:

    Dave Hastings (daveh) creation-date 09-Jul-1994

Revision History:


--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#define _WX86CPUAPI_

#include "wx86nt.h"
#include "wx86.h"
#include "wx86cpu.h"
#include "cpuassrt.h"
#include "threadst.h"
#include "instr.h"
#include "config.h"
#include "entrypt.h"
#include "compilep.h"
#include "compiler.h"
#include "instr.h"
#include "frag.h"
#include "cpumain.h"
#include "mrsw.h"
#include "cpunotif.h"
#include "tc.h"
#include "atomic.h"

ASSERTNAME;

//
// Private definition of what a WX86_CPUHINT really contains.
// The CPUHINT allows the CPU to bypass an expensive NativeAddressFromEip()
// call to map the Intel EIP value into a RISC address.  Most calls to
// CpuSimulate() are from RISC-to-x86 callbacks, and they have two DWORDS
// which the CPU uses to cache the NativeAddressFromEip() results.
//
//  Timestamp -- value of TranslationCacheTimestamp when the CPUHINT was
//               filled in.  This is used to determine if the Translation Cache
//               has been flushed.  If so, the EntryPoint pointer is now
//               invalid.
//  EntryPoint -- pointer to the ENTRYPOINT describing the Intel Address
//               corresponding to this callback.
//
//
typedef struct _CpuHint {
    DWORD       Timestamp;
    PENTRYPOINT EntryPoint;
} CPUHINT, *PCPUHINT;


//
// These values are modified by the wx86e debugger extension whenever it
// writes into this process's address space.  It is used whenever Int3
// instructions are added or removed from Intel code.  The CPU examines
// these variables whenever CPUNOTIFY_DBGFLUSHTC is set.
//
ULONG DbgDirtyMemoryAddr = 0xffffffff;
ULONG DbgDirtyMemoryLength;

#ifdef PROFILE
//
// Wrap our assembly entrypoint so we can see it in the cap output
//
VOID
_ProfStartTranslatedCode(
    PTHREADSTATE ThreadState,
    PVOID NativeCode    
    )
{
    StartTranslatedCode(ThreadState, NativeCode);
}
#endif

VOID
MsCpuSimulate(
    PWX86_CPUHINT Wx86CpuHint
)
/*++

Routine Description:

    This is the cpu internal routine that causes intel instructions
    to be executed.  Execution continues until something interesting
    happens (such as BOP Unsimulate)

Arguments:

    None.
    
Return Value:

    None.

--*/
{
    PVOID NativeCode;
    DWORD CpuNotify;
    DWORD OldCompilerFlags = CompilerFlags;
    DECLARE_CPU;
        
    CPUASSERT(sizeof(CPUHINT) == sizeof(WX86_CPUHINT));

    //
    // Check CpuNotify to see if the Translation Cache needs flushing.
    //
    CpuNotify = cpu->CpuNotify;
    cpu->CpuNotify &= ~(ULONG)CPUNOTIFY_DBGFLUSHTC;

    if (cpu->flag_tf) {
        CpuNotify |= CPUNOTIFY_MODECHANGE;
        CompilerFlags = COMPFL_SLOW;
    }

    if (CpuNotify & (CPUNOTIFY_DBGFLUSHTC|CPUNOTIFY_MODECHANGE)) {
        if (CpuNotify & CPUNOTIFY_MODECHANGE) {
            //
            // On a fast/slow compiler mode change, flush the whole cache
            //
            DbgDirtyMemoryAddr = 0;
            DbgDirtyMemoryLength = 0xffffffff;
        }
        //
        // The debugger has modified memory - flush the Translation Cache
        //
        CpuFlushInstructionCache((PVOID)DbgDirtyMemoryAddr,
                                 DbgDirtyMemoryLength);
        DbgDirtyMemoryAddr = 0xffffffff;
        DbgDirtyMemoryLength = 0;
    }

    //
    // Flag ourseleves as having the TC lock.
    //
    CPUASSERTMSG(cpu->fTCUnlocked != FALSE,
                 "CPU has been reentered with the TC already locked.\n");
    cpu->fTCUnlocked = FALSE;
    //
    // The caller has already pushed a return address on the stack.
    // (Probably to a BOP FE).  Get the callstack in sync.
    //
    PUSH_CALLSTACK(*(DWORD *)cpu->Esp.i4, 0)

    if (Wx86CpuHint) {
        PCPUHINT CpuHint = (PCPUHINT)Wx86CpuHint;
        PVOID Eip = (PVOID)cpu->eipReg.i4;

        //
        // CpuNotify isn't set, and a hint is present...try to use it.
        //
        MrswReaderEnter(&MrswTC);
        if (CpuHint->Timestamp != TranslationCacheTimestamp ||
            CpuHint->EntryPoint->intelStart != Eip) {
            //
            // The hint is present, but invalid.  Get the new address and
            // update the hint
            //
            MrswReaderExit(&MrswTC);

#if 0
            LOGPRINT((DEBUGLOG, "CPU: CpuHint was invalid: got (%X,%X) expected (%X,%X)\r\n",
                                 CpuHint->Timestamp, ((CpuHint->Timestamp)?CpuHint->EntryPoint->intelStart:0),
                                 TranslationCacheTimestamp, Eip));
#endif
            CpuHint->EntryPoint = NativeAddressFromEip(Eip, FALSE);
            CpuHint->Timestamp = TranslationCacheTimestamp;
        }

        NativeCode = CpuHint->EntryPoint->nativeStart;
    } else {
        //
        // Find the address of the Native code to execute, and lock the
        // Translation cache
        //
        NativeCode = NativeAddressFromEip((PVOID)cpu->eipReg.i4, FALSE)->nativeStart;
    }


    while (TRUE) {

        if (cpu->CSTimestamp != TranslationCacheTimestamp) {
            //
            // The timestamp associated with the callstack is different
            // than the timestamp for the Translation Cache.  Therefore,
            // the TC has been flushed.  We must flush the callstack, too.
            //
            FlushCallstack(cpu);
        }


        //
        // Go execute the code
        //
#ifdef PROFILE
        _ProfStartTranslatedCode(cpu, NativeCode);
#else
        StartTranslatedCode(cpu, NativeCode);
#endif
 
        CompilerFlags = OldCompilerFlags;

        //
        // Release the translation cache
        //
        MrswReaderExit(&MrswTC);

        //
        // if TF flag is set, then switch the compiler to SLOW_MODE
        // and set the CPUNOTIFY_TRACEFLAG to generate an x86 single-step
        // exception.
        //
        cpu->CpuNotify |= cpu->flag_tf;

        //
        // Check and see if anything needs to be done
        //
 
        if (cpu->CpuNotify) {
            
            //
            // Atomically get CpuNotify and clear the appropriate bits
            //
            CpuNotify = cpu->CpuNotify;
            cpu->CpuNotify &= (CPUNOTIFY_TRACEADDR|CPUNOTIFY_SLOWMODE|CPUNOTIFY_TRACEFLAG);

            //
            // Indicate we have left the Translation Cache
            //
            cpu->fTCUnlocked = TRUE;

            if (CpuNotify & CPUNOTIFY_UNSIMULATE) {
                break;
            }

            if (CpuNotify & CPUNOTIFY_EXITTC) {
                // There is no work to do - The Translation Cache is going
                // away, so all active reader threads needed to leave the
                // cache ASAP and block inside NativeAddressFromEip() until
                // the cache flush has completed.
            }

            if (CpuNotify & CPUNOTIFY_SUSPEND) {
                //
                // Another thread wants to suspend us.  Notify that
                // thread that we're in a consistent state, then wait
                // until we are resumed.
                //
                CpupSuspendCurrentThread();
            }

            if (CpuNotify & CPUNOTIFY_SLOWMODE) {
                // log the instruction address for debugging purposes
                cpu->eipLog[cpu->eipLogIndex++] = cpu->eipReg.i4;
                cpu->eipLogIndex %= EIPLOGSIZE;
            }

            if (CpuNotify & CPUNOTIFY_INTX) {
                BYTE intnum;

                //
                // Get the interrupt number from the code stream, and
                // advance Eip to the start of the next instruction.
                //
                intnum = *(PBYTE)cpu->eipReg.i4;
                
                cpu->eipReg.i4 += 1;
                if (intnum == 0xcc) {
                    intnum = 3;
                } else {
                    cpu->eipReg.i4 += 1;
                }
                
                CpupDoInterrupt(intnum);

                //
                // Flush the entire translation cache since we don't know what memory
                // areas the debugger has changed. We do this by simulating
                // a compiler mode change.
                //
                CpuNotify |= CPUNOTIFY_MODECHANGE;

            } else if (CpuNotify & (CPUNOTIFY_TRACEADDR|CPUNOTIFY_TRACEFLAG)) {

                if ((CpuNotify & CPUNOTIFY_TRACEADDR) &&
                    ((DWORD)(ULONGLONG)cpu->TraceAddress == cpu->eipReg.i4) 
                ) {
                    cpu->TraceAddress = NULL;
                    cpu->CpuNotify &= ~(ULONG)CPUNOTIFY_TRACEADDR;
                    Wx86RaiseStatus(WX86CPU_SINGLE_STEP);
                }

                if (CpuNotify & CPUNOTIFY_TRACEFLAG) {
                    cpu->flag_tf = 0;
                    cpu->CpuNotify &= ~(ULONG)CPUNOTIFY_TRACEFLAG;
                    Wx86RaiseStatus(WX86CPU_SINGLE_STEP);
                }

                //
                // Flush the entire translation cache since we don't know what memory
                // areas the debugger has changed. We do this by simulating
                // a compiler mode change.
                //
                CpuNotify |= CPUNOTIFY_MODECHANGE;
            }

            if (CpuNotify & (CPUNOTIFY_DBGFLUSHTC|CPUNOTIFY_MODECHANGE)) {
                if (CpuNotify & CPUNOTIFY_MODECHANGE) {
                    //
                    // On a fast/slow compiler mode change, flush whole cache
                    //
                    DbgDirtyMemoryAddr = 0;
                    DbgDirtyMemoryLength = 0xffffffff;
                }
                //
                // The debugger has modified memory - flush the Translation
                // Cache
                //

                CpuFlushInstructionCache((PVOID)DbgDirtyMemoryAddr,
                                         DbgDirtyMemoryLength);
                DbgDirtyMemoryAddr = 0xffffffff;
                DbgDirtyMemoryLength = 0;
            }

            //
            // Indicate we are re-entering the Translation Cache
            //
            cpu->fTCUnlocked = FALSE;
        }


        if (cpu->flag_tf) {
            OldCompilerFlags = CompilerFlags;
            CompilerFlags = COMPFL_SLOW;

            if (!(CpuNotify & CPUNOTIFY_MODECHANGE)) {
                CpuFlushInstructionCache(NULL, 0xffffffff);
            }
        }

        //
        // Find the address of the Native code to execute, and lock the
        // Translation cache
        //

        NativeCode = NativeAddressFromEip((PVOID)cpu->eipReg.i4, FALSE)->nativeStart;

    }
}

PENTRYPOINT
NativeAddressFromEip(
    PVOID       Eip,
    BOOL        LockTCForWrite
    )
/*++

Routine Description:

    This routine finds (or creates) the native code for the specified Intel
    code.

    NOTE:  This function can only be called when the Translation Cache is
           not locked (either read or write) by the current thread.

Arguments:

    Eip             -- Supplies the address of the Intel code
    LockTCForWrite  -- TRUE if caller wants TC locked for WRITE, FALSE if the
                       call wants it locked for READ.

Return Value:

    Entrypoint whose nativeStart Address corresponds to the Intel Address
    passed in.
    
--*/
{
    PENTRYPOINT Entrypoint;
    typedef VOID (*pfnMrswCall)(PMRSWOBJECT);
    pfnMrswCall MrswCall;
    DWORD OldEntrypointTimestamp;

    //
    // Assume we are going to call MrswReaderExit(&MrswEP) at the end
    // of this function.
    //


    MrswCall = MrswReaderExit;

    //
    // Lock the Entrypoint for reading
    //
    MrswReaderEnter(&MrswEP);

    //
    // Find the location of the Risc code corresponding to the
    // Intel EIP register
    //
    Entrypoint = EPFromIntelAddr(Eip);


    //
    // If there is no entrypoint, compile up the code
    //
    if (Entrypoint == NULL || Entrypoint->intelStart != Eip) {

        //
        // Unlock the Entrypoint read
        //
        OldEntrypointTimestamp = EntrypointTimestamp;
        MrswReaderExit(&MrswEP);

        //
        // Lock the Entrypoint for write, and change the function to be
        // called at the end of the function to be MrswWriterExit(&MrswEP)
        //
        MrswWriterEnter(&MrswEP);
        MrswCall = MrswWriterExit;

        //
        // See if another thread compiled the Entrypoint while we were
        // switching from read mode to write mode
        //
        if (OldEntrypointTimestamp != EntrypointTimestamp) {
            //
            // Timestamp has changed.  There is a possibility that another
            // thread has compiled code at Eip for us, so retry the search.
            //
            Entrypoint = EPFromIntelAddr(Eip);
        }

        //
        // Call the compiler.  It will do one of the following things:
        //  1. if Entrypoint==NULL, it will compile new code
        //  2. if Entrypoint!=NULL and Entrypoint->Eip == Eip, it will
        //     return Entrypoint unchanged
        //  3. otherwise, the Entrypoint needs splitting.  It will do so,
        //     and compile a subset of the code described by Entrypoint and
        //     then return a new Entrypoint
        //
        Entrypoint = Compile(Entrypoint, Eip);
    }

    //
    // Instruction was found - grab the translation cache for either
    // read or write, then free the entrypoint write lock.  The
    // order is important as it prevents the TC from being flushed
    // between the two Mrsw calls.
    //
    if (LockTCForWrite) {
        InterlockedIncrement(&ProcessCpuNotify);
        MrswWriterEnter(&MrswTC);
        InterlockedDecrement(&ProcessCpuNotify);
    } else {
        MrswReaderEnter(&MrswTC);
    }
    (*MrswCall)(&MrswEP);  // Either MrswReaderExit() or MrswWriterExit()

    return Entrypoint;
}

PVOID
NativeAddressFromEipNoCompile(
    PVOID Eip
    )
/*++

Routine Description:

    This routine finds the native code for the specified Intel code, if it
    exists.  No new code is compiled.

    NOTE:  This function can only be called when the Translation Cache is
           not locked (either read or write) by the current thread.

Arguments:

    Eip -- Supplies the address of the Intel code

Return Value:

    Address of corresponding native code, or NULL if none exists.  Translation
    cache locked for WRITE if native code exists for Eip.  TC is locked for
    READ if no code exitss.
    
--*/
{
    PENTRYPOINT Entrypoint;
    DWORD OldEntrypointTimestamp;

    //
    // Lock the Entrypoint for reading
    //
    MrswReaderEnter(&MrswEP);

    //
    // Find the location of the Risc code corresponding to the
    // Intel EIP register
    //
    Entrypoint = EPFromIntelAddr(Eip);

    if (Entrypoint == NULL) {
        //
        // Entrypoint not found - no native code exists for this Intel address
        //
        MrswReaderEnter(&MrswTC);
        MrswReaderExit(&MrswEP);
        return NULL;

    } else if (Entrypoint->intelStart == Eip) {
        //
        // Exact instruction found - return the NATIVE address
        //
        InterlockedIncrement(&ProcessCpuNotify);
        MrswWriterEnter(&MrswTC);
        InterlockedDecrement(&ProcessCpuNotify);
        MrswReaderExit(&MrswEP);
        return Entrypoint->nativeStart;
    }

    //
    // Else the entrypoint contains the Intel address.  Nothing can
    // be done.  Release EP write and get TC read.
    //
    MrswReaderExit(&MrswEP);
    MrswReaderEnter(&MrswTC);
    return NULL;
}


PENTRYPOINT
NativeAddressFromEipNoCompileEPWrite(
    PVOID Eip
    )
/*++

Routine Description:

    This routine finds the native code for the specified Intel code, if it
    exists.  No new code is compiled.  This function is called by functions
    in patchfn.c during compile time when they need to decide whether to
    directly place the patched version in the Translation Cache or not.

    NOTE:  This function can only be called when the Translation Cache is
           not locked (either read or write) by the current thread.

    NOTE:  The difference between this function and NativeAddressFromEipNoCompile
           is that here we assume that we have the Entry Point write lock upon
           entry to the function.  This function makes no calls to MRSW functions
           for any locks.

Arguments:

    Eip -- Supplies the address of the Intel code

Return Value:

    Address of corresponding native code, or NULL if none exists.  All MRSW objects
    are in exactly the same state they were when we entered this function.
    
--*/
{
    PENTRYPOINT Entrypoint;

    //
    // Find the location of the Risc code corresponding to the
    // Intel EIP register
    //
    Entrypoint = EPFromIntelAddr(Eip);

    if (Entrypoint == NULL) {
        //
        // Entrypoint not found - no native code exists for this Intel address
        //
        return NULL;

    } else if (Entrypoint->intelStart == Eip) {
        //
        // Exact instruction found - return the NATIVE address
        //
        return Entrypoint;
    }

    //
    // Entrypoint needs to be split.  Can't do that without compiling.
    //
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\compiler\axp64\atomic.s ===
//
// Copyright (c) 1995  Microsoft Corporation
//
// Module Name:
//
//     atomic.s
// 
// Abstract:
// 
//     This module implements atomic operations such as InterlockedOr,
//     InterlockedAnd and the MrswFetch...() functions used for
//     Multiple Reader Single Writer (mrsw) synchronization.
// 
// Author:
// 
//     Dave Hastings (daveh) creation-date 05-Jan-1996
//      from ..\mips\atomic.s
// 
// Notes:
//
//     Mrsw Counter is:  WriterCount         : 16
//                       ReaderCount         : 16
// 
// Revision History:

#include "kxalpha.h"

        SBTTL("MrswFetchAndIncrementWriter")
//++
//
// MRSWCOUNTERS
// MrswFetchAndIncrementWriter(
//    PMRSWCOUNTERS pCounters
//    )
//
// Routine Description:
//
//    Atomically increment Writer counter and return the new reader/writer
//    counts (the values AFTER the increment).
//
// Arguments:
//
//    pCounters (a0) - pointer to reader/writer counters
//
// Return Value:
//
//    MRSWCOUNTERS - value of both counters AFTER writer count was incremented
//
//--
        LEAF_ENTRY(MrswFetchAndIncrementWriter)
        PROLOGUE_END

//
// Increment the writer count and load both reader and writer accounts
// atomically.
//
fiw10:  ldl_l   v0, (a0)                // Get both reader and write counts
        addl    v0, 1, v0               // increment the writer count
        bis     v0, zero, t0            
        stl_c   t0, (a0)                
        beq     t0, fiw20               // atomic update failed?
        
        mb                              // insure that updates of the data
                                        // being protected are synch'ed
        ret     zero, (ra)
        
fiw20:  br      zero, fiw10
        .end    MrswFetchAndIncrementWriter


//++
//
// MRSWCOUNTERS
// MrswFetchAndIncrementReader(
//    PMRSWCOUNTERS pCounters
//    )
//
// Routine Description:
//
//    Atomically:  Get WriterCount.  If WriterCount zero, increment ReaderCount
//    and return the value AFTER the increment.  Else, return right away.
//
// Arguments:
//
//    pCounters (a0) - pointer to reader/writer counters
//
// Return Value:
//
//    MRSWCOUNTERS
//
//--
        LEAF_ENTRY(MrswFetchAndIncrementReader)
        PROLOGUE_END

//
// Increment the waiting reader count and load both reader and writer accounts
// atomically.
//
fir10:  ldah    t2, 1(zero)             // Load increment value for Reader count
        ldl_l   v0, (a0)                // get both counters
        and     v0, 0xffff, t1          // isolate writer count
        bne     t1, fir20               // exit if there is already a writer
        
        addl    v0, t2, v0              // increment reader count
        bis     v0, zero, t0
        stl_c   t0, (a0)
        beq     t0, fir30
        
        mb                              // insure that updates of the data
                                        // being protected are synch'ed
        
fir20:  ret     zero, (ra)

fir30:  br      zero, fir10
        .end    MrswFetchAndIncrementReader


        SBTTL("MrswFetchAndDecrementWriter")
//++
//
// MRSWCOUNTERS
// MrswFetchAndDecrementWriter(
//    PMRSWCOUNTERS pCounters
//    )
//
// Routine Description:
//
//    Atomically decrement Writer counter and return the new reader/writer
//    counts (the values AFTER the decrement).
//
// Arguments:
//
//    pCounters (a0) - pointer to reader/writer counters
//
// Return Value:
//
//    MRSWCOUNTERS - value of both counters AFTER writer count was decremented
//
//--
        LEAF_ENTRY(MrswFetchAndDecrementWriter)
        PROLOGUE_END

        mb                              // insure that updates of the data
                                        // being protected are synch'ed
//
// Decrement the writer count and load both reader and writer accounts
// atomically.
//
fdw10:  ldl_l   v0, (a0)                // get both counters
        subl    v0, 1, v0               // decrement writer count
        bis     v0, zero, t0
        stl_c   t0, (a0)
        beq     t0, fdw20
        
        ret     zero, (ra)
        
fdw20:  br      zero, fdw10
        .end    MrswFetchAndDecrementWriter


//++
//
// MRSWCOUNTERS
// MrswFetchAndDecrementReader(
//    PMRSWCOUNTERS pCounters
//    )
//
// Routine Description:
//
//    Atomically decrement Active Reader counter and return the new reader/writer
//    counts (the values AFTER the decrement).
//
// Arguments:
//
//    pCounters (a0) - pointer to reader/writer counters
//
// Return Value:
//
//    MRSWCOUNTERS - value of both counters AFTER writer count was decremented
//
//
// Notes:
//
//    No MB is used, because the readers don't write into the data, and this
//    function is called when a thread is DONE reading
//
//--
        LEAF_ENTRY(MrswFetchAndDecrementReader)
        PROLOGUE_END

//
// Decrement the active reader count and load both reader and writer accounts
// atomically.
//
fdr10:  ldah    t1, 1(zero)             // decrement value to dec reader count
        ldl_l   v0, (a0)                // get both counters
        subl    v0, t1, v0
        bis     v0, zero, t0
        stl_c   t0, (a0)
        beq     t0, fdr20
        
        ret     zero, (ra)
        
fdr20:  br      zero, fdr10
        .end    MrswFetchAndDecrementReader

//++
//
// DWORD
// InterlockedAnd(
//    DWORD *pDWORD,        // ptr to DWORD to bitwise AND a value into
//    DWORD AndValue        // value to bitwise OR into *pDWORD
//    )
//
// Routine Description:
//
//    Atomically grabs the value of *pDWORD and clears the bits in *pDWORD
//    specified by Mask.  ie. implements atomically:    temp = *pDWORD;
//                                                      *pDWORD &= Mask;
//                                                      return temp;
//
// Arguments:
//
//    pDWORD        - ptr to DWORD to modify
//    Mask          - value to bitwise AND into *pDWORD
//
// Return Value:
//
//    Value of *pDWORD before the AND operation.
//
//--
        LEAF_ENTRY(InterlockedAnd)
        PROLOGUE_END
        
ia10:   ldl_l   v0, (a0)
        and     v0, a1, t0
        stl_c   t0, (a0)
        beq     t0, ia20
        
        ret     zero, (ra)
        
ia20:   br      zero, ia10
        .end    InterlockedAnd


//++
//
// DWORD
// InterlockedOr(
//    DWORD *pDWORD,        // ptr to DWORD to bitwise OR a value into
//    DWORD OrValue         // value to bitwise OR into *pDWORD
//    )
//
// Routine Description:
//
//    Atomically grabs the value of *pDWORD and bitwise ORs in OrValue.
//
// Arguments:
//
//    pDWORD        - ptr to DWORD to modify
//    OrValue       - value to bitwise OR into *pDWORD
//
// Return Value:
//
//    Value of *pDWORD before the OR operation.
//
//--
        LEAF_ENTRY(InterlockedOr)
        PROLOGUE_END

io10:   ldl_l   v0, (a0)
        bis     v0, a1, t0
        stl_c   t0, (a0)
        beq     t0, io20
        
        ret     zero, (ra)
        
io20:   br      zero, io10
        .end    InterlockedOr
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\compiler\tc.c ===
/*++

Copyright (c) 1995-1998  Microsoft Corporation

Module Name:

    tc.c

Abstract:

    This module implements the Translation Cache, where Intel code is
    translated into native code.
    
Author:

    Dave Hastings (daveh) creation-date 26-Jul-1995

Revision History:

        24-Aug-1999 [askhalid] copied from 32-bit wx86 directory and make work for 64bit.


--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntldr.h>
#include <windows.h>

#define _WX86CPUAPI_

#include "wx86.h"
#include "wx86nt.h"
#include "wx86cpu.h"
#include "cpuassrt.h"
#include "config.h"
#include "tc.h"
#include "entrypt.h"
#include "mrsw.h"
#include "cpunotif.h"
#include "cpumain.h"
#include "instr.h"
#include "threadst.h"
#include "frag.h"
#include "atomic.h"
#ifdef CODEGEN_PROFILE
#include <coded.h>
#endif


ASSERTNAME;

#if MIPS
#define DBG_FILL_VALUE  0x73737373          // an illegal instruction
#else
#define DBG_FILL_VALUE  0x01110111
#endif

#ifdef CODEGEN_PROFILE
extern DWORD EPSequence;
#endif

//
// Descriptor for a range of the Translation Cache.
//
typedef struct _CacheInfo {
    PBYTE StartAddress;     // base address for the cache
    LONGLONG MaxSize;          // max size of the cache (in bytes)
    LONGLONG MinCommit;        // min amount that can be committed (bytes)
    LONGLONG NextIndex;        // next free address in the cache
    LONGLONG CommitIndex;      // next uncommitted address in the cache
    LONGLONG ChunkSize;        // amount to commit by
    ULONG LastCommitTime;   // time of last commit
} CACHEINFO, *PCACHEINFO;

//
// Pointers to the start and end of the function prolog for StartTranslatedCode
//
extern CHAR StartTranslatedCode[];
extern CHAR StartTranslatedCodePrologEnd[];

ULONG       TranslationCacheTimestamp = 1;
CACHEINFO   DynCache;       // Descriptor for dynamically allocated TC
RUNTIME_FUNCTION DynCacheFunctionTable;
BOOL        fTCInitialized;
extern DWORD TranslationCacheFlags;


BOOL
InitializeTranslationCache(
    VOID
    )
/*++

Routine Description:

    Per-process initialization for the Translation Cache.

Arguments:

    .
    
Return Value:

    .

--*/
{
    NTSTATUS Status;
    ULONGLONG pNewAllocation;
    ULONGLONG RegionSize;
    LONG PrologSize;

    //
    // Initialize non-zero fields in the CACHEINFO
    //
    DynCache.MaxSize = CpuCacheReserve;
    DynCache.MinCommit = CpuCacheCommit;
    DynCache.ChunkSize = CpuCacheChunkSize;

    //
    // Reserve DynCache.MaxSize bytes of memory.
    //
    RegionSize = DynCache.MaxSize;
    Status = NtAllocateVirtualMemory(NtCurrentProcess(),
                                     &(PVOID)DynCache.StartAddress,
                                     0,
                                     (ULONGLONG *)&DynCache.MaxSize,
                                     MEM_RESERVE,
                                     PAGE_EXECUTE_READWRITE
                                    );
    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    //
    // Commit enough memory to store the function prolog.
    //
    pNewAllocation = (ULONGLONG)DynCache.StartAddress;
    Status = NtAllocateVirtualMemory(NtCurrentProcess(),
                                     &(PVOID)pNewAllocation,
                                     0,
                                     &DynCache.MinCommit,
                                     MEM_COMMIT,
                                     PAGE_READWRITE);
    if (!NT_SUCCESS(Status)) {
        //
        // Commit failed.  Free the reserve and bail.
        //
ErrorFreeReserve:
        RegionSize = 0;
        NtFreeVirtualMemory(NtCurrentProcess(),
                            &(PVOID)DynCache.StartAddress,
                            &RegionSize,
                            MEM_RELEASE
                           );

        return FALSE;
    }
#if DBG
    //
    // Fill the TC with a unique illegal value, so we can distinguish
    // old code from new code and detect overwrites.
    //
    RtlFillMemoryUlong(DynCache.StartAddress, DynCache.MinCommit, DBG_FILL_VALUE);
#endif

    //
    // Copy the prolog from StartTranslatedCode into the start of the cache.
    //
    PrologSize = (LONG)(StartTranslatedCodePrologEnd - StartTranslatedCode);
    CPUASSERT(PrologSize >= 0 && PrologSize < MAX_PROLOG_SIZE);
    RtlCopyMemory(DynCache.StartAddress, StartTranslatedCode, PrologSize);


    //
    // Notify the exception unwinder that this memory is going to contain
    // executable code.
    //
    DynCacheFunctionTable.BeginAddress = (UINT_PTR)DynCache.StartAddress;
    DynCacheFunctionTable.EndAddress = (UINT_PTR)(DynCache.StartAddress + DynCache.MaxSize);
    DynCacheFunctionTable.ExceptionHandler = NULL;
    DynCacheFunctionTable.HandlerData = NULL;
    DynCacheFunctionTable.PrologEndAddress = (UINT_PTR)(DynCache.StartAddress + MAX_PROLOG_SIZE);
    if (RtlAddFunctionTable(&DynCacheFunctionTable, 1) == FALSE) {
        goto ErrorFreeReserve;
    }

    //
    // Adjust the DynCache.StartAddress up by MAX_PROLOG_SIZE so cache
    // flushes don't erase it.
    //
    DynCache.StartAddress += MAX_PROLOG_SIZE;

    fTCInitialized = TRUE;
    return TRUE;
}


PCHAR
AllocateFromCache(
    PCACHEINFO Cache,
    ULONG Size
    )
/*++

Routine Description:

    Allocate space within a Translation Cache.  If there is insufficient
    space, the allocation will fail.

Arguments:

    Cache           - Data about the cache
    Size            - Size of the allocation request, in bytes
    
Return Value:

    Pointer to DWORD-aligned memory of 'Size' bytes.  NULL if insufficient
    space.

--*/
{
    PBYTE Address;

    // Ensure parameters and cache state are acceptable
    CPUASSERTMSG((Cache->NextIndex & 3)==0, "Cache not DWORD aligned");
    CPUASSERTMSG(Cache->NextIndex == 0 || *(DWORD *)&Cache->StartAddress[Cache->NextIndex-4] != DBG_FILL_VALUE, "Cache Corrupted");
    CPUASSERT(Cache->NextIndex == Cache->CommitIndex || *(DWORD *)&Cache->StartAddress[Cache->NextIndex] == DBG_FILL_VALUE);

    if ((Cache->NextIndex + Size) >= Cache->MaxSize) {
        //
        // Not enough space in the cache.
        //
        return FALSE;
    }

    Address = &Cache->StartAddress[Cache->NextIndex];
    Cache->NextIndex += Size;

    if (Cache->NextIndex > Cache->CommitIndex) {
        //
        // Need to commit more of the cache
        //

        LONGLONG RegionSize;
        NTSTATUS Status;
        PVOID pAllocation;
        ULONG CommitTime = NtGetTickCount();

        if (Cache->LastCommitTime) {
            if ((CommitTime-Cache->LastCommitTime) < CpuCacheGrowTicks) {
                //
                // Commits are happening too frequently.  Bump up the size of
                // each commit.
                //
                if (Cache->ChunkSize < CpuCacheChunkMax) {
                    Cache->ChunkSize *= 2;
                }
            } else if ((CommitTime-Cache->LastCommitTime) > CpuCacheShrinkTicks) {
                //
                // Commits are happening too slowly.  Reduce the size of each
                // Commit.
                //
                if (Cache->ChunkSize > CpuCacheChunkMin) {
                    Cache->ChunkSize /= 2;
                }
            }
        }

        RegionSize = Cache->ChunkSize;
        if (RegionSize < Size) {
            //
            // The commit size is smaller than the requested allocation.
            // Commit enough to satisfy the allocation plus one more like it.
            //
            RegionSize = Size*2;
        }
        if (RegionSize+Cache->CommitIndex >= Cache->MaxSize) {
            //
            // The ChunkSize is larger than the remaining free space in the
            // cache.  Use whatever space is left.
            //
            RegionSize = Cache->MaxSize - Cache->CommitIndex;
        }
        pAllocation = &Cache->StartAddress[Cache->CommitIndex];

        Status = NtAllocateVirtualMemory(NtCurrentProcess(),
                                         &pAllocation,
                                         0,
                                         &RegionSize,
                                         MEM_COMMIT,
                                         PAGE_READWRITE);
        if (!NT_SUCCESS(Status)) {
            //
            // Commit failed.  Caller may flush the caches in order to
            // force success (as the static cache has no commit).
            //
            return NULL;
        }

        CPUASSERT((pAllocation == (&Cache->StartAddress[Cache->CommitIndex])))
        
#if DBG
        //
        // Fill the TC with a unique illegal value, so we can distinguish
        // old code from new code and detect overwrites.
        //
        RtlFillMemoryUlong(&Cache->StartAddress[Cache->CommitIndex],
                           RegionSize,
                           DBG_FILL_VALUE
                          );
#endif
        Cache->CommitIndex += RegionSize;
        Cache->LastCommitTime = CommitTime;

    }

    return Address;
}


VOID
FlushCache(
    PCACHEINFO Cache
    )
/*++

Routine Description:

    Flush out a Translation Cache.

Arguments:

    Cache - cache to flush
    
Return Value:

    .

--*/
{
    NTSTATUS Status;
    ULONGLONG RegionSize;
    PVOID pAllocation;

    //
    // Only decommit pages if the current commit size is >= the size
    // we want to shrink to.  It may not be that big if somebody called
    // CpuFlushInstructionCache() before the commit got too big.
    //
    if (Cache->CommitIndex > Cache->MinCommit) {
        Cache->LastCommitTime = NtGetTickCount();

        RegionSize = Cache->CommitIndex - Cache->MinCommit;
        pAllocation = &Cache->StartAddress[Cache->MinCommit];
        Status = NtFreeVirtualMemory(NtCurrentProcess(),
                                     &pAllocation,
                                     &RegionSize,
                                     MEM_DECOMMIT);
        if (!NT_SUCCESS(Status)) {
            LOGPRINT((ERRORLOG, "NtFreeVM(%x, %x) failed %x\n",
                    &Cache->StartAddress[Cache->MinCommit],
                    Cache->CommitIndex - Cache->MinCommit,
                    Status));
            ProxyDebugBreak();
        }
        CPUASSERTMSG(NT_SUCCESS(Status), "Failed to decommit TranslationCache chunk");

        Cache->CommitIndex = Cache->MinCommit;
    }

#if DBG
    //
    // Fill the Cache with a unique illegal value, so we can
    // distinguish old code from new code and detect overwrites.
    //
    RtlFillMemoryUlong(Cache->StartAddress, Cache->CommitIndex, DBG_FILL_VALUE);
#endif

    Cache->NextIndex = 0;
}


PCHAR
AllocateTranslationCache(
    ULONG Size
    )
/*++

Routine Description:

    Allocate space within the Translation Cache.  If there is insufficient
    space, the cache will be flushed.  Allocations are guaranteed to
    succeed.

Arguments:

    Size            - Size of the allocation request, in bytes
    
Return Value:

    Pointer to DWORD-aligned memory of 'Size' bytes.  Always non-NULL.

--*/
{
    PCHAR Address;

    //
    // Check parameters
    //
    CPUASSERT(Size <= CpuCacheReserve);
    CPUASSERTMSG((Size & 3) == 0, "Requested allocation size DWORD-aligned")

    //
    // Make sure there is only one thread with access to the translation
    // cache.
    //
    CPUASSERT( (MrswTC.Counters.WriterCount > 0 && MrswTC.WriterThreadId == ProxyGetCurrentThreadId()) ||
               (MrswEP.Counters.WriterCount > 0 && MrswEP.WriterThreadId == ProxyGetCurrentThreadId()) );

    //
    // Try to allocate from the cache
    //
    Address = AllocateFromCache(&DynCache, Size);
    if (!Address) {
        //
        // Translation cache is full - time to flush Translation Cache
        // (Both Dyn and Stat caches go at once).
        //
#ifdef CODEGEN_PROFILE            
        DumpAllocFailure();
#endif
        FlushTranslationCache(0, 0xffffffff);
        Address = AllocateFromCache(&DynCache, Size);
        CPUASSERT(Address); // Alloc from cache after a flush
    }

    return Address;
}

VOID
FreeUnusedTranslationCache(
    PCHAR StartOfFree
    )
/*++

Routine Description:

    After allocating from the TranlsationCache, a caller can free the tail-
    end of the last allocation.

Arguments:

    StartOfFree -- address of first unused byte in the last allocation
    
Return Value:

    .

--*/
{
    CPUASSERT(StartOfFree > (PCHAR)DynCache.StartAddress &&
              StartOfFree < (PCHAR)DynCache.StartAddress + DynCache.NextIndex);

    DynCache.NextIndex = StartOfFree - DynCache.StartAddress;
}



VOID
FlushTranslationCache(
    PVOID IntelAddr,
    DWORD IntelLength
    )
/*++

Routine Description:

    Indicates that a range of Intel memory has changed and that any
    native code in the cache which corresponds to that Intel memory is stale
    and needs to be flushed.

    The caller *must* have the EP write lock before calling.  This routine
    locks the TC for write, then unlocks the TC when done.

    IntelAddr = 0, IntelLength = 0xffffffff guarantees the entire cache is
    flushed.

Arguments:

    IntelAddr   -- Intel address of the start of the range to flush
    IntelLength -- Length (in bytes) of memory to flush
    
Return Value:

    .

--*/
{
    if (IntelLength == 0xffffffff ||
        IsIntelRangeInCache(IntelAddr, IntelLength)) {

        DECLARE_CPU;
        //
        // Tell active readers to bail out of the Translation Cache, then
        // get the TC write lock.  The MrswWriterEnter() call will block
        // until the last active reader leaves the cache.
        //
        InterlockedIncrement(&ProcessCpuNotify);
        MrswWriterEnter(&MrswTC);
        InterlockedDecrement(&ProcessCpuNotify);

        //
        // Bump the timestamp
        //
        TranslationCacheTimestamp++;
        
#ifdef CODEGEN_PROFILE
        //
        // Write the contents of the translation cache and entrypoints to 
        // disk.
        //
        DumpCodeDescriptions(TRUE);
        EPSequence = 0;
#endif        

        //
        // Flush the per-process data structures.  Per-thread data structures
        // should be flushed in the CpuSimulate() loop by examining the
        // value of TranslationCacheTimestamp.
        //
        FlushEntrypoints();
        FlushIndirControlTransferTable();
        FlushCallstack(cpu);
        FlushCache(&DynCache);
        TranslationCacheFlags = 0;

        //
        // Allow other threads to become TC readers again.
        //
        MrswWriterExit(&MrswTC);
    }
}

VOID
CpuFlushInstructionCache(
    PVOID IntelAddr,
    DWORD IntelLength
    )
/*++

Routine Description:

    Indicates that a range of Intel memory has changed and that any
    native code in the cache which corresponds to that Intel memory is stale
    and needs to be flushed.

    IntelAddr = 0, IntelLength = 0xffffffff guarantees the entire cache is
    flushed.

Arguments:

    IntelAddr   -- Intel address of the start of the range to flush
    IntelLength -- Length (in bytes) of memory to flush
    
Return Value:

    .

--*/
{
    if (!fTCInitialized) {
        // we may be called before the CpuProcessInit() has been run if
        // a Dll is mapped because of a forwarder from one Dll to another.
        return;
    }

    MrswWriterEnter(&MrswEP);
    FlushTranslationCache(IntelAddr, IntelLength);
    MrswWriterExit(&MrswEP);
}


VOID
CpuStallExecutionInThisProcess(
    VOID
    )
/*++

Routine Description:

    Get all threads out of the Translation Cache and into a state where
    their x86 register sets are accessible via the Get/SetReg APIs.
    The caller is guaranteed to call CpuResumeExecutionInThisProcess()
    a short time after calling this API.

Arguments:

    None.
    
Return Value:

    None.  This API may wait for a long time if there are many threads, but
    it is guaranteed to return.

--*/
{
    //
    // Prevent additional threads from compiling code.
    //
    MrswWriterEnter(&MrswEP);

    //
    // Tell active readers to bail out of the Translation Cache, then
    // get the TC write lock.  The MrswWriterEnter() call will block
    // until the last active reader leaves the cache.
    //
    InterlockedIncrement(&ProcessCpuNotify);
    MrswWriterEnter(&MrswTC);
    InterlockedDecrement(&ProcessCpuNotify);
}


VOID
CpuResumeExecutionInThisProcess(
    VOID
    )
/*++

Routine Description:

    Allow threads to start running inside the Translation Cache again.

Arguments:

    None.
    
Return Value:

    None.

--*/
{
    //
    // Allow other threads to become EP and TC writers again.
    //
    MrswWriterExit(&MrswEP);
    MrswWriterExit(&MrswTC);
}


BOOL
AddressInTranslationCache(
    DWORD Address
    )
/*++

Routine Description:

    Determines if a RISC address is within the bounds of the Translation
    Cache.

Arguments:

    Address     -- Address to examine
    
Return Value:

    TRUE if Address is within the Translation Cache
    FALSE if not.

--*/
{
    PBYTE ptr = (PBYTE)Address;

    if (
        ((ptr >= DynCache.StartAddress) &&
         (ptr <= DynCache.StartAddress+DynCache.NextIndex))
    ) {
        ASSERTPtrInTC(ptr);
        return TRUE;
    }

    return FALSE;
}


#if DBG
VOID
ASSERTPtrInTC(
    PVOID ptr
)
/*++

Routine Description:

    (Checked-build-only).  CPUASSERTs if a particular native address pointer
    does not point into the Translation Cache.

Arguments:

    ptr             - native pointer in question
    
Return Value:

    none - either asserts or returns

--*/
{
    // Verify pointer is DWORD aligned.
    CPUASSERT(((LONGLONG)ptr & 3) == 0);


    if (
        (((PBYTE)ptr >= DynCache.StartAddress) && 
        ((PBYTE)ptr <= DynCache.StartAddress+DynCache.NextIndex))
    ) {
    
        // Verify the pointer points into allocated space in the cache
        CPUASSERT(*(PULONG)ptr != DBG_FILL_VALUE);
    
        return;
    }

    CPUASSERTMSG(FALSE, "Pointer is not within a Translation Cache");
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\cpumain\config.c ===
/*++
                                                                                
Copyright (c) 1996 Microsoft Corporation

Module Name:

    config.c

Abstract:
    
    This module implements the configuration support for the CPU.
    
Author:

    13-Jun-1996 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>

#define _WX86CPUAPI_
#include "wx86.h"
#include "wx86nt.h"
#include "wx86cpu.h"
#include "cpuassrt.h"
#include "config.h"
#include "entrypt.h"
#include "instr.h"
#include "compiler.h"

ASSERTNAME;

char *szBadVarMsg="%Ws value out-of-range - replacing with 0x%x.\n";

//
// The list of all configurable variables in the CPU.  All are initialized
// to their default values.
//
DWORD CpuCacheReserve         = 6144*1024;
DWORD CpuCacheCommit          = MAX_PROLOG_SIZE;
DWORD CpuCacheGrowTicks       = 200;
DWORD CpuCacheShrinkTicks     = 1000;
DWORD CpuCacheChunkMin        = 32*1024;
DWORD CpuCacheChunkMax        = 512*1024;
DWORD CpuCacheChunkSize       = 64*1024;
LARGE_INTEGER MrswTimeout;
DWORD CompilerFlags           = COMPFL_FAST;
DWORD fUseNPXEM               = FALSE;
DWORD CpuMaxAllocRetries      = 4;
DWORD CpuWaitForMemoryTime    = 200;
DWORD CpuInstructionLookahead = MAX_INSTR_COUNT;
DWORD CpuDisableDynamicCache  = FALSE;
DWORD CpuEntryPointReserve    = 0x1000000;
DWORD CpuDisableRegCache      = FALSE;
DWORD CpuDisableNoFlags       = FALSE;
DWORD CpuDisableEbpAlign      = FALSE;
DWORD CpuSniffWritableCode    = FALSE;

#define IsPowerOfTwo(x)       (((x) & ((x)-1)) == 0)

VOID
GetConfigurationData(
    VOID
    )
/*++

Routine Description:

    Overrides any variable(s) listed above with values from the Registry.

Arguments:

    None

Return Value:

    None

--*/
{
    PCONFIGVAR pcfg;

    pcfg = Wx86FetchConfigVar(STR_CACHE_RESERVE);
    if (pcfg) {
        if (pcfg->Data < MAX_PROLOG_SIZE) {
            CpuCacheReserve = MAX_PROLOG_SIZE;
            LOGPRINT((TRACELOG, szBadVarMsg, STR_CACHE_RESERVE, CpuCacheReserve));
        } else {
            CpuCacheReserve = pcfg->Data;
        }
        Wx86FreeConfigVar(pcfg);
    }

    pcfg = Wx86FetchConfigVar(STR_CACHE_COMMIT);
    if (pcfg) {
        if (pcfg->Data < MAX_PROLOG_SIZE) {
            CpuCacheCommit = MAX_PROLOG_SIZE;
            LOGPRINT((TRACELOG, szBadVarMsg, STR_CACHE_COMMIT, CpuCacheCommit));
        } else {
            CpuCacheCommit = pcfg->Data;
        }
        Wx86FreeConfigVar(pcfg);
    }
   if (CpuCacheCommit > CpuCacheReserve) {
        CpuCacheCommit = CpuCacheReserve;
        LOGPRINT((TRACELOG, szBadVarMsg, STR_CACHE_COMMIT, CpuCacheCommit));
    }

    pcfg = Wx86FetchConfigVar(STR_CACHE_GROW_TICKS);
    if (pcfg) {
        CpuCacheGrowTicks = pcfg->Data;
        Wx86FreeConfigVar(pcfg);
    }

    pcfg = Wx86FetchConfigVar(STR_CACHE_SHRINK_TICKS);
    if (pcfg) {
        CpuCacheShrinkTicks = pcfg->Data;
        Wx86FreeConfigVar(pcfg);
    }
    if (CpuCacheShrinkTicks < CpuCacheGrowTicks) {
        CpuCacheShrinkTicks = CpuCacheGrowTicks;
        LOGPRINT((TRACELOG, szBadVarMsg, STR_CACHE_SHRINK_TICKS, CpuCacheGrowTicks));
    }

    pcfg = Wx86FetchConfigVar(STR_CACHE_CHUNKMIN);
    if (pcfg) {
        if (!IsPowerOfTwo(pcfg->Data) ||
             pcfg->Data < MAX_PROLOG_SIZE ||
             pcfg->Data > CpuCacheReserve) {
            LOGPRINT((TRACELOG, szBadVarMsg, STR_CACHE_CHUNKMIN, CpuCacheChunkMin));
        } else {
            CpuCacheChunkMin = pcfg->Data;
        }
        Wx86FreeConfigVar(pcfg);
    }

    pcfg = Wx86FetchConfigVar(STR_CACHE_CHUNKMAX);
    if (pcfg) {
        if (!IsPowerOfTwo(pcfg->Data)) {
            LOGPRINT((TRACELOG, szBadVarMsg, STR_CACHE_CHUNKMAX, CpuCacheChunkMax));
        } else {
            CpuCacheChunkMax = pcfg->Data;
        }
        Wx86FreeConfigVar(pcfg);
    }
    if (CpuCacheChunkMax < CpuCacheChunkMin) {
        CpuCacheChunkMax = CpuCacheChunkMin;
        LOGPRINT((TRACELOG, szBadVarMsg, STR_CACHE_CHUNKMAX, CpuCacheChunkMax));
    } else if (CpuCacheChunkMax > CpuCacheReserve) {
        CpuCacheChunkMax = CpuCacheReserve;
        LOGPRINT((TRACELOG, szBadVarMsg, STR_CACHE_CHUNKMAX, CpuCacheChunkMax));
    }

    pcfg = Wx86FetchConfigVar(STR_CACHE_CHUNKSIZE);
    if (pcfg) {
        if (!IsPowerOfTwo(pcfg->Data)) {
            LOGPRINT((TRACELOG, szBadVarMsg, STR_CACHE_CHUNKSIZE, CpuCacheChunkSize));
        } else {
            CpuCacheChunkSize = pcfg->Data;
        }
        Wx86FreeConfigVar(pcfg);
    }
    if (CpuCacheChunkSize < CpuCacheChunkMin) {
        CpuCacheChunkSize = CpuCacheChunkMin;
        LOGPRINT((TRACELOG, szBadVarMsg, STR_CACHE_CHUNKSIZE, CpuCacheChunkSize));
    } else if (CpuCacheChunkSize > CpuCacheChunkMax) {
        CpuCacheChunkSize = CpuCacheChunkMax;
        LOGPRINT((TRACELOG, szBadVarMsg, STR_CACHE_CHUNKSIZE, CpuCacheChunkSize));
    }

    pcfg = Wx86FetchConfigVar(STR_MRSW_TIMEOUT);
    if (pcfg) {
        if (pcfg->Data & 0x80000000) {
            //
            // Value is negative - use a big negative value to wait forever
            //
            MrswTimeout.LowPart =  0x00000000;
            MrswTimeout.HighPart = 0x80000000;
        } else {
            //
            // Multiply the time in ms by -10000 to convert into a relative
            // time usable by NtWaitForSingleObject().
            //
            MrswTimeout.QuadPart = Int32x32To64(pcfg->Data, -10000);
        }
        Wx86FreeConfigVar(pcfg);
    } else {
        //
        // Initialize MrswTimeout to be 3 times PEB->CriticalSectionTimeout
        //
        MrswTimeout.QuadPart = NtCurrentPeb()->CriticalSectionTimeout.QuadPart * 3;
    }

    pcfg = Wx86FetchConfigVar(STR_COMPILERFLAGS);
    if (pcfg) {
        if ( (pcfg->Data & (COMPFL_FAST|COMPFL_SLOW)) == (COMPFL_FAST|COMPFL_SLOW)) {
            LOGPRINT((TRACELOG, szBadVarMsg, STR_COMPILERFLAGS, CompilerFlags));
        } else {
            CompilerFlags = pcfg->Data;
        }
        Wx86FreeConfigVar(pcfg);
    }

    pcfg = Wx86FetchConfigVar(STR_USEWINPXEM);
    if (pcfg) {
        fUseNPXEM = pcfg->Data;
        Wx86FreeConfigVar(pcfg);
    }

    pcfg = Wx86FetchConfigVar(STR_CPU_MAX_ALLOC_RETRIES);
    if (pcfg) {
        CpuMaxAllocRetries = pcfg->Data;
        Wx86FreeConfigVar(pcfg);
    }

    pcfg = Wx86FetchConfigVar(STR_CPU_WAIT_FOR_MEMORY_TIME);
    if (pcfg) {
        CpuWaitForMemoryTime = pcfg->Data;
        Wx86FreeConfigVar(pcfg);
    }

    pcfg = Wx86FetchConfigVar(STR_CPU_MAX_INSTRUCTIONS);
    if (pcfg) {
        if (pcfg->Data > MAX_INSTR_COUNT) {
            LOGPRINT((TRACELOG, szBadVarMsg, STR_CPU_MAX_INSTRUCTIONS, CpuInstructionLookahead));
        } else {
            CpuInstructionLookahead = pcfg->Data;
        }
        Wx86FreeConfigVar(pcfg);
    }

    pcfg = Wx86FetchConfigVar(STR_CPU_DISABLE_DYNCACHE);
    if (pcfg) {
        CpuDisableDynamicCache = pcfg->Data;
        Wx86FreeConfigVar(pcfg);
    }

    pcfg = Wx86FetchConfigVar(STR_CPU_DISABLE_REGCACHE);
    if (pcfg) {
        CpuDisableRegCache = pcfg->Data;
        Wx86FreeConfigVar(pcfg);
    }

    pcfg = Wx86FetchConfigVar(STR_CPU_DISABLE_NOFLAGS);
    if (pcfg) {
        CpuDisableNoFlags = pcfg->Data;
        Wx86FreeConfigVar(pcfg);
    }

    pcfg = Wx86FetchConfigVar(STR_CPU_DISABLE_EBPALIGN);
    if (pcfg) {
        CpuDisableEbpAlign = pcfg->Data;
        Wx86FreeConfigVar(pcfg);
    }

    pcfg = Wx86FetchConfigVar(STR_CPU_SNIFF_WRITABLE_CODE);
    if (pcfg) {
        CpuSniffWritableCode = pcfg->Data;
        Wx86FreeConfigVar(pcfg);
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\cpumain\wowprxy.c ===
/*++
                                                                                
Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    wowprxy.c

Abstract:
    
    This module implements pxoxy interfaces not inplemented yet.
    
Author:

    24-Aug-1999 askhalid

Revision History:

    29-Jan-2000  SamerA  Added CpupDoInterrupt and CpupRaiseException

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <errno.h>

#define _WOW64CPUAPI_
#define _WX86CPUAPI_
#include "wx86.h"

#include "wx86nt.h"
#include "wx86cpu.h"
#include "cpuassrt.h"
#include "config.h"
#include "entrypt.h"
#include "instr.h"
#include "compiler.h"

ASSERTNAME;

PVOID _HUGE;
CONFIGVAR CpuConfigData;



NTSTATUS
CpupDoInterrupt(
    IN DWORD InterruptNumber)
/*++

Routine Description:

    This routine simulates an x86 software interrupt.

Arguments:

    InterruptNumber  - Interrupt number to simulate

Return Value:

    NTSTATUS
--*/
{
    return Wow64RaiseException(InterruptNumber, NULL);
}


NTSTATUS
CpupRaiseException(
    IN PEXCEPTION_RECORD ExceptionRecord)
{
    return Wow64RaiseException(-1L, ExceptionRecord);
}



PCONFIGVAR
Wx86FetchConfigVar(
   PWSTR VariableName
   )
{
    return NULL;
}

VOID
Wx86FreeConfigVar(
   PCONFIGVAR ConfigVar
   )
{
}

VOID
Wx86RaiseStatus(
    NTSTATUS Status
    )
{
    EXCEPTION_RECORD ExRec;
    DECLARE_CPU;

    ExRec.ExceptionCode    = Status;
    ExRec.ExceptionFlags   = EXCEPTION_NONCONTINUABLE;
    ExRec.ExceptionRecord  = NULL;
    ExRec.ExceptionAddress = (PVOID)cpu->eipReg.i4;
    ExRec.NumberParameters = 0;
    
    CpupRaiseException(&ExRec);
}

void
Wx86DispatchBop(
    PBOPINSTR Bop
    )
{
    CONTEXT32 Context;
    DECLARE_CPU;

    Context.ContextFlags = CONTEXT_CONTROL_WX86|CONTEXT_INTEGER_WX86;
    MsCpuGetContext(&Context);

    cpu->Eax.i4=Wow64SystemService(cpu->Eax.i4,
                                   &Context);
}

BOOL
ProxyIsProcessorFeaturePresent (
    DWORD ProcessorFeature
    )
{
    BOOL rv;

    if ( ProcessorFeature < PROCESSOR_FEATURE_MAX ) {
        rv = (BOOL)(USER_SHARED_DATA->ProcessorFeatures[ProcessorFeature]);
        }
    else {
        rv = FALSE;
        }
    return rv;
}



VOID ProxyRaiseException(
    IN DWORD dwExceptionCode,
    IN DWORD dwExceptionFlags,
    IN DWORD nNumberOfArguments,
    IN CONST ULONG_PTR *lpArguments
    )
{
    EXCEPTION_RECORD ExceptionRecord;
    ULONG n;
    PULONG s,d; 
    ExceptionRecord.ExceptionCode = (DWORD)dwExceptionCode;
    ExceptionRecord.ExceptionFlags = dwExceptionFlags & EXCEPTION_NONCONTINUABLE;
    ExceptionRecord.ExceptionRecord = NULL;
    ExceptionRecord.ExceptionAddress = NULL;
    if ( ARGUMENT_PRESENT(lpArguments) ) {
        n =  nNumberOfArguments;
        if ( n > EXCEPTION_MAXIMUM_PARAMETERS ) {
            n = EXCEPTION_MAXIMUM_PARAMETERS;
            }
        ExceptionRecord.NumberParameters = n;
        s = (PULONG)lpArguments;
        d = (PULONG)ExceptionRecord.ExceptionInformation;
        while(n--){
            *d++ = *s++;
            }
        }
    else {
        ExceptionRecord.NumberParameters = 0;
        }

    
    CpupRaiseException(&ExceptionRecord);

}



VOID
SetMathError ( 
              int Code 
              )
{
    int *_errno();
    *_errno() = Code;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\cpumain\cpumain.c ===
/*++
                                                                                
Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    cpumain.c

Abstract:
    
    This module implements the public interface to the CPU.
    
Author:

    03-Jul-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>

#define _WX86CPUAPI_
#include "wx86nt.h"
#include "wx86cpu.h"
#include "cpuassrt.h"
#include "config.h"
#include "instr.h"
#include "threadst.h"
#include "cpunotif.h"
#include "cpuregs.h"
#include "entrypt.h"
#include "compiler.h"
#include "instr.h"
#include "frag.h"
#include "entrypt.h"
#include "mrsw.h"
#include "tc.h"
#include "cpumain.h"
#include "wx86.h"
#include "atomic.h"
#ifdef CODEGEN_PROFILE
#include <coded.h>
#endif
#include "wow64t.h"
#include <wow64.h>

ASSERTNAME;

//
// Identify the CPU type for the debugger extensions
//
WX86_CPUTYPE Wx86CpuType = Wx86CpuCpu;

//
// Per-process CpuNotify bits.  These are different than the per-thread
// bits.
//
DWORD ProcessCpuNotify;


NTSTATUS
MsCpuProcessInit(
    VOID
    )
/*++

Routine Description:

    Initialize the CPU.  Must be called once at process initialization.

Arguments:

    None

Return Value:

    None

--*/
{
#if 0
    DbgBreakPoint();
#endif

    //
    // Read all configuration data from the registry
    //
    GetConfigurationData();

    MrswInitializeObject(&MrswEP);
    MrswInitializeObject(&MrswTC);
    MrswInitializeObject(&MrswIndirTable);

    if (!InitializeTranslationCache()) {
        return STATUS_UNSUCCESSFUL;
    }

    if (!initEPAlloc()) {
#if DBG
        LOGPRINT((TRACELOG, "CpuProcessInit: Entry Point allocator initialization failed"));
#endif
        return STATUS_UNSUCCESSFUL;
    }

    if (!initializeEntryPointModule()) {
#if DBG
        LOGPRINT((TRACELOG, "CpuProcessInit: Entry Point module initialization failed"));
#endif
        return STATUS_UNSUCCESSFUL;
    }
#if 0
    if (!(Wx86LockSynchMutexHandle = CreateMutex(NULL, FALSE, "Wx86LockSynchMutex"))) {
#if DBG
        LOGPRINT((TRACELOG, "CpuProcessInit: Cannot create Wx86LockSynchMutex"));
#endif
        return STATUS_UNSUCCESSFUL;
    }
#endif
    RtlInitializeCriticalSection(&Wx86LockSynchCriticalSection);

    SynchObjectType = USECRITICALSECTION;

#ifdef CODEGEN_PROFILE
    InitCodegenProfile();
#endif

    return STATUS_SUCCESS;
}

BOOL
MsCpuProcessTerm(
    BOOL OFlyInit
    )
{
#if 0
    NtClose(Wx86LockSynchMutexHandle);
    termEPAlloc();
#endif
    return TRUE;
}



BOOL
MsCpuThreadInit(
    VOID
    )
/*++

Routine Description:

    Initialize the CPU.  Must be called once for each thread.

Arguments:

    None.

Return Value:

    TRUE if successful initialization, FALSE if init failed.

--*/
{
    DWORD StackBase;
    PTEB32 Teb32 = WOW64_GET_TEB32(NtCurrentTeb());
    DECLARE_CPU;

    if (!FragLibInit(cpu, Teb32->NtTib.StackBase)) {
        return FALSE;
    }

    //
    // Mark the callstack as valid
    //
    cpu->CSTimestamp = TranslationCacheTimestamp;

    //
    // Mark the TC as being unlocked
    //
    cpu->fTCUnlocked = TRUE;

    //
    // All done.
    //
    return TRUE;
}



VOID
CpuResetToConsistentState(
    PEXCEPTION_POINTERS pExceptionPointers
    )
/*++

Routine Description:

    Called by WX86 when the exception filter around CpuSimulate() fires.

Arguments:

    pExceptionPointers - state of the thread at the time the exception
                         occurred.

Return Value:

    None

--*/
{
    DECLARE_CPU;

    if (!cpu->fTCUnlocked) {
        //
        // We must unlock the TC before continuing
        //
        MrswReaderExit(&MrswTC);
        cpu->fTCUnlocked = TRUE;

        //
        // Call the compiler to deduce where Eip should be pointing
        // based on the RISC exception record.  It is called with
        // the Entrypoint write lock because it calls the compiler.
        // The compiler's global vars are usable only with EP write.
        //
        MrswWriterEnter(&MrswEP);
        GetEipFromException(cpu, pExceptionPointers);
        MrswWriterExit(&MrswEP);
    }
    Wow64TlsSetValue(WOW64_TLS_EXCEPTIONADDR, LongToPtr(cpu->eipReg.i4));
}


VOID
CpuPrepareToContinue(
    PEXCEPTION_POINTERS pExceptionPointers
    )
/*++

Routine Description:

    Called by WX86 prior to resuming execution on EXCEPTION_CONTINUE_EXECUTION

Arguments:

    pExceptionPointers - alpha context with which execution will be resumed.

Return Value:

    None

--*/
{
}

BOOLEAN
CpuMapNotify(
    PVOID DllBase,
    BOOLEAN Mapped
    )
/*++

Routine Description:

    Called by WX86 when an x86 DLL is loaded or unloaded.

Arguments:

    DllBase -- address where x86 DLL was loaded.
    Mapped  -- TRUE if x86 DLL was just mapped in, FALSE if DLL is just about
               to be unmapped.

Return Value:

    TRUE on success, FALSE on failure.

--*/
{
    if (Mapped) {
        NTSTATUS st;
        MEMORY_BASIC_INFORMATION mbi;
        ULONG Length;

        st = NtQueryVirtualMemory(NtCurrentProcess(),
                                  DllBase,
                                  MemoryBasicInformation,
                                  &mbi,
                                  sizeof(mbi),
                                  NULL);
        if (NT_SUCCESS(st)) {
            Length = (ULONG)mbi.RegionSize;
        } else {
            // Flush the whole translation cache
            DllBase = 0;
            Length = 0xffffffff;
        }

        CpuFlushInstructionCache(DllBase, Length);
    }
    return TRUE;
}


VOID
CpuEnterIdle(
    BOOL OFly
    )
/*++

Routine Description:

    Called by WX86 when Wx86 ofly is going idle, or when Wx86 is out of
    memory and needs some pages.  The CPU must free as many resources
    as possible.

Arguments:

    OFly    - TRUE if called from on-the-fly, FALSE if called due to
              out of memory.

Return Value:

    None.

--*/
{
    CpuFlushInstructionCache(0, 0xffffffff);
}

BOOL
CpuIsProcessorFeaturePresent(
    DWORD ProcessorFeature
    )
/*++

Routine Description:

    Called by whkrnl32!whIsProcessorFeaturePresent().  The CPU gets to
    fill in its own feature set.

Arguments:

    ProcessorFeature    -- feature to query (see winnt.h PF_*)

Return Value:

    TRUE if feature present, FALSE if not.

--*/
{
    BOOL fRet;

    switch (ProcessorFeature) {
    case PF_FLOATING_POINT_PRECISION_ERRATA:
    case PF_COMPARE_EXCHANGE_DOUBLE:
    case PF_MMX_INSTRUCTIONS_AVAILABLE:
        fRet = FALSE;
        break;

    case PF_FLOATING_POINT_EMULATED:
        //
        // TRUE when winpxem.dll used to emulate floating-point with x86
        // integer instructions.
        //
        fRet = fUseNPXEM;
        break;

    default:
        //
        // Look up the native feature set
        //
        fRet = ProxyIsProcessorFeaturePresent(ProcessorFeature);
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\cpumain\wowrap.c ===
/*++
                                                                                
Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    wowrap.c

Abstract:
    
    This module implements some wrapper (on wx86cpu) functions wow64 might call.
    
Author:

    24-Aug-1999 askhalid

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>

#define _WOW64CPUAPI_
#define _WX86CPUAPI_
#define __WOW64_WRAPPER__

#include "wx86.h"
#include "wow64.h"
#include "wx86nt.h"
#include "wx86cpu.h"
#include "cpuassrt.h"
#include "config.h"
#include "entrypt.h"
#include "instr.h"
#include "compiler.h"
#include "wow64cpu.h"

ASSERTNAME;

typedef struct _WowBopInstr {
    BOPINSTR Wx86Bop;
    BYTE Ret;
} WOWBOPINSTR;

WOWBOPINSTR Bop;

 
NTSTATUS 
CpuProcessInit(PSIZE_T pCpuThreadDataSize)
{
    NTSTATUS st;

    memset ( (char *)&Bop, 0, sizeof (Bop) );
    Bop.Wx86Bop.Instr1 = 0xc4;
    Bop.Wx86Bop.Instr2 = 0xc4;
    Bop.Ret    = 0xc3;   // ret

    st = MsCpuProcessInit();

    *pCpuThreadDataSize = sizeof(CPUCONTEXT);

    return st;

}

NTSTATUS 
CpuProcessTerm(VOID)
{
    return 0;
}




NTSTATUS 
CpuThreadInit(PVOID pPerThreadData) 
{
    PTEB32 Teb32 = NtCurrentTeb32();

    //
    // Initialize the pointer to the DoSystemService function.
    Teb32->WOW32Reserved = (ULONG)(LONGLONG)&Bop;

    if ( MsCpuThreadInit()) {
        return 0;
    }

    return STATUS_SEVERITY_ERROR;  //return right value
}

//
// Execution 
//
VOID 
CpuSimulate(VOID)
{
    MsCpuSimulate(NULL);
}

//
// Exception handling, context manipulation
//
/* already been defined
VOID  
CpuResetToConsistentState(PEXCEPTION_POINTERS pExecptionPointers)
{


}*/


NTSTATUS  
CpuGetContext(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    OUT PCONTEXT32 Context)
/*++

Routine Description:

    Extracts the cpu context of the specified thread. If the target thread isn't the currently
    executing thread, then it should be guaranteed by the caller that the target thread 
    is suspended at a proper CPU state.
    Context->ContextFlags decides which IA32 register-set to retreive.

Arguments:

    ThreadHandle   - Target thread handle to retreive the context for
    ProcessHandle  - Open handle to the process that the thread runs in
    Teb            - Pointer to the target's thread TEB
    Context        - Context record to fill                 

Return Value:

    NTSTATUS.

--*/
{
    //Context->ContextFlags = CONTEXT_FULL_WX86;
    if (NtCurrentThread() == ThreadHandle)
    {
        return MsCpuGetContext(Context);
    }

    return MsCpuGetContextThread(ProcessHandle,
                                 Teb,
                                 Context);
}


NTSTATUS
CpuSetContext(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    PCONTEXT32 Context)
/*++

Routine Description:

    Sets the cpu context for the specified thread. If the target thread isn't the currently
    executing thread, then it should be guaranteed by the caller that the target thread is 
    suspended at a proper CPU state.
    Context->ContextFlags decides which IA32 register-set to be set.

Arguments:

    ThreadHandle   - Target thread handle to retreive the context for
    ProcessHandle  - Open handle to the process that the thread runs in
    Teb            - Pointer to the target's thread TEB
    Context        - Context record to set

Return Value:

    NTSTATUS.

--*/
{

    //Context->ContextFlags = CONTEXT_FULL_WX86;  // make sure wow return the right flags
    if (NtCurrentThread() == ThreadHandle)
    {
        return MsCpuSetContext(Context);
    }
    
    return MsCpuSetContextThread(ProcessHandle,
                                 Teb,
                                 Context);
}
 
 


 
ULONG 
CpuGetStackPointer ( )
// create a wrapper that calls the Wx86 CPU's GetEsp
{
    DECLARE_CPU;
    return GetEsp(cpu);
} 

VOID 
CpuNotifyDllLoad ( 
    LPWSTR DllName, 
    PVOID DllBase, 
    ULONG DllSize 
    )
// - create a wrapper on the Wx86 CPU's CpuMapNotify
{
        CpuMapNotify( DllBase, TRUE );
}


VOID 
CpuNotifyDllUnload ( 
    PVOID DllBase  
    )
//  - create a wrapper on the Wx86 CPU's CpuMapNotify
{
    CpuMapNotify( DllBase, FALSE );
}

VOID  
CpuSetInstructionPointer (
    ULONG Value
    )
//- wrapper on SetEip
{
    DECLARE_CPU;

    SetEip( cpu, Value);
}

VOID
CpuSetStackPointer (
    ULONG val
    ) 
//  - wrapper on SetEsp
{
    DECLARE_CPU;

    SetEsp(cpu, val);
}

NTSTATUS 
CpuThreadTerm(VOID)
//- just create an empty stub function - the Wx86 CPU doesn't care about this
{
 return 0;
}

/*
LONG
WOW64DLLAPI
Wow64SystemService(
    IN ULONG ServiceNumber,
    IN PCONTEXT32 Context32 //This is read only!
    )

*/

DWORD
ProxyWowDispatchBop( 
    ULONG ServiceNumber,
    PCONTEXT_WX86 px86Context,
    PULONG ArgBase
    )
{
    LONG ret=0;

    //CONTEXT32 _Context32;
    //_Context32.Edx = (ULONG)(ULONGLONG)ArgBase;  //this is the only field wow64 using

    if ( px86Context != NULL )
        ret = Wow64SystemService ( ServiceNumber, px86Context );
    return ret;

    //[bb] The wow64 equivalent is Wow64SystemService.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\dbgexts\entrypt.c ===
/*++
                                                                                
Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    entrypt.c

Abstract:
    
    Debugger extensions that give an entry point from either an
    intel address or a native address
    
Author:

    02-Aug-1995 Ori Gershony (t-orig)

Revision History:

--*/

#define _WOW64CPUDBGAPI_
#define DECLARE_CPU_DEBUGGER_INTERFACE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <ntsdexts.h>
#include "ntosdef.h"
#include "v86emul.h"
#include "ia64.h"
#include "wow64.h"
#include "wow64cpu.h"
#include "threadst.h"
#include "entrypt.h"

extern HANDLE Process;
extern HANDLE Thread;
extern PNTSD_OUTPUT_ROUTINE OutputRoutine;
extern PNTSD_GET_SYMBOL GetSymbolRoutine;
extern PNTSD_GET_EXPRESSION  GetExpression;
extern PWOW64GETCPUDATA CpuGetData;
extern LPSTR ArgumentString;

#define DEBUGGERPRINT (*OutputRoutine)
#define GETSYMBOL (*GetSymbolRoutine)
#define GETEXPRESSION (*GetExpression)
#define CPUGETDATA (*CpuGetData)


extern THREADSTATE LocalCpuContext;
extern BOOL ContextFetched;
extern BOOL ContextDirty;


#define DECLARE_EXTAPI(name)                    \
VOID                                            \
name(                                           \
    HANDLE hCurrentProcess,                     \
    HANDLE hCurrentThread,                      \
    DWORD64 dwCurrentPc,                        \
    PNTSD_EXTENSION_APIS lpExtensionApis,       \
    LPSTR lpArgumentString                      \
    )

#define INIT_EXTAPI                             \
    Process = hCurrentProcess;                  \
    Thread = hCurrentThread;                    \
    OutputRoutine = lpExtensionApis->lpOutputRoutine;           \
    GetSymbolRoutine = lpExtensionApis->lpGetSymbolRoutine;     \
    GetExpression = lpExtensionApis->lpGetExpressionRoutine;    \
    ArgumentString = lpArgumentString;


#if _ALPHA_
#define EXCEPTIONDATA_SIGNATURE 0x01010101
#else
#define EXCEPTIONDATA_SIGNATURE 0x12341234
#endif

// Assume we can have at most 1/2 million entrypoints in a tree:
//  With 4MB Translation Cache, we can have 1 million RISC instructions
//  in the cache.  Assume each Intel instruction requires 2 RISC instructions,
//  and that each Intel instruction has its own Entrypoint.  In that case,
//  there can be at most 1/2 million entrypoints.  Realistically, that number
//  should be much smaller (like 50,000).
//
// Also, since the Entrypoint tree is balanced (a property of Red-Black trees),
//  the required stack depth should be log2(500,000).
//
#define MAX_EPN_STACK_DEPTH 512*1024
ULONG_PTR EPN_Stack[MAX_EPN_STACK_DEPTH];
ULONG EPN_StackTop;
ULONG EPN_MaxStackDepth;

#define EPN_STACK_RESET()   EPN_StackTop=0; EPN_MaxStackDepth=0

#define EPN_PUSH(x) {                                       \
    if (EPN_StackTop == MAX_EPN_STACK_DEPTH-1) {            \
        DEBUGGERPRINT("Error: EPN stack overflow\n");             \
        goto Error;                                         \
    } else {                                                \
        EPN_Stack[EPN_StackTop] = x;                        \
        EPN_StackTop++;                                     \
        if (EPN_StackTop > EPN_MaxStackDepth) EPN_MaxStackDepth=EPN_StackTop; \
    }                                                       \
}

#define EPN_POP(x) {                                        \
    if (EPN_StackTop == 0) {                                \
        DEBUGGERPRINT("Error: EPN stack underflow\n");            \
        goto Error;                                         \
    } else {                                                \
        EPN_StackTop--;                                     \
        x = EPN_Stack[EPN_StackTop];                        \
    }                                                       \
}


NTSTATUS
TryGetExpr(
    PSTR  Expression,
    PULONG_PTR pValue
    );


VOID 
findEPI(
    ULONG_PTR intelAddress,
    ULONG_PTR intelRoot
    )
/*++

Routine Description:

    This routine finds an entry point which contains intelAddress if in the
    tree under intelRoot.

Arguments:

    intelAddress -- The intel address to be contained in the entry point
    
    intelRoot -- The root of the tree to use for the search

Return Value:

    return-value - none

--*/
{
    EPNODE entrypoint;
    NTSTATUS Status;

    for (;;) {
        Status = NtReadVirtualMemory(Process, (PVOID)intelRoot, (PVOID) (&entrypoint), sizeof(EPNODE), NULL);
        if (!NT_SUCCESS(Status)) {
            DEBUGGERPRINT("Error:  cannot read value of entry point at location %x\n", intelRoot);
            return;
        }

        if (intelRoot == (ULONG_PTR)entrypoint.intelLeft) {
            //
            // At a NIL node.
            //
            break;
        }

        if (intelAddress < (ULONG_PTR)entrypoint.ep.intelStart){
            intelRoot = (ULONG_PTR)entrypoint.intelLeft;
        } else if (intelAddress > (ULONG_PTR)entrypoint.ep.intelEnd) {
            intelRoot = (ULONG_PTR)entrypoint.intelRight;
        } else {
            DEBUGGERPRINT ("Entry point for intel address %x is at %x\n", intelAddress, intelRoot);
            DEBUGGERPRINT ("intelStart = %x,  intelEnd = %x\n", entrypoint.ep.intelStart, entrypoint.ep.intelEnd);
            DEBUGGERPRINT ("nativeStart  = %x,  nativeEnd  = %x\n", entrypoint.ep.nativeStart, entrypoint.ep.nativeEnd);
            return;
        }
    }

    DEBUGGERPRINT("Entry point corresponding to intel address %x is not in the tree.\n", intelAddress);
}

DECLARE_EXTAPI(epi)
/*++

Routine Description:

    This routine dumps the entry point information for an intel address

Arguments:

Return Value:

    return-value - none

--*/
{
    CHAR *pchCmd;
    ULONG_PTR intelAddress, pIntelRoot, intelRoot;
    NTSTATUS Status;

    INIT_EXTAPI;

    //
    // fetch the CpuContext for the current thread
    //
    if (!CpuDbgGetRemoteContext(CPUGETDATA(Process, Thread))) {
        return;
    }

    DEBUGGERPRINT ("Argument: %s\n", ArgumentString);
    
    //
    // advance to first token
    //
    pchCmd = ArgumentString;
    while (*pchCmd && isspace(*pchCmd)) {
        pchCmd++;
    }

    //
    // if exists must be intel address
    //
    if (*pchCmd) {
       Status = TryGetExpr(pchCmd, &intelAddress);
        if (!NT_SUCCESS(Status)) {
            DEBUGGERPRINT("Invalid Intel Address '%s' Status %x\n", pchCmd, Status);
            return;
        }
    } else {
        // Take the current eip value as the first argument
        intelAddress = LocalCpuContext.eipReg.i4;
    }

    Status = TryGetExpr("intelRoot", &pIntelRoot);
    if (!NT_SUCCESS(Status)) {
        DEBUGGERPRINT("Error:  cannot evaluate intelRoot\n");
        return;
    }

    Status = NtReadVirtualMemory(Process, (PVOID)pIntelRoot, (PVOID) (&intelRoot), sizeof(intelRoot), NULL);
    if (!NT_SUCCESS(Status)) {
        DEBUGGERPRINT("Error:  cannot read value of intelRoot\n");
        return;
    }

    findEPI(intelAddress, intelRoot);
}

ULONG_PTR
findEPN(
    ULONG_PTR nativeAddress,
    ULONG_PTR intelRoot
    )
/*++

Routine Description:

    This routine finds an entry point which contains nativeAddress if in the
    tree under intelRoot.

Arguments:

    nativeAddress -- The native address to be contained in the entry point
    
    intelRoot -- The root of the tree to use for the search

Return Value:

    return-value - NULL - entrypoint not found
                   non-NULL - ptr to ENTRYPOINT matching the native address

--*/
{
    EPNODE entrypoint;
    NTSTATUS Status;
    PVOID SubEP;

    EPN_STACK_RESET();

    EPN_PUSH(0);

    while (intelRoot != 0) {

        Status = NtReadVirtualMemory(Process, (PVOID)intelRoot, (PVOID) (&entrypoint), sizeof(EPNODE), NULL);
        if (!NT_SUCCESS(Status)) {
            DEBUGGERPRINT("Error:  cannot read value of entry point at location %x\n", intelRoot);
            return 0;
        }

        if ((nativeAddress >= (ULONG_PTR)entrypoint.ep.nativeStart) &&
            (nativeAddress <= (ULONG_PTR)entrypoint.ep.nativeEnd)) {

            DEBUGGERPRINT ("Entry point for native address %x is at %x\n", nativeAddress, intelRoot);
            DEBUGGERPRINT ("intelStart = %x,  intelEnd = %x\n", entrypoint.ep.intelStart, entrypoint.ep.intelEnd);
            DEBUGGERPRINT ("nativeStart  = %x,  nativeEnd  = %x\n", entrypoint.ep.nativeStart, entrypoint.ep.nativeEnd);
            return intelRoot;
        }

        // If there are sub-entrypoints, search them, too.
        SubEP = (PVOID)entrypoint.ep.SubEP;
        while (SubEP) {
            ENTRYPOINT ep;

            Status = NtReadVirtualMemory(Process, SubEP, (PVOID)(&ep), sizeof(ENTRYPOINT), NULL);
            if (!NT_SUCCESS(Status)) {
                DEBUGGERPRINT("Error:  cannot read value of sub-entry point at location %x\n", SubEP);
                return 0;
            }

            if ((nativeAddress >= (ULONG_PTR)ep.nativeStart) &&
                (nativeAddress <= (ULONG_PTR)ep.nativeEnd)) {
                DEBUGGERPRINT ("Entry point for native address %x is at %x\n", nativeAddress, intelRoot);
                DEBUGGERPRINT ("Sub-entrypoint actually containing the native address is %x\n", SubEP);
                DEBUGGERPRINT ("intelStart = %x,  intelEnd = %x\n", ep.intelStart, ep.intelEnd);
                DEBUGGERPRINT ("nativeStart  = %x,  nativeEnd  = %x\n", ep.nativeStart, ep.nativeEnd);
                return (ULONG_PTR)SubEP;
            }

            SubEP = ep.SubEP;
        }

        if ((ULONG_PTR)entrypoint.intelRight != intelRoot) {
            EPN_PUSH((ULONG_PTR)entrypoint.intelRight);
        }
        if ((ULONG_PTR)entrypoint.intelLeft != intelRoot) {
            EPN_PUSH((ULONG_PTR)entrypoint.intelLeft);
        }

        EPN_POP(intelRoot);
    }

    DEBUGGERPRINT("Entry point corresponding to native address %x is not in the tree.\n", nativeAddress);
Error:
    return 0;
}

VOID
FindEipFromNativeAddress(
    ULONG_PTR nativeAddress,
    ULONG_PTR pEP
    )
{
    ENTRYPOINT EP;
    NTSTATUS Status;
    PVOID pUL;
    ULONG UL;
    ULONG RiscStart;
    ULONG RiscEnd;
    ULONG cEntryPoints;

    Status = NtReadVirtualMemory(Process, (PVOID)pEP, (PVOID)(&EP), sizeof(ENTRYPOINT), NULL);
    if (!NT_SUCCESS(Status)) {
        DEBUGGERPRINT("Error:  cannot read value of entry point at location %x\n", pEP);
        return;
    }

    //
    // Search forward to the next EXCEPTIONDATA_SIGNATURE in the cache
    //
    pUL = (PVOID)(((ULONG_PTR)EP.nativeEnd+3) & ~3);
    do {
        Status = NtReadVirtualMemory(Process, pUL, &UL, sizeof(ULONG), NULL);
        if (!NT_SUCCESS(Status)) {
            DEBUGGERPRINT("Error: error reading from TC at %x\n", pUL);
            return;
        }

        pUL = (PVOID)( (PULONG)pUL + 1);
    } while (UL != EXCEPTIONDATA_SIGNATURE);

    //
    // Found the signature, get cEntryPoints
    //
    Status = NtReadVirtualMemory(Process, pUL, &cEntryPoints, sizeof(ULONG), NULL);
    if (!NT_SUCCESS(Status)) {
        DEBUGGERPRINT("Error: error reading from TC at %x\n", pUL);
        return;
    }
    pUL = (PVOID)( (PULONG)pUL + 1); // skip cEntryPoints

    while (1) {
        Status = NtReadVirtualMemory(Process, pUL, &UL, sizeof(ULONG), NULL);
        if (!NT_SUCCESS(Status)) {
            DEBUGGERPRINT("Error: error reading from TC at %x\n", pUL);
            return;
        }

        if (UL == (ULONG)pEP) {
            //
            // Found the right ENTRYPOINT pointer
            //
            break;
        }

        //
        // Skip over the pairs of (x86, risc) offsets
        //
        do {
            pUL = (PVOID)( (PULONG)pUL + 1);
            Status = NtReadVirtualMemory(Process, pUL, &UL, sizeof(ULONG), NULL);
            if (!NT_SUCCESS(Status)) {
                DEBUGGERPRINT("Error: error reading from TC at %x\n", pUL);
                return;
            }
        } while ((UL & 1) == 0);

        cEntryPoints--;
        if (cEntryPoints == 0) {
            DEBUGGERPRINT("Error: cEntryPoints went to 0 at %x\n", pUL);
            return;
        }

        pUL = (PVOID)( (PULONG)pUL + 1);
    }

    //
    // pUL points at the correct entrypoint pointer
    //
    nativeAddress -= (ULONG_PTR)EP.nativeStart; // Make relative to start of EP
    RiscStart = 0;                          // Also relative to start of EP
    while (1) {
        ULONG UL2;

        pUL = (PVOID)( (PULONG)pUL + 1);
        Status = NtReadVirtualMemory(Process, pUL, &UL, sizeof(ULONG), NULL);
        if (!NT_SUCCESS(Status)) {
            DEBUGGERPRINT("Error: error reading from TC at %x\n", pUL);
            return;
        }
        if (UL & 1) {
            break;
        }

        Status = NtReadVirtualMemory(Process, (PVOID)((PULONG)pUL+1), &UL2, sizeof(ULONG), NULL);
        if (!NT_SUCCESS(Status)) {
            DEBUGGERPRINT("Error: error reading from TC at %p\n", (ULONG_PTR)pUL+4);
            return;
        }
        RiscEnd = LOWORD(UL2) & 0xfffe;  // RiscEnd = RiscStart of next instr
        if ((RiscStart <= nativeAddress && nativeAddress < RiscEnd)
            || (UL & 1)) {
            DEBUGGERPRINT("Corresponding EIP=%p\n", (ULONG_PTR)EP.intelStart + HIWORD(UL));
            return;
        }
    }

    return;

}

DECLARE_EXTAPI(epn)
/*++

Routine Description:

    This routine dumps the entry point information for a native address

Arguments:

Return Value:

    return-value - none

--*/
{
    CHAR *pchCmd;
    ULONG_PTR nativeAddress, pIntelRoot, intelRoot, EP;
    NTSTATUS Status;

    INIT_EXTAPI;

    //
    // fetch the CpuContext for the current thread
    //
    if (!CpuDbgGetRemoteContext(CPUGETDATA(Process, Thread))) {
        return;
    }

    //
    // advance to first token
    //
    pchCmd = ArgumentString;
    while (*pchCmd && isspace(*pchCmd)) {
        pchCmd++;
    }

    //
    // if exists must be intel address
    //
    if (*pchCmd) {
        Status = TryGetExpr(pchCmd, &nativeAddress);
        if (!NT_SUCCESS(Status)) {
            DEBUGGERPRINT("Invalid Native Address '%s' Status %x\n", pchCmd, Status);
            return;
        }
    } else {
        // Use the current pc as the host address
        CONTEXT context;
        if (!GetThreadContext(Thread, &context)){
            DEBUGGERPRINT("Error:  cannot get thread context\n");
            return;
        }
#if defined (_MIPS_) || defined (_ALPHA_)
        nativeAddress = (ULONG)context.Fir;
#elif defined (_PPC_)
        nativeAddress = context.Iar;
#endif


    }

    Status = TryGetExpr("intelRoot", &pIntelRoot);
    if (!NT_SUCCESS(Status)) {
        DEBUGGERPRINT("Error:  cannot evaluate intelRoot\n");
        return;
    }

    Status = NtReadVirtualMemory(Process, (PVOID)pIntelRoot, (PVOID) (&intelRoot), sizeof(ULONG_PTR), NULL);
    if (!NT_SUCCESS(Status)) {
        DEBUGGERPRINT("Error:  cannot read value of intelRoot\n");
        return;
    }

    EP = findEPN(nativeAddress, intelRoot);
    if (EP) {
        FindEipFromNativeAddress(nativeAddress, EP);
    }
}

DECLARE_EXTAPI(dumpep)
/*++

Routine Description:

    This routine dumps all entrypoints.

Arguments:

Return Value:

    return-value - none

--*/
{
    ULONG_PTR pIntelRoot, intelRoot;
    NTSTATUS Status;
    EPNODE entrypoint;

    INIT_EXTAPI;

    //
    // fetch the CpuContext for the current thread
    //
    if (!CpuDbgGetRemoteContext(CPUGETDATA(Process, Thread))) {
        return;
    }

    Status = TryGetExpr("intelRoot", &pIntelRoot);
    if (!NT_SUCCESS(Status)) {
        DEBUGGERPRINT("Error:  cannot evaluate intelRoot\n");
        return;
    }

    Status = NtReadVirtualMemory(Process, (PVOID)pIntelRoot, (PVOID) (&intelRoot), sizeof(intelRoot), NULL);
    if (!NT_SUCCESS(Status)) {
        DEBUGGERPRINT("Error:  cannot read value of intelRoot\n");
        return;
    }

    EPN_STACK_RESET();

    EPN_PUSH(0);

    DEBUGGERPRINT("Entrypt: iStart:  iEnd:    rStart:  rEnd:    SubEP:   iLeft:   iRight:\n");
    //       xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx
    while (intelRoot != 0) {
        PENTRYPOINT ep;

        Status = NtReadVirtualMemory(Process, (PVOID)intelRoot, (PVOID) (&entrypoint), sizeof(EPNODE), NULL);
        if (!NT_SUCCESS(Status)) {
            DEBUGGERPRINT("Error:  cannot read value of entry point at location %x\n", intelRoot);
            return;
        }

        ep = &entrypoint.ep;

        //
        // Print all entrypoints except NIL.
        //
        if ((ULONG_PTR)entrypoint.intelLeft != intelRoot &&
            (ULONG_PTR)entrypoint.intelRight != intelRoot) {

            DEBUGGERPRINT("%8.8X %8.8X %8.8X %8.8X %8.8X %8.8X %8.8X %8.8X\n",
                    intelRoot,
                    ep->intelStart,
                    ep->intelEnd,
                    ep->nativeStart,
                    ep->nativeEnd,
                    ep->SubEP,
                    entrypoint.intelLeft,
                    entrypoint.intelRight
                   );

            while (ep->SubEP) {
                PVOID SubEP;

                SubEP = (PVOID)ep->SubEP;
                Status = NtReadVirtualMemory(Process, SubEP, (PVOID)ep, sizeof(ENTRYPOINT), NULL);
                if (!NT_SUCCESS(Status)) {
                    DEBUGGERPRINT("Error:  cannot read value of sub-entry point at location %x\n", SubEP);
                    return;
                }

                DEBUGGERPRINT("%8.8X %8.8X %8.8X %8.8X %8.8X %8.8X\n",
                    SubEP,
                    ep->intelStart,
                    ep->intelEnd,
                    ep->nativeStart,
                    ep->nativeEnd,
                    ep->SubEP
                   );


            }
        }

        if ((ULONG_PTR)entrypoint.intelRight != intelRoot) {
            EPN_PUSH((ULONG_PTR)entrypoint.intelRight);
        }
        if ((ULONG_PTR)entrypoint.intelLeft != intelRoot) {
            EPN_PUSH((ULONG_PTR)entrypoint.intelLeft);
        }

        EPN_POP(intelRoot);
    }
    DEBUGGERPRINT("---- End of Entrypoint Dump ----\n");
Error:
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\dbgexts\w64cpuex.c ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    w64cpuex.c

Abstract:

    Debugger extension DLL for debugging the CPU

Author:

    27-Sept-1999 BarryBo

Revision History:


--*/

#define _WOW64CPUDBGAPI_
#define DECLARE_CPU_DEBUGGER_INTERFACE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <ntsdexts.h>
#include "ntosdef.h"
#include "v86emul.h"
#include "ia64.h"
#include "wow64.h"
#include "wow64cpu.h"

#define MSCPU
#include "threadst.h"
#include "entrypt.h"
#include "config.h"
#include "instr.h"
#include "compiler.h"
#include "cpunotif.h"
#include "cpuregs.h"

/* Masks for bits 0 - 32. */
#define BIT0         0x1
#define BIT1         0x2
#define BIT2         0x4
#define BIT3         0x8
#define BIT4        0x10
#define BIT5        0x20
#define BIT6        0x40
#define BIT7        0x80
#define BIT8       0x100
#define BIT9       0x200
#define BIT10      0x400
#define BIT11      0x800
#define BIT12     0x1000
#define BIT13     0x2000
#define BIT14     0x4000
#define BIT15     0x8000
#define BIT16    0x10000
#define BIT17    0x20000
#define BIT18    0x40000
#define BIT19    0x80000
#define BIT20   0x100000
#define BIT21   0x200000
#define BIT22   0x400000
#define BIT23   0x800000
#define BIT24  0x1000000
#define BIT25  0x2000000
#define BIT26  0x4000000
#define BIT27  0x8000000
#define BIT28 0x10000000
#define BIT29 0x20000000
#define BIT30 0x40000000
#define BIT31 0x80000000

BOOL AutoFlushFlag = TRUE;

HANDLE Process;
HANDLE Thread;
PNTSD_OUTPUT_ROUTINE OutputRoutine;
PNTSD_GET_SYMBOL GetSymbolRoutine;
PNTSD_GET_EXPRESSION  GetExpression;
PWOW64GETCPUDATA CpuGetData;
LPSTR ArgumentString;

#define DEBUGGERPRINT (*OutputRoutine)
#define GETSYMBOL (*GetSymbolRoutine)
#define GETEXPRESSION (*GetExpression)
#define CPUGETDATA (*CpuGetData)

// Local copy of the current process/thread's CPU state
PVOID RemoteCpuData;
THREADSTATE LocalCpuContext;
BOOL ContextFetched;
BOOL ContextDirty;

// Cached addresses of interesting symbols within the CPU
HANDLE CachedProcess;
ULONG_PTR pCompilerFlags;
ULONG_PTR pTranslationCacheFlags;
ULONG_PTR pDirtyMemoryAddr;
ULONG_PTR pDirtyMemoryLength;

ULONG GetEfl(VOID);
VOID SetEfl(ULONG);

//
// Table mapping a byte to a 0 or 1, corresponding to the parity bit for
// that byte.
//
CONST BYTE ParityBit[] = {
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1
};


/*
 * Does a plain old GetExpression under a try-except
 */
NTSTATUS
TryGetExpr(
    PSTR  Expression,
    PULONG_PTR pValue
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    try {
        *pValue = GETEXPRESSION(Expression);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    return Status;
}


VOID
InvalidateSymbolsIfNeeded(
    VOID
    )
{
    if (CachedProcess == Process) {
        // The symbols match the current process
        return;
    }
    // else the symbols were for another process.  Invalidate the cache.
    pCompilerFlags = 0;
    pTranslationCacheFlags = 0;
    pDirtyMemoryAddr = 0;
    pDirtyMemoryLength = 0;
    CachedProcess = Process;
}


DWORD
GetCompilerFlags(void)
{
    NTSTATUS Status;
    DWORD CompilerFlags;

    InvalidateSymbolsIfNeeded();

    if (!pCompilerFlags) {
        Status = TryGetExpr("CompilerFlags", (ULONG_PTR *)&pCompilerFlags);
        if (!NT_SUCCESS(Status) || !pCompilerFlags) {
            DEBUGGERPRINT("Unable to get address of CompilerFlags Status %x\n",
                    Status
                   );
            pCompilerFlags = 0;
            return 0xffffffff;
        }
    }

    Status = NtReadVirtualMemory(Process, (PVOID)pCompilerFlags, &CompilerFlags, sizeof(DWORD), NULL);
    if (!NT_SUCCESS(Status)) {
        DEBUGGERPRINT("Unable to read CompilerFlags Status %x\n", Status);
        return 0xffffffff;
    }

    return CompilerFlags;
}

void
SetCompilerFlags(DWORD CompilerFlags)
{
    NTSTATUS Status;

    InvalidateSymbolsIfNeeded();

    if (!pCompilerFlags) {
        Status = TryGetExpr("CompilerFlags", (ULONG_PTR *)&pCompilerFlags);
        if (!NT_SUCCESS(Status) || !pCompilerFlags) {
            DEBUGGERPRINT("Unable to get address of CompilerFlags Status %x\n",
                    Status
                   );
            pCompilerFlags = 0;
            return;
        }
    }

    Status = NtWriteVirtualMemory(Process, (PVOID)pCompilerFlags, &CompilerFlags, sizeof(DWORD), NULL);
    if (!NT_SUCCESS(Status)) {
        DEBUGGERPRINT("Unable to writes CompilerFlags Status %x\n", Status);
        return;
    }
}

NTSTATUS
GetDirtyMemoryRange(PULONG DirtyMemoryAddr, PULONG DirtyMemoryLength)
{
    NTSTATUS Status;
    ULONG DirtyMemoryEnd;

    InvalidateSymbolsIfNeeded();

    if (pDirtyMemoryLength == 0) {
        //
        // First call to CpuFlushInstructionCache() - need to set up
        // the global variables.
        //

        Status = TryGetExpr("DbgDirtyMemoryAddr", (ULONG_PTR *)&pDirtyMemoryAddr);
        if (!NT_SUCCESS(Status) || !pDirtyMemoryAddr) {
            DEBUGGERPRINT("Unable to get address of DbgDirtyMemoryAddr Status %x\n",
                    Status
                   );
            return Status;
        }

        Status = TryGetExpr("DbgDirtyMemoryLength", (ULONG_PTR *)&pDirtyMemoryLength);
        if (!NT_SUCCESS(Status) || !pDirtyMemoryLength) {
            DEBUGGERPRINT("Unable to get address of DbgDirtyMemoryLength Status %x\n",
                    Status
                   );
            return Status;
        }
    }

    Status = NtReadVirtualMemory(Process,
                        (PVOID)pDirtyMemoryAddr,
                        DirtyMemoryAddr,
                        sizeof(ULONG),
                        NULL
                        );
    if (!NT_SUCCESS(Status)) {
        DEBUGGERPRINT("Unable to read pDirtyMemoryAddr %x Status %x\n",
                pDirtyMemoryAddr,
                Status
               );
        return Status;
    }

    Status = NtReadVirtualMemory(Process,
                        (PVOID)pDirtyMemoryLength,
                        DirtyMemoryLength,
                        sizeof(ULONG),
                        NULL
                        );
    if (!NT_SUCCESS(Status)) {
        DEBUGGERPRINT("Unable to read pDirtyMemoryLength %x Status %x\n",
                pDirtyMemoryLength,
                Status
               );
        pDirtyMemoryLength = 0;
        return Status;
    }

    return Status;
}




void
RemindUserToFlushTheCache(void)
{
    NTSTATUS Status;
    DWORD TranslationCacheFlags;
    DWORD CompilerFlags;
    BOOLEAN fCacheFlushPending;

    //
    // Read the value of TranslationCacheFlags
    //
    if (!pTranslationCacheFlags) {
        Status = TryGetExpr("TranslationCacheFlags", (ULONG_PTR *)&pTranslationCacheFlags);
        if (!NT_SUCCESS(Status) || !pTranslationCacheFlags) {
            DEBUGGERPRINT("Unable to get address of TranslationCacheFlags Status %x\n",
                    Status
                   );
            return;
        }
    }

    Status = NtReadVirtualMemory(Process, (PVOID)pTranslationCacheFlags, &TranslationCacheFlags, sizeof(TranslationCacheFlags), NULL);
    if (!NT_SUCCESS(Status)) {
        DEBUGGERPRINT("Unable to read TranslationCacheFlags Status %x\n", Status);
        return;
    }

    //
    // Read the value of CompilerFlags
    //
    CompilerFlags = GetCompilerFlags();
    if (CompilerFlags == 0xffffffff) {
        //
        // Got an error getting the CompilerFlags value.
        //
        return;
    }

    //
    // Determine if the Translation Cache is going to be flushed next time
    // the CPU runs or not.
    //
    fCacheFlushPending =
        (LocalCpuContext.CpuNotify & CPUNOTIFY_MODECHANGE) ? TRUE : FALSE;
    if (!fCacheFlushPending && (LocalCpuContext.CpuNotify & CPUNOTIFY_DBGFLUSHTC)) {
        DWORD Addr, Length;
        Status = GetDirtyMemoryRange(&Addr, &Length);
        if (!NT_SUCCESS(Status)) {
            return;
        }
        if (Addr == 0 && Length == 0xffffffff) {
            //
            // Cache flush is pending because user asked for !flush
            //
            fCacheFlushPending = TRUE;
        }
    }

    //
    // Give the user some worldly advice
    //
    if (LocalCpuContext.CpuNotify & (CPUNOTIFY_TRACEFLAG|CPUNOTIFY_SLOWMODE)) {
        //
        // We need to be in slow mode to get logging to work.
        //
        if (CompilerFlags & COMPFL_FAST) {
            //
            // Cpu is set to generate fast code.  Remedy that.
            //
            if (AutoFlushFlag) {
                SetCompilerFlags(COMPFL_SLOW);
            } else {
                DEBUGGERPRINT("CPU in fast mode.  Use '!wx86e.code SLOW' to switch to slow mode.\n");
            }
        }
        if (!fCacheFlushPending && (TranslationCacheFlags & COMPFL_FAST)) {
            //
            // Translation Cache contains fast code.  Rememdy that.
            //
            if (AutoFlushFlag) {
                LocalCpuContext.CpuNotify |= CPUNOTIFY_MODECHANGE;
                ContextDirty = TRUE;
            } else {
                DEBUGGERPRINT("Translation Cache contains fast code.  Use '!wx86e.flush' to flush,\n");
                DEBUGGERPRINT("or the CPU will probably jump somewhere unexpected.\n");
            }
        }

        if (fCacheFlushPending && TranslationCacheFlags == COMPFL_SLOW) {
            //
            // If there is a cache flush pending due to a switch in
            // compilation modes, but the code in the cache is already
            // correct, undo the cache flush
            //
            LocalCpuContext.CpuNotify &= ~(ULONG)CPUNOTIFY_MODECHANGE;
            ContextDirty = TRUE;
        }
    } else {
        //
        // We can run in fast mode.
        //
        if (CompilerFlags & COMPFL_SLOW) {
            //
            // Cpu is set to generate slow code.  Remedy that.
            //
            if (AutoFlushFlag) {
                SetCompilerFlags(COMPFL_FAST);
            } else {
                DEBUGGERPRINT("CPU in slow mode.  Use '!wx86e.code FAST' to switch to fast mode.\n");
            }
        }
        if (!fCacheFlushPending && (TranslationCacheFlags & COMPFL_SLOW)) {
            //
            // Translation Cache contains slow code.  Remedy that.
            //
            if (AutoFlushFlag) {
                LocalCpuContext.CpuNotify |= CPUNOTIFY_MODECHANGE;
                ContextDirty = TRUE;
            } else {
                DEBUGGERPRINT("Translation Cache contains slow code.  Use '!wx86e.flush' to flush.\n");
            }
        }

        if (fCacheFlushPending && TranslationCacheFlags == COMPFL_FAST) {
            //
            // If there is a cache flush pending due to a switch in
            // compilation modes, but the code in the cache is already
            // correct, undo the cache flush
            //
            LocalCpuContext.CpuNotify &= ~(ULONG)CPUNOTIFY_MODECHANGE;
            ContextDirty = TRUE;
        }
    }
}



WOW64CPUDBGAPI VOID
CpuDbgInitExtapi(
    HANDLE hArgProcess,
    HANDLE hArgThread,
    DWORD64 ArgCurrentPC,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    PWOW64GETCPUDATA lpGetData
    )
{
    Process = hArgProcess;
    Thread = hArgThread;
    OutputRoutine = lpExtensionApis->lpOutputRoutine;
    GetSymbolRoutine = lpExtensionApis->lpGetSymbolRoutine;
    GetExpression = lpExtensionApis->lpGetExpressionRoutine;
    CpuGetData = lpGetData;

    InvalidateSymbolsIfNeeded();
    ContextFetched = FALSE;
    ContextDirty = FALSE;
}


WOW64CPUDBGAPI BOOL
CpuDbgGetRemoteContext(
    PVOID CpuData
    )
{
    NTSTATUS Status;

    Status = NtReadVirtualMemory(Process,
                                 CpuData,
                                 &LocalCpuContext,
                                 sizeof(LocalCpuContext),
                                 NULL);
    if (!NT_SUCCESS(Status)) {
        DEBUGGERPRINT("CpuDbgGetRemoteContext:  Error %x reading CPU data from %x\n", Status, CpuData);
        return FALSE;
    }

    ContextFetched = TRUE;
    RemoteCpuData = CpuData;

    return TRUE;
}

WOW64CPUDBGAPI BOOL
CpuDbgSetRemoteContext(
    void
    )
{
    NTSTATUS Status;

    if (!ContextDirty) {
        // Perf. optimization... don't update the remote context if
        // nothing has changed.
        return TRUE;
    }

    if (!ContextFetched) {
        DEBUGGERPRINT("CpuDbgSetRemoteContext:  Remote context was never fetched!\n");
        return FALSE;
    }

    Status = NtWriteVirtualMemory(Process,
                                 RemoteCpuData,
                                 &LocalCpuContext,
                                 sizeof(LocalCpuContext),
                                 NULL);
    if (!NT_SUCCESS(Status)) {
        DEBUGGERPRINT("CpuDbgSetRemoteContext:  Error %x writing CPU data to %x\n", Status, RemoteCpuData);
        return FALSE;
    }

    ContextDirty = FALSE;

    return TRUE;
}

WOW64CPUDBGAPI BOOL
CpuDbgGetLocalContext(
    PCONTEXT32 Context
    )
{
    ULONG ContextFlags = Context->ContextFlags;
    PTHREADSTATE cpu = &LocalCpuContext;

    if ((ContextFlags & CONTEXT_CONTROL_WX86) == CONTEXT_CONTROL_WX86) {

        Context->EFlags = GetEfl();
        Context->SegCs  = CS;
        Context->Esp    = esp;
        Context->SegSs  = SS;
        Context->Ebp    = ebp;
        Context->Eip    = eip;
        //Context->Eip    = cpu->eipReg.i4;
    }

    if ((ContextFlags & CONTEXT_SEGMENTS_WX86) == CONTEXT_SEGMENTS_WX86) {
        Context->SegGs = GS;
        Context->SegFs = FS;
        Context->SegEs = ES;
        Context->SegDs = DS;
    }

    if ((ContextFlags & CONTEXT_INTEGER_WX86) == CONTEXT_INTEGER_WX86) {
        Context->Eax = eax;
        Context->Ebx = ebx;
        Context->Ecx = ecx;
        Context->Edx = edx;
        Context->Edi = edi;
        Context->Esi = esi;
    }

#if 0
    if ((ContextFlags & CONTEXT_FLOATING_POINT_WX86) == CONTEXT_FLOATING_POINT_WX86) {
    }

    if ((ContextFlags & CONTEXT_DEBUG_REGISTERS_WX86) == CONTEXT_DEBUG_REGISTERS_WX86) {
    }

    if ((ContextFlags & CONTEXT_EXTENDED_REGISTERS_WX86) == CONTEXT_EXTENDED_REGISTERS_WX86) {
    }
#endif
    return TRUE;
}

WOW64CPUDBGAPI BOOL
CpuDbgSetLocalContext(
    PCONTEXT32 Context
    )
{
    ULONG ContextFlags = Context->ContextFlags;
    PTHREADSTATE cpu = &LocalCpuContext;

    if ((ContextFlags & CONTEXT_CONTROL_WX86) == CONTEXT_CONTROL_WX86) {
        //
        // i386 control registers are:
        // ebp, eip, cs, eflag, esp and ss
        //
        LocalCpuContext.GpRegs[GP_EBP].i4 = Context->Ebp;
        LocalCpuContext.eipReg.i4 = Context->Eip;
        LocalCpuContext.GpRegs[REG_CS].i4= KGDT_R3_CODE|3;   // Force Reality
        SetEfl(Context->EFlags);
        LocalCpuContext.GpRegs[GP_ESP].i4 = Context->Esp;
        LocalCpuContext.GpRegs[REG_SS].i4 = KGDT_R3_DATA|3;   // Force Reality
        ContextDirty = TRUE;
    }

    if ((ContextFlags & CONTEXT_INTEGER_WX86)  == CONTEXT_INTEGER_WX86){
        //
        // i386 integer registers are:
        // edi, esi, ebx, edx, ecx, eax
        //
        LocalCpuContext.GpRegs[GP_EDI].i4 = Context->Edi;
        LocalCpuContext.GpRegs[GP_ESI].i4 = Context->Esi;
        LocalCpuContext.GpRegs[GP_EBX].i4 = Context->Ebx;
        LocalCpuContext.GpRegs[GP_EDX].i4 = Context->Edx;
        LocalCpuContext.GpRegs[GP_ECX].i4 = Context->Ecx;
        LocalCpuContext.GpRegs[GP_EAX].i4 = Context->Eax;
        ContextDirty = TRUE;
    }

    if ((ContextFlags & CONTEXT_SEGMENTS_WX86) == CONTEXT_SEGMENTS_WX86) {
        //
        // i386 segment registers are:
        // ds, es, fs, gs
        // And since they are a constant, force them to be the right values
        //
        LocalCpuContext.GpRegs[REG_DS].i4 = KGDT_R3_DATA|3;
        LocalCpuContext.GpRegs[REG_ES].i4 = KGDT_R3_DATA|3;
        LocalCpuContext.GpRegs[REG_FS].i4 = KGDT_R3_TEB|3;
        LocalCpuContext.GpRegs[REG_GS].i4 = KGDT_R3_DATA|3;
        ContextDirty = TRUE;
    }

#if 0
    if ((ContextFlags & CONTEXT_FLOATING_POINT_WX86) == CONTEXT_FLOATING_POINT_WX86) {
    }

    if ((ContextFlags & CONTEXT_DEBUG_REGISTERS_WX86) == CONTEXT_DEBUG_REGISTERS_WX86) {
    }

    if ((ContextFlags & CONTEXT_EXTENDED_REGISTERS_WX86) == CONTEXT_EXTENDED_REGISTERS_WX86) {
    }
#endif

    return TRUE;
}

WOW64CPUDBGAPI VOID
CpuDbgFlushInstructionCache(
    PVOID Addr,
    DWORD Length
    )
{
    NTSTATUS Status;
    ULONG DirtyMemoryEnd;
    ULONG DirtyMemoryAddr;
    ULONG DirtyMemoryLength;

    Status = GetDirtyMemoryRange(&DirtyMemoryAddr, &DirtyMemoryLength);
    if (!NT_SUCCESS(Status)) {
        return;
    }
    if (DirtyMemoryAddr == 0xffffffff) {
        DirtyMemoryEnd = 0;
    } else {
        DirtyMemoryEnd = DirtyMemoryAddr + DirtyMemoryLength;
    }

    if (PtrToUlong(Addr) < DirtyMemoryAddr) {
        //
        // The new address is before the start of the dirty range
        //
        DirtyMemoryLength += DirtyMemoryAddr-PtrToUlong(Addr);
        DirtyMemoryAddr = PtrToUlong(Addr);
    }

    if (PtrToUlong(Addr)+Length > DirtyMemoryEnd) {
        //
        // The range is too small - grow it
        //
        DirtyMemoryEnd = PtrToUlong(Addr)+Length;
        DirtyMemoryLength = DirtyMemoryEnd - DirtyMemoryAddr;
    }

    // Tell the CPU to call CpuFlushInstructionCache() next time it runs.
    //
    // The wow64 debugger extension guarantees that it will call
    // DbgCpuGetRemoteContext before this call, and will call
    // DbgCpuSetRemoteContext after this call, so we can flush out
    // our context then.
    //
    NtWriteVirtualMemory(Process, (PVOID)pDirtyMemoryAddr, &DirtyMemoryAddr, sizeof(ULONG), NULL);
    NtWriteVirtualMemory(Process, (PVOID)pDirtyMemoryLength, &DirtyMemoryLength, sizeof(ULONG), NULL);
    LocalCpuContext.CpuNotify |= CPUNOTIFY_DBGFLUSHTC;
    ContextDirty = TRUE;
}

VOID SetEax(ULONG ul) {
    LocalCpuContext.GpRegs[GP_EAX].i4 = ul;
    ContextDirty = TRUE;
}
VOID SetEbx(ULONG ul) {
    LocalCpuContext.GpRegs[GP_EBX].i4 = ul;
    ContextDirty = TRUE;
}
VOID SetEcx(ULONG ul) {
    LocalCpuContext.GpRegs[GP_ECX].i4 = ul;
    ContextDirty = TRUE;
}
VOID SetEdx(ULONG ul) {
    LocalCpuContext.GpRegs[GP_EDX].i4 = ul;
    ContextDirty = TRUE;
}
VOID SetEsi(ULONG ul) {
    LocalCpuContext.GpRegs[GP_ESI].i4 = ul;
    ContextDirty = TRUE;
}
VOID SetEdi(ULONG ul) {
    LocalCpuContext.GpRegs[GP_EDI].i4 = ul;
    ContextDirty = TRUE;
}
VOID SetEbp(ULONG ul) {
    LocalCpuContext.GpRegs[GP_EBP].i4 = ul;
    ContextDirty = TRUE;
}
VOID SetEsp(ULONG ul) {
    LocalCpuContext.GpRegs[GP_ESP].i4 = ul;
    ContextDirty = TRUE;
}
VOID SetEip(ULONG ul) {
    LocalCpuContext.eipReg.i4 = ul;
    ContextDirty = TRUE;
}
VOID SetEfl(ULONG ul) {
    LocalCpuContext.flag_cf = (ul & BIT0) ? 0x80000000 : 0;
    LocalCpuContext.flag_pf = (ul & BIT2) ? 0 : 1;
    LocalCpuContext.flag_aux= (ul & BIT4) ? 0x10 : 0;
    LocalCpuContext.flag_zf = (ul & BIT6) ? 0 : 1;
    LocalCpuContext.flag_sf = (ul & BIT7) ? 0x80000000 : 0;
    LocalCpuContext.flag_tf = (ul & BIT8) ? 1 : 0;
    LocalCpuContext.flag_df = (ul & BIT10) ? 1 : -1;
    LocalCpuContext.flag_of = (ul & BIT11) ? 0x80000000 : 0;
    // iopl, NT, RF, VM are ignored
    LocalCpuContext.flag_ac = (ul & BIT18);

    LocalCpuContext.CpuNotify &= ~CPUNOTIFY_TRACEFLAG;
    LocalCpuContext.CpuNotify |= LocalCpuContext.flag_tf;
    ContextDirty = TRUE;

    // If the single-step flag is set and the CPU is in fast mode, this
    // will flush the cache if autoflush is set, or else remind the user
    // if autoflush is clear.
    RemindUserToFlushTheCache();
}

ULONG GetEax(VOID) {
    return LocalCpuContext.GpRegs[GP_EAX].i4;
}
ULONG GetEbx(VOID) {
    return LocalCpuContext.GpRegs[GP_EBX].i4;
}
ULONG GetEcx(VOID) {
    return LocalCpuContext.GpRegs[GP_ECX].i4;
}
ULONG GetEdx(VOID) {
    return LocalCpuContext.GpRegs[GP_EDX].i4;
}
ULONG GetEsi(VOID) {
    return LocalCpuContext.GpRegs[GP_ESI].i4;
}
ULONG GetEdi(VOID) {
    return LocalCpuContext.GpRegs[GP_EDI].i4;
}
ULONG GetEsp(VOID) {
    return LocalCpuContext.GpRegs[GP_ESP].i4;
}
ULONG GetEbp(VOID) {
    return LocalCpuContext.GpRegs[GP_EBP].i4;
}
ULONG GetEip(VOID) {
    return LocalCpuContext.eipReg.i4;
}
ULONG GetEfl(VOID) {
    return (LocalCpuContext.flag_ac  |          // this is either 0 or 2^18
            // VM, RF, NT are all 0
            ((LocalCpuContext.flag_of & 0x80000000) ? (1 << 11) : 0) |
            ((LocalCpuContext.flag_df == -1) ? 0 : (1 << 10)) |
            1 <<  9 |    // IF
            LocalCpuContext.flag_tf <<  8 |
            ((LocalCpuContext.flag_sf & 0x80000000) ? (1 <<  7) : 0) |
            ((LocalCpuContext.flag_zf) ? 0 : (1 << 6)) |
            ((LocalCpuContext.flag_aux & 0x10) ? (1 << 4) : 0) |
            ParityBit[LocalCpuContext.flag_pf & 0xff] <<  2 |
            0x2 |
            ((LocalCpuContext.flag_cf & 0x80000000) ? 1 : 0)
            );
}

CPUREGFUNCS CpuRegFuncs[] = {
    { "eax", SetEax, GetEax },
    { "ebx", SetEbx, GetEbx },
    { "ecx", SetEcx, GetEcx },
    { "edx", SetEdx, GetEdx },
    { "esi", SetEsi, GetEsi },
    { "edi", SetEdi, GetEdi },
    { "esp", SetEsp, GetEsp },
    { "ebp", SetEbp, GetEbp },
    { "eip", SetEip, GetEip },
    { "efl", SetEfl, GetEfl },
    { NULL, NULL, NULL}
};

WOW64CPUDBGAPI PCPUREGFUNCS
CpuDbgGetRegisterFuncs(
    void
    )
{
    return CpuRegFuncs;
}

#define DECLARE_EXTAPI(name)                    \
VOID                                            \
name(                                           \
    HANDLE hCurrentProcess,                     \
    HANDLE hCurrentThread,                      \
    DWORD64 dwCurrentPc,                        \
    PNTSD_EXTENSION_APIS lpExtensionApis,       \
    LPSTR lpArgumentString                      \
    )

#define INIT_EXTAPI                             \
    Process = hCurrentProcess;                  \
    Thread = hCurrentThread;                    \
    OutputRoutine = lpExtensionApis->lpOutputRoutine;           \
    GetSymbolRoutine = lpExtensionApis->lpGetSymbolRoutine;     \
    GetExpression = lpExtensionApis->lpGetExpressionRoutine;    \
    ArgumentString = lpArgumentString;


DECLARE_EXTAPI(help)
{
    INIT_EXTAPI;

    DEBUGGERPRINT("WOW64 MS CPU debugger extensions:\n\n");
    DEBUGGERPRINT("epi [inteladdress]   - dump an entrypt based on x86 address\n");
    DEBUGGERPRINT("epn [nativeaddress]  - dump an entrypt based on a native address\n");
    DEBUGGERPRINT("dumpep               - all entrypts\n");
    DEBUGGERPRINT("code [fast|slow]     - set the CPU's code-gen mode\n");
    DEBUGGERPRINT("flush                - flush the Translation Cache\n");
    DEBUGGERPRINT("autoflush            - the debugger extension may auto-flush the TC\n");
    DEBUGGERPRINT("logeip               - enable EIP logging\n");
    DEBUGGERPRINT("last                 - dump the last EIP values\n");
    DEBUGGERPRINT("callstack            - dump the internal callstack cache\n");
}



DECLARE_EXTAPI(autoflush)
{
    INIT_EXTAPI;

    if (AutoFlushFlag) {
        AutoFlushFlag = FALSE;
        DEBUGGERPRINT("autoflush is OFF - use !flush to flush the cache when needed.\n");
    } else {
        AutoFlushFlag = TRUE;
        DEBUGGERPRINT("autoflush is ON - The CPU Cache will be flushed automatically.\n");
    }
}

DECLARE_EXTAPI(code)
{
    DWORD CompilerFlags;

    INIT_EXTAPI;

    CompilerFlags = GetCompilerFlags();
    if (CompilerFlags == 0xffffffff) {
        //
        // Got an error reading the CompilerFlags variable
        //
        return;
    }

    if (!ArgumentString) {
PrintCurrentValue:
        DEBUGGERPRINT("CPU Compiler is in %s mode.\n",
                (CompilerFlags & COMPFL_SLOW) ? "SLOW" : "FAST");
        return;
    }

    // Skip over whitespace
    while (*ArgumentString && isspace(*ArgumentString)) {
        ArgumentString++;
    }
    if (!*ArgumentString) {
        goto PrintCurrentValue;
    }

    if (_stricmp(ArgumentString, "fast") == 0) {
        SetCompilerFlags(COMPFL_FAST);
    } else if (_stricmp(ArgumentString, "slow") == 0) {
        SetCompilerFlags(COMPFL_SLOW);
    } else {
        DEBUGGERPRINT("usage: !code [fast|slow]\n");
    }

    RemindUserToFlushTheCache();
}

DECLARE_EXTAPI(flush)
{
    INIT_EXTAPI;

    if (!CpuDbgGetRemoteContext(CPUGETDATA(Process, Thread))) {
        return;
    }
    CpuDbgFlushInstructionCache(0, 0xffffffff);
    CpuDbgSetRemoteContext();
    DEBUGGERPRINT("CPU Translation Cache will flush next time CpuSimulate loops.\n");
}


DECLARE_EXTAPI(logeip)
{
    ULONG CpuNotify;

    INIT_EXTAPI;

    if (!CpuDbgGetRemoteContext(CPUGETDATA(Process, Thread))) {
        return;
    }

    CpuNotify = LocalCpuContext.CpuNotify;

    if (CpuNotify & CPUNOTIFY_SLOWMODE) {
        CpuNotify &= ~CPUNOTIFY_SLOWMODE;
    } else {
        CpuNotify |= CPUNOTIFY_SLOWMODE;
    }

    LocalCpuContext.CpuNotify = CpuNotify;
    ContextDirty = TRUE;

    if (CpuDbgSetRemoteContext()) {
        DEBUGGERPRINT("EIP logging ");
        if (CpuNotify & CPUNOTIFY_SLOWMODE) {
           DEBUGGERPRINT("ON - use !last to see the EIP log.\n");
        } else {
           DEBUGGERPRINT("OFF.\n");
        }
    }
}

DECLARE_EXTAPI(last)
{
    ULONG CpuNotify;
    DWORD64 n;
    char *pchCmd;
    DWORD64 EipOffset, i;

    INIT_EXTAPI;

    if (!CpuDbgGetRemoteContext(CPUGETDATA(Process, Thread))) {
        return;
    }

    // Parse out the optional number of instructions.  Default is all
    // instructions in the log
    n = 0xffffffff;
    pchCmd = ArgumentString;
    while (*pchCmd && isspace(*pchCmd)) {
         pchCmd++;
    }

    if (*pchCmd) {
        NTSTATUS Status;

        Status = TryGetExpr(pchCmd, &n);
        if (!NT_SUCCESS(Status) || !n) {
             DEBUGGERPRINT("Invalid Length: '%s' Status %x\n",
                     pchCmd,
                     Status
                     );
             return;
        }
    }

    CpuNotify = LocalCpuContext.CpuNotify;
    if (!(CpuNotify & CPUNOTIFY_SLOWMODE)) {
        DEBUGGERPRINT("Warning: logeip is not enabled.  Log may be out-of-date.\n");
    }

    EipOffset = LocalCpuContext.eipLogIndex;
    if (n >= EIPLOGSIZE) {
        n = EIPLOGSIZE;
    } else {
        EipOffset -= n;
    }

    for (i = 0; i<n; ++i, ++EipOffset) {
        EipOffset %= EIPLOGSIZE;
        if (LocalCpuContext.eipLog[EipOffset] == 0) {
            break;
        }
        DEBUGGERPRINT("%x %x\n", i, LocalCpuContext.eipLog[EipOffset]);
    }
}


DECLARE_EXTAPI(callstack)
/*++

Routine Description:

    This routine dumps out the callstack for the thread.

Arguments:

    none
    
Return Value:

    None.

--*/
{
    ULONG i;

    INIT_EXTAPI;
 
    //
    // fetch the CpuContext for the current thread
    //
    if (!CpuDbgGetRemoteContext(CPUGETDATA(Process, Thread))) {
        return;
    }

    //
    // Dump out the call stack
    //
    DEBUGGERPRINT("        CallStackTimeStamp : %08lx\n", LocalCpuContext.CSTimestamp);
    DEBUGGERPRINT("            CallStackIndex : %08lx\n", LocalCpuContext.CSIndex);
    DEBUGGERPRINT("        -----------------------------\n");
    DEBUGGERPRINT("                     Intel : Native\n");
    
    for (i = 0; i < CSSIZE; i++) {
        DEBUGGERPRINT(
            "                  %08lx : %08lx\n", 
            LocalCpuContext.callStack[i].intelAddr,
            LocalCpuContext.callStack[i].nativeAddr
            );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\decoder\bytefns.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    bytefns.h

Abstract:
    
    Prototypes for instructions which operate on BYTES.

Author:

    06-Jun-1995 BarryBo, Created

Revision History:

--*/

#ifndef BYTEFNS_H
#define BYTEFNS_H

#define DISPATCHCOMMON(x) DISPATCH(x ## 8)
#include "common.h"
#undef DISPATCHCOMMON

#endif //BYTEFNS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\decoder\bytefns.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    bytefns.c

Abstract:
    
    Instuctions which operate on BYTES

Author:

    29-Jun-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "cpuassrt.h"
#include "threadst.h"
#include "instr.h"
#include "decoderp.h"
#include "bytefns.h"

ASSERTNAME;

// set up to include common functions
#define MSB                 0x80
#define MANGLENAME(x)       x ## 8
#define MOD_RM              mod_rm_reg8
#define UTYPE		    unsigned char
#define STYPE		    signed char
#define GET_VAL 	    GET_BYTE
#define PUT_VAL             PUT_BYTE
#define OPNAME(x)           OP_ ## x ## 8
#define LOCKOPNAME(x)       OP_SynchLock ## x ## 8
#define DISPATCHCOMMON(fn)  DISPATCH(fn ## 8)
#define CALLFRAGCOMMON0(fn)            CALLFRAG0( fn ## 8 )
#define CALLFRAGCOMMON1(fn, pop1)      CALLFRAG1( fn ## 8 , pop1)
#define CALLFRAGCOMMON2(fn, pop1, op2) CALLFRAG2( fn ## 8 , pop1, op2)
#define AREG                GP_AL
#define BREG                GP_BL
#define CREG                GP_CL
#define DREG                GP_DL
#define DEREF(Op)           DEREF8(Op)

// include the common functions
#include "common.c"

// create the mod_rm_reg8() decoder function
#define MOD11_RM000         GP_AL
#define MOD11_RM001         GP_CL
#define MOD11_RM010         GP_DL
#define MOD11_RM011         GP_BL
#define MOD11_RM100         GP_AH
#define MOD11_RM101         GP_CH
#define MOD11_RM110         GP_DH
#define MOD11_RM111         GP_BH
#define REG000              GP_AL
#define REG001              GP_CL
#define REG010              GP_DL
#define REG011              GP_BL
#define REG100              GP_AH
#define REG101              GP_CH
#define REG110              GP_DH
#define REG111              GP_BH
#define MOD_RM_DECODER      mod_rm_reg8
#include "modrm.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\decoder\common.c ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    common.c

Abstract:
    
    Instructions with common (shared) BYTE, WORD, and DWORD flavors.

Author:

    29-Jun-1995 BarryBo

Revision History:

--*/

// THIS FILE IS #include'd INTO FILES WHICH DEFINE THE FOLLOWING MACROS:
// GET_REG  - function returning pointer to register
// MSB      - most signigicant bit
// MOD_RM   - decode mod/rm bits
// UTYPE    - UNSIGNED type which defines registers (BYTE/USHORT/DWORD)
// STYPE    -   SIGNED type which defines registers (char/short/long)
// GET_VAL  - dereference a pointer of the right type (GET_BYTE/...)
// PUT_VAL  - writes a value into memory
// DISPATCHCOMMON - mangles function name by appening 8/16/32
// AREG     - GP_AL/GP_AX/GP_EAX, etc.
// BREG     - ...
// CREG     - ...
// DREG     - ...

OPERATION MANGLENAME(Group1Map)[8] = {OPNAME(Add),
                                      OPNAME(Or),
                                      OPNAME(Adc),
                                      OPNAME(Sbb),
                                      OPNAME(And),
                                      OPNAME(Sub),
                                      OPNAME(Xor),
                                      OPNAME(Cmp)};

OPERATION MANGLENAME(Group1LockMap)[8] = {LOCKOPNAME(Add),
                                          LOCKOPNAME(Or),
                                          LOCKOPNAME(Adc),
                                          LOCKOPNAME(Sbb),
                                          LOCKOPNAME(And),
                                          LOCKOPNAME(Sub),
                                          LOCKOPNAME(Xor),
                                          OPNAME(Cmp)};

// A macro to generate _m_r functions
#define DC_M_R(x, y)                                    \
    DISPATCHCOMMON(x ## _m_r)                           \
    {                                                   \
        int cbInstr = MOD_RM(State, &Instr->Operand1, &Instr->Operand2);   \
                                                        \
        Instr->Operation = y;                           \
        DEREF(Instr->Operand2);                         \
        Instr->Size = cbInstr+1;                        \
    }                                                   

// A macro to generate _r_m functions
#define DC_R_M(x, y)                                    \
    DISPATCHCOMMON(x ## _r_m)                           \
    {                                                   \
        int cbInstr = MOD_RM(State, &Instr->Operand2, &Instr->Operand1);   \
                                                        \
        Instr->Operation = y;                           \
        DEREF(Instr->Operand2);                         \
        Instr->Size = cbInstr+1;                        \
    }

// A macro to generate _a_i functions
#define DC_A_I(x, y)                                    \
    DISPATCHCOMMON(x ## _a_i)                           \
    {                                                   \
        Instr->Operation = y;                           \
        Instr->Operand1.Type = OPND_REGREF;             \
        Instr->Operand1.Reg = AREG;                     \
        Instr->Operand2.Type = OPND_IMM;                \
        Instr->Operand2.Immed = GET_VAL(eipTemp+1);     \
        Instr->Size = 1+sizeof(UTYPE);                  \
    }

// The monster macro which generates all three
#define DC_ALL(x, y)                                    \
    DC_M_R(x,y)                                         \
    DC_R_M(x,y)                                         \
    DC_A_I(x,y)                                         

// SETSIZE sets the size of a jump instruction
#if MSB==0x80
#define SETSIZE     Instr->Size = 1+sizeof(UTYPE); // 1 byte opcode    
#else                                                 
#define SETSIZE     Instr->Size = 2+sizeof(UTYPE); // 2 byte opcode   
#endif                                                    

#if DBG
#define CLEAR_ADRPREFIX         State->AdrPrefix = FALSE;
#else
#define CLEAR_ADRPREFIX
#endif

// This macro generates jump functions
// If the ADR: prefix is set, get the 16-bit loword from the 32-bit
// immediate value following the JMP instruction, and add that value
// to the loword of EIP, and use that value as the new IP register.
#define DISPATCHJUMP(x)                                 \
DISPATCHCOMMON(j ## x)                                  \
{                                                       \
    Instr->Operand1.Type = OPND_NOCODEGEN;              \
    if (State->AdrPrefix) {                             \
        Instr->Operand1.Immed = MAKELONG((short)GET_SHORT(eipTemp+1)+1+sizeof(UTYPE)+(short)LOWORD(eipTemp), HIWORD(eipTemp)); \
        CLEAR_ADRPREFIX;                                \
    } else {                                            \
        Instr->Operand1.Immed = (STYPE)GET_VAL(eipTemp+1)+1+sizeof(UTYPE)+eipTemp; \
    }                                                   \
    if (Instr->Operand1.Immed > eipTemp) {              \
        Instr->Operation = OP_CTRL_COND_J ## x ## Fwd;  \
    } else {                                            \
        Instr->Operation = OP_CTRL_COND_J ## x ##;      \
    }                                                   \
    SETSIZE                                             \
}


DC_ALL(LOCKadd, LOCKOPNAME(Add))
DC_ALL(LOCKor,  LOCKOPNAME(Or))
DC_ALL(LOCKadc, LOCKOPNAME(Adc))
DC_ALL(LOCKsbb, LOCKOPNAME(Sbb))
DC_ALL(LOCKand, LOCKOPNAME(And))
DC_ALL(LOCKsub, LOCKOPNAME(Sub))
DC_ALL(LOCKxor, LOCKOPNAME(Xor))

DC_ALL(add, OPNAME(Add))
DC_ALL(or,  OPNAME(Or))
DC_ALL(adc, OPNAME(Adc))
DC_ALL(sbb, OPNAME(Sbb))
DC_ALL(and, OPNAME(And))
DC_ALL(sub, OPNAME(Sub))
DC_ALL(xor, OPNAME(Xor))

DISPATCHCOMMON(cmp_m_r)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, &Instr->Operand2);

    Instr->Operation = OPNAME(Cmp);
    DEREF(Instr->Operand1);     // both params are byval
    DEREF(Instr->Operand2);
    Instr->Size = cbInstr+1;
}
DISPATCHCOMMON(cmp_r_m)
{
    int cbInstr = MOD_RM(State, &Instr->Operand2, &Instr->Operand1);

    Instr->Operation = OPNAME(Cmp);
    DEREF(Instr->Operand1);     // both params are byval
    DEREF(Instr->Operand2);
    Instr->Size = cbInstr+1;
}
DISPATCHCOMMON(cmp_a_i)
{
    Instr->Operation = OPNAME(Cmp);
    Instr->Operand1.Type = OPND_REGVALUE;   // both params are byval
    Instr->Operand1.Reg = AREG;
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = GET_VAL(eipTemp+1);
    Instr->Size = 1+sizeof(UTYPE);
}

DISPATCHCOMMON(GROUP_1)
{
    int  cbInstr = MOD_RM(State, &Instr->Operand1, NULL);
    BYTE g   = GET_BYTE(eipTemp+1);

    // <instruction> modrm, imm
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = GET_VAL(eipTemp+1+cbInstr); // get immB
    g = (g >> 3) & 0x07;
    Instr->Operation = MANGLENAME(Group1Map)[g];
    if (g == 7) {
        // Cmp takes both params as byval
        DEREF(Instr->Operand1);
    }

    Instr->Size = cbInstr+sizeof(UTYPE)+1;
}
DISPATCHCOMMON(LOCKGROUP_1)
{
    int  cbInstr = MOD_RM(State, &Instr->Operand1, NULL);
    BYTE g   = GET_BYTE(eipTemp+1);

    // <instruction> modrm, imm
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = GET_VAL(eipTemp+1+cbInstr); // get immB
    g = (g >> 3) & 0x07;
    Instr->Operation = MANGLENAME(Group1LockMap)[g];
    if (g == 7) {
        // Cmp takes both args as byval
        DEREF(Instr->Operand1);
    }

    Instr->Size = cbInstr+sizeof(UTYPE)+1;
}

DISPATCHCOMMON(test_r_m)
{
    int cbInstr = MOD_RM(State, &Instr->Operand2, &Instr->Operand1);

    Instr->Operation = OPNAME(Test);
    DEREF(Instr->Operand1);     // both args are byval
    DEREF(Instr->Operand2);
    Instr->Size = cbInstr+1;
}

DISPATCHCOMMON(xchg_r_m)
{
    int cbInstr = MOD_RM(State, &Instr->Operand2, &Instr->Operand1);

    // Operand2 is always a register.  If operand1 is a memory location,
    // we must use the locked version, otherwise use the regular version.
    if (Instr->Operand1.Type == OPND_REGREF){
        Instr->Operation = OPNAME(Xchg);
    } else {
        Instr->Operation = LOCKOPNAME(Xchg);
    }
    Instr->Size = cbInstr+1;
}

DISPATCHCOMMON(xadd_m_r)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, &Instr->Operand2);

    Instr->Operation = OPNAME(Xadd);
    Instr->Size = cbInstr+2;
}

DISPATCHCOMMON(cmpxchg_m_r)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, &Instr->Operand2);

    Instr->Operation = OPNAME(CmpXchg);
    Instr->Size = cbInstr+2;
}

DISPATCHCOMMON(LOCKxadd_m_r)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, &Instr->Operand2);

    Instr->Operation = LOCKOPNAME(Xadd);
    Instr->Size = cbInstr+2;
}

DISPATCHCOMMON(LOCKcmpxchg_m_r)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, &Instr->Operand2);

    Instr->Operation = LOCKOPNAME(CmpXchg);
    Instr->Size = cbInstr+2;
}

DC_M_R(mov, OPNAME(Mov))
DC_R_M(mov, OPNAME(Mov))

DISPATCHCOMMON(mov_a_m)     // mov accum, [full displacement]
{
    Instr->Operation = OPNAME(Mov);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = AREG;
    Instr->Operand2.Type = OPND_ADDRREF;
    DEREF(Instr->Operand2); // this is a klunky ADDRVAL8/16/32 expansion
    if (State->AdrPrefix) {
        Instr->Operand2.Immed = GET_SHORT(eipTemp+1);
        Instr->Size = 3;
#if DBG
        State->AdrPrefix = FALSE;
#endif
    } else {
        Instr->Operand2.Immed = GET_LONG(eipTemp+1);
        Instr->Size = 5;
    }
}
DISPATCHCOMMON(mov_m_a)     // mov [full displacement], accum
{
    Instr->Operation = OPNAME(Mov);
    Instr->Operand1.Type = OPND_ADDRREF;
    Instr->Operand2.Type = OPND_REGVALUE;
    Instr->Operand2.Reg = AREG;
    if (State->AdrPrefix) {
        Instr->Operand1.Immed = GET_SHORT(eipTemp+1);
        Instr->Size = 3;
#if DBG
        State->AdrPrefix = FALSE;
#endif
    } else {
        Instr->Operand1.Immed = GET_LONG(eipTemp+1);
        Instr->Size = 5;
    }
}

DISPATCHCOMMON(test_a_i)
{
    Instr->Operation = OPNAME(Test);
    Instr->Operand1.Type = OPND_REGVALUE;
    Instr->Operand1.Reg = AREG;
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = GET_VAL(eipTemp+1);
    Instr->Size = 1+sizeof(UTYPE);
}

DISPATCHCOMMON(mov_a_i)
{
    Instr->Operation = OPNAME(Mov);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = AREG;
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = GET_VAL(eipTemp+1);
    Instr->Size = sizeof(UTYPE)+1;
}
DISPATCHCOMMON(mov_b_i)
{
    Instr->Operation = OPNAME(Mov);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = BREG;
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = GET_VAL(eipTemp+1);
    Instr->Size = sizeof(UTYPE)+1;
}
DISPATCHCOMMON(mov_c_i)
{
    Instr->Operation = OPNAME(Mov);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = CREG;
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = GET_VAL(eipTemp+1);
    Instr->Size = sizeof(UTYPE)+1;
}
DISPATCHCOMMON(mov_d_i)
{
    Instr->Operation = OPNAME(Mov);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = DREG;
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = GET_VAL(eipTemp+1);
    Instr->Size = sizeof(UTYPE)+1;
}
DISPATCHCOMMON(GROUP_2)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, NULL);
    BYTE g = GET_BYTE(eipTemp+1);

    // <instruction> modrm, imm
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = GET_VAL(eipTemp+1+cbInstr) & 0x1f;

    switch ((g >> 3) & 0x07) {
    case 0: // rol
        if (Instr->Operand2.Immed)
            Instr->Operation = OPNAME(Rol);
        else
            Instr->Operation = OP_Nop;
        break;
    case 1: // ror
        if (Instr->Operand2.Immed)
            Instr->Operation = OPNAME(Ror);
        else
            Instr->Operation = OP_Nop;
        break;
    case 2: // rcl
        Instr->Operation = OPNAME(Rcl);
        break;
    case 3: // rcr
        Instr->Operation = OPNAME(Rcr);
        break;
    case 4: // shl
        Instr->Operation = OPNAME(Shl);
        break;
    case 5: // shr
        Instr->Operation = OPNAME(Shr);
        break;
    case 7: // sar
        Instr->Operation = OPNAME(Sar);
        break;
    case 6: // <bad>
        BAD_INSTR;
        break;
    }
    Instr->Size = 2+cbInstr;
}

DISPATCHCOMMON(mov_m_i)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, NULL);

    Instr->Operation = OPNAME(Mov);
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = GET_VAL(eipTemp+cbInstr+1);
    Instr->Size = cbInstr+sizeof(UTYPE)+1;
}
DISPATCHCOMMON(GROUP_2_1)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, NULL);
    BYTE g = GET_BYTE(eipTemp+1);

    // <instruction> modrm, 1
    switch ((g >> 3) & 0x07) {
    case 0: // rol
        Instr->Operation = OPNAME(Rol1);
        break;
    case 1: // ror
        Instr->Operation = OPNAME(Ror1);
        break;
    case 2: // rcl
        Instr->Operation = OPNAME(Rcl1);
        break;
    case 3: // rcr
        Instr->Operation = OPNAME(Rcr1);
        break;
    case 4: // shl
        Instr->Operation = OPNAME(Shl1);
        break;
    case 5: // shr
        Instr->Operation = OPNAME(Shr1);
        break;
    case 7: // sar
        Instr->Operation = OPNAME(Sar1);
    break;
    case 6: // <bad>
        BAD_INSTR;
        break;
    }

    Instr->Size = cbInstr+1;
}
DISPATCHCOMMON(GROUP_2_CL)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, NULL);
    BYTE g = GET_BYTE(eipTemp+1);

    Instr->Operand2.Type = OPND_REGVALUE;
    Instr->Operand2.Reg = GP_CL;   //UNDONE: the fragments must mask by 31

    // <instruction> modrm, imm
    switch ((g >> 3) & 0x07) {
    case 0: // rol
        Instr->Operation = OPNAME(Rol);
        break;
    case 1: // ror
        Instr->Operation = OPNAME(Ror);
        break;
    case 2: // rcl
        Instr->Operation = OPNAME(Rcl);
        break;
    case 3: // rcr
        Instr->Operation = OPNAME(Rcr);
        break;
    case 4: // shl
        Instr->Operation = OPNAME(Shl);
        break;
    case 5: // shr
        Instr->Operation = OPNAME(Shr);
        break;
    case 7: // sar
        Instr->Operation = OPNAME(Sar);
        break;
    case 6: // <bad>
        BAD_INSTR;
        break;
    }
    Instr->Size = 1+cbInstr;
}
DISPATCHCOMMON(GROUP_3)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, NULL);
    BYTE g = GET_BYTE(eipTemp+1);

    switch ((g >> 3) & 0x07) {
    case 1: // bad
        BAD_INSTR;
        break;
    case 0: // test modrm, imm
        Instr->Operation = OPNAME(Test);
        DEREF(Instr->Operand1);     // both args are byval
        Instr->Operand2.Type = OPND_IMM;
        Instr->Operand2.Immed = GET_VAL(eipTemp+1+cbInstr);
        cbInstr += sizeof(UTYPE);   // account for the imm size
        break;
    case 2: // not, modrm
        Instr->Operation = OPNAME(Not);
        break;
    case 3: // neg, modrm
        Instr->Operation = OPNAME(Neg);
        break;
    case 4: // mul al, modrm
        Instr->Operation = OPNAME(Mul);
        break; 
    case 5: // imul al, modrm
        Instr->Operation = OPNAME(Muli);
        break; 
    case 6: // div al, modrm
        Instr->Operation = OPNAME(Div);
        break; 
    case 7: // idiv al, modrm
        Instr->Operation = OPNAME(Idiv);
        break; 
    }
    Instr->Size = cbInstr+1;
}
DISPATCHCOMMON(LOCKGROUP_3)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, NULL);
    BYTE g = GET_BYTE(eipTemp+1);

    switch ((g >> 3) & 0x07) {
    case 0:
    case 1: // bad
        BAD_INSTR;
        break;
    case 2: // not, modrm
        Instr->Operation = LOCKOPNAME(Not);
        break;
    case 3: // neg, modrm
        Instr->Operation = LOCKOPNAME(Neg);
        break;
    default:
        BAD_INSTR;
        break;
    }
    Instr->Size = cbInstr+1;
}
DISPATCHCOMMON(lods)
{
    if (Instr->FsOverride) {
        if (State->RepPrefix) {
            Instr->Operation = OPNAME(FsRepLods);
        } else {
            Instr->Operation = OPNAME(FsLods);
        }
    } else {
        if (State->RepPrefix) {
            Instr->Operation = OPNAME(RepLods);
        } else {
            Instr->Operation = OPNAME(Lods);
        }
    }
}
DISPATCHCOMMON(scas)
{
    OPERATION ScasMap[6] = {OPNAME(Scas),
                            OPNAME(RepzScas),
                            OPNAME(RepnzScas),
                            OPNAME(FsScas),
                            OPNAME(FsRepzScas),
                            OPNAME(FsRepnzScas)
                            };

    Instr->Operation = ScasMap[State->RepPrefix + 3*Instr->FsOverride];
}
DISPATCHCOMMON(stos)
{
    if (State->RepPrefix) {
        Instr->Operation = OPNAME(RepStos);
    } else {
        Instr->Operation = OPNAME(Stos);
    }
}
DISPATCHCOMMON(movs)
{
    if (Instr->FsOverride) {
        if (State->RepPrefix) {
            Instr->Operation = OPNAME(FsRepMovs);
        } else {
            Instr->Operation = OPNAME(FsMovs);
        }
    } else {
        if (State->RepPrefix) {
            Instr->Operation = OPNAME(RepMovs);
        } else {
            Instr->Operation = OPNAME(Movs);
        }
    }
}
DISPATCHCOMMON(cmps)
{
    OPERATION CmpsMap[6] = {OPNAME(Cmps),
                            OPNAME(RepzCmps),
                            OPNAME(RepnzCmps),
                            OPNAME(FsCmps),
                            OPNAME(FsRepzCmps),
                            OPNAME(FsRepnzCmps)
                            };

    Instr->Operation = CmpsMap[State->RepPrefix + 3*Instr->FsOverride];
}

// Now the jump instructions:
DISPATCHJUMP(o)
DISPATCHJUMP(no)
DISPATCHJUMP(b)
DISPATCHJUMP(ae)
DISPATCHJUMP(e)
DISPATCHJUMP(ne)
DISPATCHJUMP(be)
DISPATCHJUMP(a)
DISPATCHJUMP(s)
DISPATCHJUMP(ns)
DISPATCHJUMP(p)
DISPATCHJUMP(np)
DISPATCHJUMP(l)
DISPATCHJUMP(nl)
DISPATCHJUMP(le)
DISPATCHJUMP(g)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\decoder\comm1632.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    comm1632.c

Abstract:
    
    Instructions with common (shared) WORD, and DWORD flavors (but not BYTE).

Author:

    29-Jun-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "wx86.h"
#include "config.h"
#include "threadst.h"
#include "instr.h"
#include "decoderp.h"
#include "comm1632.h"

extern OPERATION MANGLENAME(Group1Map)[];

// ---------------- single-byte functions -------------------------------
DISPATCHCOMMON(dispatch2)
{
    eipTemp++;
#if MSB==0x8000
    ((pfnDispatchInstruction)(Dispatch216[GET_BYTE(eipTemp)]))(State, Instr);
#else
    ((pfnDispatchInstruction)(Dispatch232[GET_BYTE(eipTemp)]))(State, Instr);
#endif
}
DISPATCHCOMMON(LOCKdispatch2)
{
    eipTemp++;
#if MSB==0x8000
    ((pfnDispatchInstruction)(LockDispatch216[GET_BYTE(eipTemp)]))(State, Instr);
#else
    ((pfnDispatchInstruction)(LockDispatch232[GET_BYTE(eipTemp)]))(State, Instr);
#endif
}
DISPATCHCOMMON(pushf)
{
    Instr->Operation = OPNAME(Pushf);
}
DISPATCHCOMMON(popf)
{
    Instr->Operation = OPNAME(Popf);
}
DISPATCHCOMMON(pusha)
{
    Instr->Operation = OPNAME(PushA);
}
DISPATCHCOMMON(popa)
{
    Instr->Operation = OPNAME(PopA);
}
DISPATCHCOMMON(push_iw)
{
    Instr->Operation = OPNAME(Push);
    Instr->Operand1.Type = OPND_IMM;
    Instr->Operand1.Immed = GET_VAL(eipTemp+1);
    Instr->Size = 1+sizeof(UTYPE);
}
DISPATCHCOMMON(push_ibs)
{
    Instr->Operation = OPNAME(Push);
    Instr->Operand1.Type = OPND_IMM;
    Instr->Operand1.Immed = (UTYPE)(STYPE)(char)GET_BYTE(eipTemp+1);
    Instr->Size = 2;
}
DISPATCHCOMMON(GROUP_1WS)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, NULL);
    BYTE g = GET_BYTE(eipTemp+1);

    g = (g >> 3) & 0x07;
    Instr->Operation = MANGLENAME(Group1Map)[g];
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = (UTYPE)(STYPE)(char)GET_BYTE(eipTemp + cbInstr + 1);
    if (g == 7) {
        // Cmp takes both params as byval
        DEREF(Instr->Operand1);
    }
    Instr->Size = cbInstr+2;
}
DISPATCHCOMMON(LOCKGROUP_1WS)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, NULL);
    BYTE g = GET_BYTE(eipTemp+1);

    g = (g >> 3) & 0x07;
    Instr->Operation = MANGLENAME(Group1LockMap)[g];
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = (UTYPE)(STYPE)(char)GET_BYTE(eipTemp + cbInstr + 1);
    if (g == 7) {
        // Cmp takes both params as byval
        DEREF(Instr->Operand1);
    }
    Instr->Size = cbInstr+2;
}
DISPATCHCOMMON(mov_rw_mw)
{
    int cbInstr = MOD_RM(State, &Instr->Operand2, &Instr->Operand1);

    Instr->Operation = OPNAME(Mov);
    DEREF(Instr->Operand2);
    Instr->Size = cbInstr+1;
}
DISPATCHCOMMON(lea_rw_mw)
{
    int cbInstr = MOD_RM(State, &Instr->Operand2, &Instr->Operand1);

    Instr->Operation = OPNAME(Mov);
    Instr->Size = cbInstr+1;
}
DISPATCHCOMMON(pop_mw)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, NULL);

    Instr->Operation = OPNAME(Pop);
    Instr->Size = 1+cbInstr;
}
DISPATCHCOMMON(xchg_ax_cx)
{
    Instr->Operation = OPNAME(Xchg);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = AREG;
    Instr->Operand2.Type = OPND_REGREF;
    Instr->Operand2.Reg = CREG;
}
DISPATCHCOMMON(xchg_ax_dx)
{
    Instr->Operation = OPNAME(Xchg);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = AREG;
    Instr->Operand2.Type = OPND_REGREF;
    Instr->Operand2.Reg = DREG;
}
DISPATCHCOMMON(xchg_ax_bx)
{
    Instr->Operation = OPNAME(Xchg);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = AREG;
    Instr->Operand2.Type = OPND_REGREF;
    Instr->Operand2.Reg = BREG;
}
DISPATCHCOMMON(xchg_ax_sp)
{
    Instr->Operation = OPNAME(Xchg);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = AREG;
    Instr->Operand2.Type = OPND_REGREF;
    Instr->Operand2.Reg = SPREG;
}
DISPATCHCOMMON(xchg_ax_bp)
{
    Instr->Operation = OPNAME(Xchg);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = AREG;
    Instr->Operand2.Type = OPND_REGREF;
    Instr->Operand2.Reg = BPREG;
}
DISPATCHCOMMON(xchg_ax_si)
{
    Instr->Operation = OPNAME(Xchg);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = AREG;
    Instr->Operand2.Type = OPND_REGREF;
    Instr->Operand2.Reg = SIREG;
}
DISPATCHCOMMON(xchg_ax_di)
{
    Instr->Operation = OPNAME(Xchg);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = AREG;
    Instr->Operand2.Type = OPND_REGREF;
    Instr->Operand2.Reg = DIREG;
}
DISPATCHCOMMON(cbw)
{
    Instr->Operation = OPNAME(Cbw);
}
DISPATCHCOMMON(cwd)
{
    Instr->Operation = OPNAME(Cwd);
}
DISPATCHCOMMON(mov_sp_iw)
{
    Instr->Operation = OPNAME(Mov);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = SPREG;
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = GET_VAL(eipTemp+1);
    Instr->Size = 1+sizeof(UTYPE);
}
DISPATCHCOMMON(mov_bp_iw)
{
    Instr->Operation = OPNAME(Mov);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = BPREG;
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = GET_VAL(eipTemp+1);
    Instr->Size = 1+sizeof(UTYPE);
}
DISPATCHCOMMON(mov_si_iw)
{
    Instr->Operation = OPNAME(Mov);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = SIREG;
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = GET_VAL(eipTemp+1);
    Instr->Size = 1+sizeof(UTYPE);
}
DISPATCHCOMMON(mov_di_iw)
{
    Instr->Operation = OPNAME(Mov);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = DIREG;
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = GET_VAL(eipTemp+1);
    Instr->Size = 1+sizeof(UTYPE);
}
DISPATCHCOMMON(loopne_b)
{
    Instr->Operand1.Type = OPND_NOCODEGEN;
    Instr->Operand1.Immed = (CHAR)GET_BYTE(eipTemp+1)+2+eipTemp;
    if (Instr->Operand1.Immed > eipTemp) {
        Instr->Operation = OPNAME(CTRL_COND_Loopne_bFwd);
    } else {
        Instr->Operation = OPNAME(CTRL_COND_Loopne_b);
    }
    Instr->Size = 2;
}
DISPATCHCOMMON(loope_b)
{
    Instr->Operand1.Type = OPND_NOCODEGEN;
    Instr->Operand1.Immed = (CHAR)GET_BYTE(eipTemp+1)+2+eipTemp;
    if (Instr->Operand1.Immed > eipTemp) {
        Instr->Operation = OPNAME(CTRL_COND_Loope_bFwd);
    } else {
        Instr->Operation = OPNAME(CTRL_COND_Loope_b);
    }
    Instr->Size = 2;
}
DISPATCHCOMMON(loop_b)
{
    Instr->Operand1.Type = OPND_NOCODEGEN;
    Instr->Operand1.Immed = (CHAR)GET_BYTE(eipTemp+1)+2+eipTemp;
    if (Instr->Operand1.Immed > eipTemp) {
        Instr->Operation = OPNAME(CTRL_COND_Loop_bFwd);
    } else {
        Instr->Operation = OPNAME(CTRL_COND_Loop_b);
    }
    Instr->Size = 2;
}
DISPATCHCOMMON(jcxz_b)
{
    Instr->Operand1.Type = OPND_NOCODEGEN;
    if (State->AdrPrefix) {
        // "ADR: jecxz" is the same as "DATA: jecxz"... which is "jcxz"
        Instr->Operand1.Immed = MAKELONG((char)GET_BYTE(eipTemp+1)+2+(short)LOWORD(eipTemp), HIWORD(eipTemp));
        if (Instr->Operand1.Immed > eipTemp) {
            Instr->Operation = OP_CTRL_COND_Jcxz_bFwd16;
        } else {
            Instr->Operation = OP_CTRL_COND_Jcxz_b16;
        }
#if DBG
        State->AdrPrefix = FALSE;
#endif
    } else {
        Instr->Operand1.Immed = (CHAR)GET_BYTE(eipTemp+1)+2+eipTemp;
        if (Instr->Operand1.Immed > eipTemp) {
            Instr->Operation = OPNAME(CTRL_COND_Jcxz_bFwd);
        } else {
            Instr->Operation = OPNAME(CTRL_COND_Jcxz_b);
        }
    }
    Instr->Size = 2;
}
DISPATCHCOMMON(GROUP_5)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, NULL);
    BYTE g = GET_BYTE(eipTemp+1);

    switch ((g >> 3) & 0x07) {
    case 0: // inc modrmW
        Instr->Operation = OPNAME(Inc);
        break;
    case 1: // dec modrmW
        Instr->Operation = OPNAME(Dec);
        break;
    case 2: // call indirmodrmW
        DEREF(Instr->Operand1);
        Instr->Operand2.Type = OPND_IMM;
        Instr->Operand2.Immed = eipTemp + cbInstr + 1;
        Instr->Operation = OP_CTRL_INDIR_Call;
        break;
    case 3: // call indirFARmodrmW
        Instr->Operand2.Type = OPND_IMM;
        Instr->Operand2.Immed = eipTemp + cbInstr + 1;
        Instr->Operation = OP_CTRL_INDIR_Callf;
        break;
    case 4: // jmp  indirmodrmW
        DEREF(Instr->Operand1);
        Instr->Operation = OP_CTRL_INDIR_Jmp;
        break;
    case 5: // jmp  indirFARmodrmW
        Instr->Operation = OP_CTRL_INDIR_Jmpf;
        break;
    case 6: // push modrmW
        DEREF(Instr->Operand1);
        Instr->Operation = OPNAME(Push);
        break;
    case 7: // bad
        BAD_INSTR;
        break;
    }

    Instr->Size = cbInstr+1;
}
DISPATCHCOMMON(LOCKGROUP_5)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, NULL);
    BYTE g = GET_BYTE(eipTemp+1);

    switch ((g >> 3) & 0x07) {
    case 0: // inc modrmW
        Instr->Operation = LOCKOPNAME(Inc);
        break;
    case 1: // dec modrmW
        Instr->Operation = LOCKOPNAME(Dec);
        break;
    default:
        BAD_INSTR;
        break;
    }

    Instr->Size = cbInstr+1;
}
DISPATCHCOMMON(inc_ax)
{
    Instr->Operation = OPNAME(Inc);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = AREG;
}
DISPATCHCOMMON(inc_cx)
{
    Instr->Operation = OPNAME(Inc);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = CREG;
}
DISPATCHCOMMON(inc_dx)
{
    Instr->Operation = OPNAME(Inc);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = DREG;
}
DISPATCHCOMMON(inc_bx)
{
    Instr->Operation = OPNAME(Inc);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = BREG;
}
DISPATCHCOMMON(inc_sp)
{
    Instr->Operation = OPNAME(Inc);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = SPREG;
}
DISPATCHCOMMON(inc_bp)
{
    Instr->Operation = OPNAME(Inc);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = BPREG;
}
DISPATCHCOMMON(inc_si)
{
    Instr->Operation = OPNAME(Inc);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = SIREG;
}
DISPATCHCOMMON(inc_di)
{
    Instr->Operation = OPNAME(Inc);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = DIREG;
}
DISPATCHCOMMON(dec_ax)
{
    Instr->Operation = OPNAME(Dec);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = AREG;
}
DISPATCHCOMMON(dec_cx)
{
    Instr->Operation = OPNAME(Dec);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = CREG;
}
DISPATCHCOMMON(dec_dx)
{
    Instr->Operation = OPNAME(Dec);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = DREG;
}
DISPATCHCOMMON(dec_bx)
{
    Instr->Operation = OPNAME(Dec);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = BREG;
}
DISPATCHCOMMON(dec_sp)
{
    Instr->Operation = OPNAME(Dec);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = SPREG;
}
DISPATCHCOMMON(dec_bp)
{
    Instr->Operation = OPNAME(Dec);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = BPREG;
}
DISPATCHCOMMON(dec_si)
{
    Instr->Operation = OPNAME(Dec);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = SIREG;
}
DISPATCHCOMMON(dec_di)
{
    Instr->Operation = OPNAME(Dec);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = DIREG;
}
DISPATCHCOMMON(push_ax)
{
    Instr->Operation = OPNAME(Push);
    Instr->Operand1.Type = OPND_REGVALUE;
    Instr->Operand1.Reg = AREG;
}
DISPATCHCOMMON(push_cx)
{
    Instr->Operation = OPNAME(Push);
    Instr->Operand1.Type = OPND_REGVALUE;
    Instr->Operand1.Reg = CREG;
}
DISPATCHCOMMON(push_dx)
{
    Instr->Operation = OPNAME(Push);
    Instr->Operand1.Type = OPND_REGVALUE;
    Instr->Operand1.Reg = DREG;
}
DISPATCHCOMMON(push_bx)
{
    Instr->Operation = OPNAME(Push);
    Instr->Operand1.Type = OPND_REGVALUE;
    Instr->Operand1.Reg = BREG;
}
DISPATCHCOMMON(push_sp)
{
    Instr->Operation = OPNAME(Push);
    Instr->Operand1.Type = OPND_REGVALUE;
    Instr->Operand1.Reg = SPREG;
}
DISPATCHCOMMON(push_bp)
{
    Instr->Operation = OPNAME(Push);
    Instr->Operand1.Type = OPND_REGVALUE;
    Instr->Operand1.Reg = BPREG;
}
DISPATCHCOMMON(push_si)
{
    Instr->Operation = OPNAME(Push);
    Instr->Operand1.Type = OPND_REGVALUE;
    Instr->Operand1.Reg = SIREG;
}
DISPATCHCOMMON(push_di)
{
    Instr->Operation = OPNAME(Push);
    Instr->Operand1.Type = OPND_REGVALUE;
    Instr->Operand1.Reg = DIREG;
}
DISPATCHCOMMON(pop_ax)
{
    Instr->Operation = OPNAME(Pop);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = AREG;
}
DISPATCHCOMMON(pop_cx)
{
    Instr->Operation = OPNAME(Pop);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = CREG;
}
DISPATCHCOMMON(pop_dx)
{
    Instr->Operation = OPNAME(Pop);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = DREG;
}
DISPATCHCOMMON(pop_bx)
{
    Instr->Operation = OPNAME(Pop);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = BREG;
}
DISPATCHCOMMON(pop_sp)
{
    Instr->Operation = OPNAME(Pop);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = SPREG;
}
DISPATCHCOMMON(pop_bp)
{
    Instr->Operation = OPNAME(Pop);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = BPREG;
}
DISPATCHCOMMON(pop_si)
{
    Instr->Operation = OPNAME(Pop);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = SIREG;
}
DISPATCHCOMMON(pop_di)
{
    Instr->Operation = OPNAME(Pop);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = DIREG;
}
DISPATCHCOMMON(bound)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, &Instr->Operand2);

    Instr->Operation = OPNAME(Bound);
    Instr->Operand2.Type = OPND_REGVALUE;
    Instr->Size = 1+cbInstr;
}
DISPATCHCOMMON(retn_i)
{
    Instr->Operation = OPNAME(CTRL_INDIR_Retn_i);
    Instr->Operand1.Type = OPND_IMM;
    Instr->Operand1.Immed = (DWORD)GET_SHORT(eipTemp+1);
    Instr->Size = 3;
}
DISPATCHCOMMON(retn)
{
    Instr->Operation = OPNAME(CTRL_INDIR_Retn);
}
DISPATCHCOMMON(retf_i)
{
    Instr->Operation = OPNAME(CTRL_INDIR_Retf_i);
    Instr->Operand1.Type = OPND_IMM;
    Instr->Operand1.Immed = (DWORD)GET_SHORT(eipTemp+1);
    Instr->Size = 3;
}
DISPATCHCOMMON(retf)
{
    Instr->Operation = OPNAME(CTRL_INDIR_Retf);
}
DISPATCHCOMMON(enter)
{
    Instr->Operation = OPNAME(Enter);
    Instr->Operand1.Type = OPND_IMM;
    Instr->Operand1.Immed = GET_BYTE(eipTemp+3);      // Nesting Level
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = GET_SHORT(eipTemp+1);     // Stack bytes to alloc
    Instr->Size = 4;
}
DISPATCHCOMMON(leave)
{
    Instr->Operation = OPNAME(Leave);
}



//-------- double-byte functions -----------------------------------------------

DISPATCHCOMMON(GROUP_8)
{
    BYTE g = GET_BYTE(eipTemp+1);
    int cbInstr;

    switch ((g >> 3) & 0x07) {
    case 0: // bad
    case 1: // bad
    case 2: // bad
    case 3: // bad
        BAD_INSTR;
        break;
    case 4: // bt modrmw immb
        // Note:  the difference between the Reg and Mem version of the btx
        // fragments is that the Reg version completely ignores any bits in the
        // second operand beyond the fifth bit.  In contrast, the Mem version uses
        // them together with the first operand to determine the memory address.
        // When the second operand is an immediate, the correct thing to do is to
        // ignore them, and so we call the Reg version all the time.

        cbInstr = MOD_RM(State, &Instr->Operand1, NULL);

        Instr->Operation = OPNAME(BtReg);
        Instr->Operand2.Type = OPND_IMM;
        Instr->Operand2.Immed = GET_BYTE(eipTemp+cbInstr+1);
        Instr->Size = cbInstr+3;
        break;
    case 5: // bts modrmw immb
        cbInstr = MOD_RM(State, &Instr->Operand1, NULL);

        Instr->Operation = OPNAME(BtsReg);
        Instr->Operand2.Type = OPND_IMM;
        Instr->Operand2.Immed = GET_BYTE(eipTemp+cbInstr+1);
        Instr->Size = cbInstr+3;
        break;
    case 6: // btr modrmw immb
        cbInstr = MOD_RM(State, &Instr->Operand1, NULL);

        Instr->Operation = OPNAME(BtrReg);
        Instr->Operand2.Type = OPND_IMM;
        Instr->Operand2.Immed = GET_BYTE(eipTemp+cbInstr+1);
        Instr->Size = cbInstr+3;
        break;
    case 7: // btc modrmw immb
        cbInstr = MOD_RM(State, &Instr->Operand1, NULL);

        Instr->Operation = OPNAME(BtcReg);
        Instr->Operand2.Type = OPND_IMM;
        Instr->Operand2.Immed = GET_BYTE(eipTemp+cbInstr+1);
        Instr->Size = cbInstr+3;
        break;
    }
}
DISPATCHCOMMON(LOCKGROUP_8)
{
    BYTE g = GET_BYTE(eipTemp+1);
    int cbInstr;

    switch ((g >> 3) & 0x07) {
    case 0: // bad
    case 1: // bad
    case 2: // bad
    case 3: // bad
    case 4: // bt modrmw immb
        BAD_INSTR;
        break;
    case 5: // bts modrmw immb
        cbInstr = MOD_RM(State, &Instr->Operand1, NULL);

        Instr->Operation = LOCKOPNAME(BtsReg);
        Instr->Operand2.Type = OPND_IMM;
        Instr->Operand2.Immed = GET_BYTE(eipTemp+cbInstr+1);
        Instr->Size = cbInstr+3;
        break;
    case 6: // btr modrmw immb
        cbInstr = MOD_RM(State, &Instr->Operand1, NULL);

        Instr->Operation = LOCKOPNAME(BtrReg);
        Instr->Operand2.Type = OPND_IMM;
        Instr->Operand2.Immed = GET_BYTE(eipTemp+cbInstr+1);
        Instr->Size = cbInstr+3;
        break;
    case 7: // btc modrmw immb
        cbInstr = MOD_RM(State, &Instr->Operand1, NULL);

        Instr->Operation = LOCKOPNAME(BtcReg);
        Instr->Operand2.Type = OPND_IMM;
        Instr->Operand2.Immed = GET_BYTE(eipTemp+cbInstr+1);
        Instr->Size = cbInstr+3;
        break;
    }
}
DISPATCHCOMMON(movzx_regw_modrmb)
{
    int cbInstr = mod_rm_reg8(State, &Instr->Operand1, NULL);

    Instr->Operation = OPNAME(Movzx8To);
    Instr->Operand2.Type = OPND_NOCODEGEN;
    Instr->Operand2.Reg = GET_REG(eipTemp+1);
    DEREF8(Instr->Operand1);
    Instr->Size = 2+cbInstr;
}
DISPATCHCOMMON(movsx_regw_modrmb)
{
    int cbInstr = mod_rm_reg8(State, &Instr->Operand1, NULL);

    Instr->Operation = OPNAME(Movsx8To);
    Instr->Operand2.Type = OPND_NOCODEGEN;
    Instr->Operand2.Reg = GET_REG(eipTemp+1);
    DEREF8(Instr->Operand1);
    Instr->Size = 2+cbInstr;
}
DISPATCHCOMMON(les_rw_mw)
{
    if ((GET_BYTE(eipTemp+1) & 0xc7) == 0xc4) {
        //
        // BOP instruction
        //
        PBOPINSTR Bop = (PBOPINSTR)eipTemp;

        Instr->Size = sizeof(BOPINSTR);

        if (Bop->BopNum == 0xfe) {
            //
            // BOP FE - Unsimulate
            //
            Instr->Operation = OP_Unsimulate;

        } else {

            //
            // Generate a BOP.
            //
            if (Bop->Flags & BOPFL_ENDCODE) {
                //
                // This BOP is flagged as being the end of Intel code.
                // This is typically BOP FD in x86-to-Risc callbacks.
                //
                Instr->Operation = OP_BOP_STOP_DECODE;
            } else {
                Instr->Operation = OP_BOP;
            }
        }
    } else {
        int cbInstr = MOD_RM(State, &Instr->Operand2, &Instr->Operand1);

        Instr->Operation = OPNAME(Les);
        Instr->Size = 1+cbInstr;
    }
}
DISPATCHCOMMON(lds_rw_mw)
{
    int cbInstr = MOD_RM(State, &Instr->Operand2, &Instr->Operand1);

    Instr->Operation = OPNAME(Lds);
    Instr->Size = 1+cbInstr;
}
DISPATCHCOMMON(lss_rw_mw)
{
    int cbInstr = MOD_RM(State, &Instr->Operand2, &Instr->Operand1);

    Instr->Operation = OPNAME(Lss);
    Instr->Size = 2+cbInstr;
}
DISPATCHCOMMON(lfs_rw_mw)
{
    int cbInstr = MOD_RM(State, &Instr->Operand2, &Instr->Operand1);

    Instr->Operation = OPNAME(Lfs);
    Instr->Size = 2+cbInstr;
}
DISPATCHCOMMON(lgs_rw_mw)
{
    int cbInstr = MOD_RM(State, &Instr->Operand2, &Instr->Operand1);

    Instr->Operation = OPNAME(Lgs);
    Instr->Size = 2+cbInstr;
}
DISPATCHCOMMON(bts_m_r)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, &Instr->Operand2);

    DEREF(Instr->Operand2);
    if (Instr->Operand1.Type == OPND_REGREF){
        Instr->Operation = OPNAME(BtsReg);
    } else {
        Instr->Operation = OPNAME(BtsMem);
    }
    Instr->Size = 2+cbInstr;
}
DISPATCHCOMMON(btr_m_r)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, &Instr->Operand2);

    DEREF(Instr->Operand2);
    if (Instr->Operand1.Type == OPND_REGREF){
        Instr->Operation = OPNAME(BtrReg);
    } else {
        Instr->Operation = OPNAME(BtrMem);
    }
    Instr->Size = 2+cbInstr;
}
DISPATCHCOMMON(btc_m_r)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, &Instr->Operand2);

    DEREF(Instr->Operand2);
    if (Instr->Operand1.Type == OPND_REGREF){
        Instr->Operation = OPNAME(BtcReg);
    } else {
        Instr->Operation = OPNAME(BtcMem);
    }
    Instr->Size = 2+cbInstr;
}
DISPATCHCOMMON(LOCKbts_m_r)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, &Instr->Operand2);

    DEREF(Instr->Operand2);
    if (Instr->Operand1.Type == OPND_REGREF){
        BAD_INSTR;
    } else {
        Instr->Operation = LOCKOPNAME(BtsMem);
    }
    Instr->Size = 2+cbInstr;
}
DISPATCHCOMMON(LOCKbtr_m_r)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, &Instr->Operand2);

    DEREF(Instr->Operand2);
    if (Instr->Operand1.Type == OPND_REGREF){
        BAD_INSTR;
    } else {
        Instr->Operation = LOCKOPNAME(BtrMem);
    }
    Instr->Size = 2+cbInstr;
}
DISPATCHCOMMON(LOCKbtc_m_r)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, &Instr->Operand2);

    DEREF(Instr->Operand2);
    if (Instr->Operand1.Type == OPND_REGREF){
        BAD_INSTR;
    } else {
        Instr->Operation = LOCKOPNAME(BtcMem);
    }
    Instr->Size = 2+cbInstr;
}
DISPATCHCOMMON(bt_m_r)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, &Instr->Operand2);

    DEREF(Instr->Operand2);
    if (Instr->Operand1.Type == OPND_REGREF){
        Instr->Operation = OPNAME(BtReg);
    } else {
        Instr->Operation = OPNAME(BtMem);
    }
    Instr->Size = 2+cbInstr;
}
DISPATCHCOMMON(call_rel)
{
    Instr->Operation = OP_CTRL_UNCOND_Call;
    Instr->Operand1.Type = OPND_IMM;
    Instr->Operand1.Immed = (STYPE)GET_VAL(eipTemp+1) + sizeof(UTYPE) + 1 + eipTemp;
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = eipTemp + sizeof(UTYPE) + 1;
    Instr->Size = sizeof(UTYPE) + 1;
}
DISPATCHCOMMON(jmp_rel)
{
    Instr->Operand1.Type = OPND_NOCODEGEN;
    if (State->AdrPrefix) {
        short IP;

        // get the 16-bit loword from the 32-bit immediate value following
        // the JMP instruction, and add that value to the loword of EIP, and
        // use that value as the new IP register.
        IP = (short)GET_SHORT(eipTemp+1) +
             sizeof(UTYPE) + 1 + (short)LOWORD(eipTemp);
        Instr->Operand1.Immed = MAKELONG(IP, HIWORD(eipTemp));
#if DBG
        State->AdrPrefix = FALSE;
#endif
    } else {
        Instr->Operand1.Immed = (STYPE)GET_VAL(eipTemp+1) +
                                sizeof(UTYPE) + 1 + eipTemp;
    }
    if (Instr->Operand1.Immed > eipTemp) {
        Instr->Operation = OP_CTRL_UNCOND_JmpFwd;
    } else {
        Instr->Operation = OP_CTRL_UNCOND_Jmp;
    }
    Instr->Size = sizeof(UTYPE) + 1;
}
DISPATCHCOMMON(shld_regw_modrmw_immb)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, &Instr->Operand2);

    Instr->Operation = OPNAME(Shld);
    DEREF(Instr->Operand2);
    Instr->Operand3.Type = OPND_IMM;
    Instr->Operand3.Immed = GET_BYTE(eipTemp+cbInstr+1);
    Instr->Size = 3+cbInstr;
}
DISPATCHCOMMON(shld_regw_modrmw_cl)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, &Instr->Operand2);

    Instr->Operation = OPNAME(Shld);
    DEREF(Instr->Operand2);
    Instr->Operand3.Type = OPND_REGVALUE;
    Instr->Operand3.Reg = GP_CL;
    Instr->Size = 2+cbInstr;
}
DISPATCHCOMMON(shrd_regw_modrmw_immb)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, &Instr->Operand2);

    Instr->Operation = OPNAME(Shrd);
    DEREF(Instr->Operand2);
    Instr->Operand3.Type = OPND_IMM;
    Instr->Operand3.Immed = GET_BYTE(eipTemp+cbInstr+1);
    Instr->Size = 3+cbInstr;
}
DISPATCHCOMMON(shrd_regw_modrmw_cl)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, &Instr->Operand2);

    Instr->Operation = OPNAME(Shrd);
    DEREF(Instr->Operand2);
    Instr->Operand3.Type = OPND_REGVALUE;
    Instr->Operand3.Reg = GP_CL;
    Instr->Size = 2+cbInstr;
}
DISPATCHCOMMON(bsr_modrmw_regw)
{
    int cbInstr = MOD_RM(State, &Instr->Operand2, &Instr->Operand1);

    Instr->Operation = OPNAME(Bsr);
    DEREF(Instr->Operand2);
    Instr->Size = 2+cbInstr;
}
DISPATCHCOMMON(bsf_modrmw_regw)
{
    int cbInstr = MOD_RM(State, &Instr->Operand2, &Instr->Operand1);

    Instr->Operation = OPNAME(Bsf);
    DEREF(Instr->Operand2);
    Instr->Size = 2+cbInstr;
}
DISPATCHCOMMON(lar)
{
    int cbInstr = MOD_RM(State, &Instr->Operand2, &Instr->Operand1);

    Instr->Operation = OPNAME(Lar);
    DEREF(Instr->Operand2);
    Instr->Size = 2+cbInstr;
}
DISPATCHCOMMON(lsl)
{
    int cbInstr = MOD_RM(State, &Instr->Operand2, &Instr->Operand1);

    Instr->Operation = OPNAME(Lsl);
    DEREF(Instr->Operand2);
    Instr->Size = 2+cbInstr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\decoder\decoderp.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    decoderp.h

Abstract:
    
    Private exports, defines for CPU Instruction decoder

Author:

    27-Jun-1995 BarryBo, Created

Revision History:

--*/

#ifndef DECODERP_H
#define DECODERP_H


#define GET_BYTE(addr)       (*(UNALIGNED unsigned char *)(addr))
#define GET_SHORT(addr)      (*(UNALIGNED unsigned short *)(addr))
#define GET_LONG(addr)       (*(UNALIGNED unsigned long *)(addr))

/*---------------------------------------------------------------------*/

typedef struct _DecoderState {
    DWORD InstructionAddress;
    INT   RepPrefix;
    BOOL  AdrPrefix;
    OPERATION OperationOverride;
} DECODERSTATE, *PDECODERSTATE;

#define eipTemp State->InstructionAddress

#define DISPATCH(x)  void x(PDECODERSTATE State, PINSTRUCTION Instr)

#if DBG
#define UNIMPL_INSTR(name)  {       \
    OutputDebugString("CPU: Warning:  unimplemented instruction " ## name ## " encountered\r\n"); \
    BAD_INSTR;                      \
    }
#else
#define UNIMPL_INSTR BAD_INSTR
#endif

#define BAD_INSTR                                   \
    State->OperationOverride = OP_BadInstruction;

#define PRIVILEGED_INSTR                            \
    State->OperationOverride = OP_PrivilegedInstruction;

#define get_reg32(cpu)          \
   (GP_EAX + (((*(PBYTE)(eipTemp+1)) >> 3) & 0x07))

#define get_reg16(cpu)          \
   (GP_AX + (((*(PBYTE)(eipTemp+1)) >> 3) & 0x07))

#define DEREF8(Op)                                                        \
    CPUASSERT(Op.Type == OPND_REGREF || Op.Type == OPND_ADDRREF);         \
    Op.Type = (Op.Type == OPND_REGREF) ? OPND_REGVALUE : OPND_ADDRVALUE8;

#define DEREF16(Op)                                                       \
    CPUASSERT(Op.Type == OPND_REGREF || Op.Type == OPND_ADDRREF);         \
    Op.Type = (Op.Type == OPND_REGREF) ? OPND_REGVALUE : OPND_ADDRVALUE16;

#define DEREF32(Op)                                                       \
    CPUASSERT(Op.Type == OPND_REGREF || Op.Type == OPND_ADDRREF);         \
    Op.Type++;

int scaled_index(PBYTE pmodrm, POPERAND op);
void get_segreg(PDECODERSTATE State, POPERAND op);
int     mod_rm_reg32(PDECODERSTATE State, POPERAND op1, POPERAND op2);
int     mod_rm_reg16(PDECODERSTATE State, POPERAND op1, POPERAND op2);
int     mod_rm_reg8 (PDECODERSTATE State, POPERAND op1, POPERAND op2);

#define PREFIX_NONE  0
#define PREFIX_REPZ  1
#define PREFIX_REPNZ 2

typedef void (*pfnDispatchInstruction)(PDECODERSTATE, PINSTRUCTION);
extern pfnDispatchInstruction Dispatch32[256];
extern pfnDispatchInstruction Dispatch232[256];
extern pfnDispatchInstruction Dispatch16[256];
extern pfnDispatchInstruction Dispatch216[256];
extern pfnDispatchInstruction LockDispatch32[256];
extern pfnDispatchInstruction LockDispatch232[256];
extern pfnDispatchInstruction LockDispatch16[256];
extern pfnDispatchInstruction LockDispatch216[256];

#endif //DECODERP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\decoder\decoder.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    decoder.c

Abstract:
    
    Public Decoder APIs and helper functions use in decoding instructions

Author:

    27-Jun-1995 BarryBo

Revision History:

        24-Aug-1999 [askhalid] copied from 32-bit wx86 directory and make work for 64bit.

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "cpuassrt.h"
#include "threadst.h"
#include "instr.h"
#include "decoder.h"
#include "decoderp.h"

ASSERTNAME;

ULONG
DecoderExceptionFilter(
    PINSTRUCTION                Instruction,
    struct _EXCEPTION_POINTERS *ExInfo
    )
/*++

Routine Description:
    Handles any exception thrown while decoding an instruction.  Creates
    an OP_Fault instruction with operand2 being the exception code and
    operand1 being the address where the exception occurred.

Arguments:

    Instruction         - Structure to be filled in with the decoding
    ExInfo              - Information about the exception.

Return Value:

    ULONG - always EXCEPTION_EXECUTE_HANDLER.

--*/
{
    Instruction->Operation = OP_Fault;
    Instruction->Operand1.Type = OPND_IMM;
    Instruction->Operand2.Immed = (ULONG)(ULONGLONG)ExInfo->ExceptionRecord->ExceptionAddress;
    Instruction->Operand2.Type = OPND_IMM;
    Instruction->Operand1.Immed = ExInfo->ExceptionRecord->ExceptionCode;
    Instruction->Size = 1;

    return EXCEPTION_EXECUTE_HANDLER;
}

VOID
DecodeInstruction(
    DWORD           InstructionAddress,
    PINSTRUCTION    Instruction
    )
/*++

Routine Description:
    Decodes a single Intel instruction beginning at InstructionAddress, filling
    in the INSTRUCTION structure.

Arguments:

    InstructionAddress  - Address of first byte of the Intel Instruction
    Instruction         - Structure to be filled in with the decoding

Return Value:

    None - always succeeds.

--*/

{
    DECODERSTATE    DecoderState;


    //
    // Initialize the Instruction structure.  Instruction structures are
    // zero-filled by the analysis phase, so only non-zero fields need
    // to be filled in here.
    //
    Instruction->Size = 1;
    Instruction->Operand1.Reg = NO_REG;
    Instruction->Operand1.IndexReg = NO_REG;
    Instruction->Operand2.Reg = NO_REG;
    Instruction->Operand2.IndexReg = NO_REG;
    Instruction->Operand3.Reg = NO_REG;
    Instruction->Operand3.IndexReg = NO_REG;
    Instruction->IntelAddress = InstructionAddress;

    // Initialize the decoder state info
    DecoderState.InstructionAddress = InstructionAddress;
    DecoderState.RepPrefix = PREFIX_NONE;
    DecoderState.AdrPrefix = FALSE;
    DecoderState.OperationOverride = OP_MAX;

    try {

        // Decode the instruction, filling in the Instruction structure
        (Dispatch32[GET_BYTE(InstructionAddress)])(&DecoderState, Instruction);

    } except(DecoderExceptionFilter(Instruction, GetExceptionInformation())) {

    }

    // Handle illegal instructions
    if (DecoderState.OperationOverride != OP_MAX) {
        Instruction->Size = 1;
        Instruction->Operation = DecoderState.OperationOverride;
        Instruction->Operand1.Type = OPND_NONE;
        Instruction->Operand2.Type = OPND_NONE;
    }

    // If Operand2 is filled-in, then Operand1 must also be filled in.
    CPUASSERT(Instruction->Operand2.Type == OPND_NONE ||
              Instruction->Operand1.Type != OPND_NONE);
}



void get_segreg(PDECODERSTATE State, POPERAND op)
{
    BYTE Reg = ((*(PBYTE)(eipTemp+1)) >> 3) & 0x07;

    op->Type = OPND_REGVALUE;
    op->Reg = REG_ES + Reg;
    if (Reg > 5) {
        BAD_INSTR;
    }
}

int scaled_index(PBYTE pmodrm, POPERAND op)
{
    BYTE sib = *(pmodrm+1);
    INT IndexReg = GP_EAX + (sib >> 3) & 0x07;
    BYTE base = GP_EAX + sib & 0x07;

    op->Type = OPND_ADDRREF;
    op->Scale = sib >> 6;

    if (IndexReg != GP_ESP) {
        op->IndexReg = IndexReg;
    } // else op->IndexReg = NO_REG, which is the default value

    if (base == GP_EBP && ((*pmodrm) >> 6) == 0) {
        op->Immed = GET_LONG(pmodrm+2);
        return 5;   // account for sib+DWORD
    }

    op->Reg = base;
    return 1;   // account for sib
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\decoder\common.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    common.h

Abstract:
    
    Prototypes for instructions which operate on BYTES, WORDS or DWORDS.

Author:

    06-Jun-1995 BarryBo, Created

Revision History:

--*/

// WARNING: This file may be included multiple times by a single source file,
// WARNING: so don't add #ifndef COMMON_H checks.

DISPATCHCOMMON(LOCKadd_m_r);
DISPATCHCOMMON(LOCKadd_r_m);
DISPATCHCOMMON(LOCKadd_a_i);
DISPATCHCOMMON(LOCKor_m_r);
DISPATCHCOMMON(LOCKor_r_m);
DISPATCHCOMMON(LOCKor_a_i);
DISPATCHCOMMON(LOCKadc_m_r);
DISPATCHCOMMON(LOCKadc_r_m);
DISPATCHCOMMON(LOCKadc_a_i);
DISPATCHCOMMON(LOCKsbb_m_r);
DISPATCHCOMMON(LOCKsbb_r_m);
DISPATCHCOMMON(LOCKsbb_a_i);
DISPATCHCOMMON(LOCKand_m_r);
DISPATCHCOMMON(LOCKand_r_m);
DISPATCHCOMMON(LOCKand_a_i);
DISPATCHCOMMON(LOCKsub_m_r);
DISPATCHCOMMON(LOCKsub_r_m);
DISPATCHCOMMON(LOCKsub_a_i);
DISPATCHCOMMON(LOCKxor_m_r);
DISPATCHCOMMON(LOCKxor_r_m);
DISPATCHCOMMON(LOCKxor_a_i);

DISPATCHCOMMON(add_m_r);
DISPATCHCOMMON(add_r_m);
DISPATCHCOMMON(add_a_i);
DISPATCHCOMMON(or_m_r);
DISPATCHCOMMON(or_r_m);
DISPATCHCOMMON(or_a_i);
DISPATCHCOMMON(adc_m_r);
DISPATCHCOMMON(adc_r_m);
DISPATCHCOMMON(adc_a_i);
DISPATCHCOMMON(sbb_m_r);
DISPATCHCOMMON(sbb_r_m);
DISPATCHCOMMON(sbb_a_i);
DISPATCHCOMMON(and_m_r);
DISPATCHCOMMON(and_r_m);
DISPATCHCOMMON(and_a_i);
DISPATCHCOMMON(sub_m_r);
DISPATCHCOMMON(sub_r_m);
DISPATCHCOMMON(sub_a_i);
DISPATCHCOMMON(xor_m_r);
DISPATCHCOMMON(xor_r_m);
DISPATCHCOMMON(xor_a_i);
DISPATCHCOMMON(cmp_m_r);
DISPATCHCOMMON(cmp_r_m);
DISPATCHCOMMON(cmp_a_i);
DISPATCHCOMMON(GROUP_1);
DISPATCHCOMMON(LOCKGROUP_1);
DISPATCHCOMMON(test_r_m);
DISPATCHCOMMON(xchg_r_m);
DISPATCHCOMMON(mov_m_r);
DISPATCHCOMMON(mov_r_m);
DISPATCHCOMMON(mov_a_m);
DISPATCHCOMMON(mov_m_a);
DISPATCHCOMMON(test_a_i);
DISPATCHCOMMON(mov_a_i);
DISPATCHCOMMON(mov_b_i);
DISPATCHCOMMON(mov_c_i);
DISPATCHCOMMON(mov_d_i);
DISPATCHCOMMON(GROUP_2);
DISPATCHCOMMON(mov_m_i);
DISPATCHCOMMON(GROUP_2_1);
DISPATCHCOMMON(GROUP_2_CL);
DISPATCHCOMMON(GROUP_3);
DISPATCHCOMMON(LOCKGROUP_3);
DISPATCHCOMMON(lods);
DISPATCHCOMMON(stos);
DISPATCHCOMMON(scas);
DISPATCHCOMMON(movs);
DISPATCHCOMMON(cmps);
DISPATCHCOMMON(jo);
DISPATCHCOMMON(jno);
DISPATCHCOMMON(jb);
DISPATCHCOMMON(jae);
DISPATCHCOMMON(je);
DISPATCHCOMMON(jne);
DISPATCHCOMMON(jbe);
DISPATCHCOMMON(ja);
DISPATCHCOMMON(js);
DISPATCHCOMMON(jns);
DISPATCHCOMMON(jp);
DISPATCHCOMMON(jnp);
DISPATCHCOMMON(jl);
DISPATCHCOMMON(jnl);
DISPATCHCOMMON(jle);
DISPATCHCOMMON(jg);
DISPATCHCOMMON(xadd_m_r);
DISPATCHCOMMON(cmpxchg_m_r);
DISPATCHCOMMON(LOCKxadd_m_r);
DISPATCHCOMMON(LOCKcmpxchg_m_r);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\decoder\comm1632.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    comm1632.h

Abstract:
    
    Prototypes for instructions which operate on WORDS or DWORDS.

Author:

    06-Jun-1995 BarryBo, Created

Revision History:

--*/

// WARNING: This file may be included multiple times by a single source file,
// WARNING: so don't add #ifndef COMM1632_H checks.

DISPATCHCOMMON(dispatch2);
DISPATCHCOMMON(LOCKdispatch2);
DISPATCHCOMMON(pushf);
DISPATCHCOMMON(popf);
DISPATCHCOMMON(pusha);
DISPATCHCOMMON(popa);
DISPATCHCOMMON(push_iw);
DISPATCHCOMMON(push_ibs);
DISPATCHCOMMON(GROUP_1WS);
DISPATCHCOMMON(LOCKGROUP_1WS);
DISPATCHCOMMON(mov_rw_mw);
DISPATCHCOMMON(lea_rw_mw);
DISPATCHCOMMON(pop_mw);
DISPATCHCOMMON(xchg_ax_cx);
DISPATCHCOMMON(xchg_ax_dx);
DISPATCHCOMMON(xchg_ax_bx);
DISPATCHCOMMON(xchg_ax_sp);
DISPATCHCOMMON(xchg_ax_bp);
DISPATCHCOMMON(xchg_ax_si);
DISPATCHCOMMON(xchg_ax_di);
DISPATCHCOMMON(cbw);
DISPATCHCOMMON(cwd);
DISPATCHCOMMON(mov_sp_iw);
DISPATCHCOMMON(mov_bp_iw);
DISPATCHCOMMON(mov_si_iw);
DISPATCHCOMMON(mov_di_iw);
DISPATCHCOMMON(loopne_b);
DISPATCHCOMMON(loope_b);
DISPATCHCOMMON(loop_b);
DISPATCHCOMMON(jcxz_b);
DISPATCHCOMMON(GROUP_5);
DISPATCHCOMMON(GROUP_8);
DISPATCHCOMMON(LOCKGROUP_5);
DISPATCHCOMMON(LOCKGROUP_8);
DISPATCHCOMMON(bts_m_r);
DISPATCHCOMMON(btc_m_r);
DISPATCHCOMMON(btr_m_r);
DISPATCHCOMMON(LOCKbts_m_r);
DISPATCHCOMMON(LOCKbtc_m_r);
DISPATCHCOMMON(LOCKbtr_m_r);
DISPATCHCOMMON(bt_m_r);
DISPATCHCOMMON(jo_w);
DISPATCHCOMMON(jno_w);
DISPATCHCOMMON(jb_w);
DISPATCHCOMMON(jae_w);
DISPATCHCOMMON(je_w);
DISPATCHCOMMON(jne_w);
DISPATCHCOMMON(jbe_w);
DISPATCHCOMMON(ja_w);
DISPATCHCOMMON(js_w);
DISPATCHCOMMON(jns_w);
DISPATCHCOMMON(jp_w);
DISPATCHCOMMON(jnp_w);
DISPATCHCOMMON(jl_w);
DISPATCHCOMMON(jnl_w);
DISPATCHCOMMON(jle_w);
DISPATCHCOMMON(jg_w);
DISPATCHCOMMON(inc_ax);
DISPATCHCOMMON(inc_bx);
DISPATCHCOMMON(inc_dx);
DISPATCHCOMMON(inc_cx);
DISPATCHCOMMON(inc_sp);
DISPATCHCOMMON(inc_bp);
DISPATCHCOMMON(inc_si);
DISPATCHCOMMON(inc_di);
DISPATCHCOMMON(dec_ax);
DISPATCHCOMMON(dec_bx);
DISPATCHCOMMON(dec_cx);
DISPATCHCOMMON(dec_dx);
DISPATCHCOMMON(dec_sp);
DISPATCHCOMMON(dec_bp);
DISPATCHCOMMON(dec_si);
DISPATCHCOMMON(dec_di);
DISPATCHCOMMON(push_ax);
DISPATCHCOMMON(push_bx);
DISPATCHCOMMON(push_cx);
DISPATCHCOMMON(push_dx);
DISPATCHCOMMON(push_sp);
DISPATCHCOMMON(push_bp);
DISPATCHCOMMON(push_si);
DISPATCHCOMMON(push_di);
DISPATCHCOMMON(pop_ax);
DISPATCHCOMMON(pop_bx);
DISPATCHCOMMON(pop_cx);
DISPATCHCOMMON(pop_dx);
DISPATCHCOMMON(pop_sp);
DISPATCHCOMMON(pop_bp);
DISPATCHCOMMON(pop_si);
DISPATCHCOMMON(pop_di);
DISPATCHCOMMON(bound);
DISPATCHCOMMON(retn_i);
DISPATCHCOMMON(retn);
DISPATCHCOMMON(retf_i);
DISPATCHCOMMON(retf);
DISPATCHCOMMON(enter);
DISPATCHCOMMON(leave);
DISPATCHCOMMON(movzx_regw_modrmb);
DISPATCHCOMMON(movsx_regw_modrmb);
DISPATCHCOMMON(lds_rw_mw);
DISPATCHCOMMON(lss_rw_mw);
DISPATCHCOMMON(les_rw_mw);
DISPATCHCOMMON(lfs_rw_mw);
DISPATCHCOMMON(lgs_rw_mw);
DISPATCHCOMMON(call_rel);
DISPATCHCOMMON(jmp_rel);
DISPATCHCOMMON(shld_regw_modrmw_immb);
DISPATCHCOMMON(shld_regw_modrmw_cl);
DISPATCHCOMMON(shrd_regw_modrmw_immb);
DISPATCHCOMMON(shrd_regw_modrmw_cl);
DISPATCHCOMMON(bsf_modrmw_regw);
DISPATCHCOMMON(bsr_modrmw_regw);
DISPATCHCOMMON(lar);
DISPATCHCOMMON(lsl);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\decoder\ds16tbl.c ===
// Tables for DS: 32-bit instructions
//  (ie. no FS:, but DATA: specified)
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ds16tbl.c

Abstract:
    
    Dispatch tables for instructions with DATA: override.  It is used for
    both DS: and FS: overrides.

Author:

    29-Jun-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "threadst.h"
#include "instr.h"
#include "decoderp.h"

#include "bytefns.h"
#include "wordfns.h"
#include "miscfns.h"
#include "floatfns.h"

pfnDispatchInstruction Dispatch16[256] = {
    // 0
    add_m_r8,
    add_m_r16,
    add_r_m8,
    add_r_m16,
    add_a_i8,
    add_a_i16,
    push_es,
    pop_es,
    // 8
    or_m_r8,
    or_m_r16,
    or_r_m8,
    or_r_m16,
    or_a_i8,
    or_a_i16,
    push_cs,
    dispatch216,
    // 10
    adc_m_r8,
    adc_m_r16,
    adc_r_m8,
    adc_r_m16,
    adc_a_i8,
    adc_a_i16,
    push_ss,
    pop_ss,
    // 18
    sbb_m_r8,
    sbb_m_r16,
    sbb_r_m8,
    sbb_r_m16,
    sbb_a_i8,
    sbb_a_i16,
    push_ds,
    pop_ds,
    // 20
    and_m_r8,
    and_m_r16,
    and_r_m8,
    and_r_m16,
    and_a_i8,
    and_a_i16,
    ProcessPrefixes,	// es:
    daa,
    // 28
    sub_m_r8,
    sub_m_r16,
    sub_r_m8,
    sub_r_m16,
    sub_a_i8,
    sub_a_i16,
    ProcessPrefixes,	// cs:
    das,
    // 30
    xor_m_r8,
    xor_m_r16,
    xor_r_m8,
    xor_r_m16,
    xor_a_i8,
    xor_a_i16,
    ProcessPrefixes,	// ss:
    aaa,
    // 38
    cmp_m_r8,
    cmp_m_r16,
    cmp_r_m8,
    cmp_r_m16,
    cmp_a_i8,
    cmp_a_i16,
    ProcessPrefixes,	// ds:
    aas,
    // 40
    inc_ax16,
    inc_cx16,
    inc_dx16,
    inc_bx16,
    inc_sp16,
    inc_bp16,
    inc_si16,
    inc_di16,
    // 48
    dec_ax16,
    dec_cx16,
    dec_dx16,
    dec_bx16,
    dec_sp16,
    dec_bp16,
    dec_si16,
    dec_di16,
    // 50
    push_ax16,
    push_cx16,
    push_dx16,
    push_bx16,
    push_sp16,
    push_bp16,
    push_si16,
    push_di16,
    // 58
    pop_ax16,
    pop_cx16,
    pop_dx16,
    pop_bx16,
    pop_sp16,
    pop_bp16,
    pop_si16,
    pop_di16,
    // 60
    pusha16,
    popa16,
    bound16,
    privileged, 	// arpl
    ProcessPrefixes,	// fs:
    ProcessPrefixes,	// gs:
    ProcessPrefixes,	// data: prefix
    ProcessPrefixes,	// adr: prefix
    // 68
    push_iw16,
    imul_rw_m_iw16,
    push_ibs16,
    imul_rw_m_ib16,
    privileged,     // in_ib_dx
    privileged,     // in_iw_dx
    privileged,     // out_ib_dx
    privileged,     // out_iw_dx
    // 70
    jo8,
    jno8,
    jb8,
    jae8,
    je8,
    jne8,
    jbe8,
    ja8,
    // 78
    js8,
    jns8,
    jp8,
    jnp8,
    jl8,
    jnl8,
    jle8,
    jg8,
    // 80
    GROUP_18,
    GROUP_116,
    bad,
    GROUP_1WS16,
    test_r_m8,
    test_r_m16,
    xchg_r_m8,
    xchg_r_m16,
    // 88
    mov_m_r8,
    mov_m_r16,
    mov_r_m8,
    mov_r_m16,
    mov_mw_seg,
    lea_rw_mw16,
    mov_seg_mw,
    pop_mw16,
    // 90
    nop,
    xchg_ax_cx16,
    xchg_ax_dx16,
    xchg_ax_bx16,
    xchg_ax_sp16,
    xchg_ax_bp16,
    xchg_ax_si16,
    xchg_ax_di16,
    // 98
    cbw16,
    cwd16,
    call_md,
    wait,
    pushf16,
    popf16,
    sahf,
    lahf,
    // a0
    mov_a_m8,
    mov_a_m16,
    mov_m_a8,
    mov_m_a16,
    movs8,
    movs16,
    cmps8,
    cmps16,
    // a8
    test_a_i8,
    test_a_i16,
    stos8,
    stos16,
    lods8,
    lods16,
    scas8,
    scas16,
    // b0
    mov_a_i8,
    mov_c_i8,
    mov_d_i8,
    mov_b_i8,
    mov_ah_ib,
    mov_ch_ib,
    mov_dh_ib,
    mov_bh_ib,
    // b8
    mov_a_i16,
    mov_c_i16,
    mov_d_i16,
    mov_b_i16,
    mov_sp_iw16,
    mov_bp_iw16,
    mov_si_iw16,
    mov_di_iw16,
    // c0
    GROUP_28,
    GROUP_216,
    retn_i16,
    retn16,
    les_rw_mw16,
    lds_rw_mw16,
    mov_m_i8,
    mov_m_i16,
    // c8
    enter16,
    leave16,
    retf_i16,
    retf16,
    int3,
    int_ib,
    into,
    iret,
    // d0
    GROUP_2_18,
    GROUP_2_116,
    GROUP_2_CL8,
    GROUP_2_CL16,
    aam_ib,
    aad_ib,
    bad,
    xlat,
    // d8
    FLOAT_GP0,
    FLOAT_GP1,
    FLOAT_GP2,
    FLOAT_GP3,
    FLOAT_GP4,
    FLOAT_GP5,
    FLOAT_GP6,
    FLOAT_GP7,
    // e0
    loopne_b16,
    loope_b16,
    loop_b16,
    jcxz_b16,
    privileged,     // in_al_memb
    privileged,     // in_ax_memb
    privileged,     // out_memb_al
    privileged,     // out_memb_ax
    // e8
    call_rel16,
    jmp_rel16,
    jmpf_md,
    jmp_jb,
    privileged,     // in_al_dx
    privileged,     // in_ax_dx
    privileged,     // out_dx_al
    privileged,     // out_dx_ax
    // f0
    ProcessPrefixes,	// lock: prefix
    bad,
    ProcessPrefixes,	// repnz prefix
    ProcessPrefixes,	// repz prefix
    privileged, 	// halt
    cmc,
    GROUP_38,
    GROUP_316,
    // f8
    clc,
    stc,
    privileged,     // cli
    privileged,     // sti
    cld,
    std,
    GROUP_4,
    GROUP_516
};


pfnDispatchInstruction Dispatch216[256] = {
    // 0
    GROUP_6,
    GROUP_7,
    lar16,
    lsl16,
    bad,
    bad,
    privileged,	// clts
    bad,
    // 8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 10
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 18
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 20
    privileged,	// mov reg2W, eeeControl
    privileged,	// mov reg2W, eeeDebug
    privileged,	// mov eeeControl, reg2W
    privileged,	// mov eeeDebug, reg2W
    privileged,	// mov reg2W, eeeTest
    bad,
    privileged,	// mov eeeTest, reg2W
    bad,
    // 28
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 30
    bad,
    rdtsc,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 38
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 40
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 48
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 50
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 58
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 60
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 68
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 70
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 78
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 80
    jo16,
    jno16,
    jb16,
    jae16,
    je16,
    jne16,
    jbe16,
    ja16,
    // 88
    js16,
    jns16,
    jp16,
    jnp16,
    jl16,
    jnl16,
    jle16,
    jg16,
    // 90
    seto_modrmb,
    setno_modrmb,
    setb_modrmb,
    setae_modrmb,
    sete_modrmb,
    setne_modrmb,
    setbe_modrmb,
    seta_modrmb,
    // 98
    sets_modrmb,
    setns_modrmb,
    setp_modrmb,
    setnp_modrmb,
    setl_modrmb,
    setge_modrmb,
    setle_modrmb,
    setg_modrmb,
    // a0
    push_fs,
    pop_fs,
    bad,
    bt_m_r16,
    shld_regw_modrmw_immb16,
    shld_regw_modrmw_cl16,
    bad,
    bad,
    // a8
    push_gs,
    pop_gs,
    bad,
    bts_m_r16,
    shrd_regw_modrmw_immb16,
    shrd_regw_modrmw_cl16,
    bad,
    imul_regw_modrmw16,
    // b0
    cmpxchg_m_r8,
    cmpxchg_m_r16,
    lss_rw_mw16,
    btr_m_r16,
    lfs_rw_mw16,
    lgs_rw_mw16,
    movzx_regw_modrmb16,
    movzx_regw_modrmw,
    // b8
    bad,
    bad,
    GROUP_816,
    btc_m_r16,
    bsf_modrmw_regw16,
    bsr_modrmw_regw16,
    movsx_regw_modrmb16,
    movsx_regw_modrmw,
    // c0
    xadd_m_r8,
    xadd_m_r16,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // c8
    bswap_eax,
    bswap_ecx,
    bswap_edx,
    bswap_ebx,
    bswap_esp,
    bswap_ebp,
    bswap_esi,
    bswap_edi,
    // d0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // d8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // e0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // e8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // f0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // f8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\decoder\dwordfns.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    dwordfns.h

Abstract:
    
    Prototypes for instructions which operate on 32-bit DWORDS.

Author:

    06-Jun-1995 BarryBo, Created

Revision History:

--*/

#ifndef DWORDFNS_H
#define DWORDFNS_H

#define DISPATCHCOMMON(x) DISPATCH(x ## 32)
#include "common.h"
#include "comm1632.h"
#undef DISPATCHCOMMON

#endif //DWORDFNS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\decoder\floatfns.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    floatfns.h

Abstract:
    
    Prototypes for floating point instructions.

Author:

    20-Jun-1995 t-orig

Revision History:

--*/

DISPATCH(FLOAT_GP0);
DISPATCH(FLOAT_GP1);
DISPATCH(FLOAT_GP2);
DISPATCH(FLOAT_GP3);
DISPATCH(FLOAT_GP4);
DISPATCH(FLOAT_GP5);
DISPATCH(FLOAT_GP6);
DISPATCH(FLOAT_GP7);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\decoder\ds32tbl.c ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    ds32tbl.c

Abstract:
    
    Dispatch tables for instructions with no DATA: override.  It is used for
    both DS: and FS: overrides.

Author:

    29-Jun-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "threadst.h"
#include "instr.h"
#include "decoderp.h"

#include "bytefns.h"
#include "dwordfns.h"
#include "miscfns.h"
#include "floatfns.h"

pfnDispatchInstruction Dispatch32[256] = {
    // 0
    add_m_r8,
    add_m_r32,
    add_r_m8,
    add_r_m32,
    add_a_i8,
    add_a_i32,
    push_es,
    pop_es,
    // 8
    or_m_r8,
    or_m_r32,
    or_r_m8,
    or_r_m32,
    or_a_i8,
    or_a_i32,
    push_cs,
    dispatch232,
    // 10
    adc_m_r8,
    adc_m_r32,
    adc_r_m8,
    adc_r_m32,
    adc_a_i8,
    adc_a_i32,
    push_ss,
    pop_ss,
    // 18
    sbb_m_r8,
    sbb_m_r32,
    sbb_r_m8,
    sbb_r_m32,
    sbb_a_i8,
    sbb_a_i32,
    push_ds,
    pop_ds,
    // 20
    and_m_r8,
    and_m_r32,
    and_r_m8,
    and_r_m32,
    and_a_i8,
    and_a_i32,
    ProcessPrefixes,	// es:
    daa,
    // 28
    sub_m_r8,
    sub_m_r32,
    sub_r_m8,
    sub_r_m32,
    sub_a_i8,
    sub_a_i32,
    ProcessPrefixes,	// cs:
    das,
    // 30
    xor_m_r8,
    xor_m_r32,
    xor_r_m8,
    xor_r_m32,
    xor_a_i8,
    xor_a_i32,
    ProcessPrefixes,	// ss:
    aaa,
    // 38
    cmp_m_r8,
    cmp_m_r32,
    cmp_r_m8,
    cmp_r_m32,
    cmp_a_i8,
    cmp_a_i32,
    ProcessPrefixes,	// ds:
    aas,
    // 40
    inc_ax32,
    inc_cx32,
    inc_dx32,
    inc_bx32,
    inc_sp32,
    inc_bp32,
    inc_si32,
    inc_di32,
    // 48
    dec_ax32,
    dec_cx32,
    dec_dx32,
    dec_bx32,
    dec_sp32,
    dec_bp32,
    dec_si32,
    dec_di32,
    // 50
    push_ax32,
    push_cx32,
    push_dx32,
    push_bx32,
    push_sp32,
    push_bp32,
    push_si32,
    push_di32,
    // 58
    pop_ax32,
    pop_cx32,
    pop_dx32,
    pop_bx32,
    pop_sp32,
    pop_bp32,
    pop_si32,
    pop_di32,
    // 60
    pusha32,
    popa32,
    bound32,
    arpl,
    ProcessPrefixes,	// fs:
    ProcessPrefixes,	// gs:
    ProcessPrefixes,	// data: prefix
    ProcessPrefixes,	// adr: prefix
    // 68
    push_iw32,
    imul_rw_m_iw32,
    push_ibs32,
    imul_rw_m_ib32,
    privileged,     // in_ib_dx
    privileged,     // in_iw_dx
    privileged,     // out_ib_dx
    privileged,     // out_iw_dx
    // 70
    jo8,
    jno8,
    jb8,
    jae8,
    je8,
    jne8,
    jbe8,
    ja8,
    // 78
    js8,
    jns8,
    jp8,
    jnp8,
    jl8,
    jnl8,
    jle8,
    jg8,
    // 80
    GROUP_18,
    GROUP_132,
    bad,
    GROUP_1WS32,
    test_r_m8,
    test_r_m32,
    xchg_r_m8,
    xchg_r_m32,
    // 88
    mov_m_r8,
    mov_m_r32,
    mov_r_m8,
    mov_r_m32,
    mov_mw_seg,
    lea_rw_mw32,
    mov_seg_mw,
    pop_mw32,
    // 90
    nop,
    xchg_ax_cx32,
    xchg_ax_dx32,
    xchg_ax_bx32,
    xchg_ax_sp32,
    xchg_ax_bp32,
    xchg_ax_si32,
    xchg_ax_di32,
    // 98
    cbw32,
    cwd32,
    call_md,
    wait,
    pushf32,
    popf32,
    sahf,
    lahf,
    // a0
    mov_a_m8,
    mov_a_m32,
    mov_m_a8,
    mov_m_a32,
    movs8,
    movs32,
    cmps8,
    cmps32,
    // a8
    test_a_i8,
    test_a_i32,
    stos8,
    stos32,
    lods8,
    lods32,
    scas8,
    scas32,
    // b0
    mov_a_i8,
    mov_c_i8,
    mov_d_i8,
    mov_b_i8,
    mov_ah_ib,
    mov_ch_ib,
    mov_dh_ib,
    mov_bh_ib,
    // b8
    mov_a_i32,
    mov_c_i32,
    mov_d_i32,
    mov_b_i32,
    mov_sp_iw32,
    mov_bp_iw32,
    mov_si_iw32,
    mov_di_iw32,
    // c0
    GROUP_28,
    GROUP_232,
    retn_i32,
    retn32,
    les_rw_mw32,
    lds_rw_mw32,
    mov_m_i8,
    mov_m_i32,
    // c8
    enter32,
    leave32,
    retf_i32,
    retf32,
    int3,
    int_ib,
    into,
    iret,
    // d0
    GROUP_2_18,
    GROUP_2_132,
    GROUP_2_CL8,
    GROUP_2_CL32,
    aam_ib,
    aad_ib,
    bad,
    xlat,
    // d8
    FLOAT_GP0,
    FLOAT_GP1,
    FLOAT_GP2,
    FLOAT_GP3,
    FLOAT_GP4,
    FLOAT_GP5,
    FLOAT_GP6,
    FLOAT_GP7,
    // e0
    loopne_b32,
    loope_b32,
    loop_b32,
    jcxz_b32,
    privileged,     // in_al_memb
    privileged,     // in_ax_memb
    privileged,     // out_memb_al
    privileged,     // out_memb_ax
    // e8
    call_rel32,
    jmp_rel32,
    jmpf_md,
    jmp_jb,
    privileged,     // in_al_dx
    privileged,     // in_ax_dx
    privileged,     // out_dx_al
    privileged,     // out_dx_ax
    // f0
    ProcessPrefixes,	// lock: prefix
    bad,
    ProcessPrefixes,	// repnz prefix
    ProcessPrefixes,	// repz prefix
    privileged, 	// halt
    cmc,
    GROUP_38,
    GROUP_332,
    // f8
    clc,
    stc,
    privileged,     // cli
    privileged,     // sti
    cld,
    std,
    GROUP_4,
    GROUP_532
};


pfnDispatchInstruction Dispatch232[256] = {
    // 0
    GROUP_6,
    GROUP_7,
    lar32,
    lsl32,
    bad,
    bad,
    privileged,	// clts
    bad,
    // 8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 10
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 18
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 20
    privileged,	// mov reg2W, eeeControl
    privileged,	// mov reg2W, eeeDebug
    privileged,	// mov eeeControl, reg2W
    privileged,	// mov eeeDebug, reg2W
    privileged,	// mov reg2W, eeeTest
    bad,
    privileged,	// mov eeeTest, reg2W
    bad,
    // 28
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 30
    bad,
    rdtsc,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 38
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 40
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 48
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 50
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 58
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 60
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 68
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 70
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 78
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 80
    jo32,
    jno32,
    jb32,
    jae32,
    je32,
    jne32,
    jbe32,
    ja32,
    // 88
    js32,
    jns32,
    jp32,
    jnp32,
    jl32,
    jnl32,
    jle32,
    jg32,
    // 90
    seto_modrmb,
    setno_modrmb,
    setb_modrmb,
    setae_modrmb,
    sete_modrmb,
    setne_modrmb,
    setbe_modrmb,
    seta_modrmb,
    // 98
    sets_modrmb,
    setns_modrmb,
    setp_modrmb,
    setnp_modrmb,
    setl_modrmb,
    setge_modrmb,
    setle_modrmb,
    setg_modrmb,
    // a0
    push_fs,
    pop_fs,
    cpuid,
    bt_m_r32,
    shld_regw_modrmw_immb32,
    shld_regw_modrmw_cl32,
    bad,
    bad,
    // a8
    push_gs,
    pop_gs,
    bad,
    bts_m_r32,
    shrd_regw_modrmw_immb32,
    shrd_regw_modrmw_cl32,
    bad,
    imul_regw_modrmw32,
    // b0
    cmpxchg_m_r8,
    cmpxchg_m_r32,
    lss_rw_mw32,
    btr_m_r32,
    lfs_rw_mw32,
    lgs_rw_mw32,
    movzx_regw_modrmb32,
    movzx_regw_modrmw,
    // b8
    bad,
    bad,
    GROUP_832,
    btc_m_r32,
    bsf_modrmw_regw32,
    bsr_modrmw_regw32,
    movsx_regw_modrmb32,
    movsx_regw_modrmw,
    // c0
    xadd_m_r8,
    xadd_m_r32,
    bad,
    bad,
    bad,
    bad,
    bad,
    cmpxchg8b,
    // c8
    bswap_eax,
    bswap_ecx,
    bswap_edx,
    bswap_ebx,
    bswap_esp,
    bswap_ebp,
    bswap_esi,
    bswap_edi,
    // d0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // d8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // e0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // e8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // f0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // f8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\decoder\lds32tbl.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    lds32tbl.c

Abstract:
    
    Dispatch table for 32bit instructions with the LOCK prefix.

Author:

    23-Aug-1995 Ori Gershony (t-orig)

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "threadst.h"
#include "instr.h"
#include "decoderp.h"

#include "bytefns.h"
#include "dwordfns.h"
#include "miscfns.h"
#include "floatfns.h"

pfnDispatchInstruction LockDispatch32[256] = {
    // 0
    LOCKadd_m_r8,
    LOCKadd_m_r32,
    LOCKadd_r_m8,
    LOCKadd_r_m32,
    bad,
    bad,
    bad,
    bad,
    // 8
    LOCKor_m_r8,
    LOCKor_m_r32,
    LOCKor_r_m8,
    LOCKor_r_m32,
    bad,
    bad,
    bad,
    LOCKdispatch232,
    // 10
    LOCKadc_m_r8,
    LOCKadc_m_r32,
    LOCKadc_r_m8,
    LOCKadc_r_m32,
    bad,
    bad,
    bad,
    bad,
    // 18
    LOCKsbb_m_r8,
    LOCKsbb_m_r32,
    LOCKsbb_r_m8,
    LOCKsbb_r_m32,
    bad,
    bad,
    bad,
    bad,
    // 20
    LOCKand_m_r8,
    LOCKand_m_r32,
    LOCKand_r_m8,
    LOCKand_r_m32,
    bad,
    bad,
    bad,
    bad,
    // 28
    LOCKsub_m_r8,
    LOCKsub_m_r32,
    LOCKsub_r_m8,
    LOCKsub_r_m32,
    bad,
    bad,
    bad,
    bad,
    // 30
    LOCKxor_m_r8,
    LOCKxor_m_r32,
    LOCKxor_r_m8,
    LOCKxor_r_m32,
    bad,
    bad,
    bad,
    bad,
    // 38
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 40
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 48
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 50
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 58
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 60
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 68
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 70
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 78
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 80
    LOCKGROUP_18,
    LOCKGROUP_132,
    bad,
    LOCKGROUP_1WS32,
    bad,
    bad,
    xchg_r_m8,
    xchg_r_m32,
    // 88
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 90
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 98
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // a0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // a8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // b0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // b8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // c0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // c8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // d0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // d8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // e0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // e8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // f0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    LOCKGROUP_38,
    LOCKGROUP_332,
    // f8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    LOCKGROUP_532,
};


pfnDispatchInstruction LockDispatch232[256] = {
    // 0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 10
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 18
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 20
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 28
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 30
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 38
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 40
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 48
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 50
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 58
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 60
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 68
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 70
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 78
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 80
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 88
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 90
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 98
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // a0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // a8
    bad,
    bad,
    bad,
    LOCKbts_m_r32,
    bad,
    bad,
    bad,
    bad,
    // b0
    LOCKcmpxchg_m_r8,
    LOCKcmpxchg_m_r32,
    bad,
    LOCKbtr_m_r32,
    bad,
    bad,
    bad,
    bad,
    // b8
    bad,
    bad,
    LOCKGROUP_832,
    LOCKbtc_m_r32,
    bad,
    bad,
    bad,
    bad,
    // c0
    LOCKxadd_m_r8,
    LOCKxadd_m_r32,
    bad,
    bad,
    bad,
    bad,
    bad,
    LOCKcmpxchg8b,
    // c8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // d0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // d8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // e0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // e8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // f0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // f8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\decoder\lds16tbl.c ===
// Tables for DS: 32-bit instructions
//  (ie. no FS:, but DATA: specified)
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    lds16tbl.c

Abstract:
    
    Dispatch tables for instructions with DATA: override and the LOCK
    prefix.  It is used for both DS: and FS: overrides.

Author:

    23-Aug-1995 Ori Gershony (t-orig)

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "threadst.h"
#include "instr.h"
#include "decoderp.h"

#include "bytefns.h"
#include "wordfns.h"
#include "miscfns.h"
#include "floatfns.h"

pfnDispatchInstruction LockDispatch16[256] = {
    // 0
    LOCKadd_m_r8,
    LOCKadd_m_r16,
    LOCKadd_r_m8,
    LOCKadd_r_m16,
    bad,
    bad,
    bad,
    bad,
    // 8
    LOCKor_m_r8,
    LOCKor_m_r16,
    LOCKor_r_m8,
    LOCKor_r_m16,
    bad,
    bad,
    bad,
    LOCKdispatch216,
    // 10
    LOCKadc_m_r8,
    LOCKadc_m_r16,
    LOCKadc_r_m8,
    LOCKadc_r_m16,
    bad,
    bad,
    bad,
    bad,
    // 18
    LOCKsbb_m_r8,
    LOCKsbb_m_r16,
    LOCKsbb_r_m8,
    LOCKsbb_r_m16,
    bad,
    bad,
    bad,
    bad,
    // 20
    LOCKand_m_r8,
    LOCKand_m_r16,
    LOCKand_r_m8,
    LOCKand_r_m16,
    bad,
    bad,
    bad,
    bad,
    // 28
    LOCKsub_m_r8,
    LOCKsub_m_r16,
    LOCKsub_r_m8,
    LOCKsub_r_m16,
    bad,
    bad,
    bad,
    bad,
    // 30
    LOCKxor_m_r8,
    LOCKxor_m_r16,
    LOCKxor_r_m8,
    LOCKxor_r_m16,
    bad,
    bad,
    bad,
    bad,
    // 38
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 40
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 48
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 50
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 58
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 60
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 68
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 70
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 78
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 80
    LOCKGROUP_18,
    LOCKGROUP_116,
    bad,
    LOCKGROUP_1WS16,
    bad,
    bad,
    xchg_r_m8,
    xchg_r_m16,
    // 88
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 90
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 98
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // a0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // a8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // b0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // b8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // c0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // c8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // d0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // d8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // e0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // e8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // f0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    LOCKGROUP_38,
    LOCKGROUP_316,
    // f8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    LOCKGROUP_516,
};


pfnDispatchInstruction LockDispatch216[256] = {
    // 0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 10
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 18
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 20
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 28
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 30
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 38
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 40
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 48
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 50
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 58
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 60
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 68
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 70
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 78
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 80
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 88
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 90
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 98
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // a0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // a8
    bad,
    bad,
    bad,
    LOCKbts_m_r16,
    bad,
    bad,
    bad,
    bad,
    // b0
    LOCKcmpxchg_m_r8,
    LOCKcmpxchg_m_r16,
    bad,
    LOCKbtr_m_r16,
    bad,
    bad,
    bad,
    bad,
    // b8
    bad,
    bad,
    LOCKGROUP_816,
    LOCKbtc_m_r16,
    bad,
    bad,
    bad,
    bad,
    // c0
    LOCKxadd_m_r8,
    LOCKxadd_m_r16,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // c8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // d0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // d8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // e0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // e8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // f0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // f8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\decoder\floatfns.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    floatfns.c

Abstract:
    
    Floating point instruction decoder.

Author:

    16-Aug-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "threadst.h"
#include "instr.h"
#include "decoderp.h"

extern DWORD pfnNPXNPHandler;
extern BOOLEAN fUseNPXEM;

typedef float *PFLOAT;
typedef double *PDOUBLE;

typedef void (*pfnFrag0)(PCPUDATA);
typedef void (*pfnFrag1INT)(PCPUDATA, INT);
typedef void (*pfnFrag1FLOAT)(PCPUDATA, PFLOAT);
typedef void (*pfnFrag1DOUBLE)(PCPUDATA, PDOUBLE);
typedef void (*pfnFrag1PLONG)(PCPUDATA, PLONG);
typedef void (*pfnFrag2INTINT)(PCPUDATA, INT, INT);
typedef void (*pfnFrag1PUSHORT)(PCPUDATA, PUSHORT);

OPERATION GP0Mem[8] = {OP_FP_FADD32,
                           OP_FP_FMUL32,
                           OP_FP_FCOM32,
                           OP_FP_FCOMP32,
                           OP_FP_FSUB32,
                           OP_FP_FSUBR32,
                           OP_FP_FDIV32,
                           OP_FP_FDIVR32};


OPERATION GP0Top[8] = {OP_FP_FADD_ST_STi,
                         OP_FP_FMUL_ST_STi,
                         OP_FP_FCOM_STi,
                         OP_FP_FCOMP_STi,
                         OP_FP_FSUB_ST_STi,
                         OP_FP_FSUBR_ST_STi,
                         OP_FP_FDIV_ST_STi,
                         OP_FP_FDIVR_ST_STi};

OPERATION GP1GroupFCHS[8] = {OP_FP_FCHS,
                            OP_FP_FABS,
                            OP_BadInstruction,
                            OP_BadInstruction,
                            OP_FP_FTST,
                            OP_FP_FXAM,
                            OP_BadInstruction,
                            OP_BadInstruction};

OPERATION GP1GroupFLD1[8] = {OP_FP_FLD1,
                            OP_FP_FLDL2T,
                            OP_FP_FLDL2E,
                            OP_FP_FLDPI,
                            OP_FP_FLDLG2,
                            OP_FP_FLDLN2,
                            OP_FP_FLDZ,
                            OP_BadInstruction};

OPERATION GP1GroupF2XM1[8] = {OP_FP_F2XM1,
                             OP_FP_FYL2X,
                             OP_FP_FPTAN,
                             OP_FP_FPATAN,
                             OP_FP_FXTRACT,
                             OP_FP_FPREM1,
                             OP_FP_FDECSTP,
                             OP_FP_FINCSTP};

OPERATION GP1GroupFPREM[8] = {OP_FP_FPREM,
                             OP_FP_FYL2XP1,
                             OP_FP_FSQRT,
                             OP_FP_FSINCOS,
                             OP_FP_FRNDINT,
                             OP_FP_FSCALE,
                             OP_FP_FSIN,
                             OP_FP_FCOS};

OPERATION GP1Mem[8] = {OP_FP_FLD32,
                           OP_BadInstruction,        // never called
                           OP_FP_FST32,
                           OP_FP_FSTP32,
                           OP_FP_FLDENV,
                           OP_FP_FLDCW,
                           OP_FP_FNSTENV,
                           OP_FP_FNSTCW};

OPERATION GP2Mem[8] = {OP_FP_FIADD32,
                           OP_FP_FIMUL32,
                           OP_FP_FICOM32,
                           OP_FP_FICOMP32,
                           OP_FP_FISUB32,
                           OP_FP_FISUBR32,
                           OP_FP_FIDIV32,
                           OP_FP_FIDIVR32};

OPERATION GP4Mem[8] = {OP_FP_FADD64,
                            OP_FP_FMUL64,
                            OP_FP_FCOM64,
                            OP_FP_FCOMP64,
                            OP_FP_FSUB64,
                            OP_FP_FSUBR64,
                            OP_FP_FDIV64,
                            OP_FP_FDIVR64};

OPERATION GP4Reg[8] = {OP_FP_FADD_STi_ST,
                         OP_FP_FMUL_STi_ST,
                         OP_FP_FCOM_STi,
                         OP_FP_FCOMP_STi,
                         OP_FP_FSUB_STi_ST,
                         OP_FP_FSUBR_STi_ST,
                         OP_FP_FDIV_STi_ST,
                         OP_FP_FDIVR_STi_ST};

OPERATION GP5Mem[8] = {OP_FP_FLD64,
                        OP_BadInstruction,
                        OP_FP_FST64,
                        OP_FP_FSTP64,
                        OP_FP_FRSTOR,
                        OP_BadInstruction,
                        OP_FP_FNSAVE,
                        OP_FP_FNSTSW};

OPERATION GP5Reg[8] = {OP_FP_FFREE,
                         OP_FP_FXCH_STi,
                         OP_FP_FST_STi,
                         OP_FP_FSTP_STi,
                         OP_FP_FUCOM,
                         OP_FP_FUCOMP,
                         OP_BadInstruction,
                         OP_BadInstruction};

OPERATION GP6Mem[8] = {OP_FP_FIADD16,
                             OP_FP_FIMUL16,
                             OP_FP_FICOM16,
                             OP_FP_FICOMP16,
                             OP_FP_FISUB16,
                             OP_FP_FISUBR16,
                             OP_FP_FIDIV16,
                             OP_FP_FIDIVR16};

OPERATION GP6Reg[8] = {OP_FP_FADDP_STi_ST,
                         OP_FP_FMULP_STi_ST,
                         OP_FP_FCOMP_STi,
                         OP_FP_FCOMPP,
                         OP_FP_FSUBP_STi_ST,
                         OP_FP_FSUBRP_STi_ST,
                         OP_FP_FDIVP_STi_ST,
                         OP_FP_FDIVRP_STi_ST};

OPERATION GP7Mem[8] = {OP_FP_FILD16,
                             OP_BadInstruction,
                             OP_FP_FIST16,
                             OP_FP_FISTP16,
                             OP_FP_FBLD,
                             OP_FP_FILD64,
                             OP_FP_FBSTP,
                             OP_FP_FISTP64};

OPERATION GP7Reg[8] = {OP_FP_FFREE,     // not in Intel docs, but NTSD knows it
                         OP_FP_FXCH_STi,  // not in Intel docs, but NTSD knows it
                         OP_FP_FST_STi,
                         OP_FP_FSTP_STi,
                         OP_BadInstruction,
                         OP_BadInstruction,
                         OP_BadInstruction,
                         OP_BadInstruction};



//***************************************************************************


DISPATCH(FLOAT_GP0)     // d8 XX
{
    BYTE secondByte;

    secondByte = *((PBYTE)(eipTemp+1));

    if (secondByte < 0xc0) {
        // memory format

        int cbInstr = mod_rm_reg32(State, &Instr->Operand1, NULL);
        Instr->Operation = GP0Mem[(secondByte>>3) & 7];
        Instr->Size = cbInstr+1;
    } else {
        // register format

        Instr->Operation = GP0Top[(secondByte>>3) & 7];
        Instr->Operand1.Type = OPND_IMM;
        Instr->Operand1.Immed = secondByte & 7;
        Instr->Size = 2;
    }

    if (fUseNPXEM) {
        // generate a "CALL pfnNPXNPHandler" instruction, with a length
        // the same as the FP instruction we're emulating.
        Instr->Operation = OP_CTRL_UNCOND_Call;
        Instr->Operand1.Type = OPND_IMM;
        Instr->Operand1.Immed = pfnNPXNPHandler;        // dest of call
        Instr->Operand2.Type = OPND_IMM;
        Instr->Operand2.Immed = eipTemp;    // addr of FP instr
    }
}



DISPATCH(FLOAT_GP1)     // d9 XX
{
    BYTE secondByte, inst;

    secondByte = *((PBYTE)(eipTemp+1));
    inst = (secondByte>>3) & 7;

    if (secondByte < 0xc0) {
        // memory format

        if (inst == 1) {
            Instr->Operation = OP_BadInstruction;
        } else {
            int cbInstr = mod_rm_reg32(State, &Instr->Operand1, NULL);
            Instr->Operation = GP1Mem[(secondByte>>3) & 7];
            Instr->Size = cbInstr+1;
        }
    } else {
        // register format
        switch ( inst ) {
        case 0:                 // d9 c0+i
            Instr->Operation = OP_FP_FLD_STi;
            Instr->Operand1.Type = OPND_IMM;
            Instr->Operand1.Immed = secondByte & 7;
            break;
        case 1:                 // d9 c8+i
            Instr->Operation = OP_FP_FXCH_STi;
            Instr->Operand1.Type = OPND_IMM;
            Instr->Operand1.Immed = secondByte & 7;
            break;
        case 2:
            if (secondByte == 0xd0) {
                Instr->Operation = OP_FP_FNOP;          // FNOP  (d9 d0)
            } else {
                Instr->Operation = OP_BadInstruction;   // (d9 d1..d7)
            }
            break;
        case 3:                 // d9 d8+i
            Instr->Operation = OP_BadInstruction;
            //UNDONE: emstore.asm says FSTP Special Form 1
            break;
        case 4:                 // d9 e0+i
            Instr->Operation = GP1GroupFCHS[secondByte&7];
            break;
        case 5:
            Instr->Operation = GP1GroupFLD1[secondByte&7];
            break;
        case 6:
            Instr->Operation = GP1GroupF2XM1[secondByte&7];
            break;
        default:
        case 7:
            Instr->Operation = GP1GroupFPREM[secondByte&7];
            break;
        }
        Instr->Size = 2;
    }

    if (fUseNPXEM) {
        // generate a "CALL pfnNPXNPHandler" instruction, with a length
        // the same as the FP instruction we're emulating.
        Instr->Operation = OP_CTRL_UNCOND_Call;
        Instr->Operand1.Type = OPND_IMM;
        Instr->Operand1.Immed = pfnNPXNPHandler;
        Instr->Operand2.Type = OPND_IMM;
        Instr->Operand2.Immed = eipTemp;    // addr of FP instr
    }
}


DISPATCH(FLOAT_GP2)     // da XX
{
    BYTE secondByte;

    secondByte = *((PBYTE)(eipTemp+1));

    if (secondByte < 0xc0) {
        // memory format

        int cbInstr = mod_rm_reg32(State, &Instr->Operand1, NULL);
        Instr->Operation = GP2Mem[(secondByte>>3) & 7];
        Instr->Size = cbInstr+1;

    } else if (secondByte == 0xe9) {
        Instr->Operation = OP_FP_FUCOMPP;
        Instr->Size = 2;
    } else {
        Instr->Operation = OP_BadInstruction;
    }

    if (fUseNPXEM) {
        // generate a "CALL pfnNPXNPHandler" instruction, with a length
        // the same as the FP instruction we're emulating.
        Instr->Operation = OP_CTRL_UNCOND_Call;
        Instr->Operand1.Type = OPND_IMM;
        Instr->Operand1.Immed = pfnNPXNPHandler;
        Instr->Operand2.Type = OPND_IMM;
        Instr->Operand2.Immed = eipTemp;    // addr of FP instr
    }
}


DISPATCH(FLOAT_GP3)     // db XX
{
    BYTE secondByte;

    secondByte = *((PBYTE)(eipTemp+1));

    if (secondByte < 0xc0) {
        // memory format
        int cbInstr = mod_rm_reg32(State, &Instr->Operand1, NULL);

        switch ((secondByte>>3) & 7) {
        case 0:
            Instr->Operation = OP_FP_FILD32;
            break;
        case 1:
        case 4:
        case 6:
            Instr->Operation = OP_BadInstruction;
            break;
        case 2:
            Instr->Operation = OP_FP_FIST32;
            break;
        case 3:
            Instr->Operation = OP_FP_FISTP32;
            break;
        case 5:
            Instr->Operation = OP_FP_FLD80;
            break;
        case 7:
            Instr->Operation = OP_FP_FSTP80;
            break;
        }
        Instr->Size = cbInstr+1;
    } else {
        Instr->Size = 2;

        if (secondByte == 0xe2) {
            Instr->Operation = OP_FP_FNCLEX;
        } else if (secondByte == 0xe3) {
            Instr->Operation = OP_FP_FNINIT;
        } else {
            Instr->Operation = OP_FP_FNOP;  // FDISI, FENI, FSETPM are 2-byte FNOPs
        }
    }

    if (fUseNPXEM) {
        // generate a "CALL pfnNPXNPHandler" instruction, with a length
        // the same as the FP instruction we're emulating.
        Instr->Operation = OP_CTRL_UNCOND_Call;
        Instr->Operand1.Type = OPND_IMM;
        Instr->Operand1.Immed = pfnNPXNPHandler;
        Instr->Operand2.Type = OPND_IMM;
        Instr->Operand2.Immed = eipTemp;    // addr of FP instr
    }
}



DISPATCH(FLOAT_GP4)     // dc XX
{
    BYTE secondByte;

    secondByte = *((PBYTE)(eipTemp+1));

    if (secondByte < 0xc0) {
        // memory format

        int cbInstr = mod_rm_reg32(State, &Instr->Operand1, NULL);
        Instr->Operation = GP4Mem[(secondByte>>3) & 7];
        Instr->Size = cbInstr+1;
    } else {
        // register format - "OP ST(i)"

        Instr->Operation = GP4Reg[(secondByte>>3) & 7];
        Instr->Operand1.Type = OPND_IMM;
        Instr->Operand1.Immed = secondByte & 7;
        Instr->Size = 2;
    }

    if (fUseNPXEM) {
        // generate a "CALL pfnNPXNPHandler" instruction, with a length
        // the same as the FP instruction we're emulating.
        Instr->Operation = OP_CTRL_UNCOND_Call;
        Instr->Operand1.Type = OPND_IMM;
        Instr->Operand1.Immed = pfnNPXNPHandler;
        Instr->Operand2.Type = OPND_IMM;
        Instr->Operand2.Immed = eipTemp;    // addr of FP instr
    }
}


DISPATCH(FLOAT_GP5)     // dd XX
{
    BYTE secondByte;

    secondByte = *((PBYTE)(eipTemp+1));

    if (secondByte < 0xc0) {
        // memory format

        int cbInstr = mod_rm_reg32(State, &Instr->Operand1, NULL);
        Instr->Operation = GP5Mem[(secondByte>>3)&7];
        Instr->Size = cbInstr+1;
    } else {
        // register format "OP ST(i)"

        Instr->Operation = GP5Reg[(secondByte>>3)&7];
        Instr->Operand1.Type = OPND_IMM;
        Instr->Operand1.Immed = secondByte & 7;
        Instr->Size = 2;
    }

    if (fUseNPXEM) {
        // generate a "CALL pfnNPXNPHandler" instruction, with a length
        // the same as the FP instruction we're emulating.
        Instr->Operation = OP_CTRL_UNCOND_Call;
        Instr->Operand1.Type = OPND_IMM;
        Instr->Operand1.Immed = pfnNPXNPHandler;
        Instr->Operand2.Type = OPND_IMM;
        Instr->Operand2.Immed = eipTemp;    // addr of FP instr
    }
}


DISPATCH(FLOAT_GP6)     // de XX
{
    BYTE secondByte, inst;

    secondByte = *((PBYTE)(eipTemp+1));
    inst = (secondByte>>3) & 7;

    if (secondByte < 0xc0) {
        // memory format

        int cbInstr = mod_rm_reg32(State, &Instr->Operand1, NULL);
        Instr->Operation = GP6Mem[(secondByte>>3)&7];
        Instr->Size = cbInstr+1;
    } else {
        // register format

        if (inst == 3 && secondByte != 0xd9) {
            Instr->Operation = OP_BadInstruction;
        } else {
            Instr->Operation = GP6Reg[inst];
            Instr->Operand1.Type = OPND_IMM;
            Instr->Operand1.Immed = secondByte & 7;
            Instr->Size = 2;
        }
    }

    if (fUseNPXEM) {
        // generate a "CALL pfnNPXNPHandler" instruction, with a length
        // the same as the FP instruction we're emulating.
        Instr->Operation = OP_CTRL_UNCOND_Call;
        Instr->Operand1.Type = OPND_IMM;
        Instr->Operand1.Immed = pfnNPXNPHandler;
        Instr->Operand2.Type = OPND_IMM;
        Instr->Operand2.Immed = eipTemp;    // addr of FP instr
    }
}


DISPATCH(FLOAT_GP7)     // df XX
{
    BYTE secondByte, inst;

    secondByte = *((PBYTE)(eipTemp+1));
    inst = (secondByte>>3) & 7;

    if (secondByte < 0xc0) {
        // memory format

        int cbInstr = mod_rm_reg32(State, &Instr->Operand1, NULL);
        Instr->Operation = GP7Mem[(secondByte>>3)&7];
        Instr->Size = cbInstr+1;
    } else {
        // register format
        if (inst == 4) {
            Instr->Operation = OP_FP_FNSTSW;
            Instr->Operand1.Type = OPND_REGREF;
            Instr->Operand1.Reg = GP_AX;
        } else {
            Instr->Operation = GP7Reg[inst];
            Instr->Operand1.Type = OPND_IMM;
            Instr->Operand1.Immed = secondByte & 7;
        }
        Instr->Size = 2;
    }

    if (fUseNPXEM) {
        // generate a "CALL pfnNPXNPHandler" instruction, with a length
        // the same as the FP instruction we're emulating.
        Instr->Operation = OP_CTRL_UNCOND_Call;
        Instr->Operand1.Type = OPND_IMM;
        Instr->Operand1.Immed = pfnNPXNPHandler;
        Instr->Operand2.Type = OPND_IMM;
        Instr->Operand2.Immed = eipTemp;    // addr of FP instr
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\decoder\dwordfns.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    dwordfns.c

Abstract:
    
    Instuctions which operate on 32-bit DWORDS

Author:

    29-Jun-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "cpuassrt.h"
#include "threadst.h"
#include "instr.h"
#include "decoderp.h"
#include "dwordfns.h"

ASSERTNAME;

// set up to include common functions
#define GET_REG 	    get_reg32
#define MANGLENAME(x)       x ## 32
#define MSB		    0x80000000
#define MOD_RM              mod_rm_reg32
#define UTYPE		    unsigned long
#define STYPE		    signed long
#define GET_VAL 	    GET_LONG
#define PUT_VAL 	    PUT_LONG
#define PUSH_VAL	    PUSH_LONG
#define POP_VAL 	    POP_LONG
#define OPNAME(x)           OP_ ## x ## 32
#define LOCKOPNAME(x)       OP_SynchLock ## x ## 32
#define DISPATCHCOMMON(fn)  DISPATCH(fn ## 32)
#define CALLFRAGCOMMON0(fn)            CALLFRAG0( fn ## 32 )
#define CALLFRAGCOMMON1(fn, pop1)      CALLFRAG1( fn ## 32 , pop1)
#define CALLFRAGCOMMON2(fn, pop1, op2) CALLFRAG2( fn ## 32 , pop1, op2)
#define AREG                GP_EAX
#define BREG                GP_EBX
#define CREG                GP_ECX
#define DREG                GP_EDX
#define SPREG               GP_ESP
#define BPREG               GP_EBP
#define SIREG               GP_ESI
#define DIREG               GP_EDI
#define DEREF(Op)           DEREF32(Op)

// include the common functions with 8/16/32 flavors
#include "common.c"

// include the common functions with 16/32 flavors
#include "comm1632.c"

// create the mod_rm_reg32() decoder function
#define MOD11_RM000         GP_EAX
#define MOD11_RM001         GP_ECX
#define MOD11_RM010         GP_EDX
#define MOD11_RM011         GP_EBX
#define MOD11_RM100         GP_ESP
#define MOD11_RM101         GP_EBP
#define MOD11_RM110         GP_ESI
#define MOD11_RM111         GP_EDI
#define REG000              GP_EAX
#define REG001              GP_ECX
#define REG010              GP_EDX
#define REG011              GP_EBX
#define REG100              GP_ESP
#define REG101              GP_EBP
#define REG110              GP_ESI
#define REG111              GP_EDI
#define MOD_RM_DECODER      mod_rm_reg32
#include "modrm.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\decoder\miscfns.c ===
/*++

Copyright (c) 1996-1998 Microsoft Corporation

Module Name:

    miscfns.c

Abstract:
    
    Miscellaneous instuctions

Author:

    29-Jun-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "wx86.h"
#include "cpuassrt.h"
#include "threadst.h"
#include "instr.h"
#include "decoderp.h"

ASSERTNAME;

// table used by ProcessPrefixes
pfnDispatchInstruction *DispatchTables[4] = { Dispatch32, Dispatch16, LockDispatch32, LockDispatch16 };


// ---------------- single-byte functions -------------------------------
DISPATCH(ProcessPrefixes)
{
    int DataPrefix = 0;
    int LockPrefix = 0;
    int cbInstr = 0;

    for (;;) {
	switch (*(PBYTE)(eipTemp)) {
        case 0x64:          // fs:
            Instr->FsOverride = TRUE;
	    break;

	case 0xf3:	    // repz
            State->RepPrefix = PREFIX_REPZ;
	    break;

	case 0xf2:	    // repnz
            State->RepPrefix = PREFIX_REPNZ;
	    break;

	case 0xf0:	    // lock
            LockPrefix = 2;  // The lock tables are in locations 2 and 3 DispatchTables
	    break;

	case 0x2e:	    // cs:
	case 0x36:	    // ss:
	case 0x3e:	    // ds:
	case 0x26:	    // es:
        case 0x65:          // gs:
            Instr->FsOverride = FALSE;
	    break;

	case 0x66:	    // data
	    DataPrefix = 1;
	    break;

        case 0x67:          // adr
            State->AdrPrefix=TRUE;
	    break;

	default:
	    // No more prefixes found.	Set up dispatch tables based on
	    // the prefixes seen.

	    // Decode and execute the actual instruction
            ((DispatchTables[DataPrefix+LockPrefix])[GET_BYTE(eipTemp)])(State, Instr);

            // Adjust the Intel instruction size by the number of prefixes
            Instr->Size += cbInstr;

#if DBG
            // Ensure that if we saw an ADR: prefix, the decoder had code
            // to handle the prefix.  In the checked build, all functions which
            // handle the ADR: prefix clear State->AdrPrefix.
            if (State->AdrPrefix) {
                LOGPRINT((TRACELOG, "CPU Decoder: An unsupported instruction had an ADR: prefix.\r\n"
                        "Instruction Address = 0x%x.  Ignoring ADR: - this address may be data\r\n",
                        Instr->IntelAddress
                       ));
            }
#endif
            State->AdrPrefix = FALSE;

            // return to the decoder
	    return;
	}
        eipTemp++;
        cbInstr++;
    }
}
DISPATCH(bad)
{
    BAD_INSTR;
}
DISPATCH(privileged)
{
    PRIVILEGED_INSTR;
}
DISPATCH(push_es)
{
    Instr->Operation = OP_PushEs;
}
DISPATCH(pop_es)
{
    Instr->Operation = OP_PopEs;
}
DISPATCH(push_cs)
{
    Instr->Operation = OP_PushCs;
}
DISPATCH(aas)
{
    Instr->Operation = OP_Aas;
}
DISPATCH(push_ss)
{
    Instr->Operation = OP_PushSs;
}
DISPATCH(pop_ss)
{
    Instr->Operation = OP_PopSs;
}
DISPATCH(push_ds)
{
    Instr->Operation = OP_PushDs;
}
DISPATCH(pop_ds)
{
    Instr->Operation = OP_PopDs;
}
DISPATCH(daa)
{
    Instr->Operation = OP_Daa;
}
DISPATCH(das)
{
    Instr->Operation = OP_Das;
}
DISPATCH(aaa)
{
    Instr->Operation = OP_Aaa;
}
DISPATCH(aad_ib)
{
    Instr->Operation = OP_Aad;
    Instr->Operand1.Type = OPND_IMM;
    Instr->Operand1.Immed = GET_BYTE(eipTemp+1);
    Instr->Size = 2;
}
DISPATCH(imul_rw_m_iw16) // reg16 = rm16 * immediate word
{
    int cbInstr = mod_rm_reg16(State, &Instr->Operand2, &Instr->Operand1);

    Instr->Operation = OP_Imul3Arg16;
    DEREF16(Instr->Operand2);
    Instr->Operand3.Type = OPND_IMM;
    Instr->Operand3.Immed = GET_SHORT(eipTemp+1+cbInstr);
    Instr->Size = 3+cbInstr;
}
DISPATCH(imul_rw_m_iw32)
{
    int cbInstr = mod_rm_reg32(State, &Instr->Operand2, &Instr->Operand1);

    Instr->Operation = OP_Imul3Arg32;
    DEREF32(Instr->Operand2);
    Instr->Operand3.Type = OPND_IMM;
    Instr->Operand3.Immed = GET_LONG(eipTemp+1+cbInstr);
    Instr->Size = 5+cbInstr;
}
DISPATCH(imul_rw_m_ib16) // reg16 = rm16 * sign-extended immediate byte
{
    int cbInstr = mod_rm_reg16(State, &Instr->Operand2, &Instr->Operand1);

    Instr->Operation = OP_Imul3Arg16;
    DEREF16(Instr->Operand2);
    Instr->Operand3.Type = OPND_IMM;
    Instr->Operand3.Immed = (DWORD)(short)(char)GET_BYTE(eipTemp+1+cbInstr);
    Instr->Size = 2+cbInstr;
}
DISPATCH(imul_rw_m_ib32)	// reg32 = rm32 * sign-extended immediate byte
{
    int cbInstr = mod_rm_reg32(State, &Instr->Operand2, &Instr->Operand1);

    Instr->Operation = OP_Imul3Arg32;
    DEREF32(Instr->Operand2);
    Instr->Operand3.Type = OPND_IMM;
    Instr->Operand3.Immed = (DWORD)(long)(char)GET_BYTE(eipTemp+1+cbInstr);
    Instr->Size = 2+cbInstr;
}
DISPATCH(mov_mw_seg)
{
    int cbInstr = mod_rm_reg16(State, &Instr->Operand1, NULL);
    get_segreg(State, &Instr->Operand2);

    Instr->Operation = OP_Mov16;
    Instr->Size = cbInstr+1;
}
DISPATCH(mov_seg_mw)
{
    int cbInstr = mod_rm_reg16(State, &Instr->Operand2, NULL);
    get_segreg(State, &Instr->Operand1);

    Instr->Operation = OP_Mov16;
    DEREF16(Instr->Operand2);
    CPUASSERT(Instr->Operand1.Type == OPND_REGVALUE);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Size = cbInstr+1;
}
DISPATCH(nop)
{
    Instr->Operation = OP_Nop;
}
DISPATCH(call_md)
{
    Instr->Operation = OP_CTRL_UNCOND_Callf;
    Instr->Operand1.Type = OPND_IMM;
    Instr->Operand1.Immed = eipTemp+1;
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = eipTemp+sizeof(ULONG)+sizeof(USHORT)+1;
    Instr->Size = sizeof(ULONG)+sizeof(USHORT)+1;
}
DISPATCH(sahf)
{
    Instr->Operation = OP_Sahf;
}
DISPATCH(lahf)
{
    Instr->Operation = OP_Lahf;
}
DISPATCH(mov_ah_ib)
{
    Instr->Operation = OP_Mov8;
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = GP_AH;
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = GET_BYTE(eipTemp+1);
    Instr->Size = 2;
}
DISPATCH(mov_ch_ib)
{
    Instr->Operation = OP_Mov8;
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = GP_CH;
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = GET_BYTE(eipTemp+1);
    Instr->Size = 2;
}
DISPATCH(mov_dh_ib)
{
    Instr->Operation = OP_Mov8;
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = GP_DH;
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = GET_BYTE(eipTemp+1);
    Instr->Size = 2;
}
DISPATCH(mov_bh_ib)
{
    Instr->Operation = OP_Mov8;
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = GP_BH;
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = GET_BYTE(eipTemp+1);
    Instr->Size = 2;
}
DISPATCH(int3)
{
    Instr->Operation = OP_Int;
}
DISPATCH(int_ib)
{
    Instr->Operation = OP_Int;
    Instr->Size = 2;
}
DISPATCH(into)
{
    Instr->Operation = OP_IntO;
}
DISPATCH(iret)
{
    Instr->Operation = OP_CTRL_INDIR_IRet;
}
DISPATCH(aam_ib)
{
    Instr->Operation = OP_Aam;
    Instr->Operand1.Type = OPND_IMM;
    Instr->Operand1.Immed = GET_BYTE(eipTemp+1);
    Instr->Size = 2;
}
DISPATCH(xlat)
{
    Instr->Operation = OP_Xlat;
}
DISPATCH(jmpf_md)
{
    Instr->Operation = OP_CTRL_UNCOND_Jmpf;
    Instr->Operand1.Type = OPND_IMM;
    Instr->Operand1.Immed = eipTemp+1;
    Instr->Size = 7;
}
DISPATCH(jmp_jb)
{
    Instr->Operand1.Type = OPND_NOCODEGEN;
    if (State->AdrPrefix) {
        Instr->Operand1.Immed = MAKELONG((short)(char)GET_BYTE(eipTemp+1)+2+(short)LOWORD(eipTemp), HIWORD(eipTemp));
#if DBG
        State->AdrPrefix = FALSE;
#endif
    } else {
        Instr->Operand1.Immed = (DWORD)(long)(char)GET_BYTE(eipTemp+1)+2+eipTemp;
    }
    if (Instr->Operand1.Immed > eipTemp) {
        Instr->Operation = OP_CTRL_UNCOND_JmpFwd;
    } else {
        Instr->Operation = OP_CTRL_UNCOND_Jmp;
    }
    Instr->Size = 2;
}
DISPATCH(cmc)
{
    Instr->Operation = OP_Cmc;
}
DISPATCH(clc)
{
    Instr->Operation = OP_Clc;
}
DISPATCH(stc)
{
    Instr->Operation = OP_Stc;
}
DISPATCH(cld)
{
    Instr->Operation = OP_Cld;
}
DISPATCH(std)
{
    Instr->Operation = OP_Std;
}
DISPATCH(GROUP_4)
{
    int cbInstr = mod_rm_reg8(State, &Instr->Operand1, NULL);
    BYTE g = GET_BYTE(eipTemp+1);

    switch ((g >> 3) & 0x07) {
    case 0: // inc modrmB
        Instr->Operation = OP_Inc8;
        Instr->Size = 1+cbInstr;
	break;
    case 1: // dec modrmB
        Instr->Operation = OP_Dec8;
        Instr->Size = 1+cbInstr;
        break;
    default:
	BAD_INSTR;
    }
}



//-------- double-byte functions -----------------------------------------------



DISPATCH(GROUP_6)
{
    BYTE g = GET_BYTE(eipTemp+1);
    int cbInstr;

    switch ((g >> 3) & 0x07) {
    case 0: // sldt modrmw
    case 1: // str modrmw
    case 2: // lldt modrmw
    case 3: // ltr modrmw
        PRIVILEGED_INSTR;
        break;

    case 4: // verr modrmw
        cbInstr = mod_rm_reg16(State, &Instr->Operand1, NULL);
        Instr->Operation = OP_Verr;
        Instr->Size = 2+cbInstr;
        break;

    case 5: // verw modrmw
        cbInstr = mod_rm_reg16(State, &Instr->Operand1, NULL);
        Instr->Operation = OP_Verw;
        Instr->Size = 2+cbInstr;
        break;

    default:
	BAD_INSTR;	// bad
    }
}
DISPATCH(GROUP_7)
{
    BYTE g = GET_BYTE(eipTemp+1);
    int cbInstr;

    switch ((g >> 3) & 0x07) {
    case 0: // sgdt modrmw
    case 1: // sidt modrmw
    case 2: // lgdt modrmw
    case 3: // lidt modrmw
    case 6: // lmsw modrmw
        PRIVILEGED_INSTR;
        break;

    case 4: // smsw modrmw
        cbInstr = mod_rm_reg16(State, &Instr->Operand1, NULL);
        Instr->Operation = OP_Smsw;
        Instr->Size = 2+cbInstr;
        break;

    case 5: // bad
    case 7: // bad
	BAD_INSTR;
    }
}
DISPATCH(seto_modrmb)
{
    int cbInstr = mod_rm_reg8(State, &Instr->Operand1, NULL);

    Instr->Operation = OP_Seto;
    Instr->Size = 2+cbInstr;
}
DISPATCH(setno_modrmb)
{
    int cbInstr = mod_rm_reg8(State, &Instr->Operand1, NULL);

    Instr->Operation = OP_Setno;
    Instr->Size = 2+cbInstr;
}
DISPATCH(setb_modrmb)
{
    int cbInstr = mod_rm_reg8(State, &Instr->Operand1, NULL);

    Instr->Operation = OP_Setb;
    Instr->Size = 2+cbInstr;
}
DISPATCH(setae_modrmb)
{
    int cbInstr = mod_rm_reg8(State, &Instr->Operand1, NULL);

    Instr->Operation = OP_Setae;
    Instr->Size = 2+cbInstr;
}
DISPATCH(sete_modrmb)
{
    int cbInstr = mod_rm_reg8(State, &Instr->Operand1, NULL);

    Instr->Operation = OP_Sete;
    Instr->Size = 2+cbInstr;
}
DISPATCH(setne_modrmb)
{
    int cbInstr = mod_rm_reg8(State, &Instr->Operand1, NULL);

    Instr->Operation = OP_Setne;
    Instr->Size = 2+cbInstr;
}
DISPATCH(setbe_modrmb)
{
    int cbInstr = mod_rm_reg8(State, &Instr->Operand1, NULL);

    Instr->Operation = OP_Setbe;
    Instr->Size = 2+cbInstr;
}
DISPATCH(seta_modrmb)
{
    int cbInstr = mod_rm_reg8(State, &Instr->Operand1, NULL);

    Instr->Operation = OP_Seta;
    Instr->Size = 2+cbInstr;
}
DISPATCH(sets_modrmb)
{
    int cbInstr = mod_rm_reg8(State, &Instr->Operand1, NULL);

    Instr->Operation = OP_Sets;
    Instr->Size = 2+cbInstr;
}
DISPATCH(setns_modrmb)
{
    int cbInstr = mod_rm_reg8(State, &Instr->Operand1, NULL);

    Instr->Operation = OP_Setns;
    Instr->Size = 2+cbInstr;
}
DISPATCH(setp_modrmb)
{
    int cbInstr = mod_rm_reg8(State, &Instr->Operand1, NULL);

    Instr->Operation = OP_Setp;
    Instr->Size = 2+cbInstr;
}
DISPATCH(setnp_modrmb)
{
    int cbInstr = mod_rm_reg8(State, &Instr->Operand1, NULL);

    Instr->Operation = OP_Setnp;
    Instr->Size = 2+cbInstr;
}
DISPATCH(setl_modrmb)
{
    int cbInstr = mod_rm_reg8(State, &Instr->Operand1, NULL);

    Instr->Operation = OP_Setl;
    Instr->Size = 2+cbInstr;
}
DISPATCH(setge_modrmb)
{
    int cbInstr = mod_rm_reg8(State, &Instr->Operand1, NULL);

    Instr->Operation = OP_Setge;
    Instr->Size = 2+cbInstr;
}
DISPATCH(setle_modrmb)
{
    int cbInstr = mod_rm_reg8(State, &Instr->Operand1, NULL);

    Instr->Operation = OP_Setle;
    Instr->Size = 2+cbInstr;
}
DISPATCH(setg_modrmb)
{
    int cbInstr = mod_rm_reg8(State, &Instr->Operand1, NULL);

    Instr->Operation = OP_Setg;
    Instr->Size = 2+cbInstr;
}
DISPATCH(push_fs)
{
    Instr->Operation = OP_PushFs;
    Instr->Size = 2;
}
DISPATCH(pop_fs)
{
    Instr->Operation = OP_PopFs;
    Instr->Size = 2;
}
DISPATCH(push_gs)
{
    Instr->Operation = OP_PushGs;
    Instr->Size = 2;
}
DISPATCH(pop_gs)
{
    Instr->Operation = OP_PopGs;
    Instr->Size = 2;
}
DISPATCH(imul_regw_modrmw16) // reg16 = reg16 * mod/rm
{
    int cbInstr = mod_rm_reg16(State, &Instr->Operand2, &Instr->Operand1);

    Instr->Operation = OP_Imul16;
    DEREF32(Instr->Operand2);
    Instr->Size = 2+cbInstr;

}
DISPATCH(imul_regw_modrmw32) // reg32 = reg32 * mod/rm
{
    int cbInstr = mod_rm_reg32(State, &Instr->Operand2, &Instr->Operand1);

    Instr->Operation = OP_Imul32;
    DEREF32(Instr->Operand2);
    Instr->Size = 2+cbInstr;
}
DISPATCH(movzx_regw_modrmw)
{
    int cbInstr = mod_rm_reg16(State, &Instr->Operand1, NULL);

    DEREF16(Instr->Operand1);
    Instr->Operation = OP_Movzx16To32;
    Instr->Operand2.Type = OPND_NOCODEGEN;
    Instr->Operand2.Reg = get_reg32(State);
    Instr->Size = 2+cbInstr;
}
DISPATCH(movsx_regw_modrmw)
{
    int cbInstr = mod_rm_reg16(State, &Instr->Operand1, NULL);
    
    DEREF16(Instr->Operand1);
    Instr->Operation = OP_Movsx16To32;
    Instr->Operand2.Type = OPND_NOCODEGEN;
    Instr->Operand2.Reg = get_reg32(State);
    Instr->Size = 2+cbInstr;
}
DISPATCH(wait)
{
    Instr->Operation = OP_Wait;
}
DISPATCH(bswap_eax)
{
    Instr->Operation = OP_Bswap32;
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = GP_EAX;
    Instr->Size = 2;
}
DISPATCH(bswap_ebx)
{
    Instr->Operation = OP_Bswap32;
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = GP_EBX;
    Instr->Size = 2;
}
DISPATCH(bswap_ecx)
{
    Instr->Operation = OP_Bswap32;
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = GP_ECX;
    Instr->Size = 2;
}
DISPATCH(bswap_edx)
{
    Instr->Operation = OP_Bswap32;
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = GP_EDX;
    Instr->Size = 2;
}
DISPATCH(bswap_esp)
{
    Instr->Operation = OP_Bswap32;
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = GP_ESP;
    Instr->Size = 2;
}
DISPATCH(bswap_ebp)
{
    Instr->Operation = OP_Bswap32;
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = GP_EBP;
    Instr->Size = 2;
}
DISPATCH(bswap_esi)
{
    Instr->Operation = OP_Bswap32;
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = GP_ESI;
    Instr->Size = 2;
}
DISPATCH(bswap_edi)
{
    Instr->Operation = OP_Bswap32;
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = GP_EDI;
    Instr->Size = 2;
}
DISPATCH(arpl)
{
    int cbInstr = mod_rm_reg16(State, &Instr->Operand1, &Instr->Operand2);

    Instr->Operation = OP_Arpl;
    CPUASSERT(Instr->Operand2.Type == OPND_REGREF);
    Instr->Operand2.Type = OPND_REGVALUE;
    Instr->Size = 1+cbInstr;
}
DISPATCH(cpuid)
{
    Instr->Operation = OP_CPUID;
    Instr->Size = 2;
}
DISPATCH(rdtsc)
{
    Instr->Operation = OP_Rdtsc;
    Instr->Size = 2;
}
DISPATCH(cmpxchg8b)
{
    int cbInstr = mod_rm_reg32(State, &Instr->Operand1, &Instr->Operand2);

    Instr->Operation = OP_CMPXCHG8B;
    Instr->Size = 2+cbInstr;
}
DISPATCH(LOCKcmpxchg8b)
{
    int cbInstr = mod_rm_reg32(State, &Instr->Operand1, &Instr->Operand2);

    Instr->Operation = OP_SynchLockCMPXCHG8B;
    Instr->Size = 2+cbInstr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\entrypt\epalloc.c ===
/*++
                                                                                
Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    epalloc.c

Abstract:
    
    This module allocates memory for the entry point structures
    
Author:

    21-Aug-1995 Ori Gershony (t-orig)

Revision History:

        24-Aug-1999 [askhalid] copied from 32-bit wx86 directory and make work for 64bit.

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "wx86.h"
#include "cpuassrt.h"
#include "config.h"
#include "entrypt.h"

ASSERTNAME;

PVOID allocBase;        // Base of the allocation unit
PVOID commitLimit;      // Top of commited memory
PVOID allocLimit;       // Top of memory allocated to the user

#if DBG
#define EPTRASHVALUE    0x0b
#endif

INT
initEPAlloc(
    VOID
    )
/*++

Routine Description:

    Initializes the entry point memory allocator

Arguments:

    none

Return Value:

    return-value - non-zero for success, 0 for failure

--*/
{
    NTSTATUS Status;
    ULONGLONG ReserveSize = CpuEntryPointReserve;


    Status = NtAllocateVirtualMemory(NtCurrentProcess(),
                                     &allocBase,
                                     0,
                                     &ReserveSize,
                                     MEM_RESERVE,
                                     PAGE_READWRITE
                                     );
    if (!NT_SUCCESS(Status)) {
        return 0;
    }

    // No memory is commited yet, nor is any allocated to the user

    allocLimit = commitLimit = allocBase;

    return (INT)(LONGLONG)allocBase;  
}


VOID
termEPAlloc(
    VOID
    )
/*++

Routine Description:

    Frees the memory used the the allocator.  This should only be
    called before the process is terminated.

Arguments:

    none

Return Value:

    return-value - none

--*/
{
    ULONGLONG ReserveSize = CpuEntryPointReserve;

    NtFreeVirtualMemory(NtCurrentProcess(),
                        &allocBase,
                        &ReserveSize,
                        MEM_RELEASE
                       );
}


BOOLEAN
commitMemory(
    LONG CommitDiff
    )
/*++

Routine Description:

    This routine tries to commit memory for use by the allocator.  If there
    is no more memory left, is fails and returns with zero.  Else it returns
    1 for success.  This is an internal function for use by the allocator
    only.

Arguments:

    none

Return Value:

    return-value - TRUE for success, FALSE for failure

--*/
{
    LONG CommitSize;
    DWORD i;
    LONGLONG TempCommitDiff = CommitDiff;

    for (i=0; i<CpuMaxAllocRetries; ++i) {
        NTSTATUS Status;
        LARGE_INTEGER Timeout;

        //
        // Try to allocate more memory
        //
        if ((LONG)(ULONGLONG)commitLimit + CommitDiff -(LONG)(ULONGLONG)allocBase > (LONG)(ULONGLONG)CpuEntryPointReserve) {
            //
            // The commit would extend pase the reserve.  Fail the
            // alloc, which will cause a cache/entrypoint flush.
            //
            return FALSE;
        }
        Status = NtAllocateVirtualMemory(NtCurrentProcess(),
                                         &commitLimit,
                                         0,
                                         &TempCommitDiff,
                                         MEM_COMMIT,
                                         PAGE_READWRITE
                                        );
        if (NT_SUCCESS(Status)) {
            //
            // Allocation succeeded.  Move commitLimit up and return success
            //
#if DBG
            RtlFillMemory(commitLimit, TempCommitDiff, EPTRASHVALUE);
#endif
            commitLimit = (PVOID) ((ULONG)(ULONGLONG)commitLimit + TempCommitDiff);
            return TRUE;
        }

        //
        // No pages available.  Sleep a bit and hope another thread frees a
        // page.
        //
        Timeout.QuadPart = (LONGLONG)CpuWaitForMemoryTime * -10000i64;
        NtDelayExecution(FALSE, &Timeout);
    }

    //
    // No pages available.  Return failure.  Caller will attempt to free
    // some pages and retry the EPAlloc call.
    return FALSE;
}


PVOID
EPAlloc(
    DWORD cb
    )
/*++

Routine Description:

    This routine allocated memory for use by the entry point module.

Arguments:

    cb - count of bytes to allocate from the entrypoint memory.

Return Value:

    return-value - The memory allocated if succeeded, NULL otherwise

--*/
{
    PVOID newAllocLimit, oldAllocLimit;
    LONG CommitDiff;

    

    CPUASSERTMSG(allocLimit == commitLimit || *(PBYTE)allocLimit == EPTRASHVALUE, "Entrypoint memory overrun");

    // Calculate new allocation limit
    oldAllocLimit = allocLimit;
    newAllocLimit = (PVOID) ((ULONG)(ULONGLONG)oldAllocLimit + cb);

    // See if we need to commit more memory
    CommitDiff = (LONG)(ULONGLONG)newAllocLimit - (LONG)(ULONGLONG)commitLimit;
    if (CommitDiff > 0){
        // Yes we do, so try to commit more memory
        if (!commitMemory(CommitDiff)){
            // Cannot commit more memory, so return failure
            return NULL;
        }
    }

    allocLimit = newAllocLimit;
    return oldAllocLimit;
}


VOID
EPFree(
    VOID
    )
/*++

Routine Description:

    This routine frees all entry point memory allocated so far

Arguments:

    none

Return Value:

    none

--*/
{
#if DBG
    //
    // Fill the committed space with a known value to make
    // debugging easier
    //
    RtlFillMemory(allocBase, (ULONG)(ULONGLONG)allocLimit-(ULONG)(ULONGLONG)allocBase, EPTRASHVALUE);
#endif
    allocLimit = allocBase;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\decoder\wordfns.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    wordfns.h

Abstract:
    
    Prototypes for instructions which operate on 16-bit WORDS.

Author:

    06-Jun-1995 BarryBo, Created

Revision History:

--*/

#ifndef WORDFNS_H
#define WORDFNS_H

#define DISPATCHCOMMON(x) DISPATCH(x ## 16)
#include "common.h"
#include "comm1632.h"
#undef DISPATCHCOMMON

#endif //WORDFNS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\decoder\miscfns.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    miscfns.h

Abstract:
    
    Prototypes for miscellaneous instructions.

Author:

    06-Jun-1995 BarryBo, Created

Revision History:

--*/

#ifndef MISCFNS_H
#define MISCFNS_H

DISPATCH(ProcessPrefixes);
DISPATCH(bad);
DISPATCH(privileged);
DISPATCH(push_es);
DISPATCH(pop_es);
DISPATCH(push_cs);
DISPATCH(aas);
DISPATCH(push_ss);
DISPATCH(pop_ss);
DISPATCH(push_ds);
DISPATCH(pop_ds);
DISPATCH(daa);
DISPATCH(das);
DISPATCH(aaa);
DISPATCH(push_iw);
DISPATCH(imul_rw_mw);
DISPATCH(push_ibs);
DISPATCH(imul_rw_m_iw16);
DISPATCH(imul_rw_m_iw32);
DISPATCH(imul_rw_m_ib16);
DISPATCH(imul_rw_m_ib32);
DISPATCH(GROUP_1WS);
DISPATCH(mov_rw_mw);
DISPATCH(mov_mw_seg);
DISPATCH(lea_rw_mw);
DISPATCH(mov_seg_mw);
DISPATCH(pop_mw);
DISPATCH(nop);
DISPATCH(call_md);
DISPATCH(sahf);
DISPATCH(lahf);
DISPATCH(movsb);
DISPATCH(movsw);
DISPATCH(cmpsb);
DISPATCH(cmpsw);
DISPATCH(stosb);
DISPATCH(stosw);
DISPATCH(lodsb);
DISPATCH(lodsw);
DISPATCH(scasb);
DISPATCH(scasw);
DISPATCH(mov_ah_ib);
DISPATCH(mov_ch_ib);
DISPATCH(mov_dh_ib);
DISPATCH(mov_bh_ib);
DISPATCH(mov_sp_iw);
DISPATCH(mov_bp_iw);
DISPATCH(mov_si_iw);
DISPATCH(mov_di_iw);
DISPATCH(retn_iw);
DISPATCH(retn);
DISPATCH(enter_iw_ib);
DISPATCH(leaveX);    // 'leave' is already defined on PPC
DISPATCH(int3);
DISPATCH(int_ib);
DISPATCH(into);
DISPATCH(iret);
DISPATCH(aam_ib);
DISPATCH(aad_ib);
DISPATCH(xlat);
DISPATCH(FLOAT_INSTR);
DISPATCH(loopne_b);
DISPATCH(loope_b);
DISPATCH(loop_b);
DISPATCH(jcxz_b);
DISPATCH(jmpf_md);
DISPATCH(jmp_jb);
DISPATCH(cmc);
DISPATCH(clc);
DISPATCH(stc);
DISPATCH(cld);
DISPATCH(std);
DISPATCH(GROUP_4);
DISPATCH(GROUP_5);
DISPATCH(GROUP_6);
DISPATCH(GROUP_7);
DISPATCH(GROUP_8);
DISPATCH(seto_modrmb);
DISPATCH(setno_modrmb);
DISPATCH(setb_modrmb);
DISPATCH(setae_modrmb);
DISPATCH(sete_modrmb);
DISPATCH(setne_modrmb);
DISPATCH(setbe_modrmb);
DISPATCH(seta_modrmb);
DISPATCH(sets_modrmb);
DISPATCH(setns_modrmb);
DISPATCH(setp_modrmb);
DISPATCH(setnp_modrmb);
DISPATCH(setl_modrmb);
DISPATCH(setge_modrmb);
DISPATCH(setle_modrmb);
DISPATCH(setg_modrmb);
DISPATCH(push_fs);
DISPATCH(pop_fs);
DISPATCH(bt_modrmw_regw);
DISPATCH(push_gs);
DISPATCH(pop_gs);
DISPATCH(imul_regw_modrmw16);
DISPATCH(imul_regw_modrmw32);
DISPATCH(btr_modrmw_regw);
DISPATCH(movzx_regb_modrmb);
DISPATCH(movzx_regw_modrmw);
DISPATCH(btc_modrmw_regw);
DISPATCH(movsx_regb_modrmb);
DISPATCH(movsx_regw_modrmw);
DISPATCH(wait);
DISPATCH(bswap_eax);
DISPATCH(bswap_ebx);
DISPATCH(bswap_ecx);
DISPATCH(bswap_edx);
DISPATCH(bswap_esp);
DISPATCH(bswap_ebp);
DISPATCH(bswap_esi);
DISPATCH(bswap_edi);
DISPATCH(arpl);
DISPATCH(cpuid);
DISPATCH(cmpxchg8b);
DISPATCH(LOCKcmpxchg8b);
DISPATCH(rdtsc);

#endif //MISCFNS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\entrypt\entrypt.c ===
/*++
                                                                                
Copyright (c) 1995 Microsoft Corporation

Module Name:

    entrypt.c

Abstract:
    
    This module stores the Entry Point structures, and retrieves them
    given either an intel address or a native address.
    
Author:

    16-Jun-1995 t-orig

Revision History:

        24-Aug-1999 [askhalid] copied from 32-bit wx86 directory and make work for 64bit.

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "cpuassrt.h"
#include "entrypt.h"
#include "wx86.h"
#include "redblack.h"
#include "mrsw.h"

ASSERTNAME;

//
// Count of modifications made to the ENTRYPOINT tree.  Useful for code
// which unlocks the Entrypoint MRSW object and needs to see if another thread
// has invalidated the ENTRYPOINT tree or not.
//
DWORD EntrypointTimestamp;

EPNODE _NIL;
PEPNODE NIL=&_NIL;
PEPNODE intelRoot=&_NIL;
#if DBG_DUAL_TREES
PEPNODE dualRoot=&_NIL;
#endif

#if DBG_DUAL_TREES
VOID
VerifySubTree(
    PEPNODE intelEP,
    PEPNODE dualEP
    )
{
    CPUASSERT(intelEP != NILL || dualEP == NIL);
    CPUASSERT(intelEP->dual == dualEP);
    CPUASSERT(dualEP->dual == intelEP);
    CPUASSERT(intelEP->ep.intelStart == dualEP->ep.intelStart);
    CPUASSERT(intelEP->ep.intelEnd == dualEP->ep.intelEnd);
    CPUASSERT(intelEP->ep.nativeStart == dualEP->ep.nativeStart);
    CPUASSERT(intelEP->intelColor == dualEP->intelColor);

    VerifySubTree(intelEP->intelLeft, dualEP->intelLeft);
    VerifySubTree(intelEP->intelRight, dualEP->intelRight);
}

VOID
VerifyTrees(
    VOID
    )
{
    VerifySubTree(intelRoot, dualRoot);
}
#endif


#ifdef PROFILE
void StartCAP(void);
#endif



INT
initializeEntryPointModule(
    void
    )
/*++

Routine Description:

    Initializes the entry point module by allocating initial dll tables.  
    Should be called once for each process (thus this need not be called 
    by each thread).

Arguments:

    none

Return Value:

    return-value - 1 for success, 0 for failure

--*/
{
    NIL->intelLeft = NIL->intelRight  = NIL->intelParent = NIL;
    NIL->intelColor = BLACK;

#ifdef PROFILE
    StartCAP();
#endif

    return 1;
}



INT
insertEntryPoint(
    PEPNODE pNewEntryPoint
    )
/*++

Routine Description:

    Inserts the entry point structure into the correct red/black trees 
        (both intel and native)

Arguments:

    pNewEntryPoint - A pointer to the entry point structure to be inserted 
                     into the trees

Return Value:

    return-value - 1 - Success
                   0 - No entry for that region of memory
                   -1 -- There's a problem with the entry point table

--*/
{
#if DBG_DUAL_TREES
    PEPNODE pdualNewEntryPoint = malloc(sizeof(EPNODE));
    memcpy(pdualNewEntryPoint, pNewEntryPoint, sizeof(EPNODE));
#endif
    intelRoot = insertNodeIntoIntelTree (intelRoot, 
        pNewEntryPoint, 
        NIL);

#if DBG_DUAL_TREES
    dualRoot = insertNodeIntoIntelTree (dualRoot,
        pdualNewEntryPoint,
        NIL);
    pdualNewEntryPoint->dual = pNewEntryPoint;
    pNewEntryPoint->dual = pdualNewEntryPoint;
    VerifyTrees();
#endif

    //
    // Bump the timestamp
    //
    EntrypointTimestamp++;

    return 1;
}


#if 0   // dead code, but keep it around in case we decide we want it later.
INT
removeEntryPoint(
    PEPNODE pEP
    )
/*++

Routine Description:

    Removes an entry point structure from both the intel and native
        red/black trees

Arguments:

    pEP - A pointer to the entry point structure to be removed

Return Value:

    return-value - 1 - Success
                   0 - No entry for that region of memory
                   -1 -- There's a problem with the entry point table

--*/
{
    intelRoot = intelRBDelete (intelRoot, 
        pEP, 
        NIL);

#if DBG_DUAL_TREES
    CPUASSERT(pEP->dual->dual == pEP);
    dualRoot = intelRBDelete(dualRoot,
        pEP->dual,
        NIL);
    free(pEP->dual);
    pEP->dual = NULL;
    VerifyTrees();
#endif

    EntrypointTimestamp++;

    return 1;
}
#endif  // 0


PENTRYPOINT
EPFromIntelAddr(
    PVOID intelAddr
    )
/*++

Routine Description:

    Retrieves an entry point structure containing the given intel address

Arguments:
                                                                                
    intelAddr - The intel address contained within the code corresponding to 
        the entry point structure

Return Value:

    return-value - The entry point structure if found, NULL otherwise.

--*/
{
    PENTRYPOINT EP;
    PEPNODE pEPNode;

    pEPNode = findIntel(intelRoot, intelAddr, NIL);
    if (!pEPNode) {
        //
        // No EPNODE contains the address
        //
        return NULL;
    }

    //
    // The ENTRYPOINT inside the EPNODE contains the address.  Search
    // for an ENTRYPOINT which matches that address exactly.
    //
    EP = &pEPNode->ep;
    do {
        if (EP->intelStart == intelAddr) {
            //
            // Found a sub-Entrypoint whose Intel address exactly matches
            // the one we were looking for.
            //
            return EP;
        }
        EP=EP->SubEP;
    } while (EP);

    //
    // The EPNODE in the Red-black tree contains the Intel address, but
    // no sub-Entrypoint exactly describes the Intel address.
    //
    return &pEPNode->ep;
}

PENTRYPOINT
GetNextEPFromIntelAddr(
    PVOID intelAddr
    )
/*++

Routine Description:

    Retrieves the entry point following

Arguments:

    intelAddr - The intel address contained within the code corresponding to
        the entry point structure

Return Value:

    A pointer to the first EntryPoint which follows a particular Intel Address.

--*/
{
    PEPNODE pEP;
#if DBG_DUAL_TREES
    PEPNODE pDual;
#endif

    pEP = findIntelNext (intelRoot, intelAddr, NIL);

#if DBG_DUAL_TREES
    pDual = findIntelNext(dualRoot, intelAddr, NIL);
    CPUASSERT((pDual==NULL && pEP==NULL) ||
           (pDual->dual == pEP));
    VerifyTrees();
#endif

    return &pEP->ep;
}


BOOLEAN
IsIntelRangeInCache(
    PVOID Addr,
    DWORD Length
    )
/*++

Routine Description:

    Determines if any entrypoints are contained within a range of memory.
    Used to determine if the Translation Cache must be flushed.

    Must be called with either EP write or read lock.

Arguments:

    None

Return Value:

    None

--*/
{
    BOOLEAN fContains;

    if (intelRoot == NIL) {
        //
        // Empty tree - no need to flush
        //
        return FALSE;
    }

    fContains = intelContainsRange(intelRoot,
                                   NIL,
                                   Addr,
                                   (PVOID)((ULONGLONG)Addr + Length)   
                                  );

    return fContains;
}


VOID
FlushEntrypoints(
    VOID
    )
/*++

Routine Description:

    Quickly deletes all entrypoints.  Called by the Translation Cache when
    the cache is flushed.

Arguments:

    None

Return Value:

    None

--*/
{
    if (intelRoot != NIL) {
        //
        // Delete the heap containing all entrypoints in the tree
        //
        EPFree();

        //
        // Reset the root of the tree
        //
        intelRoot = NIL;
#if DBG_DUAL_TREES
        dualRoot = NIL;
#endif

        //
        // Bump the timestamp
        //
        EntrypointTimestamp++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\decoder\modrm.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    mod_rm.c

Abstract:
    
    Mod/Rm/Reg decoder.  Compiled multiple times to generate the following
    functions:  mod_rm_reg8     - for 8-bit integer instructions
                mod_rm_reg16    - for 16-bit integer instructions
                mod_rm_reg32    - for 32-bit integer instructions
                mod_rm_regst    - for floating-point instructions (mod=11
                                   indicates rm bits specify ST(i)).
                mod_rm_seg16    - for 16-bit integer instructions which
                                   specify a segment register in the remaining
                                   bits.

Author:

    29-Jun-1995 BarryBo

Revision History:

--*/

// THIS FILE IS #include'd INTO FILES WHICH DEFINE THE FOLLOWING MACROS:
// MOD_RM_DECODER   - name of the decoder
// MOD11_RM000      - the name of the thing to use when mod=11,rm=000.
// MOD11_RM001      - mod=11,rm=001
//  ...
// MOD11_RM111      - mod=11,rm=111
//
// REG000           - the name of the register to use when reg=000
//  ...
// REG111           - reg=111

int MOD_RM_DECODER(PDECODERSTATE State, POPERAND op1, POPERAND op2)
{
    int cbInstr;
    OPERAND ScratchOperand;

    if (op2 == NULL) {
        // If caller doesn't care about operand #2, then store the results
        // to a scratch structure.
        op2 = &ScratchOperand;
    }

    op2->Type = OPND_REGREF;

    if (State->AdrPrefix) {
        // ADR: prefix specified.

        // mm aaa rrr
        // |  |   |
        // |  |   +--- 'rm' bits from mod/rm
        // |  +------- reg bits
        // +---------- 'mod' bits from mod/rm
        switch (*(PBYTE)(eipTemp+1)) {
            case 0x00:                   // mod/rm = 00 000, reg=000
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op2->Reg = REG000;
                break;
            case 0x01:                   // mod/rm = 00 001, reg=000
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op2->Reg = REG000;
                break;
            case 0x02:                   // mod/rm = 00 010, reg=000
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op2->Reg = REG000;
                break;
            case 0x03:                   // mod/rm = 00 011, reg=000
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op2->Reg = REG000;
                break;
            case 0x04:                   // mod/rm = 00 100, reg=000
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op2->Reg = REG000;
                break;
            case 0x05:                   // mod/rm = 00 101, reg=000
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op2->Reg = REG000;
                break;
            case 0x06:                   // mod/rm = 00 110, reg=000
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG000;
                break;
            case 0x07:                   // mod/rm = 00 111, reg=000
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op2->Reg = REG000;
                break;

            case 0x08:                   // mod/rm = 00 000, reg=001
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op2->Reg = REG001;
                break;
            case 0x09:                   // mod/rm = 00 001, reg=001
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op2->Reg = REG001;
                break;
            case 0x0a:                   // mod/rm = 00 010, reg=001
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op2->IndexReg = GP_SI;
                op2->Reg = REG001;
                break;
            case 0x0b:                   // mod/rm = 00 011, reg=001
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op2->IndexReg = GP_DI;
                op2->Reg = REG001;
                break;
            case 0x0c:                   // mod/rm = 00 100, reg=001
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op2->Reg = REG001;
                break;
            case 0x0d:                   // mod/rm = 00 101, reg=001
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op2->Reg = REG001;
                break;
            case 0x0e:                   // mod/rm = 00 110, reg=001
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG001;
                break;
            case 0x0f:                   // mod/rm = 00 111, reg=001
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op2->Reg = REG001;
                break;

            case 0x10:                   // mod/rm = 00 000, reg=010
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op2->Reg = REG010;
                break;
            case 0x11:                   // mod/rm = 00 001, reg=010
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op2->Reg = REG010;
                break;
            case 0x12:                   // mod/rm = 00 010, reg=010
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op2->Reg = REG010;
                break;
            case 0x13:                   // mod/rm = 00 011, reg=001
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op2->Reg = REG010;
                break;
            case 0x14:                   // mod/rm = 00 100, reg=010
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op2->Reg = REG010;
                break;
            case 0x15:                   // mod/rm = 00 101, reg=010
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op2->Reg = REG010;
                break;
            case 0x16:                   // mod/rm = 00 110, reg=010
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG010;
                break;
            case 0x17:                   // mod/rm = 00 111, reg=010
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op2->Reg = REG010;
                break;

            case 0x18:                   // mod/rm = 00 000, reg=011
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op2->Reg = REG011;
                break;
            case 0x19:                   // mod/rm = 00 001, reg=011
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->Reg = GP_DI;
                op2->Reg = REG011;
                break;
            case 0x1a:                   // mod/rm = 00 010, reg=011
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op2->Reg = REG011;
                break;
            case 0x1b:                   // mod/rm = 00 011, reg=011
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op2->Reg = REG011;
                break;
            case 0x1c:                   // mod/rm = 00 100, reg=011
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op2->Reg = REG011;
                break;
            case 0x1d:                   // mod/rm = 00 101, reg=011
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op2->Reg = REG011;
                break;
            case 0x1e:                   // mod/rm = 00 110, reg=011
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG011;
                break;
            case 0x1f:                   // mod/rm = 00 111, reg=011
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op2->Reg = REG011;
                break;

            case 0x20:                   // mod/rm = 00 000, reg=100
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op2->Reg = REG100;
                break;
            case 0x21:                   // mod/rm = 00 001, reg=100
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op2->Reg = REG100;
                break;
            case 0x22:                   // mod/rm = 00 010, reg=100
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op2->Reg = REG100;
                break;
            case 0x23:                   // mod/rm = 00 011, reg=100
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op2->Reg = REG100;
                break;
            case 0x24:                   // mod/rm = 00 100, reg=100
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op2->Reg = REG100;
                break;
            case 0x25:                   // mod/rm = 00 101, reg=100
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op2->Reg = REG100;
                break;
            case 0x26:                   // mod/rm = 00 110, reg=100
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG100;
                break;
            case 0x27:                   // mod/rm = 00 111, reg=100
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op2->Reg = REG100;
                break;

            case 0x28:                   // mod/rm = 00 000, reg=101
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op2->Reg = REG101;
                break;
            case 0x29:                   // mod/rm = 00 001, reg=101
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op2->Reg = REG101;
                break;
            case 0x2a:                   // mod/rm = 00 010, reg=101
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op2->Reg = REG101;
                break;
            case 0x2b:                   // mod/rm = 00 011, reg=101
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op2->Reg = REG101;
                break;
            case 0x2c:                   // mod/rm = 00 100, reg=101
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op2->Reg = REG101;
                break;
            case 0x2d:                   // mod/rm = 00 101, reg=101
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op2->Reg = REG101;
                break;
            case 0x2e:                   // mod/rm = 00 110, reg=101
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG101;
                break;
            case 0x2f:                   // mod/rm = 00 111, reg=101
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op2->Reg = REG101;
                break;

            case 0x30:                   // mod/rm = 00 000, reg=110
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op2->Reg = REG110;
                break;
            case 0x31:                   // mod/rm = 00 001, reg=110
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op2->Reg = REG110;
                break;
            case 0x32:                   // mod/rm = 00 010, reg=110
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op2->Reg = REG110;
                break;
            case 0x33:                   // mod/rm = 00 011, reg=110
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op2->Reg = REG110;
                break;
            case 0x34:                   // mod/rm = 00 100, reg=110
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op2->Reg = REG110;
                break;
            case 0x35:                   // mod/rm = 00 101, reg=110
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op2->Reg = REG110;
                break;
            case 0x36:                   // mod/rm = 00 110, reg=110
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG110;
                break;
            case 0x37:                   // mod/rm = 00 111, reg=110
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op2->Reg = REG110;
                break;

            case 0x38:                   // mod/rm = 00 000, reg=111
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op2->Reg = REG111;
                break;
            case 0x39:                   // mod/rm = 00 001, reg=111
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op2->Reg = REG111;
                break;
            case 0x3a:                   // mod/rm = 00 010, reg=111
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op2->Reg = REG111;
                break;
            case 0x3b:                   // mod/rm = 00 011, reg=111
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op2->Reg = REG111;
                break;
            case 0x3c:                   // mod/rm = 00 100, reg=111
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op2->Reg = REG111;
                break;
            case 0x3d:                   // mod/rm = 00 101, reg=111
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op2->Reg = REG111;
                break;
            case 0x3e:                   // mod/rm = 00 110, reg=111
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG111;
                break;
            case 0x3f:                   // mod/rm = 00 111, reg=111
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op2->Reg = REG111;
                break;

            /////////////////////////////////////////////////////////////////////

            case 0x40:                   // mod/rm = 01 000, reg=000
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG000;
                break;
            case 0x41:                   // mod/rm = 01 001, reg=000
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG000;
                break;
            case 0x42:                   // mod/rm = 01 010, reg=000
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG000;
                break;
            case 0x43:                   // mod/rm = 01 011, reg=000
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG000;
                break;
            case 0x44:                   // mod/rm = 01 100, reg=000
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG000;
                break;
            case 0x45:                   // mod/rm = 01 101, reg=000
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG000;
                break;
            case 0x46:                   // mod/rm = 01 110, reg=000
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG000;
                break;
            case 0x47:                   // mod/rm = 01 111, reg=000
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG000;
                break;

            case 0x48:                   // mod/rm = 01 000, reg=001
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG001;
                break;
            case 0x49:                   // mod/rm = 01 001, reg=001
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG001;
                break;
            case 0x4a:                   // mod/rm = 01 010, reg=001
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG001;
                break;
            case 0x4b:                   // mod/rm = 01 011, reg=001
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG001;
                break;
            case 0x4c:                   // mod/rm = 01 100, reg=001
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG001;
                break;
            case 0x4d:                   // mod/rm = 01 101, reg=001
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG001;
                break;
            case 0x4e:                   // mod/rm = 01 110, reg=001
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG001;
                break;
            case 0x4f:                   // mod/rm = 01 111, reg=001
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG001;
                break;

            case 0x50:                   // mod/rm = 01 000, reg=010
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG010;
                break;
            case 0x51:                   // mod/rm = 01 001, reg=010
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG010;
                break;
            case 0x52:                   // mod/rm = 01 010, reg=010
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG010;
                break;
            case 0x53:                   // mod/rm = 01 011, reg=001
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG010;
                break;
            case 0x54:                   // mod/rm = 01 100, reg=010
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG010;
                break;
            case 0x55:                   // mod/rm = 01 101, reg=010
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG010;
                break;
            case 0x56:                   // mod/rm = 01 110, reg=010
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG010;
                break;
            case 0x57:                   // mod/rm = 01 111, reg=010
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG010;
                break;

            case 0x58:                   // mod/rm = 01 000, reg=011
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG011;
                break;
            case 0x59:                   // mod/rm = 01 001, reg=011
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG011;
                break;
            case 0x5a:                   // mod/rm = 01 010, reg=011
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG011;
                break;
            case 0x5b:                   // mod/rm = 01 011, reg=011
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG011;
                break;
            case 0x5c:                   // mod/rm = 01 100, reg=011
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG011;
                break;
            case 0x5d:                   // mod/rm = 01 101, reg=011
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG011;
                break;
            case 0x5e:                   // mod/rm = 01 110, reg=011
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG011;
                break;
            case 0x5f:                   // mod/rm = 01 111, reg=011
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG011;
                break;

            case 0x60:                   // mod/rm = 01 000, reg=100
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG100;
                break;
            case 0x61:                   // mod/rm = 01 001, reg=100
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG100;
                break;
            case 0x62:                   // mod/rm = 01 010, reg=100
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG100;
                break;
            case 0x63:                   // mod/rm = 01 011, reg=100
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG100;
                break;
            case 0x64:                   // mod/rm = 01 100, reg=100
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG100;
                break;
            case 0x65:                   // mod/rm = 01 101, reg=100
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG100;
                break;
            case 0x66:                   // mod/rm = 01 110, reg=100
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG100;
                break;
            case 0x67:                   // mod/rm = 01 111, reg=100
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG100;
                break;

            case 0x68:                   // mod/rm = 01 000, reg=101
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG101;
                break;
            case 0x69:                   // mod/rm = 01 001, reg=101
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG101;
                break;
            case 0x6a:                   // mod/rm = 01 010, reg=101
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG101;
                break;
            case 0x6b:                   // mod/rm = 01 011, reg=101
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG101;
                break;
            case 0x6c:                   // mod/rm = 01 100, reg=101
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG101;
                break;
            case 0x6d:                   // mod/rm = 01 101, reg=101
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG101;
                break;
            case 0x6e:                   // mod/rm = 01 110, reg=101
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG101;
                break;
            case 0x6f:                   // mod/rm = 01 111, reg=101
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG101;
                break;

            case 0x70:                   // mod/rm = 01 000, reg=110
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG110;
                break;
            case 0x71:                   // mod/rm = 01 001, reg=110
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG110;
                break;
            case 0x72:                   // mod/rm = 01 010, reg=110
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG110;
                break;
            case 0x73:                   // mod/rm = 01 011, reg=110
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG110;
                break;
            case 0x74:                   // mod/rm = 01 100, reg=110
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG110;
                break;
            case 0x75:                   // mod/rm = 01 101, reg=110
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG110;
                break;
            case 0x76:                   // mod/rm = 01 110, reg=110
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG110;
                break;
            case 0x77:                   // mod/rm = 01 111, reg=110
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG110;
                break;

            case 0x78:                   // mod/rm = 01 000, reg=111
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG111;
                break;
            case 0x79:                   // mod/rm = 01 001, reg=111
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG111;
                break;
            case 0x7a:                   // mod/rm = 01 010, reg=111
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG111;
                break;
            case 0x7b:                   // mod/rm = 01 011, reg=111
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG111;
                break;
            case 0x7c:                   // mod/rm = 01 100, reg=111
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG111;
                break;
            case 0x7d:                   // mod/rm = 01 101, reg=111
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG111;
                break;
            case 0x7e:                   // mod/rm = 01 110, reg=111
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG111;
                break;
            case 0x7f:                   // mod/rm = 01 111, reg=111
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG111;
                break;

            /////////////////////////////////////////////////////////////////////

            case 0x80:                   // mod/rm = 10 000, reg=000
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG000;
                break;
            case 0x81:                   // mod/rm = 10 001, reg=000
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG000;
                break;
            case 0x82:                   // mod/rm = 10 010, reg=000
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG000;
                break;
            case 0x83:                   // mod/rm = 10 011, reg=000
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG000;
                break;
            case 0x84:                   // mod/rm = 10 100, reg=000
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG000;
                break;
            case 0x85:                   // mod/rm = 10 101, reg=000
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG000;
                break;
            case 0x86:                   // mod/rm = 10 110, reg=000
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG000;
                break;
            case 0x87:                   // mod/rm = 10 111, reg=000
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG000;
                break;

            case 0x88:                   // mod/rm = 10 000, reg=001
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG001;
                break;
            case 0x89:                   // mod/rm = 10 001, reg=001
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG001;
                break;
            case 0x8a:                   // mod/rm = 10 010, reg=001
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG001;
                break;
            case 0x8b:                   // mod/rm = 10 011, reg=001
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG001;
                break;
            case 0x8c:                   // mod/rm = 10 100, reg=001
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG001;
                break;
            case 0x8d:                   // mod/rm = 10 101, reg=001
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG001;
                break;
            case 0x8e:                   // mod/rm = 10 110, reg=001
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG001;
                break;
            case 0x8f:                   // mod/rm = 10 111, reg=001
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG001;
                break;

            case 0x90:                   // mod/rm = 10 000, reg=010
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG010;
                break;
            case 0x91:                   // mod/rm = 10 001, reg=010
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG010;
                break;
            case 0x92:                   // mod/rm = 10 010, reg=010
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG010;
                break;
            case 0x93:                   // mod/rm = 10 011, reg=010
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG010;
                break;
            case 0x94:                   // mod/rm = 10 100, reg=010
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG010;
                break;
            case 0x95:                   // mod/rm = 10 101, reg=010
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG010;
                break;
            case 0x96:                   // mod/rm = 10 110, reg=010
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG010;
                break;
            case 0x97:                   // mod/rm = 10 111, reg=010
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG010;
                break;

            case 0x98:                   // mod/rm = 10 000, reg=011
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG011;
                break;
            case 0x99:                   // mod/rm = 10 001, reg=011
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG011;
                break;
            case 0x9a:                   // mod/rm = 10 010, reg=011
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG011;
                break;
            case 0x9b:                   // mod/rm = 10 011, reg=011
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG011;
                break;
            case 0x9c:                   // mod/rm = 10 100, reg=011
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG011;
                break;
            case 0x9d:                   // mod/rm = 10 101, reg=011
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG011;
                break;
            case 0x9e:                   // mod/rm = 10 110, reg=011
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG011;
                break;
            case 0x9f:                   // mod/rm = 10 111, reg=011
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG011;
                break;

            case 0xa0:                   // mod/rm = 10 000, reg=100
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG100;
                break;
            case 0xa1:                   // mod/rm = 10 001, reg=100
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG100;
                break;
            case 0xa2:                   // mod/rm = 10 010, reg=100
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG100;
                break;
            case 0xa3:                   // mod/rm = 10 011, reg=100
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG100;
                break;
            case 0xa4:                   // mod/rm = 10 100, reg=100
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG100;
                break;
            case 0xa5:                   // mod/rm = 10 101, reg=100
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG100;
                break;
            case 0xa6:                   // mod/rm = 10 110, reg=100
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG100;
                break;
            case 0xa7:                   // mod/rm = 10 111, reg=100
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG100;
                break;

            case 0xa8:                   // mod/rm = 10 000, reg=101
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG101;
                break;
            case 0xa9:                   // mod/rm = 10 001, reg=101
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG101;
                break;
            case 0xaa:                   // mod/rm = 10 010, reg=101
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG101;
                break;
            case 0xab:                   // mod/rm = 10 011, reg=101
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG101;
                break;
            case 0xac:                   // mod/rm = 10 100, reg=101
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG101;
                break;
            case 0xad:                   // mod/rm = 10 101, reg=101
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG101;
                break;
            case 0xae:                   // mod/rm = 10 110, reg=101
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG101;
                break;
            case 0xaf:                   // mod/rm = 10 111, reg=101
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG101;
                break;

            case 0xb0:                   // mod/rm = 10 000, reg=110
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG110;
                break;
            case 0xb1:                   // mod/rm = 10 001, reg=110
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG110;
                break;
            case 0xb2:                   // mod/rm = 10 010, reg=110
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG110;
                break;
            case 0xb3:                   // mod/rm = 10 011, reg=110
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG110;
                break;
            case 0xb4:                   // mod/rm = 10 100, reg=110
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG110;
                break;
            case 0xb5:                   // mod/rm = 10 101, reg=110
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG110;
                break;
            case 0xb6:                   // mod/rm = 10 110, reg=110
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG110;
                break;
            case 0xb7:                   // mod/rm = 10 111, reg=110
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG110;
                break;

            case 0xb8:                   // mod/rm = 10 000, reg=111
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG111;
                break;
            case 0xb9:                   // mod/rm = 10 001, reg=111
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG111;
                break;
            case 0xba:                   // mod/rm = 10 010, reg=111
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG111;
                break;
            case 0xbb:                   // mod/rm = 10 011, reg=111
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG111;
                break;
            case 0xbc:                   // mod/rm = 10 100, reg=111
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG111;
                break;
            case 0xbd:                   // mod/rm = 10 101, reg=111
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG111;
                break;
            case 0xbe:                   // mod/rm = 10 110, reg=111
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG111;
                break;
            case 0xbf:                   // mod/rm = 10 111, reg=111
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG111;
                break;

            /////////////////////////////////////////////////////////////////////

            case 0xc0:                   // mod/rm = 11 000, reg=000
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM000;
                op2->Reg = REG000;
                break;
            case 0xc1:                   // mod/rm = 11 001, reg=000
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM001;
                op2->Reg = REG000;
                break;
            case 0xc2:                   // mod/rm = 11 010, reg=000
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM010;
                op2->Reg = REG000;
                break;
            case 0xc3:                   // mod/rm = 11 011, reg=000
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM011;
                op2->Reg = REG000;
                break;
            case 0xc4:                   // mod/rm = 11 100, reg=000
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM100;
                op2->Reg = REG000;
                break;
            case 0xc5:                   // mod/rm = 11 101, reg=000
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM101;
                op2->Reg = REG000;
                break;
            case 0xc6:                   // mod/rm = 11 110, reg=000
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM110;
                op2->Reg = REG000;
                break;
            case 0xc7:                   // mod/rm = 11 111, reg=000
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM111;
                op2->Reg = REG000;
                break;

            case 0xc8:                   // mod/rm = 11 000, reg=001
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM000;
                op2->Reg = REG001;
                break;
            case 0xc9:                   // mod/rm = 11 001, reg=001
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM001;
                op2->Reg = REG001;
                break;
            case 0xca:                   // mod/rm = 11 010, reg=001
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM010;
                op2->Reg = REG001;
                break;
            case 0xcb:                   // mod/rm = 11 011, reg=001
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM011;
                op2->Reg = REG001;
                break;
            case 0xcc:                   // mod/rm = 11 100, reg=001
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM100;
                op2->Reg = REG001;
                break;
            case 0xcd:                   // mod/rm = 11 101, reg=001
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM101;
                op2->Reg = REG001;
                break;
            case 0xce:                   // mod/rm = 11 110, reg=001
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM110;
                op2->Reg = REG001;
                break;
            case 0xcf:                   // mod/rm = 11 111, reg=001
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM111;
                op2->Reg = REG001;
                break;

            case 0xd0:                   // mod/rm = 11 000, reg=010
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM000;
                op2->Reg = REG010;
                break;
            case 0xd1:                   // mod/rm = 11 001, reg=010
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM001;
                op2->Reg = REG010;
                break;
            case 0xd2:                   // mod/rm = 11 010, reg=010
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM010;
                op2->Reg = REG010;
                break;
            case 0xd3:                   // mod/rm = 11 011, reg=001
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM011;
                op2->Reg = REG010;
                break;
            case 0xd4:                   // mod/rm = 11 100, reg=010
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM100;
                op2->Reg = REG010;
                break;
            case 0xd5:                   // mod/rm = 11 101, reg=010
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM101;
                op2->Reg = REG010;
                break;
            case 0xd6:                   // mod/rm = 11 110, reg=010
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM110;
                op2->Reg = REG010;
                break;
            case 0xd7:                   // mod/rm = 11 111, reg=010
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM111;
                op2->Reg = REG010;
                break;

            case 0xd8:                   // mod/rm = 11 000, reg=011
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM000;
                op2->Reg = REG011;
                break;
            case 0xd9:                   // mod/rm = 11 001, reg=011
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM001;
                op2->Reg = REG011;
                break;
            case 0xda:                   // mod/rm = 11 010, reg=011
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM010;
                op2->Reg = REG011;
                break;
            case 0xdb:                   // mod/rm = 11 011, reg=011
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM011;
                op2->Reg = REG011;
                break;
            case 0xdc:                   // mod/rm = 11 100, reg=011
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM100;
                op2->Reg = REG011;
                break;
            case 0xdd:                   // mod/rm = 11 101, reg=011
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM101;
                op2->Reg = REG011;
                break;
            case 0xde:                   // mod/rm = 11 110, reg=011
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM110;
                op2->Reg = REG011;
                break;
            case 0xdf:                   // mod/rm = 11 111, reg=011
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM111;
                op2->Reg = REG011;
                break;

            case 0xe0:                   // mod/rm = 11 000, reg=100
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM000;
                op2->Reg = REG100;
                break;
            case 0xe1:                   // mod/rm = 11 001, reg=100
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM001;
                op2->Reg = REG100;
                break;
            case 0xe2:                   // mod/rm = 11 010, reg=100
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM010;
                op2->Reg = REG100;
                break;
            case 0xe3:                   // mod/rm = 11 011, reg=100
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM011;
                op2->Reg = REG100;
                break;
            case 0xe4:                   // mod/rm = 11 100, reg=100
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM100;
                op2->Reg = REG100;
                break;
            case 0xe5:                   // mod/rm = 11 101, reg=100
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM101;
                op2->Reg = REG100;
                break;
            case 0xe6:                   // mod/rm = 11 110, reg=100
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM110;
                op2->Reg = REG100;
                break;
            case 0xe7:                   // mod/rm = 11 111, reg=100
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM111;
                op2->Reg = REG100;
                break;

            case 0xe8:                   // mod/rm = 11 000, reg=101
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM000;
                op2->Reg = REG101;
                break;
            case 0xe9:                   // mod/rm = 11 001, reg=101
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM001;
                op2->Reg = REG101;
                break;
            case 0xea:                   // mod/rm = 11 010, reg=101
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM010;
                op2->Reg = REG101;
                break;
            case 0xeb:                   // mod/rm = 11 011, reg=101
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM011;
                op2->Reg = REG101;
                break;
            case 0xec:                   // mod/rm = 11 100, reg=101
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM100;
                op2->Reg = REG101;
                break;
            case 0xed:                   // mod/rm = 11 101, reg=101
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM101;
                op2->Reg = REG101;
                break;
            case 0xee:                   // mod/rm = 11 110, reg=101
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM110;
                op2->Reg = REG101;
                break;
            case 0xef:                   // mod/rm = 11 111, reg=101
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM111;
                op2->Reg = REG101;
                break;

            case 0xf0:                   // mod/rm = 11 000, reg=110
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM000;
                op2->Reg = REG110;
                break;
            case 0xf1:                   // mod/rm = 11 001, reg=110
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM001;
                op2->Reg = REG110;
                break;
            case 0xf2:                   // mod/rm = 11 010, reg=110
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM010;
                op2->Reg = REG110;
                break;
            case 0xf3:                   // mod/rm = 11 011, reg=110
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM011;
                op2->Reg = REG110;
                break;
            case 0xf4:                   // mod/rm = 11 100, reg=110
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM100;
                op2->Reg = REG110;
                break;
            case 0xf5:                   // mod/rm = 11 101, reg=110
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM101;
                op2->Reg = REG110;
                break;
            case 0xf6:                   // mod/rm = 11 110, reg=110
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM110;
                op2->Reg = REG110;
                break;
            case 0xf7:                   // mod/rm = 11 111, reg=110
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM111;
                op2->Reg = REG110;
                break;

            case 0xf8:                   // mod/rm = 11 000, reg=111
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM000;
                op2->Reg = REG111;
                break;
            case 0xf9:                   // mod/rm = 11 001, reg=111
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM001;
                op2->Reg = REG111;
                break;
            case 0xfa:                   // mod/rm = 11 010, reg=111
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM010;
                op2->Reg = REG111;
                break;
            case 0xfb:                   // mod/rm = 11 011, reg=111
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM011;
                op2->Reg = REG111;
                break;
            case 0xfc:                   // mod/rm = 11 100, reg=111
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM100;
                op2->Reg = REG111;
                break;
            case 0xfd:                   // mod/rm = 11 101, reg=111
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM101;
                op2->Reg = REG111;
                break;
            case 0xfe:                   // mod/rm = 11 110, reg=111
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM110;
                op2->Reg = REG111;
                break;
            default:
            case 0xff:                   // mod/rm = 11 111, reg=111
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM111;
                op2->Reg = REG111;
                break;
            }
#if DBG
        State->AdrPrefix = FALSE;
#endif
        return cbInstr;
    }

    // else no ADR: prefix found...

    // mm aaa rrr
    // |  |   |
    // |  |   +--- 'rm' bits from mod/rm
    // |  +------- reg bits
    // +---------- 'mod' bits from mod/rm
    switch (*(PBYTE)(eipTemp+1)) {
        case 0x00:                   // mod/rm = 00 000, reg=000
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op2->Reg = REG000;
            break;
        case 0x01:                   // mod/rm = 00 001, reg=000
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op2->Reg = REG000;
            break;
        case 0x02:                   // mod/rm = 00 010, reg=000
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op2->Reg = REG000;
            break;
        case 0x03:                   // mod/rm = 00 011, reg=000
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op2->Reg = REG000;
            break;
        case 0x04:                   // mod/rm = 00 100, reg=000
            // s-i-b present
            cbInstr = 1 + scaled_index((BYTE *)(eipTemp+1), op1);
            op2->Reg = REG000;
            break;
        case 0x05:                   // mod/rm = 00 101, reg=000
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG000;
            break;
        case 0x06:                   // mod/rm = 00 110, reg=000
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op2->Reg = REG000;
            break;
        case 0x07:                   // mod/rm = 00 111, reg=000
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op2->Reg = REG000;
            break;

        case 0x08:                   // mod/rm = 00 000, reg=001
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op2->Reg = REG001;
            break;
        case 0x09:                   // mod/rm = 00 001, reg=001
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op2->Reg = REG001;
            break;
        case 0x0a:                   // mod/rm = 00 010, reg=001
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op2->Reg = REG001;
            break;
        case 0x0b:                   // mod/rm = 00 011, reg=001
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op2->Reg = REG001;
            break;
        case 0x0c:                   // mod/rm = 00 100, reg=001
            // s-i-b present
            cbInstr = 1 + scaled_index((BYTE *)(eipTemp+1), op1);
            op2->Reg = REG001;
            break;
        case 0x0d:                   // mod/rm = 00 101, reg=001
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG001;
            break;
        case 0x0e:                   // mod/rm = 00 110, reg=001
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op2->Reg = REG001;
            break;
        case 0x0f:                   // mod/rm = 00 111, reg=001
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op2->Reg = REG001;
            break;

        case 0x10:                   // mod/rm = 00 000, reg=010
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op2->Reg = REG010;
            break;
        case 0x11:                   // mod/rm = 00 001, reg=010
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op2->Reg = REG010;
            break;
        case 0x12:                   // mod/rm = 00 010, reg=010
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op2->Reg = REG010;
            break;
        case 0x13:                   // mod/rm = 00 011, reg=001
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op2->Reg = REG010;
            break;
        case 0x14:                   // mod/rm = 00 100, reg=010
            // s-i-b present
            cbInstr = 1 + scaled_index((BYTE *)(eipTemp+1), op1);
            op2->Reg = REG010;
            break;
        case 0x15:                   // mod/rm = 00 101, reg=010
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG010;
            break;
        case 0x16:                   // mod/rm = 00 110, reg=010
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op2->Reg = REG010;
            break;
        case 0x17:                   // mod/rm = 00 111, reg=010
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op2->Reg = REG010;
            break;

        case 0x18:                   // mod/rm = 00 000, reg=011
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op2->Reg = REG011;
            break;
        case 0x19:                   // mod/rm = 00 001, reg=011
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op2->Reg = REG011;
            break;
        case 0x1a:                   // mod/rm = 00 010, reg=011
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op2->Reg = REG011;
            break;
        case 0x1b:                   // mod/rm = 00 011, reg=011
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op2->Reg = REG011;
            break;
        case 0x1c:                   // mod/rm = 00 100, reg=011
            // s-i-b present
            cbInstr = 1 + scaled_index((BYTE *)(eipTemp+1), op1);
            op2->Reg = REG011;
            break;
        case 0x1d:                   // mod/rm = 00 101, reg=011
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG011;
            break;
        case 0x1e:                   // mod/rm = 00 110, reg=011
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op2->Reg = REG011;
            break;
        case 0x1f:                   // mod/rm = 00 111, reg=011
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op2->Reg = REG011;
            break;

        case 0x20:                   // mod/rm = 00 000, reg=100
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op2->Reg = REG100;
            break;
        case 0x21:                   // mod/rm = 00 001, reg=100
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op2->Reg = REG100;
            break;
        case 0x22:                   // mod/rm = 00 010, reg=100
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op2->Reg = REG100;
            break;
        case 0x23:                   // mod/rm = 00 011, reg=100
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op2->Reg = REG100;
            break;
        case 0x24:                   // mod/rm = 00 100, reg=100
            // s-i-b present
            cbInstr = 1 + scaled_index((BYTE *)(eipTemp+1), op1);
            op2->Reg = REG100;
            break;
        case 0x25:                   // mod/rm = 00 101, reg=100
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG100;
            break;
        case 0x26:                   // mod/rm = 00 110, reg=100
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op2->Reg = REG100;
            break;
        case 0x27:                   // mod/rm = 00 111, reg=100
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op2->Reg = REG100;
            break;

        case 0x28:                   // mod/rm = 00 000, reg=101
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op2->Reg = REG101;
            break;
        case 0x29:                   // mod/rm = 00 001, reg=101
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op2->Reg = REG101;
            break;
        case 0x2a:                   // mod/rm = 00 010, reg=101
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op2->Reg = REG101;
            break;
        case 0x2b:                   // mod/rm = 00 011, reg=101
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op2->Reg = REG101;
            break;
        case 0x2c:                   // mod/rm = 00 100, reg=101
            // s-i-b present
            cbInstr = 1 + scaled_index((BYTE *)(eipTemp+1), op1);
            op2->Reg = REG101;
            break;
        case 0x2d:                   // mod/rm = 00 101, reg=101
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG101;
            break;
        case 0x2e:                   // mod/rm = 00 110, reg=101
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op2->Reg = REG101;
            break;
        case 0x2f:                   // mod/rm = 00 111, reg=101
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op2->Reg = REG101;
            break;

        case 0x30:                   // mod/rm = 00 000, reg=110
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op2->Reg = REG110;
            break;
        case 0x31:                   // mod/rm = 00 001, reg=110
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op2->Reg = REG110;
            break;
        case 0x32:                   // mod/rm = 00 010, reg=110
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op2->Reg = REG110;
            break;
        case 0x33:                   // mod/rm = 00 011, reg=110
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op2->Reg = REG110;
            break;
        case 0x34:                   // mod/rm = 00 100, reg=110
            // s-i-b present
            cbInstr = 1 + scaled_index((BYTE *)(eipTemp+1), op1);
            op2->Reg = REG110;
            break;
        case 0x35:                   // mod/rm = 00 101, reg=110
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG110;
            break;
        case 0x36:                   // mod/rm = 00 110, reg=110
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op2->Reg = REG110;
            break;
        case 0x37:                   // mod/rm = 00 111, reg=110
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op2->Reg = REG110;
            break;

        case 0x38:                   // mod/rm = 00 000, reg=111
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op2->Reg = REG111;
            break;
        case 0x39:                   // mod/rm = 00 001, reg=111
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op2->Reg = REG111;
            break;
        case 0x3a:                   // mod/rm = 00 010, reg=111
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op2->Reg = REG111;
            break;
        case 0x3b:                   // mod/rm = 00 011, reg=111
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op2->Reg = REG111;
            break;
        case 0x3c:                   // mod/rm = 00 100, reg=111
            // s-i-b present
            cbInstr = 1 + scaled_index((BYTE *)(eipTemp+1), op1);
            op2->Reg = REG111;
            break;
        case 0x3d:                   // mod/rm = 00 101, reg=111
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG111;
            break;
        case 0x3e:                   // mod/rm = 00 110, reg=111
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op2->Reg = REG111;
            break;
        case 0x3f:                   // mod/rm = 00 111, reg=111
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op2->Reg = REG111;
            break;

        /////////////////////////////////////////////////////////////////////

        case 0x40:                   // mod/rm = 01 000, reg=000
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG000;
            break;
        case 0x41:                   // mod/rm = 01 001, reg=000
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG000;
            break;
        case 0x42:                   // mod/rm = 01 010, reg=000
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG000;
            break;
        case 0x43:                   // mod/rm = 01 011, reg=000
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG000;
            break;
        case 0x44:                   // mod/rm = 01 100, reg=000
            // s-i-b present
            cbInstr = 2 + scaled_index((BYTE *)(eipTemp+1), op1);
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+cbInstr);
            op2->Reg = REG000;
            break;
        case 0x45:                   // mod/rm = 01 101, reg=000
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBP;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG000;
            break;
        case 0x46:                   // mod/rm = 01 110, reg=000
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG000;
            break;
        case 0x47:                   // mod/rm = 01 111, reg=000
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG000;
            break;

        case 0x48:                   // mod/rm = 01 000, reg=001
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG001;
            break;
        case 0x49:                   // mod/rm = 01 001, reg=001
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG001;
            break;
        case 0x4a:                   // mod/rm = 01 010, reg=001
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG001;
            break;
        case 0x4b:                   // mod/rm = 01 011, reg=001
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG001;
            break;
        case 0x4c:                   // mod/rm = 01 100, reg=001
            // s-i-b present
            cbInstr = 2 + scaled_index((BYTE *)(eipTemp+1), op1);
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+cbInstr);
            op2->Reg = REG001;
            break;
        case 0x4d:                   // mod/rm = 01 101, reg=001
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBP;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG001;
            break;
        case 0x4e:                   // mod/rm = 01 110, reg=001
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG001;
            break;
        case 0x4f:                   // mod/rm = 01 111, reg=001
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG001;
            break;

        case 0x50:                   // mod/rm = 01 000, reg=010
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG010;
            break;
        case 0x51:                   // mod/rm = 01 001, reg=010
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG010;
            break;
        case 0x52:                   // mod/rm = 01 010, reg=010
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG010;
            break;
        case 0x53:                   // mod/rm = 01 011, reg=001
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG010;
            break;
        case 0x54:                   // mod/rm = 01 100, reg=010
            // s-i-b present
            cbInstr = 2 + scaled_index((BYTE *)(eipTemp+1), op1);
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+cbInstr);
            op2->Reg = REG010;
            break;
        case 0x55:                   // mod/rm = 01 101, reg=010
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBP;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG010;
            break;
        case 0x56:                   // mod/rm = 01 110, reg=010
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG010;
            break;
        case 0x57:                   // mod/rm = 01 111, reg=010
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG010;
            break;

        case 0x58:                   // mod/rm = 01 000, reg=011
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG011;
            break;
        case 0x59:                   // mod/rm = 01 001, reg=011
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG011;
            break;
        case 0x5a:                   // mod/rm = 01 010, reg=011
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG011;
            break;
        case 0x5b:                   // mod/rm = 01 011, reg=011
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG011;
            break;
        case 0x5c:                   // mod/rm = 01 100, reg=011
            // s-i-b present
            cbInstr = 2 + scaled_index((BYTE *)(eipTemp+1), op1);
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+cbInstr);
            op2->Reg = REG011;
            break;
        case 0x5d:                   // mod/rm = 01 101, reg=011
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBP;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG011;
            break;
        case 0x5e:                   // mod/rm = 01 110, reg=011
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG011;
            break;
        case 0x5f:                   // mod/rm = 01 111, reg=011
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG011;
            break;

        case 0x60:                   // mod/rm = 01 000, reg=100
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG100;
            break;
        case 0x61:                   // mod/rm = 01 001, reg=100
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG100;
            break;
        case 0x62:                   // mod/rm = 01 010, reg=100
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG100;
            break;
        case 0x63:                   // mod/rm = 01 011, reg=100
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG100;
            break;
        case 0x64:                   // mod/rm = 01 100, reg=100
            // s-i-b present
            cbInstr = 2 + scaled_index((BYTE *)(eipTemp+1), op1);
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+cbInstr);
            op2->Reg = REG100;
            break;
        case 0x65:                   // mod/rm = 01 101, reg=100
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBP;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG100;
            break;
        case 0x66:                   // mod/rm = 01 110, reg=100
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG100;
            break;
        case 0x67:                   // mod/rm = 01 111, reg=100
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG100;
            break;

        case 0x68:                   // mod/rm = 01 000, reg=101
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG101;
            break;
        case 0x69:                   // mod/rm = 01 001, reg=101
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG101;
            break;
        case 0x6a:                   // mod/rm = 01 010, reg=101
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG101;
            break;
        case 0x6b:                   // mod/rm = 01 011, reg=101
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG101;
            break;
        case 0x6c:                   // mod/rm = 01 100, reg=101
            // s-i-b present
            cbInstr = 2 + scaled_index((BYTE *)(eipTemp+1), op1);
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+cbInstr);
            op2->Reg = REG101;
            break;
        case 0x6d:                   // mod/rm = 01 101, reg=101
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBP;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG101;
            break;
        case 0x6e:                   // mod/rm = 01 110, reg=101
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG101;
            break;
        case 0x6f:                   // mod/rm = 01 111, reg=101
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG101;
            break;

        case 0x70:                   // mod/rm = 01 000, reg=110
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG110;
            break;
        case 0x71:                   // mod/rm = 01 001, reg=110
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG110;
            break;
        case 0x72:                   // mod/rm = 01 010, reg=110
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG110;
            break;
        case 0x73:                   // mod/rm = 01 011, reg=110
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG110;
            break;
        case 0x74:                   // mod/rm = 01 100, reg=110
            // s-i-b present
            cbInstr = 2 + scaled_index((BYTE *)(eipTemp+1), op1);
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+cbInstr);
            op2->Reg = REG110;
            break;
        case 0x75:                   // mod/rm = 01 101, reg=110
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBP;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG110;
            break;
        case 0x76:                   // mod/rm = 01 110, reg=110
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG110;
            break;
        case 0x77:                   // mod/rm = 01 111, reg=110
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG110;
            break;

        case 0x78:                   // mod/rm = 01 000, reg=111
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG111;
            break;
        case 0x79:                   // mod/rm = 01 001, reg=111
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG111;
            break;
        case 0x7a:                   // mod/rm = 01 010, reg=111
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG111;
            break;
        case 0x7b:                   // mod/rm = 01 011, reg=111
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG111;
            break;
        case 0x7c:                   // mod/rm = 01 100, reg=111
            // s-i-b present
            cbInstr = 2 + scaled_index((BYTE *)(eipTemp+1), op1);
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+cbInstr);
            op2->Reg = REG111;
            break;
        case 0x7d:                   // mod/rm = 01 101, reg=111
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBP;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG111;
            break;
        case 0x7e:                   // mod/rm = 01 110, reg=111
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG111;
            break;
        case 0x7f:                   // mod/rm = 01 111, reg=111
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG111;
            break;

        /////////////////////////////////////////////////////////////////////

        case 0x80:                   // mod/rm = 10 000, reg=000
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG000;
            break;
        case 0x81:                   // mod/rm = 10 001, reg=000
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG000;
            break;
        case 0x82:                   // mod/rm = 10 010, reg=000
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG000;
            break;
        case 0x83:                   // mod/rm = 10 011, reg=000
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG000;
            break;
        case 0x84:                   // mod/rm = 10 100, reg=000
            // s-i-b present
            cbInstr = 5 + scaled_index((BYTE *)(eipTemp+1), op1);
            op1->Immed = GET_LONG(eipTemp+cbInstr-3);
            op2->Reg = REG000;
            break;
        case 0x85:                   // mod/rm = 10 101, reg=000
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBP;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG000;
            break;
        case 0x86:                   // mod/rm = 10 110, reg=000
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG000;
            break;
        case 0x87:                   // mod/rm = 10 111, reg=000
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG000;
            break;

        case 0x88:                   // mod/rm = 10 000, reg=001
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG001;
            break;
        case 0x89:                   // mod/rm = 10 001, reg=001
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG001;
            break;
        case 0x8a:                   // mod/rm = 10 010, reg=001
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG001;
            break;
        case 0x8b:                   // mod/rm = 10 011, reg=001
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG001;
            break;
        case 0x8c:                   // mod/rm = 10 100, reg=001
            // s-i-b present
            cbInstr = 5 + scaled_index((BYTE *)(eipTemp+1), op1);
            op1->Immed = GET_LONG(eipTemp+cbInstr-3);
            op2->Reg = REG001;
            break;
        case 0x8d:                   // mod/rm = 10 101, reg=001
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBP;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG001;
            break;
        case 0x8e:                   // mod/rm = 10 110, reg=001
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG001;
            break;
        case 0x8f:                   // mod/rm = 10 111, reg=001
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG001;
            break;

        case 0x90:                   // mod/rm = 10 000, reg=010
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG010;
            break;
        case 0x91:                   // mod/rm = 10 001, reg=010
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG010;
            break;
        case 0x92:                   // mod/rm = 10 010, reg=010
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG010;
            break;
        case 0x93:                   // mod/rm = 10 011, reg=010
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG010;
            break;
        case 0x94:                   // mod/rm = 10 100, reg=010
            // s-i-b present
            cbInstr = 5 + scaled_index((BYTE *)(eipTemp+1), op1);
            op1->Immed = GET_LONG(eipTemp+cbInstr-3);
            op2->Reg = REG010;
            break;
        case 0x95:                   // mod/rm = 10 101, reg=010
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBP;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG010;
            break;
        case 0x96:                   // mod/rm = 10 110, reg=010
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG010;
            break;
        case 0x97:                   // mod/rm = 10 111, reg=010
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG010;
            break;

        case 0x98:                   // mod/rm = 10 000, reg=011
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG011;
            break;
        case 0x99:                   // mod/rm = 10 001, reg=011
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG011;
            break;
        case 0x9a:                   // mod/rm = 10 010, reg=011
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG011;
            break;
        case 0x9b:                   // mod/rm = 10 011, reg=011
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG011;
            break;
        case 0x9c:                   // mod/rm = 10 100, reg=011
            // s-i-b present
            cbInstr = 5 + scaled_index((BYTE *)(eipTemp+1), op1);
            op1->Immed = GET_LONG(eipTemp+cbInstr-3);
            op2->Reg = REG011;
            break;
        case 0x9d:                   // mod/rm = 10 101, reg=011
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBP;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG011;
            break;
        case 0x9e:                   // mod/rm = 10 110, reg=011
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG011;
            break;
        case 0x9f:                   // mod/rm = 10 111, reg=011
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG011;
            break;

        case 0xa0:                   // mod/rm = 10 000, reg=100
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG100;
            break;
        case 0xa1:                   // mod/rm = 10 001, reg=100
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG100;
            break;
        case 0xa2:                   // mod/rm = 10 010, reg=100
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG100;
            break;
        case 0xa3:                   // mod/rm = 10 011, reg=100
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG100;
            break;
        case 0xa4:                   // mod/rm = 10 100, reg=100
            // s-i-b present
            cbInstr = 5 + scaled_index((BYTE *)(eipTemp+1), op1);
            op1->Immed = GET_LONG(eipTemp+cbInstr-3);
            op2->Reg = REG100;
            break;
        case 0xa5:                   // mod/rm = 10 101, reg=100
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBP;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG100;
            break;
        case 0xa6:                   // mod/rm = 10 110, reg=100
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG100;
            break;
        case 0xa7:                   // mod/rm = 10 111, reg=100
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG100;
            break;

        case 0xa8:                   // mod/rm = 10 000, reg=101
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG101;
            break;
        case 0xa9:                   // mod/rm = 10 001, reg=101
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG101;
            break;
        case 0xaa:                   // mod/rm = 10 010, reg=101
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG101;
            break;
        case 0xab:                   // mod/rm = 10 011, reg=101
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG101;
            break;
        case 0xac:                   // mod/rm = 10 100, reg=101
            // s-i-b present
            cbInstr = 5 + scaled_index((BYTE *)(eipTemp+1), op1);
            op1->Immed = GET_LONG(eipTemp+cbInstr-3);
            op2->Reg = REG101;
            break;
        case 0xad:                   // mod/rm = 10 101, reg=101
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBP;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG101;
            break;
        case 0xae:                   // mod/rm = 10 110, reg=101
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG101;
            break;
        case 0xaf:                   // mod/rm = 10 111, reg=101
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG101;
            break;

        case 0xb0:                   // mod/rm = 10 000, reg=110
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG110;
            break;
        case 0xb1:                   // mod/rm = 10 001, reg=110
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG110;
            break;
        case 0xb2:                   // mod/rm = 10 010, reg=110
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG110;
            break;
        case 0xb3:                   // mod/rm = 10 011, reg=110
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG110;
            break;
        case 0xb4:                   // mod/rm = 10 100, reg=110
            // s-i-b present
            cbInstr = 5 + scaled_index((BYTE *)(eipTemp+1), op1);
            op1->Immed = GET_LONG(eipTemp+cbInstr-3);
            op2->Reg = REG110;
            break;
        case 0xb5:                   // mod/rm = 10 101, reg=110
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBP;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG110;
            break;
        case 0xb6:                   // mod/rm = 10 110, reg=110
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG110;
            break;
        case 0xb7:                   // mod/rm = 10 111, reg=110
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG110;
            break;

        case 0xb8:                   // mod/rm = 10 000, reg=111
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG111;
            break;
        case 0xb9:                   // mod/rm = 10 001, reg=111
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG111;
            break;
        case 0xba:                   // mod/rm = 10 010, reg=111
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG111;
            break;
        case 0xbb:                   // mod/rm = 10 011, reg=111
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG111;
            break;
        case 0xbc:                   // mod/rm = 10 100, reg=111
            // s-i-b present
            cbInstr = 5 + scaled_index((BYTE *)(eipTemp+1), op1);
            op1->Immed = GET_LONG(eipTemp+cbInstr-3);
            op2->Reg = REG111;
            break;
        case 0xbd:                   // mod/rm = 10 101, reg=111
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBP;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG111;
            break;
        case 0xbe:                   // mod/rm = 10 110, reg=111
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG111;
            break;
        case 0xbf:                   // mod/rm = 10 111, reg=111
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG111;
            break;

        /////////////////////////////////////////////////////////////////////

        case 0xc0:                   // mod/rm = 11 000, reg=000
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM000;
            op2->Reg = REG000;
            break;
        case 0xc1:                   // mod/rm = 11 001, reg=000
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM001;
            op2->Reg = REG000;
            break;
        case 0xc2:                   // mod/rm = 11 010, reg=000
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM010;
            op2->Reg = REG000;
            break;
        case 0xc3:                   // mod/rm = 11 011, reg=000
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM011;
            op2->Reg = REG000;
            break;
        case 0xc4:                   // mod/rm = 11 100, reg=000
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM100;
            op2->Reg = REG000;
            break;
        case 0xc5:                   // mod/rm = 11 101, reg=000
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM101;
            op2->Reg = REG000;
            break;
        case 0xc6:                   // mod/rm = 11 110, reg=000
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM110;
            op2->Reg = REG000;
            break;
        case 0xc7:                   // mod/rm = 11 111, reg=000
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM111;
            op2->Reg = REG000;
            break;

        case 0xc8:                   // mod/rm = 11 000, reg=001
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM000;
            op2->Reg = REG001;
            break;
        case 0xc9:                   // mod/rm = 11 001, reg=001
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM001;
            op2->Reg = REG001;
            break;
        case 0xca:                   // mod/rm = 11 010, reg=001
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM010;
            op2->Reg = REG001;
            break;
        case 0xcb:                   // mod/rm = 11 011, reg=001
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM011;
            op2->Reg = REG001;
            break;
        case 0xcc:                   // mod/rm = 11 100, reg=001
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM100;
            op2->Reg = REG001;
            break;
        case 0xcd:                   // mod/rm = 11 101, reg=001
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM101;
            op2->Reg = REG001;
            break;
        case 0xce:                   // mod/rm = 11 110, reg=001
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM110;
            op2->Reg = REG001;
            break;
        case 0xcf:                   // mod/rm = 11 111, reg=001
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM111;
            op2->Reg = REG001;
            break;

        case 0xd0:                   // mod/rm = 11 000, reg=010
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM000;
            op2->Reg = REG010;
            break;
        case 0xd1:                   // mod/rm = 11 001, reg=010
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM001;
            op2->Reg = REG010;
            break;
        case 0xd2:                   // mod/rm = 11 010, reg=010
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM010;
            op2->Reg = REG010;
            break;
        case 0xd3:                   // mod/rm = 11 011, reg=001
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM011;
            op2->Reg = REG010;
            break;
        case 0xd4:                   // mod/rm = 11 100, reg=010
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM100;
            op2->Reg = REG010;
            break;
        case 0xd5:                   // mod/rm = 11 101, reg=010
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM101;
            op2->Reg = REG010;
            break;
        case 0xd6:                   // mod/rm = 11 110, reg=010
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM110;
            op2->Reg = REG010;
            break;
        case 0xd7:                   // mod/rm = 11 111, reg=010
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM111;
            op2->Reg = REG010;
            break;

        case 0xd8:                   // mod/rm = 11 000, reg=011
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM000;
            op2->Reg = REG011;
            break;
        case 0xd9:                   // mod/rm = 11 001, reg=011
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM001;
            op2->Reg = REG011;
            break;
        case 0xda:                   // mod/rm = 11 010, reg=011
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM010;
            op2->Reg = REG011;
            break;
        case 0xdb:                   // mod/rm = 11 011, reg=011
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM011;
            op2->Reg = REG011;
            break;
        case 0xdc:                   // mod/rm = 11 100, reg=011
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM100;
            op2->Reg = REG011;
            break;
        case 0xdd:                   // mod/rm = 11 101, reg=011
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM101;
            op2->Reg = REG011;
            break;
        case 0xde:                   // mod/rm = 11 110, reg=011
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM110;
            op2->Reg = REG011;
            break;
        case 0xdf:                   // mod/rm = 11 111, reg=011
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM111;
            op2->Reg = REG011;
            break;

        case 0xe0:                   // mod/rm = 11 000, reg=100
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM000;
            op2->Reg = REG100;
            break;
        case 0xe1:                   // mod/rm = 11 001, reg=100
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM001;
            op2->Reg = REG100;
            break;
        case 0xe2:                   // mod/rm = 11 010, reg=100
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM010;
            op2->Reg = REG100;
            break;
        case 0xe3:                   // mod/rm = 11 011, reg=100
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM011;
            op2->Reg = REG100;
            break;
        case 0xe4:                   // mod/rm = 11 100, reg=100
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM100;
            op2->Reg = REG100;
            break;
        case 0xe5:                   // mod/rm = 11 101, reg=100
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM101;
            op2->Reg = REG100;
            break;
        case 0xe6:                   // mod/rm = 11 110, reg=100
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM110;
            op2->Reg = REG100;
            break;
        case 0xe7:                   // mod/rm = 11 111, reg=100
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM111;
            op2->Reg = REG100;
            break;

        case 0xe8:                   // mod/rm = 11 000, reg=101
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM000;
            op2->Reg = REG101;
            break;
        case 0xe9:                   // mod/rm = 11 001, reg=101
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM001;
            op2->Reg = REG101;
            break;
        case 0xea:                   // mod/rm = 11 010, reg=101
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM010;
            op2->Reg = REG101;
            break;
        case 0xeb:                   // mod/rm = 11 011, reg=101
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM011;
            op2->Reg = REG101;
            break;
        case 0xec:                   // mod/rm = 11 100, reg=101
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM100;
            op2->Reg = REG101;
            break;
        case 0xed:                   // mod/rm = 11 101, reg=101
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM101;
            op2->Reg = REG101;
            break;
        case 0xee:                   // mod/rm = 11 110, reg=101
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM110;
            op2->Reg = REG101;
            break;
        case 0xef:                   // mod/rm = 11 111, reg=101
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM111;
            op2->Reg = REG101;
            break;

        case 0xf0:                   // mod/rm = 11 000, reg=110
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM000;
            op2->Reg = REG110;
            break;
        case 0xf1:                   // mod/rm = 11 001, reg=110
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM001;
            op2->Reg = REG110;
            break;
        case 0xf2:                   // mod/rm = 11 010, reg=110
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM010;
            op2->Reg = REG110;
            break;
        case 0xf3:                   // mod/rm = 11 011, reg=110
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM011;
            op2->Reg = REG110;
            break;
        case 0xf4:                   // mod/rm = 11 100, reg=110
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM100;
            op2->Reg = REG110;
            break;
        case 0xf5:                   // mod/rm = 11 101, reg=110
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM101;
            op2->Reg = REG110;
            break;
        case 0xf6:                   // mod/rm = 11 110, reg=110
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM110;
            op2->Reg = REG110;
            break;
        case 0xf7:                   // mod/rm = 11 111, reg=110
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM111;
            op2->Reg = REG110;
            break;

        case 0xf8:                   // mod/rm = 11 000, reg=111
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM000;
            op2->Reg = REG111;
            break;
        case 0xf9:                   // mod/rm = 11 001, reg=111
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM001;
            op2->Reg = REG111;
            break;
        case 0xfa:                   // mod/rm = 11 010, reg=111
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM010;
            op2->Reg = REG111;
            break;
        case 0xfb:                   // mod/rm = 11 011, reg=111
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM011;
            op2->Reg = REG111;
            break;
        case 0xfc:                   // mod/rm = 11 100, reg=111
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM100;
            op2->Reg = REG111;
            break;
        case 0xfd:                   // mod/rm = 11 101, reg=111
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM101;
            op2->Reg = REG111;
            break;
        case 0xfe:                   // mod/rm = 11 110, reg=111
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM110;
            op2->Reg = REG111;
            break;
        default:
        case 0xff:                   // mod/rm = 11 111, reg=111
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM111;
            op2->Reg = REG111;
            break;
        }
    return cbInstr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\entrypt\redblack.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    redblack.c

Abstract:
    
    This module implements red/black trees.
    
Author:

    16-Jun-1995 t-orig

Revision History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "entrypt.h"
#include "redblack.h"
#include "stdio.h"
#include "stdlib.h"

// Disable warnings about MACRO redefinitions.   I'm redefining MACROS on 
// purpose...
#pragma warning (disable:4005)


//*************************************************************
//The Intel  Section:
//*************************************************************

//Intel MACROS
#define START(x)        x->ep.intelStart
#define END(x)          x->ep.intelEnd
#define KEY(x)          x->ep.intelStart
#define RIGHT(x)        x->intelRight
#define LEFT(x)         x->intelLeft
#define PARENT(x)       x->intelParent
#define COLOR(x)        x->intelColor

#define RB_INSERT       insertNodeIntoIntelTree
#define FIND            findIntel
#define CONTAINSRANGE   intelContainsRange
#define REMOVE          deleteNodeFromIntelTree
#define LEFT_ROTATE     intelLeftRotate
#define RIGHT_ROTATE    intelRightRotate
#define TREE_INSERT     intelTreeInsert
#define TREE_SUCCESSOR  intelTreeSuccessor
#define RB_DELETE       intelRBDelete
#define RB_DELETE_FIXUP intelRBDeleteFixup
#define FINDNEXT        findIntelNext

#include "redblack.fnc"


        
#ifdef BOTH
//*************************************************************
//The RISC  Section:
//*************************************************************

//RISC MACROS
#define START(x)        x->ep.nativeStart
#define END(x)          x->ep.nativeEnd
#define KEY(x)          x->ep.nativeStart
#define RIGHT(x)        x->nativeRight
#define LEFT(x)         x->nativeLeft
#define PARENT(x)       x->nativeParent
#define COLOR(x)        x->nativeColor

#define RB_INSERT       insertNodeIntoNativeTree
#define FIND            findNative
#define CONTAINSRANGE   nativeContainsRange
#define REMOVE          deleteNodeFromNativeTree
#define LEFT_ROTATE     nativeLeftRotate
#define RIGHT_ROTATE    nativeRightRotate
#define TREE_INSERT     nativeTreeInsert
#define TREE_SUCCESSOR  nativeTreeSuccessor
#define RB_DELETE       nativeRBDelete
#define RB_DELETE_FIXUP nativeRBDeleteFixup
#define FINDNEXT        findNativeNext

#include "redblack.fnc"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\decoder\wordfns.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    wordfns.c

Abstract:
    
    Instuctions which operate on 16-bit WORDS

Author:

    29-Jun-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "cpuassrt.h"
#include "threadst.h"
#include "instr.h"
#include "decoderp.h"
#include "wordfns.h"

ASSERTNAME;

// set up to include common functions
#define GET_REG 	    get_reg16
#define MANGLENAME(x)       x ## 16
#define MSB		    0x8000
#define MOD_RM              mod_rm_reg16
#define UTYPE		    unsigned short
#define STYPE		    signed short
#define GET_VAL 	    GET_SHORT
#define PUT_VAL 	    PUT_SHORT
#define PUSH_VAL	    PUSH_SHORT
#define POP_VAL             POP_SHORT
#define OPNAME(x)           OP_ ## x ## 16
#define LOCKOPNAME(x)       OP_SynchLock ## x ## 16
#define DISPATCHCOMMON(fn)  DISPATCH(fn ## 16)
#define CALLFRAGCOMMON0(fn)            CALLFRAG0( fn ## 16 )
#define CALLFRAGCOMMON1(fn, pop1)      CALLFRAG1( fn ## 16 , pop1)
#define CALLFRAGCOMMON2(fn, pop1, op2) CALLFRAG2( fn ## 16 , pop1, op2)
#define AREG                GP_AX
#define BREG                GP_BX
#define CREG                GP_CX
#define DREG                GP_DX
#define SPREG               GP_SP
#define BPREG               GP_BP
#define SIREG               GP_SI
#define DIREG               GP_DI
#define DEREF(Op)           DEREF16(Op)

// include the common functions with 8/16/32 flavors
#include "common.c"

// include the common functions with 16/32 flavors
#include "comm1632.c"

// create the mod_rm_reg16() decoder function
#define MOD11_RM000         GP_AX
#define MOD11_RM001         GP_CX
#define MOD11_RM010         GP_DX
#define MOD11_RM011         GP_BX
#define MOD11_RM100         GP_SP
#define MOD11_RM101         GP_BP
#define MOD11_RM110         GP_SI
#define MOD11_RM111         GP_DI
#define REG000              GP_AX
#define REG001              GP_CX
#define REG010              GP_DX
#define REG011              GP_BX
#define REG100              GP_SP
#define REG101              GP_BP
#define REG110              GP_SI
#define REG111              GP_DI
#define MOD_RM_DECODER      mod_rm_reg16
#include "modrm.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\fpufprem.c ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    fpufprem.c

Abstract:

    Floating point remainder fragments (FPREM, FPREM1)

Author:

    04-Oct-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <float.h>
#include <math.h>
#include <errno.h>
#include <stdio.h>
#include "wx86.h"
#include "fragp.h"
#include "fpufrags.h"
#include "fpufragp.h"

//
// Forward references
//
NPXFUNC2(FPREM_VALID_VALID);
NPXFUNC2(FPREM_VALID_ZERO);
NPXFUNC2(FPREM_VALID_SPECIAL);
NPXFUNC2(FPREM_ZERO_VALIDORZERO);
NPXFUNC2(FPREM_ZERO_SPECIAL);
NPXFUNC2(FPREM_SPECIAL_VALIDORZERO);
NPXFUNC2(FPREM_SPECIAL_SPECIAL);
NPXFUNC2(FPREM_EMPTY_ANY);
NPXFUNC2(FPREM_ANY_EMPTY);

NPXFUNC2(FPREM1_VALID_VALID);
//NPXFUNC2(FPREM1_VALID_ZERO);       // same as FPREM_VALID_ZERO
NPXFUNC2(FPREM1_VALID_SPECIAL);
//NPXFUNC2(FPREM1_ZERO_VALIDORZERO); // same as FPREM_ZERO_VALIDORZERO
NPXFUNC2(FPREM1_ZERO_SPECIAL);
NPXFUNC2(FPREM1_SPECIAL_VALIDORZERO);
NPXFUNC2(FPREM1_SPECIAL_SPECIAL);
NPXFUNC2(FPREM1_EMPTY_ANY);
NPXFUNC2(FPREM1_ANY_EMPTY);


//
// Jump tables
//
const NpxFunc2 FPREMTable[TAG_MAX][TAG_MAX] = {
    // left is TAG_VALID, right is ...
    { FPREM_VALID_VALID, FPREM_VALID_ZERO, FPREM_VALID_SPECIAL, FPREM_ANY_EMPTY },
    // left is TAG_ZERO, right is ...
    { FPREM_ZERO_VALIDORZERO, FPREM_ZERO_VALIDORZERO, FPREM_ZERO_SPECIAL, FPREM_ANY_EMPTY },
    // left is TAG_SPECIAL, right is ...
    { FPREM_SPECIAL_VALIDORZERO, FPREM_SPECIAL_VALIDORZERO, FPREM_SPECIAL_SPECIAL, FPREM_ANY_EMPTY },
    // left is TAG_EMPTY, right is ...
    { FPREM_EMPTY_ANY, FPREM_EMPTY_ANY, FPREM_EMPTY_ANY, FPREM_EMPTY_ANY }
};

const NpxFunc2 FPREM1Table[TAG_MAX][TAG_MAX] = {
    // left is TAG_VALID, right is ...
    { FPREM1_VALID_VALID, FPREM_VALID_ZERO, FPREM1_VALID_SPECIAL, FPREM1_ANY_EMPTY },
    // left is TAG_ZERO, right is ...
    { FPREM_ZERO_VALIDORZERO, FPREM_ZERO_VALIDORZERO, FPREM1_ZERO_SPECIAL, FPREM1_ANY_EMPTY },
    // left is TAG_SPECIAL, right is ...
    { FPREM1_SPECIAL_VALIDORZERO, FPREM1_SPECIAL_VALIDORZERO, FPREM1_SPECIAL_SPECIAL, FPREM1_ANY_EMPTY },
    // left is TAG_EMPTY, right is ...
    { FPREM1_EMPTY_ANY, FPREM1_EMPTY_ANY, FPREM1_EMPTY_ANY, FPREM1_EMPTY_ANY }
};


NPXFUNC2(FPREM_VALID_VALID)
{
    int ExpL;
    int ExpR;
    int ExpDiff;
    LONG Q;
    double DQ;

    ExpL = (int)((l->rdw[1] >> 20) & 0x7ff) - 1023;
    ExpR = (int)((r->rdw[1] >> 20) & 0x7ff) - 1023;
    ExpDiff = abs(ExpL-ExpR);
    if (ExpDiff < 64) {

        // Do the division and chop the integer result towards zero
        DQ = r->r64 / l->r64;
        if (DQ < 0) {
            Q = (long)ceil(DQ);
        } else {
            Q = (long)floor(DQ);
        }

        // Store the remainder
        r->r64 -= (DOUBLE)Q * l->r64;
        SetTag(r);

        // Store the status bits
        if (Q < 0) {
            //
            // Take the absolute value of Q before returning the low 3 bits
            // of the quotient.
            //
            Q = -Q;
        }
        cpu->FpStatusC2 = 0;            // indicate the final remainder is ready
        cpu->FpStatusC0 = (Q>>2) & 1;
        cpu->FpStatusC3 = (Q>>1) & 1;
        cpu->FpStatusC1 = Q & 1;
    } else {
        DOUBLE PowerOfTwo;

        cpu->FpStatusC2 = 1;            // indicate the app must loop more
        PowerOfTwo = ldexp(1.0, ExpDiff-32);    // get 2^(ExpDiff-32)

        // get Q by chopping towards zero
        DQ = (r->r64/PowerOfTwo) / (l->r64/PowerOfTwo);
        if (DQ < 0) {
            Q = (long)ceil(DQ);
        } else {
            Q = (long)floor(DQ);
        }
        r->r64 -= (DOUBLE)Q * l->r64 * PowerOfTwo;
        SetTag(r);
    }
}

NPXFUNC2(FPREM_VALID_ZERO)
{
    // l is a number, but r is zero - return ST(0) unchanged
    cpu->FpStatusC2 = 0;            // indicate the final remainder is ready
    // Q is 0, so store low 3 bits in the status word
    cpu->FpStatusC0 = 0;
    cpu->FpStatusC1 = 0;
    cpu->FpStatusC3 = 0;
}

NPXFUNC2(FPREM_VALID_SPECIAL)
{
    switch (l->TagSpecial) {
    case TAG_SPECIAL_DENORM:
        FPREM_VALID_VALID(cpu, l, r);
        break;

    case TAG_SPECIAL_INFINITY:
        // Dividing infinity.
        SetIndefinite(r);
        break;

    case TAG_SPECIAL_SNAN:
        if (HandleSnan(cpu, r)) {
            return;
        }
        // else fall into QNAN case

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_INDEF:
        // r is the destination and it is a QNAN, while l is a VALID.  Return
        // the QNAN as the result of the operation
        // x86 emulator leaves condition flags alone
        break;
    }
}

NPXFUNC2(FPREM_ZERO_VALIDORZERO)
{
    // l is zero, and r is a number or zero - return INDEFINITE due to the
    // division by zero.
    if (!HandleInvalidOp(cpu)) {
        SetIndefinite(r);
    }
}

NPXFUNC2(FPREM_ZERO_SPECIAL)
{
    if (r->TagSpecial == TAG_SPECIAL_INFINITY) {
        SetIndefinite(r);
    } else {
        FPREM_VALID_SPECIAL(cpu, l, r);
    }
}

NPXFUNC2(FPREM_SPECIAL_VALIDORZERO)
{
    switch (l->TagSpecial) {
    case TAG_SPECIAL_DENORM:
        FPREM_VALID_VALID(cpu, l, r);
        break;

    case TAG_SPECIAL_INFINITY:
        // number / infinity - quotient == 0
        cpu->FpStatusC2 = 0;
        cpu->FpStatusC0 = 0;
        cpu->FpStatusC1 = 0;
        cpu->FpStatusC3 = 0;
        break;

    case TAG_SPECIAL_SNAN:
        if (HandleSnan(cpu, l)) {
            return;
        }
        // else fall into QNAN case

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_INDEF:
        // r is the destination and it is a VALID, while l is a NAN.  Return
        // the NAN as the result of the operation
        r->r64 = l->r64;
        r->Tag = l->Tag;
        r->TagSpecial = l->TagSpecial;
        // x86 emulator leaves condition flags alone
        break;
    }
}

NPXFUNC2(FPREM_SPECIAL_SPECIAL)
{
    if (l->TagSpecial == TAG_SPECIAL_DENORM) {
        FPREM_VALID_SPECIAL(cpu, l, r);
        return;
    }

    if (r->TagSpecial == TAG_SPECIAL_DENORM) {
        FPREM_SPECIAL_VALIDORZERO(cpu, l, r);
    }

    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }

    if (l->TagSpecial == TAG_SPECIAL_INFINITY) {
        if (r->TagSpecial == TAG_SPECIAL_INFINITY) {
            SetIndefinite(r);
        }
        //
        // r is a NAN of some sort, and l is infinity - return the NAN
        // which is already in r.
        //
    } else {
        //
        // l is a NAN, and r is either a NAN or INFINITY.  Have the native
        // FPU return the largest NAN, and re-tag it as appropriate.
        //
        r->r64 = l->r64 + r->r64;
        SetTag(r);
    }

}

NPXFUNC2(FPREM_EMPTY_ANY)
{
    if (HandleStackEmpty(cpu, l)) {
        return;
    }
    (*FPREMTable[l->Tag][r->Tag])(cpu, l, r);
}

NPXFUNC2(FPREM_ANY_EMPTY)
{
    if (HandleStackEmpty(cpu, l)) {
        return;
    }
    (*FPREMTable[l->Tag][r->Tag])(cpu, l, r);
}


FRAG0(FPREM)
{
    // get remainder of r/l

    PFPREG l = &cpu->FpStack[ST(1)];
    PFPREG r = cpu->FpST0;

    FpArithPreamble(cpu);
    (*FPREMTable[l->Tag][r->Tag])(cpu, l, r);
}

NPXFUNC2(FPREM1_VALID_VALID)
{
    int ExpL;
    int ExpR;
    int ExpDiff;
    LONG Q;
    double DQ;
    double FloorQ, CeilQ;

    ExpL = (int)((l->rdw[1] >> 20) & 0x7ff) - 1023;
    ExpR = (int)((r->rdw[1] >> 20) & 0x7ff) - 1023;
    ExpDiff = abs(ExpL-ExpR);
    if (ExpDiff < 64) {

        // Do the division and get the integer nearest to the value
        DQ = r->r64 / l->r64;
        FloorQ = floor(DQ);
        CeilQ = ceil(DQ);
        if (DQ-FloorQ >= CeilQ-DQ) {
            // CeilQ is closer - use it
            Q = (long)CeilQ;
        } else {
            // FloorQ is closer - use it
            Q = (long)FloorQ;
        }

        // Store the remainder
        r->r64 -= (DOUBLE)Q * l->r64;
        SetTag(r);

        // Store the status bits
        if (Q < 0) {
            //
            // Take the absolute value of Q before returning the low 3 bits
            // of the quotient.
            //
            Q = -Q;
        }
        cpu->FpStatusC2 = 0;            // indicate the final remainder is ready
        cpu->FpStatusC0 = (Q>>2) & 1;
        cpu->FpStatusC3 = (Q>>1) & 1;
        cpu->FpStatusC1 = Q & 1;
    } else {
        DOUBLE PowerOfTwo;

        cpu->FpStatusC2 = 1;            // indicate the app must loop more
        PowerOfTwo = ldexp(1.0, ExpDiff-32);    // get 2^(ExpDiff-32)

        // get Q by finding the integer nearest to the value
        DQ = (r->r64/PowerOfTwo) / (l->r64/PowerOfTwo);
        FloorQ = floor(DQ);
        CeilQ = ceil(DQ);
        if (DQ-FloorQ >= CeilQ-DQ) {
            // CeilQ is closer - use it
            Q = (long)CeilQ;
        } else {
            // FloorQ is closer - use it
            Q = (long)FloorQ;
        }
        r->r64 -= (DOUBLE)Q * l->r64 * PowerOfTwo;
        SetTag(r);
    }
}

NPXFUNC2(FPREM1_VALID_SPECIAL)
{
    switch (l->TagSpecial) {
    case TAG_SPECIAL_DENORM:
        FPREM1_VALID_VALID(cpu, l, r);
        break;

    case TAG_SPECIAL_INFINITY:
        // dividing infinity
        SetIndefinite(r);
        break;

    case TAG_SPECIAL_SNAN:
        if (HandleSnan(cpu, r)) {
            return;
        }
        // else fall into QNAN case

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_INDEF:
        // r is the destination and it is a QNAN, while l is a VALID.  Return
        // the QNAN as the result of the operation
        // x86 emulator leaves condition flags alone
        break;
    }
}

NPXFUNC2(FPREM1_ZERO_SPECIAL)
{
    if (r->TagSpecial == TAG_SPECIAL_INFINITY) {
        SetIndefinite(r);
    } else {
        FPREM1_VALID_SPECIAL(cpu, l, r);
    }
}

NPXFUNC2(FPREM1_SPECIAL_VALIDORZERO)
{
    switch (l->TagSpecial) {
    case TAG_SPECIAL_DENORM:
        FPREM1_VALID_VALID(cpu, l, r);
        break;

    case TAG_SPECIAL_INFINITY:
        // number / infinity - quotient == 0
        cpu->FpStatusC2 = 0;
        cpu->FpStatusC0 = 0;
        cpu->FpStatusC1 = 0;
        cpu->FpStatusC3 = 0;
        break;

    case TAG_SPECIAL_SNAN:
        if (HandleSnan(cpu, l)) {
            return;
        }
        // else fall into QNAN case

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_INDEF:
        // r is the destination and it is a VALID, while l is a NAN.  Return
        // the NAN as the result of the operation
        r->r64 = l->r64;
        r->Tag = l->Tag;
        r->TagSpecial = l->TagSpecial;
        break;
    }
}

NPXFUNC2(FPREM1_SPECIAL_SPECIAL)
{
    if (l->TagSpecial == TAG_SPECIAL_DENORM) {
        FPREM1_VALID_SPECIAL(cpu, l, r);
        return;
    }

    if (r->TagSpecial == TAG_SPECIAL_DENORM) {
        FPREM1_SPECIAL_VALIDORZERO(cpu, l, r);
    }

    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }

    if (l->TagSpecial == TAG_SPECIAL_INFINITY) {
        if (r->TagSpecial == TAG_SPECIAL_INFINITY) {
            SetIndefinite(r);
        }
        //
        // r is a NAN of some sort, and l is infinity - return the NAN
        // which is already in r.
        //
    } else {
        //
        // l is a NAN, and r is either a NAN or INFINITY.  Have the native
        // FPU return the largest NAN, and re-tag it as appropriate.
        //
        r->r64 = l->r64 + r->r64;
        SetTag(r);
    }

}

NPXFUNC2(FPREM1_EMPTY_ANY)
{
    if (HandleStackEmpty(cpu, l)) {
        return;
    }
    (*FPREM1Table[l->Tag][r->Tag])(cpu, l, r);
}

NPXFUNC2(FPREM1_ANY_EMPTY)
{
    if (HandleStackEmpty(cpu, l)) {
        return;
    }
    (*FPREM1Table[l->Tag][r->Tag])(cpu, l, r);
}
FRAG0(FPREM1)
{
    // get remainder of r/l

    PFPREG l = &cpu->FpStack[ST(1)];
    PFPREG r = cpu->FpST0;

    FpArithPreamble(cpu);
    (*FPREM1Table[l->Tag][r->Tag])(cpu, l, r);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\fpuarith.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    fpuarith.h

Abstract:
    
    Common code for arithmetic floating-point operations.

Author:

    04-Oct-1995 BarryBo, Created

Revision History:

--*/

#ifndef FPUARITH_H
#define FPUARITH_H

VOID
ChangeFpPrecision(
    PCPUDATA cpu,
    INT NewPrecision
    );

VOID
FpAddCommon(
    PCPUDATA cpu,
    PFPREG   l,
    PFPREG   r
    );

VOID
FpDivCommon(
    PCPUDATA cpu,
    PFPREG   dest,
    PFPREG   l,
    PFPREG   r
    );

VOID
FpMulCommon(
    PCPUDATA cpu,
    PFPREG   l,
    PFPREG   r
    );

VOID
FpSubCommon(
    PCPUDATA cpu,
    PFPREG   dest,
    PFPREG   l,
    PFPREG   r
    );

VOID
FpComCommon(
    PCPUDATA cpu,
    PFPREG   l,
    PFPREG   r,
    BOOL     fUnordered
    );

#endif //FPUARITH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\entrypt\redblack.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    redblack.h

Abstract:
    
    Prototypes for the red/black tree implementation.
    
Author:

    16-Jun-1995 t-orig

Revision History:

--*/



// Intel prototypes:
PEPNODE
insertNodeIntoIntelTree(
    PEPNODE root,
    PEPNODE x,
    PEPNODE NIL
    );

PEPNODE
findIntel(
    PEPNODE root,
    PVOID addr,
    PEPNODE NIL
    );

PEPNODE
findIntelNext(
    PEPNODE root,
    PVOID addr,
    PEPNODE NIL
    );

PEPNODE
intelRBDelete(
    PEPNODE root,
    PEPNODE z,
    PEPNODE NIL
    );

BOOLEAN
intelContainsRange(
    PEPNODE root,
    PEPNODE NIL,
    PVOID StartAddr,
    PVOID EndAddr
    );



// RISC prototypes
PEPNODE
insertNodeIntoNativeTree(
    PEPNODE root,
    PEPNODE x,
    PEPNODE NIL
    );

PEPNODE
findNative(
    PEPNODE root,
    PVOID addr,
    PEPNODE NIL
    );

PEPNODE
findNativeNext(
    PEPNODE root,
    PVOID addr,
    PEPNODE NIL
    );

PEPNODE
nativeRBDelete(
    PEPNODE root,
    PEPNODE z,
    PEPNODE NIL
    );

BOOLEAN
nativeContainsRange(
    PEPNODE root,
    PEPNODE NIL,
    PVOID StartAddr,
    PVOID EndAddr
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\fpufragp.h ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    fpufragp.h

Abstract:
    
    Private include file for the 487 emulator portion of the Fragment Library

Author:

    04-Oct-1995 BarryBo, Created

Revision History:

--*/

#ifndef FPUFRAGP_H
#define FPUFRAGP_H

//
// ALPHA, PPC and INTEL have the same bit-patterns for QNAN/SNAN/INDEFINITE.
// MIPS has different representations.  NATIVE_NAN_IS_INTEL_FORMAT
// is used to distinguish between the different representations.
//
#if defined(_ALPHA_) || defined(_PPC_)
    #define NATIVE_NAN_IS_INTEL_FORMAT  1
#elif defined(_MIPS_)
    #define NATIVE_NAN_IS_INTEL_FORMAT  0
#else
    #error Unknown machine type
#endif


// Macros to access the register stack
#define ST(i)   ((cpu->FpTop+(i)) & 0x07)

#define PUSHFLT(x) {                    \
    INT Top;                            \
    Top = (cpu->FpTop-1) & 0x07;        \
    cpu->FpTop = Top;                   \
    x = cpu->FpST0 = &cpu->FpStack[Top];\
}

#define INCFLT  {                       \
    INT Top;                            \
    Top = (cpu->FpTop+1) & 0x07;        \
    cpu->FpTop = Top;                   \
    cpu->FpST0 = &cpu->FpStack[Top];    \
}

#define POPFLT  { cpu->FpST0->Tag = TAG_EMPTY; INCFLT; }


// Values for cpu->FpReg[].Tag
#define TAG_VALID   0       // value specified by Intel
#define TAG_ZERO    1       // value specified by Intel
#define TAG_SPECIAL 2       // value specified by Intel, indicates SpecialTag is set
#define TAG_EMPTY   3       // value specified by Intel
#define TAG_MAX     4       // value after the highest legal tag value


// Values for cpu->FpReg[].SpecialTag, valid only when Tag==TAG_SPECIAL
#define TAG_SPECIAL_DENORM  0       // private value for NPX emulator
#define TAG_SPECIAL_INFINITY 1      // private value for NPX emulator
#define TAG_SPECIAL_SNAN    2       // private value for NPX emulator
#define TAG_SPECIAL_QNAN    3       // private value for NPX emulator
#define TAG_SPECIAL_INDEF   4       // private value for NPX emulator

// Does a register hold a QNAN, SNAN, or INDEFINITE?
#define IS_TAG_NAN(FpReg)       \
    ((FpReg)->Tag == TAG_SPECIAL && (FpReg)->TagSpecial >= TAG_SPECIAL_SNAN)


// Common types used for jump tables in the 487 emulator
typedef VOID (*NpxFunc0)(PCPUDATA);
typedef VOID (*NpxFunc1)(PCPUDATA, PFPREG Fp);
typedef VOID (*NpxFunc2)(PCPUDATA cpu, PFPREG l, PFPREG r);
typedef VOID (*NpxFunc3)(PCPUDATA cpu, PFPREG dest, PFPREG l, PFPREG r);
typedef VOID (*NpxComFunc)(PCPUDATA cpu, PFPREG l, PFPREG r, BOOL fUnordered);
typedef VOID (*NpxPutIntelR4)(FLOAT *pIntelReal, PFPREG Fp);
typedef VOID (*NpxPutIntelR8)(DOUBLE *pIntelReal, PFPREG Fp);
typedef VOID (*NpxPutIntelR10)(PBYTE r10, PFPREG Fp);
typedef VOID (*NpxLoadIntelR10ToR8)(PCPUDATA cpu, PBYTE r10, PFPREG FpReg);
typedef VOID (*NpxPutI2)(PCPUDATA cpu, SHORT *pop1, PFPREG Fp);
typedef VOID (*NpxPutI4)(PCPUDATA cpu, LONG *pop1, PFPREG Fp);
typedef VOID (*NpxPutI8)(PCPUDATA cpu, LONGLONG *pop1, PFPREG Fp);

// Macros to declare functions for those common types
#define NPXFUNC0(name)  VOID name(PCPUDATA cpu)
#define NPXFUNC1(name)  VOID name(PCPUDATA cpu, PFPREG Fp)
#define NPXFUNC2(name)  VOID name(PCPUDATA cpu, PFPREG l, PFPREG r)
#define NPXFUNC3(name)  VOID name(PCPUDATA cpu, PFPREG dest, PFPREG l, PFPREG r)
#define NPXCOMFUNC(name) VOID name(PCPUDATA cpu, PFPREG l, PFPREG r, BOOL fUnordered)
#define NPXPUTINTELR4(name) VOID name(FLOAT *pIntelReal, PFPREG Fp)
#define NPXPUTINTELR8(name) VOID name(DOUBLE *pIntelReal, PFPREG Fp)
#define NPXPUTINTELR10(name) VOID name(PBYTE r10, PFPREG Fp)
#define NPXLOADINTELR10TOR8(name) VOID name(PCPUDATA cpu, PBYTE r10, PFPREG Fp)
#define NPXPUTI2(name)  VOID name(PCPUDATA cpu, SHORT *pop1, PFPREG Fp)
#define NPXPUTI4(name)  VOID name(PCPUDATA cpu, LONG *pop1, PFPREG Fp)
#define NPXPUTI8(name)  VOID name(PCPUDATA cpu, LONGLONG *pop1, PFPREG Fp)

extern const BYTE R8PositiveInfinityVal[8];
extern const BYTE R8NegativeInfinityVal[8];
#define R8PositiveInfinity *(DOUBLE *)R8PositiveInfinityVal
#define R8NegativeInfinity *(DOUBLE *)R8NegativeInfinityVal


VOID GetIntelR4(PFPREG Fp, FLOAT *pIntelReal);

#if NATIVE_NAN_IS_INTEL_FORMAT

    #define GetIntelR8(Fp, pIntelReal)                      \
        (Fp)->r64 = *(UNALIGNED DOUBLE *)(pIntelReal);      \
        SetTag(Fp);

    #define PutIntelR4(pIntelReal, Fp)                      \
        *(UNALIGNED FLOAT *)pIntelReal = (FLOAT)(Fp)->r64;

    #define PutIntelR8(pIntelReal, Fp)                      \
        *(UNALIGNED DOUBLE *)pIntelReal = (Fp)->r64;


#else

    VOID GetIntelR8(
        PFPREG Fp,
        DOUBLE *pIntelReal
        );

    extern NpxPutIntelR4 PutIntelR4Table[TAG_MAX];
    extern NpxPutIntelR8 PutIntelR8Table[TAG_MAX];

    #define PutIntelR4(pIntelReal, Fp)  \
        (*PutIntelR4Table[(Fp)->Tag])((pIntelReal), (Fp))

    #define PutIntelR8(pIntelReal, Fp)  \
        (*PutIntelR8Table[(Fp)->Tag])((pIntelReal), (Fp))

#endif

extern const NpxPutIntelR10 PutIntelR10Table[TAG_MAX];
#define PutIntelR10(pIntelReal, Fp)  (*PutIntelR10Table[(Fp)->Tag])((pIntelReal), (Fp))


VOID
SetTag(
    PFPREG FpReg
    );

VOID
ComputeR10Tag(
    USHORT *r10,
    PFPREG FpReg
    );

VOID
ChopR10ToR8(
    PBYTE r10,
    PFPREG FpReg,
    USHORT R10Exponent
);

VOID
LoadIntelR10ToR8(
    PCPUDATA cpu,
    PBYTE r10,
    PFPREG FpReg
);

BOOL
HandleSnan(
    PCPUDATA cpu,
    PFPREG   FpReg
    );

BOOL
HandleStackEmpty(
    PCPUDATA cpu,
    PFPREG FpReg
    );

VOID
UpdateFpExceptionFlags(
    PCPUDATA cpu
    );

VOID
SetIndefinite(
    PFPREG  FpReg
    );

BOOL
HandleInvalidOp(
    PCPUDATA cpu
    );

VOID
FpControlPreamble(
    PCPUDATA cpu
    );

VOID
FpArithPreamble(
    PCPUDATA cpu
    );

VOID
FpArithDataPreamble(
    PCPUDATA cpu,
    PVOID    FpData
    );

VOID
HandleStackFull(
    PCPUDATA cpu,
    PFPREG   FpReg
    );


#endif //FPUFRAGP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\fpufrags.c ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    fpufrags.c

Abstract:

    Floating point instruction fragments

Author:

    06-Jul-1995 BarryBo

Revision History:

      24-Aug-1999 [askhalid] copied from 32-bit wx86 directory and make work for 64bit.

--*/


/*
 *  Important design considerations:
 *
 * 1. Floating-point precision 32/64/80-bits.
 *      On a 487, all operations use 80-bit precision except for ADD, SUB(R),
 *      MUL, DIV(R), and SQRT, which use the precision control.
 *
 *      The emulator uses 64-bit precision for all operations except for those
 *      listed above, where 32-bit precision will be used if the app enables it.
 *
 * 2. Unmasked FP exceptions.
 *      The native FPU is set to mask *ALL* FP exceptions.  The emulator polls
 *      for exceptions at the ends of emulated instructions and simulates
 *      masked/unmasked exceptions as required.  If this is not done, the
 *      following scenerio can occur:
 *
 *       1. App unmasks all exceptions
 *       2. App loads two SNANS
 *       3. App performs FADD ST, ST(1)
 *       4. The emulated FADD is implemented as NATIVE FADD, plus NATIVE FST.
 *           The NATIVE FADD will set an unmaked exception and the NATIVE FST
 *           will raise the exception.  On Intel, the FADD is a single FP
 *           instruction, and the exception will not be raised until the next
 *           Intel instruction.
 *
 * 3. INDEFINITE/QNAN/SNAN.
 *      MIPS and PPC have a different representation for NANs than Intel/Alpha.
 *      Within the FpRegs array, NANs are stored in the native RISC format.
 *      All loads and stores of native values to Intel memory must use
 *      PutIntelR4/PutIntelR8 and GetIntelR4/GetIntelR8, which hide the
 *      conversion to/from native format.
 *          See \\orville\razzle\src\crtw32\fpw32\include\trans.h.
 *
 * 4. Floating-point Tag Word.
 *      For speed, the emulator keeps richer information about the values
 *      than the 487 does.  TAG_SPECIAL is further classified into
 *      INDEFINITE, QNAN, SNAN, or INFINITY.
 *
 * 5. Raising an FP exception.
 *      The 487 keeps track of the address of the last FP instruction and
 *      the Effective Address used to point to its operand.  The instruction
 *      opcode is also stored.  This information is required because the 486
 *      integer unit is operating concurrently and probably has updated
 *      EIP before the 487 raised the exception.
 *
 *      The CPU emulator must make EIP available to the 487 emulator for
 *      this purpose, too.  The Effective Address is passed as a parameter to
 *      instructions which care, so there is no issue (which is why all
 *      FP fragments take BYREF parameters instead of BYVAL).
 *
 *      Note that EIP must point to the first prefix for the instruction, not
 *      the opcode itself.
 *
 *      Data pointer is not affected by FINIT, FLDCW, FSTCW, FSTSW, FCLEX,
 *      FSTENV, FLDENV, FSAVE, and FRSTOR.  Data pointer is UNDEFINED if
 *      the instruction did not have a memory operand.
 *
 * 6. Thread initialization.
 *      The per-thread initialization performs no floating-point operations
 *      so that integer-only threads do not incur any overhead in NT.  For
 *      example, on an Intel MP box, any thread which executes a single FP
 *      instruction incurs additional overhead during context-switch for that
 *      thread.  We only want to add that overhead if the Intel app being
 *      emulated actually uses FP instructions.
 *
 * 7. Floating-point formats:
 *      Figure 15-10 and Table 15-3 (Intel page 15-12) describe the formats.
 *      WARNING: Figure 15-10 indicates the highest addressed byte is at
 *               the right.  In fact, the the sign bit is in the highest-
 *               addressed byte!  The mantissa is in the lowest bytes,
 *               followed by the exponent (Bias = 127,1023,16383), followed
 *               by the sign bit.
 *
 *      ie. memory = 0x00 0x00 0x00 0x00 0x00 0x00 0x08 0x40
 *          means, reverse the byte order:
 *                   0x40 0x08 0x00 0x00 0x00 0x00 0x00 0x00
 *          convert to binary:
 *                     4    0    0    8    0    0
 *                   0100 0000 0000 1000 0000 0000 ....
 *                   ||-----------| |------------- .... |
 *                   |  exponent      mantissa
 *                   sign
 *
 *          To get the unbiased exponent, subtract off the bias (1023 for R8)
 *              E = e-bias = 1024 - 1023 = 1
 *
 *          To get the mantissa, there is an implicit leading '1' (except R10)
 *              mantissa = 1 concatenated with 1000 0000 .... = 11 = 1.5(decimal)
 *
 *          Therefore, the value is +2^1*1.5 = 3
 *
 *
 */

//UNDONE: handle loading of unsupported format numbers.  TimP converts them
//        silently to INDEFINITE (the masked exception behavior)

//UNDONE: Fix the DENORMAL cases so they throw exceptions if needed.


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <float.h>
#include <math.h>
#include <errno.h>
#include <stdio.h>
#include <limits.h>
#include "wx86.h"
#include "cpuassrt.h"
#include "config.h"
#include "fragp.h"
#include "fpufrags.h"
#include "fpufragp.h"
#include "fpuarith.h"

ASSERTNAME;

DWORD pfnNPXNPHandler;      // Address of x86 NPX emulator entrypoint


//
// Bit-patterns for +INFINITY and -INFINITY
//
const BYTE R8PositiveInfinityVal[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x7f };
const BYTE R8NegativeInfinityVal[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff };

//
// Sets floating-point ES bit in status word based on current control reg
// and status reg.
//
#define SetErrorSummary(cpu) {                              \
    if (!(cpu)->FpControlMask & (cpu)->FpStatusExceptions) {\
        (cpu)->FpStatusES = 1;                              \
    } else {                                                \
        (cpu)->FpStatusES = 0;                              \
    }                                                       \
}

//
// Forward declarations
//
VOID
StoreEnvironment(
    PCPUDATA cpu,
    DWORD    *pEnv
    );

// in fraglib\{mips|ppc|alpha}\fphelp.s:
VOID
SetNativeRoundingMode(
    DWORD x86RoundingMode
    );

#ifdef ALPHA
unsigned int GetNativeFPStatus(void);
#endif


NPXFUNC1(FRNDINT_VALID);
NPXFUNC1(FRNDINT_ZERO);
NPXFUNC1(FRNDINT_SPECIAL);
NPXFUNC1(FRNDINT_EMPTY);
NPXFUNC2(FSCALE_VALID_VALID);
NPXFUNC2(FSCALE_VALIDORZERO_VALIDORZERO);
NPXFUNC2(FSCALE_SPECIAL_VALIDORZERO);
NPXFUNC2(FSCALE_VALIDORZERO_SPECIAL);
NPXFUNC2(FSCALE_SPECIAL_SPECIAL);
NPXFUNC2(FSCALE_ANY_EMPTY);
NPXFUNC2(FSCALE_EMPTY_ANY);
NPXFUNC1(FSQRT_VALID);
NPXFUNC1(FSQRT_ZERO);
NPXFUNC1(FSQRT_SPECIAL);
NPXFUNC1(FSQRT_EMPTY);
NPXFUNC1(FXTRACT_VALID);
NPXFUNC1(FXTRACT_ZERO);
NPXFUNC1(FXTRACT_SPECIAL);
NPXFUNC1(FXTRACT_EMPTY);

const NpxFunc1 FRNDINTTable[TAG_MAX] = {
    FRNDINT_VALID,
    FRNDINT_ZERO,
    FRNDINT_SPECIAL,
    FRNDINT_EMPTY
};

const NpxFunc2 FSCALETable[TAG_MAX][TAG_MAX] = {
    // left is TAG_VALID, right is ...
    { FSCALE_VALID_VALID, FSCALE_VALIDORZERO_VALIDORZERO, FSCALE_VALIDORZERO_SPECIAL, FSCALE_ANY_EMPTY},
    // left is TAG_ZERO, right is ...
    { FSCALE_VALIDORZERO_VALIDORZERO, FSCALE_VALIDORZERO_VALIDORZERO, FSCALE_VALIDORZERO_SPECIAL, FSCALE_ANY_EMPTY},
    // left is TAG_SPECIAL, right is ...
    { FSCALE_SPECIAL_VALIDORZERO, FSCALE_SPECIAL_VALIDORZERO, FSCALE_SPECIAL_SPECIAL, FSCALE_ANY_EMPTY},
    // left is TAG_EMPTY, right is ...
    { FSCALE_EMPTY_ANY, FSCALE_ANY_EMPTY, FSCALE_ANY_EMPTY, FSCALE_EMPTY_ANY}
};

const NpxFunc1 FSQRTTable[TAG_MAX] = {
    FSQRT_VALID,
    FSQRT_ZERO,
    FSQRT_SPECIAL,
    FSQRT_EMPTY,
};

const NpxFunc1 FXTRACTTable[TAG_MAX] = {
    FXTRACT_VALID,
    FXTRACT_ZERO,
    FXTRACT_SPECIAL,
    FXTRACT_EMPTY
};


FRAG0(FpuInit)

/*++

Routine Description:

    Initialize the FPU emulator to match the underlying FPU hardware's state.
    Called once per thread.

Arguments:

    cpu - per-thread data

Return Value:

    None

--*/

{
    int i;
    ANSI_STRING ProcName;
    NTSTATUS Status;

    // IMPORTANT: Read note (6), above, before adding any new code here!

    // Initialize the non-zero values here.
    cpu->FpControlMask = FPCONTROL_IM|
                         FPCONTROL_DM|
                         FPCONTROL_ZM|
                         FPCONTROL_OM|
                         FPCONTROL_UM|
                         FPCONTROL_PM;
    cpu->FpST0 = &cpu->FpStack[0];
    for (i=0; i<8; ++i) {
        cpu->FpStack[i].Tag = TAG_EMPTY;
    }
    ChangeFpPrecision(cpu, 2);
}

FRAG1(FpuSaveContext, BYTE)

/*++

Routine Description:

    Store the CPU's state to memory.  The format is the same as FNSAVE and
    winnt.h's FLOATING_SAVE_AREA expect.

Arguments:

    cpu - per-thread data
    pop1 - destination where context is to be written.

Return Value:

    None

--*/

{
    INT i, ST;

    StoreEnvironment(cpu, (DWORD *)pop1);
    pop1+=28;   // move pop1 past the 28-byte Instruction and Data Pointer image
    for (i=0; i<8; ++i) {
        ST = ST(i);

        if (cpu->FpStack[ST].Tag == TAG_EMPTY) {
            // special case: writing out a TAG_EMPTY from FNSAVE should
            // not change the value to INDEFINITE - it should write out
            // the bits as if they were really a properly-tagged R8.
            FPREG Fp;

            Fp.r64 = cpu->FpStack[ST].r64;
            SetTag(&Fp);
            PutIntelR10(pop1, &Fp);
        } else {
            PutIntelR10(pop1, &cpu->FpStack[ST]);
        }
        pop1+=10;
    }
}


VOID
SetIndefinite(
    PFPREG  FpReg
    )

/*++

Routine Description:

    Writes an INDEFINITE to an FP register.

Arguments:

    FpReg - register to write the INDEFINITE to.

Return Value:

    None

--*/

{
    FpReg->Tag = TAG_SPECIAL;
    FpReg->TagSpecial = TAG_SPECIAL_INDEF;

#if NATIVE_NAN_IS_INTEL_FORMAT
    FpReg->rdw[0] = 0;
    FpReg->rdw[1] = 0xfff80000;
#else
    FpReg->rdw[0] = 0xffffffff;
    FpReg->rdw[1] = 0x7ff7ffff;
#endif
}


VOID
FpControlPreamble2(
    PCPUDATA cpu
    )

/*++

Routine Description:

    If any FP exceptions are pending from the previous FP instruction, raise
    them now.  Called at the top of each non-control FP instruction, if
    any floating-point exception is unmasked.

Arguments:

    cpu - per-thread data

Return Value:

    None

--*/

{

    //
    // Copy the RISC FP status register into the x86 FP status register
    //
    UpdateFpExceptionFlags(cpu);

    //
    // If there is an error (FpStatusES != FALSE), then raise the
    // unmasked exception if there is one.
    //
    if (cpu->FpStatusES) {
        EXCEPTION_RECORD ExRec;
        DWORD Exception = (~cpu->FpControlMask) & cpu->FpStatusExceptions;

        //
        // There was an unmasked FP exception set by the previous instruction.
        // Raise the exception now.  The order the bits are checked is
        // the same as Kt0720 in ntos\ke\i386\trap.asm checks them.
        //

        //
        // in ntos\ke\i386\trap.asm, floating-point exceptions all vector
        // to CommonDispatchException1Arg0d, which creates a 1-parameter
        // exception with 0 as the first dword of data.  Code in
        // \nt\private\sdktools\vctools\crt\fpw32\tran\i386\filter.c cares.
        // See _fpieee_flt(), where the line reads "if (pinfo[0]) {".
        //
        ExRec.NumberParameters = 1;         // 1 parameter
        ExRec.ExceptionInformation[0]=0;    // 0 = raised by hardware
        if (Exception & FPCONTROL_IM) {        // invalid operation
            if (cpu->FpStatusSF) {

                //
                // Can't use STATUS_FLOAT_STACK_CHECK, 'cause on RISC
                // nt kernel uses it to indicate the float instruction
                // needs to be emulated. The Wx86 exception filters
                // know how to handle this.
                //
                ExRec.ExceptionCode = STATUS_WX86_FLOAT_STACK_CHECK;

                //
                // STATUS_FLOAT_STACK_CHECK has two parameters:
                //  First is 0
                //  Second is the data offset
                //
                ExRec.NumberParameters = 2;
                ExRec.ExceptionInformation[1] = (DWORD)(ULONGLONG)cpu->FpData;  
            } else {
                ExRec.ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
            }
        } else if (Exception & FPCONTROL_ZM) {      // zero divide
            ExRec.ExceptionCode = STATUS_FLOAT_DIVIDE_BY_ZERO;
        } else if (Exception & FPCONTROL_DM) {      // denormal
            ExRec.ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
        } else if (Exception & FPCONTROL_OM) {      // overflow
            ExRec.ExceptionCode = STATUS_FLOAT_OVERFLOW;
        } else if (Exception & FPCONTROL_UM) {      // underflow
            ExRec.ExceptionCode = STATUS_FLOAT_UNDERFLOW;
        } else if (!cpu->FpControlMask & FPCONTROL_PM) {   // precision
            ExRec.ExceptionCode = STATUS_FLOAT_INEXACT_RESULT;
        } else {
            //
            // ES is set, but all pending exceptions are masked.
            //    ie. ES is set because ZE is set, but only the
            //        FpControlDM exception is unmasked.
            // Nothing to do, so return.
            //
            return;
        }

        ExRec.ExceptionFlags   = 0;     // continuable exception
        ExRec.ExceptionRecord  = NULL;
        ExRec.ExceptionAddress = (PVOID)cpu->FpEip; // addr of faulting instr

        CpupRaiseException(&ExRec);
    }
}

VOID
FpControlPreamble(
    PCPUDATA cpu
    )

/*++

Routine Description:

    If any FP exceptions are pending from the previous FP instruction, raise
    them now.  Called at the top of each non-control FP instruction.  This
    routine is kept small so it can be inlined by the C compiler.  Most of
    the time, FP exceptions are masked, so there is no work to do.

Arguments:

    cpu - per-thread data

Return Value:

    None

--*/

{
    if (cpu->FpControlMask == (FPCONTROL_IM|
                               FPCONTROL_DM|
                               FPCONTROL_ZM|
                               FPCONTROL_OM|
                               FPCONTROL_UM|
                               FPCONTROL_PM)) {
        //
        // All FP exceptions are masked.  Nothing to do.
        //
        return;
    }

    FpControlPreamble2(cpu);
}



VOID
FpArithPreamble(
    PCPUDATA cpu
    )

/*++

Routine Description:

    Called at the start of every arithmetic instruction which has no data
    pointer.  Calls FpControlPreamble() to handle any pending exceptions,
    then records the EIP and FP opcode for later exception handling.

    See Intel 16-2 for the list of arithmetic vs. nonarithmetic instructions.

Arguments:

    cpu - per-thread data

Return Value:

    None

--*/

{
    FpControlPreamble(cpu);

    // Save the EIP value for this instruction
    cpu->FpEip = eip;

    // Set the data pointer to 0 - this instruction doesn't have an EA
    cpu->FpData = NULL;
}


VOID
FpArithDataPreamble(
    PCPUDATA cpu,
    PVOID    FpData
    )

/*++

Routine Description:

    Called at the start of every arithmetic instruction which has a data
    pointer.  Calls FpArithPreamble() and FpControlPreamble().


Arguments:

    cpu         - per-thread data
    FpData      - pointer to data for this instruction

Return Value:

    None

--*/

{
    FpControlPreamble(cpu);

    // Save the EIP value for this instruction
    cpu->FpEip = eip;

    // Save the data pointer for this instruction
    cpu->FpData = FpData;
}

VOID
UpdateFpExceptionFlags(
    PCPUDATA cpu
    )
/*++

Routine Description:

    Copies native RISC Fp status bits into the x86 Fp status register.

Arguments:

    cpu - per-thread data

Return Value:

    None

--*/
{
    unsigned int NativeStatus;

    //
    // Get the current native FP status word, then clear it.
    // UNDONE: For speed, consider using native instructions to get and
    //         clear the status bits, rather than waiting for the C runtime
    //         to reformat the bits into the machine-independent format.
    //         This is especially true for _clearfp(), which returns the old
    //         fp status bits (except for those dealing with handled
    //         exceptions - the ones we want to look at).
    //
#ifdef ALPHA
    #define SW_FPCR_STATUS_INVALID          0x00020000
    #define SW_FPCR_STATUS_DIVISION_BY_ZERO 0x00040000
    #define SW_FPCR_STATUS_OVERFLOW         0x00080000
    #define SW_FPCR_STATUS_UNDERFLOW        0x00100000
    #define SW_FPCR_STATUS_INEXACT          0x00200000

    NativeStatus = GetNativeFPStatus();
#else
    #define SW_FPCR_STATUS_INVALID          _SW_INVALID
    #define SW_FPCR_STATUS_DIVISION_BY_ZERO _SW_ZERODIVIDE
    #define SW_FPCR_STATUS_OVERFLOW         _SW_OVERFLOW
    #define SW_FPCR_STATUS_UNDERFLOW        _SW_UNDERFLOW
    #define SW_FPCR_STATUS_INEXACT          _SW_INEXACT

    NativeStatus = _statusfp();
    _clearfp();
#endif

    //
    // Decide what exceptions have happened during the instruction.
    // Exceptions are rare, so assume there are none by testing to see if
    // any exception is pending before checking each individual bit.
    //
    if (NativeStatus & (SW_FPCR_STATUS_INVALID|
                        SW_FPCR_STATUS_DIVISION_BY_ZERO|
                        SW_FPCR_STATUS_OVERFLOW|
#ifndef ALPHA
                        _SW_DENORMAL|
#endif
                        SW_FPCR_STATUS_UNDERFLOW)) {

        DWORD Mask = cpu->FpControlMask;
        DWORD Exceptions = cpu->FpStatusExceptions;

        if (NativeStatus & SW_FPCR_STATUS_INVALID) {
            if (!(Mask & FPCONTROL_IM)) {
                cpu->FpStatusES = 1;    // Unmasked exception
            }
            Exceptions |= FPCONTROL_IM; // Invalid instruction
            cpu->FpStatusSF = 0;    // Invalid operand, not stack overflow/underflow
        }

        if (NativeStatus & SW_FPCR_STATUS_DIVISION_BY_ZERO) {
            if (!(Mask & FPCONTROL_ZM)) {
                cpu->FpStatusES = 1;    // Unmasked exception
            }
            Exceptions |= FPCONTROL_ZM;
        }

#ifndef ALPHA
        if (NativeStatus & _SW_DENORMAL) {
            if (!(Mask & FPCONTROL_DM)) {
                cpu->FpStatusES = 1;    // Unmasked exception
            }
            Exceptions |= FPCONTROL_DM;
        }
#endif

        if (NativeStatus & SW_FPCR_STATUS_OVERFLOW) {
            if (!(Mask & FPCONTROL_OM)) {
                cpu->FpStatusES = 1;    // Unmasked exception
            }
            Exceptions |= FPCONTROL_OM;
        }

        if (NativeStatus & SW_FPCR_STATUS_UNDERFLOW) {
            if (!(Mask & FPCONTROL_UM)) {
                cpu->FpStatusES = 1;    // Unmasked exception
            }
            Exceptions |= FPCONTROL_UM;
        }

        cpu->FpStatusExceptions = Exceptions;
    }
}


USHORT
GetControlReg(
    PCPUDATA cpu
    )

/*++

Routine Description:

    Creates the USHORT 487 Control Register from the current CPU state.

Arguments:

    cpu - per-thread data

Return Value:

    USHORT value of the 487 Control Register.

--*/

{
    USHORT c;

    c = (cpu->FpControlInfinity << 12) |
        (cpu->FpControlRounding << 10) |
        (cpu->FpControlPrecision << 8) |
        (1 << 6) |      // this reserved bit is 1 on 487 chips
        (USHORT)cpu->FpControlMask;

    return c;
}


VOID
SetControlReg(
    PCPUDATA cpu,
    USHORT   NewControl
    )

/*++

Routine Description:

    Sets the FPU Control Register to the specified value.  The native FPU
    is set to match.

Arguments:

    cpu        - per-thread data
    NewControl - new value for the Control Register.

Return Value:

    None.

--*/

{
    INT NewPrecision;

    // Break the Intel Control Word into component parts
    cpu->FpControlMask = NewControl & (FPCONTROL_IM|
                                       FPCONTROL_DM|
                                       FPCONTROL_ZM|
                                       FPCONTROL_OM|
                                       FPCONTROL_UM|
                                       FPCONTROL_PM);

    cpu->FpControlRounding  = (NewControl>>10) & 3;
    cpu->FpControlInfinity =  (NewControl>>12) & 3;

    NewPrecision = (NewControl>>8) & 3;
    if (NewPrecision != cpu->FpControlPrecision) {
        //
        // Modify jump tables for instructions which are sensitive
        // to the floating-point precision.
        //
        ChangeFpPrecision(cpu, NewPrecision);
    }

    // Set the native FPU to the correct rounding mode.  Precision
    // is emulated in software.
    SetNativeRoundingMode(cpu->FpControlRounding);

    // Setting the 487 control word may have masked or unmasked exceptions.
    SetErrorSummary(cpu);
}


USHORT
GetStatusReg(
    PCPUDATA cpu
    )

/*++

Routine Description:

    Creates the USHORT 487 Status Register from the current CPU state.

Arguments:

    cpu - per-thread data

Return Value:

    USHORT value of the 487 Status Register.

--*/

{
    USHORT s;

    UpdateFpExceptionFlags(cpu);

    s = (cpu->FpStatusES << 15) |       // The 'B' bit is a mirror of 'ES'
        (cpu->FpStatusC3 << 14) |
        (cpu->FpTop << 11) |
        (cpu->FpStatusC2 << 10) |
        (cpu->FpStatusC1 << 9) |
        (cpu->FpStatusC0 << 8) |
        (cpu->FpStatusES << 7) |
        (cpu->FpStatusSF << 6) |
        (USHORT)cpu->FpStatusExceptions;

    // the PE bit in the status word is hard-wired to 0, so mask it now.
    return s & ~FPCONTROL_PM;
}

VOID
SetStatusReg(
    PCPUDATA cpu,
    USHORT   NewStatus
)

/*++

Routine Description:

    Sets the FPU Status Register to the specified value.

Arguments:

    cpu       - per-thread data
    NewStatus - new value for the Status Register.

Return Value:

    None.

--*/

{
    //
    // Break the Intel Status Word into component parts
    //
    cpu->FpStatusExceptions = NewStatus & (FPCONTROL_IM|
                                           FPCONTROL_DM|
                                           FPCONTROL_ZM|
                                           FPCONTROL_OM|
                                           FPCONTROL_UM);
    cpu->FpStatusSF = (NewStatus >> 6) & 1;
    cpu->FpStatusC0 = (NewStatus >> 8) & 1;
    cpu->FpStatusC1 = (NewStatus >> 9) & 1;
    cpu->FpStatusC2 = (NewStatus >> 10) & 1;
    cpu->FpTop = (NewStatus >> 11) & 7;
    cpu->FpST0 = &cpu->FpStack[cpu->FpTop];
    cpu->FpStatusC3 = (NewStatus >> 14) & 1;

    //
    // ES (and B) are recomputed based on the mask bits in the control word.
    // The caller must do that by calling SetErrorSummary().
    //
}


USHORT
GetTagWord(
    PCPUDATA cpu
    )

/*++

Routine Description:

    Creates the USHORT 487 Tag Word from the current CPU state.

Arguments:

    cpu - per-thread data

Return Value:

    USHORT value of the 487 Tag Word.

--*/

{
    USHORT s;
    INT i;

    s = 0;
    for (i=7; i >= 0; --i) {
        s = (s << 2) | (USHORT)cpu->FpStack[i].Tag;
    }

    return s;
}

VOID
SetTagWord(
    PCPUDATA cpu,
    USHORT s
    )
/*++

Routine Description:

    Given a new Tag Word and the FP stack, recomputes the Tag field for each entry
    in the FP stack.

Arguments:

    cpu - per-thread data
    s   - new Tag word

Return Value:

    None.

--*/
{
    INT i;
    BYTE Tag;

    for(i=0; i < 8; ++i) {
        Tag = (BYTE)(s & 3);
        s >>= 2;

        if (Tag == TAG_EMPTY) {
            cpu->FpStack[i].Tag = TAG_EMPTY;
        } else {
            // Special value - must reclassify into the richer set of tags,
            // or the caller is setting the tags to valid or zero.  We must
            // reclassify them in case the value in the register is not what
            // the caller said it was.
            SetTag(&cpu->FpStack[i]);
        }
    }    
}

VOID GetEnvironment(
    PCPUDATA cpu,
    DWORD *pEnv
    )
/*++

Routine Description:

    Implements the core of FLDENV

Arguments:

    cpu - per-thread data
    pEnv - destination to load FP environment from

Return Value:

    None.

--*/
{
    SetControlReg(cpu, (USHORT)GET_LONG(pEnv));
    SetStatusReg(cpu, (USHORT)GET_LONG(pEnv+1));
    SetErrorSummary(cpu);
    SetTagWord(cpu, (USHORT)GET_LONG(pEnv+2));
    cpu->FpEip = GET_LONG(pEnv+3);
    // ignore CS = GET_LONG(pEnv+4);
    cpu->FpData = (PVOID)GET_LONG(pEnv+5);
    // ignore DS = GET_LONG(pEnv+6);
}


VOID
StoreEnvironment(
    PCPUDATA cpu,
    DWORD *pEnv
    )

/*++

Routine Description:

    Implements the core of FSTENV, FNSTENV

Arguments:

    cpu  - per-thread data
    pEnv - destination to store FP environment to

Return Value:

    None.

--*/

{
    PUT_LONG(pEnv,   (DWORD)GetControlReg(cpu));
    PUT_LONG(pEnv+1, (DWORD)GetStatusReg(cpu));
    PUT_LONG(pEnv+2, (DWORD)GetTagWord(cpu));
    PUT_LONG(pEnv+3, cpu->FpEip);
    //
    // If FpEip is zero, then assume the FPU is uninitialized (ie. app
    // has run FNINIT but no other FP instructions).  In that case, FNINIT
    // is supposed to have set FpCS and FpDS to 0.  We don't want to add
    // the extra overhead of settings FpCS and FpDS on each FP instruction.
    // Instead, we simulate this situation by writing 0 for the selector
    // values.
    //
    //
    if (cpu->FpEip) {
        PUT_LONG(pEnv+4, (DWORD)CS);
        PUT_LONG(pEnv+6, (DWORD)DS);
    } else {
        PUT_LONG(pEnv+4, 0);
        PUT_LONG(pEnv+6, 0);
    }
    PUT_LONG(pEnv+5, (DWORD)(ULONGLONG)cpu->FpData);   

    // Mask all exceptions
    cpu->FpControlMask = FPCONTROL_IM|
                         FPCONTROL_DM|
                         FPCONTROL_ZM|
                         FPCONTROL_OM|
                         FPCONTROL_UM|
                         FPCONTROL_PM;
}


BOOL
HandleStackEmpty(
    PCPUDATA cpu,
    PFPREG FpReg
    )

/*++

Routine Description:

    Handles FP stack underflow errors.  If Invalid Instruction Exceptions
    are masked, writes an INDEFINITE into the register.  Otherwise it records
    a pending exception and aborts the instruction.

Arguments:

    cpu   - per-thread data
    FpReg - reg to set to INDEFINITE if the exception is masked.

Return Value:

    None.

--*/

{
    cpu->FpStatusExceptions |= FPCONTROL_IM;
    cpu->FpStatusC1 = 0;    // O/U# = 0 = underflow
    cpu->FpStatusSF = 1;    // stack overflow/underflow, not invalid operand

    if (cpu->FpControlMask & FPCONTROL_IM) {
        // Invalid Operation is masked - handle it by returning INDEFINITE
        SetIndefinite(FpReg);
        return FALSE;
    } else {
        cpu->FpStatusES = 1;
        return TRUE;
    }
}


VOID
HandleStackFull(
    PCPUDATA cpu,
    PFPREG   FpReg
    )

/*++

Routine Description:

    Handles FP stack overflow errors.  If Invalid Instruction Exceptions
    are masked, writes an INDEFINITE into the register.  Otherwise it records
    a pending exception and aborts the instruction.

Arguments:

    cpu   - per-thread data
    FpReg - register which caused the error.

Return Value:

    None.

--*/

{
    CPUASSERT(FpReg->Tag != TAG_EMPTY);

    cpu->FpStatusExceptions |= FPCONTROL_IM;
    cpu->FpStatusC1 = 1;    // O/U# = 1 = overflow
    cpu->FpStatusSF = 1;    // stack overflow/underflow, not invalid operand

    if (cpu->FpControlMask & FPCONTROL_IM) {
        // Invalid Operation is masked - handle it by returning INDEFINITE
        SetIndefinite(FpReg);
    } else {
        cpu->FpStatusES = 1;
    }
}


BOOL
HandleInvalidOp(
    PCPUDATA cpu
    )

/*++

Routine Description:

    Called whenever an instruction handles an invalid operation.  If exceptions
    are masked, it is a no-op.  Otherwise it records a pending excption and
    aborts the operation.

Arguments:

    cpu - per-thread data

Return Value:

    BOOL - TRUE if instruction should be aborted due to unmasked exception.

--*/

{
    cpu->FpStatusExceptions |= FPCONTROL_IM;
    cpu->FpStatusSF = 0;    // invalid operand, not stack overflow/underflow

    if (cpu->FpControlMask & FPCONTROL_IM) {
        // Invalid Operation is masked - continue instruction
        return FALSE;
    } else {
        // Unmasked exception - abort instruction
        cpu->FpStatusES = 1;
        return TRUE;
    }
}


BOOL
HandleSnan(
    PCPUDATA cpu,
    PFPREG   FpReg
    )

/*++

Routine Description:

    Handles the case when an SNAN (Signalling NAN) is detected.  If exceptions
    are masked, converts the SNAN to a QNAN with the same mantissa.  Otherwise,
    it records a pending exception and aborts the instruction.

Arguments:

    cpu   - per-thread data
    FpReg - register which caused the error.

Return Value:

    BOOL - TRUE if instruction should be aborted due to unmasked exception.

--*/

{
    BOOL fAbort;

    CPUASSERT(FpReg->Tag == TAG_SPECIAL && FpReg->TagSpecial == TAG_SPECIAL_SNAN);
#if NATIVE_NAN_IS_INTEL_FORMAT
    CPUASSERT((FpReg->rdw[1] & 0x00080000) == 0); // FP value is not a SNAN
#else
    CPUASSERT(FpReg->rdw[1] & 0x00080000);        // FP value is not a SNAN
#endif

    fAbort = HandleInvalidOp(cpu);
    if (!fAbort) {
        // Invalid Operation is masked - handle it by converting to QNAN
        FpReg->rdw[1] ^= 0x00080000; // invert the top bit of the mantissa
        FpReg->TagSpecial = TAG_SPECIAL_QNAN;
    }
    return fAbort;
}



FRAG0(FABS)
{
    PFPREG ST0;

    FpArithPreamble(cpu);
    cpu->FpStatusC1 = 0;        // assume no error
    ST0 = cpu->FpST0;
    switch (ST0->Tag) {
    case TAG_VALID:
    case TAG_ZERO:
        //
        // Clear the sign bit for NANs, VALID, ZERO, INFINITY, etc.
        //
        ST0->rdw[1] &= 0x7fffffff;
        break;

    case TAG_EMPTY:
        if (HandleStackEmpty(cpu, ST0)) {
            break;
        }
        // else fall through to TAG_SPECIAL

    case TAG_SPECIAL:
        //
        // Clear the sign bit for NANs, VALID, ZERO, INFINITY, etc.
        //
        ST0->rdw[1] &= 0x7fffffff;
        if (ST0->TagSpecial == TAG_SPECIAL_INDEF) {
            //
            // INDEFINITE with its sign changed to POSITIVE becomes just a QNAN
            //
            ST0->TagSpecial = TAG_SPECIAL_QNAN;
        }
        break;
    }
}

FRAG0(FCHS)
{
    PFPREG ST0;

    FpArithPreamble(cpu);
    cpu->FpStatusC1 = 0;        // assume no error
    ST0 = cpu->FpST0;
    switch (ST0->Tag) {
    case TAG_VALID:
    case TAG_ZERO:
        // toggle the sign bit for NANs, VALID, ZERO, INFINITY, etc.
        ST0->rdw[1] ^= 0x80000000;
        break;

    case TAG_EMPTY:
        if (HandleStackEmpty(cpu, ST0)) {
            break;
        }
        // else fall through to TAG_SPECIAL

    case TAG_SPECIAL:
        // toggle the sign bit for NANs, VALID, ZERO, INFINITY, etc.
        ST0->rdw[1] ^= 0x80000000;

        if (ST0->TagSpecial == TAG_SPECIAL_INDEF) {

            //
            // INDEFINITE with its sign changed to POSITIVE becomes
            // just a QNAN
            //
            ST0->TagSpecial = TAG_SPECIAL_QNAN;

        } else if (ST0->TagSpecial == TAG_SPECIAL_QNAN &&
                   ST0->rdw[0] == 0 &&
                   ST0->rdw[1] == 0xfff80000) {

            //
            // this particular QNAN becames INDEFINITE
            //
            ST0->TagSpecial = TAG_SPECIAL_INDEF;
        }
        break;
    }

}

FRAG0(FNCLEX)
{
    // NOWAIT flavor, so no preamble
    cpu->FpStatusES = 0;
    cpu->FpStatusExceptions = 0;
}

FRAG0(FDECSTP)
{
    FpArithPreamble(cpu);
    cpu->FpStatusC1 = 0;        // assume no error
    PUSHFLT(cpu->FpST0);
}

FRAG1IMM(FFREE, INT)
{
    FpArithPreamble(cpu);

    CPUASSERT((op1 & 0x07) == op1);
    cpu->FpStack[ST(op1)].Tag = TAG_EMPTY;
}

FRAG0(FINCSTP)
{
    FpArithPreamble(cpu);
    cpu->FpStatusC1 = 0;        // assume no error
    INCFLT;
}

FRAG0(FNINIT)
{
    int i;

    SetControlReg(cpu, 0x37f);
    SetStatusReg(cpu, 0);
    cpu->FpStatusES = 0;
    for (i=0; i<8; ++i) {
        cpu->FpStack[i].Tag = TAG_EMPTY;
    }
    cpu->FpEip = 0;
    cpu->FpData = 0;
}

FRAG1(FLDCW, USHORT*)
{
    FpControlPreamble(cpu);

    SetControlReg(cpu, GET_SHORT(pop1));
}

FRAG1(FLDENV, BYTE)
{
    // Intel instruction set docs don't define the layout for the structure.
    // This code is copied from ntos\dll\i386\emlsenv.asm.
    GetEnvironment(cpu, (DWORD *)pop1);
}

NPXFUNC1(FRNDINT_VALID)
{
    double fraction;

    fraction = modf(Fp->r64, &Fp->r64);
    switch (cpu->FpControlRounding) {
    case 0:     // _RC_NEAR
        if (fraction <= -0.5) {
            // Fp->r64 is negative and the fraction is >= 0.5
            Fp->r64-=1.0;
        } else if (fraction >= 0.5) {
            // Fp->r64 is positive and the fraction is >= 0.5
            Fp->r64+=1.0;
        }
        break;

    case 1:     // _RC_DOWN
        if (fraction < 0.0) {
            // Fp->r64 is negative and there is a fraction.  Round down
            Fp->r64-=1.0;
        }
        break;

    case 2:     // _RC_UP
        if (fraction > 0.0) {
            // Fp->r64 is positive and there is a fraction.  Round up
            Fp->r64+=1.0;
        }
        break;

    case 3:     // _RC_CHOP
        // nothing to do - modf chops
        break;

    default:
        CPUASSERT(FALSE);
    }
    if (Fp->r64 == 0.0) {
        Fp->Tag = TAG_ZERO;
    } else {
        Fp->Tag = TAG_VALID;
    }
}

NPXFUNC1(FRNDINT_ZERO)
{
    // nothing to do - zero is already an integer!
}

NPXFUNC1(FRNDINT_SPECIAL)
{
    switch (Fp->TagSpecial) {
    case TAG_SPECIAL_DENORM:
        FRNDINT_VALID(cpu, Fp);
        break;

    case TAG_SPECIAL_SNAN:
        HandleSnan(cpu, Fp);
        break;

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_INDEF:
    case TAG_SPECIAL_INFINITY:
        // infinity and NANs are unchanged
        break;
    }
}

NPXFUNC1(FRNDINT_EMPTY)
{
    HandleStackEmpty(cpu, Fp);
}


FRAG0(FRNDINT)
{
    PFPREG ST0;

    FpArithPreamble(cpu);
    ST0 = cpu->FpST0;
    (*FRNDINTTable[ST0->Tag])(cpu, ST0);
}

FRAG1(FRSTOR, BYTE)
{
    INT i;
    PBYTE DataImagePtr = pop1;

    //
    // Load the status register first, so that the ST(i) calculation
    // is correct.
    //
    SetStatusReg(cpu, (USHORT)GET_LONG(pop1+4));

    // Intel instruction set docs don't define the layout for the structure.
    // This code is copied from ntos\dll\i386\emlsenv.asm.
    pop1 += 28;   // move past the Numeric Instruction and Data Pointer image
    for (i=0; i<8; ++i) {
        LoadIntelR10ToR8(cpu, pop1, &cpu->FpStack[ST(i)]);
        pop1+=10;
    }

   //
   // Setting tags requires looking at the R8 values on the FP stack, so do this
   // after loading the FP stack from memory
   // 
   GetEnvironment(cpu, (DWORD *)DataImagePtr);
}

FRAG1(FNSAVE, BYTE)
{
    FpuSaveContext(cpu, pop1);
    FNINIT(cpu);
}

NPXFUNC2(FSCALE_VALID_VALID)
{
    l->r64 = _scalb(l->r64, (long)r->r64);

    //
    // Assume the scaling did not overflow
    //
    SetTag(l);

    if (errno == ERANGE) {
        if (l->r64 == HUGE_VAL) {
            //
            // The scaling overflowed - fix up the result
            //
            l->r64 = R8PositiveInfinity;
            l->Tag = TAG_SPECIAL;
            l->TagSpecial = TAG_SPECIAL_INFINITY;
        } else if (l->r64 == -HUGE_VAL) {
            //
            // The scaling overflowed - fix up the result
            //
            l->r64 = R8NegativeInfinity;
            l->Tag = TAG_SPECIAL;
            l->TagSpecial = TAG_SPECIAL_INFINITY;
        }
    }
}

NPXFUNC2(FSCALE_VALIDORZERO_VALIDORZERO)
{
    // no work to do - either: adding 0 to the exponent
    //                     or: adding nonzero to the exponent on 0
}

NPXFUNC2(FSCALE_SPECIAL_VALIDORZERO)
{
    switch (l->TagSpecial) {
    case TAG_SPECIAL_DENORM:
        FSCALE_VALID_VALID(cpu, l, r);
        break;

    case TAG_SPECIAL_INFINITY:
        // no change if adjusting the exponent of INFINITY
        break;

    case TAG_SPECIAL_SNAN:
        HandleSnan(cpu, l);
        // fall into TAG_SPECIAL_QNAN

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_INDEF:
        break;
    }
}

NPXFUNC2(FSCALE_VALIDORZERO_SPECIAL)
{
    switch (r->TagSpecial) {
    case TAG_SPECIAL_DENORM:
        FSCALE_VALID_VALID(cpu, l, r);
        break;

    case TAG_SPECIAL_INFINITY:
        if (l->Tag != TAG_ZERO) {
            // scaling VALID by INFINITY - return INDEFINITE
            SetIndefinite(l);
        }
        // else scaling ZERO by INFINITY - return ZERO
        break;

    case TAG_SPECIAL_SNAN:
        HandleSnan(cpu, r);
        // fall into TAG_SPECIAL_QNAN:

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_INDEF:
        break;
    }
}

NPXFUNC2(FSCALE_SPECIAL_SPECIAL)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleStackEmpty(cpu, l)) {
        return;
    }
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleStackEmpty(cpu, r)) {
        return;
    }

    if (l->TagSpecial == TAG_SPECIAL_DENORM) {
        (*FSCALETable[TAG_VALID][r->Tag])(cpu, l, r);
        return;
    }
    if (r->TagSpecial == TAG_SPECIAL_DENORM) {
        (*FSCALETable[l->Tag][TAG_VALID])(cpu, l, r);
        return;
    }

    if (l->TagSpecial == TAG_SPECIAL_INFINITY) {

        if (r->TagSpecial == TAG_SPECIAL_INFINITY) {

            // two infinities - return INDEFINITE
            SetIndefinite(l);

        } else {
            CPUASSERT(IS_TAG_NAN(r));

            // Copy the NAN from r to l, to return it
            l->r64 = r->r64;
            l->TagSpecial = r->TagSpecial;
        }
    } else {

        CPUASSERT(IS_TAG_NAN(l));
        if (r->TagSpecial == TAG_SPECIAL_INFINITY) {
            //
            // l already has the NAN to return
            //
        } else {
            CPUASSERT(IS_TAG_NAN(r));

            //
            // Return the largest of the two NANs
            //
            l->r64 = r->r64 + l->r64;
            SetTag(l);
        }
    }
}

NPXFUNC2(FSCALE_ANY_EMPTY)
{
    if (!HandleStackEmpty(cpu, r)) {
        (*FSCALETable[l->Tag][TAG_SPECIAL])(cpu, l, r);
    }
}

NPXFUNC2(FSCALE_EMPTY_ANY)
{
    if (!HandleStackEmpty(cpu, l)) {
        (*FSCALETable[TAG_SPECIAL][r->Tag])(cpu, l, r);
    }
}

FRAG0(FSCALE)
{
    PFPREG l, r;

    FpArithPreamble(cpu);

    l = cpu->FpST0;
    r = &cpu->FpStack[ST(1)];

    (*FSCALETable[l->Tag][r->Tag])(cpu, l, r);
}

NPXFUNC1(FSQRT_VALID)
{
    if (Fp->rb[7] & 0x80) {
        // value is negative - return INDEFINITE
        if (!HandleInvalidOp(cpu)) {
            SetIndefinite(Fp);
        }
    } else {
        Fp->r64 = sqrt(Fp->r64);
        SetTag(Fp);
    }
}

NPXFUNC1(FSQRT_ZERO)
{
    // according to the docs, sqrt(-0.0) is -0.0, so there is nothing to do
}

NPXFUNC1(FSQRT_SPECIAL)
{
    switch (Fp->TagSpecial) {
    case TAG_SPECIAL_DENORM:
        FSQRT_VALID(cpu, Fp);
        break;

    case TAG_SPECIAL_INFINITY:
        if (Fp->rb[7] & 0x80) {
            // negative infinity - invalid op
            SetIndefinite(Fp);
        }
        // else positive infinity, which is preserved
        break;

    case TAG_SPECIAL_SNAN:
        HandleSnan(cpu, Fp);
        break;

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_INDEF:
        break;
    }
}

NPXFUNC1(FSQRT_EMPTY)
{
    HandleStackEmpty(cpu, Fp);
    // nothing else to do
}

FRAG0(FSQRT)
{
    PFPREG ST0;

    FpArithPreamble(cpu);
    ST0 = cpu->FpST0;
    (*FSQRTTable[ST0->Tag])(cpu, ST0);
}

FRAG1(FNSTCW, USHORT)
{
    // No-wait flavor - no preamble required.
    PUT_SHORT(pop1, GetControlReg(cpu));
}

FRAG1(FNSTENV, BYTE)
{
    // No-wait flavor - no preamble required.

    StoreEnvironment(cpu, (DWORD *)pop1);
}

FRAG1(FNSTSW, USHORT)
{
    // No-wait flavor - no preamble required
    PUT_SHORT(pop1, GetStatusReg(cpu));
}

FRAG0(OPT_FNSTSWAxSahf)
{
    DWORD Status;

    // No-wait flavor - no preamble required
    Status = GetStatusReg(cpu);
    ax = (USHORT)Status;
    SET_CFLAG(Status << (31-8));    // FLAG_CF==1<<0
    SET_PFLAG(!(Status & (FLAG_PF<<8))); // flag_pf contains an index into ParityBit[] array
    SET_AUXFLAG(Status >> 8);       // AUX bit is already in the right place
    SET_ZFLAG(!(Status & (FLAG_ZF<<8))); // zf has inverse logic
    SET_SFLAG(Status << (31-7-8));  // SFLAG is bit 7 in AH
}

FRAG0(FXAM)
{
    PFPREG ST0;

    FpArithPreamble(cpu);

    ST0 = cpu->FpST0;

    // C1 = sign bit
    cpu->FpStatusC1 = ST0->rdw[1] >> 31;

    // Set C3, C2, C0 based on the type of the number
    switch (ST0->Tag) {
    case TAG_VALID:
        cpu->FpStatusC3 = 0; cpu->FpStatusC2 = 1; cpu->FpStatusC0 = 0;
        break;

    case TAG_ZERO:
        cpu->FpStatusC3 = 1; cpu->FpStatusC2 = 0; cpu->FpStatusC0 = 0;
        break;

    case TAG_EMPTY:
        cpu->FpStatusC3 = 1; cpu->FpStatusC2 = 0; cpu->FpStatusC0 = 1;
        break;

    case TAG_SPECIAL:
        switch (cpu->FpST0->TagSpecial) {
        case TAG_SPECIAL_DENORM:
            cpu->FpStatusC3 = 1; cpu->FpStatusC2 = 1; cpu->FpStatusC0 = 0;
            break;

        case TAG_SPECIAL_SNAN:
        case TAG_SPECIAL_QNAN:
        case TAG_SPECIAL_INDEF:
            cpu->FpStatusC3 = 0; cpu->FpStatusC2 = 0; cpu->FpStatusC0 = 1;
            break;

        case TAG_SPECIAL_INFINITY:
            cpu->FpStatusC3 = 0; cpu->FpStatusC2 = 1; cpu->FpStatusC0 = 1;
            break;
        }
        break;
    }
}

FRAG1IMM(FXCH_STi, INT)
{
    PFPREG pReg;
    PFPREG ST0;
    FPREG Temp;

    FpArithPreamble(cpu);

    CPUASSERT( (op1&0x07)==op1 );

    ST0 = cpu->FpST0;

    if (ST0->Tag == TAG_EMPTY) {
        if (HandleStackEmpty(cpu, ST0)) {
            // unmasked exception - abort the instruction
            return;
        }
    }
    pReg = &cpu->FpStack[ST(op1)];
    if (pReg->Tag == TAG_EMPTY) {
        if (HandleStackEmpty(cpu, pReg)) {
            // unmasked exception - abort the instruction
            return;
        }
    }

    Temp.Tag = pReg->Tag;
    Temp.TagSpecial = pReg->TagSpecial;
    Temp.r64 = pReg->r64;
    pReg->Tag = ST0->Tag;
    pReg->TagSpecial = ST0->TagSpecial;
    pReg->r64 = ST0->r64;
    ST0->Tag = Temp.Tag;
    ST0->TagSpecial = Temp.TagSpecial;
    ST0->r64 = Temp.r64;
}

NPXFUNC1(FXTRACT_VALID)
{
    DOUBLE Significand;
    int Exponent;

    Exponent = (int)_logb(Fp->r64);
    Significand = _scalb(Fp->r64, (long)-Exponent);

    //
    // Place the exponent in what will become ST(1)
    //
    Fp->r64 = (DOUBLE)Exponent;
    if (Exponent == 0) {
        Fp->Tag = TAG_ZERO;
    } else {
        Fp->Tag = TAG_VALID;
    }

    //
    // Place the mantissa in ST, with the same sign as the original value
    //
    PUSHFLT(Fp);
    Fp->r64 = Significand;
    if (Significand == 0.0) {
        Fp->Tag = TAG_ZERO;
    } else {
        Fp->Tag = TAG_VALID;
    }
}

NPXFUNC1(FXTRACT_ZERO)
{
    DWORD Sign;

    //
    // ST(1) gets -infinity, ST gets 0 with same sign as the original value
    //
    Sign = Fp->rdw[1] & 0x80000000;
    Fp->r64 = R8NegativeInfinity;
    Fp->Tag = TAG_SPECIAL;
    Fp->TagSpecial = TAG_SPECIAL_INFINITY;
    PUSHFLT(Fp);
    Fp->rdw[0] = 0;
    Fp->rdw[1] = Sign;
    Fp->Tag = TAG_ZERO;

    //
    // Raise the zero-divide exception
    //
    if (!(cpu->FpControlMask & FPCONTROL_ZM)) {
        cpu->FpStatusES = 1;    // Unmasked exception
    }
    cpu->FpStatusExceptions |= FPCONTROL_ZM;
}

NPXFUNC1(FXTRACT_SPECIAL)
{
    DOUBLE Temp;
    FPTAG TempTagSpecial;

    switch (Fp->TagSpecial) {
    case TAG_SPECIAL_DENORM:
        FXTRACT_VALID(cpu, Fp);
        break;

    case TAG_SPECIAL_INFINITY:
        //
        // According to ntos\dll\i386\emxtract.asm, ST(0) = infinity (same sign)
        // and ST(1) = +infinity
        //
        Temp = Fp->r64;
        Fp->r64 = R8PositiveInfinity;
        CPUASSERT(Fp->Tag == TAG_SPECIAL && Fp->TagSpecial == TAG_SPECIAL_INFINITY);
        PUSHFLT(Fp);
        Fp->r64 = Temp;
        Fp->Tag = TAG_SPECIAL;
        Fp->TagSpecial = TAG_SPECIAL_INFINITY;
        break;

    case TAG_SPECIAL_SNAN:
        if (HandleSnan(cpu, Fp)) {
            return;
        }
        // else fall thru to TAG_SPECIAL_QNAN

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_INDEF:
        //
        // Copy the QNAN to both ST(1) and ST
        //
        Temp = Fp->r64;
        TempTagSpecial = Fp->TagSpecial;
        PUSHFLT(Fp);
        Fp->r64 = Temp;
        Fp->Tag = TAG_SPECIAL;
        Fp->TagSpecial = TempTagSpecial;
        break;
    }
}

NPXFUNC1(FXTRACT_EMPTY)
{
    CPUASSERT(FALSE);    // this was taken care of by the real FXTRACT
}

FRAG0(FXTRACT)
{
    PFPREG ST0;

    FpArithPreamble(cpu);

    cpu->FpStatusC1 = 0;        // assume no error
    ST0 = cpu->FpST0;

    //
    // We must take care of this case first, so that the check for ST(7)
    // can occur next, before any other exception handling takes place.
    //
    if (ST0->Tag == TAG_EMPTY) {
        if (HandleStackEmpty(cpu, ST0)) {
            // unmasked exception - abort the instruction
            return;
        }
    }

    if (cpu->FpStack[ST(7)].Tag != TAG_EMPTY) {
        HandleStackFull(cpu, &cpu->FpStack[ST(7)]);
        return;
    }

    (*FXTRACTTable[ST0->Tag])(cpu, ST0);
}

FRAG0(WaitFrag)
{
    FpControlPreamble(cpu);
}

FRAG0(FNOP)
{
    FpArithPreamble(cpu);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\fpuarith.c ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    fpuarith.c

Abstract:

    Floating point arithmetic fragments (Add/Sub/Mul/Div/Com/Tst)

Author:

    04-Oct-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <float.h>
#include <math.h>
#include <errno.h>
#include <stdio.h>
#include "wx86.h"
#include "cpuassrt.h"
#include "fragp.h"
#include "fpufrags.h"
#include "fpufragp.h"
#include "fpuarith.h"

ASSERTNAME;

#define CALLNPXFUNC2(table, lTag, rTag, l, r) {         \
    NpxFunc2 *p = (NpxFunc2 *)(table);                  \
    (*(p + (lTag)*TAG_MAX + (rTag)))(cpu, l, r);        \
    }

#define CALLNPXFUNC3(table, lTag, rTag, d, l, r) {      \
    NpxFunc3 *p = (NpxFunc3 *)(table);                  \
    (*(p + (lTag)*TAG_MAX + (rTag)))(cpu, d, l, r);     \
    }


//
// Forward declarations
//
NPXFUNC2(FpAdd32_VALID_VALID);
NPXFUNC2(FpAdd32_VALID_SPECIAL);
NPXFUNC2(FpAdd32_SPECIAL_VALID);
NPXFUNC2(FpAdd32_SPECIAL_SPECIAL);
NPXFUNC2(FpAdd_ANY_EMPTY);
NPXFUNC2(FpAdd_EMPTY_ANY);
NPXFUNC2(FpAdd64_VALID_VALID);
NPXFUNC2(FpAdd64_VALID_SPECIAL);
NPXFUNC2(FpAdd64_SPECIAL_VALID);
NPXFUNC2(FpAdd64_SPECIAL_SPECIAL);
NPXFUNC3(FpDiv32_VALID_VALID);
NPXFUNC3(FpDiv32_VALID_SPECIAL);
NPXFUNC3(FpDiv32_SPECIAL_VALID);
NPXFUNC3(FpDiv32_SPECIAL_SPECIAL);
NPXFUNC3(FpDiv_ANY_EMPTY);
NPXFUNC3(FpDiv_EMPTY_ANY);
NPXFUNC3(FpDiv64_VALID_VALID);
NPXFUNC3(FpDiv64_VALID_SPECIAL);
NPXFUNC3(FpDiv64_SPECIAL_VALID);
NPXFUNC3(FpDiv64_SPECIAL_SPECIAL);
NPXFUNC2(FpMul32_VALID_VALID);
NPXFUNC2(FpMul32_VALID_SPECIAL);
NPXFUNC2(FpMul32_SPECIAL_VALID);
NPXFUNC2(FpMul32_SPECIAL_SPECIAL);
NPXFUNC2(FpMul_ANY_EMPTY);
NPXFUNC2(FpMul_EMPTY_ANY);
NPXFUNC2(FpMul64_VALID_VALID);
NPXFUNC2(FpMul64_VALID_SPECIAL);
NPXFUNC2(FpMul64_SPECIAL_VALID);
NPXFUNC2(FpMul64_SPECIAL_SPECIAL);
NPXFUNC3(FpSub32_VALID_VALID);
NPXFUNC3(FpSub32_VALID_SPECIAL);
NPXFUNC3(FpSub32_SPECIAL_VALID);
NPXFUNC3(FpSub32_SPECIAL_SPECIAL);
NPXFUNC3(FpSub_ANY_EMPTY);
NPXFUNC3(FpSub_EMPTY_ANY);
NPXFUNC3(FpSub64_VALID_VALID);
NPXFUNC3(FpSub64_VALID_SPECIAL);
NPXFUNC3(FpSub64_SPECIAL_VALID);
NPXFUNC3(FpSub64_SPECIAL_SPECIAL);
NPXCOMFUNC(FpCom_VALID_VALID);
NPXCOMFUNC(FpCom_VALID_SPECIAL);
NPXCOMFUNC(FpCom_SPECIAL_VALID);
NPXCOMFUNC(FpCom_SPECIAL_SPECIAL);
NPXCOMFUNC(FpCom_VALID_EMPTY);
NPXCOMFUNC(FpCom_EMPTY_VALID);
NPXCOMFUNC(FpCom_EMPTY_SPECIAL);
NPXCOMFUNC(FpCom_SPECIAL_EMPTY);
NPXCOMFUNC(FpCom_EMPTY_EMPTY);

//
// Jump tables
//
const NpxFunc2 FpAdd32Table[TAG_MAX][TAG_MAX] = {
    // Left is TAG_VALID, Right is...
    {FpAdd32_VALID_VALID, FpAdd32_VALID_VALID, FpAdd32_VALID_SPECIAL, FpAdd_ANY_EMPTY},
    // Left is TAG_ZERO, Right is...
    {FpAdd32_VALID_VALID, FpAdd32_VALID_VALID, FpAdd32_VALID_SPECIAL, FpAdd_ANY_EMPTY},
    // Left is TAG_SPECIAL, Right is...
    {FpAdd32_SPECIAL_VALID, FpAdd32_SPECIAL_VALID, FpAdd32_SPECIAL_SPECIAL, FpAdd_ANY_EMPTY},
    // Left is TAG_EMPTY, Right is...
    {FpAdd_EMPTY_ANY, FpAdd_EMPTY_ANY, FpAdd_EMPTY_ANY, FpAdd_EMPTY_ANY}
};
const NpxFunc2 FpAdd64Table[TAG_MAX][TAG_MAX] = {
    // Left is TAG_VALID, Right is...
    {FpAdd64_VALID_VALID, FpAdd64_VALID_VALID, FpAdd64_VALID_SPECIAL, FpAdd_ANY_EMPTY},
    // Left is TAG_ZERO, Right is...
    {FpAdd64_VALID_VALID, FpAdd64_VALID_VALID, FpAdd64_VALID_SPECIAL, FpAdd_ANY_EMPTY},
    // Left is TAG_SPECIAL, Right is...
    {FpAdd64_SPECIAL_VALID, FpAdd64_SPECIAL_VALID, FpAdd64_SPECIAL_SPECIAL, FpAdd_ANY_EMPTY},
    // Left is TAG_EMPTY, Right is...
    {FpAdd_EMPTY_ANY, FpAdd_EMPTY_ANY, FpAdd_EMPTY_ANY, FpAdd_EMPTY_ANY}
};

const NpxFunc3 FpDiv32Table[TAG_MAX][TAG_MAX] = {
    // Left is TAG_VALID, Right is...
    {FpDiv32_VALID_VALID, FpDiv32_VALID_VALID, FpDiv32_VALID_SPECIAL, FpDiv_ANY_EMPTY},
    // Left is TAG_ZERO, Right is...
    {FpDiv32_VALID_VALID, FpDiv32_VALID_VALID, FpDiv32_VALID_SPECIAL, FpDiv_ANY_EMPTY},
    // Left is TAG_SPECIAL, Right is...
    {FpDiv32_SPECIAL_VALID, FpDiv32_SPECIAL_VALID, FpDiv32_SPECIAL_SPECIAL, FpDiv_ANY_EMPTY},
    // Left is TAG_EMPTY, Right is...
    {FpDiv_EMPTY_ANY, FpDiv_EMPTY_ANY, FpDiv_EMPTY_ANY, FpDiv_EMPTY_ANY}
};
const NpxFunc3 FpDiv64Table[TAG_MAX][TAG_MAX] = {
    // Left is TAG_VALID, Right is...
    {FpDiv64_VALID_VALID, FpDiv64_VALID_VALID, FpDiv64_VALID_SPECIAL, FpDiv_ANY_EMPTY},
    // Left is TAG_ZERO, Right is...
    {FpDiv64_VALID_VALID, FpDiv64_VALID_VALID, FpDiv64_VALID_SPECIAL, FpDiv_ANY_EMPTY},
    // Left is TAG_SPECIAL, Right is...
    {FpDiv64_SPECIAL_VALID, FpDiv64_SPECIAL_VALID, FpDiv64_SPECIAL_SPECIAL, FpDiv_ANY_EMPTY},
    // Left is TAG_EMPTY, Right is...
    {FpDiv_EMPTY_ANY, FpDiv_EMPTY_ANY, FpDiv_EMPTY_ANY, FpDiv_EMPTY_ANY}
};

const NpxFunc2 FpMul32Table[TAG_MAX][TAG_MAX] = {
    // Left is TAG_VALID, Right is...
    {FpMul32_VALID_VALID, FpMul32_VALID_VALID, FpMul32_VALID_SPECIAL, FpMul_ANY_EMPTY},
    // Left is TAG_ZERO, Right is...
    {FpMul32_VALID_VALID, FpMul32_VALID_VALID, FpMul32_VALID_SPECIAL, FpMul_ANY_EMPTY},
    // Left is TAG_SPECIAL, Right is...
    {FpMul32_SPECIAL_VALID, FpMul32_SPECIAL_VALID, FpMul32_SPECIAL_SPECIAL, FpMul_ANY_EMPTY},
    // Left is TAG_EMPTY, Right is...
    {FpMul_EMPTY_ANY, FpMul_EMPTY_ANY, FpMul_EMPTY_ANY, FpMul_EMPTY_ANY}
};
const NpxFunc2 FpMul64Table[TAG_MAX][TAG_MAX] = {
    // Left is TAG_VALID, Right is...
    {FpMul64_VALID_VALID, FpMul64_VALID_VALID, FpMul64_VALID_SPECIAL, FpMul_ANY_EMPTY},
    // Left is TAG_ZERO, Right is...
    {FpMul64_VALID_VALID, FpMul64_VALID_VALID, FpMul64_VALID_SPECIAL, FpMul_ANY_EMPTY},
    // Left is TAG_SPECIAL, Right is...
    {FpMul64_SPECIAL_VALID, FpMul64_SPECIAL_VALID, FpMul64_SPECIAL_SPECIAL, FpMul_ANY_EMPTY},
    // Left is TAG_EMPTY, Right is...
    {FpMul_EMPTY_ANY, FpMul_EMPTY_ANY, FpMul_EMPTY_ANY, FpMul_EMPTY_ANY}
};

const NpxFunc3 FpSub32Table[TAG_MAX][TAG_MAX] = {
    // Left is TAG_VALID, Right is...
    {FpSub32_VALID_VALID, FpSub32_VALID_VALID, FpSub32_VALID_SPECIAL, FpSub_ANY_EMPTY},
    // Left is TAG_ZERO, Right is...
    {FpSub32_VALID_VALID, FpSub32_VALID_VALID, FpSub32_VALID_SPECIAL, FpSub_ANY_EMPTY},
    // Left is TAG_SPECIAL, Right is...
    {FpSub32_SPECIAL_VALID, FpSub32_SPECIAL_VALID, FpSub32_SPECIAL_SPECIAL, FpSub_ANY_EMPTY},
    // Left is TAG_EMPTY, Right is...
    {FpSub_EMPTY_ANY, FpSub_EMPTY_ANY, FpSub_EMPTY_ANY, FpSub_EMPTY_ANY}
};
const NpxFunc3 FpSub64Table[TAG_MAX][TAG_MAX] = {
    // Left is TAG_VALID, Right is...
    {FpSub64_VALID_VALID, FpSub64_VALID_VALID, FpSub64_VALID_SPECIAL, FpSub_ANY_EMPTY},
    // Left is TAG_ZERO, Right is...
    {FpSub64_VALID_VALID, FpSub64_VALID_VALID, FpSub64_VALID_SPECIAL, FpSub_ANY_EMPTY},
    // Left is TAG_SPECIAL, Right is...
    {FpSub64_SPECIAL_VALID, FpSub64_SPECIAL_VALID, FpSub64_SPECIAL_SPECIAL, FpSub_ANY_EMPTY},
    // Left is TAG_EMPTY, Right is...
    {FpSub_EMPTY_ANY, FpSub_EMPTY_ANY, FpSub_EMPTY_ANY, FpSub_EMPTY_ANY}
};

const NpxComFunc FpComTable[TAG_MAX][TAG_MAX] = {
    // Left is TAG_VALID, Right is...
    {FpCom_VALID_VALID, FpCom_VALID_VALID, FpCom_VALID_SPECIAL, FpCom_VALID_EMPTY},
    // Left is TAG_ZERO, Right is...
    {FpCom_VALID_VALID, FpCom_VALID_VALID, FpCom_VALID_SPECIAL, FpCom_VALID_EMPTY},
    // Left is TAG_SPECIAL, Right is...
    {FpCom_SPECIAL_VALID, FpCom_SPECIAL_VALID, FpCom_SPECIAL_SPECIAL, FpCom_SPECIAL_EMPTY},
    // Left is TAG_EMPTY, Right is...
    {FpCom_EMPTY_VALID, FpCom_EMPTY_VALID, FpCom_EMPTY_SPECIAL, FpCom_EMPTY_EMPTY}
};


VOID
ChangeFpPrecision(
    PCPUDATA cpu,
    INT NewPrecision
    )
/*++

Routine Description:

    Called to modify the floating-point precision.  It modifies per-thread
    jump tables used by instructions which are sensitive to the FP
    precision bits.

Arguments:

    cpu - per-thread data
    NewPrecision - new precision value

Return Value:

    None

--*/
{
    cpu->FpControlPrecision = NewPrecision;

    if (NewPrecision == 0) {
        //
        // New precision is 32-bit
        //
        cpu->FpAddTable = FpAdd32Table;
        cpu->FpSubTable = FpSub32Table;
        cpu->FpMulTable = FpMul32Table;
        cpu->FpDivTable = FpDiv32Table;
    } else {
        //
        // New precision is 24, 64, or 80-bit - treat all as 64-bit
        //
        cpu->FpAddTable = FpAdd64Table;
        cpu->FpSubTable = FpSub64Table;
        cpu->FpMulTable = FpMul64Table;
        cpu->FpDivTable = FpDiv64Table;
    }
}


NPXFUNC2(FpAdd32_VALID_VALID)
{
    //UNDONE:  If 487 overflow exceptions are unmasked and an overflow occurs,
    //UNDONE:  a different value is written to 'l' than if the exception
    //UNDONE:  was masked.  To get this right, we need to install an
    //UNDONE:  exception handler around the addition and run the native FPU
    //UNDONE:  with overflow exceptions unmasked.  The trap handler must then
    //UNDONE:  map the exception back into FpStatus->ES so the next Intel
    //UNDONE:  FP instruction can get the Intel exception as expected.  Gross!
    //UNDONE:  Read Intel 16-24 for the gory details.

    l->r64 = (DOUBLE)( (FLOAT)l->r64 + (FLOAT)r->r64 );

    // Compute the new tag value
    SetTag(l);
}

NPXFUNC2(FpAdd64_VALID_VALID)
{
    //UNDONE:  If 487 overflow exceptions are unmasked and an overflow occurs,
    //UNDONE:  a different value is written to 'l' than if the exception
    //UNDONE:  was masked.  To get this right, we need to install an
    //UNDONE:  exception handler around the addition and run the native FPU
    //UNDONE:  with overflow exceptions unmasked.  The trap handler must then
    //UNDONE:  map the exception back into FpStatus->ES so the next Intel
    //UNDONE:  FP instruction can get the Intel exception as expected.  Gross!
    //UNDONE:  Read Intel 16-24 for the gory details.

    l->r64 = l->r64 + r->r64;

    // Compute the new tag value
    SetTag(l);
}

NPXFUNC2(FpAdd32_VALID_SPECIAL)
{
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpAdd32_VALID_VALID(cpu, l, r);
}

NPXFUNC2(FpAdd64_VALID_SPECIAL)
{
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpAdd64_VALID_VALID(cpu, l, r);
}

NPXFUNC2(FpAdd32_SPECIAL_VALID)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpAdd32_VALID_VALID(cpu, l, r);
}

NPXFUNC2(FpAdd64_SPECIAL_VALID)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpAdd64_VALID_VALID(cpu, l, r);
}

NPXFUNC2(FpAdd32_SPECIAL_SPECIAL)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpAdd32_VALID_VALID(cpu, l, r);
}

NPXFUNC2(FpAdd64_SPECIAL_SPECIAL)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpAdd64_VALID_VALID(cpu, l, r);
}

NPXFUNC2(FpAdd_ANY_EMPTY)
{
    if (!HandleStackEmpty(cpu, r)) {
        CALLNPXFUNC2(cpu->FpAddTable, l->Tag, TAG_SPECIAL, l, r);
    }
}

NPXFUNC2(FpAdd_EMPTY_ANY)
{
    if (!HandleStackEmpty(cpu, l)) {
        CALLNPXFUNC2(cpu->FpAddTable, TAG_SPECIAL, r->Tag, l, r);
    }
}

VOID
FpAddCommon(
    PCPUDATA cpu,
    PFPREG   l,
    PFPREG   r
    )

/*++

Routine Description:

    Implements l += r.

Arguments:

    cpu     - per-thread data
    l       - left-hand FP register
    r       - right-hand FP register

Return Value:

    None.  l is updated to contain the value of l+r.

--*/

{
    CALLNPXFUNC2(cpu->FpAddTable, l->Tag, r->Tag, l, r);
}



NPXFUNC3(FpDiv32_VALID_VALID)
{
    //UNDONE:  If 487 overflow exceptions are unmasked and an overflow occurs,
    //UNDONE:  a different value is written to 'l' than if the exception
    //UNDONE:  was masked.  To get this right, we need to install an
    //UNDONE:  exception handler around the addition and run the native FPU
    //UNDONE:  with overflow exceptions unmasked.  The trap handler must then
    //UNDONE:  map the exception back into FpStatus->ES so the next Intel
    //UNDONE:  FP instruction can get the Intel exception as expected.  Gross!
    //UNDONE:  Read Intel 16-24 for the gory details.

    dest->r64 = (DOUBLE)( (FLOAT)l->r64 / (FLOAT)r->r64 );

    // Compute the new tag value
    SetTag(dest);
}

NPXFUNC3(FpDiv64_VALID_VALID)
{
    //UNDONE:  If 487 overflow exceptions are unmasked and an overflow occurs,
    //UNDONE:  a different value is written to 'l' than if the exception
    //UNDONE:  was masked.  To get this right, we need to install an
    //UNDONE:  exception handler around the addition and run the native FPU
    //UNDONE:  with overflow exceptions unmasked.  The trap handler must then
    //UNDONE:  map the exception back into FpStatus->ES so the next Intel
    //UNDONE:  FP instruction can get the Intel exception as expected.  Gross!
    //UNDONE:  Read Intel 16-24 for the gory details.

    dest->r64 = l->r64 / r->r64;

    // Compute the new tag value
    SetTag(dest);
}

NPXFUNC3(FpDiv32_VALID_SPECIAL)
{
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpDiv32_VALID_VALID(cpu, dest, l, r);
}

NPXFUNC3(FpDiv64_VALID_SPECIAL)
{
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpDiv64_VALID_VALID(cpu, dest, l, r);
}

NPXFUNC3(FpDiv32_SPECIAL_VALID)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpDiv32_VALID_VALID(cpu, dest, l, r);
}

NPXFUNC3(FpDiv64_SPECIAL_VALID)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpDiv64_VALID_VALID(cpu, dest, l, r);
}

NPXFUNC3(FpDiv32_SPECIAL_SPECIAL)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpDiv32_VALID_VALID(cpu, dest, l, r);
}

NPXFUNC3(FpDiv64_SPECIAL_SPECIAL)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpDiv64_VALID_VALID(cpu, dest, l, r);
}

NPXFUNC3(FpDiv_ANY_EMPTY)
{
    if (!HandleStackEmpty(cpu, r)) {
        CALLNPXFUNC3(cpu->FpDivTable, l->Tag, TAG_SPECIAL, dest, l, r);
    }
}

NPXFUNC3(FpDiv_EMPTY_ANY)
{
    if (!HandleStackEmpty(cpu, l)) {
        CALLNPXFUNC3(cpu->FpDivTable, TAG_SPECIAL, r->Tag, dest, l, r);
    }
}

VOID
FpDivCommon(
    PCPUDATA cpu,
    PFPREG   dest,
    PFPREG   l,
    PFPREG   r
    )

/*++

Routine Description:

    Implements dest = l/r

Arguments:

    cpu     - per-thread data
    l       - left-hand FP register
    r       - right-hand FP register

Return Value:

    None.  l is updated to contain the value of l+r.

--*/

{
    CALLNPXFUNC3(cpu->FpDivTable, l->Tag, r->Tag, dest, l, r);
}


NPXFUNC2(FpMul32_VALID_VALID)
{
    //UNDONE:  If 487 overflow exceptions are unmasked and an overflow occurs,
    //UNDONE:  a different value is written to 'l' than if the exception
    //UNDONE:  was masked.  To get this right, we need to install an
    //UNDONE:  exception handler around the addition and run the native FPU
    //UNDONE:  with overflow exceptions unmasked.  The trap handler must then
    //UNDONE:  map the exception back into FpStatus->ES so the next Intel
    //UNDONE:  FP instruction can get the Intel exception as expected.  Gross!
    //UNDONE:  Read Intel 16-24 for the gory details.

    l->r64 = (DOUBLE)( (FLOAT)l->r64 * (FLOAT)r->r64 );

    // Compute the new tag value
    SetTag(l);
}

NPXFUNC2(FpMul64_VALID_VALID)
{
    //UNDONE:  If 487 overflow exceptions are unmasked and an overflow occurs,
    //UNDONE:  a different value is written to 'l' than if the exception
    //UNDONE:  was masked.  To get this right, we need to install an
    //UNDONE:  exception handler around the addition and run the native FPU
    //UNDONE:  with overflow exceptions unmasked.  The trap handler must then
    //UNDONE:  map the exception back into FpStatus->ES so the next Intel
    //UNDONE:  FP instruction can get the Intel exception as expected.  Gross!
    //UNDONE:  Read Intel 16-24 for the gory details.

    l->r64 = l->r64 * r->r64;

    // Compute the new tag value
    SetTag(l);
}

NPXFUNC2(FpMul32_VALID_SPECIAL)
{
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpMul32_VALID_VALID(cpu, l, r);
}

NPXFUNC2(FpMul64_VALID_SPECIAL)
{
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpMul64_VALID_VALID(cpu, l, r);
}

NPXFUNC2(FpMul32_SPECIAL_VALID)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpMul32_VALID_VALID(cpu, l, r);
}

NPXFUNC2(FpMul64_SPECIAL_VALID)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpMul64_VALID_VALID(cpu, l, r);
}

NPXFUNC2(FpMul32_SPECIAL_SPECIAL)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpMul32_VALID_VALID(cpu, l, r);
}
NPXFUNC2(FpMul64_SPECIAL_SPECIAL)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpMul64_VALID_VALID(cpu, l, r);
}

NPXFUNC2(FpMul_ANY_EMPTY)
{
    if (!HandleStackEmpty(cpu, r)) {
        CALLNPXFUNC2(cpu->FpMulTable, l->Tag, TAG_SPECIAL, l, r);
    }
}

NPXFUNC2(FpMul_EMPTY_ANY)
{
    if (!HandleStackEmpty(cpu, l)) {
        CALLNPXFUNC2(cpu->FpMulTable, TAG_SPECIAL, r->Tag, l, r);
    }
}

VOID
FpMulCommon(
    PCPUDATA cpu,
    PFPREG   l,
    PFPREG   r
    )

/*++

Routine Description:

    Implements l += r.

Arguments:

    cpu     - per-thread data
    l       - left-hand FP register
    r       - right-hand FP register

Return Value:

    None.  l is updated to contain the value of l+r.

--*/

{
    CALLNPXFUNC2(cpu->FpMulTable, l->Tag, r->Tag, l, r);
}



NPXFUNC3(FpSub32_VALID_VALID)
{
    //UNDONE:  If 487 overflow exceptions are unmasked and an overflow occurs,
    //UNDONE:  a different value is written to 'l' than if the exception
    //UNDONE:  was masked.  To get this right, we need to install an
    //UNDONE:  exception handler around the addition and run the native FPU
    //UNDONE:  with overflow exceptions unmasked.  The trap handler must then
    //UNDONE:  map the exception back into FpStatus->ES so the next Intel
    //UNDONE:  FP instruction can get the Intel exception as expected.  Gross!
    //UNDONE:  Read Intel 16-24 for the gory details.

    dest->r64 = (DOUBLE)( (FLOAT)l->r64 - (FLOAT)r->r64 );

    // Compute the new tag value
    SetTag(dest);
}

NPXFUNC3(FpSub64_VALID_VALID)
{
    //UNDONE:  If 487 overflow exceptions are unmasked and an overflow occurs,
    //UNDONE:  a different value is written to 'l' than if the exception
    //UNDONE:  was masked.  To get this right, we need to install an
    //UNDONE:  exception handler around the addition and run the native FPU
    //UNDONE:  with overflow exceptions unmasked.  The trap handler must then
    //UNDONE:  map the exception back into FpStatus->ES so the next Intel
    //UNDONE:  FP instruction can get the Intel exception as expected.  Gross!
    //UNDONE:  Read Intel 16-24 for the gory details.

    dest->r64 = l->r64 - r->r64;

    // Compute the new tag value
    SetTag(dest);
}

NPXFUNC3(FpSub32_VALID_SPECIAL)
{
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpSub32_VALID_VALID(cpu, dest, l, r);
}

NPXFUNC3(FpSub64_VALID_SPECIAL)
{
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpSub64_VALID_VALID(cpu, dest, l, r);
}

NPXFUNC3(FpSub32_SPECIAL_VALID)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpSub32_VALID_VALID(cpu, dest, l, r);
}

NPXFUNC3(FpSub64_SPECIAL_VALID)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpSub64_VALID_VALID(cpu, dest, l, r);
}

NPXFUNC3(FpSub32_SPECIAL_SPECIAL)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpSub32_VALID_VALID(cpu, dest, l, r);
}

NPXFUNC3(FpSub64_SPECIAL_SPECIAL)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpSub64_VALID_VALID(cpu, dest, l, r);
}

NPXFUNC3(FpSub_ANY_EMPTY)
{
    if (!HandleStackEmpty(cpu, r)) {
        CALLNPXFUNC3(cpu->FpSubTable, l->Tag, TAG_SPECIAL, dest, l, r);
    }
}

NPXFUNC3(FpSub_EMPTY_ANY)
{
    if (!HandleStackEmpty(cpu, l)) {
        CALLNPXFUNC3(cpu->FpSubTable, TAG_SPECIAL, r->Tag, dest, l, r);
    }
}

VOID
FpSubCommon(
    PCPUDATA cpu,
    PFPREG   dest,
    PFPREG   l,
    PFPREG   r
    )

/*++

Routine Description:

    Implements dest = l-r

Arguments:

    cpu     - per-thread data
    dest    - destination FP register
    l       - left-hand FP register
    r       - right-hand FP register

Return Value:

    None.  l is updated to contain the value of l+r.

--*/

{
    CALLNPXFUNC3(cpu->FpSubTable, l->Tag, r->Tag, dest, l, r);
}



NPXCOMFUNC(FpCom_VALID_VALID)
{
    //
    // Note that this function is called when one or both of the values
    // is zero - the sign of 0.0 is ignored in the comparison, so the
    // C language '==' and '<' operators do the Right Thing.
    //

    if (l->r64 == r->r64) {
        cpu->FpStatusC3 = 1;
        cpu->FpStatusC2 = 0;
        cpu->FpStatusC0 = 0;
    } else if (l->r64 < r->r64) {
        cpu->FpStatusC3 = 0;
        cpu->FpStatusC2 = 0;
        cpu->FpStatusC0 = 1;
    } else {
        cpu->FpStatusC3 = 0;
        cpu->FpStatusC2 = 0;
        cpu->FpStatusC0 = 0;
    }
}

NPXCOMFUNC(FpCom_VALID_SPECIAL)
{
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }

    if (r->TagSpecial == TAG_SPECIAL_QNAN || r->TagSpecial == TAG_SPECIAL_INDEF) {
        //
        // Cannot compare a VALID to a QNAN/INDEF
        //
        if (!fUnordered && HandleInvalidOp(cpu)) {
            // abort the FCOM/FTST instruction - Illegal opcode is unmasked
            return;
        }

        // Otherwise, FCOM's illegal opcode is masked, or the instruction
        // is FUCOM, for which QNANs are uncomparable.  Return "Not comparable"
        cpu->FpStatusC3 = 1;
        cpu->FpStatusC2 = 1;
        cpu->FpStatusC0 = 1;
        return;
    }

    CPUASSERT(r->TagSpecial == TAG_SPECIAL_DENORM || r->TagSpecial == TAG_SPECIAL_INFINITY);
    FpCom_VALID_VALID(cpu, l, r, FALSE);
}

NPXCOMFUNC(FpCom_SPECIAL_VALID)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }

    if (l->TagSpecial == TAG_SPECIAL_QNAN || l->TagSpecial == TAG_SPECIAL_INDEF) {
        //
        // Cannot compare a VALID to a QNAN/INDEF
        //
        if (!fUnordered && HandleInvalidOp(cpu)) {
            // abort the FCOM/FTST instruction - Illegal opcode is unmasked
            return;
        }

        // Otherwise, FCOM's illegal opcode is masked, or the instruction
        // is FUCOM, for which QNANs are uncomparable.  Return "Not comparable"
        cpu->FpStatusC3 = 1;
        cpu->FpStatusC2 = 1;
        cpu->FpStatusC0 = 1;
        return;
    }

    CPUASSERT(l->TagSpecial == TAG_SPECIAL_DENORM || l->TagSpecial == TAG_SPECIAL_INFINITY);
    FpCom_VALID_VALID(cpu, l, r, FALSE);
}

NPXCOMFUNC(FpCom_SPECIAL_SPECIAL)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }

    if (l->TagSpecial == TAG_SPECIAL_QNAN || l->TagSpecial == TAG_SPECIAL_INDEF ||
        r->TagSpecial == TAG_SPECIAL_QNAN || r->TagSpecial == TAG_SPECIAL_INDEF) {
        //
        // Cannot compare a VALID to a QNAN/INDEF
        //
        if (!fUnordered && HandleInvalidOp(cpu)) {
            // abort the FCOM/FTST instruction - Illegal opcode is unmasked
            return;
        }

        // Otherwise, FCOM's illegal opcode is masked, or the instruction
        // is FUCOM, for which QNANs are uncomparable.  Return "Not comparable"
        cpu->FpStatusC3 = 1;
        cpu->FpStatusC2 = 1;
        cpu->FpStatusC0 = 1;
        return;
    }

    CPUASSERT((l->TagSpecial == TAG_SPECIAL_DENORM || l->TagSpecial == TAG_SPECIAL_INFINITY) &&
              (r->TagSpecial == TAG_SPECIAL_DENORM || r->TagSpecial == TAG_SPECIAL_INFINITY));
    FpCom_VALID_VALID(cpu, l, r, FALSE);
}

NPXCOMFUNC(FpCom_VALID_EMPTY)
{
    if (!HandleStackEmpty(cpu, r)) {

        //
        // r is now Indefinite, which can't be compared.
        //
        CPUASSERT(r->Tag == TAG_SPECIAL && r->TagSpecial == TAG_SPECIAL_INDEF);
        if (!fUnordered && HandleInvalidOp(cpu)) {
            // abort the FCOM/FTST instruction - Illegal opcode is unmasked
            return;
        }

        // Otherwise, FCOM's illegal opcode is masked, or the instruction
        // is FUCOM, for which QNANs are uncomparable.  Return "Not comparable"
        cpu->FpStatusC3 = 1;
        cpu->FpStatusC2 = 1;
        cpu->FpStatusC0 = 1;
    }
}

NPXCOMFUNC(FpCom_EMPTY_VALID)
{
    if (!HandleStackEmpty(cpu, l)) {

        //
        // l is now Indefinite, which can't be compared.
        //
        CPUASSERT(l->Tag == TAG_SPECIAL && l->TagSpecial == TAG_SPECIAL_INDEF);
        if (!fUnordered && HandleInvalidOp(cpu)) {
            // abort the FCOM/FTST instruction - Illegal opcode is unmasked
            return;
        }

        // Otherwise, FCOM's illegal opcode is masked, or the instruction
        // is FUCOM, for which QNANs are uncomparable.  Return "Not comparable"
        cpu->FpStatusC3 = 1;
        cpu->FpStatusC2 = 1;
        cpu->FpStatusC0 = 1;
    }
}

NPXCOMFUNC(FpCom_EMPTY_SPECIAL)
{
    if (!HandleStackEmpty(cpu, l)) {
        (*FpComTable[TAG_SPECIAL][r->Tag])(cpu, l, r, fUnordered);
    }
}

NPXCOMFUNC(FpCom_SPECIAL_EMPTY)
{
    if (!HandleStackEmpty(cpu, r)) {
        (*FpComTable[r->Tag][TAG_SPECIAL])(cpu, l, r, fUnordered);
    }
}

NPXCOMFUNC(FpCom_EMPTY_EMPTY)
{
    if (!HandleStackEmpty(cpu, l) && !HandleStackEmpty(cpu, r)) {

        //
        // l and r are both now Indefinite, which can't be compared.
        //
        CPUASSERT(l->Tag == TAG_SPECIAL && l->TagSpecial == TAG_SPECIAL_INDEF);
        CPUASSERT(r->Tag == TAG_SPECIAL && r->TagSpecial == TAG_SPECIAL_INDEF);
        if (!fUnordered && HandleInvalidOp(cpu)) {
            // abort the FCOM/FTST instruction - Illegal opcode is unmasked
            return;
        }

        // Otherwise, FCOM's illegal opcode is masked, or the instruction
        // is FUCOM, for which QNANs are uncomparable.  Return "Not comparable"
        cpu->FpStatusC3 = 1;
        cpu->FpStatusC2 = 1;
        cpu->FpStatusC0 = 1;
    }
}

VOID
FpComCommon(
    PCPUDATA cpu,
    PFPREG   l,
    PFPREG   r,
    BOOL     fUnordered
    )

/*++

Routine Description:

    Implements l += r.

Arguments:

    cpu     - per-thread data
    l       - left-hand FP register
    r       - right-hand FP register
    fUnordered - TRUE for unordered compares

Return Value:

    None.  l is updated to contain the value of l+r.

--*/

{
    cpu->FpStatusC1 = 0;        // assume no error
    (*FpComTable[l->Tag][r->Tag])(cpu, l, r, fUnordered);
}


FRAG1(FADD32, FLOAT)      // FADD m32real
{
    FPREG m32real;

    FpArithDataPreamble(cpu, pop1);

    GetIntelR4(&m32real, pop1);
    FpAddCommon(cpu, cpu->FpST0, &m32real);
}

FRAG1(FADD64, DOUBLE)     // FADD m64real
{
    FPREG m64real;

    FpArithDataPreamble(cpu, pop1);

    GetIntelR8(&m64real, pop1);
    FpAddCommon(cpu, cpu->FpST0, &m64real);
}

FRAG1IMM(FADD_STi_ST, INT) // FADD ST(i), ST = add ST to ST(i)
{
    FpArithPreamble(cpu);

    FpAddCommon(cpu, &cpu->FpStack[ST(op1)], cpu->FpST0);
}

FRAG1IMM(FADD_ST_STi, INT) // FADD ST, ST(i) = add ST(i) to ST
{
    FpArithPreamble(cpu);

    FpAddCommon(cpu, cpu->FpST0, &cpu->FpStack[ST(op1)]);
}

FRAG1IMM(FADDP_STi_ST, INT) // FADDP ST(i), ST = add ST to ST(i) and pop ST
{
    FpArithPreamble(cpu);

    FpAddCommon(cpu, &cpu->FpStack[ST(op1)], cpu->FpST0);
    POPFLT;
}

FRAG1(FIADD16, USHORT)   // FIADD m16int
{
    FPREG m16int;
    short s;

    FpArithDataPreamble(cpu, pop1);

    s = (short)GET_SHORT(pop1);
    if (s) {
        m16int.r64 = (DOUBLE)s;
        m16int.Tag = TAG_VALID;
    } else {
        m16int.r64 = 0.0;
        m16int.Tag = TAG_ZERO;
    }
    FpAddCommon(cpu, cpu->FpST0, &m16int);
}

FRAG1(FIADD32, ULONG)    // FIADD m32int
{
    FPREG m32int;
    long l;

    FpArithDataPreamble(cpu, pop1);

    l = (long)GET_LONG(pop1);
    if (l) {
        m32int.r64 = (DOUBLE)l;
        m32int.Tag = TAG_VALID;
    } else {
        m32int.r64 = 0.0;
        m32int.Tag = TAG_ZERO;
    }
    FpAddCommon(cpu, cpu->FpST0, &m32int);
}


FRAG1(FCOM32, FLOAT)  // FCOM m32real
{
    FPREG m32real;

    FpArithDataPreamble(cpu, pop1);

    GetIntelR4(&m32real, pop1);
    FpComCommon(cpu, cpu->FpST0, &m32real, FALSE);
}

FRAG1(FCOM64, DOUBLE) // FCOM m64real
{
    FPREG m64real;

    FpArithDataPreamble(cpu, pop1);

    GetIntelR8(&m64real, pop1);
    FpComCommon(cpu, cpu->FpST0, &m64real, FALSE);
}

FRAG1IMM(FCOM_STi, INT) // FCOM ST(i)
{
    FpArithPreamble(cpu);

    FpComCommon(cpu, cpu->FpST0, &cpu->FpStack[ST(op1)], FALSE);
}

FRAG1(FCOMP32, FLOAT) // FCOMP m32real
{
    FPREG m32real;

    FpArithDataPreamble(cpu, pop1);

    GetIntelR4(&m32real, pop1);
    FpComCommon(cpu, cpu->FpST0, &m32real, FALSE);
    POPFLT;
}

FRAG1(FCOMP64, DOUBLE) // FCOMP m64real
{
    FPREG m64real;

    FpArithDataPreamble(cpu, pop1);

    GetIntelR8(&m64real, pop1);
    FpComCommon(cpu, cpu->FpST0, &m64real, FALSE);
    POPFLT;
}

FRAG1IMM(FCOMP_STi, INT) // FCOMP ST(i)
{
    FpArithPreamble(cpu);

    FpComCommon(cpu, cpu->FpST0, &cpu->FpStack[ST(op1)], FALSE);
    POPFLT;
}

FRAG0(FCOMPP)
{
    FpArithPreamble(cpu);

    FpComCommon(cpu, cpu->FpST0, &cpu->FpStack[ST(1)], FALSE);
    POPFLT;
    POPFLT;
}


FRAG1(FDIV32, FLOAT)  // FDIV m32real
{
    FPREG m32real;

    FpArithDataPreamble(cpu, pop1);

    GetIntelR4(&m32real, pop1);
    FpDivCommon(cpu, cpu->FpST0, cpu->FpST0, &m32real);
}

FRAG1(FDIV64, DOUBLE) // FDIV m64real
{
    FPREG m64real;

    FpArithDataPreamble(cpu, pop1);

    GetIntelR8(&m64real, pop1);
    FpDivCommon(cpu, cpu->FpST0, cpu->FpST0, &m64real);
}

FRAG1IMM(FDIV_ST_STi, INT) // FDIV ST, ST(i)
{
    FpArithPreamble(cpu);

    FpDivCommon(cpu, cpu->FpST0, cpu->FpST0, &cpu->FpStack[ST(op1)]);
}

FRAG1IMM(FDIV_STi_ST, INT) // FDIV ST(i), ST
{
    FpArithPreamble(cpu);

    FpDivCommon(cpu, &cpu->FpStack[ST(op1)], cpu->FpST0, &cpu->FpStack[ST(op1)]);
}

FRAG1(FIDIV16, USHORT) // FIDIV m16int
{
    FPREG m16int;
    short s;

    FpArithDataPreamble(cpu, pop1);

    s = (short)GET_SHORT(pop1);
    if (s) {
        m16int.r64 = (DOUBLE)s;
        m16int.Tag = TAG_VALID;
    } else {
        m16int.r64 = 0.0;
        m16int.Tag = TAG_ZERO;
    }
    FpDivCommon(cpu, cpu->FpST0, cpu->FpST0, &m16int);
}

FRAG1(FIDIV32, ULONG)   // FIDIV m32int
{
    FPREG m32int;
    long l;

    FpArithDataPreamble(cpu, pop1);

    l = (long)GET_LONG(pop1);
    if (l) {
        m32int.r64 = (DOUBLE)l;
        m32int.Tag = TAG_VALID;
    } else {
        m32int.r64 = 0.0;
        m32int.Tag = TAG_ZERO;
    }
    FpDivCommon(cpu, cpu->FpST0, cpu->FpST0, &m32int);
}

FRAG1IMM(FDIVP_STi_ST, INT)    // FDIVP ST(i), ST
{
    FpArithPreamble(cpu);

    FpDivCommon(cpu, &cpu->FpStack[ST(op1)], cpu->FpST0, &cpu->FpStack[ST(op1)]);
    POPFLT;
}

FRAG1(FDIVR32, FLOAT)     // FDIVR m32real
{
    FPREG m32real;

    FpArithDataPreamble(cpu, pop1);

    GetIntelR4(&m32real, pop1);
    FpDivCommon(cpu, cpu->FpST0, &m32real, cpu->FpST0);
}

FRAG1(FDIVR64, DOUBLE)    // FDIVR m64real
{
    FPREG m64real;

    FpArithDataPreamble(cpu, pop1);

    GetIntelR8(&m64real, pop1);
    FpDivCommon(cpu, cpu->FpST0, &m64real, cpu->FpST0);
}

FRAG1IMM(FDIVR_ST_STi, INT) // FDIVR ST, ST(i)
{
    FpArithPreamble(cpu);

    FpDivCommon(cpu, cpu->FpST0, &cpu->FpStack[ST(op1)], cpu->FpST0);
}

FRAG1IMM(FDIVR_STi_ST, INT) // FDIVR ST(i), ST
{
    FpArithPreamble(cpu);

    FpDivCommon(cpu, &cpu->FpStack[ST(op1)], &cpu->FpStack[ST(op1)], cpu->FpST0);
}

FRAG1IMM(FDIVRP_STi_ST, INT) // FDIVRP ST(i)
{
    FpArithPreamble(cpu);

    FpDivCommon(cpu, &cpu->FpStack[ST(op1)], &cpu->FpStack[ST(op1)], cpu->FpST0);
    POPFLT;
}

FRAG1(FIDIVR16, USHORT)  // FIDIVR m16int
{
    FPREG m16int;
    short s;

    FpArithDataPreamble(cpu, pop1);

    s = (short)GET_SHORT(pop1);
    if (s) {
        m16int.r64 = (DOUBLE)s;
        m16int.Tag = TAG_VALID;
    } else {
        m16int.r64 = 0.0;
        m16int.Tag = TAG_ZERO;
    }
    FpDivCommon(cpu, cpu->FpST0, &m16int, cpu->FpST0);
}

FRAG1(FIDIVR32, ULONG)   // FIDIVR m32int
{
    FPREG m32int;
    long l;

    FpArithDataPreamble(cpu, pop1);

    l = (long)GET_LONG(pop1);
    if (l) {
        m32int.r64 = (DOUBLE)l;
        m32int.Tag = TAG_VALID;
    } else {
        m32int.r64 = 0.0;
        m32int.Tag = TAG_ZERO;
    }
    FpDivCommon(cpu, cpu->FpST0, &m32int, cpu->FpST0);
}

FRAG1(FICOM16, USHORT)   // FICOM m16int (Intel docs say m16real)
{
    FPREG m16int;
    short s;

    FpArithDataPreamble(cpu, pop1);

    s = (short)GET_SHORT(pop1);
    if (s) {
        m16int.r64 = (DOUBLE)s;
        m16int.Tag = TAG_VALID;
    } else {
        m16int.r64 = 0.0;
        m16int.Tag = TAG_ZERO;
    }
    FpComCommon(cpu, cpu->FpST0, &m16int, FALSE);
}

FRAG1(FICOM32, ULONG)    // FICOM m32int (Intel docs say m32real)
{
    FPREG m32int;
    long l;

    FpArithDataPreamble(cpu, pop1);

    l = (long)GET_LONG(pop1);
    if (l) {
        m32int.r64 = (DOUBLE)l;
        m32int.Tag = TAG_VALID;
    } else {
        m32int.r64 = 0.0;
        m32int.Tag = TAG_ZERO;
    }
    FpComCommon(cpu, cpu->FpST0, &m32int, FALSE);
}

FRAG1(FICOMP16, USHORT)  // FICOMP m16int
{
    FPREG m16int;
    short s;

    FpArithDataPreamble(cpu, pop1);

    s = (short)GET_SHORT(pop1);
    if (s) {
        m16int.r64 = (DOUBLE)s;
        m16int.Tag = TAG_VALID;
    } else {
        m16int.r64 = 0.0;
        m16int.Tag = TAG_ZERO;
    }
    FpComCommon(cpu, cpu->FpST0, &m16int, FALSE);
    POPFLT;
}

FRAG1(FICOMP32, ULONG)   // FICOMP m32int
{
    FPREG m32int;
    long l;

    FpArithDataPreamble(cpu, pop1);

    l = (long)GET_LONG(pop1);
    if (l) {
        m32int.r64 = (DOUBLE)l;
        m32int.Tag = TAG_VALID;
    } else {
        m32int.r64 = 0.0;
        m32int.Tag = TAG_ZERO;
    }
    FpComCommon(cpu, cpu->FpST0, &m32int, FALSE);
    POPFLT;
}

FRAG1(FMUL32, FLOAT)      // FMUL m32real
{
    FPREG m32real;

    FpArithDataPreamble(cpu, pop1);

    GetIntelR4(&m32real, pop1);
    FpMulCommon(cpu, cpu->FpST0, &m32real);
}

FRAG2(FMUL64, DOUBLE)     // FMUL m64real
{
    FPREG m64real;

    FpArithDataPreamble(cpu, pop1);

    GetIntelR8(&m64real, pop1);
    FpMulCommon(cpu, cpu->FpST0, &m64real);
}

FRAG1IMM(FMUL_STi_ST, INT) // FMUL ST(i), ST
{
    FpArithPreamble(cpu);

    FpMulCommon(cpu, &cpu->FpStack[ST(op1)], cpu->FpST0);
}

FRAG1IMM(FMUL_ST_STi, INT) // FMUL ST, ST(i)
{
    FpArithPreamble(cpu);

    FpMulCommon(cpu, cpu->FpST0, &cpu->FpStack[ST(op1)]);
}

FRAG1IMM(FMULP_STi_ST, INT)    // FMULP ST(i), ST
{
    FpArithPreamble(cpu);

    FpMulCommon(cpu, &cpu->FpStack[ST(op1)], cpu->FpST0);
    POPFLT;
}

FRAG1(FIMUL16, USHORT)      // FIMUL m16int
{
    FPREG m16int;
    short s;

    FpArithDataPreamble(cpu, pop1);

    s = (short)GET_SHORT(pop1);
    if (s) {
        m16int.r64 = (DOUBLE)s;
        m16int.Tag = TAG_VALID;
    } else {
        m16int.r64 = 0.0;
        m16int.Tag = TAG_ZERO;
    }
    FpMulCommon(cpu, cpu->FpST0, &m16int);
}

FRAG1(FIMUL32, ULONG)       // FIMUL m32int
{
    FPREG m32int;
    long l;

    FpArithDataPreamble(cpu, pop1);

    l = (long)GET_LONG(pop1);
    if (l) {
        m32int.r64 = (DOUBLE)l;
        m32int.Tag = TAG_VALID;
    } else {
        m32int.r64 = 0.0;
        m32int.Tag = TAG_ZERO;
    }
    FpMulCommon(cpu, cpu->FpST0, &m32int);
}

FRAG1(FSUB32, FLOAT)      // FSUB m32real
{
    FPREG m32real;

    FpArithDataPreamble(cpu, pop1);

    GetIntelR4(&m32real, pop1);
    FpSubCommon(cpu, cpu->FpST0, cpu->FpST0, &m32real);
}

FRAG1(FSUBP32, FLOAT)     // FSUBP m32real
{
    FPREG m32real;

    FpArithDataPreamble(cpu, pop1);

    GetIntelR4(&m32real, pop1);
    FpSubCommon(cpu, cpu->FpST0, cpu->FpST0, &m32real);
    POPFLT;
}

FRAG1(FSUB64, DOUBLE)     // FSUB m64real
{
    FPREG m64real;

    FpArithDataPreamble(cpu, pop1);

    GetIntelR8(&m64real, pop1);
    FpSubCommon(cpu, cpu->FpST0, cpu->FpST0, &m64real);
}

FRAG1(FSUBP64, DOUBLE)    // FSUBP m64real
{
    FPREG m64real;

    FpArithDataPreamble(cpu, pop1);

    GetIntelR8(&m64real, pop1);
    FpSubCommon(cpu, cpu->FpST0, cpu->FpST0, &m64real);
    POPFLT;
}

FRAG1IMM(FSUB_ST_STi, INT)   // FSUB ST, ST(i)
{
    FpArithPreamble(cpu);

    FpSubCommon(cpu, cpu->FpST0, cpu->FpST0, &cpu->FpStack[ST(op1)]);
}

FRAG1IMM(FSUB_STi_ST, INT)  // FSUB ST(i), ST
{
    FpArithPreamble(cpu);

    FpSubCommon(cpu, &cpu->FpStack[ST(op1)], cpu->FpST0, &cpu->FpStack[ST(op1)]);
}

FRAG1IMM(FSUBP_STi_ST, INT) // FSUBP ST(i), ST
{
    FpArithPreamble(cpu);

    FpSubCommon(cpu, &cpu->FpStack[ST(op1)], cpu->FpST0, &cpu->FpStack[ST(op1)]);
    POPFLT;
}

FRAG1(FISUB16, USHORT)   // FISUB m16int
{
    FPREG m16int;
    short s;

    FpArithDataPreamble(cpu, pop1);

    s = (short)GET_SHORT(pop1);
    if (s) {
        m16int.r64 = (DOUBLE)s;
        m16int.Tag = TAG_VALID;
    } else {
        m16int.r64 = 0.0;
        m16int.Tag = TAG_ZERO;
    }
    FpSubCommon(cpu, cpu->FpST0, cpu->FpST0, &m16int);
}

FRAG1(FISUB32, ULONG)    // FISUB m32int
{
    FPREG m32int;
    long l;

    FpArithDataPreamble(cpu, pop1);

    l = (long)GET_LONG(pop1);
    if (l) {
        m32int.r64 = (DOUBLE)l;
        m32int.Tag = TAG_VALID;
    } else {
        m32int.r64 = 0.0;
        m32int.Tag = TAG_ZERO;
    }
    FpSubCommon(cpu, cpu->FpST0, cpu->FpST0, &m32int);
}

FRAG1(FSUBR32, FLOAT)     // FSUBR m32real
{
    FPREG m32real;

    FpArithDataPreamble(cpu, pop1);

    GetIntelR4(&m32real, pop1);
    FpSubCommon(cpu, cpu->FpST0, &m32real, cpu->FpST0);
}

FRAG1(FSUBR64, DOUBLE)    // FSUBR m64real
{
    FPREG m64real;

    FpArithDataPreamble(cpu, pop1);

    GetIntelR8(&m64real, pop1);
    FpSubCommon(cpu, cpu->FpST0, &m64real, cpu->FpST0);
}

FRAG1IMM(FSUBR_ST_STi, INT) // FSUBR ST, ST(i)
{
    FpArithPreamble(cpu);

    FpSubCommon(cpu, cpu->FpST0, &cpu->FpStack[ST(op1)], cpu->FpST0);
}

FRAG1IMM(FSUBR_STi_ST, INT) // FSUBR ST(i), ST
{
    FpArithPreamble(cpu);

    FpSubCommon(cpu, &cpu->FpStack[ST(op1)], &cpu->FpStack[ST(op1)], cpu->FpST0);
}

FRAG1IMM(FSUBRP_STi_ST, INT) // FSUBRP ST(i)
{
    FpArithPreamble(cpu);

    FpSubCommon(cpu, &cpu->FpStack[ST(op1)], &cpu->FpStack[ST(op1)], cpu->FpST0);
    POPFLT;
}

FRAG1(FISUBR16, USHORT)
{
    FPREG m16int;
    short s;

    FpArithDataPreamble(cpu, pop1);

    s = (short)GET_SHORT(pop1);
    if (s) {
        m16int.r64 = (DOUBLE)s;
        m16int.Tag = TAG_VALID;
    } else {
        m16int.r64 = 0.0;
        m16int.Tag = TAG_ZERO;
    }
    FpSubCommon(cpu, cpu->FpST0, &m16int, cpu->FpST0);
}

FRAG1(FISUBR32, ULONG)
{
    FPREG m32int;
    long l;

    FpArithDataPreamble(cpu, pop1);

    l = (long)GET_LONG(pop1);
    if (l) {
        m32int.r64 = (DOUBLE)l;
        m32int.Tag = TAG_VALID;
    } else {
        m32int.r64 = 0.0;
        m32int.Tag = TAG_ZERO;
    }
    FpSubCommon(cpu, cpu->FpST0, &m32int, cpu->FpST0);
}

FRAG0(FTST)
{
    FPREG Zero;

    FpArithPreamble(cpu);

    Zero.r64 = 0.0;
    Zero.Tag = TAG_ZERO;
    FpComCommon(cpu, cpu->FpST0, &Zero, FALSE);
}

FRAG1IMM(FUCOM, INT)        // FUCOM ST(i) / FUCOM
{
    FpArithPreamble(cpu);

    FpComCommon(cpu, cpu->FpST0, &cpu->FpStack[ST(op1)], TRUE);
}

FRAG1IMM(FUCOMP, INT)       // FUCOMP ST(i) / FUCOMP
{
    FpArithPreamble(cpu);

    FpComCommon(cpu, cpu->FpST0, &cpu->FpStack[ST(op1)], TRUE);
    POPFLT;
}

FRAG0(FUCOMPP)
{
    FpArithPreamble(cpu);

    FpComCommon(cpu, cpu->FpST0, &cpu->FpStack[ST(1)], TRUE);
    POPFLT;
    POPFLT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\fpubcd.c ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    fpubcd.c

Abstract:

    Floating point BCD fragments (FBLD, FBSTP)

Author:

    05-Oct-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <float.h>
#include <math.h>
#include <errno.h>
#include <stdio.h>
#include "wx86.h"
#include "fragp.h"
#include "fpufrags.h"
#include "fpufragp.h"

typedef VOID (*NpxPutBCD)(PCPUDATA cpu, PFPREG Fp, PBYTE pop1);
#define NPXPUTBCD(name) VOID name(PCPUDATA cpu, PFPREG Fp, PBYTE pop1)

NPXPUTBCD(FBSTP_VALID);
NPXPUTBCD(FBSTP_ZERO);
NPXPUTBCD(FBSTP_SPECIAL);
NPXPUTBCD(FBSTP_EMPTY);

const NpxPutBCD FBSTPTable[TAG_MAX] = {
    FBSTP_VALID,
    FBSTP_ZERO,
    FBSTP_SPECIAL,
    FBSTP_EMPTY
};

const double BCDMax=999999999999999999.0;

VOID
StoreIndefiniteBCD(
    PBYTE pop1
    )
/*++

Routine Description:

    Write out the BCD encoding for INDEFINITE.

    Note that ntos\dll\i386\emlsbcd.asm writes out a different
    bit-pattern than the 487 does!  The value written here matches
    a Pentium's response.

Arguments:

    pop1 - address of BCD to write to

Return Value:

    None

--*/
{
    //
    // Write out:          0xffff c0000000 00000000
    // emlsbcd.asm writes: 0xffff 00000000 00000000
    //                            ^
    //
    PUT_LONG(pop1, 0);
    PUT_LONG(pop1+4, 0xc0000000);
    PUT_SHORT(pop1+8, 0xffff);
}



FRAG1(FBLD, BYTE)
{
    FpArithDataPreamble(cpu, pop1);

    cpu->FpStatusC1 = 0;        // assume no error
    if (cpu->FpStack[ST(7)].Tag != TAG_EMPTY) {
        HandleStackFull(cpu, &cpu->FpStack[ST(7)]);
    } else {
        LONGLONG I64;
        DWORD dw0;
        INT Bytes;
        BYTE Val;
        PFPREG ST0;

        //
        // Get the BCD value into the FPU
        //
        dw0 = GET_LONG(pop1);

        PUSHFLT(ST0);

        if (dw0 == 0) {
            DWORD dw1 = GET_LONG(pop1+4);
            USHORT us0 = GET_SHORT(pop1+8);

            if (dw1 == 0xc0000000 && us0 == 0xffff) {

                //
                // The value is INDEFINITE
                //
                SetIndefinite(ST0);
                return;

            } else if (dw1 == 0 && (us0 & 0xff) == 0) {

                //
                // The value is +/- 0
                //
                ST0->Tag = TAG_ZERO;
                ST0->r64 = 0;
                ST0->rb[7] = (us0 >> 8); // copy in the sign bit
                return;
            }
        }

        //
        // Otherwise, the BCD value is TAG_VALID - load the digits in
        //
        I64 = 0;
        for (Bytes=8; Bytes>=0; --Bytes) {
            Val = GET_BYTE(pop1+Bytes);
            I64 = I64*100 + (Val>>4)*10 + (Val&0x0f);
        }

        //
        // Get the sign bit
        //
        Val = GET_BYTE(pop1+9) & 0x80;

        //
        // Set up the FP reg
        //
        ST0->Tag = TAG_VALID;
        ST0->r64 = (double)I64;
        ST0->rb[7] |= Val;       // copy in the sign bit
    }
}

NPXPUTBCD(FBSTP_VALID)
{
    BYTE Sign = Fp->rb[7] & 0x80;       // preserve the R8 sign
    BYTE Val;
    INT Bytes;
    LONGLONG I64;
    LONGLONG NewI64;
    DOUBLE r64;

    //
    // Take the absolute value of the R8 by clearing its sign bit
    //
    r64 = Fp->r64;
    *((PBYTE)&r64+7) &= 0x7f;

    //
    // Check the range of the R8
    //
    if (r64 > BCDMax) {
        //
        // Overflow - write out BCD indefinite.
        //
        StoreIndefiniteBCD(pop1);
        return;
    }

    //
    // Convert to an integer according the the current rounding mode
    //
    I64 = (LONGLONG)r64;

    //
    // Convert the integer to BCD, two digits at a time, and store it
    //
    for (Bytes = 0; Bytes < 9; ++Bytes) {
        NewI64 = I64 / 10;
        Val = (BYTE)(I64 - NewI64*10);  // low nibble Val = I64 mod 10
                                        // high nibble Val = 0

        I64 = NewI64 / 10;
        Val += 16*(BYTE)(NewI64 - I64*10);    // low nibble Val = I64 mod 10
                                        // high nibble Val = (I64/10) mod 10

        //
        // Store the two BCD digits
        //
        PUT_BYTE(pop1, Val);

        //
        // I64 has been divided by 100 since the top of the loop, so
        // there is nothing to do to it in order to loop again.  Update
        // the address we are writing to, then loop.
        //
        pop1++;
    }

    //
    // Store the sign bit, along with 7 zero bits in the top byte
    //
    PUT_BYTE(pop1, Sign);
    POPFLT;
}

NPXPUTBCD(FBSTP_ZERO)
{
    // Store out the signed zero value
    memset(pop1, 0, 9);
    PUT_BYTE(pop1+9, Fp->rb[7]);
    POPFLT;
}

NPXPUTBCD(FBSTP_SPECIAL)
{
    if (Fp->TagSpecial) {
        FBSTP_VALID(cpu, Fp, pop1);
    } else {
        //
        // INFINITY and NANs are invalid, and the masked behavior is
        // to write out INDEFINITE.
        //
        if (!HandleInvalidOp(cpu)) {
            StoreIndefiniteBCD(pop1);
            POPFLT;
        }
    }
}

NPXPUTBCD(FBSTP_EMPTY)
{
    if (!HandleStackEmpty(cpu, Fp)) {
        StoreIndefiniteBCD(pop1);
    }
}

FRAG1(FBSTP, BYTE)
{
    PFPREG ST0;

    FpArithDataPreamble(cpu, pop1);
    ST0 = cpu->FpST0;
    (*FBSTPTable[ST0->Tag])(cpu, ST0, pop1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\fpufrags.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    fpufrags.h

Abstract:
    
    Prototypes for floating-point instruction fragments.

Author:

    11-Jul-1995 BarryBo, Created

Revision History:

--*/

FRAG0(FpuInit);
FRAG1(FpuSaveContext, BYTE);

FRAG0(F2XM1);
FRAG0(FABS);
FRAG1(FADD32, FLOAT);      // FADD m32real
FRAG1(FADD64, DOUBLE);     // FADD m64real
FRAG1IMM(FADD_STi_ST, INT); // FADD ST(i), ST = add ST to ST(i)
FRAG1IMM(FADD_ST_STi, INT); // FADD ST, ST(i) = add ST(i) to ST
FRAG1IMM(FADDP_STi_ST, INT); // FADDP ST(i), ST = add ST to ST(i) and pop ST
FRAG1(FIADD16, USHORT);   // FIADD m16int
FRAG1(FIADD32, ULONG);    // FIADD m32int
FRAG1(FBLD, BYTE);
FRAG1(FBSTP, BYTE);
FRAG0(FCHS);
FRAG0(FNCLEX);
FRAG1(FCOM32, FLOAT);  // FCOM m32real
FRAG1(FCOM64, DOUBLE); // FCOM m64real
FRAG1IMM(FCOM_STi, INT); // FCOM ST(i)
FRAG1(FCOMP32, FLOAT); // FCOMP m32real
FRAG1(FCOMP64, DOUBLE); // FCOMP m64real
FRAG1IMM(FCOMP_STi, INT); // FCOMP ST(i)
FRAG0(FCOMPP);
FRAG0(FCOS);
FRAG0(FDECSTP);
FRAG1(FDIV32, FLOAT);  // FDIV m32real
FRAG1(FDIV64, DOUBLE); // FDIV m64real
FRAG1IMM(FDIV_ST_STi, INT); // FDIV ST, ST(i)
FRAG1IMM(FDIV_STi_ST, INT); // FDIV ST(i), ST
FRAG1(FIDIV16, USHORT); // FIDIV m16int
FRAG1(FIDIV32, ULONG);   // FIDIV m32int
FRAG1IMM(FDIVP_STi_ST, INT);    // FDIVP ST(i), ST
FRAG1(FDIVR32, FLOAT);     // FDIVR m32real
FRAG1(FDIVR64, DOUBLE);    // FDIVR m64real
FRAG1IMM(FDIVR_ST_STi, INT); // FDIVR ST, ST(i)
FRAG1IMM(FDIVR_STi_ST, INT); // FDIVR ST(i), ST
FRAG1IMM(FDIVRP_STi_ST, INT); // FDIVRP ST(i)
FRAG1(FIDIVR16, USHORT);  // FIDIVR m16int
FRAG1(FIDIVR32, ULONG);   // FIDIVR m32int
FRAG1IMM(FFREE, INT);
FRAG1(FICOM16, USHORT);   // FICOM m16int (Intel docs say m16real);
FRAG1(FICOM32, ULONG);    // FICOM m32int (Intel docs say m32real);
FRAG1(FICOMP16, USHORT);  // FICOMP m16int
FRAG1(FICOMP32, ULONG);   // FICOMP m32int
FRAG1(FILD16, SHORT);    // FILD m16int
FRAG1(FILD32, LONG);     // FILD m32int
FRAG1(FILD64, LONGLONG); // FILD m64int
FRAG0(FINCSTP);
FRAG0(FNINIT);
FRAG1(FIST16, SHORT);     // FIST m16int
FRAG1(FISTP16, SHORT);    // FISTP m16int
FRAG1(FIST32, LONG);      // FIST m32int
FRAG1(FISTP32, LONG);     // FISTP m32int
FRAG1(FIST64, LONGLONG);  // FIST m64int
FRAG1(FISTP64, LONGLONG); // FISTP m64int
FRAG1(FLD32, FLOAT);       // FLD m32real
FRAG1(FLD64, DOUBLE);      // FLD m64real
FRAG1(FLD80, BYTE);        // FLD m80real
FRAG0(FLD1);
FRAG0(FLDL2T);
FRAG0(FLDL2E);
FRAG0(FLDPI);
FRAG0(FLDLG2);
FRAG0(FLDLN2);
FRAG1IMM(FLD_STi, INT);
FRAG0(FLDZ);
FRAG1(FLDCW, USHORT*);
FRAG1(FLDENV, BYTE);
FRAG1(FMUL32, FLOAT);      // FMUL m32real
FRAG2(FMUL64, DOUBLE);     // FMUL m64real
FRAG1IMM(FMUL_STi_ST, INT); // FMUL ST(i), ST
FRAG1IMM(FMUL_ST_STi, INT); // FMUL ST, ST(i)
FRAG1IMM(FMULP_STi_ST, INT);    // FMULP ST(i), ST
FRAG1(FIMUL16, USHORT);      // FIMUL m16int
FRAG1(FIMUL32, ULONG);       // FIMUL m32int
FRAG0(FPATAN);
FRAG0(FPREM);
FRAG0(FPREM1);
FRAG0(FPTAN);
FRAG0(FRNDINT);
FRAG1(FRSTOR, BYTE);
FRAG1(FNSAVE, BYTE);
FRAG0(FSCALE);
FRAG0(FSIN);
FRAG0(FSINCOS);
FRAG0(FSQRT);
FRAG1(FST32, FLOAT);       // FST m32real
FRAG1(FSTP32, FLOAT);      // FSTP m32real
FRAG1(FST64, DOUBLE);      // FST m64real
FRAG1(FSTP64, DOUBLE);     // FSTP m64real
FRAG1(FSTP80, BYTE);       // FSTP m80real
FRAG1IMM(FST_STi, INT);      // FST ST(i)
FRAG1IMM(FSTP_STi, INT);     // FSTP ST(i)
FRAG0(OPT_FSTP_ST0);     // FSTP ST(0)
FRAG1(FNSTCW, USHORT);
FRAG1(FNSTENV, BYTE);
FRAG1(FNSTSW, USHORT);
FRAG0(OPT_FNSTSWAxSahf);    // FNSTSW AX, SAHF
FRAG1(FSUB32, FLOAT);      // FSUB m32real
FRAG1(FSUBP32, FLOAT);     // FSUBP m32real
FRAG1(FSUB64, DOUBLE);     // FSUB m64real
FRAG1(FSUBP64, DOUBLE);    // FSUBP m64real
FRAG1IMM(FSUB_ST_STi, INT);   // FSUB ST, ST(i)
FRAG1IMM(FSUB_STi_ST, INT);  // FSUB ST(i), ST
FRAG1IMM(FSUBP_STi_ST, INT); // FSUBP ST(i), ST
FRAG1(FISUB16, USHORT);   // FISUB m16int
FRAG1(FISUB32, ULONG);    // FISUB m64int
FRAG1(FSUBR32, FLOAT);     // FSUBR m32real
FRAG1(FSUBR64, DOUBLE);    // FSUBR m64real
FRAG1IMM(FSUBR_ST_STi, INT); // FSUBR ST, ST(i)
FRAG1IMM(FSUBR_STi_ST, INT); // FSUBR ST(i), ST
FRAG1IMM(FSUBRP_STi_ST, INT); // FSUBRP ST(i)
FRAG1(FISUBR16, USHORT);
FRAG1(FISUBR32, ULONG);
FRAG0(FTST);
FRAG1IMM(FUCOM, INT);        // FUCOM ST(i) / FUCOM
FRAG1IMM(FUCOMP, INT);       // FUCOMP ST(i) / FUCOMP
FRAG0(FUCOMPP);
FRAG0(FXAM);
FRAG1IMM(FXCH_STi, INT);
FRAG0(FXTRACT);
FRAG0(FYL2X);
FRAG0(FYL2XP1);
FRAG0(WaitFrag);
FRAG0(FNOP);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\fpuload.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    fpuload.c

Abstract:

    Floating point load functions

Author:

    04-Oct-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <float.h>
#include <math.h>
#include <stdio.h>
#include "wx86.h"
#include "cpuassrt.h"
#include "fragp.h"
#include "fpufragp.h"
#include "fpuarith.h"

ASSERTNAME;

VOID GetIntelR4(
    PFPREG Fp,
    FLOAT *pIntelReal
    )
/*++

Routine Description:

    Load an Intel R4 and convert it to a native R4, accounting for
    the difference in how MIPS represents QNAN/SNAN.

    NOTE: This is not in fpufrag.c due to a code-generator bug on PPC -
          irbexpr.c:932 asserts trying to inline this function.  Moving it
          to a different file defeats the inliner.

Arguments:

    Fp         - floating-point register to load the R4 into
    pIntelReal - R4 value to load (in Intel format)
    
Return Value:

    None.

--*/
{
    DWORD d = GET_LONG(pIntelReal);

    if ((d & 0x7f800000) == 0x7f800000) {

        Fp->Tag = TAG_SPECIAL;

        // Found some sort of NAN
        if (d == 0xffc00000) {  // Indefinite

            // Create the native indefinite form
#if NATIVE_NAN_IS_INTEL_FORMAT
            Fp->rdw[0] = 0;
            Fp->rdw[1] = 0xfff80000;
#else
            Fp->rdw[0] = 0xffffffff;
            Fp->rdw[1] = 0x7ff7ffff;
#endif
            Fp->TagSpecial = TAG_SPECIAL_INDEF;

        } else if (d == 0x7f800000) {   // +infinity

            Fp->r64 = R8PositiveInfinity;
            Fp->TagSpecial = TAG_SPECIAL_INFINITY;

        } else if (d == 0xff800000) {   // -infinity

            Fp->r64 = R8NegativeInfinity;
            Fp->TagSpecial = TAG_SPECIAL_INFINITY;

        } else {                // SNAN/QNAN

            DWORD Sign;

            if (d & 0x00400000) {
                //
                // Intel QNAN
                //
                Fp->TagSpecial = TAG_SPECIAL_QNAN;

            } else {
                //
                // Intel SNAN
                //
                Fp->TagSpecial = TAG_SPECIAL_SNAN;
            }

#if !NATIVE_NAN_IS_INTEL_FORMAT
            //
            // Toggle the NAN to native format
            //
            d ^= 0x00400000;
#endif

            //
            // Cast the r4 RISC QNAN to double.  Don't trust the CRT to
            // do the right thing - MIPS converts them both to INDEFINITE.
            //
            Sign = d & 0x80000000;
            d &= 0x007fffff;    // grab the mantissa from the r4 (23 bits)
            Fp->rdw[1] = Sign | 0x7ff00000 | (d >> 3); // store 20 bits of mantissa, plus sign
            Fp->rdw[0] = d << 25;               // store 3 bits of mantissa
        }

    } else { // denormal, zero, or number

        // Coerce it to an R8
        Fp->r64 = (DOUBLE)*(FLOAT *)&d;

        // Compute its tag by looking at the value *after* the conversion,
        // as the native FPU may have normalized the value
        if (Fp->r64 == 0.0) {
            Fp->Tag = TAG_ZERO;
        } else if ((Fp->rdw[1] & 0x7ff00000) == 0) {
            // Exponent is 0 - R8 denormal
            Fp->Tag = TAG_SPECIAL;
            Fp->TagSpecial = TAG_SPECIAL_DENORM;
        } else {
            Fp->Tag = TAG_VALID;
#if DBG
            SetTag(Fp);
            CPUASSERT(Fp->Tag == TAG_VALID);
#endif
        }
    }
}

#if !NATIVE_NAN_IS_INTEL_FORMAT

VOID GetIntelR8(
    PFPREG Fp,
    DOUBLE *pIntelReal
    )
/*++

Routine Description:

    Load an Intel R8 and convert it to a native R8, accounting for
    the difference in how MIPS represents QNAN/SNAN.

Arguments:

    Fp         - floating-point register to load the R8 into
    pIntelReal - R8 value to load (in Intel format)
    
Return Value:

    None.

--*/
{
    //
    // Copy the R8 into the FP register
    //
    Fp->r64 = *(UNALIGNED DOUBLE *)pIntelReal;

    //
    // Compute its tag
    //
    SetTag(Fp);

    //
    // If the value is QNAN/SNAN/INDEF, convert it to native format
    //
    if (IS_TAG_NAN(Fp)) {

        if (Fp->rdw[0] == 0 && Fp->rdw[1] == 0xfff80000) {
            // indefinite - make the R8 into a native indefinite
            Fp->TagSpecial = TAG_SPECIAL_INDEF;
            Fp->rdw[0] = 0xffffffff;
            Fp->rdw[1] = 0x7ff7ffff;
        } else {
            if (Fp->rdw[1] & 0x00080000) {
                // top bit of mantissa is set - QNAN
                Fp->TagSpecial = TAG_SPECIAL_QNAN;
            } else {
                // top bit of mantissa clear - SNAN
                Fp->TagSpecial = TAG_SPECIAL_SNAN;
            }
            Fp->rdw[1] ^= 0x00080000; // invert the top bit of the mantissa
        }
    }
}

#endif //!NATIVE_NAN_IS_INTEL_FORMAT




VOID
SetTag(
    PFPREG FpReg
    )

/*++

Routine Description:

    Sets the Tag value corresponding to a r64 value in an FP register.
    Assumes the R8 value is in native format (ie. Intel NANs are already
    converted to native NANs).

Arguments:

    FpReg - register to set Tag field in.

Return Value:

    None

--*/

{
    DWORD Exponent;

    /* On average, the value will be zero or a valid real, so those cases
     * have the fastest code paths.  NANs tend to be less frequent and are
     * slower to calculate.
     */
    Exponent = FpReg->rdw[1] & 0x7ff00000;
    if (Exponent == 0x7ff00000) {
        // exponent is all 1's - NAN of some sort

        FpReg->Tag = TAG_SPECIAL;

        if (FpReg->rdw[0] == 0 && (FpReg->rdw[1] & 0x7fffffff) == 0x7ff00000) {
            // Exponent is all 1s, mantissa is all 0s - Infinity
            FpReg->TagSpecial = TAG_SPECIAL_INFINITY;
        } else {

#if NATIVE_NAN_IS_INTEL_FORMAT
            if (FpReg->rdw[0] == 0 && FpReg->rdw[1] == 0xfff80000) {
                // indefinite
                FpReg->TagSpecial = TAG_SPECIAL_INDEF;
            } else if (FpReg->rdw[1] & 0x00080000) {
                // top bit of mantissa is set - QNAN
                FpReg->TagSpecial = TAG_SPECIAL_QNAN;
            } else {
                // Top bit of mantissa clear - but some mantissa bit set - QNAN
                FpReg->TagSpecial = TAG_SPECIAL_SNAN;
            }
#else   //!NATIVE_NAN_IS_INTEL_FORMAT
            if (FpReg->rdw[0] == 0xffffffff && FpReg->rdw[1] == 0x7ff7ffff) {
                // indefinite
                FpReg->TagSpecial = TAG_SPECIAL_INDEF;
            } else if (FpReg->rdw[1] & 0x00080000) {
                // top bit of mantissa is set - SNAN
                FpReg->TagSpecial = TAG_SPECIAL_SNAN;
            } else {
                // top bit of mantissa clear - QNAN
                FpReg->TagSpecial = TAG_SPECIAL_QNAN;
            }
#endif  //!NATIVE_NAN_IS_INTEL_FORMAT

        }
    } else if (Exponent == 0) {
        // exponent is 0 - DENORMAL or ZERO
        if ((FpReg->rdw[1] & 0x1ffff) == 0 && FpReg->rdw[0] == 0) {
            // mantissa is all zeroes - ZERO
            FpReg->Tag = TAG_ZERO;
        } else {
            FpReg->Tag = TAG_SPECIAL;
            FpReg->TagSpecial = TAG_SPECIAL_DENORM;
        }
    } else {
        // Exponent is not all 1's and not all 0's - a VALID
        FpReg->Tag = TAG_VALID;
    }
}

FRAG1(FILD16, SHORT)    // FILD m16int
{
    PFPREG ST0;
    FpArithDataPreamble(cpu, pop1);

    cpu->FpStatusC1 = 0;        // assume no error
    PUSHFLT(ST0);
    if (ST0->Tag != TAG_EMPTY) {
        HandleStackFull(cpu, ST0);
    } else {
        SHORT s;

        s = (SHORT)GET_SHORT(pop1);
        ST0->r64 = (DOUBLE)s;
        if (s) {
            ST0->Tag = TAG_VALID;
        } else {
            ST0->Tag = TAG_ZERO;
        }
    }
}

FRAG1(FILD32, LONG)     // FILD m32int
{
    PFPREG ST0;
    FpArithDataPreamble(cpu, pop1);

    cpu->FpStatusC1 = 0;        // assume no error
    PUSHFLT(ST0);
    if (ST0->Tag != TAG_EMPTY) {
        HandleStackFull(cpu, ST0);
    } else {
        LONG l;

        l = (LONG)GET_LONG(pop1);
        ST0->r64 = (DOUBLE)l;
        if (l) {
            ST0->Tag = TAG_VALID;
        } else {
            ST0->Tag = TAG_ZERO;
        }
    }
}

FRAG1(FILD64, LONGLONG) // FILD m64int
{
    PFPREG ST0;
    FpArithDataPreamble(cpu, pop1);

    cpu->FpStatusC1 = 0;        // assume no error
    PUSHFLT(ST0);
    if (ST0->Tag != TAG_EMPTY) {
        HandleStackFull(cpu, ST0);
    } else {
        LONGLONG ll;

        ll = *(UNALIGNED LONGLONG *)pop1;
        ST0->r64 = (DOUBLE)ll;
        if (ll) {
            ST0->Tag = TAG_VALID;
        } else {
            ST0->Tag = TAG_ZERO;
        }
    }
}


FRAG1(FLD32, FLOAT)       // FLD m32real
{
    PFPREG ST0;
    FpArithDataPreamble(cpu, pop1);

    cpu->FpStatusC1 = 0;        // assume no error
    PUSHFLT(ST0);
    if (ST0->Tag != TAG_EMPTY) {
        HandleStackFull(cpu, ST0);
    } else {
        GetIntelR4(ST0, pop1);
        if (ST0->Tag == TAG_SPECIAL) {
            if (ST0->TagSpecial == TAG_SPECIAL_DENORM) {
                if (!(cpu->FpControlMask & FPCONTROL_DM)) {
                    cpu->FpStatusES = 1;    // Unmasked exception
                    //
                    // Instruction needs to be aborted due to unmasked
                    // exception.  We've already hosed ST0, so "correct"
                    // it by popping the FP stack.  Note that
                    // the contents of the register have been lost, which
                    // is a compatibility break with Intel.
                    //
                    POPFLT;
                }
                cpu->FpStatusExceptions |= FPCONTROL_DM;
            } else if (ST0->TagSpecial == TAG_SPECIAL_SNAN) {
                if (HandleSnan(cpu, ST0)) {
                    //
                    // Instruction needs to be aborted due to unmasked
                    // exception.  We've already hosed ST0, so "correct"
                    // it by popping the FP stack.  Note that
                    // the contents of the register have been lost, which
                    // is a compatibility break with Intel.
                    //
                    POPFLT;
                }
            }
        }
    }
}

FRAG1(FLD64, DOUBLE)      // FLD m64real
{
    PFPREG ST0;
    FpArithDataPreamble(cpu, pop1);

    cpu->FpStatusC1 = 0;        // assume no error
    PUSHFLT(ST0);
    if (ST0->Tag != TAG_EMPTY) {
        HandleStackFull(cpu, ST0);
    } else {
        GetIntelR8(ST0, pop1);
        if (ST0->Tag == TAG_SPECIAL) {
            if (ST0->TagSpecial == TAG_SPECIAL_DENORM) {
                if (!(cpu->FpControlMask & FPCONTROL_DM)) {
                    cpu->FpStatusES = 1;    // Unmasked exception
                    //
                    // Instruction needs to be aborted due to unmasked
                    // exception.  We've already hosed ST0, so "correct"
                    // it by popping the FP stack.  Note that
                    // the contents of the register have been lost, which
                    // is a compatibility break with Intel.
                    //
                    POPFLT;
                }
                cpu->FpStatusExceptions |= FPCONTROL_DM;
            } else if (ST0->TagSpecial == TAG_SPECIAL_SNAN) {
                if (HandleSnan(cpu, ST0)) {
                    //
                    // Instruction needs to be aborted due to unmasked
                    // exception.  We've already hosed ST0, so "correct"
                    // it by popping the FP stack.  Note that
                    // the contents of the register have been lost, which
                    // is a compatibility break with Intel.
                    //
                    POPFLT;
                }
            }
        }
    }
}

FRAG0(FLD1)
{
    PFPREG ST0;
    FpArithPreamble(cpu);

    cpu->FpStatusC1 = 0;        // assume no error
    PUSHFLT(ST0);
    if (ST0->Tag != TAG_EMPTY) {
        HandleStackFull(cpu, ST0);
    } else {
        ST0->r64 = 1.0;
        ST0->Tag = TAG_VALID;
    }
}

FRAG0(FLDL2T)
{
    PFPREG ST0;
    FpArithPreamble(cpu);

    cpu->FpStatusC1 = 0;        // assume no error
    PUSHFLT(ST0);
    if (ST0->Tag != TAG_EMPTY) {
        HandleStackFull(cpu, ST0);
    } else {
        ST0->r64 = 2.3025850929940456840E0 / 6.9314718055994530942E-1;  //log2(10) = ln10/ln2
        ST0->Tag = TAG_VALID;
    }
}

FRAG0(FLDL2E)
{
    PFPREG ST0;
    FpArithPreamble(cpu);

    cpu->FpStatusC1 = 0;        // assume no error
    PUSHFLT(ST0);
    if (ST0->Tag != TAG_EMPTY) {
        HandleStackFull(cpu, ST0);
    } else {
        ST0->r64 = 1.4426950408889634074E0;
        ST0->Tag = TAG_VALID;
    }
}

FRAG0(FLDPI)
{
    PFPREG ST0;
    FpArithPreamble(cpu);

    cpu->FpStatusC1 = 0;        // assume no error
    PUSHFLT(ST0);
    if (ST0->Tag != TAG_EMPTY) {
        HandleStackFull(cpu, ST0);
    } else {
        ST0->r64 = 3.14159265358979323846;
        ST0->Tag = TAG_VALID;
    }
}

FRAG0(FLDLG2)
{
    PFPREG ST0;
    FpArithPreamble(cpu);

    cpu->FpStatusC1 = 0;        // assume no error
    PUSHFLT(ST0);
    if (ST0->Tag != TAG_EMPTY) {
        HandleStackFull(cpu, ST0);
    } else {
        ST0->r64 = 6.9314718055994530942E-1 / 2.3025850929940456840E0;
        ST0->Tag = TAG_VALID;
    }
}

FRAG0(FLDLN2)
{
    PFPREG ST0;
    FpArithPreamble(cpu);

    cpu->FpStatusC1 = 0;        // assume no error
    PUSHFLT(ST0);
    if (ST0->Tag != TAG_EMPTY) {
        HandleStackFull(cpu, ST0);
    } else {
        ST0->r64 = 6.9314718055994530942E-1;
        ST0->Tag = TAG_VALID;
    }
}


FRAG1IMM(FLD_STi, INT)
{
    PFPREG ST0;
    PFPREG STi;

    FpArithPreamble(cpu);

    cpu->FpStatusC1 = 0;        // assume no error
    STi = &cpu->FpStack[ST(op1)];
    PUSHFLT(ST0);
    if (ST0->Tag != TAG_EMPTY) {
        HandleStackFull(cpu, ST0);
    } else {
        ST0->r64 = STi->r64;
        ST0->Tag = STi->Tag;
        ST0->TagSpecial = STi->TagSpecial;
    }
}

FRAG0(FLDZ)
{
    PFPREG ST0;
    FpArithPreamble(cpu);

    cpu->FpStatusC1 = 0;        // assume no error
    PUSHFLT(ST0);
    if (ST0->Tag != TAG_EMPTY) {
        HandleStackFull(cpu, ST0);
    } else {
        ST0->r64 = 0.0;
        ST0->Tag = TAG_ZERO;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\frag32.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    frag32.c

Abstract:
    
    Instuction fragments which operate on 32-bit DWORDS, shared with CCPU

Author:

    12-Jun-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "fragp.h"
#include "frag32.h"
#include "optfrag.h"

// set up to include common functions
#define MSB		    0x80000000
#define LMB                 31  // Left Most Bit
#define UTYPE		    unsigned long
#define STYPE		    signed long
#define GET_VAL 	    GET_LONG
#define PUT_VAL 	    PUT_LONG
#define PUSH_VAL	    PUSH_LONG
#define POP_VAL 	    POP_LONG
#define FRAGCOMMON0(fn)     FRAG0(fn ## 32)
#define FRAGCOMMON1(fn)     FRAG1(fn ## 32, UTYPE)
#define FRAGCOMMON1IMM(fn)  FRAG1IMM( fn ## 32, UTYPE)
#define FRAGCOMMON2(fn)     FRAG2(fn ## 32, UTYPE)
#define FRAGCOMMON2IMM(fn)  FRAG2IMM( fn ## 32, UTYPE, UTYPE)
#define FRAGCOMMON2REF(fn)  FRAG2REF(fn ## 32, UTYPE)
#define FRAGCOMMON3(fn)     FRAG3(fn ## 32, UTYPE, UTYPE, UTYPE)
#define AREG                eax
#define BREG		    ebx
#define CREG		    ecx
#define DREG		    edx
#define SPREG		    esp
#define BPREG		    ebp
#define SIREG		    esi
#define DIREG		    edi
#define SET_FLAGS_ADD       SET_FLAGS_ADD32
#define SET_FLAGS_SUB       SET_FLAGS_SUB32
#define SET_FLAGS_INC       SET_FLAGS_INC32
#define SET_FLAGS_DEC       SET_FLAGS_DEC32
#define GET_BYTE(addr)      (*(UNALIGNED unsigned char *)(addr))
#define GET_SHORT(addr)     (*(UNALIGNED unsigned short *)(addr))
#define GET_LONG(addr)      (*(UNALIGNED unsigned long *)(addr))

#define PUT_BYTE(addr,dw)   {GET_BYTE(addr)=dw;}
#define PUT_SHORT(addr,dw)  {GET_SHORT(addr)=dw;}
#define PUT_LONG(addr,dw)   {GET_LONG(addr)=dw;}

// include the common functions with 8/16/32 flavors
#include "shared.c"

// include the common functions with 16/32 flavors
#include "shr1632.c"

// include the common unaligned functions with 8/16/32 flavors
#include "shareda.c"

// include the common unaligned functions with 16/32 flavors
#include "shr1632a.c"

#undef FRAGCOMMON0
#undef FRAGCOMMON1
#undef FRAGCOMMON1IMM
#undef FRAGCOMMON2
#undef FRAGCOMMON2IMM
#undef FRAGCOMMON2REF
#undef FRAGCOMMON3
#undef GET_BYTE
#undef GET_SHORT
#undef GET_LONG

#if MSCPU
#define FRAGCOMMON0(fn)     FRAG0(fn ## 32A)
#define FRAGCOMMON1(fn)     FRAG1(fn ## 32A,UTYPE)
#define FRAGCOMMON1IMM(fn)  FRAG1IMM( fn ## 32A, UTYPE)
#define FRAGCOMMON2(fn)     FRAG2(fn ## 32A, UTYPE)
#define FRAGCOMMON2IMM(fn)  FRAG2IMM( fn ## 32A, UTYPE, UTYPE)
#define FRAGCOMMON2REF(fn)  FRAG2REF(fn ## 32A, UTYPE)
#define FRAGCOMMON3(fn)     FRAG3(fn ## 32A, UTYPE, UTYPE, UTYPE)
#define GET_BYTE(addr)      (*(unsigned char *)(addr))
#define GET_SHORT(addr)     (*(unsigned short *)(addr))
#define GET_LONG(addr)      (*(unsigned long *)(addr))

// include the common aligned functions with 8/16/32 flavors
#include "shareda.c"

// include the common aligned functions with 16/32 flavors
#include "shr1632a.c"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\frag32.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    frag32.h

Abstract:
    
    Prototypes for instruction fragments which operate on 32-bit DWORDS.

Author:

    12-Jun-1995 BarryBo, Created

Revision History:

--*/

#ifndef FRAG32_H
#define FRAG32_H

#define FRAGCOMMON0(fn)     FRAG0(fn ## 32)
#define FRAGCOMMON1(fn)     FRAG1(fn ## 32, DWORD)
#define FRAGCOMMON1IMM(fn)  FRAG1IMM( fn ## 32, DWORD)
#define FRAGCOMMON2IMM(fn)  FRAG2IMM( fn ## 32, DWORD, DWORD)
#define FRAGCOMMON2(fn)     FRAG2(fn ## 32, DWORD)
#define FRAGCOMMON2REF(fn)  FRAG2REF(fn ## 32, DWORD)
#define FRAGCOMMON3(fn)     FRAG3(fn ## 32, DWORD, DWORD, DWORD)
#include "shared.h"
#include "shr1632.h"
#include "shareda.h"
#include "shr1632a.h"
#undef FRAGCOMMON0
#undef FRAGCOMMON1
#undef FRAGCOMMON1IMM
#undef FRAGCOMMON2IMM
#undef FRAGCOMMON2
#undef FRAGCOMMON2REF
#undef FRAGCOMMON3
#define FRAGCOMMON0(fn)     FRAG0(fn ## 32A)
#define FRAGCOMMON1(fn)     FRAG1(fn ## 32A, DWORD)
#define FRAGCOMMON1IMM(fn)  FRAG1IMM( fn ## 32A, DWORD)
#define FRAGCOMMON2IMM(fn)  FRAG2IMM( fn ## 32A, DWORD, DWORD)
#define FRAGCOMMON2(fn)     FRAG2(fn ## 32A, DWORD)
#define FRAGCOMMON2REF(fn)  FRAG2REF(fn ## 32A, DWORD)
#define FRAGCOMMON3(fn)     FRAG3(fn ## 32A, DWORD, DWORD, DWORD)
#include "shareda.h"
#include "shr1632a.h"
#undef FRAGCOMMON0
#undef FRAGCOMMON1
#undef FRAGCOMMON1IMM
#undef FRAGCOMMON2IMM
#undef FRAGCOMMON2
#undef FRAGCOMMON2REF
#undef FRAGCOMMON3

#endif //FRAG32_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\frag16.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    frag16.c

Abstract:
    
    Instuction fragments which operate on 16-bit WORDS

Author:

    12-Jun-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "fragp.h"
#include "frag16.h"

// set up to include common functions
#define MSB		    0x8000
#define LMB                 15  // Left Most Bit
#define UTYPE		    unsigned short
#define STYPE		    signed short
#define GET_VAL 	    GET_SHORT
#define PUT_VAL 	    PUT_SHORT
#define PUSH_VAL	    PUSH_SHORT
#define POP_VAL 	    POP_SHORT
#define FRAGCOMMON0(fn)     FRAG0(fn ## 16)
#define FRAGCOMMON1(fn)     FRAG1(fn ## 16,UTYPE)
#define FRAGCOMMON1IMM(fn)  FRAG1IMM( fn ## 16, UTYPE)
#define FRAGCOMMON2(fn)     FRAG2(fn ## 16, UTYPE)
#define FRAGCOMMON2IMM(fn)  FRAG2IMM( fn ## 16, UTYPE, UTYPE)
#define FRAGCOMMON2REF(fn)  FRAG2REF(fn ## 16, UTYPE)
#define FRAGCOMMON3(fn)     FRAG3(fn ## 16, UTYPE, UTYPE, UTYPE)
#define AREG                ax
#define BREG		    bx
#define CREG		    cx
#define DREG		    dx
#define SPREG		    sp
#define BPREG		    bp
#define SIREG		    si
#define DIREG		    di
#define SET_FLAGS_ADD       SET_FLAGS_ADD16
#define SET_FLAGS_SUB       SET_FLAGS_SUB16
#define SET_FLAGS_INC       SET_FLAGS_INC16
#define SET_FLAGS_DEC       SET_FLAGS_DEC16
#define GET_BYTE(addr)      (*(UNALIGNED unsigned char *)(addr))
#define GET_SHORT(addr)     (*(UNALIGNED unsigned short *)(addr))
#define GET_LONG(addr)      (*(UNALIGNED unsigned long *)(addr))

#undef PUT_BYTE
#undef PUT_SHORT
#undef PUT_LONG

#define PUT_BYTE(addr,dw)   {GET_BYTE(addr)=(unsigned char)dw;}
#define PUT_SHORT(addr,dw)  {GET_SHORT(addr)=(unsigned short)dw;}
#define PUT_LONG(addr,dw)   {GET_LONG(addr)=(unsigned long)dw;}

// include the common functions with 8/16/32 flavors, with no alignment issues
#include "shared.c"

// include the common functions with 16/32 flavors, with no alignment issues
#include "shr1632.c"

// include the common unaligned functions with 8/16/32 flavors
#include "shareda.c"

// include the common unaligned functions with 16/32 flavors
#include "shr1632a.c"

#undef FRAGCOMMON0
#undef FRAGCOMMON1
#undef FRAGCOMMON1IMM
#undef FRAGCOMMON2
#undef FRAGCOMMON2IMM
#undef FRAGCOMMON2REF
#undef FRAGCOMMON3
#undef GET_BYTE
#undef GET_SHORT
#undef GET_LONG

#if MSCPU
#define FRAGCOMMON0(fn)     FRAG0(fn ## 16A)
#define FRAGCOMMON1(fn)     FRAG1(fn ## 16A,UTYPE)
#define FRAGCOMMON1IMM(fn)  FRAG1IMM( fn ## 16A, UTYPE)
#define FRAGCOMMON2(fn)     FRAG2(fn ## 16A, UTYPE)
#define FRAGCOMMON2IMM(fn)  FRAG2IMM( fn ## 16A, UTYPE, UTYPE)
#define FRAGCOMMON2REF(fn)  FRAG2REF(fn ## 16A, UTYPE)
#define FRAGCOMMON3(fn)     FRAG3(fn ## 16A, UTYPE, UTYPE, UTYPE)
#define GET_BYTE(addr)      (*(unsigned char *)(addr))
#define GET_SHORT(addr)     (*(unsigned short *)(addr))
#define GET_LONG(addr)      (*(unsigned long *)(addr))

// include the common aligned functions with 8/16/32 flavors
#include "shareda.c"

// include the common aligned functions with 16/32 flavors
#include "shr1632a.c"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\fpustore.c ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    fpustore.c

Abstract:

    Floating point store functions

Author:

    04-Oct-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <float.h>
#include <math.h>
#include <stdio.h>
#include "wx86.h"
#include "cpuassrt.h"
#include "fragp.h"
#include "fpufragp.h"
#include "fpuarith.h"

ASSERTNAME;

//
// Forward declarations
//

__int64 CastDoubleToInt64(double d);    // in alpha\fphelp.s


#if !NATIVE_NAN_IS_INTEL_FORMAT

//
// Forward declarations
//
NPXPUTINTELR4(PutIntelR4_VALID);
NPXPUTINTELR4(PutIntelR4_ZERO);
NPXPUTINTELR4(PutIntelR4_SPECIAL);
NPXPUTINTELR4(PutIntelR4_EMPTY);
NPXPUTINTELR8(PutIntelR8_VALID);
NPXPUTINTELR8(PutIntelR8_ZERO);
NPXPUTINTELR8(PutIntelR8_SPECIAL);
NPXPUTINTELR8(PutIntelR8_EMPTY);

//
// Jump tables
//
const NpxPutIntelR4 PutIntelR4Table[TAG_MAX] = {
    PutIntelR4_VALID,
    PutIntelR4_ZERO,
    PutIntelR4_SPECIAL,
    PutIntelR4_EMPTY
    };

const NpxPutIntelR8 PutIntelR8Table[TAG_MAX] = {
    PutIntelR8_VALID,
    PutIntelR8_ZERO,
    PutIntelR8_SPECIAL,
    PutIntelR8_EMPTY
    };



NPXPUTINTELR4(PutIntelR4_VALID)
{
    FLOAT f = (FLOAT)Fp->r64;
    PUT_LONG(pIntelReal, *(DWORD *)&f);
}

NPXPUTINTELR4(PutIntelR4_ZERO)
{
    //
    // This cannot simply write a constant 0.0 to memory as it must
    // copy the correct sign from the 0.0 in the FP register.
    //
    PUT_LONG(pIntelReal, Fp->rdw[1]);
}

NPXPUTINTELR4(PutIntelR4_SPECIAL)
{
    switch (Fp->TagSpecial) {
    default:
        CPUASSERT(FALSE);    // unknown tag - fall into TAG_INDEF

    case TAG_SPECIAL_INFINITY:
    case TAG_SPECIAL_DENORM:
        PutIntelR4_VALID(pIntelReal, Fp);
        break;

    case TAG_SPECIAL_INDEF:
        // Write out the R4 indefinite bit pattern
        PUT_LONG(pIntelReal, 0xffc00000);
        break;

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_SNAN: {
        DWORD d[2];
        FLOAT f;
        //
        // Truncate the R8 to an R4, and toggle the top bit of the mantissa
        // to form an Intel QNAN/SNAN (which is different than a native
        // QNAN/SNAN).
        //
        d[0] = Fp->rdw[0];
        d[1] = Fp->rdw[1] ^ 0x00400000;
        f = *(FLOAT *)d;
        PUT_LONG(pIntelReal, *(DWORD *)&f);
        }
        break;
    }
}

NPXPUTINTELR4(PutIntelR4_EMPTY)
{
    //
    // It is assumed that callers of PutIntelR4() have already handled
    // TAG_EMPTY by raising an exception or converting it to TAG_INDEF.
    //
    CPUASSERT(FALSE);
}



NPXPUTINTELR8(PutIntelR8_VALID)
{
    *(UNALIGNED DOUBLE *)pIntelReal = Fp->r64;
}

NPXPUTINTELR8(PutIntelR8_ZERO)
{
    //
    // This cannot simply write a constant 0.0 to memory as it must
    // copy the correct sign from the 0.0 in the FP register.
    //
    *(UNALIGNED DOUBLE *)pIntelReal = Fp->r64;
}

NPXPUTINTELR8(PutIntelR8_SPECIAL)
{
    DWORD *pdw = (DWORD *)pIntelReal;

    switch (Fp->TagSpecial) {
    default:
        CPUASSERT(FALSE);    // unknown tag - fall into TAG_INDEF

    case TAG_SPECIAL_DENORM:
    case TAG_SPECIAL_INFINITY:
        // Both can be done as a simple R8-toR8 copy
        PutIntelR8_VALID(pIntelReal, Fp);
        break;

    case TAG_SPECIAL_INDEF:
        // Write out an Intel Indefinite
        PUT_LONG(pdw, 0);
        PUT_LONG((pdw+1), 0xfff80000);
        break;

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_SNAN:
        //
        // Toggle the top bit of the mantissa to form an Intel QNAN/SNAN
        // (which is different than a native QNAN/SNAN).
        //
        PUT_LONG(pdw, Fp->rdw[0]);
        PUT_LONG((pdw+1), Fp->rdw[1] ^ 0x00080000);
        break;
    }
}

NPXPUTINTELR8(PutIntelR8_EMPTY)
{
    //
    // It is assumed that callers of PutIntelR8() have already handled
    // TAG_EMPTY by raising an exception or converting it to TAG_INDEF.
    //
    CPUASSERT(FALSE);
}

#endif //!NATIVE_NAN_IS_INTEL_FORMAT



FRAG1(FIST16, SHORT)     // FIST m16int
{
    PFPREG ST0 = cpu->FpST0;
    __int64 i64;
    int Exponent;
    SHORT i16;

    FpArithDataPreamble(cpu, pop1);

    switch (ST0->Tag) {
    case TAG_VALID:
        Exponent = (int)((ST0->rdw[1] >> 20) & 0x7ff) - 1023;
        //
        if (Exponent >= 64) {
            //
            // Exponent is too big - this cannot be converted to an __int64
            // Raise I exception on overflow, or write 0x8000 for masked
            // exception.
            //
IntOverflow:
            if (HandleInvalidOp(cpu)) {
                return;
            }
            PUT_SHORT(pop1, 0x8000);
        } else {
            i64 = CastDoubleToInt64(ST0->r64);
            i16 = (SHORT)i64;
            if ((__int64)i16 != i64) {
                goto IntOverflow;
            }
            PUT_SHORT(pop1, i16);
        }
        break;

    case TAG_ZERO:
        PUT_SHORT(pop1, 0);
        break;

    case TAG_SPECIAL:
        if (ST0->TagSpecial == TAG_SPECIAL_DENORM) {
            i64 = CastDoubleToInt64(ST0->r64);
            PUT_SHORT(pop1, (SHORT)i64);
        } else if (!HandleInvalidOp(cpu)) {
            // INFINITY and NANs are all invalid operations, and the masked
            // behavior is to write 0x8000
            PUT_SHORT(pop1, 0x8000);
        }
        break;

    case TAG_EMPTY:
        if (!HandleStackEmpty(cpu, ST0)) {
            PUT_SHORT(pop1, 0x8000);
        }
        break;
    }
}

FRAG1(FISTP16, SHORT)    // FISTP m16int
{
    PFPREG ST0 = cpu->FpST0;
    __int64 i64;
    int Exponent;
    SHORT i16;

    FpArithDataPreamble(cpu, pop1);

    switch (ST0->Tag) {
    case TAG_VALID:
        Exponent = (int)((ST0->rdw[1] >> 20) & 0x7ff) - 1023;
        if (Exponent >= 64) {
            //
            // Exponent is too big - this cannot be converted to an __int64
            // Raise I exception on overflow, or write 0x8000 for masked
            // exception.
            //
IntOverflow:
            if (HandleInvalidOp(cpu)) {
                return;
            }
            PUT_SHORT(pop1, 0x8000);
        } else {
            i64 = CastDoubleToInt64(ST0->r64);
            i16 = (SHORT)i64;
            if ((__int64)i16 != i64) {
                goto IntOverflow;
            }
            PUT_SHORT(pop1, i16);
        }
        POPFLT;
        break;

    case TAG_ZERO:
        PUT_SHORT(pop1, 0);
        break;

    case TAG_SPECIAL:
        if (ST0->TagSpecial == TAG_SPECIAL_DENORM) {
            i64 = CastDoubleToInt64(ST0->r64);
            PUT_SHORT(pop1, (SHORT)i64);
        } else if (!HandleInvalidOp(cpu)) {
            // INFINITY and NANs are all invalid operations, and the masked
            // behavior is to write 0x8000
            PUT_SHORT(pop1, 0x8000);
        }
        POPFLT;
        break;

    case TAG_EMPTY:
        if (!HandleStackEmpty(cpu, ST0)) {
            PUT_SHORT(pop1, 0x8000);
            POPFLT;
        }
        break;
    }
}


FRAG1(FIST32, LONG)      // FIST m32int
{
    PFPREG ST0 = cpu->FpST0;
    __int64 i64;
    int Exponent;
    LONG i32;

    FpArithDataPreamble(cpu, pop1);

    switch (ST0->Tag) {
    case TAG_VALID:
        Exponent = (int)((ST0->rdw[1] >> 20) & 0x7ff) - 1023;
        if (Exponent >= 64) {
            //
            // Exponent is too big - this cannot be converted to an __int64
            // Raise I exception on overflow, or write 0x80000000 for masked
            // exception.
            //
IntOverflow:
            if (HandleInvalidOp(cpu)) {
                return;
            }
            PUT_LONG(pop1, 0x80000000);
        } else {
            i64 = CastDoubleToInt64(ST0->r64);
            i32 = (LONG)i64;
            if ((__int64)i32 != i64) {
                goto IntOverflow;
            }
            PUT_LONG(pop1, i32);
        }
        break;

    case TAG_ZERO:
        PUT_LONG(pop1, 0);
        break;

    case TAG_SPECIAL:
        if (ST0->TagSpecial == TAG_SPECIAL_DENORM) {
            i64 = CastDoubleToInt64(ST0->r64);
            PUT_LONG(pop1, (LONG)i64);
        } else if (!HandleInvalidOp(cpu)) {
            // INFINITY and NANs are all invalid operations, and the masked
            // behavior is to write 0x80000000
            PUT_LONG(pop1, 0x80000000);
        }
        break;

    case TAG_EMPTY:
        if (!HandleStackEmpty(cpu, ST0)) {
            PUT_LONG(pop1, 0x80000000);
            POPFLT;
        }
        break;
    }
}

FRAG1(FISTP32, LONG)     // FISTP m32int
{
    PFPREG ST0 = cpu->FpST0;
    __int64 i64;
    int Exponent;
    LONG i32;

    FpArithDataPreamble(cpu, pop1);

    switch (ST0->Tag) {
    case TAG_VALID:
        Exponent = (int)((ST0->rdw[1] >> 20) & 0x7ff) - 1023;
        if (Exponent >= 64) {
            //
            // Exponent is too big - this cannot be converted to an __int64
            // Raise I exception on overflow, or write 0x80000000 for masked
            // exception.
            //
IntOverflow:
            if (HandleInvalidOp(cpu)) {
                return;
            }
            PUT_LONG(pop1, 0x80000000);
        } else {
            i64 = CastDoubleToInt64(ST0->r64);
            i32 = (LONG)i64;
            if ((__int64)i32 != i64) {
                goto IntOverflow;
            }
            PUT_LONG(pop1, i32);
        }
        POPFLT;
        break;

    case TAG_ZERO:
        PUT_LONG(pop1, 0);
        POPFLT;
        break;

    case TAG_SPECIAL:
        if (ST0->TagSpecial == TAG_SPECIAL_DENORM) {
            i64 = CastDoubleToInt64(ST0->r64);
            PUT_LONG(pop1, (LONG)i64);
        } else if (!HandleInvalidOp(cpu)) {
            // INFINITY and NANs are all invalid operations, and the masked
            // behavior is to write 0x80000000
            PUT_LONG(pop1, 0x80000000);
        }
        POPFLT;
        break;

    case TAG_EMPTY:
        if (!HandleStackEmpty(cpu, ST0)) {
            PUT_LONG(pop1, 0x80000000);
            POPFLT;
        }
        break;
    }
}


FRAG1(FISTP64, LONGLONG) // FISTP m64int
{
    PFPREG ST0 = cpu->FpST0;
    __int64 i64;
    int Exponent;

    FpArithDataPreamble(cpu, pop1);

    switch (ST0->Tag) {
    case TAG_VALID:
        Exponent = (int)((ST0->rdw[1] >> 20) & 0x7ff) - 1023;
        if (Exponent >= 64) {
            //
            // Exponent is too big - this cannot be converted to an __int64,
            // Raise I exception on overflow, or write 0x800...0 for masked
            // exception
            //
            if (HandleInvalidOp(cpu)) {
                return;
            }
            i64 = (__int64)0x8000000000000000i64;
        } else {
            i64 = CastDoubleToInt64(ST0->r64);
        }
        *(UNALIGNED LONGLONG *)pop1 = (LONGLONG)i64;
        POPFLT;
        break;

    case TAG_ZERO:
        *(UNALIGNED LONGLONG *)pop1 = 0;
        POPFLT;
        break;

    case TAG_SPECIAL:
        if (ST0->TagSpecial == TAG_SPECIAL_DENORM) {
            i64 = CastDoubleToInt64(ST0->r64);
            *(UNALIGNED LONGLONG *)pop1 = (LONGLONG)i64;
        } else if (!HandleInvalidOp(cpu)) {
            DWORD *pdw = (DWORD *)pop1;

            // INFINITY and NANs are all invalid operations, and the masked
            // behavior is to write 0x80000000
            PUT_LONG(pdw,   0x00000000);
            PUT_LONG((pdw+1), 0x80000000);
        }
        POPFLT;
        break;

    case TAG_EMPTY:
        if (!HandleStackEmpty(cpu, ST0)) {
            DWORD *pdw = (DWORD *)pop1;

            PUT_LONG(pdw,   0x00000000);
            PUT_LONG((pdw+1), 0x80000000);
            POPFLT;
        }
        break;
    }
}

FRAG1(FST32, FLOAT)       // FST m32real
{
    FpArithDataPreamble(cpu, pop1);

    if (cpu->FpST0->Tag == TAG_EMPTY) {
        if (HandleStackEmpty(cpu, cpu->FpST0)) {
            // unmasked exception - abort the instruction
            return;
        }
    }
    PutIntelR4(pop1, cpu->FpST0);
}

FRAG1(FSTP32, FLOAT)      // FSTP m32real
{
    FpArithDataPreamble(cpu, pop1);

    if (cpu->FpST0->Tag == TAG_EMPTY) {
        if (HandleStackEmpty(cpu, cpu->FpST0)) {
            // unmasked exception - abort the instruction
            return;
        }
    }
    PutIntelR4(pop1, cpu->FpST0);
    POPFLT;
}

FRAG1(FST64, DOUBLE)      // FST m64real
{
    FpArithDataPreamble(cpu, pop1);

    if (cpu->FpST0->Tag == TAG_EMPTY) {
        if (HandleStackEmpty(cpu, cpu->FpST0)) {
            // unmasked exception - abort the instruction
            return;
        }
    }
    PutIntelR8(pop1, cpu->FpST0);
}

FRAG1(FSTP64, DOUBLE)     // FSTP m64real
{
    FpArithDataPreamble(cpu, pop1);

    if (cpu->FpST0->Tag == TAG_EMPTY) {
        if (HandleStackEmpty(cpu, cpu->FpST0)) {
            // unmasked exception - abort the instruction
            return;
        }
    }
    PutIntelR8(pop1, cpu->FpST0);
    POPFLT;
}

FRAG1IMM(FST_STi, INT)      // FST ST(i)
{
    FpArithPreamble(cpu);

    CPUASSERT( (op1 & 0x07) == op1);

    if (cpu->FpST0->Tag == TAG_EMPTY) {
        if (HandleStackEmpty(cpu, cpu->FpST0)) {
            // unmasked exception - abort the instruction
            return;
        }
    }
    cpu->FpStack[ST(op1)] = *cpu->FpST0;
}

FRAG1IMM(FSTP_STi, INT)     // FSTP ST(i)
{
    FpArithPreamble(cpu);

    CPUASSERT( (op1 & 0x07) == op1);

    if (cpu->FpST0->Tag == TAG_EMPTY) {
        if (HandleStackEmpty(cpu, cpu->FpST0)) {
            // unmasked exception - abort the instruction
            return;
        }
    }
    //CONSIDER: According to TimP, FSTP ST(0) is commonly used to pop the
    //          stack.  It may be worthwhile to test if op1==0 and skip the
    //          assignment and go right to the POPFLT.
    cpu->FpStack[ST(op1)] = *cpu->FpST0;
    POPFLT;
}

FRAG0(OPT_FSTP_ST0)     // FSTP ST(0)
{
    FpArithPreamble(cpu);

    if (cpu->FpST0->Tag == TAG_EMPTY) {
        if (HandleStackEmpty(cpu, cpu->FpST0)) {
            // unmasked exception - abort the instruction
            return;
        }
    }
    POPFLT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\frag16.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    frag16.h

Abstract:
    
    Prototypes for instruction fragments which operate on 16-bit WORDS.

Author:

    12-Jun-1995 BarryBo, Created

Revision History:

--*/

#ifndef FRAG16_H
#define FRAG16_H

#define FRAGCOMMON0(fn)     FRAG0( fn ## 16)
#define FRAGCOMMON1(fn)     FRAG1( fn ## 16, USHORT)
#define FRAGCOMMON1IMM(fn)  FRAG1IMM( fn ## 16, USHORT)
#define FRAGCOMMON2IMM(fn)  FRAG2IMM( fn ## 16, USHORT, USHORT)
#define FRAGCOMMON2(fn)     FRAG2( fn ## 16, USHORT)
#define FRAGCOMMON2REF(fn)  FRAG2REF( fn ## 16, USHORT)
#define FRAGCOMMON3(fn)     FRAG3(fn ## 16, USHORT, USHORT, USHORT)
#include "shared.h"
#include "shr1632.h"
#include "shareda.h"
#include "shr1632a.h"
#undef FRAGCOMMON0
#undef FRAGCOMMON1
#undef FRAGCOMMON1IMM
#undef FRAGCOMMON2IMM
#undef FRAGCOMMON2
#undef FRAGCOMMON2REF
#undef FRAGCOMMON3
#define FRAGCOMMON0(fn)     FRAG0( fn ## 16A)
#define FRAGCOMMON1(fn)     FRAG1( fn ## 16A, USHORT)
#define FRAGCOMMON1IMM(fn)  FRAG1IMM( fn ## 16A, USHORT)
#define FRAGCOMMON2IMM(fn)  FRAG2IMM( fn ## 16A, USHORT, USHORT)
#define FRAGCOMMON2(fn)     FRAG2( fn ## 16A, USHORT)
#define FRAGCOMMON2REF(fn)  FRAG2REF( fn ## 16A, USHORT)
#define FRAGCOMMON3(fn)     FRAG3(fn ## 16A, USHORT, USHORT, USHORT)
#include "shareda.h"
#include "shr1632a.h"
#undef FRAGCOMMON0
#undef FRAGCOMMON1
#undef FRAGCOMMON1IMM
#undef FRAGCOMMON2IMM
#undef FRAGCOMMON2
#undef FRAGCOMMON2REF
#undef FRAGCOMMON3

#endif //FRAG16_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\fpur10.c ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    fpur10.c

Abstract:

    Floating point 10-byte real support

Author:

    06-Oct-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <float.h>
#include <math.h>
#include <stdio.h>
#include "wx86.h"
#include "cpuassrt.h"
#include "fragp.h"
#include "fpufragp.h"

ASSERTNAME;

//
// Forward declarations
//
NPXLOADINTELR10TOR8(LoadIntelR10ToR8_VALID);
NPXLOADINTELR10TOR8(LoadIntelR10ToR8_ZERO);
NPXLOADINTELR10TOR8(LoadIntelR10ToR8_SPECIAL);
NPXLOADINTELR10TOR8(LoadIntelR10ToR8_EMPTY);
NPXPUTINTELR10(PutIntelR10_VALID);
NPXPUTINTELR10(PutIntelR10_ZERO);
NPXPUTINTELR10(PutIntelR10_SPECIAL);
NPXPUTINTELR10(PutIntelR10_EMPTY);

//
// Jump tables
//
const NpxLoadIntelR10ToR8 LoadIntelR10ToR8Table[TAG_MAX] = {
    LoadIntelR10ToR8_VALID,
    LoadIntelR10ToR8_ZERO,
    LoadIntelR10ToR8_SPECIAL,
    LoadIntelR10ToR8_EMPTY
};
const NpxPutIntelR10 PutIntelR10Table[TAG_MAX] = {
    PutIntelR10_VALID,
    PutIntelR10_ZERO,
    PutIntelR10_SPECIAL,
    PutIntelR10_EMPTY
};


VOID
ComputeR10Tag(
    USHORT *r10,
    PFPREG FpReg
    )

/*++

Routine Description:

    Computes the TAG value for an R10, classifying it so conversion to R8
    is simpler.

Arguments:

    r10 - pointer to R10 value to classify.
    FpReg - OUT FP register to set Tag and TagSpecial fields in

Return Value:

    Tag value which classifies the R10.

--*/

{
    USHORT Exponent;

    /* On average, the value will be zero or a valid real, so those cases
     * have the fastest code paths.  NANs tend to be less frequent and are
     * slower to calculate.
     */
    Exponent = r10[4] & 0x7fff;
    if (Exponent == 0x7fff) {

        // exponent is all 1's - NAN or INFINITY of some sort
        FpReg->Tag = TAG_SPECIAL;

        if (r10[0] == 0 && r10[1] == 0 && r10[2] == 0) {
            // Low 6 bytes of mantissa are 0.

            if (r10[3] & 0x4000) {
                // 2nd bit of mantissa set - INDEF or QNAN
                if (r10[3] == 0xc000 && r10[4] == 0xffff) {
                    // INDEF - negative and only top 2 bits of mantissa set
                    FpReg->TagSpecial = TAG_SPECIAL_INDEF;
                } else {
                    // QNAN - positive or more than 2 top bits set
                    FpReg->TagSpecial = TAG_SPECIAL_QNAN;
                }
            } else if (r10[3] & 0x3fff) {
                // SNAN - Only top 1 bit of mantissa is set
                FpReg->TagSpecial = TAG_SPECIAL_SNAN;
            } else {
                FpReg->TagSpecial = TAG_SPECIAL_INFINITY;
            }
        } else {
            // Some bit is set in the low 6 bytes - SNAN or QNAN
            if (r10[3] & 0x4000) {
                // QNAN - Top 2 bits of mantissa set
                FpReg->TagSpecial = TAG_SPECIAL_QNAN;
            } else {
                // SNAN - 2nd bit of mantissa clear
                FpReg->TagSpecial = TAG_SPECIAL_SNAN;
            }
        }
    } else if (Exponent == 0) {
        // exponent is 0 - DENORMAL or ZERO
        if (r10[0] == 0 && r10[1] == 0 && r10[2] == 0 && r10[3] == 0) {
            // mantissa is all zeroes - ZERO
            FpReg->Tag = TAG_ZERO;
        } else {
            FpReg->Tag = TAG_SPECIAL;
            FpReg->TagSpecial = TAG_SPECIAL_DENORM;
        }
    } else {
        // Exponent is not all 1's and not all 0's - a VALID
        FpReg->Tag = TAG_VALID;
    }
}

VOID
ChopR10ToR8(
    PBYTE r10,
    PFPREG FpReg,
    USHORT R10Exponent
)

/*++

Routine Description:

    Chops a 10-byte real to fit into an FPREG's r64 field.  The FPREG's Tag
    value is not set.

Arguments:

    r10     - 10-byte real to load
    FpReg   - Destination FP register
    R10Exponent - Biased exponent from the R10 value

Return Value:

    None

--*/

{
    short Exponent;
    PBYTE r8 = (PBYTE)&FpReg->r64;

    if (FpReg->Tag == TAG_SPECIAL && FpReg->TagSpecial != TAG_SPECIAL_DENORM) {

        //
        // The caller must handle all other special values itself.
        //
        CPUASSERT(FpReg->TagSpecial == TAG_SPECIAL_QNAN || FpReg->TagSpecial == TAG_SPECIAL_SNAN);

        //
        // The R10 is a QNAN or an SNAN - ignore its exponent (fifteen 1's)
        // and set Exponent to be the correct number of 1 bits for an R8
        // (11 ones, in the correct location within a SHORT)
        //
        Exponent = (short)0x7ff0;

    } else {

        //
        // The R10 is a valid number.  Convert the R10 exponent to an
        // R8 exponent by changing the bias.
        //
        Exponent = (short)R10Exponent - 16383;
        if (Exponent < -1022) {
            //
            // Exponent is too small - silently convert the R10 to an
            // R8 +/-DBL_MIN
            //
            if (r8[7] & 0x80) {
                FpReg->r64 = -DBL_MIN;
            } else {
                FpReg->r64 = DBL_MIN;
            }
            return;
        } else if (Exponent > 1023) {
            //
            // Exponent is too big - silently convert the R10 to an
            // R8 +/-DBL_MAX
            //
            if (r8[7] & 0x80) {
                FpReg->r64 = -DBL_MAX;
            } else {
                FpReg->r64 = DBL_MAX;
            }
            return;
        }

        //
        // Bias the exponent and shift it to the correct location for an R8
        //
        Exponent = ((USHORT)(Exponent + 1023) & 0x7ff) << 4;
    }

    // Copy in the top 7 bits of the exponent along with the sign bit
    r8[7] = (r10[9] & 0x80) | ((USHORT)Exponent >> 8);

    // Copy in the remaining 4 bits of the exponent, along with bits 1-4 of
    // the R10's mantissa (bit 0 is always 1 in R10s).
    r8[6] = (Exponent & 0xf0) | ((r10[7] >> 3) & 0x0f);

    // Copy bits 6-13 from the R10's mantissa
    r8[5] = (r10[7] << 5) | ((r10[6] >> 3) & 0x1f); // bits 5-12 from the R10
    r8[4] = (r10[6] << 5) | ((r10[5] >> 3) & 0x1f); // bits 14-20 from the R10
    r8[3] = (r10[5] << 5) | ((r10[4] >> 3) & 0x1f); // bits 21-28 from the R10
    r8[2] = (r10[4] << 5) | ((r10[3] >> 3) & 0x1f); // bits 29-36 from the R10
    r8[1] = (r10[3] << 5) | ((r10[2] >> 3) & 0x1f); // bits 37-44 from the R10
    r8[0] = (r10[2] << 5) | ((r10[1] >> 3) & 0x1f); // bits 45-52 from the R10
    //
    // Bits 53-64 from the R10 are ignored.  The caller may examine them
    // and round the resulting R8 accordingly.
    //
}

VOID
NextValue(
    PFPREG Fp,
    BOOLEAN RoundingUp
    )
/*++

Routine Description:

    Replaces a floating-point value with either its higher- or lower-
    valued neighbour.

Arguments:

    Fp          - floating-point value to adjust (tag must be set to one of:
                  TAG_VALID, TAG_ZERO or TAG_SPECIAL/TAG_SPECIAL_DENORM)
    RoundingUp  - TRUE if the next value is to be the higher-valued neighbour.
                  FALSE to return the lower-valued neighbour.

Return Value:

    None.  Value in FP and the Tag may have changed.

--*/
{
    DWORD OldExp;
    DWORD NewExp;
    DWORD Sign;


    if (Fp->Tag == TAG_ZERO) {
        //
        // Neighbour of 0.0 is +/- DBL_MIN.
        //
        Fp->Tag = TAG_VALID;
        if (RoundingUp) {
            Fp->r64 = DBL_MIN;
        } else {
            Fp->r64 = -DBL_MIN;
        }

        return;
    }

    //
    // Remember the original sign and exponent
    //
    Sign =   Fp->rdw[1] & 0x80000000;
    OldExp = Fp->rdw[1] & 0x7ff00000;

    //
    // Treat x as a 64-bit integer then add or subtract 1.
    //
    if ((Sign && RoundingUp) || (!Sign && !RoundingUp)) {
        //
        // x is negative.  Subtract 1.
        //
        Fp->rdw[0]--;
        if (Fp->rdw[0] == 0xffffffff) {
            //
            // need to borrow from the high dword
            //
            Fp->rdw[1]--;
        }
    } else {
        //
        // x is positive.  Add 1.
        //
        Fp->rdw[0]++;
        if (Fp->rdw[0] == 0) {
            //
            // propagate carry to the high dword
            //
            Fp->rdw[1]++;
        }
    }

    //
    // Get the new value of the exponent
    //
    NewExp = Fp->rdw[1] & 0x7ff00000;

    if (NewExp != OldExp) {
        //
        // A borrow or a carry caused the exponent to change.
        //
        if (NewExp == 0x7ff00000) {
            //
            // Got an overflow.  Return the largest double value.
            //
            Fp->Tag = TAG_VALID;
            if (Sign) {
                Fp->r64 = -DBL_MAX;
            } else {
                Fp->r64 = DBL_MAX;
            }
        } else if (OldExp && !NewExp) {
            //
            // The original value was a normal number, but the result is a
            // denormal.  Convert the underflow to a 0 with the correct sign.
            //
            Fp->Tag = TAG_ZERO;
            Fp->rdw[0] = 0;
            Fp->rdw[1] = Sign;
        }
    }
}



NPXLOADINTELR10TOR8(LoadIntelR10ToR8_VALID)
{
    USHORT R10Exponent = (*(USHORT *)&r10[8]) & 0x7fff;

    // Copy the value in, chopping exponent and mantissa to fit
    ChopR10ToR8(r10, Fp, R10Exponent);

    if (r10[0] != 0 || (r10[1]&0x7) != 0) {
        // The value can't fit without rounding.  DO NOT REPORT THIS
        // AS AN OVERFLOW EXCEPTION - THIS ONLY OCCURS BECAUSE THE
        // FPU EMULATOR IS USING R8 ARITHMETIC INTERNALLY.  Because of
        // this, the roundoff should be performed silently.  The default
        // behavior when a masked overflow exception is performed is to
        // store +/-infinity.  We don't want hand-coded R10's loading as
        // infinity as many instructions thow Invalid Operation exceptions
        // when they detect an infinity.

        switch (cpu->FpControlRounding) {
        case 0:     // round to nearest or even
            {
                FPREG a, c;
                double ba, cb;

                a = *Fp;
                NextValue(&a, FALSE);   // a is lower neighbour
                // b = Fp->r64.
                c = *Fp;
                NextValue(&c, TRUE);    // c is higher neighbour
                ba = Fp->r64 - a.r64;
                cb = c.r64 - Fp->r64;

                if (ba == cb) {
                    // a and c are equally close to b - select the even
                    // number (LSB==0)
                    if ( ((*(PBYTE)&a) & 1) == 0) {
                        *Fp = a;
                    } else {
                        *Fp = c;
                    }
                } else if (ba < cb) {
                    // a is closer to b than c is.  Choose a
                    *Fp = a;
                } else {
                    // c is closer to b than a is.  Choose c
                    *Fp = c;
                }
            }
            break;

        case 1:     // round down (towards -infinity)
            NextValue(Fp, FALSE);
            break;

        case 2:     // round up (towards +infinity)
            NextValue(Fp, TRUE);
            break;

        case 3:     // chop (truncate toward zero)
            if (Fp->rdw[0] == 0 && (Fp->rdw[1] & 0x7fffffff) == 0) {
                //
                // Truncated value is 0.0.  Reclassify.
                //
                Fp->Tag = TAG_ZERO;
            }
            break;
        }
    }
}

NPXLOADINTELR10TOR8(LoadIntelR10ToR8_ZERO)
{
    // write in zeroes
    Fp->r64 = 0.0;

    // copy in the sign bit
    Fp->rb[7] = r10[9] & 0x80;
}

NPXLOADINTELR10TOR8(LoadIntelR10ToR8_SPECIAL)
{
    switch (Fp->TagSpecial) {
    case TAG_SPECIAL_INFINITY:
        Fp->rdw[0] = 0;          // low 32 bits of mantissa are zero
        Fp->rdw[1] = 0x7ff00000; // mantissa=0, exponent=1s
        Fp->rb[7] |= r10[9] & 0x80; // copy in the sign bit
        break;

    case TAG_SPECIAL_INDEF:
#if NATIVE_NAN_IS_INTEL_FORMAT
        Fp->rdw[0] = 0;
        Fp->rdw[1] = 0xfff80000;
#else
        Fp->rdw[0] = 0xffffffff;
        Fp->rdw[1] = 0x7ff7ffff;
#endif
        break;

    case TAG_SPECIAL_SNAN:
    case TAG_SPECIAL_QNAN:
        ChopR10ToR8(r10, Fp, (USHORT)((*(USHORT *)&r10[8]) & 0x7fff));
#if !NATIVE_NAN_IS_INTEL_FORMAT
        Fp->rb[6] ^= 0x08; // invert the top bit of the mantissa
#endif
        break;

    case TAG_SPECIAL_DENORM:
        LoadIntelR10ToR8_VALID(cpu, r10, Fp);
        break;
    }
}

NPXLOADINTELR10TOR8(LoadIntelR10ToR8_EMPTY)
{
    CPUASSERT(FALSE);
}

VOID
LoadIntelR10ToR8(
    PCPUDATA cpu,
    PBYTE r10,
    PFPREG FpReg
)

/*++

Routine Description:

    Converts an Intel 10-byte real to an FPREG (Tag and 64-byte real).

    According to emload.asm, this is not an arithmetic operation,
    so SNANs do not throw exceptions.

Arguments:

    cpu     - per-thread data
    r10     - 10-byte real to load
    FpReg   - destination FP register.

Return Value:

    None

--*/

{
    // Classify the R10 and store its tag into the FP register
    ComputeR10Tag( (USHORT*)r10, FpReg );

    // Perform the coersion based on the classification
    (*LoadIntelR10ToR8Table[FpReg->Tag])(cpu, r10, FpReg);
}


FRAG1(FLD80, BYTE)        // FLD m80real
{
    PFPREG ST0;
    FpArithDataPreamble(cpu, pop1);

    cpu->FpStatusC1 = 0;        // assume no error
    PUSHFLT(ST0);
    if (ST0->Tag != TAG_EMPTY) {
        HandleStackFull(cpu, ST0);
    } else {
        LoadIntelR10ToR8(cpu, pop1, ST0);
        if (ST0->Tag == TAG_SPECIAL && ST0->TagSpecial == TAG_SPECIAL_DENORM) {
            if (!(cpu->FpControlMask & FPCONTROL_DM)) {
                cpu->FpStatusES = 1;    // Unmasked exception
            }
            cpu->FpStatusExceptions |= FPCONTROL_DM;
        }
    }
}


NPXPUTINTELR10(PutIntelR10_VALID)
{
    USHORT Exponent;
    FPREG  FpReg;

    //
    // Ugly compatibility hack here.  If the app sets the Tag word so all
    // registers are VALID, but the registers actually contain ZERO, detect
    // and correct that so we write the correct value back to memory.
    //
    FpReg.r64 = Fp->r64;
    SetTag(&FpReg);
    if (FpReg.Tag != TAG_VALID &&
        !(FpReg.Tag == TAG_SPECIAL && FpReg.TagSpecial == TAG_SPECIAL_DENORM)) {
        //
        // The app lied to us.  The tag word does not match the value in the
        // tag field.  Write the value according to its actual tag, not
        // according to the tag the app tried to foist on us.
        //
        PutIntelR10(r10, &FpReg);
        return;
    }

    // Grab the 11-bit SIGNED exponent and sign-extend it to 15 bits
    Exponent = (short)((FpReg.rdw[1] >> 20) & 0x7ff) - 1023 + 16383;

    // Drop in the sign bit
    if (FpReg.rb[7] >= 0x80) {
        Exponent |= 0x8000;
    }

    // Write the sign and exponent into the r10
    r10[9] = (Exponent >> 8) & 0xff;
    r10[8] = Exponent & 0xff;

    // Bit 0 of the mantissa is always 1 for R10 values, so write that
    // in, along with the first 7 bits of the FpReg.rb mantissa.
    r10[7] = 0x80 | ((FpReg.rb[6] & 0x0f) << 3) | (FpReg.rb[5] >> 5);

    // Copy in the remaining bits of the FpReg.rb mantissa
    r10[6] = (FpReg.rb[5] << 3) | (FpReg.rb[4] >> 5); // copy bits 7-14 from the FpReg.rb
    r10[5] = (FpReg.rb[4] << 3) | (FpReg.rb[3] >> 5); // copy bits 15-22
    r10[4] = (FpReg.rb[3] << 3) | (FpReg.rb[2] >> 5); // copy bits 23-30
    r10[3] = (FpReg.rb[2] << 3) | (FpReg.rb[1] >> 5); // copy bits 31-38
    r10[2] = (FpReg.rb[1] << 3) | (FpReg.rb[0] >> 5); // copy bits 39-46
    r10[1] = FpReg.rb[0] << 3; // copy bits 46-52, then fill the remaining bits
    r10[0] = 0;          // of the R10 mantissa with 0s
}

NPXPUTINTELR10(PutIntelR10_ZERO)
{
    r10[9] = Fp->rb[7];     // copy in sign plus 7 bits of exponent
    memset(r10, 0, 9);      // remainder is all zeroes
}

NPXPUTINTELR10(PutIntelR10_SPECIAL)
{
    switch (Fp->TagSpecial) {
    case TAG_SPECIAL_INDEF:
        r10[9] = 0xff;          // sign=1, exponent = 7 1s
        r10[8] = 0xff;          // exponent = 8 1s
        r10[7] = 0xc0;          // mantissa = 1100.00
        memset(r10, 0, 7);      // store rest of mantissa
        break;

    case TAG_SPECIAL_INFINITY:
        r10[9] = Fp->rb[7];         // copy in sign plus 7 bits of exponent
        r10[8] = 0xff;          // remainder of exponent is all 1s
        r10[7] = 0x80;          // top bit of mantissa is 1, rest is 0s
        memset(r10, 0, 7);      // remainder is all zeroes
        break;

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_SNAN:
        r10[9] = Fp->rb[7];         // copy in sign plus 7 1 bits of exponent
        r10[8] = 0xff;          // remainder of exponent is all 1s
        // Bit 0 of the mantissa is always 1 for R10 values, so write that
        // in, along with the first 7 bits of the R8 mantissa.
        r10[7] = 0x80 | ((Fp->rb[6] & 0x0f) << 3) | (Fp->rb[5] >> 5);
#if !NATIVE_NAN_IS_INTEL_FORMAT
        r10[7] ^= 0x40;         // switch the meaning of the NAN
#endif
        r10[6] = (Fp->rb[5] << 3) | (Fp->rb[4] >> 5); // copy bits 7-14 from the R8
        r10[5] = (Fp->rb[4] << 3) | (Fp->rb[3] >> 5); // copy bits 15-22
        r10[4] = (Fp->rb[3] << 3) | (Fp->rb[2] >> 5); // copy bits 23-30
        r10[3] = (Fp->rb[2] << 3) | (Fp->rb[1] >> 5); // copy bits 31-38
        r10[2] = (Fp->rb[1] << 3) | (Fp->rb[0] >> 5); // copy bits 39-46
        r10[1] = Fp->rb[0] << 3; // copy bits 46-52, then fill the remaining bits
        r10[0] = 0;          // of the R10 mantissa with 0s
        break;

    default:
        CPUASSERT(FALSE);        // fall through in free builds

    case TAG_SPECIAL_DENORM:
        PutIntelR10_VALID(r10, Fp);
        break;
    }
}

NPXPUTINTELR10(PutIntelR10_EMPTY)
{
    CPUASSERT(FALSE);    // Callers must handle TAG_EMPTY on their own.
}

FRAG1(FSTP80, BYTE)       // FSTP m80real
{
    PFPREG ST0;

    FpArithDataPreamble(cpu, pop1);

    cpu->FpStatusC1 = 0;        // assume no error
    ST0 = cpu->FpST0;
    if (ST0->Tag == TAG_EMPTY && HandleStackEmpty(cpu, ST0)) {
        return;
    }
    PutIntelR10(pop1, ST0);
    POPFLT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\fputrig.c ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    fputrig.c

Abstract:

    Floating point trig and transcendental functions

Author:

    05-Oct-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <float.h>
#include <math.h>
#include <stdio.h>
#include "wx86.h"
#include "cpuassrt.h"
#include "fragp.h"
#include "fpufragp.h"

ASSERTNAME;

//
// Forward declarations
//
NPXFUNC1(FCOS_VALID);
NPXFUNC1(FCOS_ZERO);
NPXFUNC1(FCOS_SPECIAL);
NPXFUNC1(FCOS_EMPTY);
NPXFUNC2(FPATAN_VALID_VALID);
NPXFUNC2(FPATAN_VALID_SPECIAL);
NPXFUNC2(FPATAN_SPECIAL_VALID);
NPXFUNC2(FPATAN_SPECIAL_SPECIAL);
NPXFUNC2(FPATAN_EMPTY_ALL);
NPXFUNC2(FPATAN_ALL_EMPTY);
NPXFUNC0(FPTAN_VALID);
NPXFUNC0(FPTAN_ZERO);
NPXFUNC0(FPTAN_SPECIAL);
NPXFUNC0(FSIN_VALID);
NPXFUNC0(FSIN_ZERO);
NPXFUNC0(FSIN_SPECIAL);
NPXFUNC0(FSIN_EMPTY);
NPXFUNC0(FSINCOS_VALID);
NPXFUNC0(FSINCOS_ZERO);
NPXFUNC0(FSINCOS_SPECIAL);
NPXFUNC2(FYL2X_VALID_VALID);
NPXFUNC2(FYL2X_VALID_ZERO);
NPXFUNC2(FYL2X_ZERO_VALID);
NPXFUNC2(FYL2X_ZERO_ZERO);
NPXFUNC2(FYL2X_SPECIAL_VALIDORZERO);
NPXFUNC2(FYL2X_VALIDORZERO_SPECIAL);
NPXFUNC2(FYL2X_SPECIAL_SPECIAL);
NPXFUNC2(FYL2X_ANY_EMPTY);
NPXFUNC2(FYL2X_EMPTY_ANY);
NPXFUNC2(FYL2XP1_VALIDORZERO_ZERO);
NPXFUNC2(FYL2XP1_VALIDORZERO_VALID);
NPXFUNC2(FYL2XP1_SPECIAL_VALIDORZERO);
NPXFUNC2(FYL2XP1_VALIDORZERO_SPECIAL);
NPXFUNC2(FYL2XP1_SPECIAL_SPECIAL);
NPXFUNC2(FYL2XP1_ANY_EMPTY);
NPXFUNC2(FYL2XP1_EMPTY_ANY);
NPXFUNC1(F2XM1_VALID);
NPXFUNC1(F2XM1_ZERO);
NPXFUNC1(F2XM1_SPECIAL);
NPXFUNC1(F2XM1_EMPTY);


//
// Jump tables
//
const NpxFunc1 FCOSTable[TAG_MAX] = {
    FCOS_VALID,
    FCOS_ZERO,
    FCOS_SPECIAL,
    FCOS_EMPTY
};

const NpxFunc2 FPATANTable[TAG_MAX][TAG_MAX] = {
    // left = TAG_VALID, right is ...
    { FPATAN_VALID_VALID, FPATAN_VALID_VALID, FPATAN_VALID_SPECIAL, FPATAN_ALL_EMPTY },
    // left = TAG_ZERO, right is ...
    { FPATAN_VALID_VALID, FPATAN_VALID_VALID, FPATAN_VALID_SPECIAL, FPATAN_ALL_EMPTY },
    // left = TAG_SPECIAL, right is ...
    { FPATAN_SPECIAL_VALID, FPATAN_SPECIAL_VALID, FPATAN_SPECIAL_SPECIAL, FPATAN_ALL_EMPTY },
    // left = TAG_EMPTY, right is ...
    { FPATAN_EMPTY_ALL, FPATAN_EMPTY_ALL, FPATAN_EMPTY_ALL, FPATAN_EMPTY_ALL }
};

const NpxFunc0 FPTANTable[TAG_MAX-1] = {
    FPTAN_VALID,
    FPTAN_ZERO,
    FPTAN_SPECIAL
};

const NpxFunc0 FSINTable[TAG_MAX] = {
    FSIN_VALID,
    FSIN_ZERO,
    FSIN_SPECIAL,
    FSIN_EMPTY
};

const NpxFunc0 FSINCOSTable[TAG_MAX-1] = {
    FSINCOS_VALID,
    FSINCOS_ZERO,
    FSINCOS_SPECIAL
};

// In the functions, l == ST(0), r = ST(1)
// r = r*log(l), l must be > 0
const NpxFunc2 FYL2XTable[TAG_MAX][TAG_MAX] = {
    // left is TAG_VALID, right is ...
    { FYL2X_VALID_VALID, FYL2X_VALID_ZERO, FYL2X_VALIDORZERO_SPECIAL, FYL2X_ANY_EMPTY },
    // left is TAG_ZERO, right is ...
    { FYL2X_ZERO_VALID, FYL2X_ZERO_ZERO, FYL2X_VALIDORZERO_SPECIAL, FYL2X_ANY_EMPTY },
    // left is TAG_SPECIAL, right is ...
    { FYL2X_SPECIAL_VALIDORZERO, FYL2X_SPECIAL_VALIDORZERO, FYL2X_SPECIAL_SPECIAL, FYL2X_ANY_EMPTY },
    // left is TAG_EMPTY, right is ...
    { FYL2X_EMPTY_ANY, FYL2X_EMPTY_ANY, FYL2X_EMPTY_ANY, FYL2X_EMPTY_ANY}
};

// In the functions, l == ST(0), r = ST(1)
// r = r*(logl+1), l must be > 1
const NpxFunc2 FYL2XP1Table[TAG_MAX][TAG_MAX] = {
    // left is TAG_VALID, right is ...
    { FYL2XP1_VALIDORZERO_VALID, FYL2XP1_VALIDORZERO_ZERO, FYL2XP1_VALIDORZERO_SPECIAL, FYL2XP1_ANY_EMPTY },
    // left is TAG_ZERO, right is ...
    { FYL2XP1_VALIDORZERO_VALID, FYL2XP1_VALIDORZERO_ZERO, FYL2XP1_VALIDORZERO_SPECIAL, FYL2X_ANY_EMPTY },
    // left is TAG_SPECIAL, right is ...
    { FYL2XP1_SPECIAL_VALIDORZERO, FYL2XP1_SPECIAL_VALIDORZERO, FYL2XP1_SPECIAL_SPECIAL, FYL2XP1_ANY_EMPTY },
    // left is TAG_EMPTY, right is ...
    { FYL2XP1_EMPTY_ANY, FYL2XP1_EMPTY_ANY, FYL2XP1_EMPTY_ANY, FYL2XP1_EMPTY_ANY}
};

const NpxFunc1 F2XM1Table[TAG_MAX] = {
    F2XM1_VALID,
    F2XM1_ZERO,
    F2XM1_SPECIAL,
    F2XM1_EMPTY
};



NPXFUNC1(FCOS_VALID)
{
    Fp->r64 = cos(Fp->r64);
    SetTag(Fp);
}

NPXFUNC1(FCOS_ZERO)
{
    Fp->Tag = TAG_VALID;
    Fp->r64 = 1.0;
}

NPXFUNC1(FCOS_SPECIAL)
{
    switch (Fp->TagSpecial) {
    case TAG_SPECIAL_DENORM:
        FCOS_VALID(cpu, Fp);
        break;

    case TAG_SPECIAL_INFINITY:
        cpu->FpStatusC2 = 1;
        SetIndefinite(Fp);
        break;

    case TAG_SPECIAL_SNAN:
        HandleSnan(cpu, Fp);
        break;

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_INDEF:
        HandleInvalidOp(cpu);
        break;
    }
}

NPXFUNC1(FCOS_EMPTY)
{
    HandleStackEmpty(cpu, Fp);
}

FRAG0(FCOS)
{
    PFPREG ST0;
    FpArithPreamble(cpu);

    cpu->FpStatusC2 = 0;
    ST0 = cpu->FpST0;
    (*FCOSTable[ST0->Tag])(cpu, ST0);
}

NPXFUNC2(FPATAN_VALID_VALID)
{
    l->r64 = Proxyatan2(l->r64, r->r64);
    SetTag(l);
    POPFLT;
}

NPXFUNC2(FPATAN_VALID_SPECIAL)
{
    switch (r->TagSpecial) {
    case TAG_SPECIAL_DENORM:
    case TAG_SPECIAL_INFINITY:
        FPATAN_VALID_VALID(cpu, l, r);
        break;

    case TAG_SPECIAL_SNAN:
        if (HandleSnan(cpu, r)) {
            break;
        }
        // else fall into QNAN

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_INDEF:
        // return the QNAN as the result
        l->r64 = r->r64;
        l->Tag = TAG_SPECIAL;
        l->TagSpecial = r->TagSpecial;
        POPFLT;
        break;
    }
}

NPXFUNC2(FPATAN_SPECIAL_VALID)
{
    switch (l->TagSpecial) {
    case TAG_SPECIAL_DENORM:
    case TAG_SPECIAL_INFINITY:
        FPATAN_VALID_VALID(cpu, l, r);
        break;

    case TAG_SPECIAL_SNAN:
        if (HandleSnan(cpu, l)) {
            break;
        }
        // else fall into QNAN

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_INDEF:
        // The QNAN is already in l, so nothing to do.
        POPFLT;
        break;
    }
}

NPXFUNC2(FPATAN_SPECIAL_SPECIAL)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }
    if (IS_TAG_NAN(l)) {
        if (IS_TAG_NAN(r)) {
            //
            // Return the larger of the two NANs
            //
            l->r64 = l->r64 + r->r64;
            SetTag(l);
        }
        //
        // else l is a NAN and r isn't - return the NAN in l
        //
        POPFLT;
        return;
    }
    if (IS_TAG_NAN(r)) {
        // r is a NAN and l isn't - return the NAN in l
        l->r64 = r->r64;
        l->Tag = TAG_SPECIAL;
        l->TagSpecial = r->TagSpecial;
        POPFLT;
    }

    // Otherwise, l and r are both INFINITY.  Return INDEFINITE
    CPUASSERT(l->TagSpecial == TAG_SPECIAL_INFINITY &&
              r->TagSpecial == TAG_SPECIAL_INFINITY);
    SetIndefinite(l);
    POPFLT;
}

NPXFUNC2(FPATAN_EMPTY_ALL)
{
    if (!HandleStackEmpty(cpu, l)) {
        (*FPATANTable[TAG_SPECIAL][r->Tag])(cpu, l, r);
    }
}

NPXFUNC2(FPATAN_ALL_EMPTY)
{
    if (!HandleStackEmpty(cpu, r)) {
        (*FPATANTable[l->Tag][TAG_SPECIAL])(cpu, l, r);
    }
}

FRAG0(FPATAN)
{
    PFPREG l = &cpu->FpStack[ST(1)];
    PFPREG r = cpu->FpST0;

    FpArithPreamble(cpu);
    (*FPATANTable[l->Tag][r->Tag])(cpu, l, r);
}


NPXFUNC0(FPTAN_VALID)
{
    int Exponent;
    PFPREG ST0;

    // get the exponent and make sure it is < 63
    ST0 = cpu->FpST0;
    Exponent = (int)((ST0->rdw[1] >> 20) & 0x7ff) - 1023;
    if (Exponent >= 63) {
        cpu->FpStatusC2 = 1;
        return;
    }
    ST0->r64 = tan(ST0->r64);
    SetTag(ST0);
    PUSHFLT(ST0);
    ST0->Tag = TAG_VALID;
    ST0->r64 = 1.0;
}

NPXFUNC0(FPTAN_ZERO)
{
    PFPREG ST0;

    ST0=cpu->FpST0;
    ST0->r64 = 0.0;
    ST0->Tag = TAG_ZERO;
    PUSHFLT(ST0);
    ST0->r64 = 1.0;
    ST0->Tag = TAG_VALID;
}

NPXFUNC0(FPTAN_SPECIAL)
{
    if (cpu->FpST0->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, cpu->FpST0)) {
        return;
    } else if (cpu->FpST0->TagSpecial == TAG_SPECIAL_DENORM) {
        FPTAN_VALID(cpu);
    }
    cpu->FpStatusC2 = 1;
}

FRAG0(FPTAN)
{
    PFPREG ST0;

    FpArithPreamble(cpu);

    ST0 = cpu->FpST0;

    //
    // TAG_EMPTY is handled first so that we can check ST(7) before
    // anything else has a chance to raise an exception.
    //
    if (ST0->Tag == TAG_EMPTY && HandleStackEmpty(cpu, ST0)) {
        return;
    }

    if (cpu->FpStack[ST(7)].Tag != TAG_EMPTY) {
        HandleStackFull(cpu, &cpu->FpStack[ST(7)]);
        return;
    }

    // assume no error
    cpu->FpStatusC2 = 0;

    // calculate the value
    CPUASSERT(ST0->Tag < TAG_EMPTY); // EMPTY was already handled
    (*FPTANTable[ST0->Tag])(cpu);
}

NPXFUNC0(FSIN_VALID)
{
    PFPREG ST0;

    ST0 = cpu->FpST0;
    ST0->r64 = sin(ST0->r64);
    SetTag(ST0);
}

NPXFUNC0(FSIN_ZERO)
{
    // sin(0.0) == 0.0, so there is nothing to do
}

NPXFUNC0(FSIN_SPECIAL)
{
    if (cpu->FpST0->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, cpu->FpST0)) {
        return;
    } else if (cpu->FpST0->TagSpecial == TAG_SPECIAL_DENORM) {
        FSIN_VALID(cpu);
    }
    cpu->FpStatusC2 = 1;
}

NPXFUNC0(FSIN_EMPTY)
{
    if (!HandleStackEmpty(cpu, cpu->FpST0)) {
        cpu->FpStatusC2 = 1;
    }
}

FRAG0(FSIN)
{
    FpArithPreamble(cpu);

    // assume no error
    cpu->FpStatusC2 = 0;

    // calculate the value
    (*FSINTable[cpu->FpST0->Tag])(cpu);
}

NPXFUNC0(FSINCOS_VALID)
{
    DOUBLE Val;
    PFPREG ST0;

    ST0 = cpu->FpST0;
    Val = ST0->r64;
    ST0->r64 = sin(Val);
    SetTag(ST0);
    PUSHFLT(ST0);
    ST0->r64 = cos(Val);
    SetTag(ST0);
}

NPXFUNC0(FSINCOS_ZERO)
{
    PFPREG ST0;

    ST0=cpu->FpST0;
    ST0->r64 = 0.0;
    ST0->Tag = TAG_ZERO;
    PUSHFLT(ST0);
    ST0->r64 = 1.0;
    ST0->Tag = TAG_VALID;
}

NPXFUNC0(FSINCOS_SPECIAL)
{
    switch (cpu->FpST0->TagSpecial) {
    case TAG_SPECIAL_DENORM:
        FSINCOS_VALID(cpu);
        break;

    case TAG_SPECIAL_INFINITY:
        cpu->FpStatusC2 = 1;
        SetIndefinite(cpu->FpST0);
        break;

    case TAG_SPECIAL_SNAN:
        if (HandleSnan(cpu, cpu->FpST0)) {
            return;
        }
        // else fall into TAG_SPECIAL_QNAN

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_INDEF:
        cpu->FpStatusC2 = 1;
        break;
    }
}

FRAG0(FSINCOS)
{
    PFPREG ST0;

    FpArithPreamble(cpu);

    // assume no errors
    cpu->FpStatusC2 = 0;

    ST0 = cpu->FpST0;
    if (ST0->Tag == TAG_EMPTY && HandleStackEmpty(cpu, ST0)) {
        return;
    }

    if (cpu->FpStack[ST(7)].Tag != TAG_EMPTY) {
        HandleStackFull(cpu, &cpu->FpStack[ST(7)]);
        return;
    }

    CPUASSERT(ST0->Tag < TAG_EMPTY); // EMPTY was already handled
    (*FSINCOSTable[ST0->Tag])(cpu);
}

NPXFUNC2(FYL2X_VALID_VALID)
{
    if (l->r64 < 0.0) {
        // ST0 is negative - invalid operation
        if (!HandleInvalidOp(cpu)) {
            SetIndefinite(r);
            POPFLT;
        }
        return;
    }
    // r = r * log10(l->r64) / log10(2)
    //
    r->r64 *= Proxylog10(l->r64) / (0.301029995664);
    SetTag(r);
    POPFLT;
}

NPXFUNC2(FYL2X_VALID_ZERO)
{
    if (l->r64 < 0.0) {
        // ST0 is negative - invalid operation
        if (!HandleInvalidOp(cpu)) {
            SetIndefinite(r);
            POPFLT;
        }
        return;
    }
    // r = r*log2(l), but r=0, so the answer is 0.
    r->r64 = 0;
    r->Tag = TAG_ZERO;
    POPFLT;
}

NPXFUNC2(FYL2X_ZERO_VALID)
{
    // Divide-by-zero error
    cpu->FpStatusExceptions |= FPCONTROL_ZM;
    if (cpu->FpControlMask & FPCONTROL_ZM) {
        // Zero-divide exception is masked - return -INFINITY
        r->r64 = R8NegativeInfinity;
        r->Tag = TAG_SPECIAL;
        r->TagSpecial = TAG_SPECIAL_INFINITY;
        POPFLT;
    } else {
        cpu->FpStatusES = 1;
    }
}

NPXFUNC2(FYL2X_ZERO_ZERO)
{
    if (!HandleInvalidOp(cpu)) {
        SetIndefinite(r);
        POPFLT;
    }
}


NPXFUNC2(FYL2X_SPECIAL_VALIDORZERO)
{
    switch (l->TagSpecial) {
    case TAG_SPECIAL_DENORM:
        (*FYL2XTable[TAG_VALID][r->Tag])(cpu, l, r);
        break;

    case TAG_SPECIAL_INFINITY:
        if (r->Tag == TAG_ZERO || r->rb[7] & 0x80) {
            // 0*infinity, or anything*-infinity
            SetIndefinite(r);
        } else {
            // return -infinity
            r->rb[7] |= 0x80;
        }
        POPFLT;
        break;

    case TAG_SPECIAL_SNAN:
        if (HandleSnan(cpu, l)) {
            return;
        }
        // else fall into TAG_SPECIAL_QNAN

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_INDEF:
        // l is a NAN and r is VALID or ZERO - return the NAN
        r->r64 = l->r64;
        r->Tag = l->Tag;
        r->TagSpecial = r->TagSpecial;
        POPFLT;
        break;
    }
}

NPXFUNC2(FYL2X_VALIDORZERO_SPECIAL)
{
    switch (r->TagSpecial) {
    case TAG_SPECIAL_DENORM:
        (*FYL2XTable[l->Tag][TAG_VALID])(cpu, l, r);
        break;

    case TAG_SPECIAL_INFINITY:
        // log(x)*infinity
        if (l->r64 > 1.0) {
            // return the original infinity - nothing to do
        } else if (l->r64 < 0.0 || l->r64 == 1.0) {
            if (HandleInvalidOp(cpu)) {
                return;
            }
            SetIndefinite(r);
        } else {
            // return infinity with sign flipped
            r->rb[7] ^= 0x80;
        }

        POPFLT;
        break;

    case TAG_SPECIAL_SNAN:
        if (HandleSnan(cpu, r)) {
            return;
        }
        // else fall into TAG_SPECIAL_QNAN

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_INDEF:
        // r is a NAN and l is VALID or ZERO - return the NAN
        POPFLT;
        break;
    }
}

NPXFUNC2(FYL2X_SPECIAL_SPECIAL)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleStackEmpty(cpu, l)) {
        return;
    }
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleStackEmpty(cpu, r)) {
        return;
    }

    if (l->TagSpecial == TAG_SPECIAL_DENORM) {
        (*FYL2XTable[TAG_VALID][r->Tag])(cpu, l, r);
        return;
    }
    if (r->TagSpecial == TAG_SPECIAL_DENORM) {
        (*FYL2XTable[l->Tag][TAG_VALID])(cpu, l, r);
        return;
    }

    if (l->Tag == TAG_SPECIAL_INFINITY) {

        if (r->Tag == TAG_SPECIAL_INFINITY) {

            // two infinities - return INDEFINITE
            SetIndefinite(r);

        } else {
            CPUASSERT(IS_TAG_NAN(r));

            // r already has the NAN to return
        }
    } else {
        CPUASSERT(IS_TAG_NAN(l));

        if (r->Tag == TAG_SPECIAL_INFINITY) {
            //
            // Return the NAN from l
            //
            r->r64 = l->r64;
            r->TagSpecial = l->TagSpecial;
        } else {
            //
            // Return the largest of the two NANs
            //
            r->r64 = l->r64 + r->r64;
            SetTag(r);
        }
    }
    POPFLT;
}


NPXFUNC2(FYL2X_ANY_EMPTY)
{
    if (!HandleStackEmpty(cpu, r)) {
        (*FYL2XTable[l->Tag][TAG_SPECIAL])(cpu, l, r);
    }
}

NPXFUNC2(FYL2X_EMPTY_ANY)
{
    if (!HandleStackEmpty(cpu, l)) {
        (*FYL2XTable[TAG_SPECIAL][r->Tag])(cpu, l, r);
    }
}

FRAG0(FYL2X)
{
    PFPREG l, r;

    FpArithPreamble(cpu);

    l = cpu->FpST0;
    r = &cpu->FpStack[ST(1)];

    // In the functions, l == ST(0), r = ST(1)
    (*FYL2XTable[l->Tag][r->Tag])(cpu, l, r);
}



NPXFUNC2(FYL2XP1_VALIDORZERO_VALID)
{
    if (l->r64 < -1.0) {
        if (!HandleInvalidOp(cpu)) {
            SetIndefinite(r);
            POPFLT;
        }
        return;
    } else if (l->r64 == -1.0) {
        // Divide-by-zero error
        cpu->FpStatusExceptions |= FPCONTROL_ZM;
        if (cpu->FpControlMask & FPCONTROL_ZM) {
            // Zero-divide exception is masked - return -INFINITY
            r->r64 = R8NegativeInfinity;
            r->Tag = TAG_SPECIAL;
            r->TagSpecial = TAG_SPECIAL_INFINITY;
            POPFLT;
        } else {
           cpu->FpStatusES = 1;
        }
        return;
    }
    // r = r * log10(l+1) / log10(2)
    //
    r->r64 *= Proxylog10(l->r64 + 1.0) / (0.301029995664);
    SetTag(r);
    POPFLT;
}

NPXFUNC2(FYL2XP1_VALIDORZERO_ZERO)
{
    if (l->r64 < -1.0) {
        if (!HandleInvalidOp(cpu)) {
            SetIndefinite(r);
            POPFLT;
        }
        return;
    }
    // r = r*log2(l), but r=0, so the answer is 0.
    r->r64 = 0;
    r->Tag = TAG_ZERO;
    POPFLT;
}

NPXFUNC2(FYL2XP1_SPECIAL_VALIDORZERO)
{
    switch (l->TagSpecial) {
    case TAG_SPECIAL_DENORM:
        (*FYL2XP1Table[TAG_VALID][r->Tag])(cpu, l, r);
        break;

    case TAG_SPECIAL_INFINITY:
        if (r->Tag == TAG_ZERO || r->rb[7] & 0x80) {
            if (HandleInvalidOp(cpu)) {
                return;
            }

            // 0*infinity, or anything*-infinity
            SetIndefinite(r);
        } else {
            // return -infinity
            r->rb[7] |= 0x80;
        }
        POPFLT;
        break;

    case TAG_SPECIAL_SNAN:
        if (HandleSnan(cpu, l)) {
            return;
        }
        // else fall into TAG_SPECIAL_QNAN

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_INDEF:
        // l is a NAN and r is VALID or ZERO - return the NAN
        r->r64 = l->r64;
        r->Tag = l->Tag;
        r->TagSpecial = r->TagSpecial;
        POPFLT;
        break;
    }
}

NPXFUNC2(FYL2XP1_VALIDORZERO_SPECIAL)
{
    switch (r->TagSpecial) {
    case TAG_SPECIAL_DENORM:
        (*FYL2XP1Table[l->Tag][TAG_VALID])(cpu, l, r);
        break;

    case TAG_SPECIAL_INFINITY:
        // log(x)*infinity
        if (l->r64 > 1.0) {
            // return the original infinity - nothing to do
        } else if (l->r64 < 0.0 || l->r64 == 1.0) {
            if (HandleInvalidOp(cpu)) {
                return;
            }
            SetIndefinite(r);
        } else {
            // return infinity with sign flipped
            r->rb[7] ^= 0x80;
        }

        POPFLT;
        break;

    case TAG_SPECIAL_SNAN:
        if (HandleSnan(cpu, r)) {
            return;
        }
        // else fall into TAG_SPECIAL_QNAN

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_INDEF:
        // r is a NAN and l is VALID or ZERO - return the NAN
        POPFLT;
        break;
    }
}

NPXFUNC2(FYL2XP1_SPECIAL_SPECIAL)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleStackEmpty(cpu, l)) {
        return;
    }
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleStackEmpty(cpu, r)) {
        return;
    }

    if (l->TagSpecial == TAG_SPECIAL_DENORM) {
        (*FYL2XP1Table[TAG_VALID][r->Tag])(cpu, l, r);
        return;
    }
    if (r->TagSpecial == TAG_SPECIAL_DENORM) {
        (*FYL2XP1Table[l->Tag][TAG_VALID])(cpu, l, r);
        return;
    }

    if (l->Tag == TAG_SPECIAL_INFINITY) {

        if (r->Tag == TAG_SPECIAL_INFINITY) {

            if (l->rb[7] & 0x80) {
                // l is negative infinity.  Invalid op
                if (HandleInvalidOp(cpu)) {
                    return;
                }
                SetIndefinite(r);
            }


        } else {
            CPUASSERT(IS_TAG_NAN(r));

            // r already has the NAN to return
        }
    } else {
        CPUASSERT(IS_TAG_NAN(l));

        if (r->Tag == TAG_SPECIAL_INFINITY) {
            //
            // Return the NAN from l
            //
            r->r64 = l->r64;
            r->TagSpecial = l->TagSpecial;
        } else {
            //
            // Return the largest of the two NANs
            //
            r->r64 = l->r64 + r->r64;
            SetTag(r);
        }
    }
    POPFLT;
}


NPXFUNC2(FYL2XP1_ANY_EMPTY)
{
    if (!HandleStackEmpty(cpu, r)) {
        (*FYL2XP1Table[l->Tag][TAG_SPECIAL])(cpu, l, r);
    }
}

NPXFUNC2(FYL2XP1_EMPTY_ANY)
{
    if (!HandleStackEmpty(cpu, l)) {
        (*FYL2XP1Table[TAG_SPECIAL][r->Tag])(cpu, l, r);
    }
}

FRAG0(FYL2XP1)
{
    PFPREG l, r;

    FpArithPreamble(cpu);

    l = cpu->FpST0;
    r = &cpu->FpStack[ST(1)];

    // In the functions, l == ST(0), r = ST(1)
    (*FYL2XP1Table[l->Tag][r->Tag])(cpu, l, r);
}



NPXFUNC1(F2XM1_VALID)
{
    Fp->r64 = pow(2.0, Fp->r64) - 1.0;
    SetTag(Fp);
}

NPXFUNC1(F2XM1_ZERO)
{
    // nothing to do - return the same zero
}

NPXFUNC1(F2XM1_SPECIAL)
{
    switch (Fp->TagSpecial) {
    case TAG_SPECIAL_DENORM:
        F2XM1_VALID(cpu, Fp);
        break;

    case TAG_SPECIAL_INFINITY:
        if (Fp->rb[7] & 0x80) {
            // -infinity - return 1
            Fp->r64 = 1.0;
            Fp->Tag = TAG_VALID;
        }
        // else +infinity - return +infinity
        break;

    case TAG_SPECIAL_SNAN:
        HandleSnan(cpu, Fp);
        // fall into TAG_SPECIAL_QNAN

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_INDEF:
        // return the NAN
        break;
    }
}

NPXFUNC1(F2XM1_EMPTY)
{
    HandleStackEmpty(cpu, Fp);
}

FRAG0(F2XM1)
{
    PFPREG ST0;

    FpArithPreamble(cpu);
    ST0 = cpu->FpST0;
    (*F2XM1Table[ST0->Tag])(cpu, ST0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\fragmisc.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    fragmisc.h

Abstract:
    
    Prototypes for misc. instruction fragments.

Author:

    12-Jun-1995 BarryBo, Created

Revision History:

--*/
FRAG0(CbwFrag16);
FRAG0(CbwFrag32);
FRAG0(PushEsFrag);
FRAG0(PopEsFrag);
FRAG0(PushFsFrag);
FRAG0(PopFsFrag);
FRAG0(PushGsFrag);
FRAG0(PopGsFrag);
FRAG0(PushCsFrag);
FRAG0(AasFrag);
FRAG0(PushSsFrag);
FRAG0(PopSsFrag);
FRAG0(PushDsFrag);
FRAG0(PopDsFrag);
FRAG0(DaaFrag);
FRAG0(DasFrag);
FRAG0(AaaFrag);
FRAG1IMM(AadFrag, BYTE);
FRAG2(ImulFrag16, USHORT);
FRAG2(ImulFrag16A, USHORT);
FRAG3(Imul3ArgFrag16, USHORT, USHORT, USHORT);
FRAG3(Imul3ArgFrag16A, USHORT, USHORT, USHORT);
FRAG2(ImulNoFlagsFrag16, USHORT);
FRAG2(ImulNoFlagsFrag16A, USHORT);
FRAG3(Imul3ArgNoFlagsFrag16, USHORT, USHORT, USHORT);
FRAG3(Imul3ArgNoFlagsFrag16A, USHORT, USHORT, USHORT);
FRAG2(ImulFrag32, DWORD);
FRAG2(ImulFrag32A, DWORD);
FRAG3(Imul3ArgFrag32, DWORD, DWORD, DWORD);
FRAG3(Imul3ArgFrag32A, DWORD, DWORD, DWORD);
FRAG2(ImulNoFlagsFrag32, DWORD);
FRAG2(ImulNoFlagsFrag32A, DWORD);
FRAG3(Imul3ArgNoFlagsFrag32, DWORD, DWORD, DWORD);
FRAG3(Imul3ArgNoFlagsFrag32A, DWORD, DWORD, DWORD);
FRAG0(SahfFrag);
FRAG0(LahfFrag);
FRAG1IMM(AamFrag, BYTE);
FRAG0(XlatFrag);
FRAG0(CmcFrag);
FRAG0(ClcFrag);
FRAG0(StcFrag);
FRAG0(CldFrag);
FRAG0(StdFrag);
FRAG1(SetoFrag, BYTE);
FRAG1(SetnoFrag, BYTE);
FRAG1(SetbFrag, BYTE);
FRAG1(SetaeFrag, BYTE);
FRAG1(SeteFrag, BYTE);
FRAG1(SetneFrag, BYTE);
FRAG1(SetbeFrag, BYTE);
FRAG1(SetaFrag, BYTE);
FRAG1(SetsFrag, BYTE);
FRAG1(SetnsFrag, BYTE);
FRAG1(SetpFrag, BYTE);
FRAG1(SetnpFrag, BYTE);
FRAG1(SetlFrag, BYTE);
FRAG1(SetgeFrag, BYTE);
FRAG1(SetleFrag, BYTE);
FRAG1(SetgFrag, BYTE);
FRAG2(Movzx8ToFrag16, USHORT);
FRAG2(Movzx8ToFrag16A, USHORT);
FRAG2(Movsx8ToFrag16, USHORT);
FRAG2(Movsx8ToFrag16A, USHORT);
FRAG2(Movzx8ToFrag32, DWORD);
FRAG2(Movzx8ToFrag32A, DWORD);
FRAG2(Movsx8ToFrag32, DWORD);
FRAG2(Movsx8ToFrag32A, DWORD);
FRAG2(Movzx16ToFrag32, DWORD);
FRAG2(Movzx16ToFrag32A, DWORD);
FRAG2(Movsx16ToFrag32, DWORD);
FRAG2(Movsx16ToFrag32A, DWORD);
FRAG1(BswapFrag32, DWORD);
FRAG2(ArplFrag, USHORT);
FRAG1(VerrFrag, USHORT);
FRAG1(VerwFrag, USHORT);
FRAG1(SmswFrag, USHORT);
FRAG2REF(CmpXchg8bFrag32, ULONGLONG);

#if MSCPU
FRAG0(IntFrag);
FRAG0(IntOFrag);
FRAG0(NopFrag);
FRAG0(PrivilegedInstructionFrag);
FRAG0(BadInstructionFrag);
FRAG2(FaultFrag, DWORD);
FRAG0(CPUID);
#endif //MSCPU
FRAG0(Rdtsc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\lock.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    lock.c

Abstract:
    
    32bit instructions with the LOCK prefix

Author:

    15-Aug-1995 t-orig (Ori Gershony)

Revision History:

        24-Aug-1999 [askhalid] copied from 32-bit wx86 directory and make work for 64bit.
        20-Sept-1999[barrybo]  added FRAG2REF(LockCmpXchg8bFrag32, ULONGLONG)

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "fragp.h"
#include "lock.h"


// Define a macro which calls the lock helper functions
#define CALLLOCKHELPER0(fn)             fn ## LockHelper ()
#define CALLLOCKHELPER1(fn,a1)          fn ## LockHelper (a1)
#define CALLLOCKHELPER2(fn,a1,a2)       fn ## LockHelper (a1,a2)
#define CALLLOCKHELPER3(fn,a1,a2,a3)    fn ## LockHelper (a1,a2,a3)
#define CALLLOCKHELPER4(fn,a1,a2,a3,a4) fn ## LockHelper (a1,a2,a3,a4)

// Now define 32bit MSB
#define MSB		    0x80000000

#define SET_FLAGS_ADD   SET_FLAGS_ADD32
#define SET_FLAGS_SUB   SET_FLAGS_SUB32
#define SET_FLAGS_INC   SET_FLAGS_INC32
#define SET_FLAGS_DEC   SET_FLAGS_DEC32

FRAG2(LockAddFrag32, ULONG)
{
    ULONG result, op1;

    result = CALLLOCKHELPER3(Add, &op1, pop1, op2); 
    SET_FLAGS_ADD(result, op1, op2, MSB);
}

FRAG2(LockOrFrag32, ULONG)
{
    ULONG result;

    result = CALLLOCKHELPER2(Or, pop1, op2); 
    SET_PFLAG(result);
    SET_ZFLAG(result);
    SET_SFLAG(result);
    SET_CFLAG_OFF;
    SET_OFLAG_OFF;
}

FRAG2(LockAdcFrag32, ULONG)
{
    ULONG result, op1;

    result = CALLLOCKHELPER4(Adc, &op1, pop1, op2, cpu->flag_cf);
    SET_FLAGS_ADD(result, op1, op2, MSB);
}

FRAG2(LockSbbFrag32, ULONG)
{
    ULONG result, op1;

    result = CALLLOCKHELPER4(Sbb, &op1, pop1, op2, cpu->flag_cf);
    SET_FLAGS_SUB(result, op1, op2, MSB);
}

FRAG2(LockAndFrag32, ULONG)
{
    ULONG result;

    result = CALLLOCKHELPER2(And, pop1, op2); 
    SET_ZFLAG(result);
    SET_PFLAG(result);
    SET_SFLAG(result);
    SET_CFLAG_OFF;
    SET_OFLAG_OFF;
}

FRAG2(LockSubFrag32, ULONG)
{
    ULONG result, op1;

    result = CALLLOCKHELPER3(Sub, &op1, pop1, op2); 
    SET_FLAGS_SUB(result, op1, op2, MSB);
}

FRAG2(LockXorFrag32, ULONG)
{
    ULONG result;

    result = CALLLOCKHELPER2(Xor, pop1, op2); 
    SET_ZFLAG(result);
    SET_PFLAG(result);
    SET_SFLAG(result);
    SET_CFLAG_OFF;
    SET_OFLAG_OFF;
}

FRAG1(LockNotFrag32, ULONG)
{
    CALLLOCKHELPER1(Not, pop1);
}

FRAG1(LockNegFrag32, ULONG)
{
    ULONG result, op1;

    result = CALLLOCKHELPER2(Neg, &op1, pop1);
    SET_CFLAG_IND(result == 0);
    SET_ZFLAG(result);
    SET_PFLAG(result);
    SET_SFLAG(result);
    SET_OFLAG_IND(op1 & result & MSB);
}

FRAG1(LockIncFrag32, ULONG)
{
    ULONG result, op1;

    result = CALLLOCKHELPER3(Add, &op1, pop1, 1); 
    SET_FLAGS_INC(result, op1);
}

FRAG1(LockDecFrag32, ULONG)
{
    ULONG result, op1;

    result = CALLLOCKHELPER3(Sub, &op1, pop1, 1); 
    SET_FLAGS_DEC(result, op1);
}

FRAG2(LockBtsMemFrag32, ULONG)
{
    ULONG bit = 1<<(op2&0x1f);

    pop1 += (op2 >> 5);
    SET_CFLAG_IND(CALLLOCKHELPER2(Bts, pop1, bit));
}

FRAG2(LockBtsRegFrag32, ULONG)
{
    ULONG bit = 1<<(op2&0x1f);

    SET_CFLAG_IND(CALLLOCKHELPER2(Bts, pop1, bit));
}

FRAG2(LockBtrMemFrag32, ULONG)
{
    ULONG bit = 1<<(op2&0x1f);

    pop1 += (op2 >> 5);
    SET_CFLAG_IND(CALLLOCKHELPER2(Btr, pop1, bit));
}

FRAG2(LockBtrRegFrag32, ULONG)
{
    ULONG bit = 1<<(op2&0x1f);

    SET_CFLAG_IND(CALLLOCKHELPER2(Btr, pop1, bit));
}

FRAG2(LockBtcMemFrag32, ULONG)
{
    ULONG bit = 1<<(op2&0x1f);

    pop1 += (op2 >> 5);
    SET_CFLAG_IND(CALLLOCKHELPER2(Btc, pop1, bit));
}

FRAG2(LockBtcRegFrag32, ULONG)
{
    ULONG bit = 1<<(op2&0x1f);

    SET_CFLAG_IND(CALLLOCKHELPER2(Btc, pop1, bit));
}

FRAG2REF(LockXchgFrag32, ULONG)
{
    CALLLOCKHELPER2(Xchg, pop1, pop2);
}

FRAG2REF(LockXaddFrag32, ULONG)
{
    ULONG op1, op2;

    op2 = CALLLOCKHELPER3(Xadd, &op1, pop1, pop2);
    // op1 has the original value of dest (*pop1)
    // op2 has the result of the XADD
    // so, op2-op1 is the original value of src
    SET_FLAGS_ADD(op2, (op2-op1), op1, MSB);
}
FRAG2REF(LockCmpXchgFrag32, ULONG)
{
    ULONG op1;
    ULONG Value = eax;

    SET_ZFLAG(CALLLOCKHELPER4(CmpXchg, &eax, pop1, pop2, &op1));
    SET_FLAGS_SUB(Value-op1, Value, op1, MSB);
}
FRAG2REF(LockCmpXchg8bFrag32, ULONGLONG)
{
    ULONGLONG op1;
    ULONGLONG EdxEax;
    ULONGLONG EcxEbx;

    EdxEax = (((ULONGLONG)edx) << 32) | (ULONGLONG)eax;
    EcxEbx = (ULONGLONG)ecx << 32 | (ULONGLONG)ebx;
    SET_ZFLAG(CALLLOCKHELPER3(CmpXchg8b, &EdxEax, &EcxEbx, pop1));
    edx = (ULONG)(EdxEax >> 32);
    eax = (ULONG)EdxEax;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\fragmisc.c ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    fragmisc.c

Abstract:
    
    Miscellaneous instuction fragments.

Author:

    12-Jun-1995 BarryBo

Revision History:

      24-Aug-1999 [askhalid] copied from 32-bit wx86 directory and make work for 64bit.
      20-Sept-1999[barrybo]  added FRAG2REF(CmpXchg8bFrag32, ULONGLONG)

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <float.h>
#include "wx86.h"
#include "wx86nt.h"
#include "fragp.h"
#include "fragmisc.h"
#include "cpunotif.h"
#include "config.h"
#include "mrsw.h"
#include "cpuassrt.h"
#if MSCPU
#include "atomic.h"
#endif
ASSERTNAME;

void
CpupUnlockTCAndDoInterrupt(
    PTHREADSTATE cpu,
    int Interrupt
    )
{
    MrswReaderExit(&MrswTC);
    cpu->fTCUnlocked = TRUE;
    CpupDoInterrupt(Interrupt);
    // If we get here, CpupDoInterrupt returned due to CONTINUE_EXECUTION.
    // We need to redesign so we can jump to EndTranslatedCode now, as
    // the cache may have been flushed.
    CPUASSERT(FALSE);
    MrswReaderEnter(&MrswTC);
    cpu->fTCUnlocked = FALSE;
}


FRAG0(CbwFrag32)
{
    eax = (signed long)(signed short)ax;
}
FRAG0(CbwFrag16)
{
    ax = (signed short)(signed char)al;
}
FRAG0(PushEsFrag)
{
    PUSH_LONG(ES);
}
FRAG0(PopEsFrag)
{
    DWORD temp;
    POP_LONG(temp);
    ES = (USHORT)temp;
}
FRAG0(PushFsFrag)
{
    PUSH_LONG(FS);
}
FRAG0(PopFsFrag)
{
    DWORD temp;
    POP_LONG(temp);
    FS = (USHORT)temp;
}
FRAG0(PushGsFrag)
{
    PUSH_LONG(GS);
}
FRAG0(PopGsFrag)
{
    DWORD temp;
    POP_LONG(temp);
    GS = (USHORT)temp;
}
FRAG0(PushCsFrag)
{
    PUSH_LONG(CS);
}
FRAG0(AasFrag)
{
    if ( (al & 0x0f) > 9 || GET_AUXFLAG) {
        ah--;
        al = (al-6) & 0x0f;
        SET_CFLAG_ON;
        SET_AUXFLAG_ON;
    } else {
        SET_CFLAG_OFF;
        SET_AUXFLAG_OFF;
        al &= 0xf;
    }
}
FRAG0(PushSsFrag)
{
    PUSH_LONG(SS);
}
FRAG0(PopSsFrag)
{
    DWORD temp;
    POP_LONG(temp);
    SS = (USHORT)temp;
}
FRAG0(PushDsFrag)
{
    PUSH_LONG(DS);
}
FRAG0(PopDsFrag)
{
    DWORD temp;
    POP_LONG(temp);
    DS = (USHORT)temp;
}
FRAG0(DaaFrag)
{
    if ((al & 0x0f) > 9 || GET_AUXFLAG) {
    al += 6;
    SET_AUXFLAG_ON;
    } else {
    SET_AUXFLAG_OFF;
    }
    if ((al & 0xf0) > 0x90 || GET_CFLAG) {
    al += 0x60;
    SET_CFLAG_ON;
    } else {
    SET_CFLAG_OFF;
    }
    SET_ZFLAG(al);
    SET_PFLAG(al);
    SET_SFLAG(al << (31-7)); // SET_SFLAG_IND(al & 0x80);
}
FRAG0(DasFrag)
{
    if ( (al & 0x0f) > 9 || GET_AUXFLAG) {
    al -= 6;
    SET_AUXFLAG_ON;
    } else {
    SET_AUXFLAG_OFF;
    }
    if ( al > 0x9f || GET_CFLAG) {
    al -= 0x60;
    SET_CFLAG_ON;
    } else {
    SET_CFLAG_OFF;
    }
    SET_ZFLAG(al);
    SET_PFLAG(al);
    SET_SFLAG(al << (31-7)); // SET_SFLAG_IND(al & 0x80);
}
FRAG0(AaaFrag)
{
    if ((al & 0x0f) > 9 || GET_AUXFLAG) {
        al=(al+6) & 0x0f;
        ah++;       // inc ah
        SET_AUXFLAG_ON;
        SET_CFLAG_ON;
    } else {
        SET_AUXFLAG_OFF;
        SET_CFLAG_OFF;
        al &= 0xf;
    }
}
FRAG1IMM(AadFrag, BYTE)
{
    al += ah * op1;
    ah = 0;
    SET_ZFLAG(al);
    SET_PFLAG(al);
    SET_SFLAG(al << (31-7)); // SET_SFLAG_IND(al & 0x80);
}
FRAG2(ImulFrag16, USHORT)
{
    Imul3ArgFrag16(cpu, pop1, GET_SHORT(pop1), op2);
}
FRAG2(ImulFrag16A, USHORT)
{
    Imul3ArgFrag16A(cpu, pop1, *pop1, op2);
}
FRAG3(Imul3ArgFrag16, USHORT, USHORT, USHORT)
{
    long result;

    result = (long)(short)op2 * (long)(short)op3;
    PUT_SHORT(pop1, (USHORT)(short)result);
    if (HIWORD(result) == 0 || HIWORD(result) == 0xffff) {
    SET_CFLAG_OFF;
    SET_OFLAG_OFF;
    } else {
    SET_CFLAG_ON;
    SET_OFLAG_ON;
    }
}
FRAG3(Imul3ArgFrag16A, USHORT, USHORT, USHORT)
{
    long result;

    result = (short)op2 * (short)op3;
    *pop1 = (USHORT)(short)result;
    if (HIWORD(result) == 0 || HIWORD(result) == 0xffff) {
    SET_CFLAG_OFF;
    SET_OFLAG_OFF;
    } else {
    SET_CFLAG_ON;
    SET_OFLAG_ON;
    }
}
FRAG2(ImulNoFlagsFrag16, USHORT)
{
    short op1 = (short)GET_SHORT(pop1);

    PUT_SHORT(pop1, (op2 * (short)op2));
}
FRAG2(ImulNoFlagsFrag16A, USHORT)
{
    *(short *)pop1 *= (short)op2;
}
FRAG3(Imul3ArgNoFlagsFrag16, USHORT, USHORT, USHORT)
{
    PUT_SHORT(pop1, ((short)op2 * (short)op3));
}
FRAG3(Imul3ArgNoFlagsFrag16A, USHORT, USHORT, USHORT)
{
    *pop1 = (USHORT)((short)op2 * (short)op3);
}
FRAG2(ImulFrag32, DWORD)
{
    Imul3ArgFrag32(cpu, pop1, GET_LONG(pop1), op2);
}
FRAG2(ImulFrag32A, DWORD)
{
    Imul3ArgFrag32A(cpu, pop1, *pop1, (long)op2);
}
FRAG3(Imul3ArgFrag32A, DWORD, DWORD, DWORD)
{
    LARGE_INTEGER result;
    LONGLONG ll;

    ll = Int32x32To64((long)op2, (long)op3);
    result = *(LARGE_INTEGER *)&ll;
    *pop1 = result.LowPart;
    if (result.HighPart == 0 || result.HighPart == 0xffffffff) {
    SET_CFLAG_OFF;
    SET_OFLAG_OFF;
    } else {
    SET_CFLAG_ON;
    SET_OFLAG_ON;
    }
}
FRAG3(Imul3ArgFrag32, DWORD, DWORD, DWORD)
{
    LARGE_INTEGER result;
    LONGLONG ll;

    ll = Int32x32To64((long)op2, (long)op3);
    result = *(LARGE_INTEGER *)&ll;
    PUT_LONG(pop1, result.LowPart);
    if (result.HighPart == 0 || result.HighPart == 0xffffffff) {
    SET_CFLAG_OFF;
    SET_OFLAG_OFF;
    } else {
    SET_CFLAG_ON;
    SET_OFLAG_ON;
    }
}
FRAG2(ImulNoFlagsFrag32, DWORD)
{
    long op1 = (LONG)GET_LONG(pop1);

    PUT_LONG(pop1, (op1 * (long)op2));
}
FRAG2(ImulNoFlagsFrag32A, DWORD)
{
    *(long *)pop1 *= (long)op2;
}
FRAG3(Imul3ArgNoFlagsFrag32A, DWORD, DWORD, DWORD)
{
    *pop1 = (DWORD)( (long)op2 * (long)op3);
}
FRAG3(Imul3ArgNoFlagsFrag32, DWORD, DWORD, DWORD)
{
    PUT_LONG(pop1, ((long)op2 * (long)op3));
}

FRAG0(SahfFrag)
{
    DWORD dw = (DWORD)ah;

    SET_CFLAG(dw << 31);         // CFLAG is low-bit of ah
    SET_PFLAG (!(dw & FLAG_PF)); // flag_pf contains an index into ParityBit[] array
    SET_AUXFLAG(dw);             // AUX bit is already in the right place
    SET_ZFLAG (!(dw & FLAG_ZF)); // zf has inverse logic
    SET_SFLAG(dw << (31-7));     // SFLAG is bit 7 in AH
}
FRAG0(LahfFrag)
{
    ah= 2 |                                 // this bit is always set on Intel
        ((GET_CFLAG) ? FLAG_CF : 0) |
        ((GET_PFLAG) ? FLAG_PF : 0) |
        ((GET_AUXFLAG)? FLAG_AUX: 0) |
        ((cpu->flag_zf) ? 0 : FLAG_ZF) |    // zf has inverse logic
        ((GET_SFLAG) ? FLAG_SF : 0);
}
FRAG1IMM(AamFrag, BYTE)
{
    ah = al / op1;
    al %= op1;
    SET_ZFLAG(al);
    SET_PFLAG(al);
    SET_SFLAG(al << (31-7));
}
FRAG0(XlatFrag)
{
    al = GET_BYTE(ebx+al);
}
FRAG0(CmcFrag)
{
    SET_CFLAG_IND(!GET_CFLAG);
}
FRAG0(ClcFrag)
{
    SET_CFLAG_OFF;
}
FRAG0(StcFrag)
{
    SET_CFLAG_ON;
}
FRAG0(CldFrag)
{
    cpu->flag_df = 1;
}
FRAG0(StdFrag)
{
    cpu->flag_df = 0xffffffff;
}
FRAG1(SetoFrag, BYTE)
{
    PUT_BYTE(pop1, (BYTE)GET_OFLAGZO);
}
FRAG1(SetnoFrag, BYTE)
{
    PUT_BYTE(pop1, (GET_OFLAG == 0));
}
FRAG1(SetbFrag, BYTE)
{
    PUT_BYTE(pop1, (BYTE)GET_CFLAGZO);
}
FRAG1(SetaeFrag, BYTE)
{
    PUT_BYTE(pop1, (GET_CFLAG == 0));
}
FRAG1(SeteFrag, BYTE)
{
    PUT_BYTE(pop1, (cpu->flag_zf == 0));  // inverse logic
}
FRAG1(SetneFrag, BYTE)
{
    PUT_BYTE(pop1, (cpu->flag_zf != 0));  // inverse logic
}
FRAG1(SetbeFrag, BYTE)
{
    PUT_BYTE(pop1, (GET_CFLAG || cpu->flag_zf == 0));  // inverse logic
}
FRAG1(SetaFrag, BYTE)
{
    PUT_BYTE(pop1, (GET_CFLAG == 0 && cpu->flag_zf != 0));  // inverse logic
}
FRAG1(SetsFrag, BYTE)
{
    PUT_BYTE(pop1, (BYTE)GET_SFLAGZO);
}
FRAG1(SetnsFrag, BYTE)
{
    PUT_BYTE(pop1, (GET_SFLAG == 0));
}
FRAG1(SetpFrag, BYTE)
{
    PUT_BYTE(pop1, (GET_PFLAG != 0));
}
FRAG1(SetnpFrag, BYTE)
{
    PUT_BYTE(pop1, (GET_PFLAG == 0));
}
FRAG1(SetlFrag, BYTE)
{
    PUT_BYTE(pop1, (GET_SFLAG != GET_OFLAG));
}
FRAG1(SetgeFrag, BYTE)
{
    PUT_BYTE(pop1, (GET_SFLAGZO == GET_OFLAGZO));
}
FRAG1(SetleFrag, BYTE)
{
    PUT_BYTE(pop1, (!cpu->flag_zf || (GET_SFLAG != GET_OFLAG))); // inverse logic
}
FRAG1(SetgFrag, BYTE)
{
    PUT_BYTE(pop1, (cpu->flag_zf && !(GET_SFLAG ^ GET_OFLAG)));    // inverse logic
}
FRAG2(Movzx8ToFrag16, USHORT)
{
    PUT_SHORT(pop1, (USHORT)(BYTE)op2);
}
FRAG2(Movzx8ToFrag16A, USHORT)
{
    *pop1 = (USHORT)(BYTE)op2;
}
FRAG2(Movsx8ToFrag16, USHORT)
{
    PUT_SHORT(pop1, (USHORT)(short)(char)(BYTE)op2);
}
FRAG2(Movsx8ToFrag16A, USHORT)
{
    *pop1 = (USHORT)(short)(char)(BYTE)op2;
}
FRAG2(Movzx8ToFrag32, DWORD)
{
    PUT_LONG(pop1, (DWORD)(BYTE)op2);
}
FRAG2(Movzx8ToFrag32A, DWORD)
{
    *pop1 = (DWORD)(BYTE)op2;
}
FRAG2(Movsx8ToFrag32, DWORD)
{
    PUT_LONG(pop1, (DWORD)(long)(char)(BYTE)op2);
}
FRAG2(Movsx8ToFrag32A, DWORD)
{
    *pop1 = (DWORD)(long)(char)(BYTE)op2;
}
FRAG2(Movzx16ToFrag32, DWORD)
{
    PUT_LONG(pop1, (DWORD)(USHORT)op2);
}
FRAG2(Movzx16ToFrag32A, DWORD)
{
    *pop1 = (DWORD)(USHORT)op2;
}
FRAG2(Movsx16ToFrag32, DWORD)
{
    PUT_LONG(pop1, (DWORD)(long)(short)(USHORT)op2);
}
FRAG2(Movsx16ToFrag32A, DWORD)
{
    *pop1 = (DWORD)(long)(short)(USHORT)op2;
}
FRAG1(BswapFrag32, DWORD)
{
    DWORD d;
    PBYTE pSrc = (PBYTE)pop1;

    d = (pSrc[0] << 24) | (pSrc[1] << 16) | (pSrc[2] << 8) | pSrc[3];
    // pop1 is always a pointer to a register, so an ALIGNED store is correct
    *pop1 = d;
}

FRAG2(ArplFrag, USHORT)
{
    USHORT op1 = GET_SHORT(pop1);

    op2 &= 3;              // just get the RPL bits of the selector
    if ((op1&3) < op2) {
        // RPL bits of DEST < RPL bits of SRC
        op1 = (op1 & ~3) | op2; // copy RPL bits from SRC to DEST
        PUT_SHORT(pop1, op1);   // store DEST
        SET_ZFLAG(0);           // ZF=1
    } else {
        SET_ZFLAG(1);
    }
}

FRAG1(VerrFrag, USHORT)
{
    USHORT op1 = GET_SHORT(pop1) & ~3;  // mask off RPL bits

    if (op1 == KGDT_R3_CODE ||          // CS: selector
        op1 == KGDT_R3_DATA ||          // DS:, SS:, ES: selector
        op1 == KGDT_R3_TEB              // FS: selector
       ) {
        SET_ZFLAG(0);       // ZF=1
    } else {
        SET_ZFLAG(1);       // ZF=0
    }
}

FRAG1(VerwFrag, USHORT)
{
    USHORT op1 = GET_SHORT(pop1) & ~3;  // mask off RPL bits

    if (op1 == KGDT_R3_DATA ||          // DS:, SS:, ES: selector
        op1 == KGDT_R3_TEB              // FS: selector
       ) {
        SET_ZFLAG(0);       // ZF=1
    } else {
        SET_ZFLAG(1);       // ZF=0
    }
}

FRAG1(SmswFrag, USHORT)
{
    //
    // This value is empirically discovered by running it on a Pentium
    // machine.  CR0_PE, CR0_EX, and CR0_NE bits were set, and all others
    // notably CR0_MP, are clear.
    //
    PUT_SHORT(pop1, 0x31);
}

#if MSCPU
FRAG0(IntOFrag)
{
    if (GET_OFLAG) {
        Int4();     // raise overflow
    }
}
FRAG0(NopFrag)
{
}
FRAG0(PrivilegedInstructionFrag)
{
    PRIVILEGED_INSTR;
}
FRAG0(BadInstructionFrag)
{
    Int6();     // Throw invalid opcode exception
}
FRAG2(FaultFrag, DWORD)
{
    // pop1 = exception code
    // op2  = address where fault occurred
#if DBG
    LOGPRINT((TRACELOG, "CPU: FaultFrag called\r\n"));
#endif

    RtlRaiseStatus((NTSTATUS)(ULONGLONG)pop1);   
}
#endif //MSCPU
FRAG0(CPUID)
{
    switch (eax) {
    case 0:
        eax = 1;            // We are a 486 with CPUID (PPro returns 2)
        //ebx = 0x756e6547;   // "GenuineIntel"
        //edx = 0x49656e69;
        //ecx = 0x6c65746e;
        ebx = 0x7263694d;   // "Micr" with M in the low nibble of BL
        edx = 0x666f736f;   // "osof" with o in the low nibble of DL
        ecx = 0x55504374;   // "tCPU" with t in the low nibble of CL
        break;

    case 1:
        eax = (0 << 12) |   // Type   = 0 (2 bits) Original OEM Processor
              (4 << 8) |    // Family = 4 (4 bits) 80486
              (1 << 4) |    // Model  = 1 (4 bits)
              0;            // Stepping=0 (4 bits)
        edx = (fUseNPXEM) ? 1: 0;   // bit 0:  FPU on-chip.  wx86cpu doesn't
                                    // support any other features.
        break;

    default:
        //
        // The Intel behavior indicates that if eax is out-of-range, the
        // results returned in the regsiters are unpredictable but it
        // doesn't fault.
        //
        break;
    }
}
FRAG2REF(CmpXchg8bFrag32, ULONGLONG)
{
    ULONGLONG EdxEax;
    ULONGLONG Value;

    EdxEax = (((ULONGLONG)edx) << 32) | (ULONGLONG)eax;
    Value = *(ULONGLONG UNALIGNED *)pop1;

    if (Value == EdxEax) {
    ULONGLONG EcxEbx;

    EcxEbx = (ULONGLONG)ecx << 32 | (ULONGLONG)ebx;
    *(ULONGLONG UNALIGNED *)pop1 = EcxEbx;
        SET_ZFLAG(0);       // zf has inverse logic
    } else {
    eax = (ULONG)Value;
    edx = (ULONG)(Value >> 32);
        SET_ZFLAG(1);       // zf has inverse logic
    }
}
FRAG0(Rdtsc)
{
    LARGE_INTEGER Counter;

    // This is cheese, but it will at least return a value that increases
    // over time.
    NtQueryPerformanceCounter(&Counter, NULL);
    edx = Counter.HighPart;
    eax = Counter.LowPart;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\frag8.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    frag8.h

Abstract:
    
    Prototypes for instruction fragments which operate on 8-bit BYTES.

Author:

    12-Jun-1995 BarryBo, Created

Revision History:

--*/

#ifndef FRAG8_H
#define FRAG8_H

#define FRAGCOMMON0(fn)     FRAG0(fn ## 8)
#define FRAGCOMMON1(fn)     FRAG1(fn ## 8, BYTE)
#define FRAGCOMMON1IMM(fn)  FRAG1IMM( fn ## 8, BYTE)
#define FRAGCOMMON2IMM(fn)  FRAG2IMM( fn ## 8, BYTE, BYTE)
#define FRAGCOMMON2(fn)     FRAG2(fn ## 8, BYTE)
#define FRAGCOMMON2REF(fn)  FRAG2REF(fn ## 8, BYTE)
#define FRAGCOMMON3(fn)     FRAG3(fn ## 8, BYTE, BYTE, BYTE)
#include "shared.h"
#include "shareda.h"
#undef FRAGCOMMON0
#undef FRAGCOMMON1
#undef FRAGCOMMON1IMM
#undef FRAGCOMMON2IMM
#undef FRAGCOMMON2
#undef FRAGCOMMON2REF
#undef FRAGCOMMON3

#endif //FRAG8_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\fragp.h ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    fragp.h

Abstract:
    
    Private exports, defines for shared code fragments.

Author:

    12-Jun-1995 BarryBo, Created

Revision History:

--*/

#include "cpumain.h"

#ifndef FRAGP_H
#define FRAGP_H

#include "fraglib.h"
#include "eflags.h"

//
// This function patches a call to pass the mips address corresponding to
// intelAddr directly to the call fragments.
//
PULONG
patchCallRoutine(
    IN PULONG intelAddr,
    IN PULONG patchAddr
    );

//
// Table mapping a byte to a 0 or 1, corresponding to the parity bit for
// that byte.
//
extern const BYTE ParityBit[256];

#if _ALPHA_
// defined in fraginit.c, used in the Alpha code generator
extern DWORD fByteInstructionsOK;
#endif

#ifdef MSCCPU

#define eax     cpu->GpRegs[GP_EAX].i4
#define ebx     cpu->GpRegs[GP_EBX].i4
#define ecx     cpu->GpRegs[GP_ECX].i4
#define edx     cpu->GpRegs[GP_EDX].i4
#define esp     cpu->GpRegs[GP_ESP].i4
#define ebp     cpu->GpRegs[GP_EBP].i4
#define esi     cpu->GpRegs[GP_ESI].i4
#define edi     cpu->GpRegs[GP_EDI].i4
#define eip     cpu->eipReg.i4
#define eipTemp cpu->eipTempReg.i4

#define ax      cpu->GpRegs[GP_EAX].i2
#define bx      cpu->GpRegs[GP_EBX].i2
#define cx      cpu->GpRegs[GP_ECX].i2
#define dx      cpu->GpRegs[GP_EDX].i2
#define sp      cpu->GpRegs[GP_ESP].i2
#define bp      cpu->GpRegs[GP_EBP].i2
#define si      cpu->GpRegs[GP_ESI].i2
#define di      cpu->GpRegs[GP_EDI].i2

#define al      cpu->GpRegs[GP_EAX].i1
#define bl      cpu->GpRegs[GP_EBX].i1
#define cl      cpu->GpRegs[GP_ECX].i1
#define dl      cpu->GpRegs[GP_EDX].i1

#define ah      cpu->GpRegs[GP_EAX].hb
#define bh      cpu->GpRegs[GP_EBX].hb
#define ch      cpu->GpRegs[GP_ECX].hb
#define dh      cpu->GpRegs[GP_EDX].hb

#define CS      cpu->cs
#define DS      cpu->ds
#define ES      cpu->es
#define SS      cpu->ss
#define FS      cpu->fs
#define GS      cpu->gs


#define CPUDATA  CPUCONTEXT
#define PCPUDATA PCPUCONTEXT

#else   //!MSCCPU

#define eax     cpu->GpRegs[GP_EAX].i4
#define ebx     cpu->GpRegs[GP_EBX].i4
#define ecx     cpu->GpRegs[GP_ECX].i4
#define edx     cpu->GpRegs[GP_EDX].i4
#define esp     cpu->GpRegs[GP_ESP].i4
#define ebp     cpu->GpRegs[GP_EBP].i4
#define esi     cpu->GpRegs[GP_ESI].i4
#define edi     cpu->GpRegs[GP_EDI].i4
#define eip     cpu->eipReg.i4
#define eipTemp cpu->eipTempReg.i4

#define ax      cpu->GpRegs[GP_EAX].i2
#define bx      cpu->GpRegs[GP_EBX].i2
#define cx      cpu->GpRegs[GP_ECX].i2
#define dx      cpu->GpRegs[GP_EDX].i2
#define sp      cpu->GpRegs[GP_ESP].i2
#define bp      cpu->GpRegs[GP_EBP].i2
#define si      cpu->GpRegs[GP_ESI].i2
#define di      cpu->GpRegs[GP_EDI].i2

#define al      cpu->GpRegs[GP_EAX].i1
#define bl      cpu->GpRegs[GP_EBX].i1
#define cl      cpu->GpRegs[GP_ECX].i1
#define dl      cpu->GpRegs[GP_EDX].i1

#define ah      cpu->GpRegs[GP_EAX].hb
#define bh      cpu->GpRegs[GP_EBX].hb
#define ch      cpu->GpRegs[GP_ECX].hb
#define dh      cpu->GpRegs[GP_EDX].hb

#define CS      cpu->GpRegs[REG_CS].i2
#define DS      cpu->GpRegs[REG_DS].i2
#define ES      cpu->GpRegs[REG_ES].i2
#define SS      cpu->GpRegs[REG_SS].i2
#define FS      cpu->GpRegs[REG_FS].i2
#define GS      cpu->GpRegs[REG_GS].i2

#define CPUDATA  THREADSTATE
#define PCPUDATA PTHREADSTATE

#endif  //!MSCCPU

#define MSB32   0x80000000

#define SET_FLAG(flag, b)    flag = (DWORD)b
#define SET_CFLAG(b)	     SET_FLAG(cpu->flag_cf, (b))
#define SET_PFLAG(b)	     SET_FLAG(cpu->flag_pf, (b))
#define SET_AUXFLAG(b)	     SET_FLAG(cpu->flag_aux,(b))
#define SET_ZFLAG(b)         SET_FLAG(cpu->flag_zf, (b))
#define SET_SFLAG(b)	     SET_FLAG(cpu->flag_sf, (b))
// SET_DFLAG is special
#define SET_OFLAG(b)	     SET_FLAG(cpu->flag_of, (b))
#define SET_TFLAG(b)	     SET_FLAG(cpu->flag_tf, (b))
#define SET_RFLAG(b)   //UNDONE: not used until 386 debug registers implemented

#define AUX_VAL             0x10
#define GET_AUXFLAG         (cpu->flag_aux & AUX_VAL)
#define SET_AUXFLAG_ON      SET_AUXFLAG(AUX_VAL)
#define SET_AUXFLAG_OFF     SET_AUXFLAG(0x0)

#define GET_OFLAG           (cpu->flag_of & MSB32)
#define GET_OFLAGZO         (cpu->flag_of >> 31)
#define SET_OFLAG_ON        SET_OFLAG(MSB32)
#define SET_OFLAG_OFF       SET_OFLAG(0)
#define SET_OFLAG_IND(b)    SET_OFLAG(b ? MSB32 : 0)

#define GET_CFLAG           (cpu->flag_cf & MSB32)
#define GET_CFLAGZO         (cpu->flag_cf >> 31)
#define SET_CFLAG_ON        SET_CFLAG(MSB32)
#define SET_CFLAG_OFF       SET_CFLAG(0)
#define SET_CFLAG_IND(b)    SET_CFLAG(b ? MSB32 : 0)

#define GET_SFLAG           (cpu->flag_sf & MSB32)
#define GET_SFLAGZO         (cpu->flag_sf >> 31)
#define SET_SFLAG_ON        SET_SFLAG(MSB32)
#define SET_SFLAG_OFF       SET_SFLAG(0)
#define SET_SFLAG_IND(b)    SET_SFLAG(b ? MSB32 : 0)

#define GET_PFLAG           (ParityBit[cpu->flag_pf & 0xff])


#define GET_BYTE(addr)       (*(UNALIGNED unsigned char *)(addr))
#define GET_SHORT(addr)      (*(UNALIGNED unsigned short *)(addr))
#define GET_LONG(addr)       (*(UNALIGNED unsigned long *)(addr))

#define PUT_BYTE(addr,dw)    {GET_BYTE(addr)=dw;}
#define PUT_SHORT(addr,dw)   {GET_SHORT(addr)=dw;}
#define PUT_LONG(addr,dw)    {GET_LONG(addr)=dw;}

typedef void (*pfnFrag0)(PCPUDATA);
typedef void (*pfnFrag18)(PCPUDATA, BYTE *);
typedef void (*pfnFrag116)(PCPUDATA, USHORT *);
typedef void (*pfnFrag132)(PCPUDATA, DWORD *);
typedef void (*pfnFrag28)(PCPUDATA, BYTE *, BYTE);
typedef void (*pfnFrag216)(PCPUDATA, USHORT *, USHORT);
typedef void (*pfnFrag232)(PCPUDATA, DWORD *, DWORD);
typedef void (*pfnFrag38)(PCPUDATA, BYTE *, BYTE, BYTE);
typedef void (*pfnFrag316)(PCPUDATA, USHORT *, USHORT, USHORT);
typedef void (*pfnFrag332)(PCPUDATA, DWORD *, DWORD, DWORD);

/*---------------------------------------------------------------------*/
extern void CpupUnlockTCAndDoInterrupt(PTHREADSTATE cpu, int Interrupt);

#define Int0()              CpupUnlockTCAndDoInterrupt(cpu, 0)   // Divide error
#define Int3()              CpupUnlockTCAndDoInterrupt(cpu, 3)   // Breakpoint
#define Int4()              CpupUnlockTCAndDoInterrupt(cpu, 4)   // Overflow
#define Int5()              CpupUnlockTCAndDoInterrupt(cpu, 5)   // Bound check
#define Int6()              CpupUnlockTCAndDoInterrupt(cpu, 6)   // Invalid opcode
#define Int8()              CpupUnlockTCAndDoInterrupt(cpu, 8)   // Double fault
#define Int13(sel)          CpupUnlockTCAndDoInterrupt(cpu, 13)  // General protection

#define PRIVILEGED_INSTR        Int13(0)
#define BREAKPOINT_INSTR        Int3()
#define OVERFLOW_INSTR          Int4()

/*---------------------------------------------------------------------*/

#define PUSH_LONG(dw) {     \
    DWORD NewEsp = esp-4;   \
    *(DWORD *)(NewEsp) = (DWORD)(dw); \
    esp=NewEsp;             \
    }

#define POP_LONG(dw)  {     \
    DWORD espTemp = esp;    \
    (dw)=*(DWORD *)espTemp; \
    esp=espTemp+4;          \
    }

#define PUSH_SHORT(s) {     \
    DWORD NewEsp = esp-2;   \
    *(USHORT *)(NewEsp)=(USHORT)(s); \
    esp=NewEsp;                 \
    }

#define POP_SHORT(s) {      \
    DWORD espTemp = esp;    \
    (s)=*(USHORT *)espTemp; \
    esp=espTemp+2;          \
    }

#define XCHG(t, r1, r2) {   \
    t temp;		    \
    temp = r1;		    \
    r1=r2;		    \
    r2=temp;		    \
    }

#define XCHG_MEM(t, m1, m2) { \
    t temp;		    \
    temp = *m1; 	    \
    *m1 = *m2;		    \
    *m2 = temp; 	    \
    }

#define do_j_b(f) {         \
    if (cpu->AdrPrefix) {                           \
        if (f) {                                    \
            cpu->eipTempReg.i2+=(char)GET_BYTE(eipTemp+1)+2;   \
        } else {                                    \
            cpu->eipTempReg.i2+=2;                  \
        }                                           \
        cpu->AdrPrefix = PREFIX_NONE;               \
    } else {                                        \
        if (f) {                                    \
            eipTemp+=(char)GET_BYTE(eipTemp+1)+2;   \
        } else {                                    \
            eipTemp+=2;                             \
        }                                           \
    }                                               \
}

#define DO_J(f) {           \
    if (cpu->AdrPrefix) {                                       \
        if (f) {                                                \
            cpu->eipTempReg.i2+=(STYPE)GET_VAL(eipTemp+1)+1+sizeof(UTYPE); \
        } else {                                                \
            cpu->eipTempReg.i2+=1+sizeof(UTYPE);                \
        }                                                       \
        cpu->AdrPrefix = PREFIX_NONE;                           \
    } else {                                                    \
        if (f) {                                                \
            eipTemp+=(STYPE)GET_VAL(eipTemp+1)+1+sizeof(UTYPE); \
        } else {                                                \
            eipTemp+=1+sizeof(UTYPE);                           \
        }                                                       \
    }                                                           \
}

#define SET_FLAGS_ADD32(r, op1, op2, msb) {                             \
    DWORD carry = (op1) ^ (op2) ^ (r);                                  \
    /* next line is different for ADD/SUB */                            \
    SET_OFLAG(~((op1) ^ (op2)) & ((op2) ^ (r)));                        \
    SET_CFLAG(carry ^ cpu->flag_of);                                    \
    SET_ZFLAG((r));                                                     \
    SET_SFLAG((r));                                                     \
    SET_PFLAG((r));                                                     \
    SET_AUXFLAG(carry);                                                 \
    }

#define SET_FLAGS_ADD16(r, op1, op2, msb) {                             \
    DWORD carry = (op1) ^ (op2) ^ (r);                                  \
    /* next line is different for ADD/SUB */                            \
    SET_OFLAG((~((op1) ^ (op2)) & ((op2) ^ (r))) << 16);                \
    SET_CFLAG((carry<<16) ^ cpu->flag_of);                              \
    SET_ZFLAG((r));                                                     \
    SET_PFLAG((r));                                                     \
    SET_SFLAG((r) << 16);                                               \
    SET_AUXFLAG(carry);                                                 \
    }

#define SET_FLAGS_ADD8(r, op1, op2, msb) {                              \
    DWORD carry = (op1) ^ (op2) ^ (r);                                  \
    /* next line is different for ADD/SUB */                            \
    SET_OFLAG((~((op1) ^ (op2)) & ((op2) ^ (r))) << 24);                \
    SET_CFLAG((carry<<24) ^ cpu->flag_of);                              \
    SET_ZFLAG((r));                                                     \
    SET_SFLAG((r) << 24);                                               \
    SET_AUXFLAG(carry);                                                 \
    SET_PFLAG((r));                                                     \
    }

#define SET_FLAGS_SUB32(r, op1, op2, msb) {                             \
    DWORD carry = (op1) ^ (op2) ^ (r);                                  \
    /* next line is different for ADD/SUB */                            \
    SET_OFLAG(((op1) ^ (op2)) & ((op1) ^ (r)));                         \
    SET_CFLAG(carry ^ cpu->flag_of);                                    \
    SET_ZFLAG((r));                                                     \
    SET_SFLAG((r));                                                     \
    SET_AUXFLAG(carry);                                                 \
    SET_PFLAG((r));                                                     \
    }

#define SET_FLAGS_SUB16(r, op1, op2, msb) {                             \
    DWORD carry = (op1) ^ (op2) ^ (r);                                  \
    /* next line is different for ADD/SUB */                            \
    SET_OFLAG((((op1) ^ (op2)) & ((op1) ^ (r))) << 16);                 \
    SET_CFLAG((carry<<16) ^ cpu->flag_of);                              \
    SET_ZFLAG((r));                                                     \
    SET_SFLAG((r) << 16);                                               \
    SET_AUXFLAG(carry);                                                 \
    SET_PFLAG((r));                                                     \
    }

#define SET_FLAGS_SUB8(r, op1, op2, msb) {                              \
    DWORD carry = (op1) ^ (op2) ^ (r);                                  \
    /* next line is different for ADD/SUB */                            \
    SET_OFLAG((((op1) ^ (op2)) & ((op1) ^ (r))) << 24);                 \
    SET_CFLAG((carry<<24) ^ cpu->flag_of);                              \
    SET_ZFLAG((r));                                                     \
    SET_SFLAG((r) << 24);                                               \
    SET_AUXFLAG(carry);                                                 \
    SET_PFLAG((r));                                                     \
    }

#define SET_FLAGS_INC32(r, op1) {                                       \
    DWORD carry = (op1) ^ 1 ^ (r);                                      \
    /* next line is different for INC/DEC */                            \
    SET_OFLAG(~((op1) ^ 1) & (1 ^ (r)));                                \
    SET_ZFLAG((r));                                                     \
    SET_SFLAG((r));                                                     \
    SET_PFLAG((r));                                                     \
    SET_AUXFLAG(carry);                                                 \
    }

#define SET_FLAGS_INC16(r, op1) {                                       \
    DWORD carry = (op1) ^ 1 ^ (r);                                      \
    /* next line is different for INC/DEC */                            \
    SET_OFLAG((~((op1) ^ 1) & (1 ^ (r))) << 16);                        \
    SET_ZFLAG((r));                                                     \
    SET_PFLAG((r));                                                     \
    SET_SFLAG((r) << 16);                                               \
    SET_AUXFLAG(carry);                                                 \
    }

#define SET_FLAGS_INC8(r, op1) {                                        \
    DWORD carry = (op1) ^ 1 ^ (r);                                      \
    /* next line is different for INC/DEC */                            \
    SET_OFLAG((~((op1) ^ 1) & (1 ^ (r))) << 24);                        \
    SET_ZFLAG((r));                                                     \
    SET_SFLAG((r) << 24);                                               \
    SET_PFLAG((r));                                                     \
    SET_AUXFLAG(carry);                                                 \
    }

#define SET_FLAGS_DEC32(r, op1) {                                       \
    DWORD carry = (op1) ^ 1 ^ (r);                                      \
    /* next line is different for INC/DEC */                            \
    SET_OFLAG(((op1) ^ 1) & ((op1) ^ (r)));                             \
    SET_ZFLAG((r));                                                     \
    SET_SFLAG((r));                                                     \
    SET_PFLAG((r));                                                     \
    SET_AUXFLAG(carry);                                                 \
    }

#define SET_FLAGS_DEC16(r, op1) {                                       \
    DWORD carry = (op1) ^ 1 ^ (r);                                      \
    /* next line is different for INC/DEC */                            \
    SET_OFLAG((((op1) ^ 1) & ((op1) ^ (r))) << 16);                     \
    SET_ZFLAG((r));                                                     \
    SET_SFLAG((r) << 16);                                               \
    SET_PFLAG((r));                                                     \
    SET_AUXFLAG(carry);                                                 \
    }

#define SET_FLAGS_DEC8(r, op1) {                                        \
    DWORD carry = (op1) ^ 1 ^ (r);                                      \
    /* next line is different for INC/DEC */                            \
    SET_OFLAG((((op1) ^ 1) & ((op1) ^ (r))) << 24);                     \
    SET_ZFLAG((r));                                                     \
    SET_SFLAG((r) << 24);                                               \
    SET_PFLAG((r));                                                     \
    SET_AUXFLAG(carry);                                                 \
    }


VOID    CpuRaiseStatus( NTSTATUS Status );

#endif //FRAGP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\frag8.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    frag8.c

Abstract:
    
    Instuction fragments which operate on BYTES

Author:

    12-Jun-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "fragp.h"
#include "frag8.h"

// set up to include common functions
#define MSB		    0x80
#define LMB                 7   // Left Most Bit
#define UTYPE		    unsigned char
#define STYPE		    signed char
#define GET_VAL 	    GET_BYTE
#define PUT_VAL 	    PUT_BYTE
#define FRAGCOMMON0(fn)     FRAG0(fn ## 8)
#define FRAGCOMMON1(fn)     FRAG1(fn ## 8, UTYPE)
#define FRAGCOMMON1IMM(fn)  FRAG1IMM( fn ## 8, UTYPE)
#define FRAGCOMMON2IMM(fn)  FRAG2IMM( fn ## 8, UTYPE, UTYPE)
#define FRAGCOMMON2(fn)     FRAG2(fn ## 8, UTYPE)
#define FRAGCOMMON2REF(fn)  FRAG2REF(fn ## 8, UTYPE)
#define FRAGCOMMON3(fn)     FRAG3(fn ## 8, UTYPE, UTYPE, UTYPE)
#define AREG                al
#define BREG		    bl
#define CREG		    cl
#define DREG		    dl
#define SET_FLAGS_ADD       SET_FLAGS_ADD8
#define SET_FLAGS_SUB       SET_FLAGS_SUB8
#define SET_FLAGS_INC       SET_FLAGS_INC8
#define SET_FLAGS_DEC       SET_FLAGS_DEC8

// include the common functions
#include "shared.c"
#include "shareda.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\fraglib.h ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    fraglib.h

Abstract:
    
    Public interface to the fragment library.

Author:

    12-Jun-1995 BarryBo, Created

Revision History:

--*/

#ifndef FRAGLIB_H
#define FRAGLIB_H

#ifdef MSCCPU
#include "ccpu.h"
#define FRAG0(x)                        void x(PCPUCONTEXT cpu)
#define FRAG1(x, t)                     void x(PCPUCONTEXT cpu, t *pop1)
#define FRAG1IMM(x, t)                  void x(PCPUCONTEXT cpu, t op1)
#define FRAG2(x, t)                     void x(PCPUCONTEXT cpu, t *pop1, t op2)
#define FRAG2REF(x, t)                  void x(PCPUCONTEXT cpu, t *pop1, t *pop2)
#define FRAG2IMM(x, t1, t2)             void x(PCPUCONTEXT cpu, t1 op1, t2 op2)
#define FRAG3(x, t1, t2, t3)            void x(PCPUCONTEXT cpu, t1 *pop1, t2 op2, t3 op3)
#else
#include "threadst.h"
#define FRAGCONTROLTRANSFER(x)          ULONG x(PTHREADSTATE cpu)
#define FRAG0(x)                        void x(PTHREADSTATE cpu)
#define FRAG1(x, t)                     void x(PTHREADSTATE cpu, t *pop1)
#define FRAG1IMM(x, t)                  void x(PTHREADSTATE cpu, t op1)
#define FRAG2(x, t)                     void x(PTHREADSTATE cpu, t *pop1, t op2)
#define FRAG2REF(x, t)                  void x(PTHREADSTATE cpu, t *pop1, t *pop2)
#define FRAG2IMM(x, t1, t2)             void x(PTHREADSTATE cpu, t1 op1, t2 op2)
#define FRAG3(x, t1, t2, t3)            void x(PTHREADSTATE cpu, t1 *pop1, t2 op2, t3 op3)
#endif

//
// Function for initializing the fragment library
//
BOOL
FragLibInit(
    PCPUCONTEXT cpu,
    DWORD StackBase
    );


#define CALLFRAG0(x)                    x(cpu)
#define CALLFRAG1(x, pop1)              x(cpu, pop1)
#define CALLFRAG2(x, pop1, op2)         x(cpu, pop1, op2)
#define CALLFRAG3(x, pop1, op2, op3)    x(cpu, pop1, op2, op3)

#include "fragmisc.h"
#include "frag8.h"
#include "frag16.h"
#include "frag32.h"
#include "fpufrags.h"
#include "lock.h"
#include "synlock.h"

//
// Table mapping a byte to a 0 or 1, corresponding to the parity bit for
// that byte.
//
extern const BYTE ParityBit[256];

// These fragments are used only by the compiler
#ifdef MSCPU
#include "ctrltrns.h"
#include "optfrag.h"
#endif

#endif //FRAGLIB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\fraginit.c ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name: 

    fraginit.c

Abstract:
    
    Initialization, termination, and CPU interface functions

Author:

    25-Aug-1995 BarryBo

Revision History:

--*/
 
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>

#define _WX86CPUAPI_
#include "wx86.h"
#include "wx86nt.h"
#include "wx86cpu.h"
#include "cpuassrt.h"
#ifdef MSCCPU
#include "ccpu.h"
#include "msccpup.h"
#undef GET_BYTE
#undef GET_SHORT
#undef GET_LONG
#else
#include "threadst.h"
#include "instr.h"
#include "frag.h"
ASSERTNAME;
#endif
#include "fragp.h"


//
// Table mapping a byte to a 0 or 1, corresponding to the parity bit for
// that byte.
//
const BYTE ParityBit[] = {
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1
};

#if _ALPHA_
//
// TRUE if the CPU should generate the new LDB/STB instructions for accessing
// data less than one DWORD long or when accessing unaligned data.
//
DWORD fByteInstructionsOK;
#endif


int *
_errno(
    )
/*++

Routine Description:

    Stub function so the CPU can pull in floating-point CRT support
    without the C startup code.

Arguments:

    None.
    
Return Value:

    Pointer to per-thread [actually per-fiber] errno value.

--*/
{
    DECLARE_CPU;

    return &cpu->ErrnoVal;
}

BOOL
FragLibInit(
    PCPUCONTEXT cpu,
    DWORD StackBase
    )
/*++

Routine Description:

    This routine initializes the fragment library.

Arguments:

    cpu - per-thread CPU data
    StackBase - initial ESP value
    
Return Value:

    True if successful.

--*/
{
    //
    // Initialize the 487 emulator
    //
    FpuInit(cpu);

    //
    // Initialize all non-zero fields in the cpu
    //
    cpu->flag_df = 1;       // direction flag is initially UP
    cpu->flag_if = 1;       // enable interrupts
    ES = SS = DS = KGDT_R3_DATA+3;
    CS = KGDT_R3_CODE+3;
    FS = KGDT_R3_TEB+3;
    esp = StackBase;        // set up the initial ESP value

#if _ALPHA_
    //
    // See if LDB/STB instructions are implemented.
    //
    fByteInstructionsOK = (DWORD)ProxyIsProcessorFeaturePresent(
                                    PF_ALPHA_BYTE_INSTRUCTIONS);
#endif

    return TRUE;
}


DWORD GetEax(PVOID CpuContext)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    return eax;
}
DWORD GetEbx(PVOID CpuContext)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    return ebx;
}
DWORD GetEcx(PVOID CpuContext)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    return ecx;
}
DWORD GetEdx(PVOID CpuContext)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    return edx;
}
DWORD GetEsp(PVOID CpuContext)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    return esp;
}
DWORD GetEbp(PVOID CpuContext)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    return ebp;
}
DWORD GetEsi(PVOID CpuContext)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    return esi;
}
DWORD GetEdi(PVOID CpuContext)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    return edi;
}
DWORD GetEip(PVOID CpuContext)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    return eip;
}
void SetEax(PVOID CpuContext, DWORD dw)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    eax = dw;
}
void SetEbx(PVOID CpuContext, DWORD dw)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    ebx = dw;
}
void SetEcx(PVOID CpuContext, DWORD dw)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    ecx = dw;
}
void SetEdx(PVOID CpuContext, DWORD dw)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    edx = dw;
}
void SetEsp(PVOID CpuContext, DWORD dw)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    esp = dw;
}
void SetEbp(PVOID CpuContext, DWORD dw)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    ebp = dw;
}
void SetEsi(PVOID CpuContext, DWORD dw)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    esi = dw;
}
void SetEdi(PVOID CpuContext, DWORD dw)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    edi = dw;
}
void SetEip(PVOID CpuContext, DWORD dw)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    eip = dw;
}
VOID SetCs(PVOID CpuContext, USHORT us)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    CS = us;
}
VOID SetSs(PVOID CpuContext, USHORT us)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    SS = us;
}
VOID SetDs(PVOID CpuContext, USHORT us)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    DS = us;
}
VOID SetEs(PVOID CpuContext, USHORT us)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    ES = us;
}
VOID SetFs(PVOID CpuContext, USHORT us)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    FS = us;
}
VOID SetGs(PVOID CpuContext, USHORT us)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    GS = us;
}
USHORT GetCs(PVOID CpuContext)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    return CS;
}
USHORT GetSs(PVOID CpuContext)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    return SS;
}
USHORT GetDs(PVOID CpuContext)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    return DS;
}
USHORT GetEs(PVOID CpuContext)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    return ES;
}
USHORT GetFs(PVOID CpuContext)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    return FS;
}
USHORT GetGs(PVOID CpuContext)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    return GS;
}
ULONG GetEfl(PVOID CpuContext)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    DWORD dw;

    dw = ((GET_CFLAG) ? FLAG_CF : 0)
     | 2
     | 3 << 12     // iopl
     | ((GET_AUXFLAG) ? FLAG_AUX : 0)
     | ((GET_PFLAG) ? FLAG_PF : 0)
     | ((cpu->flag_zf) ? 0 : FLAG_ZF)   // zf has inverse logic
     | ((GET_SFLAG) ? FLAG_SF : 0)
     | ((cpu->flag_tf) ? FLAG_TF : 0)
     | ((cpu->flag_if) ? FLAG_IF : 0)
     | ((cpu->flag_df == -1) ? FLAG_DF : 0)
     | ((GET_OFLAG) ? FLAG_OF : 0)
     | cpu->flag_ac;

    return dw;
}
void  SetEfl(PVOID CpuContext, ULONG RegValue)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;

    // IOPL, IF, NT, RF, VM, AC ignored.

    SET_CFLAG_IND(RegValue & FLAG_CF);
    cpu->flag_pf = (RegValue & FLAG_PF) ? 0 : 1;    // see ParityBit[] table
    cpu->flag_aux= (RegValue & FLAG_AUX) ? AUX_VAL : 0;
    cpu->flag_zf = (RegValue & FLAG_ZF) ? 0 : 1;    // inverse logic
    SET_SFLAG_IND(RegValue & FLAG_SF);
    cpu->flag_tf = (RegValue & FLAG_TF) ? 1 : 0;
    cpu->flag_df = (RegValue & FLAG_DF) ? -1 : 1;
    SET_OFLAG_IND(RegValue & FLAG_OF);
    cpu->flag_ac = (RegValue & FLAG_AC);
}


#if DBG
VOID
DoAssert(
    PSZ exp,
    PSZ msg,
    PSZ mod,
    INT line
    )
{
    if (msg) {
        LOGPRINT((ERRORLOG, "CPU ASSERTION FAILED:\r\n  %s\r\n%s\r\nFile: %s Line %d\r\n", msg, exp, mod, line));
    } else {
        LOGPRINT((ERRORLOG, "CPU ASSERTION FAILED:\r\n  %s\r\nFile: %s Line %d\r\n", exp, mod, line));
    }

    DbgBreakPoint();
}
#endif  //DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\lock.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    lock.h

Abstract:
    
    Prototypes for lock instructions

Author:

    15-Aug-1995 t-orig (Ori Gershony)

Revision History:

--*/



// Macros for prototyping the lock helper functions
#define LOCKHELPER0(fn)             ULONG fn ## LockHelper ()
#define LOCKHELPER1(fn,a1)          ULONG fn ## LockHelper (a1)
#define LOCKHELPER2(fn,a1,a2)       ULONG fn ## LockHelper (a1,a2)
#define LOCKHELPER3(fn,a1,a2,a3)    ULONG fn ## LockHelper (a1,a2,a3)
#define LOCKHELPER4(fn,a1,a2,a3,a4) ULONG fn ## LockHelper (a1,a2,a3,a4)


// The lock fragments
FRAG2(LockAddFrag32, ULONG);
FRAG2(LockOrFrag32, ULONG);
FRAG2(LockAdcFrag32, ULONG);
FRAG2(LockSbbFrag32, ULONG);
FRAG2(LockAndFrag32, ULONG);
FRAG2(LockSubFrag32, ULONG);
FRAG2(LockXorFrag32, ULONG);
FRAG1(LockNotFrag32, ULONG);
FRAG1(LockNegFrag32, ULONG);
FRAG1(LockIncFrag32, ULONG);
FRAG1(LockDecFrag32, ULONG);
FRAG2(LockBtsMemFrag32, ULONG);
FRAG2(LockBtsRegFrag32, ULONG);
FRAG2(LockBtrMemFrag32, ULONG);
FRAG2(LockBtrRegFrag32, ULONG);
FRAG2(LockBtcMemFrag32, ULONG);
FRAG2(LockBtcRegFrag32, ULONG);
FRAG2REF(LockXchgFrag32, ULONG);
FRAG2REF(LockXaddFrag32, ULONG);
FRAG2REF(LockCmpXchgFrag32, ULONG);
FRAG2REF(LockCmpXchg8bFrag32, ULONGLONG);


// The lock helper functions
LOCKHELPER3(Add, ULONG *localpop1, ULONG *pop1, ULONG op2); 
LOCKHELPER2(Or, ULONG *pop1, ULONG op2); 
LOCKHELPER4(Adc, ULONG *localpop1, ULONG *pop1, ULONG op2, ULONG carry);
LOCKHELPER4(Sbb, ULONG *localpop1, ULONG *pop1, ULONG op2, ULONG carry);
LOCKHELPER2(And, ULONG *pop1, ULONG op2); 
LOCKHELPER3(Sub, ULONG *localpop1, ULONG *pop1, ULONG op2); 
LOCKHELPER2(Xor, ULONG *pop1, ULONG op2); 
LOCKHELPER1(Not, ULONG *pop1);
LOCKHELPER2(Neg, ULONG *localpop1, ULONG *pop1);
LOCKHELPER2(Bts, ULONG *pop1, ULONG bit);
LOCKHELPER2(Btr, ULONG *pop1, ULONG bit);
LOCKHELPER2(Btc, ULONG *pop1, ULONG bit);
LOCKHELPER2(Xchg, ULONG *pop1, ULONG *pop2);
LOCKHELPER3(Xadd, ULONG *localpop1, ULONG *pop1, ULONG *pop2);
LOCKHELPER4(CmpXchg, ULONG *Reax, ULONG *pop1, ULONG *pop2, ULONG *localpop1);
LOCKHELPER3(CmpXchg8b, ULONGLONG *EaxEcx, ULONGLONG *EcxEdx, ULONGLONG *pop2);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\optfrag.c ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    optfrag.c

Abstract:
    
    Instruction Fragments which correspond to optimizations.

Author:

    6-July-1995 Ori Gershony (t-orig)

Revision History:

          24-Aug-1999 [askhalid] copied from 32-bit wx86 directory and make work for 64bit.


--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "cpuassrt.h"
#include "fragp.h"
#include "optfrag.h"

ASSERTNAME;

// This fragment corresponds to:
//      push ebx
//      push esi
//      push edi
FRAG0(OPT_PushEbxEsiEdiFrag)
{
    ULONG *espval;

    espval=(ULONG *)esp;

    *(espval-1) = ebx;
    *(espval-2) = esi;
    *(espval-3) = edi;
    esp=(ULONG)(LONGLONG)espval-12;   
}

//  This fragment corresponds to:
//      pop edi
//      pop esi
//      pop ebx
FRAG0(OPT_PopEdiEsiEbxFrag)
{
    ULONG *espval;

    espval=(ULONG *)esp;

    edi=*espval;
    esi=*(espval+1);
    ebx=*(espval+2);
    esp=(ULONG)(LONGLONG)espval+12; 
}

// This fragment corresponds to:
//      push ebp
//      mov ebp,esp
//      sub esp, op1
FRAG1IMM(OPT_SetupStackFrag, ULONG)
{
    ULONG result, oldespminusfour;

    oldespminusfour = esp-4;
    result = oldespminusfour - op1;
    
    *(ULONG *)oldespminusfour = ebp;
    ebp = oldespminusfour;
    esp = result;
    SET_FLAGS_SUB32(result, oldespminusfour, op1, 0x80000000);
}
FRAG1IMM(OPT_SetupStackNoFlagsFrag, ULONG)
{
    ULONG result, oldespminusfour;

    oldespminusfour = esp-4;
    result = oldespminusfour - op1;
    
    *(ULONG *)oldespminusfour = ebp;
    ebp = oldespminusfour;
    esp = result;
}

FRAG1(OPT_ZEROFrag32, LONG)
{
    // implements: XOR samereg, samereg
    //             SUB samereg, samereg
    // ie. XOR EAX, EAX   or SUB ECX, ECX

    *pop1 = 0;
    SET_CFLAG_OFF;
    SET_OFLAG_OFF;
    SET_SFLAG_OFF;
    SET_ZFLAG(0);
    SET_PFLAG(0);
    SET_AUXFLAG(0);
}

FRAG1(OPT_ZERONoFlagsFrag32, LONG)
{
    // implements: XOR samereg, samereg
    //             SUB samereg, samereg
    // ie. XOR EAX, EAX   or SUB ECX, ECX

    *pop1 = 0;
}

FRAG3(OPT_CmpSbbFrag32, ULONG, ULONG, ULONG)
{
    ULONG result;
    ULONG cf;

    //
    // implements:  CMP op2, op3
    //              SBB op1, op1
    //
    result = op2-op3;
    cf = (op2 ^ op3 ^ result) ^ ((op2 ^ op3) & (op2 ^ result));
    result = (ULONG)-(LONG)(cf >> 31);
    *pop1 = result;     // pop1 is a pointer to a reg, so always aligned
    SET_OFLAG_OFF;
    SET_CFLAG(result);
    SET_SFLAG(result);
    SET_ZFLAG(result);
    SET_AUXFLAG(result);
    SET_PFLAG(result);
}
FRAG3(OPT_CmpSbbNoFlagsFrag32, ULONG, ULONG, ULONG)
{
    ULONG result;
    ULONG cf;

    //
    // implements:  CMP op2, op3
    //              SBB op1, op1
    //
    result = op2-op3;
    cf = (op2 ^ op3 ^ result) ^ ((op2 ^ op3) & (op2 ^ result));
    *pop1 = (ULONG)-(LONG)(cf >> 31);
}
FRAG3(OPT_CmpSbbNegFrag32, ULONG, ULONG, ULONG)
{
    ULONG result;
    ULONG cf;

    //
    // implements:  CMP op2, op3
    //              SBB op1, op1
    //              NEG op1
    //
    result = op2-op3;
    cf = (op2 ^ op3 ^ result) ^ ((op2 ^ op3) & (op2 ^ result));
    // pop1 is a pointer to a reg, so it is always aligned
    if (cf >= 0x80000000) {
        result = 1;
        *pop1 = result;         // store the result before updating flags
        SET_CFLAG_ON;           // set if result != 0
        SET_AUXFLAG(0xfe);      // this is (BYTE)(0xffffffff ^ 0x00000001)
    } else {
        result = 0;
        *pop1 = result;         // store the result before updating flags
        SET_CFLAG_OFF;          // cleared if result==0
        SET_AUXFLAG(0);         // this is (BYTE)(0x0 ^ 0x0)
        SET_OFLAG_OFF;          // this is (0x0 & 0x0) << 31
    }
    SET_ZFLAG(result);
    SET_PFLAG(result);
    SET_SFLAG_OFF;
    SET_OFLAG_OFF;      // this is either (0xffffffff & 0x00000001) or (0 & 0)
}
FRAG3(OPT_CmpSbbNegNoFlagsFrag32, ULONG, ULONG, ULONG)
{
    ULONG result;
    ULONG cf;

    //
    // implements:  CMP op2, op3
    //              SBB op1, op1
    //              NEG op1
    //
    result = op2-op3;
    cf = (op2 ^ op3 ^ result) ^ ((op2 ^ op3) & (op2 ^ result));
    // result is 1 if high bit of cf is set, 0 if high bit is clear
    *pop1 = cf >> 31;
}

FRAG2IMM(OPT_Push2Frag32, ULONG, ULONG)
{
    //
    // implements:      PUSH op1
    //                  PUSH op2
    // Note that the analysis phase must ensure that the value of op2 does
    // not depend on the value of ESP, as op2 will be computed before the
    // first PUSH is excuted.
    //
    PUSH_LONG(op1);
    PUSH_LONG(op2);
}
FRAG2REF(OPT_Pop2Frag32, ULONG)
{
    //
    // implements:      POP pop1
    //                  POP pop2
    //
    // Note that the analysis phase must ensure that the value of pop2 does
    // not depend on the value of pop1, as pop1 will not have been popped
    // when the value of pop2 is computed.
    //
    POP_LONG(*pop1);
    POP_LONG(*pop2);
}

FRAG1(OPT_CwdIdivFrag16, USHORT)
{
    short op1;
    short result;

    //
    // implements:      CWD
    //                  IDIV EAX, *pop1
    // The CWD sign-extends EAX into EDX:EAX, which means, we can
    // avoid a 64-bit division and just divide EAX.  There is no
    // possibility of overflow.
    //
    op1 = (short)GET_SHORT(pop1);
    // Must do the divide before modifying edx, in case op1==0 and we fault.
    result = (short)ax / op1;

    dx = (short)ax % op1;
    ax = result;
}
FRAG1(OPT_CwdIdivFrag16A, USHORT)
{
    short op1;
    short result;

    //
    // implements:      CWD
    //                  IDIV EAX, *pop1
    // The CWD sign-extends EAX into EDX:EAX, which means, we can
    // avoid a 64-bit division and just divide EAX.  There is no
    // possibility of overflow.
    //
    op1 = (short)*pop1;
    // Must do the divide before modifying edx, in case op1==0 and we fault.
    result = (short)ax / op1;

    dx = (short)ax % op1;
    ax = result;
}

FRAG1(OPT_CwdIdivFrag32, ULONG)
{
    long op1;
    long result;

    //
    // implements:      CWD
    //                  IDIV EAX, *pop1
    // The CWD sign-extends EAX into EDX:EAX, which means, we can
    // avoid a 64-bit division and just divide EAX.  There is no
    // possibility of overflow.
    //
    op1 = (long)GET_LONG(pop1);
    // Must do the divide before modifying edx, in case op1==0 and we fault.
    result = (long)eax / op1;

    edx = (long)eax % op1;
    eax = result;
}
FRAG1(OPT_CwdIdivFrag32A, ULONG)
{
    long op1;
    long result;

    //
    // implements:      CWD
    //                  IDIV EAX, *pop1
    // The CWD sign-extends EAX into EDX:EAX, which means, we can
    // avoid a 64-bit division and just divide EAX.  There is no
    // possibility of overflow.
    //
    op1 = (long)*pop1;
    // Must do the divide before modifying edx, in case op1==0 and we fault.
    result = (long)eax / op1;

    edx = (long)eax % op1;
    eax = result;
}

//  This fragment should never be called!
FRAG0(OPT_OPTIMIZEDFrag)
{
    CPUASSERTMSG(FALSE, "OPTIMIZED fragment should never be called!");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\shr1632.c ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    shr1632.c

Abstract:
    
    Instruction fragments with common (shared) WORD, and DWORD flavors
    (but not BYTE).

Author:

    12-Jun-1995 BarryBo

Revision History:
        24-Aug-1999 [askhalid] copied from 32-bit wx86 directory and make work for 64bit.

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "wx86.h"
#include "wx86nt.h"
#include "shr1632.h"

FRAGCOMMON0(PushfFrag)
{
    UTYPE dw;

    dw =   ((GET_CFLAG) ? FLAG_CF : 0)
        | 2
        | ((GET_AUXFLAG) ? FLAG_AUX : 0)  // The auxflag is special
        | ((GET_PFLAG) ? FLAG_PF : 0)
        | ((cpu->flag_zf) ? 0 : FLAG_ZF)  // zf has inverse logic
        | ((GET_SFLAG) ? FLAG_SF : 0)
        | ((cpu->flag_tf) ? FLAG_TF : 0)
        | FLAG_IF
        | ((cpu->flag_df == -1) ? FLAG_DF : 0)
        | ((GET_OFLAG) ? FLAG_OF : 0)
#if MSB==0x80000000
        | cpu->flag_ac
        | cpu->flag_id
        // VM and RF bits are both 0
#endif
        ;
    PUSH_VAL(dw);
}
FRAGCOMMON0(PopfFrag)
{
    UTYPE dw;

    POP_VAL(dw);
    // ignore: FLAG_NT, FLAG_RF, FLAG_VM, IOPL
    SET_CFLAG_IND (dw & FLAG_CF);
    cpu->flag_pf = (dw & FLAG_PF) ? 0 : 1;  // pf is an index into the ParityBit[] array
    cpu->flag_aux= (dw & FLAG_AUX) ? AUX_VAL : 0;
    cpu->flag_zf = (dw & FLAG_ZF) ? 0 : 1;  // zf has inverse logic
    SET_SFLAG_IND (dw & FLAG_SF);
    cpu->flag_tf = (dw & FLAG_TF) ? 1 : 0;
    cpu->flag_df = (dw & FLAG_DF) ? -1 : 1;
    SET_OFLAG_IND (dw & FLAG_OF);
#if MSB==0x80000000
    cpu->flag_ac = (dw & FLAG_AC);
    cpu->flag_id = (dw & FLAG_ID);
#endif
}
FRAGCOMMON0(PushAFrag)
{
    // can't use PUSH_VAL() as ESP cannot be updated until after we're sure
    // things can't fault
    *(UTYPE *)(esp-sizeof(UTYPE)) = AREG;
    *(UTYPE *)(esp-2*sizeof(UTYPE)) = CREG;
    *(UTYPE *)(esp-3*sizeof(UTYPE)) = DREG;
    *(UTYPE *)(esp-4*sizeof(UTYPE)) = BREG;
    *(UTYPE *)(esp-5*sizeof(UTYPE)) = SPREG;
    *(UTYPE *)(esp-6*sizeof(UTYPE)) = BPREG;
    *(UTYPE *)(esp-7*sizeof(UTYPE)) = SIREG;
    *(UTYPE *)(esp-8*sizeof(UTYPE)) = DIREG;
    esp -= 8*sizeof(UTYPE);
}
FRAGCOMMON0(PopAFrag)
{
    // can't use POP_VAL() as ESP cannot be updated untile after we're sure
    // things can't fault
    DIREG = *(UTYPE *)(esp);
    SIREG = *(UTYPE *)(esp+sizeof(UTYPE));
    BPREG = *(UTYPE *)(esp+2*sizeof(UTYPE));
    // ignore [E]SP register image on the stack
    BREG = *(UTYPE *)(esp+4*sizeof(UTYPE));
    DREG = *(UTYPE *)(esp+5*sizeof(UTYPE));
    CREG = *(UTYPE *)(esp+6*sizeof(UTYPE));
    AREG = *(UTYPE *)(esp+7*sizeof(UTYPE));
    esp += 8*sizeof(UTYPE);
}
FRAGCOMMON1IMM(PushFrag)
{
    PUSH_VAL(op1);
}
FRAGCOMMON0(CwdFrag)
{
    DREG = (AREG & MSB) ? (UTYPE)0xffffffff : 0;
}
FRAGCOMMON2(BoundFrag)
{
    if ((op2 < GET_VAL(pop1)) ||
        (op2 > (GET_VAL( (ULONG)(ULONGLONG)(pop1) + sizeof(UTYPE))))) {   

           Int5(); // raise BOUND exception
    }
}
FRAGCOMMON2IMM(EnterFrag)
{
    BYTE level;
    DWORD frameptr;
    DWORD espTemp;

    level = (BYTE)(op1 % 32);
    espTemp = esp - sizeof(UTYPE);
    *(UTYPE *)(espTemp) = BPREG;  // can't use PUSH_VAL because esp can't be changed
    frameptr = espTemp;
    if (level) {
        BYTE i;
        DWORD ebpTemp = ebp;
        for (i=1; i<= level-1; ++i) {
            ebpTemp -= sizeof(UTYPE);
            espTemp -= sizeof(UTYPE);
            *(UTYPE *)espTemp =  (UTYPE)ebpTemp;
        }
        espTemp-=sizeof(UTYPE);
        *(DWORD *)espTemp = frameptr;
    }
    ebp = frameptr;
    esp = espTemp-op2;
}
FRAGCOMMON0(LeaveFrag)
{
    DWORD espTemp;

    espTemp = ebp;
    BPREG = *(UTYPE *)espTemp;
    esp = espTemp + sizeof(UTYPE);
}
FRAGCOMMON2(LesFrag)
{
    *pop1 = GET_VAL(op2);       // pop1 is always a ptr to a register
    ES = GET_SHORT(op2+sizeof(UTYPE));
    //UNDONE: fault if segment register not loaded with correct value?
}
FRAGCOMMON2(LdsFrag)
{
    *pop1 = GET_VAL(op2);       // pop1 is always a ptr to a register
    DS = GET_SHORT(op2+sizeof(UTYPE));
    //UNDONE: fault if segment register not loaded with correct value?
}
FRAGCOMMON2(LssFrag)
{
    *pop1 = GET_VAL(op2);       // pop1 is always a ptr to a register
    SS = GET_SHORT(op2+sizeof(UTYPE));
    //UNDONE: fault if segment register not loaded with correct value?
}
FRAGCOMMON2(LfsFrag)
{
    *pop1 = GET_VAL(op2);       // pop1 is always a ptr to a register
    FS = GET_SHORT(op2+sizeof(UTYPE));
    //UNDONE: fault if segment register not loaded with correct value?
    //UNDONE: what about the selector base for FS?
}
FRAGCOMMON2(LgsFrag)
{
    *pop1 = GET_VAL(op2);       // pop1 is always a ptr to a register
    GS = GET_SHORT(op2+sizeof(UTYPE));
    //UNDONE: fault if segment register not loaded with correct value?
}
FRAGCOMMON2(LslFrag)
{
    //
    // pop1 is a pointer to a register, so can use aligned code
    //

    op2 &= ~3;      // mask off RPL bits
    if (op2 == KGDT_R3_CODE ||          // CS: selector
        op2 == KGDT_R3_DATA             // DS:, SS:, ES: selector
       ) {
        *pop1 = (UTYPE)-1;          // limit=0xffffffff
        SET_ZFLAG(0);               // ZF=1
    } else if (op2 == KGDT_R3_TEB) {
        *pop1 = 0xfff;              // limit=0xfff (1 x86 page)
        SET_ZFLAG(0);               // ZF=1
    } else {
        SET_ZFLAG(1);               // ZF=0
    }
}
FRAGCOMMON2(LarFrag)
{
    //
    // pop1 is a pointer to a register, so can use aligned code
    //

    op2 &= ~3;      // mask off RPL bits
    if (op2 == KGDT_R3_CODE) {
        *pop1 = (UTYPE)0xcffb00;
        SET_ZFLAG(0);               // ZF=1
    } else if (op2 == KGDT_R3_DATA) {
        *pop1 = (UTYPE)0xcff300;
        SET_ZFLAG(0);               // ZF=1
    } else if (op2 == KGDT_R3_TEB) {
        *pop1 = (UTYPE)0x40f300;
        SET_ZFLAG(0);               // ZF=1
    } else {
        SET_ZFLAG(1);               // ZF=0
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\optfrag.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    optfrag.h

Abstract:
    
    Prototypes for misc. instruction fragments.

Author:

    6-July-1995 Ori Gershony (t-orig)

Revision History:

--*/

FRAG0(OPT_PushEbxEsiEdiFrag);
FRAG0(OPT_PopEdiEsiEbxFrag);
FRAG1IMM(OPT_SetupStackFrag, ULONG);
FRAG1IMM(OPT_SetupStackNoFlagsFrag, ULONG);
FRAG1(OPT_ZEROFrag32, LONG);
FRAG1(OPT_ZERONoFlagsFrag32, LONG);
FRAG3(OPT_CmpSbbFrag32, ULONG, ULONG, ULONG);
FRAG3(OPT_CmpSbbNoFlagsFrag32, ULONG, ULONG, ULONG);
FRAG3(OPT_CmpSbbNegFrag32, ULONG, ULONG, ULONG);
FRAG3(OPT_CmpSbbNegNoFlagsFrag32, ULONG, ULONG, ULONG);
FRAG2IMM(OPT_Push2Frag32, ULONG, ULONG);
FRAG2REF(OPT_Pop2Frag32, ULONG);
FRAG1(OPT_CwdIdivFrag16, USHORT);
FRAG1(OPT_CwdIdivFrag16A, USHORT);
FRAG1(OPT_CwdIdivFrag32, ULONG);
FRAG1(OPT_CwdIdivFrag32A, ULONG);
FRAG0(OPT_OPTIMIZEDFrag);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\shared.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    shared.h

Abstract:
    
    Prototypes for instruction fragments shared between 8, 16, and 32-bit.

Author:

    12-Jun-1995 BarryBo, Created

Revision History:

--*/

// WARNING: This file may be included multiple times by a single source file,
// WARNING: so don't add #ifndef SHARED_H checks.

FRAGCOMMON1IMM(OPT_FastTestFrag);
FRAGCOMMON2IMM(CmpFrag);
FRAGCOMMON2IMM(TestFrag);
FRAGCOMMON0(LodsFrag);
FRAGCOMMON0(RepLodsFrag);
FRAGCOMMON0(FsLodsFrag);
FRAGCOMMON0(FsRepLodsFrag);
FRAGCOMMON0(ScasFrag);
FRAGCOMMON0(ScasNoFlagsFrag);
FRAGCOMMON0(RepzScasFrag);
FRAGCOMMON0(RepzScasNoFlagsFrag);
FRAGCOMMON0(RepnzScasFrag);
FRAGCOMMON0(RepnzScasNoFlagsFrag);
FRAGCOMMON0(FsScasFrag);
FRAGCOMMON0(FsScasNoFlagsFrag);
FRAGCOMMON0(FsRepzScasFrag);
FRAGCOMMON0(FsRepzScasNoFlagsFrag);
FRAGCOMMON0(FsRepnzScasFrag);
FRAGCOMMON0(FsRepnzScasNoFlagsFrag);
FRAGCOMMON0(StosFrag);
FRAGCOMMON0(RepStosFrag);
FRAGCOMMON0(MovsFrag);
FRAGCOMMON0(RepMovsFrag);
FRAGCOMMON0(FsMovsFrag);
FRAGCOMMON0(FsRepMovsFrag);
FRAGCOMMON0(CmpsFrag);
FRAGCOMMON0(RepzCmpsFrag);
FRAGCOMMON0(RepnzCmpsFrag);
FRAGCOMMON0(FsCmpsFrag);
FRAGCOMMON0(FsRepzCmpsFrag);
FRAGCOMMON0(FsRepnzCmpsFrag);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\shareda.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    shareda.h

Abstract:
    
    Prototypes for instruction fragments shared between 8, 16, and 32-bit,
    with ALIGNED and UNALIGNED flavors.

Author:

    05-Nov-1995 BarryBo, Created

Revision History:

--*/

// WARNING: This file may be included multiple times by a single source file,
// WARNING: so don't add #ifndef SHARED_H checks.

FRAGCOMMON2(AddFrag);
FRAGCOMMON2(AddNoFlagsFrag);
FRAGCOMMON1(IncFrag);
FRAGCOMMON1(IncNoFlagsFrag);
FRAGCOMMON1(DecFrag);
FRAGCOMMON1(DecNoFlagsFrag);
FRAGCOMMON2(OrFrag);
FRAGCOMMON2(OrNoFlagsFrag);
FRAGCOMMON2(AdcFrag);
FRAGCOMMON2(AdcNoFlagsFrag);
FRAGCOMMON2(SbbFrag);
FRAGCOMMON2(SbbNoFlagsFrag);
FRAGCOMMON2(AndFrag);
FRAGCOMMON2(AndNoFlagsFrag);
FRAGCOMMON2(SubFrag);
FRAGCOMMON2(SubNoFlagsFrag);
FRAGCOMMON2(XorFrag);
FRAGCOMMON2(XorNoFlagsFrag);
FRAGCOMMON2REF(XchgFrag);
FRAGCOMMON2(RolFrag);
FRAGCOMMON2(RorFrag);
FRAGCOMMON2(RclFrag);
FRAGCOMMON2(RcrFrag);
FRAGCOMMON2(ShlFrag);
FRAGCOMMON2(ShlNoFlagsFrag);
FRAGCOMMON2(ShrFrag);
FRAGCOMMON2(ShrNoFlagsFrag);
FRAGCOMMON2(SarFrag);
FRAGCOMMON2(SarNoFlagsFrag);
FRAGCOMMON1(Rol1Frag);
FRAGCOMMON1(Rol1NoFlagsFrag);
FRAGCOMMON1(Ror1Frag);
FRAGCOMMON1(Ror1NoFlagsFrag);
FRAGCOMMON1(Rcl1Frag);
FRAGCOMMON1(Rcl1NoFlagsFrag);
FRAGCOMMON1(Rcr1Frag);
FRAGCOMMON1(Rcr1NoFlagsFrag);
FRAGCOMMON1(Shl1Frag);
FRAGCOMMON1(Shl1NoFlagsFrag);
FRAGCOMMON1(Shr1Frag);
FRAGCOMMON1(Shr1NoFlagsFrag);
FRAGCOMMON1(Sar1Frag);
FRAGCOMMON1(Sar1NoFlagsFrag);
FRAGCOMMON1(NotFrag);
FRAGCOMMON1(NegFrag);
FRAGCOMMON1(NegNoFlagsFrag);
FRAGCOMMON1(MulFrag);
FRAGCOMMON1(MulNoFlagsFrag);
FRAGCOMMON1(MuliFrag);
FRAGCOMMON1(MuliNoFlagsFrag);
FRAGCOMMON1(DivFrag);
FRAGCOMMON1(IdivFrag);
FRAGCOMMON2REF(XaddFrag);
FRAGCOMMON2REF(XaddNoFlagsFrag);
FRAGCOMMON2REF(CmpXchgFrag);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\shareda.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    shareda.c

Abstract:
    
    Instruction fragments with common (shared) BYTE, WORD, and DWORD flavors.
    Compiled twice per flavor, once with UNALIGNED and once with ALIGNED
    pointers.

Author:

    05-Nov-1995 BarryBo

Revision History:

--*/


// THIS FILE IS #include'd INTO FILES WHICH DEFINE THE FOLLOWING MACROS:
// MSB          - most significant bit
// UTYPE    - UNSIGNED type which defines registers (BYTE/USHORT/DWORD)
// STYPE    -   SIGNED type which defines registers (char/short/long)
// GET_VAL  - dereference a pointer of the right type (GET_BYTE/...)
// PUT_VAL      - writes a value into memory
// FRAGCOMMON{0,1,2}  - mangles the function name and declares parameters
// AREG     - al/ax/eax
// BREG     - ...
// CREG     - ...
// DREG     - ...

FRAGCOMMON2(AddFrag)
{
    UTYPE result;
    UTYPE op1 = GET_VAL(pop1);

    result = op1 + op2;
    PUT_VAL(pop1, result);
    SET_FLAGS_ADD(result, op1, op2, MSB);
}
FRAGCOMMON2(AddNoFlagsFrag)
{
    UTYPE result;
    UTYPE op1 = GET_VAL(pop1);

    result = op1 + op2;
    PUT_VAL(pop1, result);
}
FRAGCOMMON1(IncFrag)
{
    UTYPE op1, result;

    op1 = GET_VAL(pop1);
    result = op1+1;
    PUT_VAL(pop1, result);
    SET_FLAGS_INC(result, op1);
}
FRAGCOMMON1(IncNoFlagsFrag)
{
    UTYPE op1, result;

    op1 = GET_VAL(pop1);
    result = op1+1;
    PUT_VAL(pop1, result);
}
FRAGCOMMON1(DecFrag)
{
    UTYPE op1, result;

    op1 = GET_VAL(pop1);
    result = op1-1;
    PUT_VAL(pop1, result);
    SET_FLAGS_DEC(result, op1);
}
FRAGCOMMON1(DecNoFlagsFrag)
{
    UTYPE op1, result;

    op1 = GET_VAL(pop1);
    result = op1-1;
    PUT_VAL(pop1, result);
}
FRAGCOMMON2(OrFrag)
{
    UTYPE op1, result;

    op1 = GET_VAL(pop1);
    result = op1 | op2;
    PUT_VAL(pop1, result);
    SET_ZFLAG(result);
    SET_PFLAG(result);
    SET_SFLAG(result << (31-LMB));
    SET_CFLAG_OFF;
    SET_OFLAG_OFF;
}
FRAGCOMMON2(OrNoFlagsFrag)
{
    UTYPE op1, result;

    op1 = GET_VAL(pop1);
    result = op1 | op2;
    PUT_VAL(pop1, result);
}
FRAGCOMMON2(AdcFrag)
{
    UTYPE result, op1;

    op1 = GET_VAL(pop1);
    result = op1 + op2 + (UTYPE)GET_CFLAGZO;
    PUT_VAL(pop1, result);
    SET_FLAGS_ADD(result, op1, op2, MSB);
}
FRAGCOMMON2(AdcNoFlagsFrag)
{
    UTYPE result, op1;

    op1 = GET_VAL(pop1);
    result = op1 + op2 + (UTYPE)GET_CFLAGZO;
    PUT_VAL(pop1, result);
}
FRAGCOMMON2(SbbFrag)
{
    UTYPE result, op1;

    op1 = GET_VAL(pop1);
    result = op1 - op2 - (UTYPE)GET_CFLAGZO;
    PUT_VAL(pop1, result);
    SET_FLAGS_SUB(result, op1, op2, MSB);
}
FRAGCOMMON2(SbbNoFlagsFrag)
{
    UTYPE result, op1;

    op1 = GET_VAL(pop1);
    result = op1 - op2 - (UTYPE)GET_CFLAGZO;
    PUT_VAL(pop1, result);
}
FRAGCOMMON2(AndFrag)
{
    UTYPE result, op1;

    op1 = GET_VAL(pop1);
    result = op1 & op2;
    PUT_VAL(pop1, result);
    SET_ZFLAG(result);
    SET_PFLAG(result);
    SET_SFLAG(result << (31-LMB));
    SET_CFLAG_OFF;
    SET_OFLAG_OFF;
}
FRAGCOMMON2(AndNoFlagsFrag)
{
    UTYPE result, op1;

    op1 = GET_VAL(pop1);
    result = op1 & op2;
    PUT_VAL(pop1, result);
}
FRAGCOMMON2(SubFrag)
{
    UTYPE result, op1;

    op1 = GET_VAL(pop1);
    result = op1 - op2;
    PUT_VAL(pop1, result);
    SET_FLAGS_SUB(result, op1, op2, MSB);
}
FRAGCOMMON2(SubNoFlagsFrag)
{
    UTYPE result, op1;

    op1 = GET_VAL(pop1);
    result = op1 - op2;
    PUT_VAL(pop1, result);
}
FRAGCOMMON2(XorFrag)
{
    UTYPE result, op1;

    op1 = GET_VAL(pop1);
    result  = op1 ^ op2;
    PUT_VAL(pop1, result);
    SET_ZFLAG(result);
    SET_PFLAG(result);
    SET_SFLAG(result << (31-LMB));
    SET_CFLAG_OFF;
    SET_OFLAG_OFF;
}
FRAGCOMMON2(XorNoFlagsFrag)
{
    UTYPE result, op1;

    op1 = GET_VAL(pop1);
    result  = op1 ^ op2;
    PUT_VAL(pop1, result);
}
// Note:  both pop1 and pop2 are given by reference
FRAGCOMMON2REF(XchgFrag)
{
    XCHG_MEM(UTYPE, pop1, pop2);
}
FRAGCOMMON2REF(XaddFrag)
{
    UTYPE op1, op2, result;

    op1 = GET_VAL(pop1);
    op2 = GET_VAL(pop2);
    result = op1+op2;

    PUT_VAL(pop2, op1);
    PUT_VAL(pop1, result);
    SET_FLAGS_ADD(result, op1, op2, MSB);
}
FRAGCOMMON2REF(XaddNoFlagsFrag)
{
    UTYPE op1, op2, result;

    op1 = GET_VAL(pop1);
    op2 = GET_VAL(pop2);
    result = op1+op2;

    PUT_VAL(pop2, op1);
    PUT_VAL(pop1, result);
}
FRAGCOMMON2REF(CmpXchgFrag)
{
    UTYPE op1, op2;
    UTYPE Value = AREG;

    op1 = GET_VAL(pop1);
    op2 = GET_VAL(pop2);

    SET_FLAGS_SUB(Value-op1, Value, op1, MSB);

    if (Value == op1) {
        PUT_VAL(pop1, op2);
        SET_ZFLAG(0);       // zf has inverse logic
    } else {
        AREG = op1;
        SET_ZFLAG(1);       // zf has inverse logic
    }
}
FRAGCOMMON2(RolFrag)
{
    op2 &= LMB;
    if (op2) {
        UTYPE b;

        b = GET_VAL(pop1);
#if _PPC_ && (LMB==31)
        b = _rotl(b, op2);      // an instrinsic rotlw instruction on PPC
#else
        b = (b << op2) | (b >> (LMB-op2+1));
#endif

        PUT_VAL(pop1, b);
        SET_CFLAG((DWORD)b << 31);
    }
}
FRAGCOMMON2(RorFrag)
{
    op2 &= LMB;
    if (op2) {
        UTYPE b;

        b = GET_VAL(pop1);
#if _PPC_ && (LMB==31)
        b = _rotr(b, op2);      // an instrinsic rotlw instruction on PPC
#else
        b = (b >> op2) | (b << (LMB-op2+1));
#endif
        PUT_VAL(pop1, b)
        SET_CFLAG((DWORD)b << (31-LMB));
    }
}
FRAGCOMMON2(RclFrag)
{
    op2 &= LMB;
    if (op2) {
        UTYPE b;
        DWORD temp_cf;

        b = GET_VAL(pop1);
        temp_cf = (DWORD)b << (31-LMB+op2-1);
        b = (b << op2) | (b >> (LMB-op2+2)) | ((UTYPE)GET_CFLAGZO << (op2-1));
        PUT_VAL(pop1, b);
        SET_CFLAG(temp_cf);
    }
}
FRAGCOMMON2(RcrFrag)
{
    op2 &= LMB;
    if (op2) {
        UTYPE b;
        DWORD temp_cf;

        b = GET_VAL(pop1);
        temp_cf = (DWORD)b << (32-op2);
        b = (b << (LMB-op2+2)) | (b >> op2) | (UTYPE)((GET_CFLAGZO) << (LMB-op2+1));
        PUT_VAL(pop1, b)
        SET_CFLAG(temp_cf);
    }
}
FRAGCOMMON2(ShlFrag)
{
    op2 &= 0x1f;
    if (op2) {
        UTYPE b;
        UTYPE newb;

        b = GET_VAL(pop1);
        b <<= (op2-1);
        newb = b << 1;
        PUT_VAL(pop1, newb);
        SET_CFLAG((DWORD)b << (31-LMB));
        SET_ZFLAG(newb);
        SET_PFLAG(newb);
        SET_SFLAG(newb << (31-LMB));
    }
}
FRAGCOMMON2(ShlNoFlagsFrag)
{
    op2 &= 0x1f;
    if (op2) {
        UTYPE b;

        b = GET_VAL(pop1);
        b <<= op2;
        PUT_VAL(pop1, b);
    }
}
FRAGCOMMON2(ShrFrag)
{
    op2 &= 0x1f;
    if (op2) {
        UTYPE b;
        UTYPE newb;

        b = GET_VAL(pop1);
        b >>= (op2-1);
        newb = b >> 1;
        PUT_VAL(pop1, newb);
        SET_CFLAG((DWORD)b << 31);
        SET_ZFLAG(newb);
        SET_PFLAG(newb);
        SET_SFLAG_OFF;
    }
}
FRAGCOMMON2(ShrNoFlagsFrag)
{
    op2 &= 0x1f;
    if (op2) {
        UTYPE b;

        b = GET_VAL(pop1);
        b >>= op2;
        PUT_VAL(pop1, b);
    }
}
FRAGCOMMON2(SarFrag)
{
    op2 &= 0x1f;
    if (op2) {
        UTYPE b, temp, newb;

        b = GET_VAL(pop1);
        temp = b & MSB;
        b >>= (op2-1);
        newb = b >> 1;
        if (temp) {
            newb |= ~((1u << (LMB-op2+1))-1u);
        }
        PUT_VAL(pop1, newb);
        SET_CFLAG((DWORD)b << 31);
        SET_ZFLAG(newb);
        SET_PFLAG(newb);
        SET_SFLAG(newb << (31-LMB));
    }
}
FRAGCOMMON2(SarNoFlagsFrag)
{
    op2 &= 0x1f;
    if (op2) {
        UTYPE b, temp, newb;

        b = GET_VAL(pop1);
        temp = b & MSB;
        newb = b >> op2;
        if (temp) {
            newb |= ~((1u << (LMB-op2+1))-1u);
        }
        PUT_VAL(pop1, newb);
    }
}
FRAGCOMMON1(Rol1Frag)
{
    UTYPE b, temp_cf;

    b = GET_VAL(pop1);
    temp_cf = b & MSB;
#if _PPC_ && (LMB==31)
    b = _rotl(b, 1);      // an instrinsic rotlw instruction on PPC
#else
    b = (b<<1) + (b >> LMB);
#endif
    PUT_VAL(pop1, b);
    SET_CFLAG((DWORD)temp_cf << (31-LMB));
    SET_OFLAG((DWORD)(temp_cf ^ b) << (31-LMB));
}
FRAGCOMMON1(Rol1NoFlagsFrag)
{
    UTYPE b, temp_cf;

    b = GET_VAL(pop1);
    temp_cf = b & MSB;
#if _PPC_ && (LMB==31)
    b = _rotl(b, 1);      // an instrinsic rotlw instruction on PPC
#else
    b = (b<<1) + (b >> LMB);
#endif
    PUT_VAL(pop1, b);
}
FRAGCOMMON1(Ror1Frag)
{
    UTYPE b, newb;

    b = GET_VAL(pop1);
#if _PPC_ && (LMB==31)
    newb = _rotr(b, 1);      // an instrinsic rotlw instruction on PPC
#else
    newb = (b >> 1) | (b << LMB);
#endif
    PUT_VAL(pop1, newb);
    SET_CFLAG((DWORD)b << 31);
    SET_OFLAG((DWORD)((newb>>LMB) ^ (newb>>(LMB-1)) & 1) << 31);   // xor top 2 bits together
}
FRAGCOMMON1(Ror1NoFlagsFrag)
{
    UTYPE b, newb;

    b = GET_VAL(pop1);
#if _PPC_ && (LMB==31)
    newb = _rotr(b, 1);      // an instrinsic rotlw instruction on PPC
#else
    newb = (b >> 1) | (b << LMB);
#endif
    PUT_VAL(pop1, newb);
}
FRAGCOMMON1(Rcl1Frag)
{
    UTYPE b, temp_cf;

    b = GET_VAL(pop1);
    temp_cf = b & MSB;
    b = (b<<1) + (UTYPE)GET_CFLAGZO;
    PUT_VAL(pop1, b);
    SET_CFLAG(temp_cf << (31-LMB));
    SET_OFLAG((DWORD)(temp_cf ^ b) << (31-LMB));
}
FRAGCOMMON1(Rcl1NoFlagsFrag)
{
    UTYPE b;

    b = GET_VAL(pop1);
    b = (b<<1) + (UTYPE)GET_CFLAGZO;
    PUT_VAL(pop1, b);
}
FRAGCOMMON1(Rcr1Frag)
{
    UTYPE b, temp_cf;

    b = GET_VAL(pop1);
    temp_cf = b & 1;
    b = (b >> 1) + (UTYPE)((cpu->flag_cf & 0x80000000) >> (31-LMB));
    PUT_VAL(pop1, b);
    SET_CFLAG((DWORD)temp_cf << 31);
    SET_OFLAG(((DWORD)b << (31-LMB)) ^ ((DWORD)b << (31-LMB+1))); // xor top 2 bits together
}
FRAGCOMMON1(Rcr1NoFlagsFrag)
{
    UTYPE b;

    b = GET_VAL(pop1);
    b = (b >> 1) + (UTYPE)((cpu->flag_cf & 0x80000000) >> (31-LMB));
    PUT_VAL(pop1, b);
}
FRAGCOMMON1(Shl1Frag)
{
    UTYPE b, newb;

    b = GET_VAL(pop1);
    newb = b << 1;
    PUT_VAL(pop1, newb);
    SET_CFLAG((DWORD)b << (31-LMB));
    SET_ZFLAG(newb);
    SET_PFLAG(newb);
    SET_SFLAG(newb << (31-LMB));
    SET_OFLAG(GET_CFLAG ^ GET_SFLAG);
}
FRAGCOMMON1(Shl1NoFlagsFrag)
{
    UTYPE b, newb;

    b = GET_VAL(pop1);
    newb = b << 1;
    PUT_VAL(pop1, newb);
}
FRAGCOMMON1(Shr1Frag)
{
    UTYPE b, newb;

    b = GET_VAL(pop1);
    newb = b >> 1;
    PUT_VAL(pop1, newb);
    SET_OFLAG((DWORD)b << (31-LMB));
    SET_CFLAG((DWORD)b << 31);
    SET_ZFLAG(newb);
    SET_PFLAG(newb);
    SET_SFLAG_OFF;
}
FRAGCOMMON1(Shr1NoFlagsFrag)
{
    UTYPE b, newb;

    b = GET_VAL(pop1);
    newb = b >> 1;
    PUT_VAL(pop1, newb);
}
FRAGCOMMON1(Sar1Frag)
{
    UTYPE b, temp, newb;

    b = GET_VAL(pop1);
    temp = b & MSB;
    newb = (b >> 1) + temp;
    PUT_VAL(pop1, newb);
    SET_CFLAG((DWORD)b << 31);
    SET_ZFLAG(newb);
    SET_PFLAG(newb);
    SET_SFLAG(newb << (31-LMB));
    SET_OFLAG_OFF;
}
FRAGCOMMON1(Sar1NoFlagsFrag)
{
    UTYPE b, temp, newb;

    b = GET_VAL(pop1);
    temp = b & MSB;
    newb = (b >> 1) + temp;
    PUT_VAL(pop1, newb);
}
FRAGCOMMON1(NotFrag)
{
    PUT_VAL(pop1, ~GET_VAL(pop1));
}
FRAGCOMMON1(NegFrag)
{
    UTYPE op1, result;

    op1 = GET_VAL(pop1);
    result = (UTYPE)-(STYPE)op1;
    PUT_VAL(pop1, result);
    SET_CFLAG_IND(result != 0);
    SET_ZFLAG(result);
    SET_PFLAG(result);
    SET_AUXFLAG(op1 ^ result);
    SET_SFLAG(result << (31-LMB));
    SET_OFLAG((DWORD)(op1 & result) << (31-LMB));
}
FRAGCOMMON1(NegNoFlagsFrag)
{
    UTYPE op1, result;

    op1 = GET_VAL(pop1);
    result = (UTYPE)-(STYPE)op1;
    PUT_VAL(pop1, result);
}
FRAGCOMMON1(MulFrag)
{
#if MSB == 0x80
    USHORT result;

    result = (USHORT)al * (USHORT)GET_BYTE(pop1);
    if (result <= 0xff) {
        SET_CFLAG_OFF;
        SET_OFLAG_OFF;
    } else {
        SET_CFLAG_ON;
        SET_OFLAG_ON;
    }
    ax = result;
#elif MSB == 0x8000
    ULONG result;

    result = (ULONG)ax * (ULONG)GET_SHORT(pop1);
    if (result <= 0xffff) {
        SET_CFLAG_OFF;
        SET_OFLAG_OFF;
    } else {
        SET_CFLAG_ON;
        SET_OFLAG_ON;
    }
    ax = LOWORD(result);
    dx = HIWORD(result);
#else   // MSB == 0x80000000
    LARGE_INTEGER result;

    result = RtlEnlargedUnsignedMultiply(eax, GET_LONG(pop1));
    if (result.HighPart == 0) {
        SET_CFLAG_OFF;
        SET_OFLAG_OFF;
    } else {
        SET_CFLAG_ON;
        SET_OFLAG_ON;
    }
    eax = result.LowPart;
    edx = result.HighPart;
#endif
} 
FRAGCOMMON1(MulNoFlagsFrag)
{
#if MSB == 0x80
    USHORT result;

    result = (USHORT)al * (USHORT)GET_BYTE(pop1);
    ax = result;
#elif MSB == 0x8000
    ULONG result;

    result = (ULONG)ax * (ULONG)GET_SHORT(pop1);
    ax = LOWORD(result);
    dx = HIWORD(result);
#else   // MSB == 0x80000000
    LARGE_INTEGER result;

    result = RtlEnlargedUnsignedMultiply(eax, GET_LONG(pop1));
    eax = result.LowPart;
    edx = result.HighPart;
#endif
} 
FRAGCOMMON1(MuliFrag)
{
#if MSB == 0x80
    SHORT result;

    result = (short)(char)al * (short)(char)GET_BYTE(pop1);
    if ((result & 0xff80) == 0 || (result & 0xff80) == 0xff80) {
        SET_CFLAG_OFF;
        SET_OFLAG_OFF;
    } else {
        SET_CFLAG_ON;
        SET_OFLAG_ON;
    }
    ax = result;
#elif MSB == 0x8000
    LONG result;

    result = (long)(short)ax * (long)(short)GET_SHORT(pop1);
    if ((result & 0xffff8000) == 0 || (result & 0xffff8000) == 0xffff8000) {
        SET_CFLAG_OFF;
        SET_OFLAG_OFF;
    } else {
        SET_CFLAG_ON;
        SET_OFLAG_ON;
    }
    ax = LOWORD(result);
    dx = HIWORD(result);
#else   // MSB == 0x80000000
    LARGE_INTEGER result;
    LONGLONG ll;

    ll = Int32x32To64(eax, (long)GET_LONG(pop1));
    result = *(LARGE_INTEGER *)&ll;
    if ((result.HighPart == 0 && (result.LowPart & 0x80000000) == 0) ||
        (result.HighPart == 0xffffffff && (result.LowPart & 0x80000000) == 0x80000000)) {
        SET_CFLAG_OFF;
        SET_OFLAG_OFF;
    } else {
        SET_CFLAG_ON;
        SET_OFLAG_ON;
    }
    eax = result.LowPart;
    edx = result.HighPart;
#endif
}
FRAGCOMMON1(MuliNoFlagsFrag)
{
#if MSB == 0x80
    SHORT result;

    result = (short)(char)al * (short)(char)GET_BYTE(pop1);
    ax = result;
#elif MSB == 0x8000
    LONG result;

    result = (long)(short)ax * (long)(short)GET_SHORT(pop1);
    ax = LOWORD(result);
    dx = HIWORD(result);
#else   // MSB == 0x80000000
    LARGE_INTEGER result;
    LONGLONG ll;

    ll = Int32x32To64(eax, (long)GET_LONG(pop1));
    result = *(LARGE_INTEGER *)&ll;
    eax = result.LowPart;
    edx = result.HighPart;
#endif
}
FRAGCOMMON1(DivFrag)
{
#if MSB == 0x80
    USHORT result, remainder;
    USHORT dividend, divisor;

    dividend = (USHORT)ax;
    divisor  = GET_VAL(pop1);

    result    = dividend / divisor; // may get div-by-zero fault
    remainder = dividend % divisor;
    if ((result & 0xff00) == 0) {
        al = (UTYPE)result;
        ah = (UTYPE)remainder;
    } else {
        OVERFLOW_INSTR;
    }
#elif MSB == 0x8000
    DWORD result, remainder;
    DWORD dividend, divisor;

    dividend = (((DWORD)dx)<<16) | (DWORD)ax;
    divisor =  (DWORD)GET_VAL(pop1);

    result    = dividend / divisor; // may get div-by-zero fault
    remainder = dividend % divisor;
    if ((result & 0xffff0000) == 0) {
        AREG = (UTYPE)result;
        DREG = (UTYPE)remainder;
    } else {
        OVERFLOW_INSTR;
    }
#else // MSB == 0x80000000
    LARGE_INTEGER result;
    LARGE_INTEGER remainder;
    LARGE_INTEGER dividend;
    LARGE_INTEGER divisor;

    // build large_integers, without sign extending the 32-bit values
    dividend.LowPart = AREG;
    dividend.HighPart = DREG;
    divisor.LowPart = (long)GET_LONG(pop1);
    divisor.HighPart = 0;
    result = RtlLargeIntegerDivide(dividend, divisor, &remainder);

    if (result.HighPart == 0) {
        AREG = result.LowPart;
        DREG = remainder.LowPart;
    } else {
        OVERFLOW_INSTR;
    }
#endif
}
FRAGCOMMON1(IdivFrag)
{
#if MSB == 0x80
    short result, remainder;

    result    = (signed short)ax / (STYPE)GET_VAL(pop1); // may get div-by-zero fault
    remainder = (signed short)ax % (STYPE)GET_VAL(pop1);
    if ((result & 0xff80) == 0 || (result & 0xff80) == 0xff80) {
        al = (UTYPE)result;
        ah = (UTYPE)remainder;
    } else {
        OVERFLOW_INSTR;
    }
#elif MSB == 0x8000
    LONG result, remainder;

    result    = (signed long)((dx<<16) | ax) / (signed long)(STYPE)GET_VAL(pop1); // may get div-by-zero fault
    remainder = (signed long)((dx<<16) | ax) % (signed long)(STYPE)GET_VAL(pop1);
    if ((result & 0xffff8000) == 0 || (result & 0xffff8000) == 0xffff8000) {
        AREG = (UTYPE)result;
        DREG = (UTYPE)remainder;
    } else {
        OVERFLOW_INSTR;
    }
#else // MSB == 0x80000000
    LARGE_INTEGER result;
    LARGE_INTEGER remainder;
    LARGE_INTEGER dividend;
    LARGE_INTEGER divisor;
    DWORD op1;

    //
    // Since RtlLargeIntegerDivide and all of the overhead is large,
    // it is worthwhile making this check:
    //
    if ((long)DREG == -(long)(AREG >> 31)) {
        //
        // EDX:EAX is really just the value of EAX sign-extended into EDX.
        // This division can be performed with 32-bit arithmetic and no
        // overflow checking.
        //
        OPT_CwdIdivFrag32(cpu, pop1);
        return;
    }

    op1 = GET_LONG(pop1);

    // build UNSIGNED large_integers
    dividend.LowPart = AREG;
    dividend.HighPart = DREG;
    if (dividend.QuadPart < 0) {
        dividend.QuadPart = -dividend.QuadPart;
    }

    if ((long)op1 < 0) {
        divisor.LowPart = -(long)op1;
    } else {
        divisor.LowPart = op1;
    }
    divisor.HighPart = 0;

    // perform UNSIGNED division
    result = RtlLargeIntegerDivide(dividend, divisor, &remainder);

    // if divisor and dividend signs are different, fudge the result
    if ((dividend.HighPart != (int)DREG) ^ (divisor.LowPart != (int)op1)) {
        result.QuadPart = -result.QuadPart;
    }

    // adjust the sign of the remainder if the dividend is negative
    if (dividend.HighPart != (int)DREG) {
        remainder.QuadPart = -remainder.QuadPart;
    }

    if ((result.HighPart == 0 && (result.LowPart & MSB) == 0) ||
        (result.HighPart == 0xffffffff && (result.LowPart & MSB))) {
        AREG = (UTYPE)result.LowPart;
        DREG = (UTYPE)remainder.LowPart;
    } else {
        OVERFLOW_INSTR;
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\shared.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    shared.c

Abstract:
    
    Instruction fragments with common (shared) BYTE, WORD, and DWORD flavors.

Author:

    12-Jun-1995 BarryBo

Revision History:

--*/


// THIS FILE IS #include'd INTO FILES WHICH DEFINE THE FOLLOWING MACROS:
// MSB          - most significant bit
// UTYPE    - UNSIGNED type which defines registers (BYTE/USHORT/DWORD)
// STYPE    -   SIGNED type which defines registers (char/short/long)
// GET_VAL  - dereference a pointer of the right type (GET_BYTE/...)
// PUT_VAL      - writes a value into memory
// FRAGCOMMON{0,1,2}  - mangles the function name and declares parameters
// AREG     - al/ax/eax
// BREG     - ...
// CREG     - ...
// DREG     - ...

FRAGCOMMON1IMM(OPT_FastTestFrag)
{
    SET_ZFLAG(op1);
    SET_PFLAG(op1);
    SET_SFLAG(op1 << (31-LMB));
    SET_CFLAG_OFF;
    SET_OFLAG_OFF;
}

FRAGCOMMON2IMM(CmpFrag)
{
    UTYPE result;

    result = op1 - op2;
    SET_FLAGS_SUB(result, op1, op2, MSB);
}

FRAGCOMMON2IMM(TestFrag)
{
    UTYPE result;

    result = op1 & op2;
    SET_ZFLAG(result);
    SET_PFLAG(result);
    SET_SFLAG(result << (31-LMB));
    SET_CFLAG_OFF;
    SET_OFLAG_OFF;
}


FRAGCOMMON0(RepMovsFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;

    while (ecx) {
        PUT_VAL(edi, GET_VAL(esi));
        esi += LoopIncr;
        edi += LoopIncr;
        ecx--;
    }
}
FRAGCOMMON0(FsRepMovsFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;
    DWORD Base = (DWORD)(ULONGLONG)NtCurrentTeb();

    while (ecx) {
        PUT_VAL(edi, GET_VAL(esi + Base));
        esi += LoopIncr;
        edi += LoopIncr;
        ecx--;
    }
}
FRAGCOMMON0(MovsFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;

    PUT_VAL(edi, GET_VAL(esi));
    esi += LoopIncr;
    edi += LoopIncr;
}
FRAGCOMMON0(FsMovsFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;

    PUT_VAL(edi, GET_VAL(esi + (DWORD)(ULONGLONG)NtCurrentTeb())); 
    esi += LoopIncr;
    edi += LoopIncr;
}
FRAGCOMMON0(RepnzCmpsFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;
    UTYPE result, op1, op2;

    while (ecx) {
        op1 = GET_VAL(esi);
        op2 = GET_VAL(edi);
        result = op1 - op2;
        SET_FLAGS_SUB(result, op1, op2, MSB);
        esi += LoopIncr;
        edi += LoopIncr;
        ecx--;
        if (cpu->flag_zf == 0) {    // inverse logic
            break;
        }
    }
}
FRAGCOMMON0(FsRepnzCmpsFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;
    DWORD Base = (DWORD)(ULONGLONG)NtCurrentTeb(); 
    UTYPE result, op1, op2;

    while (ecx) {
        op1 = GET_VAL(esi + Base);
        op2 = GET_VAL(edi);
        result = op1 - op2;
        SET_FLAGS_SUB(result, op1, op2, MSB);
        esi += LoopIncr;
        edi += LoopIncr;
        ecx--;
        if (cpu->flag_zf == 0) {    // inverse logic
            break;
        }
    }
}
FRAGCOMMON0(RepzCmpsFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;
    UTYPE result, op1, op2;

    while (ecx) {
        op1 = GET_VAL(esi);
        op2 = GET_VAL(edi);
        result = op1 - op2;
        SET_FLAGS_SUB(result, op1, op2, MSB);
        esi += LoopIncr;
        edi += LoopIncr;
        ecx--;
        if (cpu->flag_zf) {     // inverse logic
            break;
        }
    }
}
FRAGCOMMON0(FsRepzCmpsFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;
    DWORD Base = (DWORD)(ULONGLONG)NtCurrentTeb();  
    UTYPE result, op1, op2;

    while (ecx) {
        op1 = GET_VAL(esi + Base);
        op2 = GET_VAL(edi);
        result = op1 - op2;
        SET_FLAGS_SUB(result, op1, op2, MSB);
        esi += LoopIncr;
        edi += LoopIncr;
        ecx--;
        if (cpu->flag_zf) {     // inverse logic
            break;
        }
    }
}
FRAGCOMMON0(CmpsFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;
    UTYPE result, op1, op2;

    op1 = GET_VAL(esi);
    op2 = GET_VAL(edi);
    result = op1 - op2;
    SET_FLAGS_SUB(result, op1, op2, MSB);
    esi += LoopIncr;
    edi += LoopIncr;
}
FRAGCOMMON0(FsCmpsFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;
    UTYPE result, op1, op2;

    op1 = GET_VAL(esi + (DWORD)(ULONGLONG)NtCurrentTeb()); 
    op2 = GET_VAL(edi);
    result = op1 - op2;
    SET_FLAGS_SUB(result, op1, op2, MSB);
    esi += LoopIncr;
    edi += LoopIncr;
}
FRAGCOMMON0(RepStosFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;
    UTYPE Value = AREG;

    while (ecx) {
        PUT_VAL(edi, Value);
        edi += LoopIncr;
        ecx--;
    }
}
FRAGCOMMON0(StosFrag)
{
    PUT_VAL(edi, AREG);
    edi += sizeof(UTYPE)*cpu->flag_df;
}
FRAGCOMMON0(RepnzScasFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;
    UTYPE result, op2;
    UTYPE Value = AREG;

    while (ecx) {
        op2 = GET_VAL(edi);
        result = Value - op2;
        SET_FLAGS_SUB(result, Value, op2, MSB);
        edi += LoopIncr;
        ecx--;
        if (cpu->flag_zf == 0) {        // inverse logic
            break;
        }
    }
}
FRAGCOMMON0(RepnzScasNoFlagsFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;
    UTYPE result, op2;
    UTYPE Value = AREG;

    while (ecx) {
        op2 = GET_VAL(edi);
        result = Value - op2;
        edi += LoopIncr;
        ecx--;
        if (result == 0) {        // inverse logic
            break;
        }
    }
}
FRAGCOMMON0(FsRepnzScasFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;
    DWORD Base = (DWORD)(ULONGLONG)NtCurrentTeb();  
    UTYPE result, op2;
    UTYPE Value = AREG;

    while (ecx) {
        op2 = GET_VAL(edi + Base);
        result = Value - op2;
        SET_FLAGS_SUB(result, Value, op2, MSB);
        edi += LoopIncr;
        ecx--;
        if (cpu->flag_zf == 0) {    // inverse logic
            break;
        }
    }
}
FRAGCOMMON0(FsRepnzScasNoFlagsFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;
    DWORD Base = (DWORD)(ULONGLONG)NtCurrentTeb();  
    UTYPE result, op2;
    UTYPE Value = AREG;

    while (ecx) {
        op2 = GET_VAL(edi + Base);
        result = Value - op2;
        edi += LoopIncr;
        ecx--;
        if (result == 0) {    // inverse logic
            break;
        }
    }
}
FRAGCOMMON0(RepzScasFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;
    UTYPE result, op2;
    UTYPE Value = AREG;

    while (ecx) {
        op2 = GET_VAL(edi);
        result = Value - op2;
        SET_FLAGS_SUB(result, Value, op2, MSB);
        edi += LoopIncr;
        ecx--;
        if (cpu->flag_zf) {     // inverse logic
            break;
        }
    }
}
FRAGCOMMON0(RepzScasNoFlagsFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;
    UTYPE result, op2;
    UTYPE Value = AREG;

    while (ecx) {
        op2 = GET_VAL(edi);
        result = Value - op2;
        edi += LoopIncr;
        ecx--;
        if (result) {     // inverse logic
            break;
        }
    }
}
FRAGCOMMON0(FsRepzScasFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;
    DWORD Base = (DWORD)(ULONGLONG)NtCurrentTeb();  
    UTYPE result, op2;
    UTYPE Value = AREG;

    while (ecx) {
        op2 = GET_VAL(edi + Base);
        result = Value - op2;
        SET_FLAGS_SUB(result, Value, op2, MSB);
        edi += LoopIncr;
        ecx--;
        if (cpu->flag_zf) {     // inverse logic
            break;
        }
    }
}
FRAGCOMMON0(FsRepzScasNoFlagsFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;
    DWORD Base = (DWORD)(ULONGLONG)NtCurrentTeb();  
    UTYPE result, op2;
    UTYPE Value = AREG;

    while (ecx) {
        op2 = GET_VAL(edi + Base);
        result = Value - op2;
        edi += LoopIncr;
        ecx--;
        if (result) {     // inverse logic
            break;
        }
    }
}
FRAGCOMMON0(ScasFrag)
{
    UTYPE result, op2;

    op2 = GET_VAL(edi);
    result = AREG - op2;
    SET_FLAGS_SUB(result, AREG, op2, MSB);
    edi += sizeof(UTYPE)*cpu->flag_df;
}
FRAGCOMMON0(ScasNoFlagsFrag)
{
    UTYPE result, op2;

    op2 = GET_VAL(edi);
    result = AREG - op2;
    edi += sizeof(UTYPE)*cpu->flag_df;
}
FRAGCOMMON0(FsScasFrag)
{
    UTYPE result, op2;

    op2 = GET_VAL(edi + (DWORD)(ULONGLONG)NtCurrentTeb());  
    result = AREG - op2;
    SET_FLAGS_SUB(result, AREG, op2, MSB);
    edi += sizeof(UTYPE)*cpu->flag_df;
}
FRAGCOMMON0(FsScasNoFlagsFrag)
{
    UTYPE result, op2;

    op2 = GET_VAL(edi + (DWORD)(ULONGLONG)NtCurrentTeb());  
    result = AREG - op2;
    edi += sizeof(UTYPE)*cpu->flag_df;
}
FRAGCOMMON0(LodsFrag)
{
    AREG = GET_VAL(esi);
    esi += sizeof(UTYPE)*cpu->flag_df;
}
FRAGCOMMON0(FsLodsFrag)
{
    AREG = GET_VAL(esi + (DWORD)(ULONGLONG)NtCurrentTeb());  
    esi += sizeof(UTYPE)*cpu->flag_df;
}
FRAGCOMMON0(RepLodsFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;

    while (ecx) {
        AREG = GET_VAL(esi);
        esi += LoopIncr;
        ecx--;
    }
}
FRAGCOMMON0(FsRepLodsFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;
    DWORD Base = (DWORD)(ULONGLONG)NtCurrentTeb();  

    while (ecx) {
        AREG = GET_VAL(esi + Base);
        esi += LoopIncr;
        ecx--;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\shr1632a.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    shr1632a.h

Abstract:
    
    Prototypes for instruction fragments shared between 16 and 32 bits, with
    ALIGNED an UNALIGNED flavors.

Author:

    05-Nov-1995 BarryBo, Created

Revision History:

--*/

FRAGCOMMON2(BtRegFrag);
FRAGCOMMON2(BtsRegFrag);
FRAGCOMMON2(BtcRegFrag);
FRAGCOMMON2(BtrRegFrag);
FRAGCOMMON2(BtMemFrag);
FRAGCOMMON2(BtsMemFrag);
FRAGCOMMON2(BtcMemFrag);
FRAGCOMMON2(BtrMemFrag);
FRAGCOMMON3(ShldFrag);
FRAGCOMMON3(ShrdFrag);
FRAGCOMMON3(ShldNoFlagsFrag);
FRAGCOMMON3(ShrdNoFlagsFrag);
FRAGCOMMON2(BsfFrag);
FRAGCOMMON2(BsrFrag);
FRAGCOMMON1(PopFrag);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\soalpha.h ===
// CodeTemplate:gensocpu

//
//soalpha.h -- Generated file.  Do not hand edit
//


//
// Thread State offsets
//
#define Eax 0x0
#define Ebx 0xc
#define Ecx 0x4
#define Edx 0x8
#define Esi 0x18
#define Edi 0x1c
#define Ebp 0x14
#define Esp 0x10
#define Eip 0x38
#define CSReg 0x24
#define CpuNotify 0x158
#define fTCUnlocked 0x168

//
// Register mappings
//
#if MIPS
#ifdef _codegen_
// 0-3 are ZERO, at, v0, v1
#define RegArg0             4           // a0 arg register
#define RegArg1             5           // a1 arg register
#define RegArg2             6           // a2 arg register
#define RegArg3             7           // a3 arg register
#define RegTemp0            8           // t0 temp for operand0
#define RegTemp1            9           // t1 temp for operand1
#define RegTemp2            10          // t2 temp for operand2
#define RegTemp3            11          // t3 temp for operand3
#define RegTemp4            12          // t4 temp2 for operand0
#define RegTemp5            13          // t5 temp2 for operand1
#define RegTemp6            14          // t6 temp2 for operand2
#define RegTemp7            15          // t7 temp2 for operand3
#define RegPointer          16          // s0 saved
#define RegEip              17          // s1 saved
#define RegCache0           18          // s2 saved
#define RegCache1           19          // s3 saved
#define RegCache2           20          // s4 saved
#define RegCache3           21          // s5 saved
#define RegCache4           22          // s6 saved
#define RegProcessCpuNotify 23          // s7 saved
#define RegTemp8            24          // t8 temp unused
#define RegTemp             25          // t9 temp
// 26-29 are k0, k1, gp, sp
//#define RegS8             30          // s8 saved (DO NOT USE - USED BY trampln.s FOR EXCEPTION DISPATCHING)
#else
// 0-3 are ZERO, at, v0, v1
#define RegArg0             $4          // a0 arg register
#define RegArg1             $5          // a1 arg register
#define RegArg2             $6          // a2 arg register
#define RegArg3             $7          // a3 arg register
#define RegTemp0            $8          // t0 temp for operand0
#define RegTemp1            $9          // t1 temp for operand1
#define RegTemp2            $10         // t2 temp for operand2
#define RegTemp3            $11         // t3 temp for operand3
#define RegTemp4            $12         // t4 temp2 for operand0
#define RegTemp5            $13         // t5 temp2 for operand1
#define RegTemp6            $14         // t6 temp2 for operand2
#define RegTemp7            $15         // t7 temp2 for operand3
#define RegPointer          $16         // s0 saved
#define RegEip              $17         // s1 saved
#define RegCache0           $18         // s2 saved
#define RegCache1           $19         // s3 saved
#define RegCache2           $20         // s4 saved
#define RegCache3           $21         // s5 saved
#define RegCache4           $22         // s6 saved
#define RegProcessCpuNotify $23         // s7 saved
#define RegTemp8            $24         // t8 temp unused
#define RegTemp             $25         // t9 temp
// 26-29 are k0, k1, gp, sp
//#define RegS8             $30         // s8 saved (DO NOT USE - USED BY trampln.s FOR EXCEPTION DISPATCHING)
#endif

#define NUM_CACHE_REGS              5
#define EXCEPTIONDATA_SIGNATURE     0x12341234


#ifndef _codegen_
//
// asm fragment delcarator and end macro
//
#define FRAGMENT(name) \
	.text;\
	.globl name;\
	.ent name;\
name##:
;
#define END_FRAGMENT(name) \
	.globl _End##name;\
_End##name##:;\
	.end name;
#endif


#endif

#if ALPHA
#ifdef _codegen_
//
// Register mappings
//
// 0 is v0
#define RegTemp0            1   // t0 temp for operand1
#define RegTemp1            2   // t1 temp for operand2
#define RegTemp2            3   // t2 temp for operand3
#define RegTemp3            4   // t3 temp1 for operand1
#define RegTemp4            5   // t4 temp1 for operand2
#define RegTemp5            6   // t5 temp1 for operand3
#define RegTemp6            7   // t6 temp2 for operand1 and operand3
#define RegTemp7            8   // t7 temp2 for operand2
// 9-14 are s0-s5
#define RegPointer          9   // s0 saved
#define RegEip              10  // s1 saved
#define RegProcessCpuNotify 11  // s2 saved
#define RegCache0           12  // s3 saved
#define RegCache1           13  // s4 saved
#define RegCache2           14  // s5 saved
// 15 is fp
#define RegArg0             16  // a0 arg register
#define RegArg1             17  // a1 arg register
#define RegArg2             18  // a2 arg register
#define RegArg3             19  // a3 arg register
#define RegArg4             20  // a4 arg register
#define RegArg5             21  // a5 arg register
#define RegTemp8            22  // t8 temp3 for operand1 and operand3
#define RegTemp9            23  // t9 temp3 for operand2
#define RegTemp10           24  // t10 temp4 for operand1 and operand3
#define RegTemp11           25  // t11 temp4 for operand2
// 26 is ra
#define RegTemp             27  // t12 temp
// 28-31 are AT, gp, sp, zero
#else
//
// Register mappings
//
// 0 is v0
#define RegTemp0            $1   // t0 temp for operand1
#define RegTemp1            $2   // t1 temp for operand2
#define RegTemp2            $3   // t2 temp for operand3
#define RegTemp3            $4   // t3 temp1 for operand1
#define RegTemp4            $5   // t4 temp1 for operand2
#define RegTemp5            $6   // t5 temp1 for operand3
#define RegTemp6            $7   // t6 temp2 for operand1 and operand3
#define RegTemp7            $8   // t7 temp2 for operand2
// 9-14 are s0-s5
#define RegPointer          $9   // s0 saved
#define RegEip              $10  // s1 saved
#define RegProcessCpuNotify $11  // s2 saved
#define RegCache0           $12  // s3 saved
#define RegCache1           $13  // s4 saved
#define RegCache2           $14  // s5 saved
// 15 is fp
#define RegArg0             $16  // a0 arg register
#define RegArg1             $17  // a1 arg register
#define RegArg2             $18  // a2 arg register
#define RegArg3             $19  // a3 arg register
#define RegArg4             $20  // a4 arg register
#define RegArg5             $21  // a5 arg register
#define RegTemp8            $22  // t8 temp3 for operand1 and operand3
#define RegTemp9            $23  // t9 temp3 for operand2
#define RegTemp10           $24  // t10 temp4 for operand1 and operand3
#define RegTemp11           $25  // t11 temp4 for operand2
// 26 is ra
#define RegTemp             $27  // t12 temp
// 28-31 are AT, gp, sp, zero
#endif

#define NUM_CACHE_REGS              3
#define EXCEPTIONDATA_SIGNATURE     0x01010101


#ifndef _codegen_
//
// asm fragment delcarator and end macro
//
#define FRAGMENT(name) \
        .text;\
        .globl name;\
        .ent name;\
name##:
;
#define END_FRAGMENT(name) \
        .globl _End##name;\
_End##name##:;\
        .end name;
#endif        
#endif

#if PPC
#ifdef _codegen_
// r0 is temp unused (reads as zero in some instructions)
// r1 is stack pointer
// r2 is TOC pointer
#define RegArg0             3   // arg register 0
#define RegArg1             4   // arg register 1
#define RegArg2             5   // arg register 2
#define RegArg3             6   // arg register 3
#define RegTemp0            7   // temp for operand1 (acutally arg reg 4)
#define RegTemp1            8   // temp for operand2 (acutally arg reg 5)
#define RegTemp2            9   // temp for operand3 (acutally arg reg 6)
#define RegUt1              10  // temp
#define RegUt2              11  // temp
#define RegUt3              12  // temp
// all registers past r12 must be preserved
// r13 is the TEB pointer, set up by NT and assumed to be valid by C code
#define RegPointer          14  // saved
#define RegEip              15  // saved
#define RegProcessCpuNotify 16  // saved
#define RegCache0           17  // saved
#define RegCache1           18  // saved
#define RegCache2           19  // saved
#define RegCache3           20  // saved
#define RegCache4           21  // saved
#define RegCache5           22  // saved
#define RegTemp             23  // saved
// r24-r31 are unused
#else
// r0 is temp unused (reads as zero in some instructions)
// r1 is stack pointer
// r2 is TOC pointer
#define RegArg0             r3  // arg register 0
#define RegArg1             r4  // arg register 1
#define RegArg2             r5  // arg register 2
#define RegArg3             r6  // arg register 3
#define RegTemp0            r7  // temp for operand1 (acutally arg reg 4)
#define RegTemp1            r8  // temp for operand2 (acutally arg reg 5)
#define RegTemp2            r9  // temp for operand3 (acutally arg reg 6)
#define RegUt1              r10 // temp
#define RegUt2              r11 // temp
#define RegUt3              r12 // temp
// all registers past r12 must be preserved
// r13 is the TEB pointer, set up by NT and assumed to be valid by C code
#define RegPointer          r14 // saved
#define RegEip              r15 // saved
#define RegProcessCpuNotify r16 // saved
#define RegCache0           r17 // saved
#define RegCache1           r18 // saved
#define RegCache2           r19 // saved
#define RegCache3           r20 // saved
#define RegCache4           r21 // saved
#define RegCache5           r22 // saved
#define RegTemp             r23 // saved
// r24-r31 are unused
#endif

#define NUM_CACHE_REGS              6
#define EXCEPTIONDATA_SIGNATURE     0x12341234

#ifndef _codegen_
//
// asm fragment delcarator and end macro
//
#define FRAGMENT(name)   \
    .text;               \
    .align 2;            \
    .globl name;         \
name##:         
    
#define END_FRAGMENT(name) \
    .globl _End##name;     \
_End##name:;
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\shr1632a.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    shr1632a.c

Abstract:
    
    Instruction fragments with common (shared) WORD, and DWORD flavors
    (but not BYTE).

    Compiled twice per flavor, once with UNALIGNED and once with ALIGNED
    pointers.

Author:

    05-Nov-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "shr1632a.h"

FRAGCOMMON2(BtMemFrag)
{
    UTYPE bit = 1<<(op2&LMB);

    op2 /= LMB+1;   // compute offset of the correct WORD/DWORD
    SET_CFLAG_IND(GET_VAL(pop1+op2) & bit);
}
FRAGCOMMON2(BtsMemFrag)
{
    DWORD NewCFlag;
    UTYPE bit = 1<<(op2&LMB);
    UTYPE op1;

    op2 /= LMB+1;   // compute offset of the correct WORD/DWORD
    pop1 += op2;
    op1 = GET_VAL(pop1);

    NewCFlag = op1 & bit;
    // Intel docs indicate that we can safely overwrite all 2/4 bytes
    // when writing the value back out.  (pg. 26/43)
    PUT_VAL(pop1, (op1|bit));
    SET_CFLAG_IND(NewCFlag);
}
FRAGCOMMON2(BtcMemFrag)
{
    DWORD NewCFlag;
    UTYPE bit = 1<<(op2&LMB);
    UTYPE op1;

    op2 /= LMB+1;   // compute offset of the correct WORD/DWORD
    pop1 += op2;
    op1 = GET_VAL(pop1);

    NewCFlag = op1 & bit;
    // Intel docs indicate that we can safely overwrite all 2/4 bytes
    // when writing the value back out.  (pg. 26/43)
    PUT_VAL(pop1, op1 ^ bit);
    SET_CFLAG_IND(NewCFlag);
}
FRAGCOMMON2(BtrMemFrag)
{
    DWORD NewCFlag;
    UTYPE bit = 1<<(op2&LMB);
    UTYPE op1;

    op2 /= LMB+1;   // compute offset of the correct WORD/DWORD
    pop1 += op2;
    op1 = GET_VAL(pop1);

    NewCFlag = op1 & bit;
    // Intel docs indicate that we can safely overwrite all 2/4 bytes
    // when writing the value back out.  (pg. 26/43)
    PUT_VAL(pop1, (op1&(~bit)));
    SET_CFLAG_IND(NewCFlag);
}
FRAGCOMMON2(BtRegFrag)
{
    UTYPE bit = 1<<(op2&LMB);

    SET_CFLAG_IND(GET_VAL(pop1) & bit);
}
FRAGCOMMON2(BtsRegFrag)
{
    DWORD NewCFlag;
    UTYPE bit = 1<<(op2&LMB);
    UTYPE op1;

    op1 = GET_VAL(pop1);

    NewCFlag = op1 & bit;
    // Intel docs indicate that we can safely overwrite all 2/4 bytes
    // when writing the value back out.  (pg. 26/43)
    PUT_VAL(pop1, (op1|bit));
    SET_CFLAG_IND(NewCFlag);
}
FRAGCOMMON2(BtcRegFrag)
{
    DWORD NewCFlag;
    UTYPE bit = 1<<(op2&LMB);
    UTYPE op1;

    op1 = GET_VAL(pop1);

    NewCFlag = op1 & bit;
    // Intel docs indicate that we can safely overwrite all 2/4 bytes
    // when writing the value back out.  (pg. 26/43)
    PUT_VAL(pop1, (op1 ^ bit));
    SET_CFLAG_IND(NewCFlag);
}
FRAGCOMMON2(BtrRegFrag)
{
    DWORD NewCFlag;
    UTYPE bit = 1<<(op2&LMB);
    UTYPE op1;

    op1 = GET_VAL(pop1);

    NewCFlag = op1 & bit;
    // Intel docs indicate that we can safely overwrite all 2/4 bytes
    // when writing the value back out.  (pg. 26/43)
    PUT_VAL(pop1, (op1&(~bit)));
    SET_CFLAG_IND(NewCFlag);
}

FRAGCOMMON3(ShldFrag)
{
    // pop1 = Base   -- ptr to dest reg/mem
    // op2  = inBits -- value of register containing bits to shift into Base
    // op3  = count  -- number of bits to shift


    DWORD NewCFlag;
    UTYPE Base;

    if (op3 == 0) {
        return;         // nothing to do - nop with all flags preserved
    }
    op3 &= 0x1f;        // make the count MOD 32 (now op3 = ShiftAmt)
#if MSB == 0x8000
    if (op3 > 16) {
        // Bad parameters - *pop1 UNDEFINED!
        //                - CF,OF,SF,ZF,AF,PF UNDEFINED!
        return;
    }
#endif

    Base = GET_VAL(pop1);
    NewCFlag = Base & (1<<(LMB+1-op3));     // Get the new CF value

    Base <<= op3;               // shift Base left
    op2 >>= LMB+1-op3;          // shift the top op3 bits of op2 right
    Base |= op2;                // merge the two together
    PUT_VAL(pop1, Base);
    SET_CFLAG_IND(NewCFlag);
    SET_ZFLAG(Base);
    SET_PFLAG(Base);
    SET_SFLAG(Base << (31-LMB));
}
FRAGCOMMON3(ShldNoFlagsFrag)
{
    // pop1 = Base   -- ptr to dest reg/mem
    // op2  = inBits -- value of register containing bits to shift into Base
    // op3  = count  -- number of bits to shift


    UTYPE Base;

    if (op3 == 0) {
        return;         // nothing to do - nop with all flags preserved
    }
    op3 &= 0x1f;        // make the count MOD 32 (now op3 = ShiftAmt)
#if MSB == 0x8000
    if (op3 > 16) {
        // Bad parameters - *pop1 UNDEFINED!
        //                - CF,OF,SF,ZF,AF,PF UNDEFINED!
        return;
    }
#endif

    Base = GET_VAL(pop1);

    Base <<= op3;               // shift Base left
    op2 >>= LMB+1-op3;          // shift the top op3 bits of op2 right
    Base |= op2;                // merge the two together
    PUT_VAL(pop1, Base);
}
FRAGCOMMON3(ShrdFrag)
{
    // pop1 = Base   -- ptr to dest reg/mem
    // op2  = inBits -- value of register containing bits to shift into Base
    // op3  = count  -- number of bits to shift


    DWORD NewCFlag;
    UTYPE Base;
    int i;

    if (op3 == 0) {
        return;         // nothing to do - nop with all flags preserved
    }
    op3 &= 0x1f;        // make the count MOD 32 (now op3 = ShiftAmt)
#if MSB == 0x8000
    if (op3 > 16) {
        // Bad parameters - *pop1 UNDEFINED!
        //                - CF,OF,SF,ZF,AF,PF UNDEFINED!
        return;
    }
#endif

    Base = GET_VAL(pop1);
    NewCFlag = Base & (1<<(op3-1));     // Get the new CF value

    Base >>= op3;               // shift Base right
    op2 <<= LMB+1-op3;          // shift the low op3 bits of op2
    Base |= op2;                // merge the two together
    PUT_VAL(pop1, Base);
    SET_CFLAG_IND(NewCFlag);
    SET_ZFLAG(Base);
    SET_PFLAG(Base);
    SET_SFLAG(Base << (31-LMB));
}
FRAGCOMMON3(ShrdNoFlagsFrag)
{
    // pop1 = Base   -- ptr to dest reg/mem
    // op2  = inBits -- value of register containing bits to shift into Base
    // op3  = count  -- number of bits to shift


    UTYPE Base;
    int i;

    if (op3 == 0) {
        return;         // nothing to do - nop with all flags preserved
    }
    op3 &= 0x1f;        // make the count MOD 32 (now op3 = ShiftAmt)
#if MSB == 0x8000
    if (op3 > 16) {
        // Bad parameters - *pop1 UNDEFINED!
        //                - CF,OF,SF,ZF,AF,PF UNDEFINED!
        return;
    }
#endif

    Base = GET_VAL(pop1);

    Base >>= op3;               // shift Base right
    op2 <<= LMB+1-op3;          // shift the low op3 bits of op2
    Base |= op2;                // merge the two together
    PUT_VAL(pop1, Base);
}
FRAGCOMMON2(BsfFrag)
{
    int i;

    if (op2 == 0) {
        // value is 0 - set ZFLAG and return
        SET_ZFLAG(0);
        // *pop1 = UNDEFINED
        return;
    }

    // scan from bit 0 forward, looking for the index of '1' bit
    for (i=0; (op2 & 1) == 0; ++i) {
        op2 >>= 1;
    }

    // write the index of the '1' bit and clear the ZFLAG
    PUT_VAL(pop1, i);
    SET_ZFLAG(op2);
}
FRAGCOMMON2(BsrFrag)
{
    int i;

    if (op2 == 0) {
        // value is 0 - set ZFLAG and return
        SET_ZFLAG(0);
        // *pop1 = UNDEFINED
        return;
    }

    // scan from bit 31/15 downward, looking for the index of '1' bit
    for (i=LMB; (op2 & MSB) == 0; --i) {
        op2 <<= 1;
    }

    // write the index of the '1' bit and clear the ZFLAG
    PUT_VAL(pop1, i);
    SET_ZFLAG(op2);
}
FRAGCOMMON1(PopFrag)
{
    POP_VAL(GET_VAL(pop1));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\shr1632.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    shr1632.h

Abstract:
    
    Prototypes for instruction fragments shared between 16 and 32 bits.

Author:

    12-Jun-1995 BarryBo, Created

Revision History:

--*/

FRAGCOMMON0(PushfFrag);
FRAGCOMMON0(PopfFrag);
FRAGCOMMON0(PushAFrag);
FRAGCOMMON0(PopAFrag);
FRAGCOMMON1IMM(PushFrag);
FRAGCOMMON0(CwdFrag);
FRAGCOMMON2(BoundFrag);
FRAGCOMMON2IMM(EnterFrag);
FRAGCOMMON0(LeaveFrag);
FRAGCOMMON2(LesFrag);
FRAGCOMMON2(LdsFrag);
FRAGCOMMON2(LssFrag);
FRAGCOMMON2(LfsFrag);
FRAGCOMMON2(LgsFrag);
FRAGCOMMON2(LslFrag);
FRAGCOMMON2(LarFrag);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\axp64\fphelp.s ===
//
// Copyright (c) 1996-1998  Microsoft Corporation
//
// Module Name:
//
//     fphelp.s
// 
// Abstract:
//
//
//     This module contains assembly code helpers for floating-point
//     emulation.
// 
// Author:
//
//     Barry Bond (barrybo) creation-date 26-Aug-1996
// 
// Notes:
// 
// Revision History:

#include "kxalpha.h"
#include "soalpha.h"
#include "ksalpha.h"

.rdata

RoundingTable:
    .long (2 << 26), (1 << 26), (3 << 26), 0

.text

//
// Define call frame used to exchange a floating point and integer register.
//

        .struct 0
FpCr:   .space  8                       // fpcr value
        .space  8                       // ensure 16-byte stack alignment
FpFrameLength:                          // length of stack frame



    NESTED_ENTRY(SetNativeRoundingMode, FpFrameLength, ra)
// 
// Routine Description:
//
//     Sets the native FPU to the specified x86 rounding mode.
// 
// Arguments:
//
//     a0 -- the x86 rounding mode (already guaranteed to be just 2 bits)
//
// Return Value:
// 
//     None
//

    lda     sp, -FpFrameLength(sp)      // allocate stack frame

    PROLOGUE_END

    // map x86 rounding mode to Alpha rounding mode in a0
    lda     t0, RoundingTable
    s4addl  a0, t0, a0
    ldl     a0, 0(a0)

    excb                    // wait for all pending traps
    mf_fpcr f0, f0, f0      // get current fpcr
    excb                    // block against new traps
    stt     f0, FpCr(sp)    // store fpcr to stack
    ldl     t0, FpCr+4(sp)  // load the high dword of fpcr into integer register

    ldiq    t1, (3 << 26)   // load immediate value
    bic     t0, t1, t0      // t0 = t0 & ~(3 << 26)
    or      t0, a0, t0      // t0 |= a0

    stl     t0, FpCr+4(sp)  // store new high dword of fpcr to stack
    ldt     f0, FpCr(sp)    // load into fp register
    mt_fpcr f0, f0, f0      // set new fpcr
    excb                    // block against new traps

    lda     sp, FpFrameLength(sp)
    ret     zero, (ra)
    .end SetNativeRoundingMode




    NESTED_ENTRY(GetNativeFPStatus, FpFrameLength, ra)
// 
// Routine Description:
//
//     Alpha-specific version of _statusfp()/_clearfp().
// 
// Arguments:
//
//     None.
//
// Return Value:
// 
//     Alpha-specific equivalent of _statusfp().
//

    lda     sp, -FpFrameLength(sp)      // allocate stack frame
    PROLOGUE_END

    // this is _get_softfpcr, except the result ends up in t0
    GET_THREAD_ENVIRONMENT_BLOCK
    ldl     t0, TeSoftFpcr(v0)  // get current software fpcr value

    ldiq    t3, 0x3e0000        // t3 = SW_FPCR_STATUS_MASK
    bic     t0, t3, t1          // t1 = soft_fpcr & (~SW_FPCR_STATUS_MASK)

    // this is _set_softfpcr, except arg is in t1
    stl     t1, TeSoftFpcr(v0)  // store new software fpcr value

    excb                        // wait for all pending traps
    mf_fpcr f0, f0, f0          // get current fpcr
    excb                        // block against new traps

    stt     f0, FpCr(sp)        // store fpcr to stack
    ldq     t3, FpCr(sp)        // load fpcr into integer register

    ldiq    t1, 0x1c01000000000000  // (FPCR_ROUND_MASK|FPCR_UNDERFLOW_TO_ZERO_ENABLE|FPCR_DENORMAL_OPERANDS_TO_ZERO_ENABLE)
    and     t3, t1, t3          // t3 &= t1

    stq     t3, FpCr(sp)        // save integer version to stack
    ldt     f0, FpCr(sp)        // load it into floating-point reg
    mt_fpcr f0, f0, f0          // set new fpcr
    excb                        // block against new traps

    bis     t0, zero, v0        // move original software fpcr into v0 for ret

    lda     sp, FpFrameLength(sp)
    ret     zero, (ra)
    .end    GetNativeFPStatus


    NESTED_ENTRY(CastDoubleToInt64, FpFrameLength, ra)
//
// Arguments:
//
//      f16 = double value to be cast
//
// Return Value:
//
//      The double is cast to an __int64 value using Dynamic rounding.
//      NOTE: The Alpha C compiler generates chopped rounding always,
//            so "i64 = (double)-1.2" will give a different answer than
//               "i64 = CastDoubleToInt64(-1.2)" if the FP control word
//            is set to round towards -infinity.
//

    lda     sp, -FpFrameLength(sp)      // allocate stack frame
    PROLOGUE_END

    // Convert IEEE floating to Integer.
    //  Trapping:  S    - software
    //             V    - integer overflow enable
    //             I    - inexact enable
    //  Rounding:  D    - dynamic
    cvttqsvid  f16, f1

    // Store the int64 value onto the stack
    stt         f1, FpCr(sp)

    // Load the int64 value into an integer register
    ldq         v0, FpCr(sp)

    // Clean up the stack frame
    lda     sp, FpFrameLength(sp)
    ret     zero, (ra)
    .end CastDoubleToInt64
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\synlock.c ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    synlock.c

Abstract:
    
    Implementation of the intel locked instructions.  All locked instructions
    wait on a single global mutex (shared between processes).  This takes care
    of any synchronization problem between intel processes.  Instructions which
    access aligned 32bit memory are also synchronized with native processes
    via the functions in lock.c.

Author:

    22-Aug-1995 t-orig (Ori Gershony)

Revision History:

          24-Aug-1999 [askhalid] copied from 32-bit wx86 directory and make work for 64bit.

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "fragp.h"
#include "cpumain.h"
#include "lock.h"
#include "synlock.h"

//
// The following two variables are used to synchronize intel instructions
// with the LOCK prefix.  The critical section is a lot faster, but it does
// not guarantee synchronization in shared memory.  Eventually we should use
// the critical section by default, and the mutex for certain applications which
// need it (maybe get a list from the registry).
//
HANDLE           Wx86LockSynchMutexHandle;
RTL_CRITICAL_SECTION Wx86LockSynchCriticalSection;

//
// The following variable decided which synchronization object is used
// Remove the '#define' below to allow runtime selection of whether
// x86 LOCK: prefixes on 8-bit and 16-bit instructions and unaligned
// 32-bit instructions are synchronized across the entire machine
// or only within the current process.  With the '#define' present,
// LOCK: prefixes imply only per-process synchronization.
//
SYNCHOBJECTTYPE SynchObjectType;
#define SynchObjectType USECRITICALSECTION
 
#define GET_SYNCHOBJECT                                         \
    if (SynchObjectType == USECRITICALSECTION){                 \
        RtlEnterCriticalSection(&Wx86LockSynchCriticalSection); \
    } else {                                                    \
        WaitForSingleObject(Wx86LockSynchMutexHandle, INFINITE);\
    }

#define RELEASE_SYNCHOBJECT                                     \
    if (SynchObjectType == USECRITICALSECTION){                 \
        RtlLeaveCriticalSection(&Wx86LockSynchCriticalSection); \
    } else {                                                    \
        ReleaseMutex(Wx86LockSynchMutexHandle);                 \
    }

//
// Macros for 8 bit fragments
//
#define SLOCKFRAG1_8(x)                                 \
    FRAG1(SynchLock ## x ## Frag8, unsigned char)       \
    {                                                   \
        GET_SYNCHOBJECT                                 \
        x ## Frag8 (cpu, pop1);                         \
        RELEASE_SYNCHOBJECT                             \
    }

#define SLOCKFRAG2_8(x)                                 \
    FRAG2(SynchLock ## x ## Frag8, unsigned char)       \
    {                                                   \
        GET_SYNCHOBJECT                                 \
        x ## Frag8 (cpu, pop1, op2);                    \
        RELEASE_SYNCHOBJECT                             \
    }

#define SLOCKFRAG2REF_8(x)                              \
    FRAG2REF(SynchLock ## x ## Frag8, unsigned char)    \
    {                                                   \
        GET_SYNCHOBJECT                                 \
        x ## Frag8 (cpu, pop1, pop2);                   \
        RELEASE_SYNCHOBJECT                             \
    }


//
// Macros for 16 bit fragments
//
#define SLOCKFRAG1_16(x)                                \
    FRAG1(SynchLock ## x ## Frag16, unsigned short)     \
    {                                                   \
        GET_SYNCHOBJECT                                 \
        x ## Frag16 (cpu, pop1);                        \
        RELEASE_SYNCHOBJECT                             \
    }

#define SLOCKFRAG2_16(x)                                \
    FRAG2(SynchLock ## x ## Frag16, unsigned short)     \
    {                                                   \
        GET_SYNCHOBJECT                                 \
        x ## Frag16 (cpu, pop1, op2);                   \
        RELEASE_SYNCHOBJECT                             \
    }

#define SLOCKFRAG2REF_16(x)                             \
    FRAG2REF(SynchLock ## x ## Frag16, unsigned short)  \
    {                                                   \
        GET_SYNCHOBJECT                                 \
        x ## Frag16 (cpu, pop1, pop2);                  \
        RELEASE_SYNCHOBJECT                             \
    }


//
// Macros for 32 bit fragments
// Note:  in the 32bit case, we check if pop1 is aligned and
//        call the lock version if it is.
//

 
#define SLOCKFRAG1_32(x)                                \
    FRAG1(SynchLock ## x ## Frag32, unsigned long)      \
    {                                                   \
        GET_SYNCHOBJECT                                 \
        if (((ULONG)(ULONGLONG)pop1 & 0x3) == 0){                  \
            Lock ## x ## Frag32 (cpu, pop1);            \
        } else {                                        \
            x ## Frag32 (cpu, pop1);                    \
        }                                               \
        RELEASE_SYNCHOBJECT                             \
    }

 
#define SLOCKFRAG2_32(x)                                \
    FRAG2(SynchLock ## x ## Frag32, unsigned long)      \
    {                                                   \
        GET_SYNCHOBJECT                                 \
        if (((ULONG) (ULONGLONG)pop1 & 0x3) == 0){                  \
            Lock ## x ## Frag32 (cpu, pop1, op2);       \
        } else {                                        \
            x ## Frag32 (cpu, pop1, op2);               \
        }                                               \
        RELEASE_SYNCHOBJECT                             \
    }
 
#define SLOCKFRAG2REF_32(x)                             \
    FRAG2REF(SynchLock ## x ## Frag32, unsigned long)   \
    {                                                   \
        GET_SYNCHOBJECT                                 \
        if (((ULONG)(ULONGLONG)pop1 & 0x3) == 0){                  \
            Lock ## x ## Frag32 (cpu, pop1, pop2);      \
        } else {                                        \
            x ## Frag32 (cpu, pop1, pop2);              \
        }                                               \
        RELEASE_SYNCHOBJECT                             \
    }

//
// Monster macros!
//
#define SLOCKFRAG1(x)       \
    SLOCKFRAG1_8(x)         \
    SLOCKFRAG1_16(x)        \
    SLOCKFRAG1_32(x)

#define SLOCKFRAG2(x)       \
    SLOCKFRAG2_8(x)         \
    SLOCKFRAG2_16(x)        \
    SLOCKFRAG2_32(x)

#define SLOCKFRAG2REF(x)    \
    SLOCKFRAG2REF_8(x)      \
    SLOCKFRAG2REF_16(x)     \
    SLOCKFRAG2REF_32(x)


//
// Now finally the actual fragments
//



SLOCKFRAG2(Add)
SLOCKFRAG2(Or)
SLOCKFRAG2(Adc)
SLOCKFRAG2(Sbb)
SLOCKFRAG2(And)
SLOCKFRAG2(Sub)
SLOCKFRAG2(Xor)
SLOCKFRAG1(Not)
SLOCKFRAG1(Neg)
SLOCKFRAG1(Inc)
SLOCKFRAG1(Dec)
SLOCKFRAG2REF(Xchg)
SLOCKFRAG2REF(Xadd)
SLOCKFRAG2REF(CmpXchg)
FRAG2REF(SynchLockCmpXchg8bFrag32, ULONGLONG)
{
    GET_SYNCHOBJECT
    if (((ULONG)(ULONGLONG)pop1 & 0x7) == 0){
	LockCmpXchg8bFrag32 (cpu, pop1, pop2);
    } else {
	CmpXchg8bFrag32 (cpu, pop1, pop2);
    }
    RELEASE_SYNCHOBJECT
}

//
// Bts, Btr and Btc only come in 16bit and 32bit flavors
//
SLOCKFRAG2_16(BtsMem)
SLOCKFRAG2_16(BtsReg)
SLOCKFRAG2_16(BtrMem)
SLOCKFRAG2_16(BtrReg)
SLOCKFRAG2_16(BtcMem)
SLOCKFRAG2_16(BtcReg)

SLOCKFRAG2_32(BtsMem)
SLOCKFRAG2_32(BtsReg)
SLOCKFRAG2_32(BtrMem)
SLOCKFRAG2_32(BtrReg)
SLOCKFRAG2_32(BtcMem)
SLOCKFRAG2_32(BtcReg)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\synlock.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    synlock.h

Abstract:
    
    Prototypes for synlock.c

Author:

    22-Aug-1995 t-orig (Ori Gershony)

Revision History:
        24-Aug-1999 [askhalid] copied from 32-bit wx86 directory and make work for 64bit.
        20-Sept-1999[barrybo]  added FRAG2REF(LockCmpXchg8bFrag32, ULONGLONG)

--*/



//
// Macros for 8 bit fragments
//
#define SLOCKFRAG1_8(x)                                 \
    FRAG1(SynchLock ## x ## Frag8, unsigned char);

#define SLOCKFRAG2_8(x)                                 \
    FRAG2(SynchLock ## x ## Frag8, unsigned char);

#define SLOCKFRAG2REF_8(x)                              \
    FRAG2REF(SynchLock ## x ## Frag8, unsigned char);    


//
// Macros for 16 bit fragments
//
#define SLOCKFRAG1_16(x)                                \
    FRAG1(SynchLock ## x ## Frag16, unsigned short);

#define SLOCKFRAG2_16(x)                                \
    FRAG2(SynchLock ## x ## Frag16, unsigned short);

#define SLOCKFRAG2REF_16(x)                             \
    FRAG2REF(SynchLock ## x ## Frag16, unsigned short);


//
// Macros for 32 bit fragments
//
#define SLOCKFRAG1_32(x)                                \
    FRAG1(SynchLock ## x ## Frag32, unsigned long);

#define SLOCKFRAG2_32(x)                                \
    FRAG2(SynchLock ## x ## Frag32, unsigned long);

#define SLOCKFRAG2REF_32(x)                             \
    FRAG2REF(SynchLock ## x ## Frag32, unsigned long);

//
// Monster macros!
//
#define SLOCKFRAG1(x)       \
    SLOCKFRAG1_8(x)         \
    SLOCKFRAG1_16(x)        \
    SLOCKFRAG1_32(x)

#define SLOCKFRAG2(x)       \
    SLOCKFRAG2_8(x)         \
    SLOCKFRAG2_16(x)        \
    SLOCKFRAG2_32(x)

#define SLOCKFRAG2REF(x)    \
    SLOCKFRAG2REF_8(x)      \
    SLOCKFRAG2REF_16(x)     \
    SLOCKFRAG2REF_32(x)


//
// Now finally the actual fragments
//

SLOCKFRAG2(Add)
SLOCKFRAG2(Or)
SLOCKFRAG2(Adc)
SLOCKFRAG2(Sbb)
SLOCKFRAG2(And)
SLOCKFRAG2(Sub)
SLOCKFRAG2(Xor)
SLOCKFRAG1(Not)
SLOCKFRAG1(Neg)
SLOCKFRAG1(Inc)
SLOCKFRAG1(Dec)
SLOCKFRAG2REF(Xchg)
SLOCKFRAG2REF(Xadd)
SLOCKFRAG2REF(CmpXchg)
FRAG2REF(SynchLockCmpXchg8bFrag32, ULONGLONG);

//
// Bts, Btr and Btc only come in 16bit and 32bit flavors
//
SLOCKFRAG2_16(BtsMem)
SLOCKFRAG2_16(BtsReg)
SLOCKFRAG2_16(BtrMem)
SLOCKFRAG2_16(BtrReg)
SLOCKFRAG2_16(BtcMem)
SLOCKFRAG2_16(BtcReg)

SLOCKFRAG2_32(BtsMem)
SLOCKFRAG2_32(BtsReg)
SLOCKFRAG2_32(BtrMem)
SLOCKFRAG2_32(BtrReg)
SLOCKFRAG2_32(BtcMem)
SLOCKFRAG2_32(BtcReg)

//
// Now undef the macros
//
#undef SLOCKFRAG1_8
#undef SLOCKFRAG2_8
#undef SLOCKFRAG2REF_8
#undef SLOCKFRAG1_16
#undef SLOCKFRAG2_16
#undef SLOCKFRAG2REF_16
#undef SLOCKFRAG1_32
#undef SLOCKFRAG2_32
#undef SLOCKFRAG2REF_32
#undef SLOCKFRAG1
#undef SLOCKFRAG2
#undef SLOCKFRAG2REF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\suspend.c ===
/*++

Copyright (c) 1999-1998 Microsoft Corporation

Module Name: 

    suspend.c

Abstract:
    
    This module implements CpuSuspendThread, CpuGetContext and CpuSetContext.

Author:

    14-Dec-1999  SamerA

Revision History:

--*/
 
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>

#define _WX86CPUAPI_
#include "wx86.h"
#include "wx86nt.h"
#include "wx86cpu.h"
#include "cpuassrt.h"
#ifdef MSCCPU
#include "ccpu.h"
#include "msccpup.h"
#undef GET_BYTE
#undef GET_SHORT
#undef GET_LONG
#else
#include "threadst.h"
#include "instr.h"
#include "frag.h"
ASSERTNAME;
#endif
#include "fragp.h"
#include "cpunotif.h"


VOID
RemoteSuspendAtNativeCode (
    VOID);




NTSTATUS
CpupFreeSuspendMsg(
    PCPU_SUSPEND_MSG CpuSuspendMsg)
/*++

Routine Description:

    This routine frees the resources associated with the suspend message structure on
    the remote side.
    
Arguments:

    CpuSuspendMsg   - Address of Suspend message structure

Return Value:

    NTSTATUS.

--*/
{
    SIZE_T RegionSize;

    NtClose(CpuSuspendMsg->StartSuspendCallEvent);
    NtClose(CpuSuspendMsg->EndSuspendCallEvent);
    
    RegionSize = sizeof(*CpuSuspendMsg);
    NtFreeVirtualMemory(NtCurrentProcess(),
                        &CpuSuspendMsg,
                        &RegionSize,
                        MEM_RELEASE);

    return STATUS_SUCCESS;
}


VOID
CpupSuspendAtNativeCode(
    PCONTEXT Context,
    PCPU_SUSPEND_MSG SuspendMsg)
/*++

Routine Description:

    Prepares the current to get suspended. This routine is executed as a result
    of calling RtlRemoteCall on this current thread. This routine will
    update the CPUCONTEXT of the current thread with the passed SuspendM Message
    and  notify the CPU that the current thread needs to be suspended.
    This routine must call NtContinue at the end to continue execution at
    the point where it has been interrupted.
    
    NOTE : Any change to the parameter list of this function must accompany
           a change to the RtlRemoteCall in CpuSuspendThread() and 
           RemoteSuspendAtNativeCode().
    
Arguments:

    Context     - Context to return to execute at
    SuspendMsg  - Suspend message address

Return Value:

    NONE

--*/
{
    DECLARE_CPU;


    InterlockedCompareExchangePointer(&cpu->SuspendMsg,
                                      SuspendMsg,
                                      NULL);

    if (cpu->SuspendMsg == SuspendMsg)
    {
        cpu->CpuNotify |= CPUNOTIFY_SUSPEND;
    }
    else
    {
        CpupFreeSuspendMsg(SuspendMsg);
    }

    if (Context)
    {
        NtContinue(Context,FALSE);
    }
        
    CPUASSERT(FALSE);

    return;
}



NTSTATUS
CpupSuspendCurrentThread(
    VOID)
/*++

Routine Description:

    This routine is called from the main CPU loop after leaving the translation cache,
    and start running native code. 
    Now it's the best time to suspend the currently executing thread.
    
Arguments:

    None.

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus;
    LARGE_INTEGER TimeOut;
    PCPU_SUSPEND_MSG CpuSuspendMsg;
    SIZE_T RegionSize;
    DECLARE_CPU;


    CpuSuspendMsg = cpu->SuspendMsg;

    NtStatus = NtSetEvent(CpuSuspendMsg->StartSuspendCallEvent, NULL);

    if (NT_SUCCESS(NtStatus))
    {
        TimeOut.QuadPart = UInt32x32To64( 40000, 10000 );
        TimeOut.QuadPart *= -1;

        NtStatus = NtWaitForSingleObject(CpuSuspendMsg->EndSuspendCallEvent,
                                         FALSE,
                                         &TimeOut);
    }
    else
    {
        LOGPRINT((TRACELOG, "CpupSuspendCurrentThread: Couldn't signal Start suspendcall event (%lx) -%lx\n", 
                  CpuSuspendMsg->StartSuspendCallEvent, NtStatus));

    }

    CpupFreeSuspendMsg(CpuSuspendMsg);

    cpu->SuspendMsg = NULL;

    return NtStatus;
}


NTSTATUS CpupReadBuffer(
    IN HANDLE ProcessHandle,
    IN PVOID Source,
    OUT PVOID Destination,
    IN ULONG Size)
/*++

Routine Description:

    This routine reads the source buffer into the destination buffer. It
    optimizes calls to NtReadVirtualMemory by checking whether the
    source buffer is in the currnt process or not.
    
Arguments:

    ProcessHandle  - Target process handle to read data from
    Source         - Target base address to read data from
    Destination    - Address of buffer to receive data read from the specified address space
    Size           - Size of data to read

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    return NtReadVirtualMemory(ProcessHandle,
                               Source,
                               Destination,
                               Size,
                               NULL);
}

NTSTATUS
CpupWriteBuffer(
    IN HANDLE ProcessHandle,
    IN PVOID Target,
    IN PVOID Source,
    IN ULONG Size)
/*++

Routine Description:

    Writes data to memory taken into consideration if the write is cross-process
    or not
    
Arguments:

    ProcessHandle  - Target process handle to write data into
    Target         - Target base address to write data at
    Source         - Address of contents to write in the specified address space
    Size           - Size of data to write
    
Return Value:

    NTSTATUS.

--*/
{
    return NtWriteVirtualMemory(ProcessHandle,
                                Target,
                                Source,
                                Size,
                                NULL);
}



NTSTATUS
CpupSetupSuspendCallParamters(
    IN HANDLE RemoteProcessHandle,
    IN PCPU_SUSPEND_MSG SuspendMsg,
    OUT PVOID *Arguments)
/*++

Routine Description:

    This routine setup the arguments for the remoted call to 
    CpupSuspendAtNativeCode.
    
Arguments:

    RemoteProcessHandle   - Handle of process to setup the arguments in
    SuspendMsg            - Suspend message to remote to the target process
    Arguments             - Pointer to an array of parameters

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    CPU_SUSPEND_MSG RemoteSuspendMsg;
    SIZE_T RegionSize;


    NtStatus = NtDuplicateObject(NtCurrentProcess(),
                                 SuspendMsg->StartSuspendCallEvent,
                                 RemoteProcessHandle,
                                 &RemoteSuspendMsg.StartSuspendCallEvent,
                                 0,
                                 0,
                                 DUPLICATE_SAME_ACCESS);
    if (!NT_SUCCESS(NtStatus))
    {
        LOGPRINT((ERRORLOG, "CpupSetupSuspendCallParamters: Couldn't duplicate event (%lx) into %lx -%lx\n", 
                  SuspendMsg->StartSuspendCallEvent, RemoteProcessHandle, NtStatus));

        return NtStatus;
    }

    NtStatus = NtDuplicateObject(NtCurrentProcess(),
                                 SuspendMsg->EndSuspendCallEvent,
                                 RemoteProcessHandle,
                                 &RemoteSuspendMsg.EndSuspendCallEvent,
                                 0,
                                 0,
                                 DUPLICATE_SAME_ACCESS);
    if (!NT_SUCCESS(NtStatus))
    {
        LOGPRINT((ERRORLOG, "CpupSetupSuspendCallParamters: Couldn't duplicate event (%lx) into %lx -%lx\n", 
                  SuspendMsg->EndSuspendCallEvent, RemoteProcessHandle, NtStatus));
        return NtStatus;
    }

    RegionSize = sizeof(RemoteSuspendMsg);
    *Arguments = NULL;
    NtStatus = NtAllocateVirtualMemory(RemoteProcessHandle,
                                       Arguments,
                                       0,
                                       &RegionSize,
                                       MEM_RESERVE | MEM_COMMIT,
                                       PAGE_READWRITE);
    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = NtWriteVirtualMemory(RemoteProcessHandle,
                                        *Arguments,
                                        &RemoteSuspendMsg,
                                        sizeof(RemoteSuspendMsg),
                                        NULL);
        if (!NT_SUCCESS(NtStatus))
        {
            LOGPRINT((ERRORLOG, "CpupSetupSuspendCallParamters: Couldn't write parameters in target process (%lx) -%lx\n", 
                      RemoteProcessHandle,NtStatus));

            NtFreeVirtualMemory(RemoteProcessHandle,
                                Arguments,
                                &RegionSize,
                                MEM_RELEASE);
        }
    }
    else
    {
        LOGPRINT((ERRORLOG, "CpupSetupSuspendCallParamters: Couldn't allocate parameters space in target process (%lx) -%lx\n", 
                  RemoteProcessHandle,NtStatus));
    }

    return NtStatus;
}


NTSTATUS
CpuSuspendThread(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    OUT PULONG PreviousSuspendCount OPTIONAL)
/*++

Routine Description:

    This routine is entered while the target thread is actually suspended, however, it's 
    not known if the target thread is in a consistent state relative to
    the CPU. This routine guarantees that the target thread to suspend isn't the
    currently executing thread. It will establish a handshake protocol to suspend the
    target thread at a consistent cpu state.

Arguments:

    ThreadHandle          - Handle of target thread to suspend
    ProcessHandle         - Handle of target thread's process 
    Teb                   - Address of the target thread's TEB
    PreviousSuspendCount  - Previous suspend count

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS, WaitStatus;
    ULONG_PTR CpuSimulationFlag;
    CPU_SUSPEND_MSG CpuSuspendMsg;
    PVOID Arguments;
    LARGE_INTEGER TimeOut;
    

    
    CpuSuspendMsg.StartSuspendCallEvent = INVALID_HANDLE_VALUE;
    CpuSuspendMsg.EndSuspendCallEvent = INVALID_HANDLE_VALUE;

    //
    // Are we in CPU simulation
    // 
    NtStatus = CpupReadBuffer(ProcessHandle,
                              ((PCHAR)Teb + FIELD_OFFSET(TEB, TlsSlots[WOW64_TLS_INCPUSIMULATION])),
                              &CpuSimulationFlag,
                              sizeof(CpuSimulationFlag));

    if (!NT_SUCCESS(NtStatus))
    {
        LOGPRINT((ERRORLOG, "CpuSuspendThread: Couldn't read INCPUSIMULATION flag (%lx) -%lx\n", 
                  CpuSimulationFlag, NtStatus));
        goto Cleanup;
    }

    if (!CpuSimulationFlag)
    {
        LOGPRINT((TRACELOG, "CpuSuspendThread: Thread is not running simulated code, so leave it suspended (%lx)", 
                  ThreadHandle));
        goto Cleanup;
    }

    NtStatus = NtCreateEvent(&CpuSuspendMsg.StartSuspendCallEvent,
                             EVENT_ALL_ACCESS,
                             NULL,
                             SynchronizationEvent,
                             FALSE);
    if (!NT_SUCCESS(NtStatus))
    {
        LOGPRINT((ERRORLOG, "CpuSuspendThread: Couldn't create StartSuspendCallEvent -%lx\n", 
                  NtStatus));
        goto Cleanup;
    }

    NtStatus = NtCreateEvent(&CpuSuspendMsg.EndSuspendCallEvent,
                             EVENT_ALL_ACCESS,
                             NULL,
                             SynchronizationEvent,
                             FALSE);    
    if (!NT_SUCCESS(NtStatus))
    {
        LOGPRINT((ERRORLOG, "CpuSuspendThread: Couldn't create EndSuspendCallEvent -%lx\n", 
                  NtStatus));
        goto Cleanup;
    }

    NtStatus = CpupSetupSuspendCallParamters(ProcessHandle,
                                             &CpuSuspendMsg,
                                             &Arguments);
    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = RtlRemoteCall(ProcessHandle,
                                 ThreadHandle,
                                 (PVOID)RemoteSuspendAtNativeCode,
                                 1,
                                 (PULONG_PTR)&Arguments,
                                 TRUE,
                                 TRUE);
        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = NtResumeThread(ThreadHandle, NULL);
            if (!NT_SUCCESS(NtStatus))
            {
                LOGPRINT((ERRORLOG, "CpuSuspendThread: Couldn't resume thread (%lx) -%lx\n", 
                          ThreadHandle, NtStatus));
                goto Cleanup;
            }

            TimeOut.QuadPart = UInt32x32To64( 20000, 10000 );
            TimeOut.QuadPart *= -1;

            WaitStatus = NtWaitForSingleObject(CpuSuspendMsg.StartSuspendCallEvent,
                                               FALSE,
                                               &TimeOut);

            NtStatus = NtSuspendThread(ThreadHandle, PreviousSuspendCount);

            if (!NT_SUCCESS(WaitStatus))
            {
                LOGPRINT((ERRORLOG, "CpuSuspendThread: Couldn't wait for StartSuspendCallEvent -%lx\n", 
                          NtStatus));
                goto Cleanup;
            }
            
            if (WaitStatus == STATUS_TIMEOUT)
            {
                LOGPRINT((ERRORLOG, "CpuSuspendThread: Timeout on StartSuspendCallEvent -%lx. Thread %lx may already be waiting.\n", 
                          NtStatus, ThreadHandle));
            }


            if (NT_SUCCESS(NtStatus))
            {
                NtSetEvent(CpuSuspendMsg.EndSuspendCallEvent, NULL);
            }
        }
        else
        {
            LOGPRINT((ERRORLOG, "CpuSuspendThread: RtlRemoteCall failed -%lx\n", 
                      NtStatus));
        }
    }

Cleanup:    
    ;
    
    if (CpuSuspendMsg.StartSuspendCallEvent != INVALID_HANDLE_VALUE)
    {
        NtClose(CpuSuspendMsg.StartSuspendCallEvent);
    }

    if (CpuSuspendMsg.EndSuspendCallEvent != INVALID_HANDLE_VALUE)
    {
        NtClose(CpuSuspendMsg.EndSuspendCallEvent);
    }

    return NtStatus;
}


NTSTATUS
GetContextRecord(
    PCPUCONTEXT cpu,
    PCONTEXT_WX86 Context
    )
/*++

Routine Description:

    This routine extracts the context record out of the specified cpu context. 

Arguments:

    cpu      - CPU context structure
    Context  - Context record to fill 

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG ContextFlags;

    try 
    {
        ContextFlags = Context->ContextFlags;

        if ((ContextFlags & CONTEXT_CONTROL_WX86) == CONTEXT_CONTROL_WX86) 
        {
            Context->EFlags = GetEfl(cpu);
            Context->SegCs  = CS;
            Context->Esp    = esp;
            Context->SegSs  = SS;
            Context->Ebp    = ebp;
            Context->Eip    = eip;
            //Context->Eip    = cpu->eipReg.i4;
        }

        if ((ContextFlags & CONTEXT_SEGMENTS_WX86) == CONTEXT_SEGMENTS_WX86) 
        {
            Context->SegGs = GS;
            Context->SegFs = FS;
            Context->SegEs = ES;
            Context->SegDs = DS;
        }

        if ((ContextFlags & CONTEXT_INTEGER_WX86) == CONTEXT_INTEGER_WX86) 
        {
            Context->Eax = eax;
            Context->Ebx = ebx;
            Context->Ecx = ecx;
            Context->Edx = edx;
            Context->Edi = edi;
            Context->Esi = esi;
        }

        if ((ContextFlags & CONTEXT_FLOATING_POINT_WX86) == CONTEXT_FLOATING_POINT_WX86) 
        {
            //
            // FpuSaveContext() is the same as FNSAVE, except FNSAVE resets the
            // FPU when its done.
            //
            CALLFRAG1(FpuSaveContext, (PBYTE)&Context->FloatSave);
            Context->FloatSave.Cr0NpxState = 1;    // (Math Present)
        }

//    if ((ContextFlags & CONTEXT_DEBUG_WX86) == CONTEXT_DEBUG_WX86) 
//    {
//    }
    } 
    except (EXCEPTION_EXECUTE_HANDLER) 
    {
        NtStatus = GetExceptionCode();
    }

    return NtStatus;
}


NTSTATUS
CpupGetContextRecord(
    IN PCPUCONTEXT cpu,
    IN OUT PCONTEXT_WX86 Context)
/*++

Routine Description:

    This routine extracts the context record out of the specified cpu context. 

Arguments:

    cpu      - CPU context structure
    Context  - Context record to fill 

Return Value:

    NTSTATUS.

--*/
{
    return GetContextRecord(cpu, Context);
}


NTSTATUS
MsCpuGetContext(
    IN OUT PCONTEXT_WX86 Context
    )
/*++

Routine Description:

    This routine extracts the context record for the currently 
    executing thread. 

Arguments:

    Context  - Context record to fill 

Return Value:

    NTSTATUS.

--*/
{
    DECLARE_CPU;

    return CpupGetContextRecord(cpu, Context);
}


NTSTATUS
MsCpuGetContextThread(
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    IN OUT PCONTEXT_WX86 Context)
/*++

Routine Description:

    This routine extracts the context record of any thread. This is a generic routine.
    When entered, if the target thread isn't the currently executing thread, then it should be 
    guaranteed that the target thread is suspended at a proper CPU state.

Arguments:

    ProcessHandle  - Open handle to the process that the thread runs in
    Teb            - Pointer to the target's thread TEB
                     optimization purposes.
    Context        - Context record to fill                 

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PCPUCONTEXT CpuRemoteContext;
    CPUCONTEXT CpuContext;


    NtStatus = CpupReadBuffer(ProcessHandle,
                              ((PCHAR)Teb + FIELD_OFFSET(TEB, TlsSlots[WOW64_TLS_CPURESERVED])),
                              &CpuRemoteContext,
                              sizeof(CpuRemoteContext));

    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = CpupReadBuffer(ProcessHandle,
                                  CpuRemoteContext,
                                  &CpuContext,
                                  FIELD_OFFSET(CPUCONTEXT, FpData));

        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = CpupGetContextRecord(&CpuContext, Context);
        }
        else
        {
            LOGPRINT((ERRORLOG, "MsCpuGetContextThread: Couldn't read CPU context %lx -%lx\n", 
                      CpuRemoteContext, NtStatus));
        }
    }
    else
    {
        LOGPRINT((ERRORLOG, "MsCpuGetContextThread: Couldn't read CPU context address-%lx\n", 
                  NtStatus));
    }

    return NtStatus;
}


NTSTATUS
SetContextRecord(
    PCPUCONTEXT cpu,
    PCONTEXT_WX86 Context
    )
/*++

Routine Description:

    This routine sets the passed context record for the specified CPUCONTEXT.

Arguments:

    cpu      - CPU context structure
    Context  - Context record to set 

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG ContextFlags;

    try 
    {
        ContextFlags = Context->ContextFlags;

        if ((ContextFlags & CONTEXT_CONTROL_WX86) == CONTEXT_CONTROL_WX86) 
        {
            SetEfl(cpu, Context->EFlags);
            CS = (USHORT)Context->SegCs;
            esp = Context->Esp;
            SS = (USHORT)Context->SegSs;
            ebp = Context->Ebp;
            eip = Context->Eip;
#if MSCCPU
            eipTemp = Context->Eip;
#endif
        }

        if ((ContextFlags & CONTEXT_SEGMENTS_WX86) == CONTEXT_SEGMENTS_WX86) 
        {
            GS = (USHORT)Context->SegGs;
            FS = (USHORT)Context->SegFs;
            ES = (USHORT)Context->SegEs;
            DS = (USHORT)Context->SegDs;
        }

        if ((ContextFlags & CONTEXT_INTEGER_WX86) == CONTEXT_INTEGER_WX86) 
        {
            eax = Context->Eax;
            ebx = Context->Ebx;
            ecx = Context->Ecx;
            edx = Context->Edx;
            edi = Context->Edi;
            esi = Context->Esi;
        }

        if ((ContextFlags & CONTEXT_FLOATING_POINT_WX86) == CONTEXT_FLOATING_POINT_WX86) 
        {
            CALLFRAG1(FRSTOR, (PBYTE)&Context->FloatSave);
            // Ignore:  Context->FloatSave.Cr0NpxState
        }

//    if ((ContextFlags & CONTEXT_DEBUG_WX86) == CONTEXT_DEBUG_WX86) 
//    {
//    }
    } 
    except (EXCEPTION_EXECUTE_HANDLER) 
    {
        NtStatus = GetExceptionCode();
    }

    return NtStatus;
}


NTSTATUS
CpupSetContextRecord(
    PCPUCONTEXT cpu,
    PCONTEXT_WX86 Context
    )
/*++

Routine Description:

    This routine sets the passed context record for the specified CPU.

Arguments:

    cpu      - CPU context structure
    Context  - Context record to set 

Return Value:

    NTSTATUS.

--*/
{
    return SetContextRecord(cpu, Context);
}


NTSTATUS
MsCpuSetContext(
    PCONTEXT_WX86 Context
    )
/*++

Routine Description:

    This routine sets the context record for the currently executing thread. 

Arguments:

    Context  - Context record to fill 

Return Value:

    NTSTATUS.

--*/
{
    DECLARE_CPU;

    return CpupSetContextRecord(cpu, Context);
}



NTSTATUS
MsCpuSetContextThread(
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    IN OUT PCONTEXT_WX86 Context)
/*++

Routine Description:

    This routine sets the context record of any thread. This is a generic routine.
    When entered, if the target thread isn't the currently executing thread, then it should be 
    guaranteed that the target thread is suspended at a proper CPU state.

Arguments:

    ProcessHandle  - Open handle to the process that the thread runs in
    Teb            - Pointer to the target's thread TEB
    Context        - Context record to set

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PCPUCONTEXT CpuRemoteContext;
    CPUCONTEXT CpuContext;



    NtStatus = CpupReadBuffer(ProcessHandle,
                              ((PCHAR)Teb + FIELD_OFFSET(TEB, TlsSlots[WOW64_TLS_CPURESERVED])),
                              &CpuRemoteContext,
                              sizeof(CpuRemoteContext));

    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = CpupReadBuffer(ProcessHandle,
                                  CpuRemoteContext,
                                  &CpuContext,
                                  FIELD_OFFSET(CPUCONTEXT, FpData));

        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = CpupSetContextRecord(&CpuContext, Context);

            if (NT_SUCCESS(NtStatus))
            {
                NtStatus = CpupWriteBuffer(ProcessHandle,
                                           CpuRemoteContext,
                                           &CpuContext,
                                           FIELD_OFFSET(CPUCONTEXT, FpData));

                if (!NT_SUCCESS(NtStatus))
                {
                    LOGPRINT((ERRORLOG, "MsCpuSetContextThread: Couldn't write CPU context %lx -%lx\n", 
                              CpuRemoteContext, NtStatus));
                }
            }
        }
    }
    else
    {
        LOGPRINT((ERRORLOG, "MsCpuSetContextThread: Couldn't read CPU context address-%lx\n", 
                  NtStatus));
    }

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\axp64\lockhelp.s ===
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     lockhelp.s
// 
// Abstract:
// 
//     This module contains the assembly code for the 32bit lock instructions.  
//     We must used assembly code here because of the need for 
//     synchronization (we need ldl_l and stl_c)
// 
// Author:
// 
//     Dave Hastings (daveh) creation-date 05-Sep-1995
//      From ..\mips\lockhelp.s
// 
// Notes:
//      The failure case for the store conditional is a forward jump, because
//      AXP predicts that forward conditional jumps will not be taken, and 
//      backwards conditional jumps will be taken
//
// Revision History:

#include "kxalpha.h"
#include "soalpha.h"

.text

#define FRAGLOCK(fn)    FRAGMENT(fn ## LockHelper)
#define ENDFRAGLOCK(fn) END_FRAGMENT(fn ## LockHelper)

//
// Debug only macros to allow verification that we aren't iterating forever
//
#define ITCHK_INIT
#define ITCHK
	.set noreorder


        FRAGLOCK(Add)
// 
// Routine Description:
// 
//     This routine adds its two arguments and places the result
//     in the memory pointed to by pop1 if its content hasn't changed.
//     It also returns the value of op1 for flag calculation
// 
// Arguments:
// 
//     &op1 <a0> -- Pointer to place to store value of op1 once it it 
//                  retreived from memory.  It is used by the sign 
//                  calculation
//     pop1 <a1> -- A pointer to op1
//     op2  <a2> -- The immediate to add to op1
//
// Return Value:
// 
//     v0 contains the sum of op1 and op2
//
        ITCHK_INIT
        // 
        // Get the value of op1
        // add it to op2
        // store the value in op1
        // if the value of op1 changed between load and store, try again
        //
la01:   ldl_l   t0, (a1)
        addl    a2, t0, t1
        bis     t1, zero, v0
        stl_c   t1, (a1)
        beq     t1, la02
        
        //
        // return the value of op1 for the flags calculation
        //
        stl     t0, (a0)
        
        
        ret     zero, (ra)
        
        //
        // Someone else modified (or might have modified) the location
        // we're trying to atomically modify
        //
la02:   ITCHK
        br      zero, la01
        ENDFRAGLOCK(Add)        


        FRAGLOCK(Or)
// 
// Routine Description:
// 
//     This routine ors its two arguments and places the result
//     in the memory pointed to by pop1 if its content hasn't changed.
// 
// Arguments:
// 
//     pop1 <a0> -- A pointer to op1
//     op2  <a1> -- The immediate to add to op1
//
// Return Value:
// 
//     v0 contains (op1 | op2)
//
        ITCHK_INIT
        // 
        // Get the value of op1
        // or it to op2
        // store the value in op1
        // if the value of op1 changed between load and store, try again
        //
lo01:   ldl_l   t0, (a0)
        bis     a1, t0, t1
        bis     t1, zero, v0
        stl_c   t1, (a0)
        beq     t1, lo02
        
        ret     zero, (ra)
        
        //
        // Someone else modified (or might have modified) the location
        // we're trying to atomically modify
        //
lo02:   ITCHK
        br      zero, lo01

        ENDFRAGLOCK(Or)        


        FRAGLOCK(Adc)
// 
// Routine Description:
// 
//     This routine adds its two arguments and carry, and places the result
//     in the memory pointed to by pop1 if its content hasn't changed.
//     It also returns the value of op1 for flag calculation.
// 
// Arguments:
// 
//     &op1 <a0> -- Pointer to place to store value of op1 once it it 
//                  retreived from memory.  It is used by the sign 
//                  calculation
//     pop1 <a1> -- A pointer to op1
//     op2  <a2> -- The immediate to add to op1
//     carry<a3> -- The value of the carry flag
//
// Return Value:
// 
//     v0 contains (op1 + op2 + carry)
//
        ITCHK_INIT
        //
        // Get the value of op1
        // add it to op2 and carry
        // store it back into op1
        // if the value of op1 changed between load and store, try again
        //
lac01:  ldl_l   t0, (a1)
        addl    a2, t0, t1
        addl    t1, a3, t1
        bis     t1, zero, v0
        stl_c   t1, (a1)
        beq     t1, lac02
        
        //
        // return the value of op1 for sign calculation
        //
        stl     t0, (a0)
        
        ret     zero, (ra)
        
        //
        // Someone else modified (or might have modified) the location
        // we're trying to atomically modify
        //
lac02:  ITCHK
        br      zero, lac01
        
        ENDFRAGLOCK(Adc)        


        FRAGLOCK(Sbb)
// 
// Routine Description:
// 
//     This routine subtracts op2+carry from op1 and places the result
//     in the memory pointed to by pop1 if its content hasn't changed.
//     It also returns the value of op1 for use in flag calculation.
// 
// Arguments:
// 
//     &op1 <a0> -- A place to store the content of op1 once determined
//     pop1 <a1> -- A pointer op1
//     op2  <a2> -- The immediate to add to op1
//     carry<a3> -- The value of the carry flag
//
// Return Value:
// 
//     v0 contains op1 - (op2 + carry)
//
        ITCHK_INIT
        //
        // Get the value of op1
        // subtract op2 and carry
        // store it back into op1
        // if the value of op1 changed between load and store, try again
        //
sbb01:  ldl_l   t0, (a1)
        subl    t0, a2, t1
        subl    t1, a3, t1
        bis     t1, zero, v0
        stl_c   t1, (a1)
        beq     t1, sbb02
        
        //
        // return the value of op1 for sign calculation
        //
        stl     t0, (a0)
        
        ret     zero, (ra)
        
        //
        // Someone else modified (or might have modified) the location
        // we're trying to atomically modify
        //
sbb02:  ITCHK
        br      zero, sbb01
        

        ENDFRAGLOCK(Sbb)        


        FRAGLOCK(And)
// 
// Routine Description:
// 
//     This routine ands its two arguments and places the result
//     in the memory pointed to by pop1 if its content hasn't changed.
// 
// Arguments:
// 
//     pop1 <a0> -- A pointer to the content of op1
//     op2  <a1> -- The immediate to add to op1
//
// Return Value:
// 
//     v0 contains (op1 & op2)
//
        ITCHK_INIT
        //
        // get the value of op1
        // and it with op2
        // store the result in op1
        // if the value of op1 changed between load and store, try again
        //
and01:  ldl_l   t0, (a0)
        and     t0, a1, t1
        bis     t1, zero, v0
        stl_c   t1, (a0)
        beq     t1, and02
        
        ret     zero, (ra)
        
        //
        // Someone else modified (or might have modified) the location
        // we're trying to atomically modify
        //
and02:  ITCHK
        br      zero, and01
        
        ENDFRAGLOCK(And)        


        FRAGLOCK(Sub)
// 
// Routine Description:
// 
//     This routine subtracts op2 from op1 and places the result
//     in the memory pointed to by pop1 if its content hasn't changed.
//     It also returns the value of op1 for flag calculation.
// 
// Arguments:
// 
//     &op1 <a0> -- A place to store the content of op1 once determined
//     pop1 <a1> -- A pointer to the content of op1
//     op2  <a2> -- The immediate to add to op1
//
// Return Value:
// 
//     v0 contains op1-op2
//
        ITCHK_INIT
        //
        // get the value of op1
        // subtract op2
        // store the result in op1
        // if the value of op1 changed between load and store, try again
        //
sub01:  ldl_l   t0, (a1)
        subl    t0, a2, t1
        bis     t1, zero, v0
        stl_c   t1, (a1)
        beq     t1, sub02
        
        //
        // return the value of op1 for sign calculation
        //
        stl     t0, (a0)
        
        ret     zero, (ra)
        
        //
        // Someone else modified (or might have modified) the location
        // we're trying to atomically modify
        //
sub02:  ITCHK
        br      zero, sub01
        
        
        ENDFRAGLOCK(Sub)        


        FRAGLOCK(Xor)
// 
// Routine Description:
// 
//     This routine xors its two arguments and places the result
//     in the memory pointed to by pop1 if its content hasn't changed.
// 
// Arguments:
// 
//     pop1 <a0> -- A pointer to the content of op1
//     op2  <a1> -- The immediate to add to op1
//
// Return Value:
// 
//     v0 contains (op1 ^ op2)
//
        ITCHK_INIT
        // 
        // get the value of op1
        // xor with op2
        // store the result in op1
        // if the value of op1 changed between load and store, try again
        //
xor01:  ldl_l   t0, (a0)        
        xor     t0, a1, t1
        bis     t1, zero, v0
        stl_c   t1, (a0)
        beq     t1, xor02
        
        ret     zero, (ra)
        
        //
        // Someone else modified (or might have modified) the location
        // we're trying to atomically modify
        //
xor02:  ITCHK
        br      zero, xor01
        
        ENDFRAGLOCK(Xor)        


        FRAGLOCK(Not)
// 
// Routine Description:
// 
//      This routine computes the NOT of op1 and stores it in pop1
// 
// Arguments:
// 
//     pop1 <a0> -- A pointer to op1
//
// Return Value:
// 
//     none
//
        ITCHK_INIT
        // 
        // get the value of op1
        // not 
        // store the result in op1
        // if the value of op1 changed between load and store, try again
        //
not01:  ldl_l   t0, (a0)
        ornot   zero, t0, t1
        stl_c   t1, (a0)
        beq     t1, not02
        
        ret     zero, (ra)
        
        //
        // Someone else modified (or might have modified) the location
        // we're trying to atomically modify
        //
not02:  ITCHK
        br      zero, not01
        
        ENDFRAGLOCK(Not)        


        FRAGLOCK(Neg)
// 
// Routine Description:
// 
//     This routine calculates the negative of op1 and stores it in pop1
// 
// Arguments:
// 
//     &op1 <a0> -- A place to store the content of op1 once determined
//     pop1 <a1> -- A pointer to the content of op1
//
// Return Value:
// 
//     v0 contains -op1
//
        ITCHK_INIT
        //
        // get value of op1
        // form two's complement
        // store the result in op1
        // if the value of op1 changed between load and store, try again
        //
neg01:  ldl_l   t0, (a1)
        subl    zero, t0, t1
        bis     t1, zero, v0
        stl_c   t1, (a1)
        
        //
        // return the value of op1 for sign calculation
        //
        stl     t0, (a0)
        
        ret     zero, (ra)
        
        //
        // Someone else modified (or might have modified) the location
        // we're trying to atomically modify
        //
neg02:  ITCHK
        br      zero, neg01
        ENDFRAGLOCK(Neg)        


        FRAGLOCK(Bts)
// 
// Routine Description:
// 
//     This routine sets bit in op1 and stores it back into pop1.  It returns
//     the original state of the bit in op1.     
// 
// Arguments:
// 
//     pop1 <a0> -- A pointer to the content of op1
//     bit  <a1> -- The bit to set
//
// Return Value:
// 
//     The original "bit" bit in op1
//
        ITCHK_INIT
        //
        // get the value of op1
        // set the bit
        // store the result in op1
        // if the value of op1 changed between load and store, try again
        //
bts01:  ldl_l   t0, (a0)
        bis     t0, a1, t1
        stl_c   t1, (a0)
        beq     t1, bts02
        
        //
        // return the original value of bit
        //
        and     t0, a1, v0
        
        ret     zero, (ra)
        
        //
        // Someone else modified (or might have modified) the location
        // we're trying to atomically modify
        //
bts02:  ITCHK
        br      zero, bts01
        ENDFRAGLOCK(Bts)        


        FRAGLOCK(Btr)
// 
// Routine Description:
// 
//     This routine resets bit in op1 and stores it back into pop1.  It returns
//     the original state of the bit in op1.     
// 
// Arguments:
// 
//     pop1 <a0> -- A pointer to the content of op1
//     bit  <a1> -- The bit to reset
//
// Return Value:
// 
//     The original "bit" bit in op1
//
        ITCHK_INIT
        //
        // get the value of op1
        // clear the bit
        // store the result in op1
        // if the value of op1 changed between load and store, try again
        //
btr01:  ldl_l   t0, (a0)
        bic     t0, a1, t1
        stl_c   t1, (a0)
        beq     t1, btr02
        
        //
        // return the original value of bit
        //
        and     t0, a1, v0
        
        ret     zero, (ra)
        
        //
        // Someone else modified (or might have modified) the location
        // we're trying to atomically modify
        //
btr02:  ITCHK
        br      zero, btr01
        ENDFRAGLOCK(Btr)        


        FRAGLOCK(Btc)
// 
// Routine Description:
// 
//     This routine complements bit in op1 and stores it back into pop1.  It returns
//     the original state of the bit in op1.     
// 
// Arguments:
// 
//     pop1 <a0> -- A pointer to the content of op1
//     bit  <a1> -- The bit to complement
//
// Return Value:
// 
//     The original "bit" bit in op1
//
        //
        // get the value of op1
        // complement the bit
        // store the result in op1
        // if the value of op1 changed between load and store, try again
        //
btc01:  ldl_l   t0, (a0)
        xor     t0, a1, t1
        stl_c   t1, (a0)
        beq     t1, btc02
        
        //
        // return after checking the bit
        //
        and     t0, a1, v0
        
        ret     zero, (ra)
        
        //
        // Someone else modified (or might have modified) the location
        // we're trying to atomically modify
        //
btc02:  ITCHK
        br      zero, btc01
        ENDFRAGLOCK(Btc)        


        FRAGLOCK(Xchg)
// 
// Routine Description:
// 
//     This routine exchanges the values pointed to by pop1 and pop2.  It is
//     understood that pop2 points to an intel register and therefore does
//     not require synchronized access
// 
// Arguments:
// 
//     pop1 <a0> -- A pointer to the content of op1
//     pop2 <a1> -- A pointer to the content of op2
//
// Return Value:
// 
//     none
//
        ITCHK_INIT
        //
        //  Get op2
        //
xchg01: ldl     t1, (a1)
        
        //
        // get op1
        // store op2 into op1 (possibly memory)
        // if the value of op1 changed between load and store, try again
        //
        ldl_l   t0, (a0)
        stl_c   t1, (a0)
        beq     t1, xchg02
        
        stl     t0, (a1)
        
        ret     zero, (ra)
        //
        // Someone else modified (or might have modified) the location
        // we're trying to atomically modify
        //
xchg02: ITCHK
        br      zero, xchg01
        ENDFRAGLOCK(Xchg)        


        FRAGLOCK(Xadd)
// 
// Routine Description:
// 
//     This routine places op1 into pop2 and op1+op2 into pop1.  It is
//     understood that pop2 points to an intel register and therefore does
//     not require synchronized access
// 
// Arguments:
// 
//     &op1 <a0> -- A place to store op1 once known
//     pop1 <a1> -- A pointer to the content of op1
//     pop2 <a2> -- A pointer to the content of op2
//
// Return Value:
// 
//     none
//
        ITCHK_INIT
        //
        //  Get op2
        //
xadd01: ldl     t1, (a2)
        
        //
        // Get op1
        // add op2
        // if the value of op1 changed between load and store, try again
        //
        ldl_l   t0, (a1)
        addl    t1, t0, t1
        mov     t1, v0
        stl_c   t1, (a1)
        beq     t1, xadd02
        
        //
        // why do we do this???
        //
        stl     t0, (a2)
        stl     t0, (a0)
        
        ret     zero, (ra)
        
        //
        // Someone else modified (or might have modified) the location
        // we're trying to atomically modify
        //
xadd02: ITCHK
        br      zero, xadd01
        ENDFRAGLOCK(Xadd)        


        FRAGLOCK(CmpXchg)
// 
// Routine Description:
// 
//     This routine compares the accumulator with the destination.  If they
//     are equal, source is loaded in the destination, otherwise dest is loaded
//     into the accumulator.  It is understood that dest is the only pointer into
//     intel memory.
// 
// Arguments:
// 
//     eax  <a0> -- A pointer to the accumulator
//     pop1 <a1> -- A pointer to the destination
//     pop2 <a2> -- A pointer to the source
//     &op1 <a3> -- A place to store op1 once known
//
// Return Value:
// 
//     The value to put in the zero flag
//
// Notes:
//  
// 1.) On page 5-7 of Alpha Architecture Reference Manual 
//     (ISBN 1-55558-098-X) subtlety #4, "some implementations
//     may not allow a successful stx_c after a branch taken."
//     This means that the branch between the ldl_l and the stl_c
//     should be not taken for the case where we want to store the
//     value.
//  


        ITCHK_INIT
        //
        // get source and eax
        //
        ldl     t0, (a0)
cx10:   ldl     t2, (a2)
        
        //
        // Get destination
        //
        ldl_l   t1, (a1)
        
        //
        // check for d == eax
        // (can we use some of the cmove instructions here?)
        //
        cmpeq   t1, t0, t3        
        beq     t3, cx20
        
        //
        // They're equal so copy source to dest, set return value
        //
        stl_c   t2, (a1)
        beq     t2, cx30
        addl    zero, zero, v0
        stl     t1, (a3)
        
        ret     zero, (ra)
        
        //
        // Not equal, store dest in eax, set return value
        //
cx20:   stl     t1, (a0)
        stl     t1, (a3)
        addl    zero, 1, v0
        
        ret     zero, (ra)
        
        //
        // Someone else modified (or might have modified) the location
        // we're trying to atomically modify
        //
cx30:   ITCHK
        br      zero, cx10
   
        ENDFRAGLOCK(CmpXchg)        

	FRAGLOCK(CmpXchg8b)
// 
// Routine Description:
// 
//     This routine compares the accumulator with the destination.  If they
//     are equal, source is loaded in the destination, otherwise dest is loaded
//     into the accumulator.  It is understood that dest is the only pointer into
//     intel memory.
// 
// Arguments:
// 
//     eax  <a0> -- A pointer to the value of edx:eax
//     pop1 <a1> -- A pointer to the value of ecx:ebx
//     pop2 <a2> -- A pointer to the memory value
//
// Return Value:
// 
//     The value to put in the zero flag
//
// Notes:
//  
// 1.) On page 5-7 of Alpha Architecture Reference Manual 
//     (ISBN 1-55558-098-X) subtlety #4, "some implementations
//     may not allow a successful stx_c after a branch taken."
//     This means that the branch between the ldl_l and the stl_c
//     should be not taken for the case where we want to store the
//     value.
//  


        ITCHK_INIT
        //
        // get source and eax
        //
        ldq     t0, (a0)        // t0 = value of EDX:EAX
cxb10:  ldq     t1, (a1)        // t1 = value of ECX:EBX
        
        //
        // Get destination
        //
        ldq_l   t2, (a2)        // t2 = value of memory
        
        //
        // check for d == edx:eax
        // (can we use some of the cmove instructions here?)
        //
        cmpeq   t0, t2, t3
        beq     t3, cxb20
        
        //
        // They're equal so copy source to dest, set return value
        //
        stq_c   t1, (a2)
        beq     t1, cxb30
        addl    zero, zero, v0
        
        ret     zero, (ra)
        
        //
	// Not equal, store dest in edx:eax, set return value
        //
cxb20:	stl	t2, (a0)    // update edx:eax
        addl    zero, 1, v0
        
        ret     zero, (ra)
        
        //
        // Someone else modified (or might have modified) the location
        // we're trying to atomically modify
        //
cxb30:	 ITCHK
	br	zero, cxb10
   
	ENDFRAGLOCK(CmpXchg8b)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\cpu\ctrltrns.c ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    ctrltrns.c

Abstract:
    
    Control Transfer Fragments.

Author:

    10-July-1995 t-orig (Ori Gershony)

Revision History:

            24-Aug-1999 [askhalid] copied from 32-bit wx86 directory and make work for 64bit.
            20-Sept-1999[barrybo]  added FRAG2REF(LockCmpXchg8bFrag32, ULONGLONG)

--*/  

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#define _WX86CPUAPI_

#include "wx86nt.h"
#include "wx86cpu.h"
#include "instr.h"
#include "config.h"
#include "cpuassrt.h"
#include "fragp.h"
#include "entrypt.h"
#include "compiler.h"
#include "ctrltrns.h"
#include "threadst.h"
#include "tc.h"
#include "cpunotif.h"
#include "atomic.h"

ASSERTNAME;

VOID
FlushCallstack(
    PTHREADSTATE cpu
    )
/*++

Routine Description:

    Flush the callstack - the Translation Cache is flushing, which
    invalidates the callstack.

Arguments:

    cpu - per-thread info
    
Return Value:

    .

--*/
{
    //
    // Mark the callstack as valid.
    //
    cpu->CSTimestamp = TranslationCacheTimestamp;

    memset(cpu->callStack, 0, CSSIZE*sizeof(CALLSTACK));
    //
    // No need to reset cpu->CSIndex as the stack is actually implemented
    // within a circular buffer.  It can start at any offset
    //
}

// Call
ULONG
CTRL_CallFrag(
    PTHREADSTATE cpu,       // cpu state pointer
    ULONG inteldest,
    ULONG intelnext,
    ULONG nativenext
    )
{
    PUSH_LONG(intelnext);
    PUSH_CALLSTACK(intelnext, nativenext);
    ASSERTPtrInTCOrZero((PVOID)nativenext);

    eip = inteldest;

    return inteldest;
}

// Call FAR
ULONG
CTRL_CallfFrag(
    PTHREADSTATE cpu,       // cpu state pointer
    PUSHORT pinteldest,
    ULONG intelnext,
    ULONG nativenext
    )
{
    USHORT sel;
    DWORD offset;

    offset = *(UNALIGNED PULONG)(pinteldest);
    sel = *(UNALIGNED PUSHORT)(pinteldest+2);

    PUSH_LONG(CS);
    PUSH_LONG(intelnext);
    PUSH_CALLSTACK(intelnext, nativenext);
    ASSERTPtrInTCOrZero((PVOID)nativenext);

    eip = offset;
    CS = sel;

    return (ULONG)(ULONGLONG)pinteldest;  
}

// IRet
ULONG CTRL_INDIR_IRetFrag(PTHREADSTATE cpu)
{
    ULONG intelAddr, nativeAddr;
    DWORD CSTemp;

    POP_LONG(intelAddr);
    POP_LONG(CSTemp);
    PopfFrag32(cpu);

    eip = intelAddr;
    CS = (USHORT)CSTemp;
    POP_CALLSTACK(intelAddr,nativeAddr);
    ASSERTPtrInTCOrZero((PVOID)nativeAddr);

    return nativeAddr;
}

// Now the ret fragments
ULONG CTRL_INDIR_RetnFrag32(PTHREADSTATE cpu)
{
    ULONG intelAddr, nativeAddr;

    POP_LONG(intelAddr);
    eip = intelAddr;
    POP_CALLSTACK(intelAddr,nativeAddr);
    ASSERTPtrInTCOrZero((PVOID)nativeAddr);

    return nativeAddr;
}
ULONG CTRL_INDIR_RetnFrag16(PTHREADSTATE cpu)
{
    ULONG intelAddr, nativeAddr;

    POP_SHORT(intelAddr);
    intelAddr &= 0x0000ffff;
    eip = intelAddr;
    POP_CALLSTACK(intelAddr,nativeAddr);
    ASSERTPtrInTCOrZero((PVOID)nativeAddr);

    return nativeAddr;
}
ULONG CTRL_INDIR_RetfFrag32(PTHREADSTATE cpu)
{
    ULONG intelAddr, nativeAddr;
    ULONG CSTemp;

    POP_LONG(intelAddr);
    POP_LONG(CSTemp);

    eip = intelAddr;
    CS = (USHORT)CSTemp;
    POP_CALLSTACK(intelAddr,nativeAddr);
    ASSERTPtrInTCOrZero((PVOID)nativeAddr);

    return nativeAddr;
}
ULONG CTRL_INDIR_RetfFrag16(PTHREADSTATE cpu)
{
    ULONG intelAddr, nativeAddr;
    ULONG CSTemp;

    POP_SHORT(intelAddr);
    POP_SHORT(CSTemp);
    intelAddr &= 0x0000ffff;
    eip = intelAddr;
    CS = (USHORT)CSTemp;
    POP_CALLSTACK(intelAddr,nativeAddr);
    ASSERTPtrInTCOrZero((PVOID)nativeAddr);

    return nativeAddr;
}
ULONG CTRL_INDIR_Retn_iFrag32(PTHREADSTATE cpu, ULONG numBytes)
{
    ULONG intelAddr, nativeAddr;

    intelAddr = *(DWORD *)esp;
    eip = intelAddr;
    esp += numBytes+4;
    POP_CALLSTACK(intelAddr,nativeAddr);
    ASSERTPtrInTCOrZero((PVOID)nativeAddr);

    return nativeAddr;
}
ULONG CTRL_INDIR_Retn_iFrag16(PTHREADSTATE cpu, ULONG numBytes)
{
    ULONG intelAddr, nativeAddr;

    intelAddr = *(USHORT *)esp;
    eip = intelAddr;
    esp += numBytes+2;
    POP_CALLSTACK(intelAddr,nativeAddr);
    ASSERTPtrInTCOrZero((PVOID)nativeAddr);

    return nativeAddr;
}
ULONG CTRL_INDIR_Retf_iFrag32(PTHREADSTATE cpu, ULONG numBytes)
{
    ULONG intelAddr, nativeAddr;
    USHORT CSTemp;

    intelAddr = *(DWORD *)esp;
    CSTemp = *(USHORT *)(esp+sizeof(ULONG));
    eip = intelAddr;
    CS = CSTemp;
    esp += numBytes+sizeof(ULONG)+sizeof(ULONG);
    POP_CALLSTACK(intelAddr,nativeAddr);
    ASSERTPtrInTCOrZero((PVOID)nativeAddr);

    return nativeAddr;
}
ULONG CTRL_INDIR_Retf_iFrag16(PTHREADSTATE cpu, ULONG numBytes)
{
    ULONG intelAddr, nativeAddr;
    USHORT CSTemp;

    intelAddr = *(USHORT *)esp;
    CSTemp = *(USHORT *)(esp+sizeof(USHORT));
    eip = intelAddr;
    CS = CSTemp;
    esp += numBytes+sizeof(USHORT)+sizeof(USHORT);
    POP_CALLSTACK(intelAddr,nativeAddr);
    ASSERTPtrInTCOrZero((PVOID)nativeAddr);

    return nativeAddr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\cpu\codeseqp.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    codeseqp.h

Abstract:

    This header file contains the non-processor-specific includes and
    declarations used by mips, ppc, and alpha codeseq.c files.

Author:

    Barry Bond (barrybo) creation-date 23-Sept-1996

Revision History:

          24-Aug-1999 [askhalid] copied from 32-bit wx86 directory and make work for 64bit.
          20-Sept-1999[barrybo]  added FRAG2REF(LockCmpXchg8bFrag32, ULONGLONG)


--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#define _WX86CPUAPI_
#define _codegen_
#include <wx86.h>
#include <wx86nt.h>
#include <wx86cpu.h>
#include <cpuassrt.h>
#include <instr.h>
#include <config.h>
#include <threadst.h>
#include <frag.h>
#include <fragp.h>
#include <ptchstrc.h>
#include <codeseq.h>
#include <compiler.h>
#include <codegen.h>
#include <codesize.h>
#include <opt.h>
#if _ALPHA_
#include <soalpha.h>
#elif _MIPS_
#include <somips.h>
#elif _PPC_
#include <soppc.h>
#endif
#include <process.h>

extern int JumpToNextCompilationUnitHelper();
extern int CallJxxHelper();
extern int CallJxxSlowHelper();
extern int CallJxxFwdHelper();
extern int CallJmpDirectHelper();
extern int CallJmpDirectSlowHelper();
extern int CallJmpFwdDirectHelper();
extern int CallJmpfDirectHelper();
extern int CallJmpfDirect2Helper();
extern int CallDirectHelper();
extern int CallfDirectHelper();
extern int CallDirectHelper2();
extern int CallfDirectHelper2();
extern int CallIndirectHelper();
extern int CallfIndirectHelper();
extern int IndirectControlTransferHelper();
extern int IndirectControlTransferFarHelper();
extern int RegisterOffset[];

#define START_FRAGMENT                  \
    PULONG d = CodeLocation;

//
// fragment generation function beginnings and endings
//
#if _ALPHA_
    #define FRAGMENT(name)                  \
    ULONG                                   \
    Gen##name (                             \
        IN PULONG CodeLocation,             \
        IN ULONG CurrentECU,                \
        IN PINSTRUCTION Instruction         \
        )                                   \
    {                                       \
        const ULONG fCompiling = TRUE;      \
        START_FRAGMENT
#else
    #define FRAGMENT(name)                  \
    ULONG                                   \
    Gen##name (                             \
        IN PULONG CodeLocation,             \
        IN PINSTRUCTION Instruction         \
        )                                   \
    {                                       \
        const ULONG fCompiling = TRUE;      \
        START_FRAGMENT
#endif

 

#define END_FRAGMENT                    \
    return (ULONG)(ULONGLONG)(d - CodeLocation) * sizeof(ULONG);      \
}
        
#define OP_FRAGMENT(name)               \
ULONG                                   \
Gen##name (                             \
    IN PULONG CodeLocation,             \
    IN POPERAND Operand,                \
    IN ULONG OperandNumber              \
    )                                   \
{                                       \
    START_FRAGMENT

//
// These functions have a private interface.  The caller and callee have to
// agree how many of the parameters are valid.  This lets us use the same
// basic form for all of the code that goes into the translation cache
//
#if _ALPHA_
    #define PATCH_FRAGMENT(name)            \
    ULONG                                   \
    Gen##name (                             \
        IN PULONG CodeLocation,             \
        IN ULONG fCompiling,                \
        IN ULONG CurrentECU,                \
        IN ULONG Param1,                    \
        IN ULONG Param2                     \
        )                                   \
    {                                       \
        START_FRAGMENT
#else
    #define PATCH_FRAGMENT(name)            \
    ULONG                                   \
    Gen##name (                             \
        IN PULONG CodeLocation,             \
        IN ULONG fCompiling,                \
        IN ULONG Param1,                    \
        IN ULONG Param2                     \
        )                                   \
    {                                       \
        START_FRAGMENT
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\cpu\codeseq.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    codeseq.h

Abstract:

    This header file contains the function prototypes for all fragments
    in codeseq.c

Author:

    Barry Bond (barrybo) creation-date 23-Sept-1996

Revision History:


--*/


#undef FRAGMENT
#undef PATCH_FRAGMENT
#undef OP_FRAGMENT

#if _ALPHA_
    #define FRAGMENT(name)                  \
    ULONG                                   \
    Gen##name (                             \
        IN PULONG CodeLocation,             \
        IN ULONG CurrentECU,                \
        IN PINSTRUCTION Instruction         \
        );

    #define PATCH_FRAGMENT(name)            \
    ULONG                                   \
    Gen##name (                             \
        IN PULONG CodeLocation,             \
        IN ULONG fCompiling,                \
        IN ULONG CurrentECU,                \
        IN ULONG Param1,                    \
        IN ULONG Param2                     \
        );
#else
    #define FRAGMENT(name)                  \
    ULONG                                   \
    Gen##name (                             \
        IN PULONG CodeLocation,             \
        IN PINSTRUCTION Instruction         \
        );

    #define PATCH_FRAGMENT(name)            \
    ULONG                                   \
    Gen##name (                             \
        IN PULONG CodeLocation,             \
        IN ULONG fCompiling,                \
        IN ULONG Param1,                    \
        IN ULONG Param2                     \
        );
#endif

#define OP_FRAGMENT(name)               \
ULONG                                   \
Gen##name (                             \
    IN PULONG CodeLocation,             \
    IN POPERAND Operand,                \
    IN ULONG OperandNumber              \
    );


FRAGMENT(AddFragNoFlags32)
FRAGMENT(AddFragNoFlags32A)
FRAGMENT(AndFragNoFlags32)
FRAGMENT(AndFragNoFlags32A)
FRAGMENT(DecFragNoFlags32)
FRAGMENT(DecFragNoFlags32A)
FRAGMENT(IncFragNoFlags32)
FRAGMENT(IncFragNoFlags32A)
FRAGMENT(OrFragNoFlags32)
FRAGMENT(OrFragNoFlags32A)
FRAGMENT(SubFragNoFlags32)
FRAGMENT(SubFragNoFlags32A)
FRAGMENT(XorFragNoFlags32)
FRAGMENT(XorFragNoFlags32A)
FRAGMENT(StartBasicBlock)
FRAGMENT(JumpToNextCompilationUnit)
PATCH_FRAGMENT(JumpToNextCompilationUnit2)
FRAGMENT(CallCFrag)
FRAGMENT(CallCFragNoCpu)
FRAGMENT(CallCFragLoadEip)
FRAGMENT(CallCFragLoadEipNoCpu)
FRAGMENT(CallCFragLoadEipNoCpuSlow)
FRAGMENT(CallCFragLoadEipSlow)
FRAGMENT(CallCFragSlow)
FRAGMENT(CallCFragNoCpuSlow)
FRAGMENT(JaFrag)
FRAGMENT(JaeFrag)
FRAGMENT(JbeFrag)
FRAGMENT(JbFrag)
FRAGMENT(JeFrag)
FRAGMENT(JgFrag)
FRAGMENT(JlFrag)
FRAGMENT(JleFrag)
FRAGMENT(JneFrag)
FRAGMENT(JnlFrag)
FRAGMENT(JnoFrag)
FRAGMENT(JnpFrag)
FRAGMENT(JnsFrag)
FRAGMENT(JoFrag)
FRAGMENT(JpFrag)
FRAGMENT(JsFrag)
FRAGMENT(JecxzFrag)
FRAGMENT(JcxzFrag)
FRAGMENT(LoopFrag32)
FRAGMENT(LoopFrag16)
FRAGMENT(LoopneFrag32)
FRAGMENT(LoopneFrag16)
FRAGMENT(LoopeFrag32)
FRAGMENT(LoopeFrag16)
FRAGMENT(JxxBody)
PATCH_FRAGMENT(JxxBody2)
FRAGMENT(JxxStartSlow)
FRAGMENT(JxxBodySlow)
PATCH_FRAGMENT(JxxBodySlow2)
FRAGMENT(JxxBodyFwd)
PATCH_FRAGMENT(JxxBodyFwd2)
FRAGMENT(CallJmpDirect)
PATCH_FRAGMENT(CallJmpDirect2)
FRAGMENT(CallJmpDirectSlow)
PATCH_FRAGMENT(CallJmpDirectSlow2)
FRAGMENT(CallJmpFwdDirect)
PATCH_FRAGMENT(CallJmpFwdDirect2)
FRAGMENT(CallJmpfDirect)
PATCH_FRAGMENT(CallJmpfDirect2)
FRAGMENT(CallJmpIndirect)
FRAGMENT(CallJmpfIndirect)
FRAGMENT(CallRetIndirect)
FRAGMENT(CallDirect)
PATCH_FRAGMENT(CallDirect2)
PATCH_FRAGMENT(CallDirect3)
FRAGMENT(CallfDirect)
PATCH_FRAGMENT(CallfDirect2)
PATCH_FRAGMENT(CallfDirect3)
FRAGMENT(CallIndirect)
FRAGMENT(CallfIndirect)
PATCH_FRAGMENT(CallIndirect2)
PATCH_FRAGMENT(CallfIndirect2)
FRAGMENT(Movsx8To32)
FRAGMENT(Movsx8To32Slow)
FRAGMENT(Movsx16To32)
FRAGMENT(Movsx16To32Slow)
FRAGMENT(Movsx8To16)
FRAGMENT(Movsx8To16Slow)
FRAGMENT(Movzx8To32)
FRAGMENT(Movzx8To32Slow)
FRAGMENT(Movzx16To32)
FRAGMENT(Movzx16To32Slow)
FRAGMENT(Movzx8To16)
FRAGMENT(Movzx8To16Slow)
FRAGMENT(EndCompilationUnit)
FRAGMENT(EndMovSlow)

#if _ALPHA_
OP_FRAGMENT(OperandMovRegToReg8B)
OP_FRAGMENT(OperandMovToMem8D)
OP_FRAGMENT(OperandMovToMem16D)
#endif

OP_FRAGMENT(OperandMovToMem32B)
OP_FRAGMENT(OperandMovToMem32D)
OP_FRAGMENT(OperandMovToMem16B)
OP_FRAGMENT(OperandMovToMem16W)
OP_FRAGMENT(OperandMovToMem8B)
OP_FRAGMENT(OperandMovToReg)
OP_FRAGMENT(OperandMovRegToReg32)
OP_FRAGMENT(OperandMovRegToReg16)
OP_FRAGMENT(OperandMovRegToReg8)
OP_FRAGMENT(OperandImm)
OP_FRAGMENT(OperandRegRef)
OP_FRAGMENT(OperandRegVal)
OP_FRAGMENT(LoadCacheReg)

ULONG GenOperandAddr(
    PULONG CodeLocation,
    POPERAND Operand,
    ULONG OperandNumber,
    ULONG FsOverride
    );

#undef FRAGMENT
#undef PATCH_FRAGMENT
#undef OP_FRAGMENT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\cpu\findpc.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    findpc.h

Abstract:

    This module declares a function to determine the address of the translation
    cache within the callstack.

Author:

    Barry Bond (barrybo) creation-date 13-May-1996

Revision History:


--*/

ULONG
FindPcInTranslationCache(
    PEXCEPTION_POINTERS pExceptionPointers
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\cpu\ptchstrc.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    patchstrc.h

Abstract:

    This include file contains structures describing the patchable 
    fragments.

Author:

    Dave Hastings (daveh) creation-date 24-Jun-1995

Revision History:


--*/

#ifndef _PATCHSTRC_H_
#define _PATCHSTRC_H_


ULONG
PlaceJxx(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    );

ULONG
PlaceJxxSlow(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    );

ULONG
PlaceJxxFwd(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    );

ULONG
PlaceJmpDirect(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    );
    
ULONG
PlaceJmpDirectSlow(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    );
    
ULONG
PlaceJmpFwdDirect(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    );
    
ULONG
PlaceJmpfDirect(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    );
    
ULONG
PlaceCallDirect(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    );

ULONG
PlaceCallfDirect(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    );

ULONG
PlaceNop(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    );
    
extern ULONG EndTranslatedCode[];    
extern CONST PVOID FragmentArray[];
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\cpu\fragdata.c ===
/*--

Copyright (c) 1996  Microsoft Corporation

Module Name:

    fragdata.c

Abstract:

    This module contains arrays that are used to connect operations with
    fragments.  There is a fragment description array, and a fragment array.

Author:

    Dave Hastings (daveh) creation-date 08-Jan-1995


Revision History:


--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <instr.h>
#include <config.h>
#include <threadst.h>
#include <frag.h>
#include <fraglib.h>
#include <ptchstrc.h>
#include <codeseq.h>
#include <ctrltrns.h>

CONST FRAGDESC Fragments[] = {
    #define DEF_INSTR(OpName, FlagsNeeded, FlagsSet, RegsSet, Opfl, FastPlaceFn, SlowPlaceFn, FragName)   \
        {FastPlaceFn, SlowPlaceFn, Opfl, RegsSet, FlagsNeeded, FlagsSet},

    #include "idata.h"
};

CONST PVOID FragmentArray[] = {
    #define DEF_INSTR(OpName, FlagsNeeded, FlagsSet, RegsSet, Opfl, FastPlaceFn, SlowPlaceFn, FragName)   \
        FragName,

    #include "idata.h"
};

CONST PPLACEOPERATIONFN PlaceFn[] = {
    #define DEF_PLACEFN(Name) Name,

    #include "fndata.h"
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\cpu\ctrltrns.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ctrltrns.h

Abstract:
    
    Prototypes for control transfer fragments.

Author:

    10-July-1995 t-orig (Ori Gershony)

Revision History:

--*/

BOOL
InitializeCallstack(
    VOID
    );

VOID
FlushCallstack(
    PTHREADSTATE cpu
    );

// Called by the assembly-langauge CallDirectX fragments
ULONG
CTRL_CallFrag(
    PTHREADSTATE cpu,       // cpu state pointer
    ULONG inteldest,
    ULONG intelnext,
    ULONG nativenext
    );

ULONG
CTRL_CallfFrag(
    PTHREADSTATE cpu,       // cpu state pointer
    PUSHORT pinteldest,
    ULONG intelnext,
    ULONG nativenext
    );

// And now the ret fragments
ULONG CTRL_INDIR_IRetFrag(PTHREADSTATE cpu);
ULONG CTRL_INDIR_RetnFrag32(PTHREADSTATE cpu);
ULONG CTRL_INDIR_RetnFrag16(PTHREADSTATE cpu);
ULONG CTRL_INDIR_Retn_iFrag32(PTHREADSTATE cpu, ULONG numBytes);
ULONG CTRL_INDIR_Retn_iFrag16(PTHREADSTATE cpu, ULONG numBytes);
ULONG CTRL_INDIR_RetfFrag32(PTHREADSTATE cpu);
ULONG CTRL_INDIR_RetfFrag16(PTHREADSTATE cpu);
ULONG CTRL_INDIR_Retf_iFrag32(PTHREADSTATE cpu, ULONG numBytes);
ULONG CTRL_INDIR_Retf_iFrag16(PTHREADSTATE cpu, ULONG numBytes);

// And a few others
VOID BOPFrag(PTHREADSTATE cpu, ULONG bop, ULONG imm);
VOID UnsimulateFrag(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\cpu\process.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    process.h

Abstract:

    This module contains the proessor-independent routines used during
    RISC code generation.

Author:

    Barry Bond (barrybo) creation-date 27-Sept-1996

Revision History:


--*/

#ifndef _PROCESS_H_
#define _PROCESS_H_

#define ALIGN_DWORD_ALIGNED 2
#define ALIGN_WORD_ALIGNED 1
#define ALIGN_BYTE_ALIGNED 0

extern DWORD RegCache[NUM_CACHE_REGS];  // One entry for each cached register
extern DWORD Arg1Contents;
extern DWORD Arg2Contents;

ULONG
LookupRegInCache(
    ULONG Reg
    );

#define GetArgContents(OperandNumber)       \
    ((OperandNumber == 1) ? Arg1Contents :  \
    (OperandNumber == 2) ? Arg2Contents :   \
    NO_REG)

VOID SetArgContents(
    ULONG OperandNumber,
    ULONG Reg
    );

USHORT
ChecksumMemory(
    ENTRYPOINT *pEP
    );

DWORD
SniffMemory(
    ENTRYPOINT *pEP,
    USHORT Checksum
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\cpu\process.c ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation

Module Name:

    Process.c

Abstract:

    This module contains the entrypoints for processing instructions.

Author:

    Barry Bond (barrybo) creation-date 1-Apr-1996


Revision History:

            24-Aug-1999 [askhalid] copied from 32-bit wx86 directory and make work for 64bit.
            20-Sept-1999[barrybo]  added FRAG2REF(LockCmpXchg8bFrag32, ULONGLONG)


--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#define _WX86CPUAPI_
#include <wx86.h>
#include <wx86nt.h>
#include <wx86cpu.h>
#include <cpuassrt.h>
#include <config.h>
#include <instr.h>
#include <threadst.h>
#include <frag.h>
#include <compiler.h>
#include <ptchstrc.h>
#include <codeseq.h>
#include <findpc.h>
#include <tc.h>
#include <opt.h>
#include <atomic.h>
#include <cpunotif.h>
#define _codegen_
#if _PPC_
#include <soppc.h>
#elif _MIPS_
#include <somips.h>
#elif _ALPHA_
#include <soalpha.h>
ENTRYPOINT EntrypointECU;
#endif
#include <process.h>

ASSERTNAME;

#define MAX_OPERAND_SIZE 32     // allow upto 32 instructions per operand


DWORD RegCache[NUM_CACHE_REGS];     // One entry for each cached register
DWORD LastRegDeleted;

DWORD Arg1Contents;   // GP_ number of x86 reg held in A1, or NO_REG
DWORD Arg2Contents;   // GP_ number of x86 reg held in A1, or NO_REG

typedef enum _Operand_Op {
#if _ALPHA_
    OP_MovRegToReg8B,
#endif
    OP_MovToMem32B,
    OP_MovToMem32W,
    OP_MovToMem32D,
    OP_MovToMem16B,
    OP_MovToMem16W,
    OP_MovToMem16D,
    OP_MovToMem8B,
    OP_MovToMem8D,
    OP_MovRegToReg32,
    OP_MovRegToReg16,
    OP_MovRegToReg8
} OPERAND_OP;


CONST PPLACEOPERANDFN OpFragments[] = {
#if _ALPHA_
    GenOperandMovRegToReg8B,
#endif
    GenOperandMovToMem32B,
    GenOperandMovToMem32B,
    GenOperandMovToMem32D,
    GenOperandMovToMem16B,
    GenOperandMovToMem16W,
#if _ALPHA_
    GenOperandMovToMem16D,
    GenOperandMovToMem8B,
    GenOperandMovToMem8D,
#else
    GenOperandMovToMem16W,
    GenOperandMovToMem8B,
    GenOperandMovToMem8B,
#endif
    GenOperandMovRegToReg32,
    GenOperandMovRegToReg16,
    GenOperandMovRegToReg8
};


VOID
UpdateEntrypointNativeInfo(
    PCHAR NativeEnd
    );

ULONG
PlaceExceptionData(
    PCHAR Location,
    DWORD cEntryPoints
    );

ULONG
PlaceNativeCode(
    PCHAR CodeLocation
    );

VOID
DetermineOperandAlignment(
    BOOL EbpAligned,
    POPERAND Operand
    );
    
ULONG
DetermineInstructionAlignment(
    PINSTRUCTION Instruction
    );

ULONG
PlaceOperand(
    ULONG OperandNumber,
    POPERAND Operand,
    PINSTRUCTION Instruction,
    PCHAR Location
    );

PCHAR
InterleaveInstructions(
    OUT PCHAR CodeLocation,
    IN PCHAR  Op1Code,
    IN ULONG  Op1Count,
    IN PCHAR  Op2Code,
    IN ULONG  Op2Count
    );


ULONG
LookupRegInCache(
    ULONG Reg
    )
/*++

Routine Description:

    Determines if an x86 register is cached in a RISC register or not, and
    if so, which RISC register contains the x86 register.

Arguments:

    Reg - one of the GP_ constants or NO_REG.

Return Value:

    Offset into RegCache[] array if the x86 register is cached in a RISC
    register, or NO_REG if the x86 register is not cached.
    
--*/
{
    int RegCacheNum;

    //
    // Map the register number into one of the 32-bit x86 regs.
    //   ie. REG_AH, REG_AL, and REG_AX all become REG_EAX.
    //
    if (Reg == NO_REG) {
        return NO_REG;
    } else if (Reg >= GP_AH) {
        Reg -= GP_AH;
    } else if (Reg >= GP_AL) {
        Reg -= GP_AL;
    } else if (Reg >= GP_AX) {
        Reg -= GP_AX;
    } else if (Reg >= REG_ES) {
        return NO_REG;
    }

    //
    // Search the register cache to see if the 32-bit x86 register
    // is loaded into a RISC register already.
    //
    for (RegCacheNum=0; RegCacheNum<NUM_CACHE_REGS; ++RegCacheNum) {
        if (RegCache[RegCacheNum] == Reg) {
            return RegCacheNum;
        }
    }

    return NO_REG;
}

VOID SetArgContents(
    ULONG OperandNumber,
    ULONG Reg
    )
/*++

Routine Description:

    Updates information about what argument registers are known to
    contain x86 register values.

Arguments:

    OperandNumber - Number of ArgReg to update
                     (0 means no ArgReg caches the x86 register)
    Reg           - New contents of AREG_NP(OperandNumber)
                     (NO_REG means the ArgReg does not cache an x86 register)

Return Value:

    None.
    
--*/
{
    ULONG Reg2;
    ULONG Reg3;
    ULONG Reg4;

    //
    // If an 8- or 16-bit register is known to be in a particular
    // argreg, then older copies of the 32-bit register are invalid.
    // ie.  if a fragment calls SetArgContents(1, GP_AH) and Arg2Contents
    // is GP_AX, then Arg2Contents must be invalidated.
    //
    if (Reg >= GP_AH) {
        //
        // For a hi-8 register, invalidate the 16- and 32-bit versions
        //
        Reg2 = GP_AX + Reg-GP_AH;
        Reg3 = GP_EAX + Reg-GP_AH;
        Reg4 = NO_REG;
    } else if (Reg >= GP_AL) {
        //
        // For a low-8 register, invalidate the 16-bit and 32-bit versions
        //
        Reg2 = GP_AX + Reg-GP_AL;
        Reg3 = GP_EAX + Reg-GP_AL;
        Reg4 = NO_REG;
    } else if (Reg >= GP_AX) {
        //
        // For a 16-bit register, invalidate the lo-8, high-8 and 32-bit versions
        //
        Reg2 = GP_EAX + Reg-GP_AX;
        Reg3 = GP_AH + Reg-GP_AX;
        Reg4 = GP_AL + Reg-GP_AX;
    } else {
        //
        // For a 32-bit register, invalidate the low-8, high-8, and 16-bit versions
        //
        Reg2 = GP_AH + Reg-GP_EAX;
        Reg3 = GP_AL + Reg-GP_EAX;
        Reg4 = GP_AX + Reg-GP_EAX;
    }

    //
    // Assume that all other registers known to hold Reg are invalid, as
    // SetArgContents() is called only after a new value is stored from the
    // argreg into memory.
    //
    if (Arg1Contents == Reg || Arg1Contents == Reg2 || Arg1Contents == Reg3 || Arg1Contents == Reg4) {
        Arg1Contents = NO_REG;
    }
    if (Arg2Contents == Reg || Arg2Contents == Reg2 || Arg2Contents == Reg3 || Arg2Contents == Reg4) {
        Arg2Contents = NO_REG;
    }

    if (OperandNumber == 1) {
        Arg1Contents = Reg;
    } else if (OperandNumber == 2) {
        Arg2Contents = Reg;
    }
}

ULONG
LoadRegCacheForInstruction(
    DWORD RegsToCache,
    PCHAR CodeLocation
    )
/*++

Routine Description:

    Loads x86 regsisters into RISC registers based on information the
    analysis phase placed into RegsToCache and the current contents of
    the register cache.

Arguments:

    RegsToCache - list of x86 registers which will be referenced frequently
                  in subsequent instructions
    CodeLocation - pointer to place to generate code

Return Value:

    Count of DWORDs of code generated to load x86 registers into the cache.
    
--*/
{
    DWORD i;
    int RegCacheNum;
    PCHAR Location = CodeLocation;

    //
    // Iterate over the 8 32-bit x86 general-purpose registers
    //
    for (i=0; i<REGCOUNT; ++i, RegsToCache >>= REGSHIFT) {
        if (RegsToCache & REGMASK) {
            //
            // There is a register to cache.  See if it is already cached.
            //
            for (RegCacheNum = 0; RegCacheNum<NUM_CACHE_REGS; ++RegCacheNum) {
                if (RegCache[RegCacheNum] == i) {
                    //
                    // Register is already cached.  Nothing to do.
                    //
                    goto NextCachedReg;
                }
            }

            //
            // The register is not already cached, so cache it.
            //
            for (RegCacheNum = 0; RegCacheNum<NUM_CACHE_REGS; ++RegCacheNum) {
                if (RegCache[RegCacheNum] == NO_REG) {
                    //
                    // This slot is empty, so use it.
                    //
                    RegCache[RegCacheNum] = i;
                    //
                    // Generate code to load the register
                    //
                    Location += GenLoadCacheReg(
                                        (PULONG)Location,
                                        NULL,
                                        RegCacheNum
                                        );
                    goto NextCachedReg;
                }
            }

            //
            // There is no free register to cache the value in.
            // Select a cached register and use it.
            //
            LastRegDeleted = (LastRegDeleted+1) % NUM_CACHE_REGS;
            RegCache[LastRegDeleted] = i;
            //
            // Generate code to load the register
            //
            Location += GenLoadCacheReg(
                (PULONG)Location,
                NULL,
                LastRegDeleted
                );
        }
NextCachedReg:;
    }

    return (ULONG) (ULONGLONG)(Location - CodeLocation);  
}

VOID
ResetRegCache(
    VOID
    )
/*++

Routine Description:

    Invalidates the entire register cache by marking RISC registers as free.
    Functionally the same as:
        InvalidateRegCacheForInstruction(0xffffffff)
        LastRegDeleted = 0;

Arguments:

    None.

Return Value:

    None.
    
--*/
{
    int CacheRegNum;

    for (CacheRegNum = 0; CacheRegNum<NUM_CACHE_REGS; CacheRegNum++) {
        RegCache[CacheRegNum] = NO_REG;
    }
    LastRegDeleted = 0;
}


VOID
InvalidateRegCacheForInstruction(
    DWORD RegsSet
    )
/*++

Routine Description:

    Invalidates the register cache by marking RISC registers as free if
    RegsSet indicates the previous instruction modified the x86 register
    in the cache.

Arguments:

    RegsSet - list of x86 registers which have been modified.

Return Value:

    None.
    
--*/
{
    int CacheRegNum;

    //
    // Invalidate cached registers which have been alterd
    //
    for (CacheRegNum = 0; CacheRegNum<NUM_CACHE_REGS; CacheRegNum++) {
        if (RegCache[CacheRegNum] != NO_REG &&
            ((REGMASK << (REGSHIFT*RegCache[CacheRegNum])) & RegsSet)) {
            RegCache[CacheRegNum] = NO_REG;
            LastRegDeleted = CacheRegNum;
        }
    }
}

VOID
CleanupMovInstruction(
    PINSTRUCTION pInstr
    )
/*++

Routine Description:

    Performs some final optimizatins on MOV instructions.  This cannot
    be performed during the x86 analysis phase as it needs to know
    about register caching.

Arguments:

    pInstr - MOV instruction to clean up.

Return Value:

    None.  pInstr modified.
    
--*/
{
    if (pInstr->Operand1.Type == OPND_REGREF) {
        ULONG Reg;

        if (pInstr->Operand2.Type == OPND_REGVALUE &&
            pInstr->Operand2.Reg < GP_AH &&
            (Reg = LookupRegInCache(pInstr->Operand2.Reg)) != NO_REG) {

            //
            // pInstr is a MOV reg1, reg2 (Where reg2 is not a Hi8),
            // and reg2 is cached.  Set Operand1 to be an OPND_MOVREGTOREG
            // with Reg=destination register and IndexReg = source register
            // (in the cache).
            //
            pInstr->Operand2.Type = OPND_NONE;
            pInstr->Operand1.Type = OPND_MOVREGTOREG;
            pInstr->Operand1.IndexReg = pInstr->Operand1.Reg;
            pInstr->Operand1.Reg = Reg;
            pInstr->Operand1.Immed = pInstr->Operation;

        } else {

            //
            // pInstr is a MOV reg, X.  Rewrite it to be a NOP
            // with Operand1 set to X, Operand2 set to OPND_NONE,
            // and Operand3 set to OPND_MOVTOREG.
            //
            Reg = pInstr->Operand1.Reg;

            pInstr->Operand1 = pInstr->Operand2;
            pInstr->Operand2.Type = OPND_NONE;
            pInstr->Operand3.Type = OPND_MOVTOREG;
            pInstr->Operand3.Reg = Reg;
            pInstr->Operand3.Immed = pInstr->Operation;
        }
    } else {
        pInstr->Operand3.Type = OPND_MOVTOMEM;
        pInstr->Operand3.Immed = pInstr->Operation;

    }
}

ULONG PlaceInstructions(
    PCHAR CodeLocation,
    DWORD cEntryPoints
    )
/*++

Routine Description:

    Generates optimized native code for the entire InstructionStream[] array.

Arguments:

    CodeLocation    -- place to write the native code
    cEntryPoints    -- count of ENTRYPOINT structures describing the x86 code

Return Value:

    Size of native code generated, in bytes.
    
--*/
{
    ULONG NativeSize;
    int i;
    ULONG IntelNext;
    PULONG NextCompilationUnitStart;

    FixupCount = 0;

    //
    // Generate native code
    //
    NativeSize = PlaceNativeCode(CodeLocation);

    //
    // Generate the JumpToNextCompilationUnit code.  It loads
    // RegEip with the intel address of the Intel instruction following
    // this run of code.
    //
    // First, find the last non-Nop instruction in the stream.  These
    // are only present if there is an OPT_ instruction in the stream,
    // so the loop is guaranteed to terminate.
    //

    

    for (i=NumberOfInstructions-1; InstructionStream[i].Size == 0; i--)
        ;
    IntelNext = InstructionStream[i].IntelAddress +
                InstructionStream[i].Size;
    NextCompilationUnitStart = (PULONG)(CodeLocation+NativeSize);


    NativeSize += GenJumpToNextCompilationUnit(NextCompilationUnitStart,
#if _ALPHA_
                                               (ULONG)(ULONGLONG)&EntrypointECU,
#endif
                                               (PINSTRUCTION)IntelNext);



#if _ALPHA_
    //
    // Fixups which reference EntrypointECU will be patched by ApplyFixups()
    // to point at the EndCompilationUnit fragment generated here
    //

    EntrypointECU.nativeStart = CodeLocation + NativeSize;
    NativeSize += GenEndCompilationUnit((PULONG)(CodeLocation + NativeSize), 0, NULL);
#endif

    //
    // Update the nativeStart and nativeEnd fields in Entrypoints
    //
    UpdateEntrypointNativeInfo(CodeLocation + NativeSize);

    //
    // Use fixup information to finish generation
    //
    ApplyFixups(NextCompilationUnitStart);

    //
    // Optimize the resulting code
    //
    PeepNativeCode(CodeLocation, NativeSize);

    //
    // Generate the information required to regenerate EIP after
    // an exception
    //
    NativeSize += PlaceExceptionData(CodeLocation + NativeSize, cEntryPoints);

    return NativeSize;

}

VOID
UpdateEntrypointNativeInfo(
    PCHAR NativeEnd
    )
/*++

Routine Description:

    After native code is generated, this function sets the nativeStart and
    nativeEnd fields of entrypoints.

Arguments:

    NativeEnd       -- highest native address used for the generated code.

Return Value:

    None.  EntryPoints updated.
    
--*/
{
    PENTRYPOINT EntryPoint = NULL;
    ULONG i;
    BYTE InstrCount;

    InstrCount = 0;
    for (i=0; i<NumberOfInstructions; ++i) {

        //
        // Keep count of the number of x86 instructions within the
        // entrypoint (not counting 0-byte NOPs)
        //
        if (InstructionStream[i].Operation != OP_Nop ||
            InstructionStream[i].Size != 0) {
            InstrCount++;
        }

        if (EntryPoint != InstructionStream[i].EntryPoint) {
            if (EntryPoint) {
                EntryPoint->nativeEnd = InstructionStream[i].NativeStart-1;
            }
            InstrCount = 1;
            EntryPoint = InstructionStream[i].EntryPoint;
            EntryPoint->nativeStart = InstructionStream[i].NativeStart;
        }
    }
    EntryPoint->nativeEnd = NativeEnd;
}

ULONG
PlaceExceptionData(
    PCHAR Location,
    DWORD cEntryPoints
    )
/*++

Routine Description:

    Places the data required to regenerate EIP after an exception occurs.

Arguments:

    Locatoion       -- address to store the exception data to
    cEntryPoints    -- count of EntryPoints describing the x86 code generated

Return Value:

    Size of exception data, in bytes.
    
--*/
{
    DWORD i;
    PENTRYPOINT EP;
    PULONG pData;
    PINSTRUCTION pInstr;

    //
    // The format of the Exception data is a series of ULONGs:
    //   EXCEPTIONDATA_SIGNATURE (an illegal RISC instruction)
    //   cEntryPoints            (count of ENTRYPOINTs in InstructionStream[])
    //   for each ENTRYPOINT in the InstructionStream {
    //      ptr to ENTRYPOINT
    //      for each x86 instruction with non-zero x86 size {
    //          MAKELONG(offset of start of x86 instr from EP->IntelAddress,
    //                   offset of first RISC instr in the x86 instr from
    //                    EP->nativeStart)
    //      }
    //  }
    //
    // The last RISC offset in each EntryPoint has the low bit set to
    // mark it as the last offset.
    //
    //
    pData = (PULONG)Location;
    *pData = EXCEPTIONDATA_SIGNATURE;
    pData++;

    *pData = cEntryPoints;
    pData++;

    EP = NULL;
    pInstr = &InstructionStream[0];
    for (i=0; i<NumberOfInstructions; ++i, pInstr++) {
        if (EP != pInstr->EntryPoint) {
            if (EP) {
                //
                // flag the previous offset NativeStart as the last one for
                // that EntryPoint.
                //
                *(pData-1) |= 1;
            }
            EP = pInstr->EntryPoint;
            *pData = (ULONG)(ULONGLONG)EP;   
            pData++;
        }

        if (pInstr->Operation != OP_Nop || pInstr->Size != 0) {
            *pData = MAKELONG(
                (USHORT)(pInstr->NativeStart - (PCHAR)EP->nativeStart),
                (USHORT)(pInstr->IntelAddress - (ULONG)(ULONGLONG)EP->intelStart));  
            pData++;
        }
    }

    *(pData-1) |= 1;        // Flag the pair of offsets as the last.
    return (ULONG)(LONGLONG) ( (PCHAR)pData - Location);  
}

VOID
GetEipFromException(
    PCPUCONTEXT cpu,
    PEXCEPTION_POINTERS pExceptionPointers
    )
/*++

Routine Description:

    This routine derives the value of EIP from a RISC exception record.

    1. Walk the stack until the instruction pointer points into the
       Translation Cache.
    2. Walk forward through the Translation Cache until the
       EXCEPTIONDATA_SIGNATURE signature is found.
    3. Find the ENTRYPOINT which describes the faulting instruction.
    4. Find the correct x86 instruction by examining the pairs of
       RISC offsets of the starts of x86 instructions.

Arguments:

    cpu                -- current cpu state
    pExceptionPointers -- state of the thread when the exception occurred
                            
Return Value:

    None.  cpu->Eip now points at faulting x86 instruction.
    
--*/
{
    ULONG NextPc;
    PENTRYPOINT EP;
    PULONG Location;
    ULONG i;
    ULONG cEntryPoints;
    ULONG RiscStart;
    ULONG RiscEnd;

    //
    // 1. Walk the stack until the instruction pointer points into the
    //    Translation Cache
    //
    NextPc = FindPcInTranslationCache(pExceptionPointers);
    if (!NextPc) {
        //
        // The Translation Cache is not on the stack.  Nothing we can do.
        //
        CPUASSERTMSG(FALSE, "FindPcInTranslationCache failed");
        cpu->eipReg.i4 = 0x81234567;
        return;
    }

    //
    // 2. Walk forwards through the Translation Cache until the
    //    EXCEPTIONDATA_SIGNATURE signature is found
    //
    CPUASSERTMSG((NextPc & 3) == 0, "NextPc is not DWORD-aligned");
    Location = (PULONG)NextPc;
    while (*Location != EXCEPTIONDATA_SIGNATURE) {
        Location++;
        if (!AddressInTranslationCache((ULONG) (ULONGLONG) Location)) {  
            cpu->eipReg.i4 = 0x80012345;
            CPUASSERTMSG(FALSE, "EXCEPTIONDATA_SIGNATURE not found");
            return;
        }
    }

    //
    // 3. Find the ENTRYPOINT which describes the address within
    //    the Cache.
    //
    Location++;     // skip over EXCEPTIONDATA_SIGNATURE
    cEntryPoints = *Location;
    Location++;     // skip over cEntryPoints
    for (i=0; i<cEntryPoints; ++i) {
        EP = (PENTRYPOINT)*Location;
         
        if ((ULONG)(ULONGLONG)EP->nativeStart <= NextPc && (ULONG)(ULONGLONG)EP->nativeEnd > NextPc) {
            //
            // This EntryPoint describes the Pc value in the cache
            //
            break;
        }

        //
        // Skip over the pairs of x86 instruction starts and RISC
        // instruction starts.
        //
        do {
            Location++;
        } while ((*Location & 1) == 0);
        Location++;
    }
    if (i == cEntryPoints) {
        CPUASSERTMSG(FALSE, "Entrypoint not found in EXCEPTIONDATA");
        cpu->eipReg.i4 = 0x80001234;
        return;
    }

    //
    // 4. Find the correct x86 instruction by examining the pairs of
    //    RISC offsets of the starts of x86 instructions.
    //
     
    NextPc -= (ULONG)(ULONGLONG)EP->nativeStart;   // Make relative to nativeStart of EP
    RiscStart = 0;                      // Also relative to nativeStart of EP
    Location++;
    while ((*Location & 1) == 0) {

        RiscEnd = LOWORD(*(Location + 1)) & 0xfffe; // RiscEnd = RiscStart of next instr
        if (RiscStart <= NextPc && NextPc < RiscEnd) {
            cpu->eipReg.i4 = (ULONG)(ULONGLONG)EP->intelStart + HIWORD(*Location);  
            return;
        }
        RiscStart = RiscEnd;
        Location++;
    }
     
    cpu->eipReg.i4 = (ULONG)(ULONGLONG)EP->intelStart + HIWORD(*Location);
}



    
ULONG
PlaceNativeCode(
    PCHAR CodeLocation
    )
/*++

Routine Description:

    Generates native code for the set of x86 instructions described by
    InstructionStream[] and NumberOfInstructions.

Arguments:

    CodeLocation    -- pointer to location to generate native code into.

Return Value:

    Returns the number of bytes in the native code for this compilation unit
    
Notes:

    None.
    
--*/
{
    PENTRYPOINT EntryPoint = NULL;
    PINSTRUCTION pInstr;
    PBYTE Location;
    PBYTE StartLocation;
    ULONG Size;
    ULONG i;
    OPERATION Op;
    CHAR Op1Buffer[MAX_OPERAND_SIZE*sizeof(ULONG)];
    CHAR Op2Buffer[MAX_OPERAND_SIZE*sizeof(ULONG)];
    ULONG Op1Size;
    ULONG Op2Size;
    BOOLEAN fMovInstruction;

    Location = CodeLocation;
    pInstr = &InstructionStream[0];
    for (i=NumberOfInstructions; i > 0; --i, pInstr++) {

        Op = pInstr->Operation;
        pInstr->NativeStart = Location;

        if (EntryPoint != pInstr->EntryPoint) {
            //
            // This instruction begins an EntryPoint
            //
            EntryPoint = pInstr->EntryPoint;
            StartLocation = Location;

            //
            // Reset per-basic-block state
            //
            ResetRegCache();
            Arg1Contents = Arg2Contents = NO_REG;
            Location += GenStartBasicBlock((PULONG)Location,
 
#if _ALPHA_
                                           (ULONG)(ULONGLONG)&EntrypointECU,
#endif
                                           pInstr);
        }

        if (pInstr->RegsToCache) {
            //
            // Load up frequently-used x86 registers into RISC registers
            //
            Location += LoadRegCacheForInstruction(pInstr->RegsToCache,
                                                   Location);
        }

        if ((Op==OP_Mov32) || (Op==OP_Mov16) || (Op==OP_Mov8)) {
            //
            // Make some final x86 code optimzations based on the
            // register caching info.
            //
            CleanupMovInstruction(pInstr);
            fMovInstruction = TRUE;
        } else {
            fMovInstruction = FALSE;
        }

        //
        // Generate code for the operands
        //
        Op1Size = PlaceOperand(1, &pInstr->Operand1, pInstr, Op1Buffer);
        Op2Size = PlaceOperand(2, &pInstr->Operand2, pInstr, Op2Buffer);
#if _PPC_
        if (pInstr->Operand1.Type == OPND_ADDRVALUE32 &&
            pInstr->Operand1.Alignment != ALIGN_DWORD_ALIGNED &&
            pInstr->Operand2.Type == OPND_ADDRVALUE32 &&
            pInstr->Operand2.Alignment != ALIGN_DWORD_ALIGNED) {
            //
            // Two MakeValue32 operands cannot be interleaved on PPC due
            // to the fact that they share registers RegUt1, RegUt2, RegUt3
            //
            memcpy(Location, Op1Buffer, Op1Size);
            Location += Op1Size;
            memcpy(Location, Op2Buffer, Op2Size);
            Location += Op2Size;
        } else {
            Location = InterleaveInstructions(Location,
                                              Op1Buffer,
                                              Op1Size,
                                              Op2Buffer,
                                              Op2Size);
        }
#elif _ALPHA_
        memcpy(Location, Op1Buffer, Op1Size);
        Location += Op1Size;
        memcpy(Location, Op2Buffer, Op2Size);
        Location += Op2Size;
#else
        Location = InterleaveInstructions(Location,
                                          Op1Buffer,
                                          Op1Size,
                                          Op2Buffer,
                                          Op2Size);
#endif
        Location += PlaceOperand(3, &pInstr->Operand3, pInstr, Location);

        if (DetermineInstructionAlignment(pInstr)) {
            //
            // The instruction has an aligned version and the operands
            // are sufficiently aligned to use it.
            //
            Op++;
            pInstr->Operation = Op;
        }

        //
        // Generate the body of the instruction
        //
        if (CompilerFlags & COMPFL_FAST) {
 
            Location += (*PlaceFn[Fragments[Op].FastPlaceFn])((PULONG)Location,
#if _ALPHA_
                                                              (ULONG)(ULONGLONG)&EntrypointECU,
#endif
                                                              pInstr);
        } else {
 
            Location += (*PlaceFn[Fragments[Op].SlowPlaceFn])((PULONG)Location,
#if _ALPHA_
                                                              (ULONG)(ULONGLONG)&EntrypointECU,
#endif
                                                              pInstr);
        }

        if (pInstr->RegsSet) {
            //
            // Mark RISC registers in the cache as invalid if this instruction
            // modified the matching x86 register.
            //
            InvalidateRegCacheForInstruction(pInstr->RegsSet);
        }

        if (!fMovInstruction) {
            //
            // If the instruction isn't a MOV, then assume the arg regs
            // were modified by the fragment
            //
            Arg1Contents = Arg2Contents = NO_REG;
        }

    }

    return (ULONG)(ULONGLONG)(Location - CodeLocation);  
}
    

VOID
DetermineOperandAlignment(
    BOOL EbpAligned,
    POPERAND Operand
    )
/*++

Routine Description:

    This function determines the alignment of an operand.  It also sets the 
    alignment field in the specified operand.  The alignment returned indicates
    the best we can determine at compile time.  An operand that is specified
    as byte aligned may actually turn out to be dword aligned.

Arguments:

    Operand -- Supplies the operand
    
Return Value:

    Returns the value specifying the alignment
    
Notes:
    
    It would be really handy here to have an idea what the register 
    contents were.  It would allow us to try to be more optimistic
    about the alignment.
    
    This routine should be expanded for all of the alignment cases
    assuming its possible.
    
--*/
{
    USHORT LowBits;

    switch (Operand->Type) {
    
        //
        // All of the following are regarded as dword aligned, including
        // high register refrence.  The code for handing high half registers
        // takes care of alignment
        //
        case OPND_MOVREGTOREG :
#if _ALPHA_
            if (Operand->IndexReg >= GP_AH) {
                // The Hi8 registers are considered to be only BYTE-aligned
                // on Alpha.  This matters for 'mov bh, val' instructions.
                // We need to select the MovFrag8B fragment in this case.
                Operand->Alignment = ALIGN_BYTE_ALIGNED;
            } else {
                Operand->Alignment = ALIGN_DWORD_ALIGNED;
            }
            break;
#endif
            // fall into the other cases on MIPS and PPC.

        case OPND_REGREF :
        case OPND_MOVTOREG :
#if _ALPHA_
            if (Operand->Reg >= GP_AH) {
                // The Hi8 registers are considered to be only BYTE-aligned
                // on Alpha.  This matters for 'mov bh, val' instructions.
                // We need to select the MovFrag8B fragment in this case.
                Operand->Alignment = ALIGN_BYTE_ALIGNED;
                break;
            }
#endif
            // fall into the other cases on MIPS and PPC

        case OPND_NONE :
        case OPND_NOCODEGEN :
        case OPND_REGVALUE :
        case OPND_IMM:
                    
            Operand->Alignment = ALIGN_DWORD_ALIGNED;
            break;
            
        //
        // All of the following have alignment depending on the formation
        // of the operand
        //
        case OPND_ADDRREF :
        case OPND_ADDRVALUE32 : 
        case OPND_ADDRVALUE16 :
        case OPND_ADDRVALUE8 : 
        
            if ((Operand->Reg != NO_REG) && (Operand->Reg != GP_ESP) && (Operand->Reg != GP_EBP || !EbpAligned)) {
            
                //
                // We have a reg + ... form.  Since we have no idea what the
                // contents of the register are, we can't guess about the
                // alignment.
                //
                Operand->Alignment = ALIGN_BYTE_ALIGNED;
                
            } else {
            
                //
                // Figure out low two bits
                //
                LowBits = (USHORT)(Operand->Immed & 0x3);
                
                if ((Operand->IndexReg != NO_REG) && (Operand->IndexReg != GP_ESP) && (Operand->IndexReg != GP_EBP || !EbpAligned)) {
                    LowBits = (LowBits | (1 << Operand->Scale)) & 0x3;
                }
                
                //
                // Convert lowbits into alignment
                //
                if (!LowBits) {
                    Operand->Alignment = ALIGN_DWORD_ALIGNED;
                } else if (!(LowBits & 0x1)){
                    Operand->Alignment = ALIGN_WORD_ALIGNED;
                } else {
                    Operand->Alignment = ALIGN_BYTE_ALIGNED;
                }
            }
            break;

        case OPND_MOVTOMEM:
            //
            // No alignment issue with this operand.
            //
            break;
                
        default : 
                
            CPUASSERTMSG(FALSE, "Bad Operand type");
    }
}
    
ULONG
DetermineInstructionAlignment(
    PINSTRUCTION Instruction
    )
/*++

Routine Description:

    This routine determines if the aligned form of an instruction can
    be used.

Arguments:

    Instruction - Supplies a pointer to the instruction
    
Return Value:

    Returns the alignment condition of the instruction
    
Notes:

    The results of this are pretty much ignored for inline mov's.  They are
    currently the only instructions that care about the details of the 
    alignment.  For the rest, naturally aligned or un-aligned is sufficient.
    
--*/
{
    OPERATION Op = Instruction->Operation;

    //
    // If the instruction does not have an aligned version, then
    // there is no work to do.
    //
    if (!(Fragments[Op].Flags & OPFL_ALIGN)) {
        return FALSE;
    }
    
    if (Instruction->Operand1.Type != OPND_ADDRREF) {
        ;
    } else if (Instruction->Operand1.Alignment == ALIGN_DWORD_ALIGNED) {
        ;
    } else if ((Instruction->Operand1.Alignment == ALIGN_WORD_ALIGNED) &&
        (Fragments[Op].Flags & OPFL_ADDR16) 
    ) {
        ;
    } else {
        return FALSE;
    }
    
    if (Instruction->Operand2.Type != OPND_ADDRREF) {
        ;
    } else if (Instruction->Operand2.Alignment == ALIGN_DWORD_ALIGNED) {
        ;
    } else if ((Instruction->Operand2.Alignment == ALIGN_WORD_ALIGNED) &&
        (Fragments[Op].Flags & OPFL_ADDR16) 
    ) {
        ;
    } else {
        return FALSE;
    }

    return TRUE;
}


ULONG
PlaceOperand(
    ULONG OperandNumber,
    POPERAND Operand,
    PINSTRUCTION Instruction,
    PCHAR Location
    )    
/*++

Routine Description:

    This routine generates the fragments necessary to form and operand.

Arguments:

    OperandNumber - number of operand (selects arg register number to target)
    Operand - Supplies the operand
    Instruction - The instruction containing the operand
    Location - Location to generate code into

Return Value:

    The size in bytes of the fragments selected.
    
--*/
{

    OPERAND_OP Op;
    ULONG RegCacheNum;
    PCHAR StartLocation;

#define GEN_OPERAND(Op)     (OpFragments[Op])((PULONG)Location, Operand, OperandNumber)
    
    //
    // Early return for no operands
    //
    if (Operand->Type == OPND_NONE || Operand->Type == OPND_NOCODEGEN) {
        return 0;
    }

    StartLocation = Location;

    DetermineOperandAlignment(Instruction->EbpAligned, Operand);
    
    switch (Operand->Type) {
    
        case OPND_REGVALUE:

            if ((CompilerFlags & COMPFL_FAST)
                && (Fragments[Instruction->Operation].Flags & OPFL_INLINEARITH)) {
                break;
            } else {
                Location += GenOperandRegVal((PULONG)Location,
                                             Operand,
                                             OperandNumber
                                            );
            }
            break;

        case OPND_REGREF:

            if ((CompilerFlags & COMPFL_FAST)
                && (Fragments[Instruction->Operation].Flags & OPFL_INLINEARITH)) {
                break;
            } else {
                Location += GenOperandRegRef((PULONG)Location,
                                             Operand,
                                             OperandNumber
                                            );
            }
            break;
            
        case OPND_ADDRREF:
        case OPND_ADDRVALUE8:
        case OPND_ADDRVALUE16:
        case OPND_ADDRVALUE32:
            Location += GenOperandAddr((PULONG)Location,
                                       Operand,
                                       OperandNumber,
                                       Instruction->FsOverride
                                       );
            break;
        
        case OPND_IMM :
            if ((CompilerFlags & COMPFL_FAST)
                && (Fragments[Instruction->Operation].Flags & OPFL_INLINEARITH)) {
                break;
            } else {
                Location += GenOperandImm((PULONG)Location,
                                          Operand,
                                          OperandNumber);
            }
            break;

        case OPND_MOVTOREG:
            Location += GenOperandMovToReg((PULONG)Location,
                                           Operand,
                                           OperandNumber);

            break;

        case OPND_MOVREGTOREG:
            switch (Operand->Immed) {
            case OP_Mov32:
                Op = OP_MovRegToReg32;
                break;
            case OP_Mov16:
                Op = OP_MovRegToReg16;
                break;
            case OP_Mov8:
#if _ALPHA_
                if (Operand->Alignment == ALIGN_BYTE_ALIGNED) {
                    Op = OP_MovRegToReg8B;
                    break;
                }
#endif
                Op = OP_MovRegToReg8;
                break;
            default:
                CPUASSERT(FALSE);
            }
            Location += GEN_OPERAND(Op);
            break;

        case OPND_MOVTOMEM:
            switch (Operand->Immed) {
            case OP_Mov32:
                Op = OP_MovToMem32B + Instruction->Operand1.Alignment;
                break;
            case OP_Mov16:
                Op = OP_MovToMem16B + Instruction->Operand1.Alignment;
                break;
            case OP_Mov8:
                Op = OP_MovToMem8D;
#if _ALPHA_
                if (Instruction->Operand1.Alignment != ALIGN_DWORD_ALIGNED) {
                    Op = OP_MovToMem8B;
                }
#endif
                break;

            default:
                CPUASSERT(FALSE);       // unknown MOV opcode
            }
            //
            // Generate the correct code based on the alignment of the operand
            //
            Location += GEN_OPERAND(Op);
            break;
            
        default:
        
            //
            // This is an internal error
            //
            CPUASSERT(FALSE);  // Unknown operand type!!!!
    }
    
    return (ULONG)(ULONGLONG)(Location - StartLocation);  
}

PCHAR
InterleaveInstructions(
    OUT PCHAR CodeLocation,
    IN PCHAR  Op1Code,
    IN ULONG  Op1Count,
    IN PCHAR  Op2Code,
    IN ULONG  Op2Count
)
/*++

Routine Description:

    This routine interleaves two streams of native code into one stream
    to try and avoid pipeline stalls.  It assumes that the two streams
    have no interdependencies (like they can't use the same register).

Arguments:

    CodeLocation -- Supplies the location to place the code at
    Op1Code      -- Code for the first operand
    Op1Count     -- Count of BYTES in the first operand
    Op2Code      -- Code for the second operand
    Op2Count     -- Count of BYTES in the second operand

Return Value:

    New value for CodeLocation - just past the end of the operands.

Notes:

    None

--*/
{
    PULONG pCode = (PULONG)CodeLocation;
    PULONG LongCode;
    PULONG ShortCode;
    ULONG LongCount;
    ULONG ShortCount;
    ULONG LongTail;

    //
    // Figure out which operand has more instructions - it starts first
    //
    if (Op1Count > Op2Count) {
        LongCode = (PULONG)Op1Code;
        LongCount = Op1Count / sizeof(ULONG);
        ShortCode = (PULONG)Op2Code;
        ShortCount = Op2Count / sizeof(ULONG);
    } else {
        LongCode = (PULONG)Op2Code;
        LongCount = Op2Count / sizeof(ULONG);
        ShortCode = (PULONG)Op1Code;
        ShortCount = Op1Count / sizeof(ULONG);
    }

    // get the length of the part of the longer operand which
    // goes after the interleaved part (in BYTES)
    LongTail = (LongCount - ShortCount) * sizeof(ULONG);

    //
    // Interleave instructions from both operands
    //
    while (ShortCount) {
        *pCode++ = *LongCode++;
        *pCode++ = *ShortCode++;
        ShortCount--;
    }

    //
    // Copy in the remaining instructions from the longer operand
    //
    if (LongTail) {
        memcpy(pCode, LongCode, LongTail);
    }

    return CodeLocation + Op1Count + Op2Count;
}


USHORT
ChecksumMemory(
    ENTRYPOINT *pEP
    )
/*++

Routine Description:

    Perform a simple checksum on the range of Intel addresses specified
    in an Entrypoint.

Arguments:

    pEp -- entrypoint describing Intel memory to checksum

Return Value:

    Checksum for the memory

Notes:

    None

--*/
{
    USHORT Checksum = 0;
    PBYTE pb = (PBYTE)pEP->intelStart;

    while (pb != (PBYTE)pEP->intelEnd) {
        Checksum = ((Checksum << 1) | ((Checksum >> 15) & 1)) + (USHORT)*pb;
        pb++;
    };

    return Checksum;
}


DWORD
SniffMemory(
    ENTRYPOINT *pEP,
    USHORT Checksum
    )
/*++

Routine Description:

    Called from the StartBasicBlock code for regions of memory which
    must be sniffed to determine if the x86 app has modified its code or not.

Arguments:

    pEp         -- entrypoint describing Intel memory to checksum
    Checksum    -- checksum of the code at compile-time

Return Value:

    TRUE    - code has not changed...native translation OK
    FALSE   - code has been modified.  CpuNotify has been set to flush
              the cache on the next CpuSimulateLoop.  Caller must jump
              to EndTranslatedCode immediately!

Notes:

    None

--*/
{
    USHORT NewChecksum = ChecksumMemory(pEP);

    if (NewChecksum != Checksum) {
        DECLARE_CPU;

        //
        // Intel code has been modified!!!!!  We must flush the cache and
        // recompile!!!!
        //
#if DBG
        LOGPRINT((TRACELOG, "WX86CPU: Intel code at %x modified!\n", pEP->intelStart));
#endif
        #undef CpuNotify   // soalpha.h defines this to be offset of CpuNotify
        InterlockedOr(&cpu->CpuNotify, CPUNOTIFY_MODECHANGE);
        cpu->eipReg.i4 = (ULONG)(ULONGLONG)pEP->intelStart;  
        return FALSE;
    }

    //
    // Intel code has not been modified.  Continue simulation without
    // recompilation
    //
    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\cpu\patchfn.c ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation

Module Name:

    patchfn.c

Abstract:

    This module contains generic functions to patch fragments.  Structures
    that describe the fragments to be patched.  The structures live in 
    the processor specific directory.

Author:

    Dave Hastings (daveh) creation-date 24-Jun-1995

Revision History:

    Barry Bond (barrybo) 1-Apr-1995
        Switch the PPC build to the AXP model of patching
            24-Aug-1999 [askhalid] copied from 32-bit wx86 directory and make work for 64bit.
            20-Sept-1999[barrybo]  added FRAG2REF(LockCmpXchg8bFrag32, ULONGLONG)
        
        
Notes:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#define _WX86CPUAPI_
#include "wx86.h"
#include "wx86nt.h"
#include "wx86cpu.h"
#include "cpuassrt.h"
#include "instr.h"
#include "config.h"
#include "fragp.h"
#include "entrypt.h"
#include "compiler.h"
#include "ctrltrns.h"
#include "threadst.h"
#include "instr.h"
#include "frag.h"
#include "ptchstrc.h"
#include "mrsw.h"
#include "tc.h"
#include "codeseq.h"
#include "codesize.h"
#include "opt.h"
#if _ALPHA_
#define _codegen_
#include "soalpha.h"
#undef fTCUnlocked      // this is a field in CPUCONTEXT
ULONG
GetCurrentECU(
    PULONG CodeLocation
    );
#endif

ASSERTNAME;

extern CHAR CallJxxHelper[];
extern CHAR CallJmpDirectHelper[];
extern CHAR IndirectControlTransferHelper[];
extern CHAR IndirectControlTransferFarHelper[];
extern CHAR CallDirectHelper[];
extern CHAR CallDirectHelper2[];
extern CHAR CallIndirectHelper[];
extern CHAR JumpToNextCompilationUnitHelper[];
 
#define OFFSET(type, field) ((LONG)(ULONGLONG)(&((type *)0)->field))

ULONG RegisterOffset[] = {
    OFFSET(THREADSTATE, GpRegs[GP_EAX].i4), // EAX
    OFFSET(THREADSTATE, GpRegs[GP_ECX].i4), // ECX
    OFFSET(THREADSTATE, GpRegs[GP_EDX].i4), // EDX
    OFFSET(THREADSTATE, GpRegs[GP_EBX].i4), // EBX
    OFFSET(THREADSTATE, GpRegs[GP_ESP].i4), // ESP
    OFFSET(THREADSTATE, GpRegs[GP_EBP].i4), // EBP
    OFFSET(THREADSTATE, GpRegs[GP_ESI].i4), // ESI
    OFFSET(THREADSTATE, GpRegs[GP_EDI].i4), // EDI
    OFFSET(THREADSTATE, GpRegs[REG_ES]),    // ES
    OFFSET(THREADSTATE, GpRegs[REG_CS]),    // CS
    OFFSET(THREADSTATE, GpRegs[REG_SS]),    // SS
    OFFSET(THREADSTATE, GpRegs[REG_DS]),    // DS
    OFFSET(THREADSTATE, GpRegs[REG_FS]),    // FS
    OFFSET(THREADSTATE, GpRegs[REG_GS]),    // GS
    OFFSET(THREADSTATE, GpRegs[GP_EAX].i2), // AX
    OFFSET(THREADSTATE, GpRegs[GP_ECX].i2), // CX
    OFFSET(THREADSTATE, GpRegs[GP_EDX].i2), // DX
    OFFSET(THREADSTATE, GpRegs[GP_EBX].i2), // BX
    OFFSET(THREADSTATE, GpRegs[GP_ESP].i2), // SP
    OFFSET(THREADSTATE, GpRegs[GP_EBP].i2), // BP
    OFFSET(THREADSTATE, GpRegs[GP_ESI].i2), // SI
    OFFSET(THREADSTATE, GpRegs[GP_EDI].i2), // DI
    OFFSET(THREADSTATE, GpRegs[GP_EAX].i1), // AL
    OFFSET(THREADSTATE, GpRegs[GP_ECX].i1), // CL
    OFFSET(THREADSTATE, GpRegs[GP_EDX].i1), // DL
    OFFSET(THREADSTATE, GpRegs[GP_EBX].i1), // BL
    OFFSET(THREADSTATE, GpRegs[GP_EAX].hb), // AH
    OFFSET(THREADSTATE, GpRegs[GP_ECX].hb), // CH
    OFFSET(THREADSTATE, GpRegs[GP_EDX].hb), // DH
    OFFSET(THREADSTATE, GpRegs[GP_EBX].hb)  // BH
};


ULONG
PatchJumpToNextCompilationUnit(
    IN PULONG PatchAddr,
    IN ULONG IntelDest
    )
/*++

Routine Description:

    This routine ends basic blocks when the native address of the next
    basic block is known.
     
Arguments:

    PatchAddr -- address of JumpToNextCompilationUnit code in the TC
    IntelDest -- intel address of the next basic block

Return Value:

    Native address to jump to to resume execution.
    
--*/
{
    DWORD TCTimestamp;
    ULONG NativeDest;
    ULONG NativeSize;
    DECLARE_CPU;


    if (cpu->flag_tf) {
        return (ULONG)(ULONGLONG)&EndTranslatedCode;
    }
    //
    // Switch from being a TC reader to a writer
    //
    TCTimestamp = TranslationCacheTimestamp;
    MrswReaderExit(&MrswTC);

    //
    // Compile the next basic block, and get the TC write lock
    //
    NativeDest = (ULONG)(ULONGLONG)NativeAddressFromEip((PVOID)IntelDest, TRUE)->nativeStart;  

    if (TCTimestamp == TranslationCacheTimestamp) {
        PULONG CodeLocation = PatchAddr - JumpToNextCompilationUnit_SIZE;
        //
        // The Translation Cache wasn't flushed - replace the
        // JumpToNextCompilationUnit fragment by JumpToNextCompilationUnit2
        //
        NativeSize=GenJumpToNextCompilationUnit2(CodeLocation,
                                                 FALSE, // patching, not compiling
#if _ALPHA_
                                                 GetCurrentECU(CodeLocation),
#endif
                                                 NativeDest,
                                                 0);
        
        NtFlushInstructionCache(
            NtCurrentProcess(),
            CodeLocation, 
            NativeSize
            );
        
    } else {

        TCTimestamp = TranslationCacheTimestamp;

        if (cpu->CSTimestamp != TCTimestamp) {
            //
            // The cache was flushed by another thread in the small window
            // between mrsw calls in this thread, we plan on jumping directly
            // to NativeDest, so the CPU callstack needs to be flushed.
            // Normally this would be done in the CpuSimulate() loop as a
            // result of jumping to EndTranslatedCode.
            //
            FlushCallstack(cpu);
        }
    }

    //
    // Switch back to being a TC reader
    //
    MrswWriterExit(&MrswTC);
    MrswReaderEnter(&MrswTC);


    if (TCTimestamp == TranslationCacheTimestamp) {
        //
        // TC was not flushed - NativeDest is valid
        //
        return NativeDest;
    } else {
        //
        // TC was flushed while becomming a TC reader again - NativeDest
        // is now bogus.
        //
        return (ULONG)(ULONGLONG)&EndTranslatedCode;  
    }
}

ULONG
PlaceJxx(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    )
/*++

Routine Description:

     This routine copies the fragment into place, and modifies the 
     instructions that load the destination into the register
     
Arguments:

    Instruction - Supplies a description of the instruction the fragment
        represents
    CodeLocation - Supplies the address the code for the fragment has been
        copied to

Return Value:

    Size of code placed at CodeLocation
    
--*/
{
    DWORD IntelDest;
    PPLACEOPERATIONFN pfn;
    PENTRYPOINT EP;
    ULONG NativeSize;

    //
    // Generate the code to determine if the branch is taken or not
    //
    pfn = (PPLACEOPERATIONFN)FragmentArray[Instruction->Operation];
    NativeSize = (*pfn)(CodeLocation,
#if _ALPHA_
                        CurrentECU,
#endif
                        Instruction);
    CodeLocation += NativeSize/sizeof(ULONG);

    // Let's see if we can place the patched version immediately

    // ASSUME:  The first argument is always a NOCODEGEN
    CPUASSERT( Instruction->Operand1.Type == OPND_NOCODEGEN );
    IntelDest = Instruction->Operand1.Immed;

    EP = NativeAddressFromEipNoCompileEPWrite((PVOID)IntelDest);

    if (EP == NULL) {
        //
        // knowing NativeDest requires compilation.  Just place the unpatched
        // version to be patched later.
        //
        NativeSize += GenJxxBody(CodeLocation,
#if _ALPHA_
                                 CurrentECU,
#endif
                                 Instruction);
        
    } else {
        //
        // We can place the patched version right away!
        //
        NativeSize += GenJxxBody2(CodeLocation,
                    TRUE,   // compiling, not patching
#if _ALPHA_
                    CurrentECU,
#endif
                    (ULONG)IntelDest,
                    (ULONG)(ULONGLONG)EP); 
    }
    return NativeSize;
}


ULONG
PlaceJxxSlow(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    )
/*++

Routine Description:

     This routine copies the fragment into place, and modifies the 
     instructions that load the destination into the register
     
Arguments:

    Instruction - Supplies a description of the instruction the fragment
        represents
    CodeLocation - Supplies the address the code for the fragment has been
        copied to

Return Value:

    Size of code placed at CodeLocation
    
--*/
{
    DWORD IntelDest;
    PPLACEOPERATIONFN pfn;
    PENTRYPOINT EP;
    ULONG NativeSize;

    //
    // Generate the code to load RegEip with the branch-not-taken value
    //
    NativeSize = GenJxxStartSlow(CodeLocation,
#if _ALPHA_
                                 CurrentECU,
#endif
                                 Instruction);

    //
    // Generate the code to determine if the branch is taken or not
    //
    pfn = (PPLACEOPERATIONFN)FragmentArray[Instruction->Operation];
    NativeSize += (*pfn)(CodeLocation+NativeSize/sizeof(ULONG),
#if _ALPHA_
                         CurrentECU,
#endif
                         Instruction);
    CodeLocation += NativeSize/sizeof(ULONG);

    // Let's see if we can place the patched version immediately

    // ASSUME:  The first argument is always a NOCODEGEN
    CPUASSERT( Instruction->Operand1.Type == OPND_NOCODEGEN );
    IntelDest = Instruction->Operand1.Immed;

    EP = NativeAddressFromEipNoCompileEPWrite((PVOID)IntelDest);

    if (EP == NULL) {
        //
        // knowing NativeDest requires compilation.  Just place the unpatched
        // version to be patched later.
        //
        NativeSize += GenJxxBodySlow(CodeLocation,
#if _ALPHA_
                                     CurrentECU,
#endif
                                     Instruction);
        
    } else {
        //
        // We can place the patched version right away!
        //
        NativeSize += GenJxxBodySlow2(CodeLocation,
                       TRUE,    // compiling, not patching
#if _ALPHA_
                       CurrentECU,
#endif
                       (ULONG)IntelDest,
                       (ULONG)(ULONGLONG)EP);  
    }
    return NativeSize;
}


ULONG
PlaceJxxFwd(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    )
/*++

Routine Description:

     This routine copies the fragment into place, and modifies the 
     instructions that load the destination into the register
     
Arguments:

    Instruction - Supplies a description of the instruction the fragment
        represents
    CodeLocation - Supplies the address the code for the fragment has been
        copied to

Return Value:

    Size of code placed at CodeLocation
    
--*/
{
    DWORD IntelDest;
    PPLACEOPERATIONFN pfn;
    PENTRYPOINT EP;
    ULONG NativeSize;

    //
    // Generate the code to determine if the branch is taken or not
    //
    pfn = (PPLACEOPERATIONFN)FragmentArray[Instruction->Operation];
    NativeSize = (*pfn)(CodeLocation,
#if _ALPHA_
                        CurrentECU,
#endif
                        Instruction);
    CodeLocation += NativeSize/sizeof(ULONG);


    // Let's see if we can place the patched version immediately

    // ASSUME:  The first argument is always a NOCODEGEN
    CPUASSERT( Instruction->Operand1.Type == OPND_NOCODEGEN );
    IntelDest = Instruction->Operand1.Immed;

    // Assert that the branch is going forward.
    CPUASSERT(IntelDest > Instruction->IntelAddress);

    EP = NativeAddressFromEipNoCompileEPWrite((PVOID)IntelDest);

    if (EP == NULL) {
        //
        // knowing NativeDest requires compilation.  Just place the unpatched
        // version to be patched later.
        NativeSize += GenJxxBodyFwd(CodeLocation,
#if _ALPHA_
                                    CurrentECU,
#endif
                                    Instruction);
        
    } else {
        //
        // We can place the patched version right away!
        //
        NativeSize += GenJxxBodyFwd2(CodeLocation,
                       TRUE,    // compiling, not patching
#if _ALPHA_
                       CurrentECU,
#endif
                       (ULONG)(ULONGLONG)EP, 
                       0);
    }
    return NativeSize;
}


ULONG
PatchJxx(
    IN ULONG IntelDest,
    IN PULONG PatchAddr
    )
/*++

Routine Description:

     This routine replaces a JXXSTRUC by a JXXSTRC2 at runtime.  It is called
     when the conditional branch is taken, and the native address of the
     destination is not yet known.
     
Arguments:

    inteldest  -- Intel destination address if the branch is taken
    patchaddr  -- address of the JXXSTRUC in the Translation Cache

Return Value:

    Native address to jump to in order to resume execution.
    
--*/
{
    ULONG NativeDest;       // branch-taken address
    PULONG fragaddr;        // address of START of the fragment
    DWORD TCTimestamp;      // old timestamp of the Translation Cache
    ULONG NativeSize;
    DECLARE_CPU;


    if (cpu->flag_tf) {
        return (ULONG)(ULONGLONG)&EndTranslatedCode;
    }

    //
    // Switch over to being a TC writer
    //
    TCTimestamp = TranslationCacheTimestamp;
    MrswReaderExit(&MrswTC);

    //
    // Get the native destination address of the branch and get the TC
    // write lock
    //
    NativeDest = (ULONG)(ULONGLONG)  NativeAddressFromEip((PVOID)IntelDest, TRUE)->nativeStart;

    if (TCTimestamp == TranslationCacheTimestamp) {
        PULONG CodeLocation = PatchAddr - CallJxx_PATCHRA_OFFSET;
        //
        // The Translation Cache was not flushed while switching to a TC
        // writer or by the compilation.  Replace JxxBody by the faster
        // JxxBody2
        //
        NativeSize=GenJxxBody2(CodeLocation,
                               FALSE, // patching, not compiling
#if _ALPHA_
                               GetCurrentECU(CodeLocation),
#endif
                               (DWORD)IntelDest,
                               (DWORD)NativeDest);

        NtFlushInstructionCache(
            NtCurrentProcess(),
            CodeLocation, 
            NativeSize
            );
            
    } else {

        TCTimestamp = TranslationCacheTimestamp;

        if (cpu->CSTimestamp != TCTimestamp) {
            //
            // The cache was flushed by another thread in the small window
            // between mrsw calls in this thread, we plan on jumping directly
            // to NativeDest, so the CPU callstack needs to be flushed.
            // Normally this would be done in the CpuSimulate() loop as a
            // result of jumping to EndTranslatedCode.
            //
            FlushCallstack(cpu);
        }
    }

    //
    // Switch back to being a TC reader again
    //
    MrswWriterExit(&MrswTC);
    MrswReaderEnter(&MrswTC);

    if (TCTimestamp == TranslationCacheTimestamp) {
        //
        // TC was not flushed while becomming a reader again
        //
        return NativeDest;
    } else {
        //
        // TC was flushed while becomming a reader.  nativedest is invalid
        // so do an EndTranslatedCode instead.
        //
        return (ULONG)(ULONGLONG)  &EndTranslatedCode;
    }
}


ULONG
PatchJxxSlow(
    IN ULONG IntelDest,
    IN PULONG PatchAddr
    )
/*++

Routine Description:

     This routine replaces a JXXSTRUC by a JXXSTRC2 at runtime.  It is called
     when the conditional branch is taken, and the native address of the
     destination is not yet known.
     
Arguments:

    inteldest  -- Intel destination address if the branch is taken
    patchaddr  -- address of the JXXSTRUC in the Translation Cache

Return Value:

    Native address to jump to in order to resume execution.
    
--*/
{
    ULONG NativeDest;       // branch-taken address
    PULONG fragaddr;        // address of START of the fragment
    DWORD TCTimestamp;      // old timestamp of the Translation Cache
    ULONG NativeSize;
    DECLARE_CPU;


    if (cpu->flag_tf) {
        return (ULONG)(ULONGLONG)&EndTranslatedCode;
    }

    //
    // Switch over to being a TC writer
    //
    TCTimestamp = TranslationCacheTimestamp;
    MrswReaderExit(&MrswTC);

    //
    // Get the native destination address of the branch and get the TC
    // write lock
    //
    NativeDest = (ULONG)(ULONGLONG)  NativeAddressFromEip((PVOID)IntelDest, TRUE)->nativeStart;

    if (TCTimestamp == TranslationCacheTimestamp) {
        PULONG CodeLocation = PatchAddr - CallJxxSlow_PATCHRA_OFFSET;
        //
        // The Translation Cache was not flushed while switching to a TC
        // writer or by the compilation.  Replace JxxBody by the faster
        // JxxBody2
        //
        NativeSize = GenJxxBodySlow2(CodeLocation,
                                     FALSE, // patching, not compiling
#if _ALPHA_
                                     GetCurrentECU(CodeLocation),
#endif
                                     (DWORD)IntelDest,
                                     (DWORD)NativeDest);

        NtFlushInstructionCache(
            NtCurrentProcess(),
            CodeLocation, 
            NativeSize
            );
            
    } else {
        TCTimestamp = TranslationCacheTimestamp;

        if (cpu->CSTimestamp != TCTimestamp) {
            //
            // The cache was flushed by another thread in the small window
            // between mrsw calls in this thread, we plan on jumping directly
            // to NativeDest, so the CPU callstack needs to be flushed.
            // Normally this would be done in the CpuSimulate() loop as a
            // result of jumping to EndTranslatedCode.
            //
            FlushCallstack(cpu);
        }
    }

    //
    // Switch back to being a TC reader again
    //
    MrswWriterExit(&MrswTC);
    MrswReaderEnter(&MrswTC);

    if (TCTimestamp == TranslationCacheTimestamp) {
        //
        // TC was not flushed while becomming a reader again
        //
        return NativeDest;
    } else {
        //
        // TC was flushed while becomming a reader.  nativedest is invalid
        // so do an EndTranslatedCode instead.
        //
        return (ULONG)(ULONGLONG)  &EndTranslatedCode;
    }
}


ULONG
PatchJxxFwd(
    IN ULONG IntelDest,
    IN PULONG PatchAddr
    )
/*++

Routine Description:

     This routine replaces a JXXBODYFWD by a JXXBODYFWD2 at runtime.  It is
     called when the conditional branch is taken, and the native address of the
     destination is not yet known.
     
Arguments:

    inteldest  -- Intel destination address if the branch is taken
    patchaddr  -- address of the JXXSTRUCFWD in the Translation Cache

Return Value:

    Native address to jump to in order to resume execution.
    
--*/
{
    ULONG NativeDest;       // branch-taken address
    PULONG fragaddr;        // address of START of the fragment
    DWORD TCTimestamp;      // old timestamp of the Translation Cache
    ULONG NativeSize;
    DECLARE_CPU;

    if (cpu->flag_tf) {
        return (ULONG)(ULONGLONG)&EndTranslatedCode;
    }

    //
    // Switch over to being a TC writer
    //
    TCTimestamp = TranslationCacheTimestamp;
    MrswReaderExit(&MrswTC);

    //
    // Get the native destination address of the branch and get the TC write lock
    //
    NativeDest = (ULONG)(ULONGLONG)  NativeAddressFromEip((PVOID)IntelDest, TRUE)->nativeStart;

    if (TCTimestamp == TranslationCacheTimestamp) {
        PULONG CodeLocation = PatchAddr - CallJxxFwd_PATCHRA_OFFSET;
        //
        // The Translation Cache was not flushed while switching to a TC
        // writer or by the compilation.  Replace JxxBody by the faster
        // JxxBodyFwd2
        //
        NativeSize = GenJxxBodyFwd2(CodeLocation,
                                    FALSE, // patching, not compiling
#if _ALPHA_
                                    GetCurrentECU(CodeLocation),
#endif
                                    (DWORD)NativeDest,
                                    0);

        NtFlushInstructionCache(
            NtCurrentProcess(),
            CodeLocation, 
            NativeSize
            );
            
    } else {
        TCTimestamp = TranslationCacheTimestamp;

        if (cpu->CSTimestamp != TCTimestamp) {
            //
            // The cache was flushed by another thread in the small window
            // between mrsw calls in this thread, we plan on jumping directly
            // to NativeDest, so the CPU callstack needs to be flushed.
            // Normally this would be done in the CpuSimulate() loop as a
            // result of jumping to EndTranslatedCode.
            //
            FlushCallstack(cpu);
        }
    }

    //
    // Switch back to being a TC reader again
    //
    MrswWriterExit(&MrswTC);
    MrswReaderEnter(&MrswTC);

    if (TCTimestamp == TranslationCacheTimestamp) {
        //
        // TC was not flushed while becomming a reader again
        //
        return NativeDest;
    } else {
        //
        // TC was flushed while becomming a reader.  nativedest is invalid
        // so do an EndTranslatedCode instead.
        //
        return (ULONG)(ULONGLONG)  &EndTranslatedCode;
    }
}


ULONG
PlaceJmpDirect(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    )
/*++

Routine Description:

    This routine copies the unconditional jump fragment into place and patches
    the instructions that jump to EndTranslatedCode
     
Arguments:

    Instruction - Supplies a description of the instruction the fragment
        represents
    CodeLocation - Supplies the address the code for the fragment has been
        copied to

Return Value:

    Size of code placed at CodeLocation
    
--*/
{
    DWORD IntelDest;
    PENTRYPOINT EP;
    ULONG NativeSize;

    // ASSUME:  The first argument is always an immediate
    CPUASSERT( Instruction->Operand1.Type == OPND_NOCODEGEN );

    IntelDest = Instruction->Operand1.Immed;
    EP = NativeAddressFromEipNoCompileEPWrite((PVOID)IntelDest);

    if (EP == NULL) {
        //
        // Knowing NativeDest requires compilation.  Just place the unpatched version for
        // now and patch it later if necessary
        //
        NativeSize = GenCallJmpDirect(CodeLocation,
#if _ALPHA_
                                      CurrentECU,
#endif
                                      Instruction);
        
    } else {
        //
        // We can place the patched version right away!
        //
        NativeSize = GenCallJmpDirect2(CodeLocation,
                                       TRUE,    // compiling, not patching
#if _ALPHA_
                                       CurrentECU,
#endif
                                       (ULONG)(ULONGLONG)  EP,
                                       IntelDest);
    }

    return NativeSize;
}


ULONG 
PatchJmpDirect(
    IN PULONG PatchAddr,
    IN ULONG IntelDest
)
/*++

Routine Description:

    This routine patches a JMPDIRECT to a JMPDIRECT2.  It is called when
    the native destination address of a jmp instruction is not yet known.
    It patches the jmp to jump directly to the corresponding native code.
     
Arguments:

    PatchAddr -- address of the JMPDIRECT in the Translation Cache
    IntelDest -- intel address of the destination of the jmp

Return Value:

    Native address to jump to in order to resume execution
    
--*/
{
    DWORD TCTimestamp;
    ULONG NativeDest;
    ULONG NativeSize;
    DECLARE_CPU;
    
    if (cpu->flag_tf) {
        return (ULONG)(ULONGLONG)&EndTranslatedCode;
    }

    //
    // Switch from being a TC reader to a writer
    //
    TCTimestamp = TranslationCacheTimestamp;
    MrswReaderExit(&MrswTC);

    //
    // Compile the destination of the jmp and get the TC write lock
    //
    NativeDest = (ULONG)(ULONGLONG)  NativeAddressFromEip((PVOID)IntelDest, TRUE)->nativeStart;

    if (TCTimestamp == TranslationCacheTimestamp) {
        PULONG CodeLocation = PatchAddr - CallJmpDirect_PATCHRA_OFFSET;
        //
        // The Translation Cache wasn't flushed - replace the JMPDIRECT
        // fragment by JMPDIRECT2
        //
        NativeSize = GenCallJmpDirect2(CodeLocation,
                                       FALSE, // patching, not compiling
#if _ALPHA_
                                       GetCurrentECU(CodeLocation),
#endif
                                       (ULONG)NativeDest,
                                       IntelDest);
        NtFlushInstructionCache(
            NtCurrentProcess(),
            (PVOID)CodeLocation, 
            NativeSize
            );
    } else {
        TCTimestamp = TranslationCacheTimestamp;

        if (cpu->CSTimestamp != TCTimestamp) {
            //
            // The cache was flushed by another thread in the small window
            // between mrsw calls in this thread, we plan on jumping directly
            // to NativeDest, so the CPU callstack needs to be flushed.
            // Normally this would be done in the CpuSimulate() loop as a
            // result of jumping to EndTranslatedCode.
            //
            FlushCallstack(cpu);
        }
    }

    //
    // Switch back to being a TC reader
    //
    MrswWriterExit(&MrswTC);
    MrswReaderEnter(&MrswTC);

    if (TCTimestamp == TranslationCacheTimestamp) {
        //
        // TC was not flushed - nativedest is valid
        //
        return NativeDest;
    } else {
        //
        // TC was flushed while becomming a TC reader again - nativedest
        // is now bogus.
        //
        return (ULONG)(ULONGLONG)  &EndTranslatedCode;
    }
}

ULONG
PlaceJmpDirectSlow(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    )
/*++

Routine Description:

    This routine copies the unconditional jump fragment into place and patches
    the instructions that jump to EndTranslatedCode
     
Arguments:

    Instruction - Supplies a description of the instruction the fragment
        represents
    CodeLocation - Supplies the address the code for the fragment has been
        copied to

Return Value:

    Size of code placed at CodeLocation
    
--*/
{
    DWORD IntelDest;
    PENTRYPOINT EP;
    ULONG NativeSize;

    // ASSUME:  The first argument is always an immediate
    CPUASSERT( Instruction->Operand1.Type == OPND_NOCODEGEN );

    IntelDest = Instruction->Operand1.Immed;
    EP = NativeAddressFromEipNoCompileEPWrite((PVOID)IntelDest);

    if (EP == NULL) {
        //
        // Knowing NativeDest requires compilation.  Just place the unpatched version for
        // now and patch it later if necessary
        //
        NativeSize = GenCallJmpDirectSlow(CodeLocation,
#if _ALPHA_
                                          CurrentECU,
#endif
                                          Instruction);
        
    } else {
        //
        // We can place the patched version right away!
        //
        NativeSize = GenCallJmpDirectSlow2(CodeLocation,
                                           TRUE, // compiling, not patching
#if _ALPHA_
                                           CurrentECU,
#endif
                                           (ULONG)(ULONGLONG)  EP,
                                           IntelDest);
    }

    return NativeSize;
}


ULONG 
PatchJmpDirectSlow(
    IN PULONG PatchAddr,
    IN ULONG IntelDest
)
/*++

Routine Description:

    This routine patches a JMPDIRECT to a JMPDIRECT2.  It is called when
    the native destination address of a jmp instruction is not yet known.
    It patches the jmp to jump directly to the corresponding native code.
     
Arguments:

    PatchAddr -- address of the JMPDIRECT in the Translation Cache
    IntelDest -- intel address of the destination of the jmp

Return Value:

    Native address to jump to in order to resume execution
    
--*/
{
    DWORD TCTimestamp;
    ULONG NativeDest;
    ULONG NativeSize;
    DECLARE_CPU;


    if (cpu->flag_tf) {
        return (ULONG)(ULONGLONG)&EndTranslatedCode;
    }

    //
    // Switch from being a TC reader to a writer
    //
    TCTimestamp = TranslationCacheTimestamp;
    MrswReaderExit(&MrswTC);

    //
    // Compile the destination of the jmp and get the TC write lock
    //
    NativeDest = (ULONG)(ULONGLONG)  NativeAddressFromEip((PVOID)IntelDest, TRUE)->nativeStart;

    if (TCTimestamp == TranslationCacheTimestamp) {
        PULONG CodeLocation = PatchAddr - CallJmpDirectSlow_PATCHRA_OFFSET;
        //
        // The Translation Cache wasn't flushed - replace the JMPDIRECT
        // fragment by JMPDIRECT2
        //
        NativeSize = GenCallJmpDirectSlow2(CodeLocation,
                                           FALSE, // patching, not compiling
#if _ALPHA_
                                           GetCurrentECU(CodeLocation),
#endif
                                           (ULONG)NativeDest,
                                           IntelDest);
        NtFlushInstructionCache(
            NtCurrentProcess(),
            (PVOID)CodeLocation, 
            NativeSize
            );
    } else {
        TCTimestamp = TranslationCacheTimestamp;

        if (cpu->CSTimestamp != TCTimestamp) {
            //
            // The cache was flushed by another thread in the small window
            // between mrsw calls in this thread, we plan on jumping directly
            // to NativeDest, so the CPU callstack needs to be flushed.
            // Normally this would be done in the CpuSimulate() loop as a
            // result of jumping to EndTranslatedCode.
            //
            FlushCallstack(cpu);
        }
    }

    //
    // Switch back to being a TC reader
    //
    MrswWriterExit(&MrswTC);
    MrswReaderEnter(&MrswTC);

    if (TCTimestamp == TranslationCacheTimestamp) {
        //
        // TC was not flushed - nativedest is valid
        //
        return NativeDest;
    } else {
        //
        // TC was flushed while becomming a TC reader again - nativedest
        // is now bogus.
        //
        return (ULONG)(ULONGLONG)  &EndTranslatedCode;
    }
}

ULONG
PlaceJmpFwdDirect(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    )
/*++

Routine Description:

    This routine copies the unconditional jump fragment into place and patches
    the instructions that jump to EndTranslatedCode
     
Arguments:

    Instruction - Supplies a description of the instruction the fragment
        represents
    CodeLocation - Supplies the address the code for the fragment has been
        copied to

Return Value:

    Size of code placed at CodeLocation
    
--*/
{
    DWORD IntelDest;
    PENTRYPOINT EP;
    ULONG NativeSize;

    // ASSUME:  The first argument is always an immediate
    CPUASSERT( Instruction->Operand1.Type == OPND_NOCODEGEN );

    IntelDest = Instruction->Operand1.Immed;
    EP = NativeAddressFromEipNoCompileEPWrite((PVOID)IntelDest);

    if (EP == NULL) {
        //
        // Knowing NativeDest requires compilation.  Just place the unpatched version for
        // now and patch it later if necessary
        //
        NativeSize = GenCallJmpFwdDirect(CodeLocation,
#if _ALPHA_
                                         CurrentECU,
#endif
                                         Instruction);
        
    } else {
        //
        // We can place the patched version right away!
        //
        NativeSize = GenCallJmpFwdDirect2(CodeLocation,
                                          TRUE, // compiling, not patching
#if _ALPHA_
                                          CurrentECU,
#endif
                                          (ULONG)(ULONGLONG)  EP,
                                          0);
    }

    return NativeSize;
}


ULONG 
PatchJmpFwdDirect(
    IN PULONG PatchAddr,
    IN ULONG IntelDest
)
/*++

Routine Description:

    This routine patches a JMPDIRECT to a JMPDIRECT2.  It is called when
    the native destination address of a jmp instruction is not yet known.
    It patches the jmp to jump directly to the corresponding native code.
     
Arguments:

    PatchAddr -- address of the JMPDIRECT in the Translation Cache
    IntelDest -- intel address of the destination of the jmp

Return Value:

    Native address to jump to in order to resume execution
    
--*/
{
    DWORD TCTimestamp;
    ULONG NativeDest;
    ULONG NativeSize;
    DECLARE_CPU;

    if (cpu->flag_tf) {
        return (ULONG)(ULONGLONG)&EndTranslatedCode;
    }

    //
    // Switch from being a TC reader to a writer
    //
    TCTimestamp = TranslationCacheTimestamp;
    MrswReaderExit(&MrswTC);

    //
    // Compile the destination of the jmp and get the TC write lock
    //
    NativeDest = (ULONG)(ULONGLONG)  NativeAddressFromEip((PVOID)IntelDest, TRUE)->nativeStart;

    if (TCTimestamp == TranslationCacheTimestamp) {
        PULONG CodeLocation = PatchAddr - CallJmpFwdDirect_PATCHRA_OFFSET;
        //
        // The Translation Cache wasn't flushed - replace the JMPDIRECT
        // fragment by JMPDIRECT2
        //
        NativeSize = GenCallJmpFwdDirect2(CodeLocation,
                                          FALSE, // patching, not compiling
#if _ALPHA_
                                          GetCurrentECU(CodeLocation),
#endif
                                          (ULONG)NativeDest,
                                          0);
        NtFlushInstructionCache(
            NtCurrentProcess(),
            (PVOID)CodeLocation, 
            NativeSize
            );
    } else {
        TCTimestamp = TranslationCacheTimestamp;

        if (cpu->CSTimestamp != TCTimestamp) {
            //
            // The cache was flushed by another thread in the small window
            // between mrsw calls in this thread, we plan on jumping directly
            // to NativeDest, so the CPU callstack needs to be flushed.
            // Normally this would be done in the CpuSimulate() loop as a
            // result of jumping to EndTranslatedCode.
            //
            FlushCallstack(cpu);
        }
    }

    //
    // Switch back to being a TC reader
    //
    MrswWriterExit(&MrswTC);
    MrswReaderEnter(&MrswTC);

    if (TCTimestamp == TranslationCacheTimestamp) {
        //
        // TC was not flushed - nativedest is valid
        //
        return NativeDest;
    } else {
        //
        // TC was flushed while becomming a TC reader again - nativedest
        // is now bogus.
        //
        return (ULONG)(ULONGLONG)  &EndTranslatedCode;
    }
}

ULONG
PlaceJmpfDirect(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    )
/*++

Routine Description:

    This routine copies the unconditional jump fragment into place and patches
    the instructions that jump to EndTranslatedCode
     
Arguments:

    Instruction - Supplies a description of the instruction the fragment
        represents
    CodeLocation - Supplies the address the code for the fragment has been
        copied to

Return Value:

    Size of code placed at CodeLocation
    
--*/
{
    DWORD IntelDest;
    PENTRYPOINT EP;
    ULONG NativeSize;

    // ASSUME:  The first argument is always an IMM, pointing at the address
    CPUASSERT( Instruction->Operand1.Type == OPND_IMM );
    IntelDest = Instruction->Operand1.Immed;

    EP = NativeAddressFromEipNoCompileEPWrite((PVOID)*(UNALIGNED DWORD *)IntelDest);

    if (EP == NULL) {
        //
        // Knowing NativeDest requires compilation.  Just place the unpatched
        // version for now and patch it later if necessary
        //
        NativeSize = GenCallJmpfDirect(CodeLocation,
#if _ALPHA_
                                       CurrentECU,
#endif
                                       Instruction);
        
    } else {
        //
        // We can place the patched version right away!
        //
        NativeSize = GenCallJmpfDirect2(CodeLocation,
                                        TRUE, // compiling, not patching
#if _ALPHA_
                                        CurrentECU,
#endif
                                        (ULONG)(ULONGLONG)  EP,
                                        0);
    }

    return NativeSize;
}



ULONG 
PatchJmpfDirect(
    PTHREADSTATE cpu,
    IN PULONG pIntelDest,
    IN PULONG PatchAddr
)
/*++

Routine Description:

    This routine patches a JMPFDIRECT to a JMPFDIRECT2.  It is called when
    the native destination address of a jmp instruction is not yet known.
    It patches the jmp to jump directly to the corresponding native code.
     
Arguments:

    PatchAddr -- address of the JMPDIRECT in the Translation Cache
    pIntelDest -- intel address of the destination of the jmp

Return Value:

    Native address to jump to in order to resume execution
    
--*/
{
    DWORD TCTimestamp;
    ULONG NativeDest;
    PVOID IntelDest;
    USHORT Sel;
    ULONG NativeSize;

    if (cpu->flag_tf) {
        return (ULONG)(ULONGLONG)&EndTranslatedCode;
    }

    //
    // Switch from being a TC reader to a writer
    //
    TCTimestamp = TranslationCacheTimestamp;
    MrswReaderExit(&MrswTC);

    //
    // Compile the destination of the jmp and get the TC write lock
    //
    IntelDest = (PVOID)*(UNALIGNED DWORD *)pIntelDest;
    Sel = *(UNALIGNED PUSHORT)(pIntelDest+1);
    eip = (ULONG)(ULONGLONG)  IntelDest;
    CS = Sel;
    NativeDest = (ULONG)(ULONGLONG)  NativeAddressFromEip(IntelDest, TRUE)->nativeStart;

    if (TCTimestamp == TranslationCacheTimestamp) {
        PULONG CodeLocation = PatchAddr - CallJmpfDirect_PATCHRA_OFFSET;
        //
        // The Translation Cache wasn't flushed - replace the JMPFDIRECT
        // fragment by JMPFDIRECT2
        //
        NativeSize = GenCallJmpfDirect2(CodeLocation,
                                        FALSE,  // patching, not compiling
#if _ALPHA_
                                        GetCurrentECU(CodeLocation),
#endif
                                        (ULONG)NativeDest,
                                        0);
        NtFlushInstructionCache(
            NtCurrentProcess(),
            (PVOID)CodeLocation, 
            NativeSize
            );
    } else {
        TCTimestamp = TranslationCacheTimestamp;

        if (cpu->CSTimestamp != TCTimestamp) {
            //
            // The cache was flushed by another thread in the small window
            // between mrsw calls in this thread, we plan on jumping directly
            // to NativeDest, so the CPU callstack needs to be flushed.
            // Normally this would be done in the CpuSimulate() loop as a
            // result of jumping to EndTranslatedCode.
            //
            FlushCallstack(cpu);
        }
    }

    //
    // Switch back to being a TC reader
    //
    MrswWriterExit(&MrswTC);
    MrswReaderEnter(&MrswTC);

    if (TCTimestamp == TranslationCacheTimestamp) {
        //
        // TC was not flushed - nativedest is valid
        //
        return NativeDest;
    } else {
        //
        // TC was flushed while becomming a TC reader again - nativedest
        // is now bogus.
        //
        return (ULONG)(ULONGLONG)  &EndTranslatedCode;
    }
}

ULONG
PlaceCallDirect(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    )
/*++

Routine Description:

    This routine copies the unconditional call fragment into place.
     
Arguments:

    Instruction - Supplies a description of the instruction the fragment
        represents
    CodeLocation - Supplies the address the code for the fragment has been
        copied to

Return Value:

    Size of code placed at CodeLocation
    
--*/
{
    DWORD IntelDest;
    DWORD IntelNext;
    PENTRYPOINT EP;

    // ASSUME:  The first argument is always an immediate
    CPUASSERT( Instruction->Operand1.Type == OPND_IMM );

    IntelDest = Instruction->Operand1.Immed;
    EP = NativeAddressFromEipNoCompileEPWrite((PVOID)IntelDest);

    if (EP == NULL) {
        //
        // Knowing NativeDest requires compilation.  Just place the unpatched
        // version for now and patch it later if necessary
        //
        GenCallDirect(CodeLocation,
#if _ALPHA_
                      CurrentECU,
#endif
                      Instruction);
    } else {
        //
        // We can place the patched version right away!  Deterime if the
        // NativeNext address is known.
        //
        IntelNext = Instruction->Operand2.Immed;

        //
        // If the current instruction is not the last one compiled, then
        // NativeNext is CodeLocation+CallDirect_SIZE and CallDirect3 can
        // be placed right away.
        //
        if (Instruction != &InstructionStream[NumberOfInstructions-1]) {
            GenCallDirect3(CodeLocation,
                           TRUE, // compiling, not patching
#if _ALPHA_
                           CurrentECU,
#endif
                           (ULONG)(ULONGLONG)  EP,
                           (ULONG)(ULONGLONG)  (CodeLocation+CallDirect_SIZE));
        } else {
            GenCallDirect2(CodeLocation,
                           TRUE, // compiling, not patching
#if _ALPHA_
                           CurrentECU,
#endif
                           (ULONG)(ULONGLONG)  EP,
                           0);
        }
    }
    return CallDirect_SIZE * sizeof(ULONG);
}


ULONG
PlaceCallfDirect(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    )
/*++

Routine Description:

    This routine copies the unconditional FAR call fragment into place.
     
Arguments:

    Instruction - Supplies a description of the instruction the fragment
        represents
    CodeLocation - Supplies the address the code for the fragment has been
        copied to

Return Value:

    Size of code placed at CodeLocation
    
--*/
{
    DWORD IntelDest;
    DWORD IntelAddr;
    DWORD IntelNext;
    PVOID NativeNext;
    PENTRYPOINT EP;

    // ASSUME:  The first two arguments are pIntelDest and IntelNext, stored
    //          as immediates.
    CPUASSERT( Instruction->Operand1.Type == OPND_IMM );
    CPUASSERT( Instruction->Operand2.Type == OPND_IMM );

    IntelAddr = Instruction->Operand1.Immed;

    // Get the offset portion of the address (skipping the selector)
    IntelDest = *(UNALIGNED DWORD *)(IntelAddr+2);
    EP = NativeAddressFromEipNoCompileEPWrite((PVOID)IntelDest);

    if (EP == NULL) {
        //
        // Knowing NativeDest requires compilation.  Just place the unpatched
        // version for now and patch it later if necessary
        //
        GenCallfDirect(CodeLocation,
#if _ALPHA_
                       CurrentECU,
#endif
                       Instruction);
    } else {
        //
        // We can place the patched version right away!  Deterime if the
        // NativeNext address is known.
        //
        IntelNext = Instruction->Operand2.Immed;

        //
        // If the current instruction is not the last one compiled, then
        // NativeNext is CodeLocation+CallfDirect_SIZE and CallDirect3 can
        // be placed right away.
        //
        if (Instruction != &InstructionStream[NumberOfInstructions-1]) {
            GenCallfDirect3(CodeLocation,
                            TRUE, // compiling, not patching
#if _ALPHA_
                            CurrentECU,
#endif
                            (ULONG)(ULONGLONG)  EP,
                            (ULONG)(ULONGLONG)  (CodeLocation+CallfDirect_SIZE));
        } else {
            GenCallfDirect2(CodeLocation,
                            TRUE, // compiling, not patching
#if _ALPHA_
                            CurrentECU,
#endif
                            (ULONG)(ULONGLONG)  EP,
                            0);
        }
    }
    return CallfDirect_SIZE * sizeof(ULONG);
}

DWORD
PatchCallDirectExceptionFilter(
    PTHREADSTATE cpu
    )
/*++

Routine Description:

    Called if CTRL_CallFrag() throws an exception from within
    PatchCallDirect().  If this happens, the Translation Cache is in fact
    unlocked, although cpu->fTCUnlocked == FALSE.  Need to fix this up before
    CpuResetToConsistentState() gets run and unlocks the cache a second time.

Arguments:

    cpu
    
Return Value:

    None.

--*/
{
    //
    // Indicate the TC read lock is not held.
    //
    cpu->fTCUnlocked = TRUE;

    //
    // Continue unwinding the stack
    //
    return EXCEPTION_CONTINUE_SEARCH;
}


ULONG 
PatchCallDirect(
    IN PTHREADSTATE Cpu,
    IN ULONG IntelDest,
    IN ULONG IntelNext,
    IN PULONG PatchAddr
    )
/*++

Routine Description:

    This routine patches a CALLDIRECT to a CALLDIRECT2.  It is called when
    the native destination address of a call instruction is not yet known.
    It patches the call to jump directly to the corresponding native code.
     
Arguments:

    Cpu       -- per-thread info
    IntelDest -- intel address of the destination of the call
    IntelNext -- intel address of the instruction following the call
    PatchAddr -- address of the CALLDIRECT in the Translation Cache

Return Value:

    Native address to jump to in order to resume execution
    
--*/
{
    DWORD TCTimestamp;
    ULONG NativeDest;
    ULONG NativeSize;

    //
    // Switch from being a TC reader to a writer
    //
    TCTimestamp = TranslationCacheTimestamp;
    MrswReaderExit(&MrswTC);

    //
    // Compile the code at the destination of the call and get the TC write lock
    //
    NativeDest = (ULONG)(ULONGLONG)  NativeAddressFromEip((PVOID)IntelDest, TRUE)->nativeStart;

    if (TCTimestamp == TranslationCacheTimestamp) {
        PULONG CodeLocation = PatchAddr - CallDirect_PATCHRA_OFFSET;
        //
        // The Translation Cache wasn't flushed - replace the CALLDIRECT
        // fragment by CALLDIRECT2
        //
        NativeSize = GenCallDirect2(CodeLocation,
                                    FALSE,  // patching, not compiling
#if _ALPHA_
                                    GetCurrentECU(CodeLocation),
#endif
                                    NativeDest,
                                    0);
        NtFlushInstructionCache(
            NtCurrentProcess(),
            CodeLocation, 
            NativeSize
            );
    } else {
        TCTimestamp = TranslationCacheTimestamp;

        if (Cpu->CSTimestamp != TCTimestamp) {
            //
            // The cache was flushed by another thread in the small window
            // between mrsw calls in this thread, we plan on jumping directly
            // to NativeDest, so the CPU callstack needs to be flushed.
            // Normally this would be done in the CpuSimulate() loop as a
            // result of jumping to EndTranslatedCode.
            //
            FlushCallstack(Cpu);
        }
    }

    //
    // Push IntelNext on the stack and update the stack optimization code.
    // This must be done while still in TC write mode.  If it isn't, then
    // the transition back to TC reader may allow a TC cache flush, invalidating
    // nativedest before it is written into the stack optimization.  (The
    // stack optimization is blown away whenever the TC is flushed, so if
    // it is written in BEFORE the flush, it will just get blown away.
    //
    try {
        CTRL_CallFrag(Cpu, IntelDest, IntelNext, 0 /* nativenext is unknown */);
    } _except(PatchCallDirectExceptionFilter(Cpu)) {
        // nothing to do - the exception filter does everything
    }

    //
    // Become a TC reader again.
    //
    MrswWriterExit(&MrswTC);
    MrswReaderEnter(&MrswTC);
    Cpu->fTCUnlocked = FALSE;

    if (TCTimestamp == TranslationCacheTimestamp) {
        //
        // TC was not flushed while becomming a reader again.
        //
        return NativeDest;
    } else {
        //
        // TC was flushed - nativedest is invalid.  The callstack optimization
        // was deleted when the TC flush occurred, so do an EndTranslatedCode
        // instead.
        return (ULONG)(ULONGLONG)  &EndTranslatedCode;
    }
}


ULONG 
PatchCallfDirect(
    IN PTHREADSTATE cpu,
    IN PUSHORT pIntelDest,
    IN ULONG IntelNext,
    IN PULONG PatchAddr
    )
/*++

Routine Description:

    This routine patches a CALLFDIRECT to a CALLFDIRECT2.  It is called when
    the native destination address of a call instruction is not yet known.
    It patches the call to jump directly to the corresponding native code.
     
Arguments:

    cpu       -- per-thread info
    pIntelDest-- ptr to SEL:OFFSET intel address of the destination of the call
    IntelNext -- intel address of the instruction following the call
    PatchAddr -- address of the CALLDIRECT in the Translation Cache

Return Value:

    Native address to jump to in order to resume execution
    
--*/
{
    DWORD TCTimestamp;
    ULONG NativeDest;
    PVOID IntelDest;
    ULONG NativeSize;


    //
    // Switch from being a TC reader to a writer
    //
    TCTimestamp = TranslationCacheTimestamp;
    MrswReaderExit(&MrswTC);

    //
    // Compile the code at the destination of the call and get the TC write lock
    //
    IntelDest = (PVOID)*(UNALIGNED DWORD *)pIntelDest;
    NativeDest = (ULONG)(ULONGLONG)  NativeAddressFromEip(IntelDest, TRUE)->nativeStart;

    if (TCTimestamp == TranslationCacheTimestamp) {
        PULONG CodeLocation = PatchAddr - CallfDirect_PATCHRA_OFFSET;
        //
        // The Translation Cache wasn't flushed - replace the CALLDIRECT
        // fragment by CALLDIRECT2
        //
        NativeSize = GenCallfDirect2(CodeLocation,
                                     FALSE,  // patching, not compiling
#if _ALPHA_
                                     GetCurrentECU(CodeLocation),
#endif
                                     NativeDest,
                                     0);
        NtFlushInstructionCache(
            NtCurrentProcess(),
            CodeLocation, 
            NativeSize
            );
    } else {
        TCTimestamp = TranslationCacheTimestamp;

        if (cpu->CSTimestamp != TCTimestamp) {
            //
            // The cache was flushed by another thread in the small window
            // between mrsw calls in this thread, we plan on jumping directly
            // to NativeDest, so the CPU callstack needs to be flushed.
            // Normally this would be done in the CpuSimulate() loop as a
            // result of jumping to EndTranslatedCode.
            //
            FlushCallstack(cpu);
        }
    }

    //
    // Push IntelNext on the stack and update the stack optimization code.
    // This must be done while still in TC write mode.  If it isn't, then
    // the transition back to TC reader may allow a TC cache flush, invalidating
    // nativedest before it is written into the stack optimization.  (The
    // stack optimization is blown away whenever the TC is flushed, so if
    // it is written in BEFORE the flush, it will just get blown away.
    //
    try {
        CTRL_CallfFrag(cpu, pIntelDest, IntelNext, 0 /* nativenext is unknown */);
    } _except(PatchCallDirectExceptionFilter(cpu)) {
        // nothing to do - the exception filter does everything
    }

    //
    // Become a TC reader again.
    //
    MrswWriterExit(&MrswTC);
    MrswReaderEnter(&MrswTC);
    cpu->fTCUnlocked = FALSE;

    if (TCTimestamp == TranslationCacheTimestamp) {
        //
        // TC was not flushed while becomming a reader again.
        //
        return NativeDest;
    } else {
        //
        // TC was flushed - nativedest is invalid.  The callstack optimization
        // was deleted when the TC flush occurred, so do an EndTranslatedCode
        // instead.
        return (ULONG)(ULONGLONG)  &EndTranslatedCode;
    }
}


ULONG 
PatchCallDirect2(
    IN PTHREADSTATE Cpu,
    IN ULONG IntelDest,
    IN ULONG IntelNext,
    IN ULONG NativeDest,
    IN PULONG PatchAddr
)
/*++

Routine Description:

    This routine patches a CALLDIRECT2 to a CALLDIRECT3.  It is called when
    the native destination address of the instruction after the call is not yet
    known.  It patches the fragment to place the native address of the
    instruction after the call on the optimized callstack.
     
Arguments:

    Cpu       -- per-thread info
    IntelDest -- intel address of the destination of the call
    IntelNext -- intel address of the instruction following the call
    NativeDest  -- native address of the destination of the call
    PatchAddr -- address of the CALLDIRECT2 in the Translation Cache

Return Value:

    Native address to jump to in order to resume execution
    
--*/
{
    DWORD TCTimestamp;
    ULONG NativeNext;
    ULONG NativeSize;

    TCTimestamp = TranslationCacheTimestamp;
    MrswReaderExit(&MrswTC);
    NativeNext = (ULONG)(ULONGLONG)  NativeAddressFromEipNoCompile((PVOID)IntelNext);

    if (NativeNext) {
        PULONG CodeLocation;

        //
        // The code at the return address from the call has already been
        // compiled.  Replace CALLDIRECT2 by CALLDIRECT3.  TC is locked
        // for write.
        //

        if (TCTimestamp != TranslationCacheTimestamp) {
            //
            // The TC was flushed while switching from reader to writer.
            // Become a TC reader again
            //
            MrswWriterExit(&MrswTC);
            MrswReaderEnter(&MrswTC);

            // The CALLDIRECT2 code is now gone, so set up for the call and
            // then go to EndTranslatedCode to make the control transfer.
            //
            CTRL_CallFrag(Cpu,
                          IntelDest,
                          IntelNext,
                          0   // nativenext is also unknown
                          );

            return (ULONG)(ULONGLONG)  &EndTranslatedCode;
        }

        CodeLocation = PatchAddr - CallDirect2_PATCHRA_OFFSET;
        //
        // Else the TC was not flushed, and nativenext is now known.  Patch
        // CALLDIRECT2 to be CALLDIRECT3
        //
        NativeSize = GenCallDirect3(CodeLocation,
                                    FALSE,  // patching, not compiling
#if _ALPHA_
                                    GetCurrentECU(CodeLocation),
#endif
                                    NativeDest,
                                    NativeNext);
        NtFlushInstructionCache(
            NtCurrentProcess(),
            CodeLocation, 
            NativeSize
            );

        //
        // Push IntelNext on the stack and update the stack optimization code.
        // This must be done while still in TC write mode.  If it isn't, then
        // the transition back to TC reader may allow a TC cache flush, invalidating
        // nativedest before it is written into the stack optimization.  (The
        // stack optimization is blown away whenever the TC is flushed, so if
        // it is written in BEFORE the flush, it will just get blown away.
        //
        CTRL_CallFrag(Cpu, IntelDest, IntelNext, NativeNext);

        //
        // Switch back to being a TC reader
        //
        MrswWriterExit(&MrswTC);
        MrswReaderEnter(&MrswTC);

        if (TCTimestamp != TranslationCacheTimestamp) {
            //
            // TC was flushed while we were becomming a reader again.
            // nativedest and nativenext are invalid, but stack optimization
            // code was flushed.
            //
            return (ULONG)(ULONGLONG)  &EndTranslatedCode;
        }
    } else {        // NativeNext == NULL, TC locked for Read
        CTRL_CallFrag(Cpu, IntelDest, IntelNext, 0);

        if (TCTimestamp != TranslationCacheTimestamp) {
            //
            // Cache was flushed by another thread.  NativeDest is invalid.
            //
            return (ULONG)(ULONGLONG)  &EndTranslatedCode;
        }
    }

    return NativeDest;
}


ULONG 
PatchCallfDirect2(
    IN PTHREADSTATE Cpu,
    IN PUSHORT pIntelDest,
    IN ULONG IntelNext,
    IN ULONG NativeDest,
    IN PULONG PatchAddr
)
/*++

Routine Description:

    This routine patches a CALLFDIRECT2 to a CALLFDIRECT3.  It is called when
    the native destination address of the instruction after the call is not yet
    known.  It patches the fragment to place the native address of the
    instruction after the call on the optimized callstack.
     
Arguments:

    Cpu       -- per-thread info
    pIntelDest-- ptr to SEL:OFFSET intel address of the destination of the call
    IntelNext -- intel address of the instruction following the call
    NativeDest  -- native address of the destination of the call
    PatchAddr -- address of the CALLDIRECT2 in the Translation Cache

Return Value:

    Native address to jump to in order to resume execution
    
--*/
{
    DWORD TCTimestamp;
    ULONG NativeNext;
    ULONG NativeSize;

    TCTimestamp = TranslationCacheTimestamp;
    MrswReaderExit(&MrswTC);
    NativeNext = (ULONG)(ULONGLONG)  NativeAddressFromEipNoCompile((PVOID)IntelNext);

    if (NativeNext) {
        PULONG CodeLocation;

        //
        // The code at the return address from the call has already been
        // compiled.  Replace CALLDIRECT2 by CALLDIRECT3.  TC is locked
        // for write.
        //

        if (TCTimestamp != TranslationCacheTimestamp) {
            //
            // The TC was flushed while switching from reader to writer.
            // Become a TC reader again
            //
            MrswWriterExit(&MrswTC);
            MrswReaderEnter(&MrswTC);

            // The CALLFDIRECT2 code is now gone, so set up for the call and
            // then go to EndTranslatedCode to make the control transfer.
            //
            CTRL_CallfFrag(Cpu,
                           pIntelDest,
                           IntelNext,
                           0   // nativenext is also unknown
                           );

            return (ULONG)(ULONGLONG)  &EndTranslatedCode;
        }

        CodeLocation = PatchAddr - CallfDirect2_PATCHRA_OFFSET;
        //
        // Else the TC was not flushed, and nativenext is now known.  Patch
        // CALLFDIRECT2 to be CALLFDIRECT3
        //
        NativeSize = GenCallfDirect3(CodeLocation,
                                     FALSE,  // patching, not compiling
#if _ALPHA_
                                     GetCurrentECU(CodeLocation),
#endif
                                     NativeDest,
                                     NativeNext);
        NtFlushInstructionCache(
            NtCurrentProcess(),
            CodeLocation, 
            NativeSize
            );

        //
        // Push IntelNext on the stack and update the stack optimization code.
        // This must be done while still in TC write mode.  If it isn't, then
        // the transition back to TC reader may allow a TC cache flush, invalidating
        // nativedest before it is written into the stack optimization.  (The
        // stack optimization is blown away whenever the TC is flushed, so if
        // it is written in BEFORE the flush, it will just get blown away.
        //
        CTRL_CallfFrag(Cpu, pIntelDest, IntelNext, NativeNext);

        //
        // Switch back to being a TC reader
        //
        MrswWriterExit(&MrswTC);
        MrswReaderEnter(&MrswTC);

        if (TCTimestamp != TranslationCacheTimestamp) {
            //
            // TC was flushed while we were becomming a reader again.
            // nativedest and nativenext are invalid, but stack optimization
            // code was flushed.
            //
            return (ULONG)(ULONGLONG)  &EndTranslatedCode;
        }
    } else {        // NativeNext == NULL, TC locked for Read
        CTRL_CallfFrag(Cpu, pIntelDest, IntelNext, 0);

        if (TCTimestamp != TranslationCacheTimestamp) {
            //
            // Cache was flushed by another thread.  NativeDest is invalid.
            //
            return (ULONG)(ULONGLONG)  &EndTranslatedCode;
        }
    }

    return NativeDest;
}


DWORD
PatchCallIndirectExceptionFilter(
    PTHREADSTATE cpu
    )
/*++

Routine Description:

    Called if CTRL_CallFrag() throws an exception from within
    PatchCallIndirect().  If this happens, the Translation Cache Write lock
    is being held.  This must be released before the exception can be
    allowed to continue.

Arguments:

    cpu
    
Return Value:

    None.

--*/
{
    //
    // Release the TC write lock.
    //
    MrswWriterExit(&MrswTC);

    //
    // Indicate the TC read lock is not held, either
    //
    cpu->fTCUnlocked = TRUE;

    //
    // Continue unwinding the stack
    //
    return EXCEPTION_CONTINUE_SEARCH;
}

VOID
PatchCallIndirect(
    IN PTHREADSTATE Cpu,
    IN ULONG IntelDest,
    IN ULONG IntelNext,
    IN PULONG PatchAddr
    )
/*++

Routine Description:

    This routine patches a CALLINDIRECT to a CALLINDIRECT2.  It is called when
    the native destination address of the instruction after the call is not yet
    known.  It patches the fragment to place the native address of the
    instruction after the call on the optimized callstack.
     
Arguments:

    Cpu       -- per-thread info
    IntelDest -- intel address of the destination of the call
    IntelNext -- intel address of the instruction following the call
    PatchAddr -- address of the CALLDIRECT2 in the Translation Cache

Return Value:

    None.  cpu->Eip updated to be IntelDest.
    
--*/
{
    DWORD TCTimestamp;
    ULONG NativeNext;
    ULONG NativeSize;

    TCTimestamp = TranslationCacheTimestamp;
    MrswReaderExit(&MrswTC);

    NativeNext = (ULONG)(ULONGLONG)  NativeAddressFromEipNoCompile((PVOID)IntelNext);

    if (NativeNext) {
         PULONG CodeLocation;

        //
        // The code at the return address from the call has already been
        // compiled.  Replace CALLINDIRECT by CALLINDIRECT2.  TC is locked
        // for write.
        //

        if (TCTimestamp != TranslationCacheTimestamp) {
            //
            // The TC was flushed while switching from reader to writer.
            // Become a TC reader again
            //
            MrswWriterExit(&MrswTC);
            MrswReaderEnter(&MrswTC);


            // The CALLINDIRECT code is now gone, so set up for the call
            // without patching anything
            //
            CTRL_CallFrag(
                Cpu,
                IntelDest,
                IntelNext,
                0     // nativenext is unknown
                );

            return;
        }

        //
        // Else the TC was not flushed, and nativenext is now known.  Patch
        // CALLINDIRECT to be CALLINDIRECT2
        //
        CodeLocation = PatchAddr - CallIndirect_PATCHRA_OFFSET;
        NativeSize = GenCallIndirect2(CodeLocation,
                                      FALSE,  // patching, not compiling
#if _ALPHA_
                                      GetCurrentECU(CodeLocation),
#endif
                                      NativeNext,
                                      getUniqueIndex());
        NtFlushInstructionCache(
            NtCurrentProcess(),
            CodeLocation, 
            NativeSize
            );

        //
        // Push IntelNext on the stack and update the stack optimization code.
        // This must be done while still in TC write mode.  If it isn't, then
        // the transition back to TC reader may allow a TC cache flush, invalidating
        // nativedest before it is written into the stack optimization.  (The
        // stack optimization is blown away whenever the TC is flushed, so if
        // it is written in BEFORE the flush, it will just get blown away.
        //
        _try {
            CTRL_CallFrag(Cpu, IntelDest, IntelNext, NativeNext);
        } _except(PatchCallIndirectExceptionFilter(Cpu)) {
            // nothing to do - the exception filter does everything
        }

        //
        // Switch back to being a TC reader.  TC flushes during the switch
        // are OK and require no extra work.
        //
        MrswWriterExit(&MrswTC);
        MrswReaderEnter(&MrswTC);

    } else {        // NativeNext == NULL, TC locked for read.

        CTRL_CallFrag(Cpu, IntelDest, IntelNext, 0);
    }

    return;
}

VOID
PatchCallfIndirect(
    IN PTHREADSTATE Cpu,
    IN PUSHORT pIntelDest,
    IN ULONG IntelNext,
    IN PULONG PatchAddr
    )
/*++

Routine Description:

    This routine patches a CALLFINDIRECT to a CALLFINDIRECT2.  It is called when
    the native destination address of the instruction after the call is not yet
    known.  It patches the fragment to place the native address of the
    instruction after the call on the optimized callstack.
     
Arguments:

    Cpu       -- per-thread info
    pIntelDest-- ptr to SEL:OFFSET intel address of the destination of the call
    IntelNext -- intel address of the instruction following the call
    PatchAddr -- address of the CALLDIRECT2 in the Translation Cache

Return Value:

    None.  cpu->eip updated to IntelDest
    
--*/
{
    DWORD TCTimestamp;
    ULONG NativeNext;
    ULONG IntelDest;
    ULONG NativeSize;

    TCTimestamp = TranslationCacheTimestamp;
    MrswReaderExit(&MrswTC);

    IntelDest = *(UNALIGNED DWORD *)pIntelDest;
    NativeNext = (ULONG)(ULONGLONG)   NativeAddressFromEipNoCompile((PVOID)IntelNext);

    if (NativeNext) {
         PULONG CodeLocation;

        //
        // The code at the return address from the call has already been
        // compiled.  Replace CALLINDIRECT by CALLINDIRECT2.  TC is locked
        // for write.
        //

        if (TCTimestamp != TranslationCacheTimestamp) {
            //
            // The TC was flushed while switching from reader to writer.
            // Become a TC reader again
            //
            MrswWriterExit(&MrswTC);
            MrswReaderEnter(&MrswTC);


            // The CALLFINDIRECT code is now gone, so set up for the call
            // without patching anything
            //
            CTRL_CallfFrag(
                Cpu,
                pIntelDest,
                IntelNext,
                0     // nativenext is unknown
                );

            return;
        }

        //
        // Else the TC was not flushed, and nativenext is now known.  Patch
        // CALLFINDIRECT to be CALLFINDIRECT2
        //
        CodeLocation = PatchAddr - CallfIndirect_PATCHRA_OFFSET;
        NativeSize = GenCallfIndirect2(CodeLocation,
                                       FALSE,  // patching, not compiling
#if _ALPHA_
                                       GetCurrentECU(CodeLocation),
#endif
                                       NativeNext,
                                       getUniqueIndex());
        NtFlushInstructionCache(
            NtCurrentProcess(),
            CodeLocation, 
            NativeSize
            );

        //
        // Push IntelNext on the stack and update the stack optimization code.
        // This must be done while still in TC write mode.  If it isn't, then
        // the transition back to TC reader may allow a TC cache flush, invalidating
        // nativedest before it is written into the stack optimization.  (The
        // stack optimization is blown away whenever the TC is flushed, so if
        // it is written in BEFORE the flush, it will just get blown away.
        //
        _try {
            CTRL_CallfFrag(Cpu, pIntelDest, IntelNext, NativeNext);
        } _except(PatchCallIndirectExceptionFilter(Cpu)) {
            // nothing to do - the exception filter does everything
        }

        //
        // Switch back to being a TC reader.  TC flushes during the switch
        // are OK and require no extra work.
        //
        MrswWriterExit(&MrswTC);
        MrswReaderEnter(&MrswTC);

    } else {        // NativeNext == NULL, TC locked for read.

        CTRL_CallfFrag(Cpu, pIntelDest, IntelNext, 0);
    }

    return;
}



//*********************************************************************************
// Below are functions for the Indirect Control Transfer Table
//*********************************************************************************

// This number must be below 0xffff, because we want to be able to load it with just
// one instruction (now we use ori).  It should also be a factor of two to get good
// code generation for % (so that we won't have to use a division instruction).
#define MAX_TABLE_ENTRIES   0x1000

typedef struct _IndirControlTransferTable {
    ULONG intelAddr;
    ULONG nativeAddr;
} INDIRCONTROLTRANSFERTABLE, *PINDIRCONTROLTRANSFERTABLE;

INDIRCONTROLTRANSFERTABLE IndirControlTransferTable[MAX_TABLE_ENTRIES];

// The last used index in the table
ULONG lastTableIndex;

ULONG
getUniqueIndex(
    VOID
    )
/*++

Routine Description:

    This function returns the next free index to the indirect control
    transfer table.  If it reaches the end of the table, it wraps around.
    NOTE:  we need not worry about synchronization  here, because we have
    an Entry Point write lock whenever we are called.

Arguments:

    none

Return Value:

    An index into the table

--*/
{
    return (lastTableIndex = ((lastTableIndex + 1) % MAX_TABLE_ENTRIES));
}

VOID
FlushIndirControlTransferTable(
    VOID
    )
/*++

Routine Description:

    This routine flushes the Indirect Control Transfer Table
    NOTE:  we need not worry about synchronizations here, because the routine
    which calls us (FlushTranslationCache) has a Translation Cache write lock.

Arguments:

    none

Return Value:

    none

--*/
{
    RtlZeroMemory (IndirControlTransferTable, sizeof(INDIRCONTROLTRANSFERTABLE)*MAX_TABLE_ENTRIES);
    lastTableIndex = 0;
}

ULONG
IndirectControlTransfer(
    IN ULONG tableEntry,
    IN ULONG intelAddr,
    IN PTHREADSTATE cpu
    )
/*++

Routine Description:

    This routine is used by an indirect control transfer operation to try
    and save a call to the Entry Point Manager.

Arguments:

    tableEntry -- The index of the table entry where information might be
        available about intelAddr

    intelAddr -- The intel address we want to go to

    cpu -- pointer to per-thread CPU data

Return Value:

    The native address we want to go to

--*/
{
    ULONG nativeAddr;
    DWORD TCTimestamp;

    //
    // Detect apps which do the following:
    //    call foo
    // where
    //    foo:   mov eax, [esp]
    //           ...
    //           jmp eax        ; this is really a 'ret' instruction
    //
    // This is the way _alloca() works - you call it with eax==number of bytes
    // to allocate, and it jumps back to its caller with esp munged.
    //
    // What happens is the callstack cache gets out-of-sync.  If the app
    // is trying to do an indirect jump to the address already on the
    // callstack cache, we will pop the callstack cache.
    //
    if (ISTOPOF_CALLSTACK(intelAddr)) {
        POP_CALLSTACK(intelAddr, nativeAddr);
        if (nativeAddr) {
            return nativeAddr;
        }
    }

    // First see if the table is filled in correctly already
    MrswReaderEnter(&MrswIndirTable);
    if (IndirControlTransferTable[tableEntry].intelAddr == intelAddr){
        nativeAddr = IndirControlTransferTable[tableEntry].nativeAddr;
        if (nativeAddr) {
            MrswReaderExit(&MrswIndirTable);
            return nativeAddr;
        }
    }
    MrswReaderExit(&MrswIndirTable);

    // Give up the translation cache reading lock so that we can call NativeAddressFromEip
    TCTimestamp = TranslationCacheTimestamp;
    MrswReaderExit(&MrswTC);
    nativeAddr = (ULONG) (ULONGLONG)NativeAddressFromEip((PVOID)intelAddr, FALSE)->nativeStart; 

    // Note:  we now have a TC read lock obtained by NativeAddressFromEip.  
    if (TCTimestamp == TranslationCacheTimestamp) {
        // We haven't flushed the cache.  Save the native address in the table.
        MrswWriterEnter(&MrswIndirTable);
        IndirControlTransferTable[tableEntry].intelAddr = intelAddr;
        IndirControlTransferTable[tableEntry].nativeAddr = nativeAddr;
        MrswWriterExit(&MrswIndirTable);
    } else {
        //
        // Translation cache was flushed, possibly by another thread.
        // Flush our callstack before resuming execution of RISC code
        // in the Translation Cache.
        //
        FlushCallstack(cpu);
    }
    // Return the native address to IndirectControlTransferHelper which will go there.
    return nativeAddr;
}

ULONG
IndirectControlTransferFar(
    IN PTHREADSTATE cpu,
    IN PUSHORT pintelAddr,
    IN ULONG tableEntry
    )
/*++

Routine Description:

    This routine is used by a FAR indirect control transfer operation to try
    and save a call to the Entry Point Manager.

Arguments:

    tableEntry -- The index of the table entry where information might be
        available about intelAddr

    pintelAddr -- Pointer to SEL:OFFSET intel address we want to go to

Return Value:

    The native address we want to go to

--*/
{
    USHORT Sel;
    ULONG Offset;

    Offset = *(UNALIGNED PULONG)pintelAddr;
    Sel = *(UNALIGNED PUSHORT)(pintelAddr+2);

    CS = Sel;
    eip = Offset;

    return IndirectControlTransfer(tableEntry, Offset, cpu);
}



ULONG
PlaceNop(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    )
{
    return 0;
}


#if _ALPHA_
ULONG
GetCurrentECU(
    PULONG CodeLocation
    )
/*++

Routine Description:

    This routine returns the correct ECU.  CurrentECU is the target for 
    branch instructions when a fragment wants to jump to EndTranslatedCode.
    
    N.B.  This routine cannot change the global CurrentECU.  This is set in
          Compile(), and is the only way to locate the ECU at the end of 
          the translation cache if the exception info hasn't been placed
          yet.
    
Arguments:
    
    CodeLocation -- The code location which will be patched.
                            
Return Value:

    None.
    
--*/
{
    //
    // Find an EndCompilationUnit fragment by searching the Translation Cache
    // for the next EXCEPTIONDATA_SIGNATURE.  The code immediately before it
    // is an EndCompilationUnit fragment.
    //
    while (*CodeLocation != EXCEPTIONDATA_SIGNATURE) {
        CodeLocation++;
    }
    return (ULONG)(ULONGLONG)(CodeLocation-EndCompilationUnit_SIZE); 
}
#endif      // _ALPHA_-only
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\cpu\axp64\arith.c ===
//
// Copyright (c) 1996  Microsoft Corporation
//
// Module Name:
//
//     arith.c
// 
// Abstract:
// 
//     This module contains descriptions of the hand generated arithmetic
//     fragments.
// 
// Author:
// 
//     Barry Bond (barrybo) creation-date 29-Mar-1996
// 
// Notes:
//
// Revision History:
//
//

#include <codeseqp.h>

ASSERTNAME;


/*++

Macro Description:

    Preamble code placed before a 32-bit aligned inline arithmetic instruction.

Arguments:

    None

Return Value:

    None.  Defines a new variable, SrcReg, which contains the number of
    the RISC register containing the value of Operand1.
    
--*/
#define INSTR_PREAMBLE32A                                                   \
ULONG SrcReg;                                                               \
                                                                            \
if (Instruction->Operand1.Type == OPND_REGREF) {                            \
    if (GetArgContents(1) == Instruction->Operand1.Reg) {                   \
        SrcReg = AREG_NP(A1);                                               \
    } else if (GetArgContents(2) == Instruction->Operand1.Reg) {            \
        SrcReg = AREG_NP(A2);                                               \
    } else {                                                                \
        SrcReg = LookupRegInCache(Instruction->Operand1.Reg);               \
        if (SrcReg == NO_REG) {                                             \
            SrcReg = RegTemp;                                               \
            LDL (SrcReg, DISP(RegisterOffset[Instruction->Operand1.Reg]), RegPointer)\
        } else {                                                            \
            SrcReg = CACHEREG(SrcReg);                                      \
        }                                                                   \
    }                                                                       \
} else {                                                                    \
    SrcReg = RegTemp;                                                       \
    LDL (SrcReg, 0, AREG_NP(A1))                                            \
}


/*++

Macro Description:

    Preamble code placed before a 32-bit unaligned inline arithmetic
    instruction.

Arguments:

    AREG_NP(A1) contains the address to load the DWORD from.

Return Value:

    None.  Defines a new variable, SrcReg, which contains the number of
    the RISC register containing the value of Operand1.

    TREG_NP(T4) contains the low 2 bits of AREG_NP(A1)
    
--*/
#define INSTR_PREAMBLE32                                    \
ULONG SrcReg = RegTemp;                                     \
LABEL_DEC(l1)                                               \
LABEL_DEC(l2)                                               \
/* It is better to not use the byte instructions here */    \
/* They require 7 instructions to do the unaligned    */    \
/* load, vs. 5 with LDQ_U.                            */    \
CPUASSERT(Instruction->Operand1.Type != OPND_REGREF);       \
    AND(AREG_NP(A1), CNST(3), TREG_NP(T4))                  \
    BNE_LABEL(TREG_NP(T4), FWD(l1))   /* brif not aligned */\
    LDL(RegTemp, DISP(0), AREG_NP(A1))                      \
    BR_LABEL(REG(AT), FWD(l2))                              \
LABEL(l1)                                                   \
    LDQ_U(RegTemp, 0, AREG_NP(A1))                          \
    EXTLL(RegTemp, AREG_NP(A1), RegTemp0)                   \
    LDQ_U(RegTemp, 3, AREG_NP(A1))                          \
    EXTLH(RegTemp, AREG_NP(A1), RegTemp1)                   \
    BIS(RegTemp0, RegTemp1, RegTemp)                        \
LABEL(l2)                                                   \
GEN_CT(l1)                                                  \
GEN_CT(l2)


/*++

Macro Description:

    Postamble code placed after a 32-bit aligned inline arithmetic
    instruction.  Stores the result of the instruction back to memory.

Arguments:

    RegTemp -- results of the arithmetic operation, ready for store into
    memory.

Return Value:

    None.
    
--*/
#define INSTR_POSTAMBLE32A                                                  \
if (Instruction->Operand1.Type == OPND_REGREF) {                            \
    STL (RegTemp, RegisterOffset[Instruction->Operand1.Reg], RegPointer)    \
} else {                                                                    \
    STL (RegTemp, 0, AREG_NP(A1))                                           \
}


/*++

Macro Description:

    Postamble code placed after a 32-bit unaligned inline arithmetic
    instruction.  Stores the result of the instruction back to memory.

Arguments:

    RegTemp     -- Results of the arithmetic operation, ready for store into
                   memory.

    AREG_NP(A1) -- Address to store DWORD to.
    TREG_NP(T4) -- Low 2 bits of AREG_NP(A1)

Return Value:

    None.
    
--*/
#define INSTR_POSTAMBLE32                               \
CPUASSERT(Instruction->Operand1.Type != OPND_REGREF);   \
    BNE_LABEL(TREG_NP(T4), FWD(l1))                     \
    STL(RegTemp, DISP(0), AREG_NP(A1))                  \
    BR_LABEL(REG(AT), FWD(l2))                          \
LABEL(l1)                                               \
    if (fByteInstructionsOK) {                          \
        /* save 5 instructions */                       \
        STB(RegTemp, DISP(0), AREG_NP(A1))              \
        SRL(RegTemp, CNST(8), TREG_NP(T0))              \
        STB(TREG_NP(T0), DISP(1), AREG_NP(A1))          \
        SRL(RegTemp, CNST(16), TREG_NP(T0))             \
        STB(TREG_NP(T0), DISP(2), AREG_NP(A1))          \
        SRL(RegTemp, CNST(24), TREG_NP(T0))             \
        STB(TREG_NP(T0), DISP(3), AREG_NP(A1))          \
    } else {                                            \
        BIC(AREG_NP(A1), CNST(3), TREG_NP(T0))          \
        LDL(TREG_NP(T1), DISP(0), TREG_NP(T0))          \
        INSLL(RegTemp, TREG_NP(T4), TREG_NP(T2))        \
        MSKLL(TREG_NP(T1), TREG_NP(T4), TREG_NP(T3))    \
        BIS(TREG_NP(T3), TREG_NP(T2), TREG_NP(T1))      \
        STL(TREG_NP(T1), DISP(0), TREG_NP(T0))          \
        ADDL(TREG_NP(T4), CNST(4), TREG_NP(T4))         \
        LDL(TREG_NP(T1), DISP(4), TREG_NP(T0))          \
        INSLH(RegTemp, TREG_NP(T4), TREG_NP(T2))        \
        MSKLH(TREG_NP(T1), TREG_NP(T4), TREG_NP(T3))    \
        BIS(TREG_NP(T3), TREG_NP(T2), TREG_NP(T1))      \
        STL(TREG_NP(T1), DISP(4), TREG_NP(T0))          \
    }                                                   \
LABEL(l2)                                               \
GEN_CT(l1)                                              \
GEN_CT(l2)



PULONG
LoadOperand32(
    PULONG d,
    PINSTRUCTION Instruction,
    PULONG SrcReg
    )
/*++

Routine Description:

    Loads the value specified in Instruction->Operand2 into a RISC register.

Arguments:

    d           -- offset to generate new RISC code at
    Instruction -- x86 instruction to generate code for
    SrcReg      -- OUT ptr to the RISC register Operand2 was loaded into.

Return Value:

    New offset to generate code at.
    
--*/
{
    if (Instruction->Operand2.Type != OPND_REGVALUE) {
        *SrcReg = AREG_NP(A2);
        return d;
    }

    if (GetArgContents(2) == Instruction->Operand2.Reg) {
        *SrcReg = AREG_NP(A2);
    } else {
        *SrcReg = LookupRegInCache(Instruction->Operand2.Reg);
        if (*SrcReg == NO_REG) {
            *SrcReg = AREG_NP(A0);
            LDL (*SrcReg, RegisterOffset[Instruction->Operand2.Reg], RegPointer)
        } else {
            *SrcReg = CACHEREG(*SrcReg);
        }
    }

    return d;
}


PULONG
InlineAddInstr(
    PULONG d,
    PINSTRUCTION Instruction,
    ULONG SrcReg
    )
/*++

Routine Description:

    Generates code for an inlined ADD instruction.

Arguments:

    d           -- offset to generate new RISC code at
    Instruction -- x86 instruction to generate code for
    SrcReg      -- the RISC register containing the value of Operand1

Return Value:

    New offset to generate code at.  RegTemp contains the resulting value
    of the instruction.
    
--*/
{
    if (Instruction->Operand2.Type == OPND_IMM) {
        ULONG Immed = Instruction->Operand2.Immed;

        if (Immed == 0) {
            if (SrcReg != RegTemp) {
                MOV (SrcReg, RegTemp)
            }
        } else if (Immed < 0x100) {
            // Immed is < 256, so add it in via immediate form
            ADDL (SrcReg, CNST(Immed), RegTemp)
        } else if (Immed > 0xffffff00) {
            // Immed is > -256 and less than 0, so subtract it via immed form
            Immed = (ULONG)-(LONG)Immed;
            SUBL (SrcReg, CNST(Immed), RegTemp)
        } else {
            USHORT High;
            USHORT Low;

            High = HIWORD(Immed);
            Low = LOWORD(Immed);

            if (Low || High == 0) {
                if (Low & 0x8000) {
                    //
                    // Account for sign-extension
                    //
                    High++;
                }
                if (High) {
                    LDAH (RegTemp, High, SrcReg)
                    LDA  (RegTemp, Low, RegTemp)
                } else {
                    LDA  (RegTemp, Low, SrcReg)
                }

            } else {
                LDAH  (RegTemp, High, SrcReg)
            }
        }
    } else  {
        ULONG SrcReg2;

        d = LoadOperand32(d, Instruction, &SrcReg2);

        ADDL (SrcReg, SrcReg2, RegTemp)
    }

    return d;
}


PULONG
InlineAndInstr(
    PULONG d,
    PINSTRUCTION Instruction,
    ULONG SrcReg
    )
/*++

Routine Description:

    Generates code for an inlined AND instruction.

Arguments:

    d           -- offset to generate new RISC code at
    Instruction -- x86 instruction to generate code for
    SrcReg      -- the RISC register containing the value of Operand1

Return Value:

    New offset to generate code at.  RegTemp contains the resulting value
    of the instruction.
    
--*/
{
    if (Instruction->Operand2.Type == OPND_IMM) {
        ULONG Immed = Instruction->Operand2.Immed;

        if (Immed == 0) {
            //
            // "AND x, 0"   gives 0 as the result
            //
            MOV (REG(ZERO), RegTemp)
        } else if (Immed < 0x100) {
            // Immed is < 256, so and it in via immediate form
            AND (SrcReg, CNST(Immed), RegTemp)
        } else {
            USHORT High;
            USHORT Low;
            ULONG ImmedReg;

            if (SrcReg == RegTemp) {
                ImmedReg = AREG_NP(A2);
            } else {
                ImmedReg = RegTemp;
            }

            High = HIWORD(Immed);
            Low = LOWORD(Immed);

            if (Low || High == 0) {
                if (Low & 0x8000) {
                    //
                    // Account for sign-extension
                    //
                    High++;
                }
                if (High) {
                    LDAH (ImmedReg, High, REG(ZERO))
                    LDA  (ImmedReg, Low, ImmedReg)
                } else {
                    LDA  (ImmedReg, Low, REG(ZERO))
                }

            } else {
                LDAH  (ImmedReg, High, REG(ZERO))
            }
            AND (SrcReg, ImmedReg, RegTemp)
        }
    } else {
        ULONG SrcReg2;

        d = LoadOperand32(d, Instruction, &SrcReg2);

        AND (SrcReg, SrcReg2, RegTemp)
    }

    return d;
}


PULONG
InlineOrInstr(
    PULONG d,
    PINSTRUCTION Instruction,
    ULONG SrcReg
    )
/*++

Routine Description:

    Generates code for an inlined OR instruction.

Arguments:

    d           -- offset to generate new RISC code at
    Instruction -- x86 instruction to generate code for
    SrcReg      -- the RISC register containing the value of Operand1

Return Value:

    New offset to generate code at.  RegTemp contains the resulting value
    of the instruction.
    
--*/
{
    if (Instruction->Operand2.Type == OPND_IMM) {
        ULONG Immed = Instruction->Operand2.Immed;

        if (Immed == 0) {
            //
            // "OR x, 0"   gives x as the result
            //
            MOV (SrcReg, RegTemp)
        } else if (Immed < 0x100) {
            // Immed is < 256, so or it in via immediate form
            BIS (SrcReg, CNST(Immed), RegTemp)
        } else {
            USHORT High;
            USHORT Low;
            ULONG ImmedReg;

            if (SrcReg == RegTemp) {
                ImmedReg = AREG_NP(A2);
            } else {
                ImmedReg = RegTemp;
            }

            High = HIWORD(Immed);
            Low = LOWORD(Immed);

            if (Low || High == 0) {
                if (Low & 0x8000) {
                    //
                    // Account for sign-extension
                    //
                    High++;
                }
                if (High) {
                    LDAH (ImmedReg, High, REG(ZERO))
                    LDA  (ImmedReg, Low, ImmedReg)
                } else {
                    LDA  (ImmedReg, Low, REG(ZERO))
                }

            } else {
                LDAH  (ImmedReg, High, REG(ZERO))
            }
            BIS (SrcReg, ImmedReg, RegTemp)
        }
    } else {
        ULONG SrcReg2;

        d = LoadOperand32(d, Instruction, &SrcReg2);

        BIS (SrcReg, SrcReg2, RegTemp)
    }

    return d;
}


PULONG
InlineSubInstr(
    PULONG d,
    PINSTRUCTION Instruction,
    ULONG SrcReg
    )
/*++

Routine Description:

    Generates code for an inlined SUB instruction.

Arguments:

    d           -- offset to generate new RISC code at
    Instruction -- x86 instruction to generate code for
    SrcReg      -- the RISC register containing the value of Operand1

Return Value:

    New offset to generate code at.  RegTemp contains the resulting value
    of the instruction.
    
--*/
{
    if (Instruction->Operand2.Type == OPND_IMM) {
        ULONG Immed = Instruction->Operand2.Immed;

        if (Immed == 0) {
            if (SrcReg != RegTemp) {
                MOV (SrcReg, RegTemp)
            }
        } else if (Immed < 0x100) {
            // Immed is < 256, so subtract it in via immediate form
            SUBL (SrcReg, CNST(Immed), RegTemp)
        } else if (Immed > 0xffffff00) {
            // Immed is > -256 and less than 0, so add it via immed form
            Immed = (ULONG)-(LONG)Immed;
            ADDL (SrcReg, CNST(Immed), RegTemp)
        } else {
            USHORT High;
            USHORT Low;

            //
            // Negate the immediate value and add it in
            //
            Immed = (LONG)-(LONG)Immed;

            High = HIWORD(Immed);
            Low = LOWORD(Immed);

            if (Low || High == 0) {
                if (Low & 0x8000) {
                    //
                    // Account for sign-extension
                    //
                    High++;
                }
                if (High) {
                    LDAH (RegTemp, High, SrcReg)
                    LDA  (RegTemp, Low, RegTemp)
                } else {
                    LDA  (RegTemp, Low, SrcReg)
                }

            } else {
                LDAH  (RegTemp, High, SrcReg)
            }
        }
    } else  {
        ULONG SrcReg2;

        d = LoadOperand32(d, Instruction, &SrcReg2);
        SUBL (SrcReg, SrcReg2, RegTemp)
    }

    return d;
}


PULONG
InlineXorInstr(
    PULONG d,
    PINSTRUCTION Instruction,
    ULONG SrcReg
    )
/*++

Routine Description:

    Generates code for an inlined XOR instruction.

Arguments:

    d           -- offset to generate new RISC code at
    Instruction -- x86 instruction to generate code for
    SrcReg      -- the RISC register containing the value of Operand1

Return Value:

    New offset to generate code at.  RegTemp contains the resulting value
    of the instruction.
    
--*/
{
    if (Instruction->Operand2.Type == OPND_IMM) {
        ULONG Immed = Instruction->Operand2.Immed;

        if (Immed == 0) {
            //
            // "XOR x, 0"   gives x as the result
            //
            MOV (SrcReg, RegTemp)
        } else if (Immed < 0x100) {
            // Immed is < 256, so or it in via immediate form
            XOR (SrcReg, CNST(Immed), RegTemp)
        } else {
            USHORT High;
            USHORT Low;
            ULONG ImmedReg;

            if (SrcReg == RegTemp) {
                ImmedReg = AREG_NP(A2);
            } else {
                ImmedReg = RegTemp;
            }

            High = HIWORD(Immed);
            Low = LOWORD(Immed);

            if (Low || High == 0) {
                if (Low & 0x8000) {
                    //
                    // Account for sign-extension
                    //
                    High++;
                }
                if (High) {
                    LDAH (ImmedReg, High, REG(ZERO))
                    LDA  (ImmedReg, Low, ImmedReg)
                } else {
                    LDA  (ImmedReg, Low, REG(ZERO))
                }

            } else {
                LDAH  (ImmedReg, High, REG(ZERO))
            }
            XOR (SrcReg, ImmedReg, RegTemp)
        }
    } else  {
        ULONG SrcReg2;

        d = LoadOperand32(d, Instruction, &SrcReg2);

        XOR (SrcReg, SrcReg2, RegTemp)
    }

    return d;
}


        FRAGMENT(AddFragNoFlags32A)
//
// Routine Description:
// 
//     This fragment generates inline code for 32-bit aligned NoFlags ADD.
// 
// Arguments:
// 
//     If Operand1.Type is not OPND_REGREF, A1 contains the pointer to the
//     destination of the add.  Otherwise, A1 is undefined (ie. for
//     OPND_REGREF).
//
// Return Value:
// 
//     None.
//
            INSTR_PREAMBLE32A
            d = InlineAddInstr(d, Instruction, SrcReg);
            INSTR_POSTAMBLE32A
        END_FRAGMENT


        FRAGMENT(AddFragNoFlags32)
//
// Routine Description:
// 
//     This fragment generates inline code for 32-bit unaligned NoFlags ADD.
// 
// Arguments:
// 
//     If Operand1.Type is not OPND_REGREF, A1 contains the pointer to the
//     destination of the add.  Otherwise, A1 is undefined (ie. for
//     OPND_REGREF).
//
// Return Value:
// 
//     None.
//
            INSTR_PREAMBLE32
            d = InlineAddInstr(d, Instruction, SrcReg);
            INSTR_POSTAMBLE32
        END_FRAGMENT


        FRAGMENT(AndFragNoFlags32A)
//
// Routine Description:
// 
//     This fragment generates inline code for 32-bit aligned NoFlags AND.
// 
// Arguments:
// 
//     If Operand1.Type is not OPND_REGREF, A1 contains the pointer to the
//     destination of the add.  Otherwise, A1 is undefined (ie. for
//     OPND_REGREF).
//
// Return Value:
// 
//     None.
//
            INSTR_PREAMBLE32A
            d = InlineAndInstr(d, Instruction, SrcReg);
            INSTR_POSTAMBLE32A
        END_FRAGMENT

        FRAGMENT(AndFragNoFlags32)
//
// Routine Description:
// 
//     This fragment generates inline code for 32-bit unaligned NoFlags AND.
// 
// Arguments:
// 
//     If Operand1.Type is not OPND_REGREF, A1 contains the pointer to the
//     destination of the add.  Otherwise, A1 is undefined (ie. for
//     OPND_REGREF).
//
// Return Value:
// 
//     None.
//
            INSTR_PREAMBLE32
            d = InlineAndInstr(d, Instruction, SrcReg);
            INSTR_POSTAMBLE32
        END_FRAGMENT


        FRAGMENT(IncFragNoFlags32A)
//
// Routine Description:
// 
//     This fragment generates inline code for 32-bit aligned NoFlags INC.
// 
// Arguments:
// 
//     If Operand1.Type is not OPND_REGREF, A1 contains the pointer to the
//     destination of the add.  Otherwise, A1 is undefined (ie. for
//     OPND_REGREF).
//
// Return Value:
// 
//     None.
//
            INSTR_PREAMBLE32A
            //
            // Rewrite "INC Operand1" as "ADD Operand1, 1"
            //
            Instruction->Operand2.Type = OPND_IMM;
            Instruction->Operand2.Immed = 1;
            d = InlineAddInstr(d, Instruction, SrcReg);
            INSTR_POSTAMBLE32A
        END_FRAGMENT


        FRAGMENT(IncFragNoFlags32)
//
// Routine Description:
// 
//     This fragment generates inline code for 32-bit unaligned NoFlags INC.
// 
// Arguments:
// 
//     If Operand1.Type is not OPND_REGREF, A1 contains the pointer to the
//     destination of the add.  Otherwise, A1 is undefined (ie. for
//     OPND_REGREF).
//
// Return Value:
// 
//     None.
//
            INSTR_PREAMBLE32
            //
            // Rewrite "INC Operand1" as "ADD Operand1, 1"
            //
            Instruction->Operand2.Type = OPND_IMM;
            Instruction->Operand2.Immed = 1;
            d = InlineAddInstr(d, Instruction, SrcReg);
            INSTR_POSTAMBLE32
        END_FRAGMENT

        FRAGMENT(DecFragNoFlags32A)
//
// Routine Description:
// 
//     This fragment generates inline code for 32-bit aligned NoFlags DEC.
// 
// Arguments:
// 
//     If Operand1.Type is not OPND_REGREF, A1 contains the pointer to the
//     destination of the add.  Otherwise, A1 is undefined (ie. for
//     OPND_REGREF).
//
// Return Value:
// 
//     None.
//
            INSTR_PREAMBLE32A
            //
            // Rewrite "DEC Operand1" as "ADD Operand1, -1"
            //
            Instruction->Operand2.Type = OPND_IMM;
            Instruction->Operand2.Immed = 0xffffffff;
            d = InlineAddInstr(d, Instruction, SrcReg);
            INSTR_POSTAMBLE32A
        END_FRAGMENT


        FRAGMENT(DecFragNoFlags32)
//
// Routine Description:
// 
//     This fragment generates inline code for 32-bit unaligned NoFlags DEC.
// 
// Arguments:
// 
//     If Operand1.Type is not OPND_REGREF, A1 contains the pointer to the
//     destination of the add.  Otherwise, A1 is undefined (ie. for
//     OPND_REGREF).
//
// Return Value:
// 
//     None.
//
            INSTR_PREAMBLE32
            //
            // Rewrite "DEC Operand1" as "ADD Operand1, -1"
            //
            Instruction->Operand2.Type = OPND_IMM;
            Instruction->Operand2.Immed = 0xffffffff;
            d = InlineAddInstr(d, Instruction, SrcReg);
            INSTR_POSTAMBLE32
        END_FRAGMENT


        FRAGMENT(OrFragNoFlags32A)
//
// Routine Description:
// 
//     This fragment generates inline code for 32-bit aligned NoFlags OR.
// 
// Arguments:
// 
//     If Operand1.Type is not OPND_REGREF, A1 contains the pointer to the
//     destination of the add.  Otherwise, A1 is undefined (ie. for
//     OPND_REGREF).
//
// Return Value:
// 
//     None.
//
            INSTR_PREAMBLE32A
            d = InlineOrInstr(d, Instruction, SrcReg);
            INSTR_POSTAMBLE32A
        END_FRAGMENT


        FRAGMENT(OrFragNoFlags32)
//
// Routine Description:
// 
//     This fragment generates inline code for 32-bit unaligned NoFlags OR.
// 
// Arguments:
// 
//     If Operand1.Type is not OPND_REGREF, A1 contains the pointer to the
//     destination of the add.  Otherwise, A1 is undefined (ie. for
//     OPND_REGREF).
//
// Return Value:
// 
//     None.
//
            INSTR_PREAMBLE32
            d = InlineOrInstr(d, Instruction, SrcReg);
            INSTR_POSTAMBLE32
        END_FRAGMENT


        FRAGMENT(SubFragNoFlags32A)
//
// Routine Description:
// 
//     This fragment generates inline code for 32-bit aligned NoFlags SUB.
// 
// Arguments:
// 
//     If Operand1.Type is not OPND_REGREF, A1 contains the pointer to the
//     destination of the add.  Otherwise, A1 is undefined (ie. for
//     OPND_REGREF).
//
// Return Value:
// 
//     None.
//
            INSTR_PREAMBLE32A
            d = InlineSubInstr(d, Instruction, SrcReg);
            INSTR_POSTAMBLE32A
        END_FRAGMENT


        FRAGMENT(SubFragNoFlags32)
//
// Routine Description:
// 
//     This fragment generates inline code for 32-bit unaligned NoFlags SUB.
// 
// Arguments:
// 
//     If Operand1.Type is not OPND_REGREF, A1 contains the pointer to the
//     destination of the add.  Otherwise, A1 is undefined (ie. for
//     OPND_REGREF).
//
// Return Value:
// 
//     None.
//
            INSTR_PREAMBLE32
            d = InlineSubInstr(d, Instruction, SrcReg);
            INSTR_POSTAMBLE32
        END_FRAGMENT


        FRAGMENT(XorFragNoFlags32A)
//
// Routine Description:
// 
//     This fragment generates inline code for 32-bit aligned NoFlags XOR.
// 
// Arguments:
// 
//     If Operand1.Type is not OPND_REGREF, A1 contains the pointer to the
//     destination of the add.  Otherwise, A1 is undefined (ie. for
//     OPND_REGREF).
//
// Return Value:
// 
//     None.
//
            INSTR_PREAMBLE32A
            d = InlineXorInstr(d, Instruction, SrcReg);
            INSTR_POSTAMBLE32A
        END_FRAGMENT


        FRAGMENT(XorFragNoFlags32)
//
// Routine Description:
// 
//     This fragment generates inline code for 32-bit unaligned NoFlags XOR.
// 
// Arguments:
// 
//     If Operand1.Type is not OPND_REGREF, A1 contains the pointer to the
//     destination of the add.  Otherwise, A1 is undefined (ie. for
//     OPND_REGREF).
//
// Return Value:
// 
//     None.
//
            INSTR_PREAMBLE32
            d = InlineXorInstr(d, Instruction, SrcReg);
            INSTR_POSTAMBLE32
        END_FRAGMENT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\cpu\axp64\codeseq.c ===
//
// Copyright (c) 1995-2000  Microsoft Corporation
//
// Module Name:
//
//     codeseq.c
// 
// Abstract:
// 
//     This module contains descriptions of the hand generated fragments.  
//     There should be as few as possible.  They should be as simple as 
//     possible.  This file is (potentially) included multiple times with
//     the macros redefined to produce different representations of the code.
//     This is the only representation of the hand written assembler that 
//     is put into the translation cache.  Hand written assembler that is
//     not put into the translation cache appears elsewhere.
// 
// Author:
// 
//     Dave Hastings (daveh) creation-date 12-Jan-1996
// 
// Notes:
// 
//     Definitions for any macros used is done by the including code
//
//     Fragment Naming:
//          No specifier -- DWORD aligned
//          U            -- unaligned
//          Q            -- contained in a qword
//          D            -- contained in a dword
//
//          Unaligned is always the worst case code.
//          Contained in <size> indicates that the entire value
//              falls inside an aligned memory location of <size>
//              This allows us to generate slightly better code, in that
//              we don't have to do two fetches  
//
//     'Asm' macros and their usage
//
//          Each instruction has a macro of the same name as the instruction
//          with the same parameters as the instruction.
//
//          Labels have to be declared.  Only on instruction can branch to 
//          a specific label in a given fragment (because of the way forward
//          destinations are determined).  If two instructions need to branch
//          to the same location in the fragment, TWO labels must be declared
//          and used.  Each label requires a GEN_CT(<label>) at the end of 
//          the fragment.  If you don't put one in, the control transfer 
//          instruction will not be placed in memory (which will result
//          in a fault on a halt instruction).
//
//          AREG is replaced with the correct argument register for operand
//          fragments
//          
//          TREG(<tn>) is replaced with the appropriate temporary register for
//          the argument number in operand fragments
//          
//          AREG_NP(<an>)/TREG_NP(<tn>) is the specified argument/temp register.
//          (_NP stands for no patch)
//
//          REG() specifies a register
//      
//          CNST() specifies a constant.  Since operate instructions can
//          take either a register or a constant, and have different encodings,
//          we diddle some bits in the constant so we can distinguish it from
//          a register
//
//          DISP() is a 16 bit displacement
//          
//          CFUNC_LOW() is the low 16 bits of a 32 bit constant
//          CFUNC_HIGH() is the high 16 bits of the constant, adjusted
//          for sign extension (see the lda/ldah instructions)
//
//          BDISP() is a branch displacement the argment is the destination
//          of the branch
//
//          JHINT() is a jmp hint.  The argument is the destination.
//
// Revision History:

//            24-Aug-1999 [askhalid] copied from 32-bit wx86 directory and make work for 64bit.
//            20-Sept-1999[barrybo]  added FRAG2REF(LockCmpXchg8bFrag32, ULONGLONG)
//
//
//  maybe load a saved register with 0x00010000 to use to compensate
//  for sign extension?
//
// Look at 8 bit imm (largest that fits operate instructions)

#include <codeseqp.h>

//
// In the Alpha translation cache, all calls to the fragment library are
// made via a "jsr ra, reg" instruction because there aren't enough bits
// to jump to an address.  Rather than reloading the target register
// before each jump, if there are two consecutive calls to the same fragment,
// the address does not need to be reloaded, saving two instructions.
//
PVOID LastFragCalled;

ASSERTNAME;


        FRAGMENT(StartBasicBlock)
//
// Routine Description:
// 
//     This fragment is placed at the start of every basic block.
// 
// Arguments:
// 
//     None
//
// Return Value:
// 
//     None
//
#ifdef CODEGEN_PROFILE
        Instruction->EntryPoint->ExecutionCount = 0;
        LDA(TREG_NP(T1), CFUNC_LOW(&(Instruction->EntryPoint->ExecutionCount)), REG(ZERO))
        LDAH(TREG_NP(T2), CFUNC_HIGH(&(Instruction->EntryPoint->ExecutionCount)), TREG_NP(T1))
        LDL(TREG_NP(T3), DISP(0), TREG_NP(T2))
        ADDL(TREG_NP(T3), CNST(1), TREG_NP(T1))
        STL(TREG_NP(T1), DISP(0), TREG_NP(T2))
#endif
        if (CpuSniffWritableCode) {
            PENTRYPOINT pEP;
            DWORD IntelLength;
            USHORT Checksum;

            PVOID FileHeader;

            pEP = Instruction->EntryPoint;
            if (Instruction->Operation == OP_BOP ||
                Instruction->Operation == OP_BOP_STOP_DECODE) {

                //
                // This is a BOP instruction.  Assume Wx86 does the
                // right thing and flushes the Cpu cache when it modifies
                // BOPs.
                //
                FileHeader = (PVOID)1;
            } else {

                //
                // See if intelStart is contained within an executable
                // image or not.
                //
                RtlPcToFileHeader(pEP->intelStart, &FileHeader);
            }

            if (!FileHeader) {
                //
                // Address is not within an executable image
                //
                Checksum = ChecksumMemory(pEP);

                //
                // Generate:
                //  v0 = SniffMemory(pEP, Checksum)
                //  if (v0) {
                //      cpu->Eip = pEP->intelStart;
                //      (SniffMemory set CpuNotify==
                //      jmp EndtranslatedCode
                //  }
                //
                //
#if DBG
                LOGPRINT((TRACELOG, "WX86CPU: Adding Sniff code for %x\n", pEP->intelStart));
#endif

                LDA(AREG_NP(A0), CFUNC_LOW(pEP), REG(ZERO))
                LDAH(AREG_NP(A0), CFUNC_HIGH(pEP), AREG_NP(A0))
                LDA(AREG_NP(A1), CFUNC_LOW(Checksum), REG(ZERO))
                SetArgContents(1, NO_REG);  // A1 is trashed

                LDA(TREG_NP(T0), CFUNC_LOW(SniffMemory), REG(ZERO))
                LDAH(TREG_NP(T1), CFUNC_HIGH(SniffMemory), TREG_NP(T0))
                JMP(REG(RA), TREG_NP(T1), JHINT(SniffMemory))

                CMPEQ(V0, CNST(0), V0)
                GEN_FIXUP(ECUEP, CurrentECU)
                BNE(V0, BDISP(CurrentECU - (ULONG)(ULONGLONG)(d + 1)))   
            }
        }

        //
        // Reset the pointer to the last fragment called.
        //
        LastFragCalled = NULL;
        END_FRAGMENT

        FRAGMENT(JumpToNextCompilationUnit)
//
// Routine Description:
// 
//     This fragment is placed at the end of a burst of translated code
//     ie. after the last instruction in the compiler's InstructionStream[]
//     array.  It compiles the code corresponding to the next Intel
//     instruction, then replaces this fragment by one which jumps directly
//     to that code the next time this fragment is executed.
//
//     This code is replaced by the JumpToNextCompilationUnit2 fragment
// 
// Arguments:
// 
//     RegEip -- Contains Eip prior to the current instruction
//
// Return Value:
// 
//     RegEip -- Contains the Eip value after the current instruction
//
        LDA(TREG_NP(T0), CFUNC_LOW(JumpToNextCompilationUnitHelper), REG(ZERO))
        LDA(REG(RegEip), CFUNC_LOW(Instruction), REG(ZERO))
        LDAH(TREG_NP(T1), CFUNC_HIGH(JumpToNextCompilationUnitHelper), TREG_NP(T0))
        LDAH(REG(RegEip), CFUNC_HIGH(Instruction), REG(RegEip))
        JMP(REG(RA), TREG_NP(T1), JHINT(JumpToNextCompilationUnitHelper))
        CPUASSERT(d - CodeLocation == JumpToNextCompilationUnit_SIZE);
        END_FRAGMENT
        
        PATCH_FRAGMENT(JumpToNextCompilationUnit2)
//
// Routine Description:
// 
//     Replacement fragment for JumpToNextCompilationUnit once the RISC address of
//     the next basic block is known.
// 
// Arguments:
// 
//     RegEip -- Contains Eip prior to the current instruction
//
// Return Value:
// 
//     none   -- Jumps directly to nativedest
//
        LDA(TREG_NP(T0), CFUNC_LOW(Param1), REG(ZERO))        
        LDAH(TREG_NP(T1), CFUNC_HIGH(Param1), TREG_NP(T0))
        JMP(REG(AT), TREG_NP(T1), JHINT(Param1))
        if (!fCompiling) {
            // patching, so overwrite old code with nops
            NOP
            NOP
            CPUASSERT(d - CodeLocation == JumpToNextCompilationUnit_SIZE);
        }
        
        END_FRAGMENT


//
// Routine Description:
//
//     These routines call C-language fragments.
//
// Arguments:
//
//     a1..a3 - arguments to the C-language fragment
//     RegPointer - pointer to per-thread CPU data
//
// Return Value:
//
//     none
//
// Notes:
//

        FRAGMENT(CallCFrag)
        if (FragmentArray[Instruction->Operation] != LastFragCalled) {
            LastFragCalled = FragmentArray[Instruction->Operation];
            LDA(RegEip, CFUNC_LOW(LastFragCalled), REG(ZERO))
            LDAH(RegEip, CFUNC_HIGH(LastFragCalled), RegEip)
        }
        MOV(REG(RegPointer), AREG_NP(A0))
        JSR(REG(RA), RegEip, JHINT(FragmentArray[Instruction->Operation]))
        END_FRAGMENT
        
        FRAGMENT(CallCFragNoCpu)
        if (FragmentArray[Instruction->Operation] != LastFragCalled) {
            LastFragCalled = FragmentArray[Instruction->Operation];
            LDA(RegEip, CFUNC_LOW(LastFragCalled), REG(ZERO))
            LDAH(RegEip, CFUNC_HIGH(LastFragCalled), RegEip)
        }
        JSR(REG(RA), RegEip, JHINT(FragmentArray[Instruction->Operation]))
        END_FRAGMENT

        FRAGMENT(CallCFragLoadEip)
        if (FragmentArray[Instruction->Operation] != LastFragCalled) {
            LastFragCalled = FragmentArray[Instruction->Operation];
            LDA(RegEip, CFUNC_LOW(LastFragCalled), REG(ZERO))
            LDAH(RegEip, CFUNC_HIGH(LastFragCalled), RegEip)
        }
        LDA(TREG_NP(T0), CFUNC_LOW(Instruction->IntelAddress), REG(ZERO))
        LDAH(TREG_NP(T0), CFUNC_HIGH(Instruction->IntelAddress), TREG_NP(T0))
        STL(TREG_NP(T0), DISP(Eip), REG(RegPointer))
        MOV(REG(RegPointer), AREG_NP(A0))
        JSR(REG(RA), RegEip, JHINT(FragmentArray[Instruction->Operation]))
        END_FRAGMENT
        
        FRAGMENT(CallCFragLoadEipNoCpu)
        if (FragmentArray[Instruction->Operation] != LastFragCalled) {
            LastFragCalled = FragmentArray[Instruction->Operation];
            LDA(RegEip, CFUNC_LOW(LastFragCalled), REG(ZERO))
            LDAH(RegEip, CFUNC_HIGH(LastFragCalled), RegEip)
        }
        LDA(TREG_NP(T0), CFUNC_LOW(Instruction->IntelAddress), REG(ZERO))
        LDAH(TREG_NP(T0), CFUNC_HIGH(Instruction->IntelAddress), TREG_NP(T0))
        STL(TREG_NP(T0), DISP(Eip), REG(RegPointer))
        JSR(REG(RA), RegEip, JHINT(FragmentArray[Instruction->Operation]))
        END_FRAGMENT

        FRAGMENT(CallCFragLoadEipNoCpuSlow)
        LDA(TREG_NP(T1), CFUNC_LOW(FragmentArray[Instruction->Operation]), REG(ZERO))
        LDAH(TREG_NP(T1), CFUNC_HIGH(FragmentArray[Instruction->Operation]), TREG_NP(T1))
        LDA(TREG_NP(T0), CFUNC_LOW(Instruction->IntelAddress), REG(ZERO))
        LDAH(TREG_NP(T0), CFUNC_HIGH(Instruction->IntelAddress), TREG_NP(T0))
        STL(TREG_NP(T0), DISP(Eip), REG(RegPointer))
        JSR(REG(RA), TREG_NP(T1), JHINT(FragmentArray[Instruction->Operation]))

        // Update Eip and check CpuNotify
        LDL(TREG_NP(T0), DISP(CpuNotify), REG(RegPointer))
        ADDL(REG(RegEip), CNST(Instruction->Size), REG(RegEip))
        STL(REG(RegEip), DISP(Eip), REG(RegPointer))
GEN_FIXUP(ECUEP, CurrentECU)
        BNE(TREG_NP(T0), BDISP(CurrentECU - (ULONG)(ULONGLONG)(d + 1)))   
        END_FRAGMENT

        FRAGMENT(CallCFragLoadEipSlow)
        LDA(TREG_NP(T1), CFUNC_LOW(FragmentArray[Instruction->Operation]), REG(ZERO))
        LDAH(TREG_NP(T1), CFUNC_HIGH(FragmentArray[Instruction->Operation]), TREG_NP(T1))
        LDA(TREG_NP(T0), CFUNC_LOW(Instruction->IntelAddress), REG(ZERO))
        LDAH(TREG_NP(T0), CFUNC_HIGH(Instruction->IntelAddress), TREG_NP(T0))
        STL(TREG_NP(T0), DISP(Eip), REG(RegPointer))
        MOV(REG(RegPointer), AREG_NP(A0))
        JSR(REG(RA), TREG_NP(T1), JHINT(FragmentArray[Instruction->Operation]))

        // Update Eip and check CpuNotify
        LDL(TREG_NP(T0), DISP(CpuNotify), REG(RegPointer))
        ADDL(REG(RegEip), CNST(Instruction->Size), REG(RegEip))
        STL(REG(RegEip), DISP(Eip), REG(RegPointer))
GEN_FIXUP(ECUEP, CurrentECU)
        BNE(TREG_NP(T0), BDISP(CurrentECU - (ULONG)(ULONGLONG)(d + 1)))   
        END_FRAGMENT

        FRAGMENT(CallCFragSlow)
        LDA(TREG_NP(T1), CFUNC_LOW(FragmentArray[Instruction->Operation]), REG(ZERO))
        LDAH(TREG_NP(T1), CFUNC_HIGH(FragmentArray[Instruction->Operation]), TREG_NP(T1))
        STL(TREG_NP(T0), DISP(Eip), REG(RegPointer))
        MOV(REG(RegPointer), AREG_NP(A0))
        JSR(REG(RA), TREG_NP(T1), JHINT(FragmentArray[Instruction->Operation]))

        // Update Eip and check CpuNotify
        LDL(TREG_NP(T0), DISP(CpuNotify), REG(RegPointer))
        ADDL(REG(RegEip), CNST(Instruction->Size), REG(RegEip))
        STL(REG(RegEip), DISP(Eip), REG(RegPointer))
GEN_FIXUP(ECUEP, CurrentECU)
        BNE(TREG_NP(T0), BDISP(CurrentECU - (ULONG)(ULONGLONG)(d + 1)))   
        END_FRAGMENT
        
        FRAGMENT(CallCFragNoCpuSlow)
        LDA(TREG_NP(T1), CFUNC_LOW(FragmentArray[Instruction->Operation]), REG(ZERO))
        LDAH(TREG_NP(T1), CFUNC_HIGH(FragmentArray[Instruction->Operation]), TREG_NP(T1))
        STL(TREG_NP(T0), DISP(Eip), REG(RegPointer))
        JSR(REG(RA), TREG_NP(T1), JHINT(FragmentArray[Instruction->Operation]))

        // Update Eip and check CpuNotify
        LDL(TREG_NP(T0), DISP(CpuNotify), REG(RegPointer))
        ADDL(REG(RegEip), CNST(Instruction->Size), REG(RegEip))
        STL(REG(RegEip), DISP(Eip), REG(RegPointer))
GEN_FIXUP(ECUEP, CurrentECU)
        BNE(TREG_NP(T0), BDISP(CurrentECU - (ULONG)(ULONGLONG)(d + 1)))   
        END_FRAGMENT
        


//
// Routine Description:
// 
//     JxxFrag - one for each Intel conditional branch instruction.
//     These fragments are placed before a JxxBody/JxxBody2 fragment.
// 
// Arguments:
// 
//     RegPointer - pointer to per-thread CPU data
//
// Return Value:
// 
//     V0 - 0 if branch not taken
//          nonzero if branch taken
//
// Notes: 
//
        FRAGMENT(JaFrag)        // brif CF==0 and ZF==0
        LDL     (V0, FIELD_OFFSET(CPUCONTEXT, flag_cf), RegPointer)
        SRL     (V0, CNST(0x1f), V0)    // V0 = CF bit (0 or 1)
        LDL     (RegTemp, FIELD_OFFSET(CPUCONTEXT, flag_zf), RegPointer)
        CMPEQ   (RegTemp, CNST(0), RegTemp)  // RegTemp = ZF
        BIS     (V0, RegTemp, V0)       // V0 = CF|ZF
        CMPEQ   (V0, CNST(0), V0)       // V0 = !(CF|ZF)=!CF & !ZF = CF==0 & ZF== 0
        END_FRAGMENT

        FRAGMENT(JaeFrag)       // brif CF==0
        LDL     (V0, FIELD_OFFSET(CPUCONTEXT, flag_cf), RegPointer)
        SRL     (V0, CNST(0x1f), V0)    // V0 = CF bit (0 or 1)
        CMPEQ   (V0, CNST(0), V0)       // V0 = !CF
        END_FRAGMENT

        FRAGMENT(JbeFrag)       // brif CF==1 or ZF==1
        LDL     (V0, FIELD_OFFSET(CPUCONTEXT, flag_cf), RegPointer)
        SRL     (V0, CNST(0x1f), V0)    // V0 = CF bit (0 or 1)
        LDL     (RegTemp, FIELD_OFFSET(CPUCONTEXT, flag_zf), RegPointer)
        CMPEQ   (RegTemp, CNST(0), RegTemp) // RegTemp = ZF
        BIS     (V0, RegTemp, V0)       // V0 = ZF | CF
        END_FRAGMENT

        FRAGMENT(JbFrag)        // brif CF==1
        LDL     (V0, FIELD_OFFSET(CPUCONTEXT, flag_cf), RegPointer)
        SRL     (V0, CNST(0x1f), V0)    // V0 = CF bit (0 or 1)
        END_FRAGMENT

        FRAGMENT(JeFrag)        // brif ZF==1
        LDL     (V0, FIELD_OFFSET(CPUCONTEXT, flag_zf), RegPointer)
        CMPEQ   (V0, CNST(0), V0) // V0 = ZF
        END_FRAGMENT

        FRAGMENT(JgFrag)        // brif ZF==0 and SF=OF
LABEL_DEC(l1)
        LDL     (V0, FIELD_OFFSET(CPUCONTEXT, flag_zf), RegPointer)
        BEQ_LABEL(REG(V0), FWD(l1))     // ZF is set - branch not taken
        LDL     (V0, FIELD_OFFSET(CPUCONTEXT, flag_sf), RegPointer)
        LDL     (RegTemp, FIELD_OFFSET(CPUCONTEXT, flag_of), RegPointer)
        EQV     (V0, RegTemp, V0)       // V0 = flag_sf ^ !flag_of
        SRL     (V0, CNST(0x1f), V0)    // V0 = SF==OF
LABEL(l1)
GEN_CT(l1)
        END_FRAGMENT

        FRAGMENT(JlFrag)        // brif SF!=OF
        LDL     (V0, FIELD_OFFSET(CPUCONTEXT, flag_sf), RegPointer)
        LDL     (RegTemp, FIELD_OFFSET(CPUCONTEXT, flag_of), RegPointer)
        XOR     (V0, RegTemp, V0)       // V0 = flag_sf ^ flag_of
        SRL     (V0, CNST(0x1f), V0)    // V0 = SF!=OF
        END_FRAGMENT

        FRAGMENT(JleFrag)        // brif ZF=1 or SF!=OF
LABEL_DEC(l1)
        LDL     (V0, FIELD_OFFSET(CPUCONTEXT, flag_zf), RegPointer)
        CMPEQ   (V0, CNST(0), V0)   // V0 = ZF
        BNE_LABEL (V0, FWD(l1))     // brif ZF==1 - done!
        LDL     (V0, FIELD_OFFSET(CPUCONTEXT, flag_sf), RegPointer)
        LDL     (RegTemp, FIELD_OFFSET(CPUCONTEXT, flag_of), RegPointer)
        XOR     (V0, RegTemp, V0)       // V0 = flag_sf ^ flag_of
        SRL     (V0, CNST(0x1f), V0)    // V0 = SF!=OF
LABEL(l1)
GEN_CT(l1)
        END_FRAGMENT

        FRAGMENT(JneFrag)        // brif ZF=0
        LDL     (V0, FIELD_OFFSET(CPUCONTEXT, flag_zf), RegPointer)
        END_FRAGMENT

        FRAGMENT(JnlFrag)        // brif SF=OF
        LDL     (V0, FIELD_OFFSET(CPUCONTEXT, flag_sf), RegPointer)
        LDL     (RegTemp, FIELD_OFFSET(CPUCONTEXT, flag_of), RegPointer)
        EQV     (V0, RegTemp, V0)       // V0 = flag_sf ^ !flag_of
        SRL     (V0, CNST(0x1f), V0)    // V0 = SF==OF
        END_FRAGMENT

        FRAGMENT(JnoFrag)        // brif OF==0
        LDL     (V0, FIELD_OFFSET(CPUCONTEXT, flag_of), RegPointer)
        SRL     (V0, CNST(0x1f), V0)    // V0 = OF
        CMPEQ   (V0, CNST(0), V0)       // V0 = !OF
        END_FRAGMENT

        FRAGMENT(JnpFrag)        // brif PF==0
        LDAH    (RegTemp, CFUNC_HIGH(ParityBit), REG(ZERO))
        LDA     (RegTemp, CFUNC_LOW(ParityBit), RegTemp)
        LDL     (V0, FIELD_OFFSET(CPUCONTEXT, flag_pf), RegPointer)
        ADDL    (V0, RegTemp, RegTemp)
        LDQ_U   (V0, 0, RegTemp)
        EXTBL   (V0, RegTemp, V0)       // V0 = ParityBit[cpu->flag_pf]
        CMPEQ   (V0, CNST(0), V0)       // V0 = ParityBit[cpu->flag_pf]==0
        END_FRAGMENT

        FRAGMENT(JnsFrag)        // brif SF==0
        LDL     (V0, FIELD_OFFSET(CPUCONTEXT, flag_sf), RegPointer)
        SRL     (V0, CNST(0x1f), V0)    // V0 = SF
        CMPEQ   (V0, CNST(0), V0)       // V0 = !SF
        END_FRAGMENT

        FRAGMENT(JoFrag)         // brif OF==1
        LDL     (V0, FIELD_OFFSET(CPUCONTEXT, flag_of), RegPointer)
        SRL     (V0, CNST(0x1f), V0)    // V0 = OF
        END_FRAGMENT

        FRAGMENT(JpFrag)         // brif PF==1
        LDAH    (RegTemp, CFUNC_HIGH(ParityBit), REG(ZERO))
        LDA     (RegTemp, CFUNC_LOW(ParityBit), RegTemp)
        LDL     (V0, FIELD_OFFSET(CPUCONTEXT, flag_pf), RegPointer)
        ADDL    (V0, RegTemp, RegTemp)
        LDQ_U   (V0, 0, RegTemp)
        EXTBL   (V0, RegTemp, V0)       // V0 = ParityBit[cpu->flag_pf]
        END_FRAGMENT

        FRAGMENT(JsFrag)        // brif SF==1
        LDL     (V0, FIELD_OFFSET(CPUCONTEXT, flag_sf), RegPointer)
        SRL     (V0, CNST(0x1f), V0)    // V0 = SF
        END_FRAGMENT

        FRAGMENT(JecxzFrag)     // brif ECX==0
        LDL     (V0, RegisterOffset[GP_ECX], RegPointer)
        CMPEQ   (V0, CNST(0), V0)
        END_FRAGMENT

        FRAGMENT(JcxzFrag)      // brif CX==0
        LDL     (V0, RegisterOffset[GP_ECX], RegPointer)
        EXTWL   (V0, CNST(0), V0)       // zero-extend CX to a DWORD
        CMPEQ   (V0, CNST(0), V0)
        END_FRAGMENT

        FRAGMENT(LoopFrag32)    // ECX--, brif ECX!=0
        LDL     (V0, RegisterOffset[GP_ECX], RegPointer)
        SUBL    (V0, CNST(1), V0)
        STL     (V0, RegisterOffset[GP_ECX], RegPointer)
        END_FRAGMENT

        FRAGMENT(LoopFrag16)    // CX--, brif CX!=0
        LDL     (RegTemp, RegisterOffset[GP_ECX], RegPointer)
        EXTWL   (RegTemp, CNST(0), V0)      // zero-extend CX to a DWORD
        SUBL    (V0, CNST(1), V0)           // cx--
        ZAP     (RegTemp, CNST(3), RegTemp) // zero out bottom two bytes from ECX
        ZAPNOT  (V0, CNST(3), V0)           // zap out all but bottom two bytes from CX
        BIS     (V0, RegTemp, RegTemp)      // RegTemp = new ECX
        STL     (RegTemp, RegisterOffset[GP_ECX], RegPointer)
        // V0 is the value of CX
        END_FRAGMENT

        FRAGMENT(LoopneFrag32)      // ECX--, brif ZF==0 && ECX!=0
LABEL_DEC(l1)
        LDL     (V0, RegisterOffset[GP_ECX], RegPointer)
        SUBL    (V0, CNST(1), V0)
        STL     (V0, RegisterOffset[GP_ECX], RegPointer)
        BEQ_LABEL (V0, FWD(l1))        // ecx==0 - branch not taken
        LDL     (V0, FIELD_OFFSET(CPUCONTEXT, flag_zf), RegPointer)
LABEL(l1)
GEN_CT(l1)
        END_FRAGMENT

        FRAGMENT(LoopneFrag16)      // CX--, brif ZF==0 && CX!=0
LABEL_DEC(l1)
        LDL     (RegTemp, RegisterOffset[GP_ECX], RegPointer)
        EXTWL   (RegTemp, CNST(0), V0)      // zero-extend CX to a DWORD
        SUBL    (V0, CNST(1), V0)           // cx--
        ZAP     (RegTemp, CNST(3), RegTemp) // zero out bottom two bytes from ECX
        ZAPNOT  (V0, CNST(3), V0)           // zap out all but bottom two bytes from CX
        BIS     (V0, RegTemp, RegTemp)      // RegTemp = new ECX
        STL     (RegTemp, RegisterOffset[GP_ECX], RegPointer)
        // V0 is the value of CX
        BEQ_LABEL (V0, FWD(l1))        // ecx==0 - branch not taken
        LDL     (V0, FIELD_OFFSET(CPUCONTEXT, flag_zf), RegPointer)
LABEL(l1)
GEN_CT(l1)
        END_FRAGMENT

        FRAGMENT(LoopeFrag32)       // ECX--, brif ZF==1 && ECX!=0
LABEL_DEC(l1)
        LDL     (V0, RegisterOffset[GP_ECX], RegPointer)
        SUBL    (V0, CNST(1), V0)
        STL     (V0, RegisterOffset[GP_ECX], RegPointer)
        BEQ_LABEL (V0, FWD(l1))        // ecx==0 - branch not taken
        LDL     (V0, FIELD_OFFSET(CPUCONTEXT, flag_zf), RegPointer)
        CMPEQ   (V0, CNST(0), V0)       // V0 = ZF
LABEL(l1)
GEN_CT(l1)
        END_FRAGMENT

        FRAGMENT(LoopeFrag16)       // CX--, brif ZF==1 && ECX!=0
LABEL_DEC(l1)
        LDL     (RegTemp, RegisterOffset[GP_ECX], RegPointer)
        EXTWL   (RegTemp, CNST(0), V0)      // zero-extend CX to a DWORD
        SUBL    (V0, CNST(1), V0)           // cx--
        ZAP     (RegTemp, CNST(3), RegTemp) // zero out bottom two bytes from ECX
        ZAPNOT  (V0, CNST(3), V0)           // zap out all but bottom two bytes from CX
        BIS     (V0, RegTemp, RegTemp)      // RegTemp = new ECX
        STL     (RegTemp, RegisterOffset[GP_ECX], RegPointer)
        // V0 is the value of CX
        BEQ_LABEL (V0, FWD(l1))        // ecx==0 - branch not taken
        LDL     (V0, FIELD_OFFSET(CPUCONTEXT, flag_zf), RegPointer)
        CMPEQ   (V0, CNST(0), V0)       // V0 = ZF
LABEL(l1)
GEN_CT(l1)
        END_FRAGMENT

        
        FRAGMENT(JxxBody)
// 
// Routine Description:
// 
//     This implements the body of the Jxx instructions.  The code which
//     determines whether to branch or not has already been placed and
//     has left the results in V0.  The RISC address of the branch-taken
//     address is known.
// 
// Arguments:
// 
//     RegPointer -- per-thread CPU data
//     V0         -- 0 if branch not taken, nonzero if branch taken
//
// Return Value:
// 
//     None.
//
LABEL_DEC(l1)
        BEQ_LABEL(REG(V0), FWD(l1))
        
        //
        // Update Eip and call the helper fragment
        //
        LDA(TREG_NP(T0), CFUNC_LOW(Instruction->Operand1.Immed), REG(ZERO))
        LDAH(AREG_NP(A0), CFUNC_HIGH(Instruction->Operand1.Immed), TREG_NP(T0))
        LDA(TREG_NP(T0), CFUNC_LOW(CallJxxHelper), REG(ZERO))
        LDAH(TREG_NP(T1), CFUNC_HIGH(CallJxxHelper), TREG_NP(T0))
        JMP(REG(RA), TREG_NP(T1), JHINT(CallJxxHelper))
        
        //
        // Padding so it this is the same size as JxxBody2
        //
        NOP     // 7
        NOP     // 8
        NOP     // 9
LABEL(l1)
GEN_CT(l1)
        END_FRAGMENT
        
        PATCH_FRAGMENT(JxxBody2)
// 
// Routine Description:
// 
//     This implements the body of the Jxx instructions.  The code which
//     determines whether to branch or not has already been placed and
//     has left the results in V0.  The native address of the branch-taken
//     address is known.
// 
// Arguments:
// 
//     RegPointer -- cpu
//     V0         -- 0 if branch not taken, nonzero if branch taken
//
//     Param1 -- IntelDest
//     Param2 -- at compile-time, ptr to EntryPoint for NativeDest
//               at patch-time, NativeDest
//
// Return Value:
// 
//     None
//
        DWORD NativeDest = Param2;
        DWORD IntelDest = Param1;
LABEL_DEC(l3)

        // if the branch is to fall through, then we're done
        BEQ_LABEL(REG(V0), FWD(l3))
    
        // else branch taken - jump directly to nativedest.
        // Must check ProcessCpuNotify to prevent deadlocks.  No need to check
        // cpu->CpuNotify as this fragment is fast-mode only.
        // NOTE: RegEip and cpu->Eip only need to be updated if we jump to ECU.
        //       it's easier to update both now on Alpha
        LDA(TREG_NP(T0), CFUNC_LOW(IntelDest), REG(ZERO))
        LDAH(REG(RegEip), CFUNC_HIGH(IntelDest), TREG_NP(T0))
        STL(REG(RegEip), DISP(Eip), REG(RegPointer))

        LDL(TREG_NP(T0), DISP(0), REG(RegProcessCpuNotify))
GEN_FIXUP(LoadEPLow, NativeDest)
        LDA(TREG_NP(T1), CFUNC_LOW(NativeDest), REG(ZERO))
GEN_FIXUP(ECUEP, CurrentECU)
        BNE(TREG_NP(T0), BDISP(CurrentECU - (ULONG)(ULONGLONG)(d + 1)))   
GEN_FIXUP(LoadEPHigh, NativeDest)
        LDAH(TREG_NP(T1), CFUNC_HIGH(NativeDest), TREG_NP(T1))

GEN_FIXUP(BranchEP, NativeDest)
        JMP(REG(AT), TREG_NP(T1), JHINT(NativeDest))
        
LABEL(l3)
GEN_CT(l3)
        END_FRAGMENT


        FRAGMENT(JxxStartSlow)
//
// Routine Description:
//
//     This fragment is placed before the Jxx fragment.  It updates Eip to
//     be the branch-not-taken value, assuming the branch isn't taken.  In
//     the event that the branch is taken, Eip will be overwritten with the
//     branch-taken address.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     RegEip updated, but not written to cpu->eip.
//
        ADDL        (RegEip, CNST(Instruction->Size), RegEip)
        END_FRAGMENT


        FRAGMENT(JxxBodySlow)
// 
// Routine Description:
// 
//     This implements the body of the Jxx instructions.  The code which
//     determines whether to branch or not has already been placed and
//     has left the results in V0.  The RISC address of the branch-taken
//     address is known.
// 
// Arguments:
// 
//     RegPointer -- per-thread CPU data
//     V0         -- 0 if branch not taken, nonzero if branch taken
//
// Return Value:
// 
//     None.
//
LABEL_DEC(l1)
        BEQ_LABEL(REG(V0), FWD(l1))
        
        //
        // Update Eip and call the helper fragment
        //
        LDA(TREG_NP(T0), CFUNC_LOW(Instruction->Operand1.Immed), REG(ZERO))
        LDAH(AREG_NP(A0), CFUNC_HIGH(Instruction->Operand1.Immed), TREG_NP(T0))
        LDA(TREG_NP(T0), CFUNC_LOW(CallJxxSlowHelper), REG(ZERO))
        LDAH(TREG_NP(T1), CFUNC_HIGH(CallJxxSlowHelper), TREG_NP(T0))
        JMP(REG(RA), TREG_NP(T1), JHINT(CallJxxSlowHelper))
        
        //
        // Padding so it this is the same size as JxxBodySlow2
        //
        NOP     // 7
        NOP     // 8
        NOP     // 9
        NOP     // 10
        NOP     // 11
        NOP     // 12
        NOP     // 13
        NOP     // 14
        NOP     // 15
        NOP     // 16
LABEL(l1)
GEN_CT(l1)
        STL(REG(RegEip), DISP(Eip), REG(RegPointer))
        END_FRAGMENT
        
        PATCH_FRAGMENT(JxxBodySlow2)
// 
// Routine Description:
// 
//     This implements the body of the Jxx instructions.  The code which
//     determines whether to branch or not has already been placed and
//     has left the results in V0.  The native address of the branch-taken
//     address is known.
// 
// Arguments:
// 
//     RegPointer -- cpu
//     V0         -- 0 if branch not taken, nonzero if branch taken
//
//     Param1 -- IntelDest
//     Param2 -- at compile-time, ptr to Entrypoint for NativeDest
//               at patch-time, NativeDest
//
// Return Value:
// 
//     None
//
        DWORD NativeDest = Param2;
        DWORD IntelDest = Param1;
LABEL_DEC(l3)

        // if the branch is to fall through, then we're done
        BEQ_LABEL(REG(V0), FWD(l3))
    
        // else branch taken - update cached Eip and jump directly to mipsdest
        // This fragment is slow-mode only, so it must check both CpuNotify
        // flags.
        LDA(TREG_NP(T0), CFUNC_LOW(IntelDest), REG(ZERO))
        LDAH(REG(RegEip), CFUNC_HIGH(IntelDest), TREG_NP(T0))
        STL(REG(RegEip), DISP(Eip), REG(RegPointer))

        LDL(TREG_NP(T0), DISP(0), REG(RegProcessCpuNotify))
GEN_FIXUP(LoadEPLow, NativeDest)
        LDA(TREG_NP(T1), CFUNC_LOW(NativeDest), REG(ZERO))
GEN_FIXUP(ECUEP, CurrentECU)
        BNE(TREG_NP(T0), BDISP(CurrentECU - (ULONG)(ULONGLONG)(d + 1)))   
        
        LDL(TREG_NP(T0), DISP(CpuNotify), REG(RegPointer))
GEN_FIXUP(LoadEPHigh, NativeDest)
        LDAH(TREG_NP(T1), CFUNC_HIGH(NativeDest), TREG_NP(T1))
GEN_FIXUP(ECUEP, CurrentECU)
        BNE(TREG_NP(T0), BDISP(CurrentECU - (ULONG)(ULONGLONG)(d + 1)))   
        
GEN_FIXUP(BranchEP, NativeDest)
        JMP(REG(AT), TREG_NP(T1), JHINT(NativeDest))
        
LABEL(l3)
GEN_CT(l3)
        STL(REG(RegEip), DISP(Eip), REG(RegPointer))

        // Check CpuNotify in the branch-not-taken case, too.
        LDL(TREG_NP(T0), DISP(0), REG(RegProcessCpuNotify))
GEN_FIXUP(ECUEP, CurrentECU)
        BNE(TREG_NP(T0), BDISP(CurrentECU - (ULONG)(ULONGLONG)(d + 1)))   
        
        LDL(TREG_NP(T0), DISP(CpuNotify), REG(RegPointer))
GEN_FIXUP(ECUEP, CurrentECU)
        BNE(TREG_NP(T0), BDISP(CurrentECU - (ULONG)(ULONGLONG)(d + 1))) 
        END_FRAGMENT

        FRAGMENT(JxxBodyFwd)
// 
// Routine Description:
// 
//     This implements the body of the Jxx instructions.  The code which
//     determines whether to branch or not has already been placed and
//     has left the results in V0.  The RISC address of the branch-taken
//     address is known.
// 
// Arguments:
// 
//     RegPointer -- per-thread CPU data
//     V0         -- 0 if branch not taken, nonzero if branch taken
//
// Return Value:
// 
//     None.
//
LABEL_DEC(l1)
        BEQ_LABEL(REG(V0), FWD(l1))
        
        //
        // Update Eip and call the helper fragment
        //
        LDA(TREG_NP(T0), CFUNC_LOW(Instruction->Operand1.Immed), REG(ZERO))
        LDAH(AREG_NP(A0), CFUNC_HIGH(Instruction->Operand1.Immed), TREG_NP(T0))

        LDA(TREG_NP(T0), CFUNC_LOW(CallJxxFwdHelper), REG(ZERO))
        LDAH(TREG_NP(T1), CFUNC_HIGH(CallJxxFwdHelper), TREG_NP(T0))
        JMP(REG(RA), TREG_NP(T1), JHINT(CallJxxFwdHelper))
LABEL(l1)
GEN_CT(l1)
        END_FRAGMENT
        
        PATCH_FRAGMENT(JxxBodyFwd2)
// 
// Routine Description:
// 
//     This implements the body of the Jxx instructions.  The code which
//     determines whether to branch or not has already been placed and
//     has left the results in V0.  The native address of the branch-taken
//     address is known.
// 
// Arguments:
// 
//     RegPointer -- cpu
//     V0         -- 0 if branch not taken, nonzero if branch taken
//
//     Param1 -- IntelDest
//     Param2 -- NativeDest
//
// Return Value:
// 
//     None
//
LABEL_DEC(l3)

        // if the branch is to fall through, then we're done
        BEQ_LABEL(REG(V0), FWD(l3))
    
        // else branch taken - jump directly to nativedest
GEN_FIXUP(LoadEPLow, Param1)
        LDA(TREG_NP(T0), CFUNC_LOW(Param1), REG(ZERO))
GEN_FIXUP(LoadEPHigh, Param1)
        LDAH(TREG_NP(T1), CFUNC_HIGH(Param1), TREG_NP(T0))
GEN_FIXUP(BranchEP, Param1)
        JMP(REG(AT), TREG_NP(T1), JHINT(Param1))

        if (!fCompiling) {
            // patching, so overwrite old code with nops
            NOP
            NOP     // pad to be same size as JxxBodyFwd
        }
        
LABEL(l3)
GEN_CT(l3)
        END_FRAGMENT

        FRAGMENT(CallJmpDirect)
//
// Routine Description:
// 
//     Initial fragment placed into the translation cache for
//     unconditional direct jmp instructions such as "jmp foo".
//
//     Once the destination address is known, this code is replaced
//     by CallJmpDirect2.
// 
// Arguments:
// 
//     RegPointer - ptr to per-thread CPU data
//
// Return Value:
// 
//     RegEip -- Contains the Eip value after the current instruction
//

        // Load A1 with IntelDest
        LDA(AREG_NP(A1), CFUNC_LOW(Instruction->Operand1.Immed), REG(ZERO))
        LDAH(AREG_NP(A1), CFUNC_HIGH(Instruction->Operand1.Immed), AREG_NP(A1))

        // Call VOID CallJmpDirectHelper(cpu, inteldest) to patch this code
        // control transfers directly to the destination of the jmp.
        LDA(TREG_NP(T0), CFUNC_LOW(CallJmpDirectHelper), REG(ZERO))
        LDAH(TREG_NP(T1), CFUNC_HIGH(CallJmpDirectHelper), TREG_NP(T0))
        JMP(REG(RA), TREG_NP(T1), JHINT(CallJmpDirectHelper))
        
        //
        // pad to same size as calljmpdirect2
        //
        NOP     // 6
        NOP     // 7
        NOP     // 8
    
        END_FRAGMENT
        
        PATCH_FRAGMENT(CallJmpDirect2)
//
// Routine Description:
// 
//     Replacement fragment for CallJmpDirect once the RISC address of
//     the jmp is known.
// 
// Arguments:
// 
//     none
//
// Return Value:
// 
//     none   -- jumps either to EndTranslatedCode if CpuNotify is set, or
//               jumps directly to nativedest
//
        // NOTE: RegEip and cpu->eip only need to be updated if we are
        //       jumping to EndTranslatedCode.  It's easier on ALPHA to
        //       update both up-front.
        LDA(RegEip, CFUNC_LOW(Param2), REG(ZERO))
        LDAH(RegEip, CFUNC_HIGH(Param2), RegEip)
        STL(RegEip, Eip, RegPointer)

        // Must check ProcessCpuNotify to prevent deadlocks.  No need to check
        // cpu->CpuNotify as this fragment is fast-mode only.
        LDL(TREG_NP(T0), DISP(0), REG(RegProcessCpuNotify))
GEN_FIXUP(LoadEPLow, Param1)
        LDA(TREG_NP(T1), CFUNC_LOW(Param1), REG(ZERO))
GEN_FIXUP(ECUEP, CurrentECU)
        BNE(TREG_NP(T0), BDISP(CurrentECU - (ULONG)(ULONGLONG)(d + 1)))  
GEN_FIXUP(LoadEPHigh, Param1)
        LDAH(TREG_NP(T1), CFUNC_HIGH(Param1), TREG_NP(T1))
        
        //
        // perform actual jump
        //
GEN_FIXUP(BranchEP, Param1)
        JMP(REG(AT), TREG_NP(T1), JHINT(Param1))
        
        END_FRAGMENT
        
        FRAGMENT(CallJmpDirectSlow)
//
// Routine Description:
// 
//     Initial fragment placed into the translation cache for
//     unconditional direct jmp instructions such as "jmp foo".
//
//     Once the destination address is known, this code is replaced
//     by CallJmpDirect2.
// 
// Arguments:
// 
//     RegPointer - ptr to per-thread CPU data
//
// Return Value:
// 
//     RegEip -- Contains the Eip value after the current instruction
//

        // Load A1 with IntelDest
        LDA(AREG_NP(A1), CFUNC_LOW(Instruction->Operand1.Immed), REG(ZERO))
        LDAH(AREG_NP(A1), CFUNC_HIGH(Instruction->Operand1.Immed), AREG_NP(A1))

        // Call VOID CallJmpDirectSlowHelper(cpu, inteldest) to patch this code
        // control transfers directly to the destination of the jmp.
        LDA(TREG_NP(T0), CFUNC_LOW(CallJmpDirectSlowHelper), REG(ZERO))
        LDAH(TREG_NP(T1), CFUNC_HIGH(CallJmpDirectSlowHelper), TREG_NP(T0))
        JMP(REG(RA), TREG_NP(T1), JHINT(CallJmpDirectSlowHelper))
        
        //
        // pad to same size as CallJmpDirectSlow2
        //
        NOP     // 6
        NOP     // 7
        NOP     // 8
        NOP     // 9
        NOP     // 10
    
        END_FRAGMENT
        
        PATCH_FRAGMENT(CallJmpDirectSlow2)
//
// Routine Description:
// 
//     Replacement fragment for CallJmpDirectSlow once the RISC address of
//     the jmp is known.
// 
// Arguments:
// 
//     none
//
// Return Value:
// 
//     none   -- jumps either to EndTranslatedCode if CpuNotify is set, or
//               jumps directly to nativedest
//
        LDA(RegEip, CFUNC_LOW(Param2), REG(ZERO))
        LDAH(RegEip, CFUNC_HIGH(Param2), RegEip)
        STL(RegEip, Eip, RegPointer)

        // If either CpuNotify is set, jump to EndTranslatedCode
        LDL(TREG_NP(T0), DISP(0), REG(RegProcessCpuNotify))
GEN_FIXUP(LoadEPLow, Param1)
        LDA(TREG_NP(T1), CFUNC_LOW(Param1), REG(ZERO))
GEN_FIXUP(ECUEP, CurrentECU)
        BNE(TREG_NP(T0), BDISP(CurrentECU - (ULONG)(ULONGLONG)(d + 1)))  
        
        LDL(TREG_NP(T0), DISP(CpuNotify), REG(RegPointer))
GEN_FIXUP(LoadEPHigh, Param1)
        LDAH(TREG_NP(T1), CFUNC_HIGH(Param1), TREG_NP(T1))
GEN_FIXUP(ECUEP, CurrentECU)
        BNE(TREG_NP(T0), BDISP(CurrentECU - (ULONG)(ULONGLONG)(d + 1)))  
        
        //
        // perform actual jump
        //
GEN_FIXUP(BranchEP, Param1)
        JMP(REG(AT), TREG_NP(T1), JHINT(Param1))
        
        END_FRAGMENT
        
        FRAGMENT(CallJmpFwdDirect)
//
// Routine Description:
// 
//     Initial fragment placed into the translation cache for
//     unconditional direct jmp instructions such as "jmp foo".
//
//     Once the destination address is known, this code is replaced
//     by CallJmpFwdDirect2.
// 
// Arguments:
// 
//     RegEip -- Contains Eip prior to the current instruction
//     a0     -- cpu
//     a1     -- intel addr of destination of the jmp   (inteldest)
//
// Return Value:
// 
//     RegEip -- Contains the Eip value after the current instruction
//

        // Load A1 with IntelDest
        LDA(AREG_NP(A1), CFUNC_LOW(Instruction->Operand1.Immed), REG(ZERO))
        LDAH(AREG_NP(A1), CFUNC_HIGH(Instruction->Operand1.Immed), AREG_NP(A1))

        // Call VOID CallJmpFwdDirectHelper(cpu, IntelDest)
        LDA(TREG_NP(T0), CFUNC_LOW(CallJmpFwdDirectHelper), REG(ZERO))
        LDAH(TREG_NP(T1), CFUNC_HIGH(CallJmpFwdDirectHelper), TREG_NP(T0))
        JMP(REG(RA), TREG_NP(T1), JHINT(CallJmpFwdDirectHelper))

        END_FRAGMENT
        
        PATCH_FRAGMENT(CallJmpFwdDirect2)
//
// Routine Description:
// 
//     Replacement fragment for CallJmpFwdDirect once the RISC address of
//     the jmp is known.
// 
// Arguments:
// 
//     RegEip -- Contains Eip prior to the current instruction
//     a0     -- cpu
//     a1     -- intel addr of destination of the jmp   (inteldest)
//
// Return Value:
// 
//     none   -- jumps directly to nativedest
//

        // jump directly to nativedest
GEN_FIXUP(LoadEPLow, Param1)
        LDA(TREG_NP(T0), CFUNC_LOW(Param1), REG(ZERO))
GEN_FIXUP(LoadEPHigh, Param1)
        LDAH(TREG_NP(T1), CFUNC_HIGH(Param1), TREG_NP(T0))
GEN_FIXUP(BranchEP, Param1)
        JMP(REG(AT), TREG_NP(T1), JHINT(Param1))
        if (!fCompiling) {
            // patching, so overwrite old code with nops
            NOP
            NOP     // padding so this frag is the same size as CallJmpFwdDirect
        }
        END_FRAGMENT
        
        FRAGMENT(CallJmpfDirect)
//
// Routine Description:
// 
//     Initial fragment placed into the translation cache for
//     unconditional FAR direct jmp instructions such as "jmp FAR foo".
//
//     Once the destination address is known, this code is replaced
//     by CallJmpfDirect2.
// 
// Arguments:
// 
//     RegEip -- Contains Eip prior to the current instruction
//     a1     -- ptr to intel addr of destination of the jmp   (pinteldest)
//
// Return Value:
// 
//     RegEip -- Contains the Eip value after the current instruction
//

        LDA(TREG_NP(T0), CFUNC_LOW(CallJmpfDirectHelper), REG(ZERO))
        LDAH(TREG_NP(T1), CFUNC_HIGH(CallJmpfDirectHelper), TREG_NP(T0))
        JMP(REG(RA), TREG_NP(T1), JHINT(CallJmpfDirectHelper))
        
        //
        // pad to same size as calljmpfdirect2
        //
        NOP
        NOP
    
        END_FRAGMENT
        
        PATCH_FRAGMENT(CallJmpfDirect2)
//
// Routine Description:
// 
//     Replacement fragment for CallJmpfDirect once the RISC address of
//     the jmp is known.
// 
// Arguments:
// 
//     RegEip -- Contains Eip prior to the current instruction
//     a1     -- ptr to intel addr of destination of the jmp   (pinteldest)
//
// Return Value:
// 
//     none   -- jumps either to EndTranslatedCode if CpuNotify is set, or
//               jumps directly to nativedest
//
GEN_FIXUP(LoadEPLow, Param1)
        LDA(AREG_NP(A0), CFUNC_LOW(Param1), REG(ZERO))
GEN_FIXUP(LoadEPHigh, Param1)
        LDAH(AREG_NP(A0), CFUNC_HIGH(Param1), AREG_NP(A0))
        LDA(TREG_NP(T0), CFUNC_LOW(CallJmpfDirect2Helper), REG(ZERO))
        LDAH(TREG_NP(T1), CFUNC_HIGH(CallJmpfDirect2Helper), TREG_NP(T0))
        JMP(REG(RA), TREG_NP(T1), JHINT(CallJmpfDirect2Helper))

        END_FRAGMENT
        
        FRAGMENT(CallJmpIndirect)
//
// Routine Description:
//
//      This routine performs an indirect jump to the destination address
//      in a1.
//
// Arguments:
//
//     a1     -- intel addr of destination of the jmp   (inteldest)
//
// Return Value:
//
//     none
//
//
LABEL_DEC(l1)
LABEL_DEC(l2)
        //
        // Check both CpuNotify flags as this code runs in both
        // fast and slow mode.  IndirectControlTransferHelper() is
        // slow, so the extra check isn't too bad when in fast mode.
        //
        LDL(TREG_NP(T0), DISP(0), REG(RegProcessCpuNotify))
        LDA(AREG_NP(A0), DISP(getUniqueIndex()), REG(ZERO))
        BNE_LABEL(TREG_NP(T0), FWD(l1))

        LDL(TREG_NP(T0), DISP(CpuNotify), REG(RegPointer))
        LDA(TREG_NP(T0), CFUNC_LOW(IndirectControlTransferHelper), REG(ZERO))
        BNE_LABEL(TREG_NP(T0), FWD(l2))
        
        LDAH(TREG_NP(T1), CFUNC_HIGH(IndirectControlTransferHelper), TREG_NP(T0))
        JMP(REG(AT), TREG_NP(T1), JHINT(IndirectControlTransferHelper))
LABEL(l1)
LABEL(l2)
        STL(AREG_NP(A1), Eip, RegPointer)
GEN_FIXUP(ECUEP, CurrentECU)
        BR(TREG_NP(T0), BDISP(CurrentECU - (ULONG)(ULONGLONG)(d + 1)))  
GEN_CT(l1)
GEN_CT(l2)
        END_FRAGMENT
        
        FRAGMENT(CallJmpfIndirect)
//
// Routine Description:
//
//      This routine performs an indirect FAR jump to the destination address
//      in a1.
//
// Arguments:
//
//     a0     -- cpu
//     a1     -- pointer to intel addr of destination of the jmp   (pinteldest)
//
// Return Value:
//
//     none
//
//
        LDA(AREG_NP(A2), DISP(getUniqueIndex()), REG(ZERO))
        LDA(TREG_NP(T0), CFUNC_LOW(IndirectControlTransferFarHelper), REG(ZERO))
        LDAH(TREG_NP(T1), CFUNC_HIGH(IndirectControlTransferFarHelper), TREG_NP(T0))
        JMP(REG(AT), TREG_NP(T1), JHINT(IndirectControlTransferFarHelper))
        END_FRAGMENT

        FRAGMENT(CallRetIndirect)
//
// Routine Description:
//
//      This routine calls the return fragment and then goes to
//      the correct place
//
// Arguments:
//
//     none
//
// Return Value:
//
//     none
//
// Notes:
//
        //
        // call worker fragment
        //
        MOV(REG(RegPointer), AREG_NP(A0))
        LDA(TREG_NP(T0), CFUNC_LOW(FragmentArray[Instruction->Operation]), REG(ZERO))
        LDAH(TREG_NP(T1), CFUNC_HIGH(FragmentArray[Instruction->Operation]), TREG_NP(T0))
        JSR(REG(RA), TREG_NP(T1), JHINT(FragmentArray[Instruction->Operation]))
        
        LDL(REG(RegEip), DISP(Eip), REG(RegPointer))
GEN_FIXUP(ECUEP, CurrentECU)
        BEQ(REG(V0), BDISP(CurrentECU - (ULONG)(ULONGLONG)(d + 1)))  
        
        //
        // Else check cpu->CpuNotify.  Don't check ProcessCpuNotify, assuming
        // that apps don't go into tight loops using the RET instruction
        // to jump backwards.  The cpu->CpuNotify check is only required
        // for slowmode, but it is cheap compared to the CTRL_INDIR[I]Ret...
        // call.
        //
        LDL(TREG_NP(T1), DISP(CpuNotify), REG(RegPointer))
GEN_FIXUP(ECUEP, CurrentECU)
        BNE(TREG_NP(T1), BDISP(CurrentECU - (ULONG)(ULONGLONG)(d + 1)))  
        
        //
        // perform the return
        //
        JMP(REG(AT), REG(V0), JHINT(0))

        END_FRAGMENT

        FRAGMENT(CallDirect)
//
// Routine Description:
// 
//     Initial fragment placed into the translation cache for
//     direct call instructions such as "call foo".
//
//     Once the destination address is known, this code is replaced
//     by CallDirect2.
// 
// Arguments:
// 
//     RegEip -- Contains Eip prior to the current instruction
//     a0     -- cpu
//     a1     -- intel addr of destination of the call      (inteldest)
//     a2     -- intel addr of instruction after the call   (intelnext)
//
// Return Value:
// 
//     none   -- jumps either to EndTranslatedCode if CpuNotify is set, or
//               jumps directly to nativedest
//
        LDA(TREG_NP(T0), CFUNC_LOW(CallDirectHelper), REG(ZERO))
        LDAH(TREG_NP(T1), CFUNC_HIGH(CallDirectHelper), TREG_NP(T0))
        JMP(REG(RA), TREG_NP(T1), JHINT(CallDirectHelper))
        
        //
        // pad to be the same size as calldirect2
        //
        NOP     // 4
        NOP     // 5
        NOP     // 6
        NOP     // 7
        NOP     // 8
        NOP     // 9
        NOP     // 10
        NOP     // 11
        NOP     // 12
        CPUASSERT(d - CodeLocation == CallDirect_SIZE);
        END_FRAGMENT

        PATCH_FRAGMENT(CallDirect2)
//
// Routine Description:
// 
//     Replacement fragment for CallDirect once the RISC address of
//     the call is known, but not the RISC address of the instruction
//     following the call instruction.
//
//     Once the RISC address of the instruction after the call is known,
//     this code is replaced by CallDirect3.
// 
// Arguments:
// 
//     RegEip -- Contains Eip prior to the current instruction
//     a0     -- cpu
//     a1     -- intel addr of destination of the call      (inteldest)
//     a2     -- intel addr of instruction after the call   (intelnext)
//
// Return Value:
// 
//     none   -- jumps either to EndTranslatedCode if CpuNotify is set, or
//               jumps directly to nativedest
//

GEN_FIXUP(LoadEPLow, Param1)
        LDA(TREG_NP(T0), CFUNC_LOW(Param1), REG(ZERO))
GEN_FIXUP(LoadEPHigh, Param1)
        LDAH(AREG_NP(A3), CFUNC_HIGH(Param1), TREG_NP(T0))
        LDA(TREG_NP(T0), CFUNC_LOW(CallDirectHelper2), REG(ZERO))
        LDAH(TREG_NP(T1), CFUNC_HIGH(CallDirectHelper2), TREG_NP(T0))
        JMP(REG(RA), TREG_NP(T1), JHINT(CallDirectHelper2))

        //
        // pad to be the same size as calldirect3
        //
        NOP     // 6
        NOP     // 7
        NOP     // 8
        NOP     // 9
        NOP     // 10
        NOP     // 11
        NOP     // 12
        CPUASSERT(d - CodeLocation == CallDirect_SIZE);
        END_FRAGMENT

        PATCH_FRAGMENT(CallDirect3)
//
// Routine Description:
// 
//     Replacement fragment for CallDirect2 once the RISC address of
//     the instruction after the call is known.  (The RISC address of the
//     destination of the call is already known).
//
// Arguments:
// 
//     RegEip -- Contains Eip prior to the current instruction
//     a0     -- cpu
//     a1     -- intel addr of destination of the call      (inteldest)
//     a2     -- intel addr of instruction after the call   (intelnext)
//
// Return Value:
// 
//     none   -- jumps either to EndTranslatedCode if CpuNotify is set, or
//               jumps directly to nativedest
//
        // Call CTRL_CallFrag(cpu, inteldest, intelnext, nativenext)
        MOV(REG(RegPointer), AREG_NP(A0))
        LDA(AREG_NP(A3), CFUNC_LOW(Param2), REG(ZERO))
        LDAH(AREG_NP(A3), CFUNC_HIGH(Param2), AREG_NP(A3))
        LDA(TREG_NP(T0), CFUNC_LOW(CTRL_CallFrag), REG(ZERO))
        LDAH(TREG_NP(T1), CFUNC_HIGH(CTRL_CallFrag), TREG_NP(T0))
        JSR(REG(RA), TREG_NP(T1), JHINT(CTRL_CallFrag))

        //
        // Point the cached EIP at inteldest.  Must be done AFTER the call
        // to CTRL_CallFrag, as the fragment may fault doing the 'push eip'.
        // Then check cpu->CpuNotify and jump either to mipsdest or to ETC.
        // ProcessCpuNotify does not need to be checked as we assume apps
        // don't go into tight loops using CALL/RET with no backward or
        // indirect Jxx instructions.  The CpuNotify check is not required
        // in fast mode, but it is cheap compared to the CTRL_CallFrag call.
        //
        MOV(REG(V0), REG(RegEip))
GEN_FIXUP(LoadEPLow, Param1)
        LDA(AREG_NP(A1), CFUNC_LOW(Param1), REG(ZERO))
        LDL(TREG_NP(T1), DISP(CpuNotify), REG(RegPointer))
GEN_FIXUP(LoadEPHigh, Param1)
        LDAH(AREG_NP(A1), CFUNC_HIGH(Param1), AREG_NP(A1))
GEN_FIXUP(ECUEP, CurrentECU)
        BNE(TREG_NP(T1), BDISP(CurrentECU - (ULONG)(ULONGLONG)(d + 1)))  
        
        // Jump directly to NativeDest
GEN_FIXUP(BranchEP, Param1)
        JMP(REG(AT), AREG_NP(A1), JHINT(Param1))
        CPUASSERT(d - CodeLocation == CallDirect_SIZE);
        
        END_FRAGMENT
        
        
        FRAGMENT(CallfDirect)
//
// Routine Description:
// 
//     Initial fragment placed into the translation cache for
//     direct call instructions such as "call FAR foo".
//
//     Once the destination address is known, this code is replaced
//     by CallfDirect2.
// 
// Arguments:
// 
//     RegEip -- Contains Eip prior to the current instruction
//     a0     -- cpu
//     a1     -- ptr to intel addr of destination of the call (pinteldest)
//     a2     -- intel addr of instruction after the call   (intelnext)
//
// Return Value:
// 
//     none   -- jumps either to EndTranslatedCode if CpuNotify is set, or
//               jumps directly to nativedest
//
        LDA(TREG_NP(T0), CFUNC_LOW(CallfDirectHelper), REG(ZERO))
        LDAH(TREG_NP(T1), CFUNC_HIGH(CallfDirectHelper), TREG_NP(T0))
        JMP(REG(RA), TREG_NP(T1), JHINT(CallfDirectHelper))
        
        //
        // pad to be the same size as callfdirect2
        //
        NOP     // 4
        NOP     // 5
        NOP     // 6
        NOP     // 7
        NOP     // 8
        NOP     // 9
        NOP     // 10
        NOP     // 11
        NOP     // 12
        CPUASSERT(d - CodeLocation == CallfDirect_SIZE);
        END_FRAGMENT

        PATCH_FRAGMENT(CallfDirect2)
//
// Routine Description:
// 
//     Replacement fragment for CallfDirect once the RISC address of
//     the call is known, but not the RISC address of the instruction
//     following the call instruction.
//
//     Once the RISC address of the instruction after the call is known,
//     this code is replaced by CallfDirect3.
// 
// Arguments:
// 
//     RegEip -- Contains Eip prior to the current instruction
//     a0     -- cpu
//     a1     -- ptr to intel addr of destination of the call (pinteldest)
//     a2     -- intel addr of instruction after the call   (intelnext)
//
// Return Value:
// 
//     none   -- jumps either to EndTranslatedCode if CpuNotify is set, or
//               jumps directly to nativedest
//

GEN_FIXUP(LoadEPLow, Param1)
        LDA(TREG_NP(T0), CFUNC_LOW(Param1), REG(ZERO))
GEN_FIXUP(LoadEPHigh, Param1)
        LDAH(AREG_NP(A3), CFUNC_HIGH(Param1), TREG_NP(T0))
        LDA(TREG_NP(T0), CFUNC_LOW(CallfDirectHelper2), REG(ZERO))
        LDAH(TREG_NP(T1), CFUNC_HIGH(CallfDirectHelper2), TREG_NP(T0))
        JMP(REG(RA), TREG_NP(T1), JHINT(CallfDirectHelper2))

        //
        // pad to be the same size as callfdirect3
        //
        NOP     // 6
        NOP     // 7
        NOP     // 8
        NOP     // 9
        NOP     // 10
        NOP     // 11
        NOP     // 12
        CPUASSERT(d - CodeLocation == CallfDirect_SIZE);
        END_FRAGMENT

        PATCH_FRAGMENT(CallfDirect3)
//
// Routine Description:
// 
//     Replacement fragment for CallfDirect2 once the RISC address of
//     the instruction after the call is known.  (The RISC address of the
//     destination of the call is already known).
//
// Arguments:
// 
//     RegEip -- Contains Eip prior to the current instruction
//     a0     -- cpu
//     a1     -- ptr to intel addr of destination of the call (pinteldest)
//     a2     -- intel addr of instruction after the call   (intelnext)
//
// Return Value:
// 
//     none   -- jumps either to EndTranslatedCode if CpuNotify is set, or
//               jumps directly to nativedest
//
        // Call CTRL_CallfFrag(cpu, pinteldest, intelnext, nativenext)
        //  V0 = pinteldest
        MOV(REG(RegPointer), AREG_NP(A0))
        LDA(AREG_NP(A3), CFUNC_LOW(Param2), REG(ZERO))
        LDAH(AREG_NP(A3), CFUNC_HIGH(Param2), AREG_NP(A3))
        LDA(TREG_NP(T0), CFUNC_LOW(CTRL_CallfFrag), REG(ZERO))
        LDAH(TREG_NP(T1), CFUNC_HIGH(CTRL_CallfFrag), TREG_NP(T0))
        JSR(REG(RA), TREG_NP(T1), JHINT(CTRL_CallfFrag))

        //
        // Point the cached EIP at inteldest.  Must be done AFTER the call
        // to CTRL_CallfFrag, as the fragment may fault doing the 'push eip'.
        // Then check cpu->CpuNotify and jump either to mipsdest or to ETC.
        // ProcessCpuNotify does not need to be checked as we assume apps
        // don't go into tight loops using CALL/RET with no backward or
        // indirect Jxx instructions.  The CpuNotify check is not required
        // in fast mode, but it is cheap compared to the CTRL_CallFrag call.
        //
        LDL(REG(RegEip), DISP(Eip), REG(RegPointer))
        
        LDL(TREG_NP(T1), DISP(CpuNotify), REG(RegPointer))
GEN_FIXUP(ECUEP, CurrentECU)
        BNE(TREG_NP(T1), BDISP(CurrentECU - (ULONG)(ULONGLONG)(d + 1))) 
        
        //
        // perform call
        //
GEN_FIXUP(LoadEPLow, Param1)
        LDA(AREG_NP(A1), CFUNC_LOW(Param1), REG(ZERO))
GEN_FIXUP(LoadEPHigh, Param1)
        LDAH(AREG_NP(A1), CFUNC_HIGH(Param1), AREG_NP(A1))
GEN_FIXUP(BranchEP, Param2)
        JMP(REG(AT), AREG_NP(A1), JHINT(Param1))
        CPUASSERT(d - CodeLocation == CallfDirect_SIZE);
        
        END_FRAGMENT
        
        
        FRAGMENT(CallIndirect)
//
// Routine Description:
// 
//     Initial fragment placed into the translation cache for
//     indirect call instructions such as "call [foo]".
//
//     Once the destination address is known, this code is replaced
//     by CallIndirect2.
// 
// Arguments:
// 
//     RegEip -- Contains Eip prior to the current instruction
//     a0     -- cpu
//     a1     -- intel addr of destination of the call      (inteldest)
//     a2     -- intel addr of instruction after the call   (intelnext)
//
// Return Value:
// 
//     none   -- jumps either to EndTranslatedCode if CpuNotify is set, or
//               jumps directly to nativedest
//
        LDA(TREG_NP(T0), CFUNC_LOW(CallIndirectHelper), REG(ZERO))        
        LDAH(TREG_NP(T1), CFUNC_HIGH(CallIndirectHelper), TREG_NP(T0))
        JMP(REG(RA), TREG_NP(T1), JHINT(CallIndirectHelper))
        
        //
        // pad to same size as callindirect2
        //
        NOP     // 4
        NOP     // 5
        NOP     // 6
        NOP     // 7
        NOP     // 8
        NOP     // 9
        NOP     // 10
        NOP     // 11
        NOP     // 12
        NOP     // 13
        NOP     // 14
        END_FRAGMENT
        
        FRAGMENT(CallfIndirect)
//
// Routine Description:
// 
//     Initial fragment placed into the translation cache for
//     indirect call instructions such as "call FAR [foo]".
//
//     Once the destination address is known, this code is replaced
//     by CallfIndirect2.
// 
// Arguments:
// 
//     RegEip -- Contains Eip prior to the current instruction
//     a0     -- cpu
//     a1     -- ptr to intel addr of destination of the call (pinteldest)
//     a2     -- intel addr of instruction after the call   (intelnext)
//
// Return Value:
// 
//     none   -- jumps either to EndTranslatedCode if CpuNotify is set, or
//               jumps directly to nativedest
//
        LDA(TREG_NP(T0), CFUNC_LOW(CallfIndirectHelper), REG(ZERO))
        LDAH(TREG_NP(T1), CFUNC_HIGH(CallfIndirectHelper), TREG_NP(T0))
        JMP(REG(RA), TREG_NP(T1), JHINT(CallfIndirectHelper))
        
        //
        // pad to same size as callfindirect2
        //
        NOP     // 4
        NOP     // 5
        NOP     // 6
        NOP     // 7
        NOP     // 8
        NOP     // 9
        NOP     // 10
        NOP     // 11
        NOP     // 12
        NOP     // 13
        NOP     // 14
        END_FRAGMENT
        
        PATCH_FRAGMENT(CallIndirect2)
//
// Routine Description:
// 
//     This fragment replaces the CallIndirect fragment once the RISC address
//     of the instruction following the indirect call is known (nativenext).
//
// Arguments:
// 
//     RegEip -- Contains Eip prior to the current instruction
//     a0     -- cpu
//     a1     -- intel addr of destination of the call      (inteldest)
//     a2     -- intel addr of instruction after the call   (intelnext)
//
// Return Value:
// 
//     none   -- jumps to EndTranslatedCode
//
        MOV(REG(RegPointer), AREG_NP(A0))
        LDA(AREG_NP(A3), CFUNC_LOW(Param1), REG(ZERO))
        LDAH(AREG_NP(A3), CFUNC_HIGH(Param1), AREG_NP(A3))
        LDA(TREG_NP(T0), CFUNC_LOW(CTRL_CallFrag), REG(ZERO))
        LDAH(TREG_NP(T1), CFUNC_HIGH(CTRL_CallFrag), TREG_NP(T0))
        JSR(REG(RA), TREG_NP(T1), JHINT(CTRL_CallFrag))
        // v0=inteldest
        
        //
        // Check cpu->CpuNotify and jump either to the helper or to ETC.
        // ProcessCpuNotify does not need to be checked as we assume apps
        // don't go into tight loops using CALL/RET with no backward or
        // indirect Jxx instructions.  The CpuNotify check is not required
        // in fast mode, but it is cheap compared to the CTRL_CallFrag call.
        //
        MOV(REG(V0), REG(RegEip))
        LDL(TREG_NP(T0), DISP(CpuNotify), REG(RegPointer))
        MOV(REG(V0), AREG_NP(A1))   // v0=inteldest - move to A1
GEN_FIXUP(ECUEP, CurrentECU)
        BNE(TREG_NP(T0), BDISP(CurrentECU - (ULONG)(ULONGLONG)(d + 1))) 

        // Jump to: IndirectControlTransferHelper(tableindex, inteldest)
        LDA(AREG_NP(A0), CFUNC_LOW(Param2), REG(ZERO))
        LDA(TREG_NP(T0), CFUNC_LOW(IndirectControlTransferHelper), REG(ZERO))
        LDAH(TREG_NP(T1), CFUNC_HIGH(IndirectControlTransferHelper), TREG_NP(T0))
        JMP(REG(RA), TREG_NP(T1), JHINT(IndirectControlTransferHelper))
        END_FRAGMENT

        PATCH_FRAGMENT(CallfIndirect2)
//
// Routine Description:
// 
//     This fragment replaces the CallfIndirect fragment once the RISC address
//     of the instruction following the indirect call is known (nativenext).
//
// Arguments:
// 
//     RegEip -- Contains Eip prior to the current instruction
//     a0     -- cpu
//     a1     -- ptr to intel addr of destination of the call (pinteldest)
//     a2     -- intel addr of instruction after the call   (intelnext)
//
// Return Value:
// 
//     none   -- jumps to EndTranslatedCode
//
        MOV(REG(RegPointer), AREG_NP(A0))
        LDA(AREG_NP(A3), CFUNC_LOW(Param1), REG(ZERO))
        LDAH(AREG_NP(A3), CFUNC_HIGH(Param1), AREG_NP(A3))
        LDA(TREG_NP(T0), CFUNC_LOW(CTRL_CallfFrag), REG(ZERO))
        LDAH(TREG_NP(T1), CFUNC_HIGH(CTRL_CallfFrag), TREG_NP(T0))
        JSR(REG(RA), TREG_NP(T1), JHINT(CTRL_CallfFrag))

        //
        // Check cpu->CpuNotify and jump either to the helper or to ETC.
        // ProcessCpuNotify does not need to be checked as we assume apps
        // don't go into tight loops using CALL/RET with no backward or
        // indirect Jxx instructions.  The CpuNotify check is not required
        // in fast mode, but it is cheap compared to the CTRL_CallfFrag call.
        //
        LDL(REG(RegEip), DISP(Eip), REG(RegPointer))
        LDL(TREG_NP(T0), DISP(CpuNotify), REG(RegPointer))
GEN_FIXUP(ECUEP, CurrentECU)
        BNE(TREG_NP(T0), BDISP(CurrentECU - (ULONG)(ULONGLONG)(d + 1)))  

        // Jump to: IndirectControlTransferFarHelper(a0=unused, pinteldest, tableindex)
        MOV(AREG_NP(A1), REG(V0))
        LDA(AREG_NP(A2), CFUNC_LOW(Param2), REG(ZERO))
        LDA(TREG_NP(T0), CFUNC_LOW(IndirectControlTransferFarHelper), REG(ZERO))
        LDAH(TREG_NP(T1), CFUNC_HIGH(IndirectControlTransferFarHelper), TREG_NP(T0))
        JMP(REG(RA), TREG_NP(T1), JHINT(IndirectControlTransferFarHelper))
        END_FRAGMENT

        FRAGMENT(Movsx8To32)
// 
// Routine Description:
// 
//     This fragment implements "movsx r32, r/m8"
// 
// Arguments:
// 
//     a1 - byte value to store
//     Instruction->Operand2.Reg = register to store into
//                                 (Operand2.Type == OPND_NOCODEGEN)
//
// Return Value:
// 
//     none
//
        if (fByteInstructionsOK) {
            SEXTB(AREG_NP(A1), AREG_NP(A1))
        } else {
            INSLL   (AREG_NP(A1), CNST(7), AREG_NP(A1))
            SRA     (AREG_NP(A1), CNST(0x38), AREG_NP(A1))
        }
        STL     (AREG_NP(A1), DISP(RegisterOffset[Instruction->Operand2.Reg]), RegPointer)

        END_FRAGMENT


        FRAGMENT(Movsx8To32Slow)
// 
// Routine Description:
// 
//     This fragment implements "movsx r32, r/m8"
// 
// Arguments:
// 
//     a1 - byte value to store
//     Instruction->Operand2.Reg = register to store into
//                                 (Operand2.Type == OPND_NOCODEGEN)
//
// Return Value:
// 
//     none
//
        if (fByteInstructionsOK) {
            SEXTB(AREG_NP(A1), AREG_NP(A1))
        } else {
            INSLL   (AREG_NP(A1), CNST(7), AREG_NP(A1))
            SRA     (AREG_NP(A1), CNST(0x38), AREG_NP(A1))
        }
        STL     (AREG_NP(A1), DISP(RegisterOffset[Instruction->Operand2.Reg]), RegPointer)

        LDL(TREG_NP(T0), DISP(CpuNotify), REG(RegPointer))
        ADDL(REG(RegEip), CNST(Instruction->Size), REG(RegEip))
        STL(REG(RegEip), DISP(Eip), REG(RegPointer))
GEN_FIXUP(ECUEP, CurrentECU)
        BNE(TREG_NP(T0), BDISP(CurrentECU - (ULONG)(ULONGLONG)(d + 1))) 
        END_FRAGMENT


        FRAGMENT(Movsx16To32)
// 
// Routine Description:
// 
//     This fragment implements "movsx r32, r/m16"
// 
// Arguments:
// 
//     a1 - byte value to store
//     Instruction->Operand2.Reg = register to store into
//                                 (Operand2.Type == OPND_NOCODEGEN)
//
// Return Value:
// 
//     none
//
        if (fByteInstructionsOK) {
            // Save 1 instruction
            SEXTW(AREG_NP(A1), AREG_NP(A1))
        } else {
            INSLL   (AREG_NP(A1), CNST(6), AREG_NP(A1))
            SRA     (AREG_NP(A1), CNST(0x30), AREG_NP(A1))
        }
        STL     (AREG_NP(A1), DISP(RegisterOffset[Instruction->Operand2.Reg]), RegPointer)

        END_FRAGMENT

        FRAGMENT(Movsx16To32Slow)
// 
// Routine Description:
// 
//     This fragment implements "movsx r32, r/m16"
// 
// Arguments:
// 
//     a1 - byte value to store
//     Instruction->Operand2.Reg = register to store into
//                                 (Operand2.Type == OPND_NOCODEGEN)
//
// Return Value:
// 
//     none
//
        if (fByteInstructionsOK) {
            // Save 1 instruction
            SEXTW (AREG_NP(A1), AREG_NP(A1))
        } else {
            INSLL   (AREG_NP(A1), CNST(6), AREG_NP(A1))
            SRA     (AREG_NP(A1), CNST(0x30), AREG_NP(A1))
        }
        STL     (AREG_NP(A1), DISP(RegisterOffset[Instruction->Operand2.Reg]), RegPointer)

        LDL(TREG_NP(T0), DISP(CpuNotify), REG(RegPointer))
        ADDL(REG(RegEip), CNST(Instruction->Size), REG(RegEip))
        STL(REG(RegEip), DISP(Eip), REG(RegPointer))
GEN_FIXUP(ECUEP, CurrentECU)
        BNE(TREG_NP(T0), BDISP(CurrentECU - (ULONG)(ULONGLONG)(d + 1))) 
        END_FRAGMENT

        FRAGMENT(Movsx8To16)
// 
// Routine Description:
// 
//     This fragment implements "movsx r16, r/m8"
// 
// Arguments:
// 
//     a1 - byte value to store
//     Instruction->Operand2.Reg = register to store into
//                                 (Operand2.Type == OPND_NOCODEGEN)
//
// Return Value:
// 
//     none
//
        if (fByteInstructionsOK) {
            // saves 5 instructions, including an LDL.
            SEXTB (AREG_NP(A1), AREG_NP(A1))
            STW   (AREG_NP(A1), DISP(RegisterOffset[Instruction->Operand2.Reg]), RegPointer)
        } else {
            // get current 32-bit register into A2
            LDL     (AREG_NP(A2), DISP(RegisterOffset[Instruction->Operand2.Reg]), RegPointer)

            // sign-extend 8 bits of A1 into A1
            INSLL   (AREG_NP(A1), CNST(7), AREG_NP(A1))
            SRA     (AREG_NP(A1), CNST(0x38), AREG_NP(A1))

            // retain loword of A1 and hiword from A2
            ZAPNOT  (AREG_NP(A1), CNST(3), AREG_NP(A1))
            ZAPNOT  (AREG_NP(A2), CNST(0x0c), AREG_NP(A2))

            // A1 = A1|A2, and store to memory
            BIS     (AREG_NP(A1), AREG_NP(A2), AREG_NP(A1))
            STL     (AREG_NP(A1), DISP(RegisterOffset[Instruction->Operand2.Reg]), RegPointer)
        }
        END_FRAGMENT

        FRAGMENT(Movsx8To16Slow)
// 
// Routine Description:
// 
//     This fragment implements "movsx r16, r/m8"
// 
// Arguments:
// 
//     a1 - byte value to store
//     Instruction->Operand2.Reg = register to store into
//                                 (Operand2.Type == OPND_NOCODEGEN)
//
// Return Value:
// 
//     none
//
        if (fByteInstructionsOK) {
            // saves 5 instructions, including an LDL.
            SEXTB (AREG_NP(A1), AREG_NP(A1))
            STW   (AREG_NP(A1), DISP(RegisterOffset[Instruction->Operand2.Reg]), RegPointer)
        } else {
            // get current 32-bit register into A2
            LDL     (AREG_NP(A2), DISP(RegisterOffset[Instruction->Operand2.Reg]), RegPointer)

            // sign-extend 8 bits of A1 into A1
            INSLL   (AREG_NP(A1), CNST(7), AREG_NP(A1))
            SRA     (AREG_NP(A1), CNST(0x38), AREG_NP(A1))

            // retain loword of A1 and hiword from A2
            ZAPNOT  (AREG_NP(A1), CNST(3), AREG_NP(A1))
            ZAPNOT  (AREG_NP(A2), CNST(0x0c), AREG_NP(A2))

            // A1 = A1|A2, and store to memory
            BIS     (AREG_NP(A1), AREG_NP(A2), AREG_NP(A1))
            STL     (AREG_NP(A1), DISP(RegisterOffset[Instruction->Operand2.Reg]), RegPointer)
        }
        LDL(TREG_NP(T0), DISP(CpuNotify), REG(RegPointer))
        ADDL(REG(RegEip), CNST(Instruction->Size), REG(RegEip))
        STL(REG(RegEip), DISP(Eip), REG(RegPointer))
GEN_FIXUP(ECUEP, CurrentECU)
        BNE(TREG_NP(T0), BDISP(CurrentECU - (ULONG)(ULONGLONG)(d + 1)))  
        END_FRAGMENT

        FRAGMENT(Movzx8To32)
// 
// Routine Description:
// 
//     This fragment implements "movzx r32, r/m8"
// 
// Arguments:
// 
//     a1 - byte value to store
//     Instruction->Operand2.Reg = register to store into
//                                 (Operand2.Type == OPND_NOCODEGEN)
//
// Return Value:
// 
//     none
//
        AND     (AREG_NP(A1), CNST(0xff), AREG_NP(A1))
        STL     (AREG_NP(A1), DISP(RegisterOffset[Instruction->Operand2.Reg]), RegPointer)

        END_FRAGMENT

        FRAGMENT(Movzx8To32Slow)
// 
// Routine Description:
// 
//     This fragment implements "movzx r32, r/m8"
// 
// Arguments:
// 
//     a1 - byte value to store
//     Instruction->Operand2.Reg = register to store into
//                                 (Operand2.Type == OPND_NOCODEGEN)
//
// Return Value:
// 
//     none
//
        AND     (AREG_NP(A1), CNST(0xff), AREG_NP(A1))
        STL     (AREG_NP(A1), DISP(RegisterOffset[Instruction->Operand2.Reg]), RegPointer)

        LDL(TREG_NP(T0), DISP(CpuNotify), REG(RegPointer))
        ADDL(REG(RegEip), CNST(Instruction->Size), REG(RegEip))
        STL(REG(RegEip), DISP(Eip), REG(RegPointer))
GEN_FIXUP(ECUEP, CurrentECU)
        BNE(TREG_NP(T0), BDISP(CurrentECU - (ULONG)(ULONGLONG)(d + 1))) 
        END_FRAGMENT

        FRAGMENT(Movzx16To32)
// 
// Routine Description:
// 
//     This fragment implements "movzx r32, r/m16"
// 
// Arguments:
// 
//     a1 - byte value to store
//     Instruction->Operand2.Reg = register to store into
//                                 (Operand2.Type == OPND_NOCODEGEN)
//
// Return Value:
// 
//     none
//
        ZAPNOT  (AREG_NP(A1), CNST(3), AREG_NP(A1))
        STL     (AREG_NP(A1), DISP(RegisterOffset[Instruction->Operand2.Reg]), RegPointer)

        END_FRAGMENT

        FRAGMENT(Movzx16To32Slow)
// 
// Routine Description:
// 
//     This fragment implements "movzx r32, r/m16"
// 
// Arguments:
// 
//     a1 - byte value to store
//     Instruction->Operand2.Reg = register to store into
//                                 (Operand2.Type == OPND_NOCODEGEN)
//
// Return Value:
// 
//     none
//
        ZAPNOT  (AREG_NP(A1), CNST(3), AREG_NP(A1))
        STL     (AREG_NP(A1), DISP(RegisterOffset[Instruction->Operand2.Reg]), RegPointer)

        LDL(TREG_NP(T0), DISP(CpuNotify), REG(RegPointer))
        ADDL(REG(RegEip), CNST(Instruction->Size), REG(RegEip))
        STL(REG(RegEip), DISP(Eip), REG(RegPointer))
GEN_FIXUP(ECUEP, CurrentECU)
        BNE(TREG_NP(T0), BDISP(CurrentECU - (ULONG)(ULONGLONG)(d + 1)))  
        END_FRAGMENT

        FRAGMENT(Movzx8To16)
// 
// Routine Description:
// 
//     This fragment implements "movzx r16, r/m8"
// 
// Arguments:
// 
//     a1 - byte value to store
//     Instruction->Operand2.Reg = register to store into
//                                 (Operand2.Type == OPND_NOCODEGEN)
//
// Return Value:
// 
//     none
//
        if (fByteInstructionsOK) {
            // retain lobyte of A1, zap second byte, and store word
            // saves 3 instructions, including an LDL
            ZAPNOT  (AREG_NP(A1), CNST(1), AREG_NP(A1))
            STW     (AREG_NP(A1), DISP(RegisterOffset[Instruction->Operand2.Reg]), RegPointer)
        } else {
            // get current 32-bit register into A2
            LDL     (AREG_NP(A2), DISP(RegisterOffset[Instruction->Operand2.Reg]), RegPointer)

            // retain lobyte of A1 and hiword from A2
            ZAPNOT  (AREG_NP(A1), CNST(1), AREG_NP(A1))
            ZAPNOT  (AREG_NP(A2), CNST(0x0c), AREG_NP(A2))

            // A1 = A1|A2, and store to memory
            BIS     (AREG_NP(A1), AREG_NP(A2), AREG_NP(A1))
            STL     (AREG_NP(A1), DISP(RegisterOffset[Instruction->Operand2.Reg]), RegPointer)
        }

        END_FRAGMENT

        FRAGMENT(Movzx8To16Slow)
// 
// Routine Description:
// 
//     This fragment implements "movzx r16, r/m8"
// 
// Arguments:
// 
//     a1 - byte value to store
//     Instruction->Operand2.Reg = register to store into
//                                 (Operand2.Type == OPND_NOCODEGEN)
//
// Return Value:
// 
//     none
//
        if (fByteInstructionsOK) {
            // retain lobyte of A1, zap next byte, and store word
            // saves 3 instructions, including an LDL
            ZAPNOT  (AREG_NP(A1), CNST(1), AREG_NP(A1))
            STW     (AREG_NP(A1), DISP(RegisterOffset[Instruction->Operand2.Reg]), RegPointer)
        } else {
            // get current 32-bit register into A2
            LDL     (AREG_NP(A2), DISP(RegisterOffset[Instruction->Operand2.Reg]), RegPointer)

            // retain lobyte of A1 and hiword from A2
            ZAPNOT  (AREG_NP(A1), CNST(1), AREG_NP(A1))
            ZAPNOT  (AREG_NP(A2), CNST(0x0c), AREG_NP(A2))

            // A1 = A1|A2, and store to memory
            BIS     (AREG_NP(A1), AREG_NP(A2), AREG_NP(A1))
            STL     (AREG_NP(A1), DISP(RegisterOffset[Instruction->Operand2.Reg]), RegPointer)
        }
        LDL(TREG_NP(T0), DISP(CpuNotify), REG(RegPointer))
        ADDL(REG(RegEip), CNST(Instruction->Size), REG(RegEip))
        STL(REG(RegEip), DISP(Eip), REG(RegPointer))
GEN_FIXUP(ECUEP, CurrentECU)
        BNE(TREG_NP(T0), BDISP(CurrentECU - (ULONG)(ULONGLONG)(d + 1))) 
        END_FRAGMENT


        FRAGMENT(EndMovSlow)
//
// Routine Description:
//
//      This is placed after all operands in inline Mov32/16/8 instructions
//      when compiling in slow mode.  It updates Eip and checks CpuNotify.
//
//      In fast mode, this is not required.
//
// Arguments:
//
//     none
//
// Return Value:
//
//     none
//
        LDL(TREG_NP(T0), DISP(CpuNotify), REG(RegPointer))
        ADDL(REG(RegEip), CNST(Instruction->Size), REG(RegEip))
        STL(REG(RegEip), DISP(Eip), REG(RegPointer))
GEN_FIXUP(ECUEP, CurrentECU)
        BNE(TREG_NP(T0), BDISP(CurrentECU - (ULONG)(ULONGLONG)(d + 1)))  
        END_FRAGMENT


        FRAGMENT(EndCompilationUnit)
// 
// Routine Description:
// 
//     This fragment provides a jump to end translated code in the correct
//     relative location in the codestream.  AXP predicts that forward
//     branches fall through, and backward branches are taken.  In order
//     for UpdateEip and the other fragments that check CpuNotify to have
//     their branches correctly predicted, the call has to come at a 
//     numerically larger address out of line.
// 
// Arguments:
// 
//     none
//
// Return Value:
// 
//     none
//
        LDA(TREG_NP(T1), CFUNC_LOW(EndTranslatedCode), REG(ZERO))
        LDAH(TREG_NP(T2), CFUNC_HIGH(EndTranslatedCode), TREG_NP(T1))
        JMP(REG(AT), TREG_NP(T2), JHINT(EndTranslatedCode))
        CPUASSERT(d - CodeLocation == EndCompilationUnit_SIZE);
        END_FRAGMENT

#if 0
        FRAGMENT(UpdateEntrypointCount)
// 
// Routine Description:
// 
// This routine updates the execution count for the specified entrypoint
//
// Arguments:
// 
//     none
//
// Return Value:
// 
//     none
//
//
        LDAH(TREG_NP(T0), CFUNC_HIGH(&(Instruction->EntryPoint->ExecutionCount)), REG(ZERO))
        LDA(TREG_NP(T0), CFUNC_LOW(&(Instruction->EntryPoint->ExecutionCount)), TREG_NP(T0))
        LDL(TREG_NP(T1), DISP(0), TREG_NP(T0))
        ADDL(TREG_NP(T1), CNST(1), TREG_NP(T1))
        STL(TREG_NP(T1), DISP(0), TREG_NP(T0))
        END_FRAGMENT

#endif


    OP_FRAGMENT(OperandMovToMem8B)
// 
// Routine Description:
// 
//     This is the inline mov8 fragment for non-dword aligned bytes
// 
// Arguments:
// 
//     a1 -- The destination of the move
//     a2 -- The value to be stored at 0(a1)
//
// Return Value:
// 
//     none
//
    ULONG Reg;

    if (fByteInstructionsOK) {
        // save 5 or 6 instructions, depending on value of Immed.
        USHORT Immed;

        if (Operand->Reg != NO_REG && Operand[-2].Type == OPND_ADDRREF) {
            Immed = (USHORT)Operand->Scale;
            Reg = Operand->Reg;
        } else {
            Reg = AREG_NP(A1);
        }
        STB (AREG_NP(A2), DISP(Immed), Reg);
    } else {
        if (Operand->Reg != NO_REG && Operand[-2].Type == OPND_ADDRREF) {
            USHORT Immed;

            Immed = (USHORT)Operand->Scale;
            Reg = Operand->Reg;
            if (Immed) {
                LDA (AREG_NP(A1), Immed, Reg);
                Reg = AREG_NP(A1);
            }
        } else {
            Reg = AREG_NP(A1);
        }

        BIC(Reg, CNST(3), TREG_NP(T1))                  // align destination
        AND(Reg, CNST(3), TREG_NP(T0))
        INSBL(AREG_NP(A2), TREG_NP(T0), TREG_NP(T2))    // align the bits to store
        LDL(AREG_NP(A2), DISP(0), TREG_NP(T1))          // get dword that will contain
        MSKBL(AREG_NP(A2), TREG_NP(T0), AREG_NP(A2))    // clear bits byte stored in
        BIS(TREG_NP(T2), AREG_NP(A2), AREG_NP(A2))      // or in byte to be stored
        STL(AREG_NP(A2), DISP(0), TREG_NP(T1))          // put back dword

        SetArgContents(2, NO_REG);  // A2 is trashed
    }

    END_FRAGMENT

    OP_FRAGMENT(OperandMovToMem8D)
// 
// Routine Description:
// 
//     This is the inline mov8 fragment for dword aligned bytes
// 
// Arguments:
// 
//     a1 -- The destination of the move
//     a2 -- The value to be stored at 0(a1)
//
// Return Value:
// 
//     none
//
    ULONG Reg;
    USHORT Immed;

    if (Operand->Reg != NO_REG && Operand[-2].Type == OPND_ADDRREF) {
        Immed = (USHORT)Operand->Scale;
        CPUASSERT((Immed&3) == 0);      // Immed must always be DWORD-aligned
        Reg = Operand->Reg;
    } else {
        Immed = 0;
        Reg = AREG_NP(A1);
    }

    if (fByteInstructionsOK) {
        // Save 4 instructions, including an LDL.
        STB(AREG_NP(A2), DISP(Immed), Reg);
    } else {
        LDL(TREG_NP(T1), DISP(Immed), Reg)
        MSKBL(TREG_NP(T1), CNST(0), TREG_NP(T2))
        INSBL(AREG_NP(A2), CNST(0), TREG_NP(T0))
        BIS(TREG_NP(T2), TREG_NP(T0), TREG_NP(T1))
        STL(TREG_NP(T1), DISP(Immed), Reg)
    }

    END_FRAGMENT

    OP_FRAGMENT(OperandMovToMem32D)
// 
// Routine Description:
// 
//     This is the inline mov32 fragment
// 
// Arguments:
// 
//     a1 -- The destination of the move
//     a2 -- The value to be stored at 0(a1)
//
// Return Value:
// 
//     none
//
    ULONG Reg;
    USHORT Immed;

    if (Operand->Reg != NO_REG && Operand[-2].Type == OPND_ADDRREF) {
        Immed = (USHORT)Operand->Scale;
        CPUASSERT((Immed&3) == 0);      // Immed must always be DWORD-aligned
        Reg = Operand->Reg;
    } else {
        Immed = 0;
        Reg = AREG_NP(A1);
    }
    STL(AREG_NP(A2), Immed, Reg)
        
    END_FRAGMENT

        
    OP_FRAGMENT(OperandMovToMem32B)
// 
// Routine Description:
// 
//     This is the inline mov32 fragment for unaligned moves
// 
// Arguments:
// 
//     a1 -- The destination of the move
//     a2 -- The value to be stored at 0(a1)
//
// Return Value:
// 
//     none
//
    ULONG Reg;
    USHORT Immed;
LABEL_DEC(l1)
LABEL_DEC(l2)

    if (Operand->Reg != NO_REG && Operand[-2].Type == OPND_ADDRREF) {
        Immed = (USHORT)Operand->Scale;
        Reg = Operand->Reg;
        if (Immed & 3) {
            //
            // Immed isn't DWORD-aligned, so add it in
            //
            LDA (AREG_NP(A1), Immed, Reg)
            Reg = AREG_NP(A1);
            Immed = 0;
        }
    } else {
        Reg = AREG_NP(A1);
        Immed = 0;
    }

    AND(Reg, CNST(3), TREG_NP(T4))              // mod for dword
    BNE_LABEL(TREG_NP(T4), FWD(l1))             // check for aligned

    STL(AREG_NP(A2), DISP(Immed), Reg)
    BR_LABEL(REG(AT), FWD(l2))

LABEL(l1)
    if (fByteInstructionsOK) {
        if (((Immed+3) ^ Immed) & 0x8000) {
            //
            // Can't add the offset into the STB instructions due to
            // wraparound on Immed+3
            //
            LDA (AREG_NP(A1), DISP(Immed), Reg)
            Immed=0;
            Reg = TREG;
        }
        /* save 5 instructions */
        STB(AREG_NP(A2), DISP(Immed), Reg)
        SRL(AREG_NP(A2), CNST(8), TREG_NP(T4))
        STB(TREG_NP(T4), DISP(Immed+1), Reg)
        SRL(AREG_NP(A2), CNST(16), TREG_NP(T4))
        STB(TREG_NP(T4), DISP(Immed+2), Reg)
        SRL(AREG_NP(A2), CNST(24), TREG_NP(T4))
        STB(TREG_NP(T4), DISP(Immed+3), Reg)
    } else {
        if (((Immed+4) ^ Immed) & 0x8000) {
            //
            // Can't add the offset into the load/store instructions due to
            // wraparound on Immed+4
            //
            LDA (AREG_NP(A1), DISP(Immed), Reg)
            Reg = AREG_NP(A1);
            Immed=0;
        }
        BIC(Reg, CNST(3), TREG_NP(T0))              // align the address
        LDL(TREG_NP(T1), DISP(Immed), TREG_NP(T0))  // get the low dword
        INSLL(AREG_NP(A2), TREG_NP(T4), TREG_NP(T2))// put low bits in place
        MSKLL(TREG_NP(T1), TREG_NP(T4), TREG_NP(T3))// mask low bit positions
        BIS(TREG_NP(T3), TREG_NP(T2), TREG_NP(T1))  // reform dword
        STL(TREG_NP(T1), DISP(Immed), TREG_NP(T0))  // put low half back in mem
        ADDL(TREG_NP(T4), CNST(4), TREG_NP(T4))     // update mask/insrt bits
        LDL(TREG_NP(T1), DISP(Immed+4), TREG_NP(T0))// get high dword
        INSLH(AREG_NP(A2), TREG_NP(T4), TREG_NP(T2))// put high bits in place
        MSKLH(TREG_NP(T1), TREG_NP(T4), TREG_NP(T3))// mask high bit positions
        BIS(TREG_NP(T3), TREG_NP(T2), TREG_NP(T1))  // reform dword
        STL(TREG_NP(T1), DISP(Immed+4), TREG_NP(T0))// put low half back in mem
    }
LABEL(l2)        
GEN_CT(l1)
GEN_CT(l2)
    END_FRAGMENT


    OP_FRAGMENT(OperandMovToMem16D)
// 
// Routine Description:
// 
//     This is the inline mov16 fragment for dword aligned moves
// 
// Arguments:
// 
//     a1 -- The destination of the move
//     a2 -- The value to be stored at 0(a1)
//
// Return Value:
// 
//     none
//
    ULONG Reg;
    USHORT Immed;

    if (Operand->Reg != NO_REG && Operand[-2].Type == OPND_ADDRREF) {
        Immed = (USHORT)Operand->Scale;
        CPUASSERT((Immed&3) == 0);      // Immed must always be DWORD-aligned
        Reg = Operand->Reg;
    } else {
        Immed = 0;
        Reg = AREG_NP(A1);
    }
    if (fByteInstructionsOK) {
        // Save 4 instructions
        STW(AREG_NP(A2), DISP(Immed), Reg)
    } else {
        LDL(TREG_NP(T0), DISP(Immed), Reg)
        INSWL(AREG_NP(A2), CNST(0), TREG_NP(T2))
        MSKWL(TREG_NP(T0), CNST(0), AREG_NP(A2))
        BIS(AREG_NP(A2), TREG_NP(T2), TREG_NP(T1))
        STL(TREG_NP(T1), DISP(Immed), Reg)

        SetArgContents(2, NO_REG);  // A2 is trashed
    }

    END_FRAGMENT

    OP_FRAGMENT(OperandMovToMem16W)
// 
// Routine Description:
// 
//     This is the inline mov16 fragment for dword contained moves
// 
// Arguments:
// 
//     a1 -- The destination of the move
//     a2 -- The value to be stored at 0(a1)
//
// Return Value:
// 
//     none
//
    ULONG Reg;
    USHORT Immed;

    if (fByteInstructionsOK) {
        // save 6 or 7 instructions and don't trash A2.
        if (Operand->Reg != NO_REG && Operand[-2].Type == OPND_ADDRREF) {
            Immed = (USHORT)Operand->Scale;
            Reg = Operand->Reg;
        } else {
            Reg = AREG_NP(A1);
            Immed = 0;
        }
        STW(AREG_NP(A2), DISP(Immed), Reg)

    } else {
        if (Operand->Reg != NO_REG && Operand[-2].Type == OPND_ADDRREF) {
            Immed = (USHORT)Operand->Scale;
            Reg = Operand->Reg;
            if (Immed & 3) {
                //
                // Immed isn't DWORD-aligned, so add it in
                //
                LDA (AREG_NP(A1), Immed, Reg)
                Reg = AREG_NP(A1);
                Immed = 0;
            }
        } else {
            Reg = AREG_NP(A1);
            Immed = 0;
        }

        BIC(Reg, CNST(3), TREG_NP(T0))
        AND(Reg, CNST(3), TREG_NP(T1))
        LDL(TREG_NP(T2), DISP(Immed), TREG_NP(T0))
        INSWL(AREG_NP(A2), TREG_NP(T1), TREG_NP(T4))
        MSKWL(TREG_NP(T2), TREG_NP(T1), AREG_NP(A2))
        BIS(AREG_NP(A2), TREG_NP(T4), TREG_NP(T2))
        STL(TREG_NP(T2), DISP(Immed), TREG_NP(T0))

        SetArgContents(2, NO_REG);  // A2 is trashed
    }
    END_FRAGMENT

    OP_FRAGMENT(OperandMovToMem16B)
// 
// Routine Description:
// 
//     This is the inline mov16 fragment for unaligned moves
// 
// Arguments:
// 
//     a1 -- The destination of the move
//     a2 -- The value to be stored at 0(a1)
//
// Return Value:
// 
//     none
//
    ULONG Reg;
    USHORT Immed;

    if (fByteInstructionsOK) {
        // save 18-20 instructions
        if (Operand->Reg != NO_REG && Operand[-2].Type == OPND_ADDRREF) {
            Immed = (USHORT)Operand->Scale;
            if (((Immed+1) ^ Immed) & 0x8000) {
                //
                // Can't add the offset into the STB instructions due to
                // wraparound on Immed+1
                //
                LDA  (TREG, DISP(Immed), Operand->Reg)
                Immed=0;
                Reg = TREG;
            } else {
                Reg = Operand->Reg;
            }
        } else {
            Reg = AREG_NP(A1);
            Immed = 0;
        }

        STB     (AREG_NP(A2), DISP(Immed), Reg)
        SRL     (AREG_NP(A2), CNST(8), TREG_NP(T4))
        STB     (TREG_NP(T4), DISP(Immed+1), Reg)
    } else {
LABEL_DEC(l1)
LABEL_DEC(l2)
        if (Operand->Reg != NO_REG && Operand[-2].Type == OPND_ADDRREF) {
            Immed = (USHORT)Operand->Scale;
            Reg = Operand->Reg;
            if (Immed & 3) {
                //
                // Immed isn't DWORD-aligned, so add it in
                //
                LDA (AREG_NP(A1), Immed, Reg)
                Reg = AREG_NP(A1);
                Immed = 0;
            }
        } else {
            Reg = AREG_NP(A1);
            Immed = 0;
        }

        AND(Reg, CNST(3), TREG_NP(T1))
        BIC(Reg, CNST(3), TREG_NP(T0))
        AND(TREG_NP(T1), CNST(1), TREG_NP(T2))
        BNE_LABEL(TREG_NP(T2), FWD(l1))             // check for aligned

        //
        // code for doing an aligned 16 bit move
        //
        LDL(TREG_NP(T2), DISP(Immed), TREG_NP(T0))
        INSWL(AREG_NP(A2), TREG_NP(T1), TREG_NP(T4))
        MSKWL(TREG_NP(T2), TREG_NP(T1), AREG_NP(A2))
        BIS(AREG_NP(A2), TREG_NP(T4), TREG_NP(T2))
        STL(TREG_NP(T2), DISP(Immed), TREG_NP(T0))
        BR_LABEL(REG(AT), FWD(l2))

    //
    // code for doing an unaligned 16 bit move
    //
LABEL(l1)        
        if (((Immed+4) ^ Immed) & 0x8000) {
            //
            // Can't add the offset into the load/store instructions due to
            // wraparound on Immed+4
            //
            LDA (TREG_NP(T0), Immed, Reg)
            Immed=0;
        }
        LDL(TREG_NP(T2), DISP(Immed), TREG_NP(T0))
        INSWL(AREG_NP(A2), TREG_NP(T1), TREG_NP(T4))
        MSKWL(TREG_NP(T2), TREG_NP(T1), TREG_NP(T3))
        BIS(TREG_NP(T3), TREG_NP(T4), TREG_NP(T2))
        STL(TREG_NP(T2), DISP(Immed), TREG_NP(T0))
        ADDL(TREG_NP(T1), CNST(4), TREG_NP(T1))
        LDL(TREG_NP(T2), DISP(Immed+4), TREG_NP(T0))
        INSWH(AREG_NP(A2), TREG_NP(T1), TREG_NP(T4))
        MSKWH(TREG_NP(T2), TREG_NP(T1), TREG_NP(T3))
        BIS(TREG_NP(T3), TREG_NP(T4), TREG_NP(T2))
        STL(TREG_NP(T2), DISP(Immed+4), TREG_NP(T0))
LABEL(l2)        
GEN_CT(l1)
GEN_CT(l2)

        SetArgContents(2, NO_REG);  // A2 is trashed
    }

    END_FRAGMENT

    OP_FRAGMENT(OperandMovToReg)
// 
// Routine Description:
// 
//     This is the inline fragment for "mov reg, X"
// 
// Arguments:
// 
//     a1 -- The value to be stored at reg(RegPointer)
//
// Return Value:
// 
//     none
//
    ULONG Reg32;

    switch (Operand->Immed) {
    case OP_Mov32:
        STL(AREG_NP(A1), DISP(RegisterOffset[Operand->Reg]), REG(RegPointer))
        break;

    case OP_Mov16:
        if (fByteInstructionsOK) {
            // Save 3-4 instructions
            STW(AREG_NP(A1), DISP(RegisterOffset[Operand->Reg]), REG(RegPointer))
        } else {
            Reg32 = LookupRegInCache(Operand->Reg - GP_AX);
            if (Reg32 == NO_REG) {
                LDL(TREG_NP(T2), DISP(RegisterOffset[Operand->Reg]), REG(RegPointer))
                Reg32 = TREG_NP(T2);
            } else {
                //
                // The 32-bit x86 register containing the 16-bit register
                // Operand->Reg is cached.  Use that instead of reloading
                // from memory.
                //
                Reg32 = CACHEREG(Reg32);
            }
            INSWL(AREG_NP(A1), CNST(0), TREG_NP(T1))    // mask out hiword of A1
            MSKWL(Reg32, CNST(0), TREG_NP(T2))          // mask out loword of Reg32
            BIS(TREG_NP(T1), TREG_NP(T2), TREG_NP(T3))  // T3 = result
            STL(TREG_NP(T3), DISP(RegisterOffset[Operand->Reg]), REG(RegPointer))
        }
        break;

    case OP_Mov8:
        if (fByteInstructionsOK) {
            // Save 3-4 instructions
            STB(AREG_NP(A1), DISP(RegisterOffset[Operand->Reg]), REG(RegPointer))
        } else {
            if (Operand->Reg < GP_AH) {
                //
                // MOV to low-8 of reg
                //
                Reg32 = LookupRegInCache(Operand->Reg - GP_AL);
                if (Reg32 == NO_REG) {
                    LDL(TREG_NP(T2), DISP(RegisterOffset[Operand->Reg]), REG(RegPointer))
                    Reg32 = TREG_NP(T2);
                } else {
                    //
                    // The 32-bit x86 register containing the low-8 register
                    // Operand->Reg is cached.  Use that instead of reloading
                    // from memory.
                    //
                    Reg32 = CACHEREG(Reg32);
                }
                INSBL(AREG_NP(A1), CNST(0), TREG_NP(T1))    // mask out all but lobyte of A1
                MSKBL(Reg32, CNST(0), TREG_NP(T2))          // mask out lobyte of Reg32
                BIS(TREG_NP(T1), TREG_NP(T2), TREG_NP(T3))  // T3 = result
                STL(TREG_NP(T3), DISP(RegisterOffset[Operand->Reg]), REG(RegPointer))
            } else {
                //
                // MOV to high-8 of reg
                //
                Reg32 = LookupRegInCache(Operand->Reg - GP_AH);
                if (Reg32 == NO_REG) {
                    LDL(TREG_NP(T2), DISP(RegisterOffset[Operand->Reg] & ~3), REG(RegPointer))
                    Reg32 = TREG_NP(T2);
                } else {
                    //
                    // The 32-bit x86 register containing the high-8 register
                    // Operand->Reg is cached.  Use that instead of reloading
                    // from memory.
                    //
                    Reg32 = CACHEREG(Reg32);
                }
                INSBL(AREG_NP(A1), CNST(1), TREG_NP(T1))    // mask out all but lobyte of A1, shifted left 1 byte
                MSKBL(Reg32, CNST(1), TREG_NP(T2))          // mask out second-lowest byte of Reg32
                BIS(TREG_NP(T1), TREG_NP(T2), TREG_NP(T3))  // T3 = result
                STL(TREG_NP(T3), DISP(RegisterOffset[Operand->Reg] & ~3), REG(RegPointer))
            }
        }
        break;

    default:
        CPUASSERT(FALSE);   // Unknown OP_ constant for a MOV instruction
    }

    SetArgContents(1, Operand->Reg);
    END_FRAGMENT

    OP_FRAGMENT(OperandMovRegToReg32)
// 
// Routine Description:
// 
//     This is the inline mov32 fragment for "mov reg1, reg2"
// 
// Arguments:
// 
//     RegPointer - pointer to cpu data
//
// Return Value:
// 
//     none
//
    STL(CACHEREG(Operand->Reg), DISP(RegisterOffset[Operand->IndexReg]), REG(RegPointer))

    SetArgContents(0, Operand->IndexReg);

    END_FRAGMENT


    OP_FRAGMENT(OperandMovRegToReg16)
// 
// Routine Description:
// 
//     This is the inline mov16 fragment for "mov reg1, reg2"
// 
// Arguments:
// 
//     RegPointer - pointer to cpu data
//
// Return Value:
// 
//     none
//
    if (fByteInstructionsOK) {
        // save 3-4 instructions
        STW (CACHEREG(Operand->Reg), DISP(RegisterOffset[Operand->IndexReg]), RegPointer)
    } else {
        ULONG Reg32 = LookupRegInCache(Operand->IndexReg - GP_AX);

        if (Reg32 == NO_REG) {
            LDL(TREG_NP(T2), DISP(RegisterOffset[Operand->IndexReg]), REG(RegPointer))
            Reg32 = TREG_NP(T2);
        } else {
            Reg32 = CACHEREG(Reg32);
        }
        INSWL(CACHEREG(Operand->Reg), CNST(0), TREG_NP(T1)) // mask out hiword of CACHEREG
        MSKWL(Reg32, CNST(0), TREG_NP(T2))                  // mask out loword of Reg32
        BIS(TREG_NP(T1), TREG_NP(T2), TREG_NP(T3))          // T3 = result
        STL(TREG_NP(T3), DISP(RegisterOffset[Operand->IndexReg]), REG(RegPointer))
    }

    SetArgContents(0, Operand->IndexReg);

    END_FRAGMENT


    OP_FRAGMENT(OperandMovRegToReg8)
// 
// Routine Description:
// 
//     This is the inline mov8 fragment for "mov reg8low1, reg8low2"
// 
// Arguments:
// 
//     RegPointer - pointer to cpu data
//
// Return Value:
// 
//     none
//
    if (fByteInstructionsOK) {
        // save 3-4 instructions
        STB (CACHEREG(Operand->Reg), DISP(RegisterOffset[Operand->IndexReg]), RegPointer)
    } else {
        ULONG Reg32 = LookupRegInCache(Operand->IndexReg - GP_AL);

        if (Reg32 == NO_REG) {
            LDL(TREG_NP(T2), DISP(RegisterOffset[Operand->IndexReg]), REG(RegPointer))
            Reg32 = TREG_NP(T2);
        } else {
            Reg32 = CACHEREG(Reg32);
        }
        INSBL(CACHEREG(Operand->Reg), CNST(0), TREG_NP(T1))// mask out all but lobyte of A1
        MSKBL(Reg32, CNST(0), TREG_NP(T2))                 // mask out lobyte of Reg32
        BIS(TREG_NP(T1), TREG_NP(T2), TREG_NP(T3))         // T3 = result
        STL(TREG_NP(T3), DISP(RegisterOffset[Operand->IndexReg]), REG(RegPointer))
    }

    SetArgContents(0, Operand->IndexReg);

    END_FRAGMENT


    OP_FRAGMENT(OperandMovRegToReg8B)
// 
// Routine Description:
// 
//     This is the inline mov8 fragment for "mov reg8high, reg8low"
// 
// Arguments:
// 
//     RegPointer - pointer to cpu data
//
// Return Value:
// 
//     none
//
    if (fByteInstructionsOK) {
        // save 3-4 instructions
        STB (CACHEREG(Operand->Reg), DISP(RegisterOffset[Operand->IndexReg]), RegPointer)
    } else {
        ULONG Reg32 = LookupRegInCache(Operand->IndexReg - GP_AH);

        if (Reg32 == NO_REG) {
            LDL(TREG_NP(T2), DISP(RegisterOffset[Operand->IndexReg] & ~3), REG(RegPointer))
            Reg32 = TREG_NP(T2);
        } else {
            Reg32 = CACHEREG(Reg32);
        }
        INSBL(CACHEREG(Operand->Reg), CNST(1), TREG_NP(T1)) // mask out all but lobyte of A1, shifted left 1 byte
        MSKBL(Reg32, CNST(1), TREG_NP(T2))                  // mask out second-lowest byte of Reg32
        BIS(TREG_NP(T1), TREG_NP(T2), TREG_NP(T3))          // T3 = result
        STL(TREG_NP(T3), DISP(RegisterOffset[Operand->IndexReg] & ~3), REG(RegPointer))
    }

    SetArgContents(0, Operand->IndexReg);

    END_FRAGMENT


    OP_FRAGMENT(OperandImm)
// 
// Routine Description:
// 
//     This is the fragment that forms 32-bit immediate operands
// 
// Arguments:
// 
//     none
//
// Return Value:
// 
//     none
//
    USHORT High;
    USHORT Low;

    High = HIWORD(Operand->Immed);
    Low = LOWORD(Operand->Immed);

    if (Low || High == 0) {
        if (Low & 0x8000) {
            //
            // Account for sign-extension
            //
            High++;
        }
        if (High) {
            LDAH (AREG, High, REG(ZERO))
            LDA  (AREG, Low, AREG)
        } else {
            LDA  (AREG, Low, REG(ZERO))
        }

    } else {
        LDAH  (AREG, High, REG(ZERO))
    }
    SetArgContents(OperandNumber, NO_REG);

    END_FRAGMENT
        
        
    OP_FRAGMENT(OperandRegRef)
// 
// Routine Description:
// 
//     This is the fragment that forms register reference operand
// 
// Arguments:
// 
//     none
//
// Return Value:
// 
//     none
//
        
    LDA(AREG, DISP(RegisterOffset[Operand->Reg]), REG(RegPointer))
    SetArgContents(OperandNumber, NO_REG);
    SetArgContents(0, Operand->Reg);

    END_FRAGMENT
        
    OP_FRAGMENT(OperandRegVal)
//
// Routine Description:
// 
//     This is the fragment that forms register value operands for 32-bit
//     registers, 16-bit registers, and the low-8-bit registers (ie.
//     EAX, AX, and AL, but not AH).  All are DWORD aligned and there is
//     always an entire DWORD of memory, so there will be no faults.
// 
// Arguments:
// 
//     none
//
// Return Value:
// 
//     none
//
    if (GetArgContents(OperandNumber) != Operand->Reg) {
        DWORD RegCacheNum = LookupRegInCache(Operand->Reg);

        if (RegCacheNum == NO_REG) {
            if (Operand->Reg >= GP_AH) {
                if (fByteInstructionsOK) {
                    // Save 1 instruction
                    LDBU(AREG, DISP(RegisterOffset[Operand->Reg]), RegPointer)
                } else {
                    LDL(AREG, DISP(RegisterOffset[Operand->Reg] & ~3), REG(RegPointer))
                    EXTBL(AREG, CNST(RegisterOffset[Operand->Reg] & 3), AREG)
                }
            } else {
                //
                // Safe to load an entire DWORD for lowbyte or 16-bit
                // regs as they are DWORD-aligned and have an entire
                // DWORD of memory associated with them.
                //
                LDL(AREG, DISP(RegisterOffset[Operand->Reg]), REG(RegPointer))
            }
            SetArgContents(OperandNumber, Operand->Reg);
        } else {
            RegCacheNum = CACHEREG(RegCacheNum);
            if (Operand->Reg >= GP_AH) {
                EXTBL (RegCacheNum, CNST(1), AREG)
            } else {
                MOV (RegCacheNum, AREG)
            }
            SetArgContents(OperandNumber, NO_REG);
        }
    }
    
    END_FRAGMENT
    
    OP_FRAGMENT(LoadCacheReg)
//
// Routine Description:
// 
//     This fragment loads an argument register from a cached register,
//     saving a memory access.
// 
// Arguments:
// 
//     OperandNumber is overloaded to be the cached register number
//                   (0-n).  RegCache[OperandNumber] indicates which
//                   x86 32-bit register to load into the cache.
//
// Return Value:
// 
//     none
//
    DWORD CacheReg = CACHEREG(OperandNumber);
    DWORD x86Reg = RegCache[OperandNumber];

    if (GetArgContents(1) == x86Reg) {
        MOV (AREG_NP(A1), CacheReg)
    } else if (GetArgContents(2) == x86Reg) {
        MOV (AREG_NP(A2), CacheReg)
    } else {
        LDL(CacheReg, DISP(RegisterOffset[x86Reg]), REG(RegPointer))
    }
    END_FRAGMENT


ULONG GenOperandAddr(
    PULONG CodeLocation,
    POPERAND Operand,
    ULONG OperandNumber,
    ULONG FsOverride
    )
// 
// Routine Description:
// 
//     This function generates code for OPND_ADDRVALUE8/16/32 and OPND_ADDRREF
//     operands.
// 
// Arguments:
// 
//     CodeLocation -- address to store generated code to
//     Operand      -- operand to generate code for
//     OperandNumber-- operand number (may be 1 through 3)
//     FsOverride   -- TRUE if the current instruction has an FS: prefix
//
// Return Value:
// 
//     none.  LOWORD(Operand->Immed) is left for the generator
//            function for OPND_MOVTOMEM to load.
//
{
    ULONG r1;
    ULONG r2;
    ULONG r3;
    ULONG r4;
    ULONG r5;
    ULONG r6;

    START_FRAGMENT;

#if DBG
    // initialize all register variables to a known bogus register
    r1 = r2 = r3 = r4 = r5 = r6 = 31;
#endif
    if (Operand->Immed & 0x8000) {
        USHORT HiWord;
        //
        // The loword of Operand->Immed has its sign bit set.
        // The loword is always loaded, sign-extended, and added
        // to the hiword, so adjust the hiword to account for the
        // sign extension.
        //
        HiWord = (USHORT)(Operand->Immed >> 16) + 1;
        Operand->Immed = (HiWord << 16) | (Operand->Immed & 0xffff);
    }

    if (Operand->Reg == NO_REG) {
        r1 = NO_REG;
    } else if (GetArgContents(OperandNumber) == Operand->Reg) {
        //
        // Operand->Reg is still in AREG, as a leftover from a
        // previous MOV instruction.
        //
        r1 = AREG;
    } else {
        r1 = LookupRegInCache(Operand->Reg);
        if (r1 == NO_REG) {
            r1 = AREG;
            LDL (r1, DISP(RegisterOffset[Operand->Reg]), RegPointer)
        } else {
            r1 = CACHEREG(r1);
        }
    }
    // r1 = BaseReg
    // r1 can be NO_REG, RegCacheX, or AREG

    if (Operand->IndexReg == NO_REG) {
        r2 = NO_REG;
    } else if (r1 != AREG && GetArgContents(OperandNumber) == Operand->IndexReg) {
        //
        // Operand->IndexReg is still in AREG, as a leftover from a
        // previous MOV instruction.
        //
        r2 = AREG;
    } else {
        r2 = LookupRegInCache(Operand->IndexReg);
        if (r2 == NO_REG) {
            if (r1 == AREG) {
                r2 = TREG;
            } else {
                r2 = AREG;
            }
            LDL (r2, DISP(RegisterOffset[Operand->IndexReg]), RegPointer)
        } else {
            r2 = CACHEREG(r2);
        }
    }
    // r2 = IndexReg
    // r2 can be NO_REG, RegCacheX, AREG, or TREG

    if (r1 == NO_REG && r2 == NO_REG) {
        r3 = NO_REG;
    } else if (r1 == NO_REG && r2 != NO_REG) {
        if (r2 != AREG) {
            r3 = AREG;  // r2 isn't AREG so it must be RegCacheX
        } else {
            r3 = r2;
        }
        switch (Operand->Scale) {
        case 1:
            SLL (r2, CNST(1), r3)
            break;

        case 2:
            S4ADDL (r2, CNST(0), r3)
            break;

        case 3:
            S8ADDL (r2, CNST(0), r3)
            break;

        default:
            r3 = r2;  // this is safe even when r2 is RegCacheX
        }
    } else if (r1 != NO_REG && r2 == NO_REG) {
        r3 = r1;
    } else {
        r3 = AREG;
        switch (Operand->Scale) {
        case 1:
            SLL (r2, CNST(1), TREG)
            ADDL (TREG, r1, r3)
            break;

        case 2:
            S4ADDL (r2, r1, r3)
            break;

        case 3:
            S8ADDL (r2, r1, r3)
            break;

        default:
            ADDL (r2, r1, r3)
            break;
        }
    }
    // r3 = BaseReg + Scale*IndexReg
    // r3 can be NO_REG, RegCacheX, AREG, but not TREG
    // r2 is dead
    // r1 is dead

    if (r3 == NO_REG) {
        r3 = REG(ZERO);
    }
    if (HIWORD(Operand->Immed)) {
        r4 = AREG;
        if ((Operand->Immed & 0x80000000) && r3 != REG(ZERO)) {
            //
            // High-bit is set in the immediate value and there is a
            // "BaseReg + Scale*IndexReg" portion of the address.  In that
            // case, we cannot use "LDAH (r4, HIWORD, r3)" as it will
            // cause the top 32 bits of r4 to be set.
            //
            LDAH (TREG, HIWORD(Operand->Immed), REG(ZERO))
            ADDL (TREG, r3, r4) // add in just 32 bits
        } else {
            LDAH (r4, HIWORD(Operand->Immed), r3)
        }
    } else {
        r4 = r3;
    }
    // r4 = BaseReg + Scale*IndexReg + HIWORD(Immed)
    // r4 is REG(ZERO), RegCacheX, or AREG, but not NO_REG or TREG
    // r3 is dead
    // r2 is dead
    // r1 is dead

    if (FsOverride) {
        RDTEB       // v0 = teb
        r5 = V0;
        // r5 = pteb

        if (r4 != REG(ZERO)) {
            r6 = AREG;
            ADDL (r5, r4, r6)
        } else {
            r6 = r5;
        }
    } else {
        r6 = r4;
    }
    // r6 is [FS:] BaseReg + Scale*IndexReg + Immed
    // r6 can be REG(ZERO), RegCacheX, or AREG, but *not* NO_REG or TREG
    // r5..r1 are dead

    if (r6 == REG(ZERO)) {
        //
        // The sum total of all this work is that the value of interest
        // is exactly 0.  Load a 0 into AREG.
        //
        r6 = AREG;
        MOV (REG(ZERO), r6)
    }
    // r6 is [FS:] BaseReg + Scale*IndexReg + Immed
    // r6 can be RegCacheX, or AREG, but *not* TREG, NO_REG or REG(ZERO)
    // r5..r1 are dead

    switch (Operand->Type) {
    case OPND_ADDRVALUE32:
        if (Operand->Alignment == ALIGN_DWORD_ALIGNED) {
            LDL (AREG, LOWORD(Operand->Immed), r6);
        } else {
            USHORT Offset;
            USHORT OffsetOfLastByte;
LABEL_DEC(l1)
LABEL_DEC(l2)

            Offset = LOWORD(Operand->Immed);
            OffsetOfLastByte = Offset+3;
            if ((Offset & 7) || (Offset ^ OffsetOfLastByte) & 0x8000) {
                //
                // Offset is unaligned or Offset+3 can't be represented as a
                // sign-extended 16-bit quantity.  Add in the offset now.
                //
                LDA (AREG, Offset, r6);
                Offset = 0;
                r6 = AREG;
            }

            AND(r6, CNST(3), TREG3)
            BNE_LABEL(TREG3, FWD(l1))       // brif not DWORD aligned

            LDL(AREG, DISP(Offset), r6)
            BR_LABEL(REG(AT), FWD(l2))

LABEL(l1)
            // Note: This is faster than the 9-instruction sequence using
            //       LDBU, so use the same code even if fByteInstructionsOK.
            LDQ_U(TREG, DISP(Offset), r6)
            EXTLL(TREG, r6, TREG1)
            LDQ_U(TREG, DISP(Offset+3), r6)
            EXTLH(TREG, r6, TREG2)
            BIS(TREG1, TREG2, AREG)
LABEL(l2)
GEN_CT(l1)
GEN_CT(l2)
        }
        break;

    case OPND_ADDRVALUE16:
        if (Operand->Alignment == ALIGN_DWORD_ALIGNED) {
            LDL (AREG, DISP(LOWORD(Operand->Immed)), r6)
        } else if (Operand->Alignment == ALIGN_WORD_ALIGNED) {
            if (fByteInstructionsOK) {
                LDWU (AREG, DISP(Operand->Immed), r6);
            } else {
                if (LOWORD(Operand->Immed)) {
                    LDA   (AREG, DISP(Operand->Immed), r6)
                    r6 = AREG;
                }
                LDQ_U (TREG, 0, r6)
                EXTWL(TREG, r6, AREG)
            }
        } else {
            USHORT Offset;
            USHORT OffsetOfLastByte;

            Offset = LOWORD(Operand->Immed);
            OffsetOfLastByte = Offset+1;

            if (fByteInstructionsOK) {
                if ((Offset ^ OffsetOfLastByte) & 0x8000) {
                    //
                    // Offset+1 can't be represented as a sign-extended
                    // 16-bit quantity.  Add in the offset now.
                    //
                    LDA (AREG, Offset, r6);
                    Offset = 0;
                    r6 = AREG;
                }
                LDBU (TREG3, DISP(Offset+1), r6)
                LDBU (AREG, DISP(Offset), r6)
                INSBL (TREG3, CNST(1), TREG3)
                BIS (TREG3, AREG, AREG)
            } else {
LABEL_DEC(l1)
LABEL_DEC(l2)

                if ((Offset & 7) || (Offset ^ OffsetOfLastByte) & 0x8000) {
                    //
                    // Offset is unaligned or Offset+1 can't be represented as a
                    // sign-extended 16-bit quantity.  Add in the offset now.
                    //
                    LDA (AREG, Offset, r6);
                    Offset = 0;
                    r6 = AREG;
                }

                AND(r6, CNST(1), TREG3)
                BNE_LABEL(TREG3, FWD(l1))       // brif not DWORD aligned

                LDQ_U(TREG, DISP(Offset), r6)
                EXTWL(TREG, r6, AREG)
                BR_LABEL(REG(AT), FWD(l2))

LABEL(l1)
                LDQ_U(TREG, DISP(Offset), r6)
                EXTWL(TREG, r6, TREG1)
                LDQ_U(TREG, DISP(Offset+1), r6)
                EXTWH(TREG, r6, TREG2)
                BIS(TREG1, TREG2, AREG)
LABEL(l2)
GEN_CT(l1)
GEN_CT(l2)
            }
        }
        break;

    case OPND_ADDRVALUE8:
        if (Operand->Alignment == ALIGN_DWORD_ALIGNED) {
            LDL (AREG, DISP(Operand->Immed), r6);
        } else if (fByteInstructionsOK) {
            LDBU (AREG, DISP(Operand->Immed), r6)
        } else {
            if (LOWORD(Operand->Immed)) {
                LDA   (AREG, DISP(Operand->Immed), r6)
                r6 = AREG;
            }
            LDQ_U (TREG, 0, r6)
            EXTBL (TREG, r6, AREG)
        }
        break;

    case OPND_ADDRREF:
        if (OperandNumber == 1 && Operand[2].Type == OPND_MOVTOMEM) {
            //
            // Communicate forward to the MOVTOMEM operand that
            // the destination address is in r6 and that the low 16
            // bits of the immediate are not loaded yet.
            //
            Operand[2].Reg = r6;
            Operand[2].Scale = LOWORD(Operand->Immed);
            break;
        } else if (LOWORD(Operand->Immed)) {
            LDA (AREG, LOWORD(Operand->Immed), r6)
        } else if (r6 != AREG) {
            //
            // A register reallocation could clean this up later...
            //
            MOV (r6, AREG)
        }
        break;

    default:
        CPUASSERT(FALSE);   // unknown OPND_ type
    }

    //
    // Indicate that the arg reg does not contain a register.  This
    // is not true for ADDRREF where there is only a Reg or an IndexReg
    // with no scale.  In that case, subsequent MOV instructions will
    // reload the reg from memory, which is slower, but correct.
    //
    SetArgContents(OperandNumber, NO_REG);

END_FRAGMENT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\cpu\axp64\codesize.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    codesize.h

Abstract:

    This module contains constants associated with the generated code

Author:

    Dave Hastings (daveh) creation-date 25-Jan-1996

Revision History:


--*/

//
// These are all # of instructions (dwords)
//
#define JumpToNextCompilationUnit_SIZE 5
#define CallDirect_SIZE 12
#define CallfDirect_SIZE 12
#define EndCompilationUnit_SIZE 3

#define CallJxx_PATCHRA_OFFSET 6
#define CallJxxSlow_PATCHRA_OFFSET 6
#define CallJxxFwd_PATCHRA_OFFSET 6
#define CallJmpDirect_PATCHRA_OFFSET 5
#define CallJmpDirectSlow_PATCHRA_OFFSET 5
#define CallJmpFwdDirect_PATCHRA_OFFSET 5
#define CallJmpfDirect_PATCHRA_OFFSET 3
#define CallDirect_PATCHRA_OFFSET 3
#define CallfDirect_PATCHRA_OFFSET 3
#define CallDirect2_PATCHRA_OFFSET 5
#define CallfDirect2_PATCHRA_OFFSET 5
#define CallIndirect_PATCHRA_OFFSET 3
#define CallfIndirect_PATCHRA_OFFSET 3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\cpu\axp64\codegen.h ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    codegen.h

Abstract:

    This include file defines the macros for the first pass of cpp over
    codeseq.txt (see codegen.c).

Author:

    Dave Hastings (daveh) creation-date 12-Jan-1996

Revision History:

            24-Aug-1999 [askhalid] copied from 32-bit wx86 directory and make work for 64bit.
            20-Sept-1999[barrybo]  added FRAG2REF(LockCmpXchg8bFrag32, ULONGLONG)


--*/

//
// Shift values for building operate instructions
//
#define RA_SHIFT    21
#define RBLIT_SHIFT 12
#define RB_SHIFT    16

//
// Macro which places an Alpha instruction at a specified address
//
#define GEN_INSTR(location, instr) {    \
    PULONG d = location;                \
    instr                               \
    }


//
// This macro forms the opcodes for AXP instructions.  For instructions without
// function codes, a function code of zero should be supplied
//
#define MAKE_OPCODE(op, fn)             (((ULONG)fn << 5) | ((ULONG)op << 26))

#define ADDL_OPCODE     MAKE_OPCODE(0x10, 0x00)
#define AND_OPCODE      MAKE_OPCODE(0x11, 0x00)
#define BEQ_OPCODE      MAKE_OPCODE(0x39, 0x00)
#define BIC_OPCODE      MAKE_OPCODE(0x11, 0x08)
#define BIS_OPCODE      MAKE_OPCODE(0x11, 0x20)
#define BNE_OPCODE      MAKE_OPCODE(0x3D, 0x00)
#define BR_OPCODE       MAKE_OPCODE(0x30, 0x00)
#define CMOVNE_OPCODE   MAKE_OPCODE(0x11, 0x26)
#define CMPEQ_OPCODE    MAKE_OPCODE(0x10, 0x2d)
#define EQV_OPCODE      MAKE_OPCODE(0x11, 0x48)
#define EXTBL_OPCODE    MAKE_OPCODE(0x12, 0x06)
#define EXTLH_OPCODE    MAKE_OPCODE(0x12, 0x6A)
#define EXTLL_OPCODE    MAKE_OPCODE(0x12, 0x26)
#define EXTWH_OPCODE    MAKE_OPCODE(0x12, 0x5A)
#define EXTWL_OPCODE    MAKE_OPCODE(0x12, 0x16)
#define INSBL_OPCODE    MAKE_OPCODE(0x12, 0x0B)
#define INSLH_OPCODE    MAKE_OPCODE(0x12, 0x67)
#define INSLL_OPCODE    MAKE_OPCODE(0x12, 0x2B)
#define INSWH_OPCODE    MAKE_OPCODE(0x12, 0x57)
#define INSWL_OPCODE    MAKE_OPCODE(0x12, 0x1B)
#define JMP_OPCODE      (0x1a << 26)
#define JSR_OPCODE      (0x1a << 26) | 0x4000
#define LDA_OPCODE      MAKE_OPCODE(0x08, 0x00)
#define LDAH_OPCODE     MAKE_OPCODE(0x09, 0x00)
#define LDBU_OPCODE     MAKE_OPCODE(0x0a, 0x00) // Check PF_ALPHA_BYTE_INSTRUCTIONS first
#define LDWU_OPCODE     MAKE_OPCODE(0x0c, 0x00) // Check PF_ALPHA_BYTE_INSTRUCTIONS first
#define LDL_OPCODE      MAKE_OPCODE(0x28, 0x00)
#define LDQ_U_OPCODE    MAKE_OPCODE(0x0B, 0x00)
#define MSKBL_OPCODE    MAKE_OPCODE(0x12, 0x02)
#define MSKLH_OPCODE    MAKE_OPCODE(0x12, 0x62)
#define MSKLL_OPCODE    MAKE_OPCODE(0x12, 0x22)
#define MSKWH_OPCODE    MAKE_OPCODE(0x12, 0x52)
#define MSKWL_OPCODE    MAKE_OPCODE(0x12, 0x12)
#define S4ADDL_OPCODE   MAKE_OPCODE(0x10, 0x02)
#define S8ADDL_OPCODE   MAKE_OPCODE(0x10, 0x12)
#define SEXTB_OPCODE    MAKE_OPCODE(0x1c, 0x00) // Check PF_ALPHA_BYTE_INSTRUCTIONS first
#define SEXTW_OPCODE    MAKE_OPCODE(0x1c, 0x01) // Check PF_ALPHA_BYTE_INSTRUCTIONS first
#define SLL_OPCODE      MAKE_OPCODE(0x12, 0x39)
#define SRA_OPCODE      MAKE_OPCODE(0x12, 0x3c)
#define SRL_OPCODE      MAKE_OPCODE(0x12, 0x34)
#define STB_OPCODE      MAKE_OPCODE(0x0e, 0x00) // Check PF_ALPHA_BYTE_INSTRUCTIONS first
#define STW_OPCODE      MAKE_OPCODE(0x0d, 0x00) // Check PF_ALPHA_BYTE_INSTRUCTIONS first
#define STL_OPCODE      MAKE_OPCODE(0x2c, 0x00)
#define STQ_U_OPCODE    MAKE_OPCODE(0x0F, 0x00)
#define SUBL_OPCODE     MAKE_OPCODE(0x10, 0x09)
#define XOR_OPCODE      MAKE_OPCODE(0x11, 0x40)
#define ZAP_OPCODE      MAKE_OPCODE(0x12, 0x30)
#define ZAPNOT_OPCODE   MAKE_OPCODE(0x12, 0x31)

//
// Register numbers
//
#define A0  0
#define A1  1
#define A2  2
#define A3  3
#define A4  4
#define AT  28
#define RA  26
#define SP  30
#define T0  0
#define T1  1
#define T2  2
#define T3  3
#define T4  4
#define V0  0
#define ZERO 31

//          AREG is replaced with the correct argument register for operand
//          fragments
//          
//          TREG(<tn>) is replaced with the appropriate temporary register for
//          the argument number in operand fragments
//          
//          AREG_NP(<an>)/TREG_NP(<tn>) is the specified argument/temp register.
//          (_NP stands for no patch)
//
//          REG() specifies a register
//      
//          CNST() specifies a constant.  Since operate instructions can
//          take either a register or a constant, and have different encodings,
//          we diddle some bits in the constant so we can distinguish it from
//          a register
//
//          DISP() is a 16 bit displacement
//          
//          CFUNC_LOW() is the low 16 bits of a 32 bit constant
//          CFUNC_HIGH() is the high 16 bits of the constant, adjusted
//          for sign extension (see the lda/ldah instructions)
//
//          BDISP() is a branch displacement the argment is the destination
//          of the branch
//
//          JHINT() is a jmp hint.  The argument is the destination.

#define CNST(lit)       ((lit & 0xFF) | 0x100)
#define DISP(d)         (d & 0xFFFF)
#define BDISP(d)        (((ULONG)(ULONGLONG)(d) >> 2) & 0x1FFFFF)
#define FWD(l)          l
#define CFUNC_LOW(name) (((ULONG)(ULONGLONG)name) & 0xFFFF)  
#define CFUNC_HIGH(name) (((ULONG)(ULONGLONG)name) & 0x8000 ? ((((ULONG)(ULONGLONG)name + 0x10000) & 0xFFFF0000) >> 16) : ((ULONG) (ULONGLONG)name & 0xFFFF0000) >> 16)  
#define JHINT(name)     ((((ULONG)(ULONGLONG)name-(ULONG)(ULONGLONG)d) >> 2) & 0x3FFF)   

#define REG(r)          r
#define AREG_NP(r)      (RegArg0+r)
#define TREG_NP(t)      (RegTemp0+t)
#define AREG            (RegArg0+OperandNumber)
#define TREG            (RegTemp0+OperandNumber-1)
#define TREG1           (RegTemp3+OperandNumber-1)
#define TREG2           ((OperandNumber < 3) ? RegTemp6+OperandNumber-1: RegTemp6)
#define TREG3           ((OperandNumber < 3) ? RegTemp8+OperandNumber-1: RegTemp8)
#define TREG4           ((OperandNumber < 3) ? RegTemp10+OperandNumber-1: RegTemp10)
#define CACHEREG(r)     (RegCache0+r)

//
// This macro formats the Rb/literal bits for operate instructions, including
// the register/literal selection bit (bit 12)
//
// For Operate instructions, bits 12 - 20 have different meanings, depending
// on whether they refer to an immediate or a register.  So that we don't 
// have to have two different instructions, the CNST macro will insure that
// bits outside the range of a LIT are set.
//
#define FORM_RBORLIT(val)                                       \
    (((USHORT)(val) > 0xFF) ? (((val) & 0xFF) << 1) | 1         \
                           : ((val) & 0x1F) << 4)

//
// Instruction macros
//

#define OPERATE_INSTR(opcode, r1, r2, r3)                               \
    *d = opcode | (r1 << RA_SHIFT) | (FORM_RBORLIT(r2) << RBLIT_SHIFT) | (r3);  \
    d++;
  
#define MEMORY_INSTR(opcode, r1, disp, r2)                              \
    *d = opcode | (r1 << RA_SHIFT) | (r2 << RB_SHIFT) | (disp);         \
    d++;
    
#define BRANCH_INSTR(opcode, r, disp)           \
    *d = opcode | ((r) << RA_SHIFT) | (disp);\
    d++;

#define BRANCH_INSTR_LABEL(opcode, r, l)        \
    l##CtInstruction = opcode | (r << RA_SHIFT);\
    l##CtInstrLocation = (PCHAR)d;              \
    d++;

//
// This is the equivalent of calling DebugBreak() from the Translation
// Cache.  Great for breaking into the debugger when a particular fragment
// is hit.  It is really 'lda v0, 16(zero) / callkd'
//
#define DEBUGBREAK                              \
    *d = 0x201f0016; d++; *d = 0xad; d++;

#define ADDL(r1, r2, r3)                        \
    OPERATE_INSTR(ADDL_OPCODE, r1, r2, r3)
    
#define AND(r1, r2, r3)                         \
    OPERATE_INSTR(AND_OPCODE, r1, r2, r3)
    
#define BEQ(r, d)                               \
    BRANCH_INSTR(BEQ_OPCODE, r, d)
    
#define BEQ_LABEL(r, l)                         \
    BRANCH_INSTR_LABEL(BEQ_OPCODE, r, l)
    
#define BIC(r1, r2, r3)                         \
    OPERATE_INSTR(BIC_OPCODE, r1, r2, r3)
        
#define BIS(r1, r2, r3)                         \
    OPERATE_INSTR(BIS_OPCODE, r1, r2, r3)
    
#define BNE(r, d)                               \
    BRANCH_INSTR(BNE_OPCODE, r, d)
    
#define BNE_LABEL(r, l)                         \
    BRANCH_INSTR_LABEL(BNE_OPCODE, r, l)
    
#define BR(r, disp)                             \
    BRANCH_INSTR(BR_OPCODE, r, disp)
    
#define BR_LABEL(r, l)                          \
    BRANCH_INSTR_LABEL(BR_OPCODE, r, l)
    
#define CMOVNE(r1, r2, r3)                      \
    OPERATE_INSTR(CMOVNE_OPCODE, r1, r2, r3)

#define CMPEQ(r1, r2, r3)                       \
    OPERATE_INSTR(CMPEQ_OPCODE, r1, r2, r3)

#define EQV(r1, r2, r3)                         \
    OPERATE_INSTR(EQV_OPCODE, r1, r2, r3)

#define EXTBL(r1, r2, r3)                       \
    OPERATE_INSTR(EXTBL_OPCODE, r1, r2, r3)

#define EXTLH(r1, r2, r3)                       \
    OPERATE_INSTR(EXTLH_OPCODE, r1, r2, r3)

#define EXTLL(r1, r2, r3)                       \
    OPERATE_INSTR(EXTLL_OPCODE, r1, r2, r3)

#define EXTWH(r1, r2, r3)                       \
    OPERATE_INSTR(EXTWH_OPCODE, r1, r2, r3)

#define EXTWL(r1, r2, r3)                       \
    OPERATE_INSTR(EXTWL_OPCODE, r1, r2, r3)

#define INSBL(r1, r2, r3)                       \
    OPERATE_INSTR(INSBL_OPCODE, r1, r2, r3)
    
#define INSLH(r1, r2, r3)                       \
    OPERATE_INSTR(INSLH_OPCODE, r1, r2, r3)
    
#define INSLL(r1, r2, r3)                       \
    OPERATE_INSTR(INSLL_OPCODE, r1, r2, r3)
    
#define INSWH(r1, r2, r3)                       \
    OPERATE_INSTR(INSWH_OPCODE, r1, r2, r3)
    
#define INSWL(r1, r2, r3)                       \
    OPERATE_INSTR(INSWL_OPCODE, r1, r2, r3)
    
#define JMP(r1, r2, hint)                       \
    MEMORY_INSTR(JMP_OPCODE, r1, hint, r2)
    
#define JSR(r1, r2, hint)                       \
    MEMORY_INSTR(JSR_OPCODE, r1, hint, r2)
    
#define LDA(r1, disp, r2)                       \
    MEMORY_INSTR(LDA_OPCODE, r1, disp, r2)
    
#define LDAH(r1, disp, r2)                      \
    MEMORY_INSTR(LDAH_OPCODE, r1, disp, r2)

#define LDBU(r1, disp, r2)                      \
    MEMORY_INSTR(LDBU_OPCODE, r1, disp, r2)
    
#define LDWU(r1, disp, r2)                      \
    MEMORY_INSTR(LDWU_OPCODE, r1, disp, r2)
    
#define LDL(r1, disp, r2)                       \
    MEMORY_INSTR(LDL_OPCODE, r1, disp, r2)
    
#define LDQ_U(r1, disp, r2)                     \
    MEMORY_INSTR(LDQ_U_OPCODE, r1, disp, r2)
    
#define MOV(r1, r2)                             \
    BIS(r1, r1, r2)
    
#define MSKBL(r1, r2, r3)                       \
    OPERATE_INSTR(MSKBL_OPCODE, r1, r2, r3)

#define MSKLH(r1, r2, r3)                       \
    OPERATE_INSTR(MSKLH_OPCODE, r1, r2, r3)

#define MSKLL(r1, r2, r3)                       \
    OPERATE_INSTR(MSKLL_OPCODE, r1, r2, r3)

#define MSKWH(r1, r2, r3)                       \
    OPERATE_INSTR(MSKWH_OPCODE, r1, r2, r3)

#define MSKWL(r1, r2, r3)                       \
    OPERATE_INSTR(MSKWL_OPCODE, r1, r2, r3)
    
#define NOP                                     \
    BIS(REG(31), REG(31), REG(31))

#define S4ADDL(r1, r2, r3)                      \
    OPERATE_INSTR(S4ADDL_OPCODE, r1, r2, r3)
    
#define S8ADDL(r1, r2, r3)                      \
    OPERATE_INSTR(S8ADDL_OPCODE, r1, r2, r3)

#define SEXTB(r1, r2)                           \
    OPERATE_INSTR(SEXTB_OPCODE, REG(31), r1, r2)
    
#define SEXTW(r1, r2)                           \
    OPERATE_INSTR(SEXTW_OPCODE, REG(31), r1, r2)
    
#define SLL(r1, r2, r3)                         \
    OPERATE_INSTR(SLL_OPCODE, r1, r2, r3)

#define SRA(r1, r2, r3)                         \
    OPERATE_INSTR(SRA_OPCODE, r1, r2, r3)
    
#define SRL(r1, r2, r3)                         \
    OPERATE_INSTR(SRL_OPCODE, r1, r2, r3)
    
#define STB(r1, disp, r2)                       \
    MEMORY_INSTR(STB_OPCODE, r1, disp, r2)

#define STW(r1, disp, r2)                       \
    MEMORY_INSTR(STW_OPCODE, r1, disp, r2)

#define STL(r1, disp, r2)                       \
    MEMORY_INSTR(STL_OPCODE, r1, disp, r2)

#define STQ_U(r1, disp, r2)                     \
    MEMORY_INSTR(STL_OPCODE, r1, disp, r2)

#define SUBL(r1, r2, r3)                        \
    OPERATE_INSTR(SUBL_OPCODE, r1, r2, r3)

#define XOR(r1, r2, r3)                         \
    OPERATE_INSTR(XOR_OPCODE, r1, r2, r3)

#define ZAP(r1, r2, r3)                         \
    OPERATE_INSTR(ZAP_OPCODE, r1, r2, r3)

#define ZAPNOT(r1, r2, r3)                      \
    OPERATE_INSTR(ZAPNOT_OPCODE, r1, r2, r3)

// This was stolen from sdk\inc\alphaops.h:
#define RDTEB                                   \
    *d = 0xab;                                  \
    d++;
    
#define LABEL_DEC(l)                            \
    PCHAR   l##CtInstrLocation;                 \
    PCHAR   l##CtDest;                          \
    ULONG   l##CtInstruction;                   \

#define INDEX_SCALE(r1, r2, r3)                 \
    if (Operand->Scale == 0) {                  \
        CPUASSERTMSG(FALSE, "Scale of 0");      \
    } else if (Operand->Scale == 1) {           \
        SLL(r1, CNST(Operand ->Scale), AT)      \
        ADDL(AT, r2, r3)                        \
    } else if (Operand->Scale == 2) {           \
        S4ADDL(r1, r2, r3)                      \
    } else if (Operand->Scale == 3) {           \
        S8ADDL(r1, r2, r3)                      \
    } else {                                    \
        CPUASSERTMSG(FALSE, "Unknown scale");   \
    }

#define LABEL(l)                                \
    l##CtDest = (PCHAR)d;

//
// In the following displacement calculation, 1 is added to the location
// of the branch instruction because the processor updates PC before 
// adding the displacement to determine the new PC.  We save the location
// of the branch instruction rather than the following instruction, so 
// we have to simulate the behavior here.
//
#define GEN_CT(l)                               \
    * (PULONG)l##CtInstrLocation = (ULONG) (l##CtInstruction |   \
        (((l##CtDest - (l##CtInstrLocation + 4)) >> 2) & 0x1FFFFF));

ULONG
GetCurrentECU(
    PULONG CodeLocation
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\cpu\axp64\ementry.s ===
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//    ementry.s
//
// Abstract:
//
//    This module contains the code fragments for entering and exiting the
//    translated code.
//
// Author:
//
//    Dave Hastings (daveh) creation-date 05-Jan-1996
//      from ..\mips\ementry.s
//
// Revision History:
//
#include "kxalpha.h"
#include "soalpha.h"
#include "cpunotif.h"

#define FRAMESIZE 0x50
#if (FRAMESIZE & f) != 0
    #error FRAMESIZE must be 16-byte aligned
#endif
#define StRa      FRAMESIZE-8
#define StS0      FRAMESIZE-0x10
#define StS1      FRAMESIZE-0x18
#define StS2      FRAMESIZE-0x20
#define StS3      FRAMESIZE-0x28
#define StS4      FRAMESIZE-0x30
#define StS5      FRAMESIZE-0x38


        .globl StartTranslatedCode
        .ent StartTranslatedCode, 0;
StartTranslatedCode:
// Routine Description:
//
//    This routine sets up the registers to run the translated code fragments.
//
// Arguments:
//
//    A0 - Supplies a pointer to the state for this thread
//    A1 - Supplies the native address to start executing at
//
// Return Value:
//
//    return-value - Description of conditions needed to return value. - or -
//    None.
//
        .frame sp, FRAMESIZE, zero

        //
        // Make space on the stack to save stuff
        //
        lda    sp, -FRAMESIZE(sp)
        //
        // Save the registers we will be using in the translated code
        //
        stq     ra, StRa(sp)
        stq     RegPointer, StS0(sp)
        stq     RegEip, StS1(sp)
        stq     RegProcessCpuNotify, StS2(sp)
        stq     s3, StS3(sp)
        stq     s4, StS4(sp)
        stq     s5, StS5(sp)

        .prologue 1;
        .globl StartTranslatedCodePrologEnd
StartTranslatedCodePrologEnd:        
        //
        // Set up the register pointer and Eip, and
        // Transfer control to actual translated code
        // (remember the delay slot)
        //
        mov     a0, RegPointer

        ldl     RegEip, Eip(a0)
        lda     RegProcessCpuNotify, ProcessCpuNotify
        jmp     ra, (a1)

        //
        // The NT exception-handling code *requires* that the instruction
        // following the 'jmp a1' is contained within the StartTranslatedCode()
        // function, and not an instruction in a subsequent function.
        //
        nop
        .set reorder
        .end StartTranslatedCode
        
#ifdef MSCPU
        //
        // This function is not included in the wx86tc.dll build
        //

        FRAGMENT(EndTranslatedCode)
//
//
// Routine Description:
//
//    This routine flushes Eip to the thread registers, and restores 
//    the contents of the registers we have to preserve
//
// Arguments:
//
//    None.
//    
// Return Value:
//
//    None.
        
        //
        // Restore registers and return
        // (remember the delay slot)
        //
        ldq     ra, StRa(sp)
        ldq     RegPointer, StS0(sp)
        ldq     RegEip, StS1(sp)
        ldq     RegProcessCpuNotify, StS2(sp)
        ldq     s3, StS3(sp)
        ldq     s4, StS4(sp)
        ldq     s5, StS5(sp)
       
        addq    sp, FRAMESIZE, sp
        jmp     zero, (ra)
        END_FRAGMENT(EndTranslatedCode)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\cpu\axp64\opt.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    opt.h

Abstract:

    Defines the interface to the native-code optimizer.

Author:

    Barry Bond (barrybo) creation-date 23-Sept-1996

Revision History:


--*/

#ifndef _OPT_H_
#define _OPT_H_

typedef enum _FixupType {
    LoadEPLow,
    LoadEPHigh,
    BranchEP,
    ECUEP
} FIXUPTYPE;

typedef struct _FixupInfo {
    PULONG FixupInstr;
    FIXUPTYPE Type;
    PENTRYPOINT EntryPoint;
} FIXUPINFO, *PFIXUPINFO;

//
// The worst-case fragment contains 7 fixups
//
#define MAX_FIXUP_COUNT (MAX_INSTR_COUNT*7)

extern FIXUPINFO FixupInfo[MAX_FIXUP_COUNT];
extern ULONG FixupCount;

#define GEN_FIXUP(T, EP)        {               \
    if (fCompiling) {                           \
        CPUASSERT(FixupCount < MAX_FIXUP_COUNT);\
        FixupInfo[FixupCount].FixupInstr = d;   \
        FixupInfo[FixupCount].Type = T;         \
        FixupInfo[FixupCount].EntryPoint = (PENTRYPOINT)EP;  \
        FixupCount++;                           \
    }                                           \
}

VOID
ApplyFixups(
    PULONG NextCompilationUnitStart
    );

VOID
PeepNativeCode(
    PCHAR CodeLocation,
    ULONG NativeSize
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\cpu\axp64\findpc.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    findpc.c

Abstract:

    This module contains code to determine the address of the translation
    cache within the callstack.

Author:

    Barry Bond (barrybo) creation-date 13-May-1996

Revision History:

Notes:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#define _WX86CPUAPI_
#include <wx86.h>
#include <wx86nt.h>
#include <wx86cpu.h>
#include <cpuassrt.h>
#include <tc.h>
#include <findpc.h>

ASSERTNAME;


ULONG
FindPcInTranslationCache(
    PEXCEPTION_POINTERS pExceptionPointers
    )
/*++

Routine Description:

    Walk up the stack until the RISC instruction pointer points into
    the Translation Cache.

Arguments:

    pExceptionPointers -- state of the thread when the exception occurred

Return Value:

    Address of code within the translation cache which is on the callstack.
    0 if Translation Cache not found on the stack.

--*/
{
    CONTEXT ContextRecord;
    ULONG NextPc;
    PRUNTIME_FUNCTION FunctionEntry;
    BOOLEAN InFunction;
    FRAME_POINTERS EstablisherFrame;

    NextPc = (ULONG)pExceptionPointers->ContextRecord->Fir;
    if (AddressInTranslationCache(NextPc)) {
        //
        // Instruction which faulted is actually one inside the TC
        //
        return NextPc;
    }

    //
    // Instruction which faulted is in code called from the TC.  Unwind
    // up the callstack until we find an address within the TC.
    //
    ContextRecord = *pExceptionPointers->ContextRecord;
    NextPc = (ULONG)ContextRecord.IntRa;

    for (;;) {

        if (AddressInTranslationCache(NextPc)) {
            return NextPc;
        }

        FunctionEntry = RtlLookupFunctionEntry(NextPc);
        if (!FunctionEntry) {
            break;
        }

        NextPc = (ULONG) RtlVirtualUnwind(NextPc,
                                  FunctionEntry,
                                  &ContextRecord,
                                  &InFunction,
                                  &EstablisherFrame,
                                  NULL
                                 );
    }

    //
    // Didn't find an address within the TC while unwinding.
    //
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\cpu\axp64\opt.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    opt.c

Abstract:

    This module contains the ALPHA native-code optimizer

Author:

    Barry Bond (barrybo) creation-date 23-Sept-1996


Revision History:
 
            24-Aug-1999 [askhalid] copied from 32-bit wx86 directory and make work for 64bit.
            20-Sept-1999[barrybo]  added FRAG2REF(LockCmpXchg8bFrag32, ULONGLONG)

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#define _WX86CPUAPI_
#include "wx86.h"
#include "wx86nt.h"
#include "wx86cpu.h"
#include "cpuassrt.h"
#include "config.h"
#include "instr.h"
#include "compiler.h"
#include "codegen.h"
#include "opt.h"

ASSERTNAME;

/*
 * Fixups:
 *
 * Native-code generation into the Translation Cache is made in a single
 * pass, so the destination address for forward branches is not known.
 *
 * So, during native-code generation, a list of fixups is maintained, and
 * after all code generation is finished, fixups are applied.  All fixups
 * are described by three components - the fixup type, a pointer to the
 * RISC instruction to be fixed up, and a pointer to the ENTRYPOINT
 * structure describing the destination address.
 *
 * On Alpha there are four types of fixups:
 *
 *  1. LoadEPLow:  The immediate field of the instruction is replaced by
 *                 the low 16 bits of the destination address described by
 *                 the specified Entrypoint (ENTRYPOINT.nativeStart).
 *  2. LoadEPHigh: The immediate field of the instruction is replaced by
 *                 the high 16 bits of the destination address described by
 *                 the specified Entrypoint (ENTRYPOINT.nativeStart).
 *  3. BranchEP:   The destination of the unconditional jump instruction
 *                 is replaced by the destination address described by
 *                 the specified Entrypoint (ENTRYPOINT.nativeStart).
 *  4. ECUEP:      The destination of the conditional branch instruction is
 *                 replaced by the address of an EndCompilationUnit fragment.
 *                 The ECU fragment is at a higher address so the branch
 *                 instruction will be predicted as Not-Taken.
 *
 * If a RISC instruction is to be fixed up after compilation, place a
 * GEN_FIXUP() macro immediately above that instruction.
 *
 * During patching (vs. compilation), fixups are *not* applied, as all
 * native code addresses are already known.  Patch Functions can be
 * called during both compilation and patching, but the meaning of
 * the parameters is different.  During compilation, addresses are specified
 * by passing pointers to ENTRYPOINT structions, and the fixup pass resolves
 * them into native addresses.  During patching, addresses are specified
 * directly, and the fixup pass is not performed.
 *
 */

FIXUPINFO FixupInfo[MAX_FIXUP_COUNT];
ULONG FixupCount;


VOID
ApplyFixups(
    PULONG NextCompilationUnitStart
    )
/*++

Routine Description:

    Apply fixups to the generated native code.  This is done after
    the nativeStart field of newly-created EntryPoint structures is
    known.
     
Arguments:

    NextCompilationUnitStart -- native address of the start of the
                  JumpToNextCompilationUnit fragment in memory.

Return Value:

    None.
    
--*/
{
    PFIXUPINFO Fixup;
    ULONG NativeAddress;
    ULONG Instr;

    if (0 == FixupCount) {
	return;
    }

    for (Fixup = &FixupInfo[FixupCount-1]; Fixup >= FixupInfo; Fixup--) {
        Instr = *(Fixup->FixupInstr);

        switch (Fixup->Type) {
        case LoadEPLow:
            //
            // Load the low 16-bits of NativeAddress into a register
            //
            NativeAddress = (ULONG)(ULONGLONG)Fixup->EntryPoint->nativeStart;
            *(Fixup->FixupInstr) = (HIWORD(Instr) << 16) |
                                   LOWORD(NativeAddress);
            break;

        case LoadEPHigh:
            //
            // Load the high 16-bits of NativeAddress into a register
            //
            NativeAddress = (ULONG)(ULONGLONG)Fixup->EntryPoint->nativeStart;  
            if (NativeAddress & 0x8000) {
                //
                // On AXP, we must account for sign-extension when the
                // low word is loaded.
                //
                NativeAddress += 0x10000;
            }
            *(Fixup->FixupInstr) = (HIWORD(Instr) << 16) |
                                   HIWORD(NativeAddress);
            break;

        case BranchEP:
            //
            // Unconditioal branch NativeAddress into a register
            //  (Updates the branch hint field on ALPHA)
            //
            NativeAddress = (ULONG)(ULONGLONG)Fixup->EntryPoint->nativeStart;
            *(Fixup->FixupInstr) = (Instr & 0xffffc000) |
                    (((NativeAddress - (ULONG)(ULONGLONG)Fixup->FixupInstr)>>2) & 0x3FFF); 
            break;

        case ECUEP:
            //
            // Conditional branch to the EndCompilationUnit fragment
            //
            NativeAddress = (ULONG)(ULONGLONG)Fixup->EntryPoint->nativeStart;
            *(Fixup->FixupInstr) = (Instr & 0xffe00000) |
                    ( (((NativeAddress - (ULONG)(ULONGLONG)Fixup->FixupInstr)>>2) - 1) & 0x1FFFFF ); 
            break;

        default:
            CPUASSERT(FALSE);
        }
    }
}


#define GET_OPCODE(Instr) (Instr & 0xfc000000)

VOID
PeepNativeCode(
    PCHAR CodeLocation,
    ULONG NativeSize
    )
/*++

Routine Description:

    Applies a simple peephole optimizer to the generated RISC code.
     
Arguments:

    CodeLocation -- start of generated code to optimize
    NativeSize   -- length of generated code, in bytes

Return Value:

    None.
    
--*/
{
    PENTRYPOINT EP = NULL;
    ULONG i;
    PULONG pInstr1;
    ULONG Instr1;
    ULONG Instr2;

    //
    // Loop over all x86 instructions, and for each entrypoint, scan over
    // the native code and make optimizations.
    //
    for (i=0; i<NumberOfInstructions; ++i) {
        if (EP == InstructionStream[i].EntryPoint) {
            //
            // This x86 instruction is contained within the entrypoint
            //
            continue;
        }

        //
        // This x86 instruction marks the beginning of an entrypoint.
        //
        EP = InstructionStream[i].EntryPoint;

        //
        // Optimize the native code for this entrypoint
        //
        for (pInstr1 = (PULONG)EP->nativeStart;
             pInstr1 < (PULONG)(EP->nativeEnd)-sizeof(ULONG);
             ++pInstr1) {

                //
                // Examine pairs of RISC instructions
                //
                Instr1 = *pInstr1;
                Instr2 = *(pInstr1+1);

                switch (GET_OPCODE(Instr1)) {
                case STL_OPCODE:
                    switch (GET_OPCODE(Instr2)) {
                    case LDL_OPCODE:
                        if ((Instr1 & 0x03ffffff) == (Instr2 & 0x03ffffff)) {
                            //
                            // Found:
                            //     STL reg1, offset(reg2)
                            //     LDL reg1, offset(reg2)
                            // Replace with:
                            //     STL reg1, offset(reg2)
                            //     NOP
                            //
                            GEN_INSTR((pInstr1+1), NOP);
                        } else if ((Instr1 & 0x001fffff) ==
                                   (Instr2 & 0x001fffff)) {
                            //
                            // Found:
                            //     STL reg1, offset(reg2)
                            //     LDL reg3, offset(reg2)
                            // Replace with:
                            //     STL reg1, offset(reg2)
                            //     MOV reg1, reg3
                            //
                            ULONG SrcReg =  (Instr1 >> 21) & 31;
                            ULONG DestReg = (Instr2 >> 21) & 31;
                            GEN_INSTR((pInstr1+1), MOV(SrcReg, DestReg));
                        }
                        break;

                    default:
                        break;
                    }
                    break;

                case LDL_OPCODE:
                    switch (GET_OPCODE(Instr2)) {
                    case STL_OPCODE:
                        if ((Instr1 & 0x03ffffff) == (Instr2 & 0x03ffffff)) {
                            //
                            // Found:
                            //  LDL reg1, offset(reg2)
                            //  STL reg1, offset(reg2)
                            // Replace with:
                            //  LDL reg1, offset(reg2)
                            //  NOP
                            // (this is typically an instruction like:
                            //   LEA ECX, [ECX], which shows up in x86 apps)
                            //
                            GEN_INSTR((pInstr1+1), NOP);
                        }
                        break;

                    default:
                        break;
                    }
                    break;

                default:
                    break;
                }
            }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\cpu\axp64\helpers.s ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    helpers.s

Abstract:

    This module contains helper routines for the generated code fragments
    in the fragment library.  Based on ..\mips\handfrag.s

Author:

    Dave Hastings (daveh) creation-date 20-Jan-1996

Revision History:


--*/

#include <kxalpha.h>
#include <soalpha.h>
#include <cpunotif.h>

#define FRAMESIZE 0x30
#if (FRAMESIZE & f) != 0
    #error FRAMESIZE must be 16-byte aligned
#endif
#define StRa      FRAMESIZE-8
#define StS0      FRAMESIZE-0x10
#define StS1      FRAMESIZE-0x18
#define StS2      FRAMESIZE-0x20

//         FRAGMENT(BOPFrag)
// Routine Description:
// 
//     This fragment implements BOPs.  It is NOT copied into the translation
//     cache - it must be outside of the cache as the cache may be flushed
//     by another thread during the Wx86DispatchBop call.
//
//     BOPFrag unlocks the translation cache before calling Wx86DispatchBOP
//     so other threads can compile while the current thread is blocked
//     waiting on lengthy API calls.  This must be done to prevent
//     deadlock where one thread calls WaitForSingleObject() and another
//     thread needs write access to the translation cache to compile the
//     code required to unblock the waiting thread.
// 
// Arguments:
// 
//     none, but cpu->Eip points at the x86 BOP instruction
//
// Return Value:
// 
//     none
//

        NESTED_ENTRY(BOPFrag, FRAMESIZE, zero)
        lda     sp, -FRAMESIZE(sp)
        stq     ra, FRAMESIZE-8(sp)
        PROLOGUE_END
        
        //
        // Update eip to point *after* the BOP instruction.  The wx86
        // exception handler expects this.
        //
        ldl     RegEip, Eip(RegPointer)
        addl    RegEip, 8, RegEip
        stl     RegEip, Eip(RegPointer)
        
        //
        // Flag that the TC is unlocked, so if an exception occurs during
        // the Wx86DispatchBop call, CpuResetToConsistentState() will
        // know NOT to unlock the TC.
        //
        stl     RegPointer, fTCUnlocked(RegPointer)
        
        //
        // Get the current Translation Cache timestamp and save it.  The
        // TC is read-locked at this point, so the timestamp can be read
        // without any worry about non-atomic reads.
        //
        ldl     RegCache1, TranslationCacheTimestamp

        //
        // Patch the saved return address to point to
        // StartTranslatedCodePrologEnd so VirtualUnwind can unwind
        // even if the Translation Cache is flushed.
        //
        stq     ra, FRAMESIZE-0x10(sp)
        lda     RegTemp, StartTranslatedCodePrologEnd
        addl    RegTemp, 4, RegTemp     // AXP unwind code expects at least one instruction ran
        stq     RegTemp, FRAMESIZE-8(sp)

        //
        // Exit the translation cache, so this thread has no locks
        //
        lda     a0, MrswTC
        bsr     ra, MrswReaderExit
        
        //
        // Execute the BOP
        //
        addl    RegEip, -8, a0      // a0 = ptr to the BOP instruction
        bsr     ra, Wx86DispatchBop
        
        //
        // Get the Translation Read Lock again
        //
        lda     a0, MrswTC
        bsr     ra, MrswReaderEnter
        
        //
        // Restore all of the preserved registers and clean up the stack.
        //
        ldq     ra, FRAMESIZE-0x10(sp)  // "real" return address is *not* in FRAMESIZE-8!
        addq    sp, FRAMESIZE
        
        //
        // Indicate that CpuResetToConsistentState() must unlock the TC
        // after an exception
        //
        stl     zero, fTCUnlocked(RegPointer)        
        
	//
	// If the EIP image in PTHREADSTATE is different than RegEip, then the
	// BOP must have changed it.  Jump to EndTranslatedCode to begin
        // execution at the new address.  Note that the TC may have been
        // flushed - it doesn't matter because EndTranslatedCode will figure
        // out where to go next.
	//
        ldl     RegTemp2, Eip(RegPointer)
        cmpeq   RegTemp2, RegEip, RegTemp3
        beq     RegTemp3, bf10      // brif cpu->eip modified via SetEip/SetContext
        
        //
        // Now the the TC is locked, see if the timestamp has changed,
        // indicating that the return address is invalid.
        //
        ldl     RegTemp1, TranslationCacheTimestamp
        addl    RegEip, -8, RegEip
        cmpeq   RegTemp1, RegCache1, RegTemp3
        beq     RegTemp3, bf10      // brif TC flushed - code at ra is gone
        
        //
        // TC has not been flushed, so ra still points to the right place.
        // Continue running without running EndTranslatedCode().
        //
        stl     RegEip, Eip(RegPointer)
        ret     zero, (ra)
        
bf10:
        br      zero, EndTranslatedCode
        
        .end BOPFrag
        
        FRAGMENT(CallDirectHelper)
//
// Routine Description:
// 
//     This code is called by CallDirect.  It is NOT copied into the
//     translation cache - it must be outside of the cache as the cache
//     may be flushed during the call to PatchDirectCall.
//
// 
// Arguments:
// 
//     RegEip -- Contains Eip prior to the current instruction
//     a1     -- inteldest
//     a2     -- intelnext
//     ra     -- patchaddr
//
// Return Value:
// 
//     none -- jumps to EndTranslatedCode if the cache was tossed or
//             CpuNotify was set, or jumps directly to nativedest.
//
        
        //
        // Build the 4th parameter (patchaddr) to PatchCallDirect
        //
        mov     ra, a3
        
        //
        // Call ULONG PatchCallDirect(cpu, inteldest, intelnext, patchaddr)
        // where v0 is the native address to jump to
        //
        mov     RegPointer, a0        
        bsr     ra, PatchCallDirect
        
        //
        // Point the cached EIP at inteldest
        //
        ldl     RegEip, Eip(RegPointer)
        
        //
        // Jump directly to the next instruction.  Don't need to check
        // ProcessCpuNotify as we assume apps don't go into tight loops
        // using only CALL/RET as control-transfer instructions.
        //
        ldl     RegTemp0, CpuNotify(RegPointer)
        bne     RegTemp0, cdh10
        jmp     zero, (v0)
        
cdh10:  br     zero, EndTranslatedCode
        END_FRAGMENT(CallDirectHelper)
        
        FRAGMENT(CallfDirectHelper)
//
// Routine Description:
// 
//     This code is called by CallDirect.  It is NOT copied into the
//     translation cache - it must be outside of the cache as the cache
//     may be flushed during the call to PatchDirectCall.
//
// 
// Arguments:
// 
//     RegEip -- Contains Eip prior to the current instruction
//     a1     -- pinteldest
//     a2     -- intelnext
//     ra     -- patchaddr
//
// Return Value:
// 
//     none -- jumps to EndTranslatedCode if the cache was tossed or
//             CpuNotify was set, or jumps directly to nativedest.
//
        
        //
        // Build the 4th parameter (patchaddr) to PatchCallfDirect
        //
        mov     ra, a3
        
        //
        // Call ULONG PatchCallfDirect(cpu, inteldest, pintelnext, patchaddr)
        // where v0 is the native address to jump to
        //
        mov     RegPointer, a0        
        bsr     ra, PatchCallfDirect
        
        //
        // Point the cached EIP at inteldest
        //
        ldl     RegEip, Eip(RegPointer)
        
        //
        // Jump directly to the next instruction.  Don't need to check
        // ProcessCpuNotify as we assume apps don't go into tight loops
        // using only CALL/RET as control-transfer instructions.
        //
        ldl     RegTemp0, CpuNotify(RegPointer)
        bne     RegTemp0, cdh10f
        jmp     zero, (v0)
        
cdh10f: br     zero, EndTranslatedCode
        END_FRAGMENT(CallfDirectHelper)
        
        FRAGMENT(CallDirectHelper2)
//
// Routine Description:
// 
//     This code is called by CallDirect2.  It is NOT copied into the
//     translation cache - it must be outside of the cache as the cache
//     may be flushed during the call to PatchCallDirect2.
//
// 
// Arguments:
// 
//     RegEip -- Contains Eip prior to the current instruction
//     a1     -- inteldest
//     a2     -- intelnext
//     a3     -- nativedest
//     ra     -- patchaddr
//
// Return Value:
// 
//     none -- jumps to EndTranslatedCode if the cache was tossed or
//             CpuNotify was set, or jumps directly to nativedest.
//

        //
        // Build the 5th parameter (patchaddr) to PatchCallDirect2
        //
        mov     ra, a4
        
        //
        // Call ULONG PatchCallDirect2(cpu, inteldest, intelnext, nativedest, patchaddr)
        // where v0 is the native address to jump to
        //
        mov     RegPointer, a0        
        bsr     ra, PatchCallDirect2
        
        //
        // Point the cached EIP at inteldest
        //
        ldl     RegEip, Eip(RegPointer)
        
        //
        // Jump directly to the next instruction.  Don't need to check
        // ProcessCpuNotify as we assume apps don't go into tight loops
        // using only CALL/RET as control-transfer instructions.
        //
        ldl     RegTemp0, CpuNotify(RegPointer)
        bne     RegTemp0, cdh210
        jmp     zero, (v0)
        
cdh210: br     zero, EndTranslatedCode
        END_FRAGMENT(CallDirectHelper2)

        FRAGMENT(CallfDirectHelper2)
//
// Routine Description:
// 
//     This code is called by CallfDirect2.  It is NOT copied into the
//     translation cache - it must be outside of the cache as the cache
//     may be flushed during the call to PatchCallfDirect2.
//
// 
// Arguments:
// 
//     RegEip -- Contains Eip prior to the current instruction
//     a1     -- pinteldest
//     a2     -- intelnext
//     a3     -- nativedest
//     ra     -- patchaddr
//
// Return Value:
// 
//     none -- jumps to EndTranslatedCode if the cache was tossed or
//             CpuNotify was set, or jumps directly to nativedest.
//

        //
        // Build the 5th parameter (patchaddr) to PatchCallDirect2
        //
        mov     ra, a4
        
        //
        // Call ULONG PatchCallfDirect2(cpu, inteldest, pintelnext, nativedest, patchaddr)
        // where v0 is the native address to jump to
        //
        mov     RegPointer, a0        
        bsr     ra, PatchCallfDirect2
        
        //
        // Point the cached EIP at inteldest
        //
        ldl     RegEip, Eip(RegPointer)
        
        //
        // Jump directly to the next instruction.  Don't need to check
        // ProcessCpuNotify as we assume apps don't go into tight loops
        // using only CALL/RET as control-transfer instructions.
        //
        ldl     RegTemp0, CpuNotify(RegPointer)
        bne     RegTemp0, cdh210f
        jmp     zero, (v0)
        
cdh210f: br     zero, EndTranslatedCode
        END_FRAGMENT(CallfDirectHelper2)

        FRAGMENT(CallJmpDirectHelper)
//
// Routine Description:
// 
//     This code is called by JumpUnconditional.  It is NOT copied into the
//     translation cache - it must be outside of the cache as the cache
//     may be flushed during the call to PatchJmpDirect.
//
// 
// Arguments:
// 
//     RegEip -- Eip of destination instruction
//     a1     -- inteldest
//     ra     -- patchaddr
//
// Return Value:
// 
//     none -- jumps to EndTranslatedCode if the cache was tossed or
//             CpuNotify was set, or jumps directly to nativedest.
//
        stl     a1, Eip(RegPointer)
        
        // Call ULONG PatchJmpDirect(patchaddr, inteldest)
        // where v0 == 0 is the native address to jump to
        mov     ra, a0
        bsr     ra, PatchJmpDirect
        
        //
        // Jump directly to the next instruction.  Don't need to check
        // ProcessCpuNotify as it will be checked next time this JMP
        // instruction gets executed.  cpu->CpuNotify check is only
        // required when in slow mode.
        //
        ldl     RegTemp0, CpuNotify(RegPointer)
        bne     RegTemp0, cjdh10
        
        jmp     zero,(v0)
        
cjdh10: br      zero, EndTranslatedCode
        
        END_FRAGMENT(CallJmpDirectHelper)

        FRAGMENT(CallJmpDirectSlowHelper)
//
// Routine Description:
// 
//     This code is called by JumpUnconditional.  It is NOT copied into the
//     translation cache - it must be outside of the cache as the cache
//     may be flushed during the call to PatchJmpDirect.
//
// 
// Arguments:
// 
//     RegEip -- Eip of destination instruction
//     a1     -- inteldest
//     ra     -- patchaddr
//
// Return Value:
// 
//     none -- jumps to EndTranslatedCode if the cache was tossed or
//             CpuNotify was set, or jumps directly to nativedest.
//
        // Update cached Eip
        stl     a1, Eip(RegPointer)
        mov     a1, RegEip
        
        // Call ULONG PatchJmpDirectSlow(patchaddr, inteldest)
        // where v0 == 0 is the native address to jump to
        mov     ra, a0
        bsr     ra, PatchJmpDirectSlow
        
        //
        // Jump directly to the next instruction.  Don't need to check
        // ProcessCpuNotify as it will be checked next time this JMP
        // instruction gets executed.  cpu->CpuNotify check is only
        // required when in slow mode.
        //
        ldl     RegTemp0, CpuNotify(RegPointer)
        bne     RegTemp0, cjdh10Slow
        
        jmp     zero,(v0)
        
cjdh10Slow: br      zero, EndTranslatedCode
        
        END_FRAGMENT(CallJmpDirectSlowHelper)

        FRAGMENT(CallJmpFwdDirectHelper)
//
// Routine Description:
// 
//     This code is called by JumpUnconditional.  It is NOT copied into the
//     translation cache - it must be outside of the cache as the cache
//     may be flushed during the call to PatchJmpFwdDirect.
//
// 
// Arguments:
// 
//     RegEip -- Eip of destination instruction
//     a1     -- inteldest
//     ra     -- patchaddr
//
// Return Value:
// 
//     none -- jumps directly to nativedest.
//
        // Update Eip
        stl     a1, Eip(RegPointer)
        
        // Call ULONG PatchJmpFwdDirect(patchaddr, inteldest)
        // where v0 == 0 is the native address to jump to
        mov     ra, a0
        bsr     ra, PatchJmpFwdDirect
        
        // Jump directly to nativedest
        jmp     zero,(v0)
        
        END_FRAGMENT(CallJmpFwdDirectHelper)

        FRAGMENT(CallJmpfDirectHelper)
//
// Routine Description:
// 
//     This code is called by CallJmpfDirect.  It is NOT copied into the
//     translation cache - it must be outside of the cache as the cache
//     may be flushed during the call to PatchJmpfDirect.
//
// 
// Arguments:
// 
//     RegEip -- Eip of destination instruction
//     a1     -- pinteldest
//     ra     -- patchaddr
//
// Return Value:
// 
//     none -- jumps to EndTranslatedCode if the cache was tossed or
//             CpuNotify was set, or jumps directly to nativedest.
//
        // Call ULONG PatchJmpfDirect(cpu, pinteldest, patchaddr)
        // where v0 == 0 is the native address to jump to
        mov     RegPointer, a0
        mov     ra, a2
        bsr     ra, PatchJmpfDirect

        ldl     RegEip, Eip(RegPointer) // reload cached Eip
        
        //
        // Jump directly to the next instruction.  Don't need to check
        // ProcessCpuNotify as it will be checked next time this JMP
        // instruction gets executed.  cpu->CpuNotify check is only
        // required when in slow mode.
        //
        ldl     RegTemp0, CpuNotify(RegPointer)
        bne     RegTemp0, cjdhf10
        
        jmp     zero,(v0)
        
cjdhf10: br      zero, EndTranslatedCode
        
        END_FRAGMENT(CallJmpfDirectHelper)

        FRAGMENT(CallJmpfDirect2Helper)
//
// Routine Description:
// 
//     This code is called by CallJmpfDirect2.  It is NOT copied into the
//     translation cache - it is too messy to write in codeseq.txt, and
//     it's a FAR JMP, which isn't performance-critical.
//
// 
// Arguments:
// 
//     RegEip -- Eip of destination instruction
//     a0     -- nativedest
//     a1     -- inteldest
//
// Return Value:
// 
//     none -- jumps to EndTranslatedCode if the cache was tossed or
//             CpuNotify was set, or jumps directly to nativedest.
//

        // NOTE:  A1 may be unaligned.  Use EV56 load-byte and load-word
        //        instructions since WOW64 doesn't run on older CPUs
        
        // Load the first longword, the offset
        and     a1, 3, RegTemp
        bne     RegTemp, A1Unaligned
        ldl     RegTemp, 0(a1)      // load the 4-byte offset
        ldwu    RegTemp2, 4(a1)     // load the 2-byte selector
        br      zero, DoneLoadingIntelDest

A1Unaligned:        
        ldq_u   RegTemp, 0(a1)
        ldq_u   RegTemp2,3(a1)
        extll   RegTemp, a1, RegTemp
        extlh   RegTemp2, a1, RegTemp2
        or      RegTemp, RegTemp2, RegTemp
        
        // Load the next word, using EV56 load-byte instructions
        ldbu    RegTemp1, 4(a1)
        ldbu    RegTemp2, 5(a1)
        sll     RegTemp2, 8, RegTemp2
        or      RegTemp1, RegTemp2, RegTemp2
DoneLoadingIntelDest:        
        
        stl     RegTemp, Eip(RegPointer)    // eip = offset
        mov     RegTemp, RegEip             // update cached eip
        stl     RegTemp2, CSReg(RegPointer)  // update CS selector (a DWORD)

        //
        // Must check ProcessCpuNotify to ensure this thread doesn't
        // go into a tight loop with the TC locked.  Must check cpu->CpuNotify
        // for slow mode.
        //
        ldl     RegTemp0, (RegProcessCpuNotify)
        bne     RegTemp0, cjdhf22
        
        ldl     RegTemp0, CpuNotify(RegPointer)
        bne     RegTemp0, cjdhf22
        
        jmp     zero,(a0)
        
cjdhf22: br      zero, EndTranslatedCode

        END_FRAGMENT(CallJmpfDirect2Helper)


        FRAGMENT(CallIndirectHelper)
//
// Routine Description:
// 
//     This code is called by CallIndirect.  It is NOT copied into the
//     translation cache - it must be outside of the cache as the cache
//     may be flushed during the call to PatchCallIndirect.
//
// 
// Arguments:
// 
//     RegEip -- Contains Eip prior to the current instruction
//     a1     -- inteldest
//     a2     -- intelnext
//     ra     -- patchaddr
//
// Return Value:
// 
//     none -- jumps to EndTranslatedCode if the cache was tossed or
//             CpuNotify was set, or jumps directly to nativedest.
//


        // Call VOID PatchCallIndirect(cpu, inteldest, intelnext, patchaddr)
        //  (PatchCallIndirect set Eip to IntelDest)
        mov     RegPointer, a0
        mov     ra, a3
        bsr     ra, PatchCallIndirect
        
        //
        // Jump directly to EndTranslatedCode to make the control transfer
        //
        br      zero, EndTranslatedCode
        
        END_FRAGMENT(CallIndirectHelper)

        FRAGMENT(CallfIndirectHelper)
//
// Routine Description:
// 
//     This code is called by CallfIndirect.  It is NOT copied into the
//     translation cache - it must be outside of the cache as the cache
//     may be flushed during the call to PatchCallIndirect.
//
// 
// Arguments:
// 
//     RegEip -- Contains Eip prior to the current instruction
//     a1     -- pinteldest
//     a2     -- intelnext
//     ra     -- patchaddr
//
// Return Value:
// 
//     none -- jumps to EndTranslatedCode if the cache was tossed or
//             CpuNotify was set, or jumps directly to nativedest.
//


        // Call VOID PatchCallfIndirect(cpu, pinteldest, intelnext, patchaddr)
        //  (PatchCallfIndirect set Eip to IntelDest)
        mov     RegPointer, a0
        mov     ra, a3
        bsr     ra, PatchCallfIndirect
        
        //
        // Jump directly to EndTranslatedCode to make the control transfer
        //
        br      zero, EndTranslatedCode
        
        END_FRAGMENT(CallfIndirectHelper)

        FRAGMENT(CallJxxHelper)
//
// Routine Description:
// 
//     This code is called by JxxBody.  It is NOT copied into the
//     translation cache - it must be outside of the cache as the cache
//     may be flushed during the call to PatchJxx.  It is only
//     called when the branch is taken.
//
// 
// Arguments:
// 
//     a0     -- Contains inteldest - target of the branch
//     ra     -- patchaddr
//
// Return Value:
//
//     VOID   -- Jumps directly to nativedest
//

        stl     a0, Eip(RegPointer)
        
        // Call ULONG PatchJxx(inteldest, patchaddr)
        // where v0 is the native address to jump to
        mov     ra, a1
        bsr     ra, PatchJxx
        
        //
        // Jump directly to mipsdest, after checking CpuNotify.  Don't
        // need to check ProcessCpuNotify as it will be checked by the
        // patched Jxx instruction next time it executes.
        //
        ldl     RegTemp0, CpuNotify(RegPointer)
        bne     RegTemp0, cjh10
        jmp     zero, (v0)
        
cjh10:  br      zero, EndTranslatedCode

        END_FRAGMENT(CallJxxHelper)


        FRAGMENT(CallJxxSlowHelper)
//
// Routine Description:
// 
//     This code is called by JxxBodySlow.  It is NOT copied into the
//     translation cache - it must be outside of the cache as the cache
//     may be flushed during the call to PatchJxxSlow.  It is only
//     called when the branch is taken.
//
// 
// Arguments:
// 
//     a0     -- Contains inteldest - target of the branch
//     ra     -- patchaddr
//
// Return Value:
//
//     VOID   -- Jumps directly to nativedest
//

        stl     a0, Eip(RegPointer)
        
        // Call ULONG PatchJxxSlow(inteldest, patchaddr)
        // where v0 is the native address to jump to
        mov     ra, a1
        bsr     ra, PatchJxxSlow
        
        //
        // Jump directly to mipsdest, after checking CpuNotify
        //
        ldl     RegTemp0, CpuNotify(RegPointer)
        bne     RegTemp0, cjh10Slow
        jmp     zero, (v0)
        
cjh10Slow:  br      zero, EndTranslatedCode

        END_FRAGMENT(CallJxxSlowHelper)


        FRAGMENT(CallJxxFwdHelper)
//
// Routine Description:
// 
//     This code is called by JxxBodyFwd.  It is NOT copied into the
//     translation cache - it must be outside of the cache as the cache
//     may be flushed during the call to PatchJxxFwd.  It is only
//     called when the branch is taken.
//
// 
// Arguments:
// 
//     a0     -- Contains inteldest - target of the branch
//     ra     -- patchaddr
//
// Return Value:
//
//     VOID   -- Jumps directly to nativedest
//

        stl     a0, Eip(RegPointer)
        
        // Call ULONG PatchJxxFwd(inteldest, patchaddr)
        // where v0 is the native address to jump to
        mov     ra, a1
        bsr     ra, PatchJxxFwd
        
        //
        // Jump directly to nativedest
        //
        jmp     zero, (v0)
        END_FRAGMENT(CallJxxFwdHelper)


        FRAGMENT(JumpToNextCompilationUnitHelper)
//
// Routine Description:
// 
//     This code is called by JumpToNextCompilationUnit.  It is NOT copied into the
//     translation cache - it must be outside of the cache as the cache
//     may be flushed during the call to PatchJumpToNextCompilationUnit.
//
// 
// Arguments:
// 
//     RegEip -- intelnext
//     ra     -- patchaddr
//
// Return Value:
//
//     None.  Jumps directly to the nativedest code.
//
        // Call ULONG PatchJumpToNextCompilationUnit(patchaddr, intelnext)
        //  return value = nativedest
        mov     ra, a0
        mov     RegEip, a1
        bsr     ra, PatchJumpToNextCompilationUnit
        
        // Jump directly to nativedest.  THIS MUST NOT CHECK CPUNOTIFY AS IT
        // DOES NOT CORRESPOND TO A REAL INTEL INSTRUCTION.
        jmp     zero,(v0)
        
        END_FRAGMENT(JumpToNextCompilationUnitHelper)


        FRAGMENT(IndirectControlTransferHelper)
//
// Routine Description:
// 
//     This code is called by indirect control transfer functions.  It is 
//     NOT copied into the translation cache - it must be outside of the cache 
//     as the cache may be flushed during the call to IndirectControlTransfer.
//
// 
// Arguments:
// 
//     a0 -- tableindex
//     a1 -- inteldest
//
// Return Value:
//
//     None.  Jumps directly to the native destination code.
//

        // Update cached Eip
        mov     a1, RegEip
        mov     RegPointer, a2

        //
        // Call ULONG IndirectControlTransfer(tableEntry, intelDest, cpu)
        // v0 = nativeDest
        //
        bsr     ra, IndirectControlTransfer        
        
        //
        // v0 should now contain the native address we want to jump to
        //
        jmp     zero, (v0)        

        END_FRAGMENT(IndirectControlTransferHelper)


        FRAGMENT(IndirectControlTransferFarHelper)
//
// Routine Description:
// 
//     This code is called by FAR indirect control transfer functions.  It is
//     NOT copied into the translation cache - it must be outside of the cache 
//     as the cache may be flushed during the call to IndirectControlTransfer.
//
// 
// Arguments:
//
//     a0 -- unused
//     a1 -- pinteldest
//     a2 -- tableindex
//
// Return Value:
//
//     None.  Jumps directly to the native destination code.
//
        //
        // Check both CpuNotify flags as this code runs in both
        // fast and slow mode.  IndirectControlTransferHelper() is
        // slow, so the extra check isn't too bad when in fast mode.
        //
        ldl     RegTemp, CpuNotify(RegPointer)
        bne     RegTemp, idctfh10
        ldl     RegTemp, (RegProcessCpuNotify)
        bne     RegTemp, idctfh10

        //
        // Call ULONG IndirectControlTransferFar(cpu, pinteldest, tableEntry)
        // v0 = nativeDest
        //
        mov     RegPointer, a0
        bsr     ra, IndirectControlTransferFar

        // Update cached Eip
        ldl     RegEip, Eip(RegPointer)
        
        //
        // v0 should now contain the native address we want to jump to
        //
        jmp     zero, (v0)

idctfh10: br      zero, EndTranslatedCode
        END_FRAGMENT(IndirectControlTransferFarHelper)


        LEAF_ENTRY(UnsimulateFrag)
//
// Routine Description:
// 
//     This code is called from the Translation Cache to implement
//     BOP FE.  It set CpuNotify to CPUNOTIFY_UNSIMULATE and jumps to
//     EndTranslatedCode.
// 
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
        PROLOGUE_END

io10:   ldl_l   v0, CpuNotify(RegPointer)
        bis     v0, CPUNOTIFY_UNSIMULATE, RegTemp0
        stl_c   RegTemp0, CpuNotify(RegPointer)
        beq     RegTemp0, io20
        
        br      zero, EndTranslatedCode
        
io20:   br      zero, io10
        .end    UnsimulateFrag

        LEAF_ENTRY(IntFrag)
//
// Routine Description:
// 
//     This code is called from the Translation Cache to implement
//     INT instructions.  It set CpuNotify to CPUNOTIFY_INTX and jumps to
//     EndTranslatedCode.
// 
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
        PROLOGUE_END

if10:   ldl_l   v0, CpuNotify(RegPointer)
        bis     v0, CPUNOTIFY_INTX, RegTemp0
        stl_c   RegTemp0, CpuNotify(RegPointer)
        beq     RegTemp0, if20
        
        br      zero, EndTranslatedCode
        
if20:   br      zero, if10
        .end    IntFrag
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\inc\analysis.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    analysis.h

Abstract:

    This module contains interfaces and structures exported by the analysis
    module.

Author:

    Dave Hastings (daveh) creation-date 26-Jun-1995

Revision History:


--*/

#ifndef _ANALYSIS_H_
#define _ANALYSIS_H_

ULONG
GetInstructionStream(
    PINSTRUCTION InstructionStream,
    PULONG NumberOfInstructions,
    PVOID pIntelInstruction,
    PVOID pLastIntelInstruction
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\inc\coded.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    coded.h

Abstract:

    This is the include file for the code description dumper, and it's 
    associated utilities.

Author:

    Dave Hastings (daveh) creation-date 20-May-1996

Revision History:


--*/

#define CODEGEN_PROFILE_REV 1

typedef struct _CodeDescriptionHeader {
    ULONG NextCodeDescriptionOffset;
    ULONG CommandLineOffset;
    ULONG ProcessorType;
    ULONG DumpFileRev;
    ULONG StartTime;
} CODEDESCRIPTIONHEADER, *PCODEDESCRIPTIONHEADER;

typedef struct _CodeDescription {
    ULONG NextCodeDescriptionOffset;
    ULONG TypeTag;
    ULONG NativeCodeOffset;
    ULONG NativeCodeSize;
    ULONG IntelCodeOffset;
    ULONG IntelCodeSize;
    ULONG NativeAddress;
    ULONG IntelAddress;    
    ULONG SequenceNumber;
    ULONG ExecutionCount;
    ULONG CreationTime;
} CODEDESCRIPTION, *PCODEDESCRIPTION;

#define PROFILE_CODEDESCRIPTIONS            0x00000001

#define PROFILE_CD_CREATE_DESCRIPTIONFILE   0x00000001
#define PROFILE_CD_CLOSE_DESCRIPTIONFILE    0x00000002

#define PROFILE_TAG_CODEDESCRIPTION         0x0
#define PROFILE_TAG_EOF                     0xFFFFFFFF
#define PROFILE_TAG_TCFLUSH                 0xFFFFFFFE
#define PROFILE_TAG_TCALLOCFAIL             0xFFFFFFFD
extern ULONG ProfileFlags;
extern ULONG CodeDescriptionFlags;

VOID
InitCodegenProfile(
    VOID
    );
    
VOID
TerminateCodegenProfile(
    VOID
    );

VOID 
DumpCodeDescriptions(
    BOOL TCFlush
    );

VOID
DumpAllocFailure(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\inc\atomic.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    atomic.h

Abstract:

    This is the include file for atomic.s - atomic operations on memory, used
    for synchronization.

Author:

    Barry Bond (barrybo) creation-date 03-Aug-1995

Revision History:


--*/

#ifndef _ATOMIC_H_
#define _ATOMIC_H_

DWORD
MrswFetchAndIncrementWriter(
    DWORD *pCounters
    );

DWORD
MrswFetchAndIncrementReader(
    DWORD *pCounters
    );

DWORD
MrswFetchAndDecrementWriter(
    DWORD *pCounters
    );

DWORD
MrswFetchAndDecrementReader(
    DWORD *pCounters
    );

DWORD
InterlockedAnd(
    DWORD *pDWORD,
    DWORD AndValue
    );

DWORD
InterlockedOr(
    DWORD *pDWORD,
    DWORD OrValue
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\fraglib\cpu\axp64\remote.s ===
/*++

Copyright (c) 1999-1998 Microsoft Corporation

Module Name: 

    remote.s

Abstract:
    
    This module contains stubs to intercept remoted calls and route them 
    to the proper C function, after correctly setting up the parameters.

Author:

    14-Dec-1999  SamerA

Revision History:

--*/


#include <kxalpha.h>


//++
//
// VOID
// RemoteSuspendAtNativeCode (
//     VOID
//     )
//
// Routine Description:
//
//     This function is called to suspend the current thread. It will
//     call to the CPU to make sure that the context is consistent.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//--

        LEAF_ENTRY(RemoteSuspendAtNativeCode)

        mov     s0, a0                    // set context frame address argument
        mov     s1, a1                    // set suspend msg address
        br      zero, CpupSuspendAtNativeCode // jump

        .end RemoteSuspendAtNativeCode
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\inc\compiler.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    compiler.h

Abstract:

    This include file defines the exports from compiler.lib.

Author:

    Dave Hastings (daveh) creation-date 10-Jul-1995

Revision History:


--*/

#ifndef _COMPILER_H_
#define _COMPILER_H_

#include <threadst.h>

//
// Bit-flags which affect the way the compiler generates code.
//
#define COMPFL_FAST     1   // fastmode - implicit Eip, infrequent CpuNotify
                            //            checks, few ENTRYPOINTs
#define COMPFL_SLOW     2   // slowmode - build ENTRYPOINT for each instruction

extern DWORD CompilerFlags;         // controls how the compiler generates code

extern INSTRUCTION InstructionStream[MAX_INSTR_COUNT];
extern ULONG NumberOfInstructions;


PENTRYPOINT
NativeAddressFromEip(
    PVOID IntelEip,
    BOOL  LockTCForWrite
    );
    
PVOID
NativeAddressFromEipNoCompile(
    PVOID IntelEip
    );
    
PENTRYPOINT
NativeAddressFromEipNoCompileEPWrite(
    PVOID IntelEip
    );

VOID
GetEipFromException(
    PCPUCONTEXT cpu,
    PEXCEPTION_POINTERS pExceptionPointers
    );


//
// This API is defined inside the fragment library, but is only used by the
// compiling cpu (MSCPU). 
//
VOID
StartTranslatedCode(
    PTHREADSTATE ThreadState,
    PVOID NativeCode    
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\inc\config.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    config.h

Abstract:

    This file defines the names of all configuration variables within
    the CPU.

Author:

    Barry Bond (barrybo)  creation-date 12-Jun-1996

Revision History:


--*/

#ifndef _CONFIG_H_
#define _CONFIG_H_

//
// Global definitions
//
#ifndef _ALPHA_
#define MAX_PROLOG_SIZE     0x1000  // max size of StartTranslatedCode prolog
#else
#define MAX_PROLOG_SIZE     0x2000  // max size of StartTranslatedCode prolog
#endif

#define MAX_INSTR_COUNT 200         // max number of instructions to compile

/*
 * The amount of memory to reserve (in bytes) for the dynamically-
 * allocated CPU Translation Cache.  This reserve is added to the
 * 2MB statically-allocated cache.
 *
 * Minimum size is 1 page of memory (4096 on MIPS and PPC, 8192 on Alpha).
 * Default value is 2MB. (DYN_CACHE_SIZE)
 * Maximum size is all available memory.
 *
 */
#define STR_CACHE_RESERVE  L"CpuCacheReserve"
extern DWORD CpuCacheReserve;

/*
 * The amount of memory to commit (in bytes) for the dynamically-
 * allocated CPU Translation Cache.  The 2MB statically-allocated
 * cache is fully committed at startup.
 *
 * Minimum size is 1 page of memory (4096 on MIPS and PPC, 8192 on Alpha).
 * Default value is 1 page. (MAX_PROLOG_SIZE)
 * Maximum size is size of reserve.
 *
 */
#define STR_CACHE_COMMIT   L"CpuCacheCommit"
extern DWORD CpuCacheCommit;

/*
 * If consecutive cache commits occur within the specified time, the amount
 * committed each time doubles. (in ms)
 *
 * Minimum value is 0
 * Default value is 200
 * Maximum value is -1
 *
 */
#define STR_CACHE_GROW_TICKS L"CpuCacheGrowTicks"
extern DWORD CpuCacheGrowTicks;

/*
 * If consecutive cache commits occur past the specified time, the amount
 * committed each time is cut in half. (in ms)
 *
 * Minimum value is 0
 * Default value is 1000
 * Maximum value is -1
 *
 */
#define STR_CACHE_SHRINK_TICKS L"CpuCacheShrinkTicks"
extern DWORD CpuCacheShrinkTicks;

/*
 * Minimum amount of memory (in bytes) to commit in the Translation Cache.
 * Note that this value will be rounded up to the next power of 2.
 *
 * Minimum value is 1 page
 * Default value is 32768
 * Maximum value is size of cache
 *
 */
#define STR_CACHE_CHUNKMIN L"CpuCacheChunkMin"
extern DWORD CpuCacheChunkMin;

/*
 * Maximum amount of memory (in bytes) to commit in the Translation Cache.
 * Note that this value will be rounded up to the next power of 2.
 *
 * Minimum value is 1 page
 * Default value is 512k
 * Maximum value is size of cache
 *
 */
#define STR_CACHE_CHUNKMAX L"CpuCacheChunkMax"
extern DWORD CpuCacheChunkMax;

/*
 * Initial amount of memory (in bytes) to commit in the Translation Cache.
 * Note that this value will be rounded up to the next power of 2.
 *
 * Minimum value is 1 page
 * Default value is 65536
 * Maximum value is size of cache
 *
 */
#define STR_CACHE_CHUNKSIZE L"CpuCacheChunkSize"
extern DWORD CpuCacheChunkSize;

/*
 * Time to wait for other threads to synchronize (in ms).
 *
 * Minimum time is 0
 * Default time is 3 times the default time used for NT critical sections
 * Maximum time is -1 (infinity)
 *
 */
#define STR_MRSW_TIMEOUT   L"CpuTimeout"
extern LARGE_INTEGER MrswTimeout;

/*
 * Default compilation flags
 *
 * See cpu\inc\compiler.h for COMPFL_ values and meanings
 *
 * Default=COMPFL_FAST
 *
 */
#define STR_COMPILERFLAGS L"CpuCompilerFlags"
extern DWORD CompilerFlags;

/*
 * Flag indicating whether winpxem.dll will be used to emulate
 * floating-point instructions using the Intel Windows NT 486SX
 * emulator instead of the Wx86 implementation.
 *
 * Default=0
 * Non-zero indicates winpxem.dll will be used.
 *
 */
#define STR_USEWINPXEM L"CpuNoFPU"
extern DWORD fUseNPXEM;

/*
 * Number of times to retry memory allocations before failing.
 *
 * Min = 1
 * Default = 4
 * Max = 0xffffffff
 *
 */
#define STR_CPU_MAX_ALLOC_RETRIES L"CpuMaxAllocRetries"
extern DWORD CpuMaxAllocRetries;

/*
 * Time to sleep between memory allocation retries (in ms).
 *
 * Min = 0
 * Default = 200
 * Max = 0xffffffff
 *
 */
#define STR_CPU_WAIT_FOR_MEMORY_TIME L"CpuWaitForMemoryTime"
extern DWORD CpuWaitForMemoryTime;

/*
 * Number of instructions of lookahead in the CPU
 *
 * Min = 1
 * Default = 200 (MAX_INSTR_COUNT)
 * Max = 200 (MAX_INSTR_COUNT)
 *
 */
#define STR_CPU_MAX_INSTRUCTIONS L"CpuInstructionLookahead"
extern DWORD CpuInstructionLookahead;

/*
 * Disable the Dynamic Translation Cache altogether
 *
 * Default = 0 - Dynamic Translation Cache enabled
 * nonzero - use only the static Translation Cache
 *
 */
#define STR_CPU_DISABLE_DYNCACHE L"CpuDisableDynamicCache"
extern DWORD CpuDisableDynamicCache;

/*
 * Size of ENTRYPOINT descriptor reservation, in bytes
 *
 * Default = 0x1000000
 *
 */
#define STR_CPU_ENTRYPOINT_RESERVE L"CpuEntryPointReserve"
extern DWORD CpuEntryPointReserve;

/*
 * Disable caching of x86 registers in RISC registers
 *
 * Default = 0 - x86 registers cached in RISC registers
 * nonzero - x86 registers accessed only from memory
 *
 */
#define STR_CPU_DISABLE_REGCACHE L"CpuDisableRegCache"
extern DWORD CpuDisableRegCache;

/*
 * Disable dead x86 flag removal
 *
 * Default = 0 - dead x86 flags not computed
 * nonzero - x86 flags always computed
 *
 */
#define STR_CPU_DISABLE_NOFLAGS L"CpuDisableNoFlags"
extern DWORD CpuDisableNoFlags;

/*
 * Disable Ebp alignment detection.
 *
 * Default = 0 - If EBP is determined to be a stack frame pointer, assume
 *               it is an aligned pointer.
 * nonzero - Assume EBP is always an unaligned pointer.
 *
 */
#define STR_CPU_DISABLE_EBPALIGN L"CpuDisableEbpAlign"
extern DWORD CpuDisableEbpAlign;

/*
 * Enable sniff-checking on x86 code found in writable memory
 *
 * Default = 0 - No sniff-checking performed.
 * nonzero - Sniff-check pages with writable attributes.
 *
 */
#define STR_CPU_SNIFF_WRITABLE_CODE L"CpuSniffWritableCode"
extern DWORD CpuSniffWritableCode;

/*
 * Logging verbosity.  Only configurable under the debugger.
 *
 */
extern DWORD ModuleLogFlags;

VOID
GetConfigurationData(
    VOID
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\inc\cpumain.h ===
/*++
                                                                                
Copyright (c) 1995 Microsoft Corporation

Module Name:

    cpumain.h

Abstract:
    
    Prototypes from cpumain.c
    
Author:

    01-Aug-1995 Ori Gershony (t-orig)

Revision History:

    29-Jan-2000  SamerA  Added CpupDoInterrupt and CpupRaiseException
--*/

#ifndef CPUMAIN_H
#define CPUMAIN_H

//
// Indicator that threads must check CpuNotify.  0 if threads don't need
// to check, nonzero if they do.
//
extern DWORD ProcessCpuNotify;

//
// Simulates an x86 software interrupt
//
NTSTATUS
CpupDoInterrupt(
    IN DWORD InterruptNumber);

//
// Raises a software exception
//
NTSTATUS
CpupRaiseException(
    IN PEXCEPTION_RECORD ExceptionRecord);

//
// Raises an exception from the cpu
//
VOID
CpuRaiseStatus(
    NTSTATUS Status
    );

//
// The following two variables are used to synchronize intel instructions
// with the LOCK prefix.  The critical section is a lot faster, but it does
// not guarantee synchronization in shared memory.  Eventually we should use
// the critical section by default, and the mutex for certain applications which
// need it (maybe get a list from the registry).
//
extern HANDLE           Wx86LockSynchMutexHandle;
extern CRITICAL_SECTION Wx86LockSynchCriticalSection;


//
// The following variable decided which synchronization object is used
//
typedef enum {USECRITICALSECTION, USEMUTEX} SYNCHOBJECTTYPE;
extern SYNCHOBJECTTYPE SynchObjectType;

#endif // CPUMAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\inc\cpuassrt.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cpuassrt.h

Abstract:

    This include file defines the assertion mechanism for the compiling
    CPU.

Author:

    Barry Bond (barrybo) creation-date 07-Aug-1995

Revision History:


--*/

#ifndef _CPUASSRT_H_
#define _CPUASSRT_H_

// This function is defined in fraglib\fraginit.c
VOID
CpuStartDebugger(
    VOID
    );


#if DBG

#undef ASSERTNAME
#define ASSERTNAME     static char szModule[] = __FILE__;

// This function is defined in fraglib\fraginit.c
VOID
DoAssert(
    PSZ exp,
    PSZ msg,
    PSZ mod,
    INT line
    );

#define CPUASSERT(exp)                                      \
{                                                           \
    if (!(exp)) {                                           \
        DoAssert( #exp , NULL, szModule, __LINE__);         \
    }                                                       \
}

#define CPUASSERTMSG(exp,msg)                               \
{                                                           \
    if (!(exp)) {                                           \
        DoAssert( #exp , (msg), szModule, __LINE__);        \
    }                                                       \
}

#else   //!DBG

#define ASSERTNAME
#define CPUASSERT(exp)
#define CPUASSERTMSG(exp,msg)

#endif  //!DBG


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\inc\decoder.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    decoder.h

Abstract:

    This module defines the interface to the Instruction Decoder.
    

Author:

    Barry Bond (barrybo) creation-date 29-June-1995

Revision History:


--*/

#ifndef _DECODER_H_
#define _DECODER_H_

VOID
DecodeInstruction(
    DWORD           InstructionAddress,
    PINSTRUCTION    Instruction
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\inc\cpuregs.h ===
/*++
                                                                                
Copyright (c) 1995 Microsoft Corporation

Module Name:

    cpuregs.h

Abstract:
    
    Handy defines from x86 reg names to cpu register fields
    
Author:

Revision History:

--*/

#define eax     cpu->GpRegs[GP_EAX].i4
#define ebx     cpu->GpRegs[GP_EBX].i4
#define ecx     cpu->GpRegs[GP_ECX].i4
#define edx     cpu->GpRegs[GP_EDX].i4
#define esp     cpu->GpRegs[GP_ESP].i4
#define ebp     cpu->GpRegs[GP_EBP].i4
#define esi     cpu->GpRegs[GP_ESI].i4
#define edi     cpu->GpRegs[GP_EDI].i4
#define eip     cpu->eipReg.i4
#define eipTemp cpu->eipTempReg.i4

#define ax      cpu->GpRegs[GP_EAX].i2
#define bx      cpu->GpRegs[GP_EBX].i2
#define cx      cpu->GpRegs[GP_ECX].i2
#define dx      cpu->GpRegs[GP_EDX].i2
#define sp      cpu->GpRegs[GP_ESP].i2
#define bp      cpu->GpRegs[GP_EBP].i2
#define si      cpu->GpRegs[GP_ESI].i2
#define di      cpu->GpRegs[GP_EDI].i2

#define al      cpu->GpRegs[GP_EAX].i1
#define bl      cpu->GpRegs[GP_EBX].i1
#define cl      cpu->GpRegs[GP_ECX].i1
#define dl      cpu->GpRegs[GP_EDX].i1

#define ah      cpu->GpRegs[GP_EAX].hb
#define bh      cpu->GpRegs[GP_EBX].hb
#define ch      cpu->GpRegs[GP_ECX].hb
#define dh      cpu->GpRegs[GP_EDX].hb

#define CS      cpu->GpRegs[REG_CS].i2
#define DS      cpu->GpRegs[REG_DS].i2
#define ES      cpu->GpRegs[REG_ES].i2
#define SS      cpu->GpRegs[REG_SS].i2
#define FS      cpu->GpRegs[REG_FS].i2
#define GS      cpu->GpRegs[REG_GS].i2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\inc\eflags.h ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation

Module Name:

    eflags.h

Abstract:

    Bit positions for the various flag bits inside EFLAGS

Author:

    Barry Bond (barrybo) creation-date 25-January-2000

Revision History:


--*/

#ifndef _EFLAGS_INCLUDED
#define _EFLAGS_INCLUDED

#define FLAG_CF	    (1<<0)	    // carry
// bit 1 is always 1
#define FLAG_PF	    (1<<2)	    // parity
// bit 3 is always 0
#define FLAG_AUX    (1<<4)	    // aux carry
// bit 5 is always 0
#define FLAG_ZF     (1<<6)	    // zero
#define FLAG_SF     (1<<7)	    // sign
#define FLAG_TF     (1<<8)	    // trap
#define FLAG_IF	    (1<<9)	    // interrupt enable
#define FLAG_DF     (1<<10)	    // direction
#define FLAG_OF     (1<<11)	    // overflow
#define FLAG_IOPL   (3<<12)	    // IOPL = 3
#define FLAG_NT	    (1<<14)	    // nested task
// bit 15 is 0
#define FLAG_RF	    (1<<16)	    // resume flag
#define FLAG_VM	    (1<<17)	    // virtual mode
#define FLAG_AC     (1<<18)     // alignment check
#define FLAG_ID     (1<<21)     // ID bit (CPUID present if this can be toggled)

#endif //_EFLAGS_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\inc\entrypt.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    entrypt.h

Abstract:
    
    The interface to the entry point module.
    
Author:

    16-Jun-1995 t-orig

Revision History:

--*/

#ifndef _ENTRYPT_H_
#define _ENTRYPT_H_

//
// Time to wait, in milliseconds, to sleep before retrying a memory
// allocation which failed due to lack of free pages.
//
#define CPU_WAIT_FOR_MEMORY_TIME    200

//
// Number of times to retry memory allocations
//
#define CPU_MAX_ALLOCATION_RETRIES  4


// Note:  if BOTH is defined, than the code compiled will allow one to
//        retrieve an entry point structure from either an intel or native
//        address.  If both is not defined, than an entry point structure 
//        can only be retrieved from an intel address.   Defining both 
//        increases the cost (time and space) of most operation by a 
//        factor of 2.
//#define BOTH

// Set this to 1 if you suspect there is a heap corruption which is
// trashing the red-black trees.  It creates a second red-black tree
// which mirrors the first, and walks both trees frequently to ensure
// they actually match.  Since the checking mechanism uses NT asserts,
// this only works on a checked NT build using a checked CPU.
#define DBG_DUAL_TREES 0

//
// This timestamp is bumped whenever an entrypoint is added, split, or
// when all entrypoits are flushed.  It an be used to determine if
// the entrypoints need to be re-searched afte switching from an Mrsw
// reader to an Mrsw Writer.
//
extern DWORD EntrypointTimestamp;

// The Entry Point Structure
typedef struct _entryPoint {
    PVOID intelStart;
    PVOID intelEnd;
    PVOID nativeStart;
    PVOID nativeEnd;
    USHORT FlagsNeeded;
    struct _entryPoint *SubEP;
#ifdef CODEGEN_PROFILE
    ULONG SequenceNumber;
    ULONG ExecutionCount;
    ULONG CreationTime;
#endif
} ENTRYPOINT, *PENTRYPOINT;

// The colors
typedef enum {RED, BLACK} COL;

// The EPNODE structure
typedef struct _epNode
{
    ENTRYPOINT ep;

    struct _epNode *intelLeft;
    struct _epNode *intelRight;
    struct _epNode *intelParent;
    COL intelColor;

#ifdef BOTH
    struct _epNode *nativeLeft;
    struct _epNode *nativeRight;
    struct _epNode *nativeParent;
    COL riscColor;
#endif

#if DBG_DUAL_TREES
    struct _epNode *dual;
#endif

} EPNODE, *PEPNODE;


// Prototypes

INT
initializeEntryPointModule(
    void
    );

PENTRYPOINT 
EPFromIntelAddr(
    PVOID intelAddr
    );

PENTRYPOINT
GetNextEPFromIntelAddr(
    PVOID intelAddr
    );

VOID
FlushEntrypoints(
    VOID
    );

#ifdef BOTH
PENTRYPOINT 
EPFromNativeAddr(
    PVOID nativeAddr
    );
#endif

INT
insertEntryPoint(
    PEPNODE pNewEntryPoint
    );

INT 
removeEntryPoint(
    PEPNODE pEP
    );

PVOID
EPAlloc(
    DWORD cb
    );

VOID
EPFree(
    VOID
    );

INT
initEPAlloc(
    VOID
    );

BOOLEAN
IsIntelRangeInCache(
    PVOID Addr,
    DWORD Length
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\inc\cpunotif.h ===
/*++ 

Copyright (c) 1994 Microsoft Corporation

Module Name:

    cpunotif.h

Abstract:
    
    definitions for CPUNOTIFY constants

Author:

    21-July-1995 t-orig (Ori Gershony), created

Revision History:

--*/


//
// defines for Wx86Tib.CpuNotify
//
#define CPUNOTIFY_TRACEFLAG  0x00000001   // Trace Flag value
#define CPUNOTIFY_TRACEADDR  0x00000002   // Trace Address is set
#define CPUNOTIFY_INSTBREAK  0x00000004   // Debug Reg Instruction breakpoints
#define CPUNOTIFY_DATABREAK  0x00000008   // Debug Reg Data breakpoints
#define CPUNOTIFY_SLOWMODE   0x00000010   // Cpu runs in slow mode
#define CPUNOTIFY_INTERRUPT  0x00000020   // async request for cpu
#define CPUNOTIFY_UNSIMULATE 0x00000040   // cpu has reached a Bop fe
#define CPUNOTIFY_CPUTRAP    0x00000080   // catch all for cpu internal usage
#define CPUNOTIFY_EXITTC     0x00000100   // TC is about to be flushed
#define CPUNOTIFY_DBGFLUSHTC 0x00000200   // debugger modified memory - flush TC
#define CPUNOTIFY_SUSPEND    0x00000400   // SuspendThread() called on this thread
#define CPUNOTIFY_INTX       0x00000800   // INTx instruction hit
#define CPUNOTIFY_MODECHANGE 0x00001000   // Compiler switched between fast and slow - flush TC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\inc\fndata.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    fndata.h

Abstract:

    This module contains definitions of all placement functions for
    fragments.  Before including this file, the DEF_PLACEFN macro must be
    defined.

Author:

    Barry Bond (barrybo) creation-date 12-Sep-1996

Revision History:


--*/


#ifndef DEF_PLACEFN
#error Must define DEF_PLACEFN(FunctionName)
#endif

// Each DEF_PLACEFN defines a new place function

DEF_PLACEFN(GenCallCFrag)
DEF_PLACEFN(GenCallCFragNoCpu)
DEF_PLACEFN(GenCallCFragLoadEip)
DEF_PLACEFN(GenCallCFragLoadEipNoCpu)
DEF_PLACEFN(GenCallCFragSlow)
DEF_PLACEFN(GenCallCFragNoCpuSlow)
DEF_PLACEFN(GenCallCFragLoadEipSlow)
DEF_PLACEFN(GenCallCFragLoadEipNoCpuSlow)
DEF_PLACEFN(PlaceJxx)
DEF_PLACEFN(PlaceJxxSlow)
DEF_PLACEFN(PlaceJxxFwd)
DEF_PLACEFN(PlaceCallDirect)
DEF_PLACEFN(PlaceCallfDirect)
DEF_PLACEFN(GenCallIndirect)
DEF_PLACEFN(GenCallfIndirect)
DEF_PLACEFN(GenCallJmpIndirect)
DEF_PLACEFN(GenCallJmpfIndirect)
DEF_PLACEFN(PlaceJmpDirect)
DEF_PLACEFN(PlaceJmpDirectSlow)
DEF_PLACEFN(PlaceJmpFwdDirect)
DEF_PLACEFN(PlaceJmpfDirect)
DEF_PLACEFN(GenCallRetIndirect)
DEF_PLACEFN(PlaceNop)
DEF_PLACEFN(GenMovsx8To32)
DEF_PLACEFN(GenMovsx8To32Slow)
DEF_PLACEFN(GenMovsx8To16)
DEF_PLACEFN(GenMovsx8To16Slow)
DEF_PLACEFN(GenMovsx16To32)
DEF_PLACEFN(GenMovsx16To32Slow)
DEF_PLACEFN(GenMovzx8To32)
DEF_PLACEFN(GenMovzx8To32Slow)
DEF_PLACEFN(GenMovzx8To16)
DEF_PLACEFN(GenMovzx8To16Slow)
DEF_PLACEFN(GenMovzx16To32)
DEF_PLACEFN(GenMovzx16To32Slow)
DEF_PLACEFN(GenStartBasicBlock)
DEF_PLACEFN(GenJumpToNextCompilationUnit)
DEF_PLACEFN(GenEndMovSlow)
DEF_PLACEFN(GenAddFragNoFlags32)
DEF_PLACEFN(GenAddFragNoFlags32A)
DEF_PLACEFN(GenAndFragNoFlags32)
DEF_PLACEFN(GenAndFragNoFlags32A)
DEF_PLACEFN(GenDecFragNoFlags32)
DEF_PLACEFN(GenDecFragNoFlags32A)
DEF_PLACEFN(GenIncFragNoFlags32)
DEF_PLACEFN(GenIncFragNoFlags32A)
DEF_PLACEFN(GenOrFragNoFlags32)
DEF_PLACEFN(GenOrFragNoFlags32A)
DEF_PLACEFN(GenSubFragNoFlags32)
DEF_PLACEFN(GenSubFragNoFlags32A)
DEF_PLACEFN(GenXorFragNoFlags32)
DEF_PLACEFN(GenXorFragNoFlags32A)

#undef DEF_PLACEFN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\inc\tc.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    tc.h

Abstract:

    This include file defines the Translation Cache interface.

Author:

    Barry Bond (barrybo) creation-date 29-Jul-1995

Revision History:


--*/

#ifndef _TC_H_
#define _TC_H_

extern ULONG TranslationCacheTimestamp;
extern DWORD TranslationCacheFlags;

BOOL
InitializeTranslationCache(
    VOID
    );

PCHAR
AllocateTranslationCache(
    ULONG Size
    );

VOID
FreeUnusedTranslationCache(
    PCHAR StartOfFree
    );

VOID
PauseAllActiveTCReaders(
    VOID
    );

VOID
FlushTranslationCache(
    PVOID IntelAddr,
    DWORD IntelLength
    );

BOOL
AddressInTranslationCache(
    DWORD Addr
    );

#if DBG
    VOID
    ASSERTPtrInTC(
        PVOID ptr
    );

    #define ASSERTPtrInTCOrZero(ptr) {          \
        if (ptr) {                              \
            ASSERTPtrInTC(ptr);                 \
        }                                       \
    }


#else
    #define ASSERTPtrInTC(ptr)
    #define ASSERTPtrInTCOrZero(ptr)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\inc\idata.h ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation

Module Name:

    idata.h

Abstract:

    This module contains definitions of all x86 instructions.  Before
    including this file, the DEF_INSTR macro must be defined.

Author:

    Dave Hastings (daveh) creation-date 23-Jun-1995

Revision History:


--*/

//
// Possible values for instruction flags (OPFL_):
//  CTRLTRNS -
//             Direct control transfers.  The compiler will build an entrypoint
//             for the destination of the call, provided it is within the
//             current instruction stream
//  END_NEXT_EP -
//             Indicates the instruction following the current one must
//             have its own entrypoint.  ie. CALL instructions.
//  STOP_COMPILE -
//             Compilation will halt after this instruction.  The remainder
//             of the instruction stream will be discarded.
//  ALIGN    -
//             The instruction has an ALIGNED flavor, created by adding 1
//             to the current Operation value.
//  HASNOFLAGS -
//             The instruction as a NOFLAGS flavor, created by the following
//             formula:
//              OP_NOFLAGS = OP + (Flags & OPFL_ALIGN) ? 2 : 1;
//
//

#include <eflags.h>
#define ALLFLAGS (FLAG_CF|FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF)


#ifndef DEF_INSTR
#error Must define DEF_INSTR(OpName,FlagsNeeded,FlagsSet,RegsSet,Opfl,FastPlaceFn,FastSize,SlowPlaceFn,SlowSize,FragName) before including this file
#endif


//
// Each DEF_INSTR defines a new instruction, with the following format:
// DEF_INSTR(instruction name,
//               flags read, flags set, registers implictly modified
//               OP flags
//               place function, size of assembly code for call to fragment
//               address of fragment)
//

DEF_INSTR(OP_CTRL_COND_Ja,
              FLAG_CF|FLAG_ZF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenJaFrag)
DEF_INSTR(OP_CTRL_COND_Jae,
              FLAG_CF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenJaeFrag)
DEF_INSTR(OP_CTRL_COND_Jbe,
              FLAG_CF|FLAG_ZF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenJbeFrag)
DEF_INSTR(OP_CTRL_COND_Jb,
              FLAG_CF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenJbFrag)
DEF_INSTR(OP_CTRL_COND_Je,
              FLAG_ZF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenJeFrag)
DEF_INSTR(OP_CTRL_COND_Jg,
              FLAG_ZF|FLAG_SF|FLAG_OF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenJgFrag)
DEF_INSTR(OP_CTRL_COND_Jl,
              FLAG_SF|FLAG_OF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenJlFrag)
DEF_INSTR(OP_CTRL_COND_Jle,
              FLAG_ZF|FLAG_SF|FLAG_OF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenJleFrag)
DEF_INSTR(OP_CTRL_COND_Jne,
              FLAG_ZF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenJneFrag)
DEF_INSTR(OP_CTRL_COND_Jnl,
              FLAG_SF|FLAG_OF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenJnlFrag)
DEF_INSTR(OP_CTRL_COND_Jno,
              FLAG_OF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenJnoFrag)
DEF_INSTR(OP_CTRL_COND_Jnp,
              FLAG_PF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenJnpFrag)
DEF_INSTR(OP_CTRL_COND_Jns,
              FLAG_SF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenJnsFrag)
DEF_INSTR(OP_CTRL_COND_Jo,
              FLAG_OF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenJoFrag)
DEF_INSTR(OP_CTRL_COND_Jp,
              FLAG_PF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenJpFrag)
DEF_INSTR(OP_CTRL_COND_Js,
              FLAG_SF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenJsFrag)
DEF_INSTR(OP_CTRL_COND_JaFwd,
              FLAG_CF|FLAG_ZF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenJaFrag)
DEF_INSTR(OP_CTRL_COND_JaeFwd,
              FLAG_CF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenJaeFrag)
DEF_INSTR(OP_CTRL_COND_JbeFwd,
              FLAG_CF|FLAG_ZF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenJbeFrag)
DEF_INSTR(OP_CTRL_COND_JbFwd,
              FLAG_CF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenJbFrag)
DEF_INSTR(OP_CTRL_COND_JeFwd,
              FLAG_ZF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenJeFrag)
DEF_INSTR(OP_CTRL_COND_JgFwd,
              FLAG_ZF|FLAG_SF|FLAG_OF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenJgFrag)
DEF_INSTR(OP_CTRL_COND_JlFwd,
              FLAG_SF|FLAG_OF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenJlFrag)
DEF_INSTR(OP_CTRL_COND_JleFwd,
              FLAG_ZF|FLAG_SF|FLAG_OF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenJleFrag)
DEF_INSTR(OP_CTRL_COND_JneFwd,
              FLAG_ZF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenJneFrag)
DEF_INSTR(OP_CTRL_COND_JnlFwd,
              FLAG_SF|FLAG_OF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenJnlFrag)
DEF_INSTR(OP_CTRL_COND_JnoFwd,
              FLAG_OF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenJnoFrag)
DEF_INSTR(OP_CTRL_COND_JnpFwd,
              FLAG_PF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenJnpFrag)
DEF_INSTR(OP_CTRL_COND_JnsFwd,
              FLAG_SF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenJnsFrag)
DEF_INSTR(OP_CTRL_COND_JoFwd,
              FLAG_OF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenJoFrag)
DEF_INSTR(OP_CTRL_COND_JpFwd,
              FLAG_PF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenJpFrag)
DEF_INSTR(OP_CTRL_COND_JsFwd,
              FLAG_SF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenJsFrag)
DEF_INSTR(OP_CTRL_COND_Jcxz_b32,
              0, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenJecxzFrag)
DEF_INSTR(OP_CTRL_COND_Jcxz_b16,
              0, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenJcxzFrag)
DEF_INSTR(OP_CTRL_COND_Jcxz_bFwd32,
              0, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenJecxzFrag)
DEF_INSTR(OP_CTRL_COND_Jcxz_bFwd16,
              0, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenJcxzFrag)
DEF_INSTR(OP_CTRL_COND_Loop_b32,
              0, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenLoopFrag32)
DEF_INSTR(OP_CTRL_COND_Loop_b16,
              0, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenLoopFrag16)
DEF_INSTR(OP_CTRL_COND_Loop_bFwd32,
              0, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenLoopFrag32)
DEF_INSTR(OP_CTRL_COND_Loop_bFwd16,
              0, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenLoopFrag16)
DEF_INSTR(OP_CTRL_COND_Loope_b32,
              FLAG_ZF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenLoopeFrag32)
DEF_INSTR(OP_CTRL_COND_Loope_b16,
              FLAG_ZF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenLoopeFrag16)
DEF_INSTR(OP_CTRL_COND_Loope_bFwd32,
              FLAG_ZF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenLoopeFrag32)
DEF_INSTR(OP_CTRL_COND_Loope_bFwd16,
              FLAG_ZF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenLoopeFrag16)
DEF_INSTR(OP_CTRL_COND_Loopne_b32,
              FLAG_ZF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenLoopneFrag32)
DEF_INSTR(OP_CTRL_COND_Loopne_b16,
              FLAG_ZF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenLoopneFrag16)
DEF_INSTR(OP_CTRL_COND_Loopne_bFwd32,
              FLAG_ZF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenLoopneFrag32)
DEF_INSTR(OP_CTRL_COND_Loopne_bFwd16,
              FLAG_ZF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenLoopneFrag16)
DEF_INSTR(OP_CTRL_UNCOND_Call,
              0, 0, ALLREGS,
              OPFL_CTRLTRNS|OPFL_END_NEXT_EP,
              FN_PlaceCallDirect,
              FN_PlaceCallDirect,
              NULL)
DEF_INSTR(OP_CTRL_UNCOND_Callf,
              0, 0, ALLREGS,
              OPFL_CTRLTRNS|OPFL_END_NEXT_EP,
              FN_PlaceCallfDirect,
              FN_PlaceCallfDirect,
              NULL)
DEF_INSTR(OP_CTRL_INDIR_Call,
              ALLFLAGS, 0, ALLREGS,
              OPFL_END_NEXT_EP,
              FN_GenCallIndirect,
              FN_GenCallIndirect,
              NULL)
DEF_INSTR(OP_CTRL_INDIR_Callf,
              ALLFLAGS, 0, ALLREGS,
              OPFL_END_NEXT_EP,
              FN_GenCallfIndirect,
              FN_GenCallfIndirect,
              NULL)
DEF_INSTR(OP_CTRL_INDIR_Jmp,
              ALLFLAGS, 0, 0,
              OPFL_END_NEXT_EP,
              FN_GenCallJmpIndirect,
              FN_GenCallJmpIndirect,
              NULL)
DEF_INSTR(OP_CTRL_INDIR_Jmpf,
              ALLFLAGS, 0, 0,
              OPFL_END_NEXT_EP,
              FN_GenCallJmpfIndirect,
              FN_GenCallJmpfIndirect,
              NULL)
DEF_INSTR(OP_CTRL_UNCOND_Jmp,
              0, 0, 0,
              OPFL_END_NEXT_EP|OPFL_CTRLTRNS,
              FN_PlaceJmpDirect,
              FN_PlaceJmpDirectSlow,
              NULL)
DEF_INSTR(OP_CTRL_UNCOND_JmpFwd,
              0, 0, 0,
              OPFL_END_NEXT_EP|OPFL_CTRLTRNS,
              FN_PlaceJmpFwdDirect,
              FN_PlaceJmpDirectSlow,
              NULL)
DEF_INSTR(OP_CTRL_UNCOND_Jmpf,
              0, 0, 0,
              OPFL_END_NEXT_EP|OPFL_CTRLTRNS,
              FN_PlaceJmpfDirect,
              FN_PlaceJmpfDirect,
              NULL)
DEF_INSTR(OP_CTRL_INDIR_Retn_i16,
              ALLFLAGS, 0, REGESP,
              OPFL_END_NEXT_EP,
              FN_GenCallRetIndirect,
              FN_GenCallRetIndirect,
              CTRL_INDIR_Retn_iFrag16)
DEF_INSTR(OP_CTRL_INDIR_Retn_i32,
              ALLFLAGS, 0, REGESP,
              OPFL_END_NEXT_EP,
              FN_GenCallRetIndirect,
              FN_GenCallRetIndirect,
              CTRL_INDIR_Retn_iFrag32)
DEF_INSTR(OP_CTRL_INDIR_Retn16,
              ALLFLAGS, 0, REGESP,
              OPFL_END_NEXT_EP,
              FN_GenCallRetIndirect,
              FN_GenCallRetIndirect,
              CTRL_INDIR_RetnFrag16)
DEF_INSTR(OP_CTRL_INDIR_Retn32,
              ALLFLAGS, 0, REGESP,
              OPFL_END_NEXT_EP,
              FN_GenCallRetIndirect,
              FN_GenCallRetIndirect,
              CTRL_INDIR_RetnFrag32)
DEF_INSTR(OP_CTRL_INDIR_Retf_i16,
              ALLFLAGS, 0, REGESP,
              OPFL_END_NEXT_EP,
              FN_GenCallRetIndirect,
              FN_GenCallRetIndirect,
              CTRL_INDIR_Retf_iFrag16)
DEF_INSTR(OP_CTRL_INDIR_Retf_i32,
              ALLFLAGS, 0, REGESP,
              OPFL_END_NEXT_EP,
              FN_GenCallRetIndirect,
              FN_GenCallRetIndirect,
              CTRL_INDIR_Retf_iFrag32)
DEF_INSTR(OP_CTRL_INDIR_Retf16,
              ALLFLAGS, 0, REGESP,
              OPFL_END_NEXT_EP,
              FN_GenCallRetIndirect,
              FN_GenCallRetIndirect,
              CTRL_INDIR_RetfFrag16)
DEF_INSTR(OP_CTRL_INDIR_Retf32,
              ALLFLAGS, 0, REGESP,
              OPFL_END_NEXT_EP,
              FN_GenCallRetIndirect,
              FN_GenCallRetIndirect,
              CTRL_INDIR_RetfFrag32)
DEF_INSTR(OP_Int,
              ALLFLAGS, ALLFLAGS, ALLREGS,
              OPFL_STOP_COMPILE,
              FN_GenCallCFragLoadEip,
              FN_GenCallCFragLoadEipSlow,
              IntFrag)
DEF_INSTR(OP_CTRL_INDIR_IRet,
              ALLFLAGS, ALLFLAGS, REGESP,
              OPFL_END_NEXT_EP,
              FN_GenCallRetIndirect,
              FN_GenCallRetIndirect,
              CTRL_INDIR_IRetFrag)
DEF_INSTR(OP_Unsimulate,
              ALLFLAGS, ALLFLAGS, ALLREGS,
              OPFL_STOP_COMPILE,
              FN_GenCallCFragNoCpu,
              FN_GenCallCFragNoCpuSlow,
              UnsimulateFrag)
DEF_INSTR(OP_PrivilegedInstruction,
              ALLFLAGS, ALLFLAGS, ALLREGS,
              OPFL_STOP_COMPILE,
              FN_GenCallCFragLoadEip,
              FN_GenCallCFragLoadEipSlow,
              PrivilegedInstructionFrag)
DEF_INSTR(OP_BadInstruction,
              ALLFLAGS, ALLFLAGS, ALLREGS,
              OPFL_STOP_COMPILE,
              FN_GenCallCFragLoadEip,
              FN_GenCallCFragLoadEipSlow,
              BadInstructionFrag)
DEF_INSTR(OP_Fault,
              ALLFLAGS, ALLFLAGS, ALLREGS,
              OPFL_STOP_COMPILE,
              FN_GenCallCFragLoadEip,
              FN_GenCallCFragLoadEipSlow,
              FaultFrag)
DEF_INSTR(OP_IntO,
              FLAG_OF, ALLFLAGS, ALLREGS,
              OPFL_STOP_COMPILE,
              FN_GenCallCFragLoadEip,
              FN_GenCallCFragLoadEipSlow,
              IntOFrag)

// Next 4 must be consecutive
DEF_INSTR(OP_Add32,
              0, ALLFLAGS, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AddFrag32)
DEF_INSTR(OP_Add32A,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AddFrag32A)
DEF_INSTR(OP_AddNoFlags32,
              0, ALLFLAGS, 0,
              OPFL_ALIGN|OPFL_INLINEARITH,
              FN_GenAddFragNoFlags32, FN_GenCallCFragNoCpuSlow,
              AddNoFlagsFrag32)
DEF_INSTR(OP_AddNoFlags32A,
              0, ALLFLAGS, 0,
              OPFL_INLINEARITH,
              FN_GenAddFragNoFlags32A, FN_GenCallCFragNoCpuSlow,
              AddNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Add16,
              0, ALLFLAGS, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AddFrag16)
DEF_INSTR(OP_Add16A,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AddFrag16A)
DEF_INSTR(OP_AddNoFlags16,
              0, ALLFLAGS, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              AddNoFlagsFrag16)
DEF_INSTR(OP_AddNoFlags16A,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              AddNoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Add8,
              0, ALLFLAGS, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AddFrag8)
DEF_INSTR(OP_AddNoFlags8,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              AddNoFlagsFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_Inc32,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              IncFrag32)
DEF_INSTR(OP_Inc32A,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              IncFrag32A)
DEF_INSTR(OP_IncNoFlags32,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_INLINEARITH,
              FN_GenIncFragNoFlags32, FN_GenCallCFragNoCpuSlow,
              IncNoFlagsFrag32)
DEF_INSTR(OP_IncNoFlags32A,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_INLINEARITH,
              FN_GenIncFragNoFlags32A, FN_GenCallCFragNoCpuSlow,
              IncNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Inc16,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              IncFrag16)
DEF_INSTR(OP_Inc16A,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              IncFrag16A)
DEF_INSTR(OP_IncNoFlags16,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              IncNoFlagsFrag16)
DEF_INSTR(OP_IncNoFlags16A,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              IncNoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Inc8,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              IncFrag8)
DEF_INSTR(OP_IncNoFlags8,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              IncNoFlagsFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_Dec32,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              DecFrag32)
DEF_INSTR(OP_Dec32A,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              DecFrag32A)
DEF_INSTR(OP_DecNoFlags32,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_INLINEARITH,
              FN_GenDecFragNoFlags32, FN_GenCallCFragNoCpuSlow,
              DecNoFlagsFrag32)
DEF_INSTR(OP_DecNoFlags32A,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_INLINEARITH,
              FN_GenDecFragNoFlags32A, FN_GenCallCFragNoCpuSlow,
              DecNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Dec16,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              DecFrag16)
DEF_INSTR(OP_Dec16A,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              DecFrag16A)
DEF_INSTR(OP_DecNoFlags16,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              DecNoFlagsFrag16)
DEF_INSTR(OP_DecNoFlags16A,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              DecNoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Dec8,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              DecFrag8)
DEF_INSTR(OP_DecNoFlags8,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              DecNoFlagsFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_Sub32,
              0, ALLFLAGS, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SubFrag32)
DEF_INSTR(OP_Sub32A,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SubFrag32A)
DEF_INSTR(OP_SubNoFlags32,
              0, ALLFLAGS, 0,
              OPFL_ALIGN|OPFL_INLINEARITH,
              FN_GenSubFragNoFlags32, FN_GenCallCFragNoCpuSlow,
              SubNoFlagsFrag32)
DEF_INSTR(OP_SubNoFlags32A,
              0, ALLFLAGS, 0,
              OPFL_INLINEARITH,
              FN_GenSubFragNoFlags32A, FN_GenCallCFragNoCpuSlow,
              SubNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Sub16,
              0, ALLFLAGS, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SubFrag16)
DEF_INSTR(OP_Sub16A,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SubFrag16A)
DEF_INSTR(OP_SubNoFlags16,
              0, ALLFLAGS, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              SubNoFlagsFrag16)
DEF_INSTR(OP_SubNoFlags16A,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              SubNoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Sub8,
              0, ALLFLAGS, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SubFrag8)
DEF_INSTR(OP_SubNoFlags8,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              SubNoFlagsFrag8)

DEF_INSTR(OP_Cmp32,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              CmpFrag32)
DEF_INSTR(OP_Cmp16,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              CmpFrag16)
DEF_INSTR(OP_Cmp8,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              CmpFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_Adc32,
              FLAG_CF, ALLFLAGS, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AdcFrag32)
DEF_INSTR(OP_Adc32A,
              FLAG_CF, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AdcFrag32A)
DEF_INSTR(OP_AdcNoFlags32,
              FLAG_CF, ALLFLAGS, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AdcNoFlagsFrag32)
DEF_INSTR(OP_AdcNoFlags32A,
              FLAG_CF, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AdcNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Adc16,
              FLAG_CF, ALLFLAGS, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AdcFrag16)
DEF_INSTR(OP_Adc16A,
              FLAG_CF, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AdcFrag16A)
DEF_INSTR(OP_AdcNoFlags16,
              FLAG_CF, ALLFLAGS, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AdcNoFlagsFrag16)
DEF_INSTR(OP_AdcNoFlags16A,
              FLAG_CF, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AdcNoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Adc8,
              FLAG_CF, ALLFLAGS, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AdcFrag8)
DEF_INSTR(OP_AdcNoFlags8,
              FLAG_CF, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AdcNoFlagsFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_Sbb32,
              FLAG_CF, ALLFLAGS, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SbbFrag32)
DEF_INSTR(OP_Sbb32A,
              FLAG_CF, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SbbFrag32A)
DEF_INSTR(OP_SbbNoFlags32,
              FLAG_CF, ALLFLAGS, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SbbNoFlagsFrag32)
DEF_INSTR(OP_SbbNoFlags32A,
              FLAG_CF, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SbbNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Sbb16,
              FLAG_CF, ALLFLAGS, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SbbFrag16)
DEF_INSTR(OP_Sbb16A,
              FLAG_CF, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SbbFrag16A)
DEF_INSTR(OP_SbbNoFlags16,
              FLAG_CF, ALLFLAGS, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SbbNoFlagsFrag16)
DEF_INSTR(OP_SbbNoFlags16A,
              FLAG_CF, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SbbNoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Sbb8,
              FLAG_CF, ALLFLAGS, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SbbFrag8)
DEF_INSTR(OP_SbbNoFlags8,
              FLAG_CF, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SbbNoFlagsFrag8)


DEF_INSTR(OP_Mov32,
              0, 0, 0,
              0,
              FN_PlaceNop, FN_GenEndMovSlow,
              NULL)
DEF_INSTR(OP_Mov16,
              0, 0, 0,
              OPFL_ADDR16,
              FN_PlaceNop, FN_GenEndMovSlow,
              NULL)
DEF_INSTR(OP_Mov8,
              0, 0, 0,
              0,
              FN_PlaceNop, FN_GenEndMovSlow,
              NULL)

// Next 4 must be consecutive
DEF_INSTR(OP_Or32,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OrFrag32)
DEF_INSTR(OP_Or32A,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OrFrag32A)
DEF_INSTR(OP_OrNoFlags32,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_INLINEARITH,
              FN_GenOrFragNoFlags32, FN_GenCallCFragNoCpuSlow,
              OrNoFlagsFrag32)
DEF_INSTR(OP_OrNoFlags32A,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_INLINEARITH,
              FN_GenOrFragNoFlags32A, FN_GenCallCFragNoCpuSlow,
              OrNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Or16,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OrFrag16)
DEF_INSTR(OP_Or16A,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OrFrag16A)
DEF_INSTR(OP_OrNoFlags16,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              OrNoFlagsFrag16)
DEF_INSTR(OP_OrNoFlags16A,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              OrNoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Or8,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OrFrag8)
DEF_INSTR(OP_OrNoFlags8,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              OrNoFlagsFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_And32,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AndFrag32)
DEF_INSTR(OP_And32A,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AndFrag32A)
DEF_INSTR(OP_AndNoFlags32,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_INLINEARITH,
              FN_GenAndFragNoFlags32, FN_GenCallCFragNoCpuSlow,
              AndNoFlagsFrag32)
DEF_INSTR(OP_AndNoFlags32A,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_INLINEARITH,
              FN_GenAndFragNoFlags32A, FN_GenCallCFragNoCpuSlow,
              AndNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_And16,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AndFrag16)
DEF_INSTR(OP_And16A,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AndFrag16A)
DEF_INSTR(OP_AndNoFlags16,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              AndNoFlagsFrag16)
DEF_INSTR(OP_AndNoFlags16A,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              AndNoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_And8,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AndFrag8)
DEF_INSTR(OP_AndNoFlags8,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              AndNoFlagsFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_Xor32,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              XorFrag32)
DEF_INSTR(OP_Xor32A,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              XorFrag32A)
DEF_INSTR(OP_XorNoFlags32,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_INLINEARITH,
              FN_GenXorFragNoFlags32, FN_GenCallCFragNoCpuSlow,
              XorNoFlagsFrag32)
DEF_INSTR(OP_XorNoFlags32A,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_INLINEARITH,
              FN_GenXorFragNoFlags32A, FN_GenCallCFragNoCpuSlow,
              XorNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Xor16,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              XorFrag16)
DEF_INSTR(OP_Xor16A,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              XorFrag16A)
DEF_INSTR(OP_XorNoFlags16,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              XorNoFlagsFrag16)
DEF_INSTR(OP_XorNoFlags16A,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              XorNoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Xor8,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              XorFrag8)
DEF_INSTR(OP_XorNoFlags8,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              XorNoFlagsFrag8)

DEF_INSTR(OP_Test32,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              TestFrag32)
DEF_INSTR(OP_Test16,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              TestFrag16)
DEF_INSTR(OP_Test8,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              TestFrag8)

// Next 2 must be consecutive
DEF_INSTR(OP_Xchg32,
              0, 0, 0,
              OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              XchgFrag32)
DEF_INSTR(OP_Xchg32A,
              0, 0, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              XchgFrag32A)
// Next 2 must be consecutive
DEF_INSTR(OP_Xchg16,
              0, 0, 0,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              XchgFrag16)
DEF_INSTR(OP_Xchg16A,
              0, 0, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              XchgFrag16A)
DEF_INSTR(OP_Xchg8,
              0, 0, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              XchgFrag8)

// Next 2 must be consecutive
DEF_INSTR(OP_Rol32,
              FLAG_CF, FLAG_CF, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RolFrag32)
DEF_INSTR(OP_Rol32A,
              FLAG_CF, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RolFrag32A)
// Next 2 must be consecutive
DEF_INSTR(OP_Rol16,
              FLAG_CF, FLAG_CF, 0,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RolFrag16)
DEF_INSTR(OP_Rol16A,
              FLAG_CF, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RolFrag16A)
DEF_INSTR(OP_Rol8,
              FLAG_CF, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RolFrag8)

// Next 2 must be consecutive
DEF_INSTR(OP_Ror32,
              FLAG_CF, FLAG_CF, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RorFrag32)
DEF_INSTR(OP_Ror32A,
              FLAG_CF, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RorFrag32A)
// Next 2 must be consecutive
DEF_INSTR(OP_Ror16,
              FLAG_CF, FLAG_CF, 0,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RorFrag16)
DEF_INSTR(OP_Ror16A,
              FLAG_CF, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RorFrag16A)
DEF_INSTR(OP_Ror8,
              FLAG_CF, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RorFrag8)

// Next 2 must be consecutive
DEF_INSTR(OP_Rcl32,
              FLAG_CF, FLAG_CF, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RclFrag32)
DEF_INSTR(OP_Rcl32A,
              FLAG_CF, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RclFrag32A)
// Next 2 must be consecutive
DEF_INSTR(OP_Rcl16,
              FLAG_CF, FLAG_CF, 0,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RclFrag16)
DEF_INSTR(OP_Rcl16A,
              FLAG_CF, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RclFrag16A)
DEF_INSTR(OP_Rcl8,
              FLAG_CF, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RclFrag8)

// Next 2 must be consecutive
DEF_INSTR(OP_Rcr32,
              FLAG_CF, FLAG_CF, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RcrFrag32)
DEF_INSTR(OP_Rcr32A,
              FLAG_CF, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RcrFrag32A)
// Next 2 must be consecutive
DEF_INSTR(OP_Rcr16,
              FLAG_CF, FLAG_CF, 0,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RcrFrag16)
DEF_INSTR(OP_Rcr16A,
              FLAG_CF, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RcrFrag16A)
DEF_INSTR(OP_Rcr8,
              FLAG_CF, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RcrFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_Shl32,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ShlFrag32)
DEF_INSTR(OP_Shl32A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ShlFrag32A)
DEF_INSTR(OP_ShlNoFlags32,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              ShlNoFlagsFrag32)
DEF_INSTR(OP_ShlNoFlags32A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              ShlNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Shl16,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ShlFrag16)
DEF_INSTR(OP_Shl16A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ShlFrag16A)
DEF_INSTR(OP_ShlNoFlags16,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              ShlNoFlagsFrag16)
DEF_INSTR(OP_ShlNoFlags16A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              ShlNoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Shl8,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ShlFrag8)
DEF_INSTR(OP_ShlNoFlags8,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              ShlNoFlagsFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_Shr32,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ShrFrag32)
DEF_INSTR(OP_Shr32A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ShrFrag32A)
DEF_INSTR(OP_ShrNoFlags32,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              ShrNoFlagsFrag32)
DEF_INSTR(OP_ShrNoFlags32A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              ShrNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Shr16,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ShrFrag16)
DEF_INSTR(OP_Shr16A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ShrFrag16A)
DEF_INSTR(OP_ShrNoFlags16,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              ShrNoFlagsFrag16)
DEF_INSTR(OP_ShrNoFlags16A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              ShrNoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Shr8,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ShrFrag8)
DEF_INSTR(OP_ShrNoFlags8,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              ShrNoFlagsFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_Sar32,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SarFrag32)
DEF_INSTR(OP_Sar32A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SarFrag32A)
DEF_INSTR(OP_SarNoFlags32,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              SarNoFlagsFrag32)
DEF_INSTR(OP_SarNoFlags32A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              SarNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Sar16,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SarFrag16)
DEF_INSTR(OP_Sar16A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SarFrag16A)
DEF_INSTR(OP_SarNoFlags16,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              SarNoFlagsFrag16)
DEF_INSTR(OP_SarNoFlags16A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              SarNoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Sar8,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SarFrag8)
DEF_INSTR(OP_SarNoFlags8,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              SarNoFlagsFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_Rol132,
              0, FLAG_CF|FLAG_OF, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rol1Frag32)
DEF_INSTR(OP_Rol132A,
              0, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rol1Frag32A)
DEF_INSTR(OP_Rol1NoFlags32,
              0, FLAG_CF|FLAG_OF, 0,
              OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Rol1NoFlagsFrag32)
DEF_INSTR(OP_Rol1NoFlags32A,
              0, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Rol1NoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Rol116,
              0, FLAG_CF|FLAG_OF, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rol1Frag16)
DEF_INSTR(OP_Rol116A,
              0, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rol1Frag16A)
DEF_INSTR(OP_Rol1NoFlags16,
              0, FLAG_CF|FLAG_OF, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Rol1NoFlagsFrag16)
DEF_INSTR(OP_Rol1NoFlags16A,
              0, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Rol1NoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Rol18,
              0, FLAG_CF|FLAG_OF, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rol1Frag8)
DEF_INSTR(OP_Rol1NoFlags8,
              0, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Rol1NoFlagsFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_Ror132,
              0, FLAG_CF|FLAG_OF, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Ror1Frag32)
DEF_INSTR(OP_Ror132A,
              0, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Ror1Frag32A)
DEF_INSTR(OP_Ror1NoFlags32,
              0, FLAG_CF|FLAG_OF, 0,
              OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Ror1NoFlagsFrag32)
DEF_INSTR(OP_Ror1NoFlags32A,
              0, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Ror1NoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Ror116,
              0, FLAG_CF|FLAG_OF, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Ror1Frag16)
DEF_INSTR(OP_Ror116A,
              0, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Ror1Frag16A)
DEF_INSTR(OP_Ror1NoFlags16,
              0, FLAG_CF|FLAG_OF, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Ror1NoFlagsFrag16)
DEF_INSTR(OP_Ror1NoFlags16A,
              0, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Ror1NoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Ror18,
              0, FLAG_CF|FLAG_OF, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Ror1Frag8)
DEF_INSTR(OP_Ror1NoFlags8,
              0, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Ror1NoFlagsFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_Rcl132,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcl1Frag32)
DEF_INSTR(OP_Rcl132A,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcl1Frag32A)
DEF_INSTR(OP_Rcl1NoFlags32,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcl1NoFlagsFrag32)
DEF_INSTR(OP_Rcl1NoFlags32A,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcl1NoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Rcl116,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcl1Frag16)
DEF_INSTR(OP_Rcl116A,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcl1Frag16A)
DEF_INSTR(OP_Rcl1NoFlags16,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcl1NoFlagsFrag16)
DEF_INSTR(OP_Rcl1NoFlags16A,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcl1NoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Rcl18,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcl1Frag8)
DEF_INSTR(OP_Rcl1NoFlags8,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcl1NoFlagsFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_Rcr132,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcr1Frag32)
DEF_INSTR(OP_Rcr132A,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcr1Frag32A)
DEF_INSTR(OP_Rcr1NoFlags32,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcr1NoFlagsFrag32)
DEF_INSTR(OP_Rcr1NoFlags32A,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcr1NoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Rcr116,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcr1Frag16)
DEF_INSTR(OP_Rcr116A,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcr1Frag16A)
DEF_INSTR(OP_Rcr1NoFlags16,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcr1NoFlagsFrag16)
DEF_INSTR(OP_Rcr1NoFlags16A,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcr1NoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Rcr18,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcr1Frag8)
DEF_INSTR(OP_Rcr1NoFlags8,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcr1NoFlagsFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_Shl132,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Shl1Frag32)
DEF_INSTR(OP_Shl132A,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Shl1Frag32A)
DEF_INSTR(OP_Shl1NoFlags32,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Shl1NoFlagsFrag32)
DEF_INSTR(OP_Shl1NoFlags32A,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Shl1NoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Shl116,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Shl1Frag16)
DEF_INSTR(OP_Shl116A,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Shl1Frag16A)
DEF_INSTR(OP_Shl1NoFlags16,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Shl1NoFlagsFrag16)
DEF_INSTR(OP_Shl1NoFlags16A,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Shl1NoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Shl18,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Shl1Frag8)
DEF_INSTR(OP_Shl1NoFlags8,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Shl1NoFlagsFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_Shr132,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Shr1Frag32)
DEF_INSTR(OP_Shr132A,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Shr1Frag32A)
DEF_INSTR(OP_Shr1NoFlags32,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Shr1NoFlagsFrag32)
DEF_INSTR(OP_Shr1NoFlags32A,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Shr1NoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Shr116,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Shr1Frag16)
DEF_INSTR(OP_Shr116A,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Shr1Frag16A)
DEF_INSTR(OP_Shr1NoFlags16,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Shr1NoFlagsFrag16)
DEF_INSTR(OP_Shr1NoFlags16A,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Shr1NoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Shr18,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Shr1Frag8)
DEF_INSTR(OP_Shr1NoFlags8,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Shr1NoFlagsFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_Sar132,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Sar1Frag32)
DEF_INSTR(OP_Sar132A,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Sar1Frag32A)
DEF_INSTR(OP_Sar1NoFlags32,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Sar1NoFlagsFrag32)
DEF_INSTR(OP_Sar1NoFlags32A,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Sar1NoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Sar116,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Sar1Frag16)
DEF_INSTR(OP_Sar116A,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Sar1Frag16A)
DEF_INSTR(OP_Sar1NoFlags16,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Sar1NoFlagsFrag16)
DEF_INSTR(OP_Sar1NoFlags16A,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Sar1NoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Sar18,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Sar1Frag8)
DEF_INSTR(OP_Sar1NoFlags8,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Sar1NoFlagsFrag8)

// Next 2 must be consecutive
DEF_INSTR(OP_Not32,
              0, 0, 0,
              OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              NotFrag32)
DEF_INSTR(OP_Not32A,
              0, 0, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              NotFrag32A)
// Next 2 must be consecutive
DEF_INSTR(OP_Not16,
              0, 0, 0,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              NotFrag16)
DEF_INSTR(OP_Not16A,
              0, 0, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              NotFrag16A)
DEF_INSTR(OP_Not8,
              0, 0, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              NotFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_Neg32,
              0, ALLFLAGS, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              NegFrag32)
DEF_INSTR(OP_Neg32A,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              NegFrag32A)
DEF_INSTR(OP_NegNoFlags32,
              0, ALLFLAGS, 0,
              OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              NegNoFlagsFrag32)
DEF_INSTR(OP_NegNoFlags32A,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              NegNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Neg16,
              0, ALLFLAGS, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              NegFrag16)
DEF_INSTR(OP_Neg16A,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              NegFrag16A)
DEF_INSTR(OP_NegNoFlags16,
              0, ALLFLAGS, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              NegNoFlagsFrag16)
DEF_INSTR(OP_NegNoFlags16A,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              NegNoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Neg8,
              0, ALLFLAGS, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              NegFrag8)
DEF_INSTR(OP_NegNoFlags8,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              NegNoFlagsFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_Mul32,
              0, FLAG_CF|FLAG_OF, REGEAX|REGEDX,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MulFrag32)
DEF_INSTR(OP_Mul32A,
              0, FLAG_CF|FLAG_OF, REGEAX|REGEDX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MulFrag32A)
DEF_INSTR(OP_MulNoFlags32,
              0, FLAG_CF|FLAG_OF, REGEAX|REGEDX,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MulNoFlagsFrag32)
DEF_INSTR(OP_MulNoFlags32A,
              0, FLAG_CF|FLAG_OF, REGEAX|REGEDX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MulNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Mul16,
              0, FLAG_CF|FLAG_OF, REGAX|REGDX,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MulFrag16)
DEF_INSTR(OP_Mul16A,
              0, FLAG_CF|FLAG_OF, REGAX|REGDX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MulFrag16A)
DEF_INSTR(OP_MulNoFlags16,
              0, FLAG_CF|FLAG_OF, REGAX|REGDX,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MulNoFlagsFrag16)
DEF_INSTR(OP_MulNoFlags16A,
              0, FLAG_CF|FLAG_OF, REGAX|REGDX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MulNoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Mul8,
              0, FLAG_CF|FLAG_OF, REGAX,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MulFrag8)
DEF_INSTR(OP_MulNoFlags8,
              0, FLAG_CF|FLAG_OF, REGAX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MulNoFlagsFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_Muli32,
              0, FLAG_CF|FLAG_OF, REGEAX|REGEDX,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MuliFrag32)
DEF_INSTR(OP_Muli32A,
              0, FLAG_CF|FLAG_OF, REGEAX|REGEDX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MuliFrag32A)
DEF_INSTR(OP_MuliNoFlags32,
              0, FLAG_CF|FLAG_OF, REGEAX|REGEDX,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MuliNoFlagsFrag32)
DEF_INSTR(OP_MuliNoFlags32A,
              0, FLAG_CF|FLAG_OF, REGEAX|REGEDX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MuliNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Muli16,
              0, FLAG_CF|FLAG_OF, REGAX|REGDX,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MuliFrag16)
DEF_INSTR(OP_Muli16A,
              0, FLAG_CF|FLAG_OF, REGAX|REGDX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MuliFrag16A)
DEF_INSTR(OP_MuliNoFlags16,
              0, FLAG_CF|FLAG_OF, REGAX|REGDX,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MuliNoFlagsFrag16)
DEF_INSTR(OP_MuliNoFlags16A,
              0, FLAG_CF|FLAG_OF, REGAX|REGDX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MuliNoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Muli8,
              0, FLAG_CF|FLAG_OF, REGAX,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MuliFrag8)
DEF_INSTR(OP_MuliNoFlags8,
              0, FLAG_CF|FLAG_OF, REGAX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MuliNoFlagsFrag8)

// Next 2 must be consecutive
DEF_INSTR(OP_Div32,
              0, 0, REGEAX|REGEDX,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              DivFrag32)
DEF_INSTR(OP_Div32A,
              0, 0, REGEAX|REGEDX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              DivFrag32A)
// Next 2 must be consecutive
DEF_INSTR(OP_Div16,
              0, 0, REGAX|REGDX,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              DivFrag16)
DEF_INSTR(OP_Div16A,
              0, 0, REGAX|REGDX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              DivFrag16A)
DEF_INSTR(OP_Div8,
              0, 0, REGAX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              DivFrag8)

// Next 2 must be consecutive
DEF_INSTR(OP_Idiv32,
              0, 0, REGEAX|REGEDX,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              IdivFrag32)
DEF_INSTR(OP_Idiv32A,
              0, 0, REGEAX|REGEDX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              IdivFrag32A)
// Next 2 must be consecutive
DEF_INSTR(OP_Idiv16,
              0, 0, REGAX|REGDX,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              IdivFrag16)
DEF_INSTR(OP_Idiv16A,
              0, 0, REGAX|REGDX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              IdivFrag16A)
DEF_INSTR(OP_Idiv8,
              0, 0, REGAX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              IdivFrag8)

DEF_INSTR(OP_Lods32,
              0, 0, REGEAX|REGESI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LodsFrag32)
DEF_INSTR(OP_Lods16,
              0, 0, REGAX|REGESI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LodsFrag16)
DEF_INSTR(OP_Lods8,
              0, 0, REGAL|REGESI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LodsFrag8)

DEF_INSTR(OP_FsLods32,
              0, 0, REGEAX|REGESI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsLodsFrag32)
DEF_INSTR(OP_FsLods16,
              0, 0, REGAX|REGESI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsLodsFrag16)
DEF_INSTR(OP_FsLods8,
              0, 0, REGAL|REGESI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsLodsFrag8)

DEF_INSTR(OP_RepLods32,
              0, 0, REGEAX|REGECX|REGESI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepLodsFrag32)
DEF_INSTR(OP_RepLods16,
              0, 0, REGAX|REGECX|REGESI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepLodsFrag16)
DEF_INSTR(OP_RepLods8,
              0, 0, REGAL|REGECX|RE