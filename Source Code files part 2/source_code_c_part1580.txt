 cbVSplit == 0 ? 0 : cbVSplitThreshold ) ) ) ||
		( cbThis > cbReq && cbVSplit < cbReq ) ) )
		{
		Assert( itag != itagFOP );
		itagVSplit = itag;
		cbVSplit = cbThis;
		clineVSplit = cbSon;
		clineVSplitTotal = clineTotalThis;
		Assert( clineVSplit != 1 || cbVSplit <= cbAvailMost );
		}

	return;
	}


//+private----------------------------------------------------------------------
//
//	BTHSplit
//	============================================================================
//
//	LOCAL VOID BTHSplit( FUCB *pfucb, INT cbReq, BOOL fAppendPage,
//		BOOL fReplace, BOOL fDIRFlags, INT *pibSon, KEY *pkeyMac, KEY *pkey,
//		BOOL *pf, BOOL *pfAppend )
//
//	Selects right or left horizontal split and location of split.
//
//	If required additional space greater than space currently used in
//	page, then split at key or node requiring additional space.
//	Otherwise, determine
//
//	Note, BTHSplit also supports the concept that an operation may
//	be and update ibSon - 1 and insert ibSon, as occurrs with
//	insertion of page pointer nodes.  This can be distinguished
//	when the page is not visible sons, and the selection algorithm is
//	adjusted not to split at ibSon.
//
//------------------------------------------------------------------------------
LOCAL VOID BTHSplit(
	FUCB   	*pfucb,
	INT		cbReq,
	BOOL   	fAppendPage,
	BOOL   	fReplace,
	BOOL   	fDIRFlags,
	INT		*pibSon,
	KEY		*pkeyMac,
	KEY		*pkey,
	BOOL   	*pfRight,
	BOOL   	*pfAppend,
	SPLIT  	*psplit )
	{
	SSIB   	*pssib = &pfucb->ssib;
	INT		ibSon;
	BYTE   	*pbSon;
	BYTE   	*rgitagSon;
	BYTE   	*pbSonMax;
	INT		cbSon;
	INT		cbT;
	INT		ibSonT;
	INT		cbTotal = cbAvailMost - CbPMFreeSpace( pssib ) - CbPMLinkSpace( pssib ) + cbReq;
	BOOL   	fInsertLeftPage;
	BOOL   	fVisibleSons;

	/*	set pbSon to point to first son and cbSon to number of sons.
	/**/
	NDGet( pfucb, itagFOP );
	fVisibleSons = FNDVisibleSons( *pssib->line.pb );

	Assert ( CbNDSon(pssib->line.pb) != 0 );
	pbSon = PbNDSonTable( pssib->line.pb );
	cbSon = CbNDSonTable( pbSon );
	pbSon++;
	rgitagSon = pbSon;

	/*	get greatest key in page for new key for page pointer to this page.
	/**/
	NDGet( pfucb, pbSon[cbSon - 1] );
	pkeyMac->pb = PbNDKey( pssib->line.pb );
	pkeyMac->cb = CbNDKey( pssib->line.pb );

	/*	APPEND cases, i.e. split no nodes to right
	/**/

	/*	append when updating last node in non-clustered index
	/**/
	if ( ( fDIRFlags & fDIRAppendItem ) && ( *pibSon == cbSon - 1 ) )
		{
		*pfRight = fTrue;
		*pkey = *pkeyMac;
		Assert( fVisibleSons );
		BTIStoreLeafSplitKey( psplit, pssib );
		*pfAppend = fTrue;
		return;
		}

	/*	append when no next page in B-tree and inserting node at end of page
	/**/
	if ( fAppendPage && *pibSon == cbSon )
		{
		/*	inserted nodes are ALWAYS inserted on new page, but replaced
		/*	nodes may or may not be moved.  If split is for replacement
		/*	then a child split of this split, may have a parent CSR that
		/*	will not move, but it must move to support the insertion of
		/*	the new page pointer node.  Thus, split avoids MCM
		/*	inconsistencies	by forcing the page pointer for current
		/*	page to be moved to the new page.
		/**/
		if ( fVisibleSons || psplit->op == opInsert )
			{
			*pfRight = fTrue;

			if ( fVisibleSons )
				{
				/* store the leaf page split key info
				/**/
				pkey->pb = PbNDKey( pssib->line.pb );
				pkey->cb = CbNDKey( pssib->line.pb );

				BTIStoreLeafSplitKey( psplit, pssib );
				}

			*pfAppend = fTrue;
			return;
			}
		}

	/*	if replacing node and page cannot hold node due to link
	/*	overhead, split only node to next page.
	/**/
	if ( fVisibleSons &&
		fReplace &&
		cbSon == 1 &&
		cbReq > CbPMFreeSpace( pssib ) )
		{
		*pfRight = fTrue;
		pkey->pb = PbNDKey(pssib->line.pb);
		pkey->cb = CbNDKey(pssib->line.pb);
		Assert( fVisibleSons );
		BTIStoreLeafSplitKey( psplit, pssib );
		*pfAppend = fFalse;
		return;
		}

	/*	append when inserting node larger than half of total space
	/*	at end of page, same effect as append page, except it is leaf only
	/**/
	if ( fVisibleSons &&
		!fReplace &&
		cbReq >= ( cbTotal / 2 ) &&
		*pibSon == (INT)cbSon )
		{
		*pfRight = fTrue;
		pkey->pb = PbNDKey(pssib->line.pb);
		pkey->cb = CbNDKey(pssib->line.pb);
		Assert( fVisibleSons );
		BTIStoreLeafSplitKey( psplit, pssib );
		*pfAppend = fTrue;
		return;
		}

	/*	prepend when inserting node larger than half of total space
	/*	at start of page.  Get split key from key of first node
	/*	on this page.  Note that the key of the inserted node cannot
	/*	be used as a result of the BT key conflict search algorithm!
	/**/
	if ( fVisibleSons &&
		!fReplace &&
		cbReq >= ( cbTotal / 2 ) &&
		*pibSon == 0 )
		{
		*pfRight = fFalse;
		NDGet( pfucb, pbSon[0] );
		pkey->pb = PbNDKey(pssib->line.pb);
		pkey->cb = CbNDKey(pssib->line.pb);
		Assert( fVisibleSons );
		BTIStoreLeafSplitKey( psplit, pssib );
		/*	set *pibSon to ibSonNull as a flag to move no nodes
		/**/
		*pibSon = ibSonNull;
		*pfAppend = fFalse;
		return;
		}

	/*	if only one node on page, and updating then split right, else
	/*	if inserting at ibSon 0 then split left or if inserting at ibSon 1
	/*	then split right.
	/**/
	if ( cbSon == 1 )
		{
		Assert( fVisibleSons );

		NDGet( pfucb, pbSon[0] );
		*pfRight = memcmp( pkey->pb, PbNDKey( pssib->line.pb ),
			min( CbNDKey( pssib->line.pb ), pkey->cb ) ) >= 0;
		if ( !*pfRight )
			{
			Assert( !fReplace && *pibSon == 0 );
			*pibSon = ibSonNull;

			/*	if left split then get split key from key of first node
			/*	on this page.  Note that the key of the inserted node cannot
			/*	be used as a result of the BT key conflict search algorithm!
			/**/
			pkey->pb = PbNDKey( pssib->line.pb );
			pkey->cb = CbNDKey( pssib->line.pb );
			}
#ifdef DEBUG
		else
			{
			Assert( fReplace && *pibSon == 0 || !fReplace && *pibSon == 1 );
			}
#endif

		Assert( fVisibleSons );
		BTIStoreLeafSplitKey( psplit, pssib );
		*pfAppend = fFalse;
		return;
		}

	/*	OTHER cases, i.e. find best place to split to have equal free
	/*	space in both pages.  Note that care must be taken to avoid
	/*	splitting data larger than page size as a result of backlinks.
	/**/
	if ( !fReplace && *pibSon == cbSon )
		{
		/* an append
		/**/
		pbSonMax = pbSon + cbSon + 1;
		}
	else
		{
		pbSonMax = pbSon + cbSon;
		}
	cbT = 0;
	fInsertLeftPage = fFalse;
	for ( ibSon = 0; pbSon < pbSonMax; ibSon++, pbSon++ )
		{
		/*	if traversing inserted/replaced node add cbReq
		/**/
		if ( ibSon == (INT)*pibSon )
			{
			cbT += cbReq;
			}

		if ( !fReplace && ibSon == cbSon )
			break;

		/* if this is the inserting spot, then split on this ibSon, and
		/* insert the new node into the left page.
		/**/
		if ( !fReplace && cbT >= ( cbTotal / 2 ) )
			{
			fInsertLeftPage = fTrue;
			break;
			}

		cbT += UsBTWeight( pfucb, (INT)*pbSon );
		if ( cbT >= ( cbTotal / 2 ) )
			break;
		}

	/*	if cannot select on size, i.e when no tags left,
	/*	then just split page into halves
	/**/
	Assert( pbSon <= pbSonMax );
	if ( pbSon == pbSonMax )
		ibSon = cbSon / 2 ;

	Assert( cbSon > 1 );

	/* regular rule for split right
	/**/
	if ( ( ibSon != 0 && *pibSon >= ibSon ) ||
		( ibSon == 0 && *pibSon > ibSon ) )
		{
		*pfRight = fTrue;
		if ( ibSon == 0 )
			ibSon++;

		/*	since we did not compute the space required in the right split,
		/*	compute the space from right most to ibSon, and shunt if greater
		/*	than available page space.
		/**/
		cbT = 0;
		for ( ibSonT = cbSon - 1; ibSonT > ibSon; ibSonT-- )
			{
			if ( ibSonT == (INT)*pibSon - 1 )
				cbT += cbReq;

			cbT += UsBTWeight( pfucb, (INT)rgitagSon[ibSonT] );
			if ( cbT > cbAvailMost )
				break;
			}
		if ( ibSonT > ibSon )
			ibSon = ibSonT;
		if ( !fVisibleSons && ibSon == *pibSon )
			{
			Assert( cbSon > 2 );
#define BUGFIX 1
#ifdef BUGFIX
			/*	adjust split point to keep current page pointer
			/*	on same page with inserted page pointer, since
			/*	both nodes must be modified and MCMed together.
			/**/
			Assert( ibSon > 1 );
			ibSon--;

#else
			ibSon++;
			Assert( ibSon < cbSon );
#endif
			}
		}
	else
		{
		/*	since splitting left is inclusive of ibSon, reduce ibSon by
		/*	one if splitting all nodes left.
		/**/
		if ( ibSon == cbSon - 1 )
			ibSon--;
		if ( !fVisibleSons && ibSon == *pibSon )
			{
			Assert( cbSon > 2 );
#ifdef BUGFIX
			/*	adjust split point to keep current page pointer
			/*	on same page with inserted page pointer, since
			/*	both nodes must be modified and MCMed together.
			/**/
			Assert( ibSon < cbSon - 2 );
			ibSon++;
#else
			ibSon--;
			Assert( ibSon > 0 );
#endif
			}
		*pfRight = fFalse;
		}

	/*	ensure that we do not split update and insert page pointer
	/*	nodes during recursive split, since both nodes must be
	/*	updated together.
	/**/
	Assert( fVisibleSons || ibSon != *pibSon );

	if ( *pfRight )
		{
		/* split empty right page for Update should never happen.
		/* so if ibSon == cbSon, an append, can not be for update.
		/**/
		Assert ( ibSon != cbSon || !fReplace);

		/*	always right split, if the inserted key should go to left side
		/*	of the split, the split key is the ibSono'th Son's key.
		/*	To detect left side of split, check if ibSon == *pibSon and
		/*	if fInsertLeftPage is set.
		/*	if ibSon == cbSon, then it must be an append.
		/**/
		Assert( ibSon <= cbSon );

		/* get the right split key
		/**/
		NDGet( pfucb, itagFOP );
		pbSon = PbNDSon( pssib->line.pb );
		Assert( ibSon >= 1 );
		NDGet( pfucb, pbSon[ ibSon - 1 ] );
		pkey->pb = PbNDKey(pssib->line.pb);
		pkey->cb = CbNDKey(pssib->line.pb);
		if ( fVisibleSons )
			{
			BTIStoreLeafSplitKey( psplit, pssib );
			}
		}
	else
		{
		/*	if left split then get split key from key of first node
		/*	on this page. Note that the key of the inserted node cannot
		/*	be used as a result of the BT key conflict search algorithm
		/**/

		/*	for update on first node and first node become huge
		/*	use first node's key as split key
		/**/
		Assert ( !( *pfRight ) );
		NDGet( pfucb, itagFOP );
		pbSon = PbNDSon( pssib->line.pb );
		NDGet( pfucb, pbSon[ibSon] );
		pkey->pb = PbNDKey(pssib->line.pb);
		pkey->cb = CbNDKey(pssib->line.pb);
		if ( fVisibleSons )
			{
			BTIStoreLeafSplitKey( psplit, pssib );
			}

		/* prepend, no move.
		/**/
		if ( !fReplace && ibSon == 0 && *pibSon == 0 && fInsertLeftPage )
			ibSon = ibSonNull;

		}

	*pibSon = ibSon;
	*pfAppend = fFalse;
	return;
	}


LOCAL VOID BTDoubleVSplit( FUCB *pfucb, INT itagSplit, INT cbReq, INT cbTotal, INT *pibSon, KEY *pkey )
	{
	SSIB   	*pssib = &pfucb->ssib;
	INT		ibSon;
	BYTE   	*pbSon;
	BYTE   	*pbSonSplit;
	BYTE   	*pbSonMax;
	INT		cbSon;
	INT		cb;

	/*	set pbSon to point to first son and cbSon to number of sons.
	/**/
	NDGet( pfucb, itagSplit );

	Assert( CbNDSon(pssib->line.pb) > 1 );
	pbSon = PbNDSonTable( pssib->line.pb );
	cbSon = CbNDSonTable( pbSon );
	pbSon++;
	pbSonSplit = pbSon;

	pbSonMax = pbSon + cbSon;
	cb = 0;
	for ( ibSon = 0; pbSon < pbSonMax; ibSon++, pbSon++ )
		{
		/*	if traversing inserted/replaced node add cbReq
		/**/
		if ( ibSon == (INT)*pibSon )
			cb += cbReq;
		cb += UsBTWeight( pfucb, (INT)*pbSon );
		if ( cb >= ( cbTotal / 2 ) )
			break;
		}

	if ( ibSon == cbSon - 1 )
		ibSon--;

	NDGet( pfucb, pbSonSplit[ibSon] );
	pkey->pb = PbNDKey(pssib->line.pb);
	pkey->cb = CbNDKey(pssib->line.pb);

	/*	set return split ibSon
	/**/
	*pibSon = ibSon;
	return;
	}


//+private----------------------------------------------------------------------
//
//	UsBTWeight
//	============================================================================
//
//	LOCAL ULONG UsBTWeight( FUCB *pfucb, INT itag )
//
//	Only used for horizontal split.
//	Recursively calculates weight, i.e space freed by moving node and
//	node descendants.
//
//------------------------------------------------------------------------------
LOCAL ULONG UsBTWeight( FUCB *pfucb, INT itag )
	{
	SSIB   	*pssib = &pfucb->ssib;
	BYTE   	*pbSon;
	INT		cbSon;
	INT		ibSon;
	ULONG  	cbWeight;

	/*	keep SSIB in ssync with current tag for bookmark computation
	/**/
	pssib->itag = itag;

	NDGet( pfucb, itag );

	/*	total length is data length + tag size + son entry + backlink
	/**/
	cbWeight = pssib->line.cb + sizeof(TAG) + 1;
	if ( !FNDBackLink( *pssib->line.pb ) )
		{
		cbWeight += sizeof(SRID);
		}
	Assert( itag != itagFOP || FNDNonIntrinsicSons( pssib->line.pb ) );

	/*	adjust weight for reserved space
	/**/
	if ( FNDVersion( *pssib->line.pb ) )
		{
		SRID	srid;
		UINT	cbMax;

		NDIGetBookmark( pfucb, &srid );
		cbMax = CbVERGetNodeMax( pfucb, srid );
		if ( cbMax > 0 && cbMax > CbNDData( pssib->line.pb, pssib->line.cb ) )
			cbWeight += ( cbMax - CbNDData( pssib->line.pb, pssib->line.cb ) );
		}

	if ( FNDNonIntrinsicSons( pssib->line.pb ) )
		{
		/*	add weight of sons
		/**/
		pbSon = PbNDSonTable( pssib->line.pb );
		cbSon = *pbSon++;
		for ( ibSon = 0; ibSon < cbSon; ibSon++ )
			{
			cbWeight += UsBTWeight( pfucb, (INT)pbSon[ibSon] );
			}
		}
	return cbWeight;
	}


//+private---------------------------------------------------------------------
//
//	ErrBTMoveSons
//	===========================================================================
//
//	LOCAL ERR ErrBTMoveSons( SPLIT *psplit,
//	  FUCB *pfucb, FUCB *pfucbNew, BYTE *rgbSon,
//	  BOOL fVisibleSons, BOOL fNoMove )
//
//	PARAMETERS
//
//	move a tree rooted at pssib to pssibNew
//	pssib.line.pb must point to the source root line
//
//	When fVisibleSons is set, indicate this node is a leaf node.
//	When fNoMove is set, no real update will be done, only buffers involved
//	in the backlink updates will be collected.
//
//------------------------------------------------------------------------------
ERR ErrBTMoveSons(
	SPLIT	*psplit,
	FUCB	*pfucb,
	FUCB	*pfucbNew,
	INT 	itagSonTable,
	BYTE	*rgbSon,
	BOOL	fVisibleSons,
	BOOL	fNoMove )
	{
	ERR  	err = JET_errSuccess;
	SSIB	*pssib = &pfucb->ssib;
	SSIB	*pssibNew = &pfucbNew->ssib;
	BYTE	*pbSon;
	INT  	cbSon;
	INT  	ibSon;
	INT  	ibSonMax;

	CallR( ErrSTWriteAccessPage( pfucb, psplit->pgnoSplit ) );
	Assert( pfucb->ssib.pbf == psplit->pbfSplit );

	/*	since splitter write latched split page there can be no
	/*	conflict and no updater can change split nodes during split.
	/**/
	Assert( FBFWriteLatch( psplit->ppib, psplit->pbfSplit ) );

	NDGet( pfucb, itagSonTable );

	rgbSon[0] = 0;

	if ( FNDNullSon( *pssib->line.pb ) )
		{
		Assert( err == JET_errSuccess );
		goto HandleError;
		}

	Assert( !FNDNullSon( *pssib->line.pb ) );

	pbSon = PbNDSonTable( pssib->line.pb );
	cbSon = CbNDSonTable(pbSon);
	pbSon++;

	if ( psplit->ibSon != ibSonNull )
		{
		switch ( psplit->splitt )
			{
			case splittVertical:
				ibSon = 0;
				ibSonMax = cbSon;
				break;
			case splittLeft:
				Assert( psplit->ibSon < cbSon );
				ibSon = 0;
				ibSonMax = psplit->ibSon + 1;
				break;
			default:
				Assert( psplit->ibSon <= cbSon );
				Assert( psplit->splitt == splittRight ||
						psplit->splitt == splittAppend );
				ibSon = psplit->ibSon;
				ibSonMax = cbSon;
			}

		for ( ; ibSon < ibSonMax; ibSon++ )
			{
			Call( ErrBTMoveNode( psplit, pfucb, pfucbNew,
				(INT)pbSon[ibSon],	rgbSon, fVisibleSons, fNoMove ) );
			}
		}

	/*	if success then should have split buffer access
	/**/
	Assert( pfucb->ssib.pbf == psplit->pbfSplit );

HandleError:
	return err;
	}


/*	forward node deferred free space to new page, allocating space from
/*	new page and releasing to split page.
/**/
INLINE LOCAL VOID BTIForwardDeferFreedNodeSpace( FUCB *pfucb, PAGE *ppageOld, PAGE *ppageNew, SRID bm )
	{
	INT	cbReserved;

	Assert( FNDVersion( *pfucb->ssib.line.pb ) );
	cbReserved = CbVERGetNodeReserve( pfucb, bm );
	Assert( cbReserved >= 0 );
	if ( cbReserved > 0 )
		{
		ppageOld->pghdr.cbFreeTotal += (SHORT)cbReserved;
		ppageNew->pghdr.cbFreeTotal -= (SHORT)cbReserved;
		}

	return;
	}

	
ERR ErrBTStoreBackLinkBuffer( SPLIT *psplit, BF *pbf, BOOL *pfAlreadyStored )
	{
	INT		cpbf;
	
	/*	check if the page is back linked in previous backlink
	/**/
	if ( psplit->cpbf )
		{
		BF	**ppbf = psplit->rgpbf;
		BF	**ppbfMax = ppbf + psplit->cpbf;

		for (; ppbf < ppbfMax; ppbf++)
			{
			if ( *ppbf == pbf )
				{
				*pfAlreadyStored = fTrue;
				return JET_errSuccess;
				}
			}
		}

	*pfAlreadyStored = fFalse;

	/*	keep the backlink into the psplit backlink table rgpbf
	/**/
	cpbf = psplit->cpbf++;
	if ( psplit->cpbf > psplit->cpbfMax )
		{
		BF **ppbf;

		/*	run out of space, get more buffers
		/**/
		psplit->cpbfMax += 10;
		ppbf = SAlloc( sizeof(BF *) * psplit->cpbfMax );
		if ( ppbf == NULL )
			return JET_errOutOfMemory;
		
		memcpy( ppbf, psplit->rgpbf, sizeof(BF *) * cpbf );
		if ( psplit->rgpbf )
			{
			SFree( psplit->rgpbf );
			}
		psplit->rgpbf = ppbf;
		}

	*( psplit->rgpbf + cpbf ) = pbf;

	return JET_errSuccess;
	}

	
/* store the operations of the merge page:
/*  sridBackLink != pgnoSplit
/*      ==> a regular backlink
/*  sridBackLink == pgnoSplit && sridNew == sridNull
/*      ==> move the node from old page to new page. Deletion on old page.
/*  sridBackLink == pgnoSplit && sridNew != sridNull.
/*      ==> a new link among the old page and the new page,
/*          replace an entry with link on old page.
/**/
ERR ErrBTStoreBackLink( SPLIT *psplit, SRID sridNew, SRID sridBackLink )
	{
	BKLNK	*pbklnk;
	INT		cbklnk;
	
	Assert( sridNew == sridNull ||
		PgnoOfSrid( sridNew ) != pgnoNull );
	Assert( sridNew == sridNull ||
		(UINT) ItagOfSrid( sridNew ) > 0 &&
		(UINT) ItagOfSrid( sridNew ) < (UINT) ctagMax );
	Assert( sridBackLink != sridNull );
	Assert( PgnoOfSrid( sridBackLink ) != pgnoNull );

	/* log the back link
	/**/
	cbklnk = psplit->cbklnk++;

	/* assert cbklnk less then max.  Note that we may store
	/*	two entries per record.
	/**/
	Assert( cbklnk < ctagMax * 2 );
	
	if ( psplit->cbklnk > psplit->cbklnkMax )
		{
		/* run out of space, get more buffers
		/**/
		psplit->cbklnkMax += 10;
		pbklnk = SAlloc( sizeof(BKLNK) * (psplit->cbklnkMax) );
		if ( pbklnk == NULL )
			{
			/*	restore cbklnk
			/**/
			psplit->cbklnk--;
			return JET_errOutOfMemory;
			}
		memcpy( pbklnk, psplit->rgbklnk, sizeof(BKLNK) * cbklnk );
					
		if ( psplit->rgbklnk )
			{
			SFree( psplit->rgbklnk );
			}
		psplit->rgbklnk = pbklnk;
		}

	pbklnk = psplit->rgbklnk + cbklnk;

	pbklnk->sridNew = sridNew;
	pbklnk->sridBackLink = sridBackLink;
	
	return JET_errSuccess;
	}
	

//+private---------------------------------------------------------------------
//
//	ErrBTMoveNode
//	===========================================================================
//
//	LOCAL ERR ErrBTMoveNode( SPLIT *psplit, FUCB *pfucb, FUCB *pfucbNew,
// 	  BYTE *rgbSon, BOOL fVisibleNode, BOOL fNoMove )
//
//	PARAMETERS
//
//	moves node and any decendants of node.  Increments rgbSonNew count
//	and sets new itag in rgbSonNew array.
//  When fVisibleSons is set, indicate this node is a leaf node.
//  if fNoMove is set, no delete or insert is done, only backlinked buffers
//  are collected.
//
//-----------------------------------------------------------------------------
LOCAL ERR ErrBTMoveNode(
	SPLIT		*psplit,
	FUCB		*pfucb,
	FUCB		*pfucbNew,
	INT  		itagNode,
	BYTE		*rgbSon,
	BOOL		fVisibleNode,
	BOOL		fNoMove )
	{
	ERR			err;
	/*	used as index into tag mapping
	/**/
	INT  		itagOld = itagNode;
	SSIB		*pssib = &pfucb->ssib;
	SSIB		*pssibNew = &pfucbNew->ssib;
	INT  		cline = 1;
	LINE		rgline[3];
	BYTE		*pb;
	BYTE		*pbNode;
	ULONG		cb;
	SRID		sridNew;
	SRID		sridBackLink;
	BYTE		rgbT[citagSonMax];

	/*	get node to move.
	/**/
	pssib->itag = itagOld;
	NDGet( pfucb, itagOld );

	rgline[0] = pssib->line;
	pbNode = pb = pssib->line.pb;
	cb = pssib->line.cb;
	Assert( cb < cbPage );

	Assert( itagOld != itagFOP || FNDNonIntrinsicSons( pssib->line.pb ) );
	if ( FNDNonIntrinsicSons( pssib->line.pb ) )
		{
		INT		itagT = itagOld;
		SPLITT	splittT;
		BOOL	fVisibleSons = FNDVisibleSons( *pssib->line.pb );

		psplit->fLeaf |= fVisibleSons;

		/*	call move tree to move all its sons
		/**/
		rgbT[0] = 0;

		/*	movement of subtrees must include whole tree, hence,
		/*	move as though vertical split
		/**/
		splittT = psplit->splitt;
		psplit->splitt = splittVertical;
		CallR( ErrBTMoveSons( psplit, pfucb, pfucbNew, itagOld, rgbT, fVisibleSons, fNoMove) );
		psplit->splitt = splittT;

		/*	can be done by copying the new rgbSon into the pssib page
		/*	directly, pb should be still effective.  Must remember
		/*	to copy back link as well.
		/**/
		pb = PbNDSonTable( pb );
		rgline[0].cb = (UINT)(pb - pbNode);
		rgline[1].pb = rgbT;
		rgline[1].cb = rgbT[0] + 1;
		rgline[2].pb = pb + *pb + 1;
		rgline[2].cb = cb - rgline[0].cb - rgline[1].cb;
		cline = 3;

		/*	restore cursor state
		/**/
		pfucb->ssib.itag = itagOld;
		NDGet( pfucb, itagOld );
		}

	/*	assert current node cached
	/**/
	AssertNDGet( pfucb, itagOld );

	/*	propogate version count if version exists for node being moved
	/**/
	if ( !fNoMove && FNDVersion( *pbNode ) )
		{
		PMDecVersion( pssib->pbf->ppage );
		PMIncVersion( pssibNew->pbf->ppage );
		}

	/*	if node is linked, it must be a leaf node, adjust links
	/*	to new location else replace with new link to new location.
	/**/
	if ( !fVisibleNode )
		{
		if ( fNoMove )
			return JET_errSuccess;

		CallS( ErrPMInsert( pssibNew, rgline, cline ) );
		Assert( !FNDBackLink( *pssib->line.pb ) );
		PMDelete( pssib );
		sridNew = sridNull;
		sridBackLink = SridOfPgnoItag( psplit->pgnoSplit, itagOld );
		CallR( ErrBTStoreBackLink( psplit, sridNew, sridBackLink ) );
		}
	else
		{
		if ( FNDBackLink( *pbNode ) )
			{
			PGNO	pgno;
			INT		itag;
			BOOL	fLatched;

#ifdef DEBUG
			{
			INT itagT = PcsrCurrent(pfucb)->itag;

			PcsrCurrent(pfucb)->itag = pssib->itag;
			NDGetBackLink( pfucb, &pgno, &itag );
			PcsrCurrent(pfucb)->itag = itagT;
			}
#else
			NDGetBackLink( pfucb, &pgno, &itag );
#endif

			if ( !fNoMove )
				{
				if ( FNDVersion( *pssib->line.pb ) )
					{
					BTIForwardDeferFreedNodeSpace(
						pfucb,
						pssib->pbf->ppage,
						pssibNew->pbf->ppage,
						SridOfPgnoItag(pgno, itag) );
					}
				CallS( ErrPMInsert( pssibNew, rgline, cline ) );
				PMDelete( pssib );
				}

			CallR( ErrSTWriteAccessPage( pfucb, pgno ) );
			if ( fRecovering &&
				pssib->pbf->ppage->pghdr.ulDBTime >= psplit->ulDBTimeRedo )
				goto EndOfUpdateLinks;

			sridNew = SridOfPgnoItag( PcsrCurrent( pfucbNew )->pgno, pssibNew->itag );
			sridBackLink = SridOfPgnoItag( pgno, itag );

			if ( !fNoMove )
				{
				pssib->itag = itag;
				PMDirty( pssib );
				PMReplaceLink( pssib, sridNew );

				/*	For redo, we do not call this function with fNoMove to hold buffer.
				 *	We simply access the buffer as we go. So we have to check if buffer
				 *	need to be stored. Check if the page is back linked in previous backlink
				 **/
				if ( fRecovering )
					{
					CallR( ErrBTStoreBackLinkBuffer( psplit, pssib->pbf, &fLatched ) );
					if ( !fLatched )
						{
						BFPin( pssib->pbf );
						BFSetWriteLatch( pssib->pbf, pssib->ppib );
						}
					}
#ifdef DEBUG
				else
					{
					BF		**ppbf = psplit->rgpbf;
					BF		**ppbfMax = ppbf + psplit->cpbf;
					BOOL	fBufferFound = fFalse;

					Assert( psplit->cpbf );

					for ( ; ppbf < ppbfMax; ppbf++ )
						{
						if ( *ppbf == pssib->pbf )
							{
							fBufferFound = fTrue;
							break;
							}
						}

					Assert( fBufferFound );
					}
#endif

				Assert( sridNew != sridNull );
				Assert( sridBackLink != sridNull );
				CallR( ErrBTStoreBackLink( psplit,
					sridNew,
					sridBackLink ) );
			
				/*	store backlink such that the source node will be
				/*	deleted during recovery.
				/**/
				CallR( ErrBTStoreBackLink( psplit,
					sridNull,
					SridOfPgnoItag( psplit->pgnoSplit, itagOld ) ) );

				goto EndOfUpdateLinks;
				}

			if ( FBFWriteLatchConflict( pssib->ppib, pssib->pbf ) )
				{
				/*	yeild after release split resources
				/**/
				return errDIRNotSynchronous;
				}

			/*	check if the page is back linked in previous backlink
			/**/
			CallR( ErrBTStoreBackLinkBuffer( psplit, pssib->pbf, &fLatched ) );
			if ( !fLatched )
                {
			    BFPin( pssib->pbf );
			    BFSetWriteLatch( pssib->pbf, pssib->ppib );
                }

EndOfUpdateLinks:

			CallR( ErrSTWriteAccessPage( pfucb, psplit->pgnoSplit ) );

			if ( fNoMove )
				return JET_errSuccess;
			}
		else
			{
			BYTE	bFlags;
			KEY 	key;
			LINE	lineSonTable;
			LINE	lineData;
			SRID	srid;

			if ( fNoMove )
				return JET_errSuccess;

			srid = SridOfPgnoItag( psplit->pgnoSplit, itagNode );

			if ( FNDVersion( *pssib->line.pb ) )
				{
				BTIForwardDeferFreedNodeSpace(
					pfucb,
					pssib->pbf->ppage,
					pssibNew->pbf->ppage,
					srid );
				}

#ifndef MOVEABLEDATANODE
			Assert( psplit->pgnoSplit != pfucb->u.pfcb->pgnoRoot ||
				itagNode != pfucb->u.pfcb->itagRoot );
#endif
			//	UNDONE:	clean this up
			bFlags = *pbNode;
			key.cb = CbNDKey( pbNode );
			if ( key.cb > 0 )
				key.pb = PbNDKey( pbNode );
			if ( FNDSon( *pbNode ) )
				{
				if ( cline == 1 )
					{
					/*	must be intrinsic son
					/**/
					Assert( FNDSon( *pbNode ) && FNDInvisibleSons( *pbNode ) &&
						CbNDSon( pbNode ) == 1 );
					lineSonTable.cb = 1 + sizeof(PGNO);
					lineSonTable.pb = PbNDSonTable( pbNode );
					}
				else
					{
					Assert( cline == 3 );
					lineSonTable.cb = rgline[1].cb;
					lineSonTable.pb = rgline[1].pb;
					}
				}
			else
				{
				lineSonTable.cb = 0;
				lineSonTable.pb = NULL;
				}
			Assert( !FNDBackLink( *pbNode ) );
			lineData.pb = PbNDData( pbNode );
			lineData.cb = cb - (UINT)( lineData.pb - pbNode );
			CallS( ErrNDInsertWithBackLink( pfucbNew, bFlags, &key, &lineSonTable, srid, &lineData ) );
			Assert( PcsrCurrent( pfucbNew )->itag != itagFOP );
			srid = SridOfPgnoItag( PcsrCurrent( pfucbNew )->pgno, PcsrCurrent( pfucbNew )->itag );
			PMReplaceWithLink( pssib, srid );
			
			sridNew = srid;
			sridBackLink = SridOfPgnoItag( psplit->pgnoSplit, itagOld );
			
			CallR( ErrBTStoreBackLink( psplit, sridNew, sridBackLink ) );
			}
		}

	rgbSon[++rgbSon[0]] = (BYTE) pssibNew->itag;

	/*	record tag mapping in SPLIT.  Note that some new itags will
	/*	be duplicated during double split, however, since source itags
	/*	are unique, there is no aliasing.
	/**/
	Assert( itagOld != 0 );
	Assert( psplit->mpitag[itagOld] == 0 );
	psplit->mpitag[itagOld] = (BYTE)pssibNew->itag;

#ifdef MOVEABLEDATANODE
	/*	if moved DATA node then update FCB.
	/**/
#ifdef DEBUG
	{
	/*	Assert that correct FCB is used with split page so that
	/*	root updates are not lost.
	/**/
	PGNO	pgnoFDP;

	LFromThreeBytes( pgnoFDP, pssib->pbf->ppage->pghdr.pgnoFDP );
	Assert( pgnoFDP == pfucb->u.pfcb->pgnoFDP );

	LFromThreeBytes( pgnoFDP, pssibNew->pbf->ppage->pghdr.pgnoFDP );
	Assert( pgnoFDP == pfucb->u.pfcb->pgnoFDP );
	}
#endif

	if ( PgnoOfPn( pssib->pbf->pn ) == pfucb->u.pfcb->pgnoRoot &&
		itagNode == pfucb->u.pfcb->itagRoot )
		{
		pfucb->u.pfcb->pgnoRoot = PgnoOfPn( pssibNew->pbf->pn );
		pfucb->u.pfcb->itagRoot = pssibNew->itag;
		}
#endif

	return JET_errSuccess;
	}


//+private----------------------------------------------------------------------
//
//	FBTSplit
//	============================================================================
//
//	BOOL FBTSplit( SSIB *pssib, INT cbReq, INT citagReq )
//
//	PARAMETERS
//
//	determine whether split is required.  Split is required if less than
//	required space is free in page or if no page tags are free.  cbReq
//	must include all space required including that space for the tag.
//
//------------------------------------------------------------------------------
BOOL FBTSplit( SSIB *pssib, INT cbReq, INT citagReq )
	{
	BOOL	fSplit;

	Assert( citagReq < ctagMax );

	fSplit =	CbPMFreeSpace( pssib ) < cbReq || !FPMFreeTag( pssib, (INT) citagReq );
	return fSplit;
	}



//+private----------------------------------------------------------------------
//
//	FBTAppendPage
//	============================================================================
//
//	LOCAL BOOL FBTAppendPage( CSR *pcsr, SSIB *pssib, INT cbReq, INT cbPageAdjust, INT cbFreeDensity )
//
//	PARAMETERS
//
//	node should be inserted into appended page when node is last son of FOP, page to be inserted in
//	is last page in b-tree, not FDP page and density contraint would be
//	violated if node were inserted on current page.
//
//------------------------------------------------------------------------------
BOOL FBTAppendPage( FUCB *pfucb, CSR *pcsr, INT cbReq, INT cbPageAdjust, INT cbFreeDensity )
	{
	BOOL	fAppendPage = fFalse;
	PGNO	pgno;
	INT		cbSon;
	SSIB	*pssib = &pfucb->ssib;

	PgnoNextFromPage( pssib, &pgno );

	/*	itagFather == 0 for non-FDP page
	/*	pgno == pgnoNull for last B-tree page
	/*	cbFree - cbReq < cbFreeDensity violates density contraint
	/*	disable density contraint when required space is too large
	/*	to satisfy density
	/**/
	if ( pcsr->itagFather == itagFOP &&
		pgno == pgnoNull &&
		( cbReq < (INT)cbAvailMost - cbFreeDensity ) &&
		( CbPMFreeSpace(pssib) - cbPageAdjust - cbReq ) < cbFreeDensity )
		{
		LINE	lineSav = pfucb->ssib.line;

		/*	get number of sons of FOP to check if current node is last of FOP's sons */
		/**/
		NDGet( pfucb, itagFOP );
		cbSon = CbNDSonTable( PbNDSonTable( pssib->line.pb ) );
		fAppendPage = ( pcsr->ibSon == cbSon );

		/*	restore line
		/**/
		pfucb->ssib.line = lineSav;
		}

	return fAppendPage;
	}


#pragma optimize("g",on)


//+private----------------------------------------------------------------------
//
//	CbBTFree
//	============================================================================
//
//	Returns free space until density or page constraint met.
//
//------------------------------------------------------------------------------
INT CbBTFree( FUCB *pfucb, INT cbFreeDensity )
	{
	SSIB	*pssib = &pfucb->ssib;
	INT		cbFree =  CbPMFreeSpace( pssib ) - cbFreeDensity;

	if ( cbFree < 0 )
		return 0;
	return cbFree;
	}


//+private----------------------------------------------------------------------
//
//	FBTTableData
//	============================================================================
//
//	LOCAL BOOL FBTTableData( FUCB *pfucb, PGNO pgno, INT itag )
//
//	PARAMETERS
//
//------------------------------------------------------------------------------
BOOL FBTTableData( FUCB *pfucb, PGNO pgno, INT itag )
	{
	BOOL	f;
	f = FFUCBRecordCursor( pfucb ) &&
		pfucb->u.pfcb->pgnoRoot == pgno &&
		pfucb->u.pfcb->itagRoot == itag;
	return f;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\dbapi.c ===
#include "config.h"

#include <string.h>
#include <stdlib.h>
#include <stddef.h>

#include "daedef.h"
#include "util.h"
#include "pib.h"
#include "ssib.h"
#include "page.h"
#include "fmp.h"
#include "fucb.h"
#include "fcb.h"
#include "stapi.h"
#include "node.h"
#include "logapi.h"
#include "log.h"
#include "nver.h"
#include "dirapi.h"
#include "fileapi.h"
#include "systab.h"
#include "dbapi.h"
#include "bm.h"

DeclAssertFile;                                 /* Declare file name for Assert macros */

extern int itibGlobal;

typedef struct {
        BYTE    bDbid;
        BYTE    bLoggable;
        /*      must be last field in structure */
        CHAR    rgchDatabaseName[1];
} DBA;

extern PIB * __near ppibAnchor;
#ifdef DEBUG
extern BOOL fDBGForceFlush;
#endif

LOCAL ERR ErrDBRemoveDatabase( PIB *ppib, CHAR *szDatabaseName );
LOCAL ERR ErrDBAddDatabase( PIB *ppib, CHAR *szDatabaseName, DBID dbid );
LOCAL ERR ErrDBInitDatabase( PIB *ppib, DBID dbid, CPG cpg, BOOL fNoLogging );
LOCAL ERR ErrDBValidDatabaseFile( CHAR *szDatabaseName, ULONG *pulVersion, BOOL *pfLoggingCapable);


ERR ErrFMPSetDatabases( PIB *ppib )
        {
        ERR             err;
        FUCB    *pfucb;
        DIB             dib;
        DBID    dbid;
        INT             cchDatabaseName;

        CallR( ErrDIROpen( ppib, pfcbNil, dbidSystemDatabase, &pfucb ) );
        DIRGotoFDPRoot( pfucb );

        dib.pos = posFirst;
        dib.fFlags = fDIRNull;

        Call( ErrDIRSeekPath( pfucb, 1, pkeyDatabases, 0 ) );
        Call( ErrDIRDown( pfucb, &dib ) );

        do
                {
                Call( ErrDIRGet( pfucb ) );

                Assert( pfucb->lineData.cb > sizeof(BYTE) * 2 );
                dbid = (DBID) ((DBA *)pfucb->lineData.pb)->bDbid;
                rgfmp[dbid].fLogOn =
                rgfmp[dbid].fDBLoggable = (BOOL) ((DBA *)pfucb->lineData.pb)->bLoggable;
                cchDatabaseName = pfucb->lineData.cb - offsetof( DBA, rgchDatabaseName );
                /*      allocate bytes for database name with NULL terminator
                /**/
                if (!(rgfmp[dbid].szDatabaseName = SAlloc( cchDatabaseName + 1 )))
                        Error( JET_errOutOfMemory, HandleError );
                strncpy( rgfmp[dbid].szDatabaseName,
                        (BYTE *)&(((DBA *)pfucb->lineData.pb)->rgchDatabaseName),
                        cchDatabaseName );
                rgfmp[dbid].szDatabaseName[cchDatabaseName] = '\0';
                DBIDSetAttached( dbid );
                err = ErrDIRNext( pfucb, &dib );
                }
        while ( err >= 0 );

HandleError:
        DIRClose( pfucb );
        
        /*      polymorph end of file to JET_errSuccess
        /**/
        if ( err == JET_errRecordNotFound || err == JET_errNoCurrentRecord )
                err = JET_errSuccess;

        /*      return error code
        /**/
        return err;
        }


//+local
//      ErrDBInitDatabase
//      ========================================================================
//      ErrDBInitDatabase( PIB *ppib, DBID dbid, CPG cpgPrimary )
//
//      Initializes database structure.  Structure is customized for
//      system, temporary and user databases which are identified by
//      the dbid.  Primary extent is set to cpgPrimary but no allocation
//      is performed.  The effect of this routine can be entirely
//      represented with page operations.
//
//      PARAMETERS      ppib                    ppib of database creator
//                                      dbid                    dbid of created database
//                                      cpgPrimary      number of pages to show in primary extent
//
//      RETURNS         JET_errSuccess or error returned from called routine.
//-
LOCAL ERR ErrDBInitDatabase( PIB *ppib, DBID dbid, CPG cpgPrimary, BOOL fNoLogging )
        {
        ERR                             err;
        THREEBYTES              tbSize;
        THREEBYTES              tbLast;
        LINE                    line;
        KEY                     key;
        BYTE                    rgbT[sizeof(THREEBYTES)];
        FUCB                    *pfucb = pfucbNil;
        BYTE                    rgb[sizeof(DBROOT)];

        /*      set up the root page
        /**/
        CallR( ErrDIRBeginTransaction( ppib ) );

        /*      open cursor on database domain.
        /**/
        Call( ErrDIROpen( ppib, pfcbNil, dbid, &pfucb ) );

        rgfmp[dbid].ulDBTime = 0;

        /*      set system root node ( pgno, itag )=( 1, 0 ) as empty FDP node
        /**/
        Call( ErrNDNewPage( pfucb, pgnoSystemRoot, pgnoSystemRoot, pgtypFDP, fTrue ) );
        DIRGotoFDPRoot( pfucb );

        /*      data for root of database is magic number followed
        /*      by version number       (followed by timestamp followed by flags)
        /**/
        ((DBROOT *)rgb)->ulMagic = ulDAEMagic;
        ((DBROOT *)rgb)->ulVersion = ulDAEVersion;

        /* initialize timestamp */
        ( (DBROOT *)rgb)->ulDBTime = 0;

        /* initialize flags, set flags to "loggable" except TMP */
        ( (DBROOT *)rgb)->usFlags =
                ( FSysTabDatabase( dbid ) && !fNoLogging ) ? dbrootfLoggable : 0;

        line.cb = sizeof(DBROOT);
        line.pb = rgb;
        Call( ErrDIRReplace( pfucb, &line, fDIRNoVersion ) );

        /*      make the "ownext" node
        /**/
        ThreeBytesFromL( *( THREEBYTES *)rgbT, cpgPrimary );
        line.cb = sizeof(THREEBYTES);
        line.pb = rgbT;
        Call( ErrDIRInsert( pfucb, &line, pkeyOwnExt, fDIRNoVersion | fDIRBackToFather ) );

        /* make the "availext" node
        /**/
        ThreeBytesFromL( *( THREEBYTES *) rgbT, pgnoNull );
        Assert( line.cb == sizeof(THREEBYTES) );
        Assert( line.pb == (BYTE *)rgbT );
        Call( ErrDIRInsert( pfucb, &line, pkeyAvailExt, fDIRNoVersion | fDIRBackToFather ) );

        /* setup OwnExt tree
        /**/
        TbKeyFromPgno( tbLast, cpgPrimary );
        key.cb = sizeof(THREEBYTES);
        key.pb = (BYTE *) &tbLast;
        ThreeBytesFromL( tbSize, cpgPrimary );
        line.cb = sizeof(THREEBYTES);
        line.pb = (BYTE *) &tbSize;
        DIRGotoOWNEXT( pfucb, PgnoFDPOfPfucb( pfucb ) );
        Call( ErrDIRInsert( pfucb, &line, &key, fDIRNoVersion | fDIRBackToFather ) );

        /* setup AvailExt tree if there are any pages left
        /**/
        if ( --cpgPrimary > 0 )
                {
                DIRGotoAVAILEXT( pfucb, PgnoFDPOfPfucb( pfucb ) );
                ThreeBytesFromL( tbSize, cpgPrimary );
                Assert( line.cb == sizeof(THREEBYTES) );
                Assert( line.pb == (BYTE *) &tbSize );
                /* tbLast should still contain last page key
                */
                Assert( key.cb == sizeof(THREEBYTES) );
                Assert( key.pb == (BYTE *) &tbLast );
                Call( ErrDIRInsert( pfucb, &line, &key, fDIRNoVersion | fDIRBackToFather ) );
                }

        /* goto FDP root and add pkeyTables son node.
        /**/
        DIRGotoFDPRoot( pfucb );

        line.cb = sizeof(WORD);
        line.pb = rgbT;
        *(WORD *)rgbT = 0;
        Call( ErrDIRInsert( pfucb, &line, pkeyTables, fDIRNoVersion | fDIRBackToFather ) );

        /*      system database
        /**/
        if ( dbid == dbidSystemDatabase )
                {
                /* add "databases" node
                /**/
                line.cb = 0;
                Call( ErrDIRInsert( pfucb, &line, pkeyDatabases, fDIRNoVersion | fDIRBackToFather ) );
                }

        /*      close cursor and commit operations
        /**/
        DIRClose( pfucb );
        pfucb = pfucbNil;
        Call( ErrDIRCommitTransaction( ppib ) );
        return err;

HandleError:
        if ( pfucb != pfucbNil )
                DIRClose( pfucb );
        CallS( ErrDIRRollback( ppib ) );
        return err;
        }


#ifdef NO_OVER_PREREAD
//to prevent read ahead over-preread, we may want to keep track of last
//page of the database.

ERR ErrDBSetLastPage( PIB *ppib, DBID dbid )
        {
        ERR err;
        DIB dib;
        FUCB *pfucb;

        CallR( ErrDIROpen( ppib, pfcbNil, dbid, &pfucb ) );
        DIRGotoAVAILEXT( pfucb, PgnoFDPOfPfucb( pfucb ) );
        dib.fFlags = fDIRNull;
        dib.pos = posLast;
        CallJ( ErrDIRDown( pfucb, &dib ), CloseFucb );
        Assert( pfucb->keyNode.cb == sizeof( THREEBYTES ) );
        PgnoFromTbKey( rgfmp[dbid].pgnoLast, *(THREEBYTES *) pfucb->keyNode.pb );

CloseFucb:
        DIRClose( pfucb );
        return err;
        }
#endif


#ifdef DISPATCHING

LOCAL ERR ErrDABAlloc( PIB *ppib, VDBID *pvdbid, DBID dbid, JET_GRBIT grbit )
        {
        VDBID vdbid = (VDBID)VdbidMEMAlloc();

        if ( vdbid == NULL )
                return JET_errTooManyOpenDatabases;
        vdbid->dbid = dbid;
        vdbid->ppib = ppib;

        /* set the mode of DBopen */
        /**/
        if ( FDBIDReadOnly( dbid ) )
                vdbid->grbit = JET_bitDbReadOnly;
        else
                vdbid->grbit = grbit;

        /* insert DAB/VDBID into ppib's dabList
        /**/
        vdbid->pdabNext = ppib->pdabList;
        ppib->pdabList = vdbid;

        *pvdbid = vdbid;
        return JET_errSuccess;
        }

#endif

LOCAL ERR ErrDABDealloc( PIB *ppib, VDBID vdbid)
        {
        DAB     **pdabPrev;
        DAB     *pdab;

        pdab = ppib->pdabList;
        pdabPrev = &ppib->pdabList;

        /* search thru thread's DAB list and unlink this DAB
        /**/
        for( ; pdab != pdabNil; pdabPrev = &pdab->pdabNext, pdab = pdab->pdabNext )
                {
                Assert( ppib == pdab->ppib );
                if ( pdab == vdbid )
                        {
                        *pdabPrev = pdab->pdabNext;
                        ReleaseVDbid( vdbid );
                        return( JET_errSuccess );
                        }
                }

        Assert( fFalse );
        return( JET_errSuccess );
        }

ERR ISAMAPI ErrIsamCreateDatabase(
        JET_VSESID sesid,
        const char __far*szDatabaseName,
        const char __far *szConnect,
        JET_DBID *pjdbid,
        JET_GRBIT grbit )
        {
        ERR             err;
        PIB             *ppib;
        DBID            dbid;
        VDBID           vdbid = vdbidNil;

        /* check parameters */
        Assert(sizeof(JET_VSESID) == sizeof(PIB *));
        ppib = (PIB*) sesid;

        dbid = 0;
        CallR( ErrDBCreateDatabase( ppib, (char *) szDatabaseName,
                (char *) szConnect, &dbid, grbit ) );

#ifdef  DISPATCHING
        Call( ErrDABAlloc( ppib, &vdbid, (DBID) dbid, JET_bitDbExclusive ) );
        Assert(sizeof(vdbid) == sizeof(JET_VDBID));
        Call( ErrAllocateDbid( pjdbid, (JET_VDBID) vdbid, &vdbfndefIsam ) );
#else
        *pjdbid = (JET_DBID) dbid;
#endif  /* !DISPATCHING */

        return JET_errSuccess;

HandleError:
        if ( vdbid != vdbidNil )
                CallS( ErrDABDealloc( ppib, vdbid ) );
        (VOID)ErrDBCloseDatabase( ppib, dbid, grbit );
        (VOID)ErrDBRemoveDatabase( ppib, (char *) szDatabaseName );
        return err;
        }


ERR ErrDBCreateDatabase( PIB *ppib, CHAR *szDatabaseName, CHAR *szConnect, DBID *pdbid, ULONG grbit )
        {
        ERR             err;
        DBID            dbid;
        CHAR            rgbFullName[JET_cbFullNameMost];
        CHAR            *szFullName;
        ULONG           cpgPrimary = cpgDatabaseMin;
        BOOL            fNoLoggingCapability;
        CHAR            *szFileName;

        CheckPIB( ppib );

        NotUsed(szConnect);
        Assert( *pdbid >= 0 && *pdbid < dbidUserMax );
        
        if (grbit & JET_bitDbNoLogging)
                grbit |= JET_bitDbRecoveryOff;

        if ( ppib->level > 0 )
                return JET_errInTransaction;

        if ( cpgPrimary == 0 )
                cpgPrimary = cpgDatabaseMin;

        if ( cpgPrimary > cpgDatabaseMax )
                return( JET_errDatabaseInvalidPages );

        /* if recovering and dbid is a known one, the lock the dbid first */
        if ( fRecovering && *pdbid != dbidTemp )
                {
                dbid = *pdbid;
                /* get corresponding dbid */
                CallS( ErrIOLockNewDbid( &dbid, rgfmp[dbid].szDatabaseName ) );
                }

        if ( fRecovering && *pdbid != dbidTemp && rgfmp[dbid].szRestorePath )
                {
                szFullName = rgfmp[dbid].szDatabaseName;
                szFileName = rgfmp[dbid].szRestorePath;
                }
        else
                {
                if ( _fullpath( rgbFullName, szDatabaseName, JET_cbFullNameMost ) == NULL )
                        {
                        return(JET_errDatabaseNotFound);
                        }
                szFullName = rgbFullName;
                szFileName = szFullName;
                }
        
        /* check if database file already exists
        /**/
        if ( FIOFileExists( szFileName ) )
                {
                err = JET_errDatabaseDuplicate;
                return err;
                }

        if ( !( fRecovering && *pdbid != dbidTemp ) )
                {
                err = ErrIOLockNewDbid( &dbid, szFullName );
                if ( err != JET_errSuccess )
                        {
                        if ( err == JET_wrnDatabaseAttached )
                                err = JET_errDatabaseDuplicate;
                        return err;
                        }
                }

        //      UNDONE: add support to FFileExists and remove check for file in
        //                              use here.
        if ( Hf(dbid) != handleNil )
                {
                IOUnlockDbid( dbid );
                err = JET_errDatabaseDuplicate;
                return err;
                }

        err = ErrIOOpenDatabase( dbid, szFileName, cpgPrimary );
        if ( err < 0 )
                {
                IOFreeDbid( dbid );
                return err;
                }

        /* set database non-loggable during CreateDB
        /**/
        rgfmp[dbid].fLogOn = fFalse;

        /*      not in a transaction, but still need to set lgposRC of the buffers
        /*      used by this function such that when get checkpoint, it will get
        /*      right check point.
        /**/
        if ( !( fLogDisabled || fRecovering ) )
                {
                EnterCriticalSection(critLGBuf);
                GetLgposOfPbEntry( &ppib->lgposStart );
                LeaveCriticalSection(critLGBuf);
                }

        /*      initialize the database file.  Logging of page operations is
        /*      turned off (during creation only). After creation the database
        /*      is marked "loggable" and logging is turned on.
        /**/
        SetOpenDatabaseFlag( ppib, dbid );

        fNoLoggingCapability = grbit & JET_bitDbNoLogging;
        Call( ErrDBInitDatabase(ppib, dbid, cpgPrimary, fNoLoggingCapability));

#ifdef  SYSTABLES
        if ( FSysTabDatabase( dbid ) )
                {
                Call( ErrSysTabCreate( ppib, dbid ) );  // Create system tables
                }
#endif  /* SYSTABLES */

#ifdef NO_OVER_PREREAD
        /*
         *  set the last page of the database, used to prevent over preread.
         */
        Call( ErrDBSetLastPage(ppib, dbid) );
#endif

        /*
         *  set database status to loggable
         */
        if ( grbit & JET_bitDbRecoveryOff )
                {
                rgfmp[ dbid ].fDBLoggable = fFalse;
                }
        else if ( FSysTabDatabase( dbid ) )
                {
                /* set all databases loggable except Temp if allowed
                /**/
                rgfmp[dbid].fDBLoggable = !fNoLoggingCapability;
                }

        rgfmp[dbid].fLogOn = rgfmp[dbid].fDBLoggable;

        /*      log Create Database prior to page modifications so file will
        /*      be open during redo of page modifications if soft crash occurs
        /**/
        Call( ErrLGCreateDB(
                        ppib,
                        dbid,
                        rgfmp[ dbid ].fLogOn,
                        grbit,
                        szFullName,
                        strlen(szFullName) + 1));

#ifdef DEBUG
        {
        /* must be a complete flush since the whole create db is log as one
        /* operation.
        /**/
        BOOL    fDBGForceFlushSav = fDBGForceFlush;
        fDBGForceFlush = fTrue;
#endif

        /* flush buffers if not temporary database
        /**/
        if ( dbid != dbidTemp )
                {
                Call( ErrBFFlushBuffers( dbid, fBFFlushSome ) );
                }


#ifdef DEBUG
        fDBGForceFlush = fDBGForceFlushSav;
        rgfmp[ dbid ].lBFFlushPattern = grbit >> 24;
        }
#endif

        /* if recover, the insertion is done by redoing logged insertion
         * operations. No need to do it again. Only do the database initialization.
         */
        if ( !fRecovering && FUserDbid( dbid ) )
                {
                err = ErrDBAddDatabase( ppib, szFullName, dbid );
                if (err < 0 && err != JET_errKeyDuplicate )
                        goto HandleError;
                }

        *pdbid = dbid;
        IOSetAttached( dbid );
        IOUnlockDbid( dbid );
        return JET_errSuccess;

HandleError:

        /*      functions may only use the call macro when the system state
        /*      is file exists, file open or closed, database record fWait
        /*      set, database record name valid and user logging status
        /*      valid.
        /**/
        BFPurge( dbid, 0 );                             /*  Purge bad db  */
        if ( FIODatabaseOpen(dbid) )
                IOCloseDatabase( dbid );
        IODeleteDatabase( dbid );
        ResetOpenDatabaseFlag( ppib, dbid );
        IOFreeDbid( dbid );
        return err;
        }


ERR ISAMAPI ErrIsamAttachDatabase(
        JET_VSESID sesid,
        const char __far *szDatabaseName,
        JET_GRBIT grbit )
        {
        PIB             *ppib;
        ERR             err;
        DBID    dbid;
        CHAR    rgbFullName[JET_cbFullNameMost];
        CHAR    *szFullName;
        ULONG   ulVersion;
        BOOL    fLoggingCapable;

        /* check parameters */
        Assert(sizeof(JET_VSESID) == sizeof(PIB *));
        ppib = (PIB*) sesid;

        CheckPIB( ppib );

        if ( ppib->level > 0 )
                return JET_errInTransaction;

        if ( _fullpath( rgbFullName, szDatabaseName, JET_cbFullNameMost ) == NULL )
                {
                return(JET_errDatabaseNotFound);
                }
        szFullName = rgbFullName;

        /*      depend on _fullpath to make same files same name
        /*      thereby preventing same file to be multiply attached
        /**/
        err = ErrIOLockNewDbid( &dbid, szFullName );
        if ( err != JET_errSuccess )
                {
                Assert( err == JET_wrnDatabaseAttached ||
                        err == JET_errOutOfMemory ||
                        err == JET_errTooManyAttachedDatabases );
                return err;
                }

        Call( ErrDBValidDatabaseFile( szFullName, &ulVersion, &fLoggingCapable ) );

#ifdef NO_OVER_PREREAD
        /*
         *  set the last page of the database, used to prevent over preread.
         */
        Call( ErrDBSetLastPage( ppib, dbid ) );
#endif

        /*      set database loggable flags.
        /**/
        if ( grbit & JET_bitDbRecoveryOff )
                {
                rgfmp[dbid].fDBLoggable = fFalse;
                }
        else if ( FSysTabDatabase( dbid ) )
                {
                /* set all databases loggable except Temp if allowed
                /**/
                rgfmp[dbid].fDBLoggable = fLoggingCapable;
                }

        rgfmp[dbid].fLogOn = rgfmp[dbid].fDBLoggable;

#ifdef DEBUG
        rgfmp[ dbid ].lBFFlushPattern = grbit >> 24;
#endif

        Call( ErrDBAddDatabase( ppib, szFullName, dbid ) );

        /* log Attach
        /**/
        Assert( dbid != dbidTemp );
        Call( ErrLGAttachDB(
                        ppib,
                        dbid,
                        rgfmp[ dbid ].fLogOn,
                        (char *) szFullName,
                        strlen(szFullName) + 1) );
                
        IOSetAttached( dbid );
        IOUnlockDbid( dbid );
        return JET_errSuccess;
HandleError:
        IOFreeDbid( dbid );
        return err;
        }


ERR ErrDBAccessDatabaseRoot(
        DBID dbid,
        SSIB *pssib,
        DBROOT **ppdbroot )
        {
        PN              pn;
        ERR             err;
        BOOL    fRecoveringSav;

        /* read in the FDP */
        pn = ((PN)dbid << 24) | (PGNO)1;

        /* set frecovering = fTrue to disable the Access page time stamp */
        /* check. The time stamp check access pfmp->ulDBTime which is */
        /* not initialized util this function is called. */

        fRecoveringSav = fRecovering;
        fRecovering = fTrue;

        CallR( ErrBFAccessPage( pssib->ppib, &pssib->pbf, pn ) );

        fRecovering = fRecoveringSav;

        /* root node */
        pssib->itag = 0;
        CallR( ErrPMGet( pssib, pssib->itag ) );
        *ppdbroot = (DBROOT*)PbNDData( pssib->line.pb ); /* point to root struct */

        return JET_errSuccess;
        }


/*      This is a special function always followed by BFFlush. No logging no
/*      Version for it. It is called in detach database or system shut down.
/**/
ERR ErrDBUpdateDatabaseRoot( DBID dbid )
        {
        ERR             err;
        LINE    rgline[3];
        DBROOT  *pdbroot;
        USHORT  usFlags;
        SSIB    ssibT;

        /*      if database updatable then update root
        /**/
        if( !FDBIDReadOnly( dbid ) )
                {
                /*  no operations on the database. This check is needed for recovering.
                /*  We may attach a database, without proper ulDBTime set, and then no
                /*  operation for this database. In this case, we do not want to
                /*  update its ulDBTime.
                /**/
                if ( rgfmp[ dbid ].ulDBTime == 0 )
                        return JET_errSuccess;

                CallR( ErrDBAccessDatabaseRoot(dbid, &ssibT, &pdbroot ) );

                /*      since database root node is fixed, we can wait
                /*      for write latch without refreshing currency
                /**/
                while ( FBFWriteLatchConflict( ssibT.ppib, ssibT.pbf ) )
                        {
                        BFSleep( cmsecWaitWriteLatch );
                        }

                /*      write latch page from dirty until log completion
                /**/
                BFPin( ssibT.pbf );
                BFSetWriteLatch( ssibT.pbf, ssibT.ppib );

                /* dirty here but not to increment the DBTime
                /**/
                BFSetDirtyBit ( ssibT.pbf );

                usFlags = pdbroot->usFlags;

                rgline[0].pb = ssibT.line.pb;
                rgline[0].cb = ssibT.line.cb - sizeof(ULONG) - sizeof(USHORT);

                Assert( !fRecovering ||
                        fDBGForceFlush ||
                        /* will be greater if UNDO is appended. */
                        rgfmp[ dbid ].ulDBTime >= rgfmp[ dbid ].ulDBTimeCurrent);
                Assert( rgfmp[ dbid ].ulDBTime > 0 );

                /* timestamp
                /**/
                rgline[1].pb = (char *)&(rgfmp[ dbid ].ulDBTime);
                rgline[1].cb = sizeof( ULONG );
                rgline[2].pb = (char *)&usFlags;
                rgline[2].cb = sizeof(USHORT);
                CallS( ErrPMReplace( &ssibT, rgline, 3 ) );

                BFResetWriteLatch( ssibT.pbf, ssibT.ppib );
                BFUnpin( ssibT.pbf );
                }

        return JET_errSuccess;
        }


ERR ISAMAPI ErrIsamDetachDatabase( JET_VSESID sesid, const char __far *szDatabaseName )
        {
        ERR             err;
        PIB             *ppib;
        DBID    dbid = 0;
        CHAR    rgbFullName[JET_cbFullNameMost];
        CHAR    *szFullName;
        DBID    dbidDetach;

        /* check parameters
        /**/
        Assert( sizeof(JET_VSESID) == sizeof(PIB *) );
        ppib = (PIB *)sesid;

        CheckPIB( ppib );

        if ( ppib->level > 0 )
                return JET_errInTransaction;

        if ( szDatabaseName == NULL )
                {
                dbidDetach = dbidUserMin;
                }
Start:
        if ( szDatabaseName == NULL )
                {
                for ( dbidDetach++; dbidDetach < dbidUserMax
                        && rgfmp[dbidDetach].szDatabaseName == NULL;
                        dbidDetach++ );
                Assert( dbidDetach != dbidSystemDatabase );
                if ( dbidDetach == dbidUserMax )
                        return JET_errSuccess;
                szFullName = rgfmp[dbidDetach].szDatabaseName;
                }
        else
                {
                if ( _fullpath( rgbFullName, szDatabaseName, JET_cbFullNameMost ) == NULL )
                        {
                        return(JET_errDatabaseNotFound);
                        }
                szFullName = rgbFullName;
                }

        /* purge all MPL entries for this dbid
        /**/

        MPLPurge( dbid );

        err = ErrIOLockDbidByNameSz( szFullName, &dbid );

        if ( err == JET_errSuccess && FIODatabaseInUse( dbid ) )
                {
                IOUnlockDbid( dbid );
                err = JET_errDatabaseInUse;
                }

        if ( err < 0 )
                {
                return err;
                }

        /*      clean up all version store. Actually we only need to clean up
        /*      the entries that had dbid as the dbid for the new database.
        /**/
        Call( ErrRCECleanAllPIB() );

        if ( FIODatabaseOpen(dbid) )
                {
                /*      if database is updatable then update time stamp.
                /**/
                if ( !FDBIDReadOnly( dbid ) )
                        {
                        Call( ErrDBUpdateDatabaseRoot( dbid ) );
                        }

                /*      flush all database buffers
                /**/
                err = ErrBFFlushBuffers( dbid, fBFFlushSome );
                if ( err < 0 )
                        {
                        IOUnlockDbid( dbid );
                        return err;
                        }

                /* purge all buffers for this dbid */
                BFPurge( dbid, (PGNO)0 );

                IOCloseDatabase( dbid );
                }

        Call( ErrDBRemoveDatabase( ppib, szFullName ) );

        // log Detach
        Assert( dbid != dbidTemp );
        Call( ErrLGDetachDB(
                        ppib,
                        dbid,
                        rgfmp[dbid].fLogOn,
                        (char *) szFullName,
                        strlen(szFullName) + 1) );

        /* purge all MPL entries for this dbid
        /**/
        MPLPurge( dbid );

        /*      clean up all version store again in case any versions created
        /*      by on-line compaction or update of database root.
        /**/
        Call( ErrRCECleanAllPIB() );

        /*      do not free dbid on detach to avoid problems related to
        /*      version RCE aliasing and database name conflict during
        /*      recovery.
        /**/
#ifdef REUSEDBID
        IOResetAttached( dbid );
        IOResetExclusive( dbid );
        IOUnlockDbid( dbid );
#else
        IOFreeDbid( dbid );
#endif

        /*      purge open table fcbs to avoid future confusion
        /**/
        FCBPurgeDatabase( dbid );

        if ( szDatabaseName == NULL )
                goto Start;

        return JET_errSuccess;

HandleError:
        IOUnlockDbid( dbid );
        return err;
        }


/*      DAE databases are repaired automatically on system restart
/**/
ERR ISAMAPI ErrIsamRepairDatabase(
        JET_VSESID sesid,
        const char __far *lszDbFile,
        JET_PFNSTATUS pfnstatus )
        {
        PIB *ppib;

        Assert(sizeof(JET_VSESID) == sizeof(PIB *));
        ppib = (PIB*) sesid;

        NotUsed(ppib);
        NotUsed(lszDbFile);
        NotUsed(pfnstatus);

        return JET_errFeatureNotAvailable;
        }


ERR ISAMAPI ErrIsamOpenDatabase(
        JET_VSESID sesid,
        const char __far *szDatabaseName,
        const char __far *szConnect,
        JET_DBID *pjdbid,
        JET_GRBIT grbit )
        {
        ERR             err;
        PIB             *ppib;
        DBID            dbid;
        VDBID           vdbid = vdbidNil;

        /* check parameters */
        Assert(sizeof(JET_VSESID) == sizeof(PIB *));
        ppib = (PIB*) sesid;
        NotUsed(szConnect);

        CheckPIB( ppib );

        dbid = 0;
        CallR( ErrDBOpenDatabase( ppib, (char *)szDatabaseName, &dbid, grbit ) );

#ifdef  DISPATCHING
        Call( ErrDABAlloc( ppib, &vdbid, dbid, grbit ) );
        Assert(sizeof(vdbid) == sizeof(JET_VDBID));
        Call( ErrAllocateDbid( pjdbid, (JET_VDBID) vdbid, &vdbfndefIsam ) );
#else   /* !DISPATCHING */
        *pjdbid = (JET_DBID) dbid;
#endif  /* !DISPATCHING */

        return JET_errSuccess;

HandleError:
        if ( vdbid != vdbidNil )
                CallS( ErrDABDealloc( ppib, vdbid ) );
        CallS( ErrDBCloseDatabase( ppib, dbid, grbit ) );
        return err;
        }


ERR ErrDBOpenDatabase( PIB *ppib, CHAR *szDatabaseName, DBID *pdbid, ULONG grbit )
        {
        ERR             err;
        CHAR    rgbFullName[JET_cbFullNameMost];
        CHAR    *szFullName;
        CHAR    *szFileName;
        DBID    dbid;
        ULONG   ulVersion;

        if ( fRecovering )
                {
                CallS( ErrIOLockDbidByNameSz( szDatabaseName, &dbid ) );
                }
        
        if ( fRecovering && rgfmp[dbid].szRestorePath )
                {
                szFullName = rgfmp[dbid].szDatabaseName;
                szFileName = rgfmp[dbid].szRestorePath;
                }
        else
                {
                if ( _fullpath( rgbFullName, szDatabaseName, JET_cbFullNameMost ) == NULL )
                        {
                        return(JET_errDatabaseNotFound);
                        }
                szFullName = rgbFullName;
                szFileName = szFullName;
                }

        if ( !fRecovering )
                {
                CallR( ErrIOLockDbidByNameSz( szFullName, &dbid ) );
                }

        /*  during recovering, we could open an non-detached database
        /*  to force to initialize the fmp entry.
        /*      if database has been detached, then return error.
        /**/
        if ( !fRecovering && !FIOAttached( dbid ) )
                {
                err = JET_errDatabaseNotFound;
                goto HandleError;
                }

        if ( FIOExclusiveByAnotherSession( dbid, ppib ) )
                {
                IOUnlockDbid( dbid );
                return JET_errDatabaseLocked;
                }

        if ( ( grbit & JET_bitDbExclusive ) )
                {
                if ( FIODatabaseInUse( dbid ) )
                        {
                        IOUnlockDbid( dbid );
                        return JET_errDatabaseInUse;
                        }
                IOSetExclusive( dbid, ppib );
                }

        if ( Hf(dbid) == handleNil )
                {
                /*  newly opened database
                /**/
                SSIB    ssibT;
                DBROOT  *pdbroot;
                BOOL    fLoggingCapable;

                Call( ErrDBValidDatabaseFile( szFileName, &ulVersion, &fLoggingCapable ) );
                Call( ErrIOOpenDatabase( dbid, szFileName, 0L ) );

                CallR( ErrDBAccessDatabaseRoot(dbid, &ssibT, &pdbroot ) );

                rgfmp[ dbid ].ulDBTime = pdbroot->ulDBTime;     /* copy last timestamp */

                /* loggable flag
                /**/
                Assert( pdbroot->usFlags & dbrootfLoggable ||
                        ( !rgfmp[ dbid ].fDBLoggable && !rgfmp[ dbid ].fLogOn ) );

                IOSetDatabaseVersion( dbid, ulVersion );
                }

        IOUnlockDbid( dbid );
        SetOpenDatabaseFlag( ppib, dbid );
        *pdbid = dbid;
        return JET_errSuccess;

HandleError:
        IOResetExclusive( dbid );
        IOUnlockDbid( dbid );
        return err;
        }


ERR ISAMAPI ErrIsamCloseDatabase(
        JET_VSESID      sesid,
        JET_VDBID       vdbid,
        JET_GRBIT       grbit )
        {
        ERR             err;
        PIB             *ppib;
        DBID            dbid = DbidOfVDbid( vdbid );
        ULONG           grbitOpen;                                                                              // flags for corresponding open

        /* check parameters
        /**/
        Assert( sizeof(JET_VSESID) == sizeof(PIB *) );
        ppib = (PIB *)sesid;
        NotUsed(grbit);

        CheckPIB( ppib );
        CheckDBID( ppib, dbid );
        grbitOpen = GrbitOfVDbid( vdbid );

        err = ErrDBCloseDatabase( ppib, dbid, grbitOpen );
#ifdef  DISPATCHING
        if ( err == JET_errSuccess )
                {
                ReleaseDbid( DbidOfVdbid( vdbid, &vdbfndefIsam ) );
                CallS( ErrDABDealloc( ppib, (VDBID) vdbid ) );
                }
#endif  /* DISPATCHING */
        return err;
        }


ERR ErrDBCloseDatabase( PIB *ppib, DBID dbid, ULONG     grbit )
        {
        ERR             err;
        FUCB    *pfucb;
        FUCB    *pfucbNext;

        if ( !( FUserOpenedDatabase( ppib, dbid ) ) )
                {
                return JET_errDatabaseNotFound;
                }

        CallR( ErrIOLockDbidByDbid( dbid ) );

        Assert( FIODatabaseOpen( dbid ) );

        if ( FLastOpen( ppib, dbid ) )
                {
                /*      close all open FUCBs on this database
                /**/

                /*      get first table FUCB
                /**/
                pfucb = ppib->pfucb;
                while ( pfucb != pfucbNil && ( pfucb->dbid != dbid || !FFCBClusteredIndex( pfucb->u.pfcb ) ) )
                        pfucb = pfucb->pfucbNext;

                while ( pfucb != pfucbNil )
                        {
                        /*      get next table FUCB
                        /**/
                        pfucbNext = pfucb->pfucbNext;
                        while ( pfucbNext != pfucbNil && ( pfucbNext->dbid != dbid || !FFCBClusteredIndex( pfucbNext->u.pfcb ) ) )
                                pfucbNext = pfucbNext->pfucbNext;

                        if ( !( FFUCBDeferClosed( pfucb ) ) )
                                {
                                if ( pfucb->fVtid )
                                        {
                                        CallS( ErrDispCloseTable( (JET_SESID)ppib, TableidOfVtid( pfucb ) ) );
                                        }
                                else
                                        {
                                        CallS( ErrFILECloseTable( ppib, pfucb ) );
                                        }
                                }
                        pfucb = pfucbNext;
                        }
                }

        /* if we opened it exclusively, we reset the flag
        /**/
        ResetOpenDatabaseFlag( ppib, dbid );
        if ( grbit & JET_bitDbExclusive )
                IOResetExclusive( dbid );
        IOUnlockDbid( dbid );

        /*      do not close file until file map space needed or database
        /*      detached.
        /**/

        return JET_errSuccess;
        }


/*      called by bookmark clean up to open database for bookmark
/*      clean up operation.  Returns error if database is in use for
/*      attachment/detachment.
/**/
ERR ErrDBOpenDatabaseByDbid( PIB *ppib, DBID dbid )
        {
        if ( !FIODatabaseAvailable( dbid ) )
                {
                return JET_errDatabaseNotFound;
                }

        SetOpenDatabaseFlag( ppib, dbid );
        return JET_errSuccess;
        }


/*      called by bookmark clean up to close database.
/**/
ERR ErrDBCloseDatabaseByDbid( PIB *ppib, DBID dbid )
        {
        ResetOpenDatabaseFlag( ppib, dbid );
        return JET_errSuccess;
        }


LOCAL ERR ErrDBRemoveDatabase( PIB *ppib, CHAR *szDatabaseName )
        {
        ERR             err = JET_errSuccess;
        FUCB    *pfucb;
        KEY             rgkey[2];
        BYTE    rgbKey[ JET_cbKeyMost ];
        DBID    dbidSysDb;

        /*      remove the entry added under DATABASES in the system database
        /*      for the detached database
        /**/
        CallR( ErrDIRBeginTransaction( ppib ) );

        dbidSysDb = dbidSystemDatabase;
        Call( ErrDBOpenDatabase( ppib, rgfmp[dbidSystemDatabase].szDatabaseName, &dbidSysDb, 0 ) );
        CallJ( ErrDIROpen( ppib, pfcbNil, dbidSystemDatabase, &pfucb ), DbClose );

        /*      normalize database name and set key and seek
        /**/
        rgkey[0] = *pkeyDatabases;
        SysNormText( szDatabaseName, strlen( szDatabaseName ), rgbKey, sizeof( rgbKey ), &rgkey[1].cb );
        rgkey[1].pb = rgbKey;
        err = ErrDIRSeekPath( pfucb, 2, rgkey, 0 );
        Assert( err != JET_errNoCurrentRecord );
        if ( err < 0 )
                {
                if ( err == JET_errRecordNotFound )
                        err = JET_errDatabaseNotFound;
                goto Close;
                }
        CallJ( ErrDIRDelete( pfucb, fDIRVersion ), Close );
        DIRClose( pfucb );
        Call( ErrDBCloseDatabase( ppib, dbidSysDb, 0 ) );
        Call( ErrDIRCommitTransaction( ppib ) );
        return JET_errSuccess;

Close:
        DIRClose( pfucb );
DbClose:
        CallS( ErrDBCloseDatabase( ppib, dbidSysDb, 0 ) );
HandleError:
        CallS( ErrDIRRollback( ppib ) );
        return err;
        }


LOCAL ERR ErrDBAddDatabase( PIB *ppib, CHAR *szDatabaseName, DBID dbid )
        {
        ERR             err = JET_errSuccess;
        FUCB    *pfucb;
        KEY             key;
        BYTE    rgbKey[ JET_cbKeyMost ];
        LINE    line;
        DBID    dbidSysDb;
        BYTE    rgdba[sizeof(BYTE) + sizeof(BYTE) + JET_cbNameMost];
        DBA             *pdba;

        /*      allocate space for DBA
        /**/
        pdba = (DBA *)rgdba;

        /*      add entry in DATABASES node of system database for created
        /*      database
        /**/
        CallR( ErrDIRBeginTransaction( ppib ) );
        dbidSysDb = dbidSystemDatabase;
#ifdef NJETNT
        Call( ErrDBOpenDatabase( ppib, rgtib[itibGlobal].szSysDbPath, &dbidSysDb, 0 ) );
#else
        Call( ErrDBOpenDatabase( ppib, szSysDbPath, &dbidSysDb, 0 ) );
#endif
        if ( FDBIDReadOnly( dbidSystemDatabase ) )
                {
                err = JET_errFileAccessDenied;
                goto DbClose;
                }

        CallJ( ErrDIROpen( ppib, pfcbNil, dbidSysDb, &pfucb ), DbClose );
        CallJ( ErrDIRSeekPath( pfucb, 1, pkeyDatabases, 0 ), Close );

        /*      normalize database name and set key
        /**/
        SysNormText( szDatabaseName, strlen( szDatabaseName ), rgbKey, sizeof( rgbKey ), &key.cb );
        key.pb = rgbKey;

        /*      set dba with dbid, fLogOn and database name without NULL terminator
        /**/
        pdba->bDbid = (BYTE)dbid;
        pdba->bLoggable = (BYTE)rgfmp[dbid].fLogOn;
        strncpy( (BYTE *)pdba->rgchDatabaseName, szDatabaseName, strlen( szDatabaseName ) );

        line.pb = (BYTE *)pdba;
        line.cb = (ULONG)(sizeof(BYTE) + sizeof(BYTE) + strlen(szDatabaseName));
        CallJ( ErrDIRInsert( pfucb, &line, &key, fDIRVersion ), Close )
        DIRClose( pfucb );
        Call( ErrDBCloseDatabase( ppib, dbidSysDb, 0 ) );
        Call( ErrDIRCommitTransaction( ppib ) );
        return JET_errSuccess;
Close:
        DIRClose( pfucb );
DbClose:
        CallS( ErrDBCloseDatabase( ppib, dbidSysDb, 0 ) );
HandleError:
        CallS( ErrDIRRollback( ppib ) );
        return err;
        }


ERR ErrDBValidDatabaseFile( CHAR *szDatabaseName, ULONG *pulVersion, BOOL *pfLoggingCapable )
        {
        ERR             err = JET_errSuccess;
        UINT    cb;
        HANDLE  hf;
        PAGE    *ppage;
        INT             ibTag;
        INT             cbTag;
        BYTE    *pb;

        CallR( ErrSysOpenFile( szDatabaseName, &hf, 0L, fTrue, fFalse ) );
        if ( ( ppage = ( PAGE * ) PvSysAllocAndCommit( cbPage ) ) == NULL )
                {
                err = JET_errOutOfMemory;
                goto HandleError;
                }

        SysChgFilePtr( hf, 0, NULL, FILE_BEGIN, &cb );
        Assert( cb == 0 );
        err = ErrSysReadBlock( hf, (BYTE*)ppage, cbPage, &cb );
        
        /* since file exists and we are unable to read data,
        /* it may not be a system.mdb
        /**/
        if ( err == JET_errDiskIO )
                err = JET_errDatabaseCorrupted;
        Call( err );
        
        IbCbFromPtag(ibTag, cbTag, &ppage->rgtag[0]);
        if ( ibTag < (BYTE*)&ppage->rgtag[1] - (BYTE*)ppage ||
                (BYTE*)ppage + ibTag + cbTag >= (BYTE*)(ppage + 1) )
                {
                err = JET_errDatabaseCorrupted;
                goto HandleError;
                }

        /*      at least FILES, OWNEXT, AVAILEXT
        /**/
        pb = (BYTE *)ppage + ibTag;
        if ( !FNDVisibleSons( *pb ) || CbNDKey( pb ) != 0 || FNDNullSon( *pb ) )
                {
                err = JET_errDatabaseCorrupted;
                goto HandleError;
                }

        /*      check data length
        /**/
        cb = cbTag - (UINT)( PbNDData( pb ) - pb );
        if ( cb != sizeof(DBROOT) )
                {
                err = JET_errDatabaseCorrupted;
                goto HandleError;
                }

        /*      return database version
        /**/
        *pulVersion = ((DBROOT *)PbNDData(pb))->ulVersion;
        *pfLoggingCapable = ((DBROOT *)PbNDData(pb))->usFlags & dbrootfLoggable;

HandleError:
        if ( ppage != NULL )
                SysFree( (VOID *)ppage );
        (VOID)ErrSysCloseFile( hf );
        return err;
        }


/* ErrDABCloseAllDBs: Close all databases (except system database) opened by this thread
/**/
ERR ErrDABCloseAllDBs( PIB *ppib )
        {
        ERR             err;

        while( ppib->pdabList != pdabNil )
                {
                Assert( FUserOpenedDatabase( ppib, ppib->pdabList->dbid ) );
                CallR( ErrIsamCloseDatabase( ( JET_VSESID ) ppib, (JET_VDBID) ppib->pdabList, 0 ) );
                }
        return JET_errSuccess;
        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\dir.c ===
#include "config.h"

#include <string.h>

#include "daedef.h"
#include "pib.h"
#include "util.h"
#include "page.h"
#include "ssib.h"
#include "node.h"
#include "fucb.h"
#include "fcb.h"
#include "stapi.h"
#include "fdb.h"
#include "idb.h"
#include "dirapi.h"
#include "spaceapi.h"
#include "recint.h"
#include "fileint.h"
#include "fileapi.h"
#include "sortapi.h"
#include "dbapi.h"
#include "nver.h"
#include "fmp.h"
#include "logapi.h"
#include "log.h"

DeclAssertFile;                                 /* Declare file name for assert macros */

extern void * __near critSplit;
extern BOOL fOLCompact;

LOCAL ERR ErrDIRIIRefresh( FUCB *pfucb );
LOCAL ERR ErrDIRICopyKey( FUCB *pfucb, KEY *pkey );
LOCAL ERR ErrDIRIDownToFDP( FUCB *pfucb, PGNO pgnoFDP );
LOCAL ERR ErrDIRIMoveToItem( FUCB *pfucb, SRID srid, BOOL fNext );
LOCAL INLINE ERR ErrDIRIInsertFDPPointer( FUCB *pfucb, PGNO pgnoFDP, KEY *pkey, INT fFlags );
LOCAL INLINE ERR ErrDIRIGotoItem( FUCB *pfucb, SRID bmItemList, ITEM item );

#undef DIRAPIReturn
#define	DIRAPIReturn( pfucbX, err )								\
	{															\
	Assert( pfucbX == pfucbNil ||								\
		((FUCB *)pfucbX)->pbfEmpty == pbfNil );				   	\
	return err;													\
	}

/****************** DIR Item Routines *********************
/**********************************************************
/**/
//	UNDONE:	if pcsr is always current then remove parameter
#define DIRIGetItemList( pfucb, pcsr )			   				\
	{											   				\
	Assert( pcsr == PcsrCurrent( pfucb ) );						\
	Assert( FFUCBNonClustered( (pfucb) ) );			  			\
	Assert( FReadAccessPage( (pfucb), (pcsr)->pgno ) );  	   	\
	AssertNDGet( pfucb, pcsr->itag ); 	 				  		\
	NDGetNode( (pfucb) );								   		\
	}


#define ErrDIRINextItem( pfucb )								\
	( pfucb->lineData.cb == sizeof(SRID) ?                      \
		errNDNoItem : ErrNDNextItem( pfucb ) )


#define ErrDIRIPrevItem( pfucb )                                \
	( PcsrCurrent(pfucb)->isrid == 0 ?                          \
		errNDNoItem : ErrNDPrevItem( pfucb ) )


/*	cache srid of first item list node for version.  Return
/*	warning JET_wrnKeyChanged if first item.
/**/
#define DIRICheckFirstSetItemListAndWarn( pfucb, wrn )			\
		{                                         				\
		if FNDFirstItem( *pfucb->ssib.line.pb )      			\
			{                                         			\
			wrn = JET_wrnKeyChanged;							\
			DIRISetItemListFromFirst( pfucb );        			\
			}                                        	 		\
		}


/*	cache srid of first item list node for version
/**/
#define DIRICheckFirstSetItemList( pfucb )         				\
		{                                            			\
		if FNDFirstItem( *pfucb->ssib.line.pb )      			\
			{                                         			\
			DIRISetItemListFromFirst( pfucb );        			\
			}                                         			\
		}


#define DIRISetItemListFromFirst( pfucb )          			   	\
		{                                    				   	\
		AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag ); 	   	\
		Assert( FNDFirstItem( *pfucb->ssib.line.pb ) );     	\
		NDGetBookmark( pfucb, &PcsrCurrent( pfucb )->bm );		\
		}


#define DIRICheckLastSetItemList( pfucb )                       \
		{                                                       \
		AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag ); 		\
		if FNDLastItem( *pfucb->ssib.line.pb )                  \
			{                                                   \
			DIRISetItemListFromLast( pfucb );                   \
			}    												\
		}


#define DIRICheckLastSetItemListAndWarn( pfucb, wrn )              	\
		{														   	\
		AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag ); 		   	\
		if FNDLastItem( *pfucb->ssib.line.pb )					   	\
			{													   	\
			wrn = JET_wrnKeyChanged;							   	\
			DIRISetItemListFromLast( pfucb );					   	\
			}													  	\
		}


/*	remember to back up one item after move to last item via
/*	seek for sridMax, since this call will normally position
/*	after last item and we want to move onto last item.
/**/
#define DIRISetItemListFromLast( pfucb ) 							\
		{                                                           \
		AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag ); 			\
		if FNDFirstItem( *pfucb->ssib.line.pb )                     \
			{                                                       \
			DIRISetItemListFromFirst( pfucb );                      \
			}                                                       \
		else                                                        \
			{                                                       \
			CallS( ErrDIRIMoveToItem( pfucb, sridMin, fFalse ) );   \
			DIRISetItemListFromFirst( pfucb );                      \
			CallS( ErrDIRIMoveToItem( pfucb, sridMax, fTrue ) );    \
			Assert( PcsrCurrent( pfucb )->isrid > 0 );				\
			PcsrCurrent( pfucb )->isrid--;							\
			}                                                       \
		}


/*********** DIR Fresh/Refresh Routines *************
/**********************************************************
/**/
#define AssertDIRFresh( pfucb )    									\
	Assert( FReadAccessPage( (pfucb),								\
		PcsrCurrent(pfucb)->pgno ) &&								\
		PcsrCurrent( pfucb )->ulDBTime ==							\
		UlSTDBTimePssib( &pfucb->ssib ) )


#define ErrDIRRefresh( pfucb )                                                                                            \
	( FReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) ?                                \
		ErrDIRIRefresh( pfucb ) : ErrDIRIIRefresh( pfucb ) )


#define ErrDIRIRefresh( pfucb )													\
	( !( FBFReadLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) ) &&							\
		PcsrCurrent(pfucb)->ulDBTime == UlSTDBTimePssib( &pfucb->ssib ) ?		\
		JET_errSuccess : ErrDIRIIRefresh( pfucb ) )


/*	this routine is called to refresh currency when time stamp is
/*	out of date or when buffer has been overlayed.  The common case
/*	is filtered out by the encapsulating macro.
/**/
LOCAL ERR ErrDIRIIRefresh( FUCB *pfucb )
	{
	ERR		err = JET_errSuccess;
	SSIB	*pssib = &pfucb->ssib;
	CSR		*pcsr;

Start:
	/*	cache pcsr for efficiency.  Must recache after start since
	/*	CSR may change as a result of some navigation operations.
	/**/
	pcsr = PcsrCurrent( pfucb );

	/*	only need to refresh currency when on node, or before, or after
	/*	node.  Before first, and after last do not need restoration.
	/*	On FDP node does not need restoration since this node is
	/*	inherently fixed.
	/**/
	switch ( pcsr->csrstat )
		{
		case csrstatOnCurNode:
		case csrstatBeforeCurNode:
		case csrstatAfterCurNode:
		case csrstatOnFDPNode:
			break;
		case csrstatDeferGotoBookmark:
			/*	goto bookmark as though operation was
			/*	not defered.  Must store currency so
			/*	that timestamp set for future operations.
			/**/
			Call( ErrBTGotoBookmark( pfucb, pcsr->bm ) );
			pcsr->csrstat = csrstatOnCurNode;
			goto AfterNodeRefresh;
			break;
		case csrstatDeferMoveFirst:
			{
			DIB		dib;
			FUCB 	*pfucbIdx;

			if ( pfucb->pfucbCurIndex )
				{
				pfucbIdx = pfucb->pfucbCurIndex;
				}
			else
				{
				pfucbIdx = pfucb;
				}

			/*	set DIB to move first
			/**/
			dib.fFlags = fDIRPurgeParent;
			dib.pos = posFirst;

			/*	go to DATA node
			/**/
			DIRGotoDataRoot( pfucbIdx );

			/*	move to first son of DATA node
			/**/
			err = ErrDIRDown( pfucbIdx, &dib );
			Assert( PcsrCurrent( pfucbIdx )->csrstat != csrstatDeferMoveFirst );
			Call( err );

			Assert( err == JET_errSuccess && PcsrCurrent( pfucbIdx )->csrstat == csrstatOnCurNode );
			if ( pfucb->pfucbCurIndex )
				{
				Assert( PcsrCurrent( pfucb ) == pcsr );
				pcsr->bm = PcsrCurrent( pfucbIdx )->item;
				Call( ErrBTGotoBookmark( pfucb, PcsrCurrent( pfucbIdx )->item ) );
				pcsr->csrstat = csrstatOnCurNode;
				}

			goto Done;
			}
		case csrstatOnDataRoot:
			{
			Assert( PcsrCurrent( pfucb ) == pcsr );
//			pcsr->bm == sridNull;
			pcsr->itagFather = itagNull;
			pcsr->pgno = PgnoRootOfPfucb( pfucb );
			while( !FReadAccessPage( pfucb, pcsr->pgno ) )
				{
				Call( ErrSTReadAccessPage( pfucb, pcsr->pgno ) );
				pcsr->pgno = PgnoRootOfPfucb( pfucb );
				}
			pcsr->itag = ItagRootOfPfucb( pfucb );
			NDGet( pfucb, pcsr->itag );

			/*	note that it is important here than the currency
			/*	is not set fresh since each time we use this CSR
			/*	we must go through the same process to navigate to the
			/*	data node.
			/**/
			goto Done;
			}
		default:
			Assert( pcsr->csrstat == csrstatAfterLast ||
				pcsr->csrstat == csrstatBeforeFirst );
			goto Done;
		}

	Assert( pcsr->csrstat == csrstatOnCurNode ||
		pcsr->csrstat == csrstatBeforeCurNode ||
		pcsr->csrstat == csrstatAfterCurNode ||
		pcsr->csrstat == csrstatOnFDPNode );

	/*	read access page and check for valid time stamp
	/**/
	if ( !FReadAccessPage( pfucb, pcsr->pgno ) )
		{
		err = ErrSTReadAccessPage( pfucb, pcsr->pgno );
		if ( err < 0 )
			return err;
		}

	/*	if timestamp unchanged then set line cache and data cache
	/*	for non-clustered cursors.  If timestamp changed then
	/*	refresh currency from bookmark.
	/**/
	if ( pcsr->ulDBTime == UlSTDBTimePssib( &pfucb->ssib ) )
		{
		NDGet( pfucb, pcsr->itag );
		if ( FFUCBNonClustered( pfucb ) )
			{
			DIRIGetItemList( pfucb, pcsr );
			}
		}
	else
		{
		/*	refresh node currency.  If node is not there for
		/*	caller then it must have been deleted so set
		/*	CSR status to before current node.
		/**/
		Assert( PcsrCurrent( pfucb ) == pcsr );
		err = ErrBTGotoBookmark( pfucb, pcsr->bm );
		if ( err < 0 )
			{
			if ( err == JET_errRecordDeleted )
				{
				err = JET_errSuccess;
				Assert( pcsr->csrstat == csrstatOnCurNode ||
					pcsr->csrstat == csrstatBeforeCurNode ||
					pcsr->csrstat == csrstatAfterCurNode );
				pcsr->csrstat = csrstatBeforeCurNode;
				}
			else
				goto HandleError;
			}

AfterNodeRefresh:
		/*	if non-clustered cursor and on item list, i.e. not on
		/*	index root, then position currency in item list.
		/**/
		if ( FFUCBNonClustered( pfucb ) && !FDIRDataRootRoot( pfucb, pcsr ) )
			{
			/*	fix item cursor for insert, delete, split.
			/**/
			DIRIGetItemList( pfucb, pcsr );
			Call( ErrDIRIMoveToItem( pfucb, pcsr->item, fTrue ) );
			}
		}

	DIRSetFresh( pfucb );
	err = JET_errSuccess;
Done:
	Assert( err >= 0 );
	if ( FBFReadLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) )
		{
		BFSleep( cmsecWaitWriteLatch );
		goto Start;
		}
	return err;

HandleError:
	Assert( err != JET_errRecordDeleted );
	return err;
	}


ERR ErrDIRGet( FUCB *pfucb )
	{
	ERR		err;
	CSR		*pcsr = PcsrCurrent( pfucb );

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );

	/*	special case on current node if
	/* 		on current node and
	/* 		page cached and
	/* 		timestamp not changed and
	/* 		node has not been versioned or
	/* 		caller sees consistent version
	/**/
	if (  pcsr->csrstat == csrstatOnCurNode )
		{
		/*	read access page and check for valid time stamp
		/**/
		if ( !FReadAccessPage( pfucb, pcsr->pgno ) )
			{
			Call( ErrSTReadAccessPage( pfucb, pcsr->pgno ) );
			}

		if ( pcsr->ulDBTime == UlSTDBTimePssib( &pfucb->ssib ) )
			{
			NDGet( pfucb, pcsr->itag );
			if ( !FNDVerDel( *(pfucb->ssib.line.pb) ) || FPIBDirty( pfucb->ppib ) )
				{
				NDGetNode( pfucb );
				return JET_errSuccess;
				}
			}
		}

	/*	refresh currency
	/**/
	Call( ErrDIRRefresh( pfucb ) );
	pcsr = PcsrCurrent(pfucb);

	/*	check CSR status
	/**/
	switch ( pcsr->csrstat )
		{
		case csrstatOnCurNode:
		case csrstatOnFDPNode:
		case csrstatOnDataRoot:
			break;
		default:
			Assert( pcsr->csrstat == csrstatBeforeCurNode ||
				pcsr->csrstat == csrstatAfterCurNode ||
				pcsr->csrstat == csrstatAfterLast ||
				pcsr->csrstat == csrstatBeforeFirst );
			return JET_errNoCurrentRecord;
		}

	/*	make node current, and return error if node is not there.
	/**/
	Call( ErrBTGetNode( pfucb, pcsr ) );

	/*	non-clustered cursor record bookmark cannot change.  Even
	/*	if record has been deleted, return from goto bookmark
	/*	operation will provide information.
	/**/
	err = JET_errSuccess;
	return err;

HandleError:
	DIRSetRefresh( pfucb );
	return err;
	}


/***************** DAE Internal Routines ******************
/**********************************************************
/**/
#define	DIRIPurgeParent( pfucb )												\
	FUCBFreePath( &(PcsrCurrent( pfucb )->pcsrPath), pcsrNil );


/*	free CSRs from current CSR to pcsr.
/**/
#define	DIRIUpToCSR( pfucb, pcsr )												\
	{																						\
	FUCBFreePath( &PcsrCurrent( pfucb ), pcsr );								\
	if ( FReadAccessPage( pfucb, pcsr->pgno ) )								\
		{																					\
		NDGet( pfucb, pcsr->itag );	  											\
		}																					\
	}


LOCAL ERR ErrDIRICopyKey( FUCB *pfucb, KEY *pkey )
	{
	if ( pfucb->pbKey == NULL )
		{
		pfucb->pbKey = LAlloc( 1L, JET_cbKeyMost );
		if ( pfucb->pbKey == NULL )
			return JET_errOutOfMemory;
		}
	KSReset( pfucb );
	AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );
	NDGetKey( pfucb );
	pkey->cb = pfucb->keyNode.cb;
	pkey->pb = pfucb->pbKey;
	memcpy( pkey->pb, pfucb->keyNode.pb, pkey->cb );
	return JET_errSuccess;
	}


LOCAL ERR ErrDIRIDownToFDP( FUCB *pfucb, PGNO pgnoFDP )
	{
	ERR	err;
	CSR	*pcsr;

	Assert( PcsrCurrent(pfucb)->csrstat == csrstatOnCurNode );

	err = ErrFUCBNewCSR( pfucb );
	if ( err < 0 )
		return err;
	pcsr = PcsrCurrent( pfucb );

	pcsr->csrstat = csrstatOnFDPNode;
	pcsr->bm = SridOfPgnoItag( pgnoFDP, 0 );
//	pcsr->item = itemNil;
	pcsr->pgno = pgnoFDP;
	pcsr->itag = 0;
	pcsr->itagFather = itagNull;
	pcsr->ibSon = 0;
	Call( ErrSTReadAccessPage( pfucb, pcsr->pgno ) );
//	pcsr->isrid = isridNull;
	NDGet( pfucb, pcsr->itag );
	NDGetNode( pfucb );
	return JET_errSuccess;

HandleError:
	BTUp( pfucb );
	return err;
	}


/*	this routine moves from first item list node to item insert
/*	position, or it moves from the last item list node to the
/*	first item list node.
/**/
LOCAL ERR ErrDIRIMoveToItem( FUCB *pfucb, SRID srid, BOOL fNext )
	{
	ERR		err = JET_errSuccess;
	SSIB	*pssib = &pfucb->ssib;
	CSR		*pcsr = PcsrCurrent( pfucb );
	DIB		dib;

	/*	item list nodes not versioned.
	/**/
	dib.fFlags = fDIRItemList;

	forever
		{
		Assert( FReadAccessPage( pfucb, pcsr->pgno ) );
		AssertNDGetNode( pfucb, pcsr->itag );

		/*	if we are moving to item insert position, then stop
		/*	when on last item list node or when insert position
		/*	found in item list node.
		/**/
		if ( fNext )
			{
			if ( srid != sridMax )
				err = ErrNDSeekItem( pfucb, srid );
			else
				{
				PcsrCurrent( pfucb )->isrid = pfucb->lineData.cb / sizeof(SRID);
				err = errNDGreaterThanAllItems;
				}
			if ( FNDLastItem( *pssib->line.pb ) || err != errNDGreaterThanAllItems )
				{
				break;
				}
			}
		else
			{
			if ( srid != sridMin )
				{
				err = ErrNDSeekItem( pfucb, srid );
				Assert( err == errNDGreaterThanAllItems ||
					err == wrnNDDuplicateItem ||
					err == JET_errSuccess );
				}
			else
				pcsr->isrid = 0;
			if ( FNDFirstItem( *pssib->line.pb ) || pcsr->isrid != 0 )
				{
				break;
				}
			}

		Call( ErrBTNextPrev( pfucb, PcsrCurrent( pfucb ), fNext, &dib ) );
		DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
		}

	if ( err != wrnNDDuplicateItem )
		err = JET_errSuccess;
HandleError:
	return err;
	}


/*	return JET_errKeyDuplicate, if any potentially there item
/*	found in this item list.
/**/
LOCAL INLINE ERR ErrDIRIKeyDuplicate( FUCB *pfucb )
	{
	ERR		err;
	CSR		*pcsr = PcsrCurrent( pfucb );
	SSIB 	*pssib = &pfucb->ssib;
	DIB		dib;
	SRID  	*psrid;
	SRID  	*psridMax;
	VS	  	vs;

	/*	must start on first item list node.
	/**/
	Assert( FNDFirstItem( *pssib->line.pb ) );
	AssertBTGetNode( pfucb, pcsr );

	dib.fFlags = fDIRNull;

	/*	for each node in item list, check for duplicate key.
	/**/
	forever
		{
		/*	for each SRID in item list, if item is potentially there
		/*	then return JET_errDuplicateKey.
		/**/
		psrid = (SRID *)pfucb->lineData.pb;
		psridMax = psrid + pfucb->lineData.cb / sizeof(SRID);
		for ( ; psrid < psridMax; psrid++ )
			{
			if ( FNDItemVersion( *( UNALIGNED SRID * )psrid ) )
				{
				vs = VsVERCheck( pfucb, PcsrCurrent( pfucb )->bm );
				if ( FVERPotThere( vs, FNDItemDelete( *( UNALIGNED SRID * )psrid ) ) )
					return JET_errKeyDuplicate;
				}
			else
				{
				if ( !FNDItemDelete( *( UNALIGNED SRID * )psrid )   )
					return JET_errKeyDuplicate;
				}
			}

		/*	if this node is last node in item list then break.
		/**/
		if ( FNDLastItem( *pssib->line.pb ) )
			break;

		Call( ErrBTNextPrev( pfucb, PcsrCurrent( pfucb ), fTrue, &dib ) );
		DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
		}

	err = JET_errSuccess;
HandleError:
	return err;
	}


/*	when a down does not find a valid item in the first/last item of
/*	an item list with the seek key, this routine is called to
/*	adjust the currency to a valid position.  The final position
/*	may be on a node with a key not equal to the seek key, if
/*	there was no valid item for the seek key.
/**/
LOCAL INLINE ERR ErrDIRIDownAdjust( FUCB *pfucb, DIB *pdib )
	{
	ERR		err = JET_errNoCurrentRecord;
	SSIB 	*pssib = &pfucb->ssib;
	INT		s;

	/* input currency on node.
	/**/
	AssertBTGetNode( pfucb, PcsrCurrent( pfucb ) );

	/*	item list nodes not versioned.
	/**/
	pdib->fFlags |= fDIRItemList;

	/*	if not pos last, move next to next valid item.
	/**/
	if ( pdib->pos != posLast )
		{
		while ( ( err = ErrDIRINextItem( pfucb ) ) < 0 )
			{
			Assert( err == errNDNoItem || err == errNDLastItemNode );
			/*	move to next node with DIB constraints
			/**/
			err = ErrBTNext( pfucb, pdib );
			if ( err < 0 )
				{
				if ( err == JET_errNoCurrentRecord )
					{
					ERR	errT;
					errT = ErrBTPrev( pfucb, pdib );
					if ( errT < 0 )
						goto HandleError;
					break;
					}
				goto HandleError;
				}

			DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );

			/*	if on new item list then set bookmark from
			/*	first item list node.
			/**/
			DIRICheckFirstSetItemList( pfucb );
			err = ErrNDFirstItem( pfucb );
			if ( err == JET_errSuccess )
				break;
			}
		}

	/*	if no valid item found then move previous item.
	/**/
	Assert( err == JET_errSuccess || err == JET_errNoCurrentRecord );
	if ( err < 0 )
		{
		while ( ( err = ErrDIRIPrevItem( pfucb ) ) < 0 )
			{
			Assert( err == errNDNoItem || err == errNDFirstItemNode );
			/*	move to previous node with DIB constraints
			/**/
			Call ( ErrBTPrev( pfucb, pdib ) );

			DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );

			/*	if on new item list, then set bookmark from
			/*	first item list node.
			/**/
			DIRICheckLastSetItemList( pfucb );
			err = ErrNDLastItem( pfucb );
			if ( err == JET_errSuccess )
				break;
			}
		}

	/*	if posDown then set status.
	/**/
	Assert( err == JET_errSuccess );
	if ( pdib->pos == posDown )
		{
		s = CmpStKey( StNDKey( pssib->line.pb ), pdib->pkey );
		if ( s == 0 )
			err = JET_errSuccess;
		else if ( s < 0 )
			err = wrnNDFoundLess;
		else
			err = wrnNDFoundGreater;
		}

HandleError:
	if ( err == JET_errNoCurrentRecord )
		err = JET_errRecordNotFound;
	return err;
	}


LOCAL INLINE ERR ErrDIRIInsertFDPPointer( FUCB *pfucb, PGNO pgnoFDP, KEY *pkey, INT fFlags )
	{
	ERR		err;
	LINE	line;
	CSR		*pcsrRoot = PcsrCurrent( pfucb );

	CheckFUCB( pfucb->ppib, pfucb );

	line.cb = sizeof(PGNO);
	line.pb = (BYTE *)&pgnoFDP;

	Call( ErrBTSeekForUpdate( pfucb, pkey, 0, 0, 0 ) );

	err = ErrBTInsert( pfucb, fNDFDPPtr, pkey, &line, fFlags );
	if ( err < 0 )
		{
		DIRIUpToCSR( pfucb, pcsrRoot );
		}

HandleError:
	CheckCSR( pfucb );
	return err;
	}


/*	Deletes item node that is either first or last
/*	enters critSplit, so split does not reorganize page during this time
/*	latches all buffers required, so no other user can read inconsistent data
/*	( since the changes are not versioned ).
/**/
LOCAL ERR ErrDIRIDeleteEndItemNode( FUCB *pfucb, BOOL fFirstItem, INT fFlags )
	{
	ERR		err;
	CSR		*pcsr = PcsrCurrent( pfucb );
	DIB		dib;
	BYTE 	bHeader;
	PGNO 	pgnoItem;
	BF	 	*pbfLatched;
	BF	 	*pbfSibling = pbfNil;

	/*	operations should not be versioned
	/**/
	Assert( !( fFlags & fDIRVersion ) );

	do
		{
Start:
		pbfSibling = pbfNil;
		LgLeaveCriticalSection( critJet );
		EnterNestableCriticalSection( critSplit );
		LgEnterCriticalSection( critJet );

		/*	check currency and refresh if necessary.
		/**/
		CallJ( ErrDIRRefresh( pfucb ), LeaveCritSplit );
		pgnoItem = pcsr->pgno;

		/* wait latch current page
		/**/
		Assert( FAccessPage( pfucb, pgnoItem ) );
		pbfLatched = pfucb->ssib.pbf;
		if ( FBFWriteLatchConflict( pfucb->ppib, pbfLatched ) )
			{
			LeaveNestableCriticalSection( critSplit );
			goto Start;
			}
		BFPin( pbfLatched );
		BFSetWriteLatch( pbfLatched, pfucb->ppib );
		BFSetWaitLatch( pbfLatched, pfucb->ppib );

		/*	if next/prev item node is on different page,
		/*	latch adjacent page
		/**/
		dib.fFlags = fDIRNull;
		if ( fFirstItem )
			{
			Call( ErrBTNext( pfucb, &dib ) );
			}
		else
			{
			Call( ErrBTPrev( pfucb, &dib ) );
			}

		if ( pcsr->pgno != pgnoItem )
			{
			Call( ErrSTWriteAccessPage( pfucb, pcsr->pgno ) );
			pbfSibling = pfucb->ssib.pbf;
			if ( FBFWriteLatchConflict( pfucb->ppib, pbfSibling ) )
				{
				BFResetWaitLatch( pbfLatched, pfucb->ppib );
				BFResetWriteLatch( pbfLatched, pfucb->ppib );
				BFUnpin( pbfLatched );
				LeaveNestableCriticalSection( critSplit );
				goto Start;
				}

			BFPin( pbfSibling );
			BFSetWriteLatch( pbfSibling, pfucb->ppib );
			BFSetWaitLatch( pbfSibling, pfucb->ppib );
			}

		/* go back page of deleted item and delete item node
		/**/
		Assert( dib.fFlags == fDIRNull );
		if ( fFirstItem )
			{
			CallS( ErrBTPrev( pfucb, &dib ) );
			}
		else
			{
			CallS( ErrBTNext( pfucb, &dib ) );
			}

		Call( ErrBTDelete( pfucb, fFlags ) );

		/*	make next/prev item list node new first/last item node
		/**/
		dib.fFlags = fDIRNull;
		if ( fFirstItem )
			{
			CallS( ErrBTNext( pfucb, &dib ) );
			}
		else
			{
			CallS( ErrBTPrev( pfucb, &dib ) );
			}

		CallS( ErrBTGet( pfucb, pcsr ) );
		bHeader = *pfucb->ssib.line.pb;
		if ( fFirstItem )
			NDSetFirstItem( bHeader );
		else
			NDSetLastItem( bHeader );

		//	UNDONE:	handle error from logging here
		CallS( ErrNDSetNodeHeader( pfucb, bHeader ) );

HandleError:
		if ( pbfSibling != pbfNil )
			{
			BFResetWaitLatch( pbfSibling, pfucb->ppib );
			BFResetWriteLatch( pbfSibling, pfucb->ppib );
			BFUnpin( pbfSibling );
			}
		BFResetWaitLatch( pbfLatched, pfucb->ppib );
		BFResetWriteLatch( pbfLatched, pfucb->ppib );
		BFUnpin( pbfLatched );

LeaveCritSplit:
		LeaveNestableCriticalSection(critSplit);
		}
	while ( err == errDIRNotSynchronous );

	return err;
	}


ERR ErrDIRICheckIndexRange( FUCB *pfucb )
	{
	ERR		err;

	AssertNDGetKey( pfucb, PcsrCurrent( pfucb )->itag );

	err = ErrFUCBCheckIndexRange( pfucb );
	if ( err == JET_errNoCurrentRecord )
		{
		if ( FFUCBUpper( pfucb ) )
			{
			DIRAfterLast( pfucb );
			}
		else
			{
			DIRBeforeFirst( pfucb );
			}
		}

	return err;
	}


VOID DIRISaveOLCStats( FUCB *pfucb )
	{
	ERR  	err;
	LINE	line;
	BOOL	fNonClustered = FFUCBNonClustered( pfucb );

	/*	release unneeded CSRs
	/**/
	if ( pfucb->pcsr != pcsrNil )
		{
		while ( pfucb->pcsr->pcsrPath != pcsrNil )
			{
			FUCBFreeCSR( pfucb );
			}
		}

	if ( !FFCBOLCStatsAvail( pfucb->u.pfcb ) )
		return;

	/* go to ../file/some_file/OLCStats
	/**/
	FUCBResetNonClustered( pfucb );
	DIRGotoFDPRoot( pfucb );
	err = ErrDIRSeekPath( pfucb, 1, pkeyOLCStats, 0 );
	if ( err != JET_errSuccess )
		{
		if ( err > 0 )
			err = JET_errDatabaseCorrupted;
#ifndef DATABASEFORMATCHANGE
		if ( err == JET_errRecordNotFound )
			err = JET_errSuccess;
#endif
		Error( err, HandleError );
		}

	/* replace existing data with pfcb->olcstats, if it has changed
	/**/
	if ( fOLCompact && FFCBOLCStatsChange( pfucb->u.pfcb ) )
		{
		line.pb = (BYTE *) &pfucb->u.pfcb->olcStat;
		line.cb = sizeof(PERS_OLCSTAT);

		Call( ErrDIRBeginTransaction( pfucb->ppib ) );
		err = ErrDIRReplace( pfucb, &line, fDIRNoVersion );
		if ( err >= JET_errSuccess )
			err = ErrDIRCommitTransaction( pfucb->ppib );
		if ( err < 0 )
			{
			CallS( ErrDIRRollback( pfucb->ppib ) );
			}
		}

HandleError:
	if ( fNonClustered )
		FUCBSetNonClustered( pfucb );
	return;
	}


/**************** DAE Super API Routines ******************
/**********************************************************
/**/
ERR ErrDIRSeekPath( FUCB *pfucb, INT ckeyPath, KEY *rgkeyPath, INT fFlags )
	{
	ERR		err = JET_errSuccess;
	DIB		dibT;
	CSR		*pcsr = PcsrCurrent( pfucb );
	INT		ikey;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );
	Assert( ckeyPath > 0 );
	Assert( rgkeyPath != NULL );

	/*	disable purge path for error recovery
	/**/
	dibT.fFlags = fFlags & ~( fDIRPurgeParent );
	dibT.pos = posDown;

	for ( ikey = 0; ikey < ckeyPath; ikey++ )
		{
		dibT.pkey = (KEY *)&rgkeyPath[ikey];
		err = ErrDIRDown( pfucb, &dibT );
		if ( err != errDIRFDP && err != JET_errSuccess )
			{
			if ( err >= JET_errSuccess )
				err = JET_errRecordNotFound;
			goto HandleError;
			}
		}

	/*	purge path if requested now that success is sure
	/**/
	if ( fFlags & fDIRPurgeParent )
		DIRIPurgeParent( pfucb );

	CheckCSR( pfucb );
	return err;

HandleError:
	DIRIUpToCSR( pfucb, pcsr );
	CheckCSR( pfucb );
	return err;
	}


VOID DIRIUp( FUCB *pfucb, INT ccsr )
	{
	CheckFUCB( pfucb->ppib, pfucb );
	CheckCSR( pfucb );
	Assert( ccsr > 0 );

	while ( PcsrCurrent( pfucb ) != pcsrNil && ccsr > 0 )
		{
		/*	must release two CSRs to move up through FDP node
		/*	since path through FDP has two CSRs
		/**/
		if ( PcsrCurrent( pfucb )->csrstat != csrstatOnFDPNode )
			ccsr--;
		FUCBFreeCSR( pfucb );
		}

	/*	set currency.
	/**/
	Assert( ccsr == 0 );
	Assert( PcsrCurrent( pfucb ) != pcsrNil );
	DIRSetRefresh( pfucb );

	/* set sridFather
	/**/
	{
	CSRSTAT		csrstat = PcsrCurrent( pfucb )->csrstat;
	if ( ( csrstat == csrstatOnFDPNode || csrstat == csrstatOnCurNode )
		 && PcsrCurrent( pfucb )->pcsrPath != pcsrNil )
		{
		pfucb->sridFather = PcsrCurrent( pfucb )->pcsrPath->bm;
		Assert( pfucb->sridFather != sridNull );
		Assert( pfucb->sridFather != sridNullLink );
		}
	else
		{
		pfucb->sridFather = sridNull;
		}
	}

	CheckCSR( pfucb );
	return;
	}


/******************** DIR API Routines ********************
/**********************************************************
/**/
ERR ErrDIROpen( PIB *ppib, FCB *pfcb, DBID dbid, FUCB **ppfucb )
	{
	ERR		err;
	FUCB 	*pfucb;

	CheckPIB( ppib );

#ifdef DEBUG
	if ( !fRecovering && fSTInit == fSTInitDone )
		CheckDBID( ppib, dbid );
#endif

	/*	canabalize deferred closed cursor
	/**/
	for ( pfucb = ppib->pfucb;
		pfucb != pfucbNil;
		pfucb = pfucb->pfucbNext )
		{
		if ( FFUCBDeferClosed(pfucb) && !FFUCBNotReuse(pfucb) )
			{
			Assert( pfucb->u.pfcb != pfcbNil );
			if ( ( pfucb->u.pfcb == pfcb ) ||
				( pfcb == pfcbNil &&
				pfucb->u.pfcb->dbid == dbid &&
				pfucb->u.pfcb->pgnoRoot == pgnoSystemRoot ) )
				{
				Assert( ppib->level > 0 );
				Assert( pfucb->levelOpen <= ppib->level );
				FUCBResetDeferClose(pfucb);
				// UNDONE: integrate this with ErrFUCBOpen
				pfucb->wFlags = 0;

				if ( FDBIDReadOnly( dbid ) )
					FUCBResetUpdatable(pfucb);
				else
					FUCBSetUpdatable(pfucb);
				goto GotoRoot;
				}
			}
		}

	err = ErrFUCBOpen( ppib, (DBID) (pfcb != pfcbNil ? pfcb->dbid : dbid), &pfucb );
	if ( err < 0 )
		{
		DIRAPIReturn( pfucbNil, err );
		}

	/*	link FCB
	/**/
	if ( pfcb == pfcbNil )
		{
		pfcb = PfcbFCBGet( dbid, pgnoSystemRoot );
		if ( pfcb == pfcbNil )
			Call( ErrFCBNew( ppib, dbid, pgnoSystemRoot, &pfcb ) );
		}
	FCBLink( pfucb, pfcb );

GotoRoot:
	/*	initialize cursor location to root of domain.
	/*	set currency.  Note, that no line can be cached
	/*	since this domain may not yet exist in page format.
	/**/
	PcsrCurrent( pfucb )->csrstat = csrstatOnFDPNode;
	PcsrCurrent( pfucb )->bm =
		SridOfPgnoItag( PgnoFDPOfPfucb( pfucb ), itagFOP );
	PcsrCurrent( pfucb )->pgno = PgnoFDPOfPfucb( pfucb );
	PcsrCurrent( pfucb )->itag = itagFOP;
	PcsrCurrent( pfucb )->itagFather = itagFOP;
	pfucb->sridFather = sridNull;
	DIRSetRefresh( pfucb );

	/*	reset rglineDiff delta logging
	/**/
	pfucb->clineDiff = 0;
	pfucb->fCmprsLg = fFalse;

	/*	set return pfucb
	/**/
	*ppfucb = pfucb;
	DIRAPIReturn( pfucb, JET_errSuccess );

HandleError:
	FUCBClose( pfucb );
	DIRAPIReturn( pfucbNil, err );
	}


VOID DIRClose( FUCB *pfucb )
	{
	/*	this cursor should not be already defer closed
	/**/
	Assert( fRecovering || !FFUCBDeferClosed(pfucb) );

	/*	release key buffer if one was allocated.
	/**/
	if ( pfucb->pbKey != NULL )
		{
		LFree( pfucb->pbKey );
		pfucb->pbKey = NULL;
		}

	/*  reset log compression */
	pfucb->clineDiff = 0;
	pfucb->fCmprsLg = fFalse;

	/*	if cursor created version then deferred close until transaction
	/*	level 0, for rollback support.
	/**/
	if ( pfucb->ppib->level > 0 && FFUCBVersioned( pfucb ) )
		{
		Assert( pfucb->u.pfcb != pfcbNil );
		DIRIPurgeParent( pfucb );
		FUCBSetDeferClose( pfucb );
		}
	else
		{
		if ( FFUCBDenyRead( pfucb ) )
			FCBResetDenyRead( pfucb->u.pfcb );
		if ( FFUCBDenyWrite( pfucb ) )
			FCBResetDenyWrite( pfucb->u.pfcb );

		/*	if last reference to fcb, save the OLCStats info
		/**/
		if ( pfucb->u.pfcb->wRefCnt == 1 )
			{
			DIRISaveOLCStats( pfucb );
			}

		FCBUnlink( pfucb );
		FUCBClose( pfucb );
		}
	}


ERR ErrDIRDown( FUCB *pfucb, DIB *pdib )
	{
	ERR		err;
	CSR		**ppcsr = &PcsrCurrent( pfucb );
	SRID	sridFatherSav = pfucb->sridFather;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );
	Assert( *ppcsr != pcsrNil );
	Assert( pdib->pos == posFirst ||
		pdib->pos == posLast ||
		pdib->pos == posDown );

	/*	check currency and refresh if necessary.
	/**/
	Call( ErrDIRRefresh( pfucb ) );

	switch( (*ppcsr)->csrstat )
		{
		case csrstatOnCurNode:
		case csrstatOnFDPNode:
		case csrstatOnDataRoot:
			break;
		default:
			Assert( (*ppcsr)->csrstat == csrstatBeforeCurNode ||
				(*ppcsr)->csrstat == csrstatAfterCurNode ||
				(*ppcsr)->csrstat == csrstatBeforeFirst ||
				(*ppcsr)->csrstat == csrstatAfterLast );
			DIRAPIReturn( pfucb, JET_errNoCurrentRecord );
		}

	/* save current node as visible father
	/**/
	pfucb->sridFather = (*ppcsr)->bm;

	/*	down to node
	/**/
	Call( ErrBTDown( pfucb, pdib ) );
	NDGetNode( pfucb );

	/*	handle key found case on non-clustered index before
	/*	status handling, since absence of valid items
	/*	may change case.
	/**/
	if ( FFUCBNonClustered( pfucb ) )
		{
		/*	if posLast, then move to last item.  If posFirst,
		/*	or posDown, then move to first item.
		/**/
		if ( err == JET_errSuccess )
			{
			if ( pdib->pos == posLast )
				{
				/*	set item list descriptor for subsequent ver
				/*	operations.
				/**/
				DIRISetItemListFromLast( pfucb );
				err = ErrNDLastItem( pfucb );
				}
			else
				{
				/*	set item list descriptor for subsequent ver
				/*	operations.
				/**/
				DIRISetItemListFromFirst( pfucb );
				err = ErrNDFirstItem( pfucb );
				}

			/*	if items not there, then go next previous
			/*	depending on DIB.  If no valid item found, then
			/*	discard leaf CSR and fail down operation.
			/**/
			if ( err != JET_errSuccess )
				{
				err = ErrDIRIDownAdjust( pfucb, pdib );
				if ( err < 0 )
					{
					if ( PcsrCurrent(pfucb)->pcsrPath )
						BTUp( pfucb );
					goto HandleError;
					}
				}
			}
		else
			{
			/*	set item list descriptor for subsequent ver
			/*	operations.
			/**/
			DIRISetItemListFromLast( pfucb );
			(VOID)ErrNDFirstItem( pfucb );
			}
		}
	else
		{
		/*	must store bookmark for currency.
		/**/
		DIRISetBookmark( pfucb, PcsrCurrent( pfucb ) );
		}

	/*	set status depending on search findings.
	/**/
	switch( err )
		{
		case JET_errSuccess:

			(*ppcsr)->csrstat = csrstatOnCurNode;

			if( FNDFDPPtr( *pfucb->ssib.line.pb ) )
				{
				AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );
//				Assert( !( FNDVersion( *pfucb->ssib.line.pb ) ) );
				Assert( pfucb->lineData.cb == sizeof(PGNO) );
				Call( ErrDIRIDownToFDP( pfucb, *( UNALIGNED PGNO * )pfucb->lineData.pb ) );
				AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );
				err = errDIRFDP;
				}
			break;

		case wrnNDFoundLess:
			(*ppcsr)->csrstat = csrstatAfterCurNode;
			if ( FFUCBNonClustered( pfucb ) )
				{
				/*	non-clustered index nodes are always there.
				/**/
				DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
				(VOID)ErrNDLastItem( pfucb );
				}
			break;

		default:
			Assert( err == wrnNDFoundGreater );
			(*ppcsr)->csrstat = csrstatBeforeCurNode;
			/*	isrid value could be any valid item
			/*	in node with key greater than seek key.
			/**/
			break;
		}

	if ( pdib->fFlags & fDIRPurgeParent )
		{
		DIRIPurgeParent( pfucb );
		}

	DIRSetFresh( pfucb );

	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, err );

HandleError:
	/*	reinstate sridFather
	/**/
	pfucb->sridFather = sridFatherSav;
	CheckCSR( pfucb );
	Assert( err != JET_errNoCurrentRecord );
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRDownFromDATA( FUCB *pfucb, KEY *pkey )
	{
	ERR		err;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );
	Assert( PcsrCurrent( pfucb ) != pcsrNil );

	/*	down to node
	/**/
	Call( ErrBTDownFromDATA( pfucb, pkey ) );
	NDGetNode( pfucb );

	/*	set to first item
	/**/
	PcsrCurrent( pfucb )->isrid = 0;

	/*	handle key found case on non-clustered index before
	/*	status handling, since absence of valid items
	/*	may change case.
	/**/
	if ( FFUCBNonClustered( pfucb ) )
		{
		/*	if posLast, then move to last item.  If posFirst,
		/*	or posDown, then move to first item.
		/**/
		if ( err == JET_errSuccess )
			{
			/*	set item list descriptor for subsequent ver
			/*	operations.
			/**/
			DIRISetItemListFromFirst( pfucb );
			err = ErrNDFirstItem( pfucb );

			/*	if items not there, then go next item.
			/*	If no valid item found, then set currency to
			/*	before first.
			/**/
			if ( err != JET_errSuccess )
				{
				DIB	dibT;

				dibT.fFlags = fDIRNull;
				dibT.pos = posDown;
				dibT.pkey = pkey;
				Call( ErrDIRIDownAdjust( pfucb, &dibT ) );
				}
			}
		else
			{
			/*	set item list descriptor for subsequent ver
			/*	operations.
			/**/
			DIRISetItemListFromLast( pfucb );
			(VOID)ErrNDFirstItem( pfucb );
			}
		}
	else
		{
		/*	must store bookmark for currency.
		/**/
		DIRISetBookmark( pfucb, PcsrCurrent( pfucb ) );
		}

	/*	set status depending on search findings.
	/**/
	switch( err )
		{
		case JET_errSuccess:
			PcsrCurrent( pfucb )->csrstat = csrstatOnCurNode;
			Assert( !FNDFDPPtr( *pfucb->ssib.line.pb ) );
			break;

		case wrnNDFoundLess:
			PcsrCurrent( pfucb )->csrstat = csrstatAfterCurNode;
			if ( FFUCBNonClustered( pfucb ) )
				{
				/*	non-clustered index nodes are always there.
				/**/
				DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
				(VOID)ErrNDLastItem( pfucb );
				}
			break;

		default:
			Assert( err == wrnNDFoundGreater );
			PcsrCurrent( pfucb )->csrstat = csrstatBeforeCurNode;
			/*	isrid value could be any valid item
			/*	in node with key greater than seek key.
			/**/
			break;
		}

	Assert( PcsrCurrent( pfucb )->pcsrPath == pcsrNil );

	DIRSetFresh( pfucb );

	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, err );

HandleError:
	CheckCSR( pfucb );
	Assert( err != JET_errNoCurrentRecord );
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRDownKeyBookmark( FUCB *pfucb, KEY *pkey, SRID srid )
	{
	ERR		err;
	DIB		dib;
	CSR		*pcsr;
	CSR		*pcsrRoot = PcsrCurrent( pfucb );
	SSIB	*pssib = &pfucb->ssib;

	/*	this routine should only be called with non-clustered indexes.
	/**/
	Assert( FFUCBNonClustered( pfucb ) );

	/*	check currency and refresh if necessary.
	/**/
	Assert( pfucb->pcsr->csrstat != csrstatDeferMoveFirst );
	Call( ErrDIRRefresh( pfucb ) );

	/*	item list nodes not versioned.
	/**/
	dib.fFlags = fDIRItemList;
	dib.pos = posDown;
	dib.pkey = pkey;
	Call( ErrBTDown( pfucb, &dib ) );
	Assert( err == JET_errSuccess );

	/*	set currency to on item list and get item list in node data.
	/**/
	pcsr = PcsrCurrent( pfucb );
	pcsr->csrstat = csrstatOnCurNode;
	DIRIGetItemList( pfucb, pcsr );

	/*	set item list descriptor for subsequent ver
	/*	operations.
	/**/
	DIRISetItemListFromFirst( pfucb );

	while ( ( err = ErrNDSeekItem( pfucb, srid ) ) == errNDGreaterThanAllItems )
		{
		Assert( !FNDLastItem( *pssib->line.pb ) );
		Call( ErrBTNextPrev( pfucb, pcsr, fTrue, &dib ) );
		DIRIGetItemList( pfucb, pcsr );
		}

	Assert( err == wrnNDDuplicateItem );
	Assert( pcsr->csrstat == csrstatOnCurNode );

	/*	set item currency.
	/**/
	pcsr->item = srid;

	/*	always purge parent.
	/**/
	DIRIPurgeParent( pfucb );

	DIRSetFresh( pfucb );

	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, JET_errSuccess );

HandleError:
	DIRIUpToCSR( pfucb, pcsrRoot );
	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, err );
	}


VOID DIRUp( FUCB *pfucb, INT ccsr )
	{
	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );

	DIRIUp( pfucb, ccsr );

	CheckCSR( pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	return;
	}


//+api
//	ERR ErrDIRNext( FUCB pfucb, DIB *pdib )
//
//	PARAMETERS
//		pfucb		 		cursor
//		pdib.pkey			key
//		pdib.fFlags
//		fDIRInPage			move to node/item of same page
//		fDIRNeighborKey		move to node/item of different key
//
//		RETURNS
//
//		err code					bottom CSR status
//		---------------------------------------------------
//		JET_errSuccess				OnCurNode
//		JET_errNoCurrentRecord		AfterLast
//		JET_errPageBoundary			AfterCurNode
//		JET_errKeyBoundary			AfterCurNode
//		errDIRFDP					OnFDPNode
//
//		COMMENTS
//
//		for negative return code, CSR status is unchanged
//-
ERR ErrDIRNext( FUCB *pfucb, DIB *pdib )
	{
	ERR		err;
	ERR		wrn = JET_errSuccess;
	CSR		*pcsr = PcsrCurrent( pfucb );
	KEY		key;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );

	/*	check currency and refresh if necessary
	/**/
	Call( ErrDIRRefresh( pfucb ) );
	pcsr = PcsrCurrent(pfucb);

	/*	switch action based on CSR status
	/**/
	switch( pcsr->csrstat )
		{
		case csrstatOnCurNode:
		case csrstatAfterCurNode:
			/*	get next item
			/**/
			break;

		case csrstatBeforeCurNode:
			/*	if non-clustered index then get first item.  If no item
			/*	then break to go to next item in next node.
			/**/
			if ( FFUCBNonClustered( pfucb ) )
				{
				/*	non-clustered index nodes are always there.
				/**/
				DIRIGetItemList( pfucb, pcsr );

				/*	set item list descriptor for subsequent ver
				/*	operations.
				/**/
				DIRICheckFirstSetItemList( pfucb );
				err = ErrNDFirstItem( pfucb );
				if ( err != JET_errSuccess )
					break;
				}
			else
				{
				/*	get current node.  If node is deleted, then break
				/*	to move to next node.
				/**/
				err = ErrBTGetNode( pfucb, pcsr );
				if ( err < 0 )
					{
					if ( err == JET_errRecordDeleted )
						break;
					goto HandleError;
					}
				}

			/*	set currency on current
			/**/
			pcsr->csrstat = csrstatOnCurNode;
			DIRSetFresh( pfucb );
			DIRAPIReturn( pfucb, err );

		case csrstatAfterLast:
			DIRAPIReturn( pfucb, JET_errNoCurrentRecord );

		case csrstatOnFDPNode:
			/*	go up to previous level so that cursor can
			/*	be moved to the next node
			/**/
			BTUp( pfucb );
			pcsr = PcsrCurrent( pfucb );
			break;

		default:
			{
			DIB	dib;
			Assert( pcsr->csrstat == csrstatBeforeFirst );

			dib.fFlags = fDIRPurgeParent;
			dib.pos = posFirst;

			/*	move to root.
			/**/
			DIRGotoDataRoot( pfucb );
			err = ErrDIRDown( pfucb, &dib );
			if ( err < 0 )
				{
				/*	retore currency.
				/**/
				DIRBeforeFirst( pfucb );

				/*	polymorph error code.
				/**/
				if ( err == JET_errRecordNotFound )
					err = JET_errNoCurrentRecord;
				}
			DIRAPIReturn( pfucb, err );
			}
		}

	/*	setup dib key
	/**/
	if ( ( pdib->fFlags & fDIRNeighborKey ) != 0 )
		{
		/*	get current node, which may no longer be there for us.
		/**/
		Call( ErrDIRICopyKey( pfucb, &key ) );
		pdib->pkey = &key;
		}

	/*	if non-clustered index, move to next item.  If on last item,
	/*	move to first item of next node else move to next node.
	/**/
	if ( FFUCBNonClustered( pfucb ) )
		{
		AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );

		/*	item list nodes not versioned.
		/**/
		pdib->fFlags |= fDIRItemList;

		/*	if neighbor key set then move to first item of next neighbor key
		/*	node, else, move to next item.  If node is deleted then move to
		/*	first item of next node.
		/**/
		if ( ( pdib->fFlags & fDIRNeighborKey ) != 0 )
			{
			/*	return warning that key has changed
			/**/
			wrn = JET_wrnKeyChanged;

			do
				{
				err = ErrBTNext( pfucb, pdib );
				/*	handle no next node such that DIB preserved.
				/**/
				if ( err < 0 )
					{
					pdib->fFlags |= fDIRNeighborKey;
					Call( err );
					}
				/*	must be on first item list node
				/**/
				Assert( !(pdib->fFlags & fDIRNeighborKey) || FNDFirstItem( *pfucb->ssib.line.pb ) );

				/*	must reset flag so can stop on item list nodes
				/*	in item list interior which have items while
				/*	other nodes have no items.  After stop then
				/*	reset DIB to initial state.
				/**/
				pdib->fFlags &= ~fDIRNeighborKey;
				DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
				/*	set item list descriptor for subsequent ver
				/*	operations.
				/**/
				DIRICheckFirstSetItemList( pfucb );
				err = ErrNDFirstItem( pfucb );
				/*	first item was not there, check for item there
				/*	later in same item list node.
				/**/
				if ( err != JET_errSuccess )
					err = ErrDIRINextItem( pfucb );
				}
			while ( err != JET_errSuccess );
			pdib->fFlags |= fDIRNeighborKey;
			}
		else
			{
			/*	non-clustered index nodes are always there.
			/**/
			pcsr->csrstat = csrstatOnCurNode;
			DIRIGetItemList( pfucb, pcsr );

			/*	move to next item and next node until item found.
			/**/
			while ( ( err = ErrDIRINextItem( pfucb ) ) < 0 )
				{
				Assert( err == errNDNoItem || err == errNDLastItemNode );
				/*	move to next node with DIB constraints
				/**/
				Call( ErrBTNext( pfucb, pdib ) );
				DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
				/*	set item list descriptor for subsequent ver
				/*	operations.
				/**/
				DIRICheckFirstSetItemListAndWarn( pfucb, wrn );
				err = ErrNDFirstItem( pfucb );
				if ( err == JET_errSuccess )
					{
					break;
					}
				}
			}
		}
	else
		{
		/*	return warning if key changed
		/**/
		wrn = JET_wrnKeyChanged;

		Call( ErrBTNext( pfucb, pdib ) );
		NDGetNode( pfucb );

		if ( FNDFDPPtr( *pfucb->ssib.line.pb ) )
			{
//			Assert( !( FNDVersion( *pfucb->ssib.line.pb ) ) );
			Assert( pfucb->lineData.cb == sizeof(PGNO) );
			Call( ErrDIRIDownToFDP( pfucb, *( UNALIGNED PGNO * )pfucb->lineData.pb ) );
#ifdef KEYCHANGED
			wrn = errDIRFDP;
#else
			err = errDIRFDP;
#endif
			}
		AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );
		DIRISetBookmark( pfucb, PcsrCurrent( pfucb ) );
		}

	/*	check index range
	/**/
	if ( FFUCBLimstat( pfucb ) && FFUCBUpper( pfucb ) && err == JET_errSuccess )
		{
		Call( ErrDIRICheckIndexRange( pfucb ) );
		}

	DIRSetFresh( pfucb );
	CheckCSR( pfucb );
#ifdef KEYCHANGED
	/*	return warning if key changed
	/**/
	DIRAPIReturn( pfucb, wrn );
#else
	DIRAPIReturn( pfucb, err );
#endif

HandleError:
	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRPrev( FUCB *pfucb, DIB *pdib )
	{
	ERR		err;
	ERR		wrn = JET_errSuccess;
	CSR		*pcsr = PcsrCurrent( pfucb );
	KEY		key;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );

	/*	check currency and refresh if necessary.
	/**/
	Call( ErrDIRRefresh( pfucb ) );
	pcsr = PcsrCurrent(pfucb);

	/*	switch action based on CSR status
	/**/
	switch( pcsr->csrstat )
		{
		case csrstatOnCurNode:
		case csrstatBeforeCurNode:
			/*	get next item
			/**/
			break;

		case csrstatAfterCurNode:
			/*	if non-clustered index then get current item.  If no item
			/*	then break to go to previous item in next node.
			/**/
			if ( FFUCBNonClustered( pfucb ) )
				{
				/*	non-clustered index nodes are always there
				/**/
				DIRIGetItemList( pfucb, pcsr );
				/*	set item list descriptor for subsequent ver
				/*	operations.
				/**/
				DIRISetItemListFromLast( pfucb );
				err = ErrNDGetItem( pfucb );
				if ( err != JET_errSuccess )
					break;
				}
			else
				{
				/*	get current node.  If node is deleted, then break
				/*	to move to next node.
				/**/
				err = ErrBTGetNode( pfucb, pcsr );
				if ( err < 0 )
					{
					if ( err == JET_errRecordDeleted )
						break;
					goto HandleError;
					}
				}

			/*	set currency on current
			/**/
			pcsr->csrstat = csrstatOnCurNode;
			DIRSetFresh( pfucb );
			DIRAPIReturn( pfucb, err );

		case csrstatBeforeFirst:
			DIRAPIReturn( pfucb, JET_errNoCurrentRecord );

		case csrstatOnFDPNode:
			/*	go up to previous level so that cursor can
			/*	be moved to the next node
			/**/
			BTUp( pfucb );
			pcsr = PcsrCurrent( pfucb );
			break;

		default:
			{
			DIB dib;

			Assert( pcsr->csrstat == csrstatAfterLast );

			dib.fFlags = fDIRPurgeParent;
			dib.pos = posLast;

			/*	move up preserving currency in case down fails.
			/**/
			DIRGotoDataRoot( pfucb );
			err = ErrDIRDown( pfucb, &dib );
			if ( err < 0 )
				{
				/*	restore currency.
				/**/
				DIRAfterLast( pfucb );

				/*	polymorph error code.
				/**/
				if ( err == JET_errRecordNotFound )
					err = JET_errNoCurrentRecord;
				}
			DIRAPIReturn( pfucb, err );
			}
		}

	/*	setup dib key
	/**/
	if ( ( pdib->fFlags & fDIRNeighborKey ) != 0 )
		{
		/*	get current node, which may no longer be there for us.
		/**/
		Call( ErrDIRICopyKey( pfucb, &key ) );
		pdib->pkey = &key;
		}

	/*	if non-clustered index, move to previous item
	/*	if on first item, move to last item of previous node
	/*	else move to previous node
	/**/
	if ( FFUCBNonClustered( pfucb ) )
		{
		AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );

		/*	item list nodes not versioned.
		/**/
		pdib->fFlags |= fDIRItemList;

		/*	if neighbor key then move to last item of previous neighbor key
		/*	node, else move to previous item.  If current node deleted, then
		/*	move to previous node.
		/**/
		if ( ( pdib->fFlags & fDIRNeighborKey ) != 0 )
			{
			/*	return warning that key has changed
			/**/
			wrn = JET_wrnKeyChanged;

			do
				{
				/*	handle no prev node such that DIB preserved
				/**/
				err = ErrBTPrev( pfucb, pdib );
				if ( err < 0 )
					{
					pdib->fFlags |= fDIRNeighborKey;
					Call( err );
					}

				/*	must be last item list node
				/**/
				Assert( !( pdib->fFlags & fDIRNeighborKey ) || FNDLastItem( *pfucb->ssib.line.pb ) );

				/*	must reset flag so can stop on item list nodes
				/*	in item list interior which have items while
				/*	other nodes have no items.  After stop then
				/*	reset DIB to initial state.
				/**/
				pdib->fFlags &= ~fDIRNeighborKey;

				DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
				/*	set item list descriptor for subsequent ver
				/*	operations.
				/**/
				DIRICheckLastSetItemList( pfucb );
				err = ErrNDLastItem( pfucb );
				/*	last item was not there, check for item there
				/*	earlier in same item list node.
				/**/
				if ( err != JET_errSuccess )
					err = ErrDIRIPrevItem( pfucb );
				}
			while ( err != JET_errSuccess );
			pdib->fFlags |= fDIRNeighborKey;
			}
		else
			{
			/*	non-clustered index nodes are always there.
			/**/
			pcsr->csrstat = csrstatOnCurNode;
			DIRIGetItemList( pfucb, pcsr );

			while ( ( err = ErrDIRIPrevItem( pfucb ) ) < 0 )
				{
				Assert( err == errNDNoItem || err == errNDFirstItemNode );
				/*	move to previous node with DIB constraints
				/**/
				Call( ErrBTPrev( pfucb, pdib ) );
				DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
				/*	set item list descriptor for subsequent ver
				/*	operations.
				/**/
				DIRICheckLastSetItemListAndWarn( pfucb, wrn );
				err = ErrNDLastItem( pfucb );
				if ( err == JET_errSuccess )
					{
					break;
					}
				}
			}
		}

	else
		{
		/*	return warning if key changed
		/**/
		wrn = JET_wrnKeyChanged;
		Call( ErrBTPrev( pfucb, pdib ) );
 		NDGetNode( pfucb );

		if ( FNDFDPPtr( *pfucb->ssib.line.pb ) )
			{
//			Assert( !( FNDVersion( *pfucb->ssib.line.pb ) ) );
			Assert( pfucb->lineData.cb == sizeof(PGNO) );
			Call( ErrDIRIDownToFDP( pfucb, *(PGNO *)pfucb->lineData.pb ) );
#ifdef KEYCHANGED
			wrn = errDIRFDP;
#else
			err = errDIRFDP;
#endif
			}
		AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );
		DIRISetBookmark( pfucb, PcsrCurrent( pfucb ) );
		}

	/*	check index range.  If exceed range, then before first, disable
	/*	range and return no current record.
	/**/
	if ( FFUCBLimstat( pfucb ) && !FFUCBUpper( pfucb ) && err == JET_errSuccess )
		{
		Call( ErrDIRICheckIndexRange( pfucb ) );
		}

	DIRSetFresh( pfucb );
	CheckCSR( pfucb );
#ifdef KEYCHANGED
	/*	return warning if key changed
	/**/
	DIRAPIReturn( pfucb, wrn );
#else
	DIRAPIReturn( pfucb, err );
#endif

HandleError:
	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRCheckIndexRange( FUCB *pfucb )
	{
	ERR		err;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );

	/*	check currency and refresh if necessary
	/**/
	Call( ErrDIRRefresh( pfucb ) );
	/*	get keyNode for check index range
	/**/
	Call( ErrDIRGet( pfucb ) );
	Call( ErrDIRICheckIndexRange( pfucb ) );

	DIRSetFresh( pfucb );
HandleError:
	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRInsert( FUCB *pfucb, LINE *pline, KEY *pkey, INT fFlags )
	{
	ERR		err;
	CSR		*pcsrRoot;
	DIB		dib;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );

Start:
	/* save current node as visible father
	/**/
	Assert( pfucb->pcsr->csrstat != csrstatDeferMoveFirst );
	pcsrRoot = PcsrCurrent( pfucb );
	pfucb->sridFather = pcsrRoot->bm;
	Assert( pfucb->sridFather != sridNull );
	Assert( pfucb->sridFather != sridNullLink );

	/*	check currency and refresh if necessary.
	/**/
	Call( ErrDIRRefresh( pfucb ) );

	if ( FFUCBNonClustered( pfucb ) )
		{
		SRID	srid;
		INT		cbReq;
		SSIB	*pssib = &pfucb->ssib;

		/*	get given item
		/**/
		Assert( pline->cb == sizeof(SRID) );
		srid = *( UNALIGNED SRID * ) pline->pb;

		/*	seek first item list node with given key.  Allow duplicate nodes
		/*	even if non-clustered index does not allow duplicate key items
		/*	since node may contain item list with all deleted items.
		/**/
		err = ErrBTSeekForUpdate( pfucb, pkey, 0, 0, fDIRDuplicate | fDIRReplaceDuplicate | fFlags );

		switch ( err )
			{
			case JET_errSuccess:
				{
				/*	seek for update does not cache line pointers.
				/*	We need this information for item insertion.
				/**/
				DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );

		 		/*	if versioning then get bookmark of first item list
				/*	node to hash item versions.
				/**/
				if ( fFlags & fDIRVersion )
					{
					SRID	bmItemList;

					/*	if node is not first item list node then
					/*	reseek to first item list node.  In this way,
					/*	thrashing across many duplicate index entries.
					/**/
					if ( !FNDFirstItem( *( pfucb->ssib.line.pb ) ) )
						{
						/*	go up to root, and reseek to begining of item list node list
						/**/
						DIRIUpToCSR( pfucb, pcsrRoot );
						dib.fFlags = fDIRNull;
						dib.pos = posDown;
						dib.pkey = pkey;
						Call( ErrBTGet( pfucb, PcsrCurrent( pfucb ) ) );
						Call( ErrBTDown( pfucb, &dib ) );
						Assert( FNDFirstItem( *( pfucb->ssib.line.pb ) ) );
						DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
						}

					/*	set item list descriptor for subsequent ver operations
					/**/
					DIRISetItemListFromFirst( pfucb );
					bmItemList = PcsrCurrent( pfucb )->bm;

					/*	if duplicates are not allowed then check for duplicate
					/**/
					if ( !( fFlags & fDIRDuplicate ) )
						{
						Assert( FNDFirstItem( *( pfucb->ssib.line.pb ) ) );

						/*	check for duplicate key
						/**/
						Call( ErrDIRIKeyDuplicate( pfucb ) );
						Assert( FNDLastItem( *( pfucb->ssib.line.pb ) ) );
						}
					else if ( !FNDLastItem( *( pfucb->ssib.line.pb ) ) )
						{
						/*	now go back to end of item list node list and seek for
						/*	insertion point, which is more likely to be at
						/*	end of list.  Note that during this time, all items
						/*	may have been deleted and cleaned up, so if not found
						/*	success, then start over.
						/**/
						DIRIUpToCSR( pfucb, pcsrRoot );
						Call( ErrBTGet( pfucb, PcsrCurrent( pfucb ) ) );
						Call( ErrBTSeekForUpdate( pfucb, pkey, 0, 0, fDIRDuplicate | fDIRReplaceDuplicate | fFlags ) );
						if ( err != JET_errSuccess )
							goto Start;
						Assert( FNDLastItem( *( pfucb->ssib.line.pb ) ) );
						DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
						}

					/*	move to item insert position
					/**/
					Assert( FNDLastItem( *( pfucb->ssib.line.pb ) ) );
					Call( ErrDIRIMoveToItem( pfucb, srid, fFalse ) );

					/*	set bm from cached bm
					/**/
					PcsrCurrent( pfucb )->bm = bmItemList;
					}
				else
					{
					/*	set bookmark from current node
					/**/
					PcsrCurrent( pfucb )->bm = SridOfPgnoItag( PcsrCurrent( pfucb )->pgno,
						PcsrCurrent( pfucb )->itag );

					/*	if duplicates are not allowed then check for duplicate
					/**/
					if ( !( fFlags & fDIRDuplicate ) )
						{
						/*	if node is not first item list node then
						/*	reseek to first item list node.  In this way,
						/*	thrashing across many duplicate index entries.
						/**/
						if ( !FNDFirstItem( *( pfucb->ssib.line.pb ) ) )
							{
							/*	go up to root, and reseek to begining of item list node list
							/**/
							DIRIUpToCSR( pfucb, pcsrRoot );
							dib.fFlags = fDIRNull;
							dib.pos = posDown;
							dib.pkey = pkey;
							Call( ErrBTGet( pfucb, PcsrCurrent( pfucb ) ) );
							Call( ErrBTDown( pfucb, &dib ) );
							Assert( FNDFirstItem( *( pfucb->ssib.line.pb ) ) );
							DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
							}

						/*	check for duplicate key
						/**/
						Assert( FNDFirstItem( *( pfucb->ssib.line.pb ) ) );
						Call( ErrDIRIKeyDuplicate( pfucb ) );
						}

					/*	move to item insert position
					/**/
					Assert( FNDLastItem( *( pfucb->ssib.line.pb ) ) );
					Call( ErrDIRIMoveToItem( pfucb, srid, fFalse ) );

					/*	set bookmark from current node
					/**/
					PcsrCurrent( pfucb )->bm = SridOfPgnoItag( PcsrCurrent( pfucb )->pgno,
						PcsrCurrent( pfucb )->itag );
					}

				/*	if item already there, then overwrite with insert version
				/**/
				if ( err == wrnNDDuplicateItem )
					{
					err = ErrNDFlagInsertItem( pfucb );
					if ( err == errDIRNotSynchronous )
						{
						DIRIUpToCSR( pfucb, pcsrRoot );
						goto Start;
						}
					Call( err );
					}
				else
					{
					/*	split item list node if maximum number of items
					/*	has been reached
					/**/
					if ( pfucb->lineData.cb == citemMax * sizeof(SRID) )
						{
						cbReq = cbFOPOneSon + pfucb->keyNode.cb;

						if ( FBTSplit( pssib, cbReq, 1 ) )
							{
							FUCBFreePath( &PcsrCurrent( pfucb )->pcsrPath, pcsrRoot );
							AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );
							Call( ErrBTSplit( pfucb, pfucb->ssib.line.cb, cbReq, NULL, fDIRAppendItem | fDIRReplace ) );
							DIRIUpToCSR( pfucb, pcsrRoot );
							goto Start;
							}

						Call( ErrNDSplitItemListNode( pfucb, fFlags ) );
						DIRIUpToCSR( pfucb, pcsrRoot );
						goto Start;
						}

					cbReq = sizeof(SRID);
					if ( FBTSplit( pssib, cbReq, 0 ) )
						{
						FUCBFreePath( &PcsrCurrent( pfucb )->pcsrPath, pcsrRoot );
						AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );
						Call( ErrBTSplit( pfucb, pfucb->ssib.line.cb, cbReq, pkey, fDIRAppendItem | fDIRReplace ) );
						DIRIUpToCSR( pfucb, pcsrRoot );
						goto Start;
						}

					/*	cache page access in case lost during loss of critJet
					/**/
					if ( !FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) )
						{
						Call( ErrSTWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
						}
					NDGet( pfucb, PcsrCurrent( pfucb )->itag );
					DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
					err = ErrNDInsertItem( pfucb, (SRID)srid, fFlags );
					if ( err == errDIRNotSynchronous )
						{
						DIRIUpToCSR( pfucb, pcsrRoot );
						goto Start;
						}
					Call( err );
					PcsrCurrent( pfucb )->csrstat = csrstatOnCurNode;
					}
				break;
				}

			case wrnNDFoundLess:
			case wrnNDFoundGreater:
				{
				cbReq = cbNullKeyData + pkey->cb + sizeof(SRID);
				if ( FBTAppendPage( pfucb, PcsrCurrent( pfucb ), cbReq, 0, CbFreeDensity( pfucb ) ) ||
					FBTSplit( pssib, cbReq, 1 ) )
					{
					FUCBFreePath( &PcsrCurrent( pfucb )->pcsrPath, pcsrRoot );
					Call( ErrBTSplit( pfucb, 0, cbReq, pkey, 0 ) );
					DIRIUpToCSR( pfucb, pcsrRoot );
					goto Start;
					}

				/*	insert item list node.
				/**/
				err = ErrNDInsertItemList( pfucb, pkey, *(UNALIGNED SRID *)pline->pb, fFlags );
				if ( err == errDIRNotSynchronous )
					{
					DIRIUpToCSR( pfucb, pcsrRoot );
					goto Start;
					}
				Call( err );
				PcsrCurrent( pfucb )->csrstat = csrstatOnCurNode;
				break;
				}

			default:
				goto HandleError;
			}
		}
	else
		{
		/*	clustered index
		/**/
		Call( ErrBTSeekForUpdate( pfucb, pkey, 0, 0, fFlags ) );

		err = ErrBTInsert( pfucb, 0, pkey, pline, fFlags );
		if ( err == errDIRNotSynchronous )
			{
			BTUp( pfucb );
			goto Start;
			}
		Call( err );
		DIRISetBookmark( pfucb, PcsrCurrent( pfucb ) );
		}

	if ( fFlags & fDIRBackToFather )
		{
		DIRIUp( pfucb, 1 );
		Assert( PcsrCurrent( pfucb ) == pcsrRoot );
		}
	else
		{
		if ( fFlags & fDIRPurgeParent )
			{
			Assert( err >= 0 );
			DIRIPurgeParent( pfucb );
			}
		DIRSetFresh( pfucb );
		}

HandleError:
	/*	 if write latched empty page the release latch
	/**/
	if ( pfucb->pbfEmpty != pbfNil )
		{
		BFResetWriteLatch( pfucb->pbfEmpty, pfucb->ppib );
		BFUnpin( pfucb->pbfEmpty );
		pfucb->pbfEmpty = pbfNil;
		}

	/*	depend on ErrDIRRollback to clean up on error.  Rollback may have
	/*	already occured in which case even pcsrRoot may no longer be
	/*	present in CSR stack.
	/**/
//	if ( err < 0 )
//		{
//		DIRIUpToCSR( pfucb, pcsrRoot );
//		}

#ifdef DEBUG
	if ( err >= JET_errSuccess )
		CheckCSR( pfucb );
#endif

	DIRAPIReturn( pfucb, err );
	}


/* Does not log, this is done at a higher level
/**/
ERR ErrDIRInsertFDP( FUCB *pfucb, LINE *pline, KEY *pkey, INT fFlags, CPG cpgMin )
	{
	ERR     err;
	CPG     cpgRequest;
	PGNO    pgnoFDP;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );

	/*	check currency and refresh if necessary.
	/**/
	Call( ErrDIRRefresh( pfucb ) );
	Assert( FReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );

	/*	create FDP
	/**/
	cpgRequest = cpgMin;
	Call( ErrSPGetExt( pfucb, pfucb->u.pfcb->pgnoFDP, &cpgRequest, cpgMin, &pgnoFDP, fTrue ) );

	/*	add FDP to directory tree
	/**/
	do
		{
		Call( ErrDIRRefresh( pfucb ) );

		err = ErrDIRIInsertFDPPointer( pfucb, pgnoFDP, pkey, fFlags );
		}
	while ( err == errDIRNotSynchronous );
	Call( err );

	/*	replace FDP root with correct data.  NOTE: key left as NULL.
	/*	Also NOTE, this node must be versioned as a indication of
	/*	domain status, to be used during rollback processing.
	/**/
	Call( ErrDIRIDownToFDP( pfucb, pgnoFDP ) );
	AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );
	DIRISetBookmark( pfucb, PcsrCurrent( pfucb ) );
	Assert( pline->cb > 0 );

	/*	since this replace is of the FDP root do not handle split case
	/**/
	do
		{
		Call( ErrDIRRefresh( pfucb ) );

		err = ErrBTReplace( pfucb, pline, fDIRVersion );
		}
	while ( err == errDIRNotSynchronous );
	Call( err );

	if ( fFlags & fDIRBackToFather )
		{
		DIRIUp( pfucb, 1 );
		}
	else
		{
		if ( fFlags & fDIRPurgeParent )
			{
			DIRIPurgeParent( pfucb );
			}
		DIRSetFresh( pfucb );
		}

HandleError:
	/*	 if write latched empty page the release latch
	/**/
	if ( pfucb->pbfEmpty != pbfNil )
		{
		BFResetWriteLatch( pfucb->pbfEmpty, pfucb->ppib );
		BFUnpin( pfucb->pbfEmpty );
		pfucb->pbfEmpty = pbfNil;
		}

	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, err );
	}


/*	This routine is for use in building non-clustered indexes.  It does not
/*	maintain normal CSR status and leaves currency on inserted node.  If for
/*	any reason simple insertion cannot be performed, errDIRNoShortCircuit
/*	is returned so that the insertion may be performed via DIRInsert.
/*
/*	Also, no versions are created for index items since the table
/*	must be opened exclusively.  When the index is visible to other
/*	sessions, so too will all the items.
/**/
ERR ErrDIRInitAppendItem( FUCB *pfucb )
	{
	ERR	err = JET_errSuccess;

	/*	allocate working buffer if needed
	/**/
	if ( pfucb->pbfWorkBuf == NULL )
		{
		err = ErrBFAllocTempBuffer( &pfucb->pbfWorkBuf );
		if ( err < 0 )
			{
			DIRAPIReturn( pfucb, err );
			}
		pfucb->lineWorkBuf.pb = (BYTE *)pfucb->pbfWorkBuf->ppage;
		}

	PrepareAppendItem( pfucb );
	((APPENDITEM *)pfucb->lineWorkBuf.pb)->isrid = 0;
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRAppendItem( FUCB *pfucb, LINE *pline, KEY *pkey )
	{
	ERR		err;
	CSR		*pcsr;
	SSIB 	*pssib = &pfucb->ssib;
	INT		fNodeHeader;
	UINT 	cbReq;
	UINT 	cbFree;
	INT		citem;
	LONG 	l;
#ifdef BULK_INSERT_ITEM
	INT		isrid = IsridAppendItemOfPfucb( pfucb );
	SRID 	*rgsrid = RgsridAppendItemOfPfucb( pfucb );
#endif

	Assert( pline->cb == sizeof(SRID) );
	Call( ErrDIRRefresh( pfucb ) );
	pcsr = PcsrCurrent( pfucb );

	/*	get current node to check for key append
	/**/
	NDGet( pfucb, pcsr->itag );
	DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
	Assert( FNDNullSon( *pssib->line.pb ) );
	citem = pfucb->lineData.cb / sizeof(SRID);

	/*	get free space to density contraint violation
	/**/
	cbFree = CbBTFree( pfucb, CbFreeDensity( pfucb ) );

	/*	if key same as current node then insert SRID, else
	/*	begin new item list node with given key
	/**/
	if ( CmpStKey( StNDKey( pssib->line.pb ), pkey ) == 0 )
		{
#ifdef BULK_INSERT_ITEM
		/*	if one more item would not require item list split
		/*	or page split, then cache current item for bulk
		/*	insertion, else if any cached items, then perform
		/*	bulk insertion.
		/*
		/*	cbReq is space required for cached item node replacement plus
		/*	space for new inserted item list node with one item.
		/**/
		cbReq = isrid * sizeof(SRID) + cbFOPOneSon + pfucb->keyNode.cb + sizeof(SRID);
		Assert( csridAppendItemMax >= citemMax );
		if ( citem + isrid == citemMax || cbReq > cbFree )
			{
			if ( isrid > 0 )
				{
				Call( ErrNDInsertItems( pfucb, ( SRID *)rgsrid, isrid ) );
				IsridAppendItemOfPfucb( pfucb ) = 0;
				}
			}
		else
			{
			Assert( !FBTSplit( pssib, cbReq, 0 ) );
			Assert( citem + isrid < citemMax );
			rgsrid[isrid] = *(UNALIGNED SRID *)pline->pb;
			IsridAppendItemOfPfucb( pfucb )++;
			DIRAPIReturn( pfucb, JET_errSuccess );
			}
#endif

		/*	if this is last item insert before split item list
		/*	cannot be satified from page space, then split item
		/*	list prematurely to ensure good item packing.
		/**/
		cbReq = cbFOPOneSon + pfucb->keyNode.cb;
		if ( cbReq <= cbFree &&  cbReq + sizeof(SRID) > cbFree )
			{
#define	citemFrag		16
			/*	if number of items in current node exceeds
			/*	fragment then split node.
			/**/
			if ( citem > citemFrag )
				{
				/*	cache current item list for item list split.
				/**/
				NDGet( pfucb, PcsrCurrent( pfucb )->itag );
				DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
				Call( ErrNDSplitItemListNode( pfucb, fDIRNoVersion | fDIRAppendItem ) );
				DIRAPIReturn( pfucb, errDIRNoShortCircuit );
				}
			}

		/*	honor density by checking free space to density violation
		/*	and check for split case.
		/**/
		cbReq = sizeof(SRID);
		if ( cbReq > cbFree )
			{
			DIRAPIReturn( pfucb, errDIRNoShortCircuit );
			}
		Assert( !FBTSplit( pssib, cbReq, 0 ) );

		/*	get lineData
		/**/
		NDGet( pfucb, pcsr->itag );
		DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );

		citem = pfucb->lineData.cb / sizeof(SRID);
		Assert( citem <= citemMax );
		if ( citem == citemMax )
			{
			DIRAPIReturn( pfucb, errDIRNoShortCircuit );
			}
		l = LSridCmp(	*(((UNALIGNED SRID *)pfucb->lineData.pb) + citem - 1),
			*(UNALIGNED SRID *)pline->pb );
		/*	SRIDs are sorted and will be returned from SORT
		/*	in ascending order.
		/**/
		Assert( l < 0 );
		pcsr->isrid = citem;
		PcsrCurrent( pfucb )->bm = SridOfPgnoItag( PcsrCurrent( pfucb )->pgno, PcsrCurrent( pfucb )->itag );
		CallS( ErrNDInsertItem( pfucb, *(UNALIGNED SRID *)pline->pb, fDIRNoVersion ) );
		}
	else
		{
#ifdef BULK_INSERT_ITEM
		/*	append duplicate items to last node
		/**/
		if ( isrid > 0 )
			{
			Call( ErrNDInsertItems( pfucb,
				( SRID *)rgsrid,
				isrid ) );
			IsridAppendItemOfPfucb( pfucb ) = 0;
			}
#endif

		Assert( CmpStKey( StNDKey( pssib->line.pb ), pkey ) < 0 );

		/*	check density contraint against free space and check split.
		/**/
		cbReq = cbFOPOneSon + CbKey( pkey ) + CbLine( pline );
		if ( cbReq > cbFree || FBTSplit( pssib, cbReq, 1 ) )
			{
			DIRAPIReturn( pfucb, errDIRNoShortCircuit );
			}

		fNodeHeader = 0;
		NDSetFirstItem( fNodeHeader );
		NDSetLastItem( fNodeHeader );
		pcsr->ibSon++;
		while( ( err = ErrNDInsertNode( pfucb, pkey, pline, fNodeHeader ) ) == errDIRNotSynchronous );
		Call( err );
		}

	/*	set CSR status to on inserted node.
	/**/
	pcsr->csrstat = csrstatOnCurNode;
	DIRSetFresh( pfucb );

HandleError:
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRTermAppendItem( FUCB *pfucb )
	{
	ERR		err = JET_errSuccess;
	INT		isrid = IsridAppendItemOfPfucb( pfucb );
	CSR		*pcsr;
	SSIB	*pssib;
	UINT	cbReq;
	UINT	cbFree;
	INT		citem;

	if ( isrid > 0 )
		{
		pssib = &pfucb->ssib;

		Call( ErrDIRRefresh( pfucb ) );
		pcsr = PcsrCurrent( pfucb );

		/*	get current node to check for key append.
		/**/
		NDGet( pfucb, pcsr->itag );
		DIRIGetItemList( pfucb, pcsr );
		Assert( FNDNullSon( *pssib->line.pb ) );

		/*	get free space to density contraint violation
		/**/
		cbFree = CbBTFree( pfucb, CbFreeDensity( pfucb ) );

		/*	if key same as current node then insert SRID, else
		/*	begin new item list node with given key
		/**/
		citem = pfucb->lineData.cb / sizeof(SRID);
		cbReq = isrid * sizeof(SRID) + cbFOPOneSon + pfucb->keyNode.cb;
		Assert( isrid != csridAppendItemMax &&
			citem + isrid < citemMax &&
			cbReq <= cbFree );
		Call( ErrNDInsertItems( pfucb,
			( SRID *)RgsridAppendItemOfPfucb( pfucb ),
			isrid ) );

		/*	set CSR status to on inserted node.
		/**/
		pcsr->csrstat = csrstatOnCurNode;

		DIRSetFresh( pfucb );
		}

HandleError:
	if ( pfucb->pbfWorkBuf != pbfNil )
		{
		BFSFree( pfucb->pbfWorkBuf );
		pfucb->pbfWorkBuf = pbfNil;
		}

	FUCBResetUpdateSeparateLV( pfucb );
	FUCBResetCbstat( pfucb );
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRReplaceKey( FUCB *pfucb, KEY *pkeyTo, INT fFlags )
	{
	ERR		err;
	BOOL   	fFDP;
	PGNO   	pgnoFDP;
	CSR		*pcsr;
	BYTE   	rgbData[ cbNodeMost ];
	LINE   	line;
	INT		bHeader;
	CSR		*pcsrRoot;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );

	/*	check currency and refresh if necessary
	/**/
	Call( ErrDIRRefresh( pfucb ) );
	pcsr = PcsrCurrent( pfucb );

	if ( pcsr->csrstat != csrstatOnCurNode && pcsr->csrstat != csrstatOnFDPNode )
		{
		DIRAPIReturn( pfucb, JET_errNoCurrentRecord );
		}
	fFDP = ( pcsr->csrstat == csrstatOnFDPNode );

	/*	if FDP, then replace key and go up to replace FDP page pointer key
	/**/
	if ( fFDP )
		{
		pgnoFDP = PcsrCurrent( pfucb )->pgno;
		Assert( pcsr->pcsrPath != pcsrNil );
		BTUp( pfucb );
		pcsr = PcsrCurrent( pfucb );
		}

	do
		{
		/*	get current node
		/**/
		Assert( pcsr->csrstat == csrstatOnCurNode );
		Call( ErrDIRRefresh( pfucb ) );
		Assert( pfucb->ssib.line.cb < cbNodeMost );

		/*	copy node header
		/**/
		bHeader = *pfucb->ssib.line.pb;
		NDResetVersion( bHeader );
		/*	can be deleted, but we can only land on this if we are
		/*	out of date, and we will fail on update since we are
		/*	out of date.
		/**/
		NDResetBackLink( bHeader );
		Assert( !FNDSon( bHeader ) );
		Assert( !FNDFirstItem( bHeader ) );
		Assert( !FNDLastItem( bHeader ) );

		/*	copy node data
		/**/
		line.cb = CbNDData( pfucb->ssib.line.pb, pfucb->ssib.line.cb );
		line.pb = rgbData;
		memcpy( line.pb, PbNDData( pfucb->ssib.line.pb ), line.cb );

		/*	delete currnet node and reinsert with new key
		/**/
		err = ErrBTDelete( pfucb, fFlags );
		}
	while ( err == errDIRNotSynchronous );
	Call( err );

	BTUp( pfucb );
	pcsrRoot = PcsrCurrent( pfucb );

	do
		{
		/*	after moving up must refresh the parent node
		/**/
		Call( ErrDIRRefresh( pfucb ) );

		/*	insert node even if not synchronous.
		/**/
		Call( ErrBTSeekForUpdate( pfucb, pkeyTo, 0, 0, fFlags ) );

		err = ErrBTInsert( pfucb, bHeader, pkeyTo, &line, fFlags );

		/* backup to where it was to start seeking again
		/**/
		if ( err < 0 )
			{
			DIRIUpToCSR( pfucb, pcsrRoot );
			}
		}
	while ( err == errDIRNotSynchronous );
	Call( err );

	/*	set line cache to honor currency semantics.
	/**/
	Assert( FAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
	NDGet( pfucb, PcsrCurrent( pfucb )->itag );

	/*	if FDP, go back down to FDP node
	/**/
	if ( fFDP )
		{
		Call( ErrDIRIDownToFDP( pfucb, pgnoFDP ) );
		AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );
		DIRISetBookmark( pfucb, PcsrCurrent( pfucb ) );
		}

	DIRSetFresh( pfucb );

HandleError:
	/*	 if write latched empty page the release latch
	/**/
	if ( pfucb->pbfEmpty != pbfNil )
		{
		BFResetWriteLatch( pfucb->pbfEmpty, pfucb->ppib );
		BFUnpin( pfucb->pbfEmpty );
		pfucb->pbfEmpty = pbfNil;
		}

	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRGotoPosition( FUCB *pfucb, ULONG ulLT, ULONG ulTotal )
	{
	ERR		err;
	CSR		**ppcsr = &PcsrCurrent( pfucb );
	DIB		dib;
	FRAC	frac;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );

	/*	check currency and refresh if necessary
	/**/
	Call( ErrDIRRefresh( pfucb ) );

	dib.fFlags = fDIRPurgeParent;
	dib.pos = posFrac;
	dib.pkey = (KEY *)&frac;

	frac.ulLT = ulLT;
	frac.ulTotal = ulTotal;

	/*	position fractionally on node.  Move up preserving currency
	/*	in case down fails.
	/**/
	Call( ErrBTDown( pfucb, &dib ) );
	NDGetNode( pfucb );

	/*	node cannot be FDP pointer, and must be record or index.
	/**/
	Assert( err == JET_errSuccess );
	Assert( !( FNDFDPPtr( *pfucb->ssib.line.pb ) ) );
	(*ppcsr)->csrstat = csrstatOnCurNode;

	/*	if non-clustered index, position fractionally on item.
	/*	FRAC will contain remaining fractional position, for
	/*	item list level.
	/**/
	if ( FFUCBNonClustered( pfucb ) )
		{
		INT           citem;
		INT           iitem;

		/*	determine fractional position in item list
		/**/
		citem = CitemNDData( pfucb->ssib.line.pb,
			pfucb->ssib.line.cb,
			PbNDData( pfucb->ssib.line.pb ) );
		if ( frac.ulTotal / citemMax == 0 )
			{
			iitem = ( citem * frac.ulLT ) / frac.ulTotal;
			}
		else
			{
			iitem = ( citem * ( frac.ulLT / ( frac.ulTotal / citemMax ) ) ) / citemMax;
			}
		if ( iitem >= citem )
			iitem = citem - 1;

		/*	if cursor is on first item list node, then cache bookmark
		/*	for version operations.
		/*
		/*	else then move previous
		/*	in same item list until first item list node found.  Cache
		/*	bookmark of first item list node for version operations.
		/**/
		if ( FNDFirstItem( *pfucb->ssib.line.pb ) )
			{
			DIRISetItemListFromFirst( pfucb );
			}
		else
			{
			INT     iitemPrev;
			DIB     dibT;

			dibT.fFlags = fDIRNull;

			for ( iitemPrev = 0;; iitemPrev++)
				{
				Call( ErrDIRPrev( pfucb, &dibT ) );
				if ( FNDFirstItem( *pfucb->ssib.line.pb ) )
					break;
				}

			DIRISetItemListFromFirst( pfucb );

			for ( ; iitemPrev > 0; iitemPrev-- )
				{
				Call( ErrDIRNext( pfucb, &dibT ) );
				}
			}

		/*	position on first item.  If item is not there for this session
		/*	then increment iitem to move to correct position.
		/**/
		err = ErrNDFirstItem( pfucb );
		Assert( err == JET_errSuccess || err == errNDNoItem );
		if ( err == errNDNoItem )
			{
			iitem++;
			}

		while ( iitem-- > 0 )
			{
			DIB     dibT;

			dibT.fFlags = fDIRNull;

			Assert( iitem >= 0 );

			/*	move to next item in item list.  Note that if some items
			/*	are not there for us, we will move to the next item
			/*	list node.
			/**/
			err = ErrDIRNext( pfucb, &dibT );
			if ( err < 0 )
				{
				if ( err == JET_errNoCurrentRecord )
					break;
				goto HandleError;
				}
			}

		/*	handle JET_errNoCurrentRecord.  We may have landed on a record
		/*	not there for us, or we may have moved past the last record
		/*	for us.  Try to move to next record, if there is no next record
		/*	then move previous to last record there for us.  If no previous
		/*	record then return JET_errNoCurrentRecord.
		/**/
		Assert( err != errNDNoItem );
		if ( err == JET_errNoCurrentRecord )
			{
			DIB     dibT;
			dibT.fFlags = fDIRNull;

			err = ErrDIRNext( pfucb, &dibT );
			if ( err < 0 )
				{
				if ( err == JET_errNoCurrentRecord )
					Call( ErrDIRPrev( pfucb, &dibT ) );
				goto HandleError;
				}
			}
		}

	/*	always purge parent.
	/**/
	DIRIPurgeParent( pfucb );
HandleError:
	DIRAPIReturn( pfucb, err );
	}


/*********** currency neutral DIR API Routines ************
/**********************************************************
/**/
ERR ErrDIRGetWriteLock( FUCB *pfucb )
	{
	ERR     err = JET_errSuccess;

	do
		{

		Assert( pfucb->ppib->level > 0 );

		/*	check currency and refresh if necessary.
		/**/
		Call( ErrDIRRefresh( pfucb ) );

		/*	check CSR status
		/**/
		switch ( PcsrCurrent( pfucb )->csrstat )
			{
			case csrstatOnCurNode:
			case csrstatOnFDPNode:
				break;
			default:
				Assert( PcsrCurrent( pfucb )->csrstat == csrstatBeforeCurNode ||
					PcsrCurrent( pfucb )->csrstat == csrstatAfterCurNode ||
					PcsrCurrent( pfucb )->csrstat == csrstatAfterLast ||
					PcsrCurrent( pfucb )->csrstat == csrstatBeforeFirst );
				DIRAPIReturn( pfucb, JET_errNoCurrentRecord );
			}

		AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );
		NDGetNode( pfucb );

		err = ErrNDLockRecord( pfucb );
		}
	while ( err == errDIRNotSynchronous );
	Call( err );
	Assert( err == JET_errSuccess );

	DIRSetFresh( pfucb );
HandleError:
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRDelete( FUCB *pfucb, INT fFlags )
	{
	ERR		err;
	CSR		*pcsr;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );
	Assert( FFUCBNonClustered( pfucb ) || !( fFlags & fDIRDeleteItem ) );

	/*	check currency and refresh if necessary.
	/**/
	Call( ErrDIRRefresh( pfucb ) );
	pcsr = PcsrCurrent( pfucb );

	switch ( pcsr->csrstat )
		{
		case csrstatOnCurNode:
			{
			Call( ErrBTGetNode( pfucb, pcsr ) );

			if ( FFUCBNonClustered( pfucb ) )
				{
				Assert( !FNDSon( *pfucb->ssib.line.pb ) );
				if ( ! ( fFlags & fDIRDeleteItem ) )
					{
					Assert( fFlags & fDIRVersion );
					err = ErrNDFlagDeleteItem( pfucb );
					while ( err == errDIRNotSynchronous )
						{
						Call( ErrDIRRefresh( pfucb ) );
						err = ErrNDFlagDeleteItem( pfucb );
						}
					Call( err );
					}
				else
					{
					/* actually delete the item
					/* used by VER in cleanup
					/**/
					Assert( !( fFlags & fDIRVersion ) );

					/*	if only one item then delete node
					/**/
					if ( pfucb->lineData.cb == sizeof(SRID) )
						{
						BOOL    fFirstItem;
						BOOL    fLastItem;

						Assert( FNDSingleItem( pfucb ) );

						if ( FNDFirstItem( *pfucb->ssib.line.pb ) )
							fFirstItem = fTrue;
						else
							fFirstItem = fFalse;

						if ( FNDLastItem( *pfucb->ssib.line.pb ) )
							fLastItem = fTrue;
						else
							fLastItem = fFalse;

						if ( fFirstItem ^ fLastItem )
							{
							/*	adjust fist/last item info appropriately
							/**/
							Call( ErrDIRIDeleteEndItemNode( pfucb, fFirstItem, fFlags ) )
							}
						else
							{
							err = ErrBTDelete( pfucb, fFlags );
							while ( err == errDIRNotSynchronous )
								{
								Call( ErrDIRRefresh( pfucb ) );
								err = ErrBTDelete( pfucb, fFlags );
								}
							Call( err );
							}
						}
					else
						{
						/*	delete item
						/**/
						if ( !FWriteAccessPage( pfucb, pcsr->pgno ) )
							{
							Call( ErrSTWriteAccessPage( pfucb, pcsr->pgno ) );
							}
						AssertNDGet( pfucb, pcsr->itag );
						Call( ErrNDDeleteItem( pfucb ) );
						}
					}
				}
			else
				{
				/*	delete current node sons and then current node.  Even
				/*	though the node has sons, the tree may be empty of
				/*	visible sons.
				/**/
				if ( FNDSon( *pfucb->ssib.line.pb ) )
					{
					DIB	dib;

					dib.pos = posFirst;
					dib.fFlags = fDIRNull;
					err = ErrDIRDown( pfucb, &dib );
					if ( err < 0 && err != JET_errRecordNotFound )
						goto HandleError;
					if ( err != JET_errRecordNotFound )
						{
						do
							{
							err = ErrDIRDelete( pfucb, fFlags );
							if ( err < 0 )
								{
								DIRAPIReturn( pfucb, err );
								}
							err = ErrDIRNext( pfucb, &dib );
							}
						while( err == 0 || err == errDIRFDP );
						DIRUp( pfucb, 1 );
						if ( err != JET_errNoCurrentRecord )
							goto HandleError;
						/*	refresh currency after up
						/**/
						Call( ErrDIRRefresh( pfucb ) );
						}
					}
				err = ErrBTDelete( pfucb, fFlags );
				while ( err == errDIRNotSynchronous )
					{
					Call( ErrDIRRefresh( pfucb ) );
					err = ErrBTDelete( pfucb, fFlags );
					}
				Call( err );
				}
			break;
			}
		case csrstatOnFDPNode:
			{
			PGNO    pgnoFDP;

			/*	delete FDP and FDP pointer node
			/**/
			if ( PcsrCurrent( pfucb )->pcsrPath == pcsrNil )
				{
				err = errDIRTop;
				goto HandleError;
				}
			BTUp( pfucb );
			pfucb->sridFather = sridNull;

			/*	refresh currency after up
			/**/
			Call( ErrDIRRefresh( pfucb ) );
			pcsr = PcsrCurrent( pfucb );
			Call( ErrBTGetNode( pfucb, pcsr ) );
			Assert( FNDFDPPtr( *pfucb->ssib.line.pb ) );
			Assert( pfucb->lineData.cb == sizeof(PGNO) );
			pgnoFDP = *(UNALIGNED PGNO *)pfucb->lineData.pb;
			err = ErrBTDelete( pfucb, fFlags );
			while ( err == errDIRNotSynchronous )
				{
				Call( ErrDIRRefresh( pfucb ) );
				err = ErrBTDelete( pfucb, fFlags );
				}
			Call( err );

			/*	release FDP space
			/**/
			Call( ErrSPFreeFDP( pfucb, pgnoFDP ) );
			break;
			}
		default:
			err = JET_errNoCurrentRecord;
		}

	DIRSetRefresh( pfucb );

HandleError:
	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRReplace( FUCB *pfucb, LINE *pline, INT fFlags )
	{
	ERR	err;

	do
		{
		CheckFUCB( pfucb->ppib, pfucb );
		Assert( pfucb->pbfEmpty == pbfNil );
		CheckCSR( pfucb );

		/*	check currency and refresh if necessary.
		/**/
		Call( ErrDIRRefresh( pfucb ) );

		if ( PcsrCurrent( pfucb )->csrstat != csrstatOnCurNode &&
			PcsrCurrent( pfucb )->csrstat != csrstatOnFDPNode )
			{
			DIRAPIReturn( pfucb, JET_errNoCurrentRecord );
			}

		NDGetNode( pfucb );
		err = ErrBTReplace( pfucb, pline, fFlags );
		if ( err == JET_errSuccess )
			{
			DIRSetFresh( pfucb );
			DIRAPIReturn( pfucb, err );
			}

		Assert( pfucb->pbfEmpty == pbfNil );
		}
	while ( err == errDIRNotSynchronous );

	DIRSetRefresh( pfucb );
HandleError:
	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRDelta( FUCB *pfucb, INT iDelta, INT fFlags )
	{
	ERR		err;
	CSR		*pcsr;

	do
		{
		CheckFUCB( pfucb->ppib, pfucb );
		Assert( pfucb->pbfEmpty == pbfNil );
		CheckCSR( pfucb );

		/*	check currency and refresh if necessary.
		/**/
		Call( ErrDIRRefresh( pfucb ) );
		pcsr = PcsrCurrent( pfucb );

		Call( ErrBTGetNode( pfucb, pcsr ) );

		err = ErrNDDelta( pfucb, iDelta, fFlags );
		}
	while ( err == errDIRNotSynchronous );

HandleError:
	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRGetPosition( FUCB *pfucb, ULONG *pulLT, ULONG *pulTotal )
	{
	ERR		err;
	CSR		*pcsr = NULL;
	INT		isrid;
	INT		citem = 1;
	ULONG	ulLT;
	ULONG	ulTotal;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );

	LgLeaveCriticalSection( critJet );
	EnterNestableCriticalSection( critSplit );
	LgEnterCriticalSection( critJet );

	/*	check currency and refresh if necessary.
	/**/
	Call( ErrDIRRefresh( pfucb ) );
	pcsr = PcsrCurrent( pfucb );

	/*	return error if not on a record
	/**/
	if ( pcsr->csrstat != csrstatOnCurNode )
		{
		DIRAPIReturn( pfucb, JET_errNoCurrentRecord );
		}

	/*	if on non-clustered index, then treat item list as
	/*	additional tree level.
	/**/
	if ( FFUCBNonClustered( pfucb ) )
		{
		DIRIGetItemList( pfucb, pcsr );

		/*	refresh srid
		/**/
		isrid = pcsr->isrid;
		citem = CitemNDData( pfucb->ssib.line.pb,
			pfucb->ssib.line.cb,
			PbNDData( pfucb->ssib.line.pb ) );
		Assert( citem > 0 && citem < citemMax );
		}

	/*	get approximate position of node.
	/**/
	Call( ErrBTGetPosition( pfucb, &ulLT, &ulTotal ) );

	/*	assert that ErrBTGetPosition does not change the
	/*	current CSR.
	/**/
	Assert( pcsr == PcsrCurrent( pfucb ) );

	/*	if citem > 1 from non-clustered index with duplicates, then
	/*	adjust fractional positon by treating non-clustered index
	/*	as additional tree level.
	/**/
	if ( citem > 1 )
		{
		ulTotal *= citem;
		ulLT = ulLT * citem + pcsr->isrid;
		}

	/*	return results
	/**/
	Assert( err == JET_errSuccess );
	Assert( ulLT <= ulTotal );
	*pulLT = ulLT;
	*pulTotal = ulTotal;

HandleError:
	/*	honor currency semantics
	/**/
	if (pcsr != NULL && FReadAccessPage( pfucb, pcsr->pgno ) )
		{
		NDGet( pfucb, PcsrCurrent( pfucb )->itag );
		}

	LeaveNestableCriticalSection( critSplit );

	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRIndexRecordCount( FUCB *pfucb, ULONG *pulCount, ULONG ulCountMost, BOOL fNext )
	{
	ERR		err;
	CSR		*pcsr;
	DIB		dib;
	INT		citem;
	ULONG 	ulCount;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );

	/*	check currency and refresh if necessary.
	/**/
	Call( ErrDIRRefresh( pfucb ) );
	pcsr = PcsrCurrent( pfucb );

	/*	return error if not on a record
	/**/
	if ( pcsr->csrstat != csrstatOnCurNode )
		{
		DIRAPIReturn( pfucb, JET_errNoCurrentRecord );
		}
	Call( ErrBTGetNode( pfucb, pcsr ) );

	if ( FFUCBNonClustered( pfucb ) )
		{
		/*	item list nodes not versioned.
		/**/
		dib.fFlags = fDIRItemList;

		/*	initialize count with current position in item list
		/**/
		if ( fNext )
			{
			citem = CitemNDThere( pfucb );
			ulCount = citem - pcsr->isrid;
			}
		else
			{
			ulCount = pcsr->isrid + 1;
			}

		/*	count all items util end of file or limit
		/**/
		forever
			{
			if ( ulCount > ulCountMost )
				{
				ulCount = ulCountMost;
				break;
				}

			err = ErrBTNextPrev( pfucb, pcsr, fNext, &dib );
			if ( err < 0 )
				break;

			/*	if on new item list then set bookmark from
			/*	first item list node, of if on new last item
			/*	list node then move to first, set bookmark,
			/*	and then move back to last.
			/**/
			if ( fNext )
				{
				DIRICheckFirstSetItemList( pfucb );
				}
			else
				{
				DIRICheckLastSetItemList( pfucb );
				}

			DIRIGetItemList( pfucb, pcsr );

			/*	check index range if on new first item list node, i.e.
			/*	key has changed.
			/**/
			if ( FFUCBLimstat( pfucb ) && FNDFirstItem( *pfucb->ssib.line.pb ) )
				{
				err = ErrDIRICheckIndexRange( pfucb );
				if ( err < 0 )
					break;
				}

			citem = CitemNDThere( pfucb );
			Assert( citem < citemMax );
			ulCount += citem;
			}
		}
	else
		{
		/*	clusterred index nodes can be versioned.
		/**/
		dib.fFlags = fDIRNull;

		/*	intialize count variable
		/**/
		ulCount = 0;

		/*	count nodes from current to limit or end of table
		/**/
		forever
			{
			ulCount++;
			if ( ulCount >= ulCountMost )
				{
				ulCount = ulCountMost;
				break;
				}
			err = ErrBTNextPrev( pfucb, pcsr, fNext, &dib );
			if ( err < JET_errSuccess )
				break;

			/*	check index range
			/**/
			if ( FFUCBLimstat( pfucb ) )
				{
				NDGetKey( pfucb );
				err = ErrDIRICheckIndexRange( pfucb );
				if ( err < 0 )
					break;
				}
			}
		}

	/*	common exit loop processing
	/**/
	if ( err < 0 && err != JET_errNoCurrentRecord )
		goto HandleError;

	err = JET_errSuccess;
	*pulCount = ulCount;
HandleError:
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRComputeStats( FUCB *pfucb, INT *pcitem, INT *pckey, INT *pcpage )
	{
	ERR		err;
	DIB		dib;
	BYTE	rgbKey[ JET_cbKeyMost ];
	KEY		key;
	PGNO	pgnoT;
	INT		citem = 0;
	INT		ckey = 0;
	INT		cpage = 0;
	INT		citemT;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );
	Assert( !FFUCBLimstat( pfucb ) );

	/*	go to first node
	/**/
	DIRGotoDataRoot( pfucb );
	dib.fFlags = fDIRNull;
	dib.pos = posFirst;
	err = ErrDIRDown( pfucb, &dib );
	if ( err < 0 )
		{
		/*	if index empty then set err to success
		/**/
		if ( err == JET_errRecordNotFound )
			{
			err = JET_errSuccess;
			goto Done;
			}
		goto HandleError;
		}

	/*	if there is at least one node, then there is a first page.
	/**/
	cpage = 1;

	if ( FFUCBNonClustered( pfucb ) )
		{
		/*	item list nodes not versioned.
		/**/
		dib.fFlags = fDIRItemList;

		/*	count all items util end of file or limit
		/**/
		forever
			{
			DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );

			citemT = CitemNDThere( pfucb );
			Assert( citemT < citemMax );
			citem += citemT;

			if ( FNDFirstItem( *pfucb->ssib.line.pb ) && citemT > 0 )
				ckey++;

			pgnoT = PcsrCurrent( pfucb )->pgno;
			err = ErrBTNextPrev( pfucb, PcsrCurrent( pfucb ), fTrue, &dib );
			if ( err < 0 )
				break;

			/*	if on new item list then set bookmark from
			/*	first item list node.
			/**/
			DIRICheckFirstSetItemList( pfucb );

			if ( PcsrCurrent( pfucb )->pgno != pgnoT )
				cpage++;
			}
		}
	else
		{
		/*	if clustered index is unique then user much faster algorithm
		/**/
		if ( pfucb->u.pfcb->pidb != NULL &&
			( pfucb->u.pfcb->pidb->fidb & fidbUnique ) )
			{
			forever
				{
				citem++;

				/*	move to next node.  If cross page boundary then
				/*	increment page count.
				/**/
				pgnoT = PcsrCurrent( pfucb )->pgno;
				err = ErrBTNextPrev( pfucb, PcsrCurrent( pfucb ), fTrue, &dib );
				if ( PcsrCurrent( pfucb )->pgno != pgnoT )
					cpage++;
				if ( err < JET_errSuccess )
					{
					ckey = citem;
					goto Done;
					}
				}
			}
		else
			{
			/*	clusterred index nodes can be versioned.
			/**/
			Assert( dib.fFlags == fDIRNull );
			key.pb = rgbKey;

			forever
				{
				ckey++;
				err = ErrDIRICopyKey( pfucb, &key );
				if ( err < 0 )
					{
					DIRAPIReturn( pfucb, err );
					}

				forever
					{
					citem++;

					/*	move to next node.  If cross page boundary then
					/*	increment page count.
					/**/
					pgnoT = PcsrCurrent( pfucb )->pgno;
					err = ErrBTNextPrev( pfucb, PcsrCurrent( pfucb ), fTrue, &dib );
					if ( PcsrCurrent( pfucb )->pgno != pgnoT )
						cpage++;
					if ( err < JET_errSuccess )
						goto Done;
					if ( CmpStKey( StNDKey( pfucb->ssib.line.pb ), &key ) != 0 )
						break;
					}
				}
			}
		}

Done:
	/*	common exit loop processing
	/**/
	if ( err < 0 && err != JET_errNoCurrentRecord )
		goto HandleError;

	err = JET_errSuccess;
	*pcitem = citem;
	*pckey = ckey;
	*pcpage = cpage;

HandleError:
	DIRAPIReturn( pfucb, err );
	}


/************** DIR Transaction Routines ******************
/**********************************************************
/**/
ERR ErrDIRBeginTransaction( PIB *ppib )
	{
	ERR		err = JET_errSuccess;

	/*	log begin transaction.
	/**/
	err = ErrLGBeginTransaction( ppib, ppib->level );
	if ( err < 0 )
		{
		DIRAPIReturn( pfucbNil, err );
		}

	DIRAPIReturn( pfucbNil, ErrVERBeginTransaction( ppib ) );
	}


ERR ErrDIRCommitTransaction( PIB *ppib )
	{
	ERR		err;
	FUCB   	*pfucb;

	CheckPIB( ppib );
	Assert( ppib->level > 0 );

	VERPrecommitTransaction( ppib );

	/*	must write commit record and flush log prior to commiting any
	/*	version pages of transaction.  Synchronous flush performed
	/*	within log commit transaction.
	/**/
	err = ErrLGCommitTransaction( ppib, ppib->level - (BYTE)1 );
	Assert( err >= 0 || fLGNoMoreLogWrite );
	if ( err < 0 )
		{
		DIRAPIReturn( pfucbNil, err );
		}

	VERCommitTransaction( ppib );

	/*	set all open cursor transaction levels to new level
	/**/
	for ( pfucb = ppib->pfucb; pfucb != pfucbNil; pfucb = pfucb->pfucbNext )
		{
		if ( pfucb->levelOpen > ppib->level )
			pfucb->levelOpen = ppib->level;
		}

	/*	reset performed DDL operation flag on open cursors.  After commit to
	/*	level 0, DDL performed in transaction will not be rolled back.
	/*	Also, fully close cursors deferred closed.
	/**/
	if ( ppib->level == 0 )
		{
		DIRPurge( ppib );
		}

	DIRAPIReturn( pfucbNil, err );
	}


/*	closes deferred closed cursors not closed in commit to transaction
/*	level 0 via VERCommit.
/**/
VOID DIRPurge( PIB *ppib )
	{
	FUCB	*pfucb;
	FUCB	*pfucbNext;

	Assert( ppib->level == 0 );

	for ( pfucb = ppib->pfucb; pfucb != pfucbNil; pfucb = pfucbNext )
		{
		pfucbNext = pfucb->pfucbNext;

		while ( FFCBDenyDDLByUs( pfucb->u.pfcb, ppib ) )
			{
			FCBResetDenyDDL( pfucb->u.pfcb );
			}
		if ( FFUCBDeferClosed( pfucb ) )
			{
			if ( FFUCBDenyRead( pfucb ) )
				FCBResetDenyRead( pfucb->u.pfcb );
			if ( FFUCBDenyWrite( pfucb ) )
				FCBResetDenyWrite( pfucb->u.pfcb );
			FCBUnlink( pfucb );
			FUCBClose( pfucb );
			}
		}

	return;
	}


ERR ErrDIRRollback( PIB *ppib )
	{
	ERR   	err;
	FUCB	*pfucb;
	INT   	levelAbortTo = (INT)ppib->level - 1;

	CheckPIB( ppib );
	/*	must be in a transaction to rollback
	/**/
	Assert( ppib->level > 0 );

	/*	clean up cursor CSR stacks
	/*	leave each cursor with at most one CSR, and reset fFUCBAll flag
	/**/
	for ( pfucb = ppib->pfucb; pfucb != pfucbNil; pfucb = pfucb->pfucbNext )
		{
		if ( PcsrCurrent( pfucb ) != pcsrNil )
			{
			while ( PcsrCurrent( pfucb )->pcsrPath != pcsrNil )
				{
				BTUp( pfucb );
				}
#undef BUG_FIX
#ifdef BUG_FIX
			DIRBeforeFirst( pfucb );
#endif
			}
#ifdef BUG_FIX
		/*	reset update separate LV and copy buffer status on rollback.
		/*	All long value resources will be freed as a result of
		/*	rollback and currency is reset to copy buffer status must
		/*	be reset.
		/**/
		FUCBResetUpdateSeparateLV( pfucb );
		FUCBResetCbstat( pfucb );
#endif
		}

	//	UNDONE:	rollback may fail from resource failure so
	//			we must retry in order to assure success
	/*	rollback changes made in transaction
	/**/
	CallS( ErrVERRollback( ppib ) );

	/*	log rollback. Must be called after VERRollback to record
	/*  the UNDO operations.  Do not handle error
	/**/
	err = ErrLGAbort( ppib, 1 );
	Assert( err == JET_errSuccess ||
			JET_errLogWriteFail ||			/* may be caused by disk full */
			err == JET_errDiskFull );

	if ( fRecovering )
		{
		/* we are done. No need to close fucb since they are faked and
		/* not the same behavior as regular fucb which could be deferred.
		/**/
		DIRAPIReturn( pfucbNil, JET_errSuccess );
		}

	/*	if rollback to level 0 then close deferred closed cursors
	/**/
	for ( pfucb = ppib->pfucb; pfucb != pfucbNil; )
		{
		FUCB    *pfucbT = pfucb->pfucbNext;

		if ( pfucb->levelOpen > ppib->level || ( ppib->level == 0 && FFUCBDeferClosed( pfucb ) ) )
			{
			if ( FFUCBDenyRead( pfucb ) )
				FCBResetDenyRead( pfucb->u.pfcb );
			if ( FFUCBDenyWrite( pfucb ) )
				FCBResetDenyWrite( pfucb->u.pfcb );
			FCBUnlink( pfucb );
			FUCBClose( pfucb );
			}

		pfucb = pfucbT;
		}

#ifdef BUG_FIX
#ifdef DEBUG
	/*	check all cursors in reset state
	/**/
	for ( pfucb = ppib->pfucb; pfucb != pfucbNil; pfucb = pfucb->pfucbNext )
		{
		if ( PcsrCurrent( pfucb ) != pcsrNil )
			{
			Assert( PcsrCurrent( pfucb )->csrstat == csrstatBeforeFirst );
			Assert( PcsrCurrent( pfucb )->pcsrPath == pcsrNil );
			}
		}
#endif
#endif

	DIRAPIReturn( pfucbNil, JET_errSuccess );
	}


#ifdef DEBUG


#define	cbKeyPrintMax		10
#define	cbDataPrintMax		10


VOID SPDump( FUCB *pfucb, INT cchIndent )
	{
	PGNO	pgno;
	CPG		cpg = 0;
	INT		ich;

	/*	print indentation
	/**/
	for ( ich = 0; ich < cchIndent; ich++ )
		{
		PrintF2( " " );
		}

	/*	print headings
	/**/
	if ( pfucb == pfucbNil )
		{
		PrintF2( "pgno      itag  bm        pgno last cpg\n");
		return;
		}

	Assert( pfucb->keyNode.cb == 3 );
	LFromThreeBytes( pgno, *pfucb->keyNode.pb );

	Assert( pfucb->lineData.cb == 3 );
	LFromThreeBytes( pgno, *pfucb->lineData.pb );

	/*	print	node	pgno:itag
	/*					bookmark
	/*					pgno last
	/*					cpg
	/**/

	/*	print fixed lenght values
	/**/
	PrintF2( "%.8x  %.2x    %.8x  %.8x  %.8x",
		PcsrCurrent( pfucb )->pgno,
		PcsrCurrent( pfucb )->itag,
		PcsrCurrent( pfucb )->bm,
		pgno,
		cpg );

	/*	terminate line
	/**/
	PrintF2( "\n" );

	return;
	}


VOID LVDump( FUCB *pfucb, INT cchIndent )
	{
	ULONG		ulId = 0;
	LVROOT		lvroot;
	INT			ich;

	/*	print indentation
	/**/
	for ( ich = 0; ich < cchIndent; ich++ )
		{
		PrintF2( " " );
		}

	/*	print headings
	/**/
	if ( pfucb == pfucbNil )
		{
		PrintF2( "****************** LONG VALUES ***********************\n" );
		PrintF2( "pgno      itag  bm        long id   lenght    reference count\n");
		return;
		}

	Assert( pfucb->keyNode.cb == sizeof(ulId) );
	//	UNDONE:	set long id from key

	Assert( pfucb->lineData.cb == sizeof(lvroot) );
	memcpy( &lvroot, pfucb->lineData.pb, sizeof(lvroot) );

	/*	print	node	pgno:itag
	/*					bookmark
	/*					long id
	/*					length
	/*					reference count
	/**/

	/*	print fixed lenght values
	/**/
	PrintF2( "%.8x  %.2x      %.8x  %.8x  %.8  %.8  ",
		PcsrCurrent( pfucb )->pgno,
		PcsrCurrent( pfucb )->itag,
		PcsrCurrent( pfucb )->bm,
		ulId,
		lvroot.ulSize,
		lvroot.ulReference );

	/*	terminate line
	/**/
	PrintF2( "\n" );

	return;
	}

BYTE mpbb[] = {	'0', '1', '2', '3', '4', '5', '6', '7',
				'8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };

//BOOL fPrintFullKeys = fTrue;
BOOL fPrintFullKeys = fFalse;
BYTE rgbKeyLastGlobal[ JET_cbKeyMost + 1 ];
BYTE *pbKeyLastGlobal = rgbKeyLastGlobal;
INT cbKeyLastGlobal = 0;

VOID NDDump( FUCB *pfucb, INT cchIndent )
	{
	INT		cbT;
	INT		ibT;
	BYTE	szKey[JET_cbKeyMost * 3];
	BYTE	rgbData[cbDataPrintMax + 1];
	INT		ich;

	/*	print indentation
	/**/
	for ( ich = 0; ich < cchIndent; ich++ )
		{
		PrintF2( " " );
		}

	/*	print headings
	/**/
	if ( pfucb == pfucbNil )
		{
		PrintF2( "pgno      itag  bm        header    key         data\n");
		return;
		}

	szKey[cbKeyPrintMax] = '\0';
	memset( szKey, ' ', cbKeyPrintMax );
	cbT = pfucb->keyNode.cb;
	if ( cbT > cbKeyPrintMax )
		cbT = cbKeyPrintMax;
	memcpy( szKey, pfucb->keyNode.pb, cbT );

	for ( ibT = 0; ibT < cbKeyPrintMax && ibT < (INT)pfucb->keyNode.cb; ibT++ )
		{
		if ( !( ( szKey[ibT] >= 'a' && szKey[ibT] <= 'z' ) ||
			( szKey[ibT] >= 'A' && szKey[ibT] <= 'Z' ) ) )
			{
			szKey[ibT] = '.';
			}
		}

	if ( fPrintFullKeys )
		{
		INT cbKey = (INT) pfucb->keyNode.cb;
		BYTE *pbKey = pfucb->keyNode.pb;
		BYTE *pbKeyMax = pbKey + pfucb->keyNode.cb;
		BYTE *pbPrint = szKey;

		if ( cbKeyLastGlobal == cbKey &&
			 memcmp( pbKeyLastGlobal, pbKey, cbKeyLastGlobal ) == 0 )
			*pbPrint++ = '*';
		else
			{
			*pbPrint++ = ' ';
			cbKeyLastGlobal = cbKey;
			memcpy( pbKeyLastGlobal, pbKey, cbKeyLastGlobal );
			}

		while ( pbKey < pbKeyMax )
			{
			BYTE b = *pbKey++;
			*pbPrint++ = mpbb[b >> 4];
			*pbPrint++ = mpbb[b & 0x0f];
			*pbPrint++ = ' ';
			}
		*pbPrint='\0';
		}

	rgbData[cbKeyPrintMax] = '\0';
	memset( rgbData, ' ', cbDataPrintMax );
	cbT = pfucb->lineData.cb;
	if ( cbT > cbDataPrintMax )
		cbT = cbDataPrintMax;
	memcpy( rgbData, pfucb->lineData.pb, cbT );
	for ( ibT = 0; ibT < cbDataPrintMax && ibT < (INT)pfucb->lineData.cb; ibT++ )
		{
		if ( !( ( rgbData[ibT] >= 'a' && rgbData[ibT] <= 'z' ) ||
			( rgbData[ibT] >= 'A' && rgbData[ibT] <= 'Z' ) ) )
			{
			rgbData[ibT] = '.';
			}
		}

	/*	print	node	pgno:itag
	/*					bookmark
	/*					header
	/*					key to 10 bytes
	/*					data to 10 bytes
	/**/

	/*	print fixed lenght values
	/**/
	PrintF2( "%.8x  %.2x    %.8x  %.2x        ",
		PcsrCurrent( pfucb )->pgno,
		PcsrCurrent( pfucb )->itag,
		PcsrCurrent( pfucb )->bm,
		*pfucb->ssib.line.pb );

	/*	print variable lenght values
	/**/
	PrintF2( "%s  %s", szKey, rgbData );

	/*	terminate line
	/**/
	PrintF2( "\n" );

	return;
	}


/*	prints tree nodes, indented by depth, in depth first fashion
/**/
ERR ErrDIRDump( FUCB *pfucb, INT cchIndent )
	{
	ERR	err = JET_errSuccess;
	DIB	dib;
	BYTE *pbKeyLastCurLevel;
	INT cbKeyLastCurLevel;

#define	cchPerDepth		5

	Call( ErrDIRGet( pfucb ) );
	/*	if parent is space node, then dump space
	/*	if parent is LONG, then dump long value root
	/*	otherwise dump node
	/**/
	if ( PgnoOfSrid( pfucb->sridFather ) == pfucb->u.pfcb->pgnoFDP &&
		( ItagOfSrid( pfucb->sridFather ) == itagOWNEXT ||
		ItagOfSrid( pfucb->sridFather ) == itagAVAILEXT ) )
		{
		if ( cchIndent == 0 )
			SPDump( pfucbNil, cchIndent );
		SPDump( pfucb, cchIndent );
		}
	else if ( PgnoOfSrid( pfucb->sridFather ) == pfucb->u.pfcb->pgnoFDP &&
		ItagOfSrid( pfucb->sridFather ) == itagLONG )
		{
		if ( cchIndent == 0 )
			LVDump( pfucbNil, cchIndent );
		LVDump( pfucb, cchIndent );
		}
	else
		{
		if ( cchIndent == 0 )
			NDDump( pfucbNil, cchIndent );
		NDDump( pfucb, cchIndent );
		}

	pbKeyLastCurLevel = pbKeyLastGlobal;
	cbKeyLastCurLevel = cbKeyLastGlobal;

	dib.fFlags = 0;
	dib.pos = posFirst;
	err = ErrDIRDown( pfucb, &dib );
	if ( err != JET_errRecordNotFound )
		{
		if (!(pbKeyLastGlobal = SAlloc( sizeof( rgbKeyLastGlobal ) )))
			Error( JET_errOutOfMemory, HandleError );
		cbKeyLastGlobal = 0;

		if ( PgnoOfSrid( pfucb->sridFather ) == pfucb->u.pfcb->pgnoFDP &&
			( ItagOfSrid( pfucb->sridFather ) == itagOWNEXT ||
			ItagOfSrid( pfucb->sridFather ) == itagAVAILEXT ) )
			{
			SPDump( pfucbNil, cchIndent + cchPerDepth );
			}
		else if ( PgnoOfSrid( pfucb->sridFather ) == pfucb->u.pfcb->pgnoFDP &&
			ItagOfSrid( pfucb->sridFather ) == itagLONG )
			{
			LVDump( pfucbNil, cchIndent + cchPerDepth );
			}
		else
			{
			NDDump( pfucbNil, cchIndent + cchPerDepth );
			}

		SFree( pbKeyLastGlobal );
		pbKeyLastGlobal = pbKeyLastCurLevel;
		cbKeyLastGlobal = cbKeyLastCurLevel;

		forever
			{
			if (!(pbKeyLastGlobal = SAlloc( sizeof( rgbKeyLastGlobal ))))
				Error( JET_errOutOfMemory, HandleError );
			cbKeyLastGlobal = 0;

			Call( ErrDIRDump( pfucb, cchIndent + cchPerDepth ) );

			SFree( pbKeyLastGlobal );
			pbKeyLastGlobal = pbKeyLastCurLevel;
			cbKeyLastGlobal = cbKeyLastCurLevel;

			err = ErrDIRNext( pfucb, &dib );
			if ( err < 0 )
				{
				if ( err == JET_errNoCurrentRecord )
					{
					break;
					}
				goto HandleError;
				}
			}

		if ( err == JET_errNoCurrentRecord )
			err = JET_errSuccess;

		DIRIUp( pfucb, 1 );
		}

	if ( err == JET_errRecordNotFound )
		err = JET_errSuccess;
HandleError:
	DIRAPIReturn( pfucbNil, err );
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\fcb.c ===
#include "config.h"

#include <string.h>

#include "daedef.h"
#include "pib.h"
#include "util.h"
#include "fmp.h"
#include "ssib.h"
#include "page.h"
#include "fcb.h"
#include "fucb.h"
#include "nver.h"
#include "stapi.h"
#include "fdb.h"
#include "idb.h"
#include "recapi.h"
#include "recint.h"
#include "fileint.h"

DeclAssertFile;					/* Declare file name for assert macros */


/*	outstanding versions may be on non-clustered index and not on
/*	table FCB, so must check all non-clustered indexes before
/*	freeing table FCBs.
/**/
LOCAL BOOL FFCBINoVersion( FCB *pfcbTable )
	{
	FCB 	*pfcbT;

	for ( pfcbT = pfcbTable; pfcbT != pfcbNil; pfcbT = pfcbT->pfcbNextIndex )
		{
		if ( pfcbT->cVersion > 0 )
			return fFalse;
		}

	return fTrue;
	}


/*	list of all file FCBs in the system which are currently available.
/*	Some may not be in use, and have wRefCnt == 0;  these may be
/*	reclaimed ( and any attendant index FCBs ) if the free pool is exhausted.
/**/
FCB * __near pfcbGlobalList = pfcbNil;
SgSemDefine( semGlobalFCBList );
SgSemDefine( semLinkUnlink );


VOID FCBLink( FUCB *pfucb, FCB *pfcb )
	{
	Assert( pfucb != pfucbNil );
	Assert( pfcb != pfcbNil );
	pfucb->u.pfcb = pfcb;
	pfucb->pfucbNextInstance = pfcb->pfucb;
	pfcb->pfucb = pfucb;
	pfcb->wRefCnt++;
	Assert( pfcb->wRefCnt > 0 );
#ifdef DEBUG
	{
	FUCB	*pfucbT = pfcb->pfucb;
	INT	cfcb = 0;

	while( cfcb++ < pfcb->wRefCnt && pfucbT != pfucbNil )
		{
		pfucbT = pfucbT->pfucbNextInstance;
		}
	Assert( pfucbT == pfucbNil );
	}
#endif
	}


VOID FCBUnlink( FUCB *pfucb )
	{
	FUCB   	*pfucbCurr;
	FUCB   	*pfucbPrev;
	FCB		*pfcb;

	Assert( pfucb != pfucbNil );
	pfcb = pfucb->u.pfcb;
	Assert( pfcb != pfcbNil );
	pfucb->u.pfcb = pfcbNil;
	pfucbPrev = pfucbNil;
	Assert( pfcb->pfucb != pfucbNil );
	pfucbCurr = pfcb->pfucb;
	while ( pfucbCurr != pfucb )
		{
		pfucbPrev = pfucbCurr;
		pfucbCurr = pfucbCurr->pfucbNextInstance;
		Assert( pfucbCurr != pfucbNil );
		}
	if ( pfucbPrev == pfucbNil )
		pfcb->pfucb = pfucbCurr->pfucbNextInstance;
	else
		pfucbPrev->pfucbNextInstance = pfucbCurr->pfucbNextInstance;
	Assert( pfcb->wRefCnt > 0 );
	pfcb->wRefCnt--;
	}

/*	returns index of bucket in FCB Hash given dbid, pgnoFDP
/**/
LOCAL ULONG UlFCBHashVal( DBID dbid, PGNO pgnoFDP )
	{
	return ( dbid + pgnoFDP ) % cFCBBuckets;
	}


/*	inserts fcb in hash
/**/
VOID FCBRegister( FCB *pfcb )
	{
	ULONG	cBucket = UlFCBHashVal( pfcb->dbid, pfcb->pgnoFDP );

	Assert( cBucket <= cFCBBuckets );
	Assert( pfcb->pfcbNextInHashBucket == pfcbNil );
	Assert( PfcbFCBGet( pfcb->dbid, pfcb->pgnoFDP ) == pfcbNil );

	Assert( pfcbHash[cBucket] != pfcb );
	pfcb->pfcbNextInHashBucket = pfcbHash[cBucket];
	pfcbHash[cBucket] = pfcb;
	return;
	}


/*	removes fcb from hash table
/**/
VOID FCBDiscard( FCB *pfcb )
	{
	ULONG  	cBucket = UlFCBHashVal( pfcb->dbid, pfcb->pgnoFDP );
	FCB		**ppfcb;

	Assert( cBucket <= cFCBBuckets );
	
	for ( ppfcb = &pfcbHash[cBucket]; *ppfcb != pfcbNil; ppfcb = &(*ppfcb)->pfcbNextInHashBucket )
		{
		Assert( UlFCBHashVal( (*ppfcb)->dbid, (*ppfcb)->pgnoFDP ) == cBucket );
		if ( *ppfcb == pfcb )
			{
			*ppfcb = pfcb->pfcbNextInHashBucket;
			pfcb->pfcbNextInHashBucket = pfcbNil;
			Assert( PfcbFCBGet( pfcb->dbid, pfcb->pgnoFDP ) == pfcbNil );
			return;
			}
		else
			{
			Assert( pfcb->dbid != (*ppfcb)->dbid || pfcb->pgnoFDP != (*ppfcb)->pgnoFDP );
			}
		}

	Assert( fFalse );
	}

/*	gets pointer to FCB with given dbid,pgnoFDP if one exists in hash;
/*	returns pfcbNil otherwise
/**/
FCB *PfcbFCBGet( DBID dbid, PGNO pgnoFDP )
	{
	ULONG  	cBucket = UlFCBHashVal( dbid, pgnoFDP );
	FCB		*pfcb = pfcbHash[cBucket];

	for ( ;	pfcb != pfcbNil && !( pfcb->dbid == dbid && pfcb->pgnoFDP == pgnoFDP );
		pfcb = pfcb->pfcbNextInHashBucket );

#ifdef DEBUG
	/* check for no duplicates in bucket
	/**/
	if ( pfcb != pfcbNil )
		{
		FCB	*pfcbT = pfcb->pfcbNextInHashBucket;

		for ( ; pfcbT != pfcbNil; pfcbT = pfcbT->pfcbNextInHashBucket )
			{
			Assert ( pfcbT->dbid != dbid || pfcbT->pgnoFDP != pgnoFDP );
			}
		}
#endif

	Assert( pfcb == pfcbNil || ( pfcb->dbid == dbid && pfcb->pgnoFDP == pgnoFDP ) );
	return pfcb;
	}


/* this function is specifically for clean-up after redo.
/**/
FCB *FCBResetAfterRedo( void )
	{
	FCB	 	*pfcb;

	for ( pfcb = pfcbGlobalList; pfcb != pfcbNil; pfcb = pfcb->pfcbNext )
		{
		if ( PfcbFCBGet( pfcb->dbid, pfcb->pgnoFDP ) == pfcb )
			FCBDiscard( pfcb );
		pfcb->dbid = 0;
		pfcb->pgnoFDP = pgnoNull;
		pfcb->wRefCnt = 0;
		}

	return pfcbNil;
	}


ERR ErrFCBAlloc( PIB *ppib, FCB **ppfcb )
	{
	FCB		*pfcb;
	FCB		*pfcbPrev;

	/*	first try free pool
	/**/
	pfcb = PfcbMEMAlloc();
	if ( pfcb != pfcbNil )
		{
		FCBInit( pfcb );
		*ppfcb = pfcb;
		return JET_errSuccess;
		}

	/*	clean versions in order to make more FCBs avaiable
	/*	for reuse.  This must be done sinece FCBs are referenced
	/*	by versioned and can only be cleaned when the cVersion
	/*	count in the FCB is 0.
	/**/
	(VOID)ErrRCECleanAllPIB();

	/*	look for FCB with 0 reference count, and also, no deny read
	/*	flag set.  It is possible that the reference count will be
	/*	zero and the deny read flag set.
	/**/
	SgSemRequest( semGlobalFCBList );
	pfcbPrev = pfcbNil;
	for (	pfcb = pfcbGlobalList;
		pfcb != pfcbNil && !FFCBAvail( pfcb, ppib );
		pfcb = pfcb->pfcbNext )
		pfcbPrev = pfcb;
	if ( pfcb == pfcbNil )
		{
		SgSemRelease( semGlobalFCBList );
		return JET_errTooManyOpenTables;
		}

	Assert( !FFCBSentinel( pfcb ) );

	/*	remove from global list and deallocate
	/**/
	if ( pfcbPrev == pfcbNil )
		{
		Assert( pfcb == pfcbGlobalList );
		pfcbGlobalList = pfcb->pfcbNext;
		}
	else
		{
		Assert( pfcb->pfcbNext != pfcbPrev );
		pfcbPrev->pfcbNext = pfcb->pfcbNext;
		}
	SgSemRelease( semGlobalFCBList );
	FILEIDeallocateFileFCB( pfcb );

	/*	there should be some FCBs free now, unless somebody happened to
	/*	grab the newly freed FCBs between these 2 statements
	/**/
	pfcb = PfcbMEMAlloc( );
	if ( pfcb == pfcbNil )
		return JET_errOutOfMemory;
	
	FCBInit( pfcb );
	*ppfcb = pfcb;
	return JET_errSuccess;
	}


//	UNDONE:	remove the need for this routine by having open
//		   	database create an FCB and permanently hold it
//		   	open via reference count on database record
ERR ErrFCBNew( PIB *ppib, DBID dbid, PGNO pgno, FCB **ppfcb )
	{
	ERR	err;

	NotUsed( pgno );

	CallR( ErrFCBAlloc( ppib, ppfcb ) );

	/*	initialize FCB
	/**/
	FCBInit( *ppfcb );
	( *ppfcb )->dbid = dbid;
	( *ppfcb )->pgnoFDP = pgnoSystemRoot;
	( *ppfcb )->pgnoRoot = pgnoSystemRoot;
	( *ppfcb )->itagRoot = 0;
	( *ppfcb )->bmRoot = SridOfPgnoItag( pgnoSystemRoot, 0 );
	( *ppfcb )->cVersion = 0;

	/*	insert into global fcb list and hash
	/**/
	Assert( pfcbGlobalList != (*ppfcb) );
	(*ppfcb)->pfcbNext = pfcbGlobalList;
	pfcbGlobalList = *ppfcb;

	FCBRegister( *ppfcb );

	return JET_errSuccess;
	}


//+API
//	FCBPurgeDatabase
//	========================================================================
//	FCBPurgeDatabase( DBID dbid )
//
//	Removes alls FCBs from the global list for given dbid.  Called when
//	database detached, so newly created or attached database with
//	same dbid will not have tables confused with previous databases
//	tables.
//
//	PARAMETERS		dbid		dbid of database
//		   						or dbidNull if all FCBs are to be purged
//
//	SIDE EFFECTS	FCBs whose FDPpgno matches the given dbid are
//		   			removed from the global list.
//-
VOID FCBPurgeDatabase( DBID dbid )
	{
	FCB	*pfcbCurr;		// pointer to current FCB in list walk
	FCB	*pfcbCurrT;		// pointer to next FCB
	FCB	*pfcbPrev;		// pointer to previous FCB in list walk

	SgSemRequest(semGlobalFCBList);

	pfcbPrev = pfcbNil;
	pfcbCurr = pfcbGlobalList;
	while ( pfcbCurr != pfcbNil )
		{
		pfcbCurrT = pfcbCurr->pfcbNext;
		if ( pfcbCurr->dbid == dbid || dbid == 0 )
			{
			if ( FFCBSentinel( pfcbCurr ) )
				{
				if ( PfcbFCBGet( pfcbCurr->dbid, pfcbCurr->pgnoFDP ) == pfcbCurr )
					FCBDiscard( pfcbCurr );
				Assert( pfcbCurr->cVersion == 0 );
				MEMReleasePfcb( pfcbCurr );
				}
			else
				{
				FILEIDeallocateFileFCB( pfcbCurr );
				}

			if ( pfcbPrev == pfcbNil )
				pfcbGlobalList = pfcbCurrT;
			else
				{
				Assert( pfcbCurrT != pfcbPrev );
				pfcbPrev->pfcbNext = pfcbCurrT;
				}
			}
		else
			{
			/*	if did not deallocate current fcb, advance previous
			/*	fcb to current fcb
			/**/
			pfcbPrev = pfcbCurr;
			}
		pfcbCurr = pfcbCurrT;
		}
	SgSemRelease(semGlobalFCBList);
	}


//+FILE_PRIVATE
// FCBPurgeTable
// ========================================================================
// FCBPurgeTable( DBID dbid, PNGO pgnoFDP )
//
// Removes an FCB from the global list and frees it up.
//
// PARAMETERS	pgnoFDP		FDP page number of FCB to purge
//
// SIDE EFFECTS
//		The FCB whose FDPpgno matches the input parameter is
//		removed from the global list ( if it was there at all ).
//-
VOID FCBPurgeTable( DBID dbid, PGNO pgnoFDP )
	{
	FCB	*pfcb;
	FCB	*pfcbPrev;

	SgSemRequest(semGlobalFCBList);

	pfcbPrev = pfcbNil;
	pfcb = pfcbGlobalList;
	while ( pfcb != pfcbNil )
		{
		if ( pfcb->pgnoFDP == pgnoFDP && pfcb->dbid == dbid )
			break;
		pfcbPrev = pfcb;
		pfcb = pfcb->pfcbNext;
		}

	if ( pfcb == pfcbNil )
		{
		SgSemRelease( semGlobalFCBList );
		return;
		}

	if ( pfcbPrev == pfcbNil )
		{
		pfcbGlobalList = pfcb->pfcbNext;
		}
	else
		{
		Assert( pfcb->pfcbNext != pfcbPrev );
		pfcbPrev->pfcbNext = pfcb->pfcbNext;
		}

	Assert( pfcb->wRefCnt == 0 );

	if ( FFCBSentinel( pfcb ) )
		{
		if ( PfcbFCBGet( pfcb->dbid, pfcb->pgnoFDP ) == pfcb )
			FCBDiscard( pfcb );
		Assert( pfcb->cVersion == 0 );
		MEMReleasePfcb( pfcb );
		}
	else
		{
		FILEIDeallocateFileFCB( pfcb );
		}

	SgSemRelease(semGlobalFCBList);
	}


/*	set domain usage mode or return error.  Allow only one deny read
/*	or one deny write.  Sessions that own locks may open other read
/*	or read write cursors, but not another deny read or deny write cursor.
/*	This is done to facillitage flag management, but could be relaxed
/*	if required.
/**/
ERR ErrFCBISetMode( PIB *ppib, FCB *pfcb, JET_GRBIT grbit )
	{
	FUCB	*pfucbT;

	/*	if table is fake deny read, then return error
	/**/
	if ( FFCBSentinel( pfcb ) )
		return JET_errTableLocked;

	/*	all cursors can read so check for deny read flag by other session.
	/**/
	if ( FFCBDenyRead( pfcb, ppib ) )
		{
		/*	check if domain is deny read locked by other session.  If
		/*	deny read locked, then all cursors must be of same session.
		/**/
		Assert( pfcb->ppibDenyRead != ppibNil );
		if ( pfcb->ppibDenyRead != ppib )
			return JET_errTableLocked;
#ifdef DEBUG
		for ( pfucbT = pfcb->pfucb; pfucbT != pfucbNil; pfucbT = pfucbT->pfucbNext )
			{
			Assert( pfucbT->ppib == pfcb->ppibDenyRead );
			}
#endif
		}

	/*	check for deny write flag by other session.  If deny write flag
	/*	set then only cursors of that session may have write privlages.
	/**/
	if ( grbit & JET_bitTableUpdatable )
		{
		if ( FFCBDenyWrite( pfcb ) )
			{
			for ( pfucbT = pfcb->pfucb; pfucbT != pfucbNil; pfucbT = pfucbT->pfucbNext )
				{
				if ( pfucbT->ppib != ppib && FFUCBDenyWrite( pfucbT ) )
					return JET_errTableLocked;
				}
			}
		}

	/*	if deny write lock requested, check for updatable cursor of
	/*	other session.  If lock is already held, even by given session,
	/*	then return error.
	/**/
	if ( grbit & JET_bitTableDenyWrite )
		{
		/*	if any session has this table open deny write, including given
		/*	session, then return error.
		/**/
		if ( FFCBDenyWrite( pfcb ) )
			{
			return JET_errTableInUse;
			}

		/*	check is cursors with write mode on domain.
		/**/
		for ( pfucbT = pfcb->pfucb; pfucbT != pfucbNil; pfucbT = pfucbT->pfucbNext )
			{
			if ( pfucbT->ppib != ppib && FFUCBUpdatable( pfucbT ) )
				{
				return JET_errTableInUse;
				}
			}
		FCBSetDenyWrite( pfcb );
		}

	/*	if deny read lock requested, then check for cursor of other
	/*	session.  If lock is already held, even by given session, then
	/*	return error.
	/**/
	if ( grbit & JET_bitTableDenyRead )
		{
		/*	if any session has this table open deny read, including given
		/*	session, then return error.
		/**/
		if ( FFCBDenyRead( pfcb, ppib ) )
			{
			return JET_errTableInUse;
			}
		/*	check if cursors belonging to another session
		/*	are open on this domain.
		/**/
		for ( pfucbT = pfcb->pfucb; pfucbT != pfucbNil; pfucbT = pfucbT->pfucbNext )
			{
			if ( pfucbT->ppib != ppib )
				{
				return JET_errTableInUse;
				}
			}
		FCBSetDenyRead( pfcb, ppib );
		}

	return JET_errSuccess;
	}


/*	reset domain mode usage.
/**/
VOID FCBResetMode( PIB *ppib, FCB *pfcb, JET_GRBIT grbit )
	{
	if ( grbit & JET_bitTableDenyRead )
		{
		Assert( FFCBDenyRead( pfcb, ppib ) );
		FCBResetDenyRead( pfcb );
		}

	if ( grbit & JET_bitTableDenyWrite )
		{
		Assert( FFCBDenyWrite( pfcb ) );
		FCBResetDenyWrite( pfcb );
		}

	return;
	}


ERR ErrFCBSetDeleteTable( PIB *ppib, DBID dbid, PGNO pgno )
	{
	ERR	err;
	FCB	*pfcb;

	SgSemRequest(semGlobalFCBList);
	pfcb = PfcbFCBGet( dbid, pgno );
	if ( pfcb == pfcbNil )
		{
		CallR( ErrFCBAlloc( ppib, &pfcb ) );

		Assert( pfcbGlobalList != pfcb );
		pfcb->pfcbNext = pfcbGlobalList;
		pfcbGlobalList = pfcb;
		pfcb->dbid = dbid;
		pfcb->pgnoFDP = pgno;
		pfcb->wRefCnt = 0;
		FCBSetDenyRead( pfcb, ppib );
		FCBRegister( pfcb );
		FCBSetSentinel( pfcb );
		}
	else
		{
		INT	wRefCnt = pfcb->wRefCnt;
		FUCB	*pfucbT;

		/*	check for open cursors on table or deferred closed
		/*	cursors by other session.
		/**/
		for ( pfucbT = pfcb->pfucb;
			pfucbT != pfucbNil;
			pfucbT = pfucbT->pfucbNextInstance )
			{
			if ( FFUCBDeferClosed( pfucbT ) && pfucbT->ppib == ppib )
				{
				Assert( wRefCnt > 0 );
				wRefCnt--;
				}
			}

		if ( wRefCnt > 0 )
			{
			SgSemRelease(semGlobalFCBList);
			return JET_errTableInUse;
			}

		FCBSetDenyRead( pfcb, ppib );
		}

	SgSemRelease(semGlobalFCBList);
	return JET_errSuccess;
	}


VOID FCBResetDeleteTable( DBID dbid, PGNO pgnoFDP )
	{
	FCB	*pfcb;
	FCB	*pfcbPrev;

	SgSemRequest(semGlobalFCBList);

	pfcbPrev = pfcbNil;
	pfcb = pfcbGlobalList;
	while ( pfcb != pfcbNil )
		{
		if ( pfcb->pgnoFDP == pgnoFDP && pfcb->dbid == dbid )
			break;
		pfcbPrev = pfcb;
		pfcb = pfcb->pfcbNext;
		}

	Assert( pfcb != pfcbNil );

	if ( FFCBSentinel( pfcb ) )
		{
		if ( PfcbFCBGet( pfcb->dbid, pfcb->pgnoFDP ) == pfcb )
			FCBDiscard( pfcb );
		if ( pfcbPrev == pfcbNil )
			{
			pfcbGlobalList = pfcb->pfcbNext;
			}
		else
			{
			Assert( pfcb->pfcbNext != pfcbPrev );
			pfcbPrev->pfcbNext = pfcb->pfcbNext;
			}
		Assert( pfcb->cVersion == 0 );
		MEMReleasePfcb( pfcb );
		}
	else
		{
		FCBResetDenyRead( pfcb );
		}

	SgSemRelease( semGlobalFCBList );
	return;
	}


ERR ErrFCBSetRenameTable( PIB *ppib, DBID dbid, PGNO pgnoFDP )
	{
	ERR	err = JET_errSuccess;
	FCB	*pfcb;

	SgSemRequest( semGlobalFCBList );
	pfcb = PfcbFCBGet( dbid, pgnoFDP );
	if ( pfcb != pfcbNil )
		{
		Call( ErrFCBSetMode( ppib, pfcb, JET_bitTableDenyRead ) );
		}
	else
		{
		CallR( ErrFCBAlloc( ppib, &pfcb ) );

		Assert( pfcbGlobalList != pfcb );
		pfcb->pfcbNext = pfcbGlobalList;
		pfcbGlobalList = pfcb;
		pfcb->dbid = dbid;
		pfcb->pgnoFDP = pgnoFDP;
		pfcb->wRefCnt = 0;
		FCBSetDenyRead( pfcb, ppib );
		FCBSetSentinel( pfcb );
		FCBRegister( pfcb );
		}

HandleError:
	SgSemRelease( semGlobalFCBList );
	return err;
	}


/*	return fTrue if table open with one or more non deferred closed tables.
/**/
BOOL FFCBTableOpen( DBID dbid, PGNO pgnoFDP )
	{
	FCB 	*pfcb = PfcbFCBGet( dbid, pgnoFDP );
	FUCB	*pfucb;

	if ( pfcb == pfcbNil || pfcb->wRefCnt == 0 )
		return fFalse;

	for ( pfucb = pfcb->pfucb; pfucb != pfucbNil; pfucb = pfucb->pfucbNextInstance )
		{
		if ( !FFUCBDeferClosed( pfucb ) )
			return fTrue;
		}

	return fFalse;
	}


VOID FCBLinkIndex( FCB *pfcbTable, FCB *pfcbIndex )
	{
	pfcbIndex->pfcbNextIndex =	pfcbTable->pfcbNextIndex;
	pfcbTable->pfcbNextIndex = pfcbIndex;
	return;
	}


VOID FCBUnlinkIndex( FCB *pfcbTable, FCB *pfcbIndex )
	{
	FCB	*pfcbT;

	for ( pfcbT = pfcbTable;
		pfcbT != pfcbNil && pfcbT->pfcbNextIndex != pfcbIndex;
		pfcbT = pfcbT->pfcbNextIndex );
	Assert( pfcbT != pfcbNil );
	pfcbT->pfcbNextIndex = pfcbIndex->pfcbNextIndex;
	pfcbIndex->pfcbNextIndex = pfcbNil;
	return;
	}


BOOL FFCBUnlinkIndexIfFound( FCB *pfcbTable, FCB *pfcbIndex )
	{
	FCB	*pfcbT;

	for ( pfcbT = pfcbTable;
		pfcbT != pfcbNil && pfcbT->pfcbNextIndex != pfcbIndex;
		pfcbT = pfcbT->pfcbNextIndex );

	if ( pfcbT != pfcbNil )
		{
		pfcbT->pfcbNextIndex = pfcbIndex->pfcbNextIndex;
		pfcbIndex->pfcbNextIndex = pfcbNil;
		return fTrue;
		}

	return fFalse;
	}


/*	detach deleted index FCB from non-clustered index chain.
/**/
FCB *PfcbFCBUnlinkIndexByName( FCB *pfcb, CHAR *szIndex )
	{
	FCB	**ppfcbIdx;
	FCB	*pfcbT;

	/*	find non-clustered index in table index FCB list.
	/**/
	for ( ppfcbIdx = &pfcb->pfcbNextIndex;
		*ppfcbIdx != pfcbNil && SysCmpText( (*ppfcbIdx)->pidb->szName, szIndex ) != 0;
		ppfcbIdx = &(*ppfcbIdx)->pfcbNextIndex )
		{
		;/*** Null-body ***/
		}

	Assert( *ppfcbIdx != pfcbNil );

	/*	remove index FCB
	/**/
	pfcbT = *ppfcbIdx;
	*ppfcbIdx = (*ppfcbIdx)->pfcbNextIndex;
	return pfcbT;
	}


ERR ErrFCBSetDeleteIndex( PIB *ppib, FCB *pfcbTable, CHAR *szIndex )
	{
	FCB	*pfcbT;
	INT	wRefCnt;
	FUCB	*pfucbT;

	/*	find index pfcb in index list
	/**/
	for( pfcbT = pfcbTable->pfcbNextIndex; ; pfcbT = pfcbT->pfcbNextIndex )
		{
		if ( SysCmpText( szIndex, pfcbT->pidb->szName ) == 0 )
			break;
		Assert( pfcbT->pfcbNextIndex != pfcbNil );
		}

	wRefCnt = pfcbT->wRefCnt;

	/*	check for open cursors on table or deferred closed
	/*	cursors by other session.
	/**/
	if ( wRefCnt > 0 )
		{
		for ( pfucbT = pfcbT->pfucb;
			pfucbT != pfucbNil;
			pfucbT = pfucbT->pfucbNextInstance )
			{
			if ( FFUCBDeferClosed( pfucbT ) && pfucbT->ppib == ppib )
				{
				Assert( wRefCnt > 0 );
				wRefCnt--;
				}
			}
		}

	if ( wRefCnt > 0 )
		{
		SgSemRelease(semGlobalFCBList);
		return JET_errIndexInUse;
		}

	FCBSetDenyRead( pfcbT, ppib );
	FCBSetDeletePending( pfcbT );

	return JET_errSuccess;
	}


VOID FCBResetDeleteIndex( FCB *pfcbIndex )
	{
	FCBResetDeletePending( pfcbIndex );
	FCBResetDenyRead( pfcbIndex );
	return;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\fcreate.c ===
#include "config.h"

#include <stdlib.h>
#include <string.h>

#include "daedef.h"
#include "pib.h"
#include "ssib.h"
#include "page.h"
#include "fmp.h"
#include "fucb.h"
#include "fcb.h"
#include "stapi.h"
#include "logapi.h"
#include "scb.h"
#include "fdb.h"
#include "idb.h"
#include "fileapi.h"
#include "fileint.h"
#include "util.h"
#include "dbapi.h"

#include "systab.h"
#include "stats.h"
#include "nver.h"
#include "dirapi.h"
#include "recapi.h"
#include "sortapi.h"
#include "node.h"
#include "recint.h"

DeclAssertFile;                                 /* Declare file name for assert macros */

static FIELDDATA fielddataInitial = {
        fidFixedLeast-1,
        fidVarLeast-1,
        fidTaggedLeast-1
};

static PERS_OLCSTAT olcStatsInit = {
        0,
        0,
        0,
        0
};

static ULONG    autoincInit = 1;
LINE                    lineNull = { 0, NULL };

//
// WaitTillOldest( TRX trx )
// Waits till trx becomes the oldest transaction alive
//      Uses exponential back off
// BFSleep releases critical sections to avoid deadlocks
LOCAL VOID WaitTillOldest( TRX trx )
        {
        ULONG ulmsec = ulStartTimeOutPeriod;

        /*      must be in critJet when inspect trxOldest global variable.
        /*      Call BFSleep to release critJet while sleeping.
        /**/
        for ( ; trx != trxOldest; )
                {
                BFSleep( ulmsec );
                ulmsec *= 2;
                if ( ulmsec > ulMaxTimeOutPeriod )
                        ulmsec = ulMaxTimeOutPeriod;
                }
        return;
        }


ERR VTAPI ErrIsamCreateTable(
        PIB                     *ppib,
        ULONG_PTR       vdbid,
        char            *szName,
        ULONG           ulPages,
        ULONG           ulDensity,
        FUCB            **ppfucb )
        {
        ERR                     err;
        DBID            dbid;
        FUCB            *pfucb;

#ifdef  DISPATCHING
        JET_TABLEID     tableid;

        /*      Allocate a dispatchable tableid
        /**/
        CallR( ErrAllocateTableid(&tableid, (JET_VTID) 0, &vtfndefIsam ) );
#endif  /* DISPATCHING */

        /* Ensure that database is updatable
        /**/
        CallR( VDbidCheckUpdatable( vdbid ) );

        dbid = DbidOfVDbid( vdbid );

        Call( ErrFILECreateTable(
                ppib,
                dbid,
                szName,
                ulPages,
                ulDensity,
                &pfucb ) );

#ifdef  DISPATCHING
        /* Inform dispatcher of correct JET_VTID */
        CallS( ErrSetVtidTableid( (JET_SESID) ppib, tableid, (JET_VTID) pfucb ) );
        pfucb->fVtid = fTrue;
        *(JET_TABLEID *) ppfucb = tableid;
#else   /* !DISPATCHING */
        *ppfucb = pfucb;
#endif  /* !DISPATCHING */

        return err;

HandleError:
#ifdef  DISPATCHING
        ReleaseTableid( tableid );
#endif  /* DISPATCHING */
        return err;
        }


//+API
// ErrFILECreateTable
// =========================================================================
// ERR ErrFILECreateTable( PIB *ppib, DBID dbid, CHAR *szName,
//              ULONG ulPages, ULONG ulDensity, FUCB **ppfucb )
//
// Create file with pathname szName.  Created file will have no fields or
// indexes defined (and so will be a "sequential" file ).
//
// PARAMETERS
//                                      ppib                            PIB of user
//                                      dbid                            database id
//                                      szName                  path name of new file
//                                      ulPages                 initial page allocation for file
//                                      ulDensity               initial loading density
//                                      ppfucb                  Exclusively locked FUCB on new file
// RETURNS              Error codes from DIRMAN or
//                                       JET_errSuccess         Everything worked OK.
//                                      -DensityIvlaid                  Density parameter not valid
//                                      -TableDuplicate                 A file already exists with
//                                                                                              the path given.
// COMMENTS             A transaction is wrapped around this function.  Thus, any
//                                      work done will be undone if a failure occurs.
// SEE ALSO             ErrIsamAddColumn, ErrIsamCreateIndex, ErrIsamDeleteTable
//-
ERR ErrFILECreateTable( PIB *ppib, DBID dbid, const CHAR *szName, ULONG ulPages, ULONG ulDensity, FUCB **ppfucb )
        {
        ERR                             err;
        CHAR                    szTable[(JET_cbNameMost + 1 )];
        FUCB                    *pfucb;
        KEY                             key;
        BYTE                    rgbKey[JET_cbKeyMost];
#define cbMostTableRoot (2*sizeof(WORD)+2*sizeof(JET_DATESERIAL)+JET_cbNameMost)
        BYTE                    rgbData[cbMostTableRoot];
        LINE                    line;
        PGNO                    pgnoFDP;
        DBID                    dbidAdjust;
        JET_DATESERIAL  dtNow;

#ifdef  SYSTABLES
        BOOL            fDoSTI;

        /*      Set fDoSTI and fix DBID...
        */
        if (dbid >= dbidMax )
                {
                dbid -= dbidMax;
                fDoSTI = 0;
                }
        else
                fDoSTI = 1;
        dbidAdjust = (ULONG) dbid;
#endif  /* SYSTABLES */

        /*** Check parms ***/
        CheckPIB(ppib );
        CheckDBID( ppib, dbid );
        CallR( ErrCheckName( szTable, szName, (JET_cbNameMost + 1) ) );
        if ( ulDensity == 0 )
                ulDensity = ulDefaultDensity;
        if ( ulDensity < ulFILEDensityLeast || ulDensity > ulFILEDensityMost )
                return JET_errDensityInvalid;

        CallR( ErrDIRBeginTransaction( ppib ) );

        // get an fucb
        Call( ErrDIROpen( ppib, pfcbNil, dbid, &pfucb ) );

        /*      move to tables node.
        /**/
        Call( ErrDIRSeekPath( pfucb, 1, pkeyTables, 0 ) );

        /****** FILE PAGE START ****************************
        /**/

        // create terminal node; data is:
        //         number of secondary indexes (WORD)
        //         density, if sequential file (WORD)
        //         creation time stamp (JET_DATESERIAL)
        //         last DDL time stamp (JET_DATESERIAL)
        //         original form of file name (var.)

        /*      normalize table name and set key
        /**/
        SysNormText( szTable, strlen( szTable ), rgbKey, sizeof( rgbKey ), &key.cb );
        key.pb = rgbKey;

        line.pb = rgbData;
        ((WORD *)line.pb)[0] = 0;                                               // number of secondary indexes
        ((WORD *)line.pb)[1] = (WORD)ulDensity;         // sequential file density
        UtilGetDateTime( &dtNow );
        memcpy( line.pb+2*sizeof(WORD), &dtNow, sizeof(JET_DATESERIAL) );
        memcpy( line.pb+2*sizeof(WORD)+sizeof(JET_DATESERIAL), &dtNow, sizeof(JET_DATESERIAL) );
        memcpy( line.pb+2*sizeof(WORD)+2*sizeof(JET_DATESERIAL), szTable, strlen(szTable) );
        line.cb = (ULONG)(2*sizeof(WORD) + 2*sizeof(JET_DATESERIAL) + strlen(szTable));
        Assert( line.cb <= cbMostTableRoot );
        err = ErrDIRInsertFDP( pfucb, &line, &key, fDIRVersion, (CPG)ulPages );
        if ( err < 0 )
                {
                if ( err == JET_errKeyDuplicate )
                        {
                        err = JET_errTableDuplicate;
                        }
                goto HandleError;
                }

        Assert( ppib != ppibNil );
        Assert( ppib->level < levelMax );
        Assert( PcsrCurrent( pfucb ) != pcsrNil );
        Assert( PcsrCurrent( pfucb )->csrstat == csrstatOnFDPNode );
        pgnoFDP = PcsrCurrent( pfucb )->pgno;

        /*      set page density.
        /**/
        pfucb->u.pfcb->cbDensityFree = ( ( 100 - ulDensity ) * cbPage ) / 100;

        // indexes/clustered/data
        Call( ErrDIRInsert( pfucb, &lineNull, pkeyIndexes, fDIRNoVersion ) );
        Call( ErrDIRInsert( pfucb, &lineNull, pkeyNull, fDIRNoVersion ) );
        Call( ErrDIRInsert( pfucb, &lineNull, pkeyData, fDIRNoVersion | fDIRBackToFather ) );
        DIRUp( pfucb, 2 );

        // fields
        line.cb = sizeof(FIELDDATA);
        line.pb = (BYTE *)&fielddataInitial;
        Call( ErrDIRInsert( pfucb, &line, pkeyFields, fDIRNoVersion | fDIRBackToFather ) );

//      // long data
//      Call( ErrDIRInsert( pfucb, &lineNull, pkeyLong, fDIRNoVersion | fDIRBackToFather ) );

        // AutoInc Node
        line.pb = (BYTE *) &autoincInit;
        line.cb = sizeof(autoincInit);
        Call( ErrDIRInsert( pfucb, &line, pkeyAutoInc, fDIRNoVersion | fDIRBackToFather ) );

        // OLCStats node
        line.pb = (BYTE *) &olcStatsInit;
        line.cb = sizeof( olcStatsInit );
        Call( ErrDIRInsert( pfucb, &line, pkeyOLCStats, fDIRNoVersion | fDIRBackToFather ) );

        DIRClose( pfucb );

#ifdef SYSTABLES
        /*      insert record in MSO...
        /**/
        if ( dbid != dbidTemp && fDoSTI )
                {
                JET_TABLEID             objidTable              = pgnoFDP;
                LINE                            rgline[ilineSxMax];
                OBJTYP                  objtyp                  = (OBJTYP)JET_objtypTable;
                JET_TABLEID             objidParentId   = objidTblContainer;
                long                            flags                           = 0;

                rgline[iMSO_Id].pb                              = (BYTE *)&objidTable;
                rgline[iMSO_Id].cb                              = sizeof(objidTable);
                rgline[iMSO_ParentId].pb                = (BYTE *)&objidParentId;
                rgline[iMSO_ParentId].cb                = sizeof(objidParentId);
                rgline[iMSO_Name].pb                            = (BYTE *)szTable;
                rgline[iMSO_Name].cb                            = strlen(szTable);
                rgline[iMSO_Type].pb                            = (BYTE *)&objtyp;
                rgline[iMSO_Type].cb                            = sizeof(objtyp);
                rgline[iMSO_DateCreate].pb              = (BYTE *)&dtNow;
                rgline[iMSO_DateCreate].cb              = sizeof(JET_DATESERIAL);
                rgline[iMSO_DateUpdate].pb              = (BYTE *)&dtNow;
                rgline[iMSO_DateUpdate].cb              = sizeof(JET_DATESERIAL);
                rgline[iMSO_Rgb].cb                             = 0;
                rgline[iMSO_Lv].cb                              = 0;
                rgline[iMSO_Owner].cb                   = 0;
                rgline[iMSO_Database].cb                = 0;
                rgline[iMSO_Connect].cb                 = 0;
                rgline[iMSO_ForeignName].cb     = 0;
                rgline[iMSO_RmtInfoShort].cb    = 0;
                rgline[iMSO_RmtInfoLong].cb     = 0;
                rgline[iMSO_Flags].pb                   = (BYTE *) &flags;
                rgline[iMSO_Flags].cb                   = sizeof(ULONG);
                rgline[iMSO_LvExtra].cb                 = 0;
                rgline[iMSO_Description].cb     = 0;
                rgline[iMSO_LvModule].cb                = 0;
                rgline[iMSO_LvProp].cb                  = 0;
                rgline[iMSO_Pages].pb                   = (BYTE *) &ulPages;
                rgline[iMSO_Pages].cb                   = sizeof(ulPages);
                rgline[iMSO_Density].pb                 = (BYTE *) &ulDensity;
                rgline[iMSO_Density].cb                 = sizeof(ulDensity);
                Call( ErrSysTabInsert( ppib, dbid, itableSo, rgline, objidTable ) );
                }
#endif  /* SYSTABLES */

        /*      open table in exclusive mode, for output parameter
        /**/
        Call( ErrFILEOpenTable( ppib, dbidAdjust, ppfucb, szName, JET_bitTableDenyRead ) );

        FCBSetDenyDDL( (*ppfucb)->u.pfcb, ppib );
        err = ErrVERFlag( *ppfucb, operCreateTable, NULL, 0 );
        if ( err < 0 )
                {
                FCBResetDenyDDL( (*ppfucb)->u.pfcb );
                goto HandleError;
                }
        FUCBSetVersioned( *ppfucb );

//      /* build empty STATS node for clustered index
//      /**/
//      Call( ErrIsamComputeStats( ppib, *ppfucb ) );

        Call( ErrDIRCommitTransaction( ppib ) );

        return JET_errSuccess;

HandleError:
        /*      close performed by rollback
        /**/
        CallS( ErrDIRRollback( ppib ) );
        return err;
        }


//+API
// ErrIsamAddColumn
// ========================================================================
// ERR ErrIsamAddColumn(
//              PIB                             *ppib;                  // IN PIB of user
//              FUCB                            *pfucb;                 // IN Exclusively opened FUCB on file
//              CHAR                            *szName;                        // IN name of new field
//              JET_COLUMNDEF   *pcolumndef             // IN definition of column added
//              BYTE                            *pbDefault              //      IN Default value of column
//              ULONG                           cbDefault               // IN length of Default value
//              JET_COLUMNID    *pcolumnid )    // OUT columnid of added column
//
// Creates a new field definition for a file.
//
// PARAMETERS
//                              pcolumndef->coltyp                      data type of new field, see jet.h
//                              pcolumndef->grbit                               field describing flags:
//                                      VALUE                           MEANING
//                                      ========================================
//                                      JET_bitColumnNotNULL                            Indicates that the field may
//                                                                                                                      not take on NULL values.
//                                      JET_bitColumnTagged                             The field is a "tagged" field.
//                                      JET_bitColumnVersion                            The field is a version field
//                                      JET_bitColumnAutoIncrement              The field is a autoinc field
//
// RETURNS              JET_errSuccess                  Everything worked OK.
//                                      -TaggedDefault                  A default value was specified
//                                                                                              for a tagged field.
//                                      -ColumnDuplicate                There is already a field
//                                                                                              defined for the name given.
// COMMENTS
//              There must not be anyone currently using the file, unless
//              the ErrIsamAddColumn is at level 0 [when non-exclusive ErrIsamAddColumn works].
//              A transaction is wrapped around this function.  Thus, any
//              work done will be undone if a failure occurs.
//              Transaction logging is turned off for temporary files.
//
// SEE ALSO             ErrIsamCreateTable, ErrIsamCreateIndex
//-
ERR VTAPI ErrIsamAddColumn(
        PIB                             *ppib,
        FUCB                    *pfucb,
        CHAR                    *szName,
        JET_COLUMNDEF   *pcolumndef,
        BYTE                    *pbDefault,
        ULONG                   cbDefault,
        JET_COLUMNID    *pcolumnid )
        {
        CHAR                    szColumn[(JET_cbNameMost + 1)];
        FIELDDATA               fielddata;
        FIELDDEFDATA    *pfdd = NULL;
        KEY                             key;
        LINE                    line;
        ERR                             err;
        BYTE                    rgbColumnNorm[ JET_cbKeyMost ];
        FCB                             *pfcb;
//      FDB                             *pfdbSav;
        LINE                    lineDefault;
        LINE                    *plineDefault;
        JET_COLTYP              coltyp;
        ULONG                   ulLength;
        USHORT                  cp = pcolumndef->cp;
        LANGID                  langid = (LANGID)pcolumndef->langid;
        WORD                    wCountry = (WORD)pcolumndef->wCountry;
//      BOOL                    fFDBConstruct = fFalse;
        BOOL                    fMaxTruncated = fFalse;

#ifdef  SYSTABLES
        BOOL                            fDoSTI;
#endif  /* SYSTABLES */

        /* check paramaters
        /**/
        CheckPIB( ppib );
        CheckTable( ppib, pfucb );
        CallR( ErrCheckName( szColumn, szName, (JET_cbNameMost + 1) ) );

        /* ensure that table is updatable */
        /**/
        CallR( FUCBCheckUpdatable( pfucb )  );

#ifdef  SYSTABLES
        /*      set fDoSTI and fix DBID...
        /**/
        if ( pfucb->dbid >= dbidMax )
                {
                pfucb->dbid -= dbidMax;
                fDoSTI = 0;
                }
        else
                fDoSTI = 1;

        if ( FFCBTemporaryTable( pfucb->u.pfcb ) )
                fDoSTI = 0;
#endif  /* SYSTABLES */

        if ( pcolumndef->cbStruct < sizeof(JET_COLUMNDEF) )
                return JET_errInvalidParameter;
        coltyp = pcolumndef->coltyp;

        /*      if column type is text then check code page and language id
        /**/
        if ( ( coltyp == JET_coltypText || coltyp == JET_coltypLongText ) )
                {
                /*      check code page
                /**/
                if ( cp != usEnglishCodePage && cp != usUniCodePage )
                        {
                        return JET_errInvalidParameter;
                        }

                /*      check language id
                /**/
                CallR( ErrSysCheckLangid( langid ) );
                }

        ulLength = pcolumndef->cbMax;

        if ( cbDefault > 0 )
                {
                lineDefault.cb = cbDefault;
                lineDefault.pb = (void *)pbDefault;
                plineDefault = &lineDefault;
                }
        else
                {
                plineDefault = NULL;
                }

        if ( pcolumndef->grbit & JET_bitColumnTagged )
                {
                if ( CbLine( plineDefault ) > 0 )
                        return JET_errTaggedDefault;
                if ( pcolumndef->grbit & JET_bitColumnNotNULL )
                        return JET_errTaggedNotNULL;
                }

        Assert( ppib != ppibNil );
        Assert( pfucb != pfucbNil );
        CheckTable( ppib, pfucb );
        Assert( pfucb->u.pfcb != pfcbNil );
        pfcb = pfucb->u.pfcb;

        /*      normalize column name
        /**/
        SysNormText( szColumn, strlen( szColumn ), rgbColumnNorm, sizeof( rgbColumnNorm ), &key.cb );
        key.pb = rgbColumnNorm;

        CallR( ErrDIRBeginTransaction( ppib ) );

        if ( FFCBDenyDDL( pfcb, ppib ) )
                {
                /* abort if DDL modification in progress
                /**/
                err = JET_errWriteConflict;
                goto HandleError;
                }
        FCBSetDenyDDL( pfcb, ppib );

        err = ErrVERFlag( pfucb, operAddColumn, (VOID *)&pfcb->pfdb, sizeof(pfcb->pfdb) );
        if ( err < 0 )
                {
                FCBResetDenyDDL( pfcb );
                goto HandleError;
                }

        /*      move to FDP root and update FDP timestamp
        /**/
        Assert( pfucb->ppib->level < levelMax );
        DIRGotoFDPRoot( pfucb );
        Call( ErrFILEIUpdateFDPData( pfucb, fDDLStamp ) );

        /*      down to "FIELDS" node.  Cache node data in fielddata.
        /**/
        Call( ErrDIRSeekPath( pfucb, 1, pkeyFields, 0 ) );
        Call( ErrDIRGet( pfucb ) );
        fielddata = *(UNALIGNED FIELDDATA *)pfucb->lineData.pb;

        /*      field should not already exist
        /**/
        err = ErrDIRSeekPath( pfucb, 1, &key, 0 );
        Assert( err != JET_errNoCurrentRecord );
        if (err >= 0)
                {
                err = JET_errColumnDuplicate;
                goto HandleError;
                }
        if (err != JET_errRecordNotFound)
                goto HandleError;

        if ( ( pfdd = SAlloc( sizeof(FIELDDEFDATA) + CbLine( plineDefault ) - 1 ) ) == NULL )
                {
                err = JET_errOutOfMemory;
                goto HandleError;
                }

        if ( coltyp == 0 || coltyp > JET_coltypLongText )
                {
                err = JET_errInvalidColumnType;
                goto HandleError;
                }

        /*      set field parameters
        /**/
        pfdd->bFlags = 0;

        if ( ( pcolumndef->grbit & JET_bitColumnAutoincrement )
                && ( pcolumndef->grbit & JET_bitColumnVersion ) )
                {
                /* mutual exclusive
                /**/
                err = JET_errInvalidParameter;
                goto HandleError;
                }

        /*      if column attribute is JET_bitVersion
        /*      return error if previous column attribute has been defined
        /*      return error if column type is not long
        /*      set column flag
        /**/
        if ( ( pcolumndef->grbit & JET_bitColumnVersion ) != 0 )
                {
                if ( pfcb->pfdb->fidVersion != 0 )
                        {
                        err = JET_errColumn2ndSysMaint;
                        goto HandleError;
                        }
                if ( coltyp != JET_coltypLong )
                        {
                        err = JET_errInvalidParameter;
                        goto HandleError;
                        }
                /*      autoincrement cannot be tagged
                /**/
                if ( pcolumndef->grbit & JET_bitColumnTagged )
                        {
                        err = JET_errCannotBeTagged;
                        goto HandleError;
                        }
                pfdd->bFlags |= ffieldVersion;
                }


        /*      if column attribute is JET_bitAutoincrement
        /*      return error if previous column attribute has been defined
        /*      return error if column type is not long
        /*      set column flag
        /**/
        if ( ( pcolumndef->grbit & JET_bitColumnAutoincrement ) != 0 )
                {
                /*      it is an autoinc column that we want to add
                /**/
                if ( pfcb->pfdb->fidAutoInc != 0 )
                        {
                        /*      there is already an autoinc column for the table.
                        /*      and we don't allow two autoinc columns for one table.
                        /**/
                        err = JET_errColumn2ndSysMaint;
                        goto HandleError;
                        }
                if ( coltyp != JET_coltypLong )
                        {
                        err = JET_errInvalidParameter;
                        goto HandleError;
                        }
                /*      autoincrement cannot be tagged
                /**/
                if ( pcolumndef->grbit & JET_bitColumnTagged )
                        {
                        err = JET_errCannotBeTagged;
                        goto HandleError;
                        }
                pfdd->bFlags |= ffieldAutoInc;
                }

        pfdd->bColtyp = (BYTE) coltyp;
        if ( coltyp == JET_coltypText || coltyp == JET_coltypLongText )
                {
                pfdd->cp                  =  cp;
                pfdd->langid  =  langid;
                pfdd->wCountry = wCountry;
                }

        if ( pcolumndef->grbit & JET_bitColumnNotNULL )
                pfdd->bFlags |= ffieldNotNull;

        if ( pcolumndef->grbit & JET_bitColumnMultiValued )
                pfdd->bFlags |= ffieldMultivalue;

        // ====================================================
        // Determine maximum field length as follows:
        // switch (field type)
        //         case numeric:
        //                 max = <exact length of specified type>;
        //         case "short" textual (Text || CaseText || Binary ):
        //                 if (specified max == 0 ) max = JET_cbColumnMost
        //                 else max = MIN( JET_cbColumnMost, specified max )
        //         case "long" textual (Memo || Graphic ):
        //                 max = specified max (if 0, unlimited )
        //====================================================
        switch ( coltyp )
                {
                case JET_coltypBit:
                case JET_coltypUnsignedByte:
                        pfdd->ulLength = 1;
                        break;
                case JET_coltypShort:
                        pfdd->ulLength = 2;
                        break;
                case JET_coltypLong:
                case JET_coltypIEEESingle:
                        pfdd->ulLength = 4;
                        break;
                case JET_coltypCurrency:
                case JET_coltypIEEEDouble:
                case JET_coltypDateTime:
                        pfdd->ulLength = 8;
                        break;
                case JET_coltypBinary:
                case JET_coltypText:
                        if ( ulLength == 0 )
                                pfdd->ulLength = JET_cbColumnMost;
                        else if ((pfdd->ulLength = ulLength ) > JET_cbColumnMost )
                                {
                                pfdd->ulLength = JET_cbColumnMost;
                                fMaxTruncated = fTrue;
                                }
                        break;
                case JET_coltypLongBinary:
                case JET_coltypLongText:
                        pfdd->ulLength = ulLength;
                        break;
                }

        if ( ( pfdd->cbDefault = CbLine( plineDefault ) ) > 0 )
                memcpy( pfdd->rgbDefault, plineDefault->pb, plineDefault->cb );
        strcpy( pfdd->szFieldName, szColumn );

        //====================================================
        // Determine field "mode" as follows:
        // if ("long" textual || JET_bitColumnTagged given ) ==> TAGGED
        // else if (numeric type || JET_bitColumnFixed given ) ==> FIXED
        // else ==> VARIABLE
        //====================================================
        if ( coltyp == JET_coltypLongBinary ||
                coltyp == JET_coltypLongText ||
                ( pcolumndef->grbit & JET_bitColumnTagged ) )
                {
                pfdd->fid = ++fielddata.fidTaggedLast;
                if ( pfdd->fid > fidTaggedMost )
                        Call( JET_errTooManyColumns );
                }
        else if ( ( pcolumndef->grbit & JET_bitColumnFixed ) ||
                         coltyp == JET_coltypBit ||
                         coltyp == JET_coltypUnsignedByte ||
                         coltyp == JET_coltypShort ||
                         coltyp == JET_coltypLong ||
                         coltyp == JET_coltypCurrency ||
                         coltyp == JET_coltypIEEESingle ||
                         coltyp == JET_coltypIEEEDouble ||
                         coltyp == JET_coltypDateTime )
                {
                pfdd->fid = ++fielddata.fidFixedLast;
                if ( pfdd->fid > fidFixedMost )
                        Call( JET_errTooManyFixedColumns );
                }
        else
                {
                pfdd->fid = ++fielddata.fidVarLast;
                if ( pfdd->fid > fidVarMost )
                        Call( JET_errTooManyVariableColumns );
                }

        /*      replace "FIELDS" node data with updated version
        /**/
        line.cb = sizeof(FIELDDATA);
        line.pb = (BYTE *)&fielddata;
        Call( ErrDIRReplace( pfucb, &line, fDIRVersion ) );

        /*      add field descriptor node, go back to "FIELDS" node
        /*      "key" still points to the case-folded field name
        /**/
        line.pb = (BYTE *)  pfdd;
        line.cb = sizeof( *pfdd ) + pfdd->cbDefault - 1;
        Call( ErrDIRInsert( pfucb, &line, &key, fDIRVersion ) );
        DIRUp( pfucb, 1 );

        if ( pcolumnid != NULL )
                *pcolumnid = (JET_COLUMNID)pfdd->fid;

        /*      rebuild FDB and default record value
        /**/
//      pfdbSav = pfcb->pfdb;
        Call( ErrDIRGet( pfucb ) );
        Call( ErrFDBConstruct( pfucb, pfcb, fTrue/*fBuildDefault*/ ) );
//      fFDBConstruct = fTrue;

        /*      set currencies at BeforeFirst
        /**/
        DIRUp( pfucb, 1 );
        DIRBeforeFirst( pfucb );
        if ( pfucb->pfucbCurIndex != pfucbNil )
                {
                DIRBeforeFirst( pfucb->pfucbCurIndex );
                }

#ifdef  SYSTABLES
        /*      insert column record into MSC before committing...
        /**/
        if ( fDoSTI )
                {
                LINE                            rgline[ilineSxMax];
                JET_TABLEID             objidTable                      =       pfucb->u.pfcb->pgnoFDP;
                BYTE                            coltypTemp                      =       (BYTE) coltyp;
                JET_COLUMNID    columnid                                =       (JET_COLUMNID)pfdd->fid;
                BYTE                            fAutoincrement          =       (BYTE) ( ( pcolumndef->grbit & JET_bitColumnAutoincrement ) ? 0xff : 0x00 );
                BYTE                            fRestricted                     =       0;
                BYTE                            fDisallowNull           =       0;
                BYTE                            fVersion                                =       (BYTE)( pcolumndef->grbit & JET_bitColumnVersion );
                LONG                            lPOrder;

                /*      set presentation order from number of existing columns
                /**/
#ifdef CHRONOLOGICAL_PRESENTATION_ORDER
                lPOrder = ( fielddata.fidFixedLast == fidFixedLeast - 1 ?
                        0 : fielddata.fidFixedLast - fidFixedLeast + 1 ) +
                        ( fielddata.fidVarLast == fidVarLeast - 1 ?
                        0 : fielddata.fidVarLast - fidVarLeast + 1 ) +
                        ( fielddata.fidTaggedLast == fidTaggedLeast - 1 ?
                        0 : fielddata.fidTaggedLast - fidTaggedLeast + 1 );
#else
                lPOrder = 0;
#endif

                rgline[iMSC_ObjectId].pb                                = (BYTE *)&objidTable;
                rgline[iMSC_ObjectId].cb                                = sizeof(objidTable);
                rgline[iMSC_Name].pb                                            = szColumn;
                rgline[iMSC_Name].cb                                            = strlen(szColumn);
                rgline[iMSC_ColumnId].pb                                = (BYTE *)&columnid;
                rgline[iMSC_ColumnId].cb                                = sizeof(columnid);
                rgline[iMSC_Coltyp].pb                                  = &coltypTemp;
                rgline[iMSC_Coltyp].cb                                  = sizeof(coltypTemp);
                rgline[iMSC_FAutoincrement].pb          = &fAutoincrement;
                rgline[iMSC_FAutoincrement].cb          = sizeof(BYTE);
                rgline[iMSC_FDisallowNull].pb                   = &fDisallowNull;
                rgline[iMSC_FDisallowNull].cb                   = sizeof(BYTE);
                rgline[iMSC_FVersion].pb                                = &fVersion;
                rgline[iMSC_FVersion].cb                                = sizeof(BYTE);
                rgline[iMSC_CodePage].pb                                = (BYTE *)&cp;
                rgline[iMSC_CodePage].cb                                = sizeof(cp);
                rgline[iMSC_LanguageId].pb                              = (BYTE *)&langid;
                rgline[iMSC_LanguageId].cb                              = sizeof(langid);
                rgline[iMSC_Country].pb                                 = (BYTE *)&wCountry;
                rgline[iMSC_Country].cb                                 = sizeof(wCountry);
                rgline[iMSC_FRestricted].pb                     = &fRestricted;
                rgline[iMSC_FRestricted].cb                     = sizeof(BYTE);
                rgline[iMSC_RmtInfoShort].cb                    = 0;
                rgline[iMSC_RmtInfoLong].cb                     = 0;
                rgline[iMSC_Description].cb                     = 0;
                rgline[iMSC_LvExtra].cb                                 = 0;
                rgline[iMSC_POrder].pb                                  = (BYTE *)&lPOrder;
                rgline[iMSC_POrder].cb                                  = sizeof(lPOrder);

                Call( ErrSysTabInsert( ppib, pfucb->dbid, itableSc, rgline, objidTable ) );
                }
#endif  /* SYSTABLES */

        if ( ( pcolumndef->grbit & JET_bitColumnAutoincrement ) != 0 )
                {
                DIB dib;

                dib.pos = posDown;
                dib.fFlags = fDIRNull;
                dib.pkey = &key;

                /*      it is an autoinc column that we want to add
                /*      make sure there are no data records
                /*      down to sequential node, down to Data node
                /**/
                DIRGotoFDPRoot( pfucb );
                Call( ErrDIRSeekPath( pfucb, 1, pkeyIndexes, 0 ) );
                Call( ErrDIRGet(pfucb) );

                /*      go down to the NULL node (for system-assigned clustering index )
                /*      or go down to the <clustering-index name> node (for user-defined
                /*      clustering index )
                /**/
                if ( FLineNull( &pfucb->lineData ) )
                        {
                        /* "sequential" file
                        /**/
                        pfcb->pidb = pidbNil;

                        /*      down to <NULL> node
                        /**/
                        Assert( dib.pos == posDown );
                        Assert( dib.fFlags == fDIRNull );
                        Assert( dib.pkey == &key );
                        key.cb = 0;
                        if ( ( err = ErrDIRDown( pfucb, &dib ) ) != JET_errSuccess )
                                {
                                if ( err > 0 )
                                        err = JET_errDatabaseCorrupted;
                                Error( err, HandleError );
                                }
                        }
                else
                        {
                        /*      file has clustering index
                        /**/
                        CHAR    rgbIndexName[(JET_cbNameMost + 1)];
                        ULONG   cbIndexName;

                        cbIndexName = pfucb->lineData.cb;
                        Assert( cbIndexName < ( JET_cbNameMost + 1 ) );
                        memcpy( rgbIndexName, pfucb->lineData.pb, cbIndexName );

                        /*      down to clustered index root
                        /**/
                        Assert( dib.pos == posDown );
                        Assert( dib.fFlags == fDIRNull );
                        Assert( dib.pkey == &key );
                        dib.pkey->cb = cbIndexName;
                        dib.pkey->pb = rgbIndexName;
                        if ( ( err = ErrDIRDown( pfucb, &dib ) ) != JET_errSuccess )
                                {
                                if ( err > 0 )
                                        err = JET_errDatabaseCorrupted;
                                Error( err, HandleError );
                                }
                        }

                /*      see if table is empty
                /**/
                Call( ErrDIRSeekPath( pfucb, 1, pkeyData, 0 ) );
                dib.pos = posFirst;
                err = ErrDIRDown( pfucb, &dib );
                if ( err < 0 && err != JET_errRecordNotFound )
                        {
                        goto HandleError;
                        }
                if ( err != JET_errRecordNotFound )
                        {
                        ULONG           ul = 1;
                        LINE            lineAutoInc;
                        FID             fidAutoIncTmp = pfucb->u.pfcb->pfdb->fidAutoInc;

                        do
                                {
                                Call( ErrIsamPrepareUpdate( ppib, pfucb, JET_prepReplace ) );
                                PrepareInsert( pfucb );
                                Call( ErrIsamSetColumn( ppib, pfucb, (ULONG) fidAutoIncTmp, (BYTE *) &ul, sizeof(ul), 0, NULL ) );
                                PrepareReplace( pfucb );
                                Call( ErrIsamUpdate( ppib, pfucb, 0, 0, 0 ) );
                                ul++;
                                err = ErrIsamMove( ppib, pfucb, JET_MoveNext, 0 );
                                if ( err < 0 && err != JET_errNoCurrentRecord )
                                        goto HandleError;
                                }
                        while ( err != JET_errNoCurrentRecord );

                        /*      now ul has the correct value for the next autoinc field.
                        /*      replace the value in the autoinc node in FDP
                        /**/
                        // UNDONE: should be able to delete the loop
                        Assert( PcsrCurrent( pfucb ) != NULL );
                        while ( PcsrCurrent( pfucb )->pcsrPath != NULL )
                                {
                                DIRUp( pfucb, 1 );
                                }

                        /*      go down to AutoInc node
                        /**/
                        DIRGotoFDPRoot( pfucb );
                        err = ErrDIRSeekPath( pfucb, 1, pkeyAutoInc, 0 );
                        if ( err != JET_errSuccess )
                                {
                                if ( err > 0 )
                                        err = JET_errDatabaseCorrupted;
                                Error( err, HandleError );
                                }
                        lineAutoInc.pb = (BYTE *) &ul;
                        lineAutoInc.cb = sizeof(ul);
                        CallS( ErrDIRReplace( pfucb, &lineAutoInc, fDIRNoVersion ) );
                        }

                /*      leave currency as it was
                /**/
                Assert( PcsrCurrent( pfucb ) != NULL );
                while ( PcsrCurrent( pfucb )->pcsrPath != NULL )
                        {
                        DIRUp( pfucb, 1 );
                        }

                DIRBeforeFirst( pfucb );
                }

        Call( ErrDIRCommitTransaction( ppib ) );

        SFree( pfdd );
        pfdd = NULL;

        /*      update all index mask.
        /**/
        FILESetAllIndexMask( pfcb );

        return fMaxTruncated ? JET_wrnColumnMaxTruncated : JET_errSuccess;

HandleError:
        if ( pfdd != NULL )
                {
                SFree( pfdd );
                }

        CallS( ErrDIRRollback( ppib ) );

        return err;
        }


ERR ErrFILEIUpdateFDPData( FUCB *pfucb, ULONG grbit )
        {
#define cbFDPDataMax    256
        ERR             err;
        BYTE            rgbData[ cbFDPDataMax ];
        LINE            line;

        Call( ErrDIRGet( pfucb ) );

        Assert( pfucb->lineData.cb <= sizeof rgbData );
        Assert( pfucb->lineData.cb > 2 * sizeof(WORD) + 2 * sizeof(JET_DATESERIAL) );
        line.pb = rgbData;
        LineCopy( &line, &pfucb->lineData );

        if ( grbit & fBumpIndexCount )
                *(WORD *)rgbData += 1;
        if ( grbit & fDropIndexCount )
                *(WORD *)rgbData -= 1;
        if ( grbit & fDDLStamp )
                {
                JET_DATESERIAL dtNow;
                UtilGetDateTime( &dtNow );
                memcpy( rgbData + 2 * sizeof(WORD) + sizeof(JET_DATESERIAL), &dtNow, sizeof(JET_DATESERIAL) );
                }
        err = ErrDIRReplace( pfucb, &line, fDIRVersion );

HandleError:
        return err;
        }



//+API
// ErrIsamCreateIndex
// ========================================================================
// ERR ErrIsamCreateIndex(
//              PIB             *ppib;                  // IN   PIB of user
//              FUCB    *pfucb;                 // IN   Exclusively opened FUCB of file
//              CHAR    *szName;                // IN   name of index to define
//              ULONG   ulFlags;                // IN   index describing flags
//              CHAR    *szKey;                 // IN   index key string
//              ULONG   cchKey;
//              ULONG   ulDensity );    // IN   loading density of index
//
//      Defines an index on a file.
//
// PARAMETERS
//              ppib            PIB of user
//              pfucb           Exclusively opened FUCB of file
//              szName          name of index to define
//              ulFlags         index describing flags
//                      VALUE                           MEANING
//                      ========================================
//                      JET_bitIndexPrimary             This index is to be the primary
//                                                                      index on the data file.  The file
//                                                                      must be empty, and there must not
//                                                                      already be a primary index.
//                      JET_bitIndexUnique              Duplicate entries are not allowed.
//                      JET_bitIndexIgnoreNull  Null keys are not to be indexed.
//                      ulDensity                               load density of index
//
// RETURNS      Error code from DIRMAN or
//                      JET_errSuccess                  Everything worked OK.
//                      -JET_errColumnNotFound  The index key specified
//                                                                      contains an undefined field.
//                      -IndexHasPrimary                The primary index for this
//                                                                      Insertfile is already defined.
//                      -IndexDuplicate                 An index on this file is
//                                                                      already defined with the
//                                                                      given name.
//                      -IndexInvalidDef                There are too many segments
//                                                                      in the key.
//                      -TableNotEmpty                  A primary index may not be
//                                                                      defined because there is at
//                                                                      least one record already in
//                                                                      the file.
// COMMENTS
//              If transaction level > 0, there must not be anyone currently
//              using the file.
//              A transaction is wrapped around this function.  Thus, any
//              work done will be undone if a failure occurs.
//
// SEE ALSO             ErrIsamAddColumn, ErrIsamCreateTable
//-
ERR VTAPI ErrIsamCreateIndex(
        PIB                                     *ppib,
        FUCB                            *pfucb,
        CHAR                            *szName,
        ULONG                           grbit,
        CHAR                            *szKey,
        ULONG                           cchKey,
        ULONG                           ulDensity )
        {
        CHAR                            szIndex[ (JET_cbNameMost + 1) ];
        FCB                                     *pfcbIdx = pfcbNil;
        INT                                     cFields;
        char                            *rgsz[JET_ccolKeyMost];
        const BYTE                      *pb;
        BYTE                            rgfbDescending[JET_ccolKeyMost];
        INDEXDEFDATA            idd;
        INT                                     iidxseg;
        FID                                     fid;
        BOOL                            fClustered = ((grbit & JET_bitIndexClustered) != 0);
        KEY                                     keyIndex;
        KEY                                     line;
        ERR                                     err;
        PGNO                            pgnoIdxRoot;
        INT                                     itagIdxRoot;
        BYTE                            rgbIndexNorm[ JET_cbKeyMost ];
        FCB                                     *pfcb;
        BOOL                            fVersion;
        //      UNDONE: get language information from database
        LANGID                          langid = 0x409;
        BOOL                            fLangid = fFalse;

#ifdef  SYSTABLES
        BOOL                            fDoSTI;

        /* do not allow clustered indexes with any Ignore bits on
        /**/
        if ( fClustered && ( grbit & JET_bitIndexIgnoreAnyNull || grbit & JET_bitIndexIgnoreNull ) )
                return JET_errInvalidParameter;

        /*      set fDoSTI and fix DBID...
        /**/
        if ( pfucb->dbid >= dbidMax )
                {
                pfucb->dbid -= dbidMax;
                fDoSTI = 0;
                }
        else
                fDoSTI = 1;

        if ( FFCBTemporaryTable( pfucb->u.pfcb ) )
                fDoSTI = 0;
#endif  /* SYSTABLES */

        /* ensure that table is updatable
        /**/
        CallR( FUCBCheckUpdatable( pfucb )  );

        Assert ( !FFUCBNonClustered( pfucb ) );

        /*      check parms
        /**/
        CheckPIB( ppib );
        CheckTable( ppib, pfucb );

        /*      check index name
        /**/
        CallR( ErrCheckName( szIndex, szName, (JET_cbNameMost + 1) ) );

        /*      check index description for required format.
        /**/
        if ( cchKey == 0 )
                return JET_errInvalidParameter;
        if ( ( szKey[0] != '+' && szKey[0] != '-' ) ||
                szKey[cchKey - 1] != '\0' ||
                szKey[cchKey - 2] != '\0' )
                {
                return JET_errIndexInvalidDef;
                }
        Assert( szKey[cchKey - 1] == '\0' );
        Assert( szKey[cchKey - 2] == '\0' );

        Assert( pfucb->u.pfcb != pfcbNil );
        pfcb = pfucb->u.pfcb;
        if ( ulDensity == 0 )
                ulDensity = ulDefaultDensity;
        if ( ulDensity < ulFILEDensityLeast || ulDensity > ulFILEDensityMost )
                return JET_errDensityInvalid;

        cFields = 0;
        pb = szKey;
        while ( *pb != '\0' )
                {
                if ( cFields >= JET_ccolKeyMost )
                        return JET_errIndexInvalidDef;
                if ( *pb == '-' )
                        {
                        rgfbDescending[cFields] = 1;
                        pb++;
                        }
                else
                        {
                        rgfbDescending[cFields] = 0;
                        if ( *pb == '+' )
                                pb++;
                        }
                rgsz[cFields++] = (char *) pb;
                pb += strlen( pb ) + 1;
                }
        if ( cFields < 1 )
                return JET_errIndexInvalidDef;

        /*      get locale from end of szKey if present
        /**/
        pb++;
        Assert( pb > szKey );
        if ( (unsigned)( pb - szKey ) < cchKey )
                {
                if ( pb - szKey + sizeof(LANGID) + 2 * sizeof(BYTE) == cchKey )
                        {
                        langid = *((UNALIGNED LANGID *)(pb));
                        CallR( ErrSysCheckLangid( langid ) );
                        fLangid = fTrue;
                        }
                else
                        return JET_errIndexInvalidDef;
                }

        /* return an error if this is a second primary index definition
        /**/
        if ( grbit & JET_bitIndexPrimary )
                {
                FCB *pfcbNext = pfcb;

                while ( pfcbNext != pfcbNil )
                        {
                        if ( pfcbNext->pidb != pidbNil && ( pfcbNext->pidb->fidb & fidbPrimary ) )
                                {
                                // If that primary index is not already deleted transaction
                                // but not yet committed.
                                if ( !FFCBDeletePending( pfcbNext ) )
                                        return JET_errIndexHasPrimary;
                                else
                                        // can break because there can only be one Primary index
                                        break;
                                }
                        Assert( pfcbNext != pfcbNext->pfcbNextIndex );
                        pfcbNext = pfcbNext->pfcbNextIndex;
                        }
                }

        /*      normalize index name and set key
        /**/
        SysNormText( szIndex, strlen( szIndex ), rgbIndexNorm, sizeof( rgbIndexNorm ), &keyIndex.cb );
        keyIndex.pb = rgbIndexNorm;

        CallR( ErrDIRBeginTransaction( ppib ) );

        if ( FFCBDenyDDL( pfcb, ppib ) )
                {
                /* abort if DDL modification in progress
                /**/
                err = JET_errWriteConflict;
                Call( err );
                }
        FCBSetDenyDDL( pfcb, ppib );

        /*      allocate FCB for index
        /**/
        pfcbIdx = NULL;
        if ( !fClustered )
                {
                err = ErrFCBAlloc( ppib, &pfcbIdx );
                if ( err < 0 )
                        {
                        FCBResetDenyDDL( pfcb );
                        goto HandleError;
                        }
                }

        /* wait for bookmark cleanup
        /* UNDONE: decouple operation from other index creations
        /**/
        while ( FFCBDomainOperation( pfcb ) )
                {
                BFSleep( cmsecWaitGeneric );
                }
        FCBSetDomainOperation( pfcb );
                
        /*      create index is flagged in version store so that
        /*      DDL will be undone.  If flag fails then pfcbIdx
        /*      must be released.
        /**/
        err = ErrVERFlag( pfucb, operCreateIndex, &pfcbIdx, sizeof(pfcbIdx) );
        if ( err < 0 )
                {
                FCBResetDenyDDL( pfcb );
                if ( !fClustered )
                        {
                        Assert( pfcbIdx != NULL );
                        Assert( pfcbIdx->cVersion == 0 );
                        MEMReleasePfcb( pfcbIdx );
                        }
                goto HandleError;
                }

        if ( ppib->level == 1 )
                {
                WaitTillOldest( ppib->trx );
                }

        /*      move to FDP root
        /**/
        DIRGotoFDPRoot( pfucb );

        /*      if this is not the clustered index, increment the index count
        /**/
        if ( !fClustered )
                {
                Call( ErrFILEIUpdateFDPData( pfucb, fBumpIndexCount | fDDLStamp ) );
                }

        /*      goto fields to get FID's
        /**/
        Call( ErrDIRSeekPath( pfucb, 1, pkeyFields, 0 ) );

        /*      get FID for each field
        /**/
        for ( iidxseg = 0 ; iidxseg < cFields ; ++iidxseg )
                {
                BYTE                    rgbColumnNorm[ JET_cbKeyMost ];
                KEY                     keyColumn;
                JET_COLTYP      coltyp;

                /*      normalize column name set key
                /**/
                SysNormText( rgsz[iidxseg], strlen( rgsz[iidxseg] ), rgbColumnNorm, sizeof( rgbColumnNorm ), &keyColumn.cb );
                keyColumn.pb = rgbColumnNorm;

                err = ErrDIRSeekPath( pfucb, 1, &keyColumn, 0 );
                Assert( err != JET_errNoCurrentRecord );
                if ( err < 0 )
                        {
                        if (err == JET_errRecordNotFound)
                                err = JET_errColumnNotFound;
                        goto HandleError;
                        }
                fid = ((FIELDDEFDATA *)pfucb->lineData.pb)->fid;
                coltyp = (JET_COLTYP)((FIELDDEFDATA *)pfucb->lineData.pb )->bColtyp;
//              if ( coltyp == JET_coltypLongBinary     || coltyp == JET_coltypLongText )
//                      {
//                      err = JET_errColumnCannotIndex;
//                      goto HandleError;
//                      }
                idd.rgidxseg[iidxseg] = rgfbDescending[iidxseg] ? -fid : fid;
                DIRUp( pfucb, 1 );
                }

        /*      go over to "INDEXES"
        /**/
        DIRUp( pfucb, 1 );
        Call( ErrDIRSeekPath( pfucb, 1, pkeyIndexes, 0 ) );

        /*      add index, checking for duplicate definition
        /**/
        idd.iidxsegMac = (BYTE)cFields;
        idd.bDensity = (BYTE)ulDensity;
        idd.bFlags = 0;
        if ( grbit & JET_bitIndexPrimary )
                idd.bFlags |= fidbPrimary | fidbUnique | fidbNoNullSeg;
        if ( grbit & JET_bitIndexUnique )
                idd.bFlags |= fidbUnique;
        if ( grbit & JET_bitIndexDisallowNull )
                idd.bFlags |= fidbNoNullSeg;
        if ( ! ( idd.bFlags & fidbNoNullSeg ) && !( grbit & JET_bitIndexIgnoreAnyNull ) )
                {
                idd.bFlags |= fidbAllowSomeNulls;
                if ( !( grbit & JET_bitIndexIgnoreNull ) )
                        idd.bFlags |= fidbAllowAllNulls;
                }
        strcpy( idd.szIndexName, szIndex );

        /*      set locale information
        /**/
        //      UNDONE: idd should not have a code page
        //      UNDONE: idd should not have a country code
        idd.cp = 0;
        idd.wCountry = 0;
        if ( fLangid )
                {
                idd.bFlags |= fidbLangid;
                idd.langid = langid;
                }
        else
                {
                Assert( ( idd.bFlags & fidbLangid ) == 0 );
                idd.langid = 0;
                }

        line.pb = (BYTE *)&idd;
        line.cb = (UINT)((BYTE *)( idd.rgidxseg + cFields ) - (BYTE *)&idd);
        if ( fClustered )
                {
                err = ErrDIRInsert( pfucb, &line, &keyIndex, fDIRVersion );
                /*      polymorph error.
                /**/
                if ( err < 0 )
                        {
                        if ( err == JET_errKeyDuplicate )
                                err = JET_errIndexDuplicate;
                        goto HandleError;
                        }

                fVersion = fDIRVersion;
                }
        else
                {
                err = ErrDIRInsertFDP( pfucb, &line, &keyIndex, fDIRVersion, (CPG)0 );
                /*      polymorph error.
                /**/
                if ( err < 0 )
                        {
                        if ( err == JET_errKeyDuplicate )
                                err = JET_errIndexDuplicate;
                        goto HandleError;
                        }

                fVersion = fDIRNoVersion;

                /*      index/OLCStats
                /**/
                line.pb = (BYTE *) &olcStatsInit;
                line.cb = sizeof( olcStatsInit );
                Call( ErrDIRInsert( pfucb, &line, pkeyOLCStats, fDIRNoVersion | fDIRBackToFather) );
                }

        /*      index/data
        /**/
        Call( ErrDIRInsert( pfucb, &lineNull, pkeyData, fVersion ) );
        pgnoIdxRoot = PcsrCurrent( pfucb )->pgno;
        itagIdxRoot = PcsrCurrent( pfucb )->itag;

        DIRUp( pfucb, 2 );

        /*      deal with clustered index definition
        /**/
        if ( fClustered )
                {
                DIB dib;

                Call( ErrDIRGet( pfucb ) );

                /*      if lineData.cb then clustered index already defined
                /**/
                if ( pfucb->lineData.cb != 0 )
                        {
                        err = JET_errIndexHasClustered;
                        goto HandleError;
                        }

                /*      replace NULL data with clustered index key
                /**/
                line.pb = keyIndex.pb;
                line.cb = keyIndex.cb;
                Call( ErrDIRReplace( pfucb, &line, fVersion ) );

                /*      down to sequential node, down to Data node
                /**/
                Call( ErrDIRSeekPath( pfucb, 1, (KEY *) &lineNull, 0 ) );
                Call( ErrDIRSeekPath( pfucb, 1, pkeyData, 0 ) );

                /*      make sure there are no data records
                /**/
                dib.pos = posFirst;
                if ( ( err = ErrDIRDown(pfucb, &dib ) ) != JET_errRecordNotFound )
                        {
                        err = JET_errTableNotEmpty;
                        goto HandleError;
                        }

                /*      up to NULL and delete.  Delete should delete all
                /*      decendants of NULL.
                /**/
                DIRUp( pfucb, 1 );
                Call( ErrDIRDelete( pfucb, fVersion ) );
                DIRUp( pfucb, 1 );
                }

#ifdef  SYSTABLES
        /*      insert index record into MSysIndexes before committing.
        /**/
        if ( fDoSTI )
                {
                LINE    rgline[ilineSxMax];
                OBJID   objidTable              = pfucb->u.pfcb->pgnoFDP;
                BOOL    fUnique                 = grbit & JET_bitIndexUnique;
                BOOL    fPrimary                        = grbit & JET_bitIndexPrimary;
                BOOL    fDisallowNull   = grbit & JET_bitIndexDisallowNull;
                BOOL    fIgnoreNull             = grbit & JET_bitIndexIgnoreNull;
                BOOL    fClustered              = grbit & JET_bitIndexClustered;

                rgline[iMSI_ObjectId].pb                                        = (BYTE *)&objidTable;
                rgline[iMSI_ObjectId].cb                                        = sizeof(objidTable);
                rgline[iMSI_Name].pb                                                    = szIndex;
                rgline[iMSI_Name].cb                                                    = strlen(szIndex);
                rgline[iMSI_FUnique].pb                                         = (BYTE *)&fUnique;
                rgline[iMSI_FUnique].cb                                         = sizeof(BYTE);
                rgline[iMSI_FPrimary].pb                                        = (BYTE *)&fPrimary;
                rgline[iMSI_FPrimary].cb                                        = sizeof(BYTE);
                rgline[iMSI_FDisallowNull].pb                           = (BYTE *)&fDisallowNull;
                rgline[iMSI_FDisallowNull].cb                           = sizeof(BYTE);
                rgline[iMSI_FExcludeAllNull].pb                 = (BYTE *)&fIgnoreNull;
                rgline[iMSI_FExcludeAllNull].cb                 = sizeof(BYTE);
                rgline[iMSI_FClustered].pb                              = (BYTE *)&fClustered;
                rgline[iMSI_FClustered].cb                              = sizeof(BYTE);
                rgline[iMSI_MatchType].cb                               = 0;
                rgline[iMSI_UpdateAction].cb                    = 0;
                rgline[iMSI_DeleteAction].cb                    = 0;
                rgline[iMSI_ObjectIdReference].cb               = 0;
                rgline[iMSI_IdxidReference].cb                  = 0;
                rgline[iMSI_RgkeydReference].cb                 = 0;
                rgline[iMSI_RglocaleReference].cb               = 0;
                rgline[iMSI_FDontEnforce].cb                    = 0;
                rgline[iMSI_RmtInfoShort].cb                    = 0;
                rgline[iMSI_RmtInfoLong].cb                     = 0;
                rgline[iMSI_LvExtra].cb                                         = 0;
                rgline[iMSI_Description].cb                             = 0;
                rgline[iMSI_Density].pb                                         = (BYTE *) &ulDensity;
                rgline[iMSI_Density].cb                                         = sizeof(ulDensity);
//              rgline[iMSI_LanguageId].pb                                      = (BYTE *)&langid;
//              rgline[iMSI_LanguageId].cb                                      = sizeof(langid);
                Call( ErrSysTabInsert( ppib, pfucb->dbid, itableSi, rgline, objidTable ) );
                }
#endif  /* SYSTABLES */

        /*      now at "INDEXES" node
        /**/
        if ( fClustered )
                {
                /*      remove extra CSR
                /**/
                DIRUp( pfucb, 1 );
                Call( ErrRECNewIDB( &pfcb->pidb ) );
                Call( ErrRECAddKeyDef(
                        (FDB *)pfcb->pfdb,
                        pfcb->pidb,
                        idd.iidxsegMac,
                        idd.rgidxseg,
                        idd.bFlags,
                        idd.langid ) );
                strcpy( pfcb->pidb->szName, szIndex );
                pfcb->pgnoRoot = pgnoIdxRoot;
                pfcb->itagRoot = itagIdxRoot;
                pfcb->bmRoot = SridOfPgnoItag( pgnoIdxRoot, itagIdxRoot );
                pfcb->cbDensityFree = ( ( 100 - idd.bDensity ) * cbPage ) / 100;

                /*      replace empty sequential STATS with empty clustered stats
                /**/
                //      UNDONE: defer creation of index stats when
                //                              movable DATA node
                Call( ErrSTATComputeIndexStats( ppib, pfcb ) );

                /*      restore current to BeforeFirst
                /**/
                DIRBeforeFirst( pfucb );
                }
        else
                {
                Call( ErrDIRSeekPath( pfucb, 1, &keyIndex, 0 ) );
                Call( ErrFILEIFillIn2ndIdxFCB( pfucb, (FDB *)pfcb->pfdb, pfcbIdx ) );
                pfcbIdx->pfcbNextIndex = pfcb->pfcbNextIndex;
                pfcb->pfcbNextIndex = pfcbIdx;
                DIRUp( pfucb, 2 );

                /*      build STATS node for new index
                /**/
                //      UNDONE: defer creation of index stats when
                //                              movable DATA node
                Call( ErrSTATComputeIndexStats( ppib, pfcbIdx ) );

                /*      move currency to before first
                /**/
                DIRBeforeFirst( pfucb );
                }

        if ( !fClustered )
                {
                Call( ErrFILEBuildIndex( ppib, pfucb, szIndex ) );
                }

        Call( ErrDIRCommitTransaction( ppib ) );

        /*      update all index mask.
        /**/
        FILESetAllIndexMask( pfcb );
        FCBResetDomainOperation( pfcb );

        return err;

HandleError:
        CallS( ErrDIRRollback( ppib ) );
        FCBResetDomainOperation( pfcb );

        return err;
        }


//+API
// BuildIndex
// ========================================================================
// ERR BuildIndex( PIB *ppib, FUCB *pfucb, CHAR *szIndex )
//
// Builds a new index for a file from scratch;  szIndex gives the
// name of an index definition.
//
// PARAMETERS   ppib                                            PIB of user
//                                      pfucb                                           Exclusively opened FUCB on file
//                                      szIndex                                         name of index to build
//
// RETURNS              Error code from DIRMAN or SORT or
//                                      JET_errSuccess                  Everything worked OK.
//                                      IndexCantBuild                  The index name specfied refers
//                                                                                              to the primary index.
// COMMENTS
//                      A transaction is wrapped around this function at the callee.
//
// SEE ALSO             ErrIsamCreateIndex
//-
ERR ErrFILEBuildIndex( PIB *ppib, FUCB *pfucb, CHAR *szIndex )
        {
        ERR             err;
        CHAR            szIdxOrig[ (JET_cbNameMost + 1) ];
        INT             fDIRFlags;
        INT             fDIRWithBackToFather;
        FUCB            *pfucbIndex = pfucbNil;
        FUCB            *pfucbSort = pfucbNil;
        DIB             dib;
        FDB             *pfdb;
        IDB             *pidb;
        LINE            rgline[2];
        BYTE            rgbKey[JET_cbKeyMost];
        SRID            sridData;
        ULONG           itagSequence;
        FCB             *pfcb;
        BOOL            fNoNullSeg;
        BOOL            fAllowNulls;
        BOOL            fAllowSomeNulls;
        INT             fUnique;
        LONG            cRecInput = 0;
        LONG            cRecOutput = 0;

        pfcb = pfucb->u.pfcb;

        CallS( ErrIsamGetCurrentIndex(ppib, pfucb, szIdxOrig, sizeof szIdxOrig ) );
        Call( ErrRECChangeIndex( pfucb, szIndex ) );
        pfucbIndex = pfucb->pfucbCurIndex;
        if ( pfucbIndex == pfucbNil )
                {
                err = JET_errIndexCantBuild;
                goto HandleError;
                }
        pfdb = (FDB *)pfcb->pfdb;
        pidb = pfucbIndex->u.pfcb->pidb;
        fNoNullSeg = ( pidb->fidb & fidbNoNullSeg ) ? fTrue : fFalse;
        fAllowNulls = ( pidb->fidb & fidbAllowAllNulls ) ? fTrue : fFalse;
        fAllowSomeNulls = ( pidb->fidb & fidbAllowSomeNulls ) ? fTrue : fFalse;
        fUnique = ( pidb->fidb & fidbUnique ) ? fSCBUnique : 0;

        /*      directory manager flags
        /**/
        fDIRFlags = fDIRNoVersion | fDIRAppendItem | ( fUnique ? 0 : fDIRDuplicate );
        fDIRWithBackToFather = fDIRFlags | fDIRBackToFather;

        /*      open sort
        /**/
        Call( ErrSORTOpen( ppib, &pfucbSort, fSCBIndex|fUnique ) );
        rgline[0].pb = rgbKey;
        rgline[1].cb = sizeof(SRID);
        rgline[1].pb = (BYTE *)&sridData;

        /*      build up new index in a sort file
        /**/
        dib.fFlags = fDIRNull;
        forever
                {
                err = ErrDIRNext( pfucb, &dib );
                if ( err < 0 )
                        {
                        if ( err == JET_errNoCurrentRecord )
                                break;
                        goto HandleError;
                        }

                Call( ErrDIRGet( pfucb ) );
                DIRGetBookmark( pfucb, &sridData );

                for ( itagSequence = 1; ; itagSequence++ )
                        {
                        KEY *pkey = &rgline[0];

                        Call( ErrRECExtractKey( pfucb, pfdb, pidb, &pfucb->lineData, pkey, itagSequence ) );
                        Assert( err == wrnFLDNullKey ||
                                err == wrnFLDOutOfKeys ||
                                err == wrnFLDNullSeg ||
                                err == JET_errSuccess );
                        if ( err == wrnFLDOutOfKeys )
                                {
                                Assert( itagSequence > 1 );
                                break;
                                }

                        if ( fNoNullSeg && ( err == wrnFLDNullSeg || err == wrnFLDNullKey ) )
                                {
                                err = JET_errNullKeyDisallowed;
                                goto HandleError;
                                }

                        if ( err == wrnFLDNullKey )
                                {
                                if ( fAllowNulls )
                                        {
                                        Call( ErrSORTInsert( pfucbSort, rgline ) );
                                        cRecInput++;
                                        }
                                break;
                                }
                        else
                                {
                                /* do not insert keys with null segment, if so specified
                                /**/
                                if ( err == wrnFLDNullSeg && !fAllowSomeNulls )
                                        break;
                                }

                        Call( ErrSORTInsert( pfucbSort, rgline ) );
                        cRecInput++;

                        if ( !( pidb->fidb & fidbHasMultivalue ) )
                                break;

                        /*      currency may have been lost so refresh record for
                        /*      next tagged column
                        /**/
                        Call( ErrDIRGet( pfucb ) );
                        }
                }
        Call( ErrSORTEndRead( pfucbSort ) );

        /*      transfer index entries to actual index
        /*      insert first one in normal method!
        /**/
        if ( ( err = ErrSORTNext( pfucbSort ) ) == JET_errNoCurrentRecord )
                goto Done;
        if ( err < 0 )
                goto HandleError;
        cRecOutput++;

        /*      move to FDP root
        /**/
        DIRGotoDataRoot( pfucbIndex );
        Call( ErrDIRInsert( pfucbIndex, &pfucbSort->lineData,
                &pfucbSort->keyNode, fDIRFlags ) );

#ifdef BULK_INSERT_ITEM
        Call( ErrDIRInitAppendItem( pfucbIndex ) );
#endif

        Assert( dib.fFlags == fDIRNull );
        dib.pos = posLast;

        /*      from now on, try short circuit first
        /**/
        forever
                {
                err = ErrSORTNext( pfucbSort );
                if ( err == JET_errNoCurrentRecord )
                        break;
                if ( err < 0 )
                        goto HandleError;
                cRecOutput++;
                err = ErrDIRAppendItem( pfucbIndex, &pfucbSort->lineData, &pfucbSort->keyNode );
                if ( err < 0 )
                        {
                        if ( err == errDIRNoShortCircuit )
                                {
                                DIRUp( pfucbIndex, 1 );
                                Call( ErrDIRInsert( pfucbIndex,
                                        &pfucbSort->lineData,
                                        &pfucbSort->keyNode,
                                        fDIRFlags ) );
                                /*      leave currency on inserted item list for
                                /*      next in page item append.
                                /**/
                                }
                        else
                                goto HandleError;
                        }
                }

#ifdef BULK_INSERT_ITEM
        Call( ErrDIRTermAppendItem( pfucbIndex ) );
#endif

        if ( fUnique && cRecOutput < cRecInput )
                {
                err = JET_errKeyDuplicate;
                goto HandleError;
                }

Done:
        Call( ErrSORTClose( pfucbSort ) );
        (VOID) ErrRECChangeIndex( pfucb, szIdxOrig );
        return JET_errSuccess;

HandleError:
        if ( pfucbIndex != pfucbNil && pfucbIndex->pbfWorkBuf != pbfNil )
                {
                BFSFree(pfucbIndex->pbfWorkBuf);
                pfucbIndex->pbfWorkBuf = pbfNil;
                }
        if ( pfucbSort != pfucbNil )
                {
                (VOID) ErrSORTClose( pfucbSort );
                }
        (VOID) ErrRECChangeIndex( pfucb, NULL );
        (VOID) ErrRECChangeIndex( pfucb, szIdxOrig );
        return err;
        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\fileopen.c ===
#include "config.h"

#include <stdlib.h>
#include <string.h>
#include <stddef.h>

#include "daedef.h"
#include "pib.h"
#include "ssib.h"
#include "page.h"
#include "fmp.h"
#include "fucb.h"
#include "fdb.h"
#include "fcb.h"
#include "stapi.h"
#include "idb.h"
#include "spaceapi.h"
#include "fileapi.h"
#include "fileint.h"
#include "util.h"
#include "dirapi.h"
#include "sortapi.h"
#include "systab.h"
#include "recapi.h"
#include "recint.h"
#include "dbapi.h"

DeclAssertFile;						/* Declare file name for assert macros */

extern SIG	sigDoneFCB;

//
// Internal routines
//
	ERR VTAPI
ErrIsamDupCursor( PIB *ppib, FUCB *pfucbOpen, FUCB **ppfucb, ULONG grbit )
	{
	ERR		err;
	FUCB 	*pfucb;
	CSR		*pcsr;
#ifdef	DISPATCHING
	JET_TABLEID	tableid;
#endif	/* DISPATCHING */

	CheckPIB( ppib );
	CheckTable( ppib, pfucbOpen );

	/*	silence warnings
	/**/
	grbit = grbit;

#ifdef	DISPATCHING

	/*	Allocate a dispatchable tableid
	/**/
	CallR( ErrAllocateTableid( &tableid, (JET_VTID) 0, &vtfndefIsam ) );
#endif	/* DISPATCHING */

	/*	allocate fucb
	/**/
	Call( ErrDIROpen( ppib, pfucbOpen->u.pfcb, 0, &pfucb ) );

	/*	reset copy buffer
	/**/
	pfucb->pbfWorkBuf = pbfNil;
	pfucb->lineWorkBuf.pb = NULL;
	Assert( !FFUCBUpdateSeparateLV( pfucb ) );
	Assert( !FFUCBUpdatePrepared( pfucb ) );

	/*	reset key buffer
	/**/
	pfucb->pbKey = NULL;
	KSReset( pfucb );

	/*	copy cursor flags
	/**/
	pfucb->wFlags |= fFUCBIndex;
	if ( FFUCBUpdatable( pfucbOpen ) )
		FUCBSetUpdatable( pfucb );
	else
		FUCBResetUpdatable( pfucb );

	/*	set currency before first node
	/**/
	pcsr = PcsrCurrent( pfucb );
	Assert( pcsr != pcsrNil );
	pcsr->csrstat = csrstatBeforeFirst;

	/*	move currency to the first record and ignore error if no records
	/**/
	err = ErrIsamMove( ppib, pfucb, JET_MoveFirst, 0 );
	if ( err < 0  )
		{
		if ( err != JET_errNoCurrentRecord )
			goto HandleError;
		err = JET_errSuccess;
		}

#ifdef	DISPATCHING
	/* Inform dispatcher of correct JET_VTID */
	CallS( ErrSetVtidTableid( (JET_SESID) ppib, tableid, (JET_VTID) pfucb ) );
	pfucb->fVtid = fTrue;
	*(JET_TABLEID *) ppfucb = tableid;
#else	/* !DISPATCHING */
	*ppfucb = pfucb;
#endif	/* !DISPATCHING */

	return JET_errSuccess;

HandleError:
#ifdef	DISPATCHING
	ReleaseTableid(tableid );
#endif	/* DISPATCHING */
	return err;
	}




	ERR VTAPI
ErrIsamOpenTable(
	PIB	*ppib,		// IN	PIB of who is opening file
	ULONG	vdbid,		// IN	database id
	FUCB	**ppfucb,	// OUT receives a new FUCB open on the file
	CHAR	*szPath,		// IN	path name of file to open
	ULONG	grbit )		// IN	lock exclusively?
	{
	ERR	err;
	DBID	dbid = DbidOfVDbid( ULongToPtr(vdbid) );
	FUCB	*pfucb = pfucbNil;
#ifdef	DISPATCHING
	JET_TABLEID  tableid;

	/*	Allocate a dispatchable tableid
	/**/
	CallR( ErrAllocateTableid( &tableid, (JET_VTID) 0, &vtfndefIsam ) );
#endif	/* DISPATCHING */

#ifdef PERISCOPE
	printf( "IsamOpenTBL( ppib=%lp, dbid= %lu, ppfucb=%lp, TBL=%s, grbit=%lu)\n",
		ppib, uldbid, ppfucb, szPath, grbit );
#endif

	Call( ErrFILEOpenTable( ppib, dbid, &pfucb, szPath, grbit ) );

	/* if database was opened read-only, so should the cursor */
	/**/
	if ( FVDbidReadOnly( ULongToPtr(vdbid) ) )
		FUCBResetUpdatable( pfucb );
	else
		FUCBSetUpdatable( pfucb );

#ifdef	DISPATCHING
	/* Inform dispatcher of correct JET_VTID */
	CallS( ErrSetVtidTableid( (JET_SESID) ppib, tableid, (JET_VTID) pfucb ) );
	pfucb->fVtid = fTrue;
	*(JET_TABLEID *) ppfucb = tableid;
#else	/* !DISPATCHING */
	*ppfucb = pfucb;
#endif	/* !DISPATCHING */

#ifdef PERISCOPE
	puts("\tIsamOpenTBL returns JET_errSuccess" );
#endif

	return JET_errSuccess;

HandleError:
#ifdef	DISPATCHING
	ReleaseTableid( tableid );
#endif	/* DISPATCHING */

#ifdef	SYSTABLES
	if ( err == JET_errObjectNotFound )
		{
		ERR			err;
		OBJID		objid;
		JET_OBJTYP	objtyp;

		err = ErrFindObjidFromIdName( ppib, dbid, objidTblContainer, szPath, &objid, &objtyp );

		if ( err >= 0 )
			{
			if ( objtyp == JET_objtypQuery )
				return JET_errQueryNotSupported;
			if ( objtyp == JET_objtypLink )
				return JET_errLinkNotSupported;
			if ( objtyp == JET_objtypSQLLink )
				return JET_errSQLLinkNotSupported;
			}
		else
			return err;
		}

#endif	/* SYSTABLES */

	return err;
	}




//+API
// ErrFILEOpenTable
// ========================================================================
// ErrFILEOpenTable( ppib, dbid, ppfucb, szName, grbit )
//		PIB *ppib;			// IN	 PIB of who is opening file
//		DBID dbid;			// IN	 database id
//		FUCB **ppfucb;		// OUT	 receives a new FUCB open on the file
//		CHAR *szName;		// IN	 path name of file to open
//		ULONG grbit;		// IN	 lock exclusively?
// Opens a data file, returning a new
// FUCB on the file.
//
// PARAMETERS
//				ppib			PIB of who is opening file
//				dbid			database id
//				ppfucb		receives a new FUCB open on the file
//								( should NOT already be pointing to an FUCB )
//				szName		path name of file to open ( the node
//								corresponding to this path must be an FDP )
//				grbit		 	flags:
//									JET_bitTableDenyRead	open table in exclusive mode;
//									default is share mode
// RETURNS		Lower level errors, or one of:
//					 JET_errSuccess					Everything worked.
//					-TableInvalidName					The path given does not
//															specify a file.
//					-JET_errDatabaseCorrupted		The database directory tree
//															is corrupted.
//					-Various out-of-memory error codes.
//				In the event of a fatal ( negative ) error, a new FUCB
//				will not be returned.
// SIDE EFFECTS FCBs for the file and each of its secondary indexes are
//				created ( if not already in the global list ).  The file's
//				FCB is inserted into the global FCB list.  One or more
//				unused FCBs may have had to be reclaimed.
//				The currency of the new FUCB is set to "before the first item".
// SEE ALSO		CloseTable
//-
ERR ErrFILEOpenTable( PIB *ppib, DBID dbid, FUCB **ppfucb, const CHAR *szName, ULONG grbit )
	{
	ERR		err;
	CHAR  	szTable[JET_cbFullNameMost + 1];
	BYTE  	rgbTableNorm[ JET_cbKeyMost ];
	CHAR  	szFileName[JET_cbFullNameMost + 1];
	KEY		rgkey[2];
	FCB		*pfcb;
	CSR		*pcsr;
	BOOL  	fReUsing = fTrue;

	CheckPIB( ppib );
	CheckDBID( ppib, dbid );
	CallR( ErrCheckName( szTable, szName, (JET_cbNameMost + 1 ) ) );

	Assert( ppib != ppibNil );
	Assert( ppfucb != NULL );

	/*	make seek path from table name.
	/**/
	rgkey[0] = *pkeyTables;

	/*	normalize table name and set key
	/**/
	SysNormText( szTable, strlen( szTable ), rgbTableNorm, sizeof( rgbTableNorm ), &rgkey[1].cb );
	rgkey[1].pb = rgbTableNorm;

	/*	open database cursor
	/**/
	CallR( ErrDIROpen( ppib, pfcbNil, dbid, ppfucb ) );

	/*	request table open mutex
	/**/
	SgSemRequest( semGlobalFCBList );

	/*	search for table
	/**/
	err = ErrDIRSeekPath( *ppfucb, 2, rgkey, fDIRPurgeParent );
	switch ( err )
		{
		case errDIRFDP: break;
		case JET_errSuccess:	Error( JET_errInvalidName, ReleaseFUCB )
		case JET_errRecordNotFound: Error( JET_errObjectNotFound, ReleaseFUCB )
		default: goto ReleaseFUCB;
		}
	Assert( *ppfucb != pfucbNil );
	Assert( ( *ppfucb )->lineData.cb > 2*sizeof(WORD)+2*sizeof( JET_DATESERIAL));
	memcpy( szFileName, ( *ppfucb )->lineData.pb+2*sizeof(WORD)+2*sizeof(JET_DATESERIAL),
		( *ppfucb )->lineData.cb-2*sizeof(WORD)-2*sizeof(JET_DATESERIAL) );
	szFileName[( *ppfucb )->lineData.cb-2*sizeof(WORD)-2*sizeof(JET_DATESERIAL)] = '\0';

	/*	reset copy buffer
	/**/
	(*ppfucb)->pbfWorkBuf = pbfNil;
	(*ppfucb)->lineWorkBuf.pb = NULL;
	Assert( !FFUCBUpdateSeparateLV( *ppfucb ) );
	Assert( !FFUCBUpdatePrepared( *ppfucb ) );

	/*	reset key buffer
	/**/
	(*ppfucb)->pbKey = NULL;
	KSReset( ( *ppfucb ) );

	/*	search global list by FDP pgno
	/**/
	Assert( ppib->level < levelMax );
	pcsr = PcsrCurrent( *ppfucb );
	Assert( pcsr != pcsrNil );
	pfcb = PfcbFCBGet( dbid, pcsr->pgno );

	/*	FCB not in global list?
	/**/
	if ( pfcb == pfcbNil )
		{
		FCB	*pfcbT;

		/*	have to build it from directory tree info
		/**/
		fReUsing = fFalse;
		SgSemRelease( semGlobalFCBList );		 // this may take a while...
		CallJ( ErrFILEIGenerateFCB( *ppfucb, &pfcb ), ReleaseFUCB )
		Assert( pfcb != pfcbNil );
		SgSemRequest( semGlobalFCBList );

		/*** Must search global list again:	 while I was out reading ***/
		/*** the tree, some other joker just might have been opening ***/
		/*** the same file and may have actually beat me to it. ***/
		pfcbT = PfcbFCBGet( dbid, pcsr->pgno );

		/*** Link into global list ( even if duplicate ) ***/
		Assert( pfcbGlobalList != pfcb );
		pfcb->pfcbNext = pfcbGlobalList;
		pfcbGlobalList = pfcb;

		/*** This is somewhat of a hack:  if the FCB was put in the ***/
		/*** list while I was building my copy, I should throw mine ***/
		/*** away.	The easiest way to do this is just to make the FCB's ***/
		/*** pgnoFDP a bogus value;	 it will sit in the global list with ***/
		/*** zero refcount, and somebody will eventually reclaim it. ***/
		if ( pfcbT != pfcbNil )
			{
			fReUsing = fTrue;
			pfcb->pgnoFDP = pgnoNull;
			pfcb->szFileName = NULL;
			pfcb = pfcbT;
			}
		else
			{
			/*	insert fcb in hash
			/**/
			Assert( PfcbFCBGet( pfcb->dbid, pfcb->pgnoFDP ) == pfcbNil );
			FCBRegister( pfcb );
			}
		}

	//	UNDONE: move this into fcb.c
	/*	wait on bookmark clean up if necessary
	/**/
	while ( FFCBWait( pfcb ) )
		{
		LgLeaveCriticalSection( critJet );
		SignalWait( &sigDoneFCB, -1 );
		LgEnterCriticalSection( critJet );
		}

	/*	set table usage mode.
	/**/
	CallJ( ErrFCBSetMode( ppib, pfcb, grbit ), ReleaseFUCB );

	/*	close database cursor and open table cursor
	/**/
	DIRClose( *ppfucb );
	CallJ( ErrDIROpen( ppib, pfcb, 0, ppfucb ), SimpleError );
	FUCBSetIndex( *ppfucb );

	/*	this code must coincide with call to ErrFCBSetMode above.
	/**/
	if ( grbit & JET_bitTableDenyRead )
		FUCBSetDenyRead( *ppfucb );
	if ( grbit & JET_bitTableDenyWrite )
		FUCBSetDenyWrite( *ppfucb );

	/*	reset copy buffer
	/**/
	( *ppfucb )->pbfWorkBuf = pbfNil;
	( *ppfucb )->lineWorkBuf.pb = NULL;
	Assert( !FFUCBUpdateSeparateLV( *ppfucb ) );
	Assert( !FFUCBUpdatePrepared( *ppfucb ) );

	/*	reset key buffer
	/**/
	( *ppfucb )->pbKey = NULL;
	KSReset( ( *ppfucb ) );

	/*	store the file name now
	/**/
	if ( !fReUsing )
		{
		if ( ( pfcb->szFileName = SAlloc( strlen( szFileName ) + 1 ) ) == NULL )
			{
			err = JET_errOutOfMemory;
			goto ReleaseFUCB;
			}
		strcpy( pfcb->szFileName, szFileName );
		}

	/*	set currency before first node
	/**/
	pcsr = PcsrCurrent( *ppfucb );
	Assert( pcsr != pcsrNil );
	pcsr->csrstat = csrstatBeforeFirst;

	/*	move currency to the first record and ignore error if no records
	/**/
	err = ErrIsamMove( ppib, *ppfucb, JET_MoveFirst, 0 );
	if ( err < 0  )
		{
		if ( err != JET_errNoCurrentRecord )
			goto ReleaseFUCB;
		err = JET_errSuccess;
		}

	/*	release crit section
	/**/
	SgSemRelease( semGlobalFCBList );
	return JET_errSuccess;

ReleaseFUCB:
	DIRClose( *ppfucb );
SimpleError:
	*ppfucb = pfucbNil;
	/*	release crit section
	/**/
	SgSemRelease( semGlobalFCBList );
	return err;
	}




ERR VTAPI ErrIsamCloseTable( PIB *ppib, FUCB *pfucb )
	{
	ERR		err;

	CheckPIB( ppib );
	CheckTable( ppib, pfucb );

#ifdef	DISPATCHING
	Assert( pfucb->fVtid );
#ifdef	SYSTABLES
	if ( FFUCBSystemTable( pfucb ) )
		ReleaseTableid( TableidFromVtid( (JET_VTID ) pfucb, &vtfndefIsamInfo ) );
	else
#endif	/* SYSTABLES */
		ReleaseTableid( TableidFromVtid( (JET_VTID ) pfucb, &vtfndefIsam ) );
	pfucb->fVtid = fFalse;
#endif	/* DISPATCHING */

	err = ErrFILECloseTable( ppib, pfucb );
	return( err );
	}




//+API
// ErrFILECloseTable
// ========================================================================
// ErrFILECloseTable( PIB *ppib, FUCB *pfucb )
//
// Closes the FUCB of a data file, previously opened using FILEOpen.
// Also closes the current secondary index, if any.
//
// PARAMETERS	ppib	PIB of this user
//				pfucb	FUCB of file to close
//
// RETURNS		JET_errSuccess
//				or lower level errors
//
// SEE ALSO		OpenTable
//-
ERR ErrFILECloseTable( PIB *ppib, FUCB *pfucb )
	{
	ERR		err;

	CheckPIB( ppib );
	CheckTable( ppib, pfucb );
	Assert( pfucb->fVtid == fFalse );

	if ( FFUCBUpdatePrepared( pfucb ) )
		{
		CallS( ErrIsamPrepareUpdate( ppib, pfucb, JET_prepCancel ) );
		}
	Assert( !FFUCBUpdateSeparateLV( pfucb ) );
	Assert( !FFUCBUpdatePrepared( pfucb ) );

	/*	release working buffer
	/**/
	if ( pfucb->pbfWorkBuf != pbfNil )
		{
		BFSFree( pfucb->pbfWorkBuf );
		pfucb->pbfWorkBuf = pbfNil;
		pfucb->lineWorkBuf.pb = NULL;
		}

	if ( pfucb->pbKey != NULL )
		{
		LFree( pfucb->pbKey );
		pfucb->pbKey = NULL;
		}

	/*	detach, close and free index FUCB, if any
	/**/
	if ( pfucb->pfucbCurIndex != pfucbNil )
		{
		DIRClose( pfucb->pfucbCurIndex );
		pfucb->pfucbCurIndex = pfucbNil;
		}

	/*	if closing a temporary table, free resources if
	/*	last one to close
	/**/
	if ( FFCBTemporaryTable( pfucb->u.pfcb ) )
		{
		FCB		*pfcb = pfucb->u.pfcb;
		DBID		dbid = pfucb->dbid;
		BYTE		szFileName[JET_cbNameMost+1];

		strncpy( szFileName, ( pfucb->u.pfcb )->szFileName, JET_cbNameMost+1 );
		DIRClose( pfucb );
		if ( pfcb->wRefCnt )
			return JET_errSuccess;

		err = ErrFILEDeleteTable( ppib, dbid, szFileName );
		return err;
		}

	/*	undo X lock applied at OPEN time
	/**/
//	if ( FFUCBDenyRead( pfucb ) )
//		{
//		SgSemRequest( semGlobalFCBList );
//		FCBResetDenyRead( pfucb->u.pfcb );
//		SgSemRelease( semGlobalFCBList );
//		}

	FUCBResetGetBookmark( pfucb );
	DIRClose( pfucb );
	return JET_errSuccess;
	}


//+INTERNAL
// ErrFILEIGenerateFCB
// ========================================================================
// ErrFILEIGenerateFCB( FUCB *pfucb, FCB **ppfcb )
//
// Allocates FCBs for a data file and its indexes, and fills them in
// from the database directory tree.
//
// PARAMETERS
//					pfucb		FUCB opened on the FDP to be built from
//					ppfcb		receives the built FCB for this file
//
// RETURNS		lower level errors, or one of:
//					JET_errSuccess						
//					JET_errTooManyOpenTables			could not allocate enough FCBs.
//
//	On fatal (negative) error, any FCBs which were allocated
//	are returned to the free pool.
//
// SIDE EFFECTS	Global FCB list may be reaped for unused FCBs
// SEE ALSO			OpenTable
//-
ERR ErrFILEIGenerateFCB( FUCB *pfucb, FCB **ppfcb )
	{
	ERR		err;								// error code of various utility
	INT		cFCBNeed;						// # of FCBs that have to be allocated
	FCB		*pfcbAllFCBs = pfcbNil;		// list of pre-allocated FCBs
	FCB		*pfcb;							// FCB pointer of various utility
	ULONG		ulFileDensity;					// loading density of file

	Assert( ppfcb != NULL );
	Assert( pfucb != pfucbNil );

	/*	allocate all the FCBs at once, chaining by pfcbNextIndex
	/*	first word of file node's data is number of secondary indexes
	/*	second word is file's loading density
	/**/
	Assert( pfucb->lineData.pb != NULL );
	Assert( pfucb->lineData.cb > 2*sizeof(WORD) );
	cFCBNeed = *(UNALIGNED WORD *)pfucb->lineData.pb + 1;
	ulFileDensity = ( (UNALIGNED WORD *)pfucb->lineData.pb )[1];
	while ( cFCBNeed > 0 )
		{
		CallJ( ErrFCBAlloc( pfucb->ppib, &pfcb ), ReleaseAllFCBs );
		pfcb->pfcbNextIndex = pfcbAllFCBs;
		pfcbAllFCBs = pfcb;
		cFCBNeed--;
		}

	/*	got all the FCBs:	now fill them in from the tree
	/**/
	pfcb->cbDensityFree = ( ( 100 - ulFileDensity ) * cbPage ) / 100;
	CallJ( ErrFILEIFillInFCB( pfucb, pfcbAllFCBs ), ReleaseAllFCBs )

	/*	combine index column masks into a single mask
	/*	for fast record replace.
	/**/
	FILESetAllIndexMask( pfcbAllFCBs );

	*ppfcb = pfcbAllFCBs;
	return JET_errSuccess;

	/*	error handling
	/**/
ReleaseAllFCBs:
	while ( pfcbAllFCBs != pfcbNil )
		{
		pfcb = pfcbAllFCBs;
		pfcbAllFCBs = pfcbAllFCBs->pfcbNextIndex;
		Assert( pfcb->cVersion == 0 );
		MEMReleasePfcb( pfcb );
		}
	return err;
	}


//+INTERNAL
// ErrFILEIFillInFCB
// ========================================================================
// ErrFILEIFillInFCB( pfucb, pfcb )
//		FUCB *pfucb;	// IN	   FUCB opened on the FDP to build from
//		FCB *pfcb;		// INOUT   empty FCB and index FCBs to fill in
// Walks the database directory tree, filling in the pre-allocated FCBs
// for the data file and indexes.
//
// PARAMETERS	pfucb		FUCB opened on the FDP to build from
//					pfcb		must point to an allocated FCB, with FCBs
//								chained on the pfcbNextIndex field, one
//								for each secondary index of the file.
// RETURNS		Lower level errors, or one of:
//					 JET_errSuccess					Everything worked.
//					-JET_errOutOfMemory				Could not allocate misc. memory
//					-JET_errDatabaseCorrupted		The database directory tree
//															is corrupted.
//				On fatal ( negative ) errors, any memory resources which
//				were allocated are freed.
// SEE ALSO		OpenTable
//-
ERR ErrFILEIFillInFCB( FUCB *pfucb, FCB *pfcb )
	{
	ERR err;
	DIB dib;				// needed for DIR calls

	Assert( pfcb != pfcbNil );
	Assert( pfucb != pfucbNil );
	Assert( pfucb->ppib != ppibNil );
	Assert( pfucb->ppib->level < levelMax );
	Assert( PcsrCurrent( pfucb ) != pcsrNil );
	Assert( PcsrCurrent( pfucb )->csrstat == csrstatOnFDPNode );
	/*** Fill in FDP page number ***/
	pfcb->pgnoFDP = PcsrCurrent( pfucb )->pgno;

	/*** Assume sequential: IDB is NULL ***/
	pfcb->pidb = pidbNil;

	/*	reference count
	/**/
	pfcb->wRefCnt = 0;
	pfcb->wFlags = fFCBClusteredIndex;
	pfcb->dbid = pfucb->dbid;	// dbid should have been set at this point

	/*** Down to \files\some_file\fields ***/
	dib.pos = posDown;
	dib.pkey = (KEY *)pkeyFields;
	dib.fFlags = fDIRNull;
	err = ErrDIRDown( pfucb, &dib );
	if ( err != JET_errSuccess )
		{
		if ( err > 0 )
			err = JET_errDatabaseCorrupted;
		Error( err, SimpleError );
		}

	/*	construct field definition block
	/**/
	CallJ( ErrFDBConstruct( pfucb, pfcb, fTrue ), SimpleError )

	/*	up to \files\some_file
	/**/
	DIRUp( pfucb, 1 );

	/*	down to \files\some_file\olcstats
	/**/
	Assert( dib.pos == posDown );
	dib.pkey = (KEY *)pkeyOLCStats;
	Assert( dib.fFlags == fDIRNull );
	err = ErrDIRDown( pfucb, &dib );
	if ( err >= JET_errSuccess )
		{
		if ( err != JET_errSuccess )
			{
			FCBResetOLCStatsAvail( pfcb );
			}
		else
			{
			FCBSetOLCStatsAvail( pfcb );
			CallJ( ErrDIRGet( pfucb ), FreeFDB );
			Assert( pfucb->lineData.cb == sizeof( PERS_OLCSTAT ) );
			memcpy( (BYTE *) &pfcb->olcStat, pfucb->lineData.pb, sizeof( PERS_OLCSTAT ) );
			}
		/*	up to \files\some_file
		/**/
		DIRUp( pfucb, 1 );
		}

	/*	down to \files\some_file\indexes
	/**/
	Assert( dib.pos == posDown );
	dib.pkey = (KEY *)pkeyIndexes;
	Assert( dib.fFlags == fDIRNull );
	err = ErrDIRDown( pfucb, &dib );
	if ( err != JET_errSuccess )
		{
		if ( err > 0 )
			err = JET_errDatabaseCorrupted;
		Error( err, FreeFDB );
		}

	/*	build index definitions
	/**/
	CallJ( ErrFILEIBuildIndexDefs( pfucb, pfcb ), FreeFDB )

	/*	up to \files\some_file
	/**/
	DIRUp( pfucb, 1 );

	/*	set long field id max
	/**/
	Assert( dib.pos == posDown );
	dib.pkey = (KEY *)pkeyLong;
	Assert( dib.fFlags == fDIRNull );
	err = ErrDIRDown( pfucb, &dib );
	if ( err != JET_errSuccess )
		goto FreeIndexes;

	/*  if err == JET_errSuccess  */

	dib.pos = posLast;
	dib.fFlags = fDIRNull;
	err = ErrDIRDown( pfucb, &dib );
	Assert( err != JET_errNoCurrentRecord );
	if ( err == JET_errSuccess )
		{
		BYTE *pb = pfucb->keyNode.pb;
		/*	remember to add 1 to make this then next long value
		/*	to add.
		/**/
		pfcb->ulLongIdMax =
			( pb[0] << 24 ) +
			( pb[1] << 16 ) +
			( pb[2] <<  8 ) +
			pb[3] + 1;
		DIRUp( pfucb, 1 );
		}
	else if ( err == JET_errRecordNotFound )
		pfcb->ulLongIdMax = 0;
	else
		goto FreeIndexes;

	/*	up to \files\some_file
	/**/
	DIRUp( pfucb, 1 );

	return JET_errSuccess;

	/*	error handling
	/**/
FreeIndexes:					// free all index FCB storage
	{
	FCB *pfcbT;					// FCB pointer of various utility

	for ( pfcbT = pfcb->pfcbNextIndex; pfcbT != pfcbNil;
		pfcbT = pfcbT->pfcbNextIndex )
		{
		RECFreeIDB( pfcbT->pidb );
		}
	}

	if ( pfcb->pidb != pidbNil )
		RECFreeIDB( pfcb->pidb );
FreeFDB:						// free file FCB's FDB block
	FDBDestruct( (FDB *)pfcb->pfdb );
SimpleError:
	return err;
	}


//+INTERNAL
//	ErrFDBConstruct
//	========================================================================
//	ErrFDBConstruct( FUCB *pfucb, FCB *pfcb, BOOL fBuildDefault )
//
//	Constructs a table FDB from the field descriptions in the tree.
//	Currency must be on FIELDS node. On error, this routine will not affect pfcb.
//
//	PARAMETERS	pfucb				FUCB open on ...\<file>\fields
//	   			pfcb				FCB containing FDB to build
//	   			fBuildDefault		Build default record?
//
//	RETURNS
//				JET_errSuccess
//				negative failing error code
//-
ERR ErrFDBConstruct( FUCB *pfucb, FCB *pfcb, BOOL fConstructDefaultRecord )
	{
	ERR						err;				// error code of various utility
	UNALIGNED FIELDDATA		*pfd;				// data found at the "fields" node
	FIELDDEFDATA	 		*pfdd;				// data found at each field descriptor node
	DIB				 		dib;				// needed for DIR calls
	FDB				 		*pfdbNew;
	FDB				 		*pfdbSav;
	FDB				 		*pfdbOld;
	WORD			 		wFlagsSav;
	RECHDR			 		*prechdr;
	BYTE			 		*pb;
	FIELD			 		field;

	Assert( pfucb != pfucbNil );
	Assert( pfcb != pfcbNil );
	Assert( pfucb->lineData.pb != NULL );
	Assert( pfucb->lineData.cb == sizeof(FIELDDATA) );

	/*	allocate FDB
	/**/
	pfd = (FIELDDATA *)pfucb->lineData.pb;
	CallR( ErrRECNewFDB(
		&pfdbNew,
		pfd->fidFixedLast,
		pfd->fidVarLast,
		pfd->fidTaggedLast) );

	/*	scan all sons of fields, filling in FDB
	/**/
	dib.pos = posFirst;
	dib.fFlags = fDIRNull;

	pfdbNew->fidVersion = 0;
	pfdbNew->fidAutoInc = 0;

	err = ErrDIRDown( pfucb, &dib );
	if ( err < 0 )
		{
		Assert( err != JET_errNoCurrentRecord );
		if ( err != JET_errRecordNotFound )
			goto HandleError;
		}
	else
		{
		/*	since move first err must be JET_errSuccess
		/**/
		Assert( err == JET_errSuccess );

		forever
			{
			Assert( pfucb->lineData.pb != NULL );
			Assert( pfucb->lineData.cb >= sizeof(FIELDDEFDATA) - 1 );
			pfdd = (FIELDDEFDATA *)pfucb->lineData.pb;
			Assert( !FKeyNull( &pfucb->keyNode ) );
			Assert( pfucb->keyNode.cb <= JET_cbKeyMost );
			Assert( pfdd->bColtyp >= JET_coltypNil && pfdd->bColtyp < JET_coltypMax );
			field.coltyp = (JET_COLTYP)pfdd->bColtyp;
			if ( field.coltyp == JET_coltypText || field.coltyp == JET_coltypLongText )
				{
				field.langid = pfdd->langid;
				field.cp		 = pfdd->cp;
				field.wCountry = pfdd->wCountry;
				}
			field.cbMaxLen = pfdd->ulLength;
			field.ffield = pfdd->bFlags;
			Assert( strlen( pfdd->szFieldName ) <= JET_cbNameMost );
			strcpy( field.szFieldName, pfdd->szFieldName );

			Call( ErrRECAddFieldDef( pfdbNew, pfdd->fid, &field ) );

			/*	fixed fields which have been deleted are not usable
			/**/
			if ( field.ffield & ffieldDeleted )
				{
				pfdbNew->pfieldFixed[pfdd->fid-fidFixedLeast].coltyp = JET_coltypNil;
				}

			/*	set version and auto increment field ids
			/**/
			if ( field.ffield & ffieldVersion )
				pfdbNew->fidVersion = pfdd->fid;
			if ( field.ffield & ffieldAutoInc )
				pfdbNew->fidAutoInc = pfdd->fid;

			err = ErrDIRNext( pfucb, &dib );
			if ( err < 0 )
				{
				/* go back up to files\some_file\fields
				/**/
				DIRUp( pfucb, 1 );
				if ( err == JET_errNoCurrentRecord )
					break;
				goto HandleError;
				}
			}
		}

	/*	set FCB pfdb to new FDB, saving old for RestoreFUCB
	/**/
	pfdbOld = (FDB *)pfcb->pfdb;
	(FDB *)pfcb->pfdb = pfdbNew;

	if ( !fConstructDefaultRecord )
		return JET_errSuccess;

	/*	make default record
	/*	prepare for set
	/**/
	if ( pfucb->pbfWorkBuf == pbfNil )
		{
		Call( ErrBFAllocTempBuffer( &pfucb->pbfWorkBuf ) )
		pfucb->lineWorkBuf.pb = (BYTE *)pfucb->pbfWorkBuf->ppage;
		}
	PrepareInsert( pfucb );

	/*	fake pfucb to look like an opened file
	/**/
	wFlagsSav = (WORD)pfucb->wFlags;
	FUCBSetIndex( pfucb );
	pfdbSav = (FDB *)pfucb->u.pfcb->pfdb;
	pfucb->u.pfcb->pfdb = pfcb->pfdb;

	/* init buffer for set column
	/**/
	prechdr = (RECHDR *)pfucb->lineWorkBuf.pb;
	prechdr->fidFixedLastInRec = (BYTE)( fidFixedLeast - 1 );
	prechdr->fidVarLastInRec = (BYTE)( fidVarLeast - 1 );
	*(WORD *)( prechdr + 1 ) = pfucb->lineWorkBuf.cb = sizeof(RECHDR) + sizeof(WORD);

	/* scan all sons of fields, building default record
	/**/
	Assert( dib.pos == posFirst );
	Assert( dib.fFlags == fDIRNull );

	err = ErrDIRDown( pfucb, &dib );
	if ( err < 0 )
		{
		Assert( err != JET_errNoCurrentRecord );
		if ( err != JET_errRecordNotFound )
			goto RestoreFUCB;
		}
	else
		{
		/*	since move first err must be JET_errSuccess
		/**/
		Assert( err == JET_errSuccess );

		forever
			{
			Assert( pfucb->lineData.pb != NULL );
			Assert( pfucb->lineData.cb >= sizeof(FIELDDEFDATA) - 1 );
			pfdd = (FIELDDEFDATA *)pfucb->lineData.pb;
			if ( pfdd->cbDefault > 0 )
				{
				CallJ( ErrIsamSetColumn( pfucb->ppib, pfucb, (ULONG)pfdd->fid, pfdd->rgbDefault, (ULONG)pfdd->cbDefault, 0, NULL ), RestoreFUCB )
				}
			err = ErrDIRNext( pfucb, &dib );
			if ( err < 0 )
				{
				/* go back up to files\some_file\fields
				/**/
				DIRUp( pfucb, 1 );
				if ( err == JET_errNoCurrentRecord )
					break;
				goto RestoreFUCB;
				}
			}
		}

	/*	alloc and copy default record, release working buffer
	/**/
	pb = SAlloc( pfucb->lineWorkBuf.cb );
	if ( pb == NULL )
		{
		err = JET_errOutOfMemory;
		goto RestoreFUCB;
		}

	pfcb->pfdb->lineDefaultRecord.pb = pb;

	LineCopy( &pfcb->pfdb->lineDefaultRecord, &pfucb->lineWorkBuf );

	/*	reset copy buffer
	/**/
	BFSFree( pfucb->pbfWorkBuf );
	pfucb->pbfWorkBuf = pbfNil;
	pfucb->lineWorkBuf.pb = NULL;
	Assert( !FFUCBUpdateSeparateLV( pfucb ) );
	FUCBResetCbstat( pfucb );

	/* unfake pfucb
	/**/
	pfucb->wFlags = wFlagsSav;
	FDBSet( pfucb->u.pfcb, pfdbSav );
	return JET_errSuccess;

	/*	error handling
	/**/
RestoreFUCB:
	pfucb->wFlags = wFlagsSav;
	FDBSet( pfucb->u.pfcb, pfdbSav );

	BFSFree( pfucb->pbfWorkBuf );
	pfucb->pbfWorkBuf = pbfNil;
	pfucb->lineWorkBuf.pb = NULL;

	(FDB *)pfcb->pfdb = pfdbOld;
HandleError:
	FDBDestruct( pfdbNew );
	return err;
	}


VOID FDBDestruct( FDB *pfdb )
	{
	Assert( pfdb != NULL );
	if ( pfdb->lineDefaultRecord.pb != NULL )
		SFree( pfdb->lineDefaultRecord.pb );
	SFree( pfdb );
	return;
	}


/*	set all table FCBs to given pfdb.  Used during reversion to
/*	saved FDB during DDL operation.
/**/
VOID FDBSet( FCB *pfcb, FDB *pfdb )
	{
	FCB	*pfcbT;

 	/* correct non-clusterred index FCBs to new FDB
	/**/
	for ( pfcbT = pfcb;
		pfcbT != pfcbNil;
		pfcbT = pfcbT->pfcbNextIndex )
		{
		pfcbT->pfdb = pfdb;
		}

	return;
	}


//+INTERNAL
// ErrFILEIBuildIndexDefs
// ========================================================================
// ErrFILEIBuildIndexDefs( pfucb, pfcb )
//		FUCB	*pfucb;		// IN	   FUCB open on ...\<file>\indexes
//		FCB	*pfcb;		// INOUT   FCB to fill in indexes for
//
// Fills in the index FCBs for a data file from the directory tree,
// including the clustered index information in the file's FCB.
//
// PARAMETERS	pfucb				FUCB open on ...\<file>\indexes
//					pfcb				must point to an allocated FCB, with FCBs
//										chained on the pfcbNextIndex field, one
//										for each secondary index of the file.
// RETURNS		Lower level errors, or one of:
//					 JET_errSuccess	 				Everything worked.
//					-JET_errOutOfMemory				Could not allocate misc. memory
//					-JET_errDatabaseCorrupted		The database directory tree
//															is corrupted.
//				On fatal ( negative ) errors, any memory resources which
//				were allocated are freed.
//
// SEE ALSO	OpenTable
//-
ERR ErrFILEIBuildIndexDefs( FUCB *pfucb, FCB *pfcb )
	{
	ERR	err;								// error code of various utility
	DIB	dib;								// needed for DIR calls
	FCB	*pfcb2ndIdx;					// pointer to secondary index FCBs
	KEY	key;

	/*** "Sequential" or "clustered" file? ***/
	if ( FLineNull( &pfucb->lineData ) )
		{
		// "sequential" file
		pfcb->pidb = pidbNil;

		/*** Down to <NULL> node ***/
		dib.pos = posDown;
		key.cb = 0;
		dib.pkey = &key;
		dib.fFlags = fDIRNull;
		if ( ( err = ErrDIRDown( pfucb, &dib ) ) != JET_errSuccess )
			{
			if ( err > 0 )
				err = JET_errDatabaseCorrupted;
			Error( err, SimpleError );
			}
		}
	else
		{
		/*	file has clustered index
		/**/
		INDEXDEFDATA	*pidd;
		KEY				key;
		CHAR				rgbIndexName[(JET_cbNameMost + 1)];
		INT				cbIndexName;

		cbIndexName = pfucb->lineData.cb;
		Assert( cbIndexName < (JET_cbNameMost + 1) );
		memcpy( rgbIndexName, pfucb->lineData.pb, cbIndexName );

		/*** Down to clustered index node ***/
		dib.pos = posDown;
		dib.pkey = &key;
		dib.pkey->cb = cbIndexName;
		dib.pkey->pb = rgbIndexName;
		dib.fFlags = fDIRNull;
		if ( ( err = ErrDIRDown( pfucb, &dib ) ) != JET_errSuccess )
			{
			if ( err > 0 )
				err = JET_errDatabaseCorrupted;
			Error( err, SimpleError );
			}

		/*** Get clustered index definition, store in IDB ***/
		Assert( pfucb->lineData.pb != NULL );
		Assert( pfucb->lineData.cb <= sizeof(INDEXDEFDATA) );
		pidd = (INDEXDEFDATA *)pfucb->lineData.pb;
		pfcb->cbDensityFree = ( (100-pidd->bDensity ) * cbPage ) / 100;
		CallJ( ErrRECNewIDB( &pfcb->pidb ), SimpleError )
		CallJ( ErrRECAddKeyDef(
			(FDB *)pfcb->pfdb,
			pfcb->pidb,
		   pidd->iidxsegMac,
			pidd->rgidxseg,
		   pidd->bFlags,
			pidd->langid ), FreeIDB )
		strcpy( pfcb->pidb->szName, pidd->szIndexName );
		}

	/*** Go down to "data" node ***/
	Assert( dib.pos == posDown );
	dib.pkey = (KEY *)pkeyData;
	Assert( dib.fFlags == fDIRNull );
	if ( ( err = ErrDIRDown( pfucb, &dib ) ) != JET_errSuccess )
		{
		if ( err > 0 )
			err = JET_errDatabaseCorrupted;
		Error( err, FreeIDB );
		}

	/*	now at "DATA"; get pgno, itag of data root from CSR
	/**/
	Assert( pfucb->ppib != ppibNil );
	Assert( pfucb->ppib->level < levelMax );
	Assert( PcsrCurrent( pfucb ) != pcsrNil );
	pfcb->pgnoRoot = PcsrCurrent( pfucb )->pgno;
	pfcb->itagRoot = PcsrCurrent( pfucb )->itag;
	pfcb->bmRoot = SridOfPgnoItag( pfcb->pgnoRoot, pfcb->itagRoot );
	
	/*** If "sequential" file, get the max DBK in use ***/
	if ( pfcb->pidb == pidbNil )
		{
		/*** Go down to the last data record ***/
		dib.pos = posLast;
		Assert( dib.fFlags == fDIRNull );

		if ( ( err = ErrDIRDown( pfucb, &dib ) ) == JET_errSuccess )
			{
			BYTE *pb = pfucb->keyNode.pb;
			pfcb->dbkMost = ( pb[0] << 24 ) + ( pb[1] << 16 ) + ( pb[2] <<  8 ) +	 pb[3];
			DIRUp( pfucb, 1 );
			}
		else if ( err == JET_errRecordNotFound )
			pfcb->dbkMost = 0;
		else
			goto FreeIDB;
		}

	/*	go back up to "indexes" node
	/**/
	DIRUp( pfucb, 2 );

	/*	build index FCB for each secondary index
	/**/
	pfcb2ndIdx = pfcb->pfcbNextIndex;
	dib.pos = posFirst;
	Assert( dib.fFlags == fDIRNull );
	err = ErrDIRDown( pfucb, &dib );
	while ( err >= 0 )
		{
		/*	ignore clustered index
		/**/
		if ( pfcb->pidb == pidbNil )
			{
			/*	sequential file
			/**/
			if ( pfucb->lineData.cb == 0 || FIndexNameNull( pfucb ) )
				goto NextIndex;
			}
		else
			{
			/*	clustered file
			/**/
			if ( CbIndexName( pfucb ) == strlen( pfcb->pidb->szName ) &&
				_strnicmp( PbIndexName( pfucb ), pfcb->pidb->szName,
				CbIndexName( pfucb ) ) == 0 )
				{
				goto NextIndex;
				}
			}

		/*	build index definition into next index FCB
		/**/
		if ( err != errDIRFDP )
			{
			/*	2nd idxs must be FDPs
			/**/
			if ( err == JET_errSuccess )
				err = JET_errDatabaseCorrupted;
			Error( err, CleanUpDoneFCBs );
			}
		if ( pfcb2ndIdx == pfcbNil )
			{
			/*	more idxs than I was told
			/**/
			Error( JET_errDatabaseCorrupted, CleanUpDoneFCBs )
			}
		CallJ( ErrFILEIFillIn2ndIdxFCB( pfucb, (FDB *)pfcb->pfdb, pfcb2ndIdx ), CleanUpDoneFCBs )

		/*	move on to the next pre-allocated index FCB
		/**/
		pfcb2ndIdx = pfcb2ndIdx->pfcbNextIndex;

NextIndex:
		/*	next index
		/**/
		err = ErrDIRNext( pfucb, &dib );
		}

	if ( pfcb2ndIdx != pfcbNil )
		{
		/*	fewer idxs than expected
		/**/
		Error( JET_errDatabaseCorrupted, CleanUpDoneFCBs )
		}
	else
		if ( err != JET_errRecordNotFound && err != JET_errNoCurrentRecord )
			goto CleanUpDoneFCBs;

	/*	go back up to "indexes" node
	/**/
	DIRUp( pfucb, 1 );

	return JET_errSuccess;

	/*** Error handling ***/
CleanUpDoneFCBs:
	// release memory for finished indexes
	{
	FCB	*pfcbT;							// FCB pointer of various utility

	for ( pfcbT = pfcb->pfcbNextIndex; pfcbT != pfcb2ndIdx; pfcbT = pfcbT->pfcbNextIndex )
		{
		Assert( pfcbT != pfcbNil );
		RECFreeIDB( pfcbT->pidb );
		}
	}
FreeIDB:						// free file clustered index IDB
	if ( pfcb->pidb != pidbNil )
		RECFreeIDB( pfcb->pidb );
SimpleError:				// nothing to clean up
	return err;
	}


//+INTERNAL
// ErrFILEIFillIn2ndIdxFCB
// ========================================================================
// ErrFILEIFillIn2ndIdxFCB( pfucb, pfdb, pfcb )
//		FUCB *pfucb;	// IN	   FUCB open on ...\<file>\indexes\<index>
//		FDB *pfdb;		// IN	   FDB of file who has this index
//		FCB *pfcb;		// INOUT   secondary index FCB to fill in
// Fills in a secondary index FCB from the directory tree.
//
// PARAMETERS	pfucb		FUCB open on ...\<file>\indexes\<index>
//				pfdb		FDB of file who has this index
//				pfcb		must point to an allocated FCB
// RETURNS		Lower level errors, or one of:
//					 JET_errSuccess					Everything worked.
//					-JET_errOutOfMemory				Could not allocate misc. memory
//					-JET_errDatabaseCorrupted		The database directory tree
//															is corrupted.
//				On fatal ( negative ) errors, any memory resources which
//				were allocated are freed.
// SEE ALSO		OpenTable
//-
ERR ErrFILEIFillIn2ndIdxFCB( FUCB *pfucb, FDB *pfdb, FCB *pfcb )
	{
	ERR												err;			// error code of various utility
	INDEXDEFDATA							*pidd; 		// data at the index node
	DIB												dib;			// needed for DIR calls

	/*** Fill in FDP page number ***/
	Assert( pfucb->ppib != ppibNil );
	Assert( pfucb->ppib->level < levelMax );
	Assert( PcsrCurrent( pfucb ) != pcsrNil );
	pfcb->pgnoFDP = PcsrCurrent( pfucb )->pgno;

	/*	reference count
	/**/
	pfcb->wRefCnt = 0;
	pfcb->wFlags = 0;
	pfcb->dbid = pfucb->dbid;	// dbid should have been set at this point

	/*** Get index definition, store in IDB ***/
	Assert( pfucb->lineData.pb != NULL );
	Assert( pfucb->lineData.cb <= sizeof(INDEXDEFDATA) );
	pidd = (INDEXDEFDATA *)pfucb->lineData.pb;
	pfcb->cbDensityFree = ( (100-pidd->bDensity ) * cbPage ) / 100;
	CallJ( ErrRECNewIDB( &pfcb->pidb ), SimpleError )
	pfcb->pfdb = pfdb;
	CallJ( ErrRECAddKeyDef(
		(FDB *)pfcb->pfdb,
		pfcb->pidb,
	   pidd->iidxsegMac,
		pidd->rgidxseg,
	   pidd->bFlags,
		pidd->langid ), FreeIDB )
	strcpy( pfcb->pidb->szName, pidd->szIndexName );

	/*	go down to "OLCStats" node and get Stats, if any
	/**/
	dib.pos = posDown;
	dib.pkey = (KEY *)pkeyOLCStats;
	dib.fFlags = fDIRNull;
	err = ErrDIRDown( pfucb, &dib );
	if ( err >= JET_errSuccess )
		{
		if ( err != JET_errSuccess )
			{
			FCBResetOLCStatsAvail( pfcb );
			}
		else
			{
			FCBSetOLCStatsAvail( pfcb );
			CallJ( ErrDIRGet( pfucb ), FreeIDB );
			Assert( pfucb->lineData.cb == sizeof( PERS_OLCSTAT ) );
			memcpy( (BYTE *) &pfcb->olcStat, pfucb->lineData.pb, sizeof( PERS_OLCSTAT ) );
			}

		/*** Go back up to ...\indexes\<index> node ***/
		DIRUp( pfucb, 1 );
		}

	/*	go down to "data" node
	/**/
	Assert( dib.pos == posDown );
	dib.pkey = (KEY *)pkeyData;
	Assert( dib.fFlags == fDIRNull );
	if ( ( err = ErrDIRDown( pfucb, &dib ) ) != JET_errSuccess )
		{
		if ( err > 0 )
			err = JET_errDatabaseCorrupted;
		Error( err, FreeIDB )
		}

	/*	now at "data", get pgno, itag of data root from CSR
	/**/
	Assert( pfucb->ppib != ppibNil );
	Assert( pfucb->ppib->level < levelMax );
	Assert( PcsrCurrent( pfucb ) != pcsrNil );
	pfcb->pgnoRoot = PcsrCurrent( pfucb )->pgno;
	pfcb->itagRoot = PcsrCurrent( pfucb )->itag;
	AssertNDGetNode( pfucb, pfcb->itagRoot );
	NDGetBookmark( pfucb, &pfcb->bmRoot );

	/*** Go back up to ...\indexes\<index> node ***/
	DIRUp( pfucb, 1 );

	return JET_errSuccess;

	/*** Error handling ***/
FreeIDB:						// free up secondary index IDB block
	RECFreeIDB( pfcb->pidb );
SimpleError:					// nothing to clean up
	return err;
	}


//+INTERNAL
// FILEIDeallocateFileFCB
// ========================================================================
// FILEIDeallocateFileFCB( FCB *pfcb )
//
// Frees memory allocations associated with a file FCB and all of its
// secondary index FCBs.
//
// PARAMETERS	
//		pfcb			pointer to FCB to deallocate
//
//-
VOID FILEIDeallocateFileFCB( FCB *pfcb )
	{
	FCB	*pfcbIdx;
	FCB	*pfcbT;

	Assert( pfcb != pfcbNil );
	Assert( CVersionFCB( pfcb ) == 0 );
	
	/*	release FCB resources
	/**/
	pfcbIdx = pfcb->pfcbNextIndex;
	if ( PfcbFCBGet( pfcb->dbid, pfcb->pgnoFDP ) == pfcb )
		{
		FCBDiscard( pfcb );
		}

	while ( pfcbIdx != pfcbNil )
		{
		Assert( pfcbIdx->pidb != pidbNil );
		RECFreeIDB( pfcbIdx->pidb );
		pfcbT = pfcbIdx->pfcbNextIndex;
		Assert( PfcbFCBGet( pfcbIdx->dbid, pfcbIdx->pgnoFDP ) == pfcbNil );
		Assert( pfcbIdx->cVersion == 0 );
		Assert( pfcbIdx->crefDenyDDL == 0 );
		MEMReleasePfcb( pfcbIdx );
		pfcbIdx = pfcbT;
		}

	/*	if fcb was on table was opened during the creation of
	/*	this FCB, then szFileName would not be set
	/**/
	if ( pfcb->szFileName != NULL )
		SFree( pfcb->szFileName );
	if ( pfcb->pfdb != pfdbNil )
		FDBDestruct( (FDB *)pfcb->pfdb );
	if ( pfcb->pidb != pidbNil )
		RECFreeIDB( pfcb->pidb );
	Assert( pfcb->cVersion == 0 );
	Assert( pfcb->crefDenyDDL == 0 );
	MEMReleasePfcb( pfcb );
	}


/*	combines all index column masks into a single per table
/*	index mask, used for index update check skip.
/**/
VOID FILESetAllIndexMask( FCB *pfcbTable )
	{
	FCB		*pfcbT;
	LONG		*plMax;
	LONG		*plAll;
	UNALIGNED LONG	*plIndex;

	/*	initialize variables.
	/**/
	plMax = (LONG *)pfcbTable->rgbitAllIndex +
		sizeof( pfcbTable->rgbitAllIndex ) / sizeof(LONG);

	/*	initialize mask to clustered index, or to 0s for sequential file.
	/**/
	if ( pfcbTable->pidb != pidbNil )
		{
		memcpy( pfcbTable->rgbitAllIndex,
			pfcbTable->pidb->rgbitIdx,
			sizeof( pfcbTable->pidb->rgbitIdx ) );
		pfcbTable->fAllIndexTagged = pfcbTable->pidb->fidb & fidbHasTagged;
		}
	else
		{
		memset( pfcbTable->rgbitAllIndex,
			'\0',
			sizeof( pfcbTable->rgbitAllIndex ) );
		pfcbTable->fAllIndexTagged = fFalse;
		}

	/*	for each non-clustered index, combine index mask with all index
	/*	mask.  Also, combine has tagged flag.
	/**/
	for ( pfcbT = pfcbTable->pfcbNextIndex;
		pfcbT != pfcbNil;
		pfcbT = pfcbT->pfcbNextIndex )
		{
		plAll = (LONG *) pfcbTable->rgbitAllIndex;
		plIndex = (LONG *) pfcbT->pidb->rgbitIdx;
		for ( ; plAll < plMax; plAll++, plIndex++ )
			{
			*plAll |= *plIndex;
			}

		/*	has tagged flag.
		/**/
		pfcbTable->fAllIndexTagged |= pfcbT->pidb->fidb & fidbHasTagged;
		}

	return;
	}


/*	calls ErrDIRSeekPath to navigate to table root.
/**/
ERR ErrFILESeek( FUCB *pfucb, CHAR *szTable )
	{
	ERR  		err;
	KEY 		rgkey[2];
	BYTE		rgbTableNorm[ JET_cbKeyMost ];

	Assert( pfucb != pfucbNil );

	/*	make seek path from table name
	/**/
	rgkey[0] = *pkeyTables;

	/*	normalize table name and set key
	/**/
	SysNormText( szTable, strlen( szTable ), rgbTableNorm, sizeof( rgbTableNorm ), &rgkey[1].cb );
	rgkey[1].pb = rgbTableNorm;

	err = ErrDIRSeekPath( pfucb, 2, rgkey, 0 );
	switch ( err )
		{
	default:
		return err;
	case JET_errRecordNotFound:
		return JET_errObjectNotFound;
	case errDIRFDP:
		break;
	case JET_errSuccess:
		return JET_errInvalidName;
		}

	return err;
	}


FIELD *PfieldFCBFromColumnName( FCB *pfcb, CHAR *szName )
	{
	FID		fid;
	FIELD		*rgfield;

	/*	find column structure in FDB and change name.  Since
	/*	column may be fixed, variable or tagged, go through
	/*	each column list.
	/**/
	rgfield = pfcb->pfdb->pfieldFixed;

	for ( fid = 0;
		fid < pfcb->pfdb->fidFixedLast; fid++ )
		{
		if ( SysCmpText( rgfield[fid].szFieldName, szName ) == 0 )
			{
			return &rgfield[fid];
			}
		}

	rgfield = pfcb->pfdb->pfieldVar;
	for ( fid = 0;
		fid < pfcb->pfdb->fidVarLast - fidVarLeast + 1; fid++ )
		{
		if ( SysCmpText( rgfield[fid].szFieldName, szName ) == 0 )
			{
			return &rgfield[fid];
			}
		}

	rgfield = pfcb->pfdb->pfieldTagged;
	for ( fid = 0;
		fid < pfcb->pfdb->fidTaggedLast - fidTaggedLeast + 1; fid++ )
		{
		if ( SysCmpText( rgfield[fid].szFieldName, szName ) == 0 )
			{
			return &rgfield[fid];
			}
		}

	/*	must have found column
	/**/
	Assert( fFalse );
	return NULL;
	}


FCB *PfcbFCBFromIndexName( FCB *pfcbTable, CHAR *szName )
	{
	FCB	*pfcb;

	/*	find index FCB and change name.
	/**/
	for ( pfcb = pfcbTable; pfcb != pfcbNil; pfcb = pfcb->pfcbNextIndex )
		{
		if ( pfcb->pidb != NULL &&
			SysCmpText( pfcb->pidb->szName, szName ) == 0 )
			{
			break;
			}
		}
//	Assert( pfcb != pfcbNil );
	return pfcb;
	}

#if 0
FIELD *PfieldFCBFromColumnid( FCB *pfcb, FID fid )
	{
	/*	find column structure in FDB and change name.  Since
	/*	column may be fixed, variable or tagged, go through
	/*	each column list.
	/**/
	if ( FFixedFid( fid ) )
		return pfcb->pfdb->pfieldFixed[fid -fidFixLeast];
	if ( FVarFid( fid ) )
		return pfcb->pfdb->pfieldVar[fid - fidVarLeast];
	if ( FTaggedFid( fid ) )
		return pfcb->pfdb->pfieldVar[fid - fidTaggedLeast];

	/*	must have found column
	/**/
	Assert( fFalse );
	return;
	}
#endif


#ifdef DEBUG
ERR	ErrFILEDumpTable( PIB *ppib, DBID dbid, CHAR *szTable )
	{
	ERR		err = JET_errSuccess;
	FUCB  	*pfucb = pfucbNil;

	Call( ErrFILEOpenTable( ppib, dbid, &pfucb, szTable, JET_bitTableDenyRead ) );

	/*	move to table root
	/**/
	DIRGotoFDPRoot( pfucb );

	/*	dump table
	/**/
	Call( ErrDIRDump( pfucb, 0 ) );

HandleError:
	if ( pfucb != pfucbNil )
		CallS( ErrFILECloseTable( ppib, pfucb ) );

	return err;
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\flddef.c ===
#include "config.h"

#include <string.h>

#include "daedef.h"
#include "fdb.h"
#include "idb.h"
#include "recapi.h"
#include "recint.h"
#include "util.h"

DeclAssertFile;					/* Declare file name for assert macros */

//+API
// ErrRECNewFDB
// ========================================================================
// ErrRECNewFDB(ppfdb, fidFixedLast, fidVarLast, fidTaggedLast)
//		FDB **ppfdb;			// OUT	 receives new FDB
//		FID fidFixedLast;	  // IN	   last fixed field id to be used
//		FID fidVarLast;		  // IN	   last var field id to be used
//		FID fidTaggedLast;	  // IN	   last tagged field id to be used
// Allocates a new FDB, initializing internal elements appropriately.
//
// PARAMETERS
//				ppfdb				receives new FDB
//				fidFixedLast   last fixed field id to be used
//									(should be fidFixedLeast-1 if none)
//				fidVarLast	   last var field id to be used
//									(should be fidVarLeast-1 if none)
//				fidTaggedLast  last tagged field id to be used
//									(should be fidTaggedLeast-1 if none)
// RETURNS		Error code, one of:
//					 JET_errSuccess				Everything worked.
//					-JET_errOutOfMemory	Failed to allocate memory.
// SEE ALSO		ErrRECAddFieldDef
//-
ERR ErrRECNewFDB( FDB **ppfdb, FID fidFixedLast, FID fidVarLast, FID fidTaggedLast)
	{
	INT		iib;						// loop counter
	WORD		cfieldFixed;			// # of fixed fields
	WORD		cfieldVar;				// # of var fields
	WORD		cfieldTagged;			// # of tagged fields
	ULONG		cbAllocate;				// total cb to allocate for this FDB
	FDB  		*pfdb;					// temporary FDB pointer

	Assert(ppfdb != NULL);
	Assert(fidFixedLast <= fidFixedMost);
	Assert(fidVarLast >= fidVarLeast-1 && fidVarLast <= fidVarMost);
	Assert(fidTaggedLast >= fidTaggedLeast-1 && fidTaggedLast <= fidTaggedMost);
						
	/*** Calculate how many of each field type to allocate ***/
	cfieldFixed = fidFixedLast + 1 - fidFixedLeast;
	cfieldVar = fidVarLast + 1 - fidVarLeast;
	cfieldTagged = fidTaggedLast + 1 - fidTaggedLeast;

	/*** Allocate entire block of memory at once ***/
	cbAllocate = sizeof(FDB)								// pfdb
				+ cfieldFixed * sizeof(FIELD)				// pfdb->pfieldFixed
				+ cfieldVar * sizeof(FIELD)				// pfdb->pfieldVar
				+ cfieldTagged * sizeof(FIELD)			// pfdb->pfieldTagged
				+ (cfieldFixed+1) * sizeof(WORD);		// pfdb->pibFixedOffsets
	if ((pfdb = (FDB*)SAlloc(cbAllocate)) == NULL)
		return JET_errOutOfMemory;
	memset((BYTE*)pfdb, '\0', cbAllocate);

	/*** Fill in max field id numbers ***/
	pfdb->fidFixedLast = fidFixedLast;
	pfdb->fidVarLast = fidVarLast;
	pfdb->fidTaggedLast = fidTaggedLast;

	/*** Set pointers into memory area ***/
	pfdb->pfieldFixed = (FIELD*)((BYTE*)pfdb + sizeof(FDB));
	pfdb->pfieldVar = pfdb->pfieldFixed + cfieldFixed;
	pfdb->pfieldTagged = pfdb->pfieldVar + cfieldVar;
	pfdb->pibFixedOffsets = (WORD*)(pfdb->pfieldTagged + cfieldTagged);

	/*** Initialize fixed field offset table ***/
	for ( iib = 0; iib <= cfieldFixed; iib++ )
		pfdb->pibFixedOffsets[iib] = sizeof(RECHDR);

	/*** Set output parameter and return ***/
	*ppfdb = pfdb;
	return JET_errSuccess;
	}


//+API
// ErrRECAddFieldDef
// ========================================================================
// ErrRECAddFieldDef(pfdb, fid, pfieldNew)
//		FDB *pfdb;				  // INOUT	 FDB to add field definition to
//		FID fid;			// IN	   field id of new field
//		FIELD *pfieldNew;
// Adds a field descriptor to an FDB.
//
// PARAMETERS	pfdb			FDB to add new field definition to
//				fid				field id of new field (should be within
//									the ranges imposed by the parameters
//									supplied to ErrRECNewFDB)
//				ftFieldType		data type of field
//				cbField			field length (only important when
//									defining fixed textual fields)
//				bFlags			field behaviour flags:
//					VALUE				MEANING
//					========================================
//					ffieldNotNull		Field may not contain NULL values.
//				szFieldName		name of field
// RETURNS		Error code, one of:
//					 JET_errSuccess			Everything worked.
//					-ColumnInvalid				Field id given is greater than
//													the maximum which was given
//													to ErrRECNewFDB.
//					-JET_errBadColumnId		A nonsensical field id was given.
//					-errFLDInvalidFieldType The field type given is either
//													undefined, or is not acceptable
//													for this field id.
// COMMENTS		When adding a fixed field, the fixed field offset table
//					in the FDB is recomputed.
// SEE ALSO		ErrRECNewFDB
//-
ERR ErrRECAddFieldDef( FDB *pfdb, FID fid, FIELD *pfieldNew )
	{
	FIELD			*pfield;							// Pointer to new field's descriptor.
	WORD			cb;								// Length of fixed field.
	WORD			*pib;								// Loop counters.
	WORD			*pibMost;						// Loop counters.
	JET_COLTYP	coltyp = pfieldNew->coltyp;

	Assert( pfdb != pfdbNil );
	/*	fixed field: determine length, either from field type
	/*	or from parameter (for text/binary types)
	/**/
	if ( FFixedFid( fid ) )
		{
		if ( fid > pfdb->fidFixedLast )
			return JET_errColumnNotFound;
		Assert(pfdb->pfieldFixed != NULL);
		pfield = &pfdb->pfieldFixed[fid-fidFixedLeast];
		switch ( coltyp )
			{
			default:
				return JET_errInvalidColumnType;
			case JET_coltypBit:
			case JET_coltypUnsignedByte:
				cb = sizeof(BYTE);
				break;
			case JET_coltypShort:
				cb = sizeof(SHORT);
				break;
			case JET_coltypLong:
			case JET_coltypIEEESingle:
				cb = sizeof(long);
				break;
			case JET_coltypCurrency:
			case JET_coltypIEEEDouble:
			case JET_coltypDateTime:
				cb = 8;//sizeof(DREAL);
				break;
			case JET_coltypBinary:
			case JET_coltypText:
				cb = (WORD)pfieldNew->cbMaxLen;
				break;
			}
		Assert(pfdb->pibFixedOffsets != NULL);
		/*	shift fixed field offsets by length of newly added field
		/**/
		pibMost = pfdb->pibFixedOffsets + pfdb->fidFixedLast;
		for (pib = pfdb->pibFixedOffsets + fid; pib <= pibMost; pib++)
			*pib += cb;
		}
	else if ( FVarFid( fid ) )
		{
		/*	Var field: check for bogus numeric and "long" types
		/**/
		if (fid > pfdb->fidVarLast)
			return JET_errColumnNotFound;
		Assert(pfdb->pfieldVar != NULL);
		pfield = &pfdb->pfieldVar[fid-fidVarLeast];
		if ( coltyp != JET_coltypBinary && coltyp != JET_coltypText )
			return JET_errInvalidColumnType;
		}
	else if ( FTaggedFid( fid ) )
		{
		/*	tagged field: any type is ok
		/**/
		if (fid > pfdb->fidTaggedLast)
			return JET_errColumnNotFound;
		Assert(pfdb->pfieldTagged != NULL);
		pfield = &pfdb->pfieldTagged[fid-fidTaggedLeast];
		}
	else
		return JET_errBadColumnId;

	/*	initialize field descriptor from parameters
	/**/
	*pfield = *pfieldNew;
	return JET_errSuccess;
	}


//+API
// ErrRECNewIDB
// ========================================================================
// ErrRECNewIDB( IDB **ppidb )
//
// Allocates a new IDB.
//
// PARAMETERS	ppidb			receives new IDB
// RETURNS		Error code, one of:
//					 JET_errSuccess				Everything worked.
//					-JET_errOutOfMemory	Failed to allocate memory.
// SEE ALSO		ErrRECAddKeyDef, RECFreeIDB
//-
ERR ErrRECNewIDB( IDB **ppidb )
	{
	Assert(ppidb != NULL);
	if ( ( *ppidb = PidbMEMAlloc() ) == NULL )
		return JET_errOutOfMemory;
	memset( (BYTE *)*ppidb, '\0', sizeof(IDB) );
	return JET_errSuccess;
	}


//+API
// ErrRECAddKeyDef
// ========================================================================
//	ERR ErrRECAddKeyDef( 
//		FDB		*pfdb, 
//		IDB		*pidb, 
//		BYTE		iidxsegMac, 
//		IDXSEG	*rgidxseg, 
//		BYTE		bFlags, 
//		LANGID	langid )
//
// Adds a key definition to an IDB.	 Actually, since an IDB can only hold
// one key definition, "adding" is really "defining/overwriting".
//
// PARAMETERS
//				pfdb			field info for index (should contain field
//								definitions for each segment of the key)
//				pidb			IDB of index being defined
//				iidxsegMac	number of key segments
//				rgidxseg		key segment specifiers:	 each segment id
//								is really a field id, except that it is
//								should be the negative of the field id
//								if the field should be descending in the key.
//				bFlags		key behaviour flags:
//					VALUE				MEANING
//					========================================
//					fidbUnique			Specifies that duplicate entries
//											in this index are not allowed.
// RETURNS		Error code, one of:
//					 JET_errSuccess			Everything worked.
//					-errFLDTooManySegments	The number of key segments
//												specified is greater than the
//												maximum number allowed.
//					-ColumnInvalid			A segment id was specified for
//												which there is no field defined.
//					-JET_errBadColumnId	One of the segment ids in the
//												key is nonsensical.
// SEE ALSO		ErrRECNewIDB, RECFreeIDB
//-
ERR ErrRECAddKeyDef( FDB *pfdb, IDB *pidb, BYTE iidxsegMac, IDXSEG *rgidxseg, BYTE bFlags, LANGID langid  )
	{
	FID					fid;
	FIELD					*pfield;
	UNALIGNED IDXSEG	*pidxseg;
	IDXSEG 				*pidxsegMac;

	Assert( pfdb != pfdbNil );
	Assert( pidb != pidbNil );
	Assert( rgidxseg != NULL );
	if ( iidxsegMac > JET_ccolKeyMost )
		return errFLDTooManySegments;

	/*	check validity of each segment id and
	/*	also set index mask bits
	/**/
	pidxsegMac = rgidxseg+iidxsegMac;
	for ( pidxseg = rgidxseg; pidxseg < pidxsegMac; pidxseg++ )
		{
		/*	field id is absolute value of segment id
		/**/
		fid = *pidxseg >= 0 ? *pidxseg : -(*pidxseg);
		if ( FFixedFid( fid ) )
			{
			if ( fid > pfdb->fidFixedLast )
				return JET_errColumnNotFound;
			pfield = &pfdb->pfieldFixed[fid-fidFixedLeast];
			if ( pfield->coltyp == JET_coltypNil )
				return JET_errColumnNotFound;
			fid -= fidFixedLeast;
			pidb->rgbitIdx[fid/8] |= 1 << fid%8;
			}
		else if ( FVarFid( fid ) )
			{
			if ( fid > pfdb->fidVarLast )
				return JET_errColumnNotFound;
			pfield = &pfdb->pfieldVar[fid-fidVarLeast];
			if ( pfield->coltyp == JET_coltypNil )
				return JET_errColumnNotFound;
			fid -= fidVarLeast;
			pidb->rgbitIdx[16+fid/8] |= 1 << fid%8;
			}
		else if ( FTaggedFid( fid ) )
			{
			if ( fid > pfdb->fidTaggedLast )
				return JET_errColumnNotFound;
			pfield = &pfdb->pfieldTagged[fid-fidTaggedLeast];
			if ( pfield->coltyp == JET_coltypNil )
				return JET_errColumnNotFound;
			pidb->fidb |= fidbHasTagged;
			if ( pfield->ffield & ffieldMultivalue )
				pidb->fidb |= fidbHasMultivalue;
			}
		else
			return JET_errBadColumnId;
		}

	/*	copy info into IDB
	/**/
	pidb->iidxsegMac = iidxsegMac;
	pidb->fidb |= bFlags;
	memcpy( pidb->rgidxseg, rgidxseg, iidxsegMac * sizeof(IDXSEG) );
	pidb->langid = langid;

	return JET_errSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\fdelete.c ===
#include "config.h"

#include <string.h>

#include "daedef.h"
#include "pib.h"
#include "util.h"
#include "fmp.h"
#include "page.h"
#include "ssib.h"
#include "fucb.h"
#include "fcb.h"
#include "stapi.h"
#include "fdb.h"
#include "idb.h"
#include "fileint.h"
#include "recint.h"
#include "logapi.h"
#include "nver.h"
#include "dirapi.h"
#include "recapi.h"
#include "fileapi.h"
#include "dbapi.h"
#include "systab.h"
#include "bm.h"

DeclAssertFile;						/* Declare file name for assert macros */

#ifdef DEBUG
//#define TRACE
#endif

//+API
// ErrIsamDeleteTable
// ========================================================================
// ERR ErrIsamDeleteTable( PIB *ppib, ULONG_PTR vdbid, CHAR *szName )
//
// Calls ErrFILEIDeleteTable to
// delete a file and all indexes associated with it.
//
// RETURNS		JET_errSuccess or err from called routine.
//
// SEE ALSO		ErrIsamCreateTable
//-
ERR VTAPI ErrIsamDeleteTable( PIB *ppib, ULONG_PTR vdbid, CHAR *szName )
	{
	ERR			err;
	DBID	   	dbid = DbidOfVDbid (vdbid);
	CHAR	   	szTable[(JET_cbNameMost + 1)];
	OBJID	   	objid;
	JET_OBJTYP	objtyp;

	/* ensure that database is updatable
	/**/
	CallR( VDbidCheckUpdatable( vdbid ) );

	CheckPIB( ppib );
	CheckDBID( ppib, dbid );
	CallR( ErrCheckName( szTable, szName, (JET_cbNameMost + 1) ) );
	
#ifdef	SYSTABLES
	if ( FSysTabDatabase( dbid ) )
		{
		err = ErrFindObjidFromIdName( ppib, dbid, objidTblContainer, szTable, &objid, &objtyp );
		if ( err < 0 )
			{
			return err;
			}
		else		
			{
			if ( objtyp == JET_objtypQuery || objtyp == JET_objtypLink || objtyp == JET_objtypSQLLink )
				{
				err = ErrIsamDeleteObject( (JET_SESID)ppib, vdbid, objid );
				return err;
				}
			}
		}
#endif	/* SYSTABLES */

	err = ErrFILEDeleteTable( ppib, dbid, szName );
	return err;
	}


// ErrFILEDeleteTable
// ========================================================================
// ERR ErrFILEDeleteTable( PIB *ppib, DBID dbid, CHAR *szName )
//
// Deletes a file and all indexes associated with it.
//
// RETURNS		JET_errSuccess or err from called routine.
//
// COMMENTS		
//	Acquires an exclusive lock on the file [FCBSetDelete].
//	A transaction is wrapped around this function.	Thus,
//	any work done will be undone if a failure occurs.
//	Transaction logging is turned off for temporary files.
//
// SEE ALSO		ErrIsamCreateTable
//-
ERR ErrFILEDeleteTable( PIB *ppib, DBID dbid, CHAR *szTable )
	{
	ERR   	err;
	FUCB  	*pfucb = pfucbNil;
	PGNO  	pgnoFDP;
	BOOL  	fSetDomainOperation = fFalse;
	FCB	  	*pfcb;
	FCB	  	*pfcbT;

	CheckPIB( ppib );
	CheckDBID( ppib, dbid );

	CallR( ErrDIRBeginTransaction( ppib ) );

	/*	open cursor on database
	/**/
	Call( ErrDIROpen( ppib, pfcbNil, dbid, &pfucb ) );

	/*	seek to table without locking
	/**/
	Call( ErrFILESeek( pfucb, szTable ) );
	Assert( ppib != ppibNil );
	Assert( ppib->level < levelMax );
	Assert( PcsrCurrent( pfucb ) != pcsrNil );
	Assert( PcsrCurrent( pfucb )->csrstat == csrstatOnFDPNode );
	pgnoFDP = PcsrCurrent( pfucb )->pgno;

	/* abort if index is being built on file
	/**/
	if ( FFCBDenyDDL( pfucb->u.pfcb, ppib ) )
		{
		err = JET_errWriteConflict;
		goto HandleError;
		}

    /*  get table FCB or sentinel FCB
    /**/
    pfcb = PfcbFCBGet( dbid, pgnoFDP );
    /* wait for other domain operation
    /**/
    while ( pfcb != pfcbNil && FFCBDomainOperation( pfcb ) )
        {
        BFSleep( cmsecWaitGeneric );
        pfcb = PfcbFCBGet( dbid, pgnoFDP );
        }
    if ( pfcb != pfcbNil )
        {
        FCBSetDomainOperation( pfcb );
        fSetDomainOperation = fTrue;
        }

	/*	handle error for above call
	/**/
	Call( ErrFCBSetDeleteTable( ppib, dbid, pgnoFDP ) );
    if ( pfcb == pfcbNil )
        {
        pfcb = PfcbFCBGet( dbid, pgnoFDP );
        Assert( pfcb != pfcbNil );
        }

	FCBSetDenyDDL( pfucb->u.pfcb, ppib );
	err = ErrVERFlag( pfucb, operDeleteTable, &pgnoFDP, sizeof(pgnoFDP) );
	if ( err < 0 )
		{
		FCBResetDenyDDL( pfucb->u.pfcb );
		FCBResetDeleteTable( dbid, pgnoFDP );
		goto HandleError;
		}

	/*	delete table FDP pointer node.  This will recursively delete
	/*	table and free table space.  Note that table space is defer
	/*	freed until commit to transaction level 0.  This is done to
	/*	facillitate rollback.
	/**/
	Call( ErrDIRDelete( pfucb, fDIRVersion ) );

	/* remove MPL entries for this table and all indexes
	/**/
	Assert( pfcb->pgnoFDP == pgnoFDP );
	for ( pfcbT = pfcb; pfcbT != pfcbNil; pfcbT = pfcbT->pfcbNextIndex )
		{
		Assert( dbid == pfcbT->dbid );
		MPLPurgeFDP( dbid, pfcbT->pgnoFDP );
		FCBSetDeletePending( pfcbT );
		}
	
	DIRClose( pfucb );
	pfucb = pfucbNil;

#ifdef	SYSTABLES
	/*	remove table record from MSysObjects before committing.
	/*	Also remove associated columns and indexes in MSC/MSI.
	/*	Pass 0 for tblid; MSO case in STD figures it out.
	/**/
	if ( dbid != dbidTemp )
		{
		Call( ErrSysTabDelete( ppib, dbid, itableSo, szTable, 0 ) );
		}
#endif	/* SYSTABLES */

#ifdef TRACE
	FPrintF2( "delete table at %d.%lu\n", pfcb->dbid, pfcb->pgnoFDP );
#endif
    if ( fSetDomainOperation )
        FCBResetDomainOperation( pfcb );
	Call( ErrDIRCommitTransaction( ppib ) );
	return err;

HandleError:
	if ( fSetDomainOperation )
		FCBResetDomainOperation( pfcb );
	if ( pfucb != pfucbNil )
		DIRClose( pfucb );
	CallS( ErrDIRRollback( ppib ) );
	return err;
	}


//+API
// DeleteIndex
// ========================================================================
// ERR DeleteIndex( PIB *ppib, FUCB *pfucb, CHAR *szIndex )
//
// Deletes an index definition and all index entries it contains.
//
// PARAMETERS	ppib						PIB of user
// 				pfucb						Exclusively opened FUCB on file
// 				szName						name of index to delete
// RETURNS		Error code from DIRMAN or
//					JET_errSuccess		  	 Everything worked OK.
//					-TableInvalid			 There is no file corresponding
// 											 to the file name given.
//					-TableNoSuchIndex		 There is no index corresponding
// 											 to the index name given.
//					-IndexMustStay			 The clustered index of a file may
// 											 not be deleted.
// COMMENTS		
//		There must not be anyone currently using the file.
//		A transaction is wrapped around this function.	Thus,
//		any work done will be undone if a failure occurs.
//		Transaction logging is turned off for temporary files.
// SEE ALSO		DeleteTable, CreateTable, CreateIndex
//-
ERR VTAPI ErrIsamDeleteIndex( PIB *ppib, FUCB *pfucb, CHAR *szName )
	{
	ERR		err;
	CHAR	szIndex[ (JET_cbNameMost + 1) ];
	BYTE	rgbIndexNorm[ JET_cbKeyMost ];
	DIB		dib;
	KEY		key;
	FCB		*pfcb;
	FCB		*pfcbIdx;

	CheckPIB( ppib );
	CheckTable( ppib, pfucb );
	CallR( ErrCheckName( szIndex, szName, ( JET_cbNameMost + 1 ) ) );

	/* ensure that table is updatable
	/**/
	CallR( FUCBCheckUpdatable( pfucb )  );

	Assert( ppib != ppibNil );
	Assert( pfucb != pfucbNil );
	Assert( pfucb->u.pfcb != pfcbNil );
	pfcb = pfucb->u.pfcb;

	/* wait for other domain operation
	/**/
	while ( FFCBDomainOperation( pfcb ) )
		{
		BFSleep( cmsecWaitGeneric );
		}
	FCBSetDomainOperation( pfcb );

	/*	normalize index and set key to normalized index
	/**/
	SysNormText( szIndex, strlen( szIndex ), rgbIndexNorm, sizeof( rgbIndexNorm ), &key.cb );
	key.pb = rgbIndexNorm;

	err = ErrDIRBeginTransaction( ppib );
	if ( err < 0 )
		{
		FCBResetDomainOperation( pfcb );
		return err;
		}

	/*	move to FDP root
	/**/
	DIRGotoFDPRoot( pfucb );

	/*	down to indexes, check against clustered index name
	/**/
	dib.pos = posDown;
	dib.pkey = (KEY *)pkeyIndexes;
	dib.fFlags = fDIRNull;
	Call( ErrDIRDown( pfucb, &dib ) );
	if ( pfucb->lineData.cb != 0 &&
		pfucb->lineData.cb == key.cb &&
		memcmp( pfucb->lineData.pb, rgbIndexNorm, pfucb->lineData.cb ) == 0 )
		{
		err = JET_errIndexMustStay;
		goto HandleError;
		}

	/*	down to index node
	/**/
	Assert( dib.pos == posDown );
	dib.pkey = &key;
	Assert( dib.fFlags == fDIRNull );
	Call( ErrDIRDown( pfucb, &dib ) );
	if ( err == wrnNDFoundLess || err == wrnNDFoundGreater )
		{
		err = JET_errIndexNotFound;
		goto HandleError;
		}

	/* abort if DDL is being done on file
	/**/
	if ( FFCBDenyDDL( pfcb, ppib ) )
		{
		err = JET_errWriteConflict;
		goto HandleError;
		}
	FCBSetDenyDDL( pfcb, ppib );
	
	/*	flag delete index
	/**/
	pfcbIdx = PfcbFCBFromIndexName( pfcb, szIndex );
	if ( pfcbIdx == NULL )
		{
		// NOTE:	This case goes away when the data structures
		//			are versioned also.
		//			This case means basically, that another session
		//			has changed this index BUT has not committed to level 0
		//			BUT has changed the RAM data structures.
		FCBResetDenyDDL( pfcb );
		err = JET_errWriteConflict;
		goto HandleError;
		}

	err = ErrFCBSetDeleteIndex( ppib, pfcb, szIndex );
	if ( err < 0 )
		{
		FCBResetDenyDDL( pfcb );
		goto HandleError;
		}
	err = ErrVERFlag( pfucb, operDeleteIndex, &pfcbIdx, sizeof(pfcbIdx) );
	if ( err < 0 )
		{
		FCBResetDeleteIndex( pfcbIdx );
		FCBResetDenyDDL( pfcb );
		goto HandleError;
		}

	/*	purge MPL entries -- must be done after FCBSetDeletePending
	/**/
	MPLPurgeFDP( pfucb->dbid, pfcbIdx->pgnoFDP );
	
	/*	assert not deleting current non-clustered index
	/**/
	Assert( pfucb->pfucbCurIndex == pfucbNil ||
		SysCmpText( szIndex, pfucb->pfucbCurIndex->u.pfcb->pidb->szName ) != 0 );

	/*	delete index node
	/**/
	Call( ErrDIRDelete( pfucb, fDIRVersion ) );

	/*	back up to file node
	/**/
	DIRUp( pfucb, 2 );

	/*	update index count and DDL time stamp
	/**/
	Call( ErrFILEIUpdateFDPData( pfucb, fDropIndexCount | fDDLStamp ) );

#ifdef	SYSTABLES
	/*	remove index record from MSysIndexes before committing...
	/**/
	if ( FSysTabDatabase( pfucb->dbid ) )
		{
		Call( ErrSysTabDelete( ppib, pfucb->dbid, itableSi, szIndex, pfucb->u.pfcb->pgnoFDP ) );
		}
#endif	/* SYSTABLES */

	Call( ErrDIRCommitTransaction( ppib ) );

	/*	set currency to before first
	/**/
	DIRBeforeFirst( pfucb );
#ifdef TRACE
	FPrintF2( "delete index at %d.%lu\n", pfcbIdx->dbid, pfcbIdx->pgnoFDP );
#endif
	FCBResetDomainOperation( pfcb );
 	return JET_errSuccess;

HandleError:
	CallS( ErrDIRRollback( ppib ) );
	FCBResetDomainOperation( pfcb );
	return err;
	}


ERR VTAPI ErrIsamDeleteColumn( PIB *ppib, FUCB *pfucb, CHAR *szName )
	{
	ERR  			  		err;
	DIB  			  		dib;
	INT 			  		iidxseg;
	KEY  			  		key;
	CHAR			  		szColumn[ (JET_cbNameMost + 1) ];
	BYTE			  		rgbColumnNorm[ JET_cbKeyMost ];
	FCB			  			*pfcb;
	LINE					lineField;
	FIELDDEFDATA  			fdd;
	FCB			  			*pfcbIndex;

	CheckPIB( ppib );
	CheckTable( ppib, pfucb );
	CallR( ErrCheckName( szColumn, szName, (JET_cbNameMost + 1) ) );

	/* ensure that table is updatable
	/**/
	CallR( FUCBCheckUpdatable( pfucb ) );

	Assert( ppib != ppibNil );
	Assert( pfucb != pfucbNil );
	Assert( pfucb->u.pfcb != pfcbNil );
	pfcb = pfucb->u.pfcb;
//	if ( !( FFCBDenyReadByUs( pfcb, ppib ) ) )
//		return JET_errTableNotLocked;

	/* normalize column name and set key
	/**/
	SysNormText( szColumn, strlen( szColumn ), rgbColumnNorm, sizeof( rgbColumnNorm ), &key.cb );
	key.pb = rgbColumnNorm;

	CallR( ErrDIRBeginTransaction( ppib ) );

	/* abort if DDL is being done on file
	/**/
	if ( FFCBDenyDDL( pfcb, ppib ) )
		{
		err = JET_errWriteConflict;
		goto HandleError;
		}
	FCBSetDenyDDL( pfcb, ppib );
	
	err = ErrVERFlag( pfucb, operDeleteColumn, (VOID *)&pfcb->pfdb, sizeof(pfcb->pfdb) );
	if ( err < 0 )
		{
		FCBResetDenyDDL( pfcb );
		}
	
	/*	move to FDP root and update FDP timestamp
	/**/
	DIRGotoFDPRoot( pfucb );
	Call( ErrFILEIUpdateFDPData( pfucb, fDDLStamp ) );

	/*	down to fields\rgbColumnNorm to find field id (and verify existance)
	/**/
	dib.pos = posDown;
	dib.pkey = (KEY *)pkeyFields;
	dib.fFlags = fDIRNull;
	Call( ErrDIRDown( pfucb, &dib ) );
	dib.pkey = &key;
	err = ErrDIRDown( pfucb, &dib );
	if ( err != JET_errSuccess )
		{
		err = JET_errColumnNotFound;
		goto HandleError;
		}
	fdd = *(FIELDDEFDATA *)pfucb->lineData.pb;

	/*	search for column in use in indexes
	/**/
	for ( pfcbIndex = pfucb->u.pfcb;
		pfcbIndex != pfcbNil;
		pfcbIndex = pfcbIndex->pfcbNextIndex )
		{
		if ( pfcbIndex->pidb != NULL )
			{
			for ( iidxseg = 0;
				iidxseg < pfcbIndex->pidb->iidxsegMac;
				iidxseg++ )
				{
				if ( pfcbIndex->pidb->rgidxseg[iidxseg] < 0 )
					{
					if ( (FID)( -pfcbIndex->pidb->rgidxseg[iidxseg] ) == fdd.fid )
						Call( JET_errColumnInUse );
					}
				else
					{
					if ( (FID)pfcbIndex->pidb->rgidxseg[iidxseg] == fdd.fid )
						Call( JET_errColumnInUse );
					}
				}
			}
		}

	Call( ErrDIRDelete( pfucb, fDIRVersion ) );

	/*	if fixed field, insert a placeholder for computing offsets
	/**/
	if ( fdd.fid <= fidFixedMost )
		{
		BYTE	bSav = *rgbColumnNorm;

		fdd.bFlags = ffieldDeleted;			//	flag deleted fixed field
		fdd.cbDefault = 0;					//	get rid of the default value
		*rgbColumnNorm = ' ';				//	clobber the key
		key.cb = 1;							//	(any value will work)
		lineField.pb = (BYTE *)&fdd;		//	point to the field definition
		lineField.cb = sizeof(fdd);

		/*	up to the FIELDS node
		/**/
		DIRUp( pfucb, 1 );
		Call( ErrDIRInsert(pfucb, &lineField, &key, fDIRVersion | fDIRDuplicate ) );
		*rgbColumnNorm = bSav;
		}

	/*	up to "FIELDS" node
	/**/
	DIRUp( pfucb, 1 );

	/*	rebuild FDB and default record value
	/**/
	Call( ErrDIRGet( pfucb ) );
	Call( ErrFDBConstruct(pfucb, pfcb, fTrue /*fBuildDefault*/ ) );

	/*	set currencies at BeforeFirst and remove unused CSR
	/**/
	DIRUp( pfucb, 1 );
	Assert( PcsrCurrent( pfucb ) != pcsrNil );
	PcsrCurrent( pfucb )->csrstat = csrstatBeforeFirst;
	if ( pfucb->pfucbCurIndex != pfucbNil )
		{
		Assert( PcsrCurrent( pfucb->pfucbCurIndex ) != pcsrNil );
		PcsrCurrent( pfucb->pfucbCurIndex )->csrstat = csrstatBeforeFirst;
		}

#ifdef SYSTABLES
	/*	remove column record from MSysColumns before committing...
	/**/
	if ( FSysTabDatabase( pfucb->dbid ) )
		{
		Call( ErrSysTabDelete( ppib, pfucb->dbid, itableSc, szColumn, pfucb->u.pfcb->pgnoFDP ) );
		}
#endif	/* SYSTABLES */

	Call( ErrDIRCommitTransaction( ppib ) );

	return JET_errSuccess;

HandleError:
	CallS( ErrDIRRollback( ppib ) );
	return err;
	}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\flddnorm.c ===
#include "config.h"

#include <string.h>
#include <stdlib.h>

#include "daedef.h"
#include "pib.h"
#include "ssib.h"
#include "fmp.h"
#include "page.h"
#include "fcb.h"
#include "fucb.h"
#include "stapi.h"
#include "dirapi.h"
#include "fdb.h"
#include "idb.h"
#include "recapi.h"
#include "recint.h"

DeclAssertFile;					/* Declare file name for assert macros */

//+API
// ErrRECDenormalizeKey
// ========================================================================
// ErrRECDenormalizeKey(pfdb, pidb, pkey, plineValues)
//		FDB *pfdb;				// IN	 field info for index
//		IDB *pidb;				// IN	 IDB of index defining key
//		KEY *pkey;				// IN	 key in normalized form
//		LINE *plineValues;			// OUT	 receives value list
// Converts a normalized key into a list of field values.  This function
// is the inverse of ErrRECNormalizeKey.
//
// PARAMETERS	
//				pfdb		 field info for index
//				pidb		 IDB of index defining key
//				pkey		 key in normalized form
//				plineValues	 plineValues->pb must point to a buffer large
//							 enough to hold the denormalized key.  A buffer
//							 of JET_cbKeyMost bytes is sufficient.  The values
//							 will be prefixed by one byte length counts,
//							 and concatenated into plineValues->pb.
// RETURNS		JET_errSuccess
// COMMENTS		Some types of fields may not denormalize with complete
//				accuracy.  For example, denormalizing a field of type
//				"Text" (which is case-insensitive), will result in a
//				field value in all upper-case.
//				Will not denormalize a Database Key (DBK).
// SEE ALSO		ErrRECNormalizeKey, ErrRECExtractKey
//-
ERR ErrRECDenormalizeKey( FDB *pfdb, IDB *pidb, KEY *pkey, LINE *plineValues )
	{
	ERR		err = JET_errSuccess;
	IDXSEG	*pidxseg, *pidxsegMac;
	BYTE		*pbKey;		// runs through key bytes
	BYTE		*pbKeyMax;	// end of key
	BYTE		*pbVal;		// end of plineValues->pb

	Assert( pfdb != pfdbNil );
	Assert( pidb != pidbNil );
	Assert( !FKeyNull(pkey) );
	Assert( plineValues != NULL );
	Assert( plineValues->pb != NULL );
	pbKey = pkey->pb;
	pbKeyMax = pbKey + pkey->cb;
	pbVal = plineValues->pb;
	pidxseg = pidb->rgidxseg;
	pidxsegMac = pidxseg + pidb->iidxsegMac;
	for (; pidxseg < pidxsegMac && pbKey < pbKeyMax; pidxseg++ )
		{
		FID			fid;							// Field id of segment.
		JET_COLTYP 	coltyp;						// Type of field.
		INT	 		cbField;						// Length of field data.
		BOOL 			fDescending;				// Segment is in desc. order.
		BOOL 			fFixedField = fFalse;	// Current field is fixed-length?
		WORD 			w;								// Temp var.
		ULONG 		ul;							// Temp var.
		BYTE 			mask;

		/*** Negative field id means descending in the key ***/
		fDescending = ( *pidxseg < 0 );
		fid = fDescending ? -(*pidxseg) : *pidxseg;
		mask = (BYTE)(fDescending ? 0xff : 0x00);

		/*** Determine field type from FDB ***/
		if ( FFixedFid(fid) )
			{
			Assert(fid <= pfdb->fidFixedLast);
			coltyp = pfdb->pfieldFixed[fid-fidFixedLeast].coltyp;
			fFixedField = fTrue;
			}
		else if ( FVarFid(fid) )
			{
			Assert(fid <= pfdb->fidVarLast);
			coltyp = pfdb->pfieldVar[fid-fidVarLeast].coltyp;
			Assert( coltyp == JET_coltypBinary || coltyp == JET_coltypText );
			}
		else
			{
			Assert( FTaggedFid( fid ) );
			Assert(fid <= pfdb->fidTaggedLast);
			coltyp = pfdb->pfieldTagged[fid-fidTaggedLeast].coltyp;
			}

		Assert( coltyp != JET_coltypNil );

		switch ( coltyp ) {
			default:
				Assert( fFalse );

			case JET_coltypBit:
			case JET_coltypUnsignedByte:
				if ( *pbKey++ == (BYTE)(mask ^ 0) )
					*pbVal++ = 0;
				else
					{
					Assert( pbKey[-1] == (BYTE)(mask ^ (BYTE)0x7f) );
					*pbVal++ = 1;
					*pbVal++ = ( coltyp == JET_coltypUnsignedByte ) ?
					   (BYTE)( mask ^ *pbKey++ ) :
					   bFlipHighBit( mask ^ *pbKey++ );
					}
				break;

			case JET_coltypShort:
				if ( *pbKey++ == (BYTE)(mask ^ 0) )
					*pbVal++ = 0;
				else
					{
					Assert( pbKey[-1] == (BYTE)(mask ^ (BYTE)0x7f) );
					w = ((mask ^ pbKey[0]) << 8) + (BYTE)(mask ^ pbKey[1]);
					pbKey += 2;
					*pbVal++ = 2;
					*(WORD *)pbVal = wFlipHighBit(w);
					pbVal += 2;
					}
				break;

			case JET_coltypLong:
				if ( *pbKey++ == (BYTE)(mask ^ 0) )
					*pbVal++ = 0;
				else
					{
					Assert(pbKey[-1] == (BYTE)(mask ^ (BYTE)0x7f));
					ul = ((ULONG)(mask ^ (UINT)pbKey[0])<<24) +
						 ((ULONG)(BYTE)(mask ^ (UINT)pbKey[1])<<16) +
						 ((mask ^ (UINT)pbKey[2])<<8) +
						 (BYTE)(mask ^ (UINT)pbKey[3]);
					pbKey += 4;
					*pbVal++ = 4;
					*(ULONG*)pbVal = ulFlipHighBit(ul);
					pbVal += 4;
					}
				break;

			case JET_coltypIEEESingle:
				if ( fDescending )
					{
					if ( *pbKey++ == (BYTE)~0 )
						*pbVal++ = 0;
					else
						{
						Assert( pbKey[-1] == (BYTE)~0x7f );
						*pbVal++ = 4;
						if ( pbKey[0] & maskByteHighBit )
							{
							pbVal[0] = pbKey[3];
							pbVal[1] = pbKey[2];
							pbVal[2] = pbKey[1];
							pbVal[3] = pbKey[0];
							}
						else
							{
							pbVal[0] = (BYTE)~pbKey[3];
							pbVal[1] = (BYTE)~pbKey[2];
							pbVal[2] = (BYTE)~pbKey[1];
							pbVal[3] = bFlipHighBit(~pbKey[0]);
							}
						pbKey += 4;
						pbVal += 4;
						}
					}
				else
					{
					if ( *pbKey++ == 0 )
						*pbVal++ = 0;
					else
						{
						Assert( pbKey[-1] == 0x7f );
						*pbVal++ = 4;
						if ( pbKey[0] & maskByteHighBit )
							{
							pbVal[0] = pbKey[3];
							pbVal[1] = pbKey[2];
							pbVal[2] = pbKey[1];
							pbVal[3] = bFlipHighBit(pbKey[0]);
							}
						else
							{
							pbVal[0] = (BYTE)~pbKey[3];
							pbVal[1] = (BYTE)~pbKey[2];
							pbVal[2] = (BYTE)~pbKey[1];
							pbVal[3] = (BYTE)~pbKey[0];
							}
						pbKey += 4;
						pbVal += 4;
						}
					}
				break;

			case JET_coltypCurrency:
			case JET_coltypIEEEDouble:
			case JET_coltypDateTime:
				if ( fDescending )
					{
					if ( *pbKey++ == (BYTE)~0 )
						*pbVal++ = 0;
					else
						{
						Assert( pbKey[-1] == (BYTE)~0x7f );
						*pbVal++ = 8;
						if ( coltyp != JET_coltypCurrency &&
							(pbKey[0] & maskByteHighBit) )
							{
							pbVal[0] = pbKey[7];
							pbVal[1] = pbKey[6];
							pbVal[2] = pbKey[5];
							pbVal[3] = pbKey[4];
							pbVal[4] = pbKey[3];
							pbVal[5] = pbKey[2];
							pbVal[6] = pbKey[1];
							pbVal[7] = pbKey[0];
							}
						else
							{
							pbVal[0] = (BYTE)~pbKey[7];
							pbVal[1] = (BYTE)~pbKey[6];
							pbVal[2] = (BYTE)~pbKey[5];
							pbVal[3] = (BYTE)~pbKey[4];
							pbVal[4] = (BYTE)~pbKey[3];
							pbVal[5] = (BYTE)~pbKey[2];
							pbVal[6] = (BYTE)~pbKey[1];
							pbVal[7] = bFlipHighBit(~pbKey[0]);
							}
						pbKey += 8;
						pbVal += 8;
						}
					}
				else
					{
					if ( *pbKey++ == 0 )
						*pbVal++ = 0;
					else
						{
						Assert( pbKey[-1] == 0x7f );
						*pbVal++ = 8;
						if ( coltyp == JET_coltypCurrency || (pbKey[0] & maskByteHighBit) )
							{
							pbVal[0] = pbKey[7];
							pbVal[1] = pbKey[6];
							pbVal[2] = pbKey[5];
							pbVal[3] = pbKey[4];
							pbVal[4] = pbKey[3];
							pbVal[5] = pbKey[2];
							pbVal[6] = pbKey[1];
							pbVal[7] = bFlipHighBit(pbKey[0]);
							}
						else
							{
							pbVal[0] = (BYTE)~pbKey[7];
							pbVal[1] = (BYTE)~pbKey[6];
							pbVal[2] = (BYTE)~pbKey[5];
							pbVal[3] = (BYTE)~pbKey[4];
							pbVal[4] = (BYTE)~pbKey[3];
							pbVal[5] = (BYTE)~pbKey[2];
							pbVal[6] = (BYTE)~pbKey[1];
							pbVal[7] = (BYTE)~pbKey[0];
							}
						pbKey += 8;
						pbVal += 8;
						}
					}
				break;

			case JET_coltypText:
			case JET_coltypLongText:
TextTypes:
				if ( fDescending )
					{
					if ( fFixedField )
						{
						if ( *pbKey++ == (BYTE)~0 )
							{
							*pbVal++ = 0;
							err = JET_wrnColumnNull;
							}
//						/* zero-length strings -- only for Text and LongText
//						/**/	
//						else if ( pbKey[-1] == (BYTE)~0x40 )
//							{
//							Assert( coltyp == JET_coltypText || coltyp == JET_coltypLongText );
//							*pbVal++ = 0;
//							}
						else
							{
							Assert( pbKey[-1] == (BYTE)~0x7f );
							cbField = pfdb->pibFixedOffsets[fid] -
							  pfdb->pibFixedOffsets[fid-1];
							if ( cbField > pbKeyMax-pbKey )
								cbField = (INT)(pbKeyMax-pbKey);
							*pbVal++ = (BYTE)cbField;
							while ( cbField-- )
							 *pbVal++ = (BYTE)~*pbKey++;
							}
						}
					else
						{
						pbVal++;
						cbField = 0;
						switch( *pbKey )
							{
							case (BYTE)~0:									/* Null-field */
								err = JET_wrnColumnNull;
								break;

							case (BYTE)~0x40:							/* zero-length string */
								Assert( coltyp == JET_coltypText || coltyp == JET_coltypLongText );
								break;

							default:
								Assert( *pbKey == ~0x7f );
								for ( ; *pbKey != (BYTE)~0; cbField++)
									*pbVal++ = (BYTE)~*pbKey++;
						  	}
						pbKey++;
						pbVal[-(cbField+1)] = (BYTE)cbField;
						}
					}
				else
					{
					if ( fFixedField )
						{
						if ( *pbKey++ == 0 )
							{
							*pbVal++ = 0;
							err = JET_wrnColumnNull;
							}
//						/* zero-length strings -- only for Text and LongText
//						/**/	
//						else if ( pbKey[-1] == (BYTE)0x40 )
//							{
//							Assert( coltyp == JET_coltypText || coltyp == JET_coltypLongText );
//							*pbVal++ = 0;
//							}
						else
							{
							cbField = pfdb->pibFixedOffsets[fid] -
							  pfdb->pibFixedOffsets[fid-1];
							if ( cbField > pbKeyMax-pbKey )
								cbField = (INT)(pbKeyMax-pbKey);
							*pbVal++ = (BYTE)cbField;
							memcpy( pbVal, pbKey, cbField );
							pbVal += cbField;
							pbKey += cbField;
							}
						}
					else
						{
						pbVal++;
						cbField = 0;
						switch( *pbKey )
							{
							/* Null-field
							/**/
							case (BYTE) 0:
								err = JET_wrnColumnNull;
								break;

							/* zero-length string
							/**/
							case (BYTE) 0x40:
								Assert( coltyp == JET_coltypText || coltyp == JET_coltypLongText );
								break;

							default:
								Assert( *pbKey == 0x7f );
								pbKey++;
								for ( ; *pbKey != (BYTE)0; cbField++)
									*pbVal++ = (BYTE)*pbKey++;
							}
						pbKey++;
						pbVal[-(cbField+1)] = (BYTE)cbField;
						}
					}
				break;

			case JET_coltypBinary:
			case JET_coltypLongBinary:
				if ( fFixedField )
					goto TextTypes;
				if ( fDescending )
					{
					cbField = 0;
					pbVal++;
					do {
						BYTE cbChunk, ib;
						if ((cbChunk = (BYTE)~pbKey[8]) == 9)
							cbChunk = 8;
						for (ib = 0; ib < cbChunk; ib++)
							pbVal[ib] = (BYTE)~pbKey[ib];
						cbField += cbChunk;
						pbKey += 9;
						pbVal += cbChunk;
						}
					while (pbKey[-1] == (BYTE)~9);
					pbVal[-(cbField+1)] = (BYTE)cbField;
					}
				else
					{
					cbField = 0;
					pbVal++;
					do {
						BYTE cbChunk;

						if ( ( cbChunk = pbKey[8] ) == 9 )
							cbChunk = 8;
						memcpy( pbVal, pbKey, cbChunk );
						cbField += cbChunk;
						pbKey += 9;
						pbVal += cbChunk;
						}
					while( pbKey[-1] == 9 );
					pbVal[-(cbField+1)] = (BYTE)cbField;
					}
				break;
			}
		}
	plineValues->cb = (DWORD)(pbVal - plineValues->pb);
	return err;
	}


ERR VTAPI ErrIsamRetrieveKey(
	PIB			*ppib,
	FUCB			*pfucb,
	BYTE			*pb,
	ULONG			cbMax,
	ULONG			*pcbActual,
	JET_GRBIT	grbit )
	{
	ERR			err;
	FUCB			*pfucbIdx;
	FCB			*pfcbIdx;
	ULONG			cbKeyReturned;
			  	
	CheckPIB( ppib );
	CheckFUCB( ppib, pfucb );

	/*	retrieve key from key buffer.
	/**/
	if ( grbit & JET_bitRetrieveCopy )
		{
		if ( pfucb->cbKey == 0 )
			return JET_errKeyNotMade;
		if ( pb != NULL )
			{
			memcpy( pb, pfucb->pbKey + 1, min( pfucb->cbKey - 1, cbMax ) );
			}
		if ( pcbActual )
			*pcbActual = pfucb->cbKey - 1;
		return JET_errSuccess;
		}

	/*	retrieve current index value
	/**/
	if ( FFUCBIndex( pfucb ) )
		{
		pfucbIdx = pfucb->pfucbCurIndex != pfucbNil ? pfucb->pfucbCurIndex : pfucb;
		Assert( pfucbIdx != pfucbNil );
		pfcbIdx = pfucbIdx->u.pfcb;
		Assert( pfcbIdx != pfcbNil );
		CallR( ErrDIRGet( pfucbIdx ) );
		}
	else
		{
		pfucbIdx = pfucb;
		pfcbIdx = (FCB *)pfucb->u.pscb; // first element of an SCB is an FCB
		Assert( pfcbIdx != pfcbNil );
		}

	/*	set err to JET_errSuccess.
	/**/
	err = JET_errSuccess;

	cbKeyReturned = pfucbIdx->keyNode.cb;
	if ( pcbActual )
		*pcbActual = cbKeyReturned;
	if ( cbKeyReturned > cbMax )
		{
		err = JET_wrnBufferTruncated;
		cbKeyReturned = cbMax;
		}

	if ( pb != NULL )
		{
		memcpy( pb, pfucbIdx->keyNode.pb, (size_t)cbKeyReturned );
		}

	return err;
	}


ERR VTAPI ErrIsamGetBookmark( PIB *ppib, FUCB *pfucb, BYTE *pb, ULONG cbMax, ULONG *pcbActual )
	{
	ERR		err;
	ULONG	 	cb;
	SRID 		srid;

	CheckPIB( ppib );
	CheckTable( ppib, pfucb );
	Assert( pb != NULL );

	/*	retrieve bookmark
	/**/
	CallR( ErrDIRGetBookmark( pfucb, &srid ) );
	FUCBSetGetBookmark( pfucb );
	cb = sizeof(SRID);
	if ( cb > cbMax )
		cb = cbMax;
	if ( pcbActual )
		*pcbActual = sizeof(SRID);
	memcpy( pb, &srid, (size_t)cb );

	return JET_errSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\fldmod.c ===
#include "config.h"

#include <string.h>
#include <stddef.h>

#include "daedef.h"
#include "pib.h"
#include "util.h"
#include "page.h"
#include "fmp.h"
#include "ssib.h"
#include "fucb.h"
#include "fcb.h"
#include "stapi.h"
#include "fdb.h"
#include "spaceapi.h"
#include "recapi.h"
#include "dirapi.h"
#include "recint.h"

DeclAssertFile; 				/* Declare file name for assert macros */

ERR ErrRECIModifyField( FUCB *pfucb, FID fid, ULONG itagSequence, LINE *plineField );
VOID RECIInitNewRecord( FUCB *pfucb );

/* structure used for passing parameters between
/* ErrIsamRetrieveColumns and ErrRECIRetrieveMany */
/**/
typedef	struct colinfo {
		LINE		lineField;
		FID			fid;
		} COLINFO;


LOCAL ERR ErrRECISetAutoIncrement( FUCB *pfucb )
	{
	ERR		err;
	FUCB	*pfucbT = pfucbNil;
	LINE	line;
	ULONG	ulAutoIncrement;
	BOOL	fCommit = fFalse;
	PIB		*ppib = pfucb->ppib;

	/*	the operation is redo only. no version needed.
	/*	If necessary, start a transaction such that the redo
	/*	would not ignore the operation.
	/**/
	if ( ppib->level == 0 || !FPIBAggregateTransaction( ppib )  )
		{
		CallR( ErrDIRBeginTransaction( ppib ) );
		fCommit = fTrue;
		}

	Call( ErrDIROpen( ppib, pfucb->u.pfcb, 0, &pfucbT ) );
	Assert( pfucbT != pfucbNil );
	FUCBSetIndex( pfucbT );

	/*	the autoinc field is not set to a value, so we use the value
	/*	stored in the AutoInc node, a son of the FDP
	/*	go down to AutoInc node
	/**/
	DIRGotoFDPRoot( pfucbT );
	err = ErrDIRSeekPath( pfucbT, 1, pkeyAutoInc, 0 );
	if ( err != JET_errSuccess )
		{
		if ( err > 0 )
			err = JET_errDatabaseCorrupted;
		goto HandleError;
		}
	Call( ErrDIRGet( pfucbT ) );
	Assert( pfucbT->lineData.cb == sizeof(ulAutoIncrement) );
	ulAutoIncrement = *(UNALIGNED ULONG *)pfucbT->lineData.pb;
	Assert( ulAutoIncrement > 0 );
	line.pb = (BYTE *)&ulAutoIncrement;
	line.cb = sizeof(ulAutoIncrement);

	/*	increment ulAutoIncrement in table BEFORE accessing
	/*	any other page.  This is to prevent loss of context
	/*	which could result in duplicate autoinc usage.
	/**/
	++ulAutoIncrement;
	Call( ErrDIRReplace( pfucbT, &line, fDIRNoVersion ) );
	
	/*	set auto increment column in record.  Must decrement
	/*	the cached table auto increment to the value first found.
	/**/
	--ulAutoIncrement;
	err = ErrRECIModifyField( pfucb, pfucb->u.pfcb->pfdb->fidAutoInc, 0, &line );

HandleError:
	if ( pfucbT != pfucbNil )
		{
		DIRClose( pfucbT );
		}

	/*	always commit to log a symetric commit for begin transaction.
	/**/
	if ( fCommit )
		{
		if ( err >= JET_errSuccess )
			err = ErrDIRCommitTransaction( ppib );
		if ( err < 0 )
			{
			CallS( ErrDIRRollback( ppib ) );
			}
		}

	Assert( err < 0 || FFUCBColumnSet( pfucb, pfucb->u.pfcb->pfdb->fidAutoInc - fidFixedLeast ) );
	return err;
	}


ERR VTAPI ErrIsamPrepareUpdate( PIB *ppib, FUCB *pfucb, ULONG grbit )
	{
	ERR		err = JET_errSuccess;
#ifndef BUG_FIX
	BOOL	fAlreadyPrepared = FFUCBUpdatePrepared( pfucb );
#endif

	CheckPIB( ppib );
	CheckFUCB( ppib, pfucb );
	Assert( ppib->level < levelMax );
	Assert( PcsrCurrent( pfucb ) != pcsrNil );

	/* ensure that table is updatable
	/**/
	CallR( FUCBCheckUpdatable( pfucb )  );

	/*	allocate working buffer if needed
	/**/
	if ( pfucb->pbfWorkBuf == NULL )
		{
		Call( ErrBFAllocTempBuffer( &pfucb->pbfWorkBuf ) );
		pfucb->lineWorkBuf.pb = (BYTE*)pfucb->pbfWorkBuf->ppage;
		}

	/*	reset rglineDiff delta logging
	/**/
	pfucb->clineDiff = 0;
	pfucb->fCmprsLg = fFalse;

	switch ( grbit )
		{
		case JET_prepCancel:
			if ( !FFUCBUpdatePrepared( pfucb ) )
				return JET_errUpdateNotPrepared;

			if ( FFUCBUpdateSeparateLV( pfucb ) )
				{
				/*	if copy buffer was prepared for replacement
				/*	then cache the record and write latch the
				/*	buffer, to prevent overlay during long value
				/*	deletion.
				/**/
				if ( FFUCBReplacePrepared( pfucb ) )
					{
					err = ErrDIRGet( pfucb );
				
					/*	wait and retry while write latch conflict
					/**/
	 				Assert( err < 0 || FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
	 				while( err >= JET_errSuccess &&
	 					FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) )
						{
						BFSleep( cmsecWaitWriteLatch );
						err = ErrDIRGet( pfucb );
		 				Assert( err < 0 || FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
						}

					if ( err >= JET_errSuccess )
						{
						(VOID)ErrRECAffectLongFields( pfucb, &pfucb->lineWorkBuf, fDereferenceAdded );
						/*	ignore error code
						/**/
						}

					/*	ignore error code
					/**/
					err = JET_errSuccess;
					}
				else
					{
					Assert( FFUCBInsertPrepared( pfucb ) );
					(VOID)ErrRECAffectLongFields( pfucb, &pfucb->lineWorkBuf, fDereferenceAdded );
					/*	ignore error code
					/**/
					}

				FUCBResetUpdateSeparateLV( pfucb );
				}
			Assert( !FFUCBUpdateSeparateLV( pfucb ) );
			FUCBResetCbstat( pfucb );
			err = JET_errSuccess;
			break;

		case JET_prepInsert:
//	UNDONE:	enable all BUG_FIX code post EMS TR2 due to DSA bug
//			dependency.  Notify Tsvi Reiter of change when made.
#undef BUG_FIX
#ifdef BUG_FIX
			if ( FFUCBUpdatePrepared( pfucb ) )
				return JET_errAlreadyPrepared;
			Assert( !FFUCBUpdatePrepared( pfucb ) );
			Assert( !FFUCBUpdateSeparateLV( pfucb ) );
#endif
			Assert( pfucb->pbfWorkBuf != pbfNil );
			RECIInitNewRecord( pfucb );
			FUCBResetColumnSet( pfucb );
			FUCBResetTaggedSet( pfucb );
			PrepareInsert( pfucb );

			/*	if table has an autoincrement column, then set column
			/*	value now so that it can be retrieved from copy
			/*	buffer.
			/**/
			if ( pfucb->u.pfcb->pfdb->fidAutoInc != 0 )
				{
				Call( ErrRECISetAutoIncrement( pfucb ) );
				}
			err = JET_errSuccess;
			break;

		case JET_prepReplace:
#ifdef BUG_FIX
			if ( FFUCBUpdatePrepared( pfucb ) )
				return JET_errAlreadyPrepared;
			Assert( !FFUCBUpdatePrepared( pfucb ) );
			Assert( !FFUCBUpdateSeparateLV( pfucb ) );
#endif
			/*	write lock node.  Note that ErrDIRGetWriteLock also
			/*	gets the current node, so no additional call to ErrDIRGet
			/*	is required.
			/**/
			/*	if locking at level 0 then goto JET_prepReplaceNoLock
			/*	since lock cannot be acquired at level 0 and lock flag
			/*	in fucb will prevent locking in update operation required
			/*	for rollback.
			/**/
			if ( pfucb->ppib->level == 0 )
				goto ReplaceNoLock;

			Call( ErrDIRGetWriteLock( pfucb ) );
			pfucb->cbRecord = pfucb->lineData.cb;
			Assert( pfucb->pbfWorkBuf != pbfNil );
			LineCopy( &pfucb->lineWorkBuf, &pfucb->lineData );
			FUCBResetColumnSet( pfucb );
			FUCBResetTaggedSet( pfucb );
			PrepareReplace( pfucb );
//			/*	for sequential files, store dbk of record to update in
//			/*	work buffer structure
//			/**/
//			if ( pfucb->u.pfcb->pidb == pidbNil )
//				{
//				pfucb->dbkUpdate = *(DBK *)(pfucb->keyNode.pb + 1 );
//				}
			pfucb->fCmprsLg = fTrue;
			break;

		case JET_prepReplaceNoLock:
#ifdef BUG_FIX
			if ( FFUCBUpdatePrepared( pfucb ) )
				return JET_errAlreadyPrepared;
#endif
ReplaceNoLock:			
#ifdef BUG_FIX
			Assert( !FFUCBUpdatePrepared( pfucb ) );
			Assert( !FFUCBUpdateSeparateLV( pfucb ) );
#endif
			Call( ErrDIRGet( pfucb ) );
			Assert( pfucb->pbfWorkBuf != pbfNil );
			pfucb->cbRecord = 0;
			LineCopy( &pfucb->lineWorkBuf, &pfucb->lineData );
			FUCBResetColumnSet( pfucb );
			FUCBResetTaggedSet( pfucb );
			PrepareReplaceNoLock( pfucb );
			StoreChecksum( pfucb );
//			/*	for sequential files, store dbk of record to update in
//			/*	work buffer structure
//			/**/
//			if ( pfucb->u.pfcb->pidb == pidbNil )
//				{
//				pfucb->dbkUpdate = *(DBK *)(pfucb->keyNode.pb + 1 );
//				}
			
			pfucb->fCmprsLg = fTrue;
			break;

		case JET_prepInsertCopy:
#ifdef BUG_FIX
			if ( FFUCBUpdatePrepared( pfucb ) )
				return JET_errAlreadyPrepared;
			Assert( !FFUCBUpdatePrepared( pfucb ) );
			Assert( !FFUCBUpdateSeparateLV( pfucb ) );
#endif
			Call( ErrDIRGet( pfucb ) );
			Assert( pfucb->pbfWorkBuf != pbfNil );
			LineCopy( &pfucb->lineWorkBuf, &pfucb->lineData );
			FUCBResetColumnSet( pfucb );
			FUCBResetTaggedSet( pfucb );

			/*	wait and retry while write latch conflict
			/**/
	   		Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
			while( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) )
				{
				BFSleep( cmsecWaitWriteLatch );
				Call( ErrDIRGet( pfucb ) );
 				Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
				}

			/*	increment reference count on long values
			/**/
			Call( ErrRECAffectLongFields( pfucb, &pfucb->lineWorkBuf, fReference ) );

			PrepareInsert( pfucb );
			
			/*	if table has an autoincrement column, then set column
			/*	value now so that it can be retrieved from copy
			/*	buffer.
			/**/
			if ( pfucb->u.pfcb->pfdb->fidAutoInc != 0 )
				{
				Call( ErrRECISetAutoIncrement( pfucb ) );
				}

//			/*	for sequential files, store dbk of record to update in
//			/*	work buffer structure
//			/**/
//			if ( pfucb->u.pfcb->pidb == pidbNil )
//				{
//				pfucb->dbkUpdate = *(DBK *)(pfucb->keyNode.pb + 1 );
//				}
			break;
		default:
			err = JET_errInvalidParameter;
			goto HandleError;
		}

	Assert( err == JET_wrnNoWriteLock || err == JET_errSuccess );

#ifndef BUG_FIX
	/*	if already prepared then do not allow compressed logging
	/*	as we will miss the previous sets.
	/**/
	if ( fAlreadyPrepared )
		pfucb->fCmprsLg = fFalse;
#endif
	
HandleError:
	return err;
	}


//+API
// ErrIsamSetColumn
// ========================================================================
// ErrIsamSetColumn( PIB *ppib, FUCB *pfucb, FID fid, ULONG itagSequence, LINE *plineField, JET_GRBIT grbit )
//
// Adds or changes a field value in the record being worked on.
// Fixed and variable fields are replaced if they already have values.
// A sequence number must be given for tagged fields.  If this is zero,
// a new tagged field occurance is added to the record.  If not zero, it
// specifies the occurance to change.
// A working buffer is allocated if there isn't one already.
// If fNewBuf == fTrue, the buffer is initialized with the default values
// for the fields in the record.  If fNewBuf == fFalse, and there was
// already a working buffer, it is left unaffected;	 if a working buffer
// had to be allocated, then this new working buffer will be initialized
// with either the field values of the current record, or the default field
// values (if the user's currency is not on a record).
//
// PARAMETERS	ppib			PIB of user
//				pfucb			FUCB of data file to which this record
//								is being added/updated.
//				fid				field id: which field to set
//				itagSequence 	Occurance number (for tagged fields):
//								which occurance of the field to change
//								If zero, it means "add a new occurance"
//				plineField		field data to use
//				grbit 			If JET_bitSetZeroLength, the field is set to size 0.
//
// RETURNS		Error code, one of:
//					 JET_errSuccess				Everything worked.
//					-JET_errOutOfBuffers		Failed to allocate a working
//												buffer
//					-JET_errInvalidBufferSize
//												
//					-ColumnInvalid				The field id given does not
//												corresponding to a defined field
//					-NullInvalid			  	An attempt was made to set a
//												field to NULL which is defined
//												as NotNull.
//					-JET_errRecordTooBig		There is not enough room in
//												the record for new column.
// COMMENTS		The GET and DELETE commands discard the working buffer
//				without writing it to the database.	 The REPLACE and INSERT
//				commands may be used to write the working buffer to the
//				database, but they also discard it when finished (the INSERT
//				command can be told not to discard it, though;	this is
//				useful for adding several similar records).
//				For tagged fields, if the data given is NULL-valued, then the
//				tagged field occurance specified is deleted from the record.
//				If there is no tagged field occurance corresponding to the
//				specified occurance number, a new tagged field is added to
//				the record, and assumes the new highest occurance number
//				(unless the data given is NULL-valued, in which case the
//				record is unaffected).
// SEE ALSO		Get, Insert, Replace
//-
ERR VTAPI ErrIsamSetColumn(
	PIB				*ppib,
	FUCB 			*pfucb,
	JET_COLUMNID	columnid,
	BYTE	  		*pbData,
	ULONG	  		cbData,
	ULONG	  		grbit,
	JET_SETINFO		*psetinfo )
	{
	ERR				err;
	LINE	  		lineField;
	LINE	  		*plineField = &lineField;
	FID 	  		fid = (FID)columnid;
	ULONG	  		itagSequence;

	/* check for updatable table
	/**/
	CallR( FUCBCheckUpdatable( pfucb )  );

	CheckPIB( ppib );
	CheckFUCB( ppib, pfucb );

	if ( ! ( FFUCBSetPrepared( pfucb ) ) )
		return JET_errUpdateNotPrepared;

	lineField.pb = pbData;
	lineField.cb = cbData;

	if ( psetinfo != NULL )
		{
		if ( psetinfo->cbStruct < sizeof(JET_SETINFO) )
			return JET_errInvalidParameter;
		itagSequence = psetinfo->itagSequence;
		/*	ignore ibLongValue as only allow append to existing long field
		/**/
		}
	else
		{
		itagSequence = 1;
		}

	/*	Return error if version or autoinc field is being set.
	/*	Check is perfomed for all fixed size column types
	/*	for replace operations.
	/**/
	if ( FFUCBReplacePrepared( pfucb ) && fid <= fidFixedMost )
		{
		BYTE	ffield = pfucb->u.pfcb->pfdb->pfieldFixed[fid - 1].ffield;

		if ( ffield & ffieldVersion || ffield & ffieldAutoInc )
			return JET_errInvalidColumnType;
		}

	/*	Set long field
	/**/
	if ( FTaggedFid( fid ) )
		{
		/* efficiency variable */
		/**/
		FDB	*pfdb = (FDB *)pfucb->u.pfcb->pfdb;

		if ( fid <= pfdb->fidTaggedLast )
			{
			/* efficiency variables */
			/**/
			FIELD			*pfieldTagged = pfdb->pfieldTagged + fid - fidTaggedLeast;
			JET_COLTYP	coltyp = pfieldTagged->coltyp;

			if ( coltyp == JET_coltypLongText || coltyp == JET_coltypLongBinary )
				{
				err = ErrRECSetLongField( pfucb, fid, itagSequence,
					plineField, grbit, psetinfo ? psetinfo->ibLongValue : 0,
					pfieldTagged->cbMaxLen );

				/*	if column does not fit then try to separate long values
				/*	and try to set column again.
				/**/
				if ( err == JET_errRecordTooBig )
					{
					Call( ErrRECAffectLongFields( pfucb, &pfucb->lineWorkBuf, fSeparateAll ) );
					err = ErrRECSetLongField( pfucb, fid, itagSequence,
						plineField, grbit, psetinfo ? psetinfo->ibLongValue : 0,
						pfieldTagged->cbMaxLen );
					}

				return err;
				}
			}
		}

	/*	do the actual field operation
	/**/

	/*	setting value to NULL
	/**/
	if ( lineField.cb == 0 && ( (grbit & JET_bitSetZeroLength) == 0 ) )
		{
		err = ErrRECIModifyField( pfucb, fid, itagSequence, NULL );
		return err;
		}

	err = ErrRECIModifyField( pfucb, fid, itagSequence, plineField );
	if ( err == JET_errRecordTooBig )
		{
		Call( ErrRECAffectLongFields( pfucb, &pfucb->lineWorkBuf, fSeparateAll ) );
		err = ErrRECIModifyField(pfucb, fid, itagSequence, plineField);
		}
HandleError:
	return err;
	}


ERR VTAPI ErrIsamSetColumns(
	PIB	 			*ppib,
	FUCB	 		*pfucb,
	JET_SETCOLUMN	*psetcols,
	unsigned long	csetcols )
	{
	ERR	 			err;
	COLINFO			*pcolinfo;
	ULONG			itagSequence;
	ULONG			ccols;

	/* check for updatable table
	/**/
	CallR( FUCBCheckUpdatable( pfucb )  );

	CheckPIB( ppib );
	CheckFUCB( ppib, pfucb );

	if ( ! ( FFUCBSetPrepared( pfucb ) ) )
		return JET_errUpdateNotPrepared;

	/* allocate space for temporary array */
	/**/
	pcolinfo = LAlloc ( csetcols, sizeof(COLINFO) );
	if ( pcolinfo == NULL )
		return JET_errOutOfMemory;

	for ( ccols = 0; ccols < csetcols ; ccols++ )
		{
		COLINFO	 			*pcolinfocurr = &pcolinfo[ccols];
		JET_SETCOLUMN		*psetcolcurr = &psetcols[ccols];
		LINE  	 			*plineField = &( pcolinfocurr->lineField );
		FID		 			fid = (FID) psetcolcurr->columnid;
		ULONG  	 			grbit = psetcolcurr->grbit;

		plineField->pb = (BYTE *) psetcolcurr->pvData;
		plineField->cb = psetcolcurr->cbData;

		itagSequence = psetcolcurr->itagSequence;
		/*	ignore ibLongValue as only allow append to existing long field
		/**/

		/*	Return error if version or autoinc field is being set.
		/*	Check is perfomed for all fixed size column types
		/*	for replace operations.
		/**/
		if ( FFUCBReplacePrepared( pfucb ) && fid <= fidFixedMost )
			{
			BYTE	ffield = pfucb->u.pfcb->pfdb->pfieldFixed[fid - 1].ffield;

			if ( ffield & ffieldVersion || ffield & ffieldAutoInc )
				{
				err = JET_errInvalidColumnType;
				goto HandleError;
				}
			}

		/*	set long field
		/**/
		if ( FTaggedFid( fid ) )
			{
			/* efficiency variable */
			/**/
			FDB	*pfdb = (FDB *)pfucb->u.pfcb->pfdb;

			if ( fid <= pfdb->fidTaggedLast )
				{
				/* efficiency variables */
				/**/
				FIELD			*pfieldTagged = pfdb->pfieldTagged + fid - fidTaggedLeast;
				JET_COLTYP	coltyp = pfieldTagged->coltyp;

				if ( coltyp == JET_coltypLongText || coltyp == JET_coltypLongBinary )
					{
					Call( ErrRECSetLongField( pfucb, fid, itagSequence,
						plineField, grbit, psetcolcurr->ibLongValue,
						pfieldTagged->cbMaxLen ) );
					psetcolcurr->err = err;
					continue;
					}
				}
			}

		/*** Do the actual field operation ***/

		/*** Setting value to NULL ***/
		if ( plineField->cb == 0 && ( (grbit & JET_bitSetZeroLength) == 0 ) )
			{
			Call( ErrRECIModifyField( pfucb, fid, itagSequence, NULL ) );
			psetcolcurr->err = err;
			continue;
			}

		err = ErrRECIModifyField( pfucb, fid, itagSequence, plineField ) ;

		if ( err == JET_errRecordTooBig )
			{
			Call( ErrRECAffectLongFields( pfucb, &pfucb->lineWorkBuf, fSeparateAll ) );
			Call( ErrRECIModifyField(pfucb, fid, itagSequence, plineField) );
			}
		Call( err );
		psetcolcurr->err = err;
		continue;
		}

HandleError:
	/* free allocated space */
	/**/
	LFree( pcolinfo );

	return err;
	}


//+INTERNAL
//	RECIInitNewRecord
//	========================================================================
//	VOID RECIInitNewRecord( FUCB *pfucb )
//
//	Initializes the working buffer in an FUCB to contain the default
//	field values.  (Does not allocate the working buffer.)
//
//	PARAMETERS	pfucb		init new record for this FUCB
//	RETURNS		JET_errSuccess, or an error code from ErrRECIModifyField.
//-
VOID RECIInitNewRecord( FUCB *pfucb )
	{
	Assert( pfucb != pfucbNil );
	Assert( pfucb->lineWorkBuf.pb != NULL );
	Assert( FFUCBIndex( pfucb ) || FFUCBSort( pfucb ) );

	if ( !FLineNull( &pfucb->u.pfcb->pfdb->lineDefaultRecord ) )
		{
		Assert( pfucb->u.pfcb != pfcbNil );
		LineCopy( &pfucb->lineWorkBuf, &pfucb->u.pfcb->pfdb->lineDefaultRecord );
		}
	else
		{
		RECHDR *prechdr;

		prechdr = (RECHDR*)pfucb->lineWorkBuf.pb;
		prechdr->fidFixedLastInRec = (BYTE)(fidFixedLeast-1);
		prechdr->fidVarLastInRec = (BYTE)(fidVarLeast-1);
		*(WORD *)(prechdr+1) = pfucb->lineWorkBuf.cb = sizeof(RECHDR) + sizeof(WORD);
		}
	}


//+INTERNAL
// ErrRECIModifyField
// ========================================================================
// ErrRECIModifyField( FUCB *pfucb, FID fid, ULONG itagSequence, LINE *plineField )
//
//	Internal function: used to implement most of ErrRECAddField and
//	ErrRECChangeField, since they are very similar in operation.
// The only difference is in handling tagged fields.  Please see the
// documentation for AddField and ChangeField for details.
//	If plineField is NULL, then value of the field is set to NULL
//-
ERR ErrRECIModifyField( FUCB *pfucb, FID fid, ULONG itagSequence, LINE *plineField )
	{
	ERR					err;					// return code
	FDB					*pfdb;					// field info of file
	ULONG			  	cbRec;					// length of current data record
	BYTE			  	*pbRec;					// pointer to current data record
	FID					fidFixedLastInRec;	 	// highest fixed fid actually in record
	FID					fidVarLastInRec;		// highest var fid actually in record
	BYTE			  	*prgbitNullity;			// pointer to fixed field bitmap
	WORD			  	*pibFixOffs;			// pointer to fixed field offsets
	WORD			  	*pibVarOffs;			// pointer to var field offsets
	UNALIGNED WORD		*pib;
	UNALIGNED WORD		*pibLast;
	ULONG			  	cbTagField;				// Length of tag field.
	ULONG			  	ulNumOccurances;		// Counts field occurances.
	BYTE			  	*pbRecMax; 				// End of record.
	ULONG			  	cbCopy;					// Number of bytes to copy from user's buffer
	LONG			  	dbFieldData;			// Size change in field data.
	TAGFLD				*ptagfld;

	/*	efficiency variables
	/**/
	Assert( pfucb != pfucbNil );
	cbRec = pfucb->lineWorkBuf.cb;
	Assert( cbRec >= 4 && cbRec <= cbRECRecordMost );
	pbRec = pfucb->lineWorkBuf.pb;
	Assert( pbRec != NULL );
	Assert( FFUCBIndex( pfucb ) || FFUCBSort( pfucb ) );
	/*	use same fdb reference for File as for Sort since sort
	/*	is conformant to file control block access
	/**/
	Assert( pfucb->u.pfcb != pfcbNil );
	pfdb = (FDB *)pfucb->u.pfcb->pfdb;
	Assert( pfdb != pfdbNil );
	fidFixedLastInRec = ((RECHDR*)pbRec)->fidFixedLastInRec;
	fidVarLastInRec = ((RECHDR*)pbRec)->fidVarLastInRec;
	pibFixOffs = pfdb->pibFixedOffsets;			// fixed field offsets

	/* only compress update log record when only fixed fields are involved
	/**/
	pfucb->fCmprsLg = pfucb->fCmprsLg && FFixedFid(fid);

	/*** -----------MODIFYING FIXED FIELD---------- ***/
	if ( FFixedFid( fid ) )
		{
		if (fid > pfdb->fidFixedLast)
			return JET_errColumnNotFound;

		if (pfdb->pfieldFixed[fid-fidFixedLeast].coltyp == JET_coltypNil)
			return JET_errColumnNotFound;

		/*** Record the fact that this field has been changed ***/
		FUCBSetFixedColumnSet( pfucb, fid );

		/*** Field not represented in record? Make room, make room ***/
		if ( fid > fidFixedLastInRec )
			{
			ULONG		ibOldFixEnd;			// End of fixed fields,
			ULONG		ibNewFixEnd;			// before and after shift.
			ULONG		cbOldBitMap;			// Size of old fixfield bitmap.
			ULONG		ibOldBitMap;			// Offset of fixfield bitmap,
			ULONG		ibNewBitMap;			// before and after shift.
			ULONG		cbShift;					// Space for new field(s).
			FID		fidT;

			/*** Adding NULL : if ( plineField==NULL || plineField->cb==0 || plineField->pb==NULL ) ***/
			if ( FLineNull(plineField) )
				{
				if (pfdb->pfieldFixed[fid-fidFixedLeast].ffield & ffieldNotNull)
					return JET_errNullInvalid;
				}

			/* if not all fixed fields are initially set, don't compress */
			pfucb->fCmprsLg = fFalse;
			
			/*** Compute room needed for new field and bitmap ***/
			ibOldFixEnd = pibFixOffs[fidFixedLastInRec];
			ibNewFixEnd = pibFixOffs[fid];
			cbOldBitMap = (fidFixedLastInRec+7)/8;
			ibOldBitMap = ibOldFixEnd + cbOldBitMap;
			ibNewBitMap = ibNewFixEnd + (fid+7)/8;
			cbShift = ibNewBitMap - ibOldBitMap;
			if ( cbRec + cbShift > cbRECRecordMost )
				return JET_errRecordTooBig;

			/*** Shift rest of record over to make room ***/
			memmove(pbRec+ibNewBitMap, pbRec+ibOldBitMap, cbRec-ibOldBitMap);
			cbRec = (pfucb->lineWorkBuf.cb += cbShift);

			/*** Bump var field offsets by cbShift ***/
			pibVarOffs = (WORD *)( pbRec + ibNewBitMap );
			pibLast = pibVarOffs+fidVarLastInRec+1-fidVarLeast;
			for (pib = pibVarOffs; pib <= pibLast; pib++)
				{
				*pib += (WORD)cbShift;
				Assert( (ULONG)ibVarOffset(*pib) >= (ULONG)((BYTE *)pibLast - pbRec) && (ULONG)ibVarOffset(*pib) <= cbRec );
				}

			/*	shift fixed field bitmap over
			/**/
			memmove( pbRec + ibNewFixEnd, pbRec + ibOldFixEnd, cbOldBitMap );

			/*	clear all new bitmap bits
			/*	(Could be faster: clear remaining bits in
			/*	fidFixedLastInRec's byte, then clear entire
			/*	bytes up to fid's byte.)
			/**/
			for ( fidT = fidFixedLastInRec + 1; fidT <= fid; fidT++ )
				{
				prgbitNullity = pbRec + ibNewFixEnd + (fidT-1)/8;
				*prgbitNullity &= ~(1 << (fidT-1)%8);
				}

			/*** Bump fidFixedLastInRec ***/
			fidFixedLastInRec = ((RECHDR*)pbRec)->fidFixedLastInRec = (BYTE)fid;
			}

		/*** fid is now definitely represented in	***/
		/*** the record; its data can simply be replaced ***/

		/*** Adjust fid to an index ***/
		fid -= fidFixedLeast;

		/*** Byte containing bit representing field's nullity ***/
		prgbitNullity = pbRec + pibFixOffs[fidFixedLastInRec] + fid/8;

		/*** Adding NULL: clear bit (or maybe error) ***/
		if ( FLineNull( plineField ) )
			{
			if ( pfdb->pfieldFixed[fid].ffield & ffieldNotNull )
				return JET_errNullInvalid;
			*prgbitNullity &= ~(1 << fid % 8);
			
			/* if null involved, don't compress
			/**/
			pfucb->fCmprsLg = fFalse;
			}
		/*** Adding non-NULL value: set bit, copy value into slot ***/
		else
			{
			JET_COLTYP coltyp = pfdb->pfieldFixed[fid].coltyp;

			err = JET_errSuccess;
			cbCopy = pibFixOffs[fid+1] - pibFixOffs[fid];

			if ( pfucb->fCmprsLg )
				{
				if ( pfucb->clineDiff >= ilineDiffMax )
					{
					/* too many fixed fields are updated, don't compress
					/**/
					pfucb->fCmprsLg = fFalse;
					}
				else
					{
					switch ( coltyp )
						{
						case JET_coltypBit:
						case JET_coltypUnsignedByte:
						case JET_coltypShort:
						case JET_coltypLong:
						case JET_coltypCurrency:
						case JET_coltypIEEESingle:
						case JET_coltypIEEEDouble:
						case JET_coltypDateTime:
							{
							int iline;

							for ( iline = 0; iline < pfucb->clineDiff; iline++ )
								{
								if ( pfucb->rglineDiff[iline].pb == (char *)pibFixOffs[fid] )
									{
									/* it was set before
									/**/
									break;
									}
								}

							iline = pfucb->clineDiff++;
							pfucb->rglineDiff[iline].cb = cbCopy;
							pfucb->rglineDiff[iline].pb = (char *)pibFixOffs[fid];
							break;
							}
						default:
							pfucb->fCmprsLg = fFalse;
						}
					}
				}

			if ( plineField->cb != cbCopy )
				{
				switch ( coltyp )
					{
					case JET_coltypBit:
					case JET_coltypUnsignedByte:
					case JET_coltypShort:
					case JET_coltypLong:
					case JET_coltypCurrency:
					case JET_coltypIEEESingle:
					case JET_coltypIEEEDouble:
					case JET_coltypDateTime:
						return JET_errInvalidBufferSize;

					case JET_coltypBinary:
						if ( plineField->cb > cbCopy )
							return JET_errInvalidBufferSize;
						else
							memset( pbRec + pibFixOffs[fid] + plineField->cb, 0, cbCopy - plineField->cb );
						cbCopy = plineField->cb;
						break;

					default:
						Assert( coltyp == JET_coltypText );
						if ( plineField->cb > cbCopy )
							return JET_errInvalidBufferSize;
						else
							memset( pbRec + pibFixOffs[fid] + plineField->cb, ' ', cbCopy - plineField->cb );
						cbCopy = plineField->cb;
						break;
					}
				}

			*prgbitNullity |= 1 << fid % 8;

			if (coltyp != JET_coltypBit)
				memcpy(pbRec + pibFixOffs[fid], plineField->pb, cbCopy);
			else if (*plineField->pb == 0)
				*(pbRec+pibFixOffs[fid]) = 0;
			else
				*(pbRec+pibFixOffs[fid]) = 0xFF;

			return err;
			}
		return JET_errSuccess;
		}

	/*** -----------MODIFYING VARIABLE FIELD---------- ***/
	if ( FVarFid(fid) )
		{
		ULONG					cbFieldOld;			// Current size of field.
		UNALIGNED WORD		*pibFieldEnd;		// Ptr to offset of end of field.
		UNALIGNED WORD		*pib;

		if ( fid > pfdb->fidVarLast )
			return JET_errColumnNotFound;
		if ( pfdb->pfieldVar[fid - fidVarLeast].coltyp == JET_coltypNil )
			return JET_errColumnNotFound;

		/*	record the fact that this field has been changed
		/**/
		FUCBSetVarColumnSet( pfucb, fid );

		/*	variable field offsets
		/**/
		pibVarOffs = (WORD *)( pbRec + pibFixOffs[fidFixedLastInRec] +
			( fidFixedLastInRec + 7 ) / 8 );

		/*	field not represented in record?  Make room, make room
		/**/
		if ( fid > fidVarLastInRec )
			{
			ULONG		cbNeed;					// Space needed for new offsets.
			BYTE		*pbVarOffsEnd;			// Ptr to end of existing offsets.
			ULONG		ibTagFields;			// offset of tagged field section

			/*** Adding NULL:  note we are not looking at plineField->cb or pb ***/
			if ( plineField == NULL )
				{
				if ( pfdb->pfieldVar[fid-fidVarLeast].ffield & ffieldNotNull )
					return JET_errNullInvalid;
				}

			/*	compute space needed for new var field offsets
			/**/
			cbNeed = ( fid - fidVarLastInRec ) * sizeof(WORD);
			if ( cbRec + cbNeed > cbRECRecordMost )
				return JET_errRecordTooBig;

			/*	bump existing var field offsets
			/**/
			pibLast = pibVarOffs+fidVarLastInRec+1-fidVarLeast;
			for ( pib = pibVarOffs; pib <= pibLast; pib++ )
				{
				*pib += (WORD)cbNeed;
				Assert( (ULONG)ibVarOffset(*pib) >= (ULONG)((BYTE*)pibLast - pbRec ) && (ULONG)ibVarOffset(*pib) <= cbRec + cbNeed );
				}

			/*	shift rest of record over to make room
			/**/
			pbVarOffsEnd=(BYTE*)pibLast;
			memmove(pbVarOffsEnd + cbNeed, pbVarOffsEnd, (size_t)(pbRec + cbRec - pbVarOffsEnd));

			/*	set new var offsets to tag offset, making them NULL
			/**/
			pibLast = pibVarOffs+fid-fidVarLeast;
			ibTagFields = pibLast[1];
			SetNullBit( ibTagFields );
			pib = pibVarOffs+fidVarLastInRec+1-fidVarLeast;
			Assert( (ULONG)ibVarOffset( ibTagFields ) >= (ULONG)((BYTE*)pib - pbRec)
				&&	(ULONG)ibVarOffset( ibTagFields ) <= cbRec + cbNeed );
			while( pib <= pibLast )
				*pib++ = (WORD)ibTagFields;

			/*	bump fidVarLastInRec and record size
			/**/
			fidVarLastInRec = ((RECHDR *)pbRec)->fidVarLastInRec = (BYTE)fid;
			pfucb->lineWorkBuf.cb = ( cbRec += cbNeed );
			}

		/*** fid is now definitely represented in the record;	***/
		/*** its data can be replaced, shifting remainder of record, ***/
		/*** either to the right or left (if expanding/shrinking)	 ***/

		/*	adjust fid to an index
		/**/
		fid -= fidVarLeast;

		err = JET_errSuccess;

		/*	NULL-value check
		/**/
		if ( plineField == NULL )
			{
			if ( pfdb->pfieldVar[fid].ffield & ffieldNotNull )
				return JET_errNullInvalid;
			else
				cbCopy = 0;
			}
		else if (plineField->pb == NULL)
			{
			cbCopy = 0;
			}
		else if ( plineField->cb > pfdb->pfieldVar[fid].cbMaxLen )
			{
			/*	field too long
			/**/
			cbCopy = pfdb->pfieldVar[fid].cbMaxLen;
			err = JET_wrnColumnMaxTruncated;
			}
		else
			{
			cbCopy = plineField->cb;
			}

		/*	compute change in field size and value of null-bit in offset
		/**/
		pibFieldEnd = &pibVarOffs[fid+1];
		cbFieldOld  = ibVarOffset( *pibFieldEnd ) - ibVarOffset( *(pibFieldEnd-1) );
		dbFieldData = cbCopy - cbFieldOld;

		/*	size changed: must shift rest of record data
		/**/
		if ( dbFieldData != 0 )
			{
			/*	shift data
			/**/
			if ( cbRec + dbFieldData > cbRECRecordMost )
				return JET_errRecordTooBig;
			memmove(pbRec + ibVarOffset( *pibFieldEnd ) + dbFieldData,
				pbRec + ibVarOffset( *pibFieldEnd ),
				cbRec - ibVarOffset( *pibFieldEnd ) );
			cbRec = ( pfucb->lineWorkBuf.cb += dbFieldData );

			/*	bump remaining var field offsets
			/**/
			pibLast = pibVarOffs+fidVarLastInRec+1-fidVarLeast;
			for (pib = pibVarOffs+fid+1; pib <= pibLast; pib++)
				{
				*pib += (WORD)dbFieldData;
				Assert( (ULONG)ibVarOffset( *pib ) >= (ULONG)((BYTE *)pibLast - pbRec )
					&& (ULONG)ibVarOffset( *pib ) <= cbRec );
				}
			}

		/*	data shift complete, if any;  copy new field value in
		/**/
		if ( cbCopy != 0 )
			memcpy( pbRec + ibVarOffset( *( pibFieldEnd - 1 ) ), plineField->pb, cbCopy );

		/*	set value of null-bit in offset
		/**/
		if ( plineField == NULL )
			SetNullBit( *( pibFieldEnd - 1 ) );
		else
			ResetNullBit( *( pibFieldEnd - 1 ) );

		return err;
		}

	/*** -----------MODIFYING TAGGED FIELD---------- ***/
	if (!FTaggedFid(fid))
		return JET_errBadColumnId;
	if (fid > pfdb->fidTaggedLast)
		return JET_errColumnNotFound;
	if (pfdb->pfieldTagged[fid - fidTaggedLeast].coltyp == JET_coltypNil)
		return JET_errColumnNotFound;

	/*	check for field too long
	/**/
	if ( pfdb->pfieldTagged[fid-fidTaggedLeast].cbMaxLen > 0 )
		{
		ULONG	cbMax;

		cbMax = pfdb->pfieldTagged[ fid - fidTaggedLeast ].cbMaxLen;

		/*	compensate for long column overhead
		/**/
		if ( pfdb->pfieldTagged[ fid - fidTaggedLeast ].coltyp == JET_coltypLongText ||
			pfdb->pfieldTagged[ fid - fidTaggedLeast ].coltyp == JET_coltypLongBinary )
			{
			cbMax += offsetof(LV, rgb);
			}

		if ( (ULONG)CbLine( plineField ) > cbMax )
			return JET_errColumnTooBig;
		}

	/*	cannot set field more than cbLVIntrinsicMost bytes
	/**/
	if ( CbLine( plineField ) > cbLVIntrinsicMost )
		return JET_errColumnLong;

	/*** Search for occurance to change ***/
	pibVarOffs = (WORD *)( pbRec +
		pibFixOffs[fidFixedLastInRec] +
		(fidFixedLastInRec+7)/8);

	ptagfld = (TAGFLD *) ( pbRec + ( (UNALIGNED WORD *) pibVarOffs )[fidVarLastInRec+1-fidVarLeast] );
	ulNumOccurances = 0;
	pbRecMax = pbRec + cbRec;
	while ( (BYTE *)ptagfld < pbRecMax )
		{
		cbTagField = ptagfld->cb;
		if ( ptagfld->fid == fid )
			{
			if ( ++ulNumOccurances == itagSequence )
				break;
			}
		if ( ptagfld->fid > fid )
			{
			break;
			}
		ptagfld = (TAGFLD*)((BYTE*)(ptagfld+1) + cbTagField);
		Assert((BYTE*)ptagfld <= pbRecMax);
		}
	Assert( (BYTE *)ptagfld <= pbRecMax );
	
	/*	record the fact that a tagged field has been changed
	/**/
	FUCBSetTaggedSet( pfucb );

	/*** Didn't find occurance, so add a new one ***/
	if ( (BYTE *)ptagfld == pbRecMax )
		{
		/*** Adding NULL: do nothing ***/
		if ( plineField == NULL )
			return JET_errSuccess;

		/*** Enough room for new field? ***/
		if ( cbRec + sizeof(TAGFLD) + plineField->cb > cbRECRecordMost )
			return JET_errRecordTooBig;

		/*** Append new field to end of record ***/
		ptagfld = (TAGFLD*)(pbRec + cbRec);
		ptagfld->fid = fid;
		ptagfld->cb = (WORD)plineField->cb;
		memcpy(ptagfld->rgb, plineField->pb, plineField->cb);
		pfucb->lineWorkBuf.cb += sizeof(TAGFLD) + ptagfld->cb;
		}
	else if ( itagSequence == 0 || ptagfld->fid > fid )
		{
		/*	inserting new tagged column instance.
		/**/
		/*** Adding NULL: do nothing ***/
		if ( plineField == NULL )
			return JET_errSuccess;

		/*** Will field fit ***/
		if ( cbRec + plineField->cb > cbRECRecordMost )
			return JET_errRecordTooBig;

		/*** Shift rest of record over including tag header ***/
		memmove( ptagfld->rgb + plineField->cb, (BYTE *)ptagfld, (size_t)(pbRecMax - (BYTE *)ptagfld) );

		/*** Copy in new field data; bump record size ***/
		memcpy( ptagfld->rgb, plineField->pb, plineField->cb );
		ptagfld->fid = fid;
		ptagfld->cb = (WORD)plineField->cb;
		pfucb->lineWorkBuf.cb += sizeof(TAGFLD) + plineField->cb;
		}
	else if ( plineField == NULL )
		{
		/*** Changing to NULL:	delete occurance from record ***/
		memmove( (BYTE*)ptagfld, ptagfld->rgb + cbTagField,
			(size_t)(pbRecMax - ( ptagfld->rgb + cbTagField )) );
		pfucb->lineWorkBuf.cb -= sizeof(TAGFLD) + cbTagField;
		}
	else
		{
		/*** Changing to non-NULL value: have to shift record data ***/
		/*** Compute change in field size ***/
		dbFieldData = plineField->cb - cbTagField;
		if ( cbRec + dbFieldData > cbRECRecordMost )
			return JET_errRecordTooBig;

		/*** Shift rest of record over ***/
		memmove( ptagfld->rgb + cbTagField + dbFieldData,
			ptagfld->rgb + cbTagField,
			(size_t)(pbRecMax - ( ptagfld->rgb + cbTagField )) );

		/*** Copy in new field data; bump record size ***/
		memcpy( ptagfld->rgb, plineField->pb, plineField->cb );
		ptagfld->cb = (WORD)plineField->cb;
		pfucb->lineWorkBuf.cb += dbFieldData;
		}

	return JET_errSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\fldnorm.c ===
#include "config.h"

#include <string.h>
#include <stddef.h>
#include <stdlib.h>

#include "daedef.h"
#include "pib.h"
#include "ssib.h"
#include "page.h"
#include "fcb.h"
#include "fucb.h"
#include "stapi.h"
#include "fdb.h"
#include "idb.h"
#include "recapi.h"
#include "recint.h"
#include "fmp.h"

DeclAssertFile;					/* Declare file name for assert macros */


LOCAL ERR ErrRECIExtractLongValue( FUCB *pfucb, BYTE *rgbLV, ULONG cbMax, LINE *pline )
	{
	ERR			err;
	ULONG		cbActual;

	if ( pline->cb >= sizeof(LV) && FFieldIsSLong( pline->pb ) )
		{
		/* lock contents for key
		/**/
		BFPin( pfucb->ssib.pbf );
		BFSetReadLatch( pfucb->ssib.pbf, pfucb->ppib );

		err = ErrRECRetrieveSLongField( pfucb,
			LidOfLV( pline->pb ),
			0,
			rgbLV,
			cbMax,
			&cbActual );

		BFResetReadLatch( pfucb->ssib.pbf, pfucb->ppib );
		BFUnpin( pfucb->ssib.pbf );

		/*	if there is an id, then there must be a chunk
		/**/
		if ( err < 0  )
			goto HandleError;
		pline->pb = rgbLV;
		pline->cb = cbActual;
		}
	else
		{
		/*	intrinsic long field
		/**/
		pline->pb += offsetof( LV, rgb );
		pline->cb -= offsetof( LV, rgb );
		}

	/*	constrain pline->cb to be within max
	/**/
	if ( pline->cb > cbMax )
		pline->cb = cbMax;
	Assert( pline->cb <= JET_cbColumnMost );
	err = JET_errSuccess;
HandleError:
	return err;
	}


//+API
//	ErrRECExtractKey
//	========================================================
//	ErrRECExtractKey( FUCB *pfucb, FDB *pfdb, IDB *pidb, LINE *plineRec, KEY *pkey, ULONG itagSequence )
//
//	Extracts the normalized key from a record, based on an index descriptor.
//
//	PARAMETERS
//		pfucb			cursor for record
//	 	pfdb		  	field info for index
// 		pidb		  	index key descriptor
// 		plineRec	  	data record to extract key from
// 		pkey		  	buffer to put extracted key in; pkey->pb must
//						point to a large enough buffer, JET_cbKeyMost bytes.
// 		itagSequence  	A secondary index whose key contains a tagged
//						field segment will have an index entry made for
//						each value of the tagged field, each refering to
//						the same record.  This parameter specifies which
//						occurance of the tagged field should be included
//						in the extracted key.
//
//	RETURNS	Error code, one of:
//		JET_errSuccess		success
//		+wrnFLDNullKey	   	key has all NULL segments
//		+wrnFLDNullSeg	   	key has NULL segment
//
//	COMMENTS
//		Key formation is as follows:  each key segment is extracted
//		from the record, transformed into a normalized form, and
//		complemented if it is "descending" in the key.	The key is
//		formed by concatenating each such transformed segment.
//-
ERR ErrRECExtractKey(
	FUCB	  	*pfucb,
	FDB	 		*pfdb,
	IDB	 		*pidb,
	LINE	  	*plineRec,
	KEY	 		*pkey,
	ULONG	   	itagSequence )
	{
	ERR	 		err = JET_errSuccess; 				// Error code of various utility.
	BOOL	  	fAllNulls = fTrue;					// Assume all null, until proven otherwise.
	BOOL	  	fNullSeg = fFalse;					// Assume no null segments
	BOOL	  	fColumnTruncated = fFalse;
	BOOL	  	fKeyTruncated = fFalse;
	BOOL	  	fSawMultivalue = fFalse;			// Extracted multi-valued column

	BYTE	  	*pbSeg;					  			// Pointer to current segment.
	INT	 		cbKeyAvail;				  			// Space remaining in key buffer.
	IDXSEG		*pidxseg;
	IDXSEG		*pidxsegMac;
	JET_COLTYP	coltyp;
	/*	long value support
	/**/
	BYTE	  	rgbLV[JET_cbColumnMost];

	Assert( pkey != NULL );
	Assert( pkey->pb != NULL );
	Assert( pfdb != pfdbNil );
	Assert( pidb != pidbNil );

	/*	start at beginning of buffer, with max size remaining.
	/**/
	pbSeg = pkey->pb;
	cbKeyAvail = JET_cbKeyMost;

	/*	extract each segment in key description
	/**/
	pidxseg = pidb->rgidxseg;
	pidxsegMac = pidxseg + pidb->iidxsegMac;
	for ( ; pidxseg < pidxsegMac; pidxseg++ )
		{
		FIELD 	*pfield;						// pointer to curr FIELD struct
		FID		fid;					 		// Field id of segment.
		BYTE   	*pbField;						// Pointer to field data.
		INT		cbField;						// Length of field data.
		INT		cbT;
		BOOL   	fDescending;					// Segment is in desc. order.
		BOOL   	fFixedField;					// Current field is fixed-length?
		BOOL   	fMultivalue = fFalse;			// Current field is multi-valued.
		BYTE   	rgbSeg[ JET_cbKeyMost ]; 		// Segment buffer.
		int		cbSeg;							// Length of segment.
		WORD   	w;				  				// Temp var.
		ULONG  	ul;								// Temp var.
		LINE   	lineField;

		/*	negative field id means descending in the key
		/**/
		fid = ( fDescending = ( *pidxseg < 0 ) ) ? -(*pidxseg) : *pidxseg;

		/*	determine field type from FDB
		/**/
		if ( fFixedField = FFixedFid( fid ) )
			{
			Assert(fid <= pfdb->fidFixedLast);
			pfield = pfdb->pfieldFixed + (fid-fidFixedLeast);
			coltyp = pfield->coltyp;
			}
		else if ( FVarFid( fid ) )
			{
			Assert( fid <= pfdb->fidVarLast );
			pfield = pfdb->pfieldVar + (fid-fidVarLeast);
			coltyp = pfield->coltyp;
			Assert( coltyp == JET_coltypBinary || coltyp == JET_coltypText );
			}
		else
			{
			Assert( FTaggedFid( fid ) );
			Assert( fid <= pfdb->fidTaggedLast );
			pfield = pfdb->pfieldTagged + (fid - fidTaggedLeast);
			coltyp = pfield->coltyp;
			fMultivalue = pfield->ffield & ffieldMultivalue;
			}

		/*	get segment value: get from the record
		/*	using ExtractField.
		/**/
		Assert( !FLineNull( plineRec ) );
		if ( fMultivalue && !fSawMultivalue )
			{
			Assert( fid != 0 );
			err = ErrRECExtractField( pfdb, plineRec, &fid, pNil, itagSequence, &lineField );
			if ( err == wrnRECLongField )
				{
				Call( ErrRECIExtractLongValue( pfucb, rgbLV, sizeof(rgbLV), &lineField ) );
				}
			if ( itagSequence > 1 && err == JET_wrnColumnNull )
				{
				err = wrnFLDOutOfKeys;
				goto HandleError;
				}
			fSawMultivalue = fTrue;
			}
		else
			{
			err = ErrRECExtractField( pfdb, plineRec, &fid, pNil, 1, &lineField );
			if ( err == wrnRECLongField )
				{
				Call( ErrRECIExtractLongValue( pfucb, rgbLV, sizeof(rgbLV), &lineField ) );
				}
			}
		Assert( err == JET_errSuccess || err == JET_wrnColumnNull );
		Assert( lineField.cb <= JET_cbColumnMost );
		cbField = lineField.cb;
		pbField = lineField.pb;

		/*	segment transformation: check for null field or zero-length fields first
		/*	err == JET_wrnColumnNull => Null field
		/*	zero-length field otherwise,
		/*	the latter is allowed only for Text and LongText
		/**/
		if ( err == JET_wrnColumnNull || pbField == NULL || cbField == 0 )
			{
			if ( err == JET_wrnColumnNull )
				fNullSeg = fTrue;
			switch ( coltyp )
				{
				/*	most nulls are represented by 0x00
				/**/
				case JET_coltypBit:
				case JET_coltypUnsignedByte:
				case JET_coltypShort:
				case JET_coltypLong:
				case JET_coltypCurrency:
				case JET_coltypIEEESingle:
				case JET_coltypIEEEDouble:
				case JET_coltypDateTime:
					Assert( err == JET_wrnColumnNull );
				case JET_coltypText:
				case JET_coltypLongText:
					cbSeg = 1;
					if ( err == JET_wrnColumnNull)
						rgbSeg[0] = 0;
					else
						rgbSeg[0] = 0x40;
					break;

				/*	binary-data: 0x00 if fixed, else 9 0x00s (a chunk)
				/**/
				default:
					Assert( err == JET_errSuccess || err == JET_wrnColumnNull );
					Assert( coltyp == JET_coltypBinary || coltyp == JET_coltypLongBinary );
					memset( rgbSeg, 0, cbSeg = min( cbKeyAvail, ( fFixedField ? 1 : 9 ) ) );
					break;
				}

			/*	avoid annoying over-nesting
			/**/
			goto AppendToKey;
			}

		/*	field is not null-valued: perform transformation
		/**/
		fAllNulls = fFalse;
		switch ( coltyp )
			{
			/*	BIT: prefix with 0x7F, flip high bit
			/**/
			/*	UBYTE: prefix with 0x7F
			/**/
			case JET_coltypBit:
			case JET_coltypUnsignedByte:
				cbSeg = 2;
				rgbSeg[0] = 0x7F;
				rgbSeg[1] = coltyp == JET_coltypUnsignedByte ?
					*pbField : bFlipHighBit(*pbField);
				break;

			/*	SHORT: prefix with 0x7F, flip high bit
			/**/
			case JET_coltypShort:
				cbSeg = 3;
				rgbSeg[0] = 0x7F;
/***BEGIN MACHINE DEPENDENT***/
				w = wFlipHighBit( *(WORD UNALIGNED *) pbField);
				rgbSeg[1] = (BYTE)(w >> 8);
				rgbSeg[2] = (BYTE)(w & 0xff);
/***END MACHINE DEPENDANT***/
				break;

			/**	LONG: prefix with 0x7F, flip high bit
			/**/
			/** works because of 2's complement **/
			case JET_coltypLong:
				cbSeg = 5;
				rgbSeg[0] = 0x7F;
				ul = ulFlipHighBit( *(ULONG UNALIGNED *) pbField);
				rgbSeg[1] = (BYTE)((ul >> 24) & 0xff);
				rgbSeg[2] = (BYTE)((ul >> 16) & 0xff);
				rgbSeg[3] = (BYTE)((ul >> 8) & 0xff);
				rgbSeg[4] = (BYTE)(ul & 0xff);
				break;

			/*	REAL: First swap bytes.  Then, if positive:
			/*	flip sign bit, else negative: flip whole thing.
			/*	Then prefix with 0x7F.
			/**/
			case JET_coltypIEEESingle:
				cbSeg = 5;
				rgbSeg[0] = 0x7F;
/***BEGIN MACHINE DEPENDANT***/
				rgbSeg[4] = *pbField++; rgbSeg[3] = *pbField++;
				rgbSeg[2] = *pbField++; rgbSeg[1] = *pbField;
				if (rgbSeg[1] & maskByteHighBit)
					*(ULONG UNALIGNED *)(&rgbSeg[1]) = ~*(ULONG UNALIGNED *)(&rgbSeg[1]);
				else
					rgbSeg[1] = bFlipHighBit(rgbSeg[1]);
 /***END MACHINE DEPENDANT***/
				break;

			/*	LONGREAL: First swap bytes.  Then, if positive:
			/*	flip sign bit, else negative: flip whole thing.
			/*	Then prefix with 0x7F.
			/**/
			/*	Same for DATETIME and CURRENCY
			/**/
			case JET_coltypCurrency:
			case JET_coltypIEEEDouble:
			case JET_coltypDateTime:
				cbSeg = 9;
				rgbSeg[0] = 0x7F;
/***BEGIN MACHINE DEPENDANT***/
				rgbSeg[8] = *pbField++; rgbSeg[7] = *pbField++;
				rgbSeg[6] = *pbField++; rgbSeg[5] = *pbField++;
				rgbSeg[4] = *pbField++; rgbSeg[3] = *pbField++;
				rgbSeg[2] = *pbField++; rgbSeg[1] = *pbField;
				if (coltyp != JET_coltypCurrency && (rgbSeg[1] & maskByteHighBit))
					{
					*(ULONG UNALIGNED *)(&rgbSeg[1]) = ~*(ULONG UNALIGNED *)(&rgbSeg[1]);
					*(ULONG UNALIGNED *)(&rgbSeg[5]) = ~*(ULONG UNALIGNED *)(&rgbSeg[5]);
					}
				else
					rgbSeg[1] = bFlipHighBit(rgbSeg[1]);
/***END MACHINE DEPENDANT***/
				break;

			/*	case-insensetive TEXT: convert to uppercase.
			/*	If fixed, prefix with 0x7F;  else affix with 0x00
			/**/
			case JET_coltypText:
			case JET_coltypLongText:
				Assert( cbKeyAvail >= 0 );
				cbT = cbKeyAvail == 0 ? 0 : cbKeyAvail - 1;

				/* Unicode support
				/**/
				if ( pfield->cp == usUniCodePage )
					{
					ERR	errT;

					/*	cbField may have been truncated to an odd number
					/*	of bytes, so enforce even.
					/**/
					Assert( cbField % 2 == 0 || cbField == JET_cbColumnMost );
					cbField = ( cbField / 2 ) * 2;
					errT = ErrSysMapString(
						(LANGID)( FIDBLangid( pidb ) ? pidb->langid : pfield->langid ),
						pbField,
						cbField,
						rgbSeg + 1,
						cbT,
						&cbSeg );
					Assert( errT == JET_errSuccess || errT == wrnFLDKeyTooBig );
					if ( errT == wrnFLDKeyTooBig )
						fColumnTruncated = fTrue;
					}
				else
					{
					ERR	errT;

					errT = ErrSysNormText( pbField, cbField, cbT, rgbSeg + 1, &cbSeg );
					Assert( errT == JET_errSuccess || errT == wrnFLDKeyTooBig );
					if ( errT == wrnFLDKeyTooBig )
						fColumnTruncated = fTrue;
					}
				Assert( cbSeg <= cbT );

				/*	put the prefix there
				/**/
				*rgbSeg = 0x7F;
				cbSeg++;

				break;

			/*	BINARY data: if fixed, prefix with 0x7F;
			/*	else break into chunks of 8 bytes, affixing each
			/*	with 0x09, except for the last chunk, which is
			/*	affixed with the number of bytes in the last chunk.
			/**/
			default:
				Assert( coltyp == JET_coltypBinary || coltyp == JET_coltypLongBinary );
				if ( fFixedField )
					{
					if ( ( cbSeg = cbField + 1 ) > cbKeyAvail )
						{
						cbSeg = cbKeyAvail;
						fColumnTruncated = fTrue;
						}
					if ( cbSeg > 0 )
						{
						rgbSeg[0] = 0x7F;
						memcpy( &rgbSeg[1], pbField, cbSeg - 1 );
						}
					}
				else
					{
					BYTE *pb;

					/*	calculate total bytes needed for chunks and
					/*	counts;  if it won't fit, round off to the
					/*	nearest chunk.
					/**/
					if ( ( cbSeg = ( ( cbField + 7 ) / 8 ) * 9 ) > cbKeyAvail )
						{
						cbSeg = ( cbKeyAvail / 9 ) * 9;
						cbField = ( cbSeg / 9 ) * 8;
						fColumnTruncated = fTrue;
						}
					/*	copy data by chunks, affixing 0x09s
					/**/
					pb = rgbSeg;
					while ( cbField >= 8 )
						{
						memcpy( pb, pbField, 8 );
						pbField += 8;
						pb += 8;
						*pb++ = 9;
						cbField -= 8;
						}
					/*	last chunk: pad with 0x00s if needed
					/**/
					if ( cbField == 0 )
						pb[-1] = 8;
					else
						{
						memcpy( pb, pbField, cbField );
						pb += cbField;
						memset( pb, 0, 8 - cbField );
						pb += ( 8 - cbField );
						*pb = (BYTE)cbField;
						}
					}
				break;
			}

AppendToKey:
		/*	if key has not already been truncated, then append
		/*	normalized key segment.  If insufficient room in key
		/*	for key segment, then set key truncated to fTrue.  No
		/*	additional key data will be appended after this append.
		/**/
		if ( !fKeyTruncated )
			{
			/*	if column truncated or insufficient room in key
			/*	for key segment, then set key truncated to fTrue.
			/*	Append variable size column keys only.
			/**/
			if ( fColumnTruncated || cbSeg > cbKeyAvail )
				{
				fKeyTruncated = fTrue;

				if ( coltyp == JET_coltypBinary ||
					coltyp == JET_coltypText ||
					coltyp == JET_coltypLongText ||
					coltyp == JET_coltypLongBinary )
					{
					cbSeg = min( cbSeg, cbKeyAvail );
					}
				else
					cbSeg = 0;
				}

			/*	if descending, flip all bits of transformed segment
			/**/
			if ( fDescending && cbSeg > 0 )
				{
				BYTE *pb;

				for ( pb = rgbSeg + cbSeg - 1; pb >= (BYTE*)rgbSeg; pb-- )
					*pb ^= 0xff;
				}

			memcpy( pbSeg, rgbSeg, cbSeg );
			pbSeg += cbSeg;
			cbKeyAvail -= cbSeg;
			}
		}

	/*	compute length of key and return error code
	/**/
	pkey->cb = (UINT)(pbSeg - pkey->pb);
	if ( fAllNulls )
		{
		err = wrnFLDNullKey;
		}
	else
		{
		if ( fNullSeg )
			err = wrnFLDNullSeg;
		}

	Assert( err == JET_errSuccess || err == wrnFLDNullKey ||
		err == wrnFLDNullSeg );
HandleError:
	return err;
	}


LOCAL INLINE ERR ErrFLDNormalizeSegment(
	IDB			*pidb,
	LINE		*plineColumn,
	LINE		*plineNorm,
	FIELD		*pfield,
	INT			cbAvail,
	BOOL		fDescending,
	BOOL		fFixedField,
	JET_GRBIT	grbit )
	{
	ERR	 	  	err = JET_errSuccess;
	JET_COLTYP	coltyp = pfield->coltyp;
	INT	 	  	cbColumn;
	BYTE 		*pbColumn;
	BYTE		*pbNorm = plineNorm->pb;
	WORD		wT;
	ULONG		ulT;

	/*	check for null or zero-length field first
	/*	plineColumn == NULL implies null-field,
	/*	zero-length otherwise
	/**/
	if ( plineColumn == NULL || plineColumn->pb == NULL || plineColumn->cb == 0 )
		{
		switch ( coltyp )
			{
			/*	most nulls are represented by 0x00
			/*	zero-length fields are represented by 0x40
			/*	and are useful only for text and longtext
			/**/
			case JET_coltypBit:
			case JET_coltypUnsignedByte:
			case JET_coltypShort:
			case JET_coltypLong:
			case JET_coltypCurrency:
			case JET_coltypIEEESingle:
			case JET_coltypIEEEDouble:
			case JET_coltypDateTime:
				plineNorm->cb = 1;
				Assert( plineColumn == NULL );
				*pbNorm = 0;
				break;
			case JET_coltypText:
			case JET_coltypLongText:
				plineNorm->cb = 1;
				if ( plineColumn != NULL )
					*pbNorm = 0;
				else
					*pbNorm = 0x40;
				break;

			/*	binary-data: 0x00 if fixed, else 9 0x00s (a chunk)
			/**/
			default:
				Assert( plineColumn == NULL );
				Assert( coltyp == JET_coltypBinary || coltyp == JET_coltypLongBinary );
				memset( pbNorm, 0, plineNorm->cb = ( fFixedField ? 1 : 9 ) );
				break;
			}
		goto FlipSegment;
		}

	cbColumn = plineColumn->cb;
	pbColumn = plineColumn->pb;

	switch ( coltyp )
		{
		/*	BYTE: prefix with 0x7F, flip high bit
		/**/
		/*	UBYTE: prefix with 0x7F
		/**/
		case JET_coltypBit:
		case JET_coltypUnsignedByte:
			plineNorm->cb = 2;
			*pbNorm++ = 0x7F;
			*pbNorm = ( coltyp == JET_coltypUnsignedByte ) ? *pbColumn :
				bFlipHighBit( *pbColumn );
			break;

		/*	SHORT: prefix with 0x7F, flip high bit
		/**/
		/*	UNSIGNEDSHORT: prefix with 0x7F
		/**/
		case JET_coltypShort:
			plineNorm->cb = 3;
			*pbNorm++ = 0x7F;
			wT = wFlipHighBit( *(WORD UNALIGNED *)pbColumn );
			*pbNorm++ = (BYTE)(wT >> 8);
			*pbNorm = (BYTE)(wT & 0xff);
			break;

		/*	LONG: prefix with 0x7F, flip high bit
		/**/
		/*	UNSIGNEDLONG: prefix with 0x7F
		/**/
		case JET_coltypLong:
			plineNorm->cb = 5;
			*pbNorm++ = 0x7F;
			ulT = ulFlipHighBit( *(ULONG UNALIGNED *) pbColumn);
			*pbNorm++ = (BYTE)((ulT >> 24) & 0xff);
			*pbNorm++ = (BYTE)((ulT >> 16) & 0xff);
			*pbNorm++ = (BYTE)((ulT >> 8) & 0xff);
			*pbNorm = (BYTE)(ulT & 0xff);
			break;

		/*	REAL: First swap bytes.  Then, if positive:
		/*	flip sign bit, else negative: flip whole thing.
		/*	Then prefix with 0x7F.
		/**/
		case JET_coltypIEEESingle:
			plineNorm->cb = 5;
			pbNorm[0] = 0x7F;
/***BEGIN MACHINE DEPENDANT***/
			pbNorm[4] = *pbColumn++; pbNorm[3] = *pbColumn++;
			pbNorm[2] = *pbColumn++; pbNorm[1] = *pbColumn;
			if (pbNorm[1] & maskByteHighBit)
				*(ULONG UNALIGNED *)(&pbNorm[1]) = ~*(ULONG UNALIGNED *)(&pbNorm[1]);
			else
				pbNorm[1] = bFlipHighBit(pbNorm[1]);
/***END MACHINE DEPENDANT***/
			break;

		/*	LONGREAL: First swap bytes.  Then, if positive:
		/*	flip sign bit, else negative: flip whole thing.
		/*	Then prefix with 0x7F.
		/*	Same for DATETIME and CURRENCY
		/**/
		case JET_coltypCurrency:
		case JET_coltypIEEEDouble:
		case JET_coltypDateTime:
			plineNorm->cb = 9;
			pbNorm[0] = 0x7F;
/***BEGIN MACHINE DEPENDANT***/
			pbNorm[8] = *pbColumn++; pbNorm[7] = *pbColumn++;
			pbNorm[6] = *pbColumn++; pbNorm[5] = *pbColumn++;
			pbNorm[4] = *pbColumn++; pbNorm[3] = *pbColumn++;
			pbNorm[2] = *pbColumn++; pbNorm[1] = *pbColumn;
			if ( coltyp != JET_coltypCurrency && ( pbNorm[1] & maskByteHighBit ) )
				{
				*(ULONG UNALIGNED *)(&pbNorm[1]) = ~*(ULONG UNALIGNED *)(&pbNorm[1]);
				*(ULONG UNALIGNED *)(&pbNorm[5]) = ~*(ULONG UNALIGNED *)(&pbNorm[5]);
				}
			else
				pbNorm[1] = bFlipHighBit(pbNorm[1]);
/***END MACHINE DEPENDANT***/
			break;

		/*	case-insensetive TEXT:	convert to uppercase.
		/*	If fixed, prefix with 0x7F;  else affix with 0x00
		/**/
		case JET_coltypText:
		case JET_coltypLongText:
				/* Unicode support
				/**/
				if ( pfield->cp == usUniCodePage )
					{
					Assert( cbAvail - 1 > 0 );
					/*	cbColumn may have been truncated to an odd number
					/*	of bytes, so enforce even.
					/**/
					Assert( cbColumn % 2 == 0 || cbColumn == JET_cbColumnMost );
					cbColumn = ( cbColumn / 2 ) * 2;
					err = ErrSysMapString(
						(LANGID)( FIDBLangid( pidb ) ? pidb->langid : pfield->langid ),
						pbColumn,
						cbColumn,
  						pbNorm + 1,
						cbAvail - 1,
						&cbColumn );
					Assert( err == JET_errSuccess || err == wrnFLDKeyTooBig );
					}
				else
					{
					err = ErrSysNormText( pbColumn, cbColumn, cbAvail - 1, pbNorm + 1, &cbColumn );
					Assert( err == JET_errSuccess || err == wrnFLDKeyTooBig );
					}

			Assert( cbColumn <= cbAvail - 1 );

			/*	put the prefix there
			/**/
			*pbNorm = 0x7F;
			plineNorm->cb = cbColumn + 1;

			break;

		/*	BINARY data: if fixed, prefix with 0x7F;
		/*	else break into chunks of 8 bytes, affixing each
		/*	with 0x09, except for the last chunk, which is
		/*	affixed with the number of bytes in the last chunk.
		/**/
		default:
			Assert( coltyp == JET_coltypBinary || coltyp == JET_coltypLongBinary );
			if ( fFixedField )
				{
				if ( cbColumn + 1 > cbAvail )
					{
					cbColumn = cbAvail - 1;
					err = wrnFLDKeyTooBig;
					}
				plineNorm->cb = cbColumn+1;
				*pbNorm++ = 0x7F;
				memcpy( pbNorm, pbColumn, cbColumn );
				}
			else
				{
				BYTE *pb;

				if ( ( ( cbColumn + 7 ) / 8 ) * 9 > cbAvail )
					{
					cbColumn = cbAvail / 9 * 8;
					err = wrnFLDKeyTooBig;
					}
				plineNorm->cb = ( ( cbColumn + 7 ) / 8 ) * 9;
				/*	copy data by chunks, affixing 0x09s
				/**/
				pb = pbNorm;
				while ( cbColumn >= 8 )
					{
					memcpy( pb, pbColumn, 8 );
					pbColumn += 8;
					pb += 8;
					*pb++ = 9;
					cbColumn -= 8;
					}
				/*	last chunk: pad with 0x00s if needed
				/**/
				if ( cbColumn == 0 )
					pb[-1] = 8;
				else
					{
					memcpy( pb, pbColumn, cbColumn );
					pb += cbColumn;
					memset( pb, 0, 8 - cbColumn );
					pb += ( 8 - cbColumn );
					*pb = (BYTE)cbColumn;
					}
				}
			break;
		}

FlipSegment:
	if ( fDescending )
		{
		BYTE *pbMin = plineNorm->pb;
		BYTE *pb = pbMin + plineNorm->cb - 1;
		while ( pb >= pbMin )
			*pb-- ^= 0xff;
		}

	/*	string and substring limit key support
	/**/
	if ( grbit & ( JET_bitStrLimit | JET_bitSubStrLimit ) )
		{
		BYTE	bDescending;

		bDescending = fDescending ? 0xff : 0x00;

		if ( ( (grbit & JET_bitSubStrLimit) != 0 ) &&
			( coltyp == JET_coltypText || coltyp == JET_coltypLongText ) )
			{
			Assert( grbit & JET_bitSubStrLimit );

			if ( pfield->cp == usUniCodePage )
				{
				INT	ibT = 1;
				BYTE	bUnicodeDelimiter = fDescending ? 0xfe : 0x01;
				BYTE	bUnicodeSentinel = 0xff;

				/*	find end of base char weight and truncate key
				/*	Append 0xff as first byte of next character as maximum
				/*	possible value.
				/**/
				while ( plineNorm->pb[ibT] != bUnicodeDelimiter && ibT < cbAvail )
					ibT += 2;

				if( ibT < cbAvail )
					{
					plineNorm->cb = ibT + 1;
					plineNorm->pb[ibT] = fDescending ? ~bUnicodeSentinel : bUnicodeSentinel;
					}
				else
					{
					Assert( ibT == cbAvail );
					plineNorm->pb[ibT - 1] = fDescending ? ~bUnicodeSentinel : bUnicodeSentinel;
					}
				}
			else
				{
				BYTE	bT = ( bDescending & 0xf0 );
				INT	ibT = 0;

				/*	find the begining of the accent string
				/**/
				while ( ( plineNorm->pb[++ibT] & 0xf0 ) != bT && ibT < cbAvail );

				/*	truncate out the accent information and increment last char
				/**/
				if( ibT < cbAvail )
					{
					plineNorm->cb = ibT + 1;
					plineNorm->pb[ibT] = ~bDescending;
					}
				else
					{
					Assert( ibT == cbAvail );
					plineNorm->pb[cbAvail - 1] += fDescending ? -1 : 1;
					}
				}
			}
		else if ( grbit & JET_bitStrLimit )
			{
			/*	binary columns padd with 0s so must effect
			/*	limit within key format
			/**/
			if ( coltyp == JET_coltypBinary || coltyp == JET_coltypLongBinary )
				{
				pbNorm = plineNorm->pb + plineNorm->cb - 1;
				Assert( *pbNorm != 0 && *pbNorm != 0xff );
				if ( fDescending )
					*pbNorm -= 1;
				else
 					*pbNorm += 1;
				pbNorm--;
				while ( *pbNorm == bDescending )
					*pbNorm-- = ~bDescending;
				}
			else
				{
				if ( plineNorm->cb < (ULONG)cbAvail )
					{
					plineNorm->pb[plineNorm->cb] = ~bDescending;
					plineNorm->cb++;
					}
				else if ( plineColumn != NULL && plineColumn->cb > 0 )
					{
					Assert( plineNorm->cb > 1 );
					while( plineNorm->pb[plineNorm->cb - 1] == ~bDescending )
						{
						Assert( plineNorm->cb > 1 );
						/*	truncate normalized key
						/**/
						plineNorm->cb--;
						}
					Assert( plineNorm->cb > 0 );
					/*	increment last normalized byte
					/**/
					plineNorm->pb[plineNorm->cb]++;
					}
				}
			}
		}

	Assert( err == JET_errSuccess || err == wrnFLDKeyTooBig );
	return err;
	}


	ERR VTAPI
ErrIsamMakeKey( PIB *ppib, FUCB *pfucb, BYTE *pbKeySeg, ULONG cbKeySeg, JET_GRBIT grbit )
	{
	ERR		err = JET_errSuccess;
	IDB		*pidb;
	FDB		*pfdb;
	FIELD 	*pfield;
	FID		fid;
	INT		iidxsegCur;
	LINE  	lineNormSeg;
	BYTE  	rgbNormSegBuf[ JET_cbKeyMost ];
	BYTE  	rgbSpaceFilled[ JET_cbKeyMost ];
	BOOL  	fDescending;
	BOOL  	fFixedField;
	LINE  	lineKeySeg;

	CheckPIB( ppib );
	CheckFUCB( ppib, pfucb );

	/*	set efficiency variables
	/**/
	lineNormSeg.pb = rgbNormSegBuf;
	lineKeySeg.pb = pbKeySeg;
	lineKeySeg.cb = min( JET_cbColumnMost, cbKeySeg );

	/*	allocate key buffer if needed
	/**/
	if ( pfucb->pbKey == NULL )
		{
		pfucb->pbKey = LAlloc( 1L, JET_cbKeyMost );
		if ( pfucb->pbKey == NULL )
			return JET_errOutOfMemory;
		}

	Assert( !( grbit & JET_bitKeyDataZeroLength ) || cbKeySeg == 0 );

	/*	if key is already normalized, then copy directly to
	/*	key buffer and return.
	/**/
	if ( grbit & JET_bitNormalizedKey )
		{
		if ( cbKeySeg > JET_cbKeyMost - 1 )
			return JET_errInvalidParameter;
		/*	set key segment counter to any value
		/*	regardless of the number of key segments.
		/**/
		pfucb->pbKey[0] = 1;
		memcpy( pfucb->pbKey + 1, pbKeySeg, cbKeySeg );
		pfucb->cbKey = cbKeySeg + 1;
		KSSetPrepare( pfucb );
		return JET_errSuccess;
		}

	/*	start new key if requested
	/**/
	if ( grbit & JET_bitNewKey )
		{
		pfucb->pbKey[0] = 0;
		pfucb->cbKey = 1;
		}
	else
		{
		if ( !( FKSPrepared( pfucb ) ) )
			{
			return JET_errKeyNotMade;
			}
		}

	/*	get pidb
	/**/
	if ( FFUCBIndex( pfucb ) )
		{
		if ( pfucb->pfucbCurIndex != pfucbNil )
			pidb = pfucb->pfucbCurIndex->u.pfcb->pidb;
		else if ( ( pidb = pfucb->u.pfcb->pidb ) == pidbNil )
			return JET_errNoCurrentIndex;
		}
	else
		{
		pidb = ((FCB*)pfucb->u.pscb)->pidb;
		}

	Assert( pidb != pidbNil );
	if ( ( iidxsegCur = pfucb->pbKey[0] ) >= pidb->iidxsegMac )
		return JET_errKeyIsMade;
	fid = ( fDescending = pidb->rgidxseg[iidxsegCur] < 0 ) ?
		-pidb->rgidxseg[iidxsegCur] : pidb->rgidxseg[iidxsegCur];
	pfdb = (FDB *)pfucb->u.pfcb->pfdb;
	if ( fFixedField = FFixedFid( fid ) )
		{
		pfield = pfdb->pfieldFixed + ( fid - fidFixedLeast );

		/*	check that length of key segment matches fixed field length
		/**/
		if ( cbKeySeg > 0 && cbKeySeg != pfield->cbMaxLen )
			{
			/*	if column is fixed text and buffer size is less
			/*	than fixed size then padd with spaces.
			/**/
			Assert( pfield->coltyp != JET_coltypLongText );
			if ( pfield->coltyp == JET_coltypText && cbKeySeg < pfield->cbMaxLen )
				{
				Assert( cbKeySeg == lineKeySeg.cb );
				memcpy( rgbSpaceFilled, lineKeySeg.pb, lineKeySeg.cb );
				memset ( rgbSpaceFilled + lineKeySeg.cb, ' ', pfield->cbMaxLen - lineKeySeg.cb );
				lineKeySeg.pb = rgbSpaceFilled;
				lineKeySeg.cb = pfield->cbMaxLen;
				}
			else
				{
				return JET_errInvalidBufferSize;
				}
			}
		}
	else if ( FVarFid( fid ) )
		{
		pfield = pfdb->pfieldVar + ( fid - fidVarLeast );
		}
	else
		{
		pfield = pfdb->pfieldTagged + ( fid - fidTaggedLeast );
		}

	Assert( pfucb->cbKey <= JET_cbKeyMost + 1 );
	if ( !FKSTooBig( pfucb ) && ( pfucb->cbKey < JET_cbKeyMost + 1 ) )
		{
		ERR		errT;

		errT = ErrFLDNormalizeSegment(
			pidb,
			( cbKeySeg != 0 || ( grbit & JET_bitKeyDataZeroLength ) ) ? (&lineKeySeg) : NULL,
			&lineNormSeg,
			pfield,
			JET_cbKeyMost + 1 - pfucb->cbKey,
			fDescending,
			fFixedField,
			grbit );
		Assert( errT == JET_errSuccess || errT == wrnFLDKeyTooBig );
		if ( errT == wrnFLDKeyTooBig )
			KSSetTooBig( pfucb );
		}
	else
		{
		lineNormSeg.cb = 0;
		Assert( pfucb->cbKey <= JET_cbKeyMost + 1 );
		}

	/*	increment segment counter
	/**/
	pfucb->pbKey[0]++;
	if ( pfucb->cbKey + lineNormSeg.cb > JET_cbKeyMost + 1 )
		{
		lineNormSeg.cb = JET_cbKeyMost + 1 - pfucb->cbKey;
		/*	no warning returned when key exceeds most size
		/**/
		}
	memcpy( pfucb->pbKey + pfucb->cbKey, lineNormSeg.pb, lineNormSeg.cb );
	pfucb->cbKey += lineNormSeg.cb;
	KSSetPrepare( pfucb );
	Assert( err == JET_errSuccess );
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\frename.c ===
#include "config.h"

#include <string.h>

#include "daedef.h"
#include "pib.h"
#include "ssib.h"
#include "page.h"
#include "fmp.h"
#include "fucb.h"
#include "fcb.h"
#include "stapi.h"
#include "fdb.h"
#include "idb.h"
#include "fileapi.h"
#include "fileint.h"
#include "util.h"
#include "nver.h"
#include "dirapi.h"
#include "spaceapi.h"
#include "dbapi.h"
#include "systab.h"
#include "node.h"
#include "recint.h"
#include "recapi.h"

DeclAssertFile;                                         /* Declare file name for assert macros */

#define fRenameColumn   (1<<0)
#define fRenameIndex    (1<<1)


//+API
//      ErrIsamRenameTable
//      ========================================================================
//      ErrIsamRenameTable( PIB *ppib, DBID dbid, CHAR *szFile, CHAR *szFileNew )
//
// Renames file szFile to szFileNew.  No other attributes of the file
// change.      The renamed file need not reside in the same directory
// as the original file.
//
// RETURNS              Error code from DIRMAN or
//                                       JET_errSuccess                 Everything worked OK.
//                                      -InvalidName                    One of the elements in the
//                                                                                      path given is an FDP node.
//                                      -TableDuplicate                 A file already exists with
//                                                                                      the path given.
// COMMENTS             
//
//      There must not be anyone currently using the file.
//      A transaction is wrapped around this function.  Thus, any
//      work done will be undone if a failure occurs.
//
// SEE ALSO             CreateTable, DeleteTable
//-
ERR VTAPI ErrIsamRenameTable( PIB *ppib, ULONG_PTR vdbid, CHAR *szName, CHAR *szNameNew )
        {
        ERR     err;
        CHAR    szTable[ (JET_cbNameMost + 1) ];
        CHAR    szTableNew[ (JET_cbNameMost + 1) ];
        DBID    dbid = DbidOfVDbid( vdbid );
        FUCB    *pfucb = pfucbNil;
        FUCB    *pfucbTable = pfucbNil;
        KEY                     key;
        BYTE    rgbKey[ JET_cbKeyMost ];
        BYTE    rgbData[ cbNodeMost ];
        LINE    line;
        PGNO    pgnoFDP = pgnoNull;
        BOOL    fSetRename = fFalse;
        FCB                     *pfcbFile;
        CHAR    *szFileName;

        /*      cannot be temporary database
        /**/
        Assert( dbid != dbidTemp );

        /* ensure that database is updatable
        /**/
        CallR( VDbidCheckUpdatable( vdbid ) );

        CheckPIB( ppib );
        CheckDBID( ppib, dbid );
        CallR( ErrCheckName( szTable, szName, (JET_cbNameMost + 1) ) );
        CallR( ErrCheckName( szTableNew, szNameNew, (JET_cbNameMost + 1) ) );

        CallR( ErrDIRBeginTransaction( ppib ) );

#ifdef  SYSTABLES
        {
        OBJID           objid;
        JET_OBJTYP      objtyp;

        CallJ( ErrFindObjidFromIdName( ppib, dbid, objidTblContainer,
                szTable, &objid, &objtyp ), SystabError );

        if ( objtyp == JET_objtypQuery || objtyp == JET_objtypLink )
                {
                CallJ( ErrSysTabRename( ppib, dbid, szTableNew, szTable,
                        objidTblContainer, itableSo ), SystabError );
                CallJ( ErrDIRCommitTransaction( ppib ), SystabError );
                return err;

SystabError:
                CallS( ErrDIRRollback( ppib ) );
                return err;
                }
        }

#endif  /* SYSTABLES */

        /*      open a cursor and move onto FDP
        /**/
        Call( ErrDIROpen( ppib, pfcbNil, dbid, &pfucb ) );

        /*      move to table.
        /**/
        Call( ErrFILESeek( pfucb, szTable ) );

        /*      save pgnoFDP for system table operation
        /**/
        pgnoFDP = PcsrCurrent( pfucb )->pgno;

        /*      cannot rename a table open by anyone
        /**/
        if ( FFCBTableOpen( dbid, pgnoFDP ) )
                {
                err = JET_errTableInUse;
                goto HandleError;
                }

        /*      make sure that table to be renamed is open to
        /*      avoid special case handling of closed table
        /**/
        Call( ErrFILEOpenTable( ppib, dbid, &pfucbTable, szTable, 0 ) );
        DIRGotoFDPRoot( pfucbTable );

        /*      lock table for rename
        /**/
        Call( ErrFCBSetRenameTable( ppib, dbid, pgnoFDP ) );
        fSetRename = fTrue;

        /*      make new table name into key
        /**/
        SysNormText( szTableNew, strlen( szTableNew ), rgbKey, sizeof( rgbKey ), &key.cb );
        key.pb = rgbKey;

        /*      replace table name
        /**/
        Call( ErrDIRGet( pfucbTable ) );
        line.pb = rgbData;
        Assert( pfucbTable->ssib.line.cb <= sizeof rgbData );
        Assert( pfucbTable->ssib.line.cb > 2 * sizeof(WORD) + 2 * sizeof(JET_DATESERIAL) );
        LineCopy( &line, &pfucbTable->lineData );
        /*      overwrite old table name with new table name
        /**/
        memcpy( rgbData + 2 * sizeof(WORD) + 2 * sizeof(JET_DATESERIAL), szTableNew, strlen(szTableNew) );
        line.cb = (ULONG)(2 * sizeof(WORD) + 2 * sizeof(JET_DATESERIAL) + strlen(szTableNew));
        Call( ErrDIRReplace( pfucbTable, &line, fDIRVersion ) );

        /*      update table time stamp
        /**/
        Call( ErrFILEIUpdateFDPData( pfucbTable, fDDLStamp ) )

        /*      replace table key
        /**/
        err = ErrDIRReplaceKey( pfucb, &key, fDIRVersion );
        if ( err < 0 )
                {
                if ( err == JET_errKeyDuplicate )
                        err = JET_errTableDuplicate;
                goto HandleError;
                }

#ifdef  SYSTABLES
        /*      fix name in MSysObjects entry for this table before committing
        /**/
        Call( ErrSysTabRename( ppib, dbid, szTableNew, szTable, objidTblContainer, itableSo ) );
#endif  /* SYSTABLES */

        szFileName = SAlloc( strlen( szTableNew ) + 1 );
        if ( szFileName == NULL )
                {
                Error( JET_errOutOfMemory, HandleError );
                }
        strcpy( szFileName, szTableNew );

        Call( ErrDIRCommitTransaction( ppib ) );

        /*      change in memory name of table, if table in memory structures exist
        /**/
        pfcbFile = PfcbFCBGet( dbid, pgnoFDP );
        Assert( pfcbFile != pfcbNil );
        SFree( pfcbFile->szFileName );
        pfcbFile->szFileName = szFileName;

HandleError:
        /*      remove lock for rename.
        /**/
        if ( fSetRename )
                {
                FCBResetRenameTable( dbid, pgnoFDP );
                }

        /*      free table cursor if allocated
        /**/
        if ( pfucbTable != pfucbNil )
                {
                CallS( ErrFILECloseTable( ppib, pfucbTable ) );
                }

        /*      free cursor if allocated
        /**/
        if ( pfucb != pfucbNil )
                {
                DIRClose( pfucb );
                }

        /*      rollback if fail
        /**/
        if ( err < 0 )
                {
                CallS( ErrDIRRollback( ppib ) );
                }

        return err;
        }


//+api
// ErrFILEIRenameIndexColumn
// ========================================================================
// LOCAL ERR ErrFILEIRenameIndexColumn( ppib, pfucb, szName, szNameNew )
//
//      Renames a column or index.
//
//      seek to old field definition
//      copy old field definition
//      modify field name
//      delete old field definition
//      add new field definition with new key
//      correct system table entry
//      rebuild field RAM structures
//
//      PARAMETERS      ppib                    PIB of user
//                              pfucb                   Exclusively opened FUCB of file
//                              szName                  old name
//                              szNameNew               new name
//                              fRenameType     rename column or index?
//
// RETURNS              JET_errSuccess
//                                      JET_errIndexNotFound
//                                      JET_errColumnNotFound
//                                      JET_errTableNotLocked
//-
LOCAL ERR ErrFILEIRenameIndexColumn(
        PIB                     *ppib,
        FUCB            *pfucb,
        CHAR            *szName,
        CHAR            *szNameNew,
        BYTE            fRenameType )
        {
        ERR                     err;
        ERR                     errNotFound;
        CHAR            szIC[ (JET_cbNameMost + 1) ];
        CHAR            rgbICNorm[ JET_cbKeyMost ];
        CHAR            szICNew[ (JET_cbNameMost + 1) ];
        BYTE            rgbICNewNorm[ JET_cbKeyMost ];
        CHAR            *pchName;
        FCB                     *pfcb;
        KEY                     keyIC;
        KEY                     keyICNew;
        KEY                     *pkey;
        union
                {
                FIELDDEFDATA fdd;
                INDEXDEFDATA idd;
                } defdata;
        BYTE            *pdefdata;
        CHAR            *pDefDataName;
        INT                     itable;
        LINE            lineReplace;
        VERRENAME       verrename;
        BOOL            fKeyDuplicate = fFalse;

        /*      check parameters
        /**/
        CheckPIB( ppib );
        CheckTable( ppib, pfucb );

        Assert ( !FFUCBNonClustered( pfucb ) );
        /*      return error if table is not exclusively locked
        /**/
        pfcb = pfucb->u.pfcb;

        /*      validate, normalize name and set key
        /**/
        CallR( ErrCheckName( szIC, szName, (JET_cbNameMost + 1) ) );
        SysNormText( szIC, strlen( szIC ), rgbICNorm, sizeof( rgbICNorm ), &keyIC.cb );
        keyIC.pb = rgbICNorm;

        /*      validate, normalize new name and set key
        /**/
        CallR( ErrCheckName( szICNew, szNameNew, (JET_cbNameMost + 1) ) );
        SysNormText( szICNew, strlen( szICNew ), rgbICNewNorm, sizeof( rgbICNewNorm ), &keyICNew.cb );
        keyICNew.pb = rgbICNewNorm;

        /*      marshal names for rollback support
        /**/
        strcpy( verrename.szName, szIC );
        strcpy( verrename.szNameNew, szICNew );

        switch( fRenameType )
                {
                case fRenameColumn:
                        pkey = pkeyFields;
                        errNotFound = JET_errColumnNotFound;
                        pdefdata = (BYTE*)&(defdata.fdd);
                        pDefDataName = defdata.fdd.szFieldName;
                        itable = itableSc;
                        break;
                
                default:
                        Assert( fRenameType == fRenameIndex );
                        pkey = pkeyIndexes;
                        errNotFound = JET_errIndexNotFound;
                        pdefdata = (BYTE*)&(defdata.idd);
                        pDefDataName = defdata.idd.szIndexName;
                        itable = itableSi;
                }

        CallR( ErrDIRBeginTransaction( ppib ) );

        /*      move to FDP root
        /**/
        DIRGotoFDPRoot( pfucb );

        Call( ErrFILEIUpdateFDPData( pfucb, fDDLStamp ) )

        /*      down to node name (ie. "FIELDS" or "INDEXES"
        /**/
        Call( ErrDIRSeekPath( pfucb, 1, pkey, 0 ) );

        /*      new name should not exist
        /**/
        err = ErrDIRSeekPath( pfucb, 1, &keyICNew, 0 );
        Assert( err != JET_errNoCurrentRecord );
        if (err < 0 && err != JET_errRecordNotFound)
                goto HandleError;
        Assert( err == JET_errSuccess ||
                        err == errDIRFDP ||
                        err == JET_errRecordNotFound );
        if ( err != JET_errRecordNotFound )
                {
                fKeyDuplicate = fTrue;
                DIRUp( pfucb, 1 );
                }

        /*      name should exist
        /**/
        if ( ( err = ErrDIRSeekPath( pfucb, 1, &keyIC, 0 ) ) < 0 )
                {
                if ( err == JET_errRecordNotFound )
                        err = errNotFound;
                goto HandleError;
                }
        
        /*      if found duplicate earlier then return error here after
        /*      checked for existing index
        /**/
        if ( fKeyDuplicate )
                {
                /*      polymorph success to key duplicate, which in turn will be
                /*      polymorphed to column or index duplicate.
                /**/
                if ( err == JET_errSuccess || err == errDIRFDP )
                        err = JET_errKeyDuplicate;
                goto HandleError;
                }

        /*      get pointer to name in RAM structures
        /**/
        if ( fRenameType == fRenameColumn )
                {
                FIELD   *pfield = PfieldFCBFromColumnName( pfcb, szIC );
                if ( pfield == NULL )
                        {
                        err = JET_errWriteConflict;
                        goto HandleError;
                        }
                pchName = pfield->szFieldName;
                }
        else
                {
                FCB     *pfcbT = PfcbFCBFromIndexName( pfcb, szIC );
                if ( pfcbT == NULL )
                        {
                        err = JET_errWriteConflict;
                        goto HandleError;
                        }
                pchName = pfcbT->pidb->szName;
                }

        /* abort if DDL is being done on table
        /**/
        if ( FFCBDenyDDL( pfcb, ppib ) )
                {
                err = JET_errWriteConflict;
                goto HandleError;
                }
        FCBSetDenyDDL( pfcb, ppib );

        if ( fRenameType == fRenameColumn )
                {
                err = ErrVERFlag( pfucb, operRenameColumn, (BYTE *)&verrename, sizeof(verrename) );
                if ( err < 0 )
                        {
                        FCBResetDenyDDL( pfcb );
                        goto HandleError;
                        }
                }
        else
                {
                Assert( fRenameType == fRenameIndex );
                err = ErrVERFlag( pfucb, operRenameIndex, (BYTE *)&verrename, sizeof(verrename) );
                if ( err < 0 )
                        {
                        FCBResetDenyDDL( pfcb );
                        goto HandleError;
                        }
                }

        /*      change name in RAM structure
        /**/
        strcpy( pchName, szICNew );

        Call( ErrDIRGet( pfucb  ) );
        memcpy( pdefdata, pfucb->lineData.pb, pfucb->lineData.cb );
        strcpy( pDefDataName, szICNew);
        lineReplace.pb = pdefdata;
        lineReplace.cb = pfucb->lineData.cb;    
        Call( ErrDIRReplace( pfucb, &lineReplace, fDIRVersion ) );

        /*      replace with new key
        /**/
        Call( ErrDIRReplaceKey( pfucb, &keyICNew, fDIRVersion ) );

#ifdef  SYSTABLES
        /*      change column name in system table
        /**/
        if ( !( FFCBTemporaryTable( pfcb ) ) )
                {
                Call( ErrSysTabRename( ppib, pfucb->dbid, szICNew, szIC,
                        pfucb->u.pfcb->pgnoFDP, itable ) );
                }
#endif  /* SYSTABLES */

        /*      back up to root
        /**/
        DIRUp( pfucb, 2 );
        DIRBeforeFirst( pfucb );

        Call( ErrDIRCommitTransaction( ppib ) );

        return err;

HandleError:
        CallS( ErrDIRRollback( ppib ) );

        /*      polymorph duplicate error for rename type.
        /**/
        if ( err == JET_errKeyDuplicate )
                {
                switch( fRenameType )
                        {
                case fRenameColumn:
                        err = JET_errColumnDuplicate;
                        break;
                default:
                        Assert( fRenameType == fRenameIndex );
                        err = JET_errIndexDuplicate;
                        }
                }
        return err;
        }


ERR ErrFILERenameObject( PIB *ppib, DBID dbid, OBJID objidParent, char __far *szObjectName, char __far *szObjectNew )
        {
        ERR         err = JET_errSuccess;

        /*      change the object's name.
        /**/
        CallR( ErrDIRBeginTransaction( ppib ) );
        Call( ErrSysTabRename( ppib, dbid, szObjectNew, szObjectName, objidParent, itableSo ) );
        Call( ErrDIRCommitTransaction( ppib ) );
        return err;

HandleError:
        CallS( ErrDIRRollback( ppib ) );
        return err;
        }


ERR VTAPI ErrIsamRenameObject(
        JET_VSESID      vsesid,
        JET_VDBID       vdbid,
        const char __far *szContainerName,
        const char __far *szObjectName,
        const char __far *szObjectNameNew )
        {
        ERR         err;
        PIB                     *ppib = (PIB *)vsesid;
        DBID                    dbid = DbidOfVDbid( vdbid );
        OBJID       objid, objidParent;
        JET_OBJTYP  objtyp;
        CHAR        szContainer[ JET_cbNameMost+1 ];
        CHAR                    szObject[ JET_cbNameMost+1 ];
        CHAR                    szObjectNew[ JET_cbNameMost+1 ];

        /* ensure that database is updatable
        /**/
        CallR( VDbidCheckUpdatable( vdbid ) );

        /*      check names
        /**/
        Call( ErrCheckName( szObject, szObjectName, JET_cbNameMost + 1 ) );
        Call( ErrCheckName( szObjectNew, szObjectNameNew, JET_cbNameMost + 1 ) );

        if ( szContainerName == NULL || *szContainerName == '\0' )
                {
                /*      root objid if no container given
                /**/
                objidParent = objidRoot;
                }
        else
                {
                /*      check container name
                /**/
                Call( ErrCheckName( szContainer, szContainerName, JET_cbNameMost+1 ) );

                /*      get container objid
                /**/
                Call( ErrFindObjidFromIdName( ppib, dbid, objidRoot,
                        szContainer, &objidParent, &objtyp ) );
                if ( objidParent == objidNil || objtyp != JET_objtypContainer )
                        return JET_errObjectNotFound;
                }
                
        Call( ErrFindObjidFromIdName( ppib, dbid, objidParent,
                        szObject, &objid, &objtyp ) );

        /*      special case rename table
        /**/
        if ( objtyp == JET_objtypTable )
                {
                err = ErrIsamRenameTable( ppib, vdbid, szObject, szObjectNew );
                if ( err == JET_errTableDuplicate )
                        err = JET_errObjectDuplicate;
                }
        else
                {
                /*      change the object's name.
                /**/
                err = ErrFILERenameObject( ppib, dbid, objidParent, szObject, szObjectNew );
                }

HandleError:
        return err;
        }


        ERR VTAPI
ErrIsamRenameColumn( PIB *ppib, FUCB *pfucb, CHAR *szName, CHAR *szNameNew )
        {
        ERR     err;

        /* Ensure that table is updatable */
        /**/
        CallR( FUCBCheckUpdatable( pfucb )  );

        err = ErrFILEIRenameIndexColumn( ppib, pfucb, szName, szNameNew, fRenameColumn );
        return err;
        }


        ERR VTAPI
ErrIsamRenameIndex( PIB *ppib, FUCB *pfucb, CHAR *szName, CHAR *szNameNew )
        {
        ERR     err;

        /* Ensure that table is updatable */
        /**/
        CallR( FUCBCheckUpdatable( pfucb )  );

        err = ErrFILEIRenameIndexColumn( ppib, pfucb, szName, szNameNew, fRenameIndex );
        return err;
        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\fldext.c ===
#include "config.h"

#include <stdlib.h>
#include <string.h>
#include <stddef.h>

#include "daedef.h"
#include "pib.h"
#include "page.h"
#include "fmp.h"
#include "ssib.h"
#include "fucb.h"
#include "fcb.h"
#include "stapi.h"
#include "fdb.h"
#include "idb.h"
#include "dirapi.h"
#include "recint.h"
#ifdef ANGEL
#include "utilwin.h"
#else
#include "recapi.h"
#endif

#ifndef ANGEL
DeclAssertFile;					/* Declare file name for assert macros */

LOCAL INLINE ERR ErrRECIRetrieveColumns( FUCB *pfucb, JET_RETRIEVECOLUMN *pretcols, ULONG cretcols );

#endif


//+API
//	ErrRECExtractField
//	========================================================================
//	ErrRECExtractField( FDB *pfdb, LINE *plineRec, FID *pfid, ULONG itagSequence, ULONG *pitagSequence, LINE *plineField)
//
//	Extracts a field from a record.  This amounts to returning a pointer
//	into the record (to where the field data starts) and a count of the
//	number of bytes in the field data.
//
// PARAMETERS	pfdb				field descriptors for this record
//				plineRec			record to extract field from
//				pfid				field id of field to extract
//						  			If this parameter is zero, then the
//						  			tagged fields are scanned without
//						  			regard to their field ids, and occurance
//						  			number "itagSequence" is returned.  This can
//						  			be used to sequentially scan all values in
//						  			the tagged area of the record.	The field
//						  			id of the field value returned is placed
//						  			in *pfid as an output parameter.
//				itagSequence	  	if a tagged field is being extracted,
//								  	this parameter specifies which occurance
//								  	of the tagged field to extract.	 Tagged
//								  	field occurances are number consecutively
//								  	starting with 1.  Occurance numbers greater
//								  	than the maximum occurance in the record
//								  	are returned as NULL-valued fields.
//	 			plineField			Receives extracted field.  plineField->pb
//								  	will point into the record, at the start
//								  	of the field.  plineField->cb will be set
//								  	to the length of the field data.
//								  	If the field requested contains a NULL
//								  	value, then plineField->pb will be set to
//								  	NULL and plineField->cb will be set to 0.
//								  	Additionally, JET_wrnColumnNull would be returned
//	RETURNS	
//		JET_errSuccess			 	Everything worked.
//		JET_errColumnInvalid	 	The field id given does not
//	 	   						 	correspond to a defined field.
//		JET_wrnColumnNull 			Extracted column has null value
//-
ERR ErrRECExtractField(
	FDB		*pfdb,
	LINE  	*plineRec,
	FID		*pfid,
	ULONG 	*pitagSequence,
	ULONG 	itagSequence,
	LINE  	*plineField )
	{
	FID	  	fid;			 		// field to extract
	ULONG 	ulNumOccurances;		// counts field occurances

	/* the following field used only when *pfid is 0
	/**/
	FID				fidCur;					// field to return
	ULONG			ulNumCurOccurances=0;	// returned field occurances count

	BYTE			*pbRec;					// efficiency var: ptr to record data
	FID				fidFixedLastInRec;		// highest fixed fid actually in record
	FID				fidVarLastInRec;		// highest var fid actually in record
	UNALIGNED WORD	*pibVarOffs;			// pointer to var field offsets
	BYTE			*pbRecMax;				// end of current data record
	TAGFLD			*ptagfld;				// pointer to tagged field

	/*** Efficiency variables ***/
	Assert( pfid != NULL );
	fid = *pfid;
	Assert( pfdb != pfdbNil );
	Assert( !FLineNull( plineRec ) );
	Assert( plineRec->cb >= 4 );
	pbRec = plineRec->pb;
	Assert( plineField != NULL );
	fidFixedLastInRec = ((RECHDR*)pbRec)->fidFixedLastInRec;
	Assert( fidFixedLastInRec <= fidFixedMost );

	/*** ---------EXTRACTING FIXED FIELD-------- ***/
	if ( FFixedFid( fid ) )
		{
		BYTE *prgbitNullity;		// pointer to fixed field bitmap
		WORD *pibFixOffs;			// fixed field offsets

		if ( fid > pfdb->fidFixedLast )
			return JET_errColumnNotFound;
		if ( pfdb->pfieldFixed[fid-fidFixedLeast].coltyp == JET_coltypNil )
			return JET_errColumnNotFound;

		/*** Field not represented in record:  field is NULL ***/
		if ( fid > fidFixedLastInRec )
			goto NullField;

		/*** Adjust fid to an index ***/
		fid -= fidFixedLeast;

		/*** Byte containing bit representing fid's nullity ***/
		pibFixOffs = pfdb->pibFixedOffsets;
		prgbitNullity = pbRec + pibFixOffs[fidFixedLastInRec] + fid/8;

		/*** Bit is not set: field is NULL ***/
		if (!(*prgbitNullity & (1 << fid % 8))) goto NullField;

		/*** Set output parameter to length and address of field ***/
		plineField->cb = pibFixOffs[fid+1] - pibFixOffs[fid];
		plineField->pb = pbRec + pibFixOffs[fid];
		return JET_errSuccess;
		}

	/*** More efficiency variables ***/
	fidVarLastInRec = ((RECHDR*)pbRec)->fidVarLastInRec;
	pibVarOffs = (WORD *)(pbRec + pfdb->pibFixedOffsets[fidFixedLastInRec] +
		(fidFixedLastInRec + 7) / 8);
	Assert(pibVarOffs[fidVarLastInRec+1-fidVarLeast] <= plineRec->cb);

	/*** ---------EXTRACTING VARIABLE FIELD-------- ***/
	if ( FVarFid( fid ) )
		{
		if (fid > pfdb->fidVarLast)
			return JET_errColumnNotFound;
		if (pfdb->pfieldVar[fid-fidVarLeast].coltyp == JET_coltypNil)
			return JET_errColumnNotFound;

		/*** Field not represented in record: field is NULL ***/
		if (fid > fidVarLastInRec )
			goto NullField;

		/*** Adjust fid to an index ***/
		fid -= fidVarLeast;

		/*** Set output parameter: field length ***/
		plineField->cb = ibVarOffset( pibVarOffs[fid+1] ) - ibVarOffset( pibVarOffs[fid] );
		Assert(plineField->cb <= plineRec->cb);

		/*** Field is set to Null ***/
		if ( FVarNullBit( pibVarOffs[fid] ) )
			{
			Assert( plineField->cb == 0 );
			goto NullField;
			}

		/*** Length is zero: return success [zero-length non-null values are allowed] ***/
		if (plineField->cb == 0)
			{
			plineField->pb = NULL;
			return JET_errSuccess;
			}

		/*** Set output parameter: field address ***/
		plineField->pb = pbRec + ibVarOffset( pibVarOffs[fid] );
		Assert(plineField->pb >= pbRec && plineField->pb <= pbRec+plineRec->cb);
		return JET_errSuccess;
		}

	/*** ---------EXTRACTING TAGGED FIELD-------- ***/

	/*	for the first occurrence, itagSequence must be 1, not 0
	/**/
	if ( itagSequence == 0 )
		return JET_errBadItagSequence;

	if (fid > pfdb->fidTaggedLast)
		return JET_errColumnNotFound;

	Assert(FTaggedFid(fid) || fid == 0);

	if (fid != 0 &&
		pfdb->pfieldTagged[fid - fidTaggedLeast].coltyp == JET_coltypNil)
		return JET_errColumnNotFound;

	/*** Scan tagged fields, counting occurances of desired field ***/
	pbRecMax = pbRec + plineRec->cb;
	ptagfld = (TAGFLD*)(pbRec + ibVarOffset( pibVarOffs[fidVarLastInRec+1-fidVarLeast] ) );
	ulNumOccurances = 0;
	fidCur = 0;
	while ( (BYTE*)ptagfld < pbRecMax )
		{
		if ( fid == 0 )
			{
			/*  if we are scanning the whole tag fields, count proper
			 *  occurrence of current fid.
			 */
			if ( fidCur == ptagfld->fid )
				ulNumCurOccurances++;
			else
				{
				fidCur = ptagfld->fid;
				ulNumCurOccurances = 1;
				}

			/* set possible returned values
			/**/
			*pfid = fidCur;
			*pitagSequence = ulNumCurOccurances;
			}

		if ( fid == 0 || ptagfld->fid == fid )
			{
			if ( ++ulNumOccurances == itagSequence )
				{
				BOOL	fLongField;

				plineField->cb = ptagfld->cb;
				plineField->pb = ptagfld->rgb;

				fLongField = pfdb->pfieldTagged[*pfid - fidTaggedLeast].coltyp == JET_coltypLongText ||
					pfdb->pfieldTagged[*pfid - fidTaggedLeast].coltyp == JET_coltypLongBinary;

				return fLongField ? wrnRECLongField : JET_errSuccess;
				}
			}
		ptagfld = (TAGFLD*)((BYTE*)(ptagfld+1) + ptagfld->cb);
		Assert((BYTE*)ptagfld <= pbRecMax);
		}

	/*** Occurance not found: field is NULL, fall through ***/

NullField:
	/*** Null Field common exit point ***/
	plineField->cb = 0;
	plineField->pb = NULL;
	return JET_wrnColumnNull;
	}


#ifndef ANGEL
/*	counts number of columns for a given column id in a given record.
/**/
ERR ErrRECCountColumn( FUCB *pfucb, FID fid, INT *pccolumn, JET_GRBIT grbit )
	{
	ERR					err = JET_errSuccess;
	LINE					lineRec;
	FDB					*pfdb = (FDB *)pfucb->u.pfcb->pfdb;
	INT					ccolumn = 0;
	BYTE					*pbRec;						// efficiency var: ptr to record data
	FID					fidFixedLastInRec;		// highest fixed fid actually in record
	FID					fidVarLastInRec;			// highest var fid actually in record
	UNALIGNED WORD		*pibVarOffs;				// pointer to var field offsets
	BYTE					*pbRecMax;					// end of current data record
	TAGFLD				*ptagfld;					// pointer to tagged field

	Assert( pfdb != pfdbNil );

	/*	get record
	/**/
	if ( ( grbit & JET_bitRetrieveCopy ) && FFUCBRetPrepared( pfucb ) )
		{
		/*	only index cursors have copy buffers.
		/**/
		Assert( FFUCBIndex( pfucb ) );
		lineRec = pfucb->lineWorkBuf;
		}
	else
		{
		if ( FFUCBIndex( pfucb ) )
			{
			CallR( ErrDIRGet( pfucb ) );
			}
		else
			{
			Assert( PcsrCurrent( pfucb )->csrstat == csrstatOnCurNode ||
				PcsrCurrent( pfucb )->csrstat == csrstatBeforeFirst ||
				PcsrCurrent( pfucb )->csrstat == csrstatAfterLast );
			if ( PcsrCurrent( pfucb )->csrstat != csrstatOnCurNode )
				return JET_errNoCurrentRecord;
			Assert( pfucb->lineData.cb != 0 || FFUCBIndex( pfucb ) );
			}
		lineRec = pfucb->lineData;
		}
	Assert( lineRec.cb >= 4 );
	pbRec = lineRec.pb;
	fidFixedLastInRec = ((RECHDR *)pbRec)->fidFixedLastInRec;
	Assert( fidFixedLastInRec <= fidFixedMost );

	/*** ---------EXTRACTING FIXED FIELD-------- ***/
	if ( FFixedFid( fid ) )
		{
		BYTE *prgbitNullity;		// pointer to fixed field bitmap
		WORD *pibFixOffs;			// fixed field offsets

		if ( fid > pfdb->fidFixedLast )
			return JET_errColumnNotFound;
		if ( pfdb->pfieldFixed[fid-fidFixedLeast].coltyp == JET_coltypNil )
			return JET_errColumnNotFound;

		/*	column is NULL
		/**/
		if ( fid > fidFixedLastInRec )
			goto NullField;

		/*	adjust fid to index
		/**/
		fid -= fidFixedLeast;

		/*	byte containing bit representing fid's nullity
		/**/
		pibFixOffs = pfdb->pibFixedOffsets;
		prgbitNullity = pbRec + pibFixOffs[fidFixedLastInRec] + fid/8;

		/*	column is NULL
		/**/
		if ( !( *prgbitNullity & ( 1 << fid % 8 ) ) )
			goto NullField;

		*pccolumn = 1;
		return JET_errSuccess;
		}

	/*** More efficiency variables ***/
	fidVarLastInRec = ((RECHDR*)pbRec)->fidVarLastInRec;
	pibVarOffs = (WORD *)(pbRec + pfdb->pibFixedOffsets[fidFixedLastInRec] +
		(fidFixedLastInRec + 7) / 8);
	Assert(pibVarOffs[fidVarLastInRec+1-fidVarLeast] <= lineRec.cb);

	/*** ---------EXTRACTING VARIABLE FIELD-------- ***/
	if ( FVarFid( fid ) )
		{
		if ( fid > pfdb->fidVarLast )
			return JET_errColumnNotFound;
		if ( pfdb->pfieldVar[fid-fidVarLeast].coltyp == JET_coltypNil )
			return JET_errColumnNotFound;

		/*	column is NULL
		/**/
		if ( fid > fidVarLastInRec )
			goto NullField;

		/*	adjust fid to an index
		/**/
		fid -= fidVarLeast;

		/*	column is set to Null
		/**/
		if ( FVarNullBit( pibVarOffs[fid] ) )
			{
			goto NullField;
			}

		*pccolumn = 1;
		return JET_errSuccess;
		}

	/*** ---------EXTRACTING TAGGED FIELD-------- ***/
	if ( fid > pfdb->fidTaggedLast )
		return JET_errColumnNotFound;
	Assert( FTaggedFid( fid ) || fid == 0 );
	if ( fid != 0 && pfdb->pfieldTagged[fid - fidTaggedLeast].coltyp == JET_coltypNil )
		return JET_errColumnNotFound;

	/* scan tagged fields, counting occurances of desired field
	/**/
	pbRecMax = pbRec + lineRec.cb;
	ptagfld = (TAGFLD*)(pbRec + ibVarOffset( pibVarOffs[fidVarLastInRec+1-fidVarLeast] ) );
	while ( (BYTE*)ptagfld < pbRecMax )
		{
		if ( fid == 0 || ptagfld->fid == fid )
			{
			++ccolumn;
			}
		ptagfld = (TAGFLD*)((BYTE*)(ptagfld+1) + ptagfld->cb);
		Assert((BYTE*)ptagfld <= pbRecMax);
		}

NullField:
	*pccolumn = ccolumn;
	return JET_errSuccess;
	}


/*	checks if field at lSeqNum is a separated long value
/*	if yes, returns fSeparated = fTrue and lid of LV.
/**/
ERR ErrRECExtrinsicLong(
	JET_VTID	tableid,
	ULONG		itagSequence,
	BOOL		*pfSeparated,
	LONG		*plid,
	ULONG		*plrefcnt,
	ULONG		grbit )
	{
	ERR 		err;
	FID		fid = 0;
	LINE		lineField;

	CallR( ErrRECIRetrieve( (FUCB *)tableid, &fid, itagSequence, &lineField, grbit ) );
	if ( err != wrnRECLongField )
		{
		*pfSeparated = fFalse;
		}
	else
		{
		*pfSeparated = ( (LV *) lineField.pb )->fSeparated;
		if ( *pfSeparated )
			{
			Assert( lineField.cb == sizeof(LV) );
			*plid = ( (LV *) lineField.pb )->lid;
			}
		}

// UNDONE: returning ref count
	return JET_errSuccess;
	}


ERR ErrRECIRetrieve( FUCB *pfucb, FID *pfid, ULONG itagSequence, LINE *plineField, ULONG grbit )
	{
	ERR		err;
	FDB		*pfdb;
	ULONG		itagSequenceT;

	/*	set pfdb.  pfdb is same for indexes and for sorts.
	/**/
	Assert( pfucb->u.pfcb->pfdb == ((FCB*)pfucb->u.pscb)->pfdb );
	pfdb = (FDB *)pfucb->u.pfcb->pfdb;
	Assert( pfdb != pfdbNil );

	/*	if retrieving from copy buffer.
	/**/
	if ( ( grbit & JET_bitRetrieveCopy ) && FFUCBRetPrepared( pfucb ) )
		{
		/*	only index cursors have copy buffers.
		/**/
		Assert( FFUCBIndex( pfucb ) );

		err = ErrRECExtractField(
			pfdb,
			&pfucb->lineWorkBuf,
			pfid,
			&itagSequenceT,
			itagSequence,
			plineField );
		return err;
		}

	/*	get current data for index cursors.  Sorts always have
	/*	current data cached.
	/**/
	if ( FFUCBIndex( pfucb ) )
		{
		CallR( ErrDIRGet( pfucb ) );
		}
	else
		{
		Assert( PcsrCurrent( pfucb )->csrstat == csrstatOnCurNode ||
			PcsrCurrent( pfucb )->csrstat == csrstatBeforeFirst ||
			PcsrCurrent( pfucb )->csrstat == csrstatAfterLast );
		if ( PcsrCurrent( pfucb )->csrstat != csrstatOnCurNode )
			return JET_errNoCurrentRecord;
		Assert( pfucb->lineData.cb != 0 || FFUCBIndex( pfucb ) );
		}

	err = ErrRECExtractField( pfdb, &pfucb->lineData, pfid, &itagSequenceT, itagSequence, plineField );
	return err;
	}


ERR ErrRECIRetrieveFromIndex( FUCB *pfucb,
	FID 			fid,
	ULONG			*pitagSequence,
	BYTE			*pb,
	ULONG			cbMax,
	ULONG			*pcbActual,
	ULONG			ibGraphic,
	JET_GRBIT	grbit )
	{
	ERR		err;
	FUCB		*pfucbIdx = pfucb->pfucbCurIndex;
	FDB		*pfdb = (FDB *)pfucb->u.pfcb->pfdb;
	IDB		*pidb;
	BOOL		fText = fFalse;
	BOOL		fTagged = fFalse;
	BOOL		fLongValue = fFalse;
	BOOL		fUnicode = fFalse;
	INT		iidxseg;
	LINE		rglineColumns[JET_ccolKeyMost];
	BYTE		rgb[JET_cbKeyMost];
	ULONG		cbReturned;
	KEY		key;
	INT		itagSequence;

	/*	if on clustered index, then return code indicating that
	/*	retrieve should be from record.  Note, sequential files
	/*	having no indexes, will be natually handled this way.
	/**/
	if ( pfucbIdx == pfucbNil )
		{
		/*	the itagSequence should not be important since
		/*	clustered indexes are not allowed over multi-value
		/*	columns.
		/**/
	  	return errDIRNoShortCircuit;
		}

	/*	determine column type so that long value warning can be returned.
	/*	this warning is used by the caller to support byte range
	/*	retrieval. Also, if coltype is Unicode, retrieve from Record only
	/**/
	if ( FFixedFid( fid ) )
		{
		fUnicode = ( pfdb->pfieldFixed[fid - fidFixedLeast].cp == usUniCodePage );
		fText = ( pfdb->pfieldFixed[fid - fidFixedLeast].coltyp == JET_coltypText );
		}
	else if ( FVarFid( fid ) )
		{
		fUnicode = ( pfdb->pfieldVar[fid - fidVarLeast].cp == usUniCodePage );
		fText = ( pfdb->pfieldVar[fid - fidVarLeast].coltyp == JET_coltypText );
		}
	else
		{
		fTagged = fTrue;
		fUnicode = ( pfdb->pfieldTagged[fid - fidTaggedLeast].cp == usUniCodePage );
		fLongValue = pfdb->pfieldTagged[fid - fidTaggedLeast].coltyp == JET_coltypLongText ||
	 		pfdb->pfieldTagged[fid - fidTaggedLeast].coltyp == JET_coltypLongBinary;
		fText = ( pfdb->pfieldTagged[fid - fidTaggedLeast].coltyp == JET_coltypLongText );
		}

	/*	check for valid currency
	/**/
	Call( ErrDIRGet( pfucbIdx ) );

	/*	find index segment for given column id
	/**/
	pidb = pfucbIdx->u.pfcb->pidb;
	for ( iidxseg = 0; iidxseg <= JET_ccolKeyMost; iidxseg++ )
		{
		if ( pidb->rgidxseg[iidxseg] == fid ||
			pidb->rgidxseg[iidxseg] == -fid )
			{
			break;
			}
		}
	if ( iidxseg > JET_ccolKeyMost )
		return JET_errColumnNotFound;

	/*	if key may have been truncated, then return code indicating
	/*	that retrieve should be from record.
	/**/
	if ( pfucbIdx->keyNode.cb == JET_cbKeyMost )
		{
		err = errDIRNoShortCircuit;
		goto ComputeItag;
		}

#ifndef NJETNT
	/*	retrieval from index returns caseless information
	/*	for text and long text.  If JET_bitRetrieveCase is
	/*	given then retrieve from record.
	/**/
	if ( fText && grbit & JET_bitRetrieveCase )
		{
		err = errDIRNoShortCircuit;
		goto ComputeItag;
		}
#endif

	if ( fUnicode )
		{
		err = errDIRNoShortCircuit;
		goto ComputeItag;
		}

	//	UNDONE:	only denormalize the column to be retrieved
	//	UNDONE:	NULL support
	/*	initialize column array
	/**/
	memset( rglineColumns, '\0', sizeof( rglineColumns ) );
	rglineColumns[0].pb = rgb;
	Call( ErrRECDenormalizeKey( pfdb, pidb, &pfucbIdx->keyNode, rglineColumns ) );

	/*	column may not have been in key, even though key lenght is less than
	/*	JET_cbKeyMost, so if NULL, then no short circuit.
	/**/
	if ( rglineColumns[iidxseg].pb == NULL )
		{
		err = errDIRNoShortCircuit;
		goto ComputeItag;
		}

	/*	first character is bogus
	/**/
	rglineColumns[0].pb += 1;
	rglineColumns[0].cb -= 1;

	/*	if long value then effect offset
	/**/
	if ( fLongValue )
		{
		if ( pcbActual )
			{
			if ( ibGraphic >= rglineColumns[iidxseg].cb  )
				*pcbActual = 0;
			else
				*pcbActual = rglineColumns[iidxseg].cb - ibGraphic;
			}
		if ( rglineColumns[iidxseg].cb == 0 )
			{
			Assert( err == JET_errSuccess || err == JET_wrnColumnNull );
			goto ComputeItag;
			}
		if ( ibGraphic >= rglineColumns[iidxseg].cb )
			{
//			rglineColumns[iidxseg].pb = NULL;
			rglineColumns[iidxseg].cb = 0;
			}
		else
			{
			rglineColumns[iidxseg].pb += ibGraphic;
			rglineColumns[iidxseg].cb -= ibGraphic;
			}
		}

	/*	set return values
	/**/
	if ( pcbActual )
		*pcbActual = rglineColumns[iidxseg].cb;
	if ( rglineColumns[iidxseg].cb == 0 )
		{
		Assert( err == JET_errSuccess || err == JET_wrnColumnNull );
		goto ComputeItag;
		}
	if ( rglineColumns[iidxseg].cb <= cbMax )
		{
		cbReturned = rglineColumns[iidxseg].cb;
		Assert( err == JET_errSuccess );
		}
	else
		{
		cbReturned = cbMax;
		err = JET_wrnBufferTruncated;
		}
	memcpy( pb, rglineColumns[iidxseg].pb, (size_t)cbReturned );

ComputeItag:
	if ( err == errDIRNoShortCircuit || ( grbit & JET_bitRetrieveTag ) )
		{
		ERR errT = err;

		/*	extract keys from record and compare against current key
		/*	to compute itag for tagged column instance, responsible for
		/*	this index key.
		/**/
		Assert( fTagged || *pitagSequence == 1 );
		if ( fTagged )
			{
			key.pb = rgb;

			for ( itagSequence = 1; ;itagSequence++ )
				{
				/*	get record for key extraction
				/**/
				Call( ErrDIRGet( pfucb ) );
				Call( ErrRECExtractKey( pfucb, pfdb, pidb, &pfucb->lineData, &key, itagSequence ) );
				if ( memcmp( pfucbIdx->keyNode.pb, key.pb, min( pfucbIdx->keyNode.cb, key.cb ) ) == 0 )
					break;
				}
			err = errDIRNoShortCircuit;
			*pitagSequence = itagSequence;
			}
		err = errT;
		}

HandleError:
	return err;
	}


ERR VTAPI ErrIsamRetrieveColumn(
	PIB	 			*ppib,
	FUCB				*pfucb,
	JET_COLUMNID	columnid,
	BYTE				*pb,
	ULONG				cbMax,
	ULONG				*pcbActual,
	JET_GRBIT		grbit,
	JET_RETINFO		*pretinfo )
	{
	ERR			err;
	LINE			line;
	FID			fid = (FID)columnid;
	ULONG			itagSequence;
	ULONG			ibGraphic;
	ULONG			cbReturned;

	CheckPIB( ppib );
	CheckFUCB( ppib, pfucb );

#ifdef JETSER
	if ( grbit == JET_bitRetrieveRecord )
		{
		err = ErrIsamRetrieveRecords(	ppib, pfucb, pb, cbMax, pcbActual, pretinfo->itagSequence );
		return err;
		}
	if ( grbit == JET_bitRetrieveFDB )
		{
		err = ErrIsamRetrieveFDB( ppib, pfucb, pb, cbMax, pcbActual, pretinfo->ibLongValue );
		return err;
		}
	if ( grbit == JET_bitRetrieveBookmarks )
		{
		err = ErrIsamRetrieveBookmarks( ppib, pfucb, pb, cbMax, pcbActual );
		return err;
		}
#endif

	if ( pretinfo != NULL )
		{
		if ( pretinfo->cbStruct < sizeof(JET_RETINFO) )
			return JET_errInvalidParameter;
		itagSequence = pretinfo->itagSequence;
		ibGraphic = pretinfo->ibLongValue;
		}
	else
		{
		itagSequence = 1;
		ibGraphic = 0;
		}

	if ( grbit & JET_bitRetrieveFromIndex )
		{
		err = ErrRECIRetrieveFromIndex( pfucb, fid, &itagSequence, pb, cbMax, pcbActual, ibGraphic, grbit );
		/*	return itagSequence if requested
		/**/
		if ( pretinfo != NULL && ( grbit & JET_bitRetrieveTag ) )
			{
			pretinfo->itagSequence = itagSequence;			
			}
		if ( err != errDIRNoShortCircuit )
			{
			return err;
		 	}
		}

	CallR( ErrRECIRetrieve( pfucb, &fid, itagSequence, &line, grbit ) );

	if ( err == wrnRECLongField )
		{
		/*	use line.cb to determine if long field
		/*	is intrinsic or separated
		/**/
		if ( line.cb >= sizeof(LV) && FFieldIsSLong( line.pb ) )
			{
			ULONG		cbActual;

			Assert( line.cb == sizeof( LV ) );

			CallR( ErrRECRetrieveSLongField( pfucb,
				LidOfLV( line.pb ),
				ibGraphic,
				pb,
				cbMax,
		  		&cbActual ) );

			/*	set return values
			/**/
			if ( pretinfo != NULL )
				pretinfo->columnidNextTagged = fid;
			if ( pcbActual )
				*pcbActual = cbActual;
			return cbMax < cbActual ? JET_wrnBufferTruncated : JET_errSuccess;
			}
		else
			{
			/* adjust line to intrinsic long field
			/**/
			line.pb += offsetof( LV, rgb );
			line.cb -= offsetof( LV, rgb );
			if ( pcbActual )
				{
				if ( ibGraphic >= line.cb  )
					*pcbActual = 0;
				else
					*pcbActual = line.cb - ibGraphic;
				}
			if ( ibGraphic >= line.cb )
				{
//				line.pb = NULL;
				line.cb = 0;
				}
			else
				{
				line.pb += ibGraphic;
				line.cb -= ibGraphic;
				}

			/*	change err to JET_errSuccess
			/**/
			Assert( err == wrnRECLongField );
			err = JET_errSuccess;
			}
		}

	/*** Set return values ***/
	if ( pcbActual )
		*pcbActual = line.cb;
	if ( pretinfo != NULL )
		pretinfo->columnidNextTagged = fid;
	if ( line.cb <= cbMax )
		{
		cbReturned = line.cb;
		}
	else
		{
		cbReturned = cbMax;
		err = JET_wrnBufferTruncated;
		}
	memcpy( pb, line.pb, (size_t)cbReturned );
	return err;
	}


/* This routine is mainly for reducing the number of calls to DIRGet
/*	while extracting many columns from the same record
/* retrieves many columns from a record and returns value in pretcol
/* pcolinfo is used for passing intermediate info
/**/
	LOCAL INLINE ERR
ErrRECIRetrieveColumns( FUCB *pfucb, JET_RETRIEVECOLUMN *pretcol, ULONG cretcol )
	{
	ERR						err;
	ULONG						cbReturned;
	BOOL						fBufferTruncated = fFalse;
	JET_RETRIEVECOLUMN	*pretcolMax = pretcol + cretcol;
	JET_RETRIEVECOLUMN	*pretcolT;

	/*	set pfdb, pfdb is same for indexes and for sorts
	/**/
	Assert( pfucb->u.pfcb->pfdb == ((FCB*)pfucb->u.pscb)->pfdb );
	Assert( pfucb->u.pfcb->pfdb != pfdbNil );

	/*	get current data for index cursors,
	/*	sorts always have current data cached.
	/**/
	if ( FFUCBIndex( pfucb ) )
		{
		CallR( ErrDIRGet( pfucb ) );
		}
	else
		{
		Assert( PcsrCurrent( pfucb )->csrstat == csrstatOnCurNode ||
			PcsrCurrent( pfucb )->csrstat == csrstatBeforeFirst ||
			PcsrCurrent( pfucb )->csrstat == csrstatAfterLast );
		if ( PcsrCurrent( pfucb )->csrstat != csrstatOnCurNode )
			return JET_errNoCurrentRecord;
		Assert( pfucb->lineData.cb != 0 || FFUCBIndex( pfucb ) );
		}

	for ( pretcolT = pretcol; pretcolT < pretcolMax; pretcolT++ )
		{
		/* efficiency variables
		/**/
		FID		fid;
		ULONG	  	cbMax;
		ULONG		ibLongValue;
		ULONG		ulT;
		LINE 	  	line;

		/*	those columns needing retrieval will have error set
		/*	to JET_errNullInvalid.  Any other value indicates column
		/*	has already been retrieved from index or copy buffer or as count.
		/**/
		if ( pretcolT->err != JET_errNullInvalid )
			continue;

		/*	set efficiency variables
		/**/
		fid = (FID)pretcolT->columnid;
		cbMax = pretcolT->cbData;
		ibLongValue = pretcolT->ibLongValue;

		CallR( ErrRECExtractField( (FDB *)pfucb->u.pfcb->pfdb,
			&pfucb->lineData,
			&fid,
			&ulT,
			pretcolT->itagSequence,
			&line ) );

		if ( err == wrnRECLongField )
			{
			/*	use line.cb to determine if long field
			/*	is intrinsic or separated
			/**/
			if ( FFieldIsSLong( line.pb ) )
				{
				Assert( line.cb == sizeof( LV ) );

				CallR( ErrRECRetrieveSLongField( pfucb,
					LidOfLV( line.pb ),
					ibLongValue,
					pretcolT->pvData,
					cbMax,
				  	&pretcolT->cbActual ) );

				/*	set return values
				/**/
				if ( err != JET_wrnColumnNull )
					err = JET_errSuccess;
				pretcolT->err = err;
			  	pretcolT->columnidNextTagged = (JET_COLUMNID)fid;

 				/*	must recache record if may have given up critical section
				/**/
				if ( FFUCBIndex( pfucb ) )
					{
					CallR( ErrDIRGet( pfucb ) );
					}

 				continue;
				}
			else
				{
				/* adjust line to intrinsic long field
				/**/
				line.pb += offsetof( LV, rgb );
				line.cb -= offsetof( LV, rgb );

				pretcolT->cbActual = ( ibLongValue >= line.cb  ) ? 0 : line.cb - ibLongValue;

				if ( ibLongValue >= line.cb )
					{
					line.cb = 0;
					}
				else
					{
					line.pb += ibLongValue;
					line.cb -= ibLongValue;
					}
				}
			}
		else
			{
			/*	set cbActual
			/**/
			pretcolT->cbActual = line.cb;
			}

		/*	set return values
		/**/
		pretcolT->columnidNextTagged = (JET_COLUMNID)fid;

		if ( err == JET_wrnColumnNull )
			{
			pretcolT->err = err;
			continue;
			}

		if ( line.cb <= cbMax )
			{
			pretcolT->err = JET_errSuccess;
			cbReturned = line.cb;
			}
		else
			{
			pretcolT->err = JET_wrnBufferTruncated;
			cbReturned = cbMax;
			fBufferTruncated = fTrue;
			}

		memcpy( pretcolT->pvData, line.pb, (size_t)cbReturned );
		}

	return fBufferTruncated ? JET_wrnBufferTruncated : JET_errSuccess;
	}


ERR VTAPI ErrIsamRetrieveColumns(
	PIB			  			*ppib,
	FUCB						*pfucb,
	JET_RETRIEVECOLUMN	*pretcol,
	ULONG						cretcol )
	{
	ERR					  	err = JET_errSuccess;
	ERR					  	wrn = JET_errSuccess;
	BOOL						fRetrieveFromRecord = fFalse;
	JET_RETRIEVECOLUMN	*pretcolT;
	JET_RETRIEVECOLUMN	*pretcolMax = pretcol + cretcol;

	CheckPIB( ppib );
	CheckFUCB( ppib, pfucb );

	for ( pretcolT = pretcol; pretcolT < pretcolMax; pretcolT++ )
		{
		/*	if itagSequence is 0 then count columns instead of retrieving.
		/**/
		if ( pretcolT->itagSequence == 0 )
			{
			Call( ErrRECCountColumn( pfucb,
				(FID)pretcolT->columnid,
				&pretcolT->itagSequence,
				pretcolT->grbit ) );

			Assert( err != JET_errNullInvalid );
			pretcolT->cbActual = 0;
			pretcolT->columnidNextTagged = pretcolT->columnid;
			Assert( err != JET_wrnBufferTruncated );
			pretcolT->err = err;
			continue;
			}

		/* try to retrieve from index; if no short circuit, RECIRetrieveMany
		/* will take retrieve record
		/**/
		if ( pretcolT->grbit & JET_bitRetrieveFromIndex )
			{
			err = ErrRECIRetrieveFromIndex(
				pfucb,
				(FID)pretcolT->columnid,
				&pretcolT->itagSequence,
				(BYTE *)pretcolT->pvData,
				pretcolT->cbData,
				&(pretcolT->cbActual),
				pretcolT->ibLongValue,
				pretcolT->grbit );
			if ( err != errDIRNoShortCircuit )
				{
				if ( err < 0 )
					goto HandleError;
				else
					{
					pretcolT->columnidNextTagged = pretcolT->columnid;
					Assert( err != JET_errNullInvalid );
					pretcolT->err = err;
					if ( err == JET_wrnBufferTruncated )
						wrn = err;
					continue;
					}
				}
			}

		/* if retrieving from copy buffer.
		/**/
		if ( pretcolT->grbit & JET_bitRetrieveCopy )
			{
			JET_RETINFO	retinfo;

			retinfo.cbStruct = sizeof(retinfo);
			retinfo.itagSequence = pretcolT->itagSequence;
			retinfo.ibLongValue = pretcolT->ibLongValue;

			Call( ErrIsamRetrieveColumn( ppib,
				pfucb,
				pretcolT->columnid,
				pretcolT->pvData,
				pretcolT->cbData,
				&pretcolT->cbActual,
				pretcolT->grbit,
				&retinfo ) );

			pretcolT->columnidNextTagged = retinfo.columnidNextTagged;
			Assert( err != JET_errNullInvalid );
			pretcolT->err = err;
			if ( err == JET_wrnBufferTruncated )
				wrn = err;
			continue;
			}

		fRetrieveFromRecord = fTrue;
		pretcolT->err = JET_errNullInvalid;
		}

	/* retrieve columns with no short circuit
	/**/
	if ( fRetrieveFromRecord )
		{
		Call( ErrRECIRetrieveColumns( pfucb, pretcol, cretcol ) );
		if ( err == JET_wrnBufferTruncated )
			wrn = err;
		}

HandleError:
		return ( ( err < 0 ) ? err : wrn );
		}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\gmem.c ===
#include "config.h"

#include <string.h>

#include "daedef.h"
#include "util.h"
#include "ssib.h"
#include "pib.h"
#include "page.h"
#include "fucb.h"
#include "fcb.h"
#include "stapi.h"
#include "idb.h"
#include "scb.h"


DeclAssertFile;					/* Declare file name for assert macros */


SgSemDefine( semMem );

#ifdef DEBUG

typedef struct RS {
	int	cresAlloc;
	int	cresAllocMax;
} RS;

static RS rgrs[iresMax];

#ifdef MEM_CHECK
#if 0
VOID MEMCheckFound( INT ires )
	{
	INT	ifcb;

	for ( ifcb = 0; ifcb < rgres[iresFCB].cblockAlloc; ifcb++ )
		{
		FCB	*pfcb = (FCB *)rgres[iresFCB].pbAlloc + ifcb;
		FCB	*pfcbT;
		BOOL	fFound = fFalse;

		for( pfcbT = (FCB *)rgres[iresFCB].pbAvail;
			pfcbT != NULL;
			pfcbT = *(FCB **)pfcbT )
			{
			if ( pfcbT == pfcb )
				{
				fFound = fTrue;
				break;
				}
			}
		Assert( fFound );
		}
	}

		
CblockMEMCount( INT ires )
	{
	INT	ipb;
	BYTE	*pb;

	for( pb = rgres[ires].pbAvail, ipb = 0;
		pb != NULL;
		pb = *( BYTE**)pb, ipb++ );
	return ipb;
	}
#endif


VOID MEMCheck( VOID )
	{
	int	ires;

	for ( ires = 0; ires < iresLinkedMax; ires++ )
		{
		Assert( rgres[ires].iblockCommit == rgres[ires].cblockAvail );
		}
	}
#endif


VOID MEMStat( int ires, BOOL fAlloc )
	{
	Assert( ires < iresMax );

	if ( fAlloc )
		{
		rgrs[ires].cresAlloc++;
		if ( rgrs[ires].cresAlloc > rgrs[ires].cresAllocMax )
			{
			rgrs[ires].cresAllocMax = rgrs[ires].cresAlloc;
			}
		}
	else
		{
		rgrs[ires].cresAlloc--;
		}
	}


VOID MEMPrintStat( VOID )
	{
	int	ires;

	if ( GetEnv2( szVerbose ) != NULL )
		{
		for ( ires = 0; ires < iresMax; ires++ )
			{
			PrintF( "%d resource %d allocated %d peak allocation.\n",
				ires, rgrs[ires].cresAlloc, rgrs[ires].cresAllocMax );
			}
		}
	}


#endif /* DEBUG */


ERR ErrMEMInit( VOID )
	{
	ERR		err = JET_errSuccess;
	INT		ires;

	#ifdef DEBUG
		memset( rgrs, '\0', sizeof(rgrs) );
	#endif

	CallR( SgErrSemCreate( &semMem, "gmem mutex" ) );

	/* allocate space for system resources
	/**/
	for ( ires = 0; ires < iresLinkedMax; ires++ )
		{
		/* the size of the allocated reaource should be on a 4-byte boundary, for MIPS
		/**/
#if defined(_MIPS_) || defined(_ALPHA_)
		Assert( rgres[ires].cbSize % 4 == 0 );
#endif
		rgres[ires].pbAlloc = PvSysAlloc( (ULONG)rgres[ires].cblockAlloc * (USHORT)rgres[ires].cbSize );
		if ( rgres[ires].pbAlloc == NULL )
			{
			int iresT;

			for ( iresT = 0; iresT < ires; iresT++ )
				SysFree( rgres[iresT].pbAlloc );

			return JET_errOutOfMemory;
			}

//		#ifdef DEBUG
//		/* set resource space to 0xff
//		/**/
//		memset( rgres[ires].pbAlloc, 0xff, rgres[ires].cblockAlloc * rgres[ires].cbSize );
//		#endif

		rgres[ires].pbAvail = NULL;
		rgres[ires].cblockAvail = 0;
		rgres[ires].iblockCommit = 0;
		}

	return JET_errSuccess;
	}


VOID MEMTerm( VOID )
	{
	INT	ires;

	for ( ires = 0; ires < iresLinkedMax; ires++ )
		{
		/* the size of the allocated reaource should be on a 4-byte boundary, for MIPS
		/**/
#if defined(_MIPS_) || defined(_ALPHA_)
		Assert( rgres[ires].cbSize % 4 == 0 );
#endif
//		#ifdef DEBUG
//		/* set resource space to 0xff
//		/**/
//		memset( rgres[ires].pbAlloc, 0xff, rgres[ires].cblockAlloc * rgres[ires].cbSize );
//		#endif

		SysFree( rgres[ires].pbAlloc );
		rgres[ires].pbAlloc = NULL;
		rgres[ires].cblockAlloc = 0;
		rgres[ires].pbAvail = NULL;
		rgres[ires].cblockAvail = 0;
		rgres[ires].iblockCommit = 0;
		}

	return;
	}


BYTE *PbMEMAlloc( int ires )
	{
	BYTE *pb;

	Assert( ires < iresLinkedMax );

#ifdef RFS2
	switch (ires)
	{
		case iresBGCB:
			if (!RFSAlloc( BGCBResource ) )
				return NULL;
			break;
		case iresCSR:
			if (!RFSAlloc( CSRResource ) )
				return NULL;
			break;
		case iresFCB:
			if (!RFSAlloc( FCBResource ) )
				return NULL;
			break;
		case iresFUCB:
			if (!RFSAlloc( FUCBResource ) )
				return NULL;
			break;
		case iresIDB:
			if (!RFSAlloc( IDBResource ) )
				return NULL;
			break;
		case iresPIB:
			if (!RFSAlloc( PIBResource ) )
				return NULL;
			break;
		case iresSCB:
			if (!RFSAlloc( SCBResource ) )
				return NULL;
			break;
		case iresVersionBucket:
			if (!RFSAlloc( VersionBucketResource ) )
				return NULL;
			break;
		case iresDAB:
			if (!RFSAlloc( DABResource ) )
				return NULL;
			break;
		default:
			if (!RFSAlloc( UnknownResource ) )
				return NULL;
			break;
	};
#endif

	SgSemRequest( semMem );
#ifdef DEBUG
	MEMStat( ires, fTrue );
#endif
	pb = rgres[ires].pbAvail;
	if ( pb != NULL )
		{
#ifdef DEBUG
		rgres[ires].cblockAvail--;
#endif
		rgres[ires].pbAvail = (BYTE *) *(BYTE * UNALIGNED *)pb;
		}

	/*	commit new resource if have uncommitted available
	/**/
	if ( pb == NULL && rgres[ires].iblockCommit < rgres[ires].cblockAlloc )
		{
		INT	cblock = 1;

		/*	there must be at least 1 block left
		/**/
		Assert( rgres[ires].cblockAlloc > rgres[ires].iblockCommit );

		if ( rgres[ires].cbSize < cbMemoryPage )
			{
			/*	commit one pages of memory at a time
			/**/
			cblock = ( ( ( ( ( ( rgres[ires].iblockCommit * rgres[ires].cbSize ) + cbMemoryPage - 1 )
				/ cbMemoryPage ) + 1 ) * cbMemoryPage )
				/ rgres[ires].cbSize ) - rgres[ires].iblockCommit;
			Assert( cblock > 0 && cblock <= cbMemoryPage/sizeof(BYTE *) );
			if ( cblock > rgres[ires].cblockAlloc - rgres[ires].iblockCommit )
				cblock = rgres[ires].cblockAlloc - rgres[ires].iblockCommit;
			}

#ifdef MEM_CHECK
		cblock = 1;
#endif

		pb = rgres[ires].pbAlloc + ( rgres[ires].iblockCommit * rgres[ires].cbSize );
			
		if ( PvSysCommit( pb, cblock * rgres[ires].cbSize ) == NULL )
			{
			pb = NULL;
			}
		else
			{
			rgres[ires].iblockCommit += cblock;

			/*	if surplus blocks, then link to resource
			/**/
			if ( cblock > 1 )
				{
				BYTE	*pbLink = pb + rgres[ires].cbSize;
				BYTE	*pbLinkMax = pb + ( ( cblock - 1 ) * rgres[ires].cbSize );

				Assert( rgres[ires].pbAvail == NULL );
				rgres[ires].pbAvail = pbLink;
				rgres[ires].cblockAvail += cblock - 1;

				/*	link surplus blocks into resource free list
				/**/
				for ( ; pbLink < pbLinkMax; pbLink += rgres[ires].cbSize )
					{
					*(BYTE * UNALIGNED *)pbLink = pbLink + rgres[ires].cbSize;
					}
				*(BYTE * UNALIGNED *)pbLink = NULL;
				}
			}
		}
	
	SgSemRelease( semMem );

#ifdef DEBUG
	/*	For setting break point:
	 */
	if ( pb == NULL )
		pb = NULL;
	else
		{
		/* set resource space to 0xff
		/**/
		memset( pb, 0xff, rgres[ires].cbSize );
		}
#endif
	return pb;
	}


VOID MEMRelease( int ires, BYTE *pb )
	{
	Assert( ires < iresLinkedMax );

#ifdef DEBUG
	memset( pb, (char)0xff, rgres[ires].cbSize );
#endif

	SgSemRequest( semMem );

#ifdef DEBUG
	rgres[ires].cblockAvail++;
	MEMStat( ires, fFalse );
#endif

	*(BYTE * UNALIGNED *)pb = rgres[ires].pbAvail;
	rgres[ires].pbAvail = pb;
	SgSemRelease( semMem );
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\info.c ===
#include "config.h"

#include <stdlib.h>
#include <string.h>

#include "daedef.h"
#include "pib.h"
#include "ssib.h"
#include "util.h"
#include "page.h"
#include "fcb.h"
#include "fucb.h"
#include "stapi.h"
#include "fdb.h"
#include "dirapi.h"
#include "spaceapi.h"
#include "idb.h"
#include "recapi.h"
#include "fileapi.h"
#include "recint.h"
#include "fileint.h"
#include "fmp.h"
#include "info.h"
#include "dbapi.h"
#include "systab.h"
#include "stats.h"
#include "nver.h"

DeclAssertFile;					/* Declare file name for assert macros */


extern CDESC * __near rgcdescSc;

/* Local data types */

typedef struct						/* returned by FidLookupColumn */
	{
	JET_COLTYP		coltyp;
	JET_COLUMNID	columnid;
	JET_GRBIT		grbit;
	unsigned long	cb;
	char			szName[ ( JET_cbNameMost + 1 ) ];
	} COLINFO;


#ifdef	SYSTABLES

/* Static data for ErrIsamGetObjectInfo */

CODECONST( JET_COLUMNDEF ) rgcolumndefGetObjects[] =
	{
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypText, 0, 0, 0, 0, 0, JET_bitColumnTTKey },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypText, 0, 0, 0, 0, 0, JET_bitColumnTTKey },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypDateTime, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypDateTime, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed }
	};

#define ccolumndefGetObjectsMax \
	( sizeof( rgcolumndefGetObjects ) / sizeof( JET_COLUMNDEF ) )

/* column indexes for rgcolumndefGetObjects */
#define iContainerName	0
#define iObjectName		1
#define iObjectType		2
#define iDtCreate			3
#define iDtUpdate			4
#define iCRecord			5
#define iCPage				6
#define iGrbit				7
#define iFlags				8

CODECONST(JET_COLUMNDEF) rgcolumndefObjectAcm[] =
	{
	 /* SID */
		{ sizeof(JET_COLUMNDEF), 0, JET_coltypBinary, 0, 0, 0, 0, 0, JET_bitColumnTTKey },
	 /* ACM */
		{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	 /* grbit */
		{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed }
	};

/* column indexes for rgcolumndefObjectAcm */
#define iAcmSid			0
#define iAcmAcm			1
#define iAcmGrbit			2
#define ccolumndefObjectAcmMax \
	( sizeof( rgcolumndefObjectAcm ) / sizeof( JET_COLUMNDEF ) )

#endif	/* SYSTABLES */


/* Static data for ErrIsamGetColumnInfo */

CODECONST( JET_COLUMNDEF ) rgcolumndefGetColumns[] =
	{
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnTTKey },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypText, 0, 0, 0, 0, 0, JET_bitColumnTTKey },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
   { sizeof(JET_COLUMNDEF), 0, JET_coltypBinary, 0, 0, 0, 0, 0, 0 },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypText, 0, 0, 0, 0, 0, 0 },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypText, 0, 0, 0, 0, 0, 0 }
	};

#define ccolumndefGetColumnsMax \
	( sizeof( rgcolumndefGetColumns ) / sizeof( JET_COLUMNDEF ) )

#define iColumnPOrder		0
#define iColumnName			1
#define iColumnId				2
#define iColumnType			3
#define iColumnCountry		4
#define iColumnLangid		5
#define iColumnCp				6
#define iColumnCollate		7
#define iColumnSize			8
#define iColumnGrbit			9
#define iColumnDefault		10
#define iColumnTableName	11
#define iColumnColumnName	12


/* Static data for ErrIsamGetIndexInfo */

CODECONST( JET_COLUMNDEF ) rgcolumndefGetIndex[] =
	{
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypText, 0, 0, 0, 0, 0, JET_bitColumnTTKey },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed | JET_bitColumnTTKey },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypText, 0, 0, 0, 0, 0, 0 }
	};

#define ccolumndefGetIndexMax ( sizeof( rgcolumndefGetIndex ) / sizeof( JET_COLUMNDEF ) )

#define iIndexName		0
#define iIndexGrbit		1
#define iIndexCKey		2
#define iIndexCEntry		3
#define iIndexCPage		4
#define iIndexCCol		5
#define iIndexICol		6
#define iIndexColId		7
#define iIndexColType	8
#define iIndexCountry	9
#define iIndexLangid		10
#define iIndexCp			11
#define iIndexCollate	12
#define iIndexColBits	13
#define iIndexColName	14

/* #ifdef	DISPATCHING
ERR VDBAPI ErrIsamOpenTempTable(
	JET_SESID		sesid,
	JET_COLUMNDEF	*rgcolumndef,
	unsigned long	ccolumndef,
	JET_GRBIT		grbit,
	JET_TABLEID		*ptableid,
	JET_COLUMNID	*rgcolumnid );
#endif	*/ /* DISPATCHING */

/* Internal function prototypes
/**/
FID FidLookupColumn( FUCB * pfucb, FID fid, char * szColumnName, 	COLINFO * pcolinfo );
LOCAL ERR ErrGetObjectPermissions(
	PIB *ppib,
	DBID dbid,
	OBJID objidCtr,
	const char *szObjectName,
	OUTLINE *pout);

#ifdef	SYSTABLES
LOCAL ERR ErrInfoGetObjectInfo0(
	PIB				*ppib,
	FUCB			*pfucbMSO,
	OBJID			objidCtr,
	JET_OBJTYP		objtyp,
	char			*szContainerName,
	char			*szObjectName,
	OUTLINE			*pout );
LOCAL ERR ErrInfoGetObjectInfo12(
	PIB				*ppib,
	FUCB			*pfucbMSO,
	OBJID			objidCtr,
	JET_OBJTYP		objtyp,
	char			*szContainerName,
	char			*szObjectName,
	OUTLINE			*pout,
	long			lInfoLevel );
LOCAL ERR ErrInfoGetObjectInfo3(
	PIB				*ppib,
	FUCB			*pfucbMSO,
	OBJID			objidCtr,
	JET_OBJTYP		objtyp,
	char			*szContainerName,
	char			*szObjectName,
	OUTLINE			*pout,
	BOOL			fReadOnly );
#endif	/* SYSTABLES */


LOCAL ERR ErrInfoGetTableColumnInfo0( PIB *ppib, FUCB *pfucb,
	CHAR *szColumnName, OUTLINE *pout );
LOCAL ERR ErrInfoGetTableColumnInfo1( PIB *ppib, FUCB *pfucb,
	CHAR *szColumnName, OUTLINE *pout );
LOCAL ERR ErrInfoGetTableColumnInfo3( PIB *ppib, FUCB *pfucb, CHAR *szColumnName, OUTLINE *pout );
LOCAL ERR ErrInfoGetTableColumnInfo4( PIB *ppib, FUCB *pfucb,
	CHAR *szColumnName, OUTLINE *pout );
LOCAL ERR ErrInfoGetTableIndexInfo01( PIB *ppib, FUCB *pfucb,
	CHAR *szIndexName, OUTLINE *pout, LONG lInfoLevel );
LOCAL ERR ErrInfoGetTableIndexInfo2( PIB *ppib, FUCB *pfucb,
	CHAR *szIndexName, OUTLINE *pout );




/*=================================================================
ErrIsamGetObjectInfo

Description: Returns information about all objects or a specified object

Parameters:	ppib				pointer to PIB for current session
				dbid				database id containing objects
				objtyp			type of object or objtypNil for all objects
				szContainer		container name or NULL for all objects
				szObjectName	object name or NULL for all objects
				pout				output buffer
				lInfoLevel		level of information ( 0, 1, or 2 )

Return Value:	JET_errSuccess if the oubput buffer is valid

Errors/Warnings:

Side Effects:
=================================================================*/
ERR VDBAPI ErrIsamGetObjectInfo(
	JET_VSESID		vsesid, 				/* pointer to PIB for current session */
	JET_DBID			vdbid, 	  			/* database id containing objects */
	JET_OBJTYP		objtyp,				/* type of object or objtypNil for all */
	const char		*szContainer, 		/* container name or NULL for all */
	const char		*szObject, 			/* object name or NULL for all */
	OLD_OUTDATA		*poutdata, 	  		/* output buffer */
	unsigned long	lInfoLevel ) 		/* information level */
	{
	PIB				*ppib = (PIB *) vsesid;
	OUTLINE			*pout = (OUTLINE *) poutdata;
#ifdef	SYSTABLES
	ERR				err;
	DBID				dbid = DbidOfVDbid( vdbid );
	FUCB 				*pfucbMSO;
	CHAR				szContainerName[( JET_cbNameMost + 1 )];
	CHAR				szObjectName[( JET_cbNameMost + 1 )];
	OBJID				objidCtr;
	ULONG				cbActual;
	JET_COLUMNID	columnidObjectId;

	CheckPIB( ppib );
	CheckDBID( ppib, ( DBID )dbid );

	if ( szContainer == NULL || *szContainer == '\0' )
		*szContainerName = '\0';
	else
		CallR( ErrCheckName( szContainerName, szContainer, ( JET_cbNameMost + 1 ) ) );
	if ( szObject == NULL || *szObject == '\0' )
		*szObjectName = '\0';
	else
		CallR( ErrCheckName( szObjectName, szObject, ( JET_cbNameMost + 1 ) ) );

	/*	check for invalid information level
	/**/
	switch( lInfoLevel )
		{
		case JET_ObjInfo:
		case JET_ObjInfoListNoStats:
		case JET_ObjInfoList:
		case JET_ObjInfoSysTabCursor:
		case JET_ObjInfoListACM:
		case JET_ObjInfoNoStats:
		case JET_ObjInfoSysTabReadOnly:
		case JET_ObjInfoRulesLoaded:
			break;
		default:
			return JET_errInvalidParameter;
		}

	/* MSysObjects will be accessed directly or scanned for all object info
	/**/
	CallR( ErrFILEOpenTable( ppib, dbid, &pfucbMSO, szSoTable, 0 ) );
	if ( lInfoLevel == JET_ObjInfo
		|| lInfoLevel == JET_ObjInfoListNoStats
		|| lInfoLevel == JET_ObjInfoList
		|| FVDbidReadOnly( vdbid ) )
		FUCBResetUpdatable( pfucbMSO );

	Call( ErrFILEGetColumnId( ppib, pfucbMSO, szSoIdColumn, &columnidObjectId ) );

	/* use the object name index for both direct access and scanning
	/**/
	Call( ErrIsamSetCurrentIndex( ppib, pfucbMSO, szSoNameIndex ) );

	/* get the object id for the specified container
	/**/
	objidCtr = objidRoot;
	if ( szContainerName != NULL && *szContainerName != '\0' )
		{
		Call( ErrIsamMakeKey( ppib, pfucbMSO, (void *)&objidCtr, sizeof( objidCtr ), JET_bitNewKey ) );
		Call( ErrIsamMakeKey( ppib, pfucbMSO, szContainerName, strlen( szContainerName ), 0 ) );
		err = ErrIsamSeek( ppib, pfucbMSO, JET_bitSeekEQ );
		if ( err < 0 )
			{
			if ( err == JET_errRecordNotFound )
				err = JET_errObjectNotFound;
			goto HandleError;
			}

		/* retrieve the container object id
		/**/
		Call( ErrIsamRetrieveColumn( ppib, pfucbMSO, columnidObjectId,
			(BYTE *)&objidCtr, sizeof( objidCtr ), &cbActual, 0, NULL ) );
		Assert( objidCtr != objidNil );
		}

	switch ( lInfoLevel )
		{
		case JET_ObjInfoNoStats:
		case JET_ObjInfo:
			err = ErrInfoGetObjectInfo0(
				ppib,
				pfucbMSO,
				objidCtr,
				objtyp,
				szContainerName,
				szObjectName,
				pout );
			break;
		case JET_ObjInfoListNoStats:
		case JET_ObjInfoList:
			err = ErrInfoGetObjectInfo12(
				ppib,
				pfucbMSO,
				objidCtr,
				objtyp,
				szContainerName,
				szObjectName,
				pout,
				lInfoLevel );
			break;
		case JET_ObjInfoSysTabCursor:
		case JET_ObjInfoSysTabReadOnly:
			err = ErrInfoGetObjectInfo3(
				ppib,
				pfucbMSO,
				objidCtr,
				objtyp,
				szContainerName,
				szObjectName,
				pout,
				FVDbidReadOnly( vdbid ) );
			break;
		case JET_ObjInfoListACM:
			err = ErrGetObjectPermissions(
				ppib,
				dbid,
				objidCtr,
				szObjectName,
				pout );
			break;

		default:
			Assert( lInfoLevel == JET_ObjInfoRulesLoaded );
//	UNDONE:	implement this
//			err = ErrINFOGetRuleStatus( ppib, dbid, objidCtr, szObjectName );
			err = JET_wrnNyi;
			break;
		}

HandleError:
	CallS( ErrFILECloseTable( ppib, pfucbMSO ) );
	return err;
#else	/* !SYSTABLES */
	return JET_errFeatureNotAvailable;
#endif	/* !SYSTABLES */
	}


#ifdef	SYSTABLES

LOCAL ERR ErrInfoGetObjectInfo0(
	PIB				*ppib,
	FUCB			*pfucbMSO,
	OBJID			objidCtr,
	JET_OBJTYP		objtyp,
	char			*szContainerName,
	char			*szObjectName,
	OUTLINE			*pout )
	{
	ERR				err;
	BYTE			*pb;
	ULONG			cbMax;
	ULONG			cbActual;

	JET_COLUMNID  	columnidParentId;			/* columnid for ParentId column in MSysObjects */
	JET_COLUMNID 	columnidObjectName;		/* columnid for Name column in MSysObjects */
	JET_COLUMNID 	columnidObjectType;		/* columnid for Type column in MSysObjects */
	JET_COLUMNID 	columnidObjectId;			/* columnid for Id column in MSysObjects */
	JET_COLUMNID 	columnidCreate;			/* columnid for DateCreate column in MSysObjects */
	JET_COLUMNID 	columnidUpdate;			/* columnid for DateUpdate column in MSysObjects */
	JET_COLUMNID 	columnidFlags;				/* columnid for Flags column in MSysObjects */
	OBJTYP			objtypObject;

	pout->cbReturned = 0;

	/* get columnids
	/**/
	Call( ErrFILEGetColumnId( ppib, pfucbMSO, szSoParentIdColumn, &columnidParentId ) );
	Call( ErrFILEGetColumnId( ppib, pfucbMSO, szSoObjectNameColumn, &columnidObjectName ) );
	Call( ErrFILEGetColumnId( ppib, pfucbMSO, szSoObjectTypeColumn, &columnidObjectType ) );
	Call( ErrFILEGetColumnId( ppib, pfucbMSO, szSoIdColumn, &columnidObjectId ) );
	Call( ErrFILEGetColumnId( ppib, pfucbMSO, szSoDateCreateColumn, &columnidCreate ) );
	Call( ErrFILEGetColumnId( ppib, pfucbMSO, szSoDateUpdateColumn, &columnidUpdate ) );
	Call( ErrFILEGetColumnId( ppib, pfucbMSO, szSoFlagsColumn, &columnidFlags ) );

	/* use the object name index for both direct access and scanning
	/**/
	Call( ErrIsamSetCurrentIndex( ppib, pfucbMSO, szSoNameIndex ) );

	/* return error if the output buffer is too small
	/**/
	if ( pout->cbMax < sizeof(JET_OBJECTINFO) )
		{
		return JET_errInvalidParameter;
		}

	/* seek to key ( ParentId = container id, Name = object name )
	/**/
	Call( ErrIsamMakeKey( ppib, pfucbMSO, (void *)&objidCtr, sizeof( objidCtr ), JET_bitNewKey ) );
	Call( ErrIsamMakeKey( ppib, pfucbMSO, szObjectName, strlen( szObjectName ), 0 ) );
	Call( ErrIsamSeek( ppib, pfucbMSO, JET_bitSeekEQ ) );

	/*	set cbStruct
	/**/
	((JET_OBJECTINFO *)pout->pb)->cbStruct = sizeof(JET_OBJECTINFO);

	/* set output data
	/**/
	pb = (BYTE *)&objtypObject;
	cbMax = sizeof(objtypObject);
	Call( ErrIsamRetrieveColumn( ppib, pfucbMSO, columnidObjectType, pb, cbMax, &cbActual, 0, NULL ) );
	*((JET_OBJTYP *)&(((JET_OBJECTINFO *)pout->pb)->objtyp)) = (JET_OBJTYP)objtypObject;

	cbMax = sizeof(JET_DATESERIAL);
	pb = (void *)&( ( JET_OBJECTINFO *)pout->pb )->dtCreate;
	Call( ErrIsamRetrieveColumn( ppib, pfucbMSO, columnidCreate, pb, cbMax, &cbActual, 0, NULL ) );

	pb = (void *)&( ( JET_OBJECTINFO *)pout->pb )->dtUpdate;
	cbMax = sizeof(JET_DATESERIAL);
	Call( ErrIsamRetrieveColumn( ppib, pfucbMSO, columnidUpdate, pb, cbMax,
		&cbActual, 0, NULL ) );

	pb    = (void *)&( ( JET_OBJECTINFO *)pout->pb )->flags;
	cbMax = sizeof(ULONG);
	Call( ErrIsamRetrieveColumn( ppib, pfucbMSO, columnidFlags, pb, cbMax,
		&cbActual, 0, NULL ) );
	if ( cbActual == 0 )
		( ( JET_OBJECTINFO  *) pout->pb )->flags = 0;

	/*	set stats
	/**/
	if ( (JET_OBJTYP)objtypObject == JET_objtypTable )
		{
		Call( ErrSTATSRetrieveTableStats( ppib, pfucbMSO->dbid, szObjectName,
			&((JET_OBJECTINFO *)pout->pb)->cRecord,
			NULL,
			&((JET_OBJECTINFO *)pout->pb)->cPage ) );
		}
	else
		{
		((JET_OBJECTINFO *)pout->pb )->cRecord = 0;
		((JET_OBJECTINFO *)pout->pb )->cPage   = 0;
		}

	//	UNDONE:	check this
	((JET_OBJECTINFO *)pout->pb )->grbit   = 0;

	pout->cbActual   = sizeof(JET_OBJECTINFO);
	pout->cbReturned = sizeof(JET_OBJECTINFO);
	err = JET_errSuccess;

HandleError:
	if ( err == JET_errRecordNotFound )
		err = JET_errObjectNotFound;
	return err;
	}


LOCAL ERR ErrInfoGetObjectInfo12(
	PIB				*ppib,
	FUCB			*pfucbMSO,
	OBJID			objidCtr,
	JET_OBJTYP		objtyp,
	char			*szContainerName,
	char			*szObjectName,
	OUTLINE			*pout,
	long			lInfoLevel )
	{
#ifdef	DISPATCHING
	ERR				err;
	OUTLINE			outline;
	LINE				line;

	JET_COLUMNID	columnidParentId;   	/* columnid for ParentId col in MSysObjects */
	JET_COLUMNID	columnidObjectName; 	/* columnid for Name column in MSysObjects */
	JET_COLUMNID	columnidObjectType; 	/* columnid for Type column in MSysObjects */
	JET_COLUMNID	columnidObjectId;   	/* columnid for Id column in MSysObjects */
	JET_COLUMNID	columnidCreate;     	/* columnid for DateCreate in MSysObjects */
	JET_COLUMNID	columnidUpdate;     	/* columnid for DateUpdate  in MSysObjects */
	JET_COLUMNID	columnidFlags;	   	/* columnid for Flags column in MSysObjects */

	char				szCtrName[( JET_cbNameMost + 1 )];
	char				szObjectNameCurrent[( JET_cbNameMost + 1 )+1];

	JET_TABLEID		tableid;
	JET_COLUMNID	rgcolumnid[ccolumndefGetObjectsMax];
	JET_OBJTYP		objtypObject;		/* type of current object */

	long				cRows = 0;			/* count of objects found */
	long				cRecord = 0;		/* count of records in table */
	long				cPage = 0;			/* count of pages in table */

	BYTE				*pbContainerName;
	ULONG				cbContainerName;
	BYTE				*pbObjectName;
	ULONG				cbObjectName;
	BYTE				*pbObjectType;
	ULONG				cbObjectType;
	BYTE				*pbDtCreate;
	ULONG				cbDtCreate;
	BYTE				*pbDtUpdate;
	ULONG				cbDtUpdate;
	BYTE				*pbCRecord;
	ULONG				cbCRecord;
	BYTE				*pbCPage;
	ULONG				cbCPage;
	BYTE				*pbFlags;
	ULONG				cbFlags;

	JET_GRBIT			grbit;
	BYTE				*pbGrbit;
	ULONG				cbGrbit;

	pout->cbReturned = 0;

	/* get columnids
	/**/
	CallR( ErrFILEGetColumnId( ppib, pfucbMSO, szSoParentIdColumn, &columnidParentId ) );
	CallR( ErrFILEGetColumnId( ppib, pfucbMSO, szSoObjectNameColumn, &columnidObjectName ) );
	CallR( ErrFILEGetColumnId( ppib, pfucbMSO, szSoObjectTypeColumn, &columnidObjectType ) );
	CallR( ErrFILEGetColumnId( ppib, pfucbMSO, szSoIdColumn, &columnidObjectId ) );
	CallR( ErrFILEGetColumnId( ppib, pfucbMSO, szSoDateCreateColumn, &columnidCreate ) );
	CallR( ErrFILEGetColumnId( ppib, pfucbMSO, szSoDateUpdateColumn, &columnidUpdate ) );
	CallR( ErrFILEGetColumnId( ppib, pfucbMSO, szSoFlagsColumn, &columnidFlags ) );

	/* Use the object name index for both direct access and scanning */
	CallR( ErrIsamSetCurrentIndex( ppib, pfucbMSO, szSoNameIndex ) );

	/* Quit if the output buffer is too small */
	if ( pout->cbMax < sizeof(JET_OBJECTLIST) )
		{
		return JET_errInvalidParameter;
		}

	pbCRecord = (BYTE  *)&cRecord;
	cbCRecord = sizeof( cRecord );

	pbCPage = (BYTE  *) &cPage;
	cbCPage = sizeof( cPage );

	pbObjectType = (BYTE  *)&objtypObject;
	cbObjectType = sizeof( objtypObject );

	pbContainerName = szContainerName;
	if ( szContainerName == NULL || *szContainerName == '\0' )
		cbContainerName = 0;
	else
		cbContainerName = strlen( szContainerName );

	/* Open the temporary table which will be returned to the caller
	/**/
	CallR( ErrIsamOpenTempTable( (JET_SESID)ppib,
		(JET_COLUMNDEF *) rgcolumndefGetObjects,
		ccolumndefGetObjectsMax, JET_bitTTScrollable | JET_bitTTScrollable,
		&tableid, rgcolumnid ) );

	/* Position to the record for the first object */
	if ( szContainerName == NULL || *szContainerName == '\0' )
		{
		/* If container not specified, then use first record in table */
		Call( ErrIsamMove( ppib, pfucbMSO, JET_MoveFirst, 0 ) );
		}
	else
		{
		/* move the first record for an object in the container
		/**/
		Call( ErrIsamMakeKey( ppib, pfucbMSO, (void *)&objidCtr,
			sizeof( objidCtr ), JET_bitNewKey ) );
		Call( ErrIsamSeek( ppib, pfucbMSO, JET_bitSeekGE ) );
		}

	do
		{
		/* get pointer to the object type
		/**/
		Call( ErrRECIRetrieve( pfucbMSO, (FID *)&columnidObjectType, 0, &line, 0 ) );

		/*	set objtypObject from line retrieval.
		/**/
		objtypObject = (JET_OBJTYP)(*(UNALIGNED OBJTYP *)line.pb);

		/*	get pointer to the ParentId ( container id )
		/**/
		Call( ErrRECIRetrieve( pfucbMSO, (FID *)&columnidParentId, 0, &line, 0 ) );

		/* done if container specified and object isn't in it
		/**/
		if ( szContainerName != NULL && *szContainerName != '\0' && objidCtr != *(UNALIGNED OBJID *)line.pb )
			goto ResetTempTblCursor;

		Assert( objidCtr == objidRoot || objidCtr == *(UNALIGNED OBJID *)line.pb );

		/* if desired object type and container
		/**/
		if ( objtyp == JET_objtypNil || objtyp == objtypObject )
			{
			/*	get the container name
			/**/
			if ( *(UNALIGNED OBJID *)line.pb == objidRoot )
				{
				pbContainerName = NULL;
				cbContainerName = 0;
				}
			else
				{
				outline.pb    = szCtrName;
				outline.cbMax = sizeof( szCtrName );
				Call( ErrFindNameFromObjid( ppib, pfucbMSO->dbid, *(UNALIGNED OBJID *)line.pb, &outline ) );
				/* save pointers to the container name
				/**/
				pbContainerName = outline.pb;
				Assert( outline.cbActual <= outline.cbMax );
				cbContainerName = outline.cbActual;
				}

			/* get pointer to the object name
			/**/
			Call( ErrRECIRetrieve( pfucbMSO, (FID *)&columnidObjectName, 0, &line, 0 ) );
			pbObjectName = line.pb;
			cbObjectName = line.cb;

			/* get pointer to the object creation date
			/**/
			Call( ErrRECIRetrieve( pfucbMSO, (FID *)&columnidCreate, 0, &line, 0 ) );
			pbDtCreate = line.pb;
			cbDtCreate = line.cb;

			/* get pointer to the last update date
			/**/
			Call( ErrRECIRetrieve( pfucbMSO, (FID *)&columnidUpdate, 0, &line, 0 ) );
			pbDtUpdate = line.pb;
			cbDtUpdate = line.cb;

			/* get pointer to the last update date
			/**/
			Call( ErrRECIRetrieve( pfucbMSO, (FID *)&columnidFlags, 0, &line, 0 ) );
			pbFlags = line.pb;
			cbFlags = line.cb;

			/* get pointer to the last update date
			/**/
			grbit = 0;
			pbGrbit = (BYTE *)&grbit;
			cbGrbit = sizeof(JET_GRBIT);

			/*	get statistics if requested and if object is table
			/**/
			Assert( lInfoLevel == JET_ObjInfoList ||
				lInfoLevel == JET_ObjInfoListNoStats );
			if ( lInfoLevel == JET_ObjInfoList && objtypObject == JET_objtypTable )
				{
				/* terminate the name
				/**/
				memcpy( szObjectNameCurrent, pbObjectName, ( size_t )cbObjectName );
				szObjectNameCurrent[cbObjectName] = '\0';

				Call( ErrSTATSRetrieveTableStats( ppib,
					pfucbMSO->dbid,
					szObjectNameCurrent,
					&cRecord,
					NULL,
					&cPage ) );
				}

			/* add the current object info to the temporary table
			/**/
			Call( ErrDispPrepareUpdate( (JET_SESID)ppib, tableid, JET_prepInsert ) );
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iContainerName], pbContainerName,
				cbContainerName, 0, NULL ) );
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iObjectName], pbObjectName,
				cbObjectName, 0, NULL ) );
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iObjectType], pbObjectType,
				cbObjectType, 0, NULL ) );
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iDtCreate], pbDtCreate,
				cbDtCreate, 0, NULL ) );
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iDtUpdate], pbDtUpdate,
				cbDtUpdate, 0, NULL ) );
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iCRecord], pbCRecord,
				cbCRecord, 0, NULL ) );
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iCPage], pbCPage, cbCPage, 0, NULL ) );
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iFlags], pbFlags, cbFlags, 0, NULL ) );
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iGrbit], pbGrbit, cbGrbit, 0, NULL ) );
			Call( ErrDispUpdate( (JET_SESID)ppib, tableid, NULL, 0, NULL ) );

			/* set the number of objects found
			/**/
			cRows++;
			}

		/* move to the next record
		/**/
		err = ErrIsamMove( ppib, pfucbMSO, JET_MoveNext, 0 );
		} while ( err >= 0 );

	/* return if error other than end of range
	/**/
	if ( err != JET_errNoCurrentRecord )
		goto HandleError;

ResetTempTblCursor:

	/* move to first record in the temporary table
	/**/
	err = ErrDispMove( (JET_SESID)ppib, tableid, JET_MoveFirst, 0 );
	if ( err < 0  )
		{
		if ( err != JET_errNoCurrentRecord )
			goto HandleError;
		err = JET_errSuccess;
		}

	/* set the return structure
	/**/
	((JET_OBJECTLIST *)pout->pb)->cbStruct = sizeof(JET_OBJECTLIST);
	((JET_OBJECTLIST *)pout->pb)->tableid = tableid;
	((JET_OBJECTLIST *)pout->pb)->cRecord = cRows;
	((JET_OBJECTLIST *)pout->pb)->columnidcontainername = rgcolumnid[iContainerName];
	((JET_OBJECTLIST *)pout->pb)->columnidobjectname = rgcolumnid[iObjectName];
	((JET_OBJECTLIST *)pout->pb)->columnidobjtyp = rgcolumnid[iObjectType];
	((JET_OBJECTLIST *)pout->pb)->columniddtCreate = rgcolumnid[iDtCreate];
	((JET_OBJECTLIST *)pout->pb)->columniddtUpdate = rgcolumnid[iDtUpdate];
	((JET_OBJECTLIST *)pout->pb)->columnidgrbit = rgcolumnid[iGrbit];
	((JET_OBJECTLIST *)pout->pb)->columnidflags =	rgcolumnid[iFlags];
	((JET_OBJECTLIST *)pout->pb)->columnidcRecord = rgcolumnid[iCRecord];
	((JET_OBJECTLIST *)pout->pb)->columnidcPage = rgcolumnid[iCPage];

	pout->cbActual   = sizeof(JET_OBJECTLIST);
	pout->cbReturned = sizeof(JET_OBJECTLIST);
	return JET_errSuccess;

HandleError:
	(VOID)ErrDispCloseTable( (JET_SESID)ppib, tableid );
	if ( err == JET_errRecordNotFound )
		err = JET_errObjectNotFound;
	return err;
#else	/* !DISPATCHING */
	return JET_errFeatureNotAvailable;
#endif	/* !DISPATCHING */
	}


LOCAL ERR ErrInfoGetObjectInfo3(
	PIB				*ppib,
	FUCB			*pfucbMSO,
	OBJID			objidCtr,
	JET_OBJTYP		objtyp,
	char			*szContainerName,
	char			*szObjectName,
	OUTLINE			*pout,
	BOOL			fReadOnly )
	{
	ERR			err;
	FUCB			*pfucb;
#ifdef	DISPATCHING
	JET_TABLEID	tableid;
#endif	/* DISPATCHING */

	if ( pout == NULL || pout->cbMax < sizeof(JET_TABLEID) )
		return JET_errInvalidParameter;

	CallR( ErrFILEOpenTable( ppib, pfucbMSO->dbid, &pfucb, szSoTable, 0 ) );
	if ( fReadOnly )
		FUCBResetUpdatable( pfucb );
	Call( ErrIsamSetCurrentIndex( ppib, pfucb, szSoNameIndex ) );
	Call( ErrIsamMakeKey( ppib, pfucb, (void *)&objidCtr, sizeof( objidCtr ), JET_bitNewKey ) );
	Call( ErrIsamMakeKey( ppib, pfucb, szObjectName, strlen( szObjectName ), 0 ) );
	Call( ErrIsamSeek( ppib, pfucb, JET_bitSeekEQ ) );

	FUCBSetSystemTable( pfucb );

#ifdef	DISPATCHING
	Call( ErrAllocateTableid( &tableid, (JET_VTID)pfucb, &vtfndefIsamInfo ) );
	pfucb->fVtid = fTrue;
	*(JET_TABLEID *)(pout->pb) = tableid;
	pout->cbReturned = sizeof(tableid);
	pout->cbActual = sizeof(tableid);
#else	/* !DISPATCHING */
	*(FUCB **)(pout->pb) = pfucb;
	pout->cbReturned = sizeof(pfucb);
	pout->cbActual = sizeof(pfucb);
#endif	/* !DISPATCHING */

	return JET_errSuccess;

HandleError:
	if ( err == JET_errRecordNotFound )
		err = JET_errObjectNotFound;
	CallS( ErrFILECloseTable( ppib, pfucb ) );
	return err;
	}


LOCAL ERR ErrGetObjectPermissions(
	PIB *ppib,
	DBID dbid,
	OBJID objidCtr,
	const char *szObjectName,
	OUTLINE *pout)
	{
#ifdef	DISPATCHING
#ifdef	SEC
	ERR				err;			   	/* error codes from internal functions */
	LINE				line;		   		/* general purpose usage */

	OBJID				objid;						/* object id of object */
	JET_OBJTYP		objtyp;						/* object type of object */
	JET_COLUMNID	columnidSid; 				/* columnid for SID column in MSysACEs */
	JET_COLUMNID	columnidFInheritable; 	/* columnid for FInheritable column in MSysACEs */
	JET_COLUMNID	columnidAcm;		   	/* columnid for ACM in MSysACEs */

	JET_TABLEID		tableid;
	JET_COLUMNID	rgcolumnid[ccolumndefObjectAcmMax];

	long				cRows = 0;			/* count of objects found */
	BYTE				*pbAcm;
	ULONG				cbAcm;
	BYTE				*pbSid;
	ULONG				cbSid;

	FUCB 				*pfucbMSA;

	pout->cbReturned = 0;

	/* open MSysACEs and set object name index
	/**/
	CallR( ErrFILEOpenTable ( ppib, dbid, &pfucbMSA, szSpTable, 0 ) );
	CallJ( ErrIsamSetCurrentIndex( ppib, pfucbMSA, szSpObjectIdIndex ), HandleError1 );

	/* get columnids
	/**/
	CallJ( ErrFILEGetColumnId( ppib, pfucbMSA, szSpSidColumn, &columnidSid ), HandleError1 );
	CallJ( ErrFILEGetColumnId( ppib, pfucbMSA, szSpAcmColumn, &columnidAcm ), HandleError1 );
 	CallJ( ErrFILEGetColumnId( ppib, pfucbMSA, szSpFInheritableColumn, &columnidFInheritable ), HandleError1 );

	/* get object id from object name
	/**/
	CallJ( ErrFindObjidFromIdName( ppib, dbid, objidCtr, szObjectName, &objid, &objtyp ), HandleError1 );

	/* quit if the output buffer is too small
	/**/
	if ( pout->cbMax < sizeof(JET_OBJECTACMLIST) )
		{
		return JET_errInvalidParameter;
		}

	/* open the temporary table which will be returned to the caller
	/**/
	CallJ( ErrIsamOpenTempTable( (JET_SESID)ppib,
		(JET_COLUMNDEF *) rgcolumndefObjectAcm,
		ccolumndefObjectAcmMax,
		JET_bitTTScrollable | JET_bitTTScrollable,
		&tableid,
		rgcolumnid ),
		HandleError1 );

	/* Move the first record for the object
	/* set range of index to be all objects in this container
	/**/
	Call( ErrIsamMakeKey( ppib, pfucbMSA, (void *)&objid, sizeof( objid ), JET_bitNewKey ) );
	Call( ErrIsamSeek( ppib, pfucbMSA, JET_bitSeekEQ | JET_bitSetIndexRange ) );

	do
		{
		JET_GRBIT	grbit = 0;

		/* get pointer to Sid
		/**/
		Call( ErrRECIRetrieve( pfucbMSA, (FID *)&columnidSid, 0, &line, 0 ) );
		pbSid = line.pb;
		cbSid = line.cb;

		/*	get pointer to FInheritable */
		Call( ErrRECIRetrieve( pfucbMSA, (FID *)&columnidFInheritable, 0, &line, 0 ) );
		if ( (BOOL) *line.pb )
			grbit |= JET_bitACEInheritable;
		Assert( line.cb == sizeof( BYTE ) );

		/* Get pointer to Acm */
		Call( ErrRECIRetrieve( pfucbMSA, (FID *)&columnidAcm, 0, &line, 0 ) );
		pbAcm = line.pb;
		cbAcm = line.cb;
		Assert( cbAcm == sizeof(ULONG) );

		/* Add the current object info to the temporary table
		/**/
		Call( ErrDispPrepareUpdate( (JET_SESID)ppib, tableid,
			JET_prepInsert ) );
		Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
			rgcolumnid[iAcmSid], pbSid, cbSid, 0, NULL ) );
		Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
			rgcolumnid[iAcmAcm], pbAcm, cbAcm, 0, NULL ) );
		Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
			rgcolumnid[iAcmGrbit], &grbit, sizeof(grbit) , 0, NULL ) );

		Call( ErrDispUpdate( (JET_SESID)ppib, tableid, NULL, 0, NULL ) );

		/* update the number of objects found
		/**/
		cRows++;

		/* Move to the next Record */
		err = ErrIsamMove( ppib, pfucbMSA, JET_MoveNext, 0 );
		} while ( err >= 0 );

	/* return if error other than end of range
	/**/
	if ( err != JET_errNoCurrentRecord )
		return err;

	/* Position the temporary table to the first object record */
	err = ErrDispMove( (JET_SESID)ppib, tableid, JET_MoveFirst, 0 );
	if ( err < 0  )
		{
		if ( err != JET_errNoCurrentRecord )
			goto HandleError;
		err = JET_errSuccess;
		}

	/* fill up the return structure
	/**/
	(( JET_OBJECTACMLIST *)pout->pb )->cbStruct = sizeof(JET_OBJECTACMLIST);
	((JET_OBJECTACMLIST *)pout->pb )->tableid = tableid;
	((JET_OBJECTACMLIST *)pout->pb )->cRecord = cRows;
	((JET_OBJECTACMLIST *)pout->pb )->columnidSid = rgcolumnid[iAcmSid];
	((JET_OBJECTACMLIST *)pout->pb )->columnidACM =	rgcolumnid[iAcmAcm];
	((JET_OBJECTACMLIST *)pout->pb )->columnidgrbit = rgcolumnid[iAcmGrbit];

	pout->cbActual   = sizeof(JET_OBJECTACMLIST);
	pout->cbReturned = sizeof(JET_OBJECTACMLIST);
	return JET_errSuccess;

HandleError:
	(VOID)ErrDispCloseTable( (JET_SESID)ppib, tableid );

HandleError1:
	CallS( ErrFILECloseTable( ppib, pfucbMSA ) );
	return err;
#else 	/* !SEC */
	return JET_errFeatureNotAvailable;
#endif	/* SEC */

#else	/* !DISPATCHING */
	return JET_errFeatureNotAvailable;
#endif	/* !DISPATCHING */
}

#endif	/* SYSTABLES */



ERR VTAPI ErrIsamGetTableInfo(
	JET_VSESID		vsesid,
	JET_VTID	 	vtid,
	void		 	*pvResult,
	unsigned long	cbMax,
	unsigned long	lInfoLevel )
	{
	ERR	 			err = JET_errSuccess;
	PIB				*ppib = (PIB *)vsesid;
	FUCB		 	*pfucb = (FUCB *)vtid;
#ifdef	SYSTABLES
	FUCB 		 	*pfucbMSO;
	ULONG		 	cbActual;
	OBJID		 	objidCtr;
	OBJTYP			objtypObject;

	JET_COLUMNID  	columnidParentId;   	/* columnid for ParentId column in MSysObjects */
	JET_COLUMNID  	columnidObjectName; 	/* columnid for Name column in MSysObjects */
	JET_COLUMNID  	columnidObjectType; 	/* columnid for Type column in MSysObjects */
	JET_COLUMNID  	columnidObjectId;   	/* columnid for Id column in MSysObjects */
	JET_COLUMNID  	columnidCreate;	   		/* columnid for DateCreate column in MSysObjects */
	JET_COLUMNID  	columnidUpdate;		   	/* columnid for DateUpdate column in MSysObjects */
	JET_COLUMNID  	columnidFlags;	   		/* columnid for Flags column in MSysObjects */

	CheckPIB( ppib );
	CheckTable( ppib, pfucb );

	/* if OLCStats info/reset can be done now
	/**/
	if ( lInfoLevel == JET_TblInfoOLC )
		{
		FCB	*pfcb = pfucb->u.pfcb;
		
		if ( cbMax < sizeof(JET_OLCSTAT) )
			return JET_errBufferTooSmall;
		cbActual = sizeof(JET_OLCSTAT);
		memcpy( (BYTE *) pvResult, (BYTE * ) &pfcb->olcStat, sizeof( PERS_OLCSTAT ) );
		( (JET_OLCSTAT *) pvResult )->cpgCompactFreed = pfcb->cpgCompactFreed;
		return JET_errSuccess;
		}
	else if ( lInfoLevel == JET_TblInfoResetOLC )
		{
		pfucb->u.pfcb->cpgCompactFreed = 0;
		return JET_errSuccess;
		}
#ifndef NJETNT
	else if ( lInfoLevel == JET_TblInfoSpaceUsage )
		{
		err = ErrSPGetInfo( pfucb, pvResult, cbMax );
		return err;
		}
	else if ( lInfoLevel == JET_TblInfoDumpTable )
		{
#ifdef DEBUG
		err = ErrFILEDumpTable( ppib, pfucb->dbid, pfucb->u.pfcb->szFileName );
		return err;
#else
		return JET_errFeatureNotAvailable;
#endif
		}
#endif
		
	CallR( ErrFILEOpenTable( ppib, pfucb->dbid, &pfucbMSO, szSoTable, 0 ) );
	FUCBResetUpdatable( pfucbMSO );

	/* get columnids
	/**/
	Call( ErrFILEGetColumnId( ppib, pfucbMSO, szSoParentIdColumn, &columnidParentId ) );
	Call( ErrFILEGetColumnId( ppib, pfucbMSO, szSoObjectNameColumn, &columnidObjectName ) );
	Call( ErrFILEGetColumnId( ppib, pfucbMSO, szSoObjectTypeColumn, &columnidObjectType ) );
	Call( ErrFILEGetColumnId( ppib, pfucbMSO, szSoIdColumn, &columnidObjectId ) );
	Call( ErrFILEGetColumnId( ppib, pfucbMSO, szSoDateCreateColumn, &columnidCreate ) );
	Call( ErrFILEGetColumnId( ppib, pfucbMSO, szSoDateUpdateColumn, &columnidUpdate ) );
	Call( ErrFILEGetColumnId( ppib, pfucbMSO, szSoFlagsColumn, &columnidFlags ) );

	Call( ErrIsamSetCurrentIndex( ppib, pfucbMSO, szSoNameIndex ) );

	switch ( lInfoLevel )
		{
	case JET_TblInfo:
		/* check buffer size
		/**/
		if ( cbMax < sizeof(JET_OBJECTINFO) )
			{
			err = JET_errInvalidParameter;
			goto HandleError;
			}

		if ( FFCBTemporaryTable( pfucb->u.pfcb ) )
			{
			err = JET_errObjectNotFound;
			goto HandleError;
			}

		/* seek on made key ( ParentId = container id, Name = object name )
		/**/
		objidCtr = objidTblContainer;
		Call( ErrIsamMakeKey( ppib, pfucbMSO, (void *)&objidCtr,
			sizeof( objidCtr ), JET_bitNewKey ) );
		Call( ErrIsamMakeKey( ppib, pfucbMSO, pfucb->u.pfcb->szFileName,
			strlen( pfucb->u.pfcb->szFileName ), 0 ) );
		Call( ErrIsamSeek( ppib, pfucbMSO, JET_bitSeekEQ ) );

		/* set data to return
		/**/
		((JET_OBJECTINFO *)pvResult)->cbStruct = sizeof(JET_OBJECTINFO);

		Call( ErrIsamRetrieveColumn( ppib, pfucbMSO, columnidObjectType, (void *)&objtypObject,
			sizeof( objtypObject ), &cbActual, 0, NULL ) );
		Assert( cbActual == sizeof(objtypObject) );
		*((JET_OBJTYP *)&(((JET_OBJECTINFO *)pvResult)->objtyp)) =	(JET_OBJTYP) objtypObject;

		Call( ErrIsamRetrieveColumn( ppib, pfucbMSO, columnidCreate,
			(void *)&( ( JET_OBJECTINFO *)pvResult )->dtCreate,
			sizeof( JET_DATESERIAL ),
			&cbActual, 0, NULL ) );
		Assert( cbActual == sizeof( JET_DATESERIAL ) );

		Call( ErrIsamRetrieveColumn( ppib, pfucbMSO, columnidUpdate,
			(void *)&( ( JET_OBJECTINFO *)pvResult )->dtUpdate,
			sizeof(JET_DATESERIAL), &cbActual, 0, NULL ) );
		Assert( cbActual == sizeof( JET_DATESERIAL ) );

		Call( ErrIsamRetrieveColumn( ppib, pfucbMSO, columnidFlags,
			(void *)&((JET_OBJECTINFO *)pvResult )->flags,
			sizeof(JET_GRBIT), &cbActual, 0, NULL ) );
		if ( cbActual == 0 )
			((JET_OBJECTINFO *) pvResult)->flags = 0;

		/* UNDONE: Don't return updatable as appropriate with security/readonly */
		((JET_OBJECTINFO  *) pvResult)->grbit = JET_bitTableInfoBookmark;
		((JET_OBJECTINFO  *) pvResult)->grbit |= JET_bitTableInfoUpdatable | JET_bitTableInfoRollback;

		Call( ErrSTATSRetrieveTableStats( pfucb->ppib,
			pfucb->dbid,
			pfucb->u.pfcb->szFileName,
			&((JET_OBJECTINFO *)pvResult )->cRecord,
			NULL,
			&((JET_OBJECTINFO *)pvResult)->cPage ) );

		break;

	case JET_TblInfoRvt:
		err = JET_errQueryIsSnapshot;
		break;

	case JET_TblInfoName:
	case JET_TblInfoMostMany:
		//	UNDONE:	add support for most many
		if ( FFCBTemporaryTable( pfucb->u.pfcb ) )
			{
			err = JET_errInvalidOperation;
			goto HandleError;
			}
		if ( strlen( pfucb->u.pfcb->szFileName ) >= cbMax )
			err = JET_errBufferTooSmall;
		else
			{
			strcpy( pvResult, pfucb->u.pfcb->szFileName );
			}
		break;

	case JET_TblInfoDbid:
		if ( FFCBTemporaryTable( pfucb->u.pfcb ) )
			{
			err = JET_errInvalidOperation;
			goto HandleError;
			}
		/* check buffer size
		/**/
		if ( cbMax < sizeof(JET_DBID) + sizeof(JET_VDBID) )
			{
			err = JET_errInvalidParameter;
			goto HandleError;
			}
		else
			{
			DAB			*pdab = pfucb->ppib->pdabList;
			JET_DBID		dbid;

			//	UNDONE:	this is bogus, link FUCB to DAB
			for (; pdab->dbid != pfucb->dbid; pdab = pdab->pdabNext )
				;
			dbid = DbidOfVdbid( (JET_VDBID)pdab, &vdbfndefIsam );
			*(JET_DBID *)pvResult = dbid;
			*(JET_VDBID *)((char *)pvResult + sizeof(JET_DBID)) = (JET_VDBID)pdab;
			}
		break;

	default:
		err = JET_errInvalidParameter;
		}

HandleError:
	CallS( ErrFILECloseTable( ppib, pfucbMSO ) );
	if ( err == JET_errRecordNotFound )
		err = JET_errObjectNotFound;
	return err;
#else	/* !SYSTABLES */
	return JET_errFeatureNotAvailable;
#endif	/* !SYSTABLES */
	}



/*=================================================================
ErrIsamGetColumnInfo

Description: Returns information about all columns for the table named

Parameters:
			ppib					pointer to PIB for current session
			dbid					id of database containing the table
			szTableName			table name
			szColumnName		column name or NULL for all columns
			pout					output buffer
			lInfoLevel			level of information ( 0, 1, or 2 )

Return Value: JET_errSuccess

Errors/Warnings:

Side Effects:
=================================================================*/
	ERR VDBAPI
ErrIsamGetColumnInfo(
	JET_VSESID		vsesid, 				/* pointer to PIB for current session */
	JET_DBID  		vdbid, 					/* id of database containing the table */
	const char		*szTable, 				/* table name */
	const char		*szColumnName,   		/* column name or NULL for all columns */
	OLD_OUTDATA		*poutdata,				/* output buffer */
	unsigned long	lInfoLevel )	 		/* information level ( 0, 1, or 2 ) */
	{
	PIB				*ppib = (PIB *) vsesid;
	OUTLINE			*pout = (OUTLINE *) poutdata;
	ERR				err;
	DBID	 		dbid = DbidOfVDbid( vdbid );
	CHAR	 		szTableName[ ( JET_cbNameMost + 1 ) ];
	FUCB	 		*pfucb = NULL;

	CheckPIB( ppib );
	CheckDBID( ppib, ( DBID )dbid );

	CallR( ErrCheckName( szTableName, szTable, ( JET_cbNameMost + 1 ) ) );

	err = ErrFILEOpenTable( ppib, dbid, &pfucb, szTableName, 0 );
	if ( err >= 0 )
		{
		if ( lInfoLevel == 0 || lInfoLevel == 1 || lInfoLevel == 4
			|| FVDbidReadOnly( vdbid ) )
			{
			FUCBResetUpdatable( pfucb );
			}
		}

#ifdef	SYSTABLES
	if ( err == JET_errObjectNotFound )
		{
		ERR			err;
		OBJID			objid;
		JET_OBJTYP	objtyp;

		err = ErrFindObjidFromIdName( ppib, dbid, objidTblContainer, szTableName, &objid, &objtyp );

		if ( err >= JET_errSuccess )
			{
			if ( objtyp == JET_objtypQuery )
				return JET_errQueryNotSupported;
			if ( objtyp == JET_objtypLink )
				return JET_errLinkNotSupported;
			if ( objtyp == JET_objtypSQLLink )
				return JET_errSQLLinkNotSupported;
			}
		else
			return err;
		}

#endif	/* SYSTABLES */

	Call( ErrIsamGetTableColumnInfo( (JET_VSESID) ppib, (JET_VTID) pfucb,
		szColumnName, pout->pb, pout->cbMax, lInfoLevel ) );
	CallS( ErrFILECloseTable( ppib, pfucb ) );
HandleError:
	if ( err >= 0 )
		{
		pout->cbActual = ( (JET_COLUMNLIST *)pout->pb )->cbStruct;
		pout->cbReturned = ( pout->cbMax < pout->cbActual ) ?
			pout->cbMax: pout->cbActual;
		}
	return err;
	}


/*=================================================================
ErrIsamGetTableColumnInfo

Description: Returns column information for the table id passed

Parameters: ppib					pointer to PIB for the current session
				pfucb					pointer to FUCB for the table
				szColumnName		column name or NULL for all columns
				pout					output buffer
				lInfoLevel			level of information ( 0, 1, or 2 )

Return Value: JET_errSuccess

Errors/Warnings:

Side Effects:
=================================================================*/
	ERR VTAPI
ErrIsamGetTableColumnInfo(
	JET_VSESID		vsesid,				/* pointer to PIB for current session */
	JET_VTID			vtid, 				/* pointer to FUCB for the table */
	const char		*szColumn, 			/* column name or NULL for all columns */
	void				*pb,
	unsigned long	cbMax,
	unsigned long	lInfoLevel )		/* information level ( 0, 1, or 2 ) */
	{
	PIB		*ppib = ( PIB * ) vsesid;
	FUCB		*pfucb = ( FUCB * ) vtid;
	ERR		err;
	CHAR		szColumnName[ ( JET_cbNameMost + 1 ) ];
	OUTLINE	out;

	out.pb = pb;
	out.cbMax = cbMax;

	CheckPIB( ppib );
	CheckTable( ppib, pfucb );
	if ( szColumn == NULL || *szColumn == '\0' )
		*szColumnName = '\0';
	else
		CallR( ErrCheckName( szColumnName, szColumn, ( JET_cbNameMost + 1 ) ) );

	switch ( lInfoLevel )
		{
		case JET_ObjInfo:
			err = ErrInfoGetTableColumnInfo0( ppib, pfucb, szColumnName, &out );
			break;
		case JET_ObjInfoListNoStats:
		case JET_ObjInfoList:
			err = ErrInfoGetTableColumnInfo1( ppib, pfucb, szColumnName, &out );
			break;
		case JET_ObjInfoSysTabCursor:
#ifdef	SYSTABLES
			err = ErrInfoGetTableColumnInfo3( ppib, pfucb, szColumnName, &out );
#else	/* !SYSTABLES */
			err = JET_errFeatureNotAvailable;
#endif	/* !SYSTABLES */
			break;
		case JET_ObjInfoListACM:
			err = ErrInfoGetTableColumnInfo4( ppib, pfucb, szColumnName, &out );
			break;
		default:
			err = JET_errInvalidParameter;
		}

	return err;
	}


LOCAL ERR ErrInfoGetTableColumnInfo0( PIB *ppib, FUCB *pfucb, CHAR *szColumnName, OUTLINE *pout )
	{
	FID				fid;
	COLINFO			colinfo;

	pout->cbReturned = 0;

	if ( pout->cbMax < sizeof(JET_COLUMNDEF) || szColumnName == NULL )
		{
		return JET_errInvalidParameter;
		}

	fid = FidLookupColumn( pfucb, fidFixedLeast, szColumnName, &colinfo );

	if ( fid >= fidTaggedMost )
		{
		return JET_errColumnNotFound;
		}

	((JET_COLUMNDEF *)pout->pb)->cbStruct	= sizeof(JET_COLUMNDEF);
	((JET_COLUMNDEF *)pout->pb)->columnid	= colinfo.columnid;
	((JET_COLUMNDEF *)pout->pb)->coltyp		= colinfo.coltyp;
	((JET_COLUMNDEF *)pout->pb)->cbMax		= colinfo.cb;
	((JET_COLUMNDEF *)pout->pb)->grbit		= colinfo.grbit;
	((JET_COLUMNDEF *)pout->pb)->wCollate	= 0;
	//	UNDONE:	support these fields;
	((JET_COLUMNDEF *)pout->pb)->cp			= usEnglishCodePage;
	((JET_COLUMNDEF *)pout->pb)->wCountry	= 1;
	((JET_COLUMNDEF *)pout->pb)->langid		= 0x409;

	pout->cbActual   = sizeof(JET_COLUMNDEF);
	pout->cbReturned = sizeof(JET_COLUMNDEF);
	return JET_errSuccess;
	}


LOCAL ERR ErrInfoGetTableColumnInfo1( PIB *ppib, FUCB *pfucb, CHAR *szColumnName, OUTLINE *pout )
	{
#ifdef	DISPATCHING
	ERR				err;
	JET_TABLEID		tableid;
	JET_COLUMNID	rgcolumnid[ccolumndefGetColumnsMax];

#if 0
	FUCB				*pfucbMSC = pfucbNil;
	JET_TABLEID		tableidMSC;
	CPCOL				rgcpcol[ccolumndefGetColumnsMax];
	INT				icpcol;
	LINE				line;
#endif

	BYTE				*pbColumnName;
	ULONG				cbColumnName;
	BYTE				*pbColumnId;
	ULONG				cbColumnId;
	BYTE				*pbColumnType;
	ULONG				cbColumnType;
	BYTE				*pbColumnSize;
	ULONG				cbColumnSize;
	BYTE				*pbColumnGrbit;
	ULONG				cbColumnGrbit;
	BYTE				*pbTableName;
	ULONG				cbTableName;

	FID				fid;
	COLINFO			colinfo;

	//	UNDONE:	support these fields;
	WORD 				cp			= usEnglishCodePage;
	WORD				wCountry	= 1;
	LANGID	 		langid  	= 0x409;
	WORD				iCollate = JET_sortEFGPI;

	long				cRows = 0;

	/*	initialize variables
	/**/
	pout->cbReturned = 0;
	if ( pout->cbMax < sizeof(JET_COLUMNLIST) )
		{
		return JET_errInvalidParameter;
		}

	/*	create temporary table
	/**/
	CallR( ErrIsamOpenTempTable( (JET_SESID)ppib,
		(JET_COLUMNDEF *) rgcolumndefGetColumns,
		ccolumndefGetColumnsMax,
		JET_bitTTScrollable | JET_bitTTScrollable,
		&tableid,
		rgcolumnid ) );

#if 0
	/*	for base tables, inspect MSysColumns.  For sorts, inspect
	/*	directory structures.
	/**/
	if ( FFUCBIndex( pfucb ) )
		{
		ULONG		ulPgnoFDP = pfucb->u.pfcb->pgnoFDP;

		Call( ErrFILEOpenTable( ppib, pfucb->dbid, &pfucbMSC, szScTable, 0 ) );
		Call( ErrIsamSetCurrentIndex( ppib, pfucbMSC, szScObjectIdNameIndex ) );

		/*	seek to first row in MSC for given table, and set index range
		/*	within current range.  Copy records to result table and close
		/*	MSC table cursor.
		/**/
		Call( ErrIsamMakeKey( ppib, pfucbMSC, (void *)&ulPgnoFDP, sizeof( ulPgnoFDP ), JET_bitNewKey ) );
		Call( ErrIsamSeek( ppib, pfucbMSC, JET_bitSeekGE ) );
		Call( ErrIsamSetIndexRange( ppib, pfucbMSC, JET_bitRangeInclusive | JET_bitRangeUpperLimit ) );

		/*	setup copy column structure.  Source column ids must correspond
		/*	to temporary table column order.
		/**/
		for( icpcol = 0; icpcol < ccolumndefGetColumnsMax; icpcol++ )
			rgcpcol[icpcol].columnidDest = rgcolumnid[icpcol];
		Call( ErrFILEGetColumnId( ppib, pfucb, szScPresentationOrder, &rgcpcol[].columnidSrc ) );
		Call( ErrFILEGetColumnId( ppib, pfucb, szScName, &rgcpcol[].columnidSrc ) );
		Call( ErrFILEGetColumnId( ppib, pfucb, szScId, &rgcpcol[].columnidSrc ) );
		Call( ErrFILEGetColumnId( ppib, pfucb, szScType, &rgcpcol[].columnidSrc ) );
		Call( ErrFILEGetColumnId( ppib, pfucb, szScCountry, &rgcpcol[].columnidSrc ) );
		Call( ErrFILEGetColumnId( ppib, pfucb, szScLanguageId, &rgcpcol[].columnidSrc ) );
		Call( ErrFILEGetColumnId( ppib, pfucb, szScCp, &rgcpcol[].columnidSrc ) );
		Call( ErrFILEGetColumnId( ppib, pfucb, szScCollate, &rgcpcol[].columnidSrc ) );
		Call( ErrFILEGetColumnId( ppib, pfucb, szScSize, &rgcpcol[].columnidSrc ) );
		Call( ErrFILEGetColumnId( ppib, pfucb, szScGrbit, &rgcpcol[].columnidSrc ) );
		Call( ErrFILEGetColumnId( ppib, pfucb, szScDefault, &rgcpcol[].columnidSrc ) );
		Call( ErrFILEGetColumnId( ppib, pfucb, szScTableName, &rgcpcol[].columnidSrc ) );
		Call( ErrFILEGetColumnId( ppib, pfucb, szScColumnName, &rgcpcol[].columnidSrc ) );

		/*	allocate tableid for copy records
		/**/
		FUCBSetSystemTable( pfucbMSC );
		Call( ErrAllocateTableid( &tableidMSC, (JET_VTID)pfucbMSC, &vtfndefIsamInfo ) );
		err = ErrIsamCopyRecords( ppib, tableidMSC, tableid, rgcpcol, ccolumndefGetColumnsMax, JET_MoveLast );
		ReleaseTableid( tableidMSC );
		Call( err );

		/*	close MSC table
		/**/
		CallS( ErrFILECloseTable( ppib, pfucbMSC ) );
		pfucbMSC = pfucbNil;
		}
	else
#endif
		{
		/*	set length later
		/**/
		cbColumnName = 0;
		pbColumnName = colinfo.szName;

		cbColumnId = sizeof( colinfo.columnid );
		pbColumnId = (BYTE *) &colinfo.columnid;

		cbColumnType = sizeof( colinfo.coltyp );
		pbColumnType = (BYTE *) &colinfo.coltyp;

		cbColumnSize = sizeof( colinfo.cb );
		pbColumnSize = (BYTE *) &colinfo.cb;

		cbColumnGrbit = sizeof( colinfo.grbit );
		pbColumnGrbit = (BYTE *) &colinfo.grbit;

		cbTableName = strlen( pfucb->u.pfcb->szFileName );
		pbTableName = pfucb->u.pfcb->szFileName;

		for ( fid = fidFixedLeast; fid < fidTaggedMost; fid++ )
			{
			fid = FidLookupColumn( pfucb, fid, NULL, &colinfo );

			if ( fid >= fidTaggedMost )
				break;

			cbColumnName = strlen( colinfo.szName );

			Call( ErrDispPrepareUpdate( (JET_SESID)ppib, tableid, JET_prepInsert ) );

			//	UNDONE:	clean this up
			/*	get presentation order for this column and set in
			/*	output table.  For temp tables, no order will be available.
			/**/
			{
			OUTLINE		out;
			JET_TABLEID	tableidInfo;
			out.pb = (BYTE *)&tableidInfo;
			out.cbMax = sizeof(tableidInfo);
			err = ErrInfoGetTableColumnInfo3( ppib, pfucb, colinfo.szName, &out );
			if ( err == JET_errSuccess )
				{
				LONG	l;
				LONG	cbT;

				Call( ErrDispRetrieveColumn( (JET_SESID)ppib, tableidInfo, 11L, &l, sizeof(l), &cbT, 0, NULL ) );
				Call( ErrDispSetColumn( (JET_SESID)ppib, tableid, rgcolumnid[iColumnPOrder], &l, sizeof(l), 0, NULL ) );
				CallS( ErrDispCloseTable( (JET_SESID)ppib, tableidInfo ) );
				}
			}

			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iColumnName], pbColumnName,
				cbColumnName, 0 , NULL ) );
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iColumnId], pbColumnId,
				cbColumnId, 0 , NULL ) );
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iColumnType], pbColumnType,
				cbColumnType, 0 , NULL ) );
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iColumnSize], pbColumnSize,
				cbColumnSize, 0 , NULL ) );
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iColumnGrbit], pbColumnGrbit,
				cbColumnGrbit, 0 , NULL ) );
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iColumnTableName], pbTableName,
				cbTableName, 0 , NULL ) );
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iColumnColumnName], pbColumnName,
				cbColumnName, 0 , NULL ) );

			//	UNDONE:	support these columns
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iColumnCountry], &wCountry,
				sizeof( wCountry ), 0 , NULL ) );
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iColumnLangid], &langid,
				sizeof( langid ), 0 , NULL ) );
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iColumnCp], &cp,
				sizeof( cp ), 0 , NULL ) );
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iColumnCollate], &iCollate,
				sizeof(iCollate), 0 , NULL ) );

			Call( ErrDispUpdate( (JET_SESID)ppib, tableid, NULL, 0, NULL ) );
			cRows++;
			}
		}

	/*	move temporary table cursor to first row and return column list
	/**/
	err = ErrDispMove( (JET_SESID)ppib, tableid, JET_MoveFirst, 0 );
	if ( err < 0  )
		{
		if ( err != JET_errNoCurrentRecord )
			goto HandleError;
		err = JET_errSuccess;
		}

	((JET_COLUMNLIST *)pout->pb)->cbStruct = sizeof(JET_COLUMNLIST);
	((JET_COLUMNLIST *)pout->pb)->tableid = tableid;
	((JET_COLUMNLIST *)pout->pb)->cRecord = cRows;
	((JET_COLUMNLIST *)pout->pb)->columnidPresentationOrder =
	 rgcolumnid[iColumnPOrder];
	((JET_COLUMNLIST *)pout->pb)->columnidcolumnname =
	 rgcolumnid[iColumnName];
	((JET_COLUMNLIST *)pout->pb)->columnidcolumnid =
	 rgcolumnid[iColumnId];
	((JET_COLUMNLIST *)pout->pb)->columnidcoltyp =
	 rgcolumnid[iColumnType];
	((JET_COLUMNLIST *)pout->pb)->columnidCountry =
	 rgcolumnid[iColumnCountry];
	((JET_COLUMNLIST *)pout->pb)->columnidLangid =
	 rgcolumnid[iColumnLangid];
	((JET_COLUMNLIST *)pout->pb)->columnidCp =
	 rgcolumnid[iColumnCp];
	((JET_COLUMNLIST *)pout->pb)->columnidCollate =
	 rgcolumnid[iColumnCollate];
	((JET_COLUMNLIST *)pout->pb)->columnidcbMax =
	 rgcolumnid[iColumnSize];
	((JET_COLUMNLIST *)pout->pb)->columnidgrbit =
	 rgcolumnid[iColumnGrbit];
	((JET_COLUMNLIST *)pout->pb)->columnidDefault =
	 rgcolumnid[iColumnDefault];
	((JET_COLUMNLIST *)pout->pb)->columnidBaseTableName =
	 rgcolumnid[iColumnTableName];
	((JET_COLUMNLIST *)pout->pb)->columnidBaseColumnName =
		rgcolumnid[iColumnColumnName];
 	((JET_COLUMNLIST *)pout->pb)->columnidDefinitionName =
	 rgcolumnid[iColumnName];

	pout->cbActual   = sizeof(JET_COLUMNLIST);
	pout->cbReturned = sizeof(JET_COLUMNLIST);
	return JET_errSuccess;

HandleError:
#if 0
	if ( pfucbMSC != pfucbNil )
		CassS( ErrFILECloseTable( ppib, pfucbMSC ) );
#endif
	(VOID)ErrDispCloseTable( (JET_SESID)ppib, tableid );
	return err;
#else	/* !DISPATCHING */
	return JET_errFeatureNotAvailable;
#endif	/* !DISPATCHING */
	}


#ifdef	SYSTABLES

	LOCAL ERR
ErrInfoGetTableColumnInfo3( PIB *ppib,
	FUCB 		*pfucb,
	CHAR 		*szColumnName,
	OUTLINE 	*pout )
	{
	ERR		err;
	ULONG		ulPgnoFDP = pfucb->u.pfcb->pgnoFDP;
	FUCB		*pfucbMSC;
#ifdef	DISPATCHING
	JET_TABLEID	tableid;
#endif	/* DISPATCHING */

	if ( szColumnName == NULL || pout->cbMax < sizeof(JET_TABLEID) )
		{
		return JET_errInvalidParameter;
		}

	CallR( ErrFILEOpenTable( ppib, pfucb->dbid, &pfucbMSC, szScTable, 0 ) );
	Call( ErrIsamSetCurrentIndex( ppib, pfucbMSC, szScObjectIdNameIndex ) );

	Call( ErrIsamMakeKey( ppib, pfucbMSC, (void *)&ulPgnoFDP, sizeof( ulPgnoFDP ), JET_bitNewKey ) );
	Call( ErrIsamMakeKey( ppib, pfucbMSC, szColumnName, strlen( szColumnName ), 0 ) );
	Call( ErrIsamSeek( ppib, pfucbMSC, JET_bitSeekEQ ) );
	FUCBSetSystemTable( pfucbMSC );

#ifdef	DISPATCHING
	Call( ErrAllocateTableid( &tableid, ( JET_VTID )pfucbMSC, &vtfndefIsamInfo ) );
	pfucbMSC->fVtid = fTrue;
	*(JET_TABLEID *)(pout->pb) = tableid;
	pout->cbReturned = sizeof(tableid);
	pout->cbActual   = sizeof(tableid);
#else	/* !DISPATCHING */
	*( FUCB * *)( pout->pb ) = pfucbMSC;
	pout->cbReturned = sizeof(pfucbMSC);
	pout->cbActual   = sizeof(pfucbMSC);
#endif	/* !DISPATCHING */
	return JET_errSuccess;

HandleError:
	CallS( ErrFILECloseTable( ppib, pfucbMSC ) );
	if ( err == JET_errRecordNotFound )
		err = JET_errColumnNotFound;
	return err;
	}

#endif	/* SYSTABLES */


	LOCAL ERR
ErrInfoGetTableColumnInfo4( PIB *ppib, FUCB *pfucb, CHAR *szColumnName,
	OUTLINE *pout )
	{
	FID				fid;
	COLINFO			colinfo;

	pout->cbActual   = sizeof(JET_COLUMNBASE);
	pout->cbReturned = 0;

	if ( pout->cbMax < sizeof(JET_COLUMNBASE) || szColumnName == NULL )
		{
		pout->cbReturned = 0;
		return JET_errInvalidParameter;
		}

	fid = FidLookupColumn( pfucb, fidFixedLeast, szColumnName, &colinfo );

	if ( fid >= fidTaggedMost )
		{
		return JET_errColumnNotFound;
		}

	((JET_COLUMNBASE *)pout->pb)->cbStruct		= sizeof(JET_COLUMNBASE);
	((JET_COLUMNBASE *)pout->pb)->columnid		= colinfo.columnid;
	((JET_COLUMNBASE *)pout->pb)->coltyp		= colinfo.coltyp;
	((JET_COLUMNBASE *)pout->pb)->wFiller		= 0;
	((JET_COLUMNBASE *)pout->pb)->cbMax			= colinfo.cb;
	((JET_COLUMNBASE *)pout->pb)->grbit			= colinfo.grbit;
	strcpy( ( ( JET_COLUMNBASE *)pout->pb )->szBaseTableName, pfucb->u.pfcb->szFileName );
	strcpy( ( ( JET_COLUMNBASE *)pout->pb )->szBaseColumnName, szColumnName );
	//	UNDONE:	support these fields;
	((JET_COLUMNBASE *)pout->pb)->wCountry		= 1;
	((JET_COLUMNBASE *)pout->pb)->langid  		= 0x409;
	((JET_COLUMNBASE *)pout->pb)->cp				= usEnglishCodePage;

	pout->cbReturned = sizeof(JET_COLUMNBASE);
	return JET_errSuccess;
	}





/*=================================================================
ErrIsamGetIndexInfo

Description: Returns a temporary file containing index definition

Parameters:	ppib					pointer to PIB for the current session
				dbid					id of database containing the table
				szTableName	 		name of table owning the index
				szIndexName	 		index name
				pout					output buffer
				lInfoLevel	 		level of information ( 0, 1, or 2 )

Return Value: JET_errSuccess

Errors/Warnings:

Side Effects:
=================================================================*/
	ERR VDBAPI
ErrIsamGetIndexInfo(
	JET_VSESID		vsesid,					/* pointer to PIB for current session */
	JET_DBID			vdbid, 	 				/* id of database containing table */
	const char		*szTable, 				/* name of table owning the index */
	const char		*szIndexName, 			/* index name */
	OLD_OUTDATA		*poutdata,				/* output buffer */
	unsigned long	lInfoLevel ) 			/* information level ( 0, 1, or 2 ) */
	{
	PIB				*ppib = (PIB *) vsesid;
	OUTLINE			*pout = (OUTLINE *) poutdata;

	ERR			err;
	DBID			dbid = DbidOfVDbid( vdbid );
	CHAR			szTableName[ ( JET_cbNameMost + 1 ) ];
	FUCB 			*pfucb;

	CheckPIB( ppib );
	CheckDBID( ppib, ( DBID )dbid );
	CallR( ErrCheckName( szTableName, szTable, ( JET_cbNameMost + 1 ) ) );

	CallR( ErrFILEOpenTable( ppib, dbid, &pfucb, szTableName, 0 ) );
	if ( lInfoLevel == 0 || lInfoLevel == 1 || FVDbidReadOnly( vdbid ) )
		FUCBResetUpdatable( pfucb );
	err = ErrIsamGetTableIndexInfo( (JET_VSESID) ppib, (JET_VTID) pfucb,
		szIndexName, pout->pb, pout->cbMax, lInfoLevel );

	CallS( ErrFILECloseTable( ppib, pfucb ) );
	return err;
	}


/*=================================================================
ErrIsamGetTableIndexInfo

Description: Returns a temporary table containing the index definition

Parameters:	ppib					pointer to PIB for the current session
				pfucb					FUCB for table owning the index
				szIndexName			index name
				pout					output buffer
				lInfoLevel			level of information ( 0, 1, or 2 )

Return Value: JET_errSuccess

Errors/Warnings:

Side Effects:
=================================================================*/
	ERR VTAPI
ErrIsamGetTableIndexInfo(
	JET_VSESID		vsesid,					/* pointer to PIB for current session */
	JET_VTID			vtid, 					/* FUCB for the table owning the index */
	const char		*szIndex, 				/* index name */
	void				*pb,
	unsigned long	cbMax,
	unsigned long	lInfoLevel )			/* information level ( 0, 1, or 2 ) */
	{
	PIB		*ppib = (PIB *) vsesid;
	FUCB		*pfucb = (FUCB *) vtid;
	ERR		err;
	CHAR		szIndexName[ ( JET_cbNameMost + 1 ) ];
	OUTLINE	out;

	/* Validate the arguments */
	CheckPIB( ppib );
	CheckTable( ppib, pfucb );
	if ( szIndex == NULL || *szIndex == '\0' )
		*szIndexName = '\0';
	else
		CallR( ErrCheckName( szIndexName, szIndex, ( JET_cbNameMost + 1 ) ) );

	out.pb = pb;
	out.cbMax = cbMax;
	out.cbReturned = 0;

	switch ( lInfoLevel )
		{
		case JET_IdxInfo:
		case JET_IdxInfoList:
		case JET_IdxInfoOLC:
			err = ErrInfoGetTableIndexInfo01( ppib, pfucb, szIndexName, &out, lInfoLevel );
			break;
		case JET_IdxInfoSysTabCursor:
#ifdef	SYSTABLES
			err = ErrInfoGetTableIndexInfo2( ppib, pfucb, szIndexName, &out );
#else	/* !SYSTABLES */
			err = JET_errFeatureNotAvailable;
#endif	/* !SYSTABLES */
			break;
		default:
			return JET_errInvalidParameter;
		}

	return err;
	}


LOCAL ERR ErrInfoGetTableIndexInfo01( PIB *ppib,
	FUCB 		*pfucb,
	CHAR 		*szIndexName,
	OUTLINE 	*pout,
	LONG 		lInfoLevel )
	{
#ifdef	DISPATCHING
	ERR		err;						/* return code from internal functions */
	FCB		*pfcb;			  		/* file control block for the index */
	IDB		*pidb;			  		/* current index control block */
	FDB		*pfdb;			  		/* field descriptor block for column */
	FID		fid;						/* column id */
	FIELD		*pfield;			  		/* pointer to current field definition */
	IDXSEG	*rgidxseg;				/* pointer to current index key defintion */

	long		cRecord;					/* number of index entries */
	long		cKey;						/* number of unique index entries */
	long		cPage;					/* number of pages in the index */
	long		cRows;					/* number of index definition records */
	long		cColumn;					/* number of columns in current index */
	long		iidxseg;					/* segment number of current column */

	JET_TABLEID		tableid;			/* table id for the VT */
	JET_COLUMNID	columnid;		/* column id of the current column */
	JET_GRBIT		grbit;			/* flags for the current index */
	JET_GRBIT		grbitColumn;	/* flags for the current column */
	JET_COLUMNID	rgcolumnid[ccolumndefGetIndexMax];

	//	UNDONE:	support these fields;
	WORD				wCountry	= 1;
	LANGID			langid  	= 0x409;
	WORD 				cp			= usEnglishCodePage;
	WORD				iCollate = JET_sortEFGPI;

	/* Initialize the return value */
	pout->cbActual   = sizeof(JET_INDEXLIST);
	pout->cbReturned = 0;

	/* Return nothing if the buffer is too small */
	if ( pout->cbMax < sizeof(JET_INDEXLIST) )
		return JET_wrnBufferTruncated;

	/* Set the pointer to the field definitions for the table */
	pfdb = (FDB *)pfucb->u.pfcb->pfdb;

	/* Locate the FCB for the specified index ( clustered index if null name ) */
	for ( pfcb = pfucb->u.pfcb; pfcb != pfcbNil; pfcb = pfcb->pfcbNextIndex )
		if ( pfcb->pidb != pidbNil && ( *szIndexName == '\0' ||
			SysCmpText( szIndexName, pfcb->pidb->szName ) == 0 ) )
			break;

	if ( pfcb == pfcbNil && *szIndexName != '\0' )
		return JET_errIndexNotFound;

	/* if OLCStats info/reset, we can do it now
	/**/
	if ( lInfoLevel == JET_IdxInfoOLC )
		{
		if ( pout->cbMax < sizeof(JET_OLCSTAT) )
			return JET_errBufferTooSmall;
		pout->cbReturned = sizeof(JET_OLCSTAT);
		memcpy( (BYTE *) pout->pb, (BYTE * ) &pfcb->olcStat, sizeof( PERS_OLCSTAT ) );
		( (JET_OLCSTAT *) pout )->cpgCompactFreed = pfcb->cpgCompactFreed;
		return JET_errSuccess;
		}
	if ( lInfoLevel == JET_IdxInfoResetOLC )
		{
		pfcb->cpgCompactFreed = 0;
		return JET_errSuccess;
		}
	
	/* Open the temporary table ( fills in the column ids in rgcolumndef )
	/**/
	CallR( ErrIsamOpenTempTable( (JET_SESID)ppib,
		(JET_COLUMNDEF *) rgcolumndefGetIndex,
		ccolumndefGetIndexMax,
		JET_bitTTScrollable | JET_bitTTScrollable,
		&tableid,
		rgcolumnid ) );

	cRows = 0;

	/* As long as there is a valid index, add its definition to the VT */
	while ( pfcb != pfcbNil )
		{
		pidb 	= pfcb->pidb;					/* point to the IDB for the index */
		cColumn	= pidb->iidxsegMac;		/* get number of columns in the key */

		/* set the index flags
		/**/
		grbit  = ( pfcb == pfucb->u.pfcb ) ? JET_bitIndexClustered: 0;
#ifndef JETSER
		grbit |= ( pidb->fidb & fidbPrimary ) ? JET_bitIndexPrimary: 0;
#endif
		grbit |= ( pidb->fidb & fidbUnique ) ? JET_bitIndexUnique: 0;
		grbit |= ( pidb->fidb & fidbNoNullSeg ) ? JET_bitIndexDisallowNull: 0;
		if ( !( pidb->fidb & fidbNoNullSeg ) )
			{
			grbit |= ( pidb->fidb & fidbAllowAllNulls ) ? 0: JET_bitIndexIgnoreNull;
			grbit |= ( pidb->fidb & fidbAllowSomeNulls ) ? 0: JET_bitIndexIgnoreAnyNull;
			}

		/* Process each column in the index key
		/**/
		for ( iidxseg = 0; iidxseg < cColumn; iidxseg++ )
			{
			Call( ErrDispPrepareUpdate( (JET_SESID)ppib, tableid, JET_prepInsert ) );

			/* index name
			/**/
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iIndexName], pidb->szName, strlen( pidb->szName ),
				0, NULL ) );

			/* index flags
			/**/
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iIndexGrbit], &grbit, sizeof( grbit ), 0, NULL ) );

			/* get statistics
			/**/
			Call( ErrSTATSRetrieveIndexStats( pfucb, pidb->szName, &cRecord, &cKey, &cPage ) );
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iIndexCKey], &cKey, sizeof( cKey ), 0, NULL ) );
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iIndexCEntry], &cRecord, sizeof( cRecord ), 0, NULL ) );
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iIndexCPage], &cPage, sizeof( cPage ), 0, NULL ) );

			/* number of key columns
			/**/
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iIndexCCol], &cColumn, sizeof( cColumn ), 0, NULL ) );

 			/* column number within key
			/* required by CLI and JET spec
			/**/
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iIndexICol], &iidxseg, sizeof( iidxseg ), 0, NULL ) );

			/* get the column id and ascending/descending flag
			/**/
			rgidxseg = pidb->rgidxseg;
			if ( rgidxseg[iidxseg] < 0 )
				{
				grbitColumn = JET_bitKeyDescending;
				fid = -rgidxseg[iidxseg];
				}
			else
				{
				grbitColumn = JET_bitKeyAscending;
				fid = rgidxseg[iidxseg];
				}

			/* column id
			/**/
			columnid  = fid;
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iIndexColId], &columnid, sizeof( columnid ),
				0, NULL ) );

			/* Set the pointer to the column definition
			/**/
			if ( fid < fidFixedMost )
				{
				pfield = pfdb->pfieldFixed + ( fid - fidFixedLeast );
				}
			else if ( fid < fidVarMost )
				{
				pfield = pfdb->pfieldVar + ( fid - fidVarLeast );
				}
			else
				{
				pfield = pfdb->pfieldTagged + ( fid - fidTaggedLeast );
				}

			/* column type
			/**/
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iIndexColType], &pfield->coltyp, sizeof( pfield->coltyp ), 0, NULL ) );

			/* Country
			/**/
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iIndexCountry], &wCountry, sizeof(wCountry), 0, NULL ) );

			/* Langid
			/**/
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iIndexLangid], &langid, sizeof(langid), 0, NULL ) );

			/* Cp
			/**/
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iIndexCp], &cp, sizeof(cp), 0, NULL ) );

			/* Collate
			/**/
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iIndexCollate], &iCollate, sizeof(iCollate), 0, NULL ) );

			/* column flags
			/**/
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iIndexColBits], &grbitColumn,
				sizeof( grbitColumn ), 0, NULL ) );

			/* column name
			/**/
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iIndexColName], pfield->szFieldName,
				strlen( pfield->szFieldName ), 0, NULL ) );

			Call( ErrDispUpdate( (JET_SESID)ppib, tableid, NULL, 0, NULL ) );

			/* count the number of VT rows
			/**/
			cRows++;
			}

		/* Quit if an index name was specified; otherwise do the next index
		/**/
		if ( *szIndexName != '\0' )
			break;
		else
			pfcb = pfcb->pfcbNextIndex;
		}

	/* Position to the first entry in the VT ( ignore error if no rows ) */
	err = ErrDispMove( (JET_SESID)ppib, tableid, JET_MoveFirst, 0 );
	if ( err < 0  )
		{
		if ( err != JET_errNoCurrentRecord )
			goto HandleError;
		err = JET_errSuccess;
		}

	/* Set up the return structure */
	((JET_INDEXLIST *)pout->pb)->cbStruct = sizeof(JET_INDEXLIST);
	((JET_INDEXLIST *)pout->pb)->tableid = tableid;
	((JET_INDEXLIST *)pout->pb)->cRecord = cRows;
	((JET_INDEXLIST *)pout->pb)->columnidindexname =
	 rgcolumnid[iIndexName];
	((JET_INDEXLIST *)pout->pb)->columnidgrbitIndex =
	 rgcolumnid[iIndexGrbit];
	((JET_INDEXLIST *)pout->pb)->columnidcEntry =
	 rgcolumnid[iIndexCEntry];
	((JET_INDEXLIST *)pout->pb)->columnidcKey =
	 rgcolumnid[iIndexCKey];
	((JET_INDEXLIST *)pout->pb)->columnidcPage =
	 rgcolumnid[iIndexCPage];
	((JET_INDEXLIST *)pout->pb)->columnidcColumn =
	 rgcolumnid[iIndexCCol];
	((JET_INDEXLIST *)pout->pb)->columnidiColumn =
	 rgcolumnid[iIndexICol];
	((JET_INDEXLIST *)pout->pb)->columnidcolumnid =
	 rgcolumnid[iIndexColId];
	((JET_INDEXLIST *)pout->pb)->columnidcoltyp =
	 rgcolumnid[iIndexColType];
	((JET_INDEXLIST *)pout->pb)->columnidCountry =
	 rgcolumnid[iIndexCountry];
	((JET_INDEXLIST *)pout->pb)->columnidLangid =
	 rgcolumnid[iIndexLangid];
	((JET_INDEXLIST *)pout->pb)->columnidCp =
	 rgcolumnid[iIndexCp];
	((JET_INDEXLIST *)pout->pb)->columnidCollate =
	 rgcolumnid[iIndexCollate];
	((JET_INDEXLIST *)pout->pb)->columnidgrbitColumn =
	 rgcolumnid[iIndexColBits];
	((JET_INDEXLIST *)pout->pb)->columnidcolumnname =
		rgcolumnid[iIndexColName];

	pout->cbReturned = sizeof(JET_INDEXLIST);

	return JET_errSuccess;

HandleError:
	(VOID)ErrDispCloseTable( (JET_SESID)ppib, tableid );
	return err;
#else	/* !DISPATCHING */
	return JET_errFeatureNotAvailable;
#endif	/* !DISPATCHING */
	}


#ifdef	SYSTABLES

	LOCAL ERR
ErrInfoGetTableIndexInfo2( PIB *ppib, FUCB *pfucb, CHAR *szIndexName,
	OUTLINE *pout )
	{
	ERR			err;
	ULONG			ulPgnoFDP = pfucb->u.pfcb->pgnoFDP;
	FUCB			*pfucbMSI;
#ifdef	DISPATCHING
	JET_TABLEID	tableid;
#endif	/* DISPATCHING */

	if ( *szIndexName == '\0' || pout->cbMax < sizeof(JET_TABLEID) )
		{
		return JET_errInvalidParameter;
		}

	CallR( ErrFILEOpenTable( ppib, pfucb->dbid, &pfucbMSI, szSiTable, 0 ) );
	Call( ErrIsamSetCurrentIndex( ppib, pfucbMSI, szSiObjectIdNameIndex ) );

	Call( ErrIsamMakeKey( ppib, pfucbMSI, (void *)&ulPgnoFDP, sizeof( ulPgnoFDP ), JET_bitNewKey ) );
	Call( ErrIsamMakeKey( ppib, pfucbMSI, szIndexName, strlen( szIndexName ), 0 ) );
	Call( ErrIsamSeek( ppib, pfucbMSI, JET_bitSeekEQ ) );

	FUCBSetSystemTable( pfucbMSI );

#ifdef	DISPATCHING
	Call( ErrAllocateTableid( &tableid, ( JET_VTID )pfucbMSI, &vtfndefIsamInfo ) );
	pfucbMSI->fVtid = fTrue;
	*(JET_TABLEID *)(pout->pb) = tableid;
	pout->cbReturned = sizeof(tableid);
	pout->cbActual   = sizeof(tableid);
#else	/* !DISPATCHING */
	*(FUCB **)( pout->pb ) = pfucbMSI;
	pout->cbReturned = sizeof(pfucbMSI);
	pout->cbActual   = sizeof(pfucbMSI);
#endif	/* !DISPATCHING */

	return JET_errSuccess;

HandleError:
	if ( err == JET_errRecordNotFound )
		err = JET_errIndexNotFound;
	CallS( ErrFILECloseTable( ppib, pfucbMSI ) );
	return err;
	}

#endif	/* SYSTABLES */


ERR VDBAPI ErrIsamGetDatabaseInfo(
	JET_VSESID		vsesid,
	JET_DBID			vdbid,
	void 				*pv,
	unsigned long	cbMax,
	unsigned long	ulInfoLevel )
	{
	PIB			*ppib = (PIB *) vsesid;
	ERR			err;
	DBID			dbid = DbidOfVDbid( vdbid );

	//	UNDONE:	support these fields;
	WORD 			cp			= usEnglishCodePage;
	WORD			wCountry	= 1;
	LANGID		langid  	= 0x409;
	WORD			iCollate = JET_sortEFGPI;

	CheckPIB( ppib );
	
	// If cbMax != 0, then pv mustn't be NULL
	Assert ( cbMax == 0 || pv != NULL );

	/*	returns database name and connect string given dbid
	/**/
	SgSemRequest( semST );

	if ( rgfmp[dbid].szDatabaseName == NULL )
		{
		err = JET_errInvalidParameter;
		goto HandleError;
		}

	switch ( ulInfoLevel )
		{
      case JET_DbInfoFilename:
			{
			if ( strlen( rgfmp[dbid].szDatabaseName ) + 1UL > cbMax )
				{
				err = JET_errBufferTooSmall;
				goto HandleError;
				}
			strcpy( (CHAR  *)pv, rgfmp[dbid].szDatabaseName );
			break;
			}
      case JET_DbInfoConnect:
			{
			//	UNDONE:	support this parameter
			if ( 1UL > cbMax )
				{
				err = JET_errBufferTooSmall;
				goto HandleError;
				}
			*(CHAR *)pv = '\0';
			break;
			}
      case JET_DbInfoCountry:
			{
			 if ( cbMax != sizeof(long) )
			    return JET_errInvalidBufferSize;
			*(long  *)pv = wCountry;
			break;
			}
      case JET_DbInfoLangid:
			{
			if ( cbMax != sizeof(long) )
	  			return JET_errInvalidBufferSize;
			*(long  *)pv = langid;
			break;
			}
      case JET_DbInfoCp:
			{
			if ( cbMax != sizeof(long) )
				return JET_errInvalidBufferSize;
			*(long  *)pv = cp;
			break;
			}
      case JET_DbInfoCollate:
			{
	 		/* Check the buffer size */
	 		if ( cbMax != sizeof(long) )
	    		return JET_errInvalidBufferSize;
     		*(long *)pv = iCollate;
     		break;
			}
      case JET_DbInfoOptions:
			{
	 		/* check the buffer size
			/**/
	 		if ( cbMax != sizeof(JET_GRBIT) )
	    		return JET_errInvalidBufferSize;

			/* return the open options for the current database
			/**/
			*(JET_GRBIT *)pv = ((VDBID)vdbid)->grbit;
     		break;
			}
      case JET_DbInfoTransactions:
			{
	 		/* Check the buffer size */
	 		if ( cbMax != sizeof(long) )
	    		return JET_errInvalidBufferSize;

			*(long*)pv = levelUserMost;
     		break;
			}
      case JET_DbInfoVersion:
			{
	 		/* Check the buffer size */
	 		if ( cbMax != sizeof(long) )
	    		return JET_errInvalidBufferSize;

			*(long*)pv = JET_DbVersion20;
     		break;
			}
      case JET_DbInfoIsam:
			{
	 		/* Check the buffer size */
	 		if ( cbMax != sizeof(long) + sizeof(long) )
	    		return JET_errInvalidBufferSize;
     		*(long *)pv = JET_IsamBuiltinBlue;
     		*( (long *)pv + 1 ) = JET_bitFourByteBookmark;
     		break;
			}

		default:
			 return JET_errInvalidParameter;
		}

	err = JET_errSuccess;
HandleError:
	SgSemRelease( semST );
	return err;
	}




	ERR VTAPI
ErrIsamGetSysTableColumnInfo(
	PIB 		*ppib,
	FUCB 		*pfucb,
	char 		*szColumnName,
	OUTLINE	*pout,
	long 		lInfoLevel )
	{
	ERR	err;

	if ( lInfoLevel > 0 )
		return JET_errInvalidParameter;
	err = ErrIsamGetTableColumnInfo( (JET_VSESID) ppib,
		(JET_VTID) pfucb, szColumnName, pout->pb, pout->cbMax, lInfoLevel );
	return err;
	}


ERR ErrFILEGetColumnId( PIB *ppib, FUCB *pfucb, const CHAR *szColumn, JET_COLUMNID *pcolumnid )
	{
	FDB		*pfdb;
	FIELD		*pfield;
	FIELD		*pfieldMax;

	CheckPIB( ppib );
	CheckTable( ppib, pfucb );
	Assert( pfucb->u.pfcb != pfcbNil );
	Assert( pfucb->u.pfcb->pfdb != pfdbNil );
	Assert( pcolumnid != NULL );

	pfdb = (FDB *)pfucb->u.pfcb->pfdb;

	/*** Search fixed field names ***/
	pfieldMax = pfdb->pfieldFixed + ( pfdb->fidFixedLast+1-fidFixedLeast );
	for ( pfield = pfdb->pfieldFixed; pfield < pfieldMax; pfield++ )
		if ( pfield->coltyp != JET_coltypNil &&
			SysCmpText( pfield->szFieldName, szColumn ) == 0 )
			{
			*pcolumnid = (DWORD)( pfield-pfdb->pfieldFixed ) + fidFixedLeast;
			return JET_errSuccess;
			}

	/*** Search variable field names ***/
	pfieldMax = pfdb->pfieldVar + ( (int)pfdb->fidVarLast+1-fidVarLeast );
	for ( pfield = pfdb->pfieldVar; pfield < pfieldMax; pfield++ )
		if ( pfield->coltyp != JET_coltypNil &&
			SysCmpText( pfield->szFieldName, szColumn ) == 0 )
			{
			*pcolumnid = (DWORD)( pfield - pfdb->pfieldVar ) + fidVarLeast;
			return JET_errSuccess;
			}

	/*** Search tagged field names ***/
	pfieldMax = pfdb->pfieldTagged +
				( (int)pfdb->fidTaggedLast+1-fidTaggedLeast );
	for ( pfield = pfdb->pfieldTagged; pfield < pfieldMax; pfield++ )
		if ( pfield->coltyp != JET_coltypNil &&
			SysCmpText( pfield->szFieldName, szColumn ) == 0 )
			{
			*pcolumnid = (DWORD)( pfield-pfdb->pfieldTagged )+fidTaggedLeast;
			return JET_errSuccess;
			}

	return JET_errColumnNotFound;
	}


/*=================================================================
FidLookupColumn

Description: Looks up next column ( matching given name if any )

Parameters:	pfucb				pointer to FUCB for table containing columns
			fid					field id to start search at
			szColumnName		column name or NULL for next column
			pcolinfo			output buffer containing column info

Return Value: Field id of column found ( fidTaggedMost if none )

Errors/Warnings:

Side Effects:
=================================================================*/
FID FidLookupColumn(
	FUCB		*pfucb, 				/* FUCB for table containing columns */
	FID		fid, 					/* field id where search is to start */
	char		*szColumnName, 	/* column name or NULL for next column */
	COLINFO	*pcolinfo )			/* output buffer for column info */
	{
	FDB		*pfdb;				/* pointer to table definition */
	FIELD		*pfield;				/* first element of specific field type */
	FID		ifield;				/* index to current element of field type */
	FID		fidLast;				/* column id of last field defined for type */

	int		iSource;				/* index to source character in column name */
	int		iDest;				/* index to destination character */

	JET_GRBIT grbit;				/* flags for the field */

	pfdb = (FDB *)pfucb->u.pfcb->pfdb;

	/* Check the fixed fields first */

	if ( fid <= fidFixedMost )
		{
		ifield  = fid - fidFixedLeast;
		fidLast = pfdb->fidFixedLast - fidFixedLeast + 1;
		pfield  = pfdb->pfieldFixed;

		while ( ifield < fidLast &&
			( pfield[ifield].coltyp == JET_coltypNil ||
			( szColumnName != NULL &&
			SysCmpText( szColumnName, pfield[ifield].szFieldName ) != 0 ) ) )
			{
			ifield++;
			}

		if ( ifield < fidLast )
			{
			fid   = ifield + fidFixedLeast;
			grbit = FFUCBUpdatable( pfucb ) ? JET_bitColumnFixed | JET_bitColumnUpdatable : JET_bitColumnFixed;
			}
		else
			fid = fidVarLeast;
		}

	/* Check the variable fields */

	if ( fid >= fidVarLeast && fid <= fidVarMost )
		{
		ifield  = fid - fidVarLeast;
		fidLast = pfdb->fidVarLast - fidVarLeast + 1;
		pfield  = pfdb->pfieldVar;

		while ( ifield < fidLast &&
			( pfield[ifield].coltyp == JET_coltypNil ||
			( szColumnName != NULL &&
			SysCmpText( szColumnName, pfield[ifield].szFieldName ) != 0 ) ) )
			ifield++;

		if ( ifield < fidLast )
			{
			fid   = ifield + fidVarLeast;
			grbit = FFUCBUpdatable( pfucb ) ? JET_bitColumnUpdatable : 0;
			}
		else
			fid = fidTaggedLeast;
		}

	/* Check the tagged fields */

	if ( fid >= fidTaggedLeast )
		{
		ifield  = fid - fidTaggedLeast;
		fidLast	= pfdb->fidTaggedLast - fidTaggedLeast + 1;
		pfield  = pfdb->pfieldTagged;

		while ( ifield < fidLast &&
			( pfield[ifield].coltyp == JET_coltypNil ||
			( szColumnName != NULL &&
			SysCmpText( szColumnName, pfield[ifield].szFieldName ) != 0 ) ) )
			{
			ifield++;
			}

		if ( ifield < fidLast )
			{
			fid   = ifield + fidTaggedLeast;
			grbit = FFUCBUpdatable( pfucb ) ? JET_bitColumnTagged | JET_bitColumnUpdatable : JET_bitColumnTagged;
			}
		else
			fid = fidTaggedMost;
		}

	/* If a field was found, then return the information about it */

	if ( fid < fidTaggedMost )
		{
		if ( pfield[ifield].ffield & ffieldNotNull )
			grbit |= JET_bitColumnNotNULL;

		if ( pfield[ifield].ffield & ffieldAutoInc )
			grbit |= JET_bitColumnAutoincrement;

		if ( pfield[ifield].ffield & ffieldVersion )
			grbit |= JET_bitColumnVersion;

		if ( pfield[ifield].ffield & ffieldMultivalue )
			grbit |= JET_bitColumnMultiValued;

		pcolinfo->columnid = fid;
		pcolinfo->grbit    = grbit;
		pcolinfo->coltyp   = pfield[ifield].coltyp;
		pcolinfo->cb       = pfield[ifield].cbMaxLen;

		iSource = 0;
		iDest   = 0;

		while ( iSource < ( JET_cbNameMost + 1 ) &&
			pfield[ifield].szFieldName[iSource] !=  '\0' )
			pcolinfo->szName[iDest++] = pfield[ifield].szFieldName[iSource++];

		pcolinfo->szName[iDest] = '\0';
		}

	return fid;
	}


ERR VTAPI ErrIsamInfoRetrieveColumn(
	PIB				*ppib,
	FUCB				*pfucb,
	JET_COLUMNID	columnid,
	BYTE				*pb,
	unsigned long	cbMax,
	unsigned long	*pcbActual,
	JET_GRBIT		grbit,
	JET_RETINFO		*pretinfo )
	{
	ERR				err;

	err = ErrIsamRetrieveColumn( ppib, pfucb, columnid, pb, cbMax, pcbActual, grbit, pretinfo );
	return err;
	}


ERR VTAPI ErrIsamInfoSetColumn(
	PIB				*ppib,
	FUCB				*pfucb,
	JET_COLUMNID	columnid,
	const void		*pbData,
	unsigned long	cbData,
	JET_GRBIT		grbit,
	JET_SETINFO		*psetinfo )
	{
	ERR				err;

	/* check table updatable
	/**/
	CallR( FUCBCheckUpdatable( pfucb ) );

	err = ErrIsamSetColumn( ppib, pfucb, columnid, (BYTE *)pbData, cbData, grbit, psetinfo );
	return err;
	}


ERR VTAPI ErrIsamInfoUpdate(
	JET_VSESID		vsesid,
	JET_VTID			vtid,
	void				*pb,
	unsigned long 	cbMax,
	unsigned long 	*pcbActual )
	{
	ERR	err;
	/* Ensure that table is updatable */
	/**/
	CallR( FUCBCheckUpdatable( (FUCB *) vtid ) );

	return ErrIsamUpdate( (PIB *) vsesid, (FUCB *) vtid, pb, cbMax, pcbActual );
	}


ERR VTAPI ErrIsamGetCursorInfo(
	JET_VSESID 		vsesid,
	JET_VTID			vtid,
	void 				*pvResult,
	unsigned long 	cbMax,
	unsigned long 	InfoLevel )
	{
	PIB		*ppib = (PIB *) vsesid;
	FUCB		*pfucb = (FUCB *) vtid;
	ERR		err = JET_errSuccess;
	CSR		*pcsr = PcsrCurrent( pfucb );
	VS			vs;

	CheckPIB( ppib );
	CheckFUCB( pfucb->ppib, pfucb );

	if ( cbMax != 0 || InfoLevel != 0 )
		return JET_errInvalidParameter;

	if ( pcsr->csrstat != csrstatOnCurNode )
		return JET_errNoCurrentRecord;

	/* temporary tables are never visible to other sessions
	/**/
	if ( FFCBTemporaryTable( pfucb->u.pfcb ) )
		return JET_errSuccess;

	/* Check if this record is being updated by another cursor
	/**/
	Call( ErrDIRGet( pfucb ) );
	if ( FNDVersion( *( pfucb->ssib.line.pb ) ) )
		{
		SRID	srid;
		NDGetBookmark( pfucb, &srid );
		vs = VsVERCheck( pfucb, srid );
		if ( vs == vsUncommittedByOther )
			return JET_errSessionWriteConflict;
		}

HandleError:
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\io.c ===
//===========================================================================
//		DAE: Database Access Engine
//		io.c: disk I/O manager
//
//
//		ULONG pn
//		High 8-bits indicate database file	(pn>>24)
//		Low 24-bits indicate page offset + 1
//		byte offset into file (pos) == ((pn & 0x00ffffff) - 1) * cbPage
//							   == (pn - 1) << 12
//
//===========================================================================

#include "config.h"

#include <string.h>
#include <stdlib.h>

#include "daedef.h"
#include "pib.h"
#include "util.h"
#include "fmp.h"
#include "page.h"
#include "ssib.h"
#include "fucb.h"
#include "stapi.h"
#include "stint.h"
#include "dbapi.h"

DeclAssertFile;					/* Declare file name for assert macros */

extern int itibGlobal;

#ifdef	ASYNC_IO_PROC
HANDLE	handleIOProcess = 0;
BOOL	fIOProcessTerm = 0;
#endif


/******************************************************************/
/*				Database Record Routine                           */
/******************************************************************/


#ifdef MULTI_PROCESS
/*
 *	The scheme is based on that we can do FileMap to achieve:
 *	1) Memory sharing among processes.
 *	2) Synchronization objects (mutex, semaphore, events) created in Jet
 *     prcess can be duplicated for other process.
 */
#endif


FMP * __near rgfmp;							/* database file map */


/*
 *	ErrIOLockDbidByNameSz returns the dbid of the database with the
 *	given name or 0 if there is no database with the given name.
 */
ERR ErrIOLockDbidByNameSz( CHAR *szFileName, DBID *pdbid )
	{
	ERR		err;
	DBID		dbid;

	err = JET_errDatabaseNotFound;
	dbid = dbidMin;
	SgSemRequest( semST );
	while ( dbid < dbidUserMax )
		{
		if ( rgfmp[dbid].szDatabaseName != pbNil &&
			SysCmpText( szFileName, rgfmp[dbid].szDatabaseName ) == 0 )
			{
			if ( ( FDBIDWait(dbid) ) )
				{
				SgSemRelease( semST );
				BFSleep( cmsecWaitGeneric );
				SgSemRequest( semST );
				dbid = dbidMin;
				}
			else
				{
				*pdbid = dbid;
				DBIDSetWait( dbid );
				err = JET_errSuccess;
				break;
				}
			}
		else
			dbid++;
		}
	SgSemRelease( semST );
	return err;
	}


/*
 *	Used in initialization and detach to lock database entries from dbid.
 */
ERR ErrIOLockDbidByDbid( DBID dbid )
	{
	forever
		{
		SgSemRequest( semST );
		if ( !( FDBIDWait(dbid) ) )
			{
			DBIDSetWait( dbid );
			break;
			}
		SgSemRelease( semST );
		BFSleep( cmsecWaitGeneric );
		}
	SgSemRelease( semST );
	return JET_errSuccess;
	}


/*
 *	ErrIOLockNewDbid( DBID *pdbid, CHAR *szDatabaseName )
 *
 *	ErrIOLockNewDbid returns JET_errSuccess and sets *pdbid to the index
 *	of a free file table entry or returns TooManyOpenDatabases if every
 *	entry is used with a positive reference count.  If the given name
 *	is found in the file map, even if it is in the process of being
 *	detached, JET_wrnAlreadyAttached is returned.  
 *	
 *	Available entries are determined by their names being set to
 *	NULL.  All database record fields are reset.  The wait flag is
 *	set to prevent the database from being opened before creation or
 *	attachment is complete.	
 */
ERR ErrIOLockNewDbid( DBID *pdbid, CHAR *szDatabaseName )
	{
	ERR		err = JET_errSuccess;
	DBID	dbid;
	BYTE	*pb;
	
	/* look for unused file map entry
	/**/
	SgSemRequest( semST );
	for ( dbid = dbidMin; dbid < dbidUserMax; dbid++ )
		{
		/*	semST guards rgfmp[*].szDatabaseName, fWait guards
		/*	file handle.  Therefore, only need semST to compare
		/*	all database names, even those with fWait set
		/**/
		if ( rgfmp[dbid].szDatabaseName != NULL &&
			SysCmpText( rgfmp[dbid].szDatabaseName, szDatabaseName) == 0 )
			{
#ifdef REUSEDBID 
			if ( FDBIDAttached( dbid ) )
				{
				err = JET_wrnDatabaseAttached;
				}
			else
				{
				/*	if find same name, then return warning with same dbid.
				/**/
				DBIDSetWait( dbid );
				Assert( !( FDBIDExclusive( dbid ) ) );
				*pdbid = dbid;
				}
#else
			err = JET_wrnDatabaseAttached;
#endif
			goto HandleError;
			}
		}

	for ( dbid = dbidMin; dbid < dbidUserMax; dbid++ )
		{
		if ( rgfmp[dbid].szDatabaseName == pbNil )
			{
			pb = SAlloc(strlen(szDatabaseName) + 1);
			if ( pb == NULL )
				{
				err = JET_errOutOfMemory;
				goto HandleError;
				}

			rgfmp[dbid].szDatabaseName = pb;
			strcpy( rgfmp[dbid].szDatabaseName, szDatabaseName );

			DBIDSetWait( dbid );
			DBIDResetExclusive( dbid );
			*pdbid = dbid;
			err = JET_errSuccess;
			goto HandleError;
			}
		}

	err = JET_errTooManyAttachedDatabases;

HandleError:
	SgSemRelease( semST );
	return err;
	}


/*
 *	ErrIOSetDbid( DBID dbid, CHAR *szDatabaseName )
 *
 *	ErrIOSetDbid sets the database record for dbid to the given name
 *	and initializes the record.  Used only in system initialization.
 */

ERR ErrIOSetDbid( DBID dbid, CHAR *szDatabaseName )
	{
	ERR		err;
	BYTE	*pb;

	Assert( Hf(dbid) == handleNil );
	Assert( rgfmp[dbid].szDatabaseName == NULL );
	pb = SAlloc(strlen(szDatabaseName) + 1);
	if ( pb == NULL )
		{
		err = JET_errOutOfMemory;
		goto HandleError;
		}
	rgfmp[dbid].szDatabaseName = pb;
	strcpy( rgfmp[dbid].szDatabaseName, szDatabaseName );
	DBIDResetWait( dbid );
	DBIDResetExclusive( dbid );

	err = JET_errSuccess;
	
HandleError:
	return err;
	}


/*
 *	IOFreeDbid( DBID dbid )
 *
 *	IOFreeDbid frees memory allocated for database name and sets
 *	database name to NULL.  Note, no other fields are reset.  This 
 *	must be done when an entry is selected for reuse. 
 */

VOID IOFreeDbid( DBID dbid )
	{
	SgSemRequest( semST );
	if ( rgfmp[dbid].szDatabaseName != NULL )
		{
		SFree( rgfmp[dbid].szDatabaseName );
		}

	rgfmp[dbid].szDatabaseName = NULL;
	SgSemRelease( semST );
	}


/*
 *	FIODatabaseInUse returns fTrue if database is
 *	opened by one or more users.  If no user has the database open,
 *	then the database record fWait flag is set and fFalse is
 *	returned.
 */
BOOL FIODatabaseInUse( DBID dbid )
	{
	PIB *ppibT;

	SgSemRequest( semST );
	ppibT = ppibAnchor;
	while ( ppibT != ppibNil )
		{
		if ( FUserOpenedDatabase( ppibT, dbid ) )
				{
				SgSemRelease( semST );
				return fTrue;
				}
		ppibT = ppibT->ppibNext;
		}

	SgSemRelease( semST );
	return fFalse;
	}


BOOL FIODatabaseAvailable( DBID dbid )
	{
	BOOL	fAvail;

	SgSemRequest( semST );
	
	fAvail = ( FDBIDAttached(dbid) &&
		!FDBIDWait(dbid) &&
		!FDBIDExclusive(dbid) );

	SgSemRelease( semST );

	return fAvail;
	}


/******************************************************************/
/*				IO                                                */
/******************************************************************/


#ifdef	ASYNC_IO_PROC

static IOQE	*pioqeHead = NULL;
static IOQE	*pioqeTail = NULL;

#ifdef MULTI_PROCESS
/* Semiphore guarding IO Queue */
SemDefine( semIOQ );
#else
/* Critical section guarding IO Que */
static CRIT critIOQ;
#endif

/* Use to wake up IO thread to work. */
static SIG sigIOProc;

/* IO Process */
LOCAL VOID	IOProcess( VOID );

#endif	/* ASYNC_IO_PROC */


ERR ErrFMPInit( )
	{
	ERR		err;
	CHAR	szFullName[256];
	DBID	dbid;

	/* initialize the file map array */
	rgfmp = (FMP *) LAlloc( (long) dbidMax, sizeof(FMP) );
	if ( !rgfmp )
		return JET_errOutOfMemory;
	
	for ( dbid = 0; dbid < dbidMax; dbid++)
		{
		memset( &rgfmp[dbid], 0, sizeof(FMP) );
		rgfmp[dbid].hf =
		rgfmp[dbid].hfPatch = handleNil;

		CallR( ErrInitializeCriticalSection( &rgfmp[dbid].critExtendDB ) );
		DBIDResetExtendingDB( dbid );
		}
		
#ifdef NJETNT
	_fullpath( szFullName, rgtib[itibGlobal].szSysDbPath, 256 );
#else
	_fullpath( szFullName, szSysDbPath, 256 );
#endif
	/* Set fmp bits */
	CallR( ErrIOSetDbid( dbidSystemDatabase, szFullName ) );
	DBIDSetAttached( dbidSystemDatabase );
	rgfmp[ dbidSystemDatabase ].fLogOn =
	rgfmp[ dbidSystemDatabase ].fDBLoggable = fTrue;

	return JET_errSuccess;
	}

	
VOID FMPTerm( )
	{
	INT	dbid;

	for ( dbid = 0; dbid < dbidMax; dbid++ )
		{
		if ( rgfmp[dbid].szDatabaseName )
			SFree( rgfmp[dbid].szDatabaseName );
		if ( rgfmp[dbid].szRestorePath )
			SFree( rgfmp[dbid].szRestorePath );

		DeleteCriticalSection( rgfmp[dbid].critExtendDB );
		}

	/*	free FMP
	/**/
	LFree( rgfmp );
	
	return;
	}


/*
 *	Allocate and initilize file map table.  The file map table is used to map
 *	page numbers to disk files.
 *
 *	UNDONE: the assync IO initialization should be seperated.
 *	Also set the assynchronized IO.
 */
ERR ErrIOInit( VOID )
	{
#ifdef	ASYNC_IO_PROC
	ERR		err;
#endif
	
#ifdef	ASYNC_IO_PROC

	/* initialize the IO Queue */
	Assert(pioqeHead == NULL);
	Assert(pioqeTail == NULL);

	/*
	 *  Set up the guarding semphore for IO Queue.
	 */
	#ifdef MULTI_PROCESS
	/* UNDONE: the sem should be copied to the JET Process */
	CallR( ErrSemCreate( &semIO, "io queue mutex sem" ) );
	#else
	CallR( ErrInitializeCriticalSection( &critIOQ ) );
	#endif
	
	/*
	 *  create signal to wait someone to ask wake IO process up.
	 */
	#ifdef WIN32
	CallR( ErrSignalCreateAutoReset( &sigIOProc, "io proc signal" ) );
	#else
	CallR( SignalCreate( &sigIOProc, "io proc signal" ) );
	#endif
	
	#ifdef MULTI_PROCESS
	/* make it available for other process to copy it over */
	#endif

	/*
	 *  Create the IO process, must be done after sigIOProc which
	 *  is called in IOProcess.
	 */
	fIOProcessTerm = fFalse;
	CallR( ErrSysCreateThread( (ULONG (*)()) IOProcess,
			cbStack,
			lThreadPriorityCritical,
			&handleIOProcess ) );

#endif	/* ASYNC_IO_PROC */

	return JET_errSuccess;
	}


/*	go through FMP closing files.
/**/
ERR ErrIOTerm( VOID )
	{
	DBID		dbid;

	SgSemRequest( semST );
	for ( dbid = dbidMin; dbid < dbidUserMax; dbid++ )
		{
		if ( Hf(dbid) != handleNil )
			{
			IOCloseFile( Hf(dbid) );
			Hf(dbid) = handleNil;
			}
//		DeleteCriticalSection( rgfmp[dbid].critExtendDB );
		}
	SgSemRelease( semST );

#ifdef	ASYNC_IO_PROC
	/*	terminate IOProcess.
	/**/
	Assert( handleIOProcess != 0 );
	fIOProcessTerm = fTrue;
	do
		{
		SignalSend( sigIOProc );
		BFSleep( cmsecWaitGeneric );
		}
	while ( !FSysExitThread( handleIOProcess ) );
	CallS( ErrSysCloseHandle( handleIOProcess ) );
	handleIOProcess = 0;
	SignalClose(sigIOProc);
	DeleteCriticalSection(critIOQ);
#endif

	return JET_errSuccess;
	}

	
ERR ErrIOOpenFile( HANDLE *phf, CHAR *szDatabaseName,
	ULONG cb, BOOL fioqefile )
	{
	ERR err;
	
#ifdef	ASYNC_IO_PROC
			
	IOQEFILE ioqefile;
		
	CallR( ErrSignalCreate( &ioqefile.sigIO, NULL ) );
	ioqefile.fioqefile = fioqefile;
	ioqefile.fioqe = fioqeOpenFile;
	ioqefile.sz = szDatabaseName;
	ioqefile.cb = cb;

	IOExecute( (IOQE *)&ioqefile );
	
	*phf = ioqefile.hf;
	err = ioqefile.err;
#else
	err = ErrSysOpenFile( szDatabaseName, phf, cb, fFalse, fTrue );
#endif

	return err;
	}


VOID IOCloseFile( HANDLE hf )
	{
#ifdef	ASYNC_IO_PROC
	IOQEFILE ioqefile;

	//	UNDONE:	guarantee file close succeeds
	CallS( ErrSignalCreate( &ioqefile.sigIO, NULL ) );
	ioqefile.fioqe = fioqeCloseFile;
	ioqefile.hf = hf;

	IOExecute((IOQE*)&ioqefile);
	
	Assert(ioqefile.err == JET_errSuccess);
#else
	CallS( ErrSysCloseFile( hf ) );
#endif
	}


BOOL FIOFileExists( CHAR *szFileName )
	{
	ERR		err;
	HANDLE	hf;

	err = ErrIOOpenFile( &hf, szFileName, 0L, fioqefileReadOnly );
	if ( err == JET_errFileNotFound )
		return fFalse;
	IOCloseFile( hf );
	return fTrue;
	}


ERR ErrIONewSize( DBID dbid, CPG cpg )
	{
	ERR		err;
	HANDLE	hf = Hf(dbid);
	ULONG		cb;
	ULONG		cbHigh;
	
	Assert( sizeof( PAGE ) == 1 << 12 );
	cb = cpg << 12;
	cbHigh = cpg >> 20;
	
#ifdef	ASYNC_IO_PROC
	{
	IOQEFILE ioqefile;
	
	CallR( ErrSignalCreate( &ioqefile.sigIO, NULL ) );
	ioqefile.fioqe = fioqeNewSize;
	ioqefile.hf = hf;
	ioqefile.cb = cb;
	ioqefile.cbHigh = cbHigh;

	IOExecute((IOQE*)&ioqefile);
	
	err = ioqefile.err;
	}
#else
	err = ErrSysNewSize( hf, cb, cbHigh, fTrue );
#endif
	return err;
	}


/*
 *  opens database file, returns JET_errSuccess if file is already open
 */
ERR ErrIOOpenDatabase( DBID dbid, CHAR *szDatabaseName, CPG cpg )
	{
	ERR		err = JET_errSuccess;
	HANDLE	hf;
	
	Assert( dbid < dbidMax );
	Assert( FDBIDWait(dbid) == fTrue );

	if ( Hf(dbid) == handleNil )
		{
		CallR( ErrIOOpenFile( &hf, szDatabaseName, cpg * cbPage, fioqefileReadWrite ) );
		Hf(dbid) = hf;
		if ( err == JET_wrnFileOpenReadOnly )
			DBIDSetReadOnly( dbid );
		else 
			DBIDResetReadOnly( dbid );
		}
	return err;
	}


VOID IOCloseDatabase( DBID dbid )
	{
	Assert( dbid < dbidMax );
//	Assert( fRecovering || FDBIDWait(dbid) == fTrue );
	Assert( Hf(dbid) != handleNil );
	IOCloseFile( Hf(dbid) );
	Hf(dbid) = handleNil;
	DBIDResetReadOnly( dbid );
	}
	

VOID IODeleteDatabase( DBID dbid )
	{
	Assert( dbid < dbidMax );
	Assert( FDBIDWait(dbid) == fTrue );
	
#ifdef	ASYNC_IO_PROC
		{		
		IOQEFILE ioqefile;

		//	UNDONE:	guarantee delete database succeeds
		CallS( ErrSignalCreate( &ioqefile.sigIO, NULL ) );
		ioqefile.fioqe = fioqeDeleteFile;
		ioqefile.sz = rgfmp[dbid].szDatabaseName;

		IOExecute((IOQE*)&ioqefile);

		Assert(ioqefile.err == JET_errSuccess);
		}
#else
	CallS( ErrSysDeleteFile( rgfmp[dbid].szDatabaseName ) );
#endif
	}


#ifndef DEBUG

#define IOCheckIOQ()

#else

#ifdef ASYNC_IO_PROC
LOCAL VOID IOCheckIOQ()
	{
	Assert(	pioqeHead == NULL && pioqeTail == NULL ||
			pioqeTail != NULL && pioqeTail != NULL );
	
	Assert( pioqeHead == NULL || pioqeHead->pioqePrev == NULL );
	
	Assert(	pioqeHead == NULL ||					/* no element */
			pioqeHead->pioqeNext == NULL ||			/* one element */
			( pioqeHead->pioqeNext != pioqeHead &&	/* first two elements */
			  pioqeHead->pioqeNext->pioqePrev == pioqeHead ) );
	
	Assert( pioqeTail == NULL || pioqeTail->pioqeNext == NULL );
	
	Assert( pioqeTail == NULL ||					/* no element */
			pioqeTail->pioqePrev == NULL ||			/* one element */
			( pioqeTail->pioqePrev != pioqeTail &&	/* last two elements */
			  pioqeTail->pioqePrev->pioqeNext == pioqeTail ) );
	}
#endif
#endif


/*  Make sure only those holding critIOQ can request critJet, but not
 *  the other way around.
 */
VOID IOExecute( IOQE *pioqe )
	{
	#ifdef MULTI_PROCESS
	SemRelease( semST );
	#else
	LeaveCriticalSection(critJet);
	#endif

	IOAsync( pioqe );
	IOWait( pioqe );
	
	#ifdef MULTI_PROCESS
	SemRequest( semST );
	#else
	EnterCriticalSection(critJet);
	#endif
	}


VOID IOAsync( IOQE *pioqe )
	{
#ifdef ASYNC_IO_PROC

	/*
	 *  Use sem/crit IOQ to guarrantee that when we insert a buffer ioqe
	 *  into the IO queue, we always have a consistent view.
	 */
	#ifdef MULTI_PROCESS
	SemRequest( semIOQ );
	#else
	EnterCriticalSection(critIOQ);
	#endif

	/* extensively check the pointers in IO Queue */
	IOCheckIOQ();

	Assert( pioqe->fioqe == fioqeOpenFile ||
		pioqe->fioqe == fioqeCloseFile ||
		pioqe->fioqe == fioqeDeleteFile ||
		pioqe->fioqe == fioqeNewSize );
	#ifdef MULTI_PROCESS
	/* copy the ioqe into JET process */
	#endif

	/*
	 *  Append pioqe to IOQ, including case of pioqeTail == NULL.
	 */
	
	pioqe->pioqePrev = pioqeTail;
	pioqe->pioqeNext = NULL;
	if ( pioqeTail != NULL )
		pioqeTail->pioqeNext = pioqe;
	else
		pioqeHead = pioqe;
	pioqeTail = pioqe;

	/*
	 *  Wake up IO Process to do the work if he is not awake.
	 */
	SignalSend( sigIOProc );

	/* complete the sensitive setting, leave the critical section */
	#ifdef MULTI_PROCESS
	SemRelease( semIOQ );
	#else
	LeaveCriticalSection(critIOQ);
	#endif

#else

#endif
	}


/*
 *	Waits for asynchronous IO to complete.
 */
VOID IOWait( IOQE *pioqe )
	{
#ifdef ASYNC_IO_PROC
	/*	leave large grain critical section, while waiting
	/*	for IO operation to complete.
	/**/
	SignalWait( pioqe->sigIO, -1 );

	SignalClose(pioqe->sigIO);
	/* UNDONE: release pioqe if it is MULTT_PROCESS */
#endif
	return;
	}


#ifdef ASYNC_IO_PROC

/*
 *	The IOProc thread processes IO requests from the IO Queue. 
 */
LOCAL VOID IOProcess( VOID )
	{
	ERR		err;
	IOQE		*pioqe;

	forever
		{
		/*
		 *  wait for some user to wake me up to do the IO.
		 */
		SignalWait( sigIOProc, -1 );
		#ifndef WIN32
		SignalReset( sigIOProc );
		#endif

		/*
		 *  now I am awake, go check the IO que list. Keep processing
		 *  the buffer in the list until I run out of buffer in the que.
		 *  Get the IO Queue resource through sem/crit
		 *  so that we can view IO queue without being interfered
		 */
		#ifdef MULTI_PROCESS
		SemRequest( semIOQ );
		#else
		EnterCriticalSection(critIOQ);
		#endif
		
		forever
			{
			/* extensively check the pointers in IO Queue */
			IOCheckIOQ();

			if ( ( pioqe = pioqeHead ) == NULL )
				{
				/*
				 *  Now no more IO to do, release IO queue, go and wait for
				 *  users to wake me up.
				 */
				#ifdef MULTI_PROCESS
				SemRelease( semIOQ );
				#else
				LeaveCriticalSection(critIOQ);
				#endif

				/*	no more request so break loop and wait until signalled again.
				/**/
				break;
				}
			else
				{
				/*
				 *  take out the first ioqe in the IO que.
				 */
				pioqeHead = pioqe->pioqeNext;
				if ( pioqeHead == NULL )
					{
					/* This is the last buffer in IO queue. */
					Assert( pioqeTail == pioqe );
					pioqeTail = NULL;
					}
				else
					{
					/* take out this buffer */
					pioqeHead->pioqePrev = NULL;
					}

				/*
				 *  At this point, this buffer is not viable for any user to
				 *  do IO because fWrite/fRead is set. Now we can do the IO.
				 *  release sem/critIOQ to let other user to add IOQ.
				 */
				#ifdef MULTI_PROCESS
				SemRelease( semIOQ );
				#else
				LeaveCriticalSection(critIOQ);
				#endif

				#ifdef MULTI_PROCESS
				/* copy the signal object pioqe->sigIO */
				/* from its caller process. */
				#endif

				switch(pioqe->fioqe)
					{
					case fioqeOpenFile:
						{
						IOQEFILE *pioqefile = (IOQEFILE *) pioqe;
						err = ErrSysOpenFile( pioqefile->sz, &pioqefile->hf,
		  					pioqefile->cb, fFalse, fTrue );
						}
						break;
					case fioqeCloseFile:
						{
						IOQEFILE *pioqefile = (IOQEFILE *) pioqe;
						err = ErrSysCloseFile( pioqefile->hf );
						}
						break;
					case fioqeDeleteFile:
						{
						IOQEFILE *pioqefile = (IOQEFILE *) pioqe;
						err = ErrSysDeleteFile( pioqefile->sz );
						}
						break;
					case fioqeNewSize:
						{
						IOQEFILE *pioqefile = (IOQEFILE *) pioqe;
						err = ErrSysNewSize(
								pioqefile->hf,
								pioqefile->cb,
								pioqefile->cbHigh,
								fTrue );
						}
						break;
					}

				/*
				 *  get back to critical section to change IOQ.
				 */
				
				#ifdef MULTI_PROCESS
				SemRequest( semIOQ );
				#else
				EnterCriticalSection(critIOQ);
				#endif
				
				pioqe->err = err;
				/* wake up those waiting for this IO */
				/* it is ok to put signal send outside CS */
				/* because there is only one thread is waiting. */
				SignalSend( pioqe->sigIO );
				}
			} /* inner forever */

		/*	break if thread is to terminate.
		/**/
		if ( fIOProcessTerm )
			break;
		} /* outer forever */

//	/*	exit thread on system termination.
//	/**/
//	SysExitThread( 0 );

	return;
	}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\log.c ===
#include "config.h"

#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "daedef.h"
#include "ssib.h"
#include "pib.h"
#include "util.h"
#include "page.h"
#include "fucb.h"
#include "stapi.h"
#include "stint.h"
#include "nver.h"
#include "logapi.h"
#include "logver.h"
#include "log.h"

DeclAssertFile;					/* Declare file name for assert macros */

/*	thread control variables.
/**/
extern HANDLE	handleLGFlushLog;
extern BOOL		fLGFlushLogTerm;

INT csecLGCheckpointCount;
INT csecLGCheckpointPeriod;
INT cLGUsers = 0;

LGPOS		lgposMax = { 0xffff, 0xffff, 0xffff };
LGPOS		lgposMin = { 0x0,  0x0,  0x0 };

/* log file info. */
HANDLE		hfLog;			/* logfile handle */


/* switch to issue no write (for non-overlapped IO only) in order
 * to test the performance without real IO.
 */
//#define NO_WRITE	1

#ifdef OVERLAPPED_LOGGING
OLP			rgolpLog[3] = {{0,0,0,0,0}, {0,0,0,0,0}, {0,0,0,0,0}};
OLP			*polpLog = rgolpLog;
SIG			rgsig[3];
INT			rgcbToWrite[4];
#endif

INT			csecLGFile;

/* cached current log file header */
LGFILEHDR	*plgfilehdrGlobal;


/* in memory log buffer. */
INT				csecLGBuf;		/* available buffer, exclude the shadow sec */
CHAR			*pbLGBufMin;
CHAR			*pbLGBufMax;
CHAR			*pbLastMSFlush = 0;	/* where last multi-sec flush LogRec in LGBuf*/
LGPOS			lgposLastMSFlush = { 0, 0, 0 };

/* variables used in logging only */
BYTE			*pbEntry;		/* location of next buffer entry */
BYTE			*pbWrite; 		/* location of next rec to flush */
INT				isecWrite;		/* logging only - next disk to write. */

LGPOS			lgposLogRec;	/* last log record entry, updated by ErrLGLogRec */
LGPOS			lgposToFlush;	/* first log record to flush. */

LGPOS			lgposStart;		/* when lrStart is added */
LGPOS			lgposRecoveryUndo;

LGPOS			lgposFullBackup = { 0, 0, 0 };
LOGTIME			logtimeFullBackup;

LGPOS			lgposIncBackup = { 0, 0, 0 };
LOGTIME			logtimeIncBackup;

/* logging EVENT */
CRIT __near	critLGFlush;	// make sure only one flush at a time.
CRIT __near	critLGBuf;	// guard pbEntry and pbWrite.
CRIT __near	critLGWaitQ;
SIG  __near	sigLogFlush;

LONG cXactPerFlush = 0;
#ifdef PERFCNT
BOOL fPERFEnabled = 0;
ULONG rgcCommitByLG[10] = {	0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
ULONG rgcCommitByUser[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
ULONG tidLG;
#endif


BOOL FIsNullLgpos(
	LGPOS *plgpos)
	{
	return	plgpos->usGeneration == 0 &&
			plgpos->isec == 0 &&
			plgpos->ib == 0;
	}


/* get pbEntry's lgpos derived from pbWrite and isecWrite
/**/
VOID GetLgposOfPbEntry(	LGPOS *plgpos )
	{
	CHAR	*pb;
	CHAR	*pbAligned;

#ifdef DEBUG
	if (!fRecovering)
		AssertCriticalSection(critLGBuf);
#endif

	if ( pbEntry < pbWrite )
		pb = pbEntry + csecLGBuf * cbSec;
	else
		pb = pbEntry;
	
	/* pbWrite is always aligned.
	/**/
	Assert( pbWrite != NULL && pbWrite == PbSecAligned( pbWrite ) );

	pbAligned = PbSecAligned( pb );
	plgpos->ib = (USHORT)(pb - pbAligned);
	plgpos->isec = (USHORT)(isecWrite + ( pbAligned - pbWrite ) / cbSec);
	plgpos->usGeneration = plgfilehdrGlobal->lgposLastMS.usGeneration;
	}


/*
 *	Write log file header data.
 *  UNDONE: should be merged with IO?
 */

ERR ErrLGWrite(
	INT isecOffset,			/* disk sector offset of logfile to write */
	BYTE *pbData,			/* log record to write. */
	INT csecData )			/* number of sector to write */
	{
#ifndef OVERLAPPED_LOGGING
 	ULONG	ulFilePointer;
#endif
	ERR		err;
	INT		cbWritten;
	INT		cbData = csecData * cbSec;

	Assert( isecOffset == 0 ||
			isecOffset == 2 ||
			pbData == PbSecAligned(pbData));

#ifdef OVERLAPPED_LOGGING
	
	polpLog->ulOffset = isecOffset * cbSec;
	Assert( polpLog->ulOffsetHigh == 0 );
	SignalReset( polpLog->sigIO );

	Call(ErrSysWriteBlockOverlapped(
				hfLog, pbData, cbData, &cbWritten, polpLog))
	
	err = ErrSysGetOverlappedResult(hfLog, polpLog, &cbWritten, fTrue/*wait*/);
	
	if (cbWritten != cbData)
		err = JET_errLogWriteFail;
#else
	
	/* move disk head to the given offset */
 	SysChgFilePtr( hfLog, isecOffset * cbSec, NULL, FILE_BEGIN, &ulFilePointer );
 	Assert( ulFilePointer == (ULONG) isecOffset * cbSec );
	
 	/* do system write on log file */
 	err = ErrSysWriteBlock( hfLog, pbData, (UINT) cbData, &cbWritten );
 	if ( err != JET_errSuccess || cbWritten != cbData )
		err = JET_errLogWriteFail;
#endif

	if ( err < 0 )
		{
		BYTE szMessage[128];

		sprintf( szMessage, "Log Write Fails. err = %d ", err );
		LGLogFailEvent( szMessage );
		fLGNoMoreLogWrite = fTrue;
		}

	return err;
	}


ULONG UlLGHdrChecksum( LGFILEHDR *plgfilehdr )
	{
	INT cul = sizeof( LGFILEHDR ) / sizeof( ULONG ) ;
	ULONG *pul = (ULONG *) plgfilehdr;
	ULONG *pulMax = pul + cul;
	ULONG ulChecksum = 0;

	pul++;			/* skip first field of checksum */
	while ( pul < pulMax )
		{
		ulChecksum += *pul++;
		}

	return ulChecksum;
	}


/*
 *  Write log file header. Make a shadow copy before write.
 */
ERR ErrLGWriteFileHdr(
	LGFILEHDR *plgfilehdr)
	{
	BYTE szMessage[128];
	ERR err;
	
	Assert( plgfilehdr->dbenv.ulLogBuffers );
	Assert( sizeof(LGFILEHDR) == cbSec );
	
	plgfilehdr->ulChecksum = UlLGHdrChecksum( plgfilehdr );

	/*	Write log file header twice. We can not write in one statement since
	 *	OS does not guarantee the first page will be finished before shadow page
	 *	is written.
	 */
	Call( ErrLGWrite( 0, (BYTE *)plgfilehdr, 1 ) );
	Call( ErrLGWrite( 1, (BYTE *)plgfilehdr, 1 ) );

	return err;

HandleError:
	sprintf( szMessage, "Log Write Header Fails. err = %d ", err );
	LGLogFailEvent( szMessage );
	fLGNoMoreLogWrite = fTrue;
	
	return err;
	}


/*
 *	Read log file header or sector data. The last disksec is a shadow
 *  sector. If an I/O error (assumed to be caused by an incompleted
 *  disksec write ending a previous run) is encountered, the shadow
 *  sector is read and (if this is successful) replaces the previous
 *  disksec in memory and on the disk.
 *
 *	PARAMETERS	hf		log file handle
 *				pbData	pointer to data to read
 *				lOffset	offset of data log file header (not including shadow)
 *				cbData	size of data
 *
 *	RETURNS		JET_errSuccess, or error code from failing routine
 * 				(reading shadow or rewriting bad last sector).
 */

ERR ErrLGRead(
	HANDLE hfLog,
	INT isecOffset,			/* disk sector offset of logfile to write */
	BYTE *pbData,			/* log record buffer to read. */
	INT csecData )			/* number of sectors to read */
	{
#ifndef OVERLAPPED_LOGGING
 	ULONG	ulFilePointer;
 	ULONG	ulOffset;
#endif
	ERR		err;
	UINT	cbData = csecData * cbSec;
	UINT	cbRead;

	Assert(isecOffset == 0 || pbData == PbSecAligned(pbData));
	
#ifdef OVERLAPPED_LOGGING
	polpLog->ulOffset = isecOffset * cbSec;
	Assert( polpLog->ulOffsetHigh == 0 );
	SignalReset( polpLog->sigIO );
	CallR( ErrSysReadBlockOverlapped( hfLog, pbData, cbData, &cbRead, polpLog))
	err = ErrSysGetOverlappedResult(hfLog, polpLog, &cbRead, fTrue/*wait*/);
	
	if ( err && cbRead < cbData && cbRead >= cbData - cbSec )
		{
		/* I/O error, assuming caused by last disksec read shadow sector */
		Assert(polpLog->ulOffset == (ULONG) isecOffset * cbSec);
		polpLog->ulOffset += cbData;
		Assert( polpLog->ulOffsetHigh == 0 );
		SignalReset( polpLog->sigIO );
		CallR( ErrSysReadBlockOverlapped(
				hfLog, pbData + cbData - cbSec, cbSec, &cbRead, polpLog))
		err = ErrSysGetOverlappedResult(hfLog, polpLog, &cbRead,fTrue/*wait*/);
		if (err || cbRead != cbSec)
			/* I/O error on reading shadow disksec, */
			/* return err so that caller may move to lastflush point. */
			return err;
		
		/*  rewrite shadow as the original.
		 *  if the caller can not find Fill record, this may be an out of
		 *  sequence page in multple sec flush. caller then will move
		 *  back to last flush point.
		 */
		Assert(polpLog->ulOffset == isecOffset * cbSec + cbData);
		polpLog->ulOffset -= cbSec;
		Assert( polpLog->ulOffsetHigh == 0 );
		SignalReset( polpLog->sigIO );

//		/* fix up the last page, no need to wait. */
//		CallR(ErrSysWriteBlockOverlapped(
//				hfLog, pbData + cbData - cbSec, cbSec, &cbRead, polpLog))
		}
#else
	
 	/* move disk head to the given offset */
 	ulOffset = isecOffset * cbSec;
 	SysChgFilePtr( hfLog, ulOffset, NULL, FILE_BEGIN, &ulFilePointer );
 	Assert( ulFilePointer == ulOffset );
	
 	/* do system read on log file */
 	cbData = csecData * cbSec;
 	cbRead = 0;
 	err = ErrSysReadBlock( hfLog, pbData, (UINT) cbData, &cbRead );

 	/* UNDONE: test for EOF, return errEOF */

 	if ( err && cbRead < cbData && cbRead >= cbData - cbSec)
		{
 		SysChgFilePtr( hfLog, ulOffset + cbData, NULL, FILE_BEGIN, &ulFilePointer );
 		Assert( ulFilePointer == ulOffset + cbData );

 		Call( ErrSysReadBlock( hfLog, pbData + cbData - cbSec, cbSec, &cbRead ))
		
//		/* fix up the last page */
//
// 		SysChgFilePtr( hfLog,
//			ulOffset + cbData - cbSec,
//			NULL,
// 			FILE_BEGIN,
//			&ulFilePointer );
//		Assert( ulFilePointer == ulOffset + cbData - cbSec );
//
//		(void) ErrSysWriteBlock(hfLog, pbData+cbData-cbSec, cbSec, &cbRead);
		}
#endif

HandleError:

	if ( err < 0 )
		{
		BYTE szMessage[128];

		sprintf( szMessage, "Log Read Fails. err = %d ", err );
		LGLogFailEvent( szMessage );
		}

	return err;
	}
							

/*
 *	Read log file header, detect and correct any incomplete or
 *	catastrophic write failures.  These failures must be corrected
 *	immediately to avoid the possibilty of destroying the single
 *	remainning valid copy later in the logging process.
 *
 *	Note that only the shadow information in the log file header is
 *	NOT set.  It is only set on log file header writing.
 *
 *	On error, contents of plgfilehdr are unknown.
 *
 *	RETURNS		JET_errSuccess, or error code from failing routine
 */

ERR ErrLGReadFileHdr(
	HANDLE hfLog,
	LGFILEHDR *plgfilehdr )
	{
	ERR			err;
	
	Assert( sizeof(LGFILEHDR) == cbSec );
	
	/* read a sector, which is shadowed. LGRead will read shadow */
	/* page if it failed in reading first page. */
	Call( ErrLGRead( hfLog, 0L, (BYTE *)plgfilehdr, 1 ) );
	
	if ( plgfilehdr->ulChecksum != UlLGHdrChecksum( plgfilehdr ) )
		{
		/* try shadow sector */
		Call( ErrLGRead( hfLog, 1L, (BYTE *)plgfilehdr, 1 ) );
		if ( plgfilehdr->ulChecksum != UlLGHdrChecksum( plgfilehdr ) )
			Call( JET_errDiskIO );
		}
	
#ifdef CHECK_LG_VERSION
	if ( !fLGIgnoreVersion )
		{
		if ( plgfilehdr->ulRup != rup ||
			 plgfilehdr->ulVersion != ((unsigned long) rmj << 16) + rmm )
			{
			BYTE szMessage[128];
			
			err = JET_errBadLogVersion;

			sprintf( szMessage, "Log Read File Header Bad Version. err = %d ", err );
			LGLogFailEvent( szMessage );
			
			fLGNoMoreLogWrite = fTrue;
			return err;
			}
		}
#endif

HandleError:
	if ( err < 0 )
		{
		BYTE szMessage[128];

		sprintf( szMessage, "Log Read File Header Fails. err = %d ", err );
		LGLogFailEvent( szMessage );
		fLGNoMoreLogWrite = fTrue;
		}
	
	return err;
	}


/*
 *	Create the log file name (no extension) corresponding to the usGeneration
 *	in szFName. NOTE: szFName need minimum 9 bytes.
 *
 *	PARAMETERS	rgbLogFileName	holds returned log file name
 *				usGeneration 	log generation number to produce	name for
 *	RETURNS		JET_errSuccess
 */
	
VOID LGSzFromLogId(
	CHAR *szFName,
	INT usGeneration )
	{
	INT	ich;

	strcpy( szFName, "jet00000" );
	for ( ich = 7; ich > 2; ich-- )
		{
		szFName[ich] = ( BYTE )'0' + ( BYTE ) ( usGeneration % 10 );
		usGeneration = usGeneration/10;
		}
	}


VOID LGGetDateTime( LOGTIME *plogtm )
	{
	_JET_DATETIME tm;
	
	UtilGetDateTime2( &tm );
	
	plogtm->bSeconds = (BYTE)tm.second;
	plogtm->bMinutes = (BYTE)tm.minute;
	plogtm->bHours = (BYTE)tm.hour;
	plogtm->bDay = (BYTE)tm.day;
	plogtm->bMonth = (BYTE)tm.month;
	plogtm->bYear = tm.year - 1900;
	}

	
/*
 *	Closes current log generation file, creates and initializes new
 *	log generation file in a safe manner.
 *
 *	PARAMETERS	plgfilehdr		pointer to log file header
 *				usGeneration 	current generation being closed
 *				fOld			TRUE if a current jet.log needs closing
 *
 *	RETURNS		JET_errSuccess, or error code from failing routine
 *
 *	COMMENTS	Active log file must be completed before new log file is
 *				called.
 */

ERR ErrLGNewLogFile( INT usGenerationToClose, BOOL fOldLog )
	{
	ERR			err;
	BYTE  		rgb[ 2 * cbSec + 16 ];
	BYTE  		szJetLog[_MAX_PATH];
	BYTE  		szJetTmpLog[_MAX_PATH];
	LOGTIME		tmOldLog;
	BYTE  		*pb;
	HANDLE		hfT = handleNil;

//	AssertCriticalSection( critLGFlush );
	
	LGMakeLogName( szJetLog, (CHAR *) szJet );
	LGMakeLogName( szJetTmpLog, (CHAR *) szJetTmp );

	/*  open an empty jettemp.log file
	/**/
#ifdef OVERLAPPED_LOGGING
	Call( ErrSysOpenFile( szJetTmpLog, &hfT, csecLGFile * cbSec, fFalse, fTrue ) );
#else
 	Call( ErrSysOpenFile( szJetTmpLog, &hfT, csecLGFile * cbSec, fFalse, fFalse ) );
 	Call( ErrSysNewSize( hfT, csecLGFile * cbSec, 0, fFalse ) == JET_errSuccess );
#endif

	/*	close active log file (if fOldLog is fTrue)
	/*	create new log file	under temporary name
	/*	rename active log file to archive name	jetnnnnn.log (if fOld is fTrue)
	/*	rename new log file to active log file name
	/*	open new active log file with ++usGenerationToClose
	/**/

	if ( fOldLog == fOldLogExists || fOldLog == fOldLogInBackup )
		{		
		/* there was a previous jet.log file, close it and
		/* create an archive name for it (don't rename it yet)
		/**/

		tmOldLog = plgfilehdrGlobal->tmCreate;

		if ( fOldLog == fOldLogExists )
			{
			CallS( ErrSysCloseFile( hfLog ) );
			hfLog = handleNil;
			}

		LGSzFromLogId( szFName, plgfilehdrGlobal->lgposLastMS.usGeneration );
		LGMakeLogName( szLogName, szFName );
		}
	else
		{
		/*	reset file hdr
		/**/
		memset( plgfilehdrGlobal, 0, sizeof(LGFILEHDR) );
		}

	/*	move new log file handle into global log file handle
	/**/
	Assert( hfLog == handleNil );
	hfLog = hfT;
	hfT = handleNil;

	EnterCriticalSection( critLGBuf );
	
	/*	set the global isecWrite, must be in critLGBuf.
	/**/
	isecWrite = sizeof (LGFILEHDR) / cbSec * 2;
	
	/*  initialize the new JetTemp.log file header.
	/*  NOTE: usGeneration automatically rolls over at 65536.
	/*  set lgposLastMS start at beginning
	/**/
	plgfilehdrGlobal->lgposLastMS.usGeneration = usGenerationToClose + 1;
	plgfilehdrGlobal->lgposLastMS.ib = 0;
	plgfilehdrGlobal->lgposLastMS.isec = sizeof(LGFILEHDR) / cbSec * 2;

	//	UNDONE: copied from jetnt\src\apirare.c, should be a macro
	plgfilehdrGlobal->ulRup = rup;
	plgfilehdrGlobal->ulVersion = ((unsigned long) rmj << 16) + rmm;
	strcpy(plgfilehdrGlobal->szComputerName, szComputerName);

	if ( fOldLog == fOldLogExists || fOldLog == fOldLogInBackup )
		{
		/*	set position of first record
		/**/
		Assert( lgposToFlush.usGeneration && lgposToFlush.isec );

		plgfilehdrGlobal->lgposFirst.ib = lgposToFlush.ib;
		
		Assert(isecWrite == sizeof (LGFILEHDR) / cbSec * 2);
		lgposToFlush.isec =
		plgfilehdrGlobal->lgposFirst.isec = (USHORT)isecWrite;
		plgfilehdrGlobal->tmPrevGen = tmOldLog;

		lgposToFlush.usGeneration =
			plgfilehdrGlobal->lgposFirst.usGeneration = plgfilehdrGlobal->lgposLastMS.usGeneration;
		}
	else
		{
		/*	no currently valid logfile initialize chkpnt to start of file
		/**/
		Assert( plgfilehdrGlobal->lgposLastMS.usGeneration == usGenerationToClose + 1 );
		Assert( plgfilehdrGlobal->lgposLastMS.ib == 0 );
		Assert( plgfilehdrGlobal->lgposLastMS.isec == sizeof(LGFILEHDR) / cbSec * 2 );
		
		plgfilehdrGlobal->lgposCheckpoint =
			plgfilehdrGlobal->lgposFirst = plgfilehdrGlobal->lgposLastMS;
		}
	
	LeaveCriticalSection( critLGBuf );

	LGGetDateTime( &plgfilehdrGlobal->tmCreate );
	LGStoreDBEnv( &plgfilehdrGlobal->dbenv );
	
	CallJ( ErrLGWriteFileHdr( plgfilehdrGlobal ), CloseJetTmp );

	if ( fOldLog == fOldLogExists || fOldLog == fOldLogInBackup )
		{
		CallJ( ErrLGWrite( isecWrite, pbWrite, 1 ), CloseJetTmp );
		}
	else
		{
		Assert( sizeof(LRTYP) == 1 );
		pb = (BYTE *) ( (ULONG_PTR) ( rgb + 16 ) & ~0x0f );
		pb[0] = pb[cbSec] = lrtypFill;
		CallJ( ErrLGWrite( isecWrite, pb, 2 ), CloseJetTmp );
		}
	
CloseJetTmp:
	/*	close new file JetTmp.log
	/**/
	CallS( ErrSysCloseFile( hfLog ) );
	hfLog = handleNil;
	
	/*	err returned from ErrLGWriteFileHdr
	/**/
	Call( err );

	if ( fOldLog == fOldLogExists )
		{
		/*	there was a previous jet.log: rename it to its archive name
		/**/
		Call( ErrSysMove( szJetLog, szLogName ) );	
		}

	/*	rename jettmp.log to jet.log, and open it as jet.log
	/**/
	err = ErrSysMove( szJetTmpLog, szJetLog );
	
HandleError:
	if ( err < 0 )
		{
		BYTE szMessage[128];

		sprintf( szMessage, "Log New Log File Fails. err = %d ", err );
		LGLogFailEvent( szMessage );
		fLGNoMoreLogWrite = fTrue;
		}

	return err;
	}																		

		
#ifdef	ASYNC_LOG_FLUSH

/*
 *	Log flush thread is signalled to flush log asynchronously when at least
 *	cThreshold disk sectors have been filled since last flush.
 */
VOID LGFlushLog( VOID )
	{
	forever
		{
		SignalWait( sigLogFlush, cmsLGFlushPeriod );

		/*	error may be returned if conflicting files
		 *	exist.  Async flush should do nothing and let error be
		 *	propogated to user when synchronous flush occurs.
		 */
#ifdef PERFCNT		
		(void) ErrLGFlushLog( 1 );
#else
		(void) ErrLGFlushLog( );
#endif

		if ( fLGFlushLogTerm )
			break;
		}

//	SysExitThread( 0 );

	return;
	}

#endif	/* ASYNC_LOG_FLUSH */


/*	check formula - make last MS (isec, ib) as a long l. add l
 *	and all the longs that are aligned on 256 boundary up to
 *	current MS.
 */
ULONG UlLGMSCheckSum( CHAR *pbLrmsNew )
	{
	ULONG ul = lgposLastMSFlush.isec << 16 | lgposLastMSFlush.ib;
	CHAR *pb;

	if ( !pbLastMSFlush )
		pb = pbLGBufMin;
	else
		{
		pb = (( pbLastMSFlush - pbLGBufMin ) / 256 + 1 ) * 256 + pbLGBufMin;

		/*	make sure the lrms is not be used for checksum.
		/*/
		if ( pbLastMSFlush + sizeof( LRMS ) > pb )
			pb += 256;
		}

	if ( pbLrmsNew < pbLastMSFlush )
		{
		/*	Wrapp around
		/*/
		while ( pb < pbLGBufMax )
			{
			ul += *(ULONG *) pb;
			pb += 256;
			}
		pb = pbLGBufMin;
		}

	/*	LRMS may be changed during next operation, do not take any possible LRMS for checksum.
	/*/
	while ( pb + sizeof( LRMS ) < pbLrmsNew )
		{
		ul += *(ULONG *) pb;
		pb += 256;
		}

	return ul;
	}


/*
 *	Flushes log buffer to log generation files.	 This function is
 *	called synchronously from wait flush and asynchronously from
 *	log buffer flush thread.
 *
 *	PARAMETERS	lgposMin, flush log records up to or pass lgposMin.
 *
 *	RETURNS		JET_errSuccess, or error code from failing routine
 */
#ifdef PERFCNT
ERR ErrLGFlushLog( BOOL fCalledByLGFlush )
#else
ERR ErrLGFlushLog( VOID )
#endif
	{
	ERR		err = JET_errSuccess;
	INT		csecWrapAround;
	BOOL  	fSingleSectorFlush;
	BOOL  	fFirstMSFlush = fFalse;
	CHAR  	*pbNextToWrite;
	INT		csecToWrite;
	CHAR  	*pbEntryT;
	CHAR  	*pbWriteNew;
	INT		isecWriteNew;
	LGPOS 	lgposToFlushT;
	BOOL  	fDoneCheckPt = fFalse;
	INT		cbToWrite;
	INT		cbWritten;
	
#ifdef OVERLAPPED_LOGGING
	INT		isig;
	OLP		*polpLogT;
	ULONG  	ulOffset;
#endif

	/*	use semLGFlush to make sure only one user is doing flush
	/**/
	EnterCriticalSection( critLGFlush );

	/* use semLGEntry to do:
	 * (1) make sure the pbEntry is read correctly
	 * (2) we may also hold semLGEntry to insert a lrFlushPoint record.
	 *     which may also update lgposLast.
	 */
	EnterCriticalSection( critLGBuf );

	if ( fLGNoMoreLogWrite )
		{
		/*	if previous error then do nothing
		/**/
		LeaveCriticalSection(critLGBuf);
		LeaveCriticalSection(critLGFlush);
		return JET_errLogWriteFail;
		}
	
	if ( hfLog == handleNil )
		{
		/*	log file not ready yet. do nothing
		/**/
		LeaveCriticalSection(critLGBuf);
		LeaveCriticalSection(critLGFlush);
		return JET_errSuccess;
		}

	/* NOTE: we can only grep semLGWrite, then semLGEntry to avoid */
	/* NOTE: dead lock. */
								
	if ( !fNewLogRecordAdded )
		{
		/* nothing to flush! */
		lgposToFlushT = lgposToFlush;
		LeaveCriticalSection(critLGBuf);
		if ( ppibLGFlushQHead != ppibNil )
			goto WakeUp;
		LeaveCriticalSection(critLGFlush);
		
		return JET_errSuccess;
		}


#ifdef PERFCNT
    if ( fCalledByLGFlush )
		{
		if ( cXactPerFlush < 10 )
			rgcCommitByLG[cXactPerFlush]++;
		}
	else
		{
		if ( cXactPerFlush < 10 )
			rgcCommitByUser[cXactPerFlush]++;
		}
#endif
	cXactPerFlush = 0;

	/*  check if more than one disk sectors need be flushed. If there are
	 *  then add an lrtypFlushPoint record at the end.
	 */
	Assert( pbEntry <= pbLGBufMax && pbEntry >= pbLGBufMin );
	Assert( pbWrite < pbLGBufMax && pbWrite >= pbLGBufMin );
	Assert( pbWrite != NULL && pbWrite == PbSecAligned( pbWrite ) );

	/* check wraparound. */
	if ( pbEntry < pbWrite )
		{		
		Assert( pbWrite != NULL && pbWrite == PbSecAligned( pbWrite ) );
		csecWrapAround = (INT)( pbLGBufMax - pbWrite ) / cbSec;
		pbNextToWrite = pbLGBufMin;
		}
	else
		{
		csecWrapAround = 0;
		pbNextToWrite = pbWrite;
		}

	/* pbEntry + 1 for Fill logrec. */
	Assert(sizeof(LRTYP) == 1);
	Assert(pbNextToWrite == PbSecAligned(pbNextToWrite));
	csecToWrite = (INT)(pbEntry - pbNextToWrite) / cbSec + 1;

	/* check if this is a multi-sector flush */
	if ((csecWrapAround + csecToWrite) == 1)
		{
		Assert(fTrue == 1);
		Assert(csecToWrite == 1);
		fSingleSectorFlush = fTrue;
		}
	else
		{
		LINE	rgline[1];
		INT	cbToFill;
		LRMS	lrmsLastMSFlush;
		CHAR	*pbLastMSFlushNew;
		
		fSingleSectorFlush = fFalse;
		
		/*  more than one page will be flushed. Append lrtypeFlush.
		 *  Note there must be enough space for it because before we
		 *  add new log rec into the buffer (ErrLGLogRec), we also
		 *  check if there is enough space for adding flush log record.
		 */

		/*  If the flush record is accrossing a sector boundary, put NOP
		 *  to fill to the rest of sector, and start it in the beginning
		 *  of the next new sector. Also adjust csecToWrite.
		 *  NOTE: we must guarrantee that the whole LastFlush log record
		 *  NOTE: on the same sector so that when we update LastFlush
		 *  NOTE: we can always assume that it is in the buffer.
		 *  NOTE: even the whole LRMS ends with sec boundary, we still need
		 *  NOTE: to move the record to next sector so that we can guarantee
		 *  NOTE: after flush, the last sector is still in buffer, such that
		 *  NOTE: pbLastMSFlush is still effective.
		 */
		cbToFill = (cbSec * 2 - (INT)(pbEntry - PbSecAligned(pbEntry))) % cbSec;
		Assert( pbEntry != pbLGBufMax || cbToFill == 0 );

		if ( cbToFill == 0 )
			{
			/* check if wraparound occurs */
			if (pbEntry == pbLGBufMax)
				{
				pbEntry = pbLGBufMin;
				csecWrapAround = csecToWrite - 1;
				csecToWrite = 1;
				}
			}
		else if ( cbToFill <= sizeof(LRMS) )
			{
			CHAR *pbEOS = pbEntry + cbToFill;
			Assert(sizeof(LRTYP) == 1);
			for ( ; pbEntry < pbEOS; pbEntry++ )
				*(LRTYP*)pbEntry = lrtypNOP;
			Assert(pbEntry == PbSecAligned(pbEntry));

			/* one more sector that will contain flush rec only. */			
			Assert(fSingleSectorFlush == fFalse);

			/* check if wraparound occurs */
			if (pbEntry == pbLGBufMax)
				{
				pbEntry = pbLGBufMin;
				csecWrapAround = csecToWrite;
				csecToWrite = 1;
				}
			else
				{
				csecToWrite++;
				}
			}

		/*  add the flush record, which should never cause
		 *  wraparound after the check above.
		 */
		
		/* remember where the FlushRec is inserted */
		Assert(pbEntry <= pbLGBufMax && pbEntry >= pbLGBufMin);
		pbLastMSFlushNew = pbEntry;

		/* insert a MS log record. */
		lrmsLastMSFlush.lrtyp = lrtypMS;
		lrmsLastMSFlush.ibForwardLink = 0;		
		lrmsLastMSFlush.isecForwardLink = 0;
		lrmsLastMSFlush.ibBackLink = lgposLastMSFlush.ib;
		lrmsLastMSFlush.isecBackLink = lgposLastMSFlush.isec;
		lrmsLastMSFlush.ulCheckSum = UlLGMSCheckSum( pbEntry );

#ifdef DEBUG
		{
		CHAR *pbEntryT = (pbEntry == pbLGBufMax) ? pbLGBufMin : pbEntry;
#endif
		
		GetLgposOfPbEntry( &lgposLogRec );
	
		Assert( lgposLogRec.isec != lrmsLastMSFlush.isecBackLink );

		rgline[0].pb = (CHAR *)&lrmsLastMSFlush;
		rgline[0].cb = sizeof(LRMS);
		AddLogRec( rgline[0].pb, rgline[0].cb, &pbEntry );
		
#ifdef DEBUG
		if (fDBGTraceLog)
			{
			PrintF2("\n(%3u,%3u)", lgposLogRec.isec, lgposLogRec.ib);
			ShowLR((LR*)pbEntryT);
			}
		}
#endif

		((LR *) pbEntry)->lrtyp = lrtypFill;
			
		/* at this point, lgposLogRec is pointing at the MS rec */
		Assert(lgposLogRec.usGeneration == plgfilehdrGlobal->lgposLastMS.usGeneration);

		/*  previous flush log must be in memory still. Set the
		 *  previous flush log record to point to the new flush log rec.
		 */
		if (pbLastMSFlush)
			{
			LRMS *plrms = (LRMS *)pbLastMSFlush;
			Assert(plrms->lrtyp == lrtypMS);
			plrms->ibForwardLink = lgposLogRec.ib;
			plrms->isecForwardLink = lgposLogRec.isec;
			}
		else
			{
			/* brandnew MS flush. */
			plgfilehdrGlobal->lgposFirstMS = lgposLogRec;
			fFirstMSFlush = fTrue;
			}
		
		lgposLastMSFlush =
		plgfilehdrGlobal->lgposLastMS = lgposLogRec;
		pbLastMSFlush = pbLastMSFlushNew;
		}


	/*  release pbEntry so that other user can continue adding log records
	 *  while we are flushing log buffer. Note that we only flush up to
	 *  pbEntryT.
	 */
	pbEntryT = pbEntry;

	/* set the lgposToFlush. */
	GetLgposOfPbEntry( &lgposToFlushT );
	isecWriteNew = isecWrite;
	fNewLogRecordAdded = fFalse;
	
	LeaveCriticalSection( critLGBuf );

#ifdef OVERLAPPED_LOGGING	
	/* move disk head to the given offset */
	ulOffset = isecWriteNew * cbSec;
	isig = 0;
	polpLogT = rgolpLog;
#else
 	{
 	ULONG	ulFilePointer;

 	SysChgFilePtr( hfLog, isecWriteNew * cbSec, NULL, FILE_BEGIN, &ulFilePointer );
 	Assert( ulFilePointer == (ULONG) isecWriteNew * cbSec );
 	}
#endif

	/*	Always wirte first page first to make sure the following case won't happen
	 *	OS write and destroy shadow page, and then failed while writing the first page
	 */

#ifdef DEBUG
	if (fDBGTraceLogWrite)
		PrintF2(
			"\n0. Writing %d sectors into sector %d from buffer (%u,%u).",
			1, isecWriteNew, pbWrite, pbEntry);
#endif
		
#ifdef OVERLAPPED_LOGGING
	polpLogT->ulOffset = ulOffset;
	Assert( polpLogT->ulOffsetHigh == 0 );
	SignalReset( polpLogT->sigIO );
	err = ErrSYSWriteBlockOverlapped(
					hfLog,
					pbWrite,
					cbSec,
					&cbWritten,
					polpLogT );
	if ( err < 0 )
		{
		BYTE szMessage[128];

		sprintf( szMessage, "Log Flush Write 0 Fails. err = %d ", err );
		LGLogFailEvent( szMessage );
		fLGNoMoreLogWrite = fTrue;
		goto WriteFail;
		}

	ulOffset += cbToWrite;
	rgcbToWrite[isig] = cbToWrite;
	rgsig[isig++] = polpLogT->sigIO;
	polpLogT++;
#else
		
#ifdef NO_WRITE
	goto EndOfWrite0;
#endif

	err = ErrSysWriteBlock( hfLog, pbWrite,	cbSec, &cbWritten );
	if ( err < 0 )
		{
		BYTE szMessage[128];

		sprintf( szMessage, "Log Flush Write 0 Fails. err = %d ", err );
		LGLogFailEvent( szMessage );
		fLGNoMoreLogWrite = fTrue;
		goto WriteFail;
		}
	Assert( cbWritten == cbSec );

#ifdef NO_WRITE
EndOfWrite0:
#endif
#endif
		
	isecWriteNew++;
	pbWriteNew = pbWrite + cbSec;

	if ( !csecWrapAround )
		{
		/*	first sec was written out already, decrement csecToWrite.
		 *	csecToWrite is ok to be 0.
		 */
		csecToWrite--;
		}
	else if ( csecWrapAround == 1 )
		{
		Assert( csecToWrite >= 1 );
		Assert( pbWriteNew == pbLGBufMax );

		pbWriteNew = pbLGBufMin;
		}
	else
		{
		Assert( csecToWrite >= 1 );
		
		/*	first sec was written out already, decrement number of WrapAround
		 */
		csecWrapAround--;
		
#ifdef OVERLAPPED_LOGGING
		cbToWrite = csecWrapAround * cbSec;
#endif
		
		Assert( csecWrapAround <= (INT) csecLGBuf );

#ifdef DEBUG
		if (fDBGTraceLogWrite)
			PrintF2(
				"\n1.Writing %d sectors into sector %d from buffer (%u,%u).",
				csecWrapAround, isecWriteNew, pbWrite, pbEntry);
#endif
		
#ifdef OVERLAPPED_LOGGING
		polpLogT->ulOffset = ulOffset;
		Assert( polpLogT->ulOffsetHigh == 0 );
		SignalReset( polpLogT->sigIO );
		err = ErrSysWriteBlockOverlapped(
					hfLog,
					pbWriteNew,
					cbToWrite,
					&cbWritten,
					polpLogT );
		if ( err < 0 )
			{
			BYTE szMessage[128];

			sprintf( szMessage, "Log Flush Write 1 Fails. err = %d ", err );
			LGLogFailEvent( szMessage );
			fLGNoMoreLogWrite = fTrue;
			goto WriteFail;
			}

		ulOffset += cbToWrite;
		rgcbToWrite[isig] = cbToWrite;
		rgsig[isig++] = polpLogT->sigIO;
		polpLogT++;
#else
		
#ifdef NO_WRITE
		goto EndOfWrite1;
#endif

 		err = ErrSysWriteBlock(
					hfLog,
					pbWriteNew,
 					csecWrapAround * cbSec,
 					&cbWritten );
		if ( err < 0 )
			{
			BYTE szMessage[128];

			sprintf( szMessage, "Log Flush Write 1 Fails. err = %d ", err );
			LGLogFailEvent( szMessage );
			fLGNoMoreLogWrite = fTrue;
			goto WriteFail;
			}
 		Assert( cbWritten == csecWrapAround * cbSec );
		
#ifdef NO_WRITE
EndOfWrite1:
#endif
#endif
		isecWriteNew += csecWrapAround;
		pbWriteNew = pbLGBufMin;
		}
	
	Assert( pbWriteNew != NULL && pbWriteNew == PbSecAligned( pbWriteNew ) );
	Assert ( csecToWrite >= 0 );

	cbToWrite = csecToWrite * cbSec;

	if ( cbToWrite == 0 )
		goto EndOfWrite2;
		
#ifdef DEBUG
	if (fDBGTraceLogWrite)
		PrintF2(
			"\n2.Writing %d sectors into sector %d from buffer (%u,%u).",
			csecToWrite, isecWriteNew, pbWriteNew, pbEntry);
#endif

#ifdef OVERLAPPED_LOGGING
	polpLogT->ulOffset = ulOffset;
	Assert( polpLogT->ulOffsetHigh == 0 );
	SignalReset( polpLogT->sigIO );
	err = ErrSysWriteBlockOverlapped(
					hfLog,
					pbWriteNew,
					cbToWrite,
					&cbWritten,
					polpLogT );
	if ( err < 0 )
		{
		BYTE szMessage[128];

		sprintf( szMessage, "Log Flush Write 2 Fails. err = %d ", err );
		LGLogFailEvent( szMessage );
		fLGNoMoreLogWrite = fTrue;
		goto WriteFail;
		}
	rgcbToWrite[isig] = cbToWrite;
	rgsig[isig++] = polpLogT->sigIO;
	polpLogT++;
#else
		
#ifdef NO_WRITE
	goto EndOfWrite2;
#endif
 	err = ErrSysWriteBlock(
					hfLog,
					pbWriteNew,
					cbToWrite,
 					&cbWritten );
	if ( err < 0 )
		{
		BYTE szMessage[128];

		sprintf( szMessage, "Log Flush Write 2 Fails. err = %d ", err );
		LGLogFailEvent( szMessage );
		fLGNoMoreLogWrite = fTrue;
		goto WriteFail;
		}
 	Assert( cbWritten == cbToWrite );
#endif

EndOfWrite2:

#ifdef OVERLAPPED_LOGGING
	polpLogT->ulOffset = ulOffset + cbToWrite;
	Assert( polpLogT->ulOffsetHigh == 0 );
	SignalReset( polpLogT->sigIO );
	err = ErrSysWriteBlockOverlapped(
					hfLog,
					pbWriteNew + cbToWrite - cbSec,
					cbSec,
					&cbWritten,
					polpLogT);
	if ( err < 0 )
		{
		BYTE szMessage[128];

		sprintf( szMessage, "Log Flush Write 3 Fails. err = %d ", err );
		LGLogFailEvent( szMessage );
		fLGNoMoreLogWrite = fTrue;
		goto WriteFail;
		}
	rgcbToWrite[isig] = cbSec;
	rgsig[isig++] = polpLogT->sigIO;
#else
#ifdef NO_WRITE
	goto EndOfWrite3;
#endif
	err = ErrSysWriteBlock(
					hfLog,
					pbWriteNew + cbToWrite - cbSec,
					cbSec,
 					&cbWritten );
	if ( err < 0 )
		{
		BYTE szMessage[128];

		sprintf( szMessage, "Log Flush Write 3 Fails. err = %d ", err );
		LGLogFailEvent( szMessage );
		fLGNoMoreLogWrite = fTrue;
		goto WriteFail;
		}
	Assert( cbWritten == cbSec );
#ifdef NO_WRITE
EndOfWrite3:
#endif
#endif

#ifdef OVERLAPPED_LOGGING
//		UtilMultipleSignalWait( isig, rgsig, fTrue /* wait all */, -1);
		{
		OLP	*polpLogCur = rgolpLog;
		INT	*pcbToWrite = rgcbToWrite;

		for ( ; polpLogCur <= polpLogT; polpLogCur++, pcbToWrite++ )
			{
			INT cb;
			
			err = ErrSysGetOverlappedResult( hfLog, polpLogCur, &cb, fTrue/*wait*/ );
			if ( err == JET_errSuccess && cb != *pcbToWrite )
				{
				BYTE szMessage[128];

				sprintf( szMessage, "Log Flush Wait Fails. err = %d ", err );
				LGLogFailEvent( szMessage );
				fLGNoMoreLogWrite = fTrue;
				err = JET_errLogWriteFail;
				}
			CallJ( err, WriteFail );
			}
		}
#endif

	/* last page is not full, need to rewrite next time. */
	Assert( pbWriteNew + cbToWrite > pbEntryT );
		
	pbWriteNew += cbToWrite - cbSec;
	Assert( pbWriteNew < pbEntryT );
	Assert( pbWriteNew != NULL && pbWriteNew == PbSecAligned( pbWriteNew ) );

	isecWriteNew += csecToWrite - 1;

	/* Free up buffer space. */
	/* use semaphore to make sure the assignment will not */
	/* other user to read pbWrite and lgposToFlush */

	EnterCriticalSection( critLGBuf );
	
	Assert( pbWriteNew < pbLGBufMax && pbWriteNew >= pbLGBufMin );
	Assert( pbWriteNew != NULL && pbWriteNew == PbSecAligned( pbWriteNew ) );
	
	lgposToFlush = lgposToFlushT;
	isecWrite = isecWriteNew;
	pbWrite = pbWriteNew;
	
	LeaveCriticalSection(critLGBuf);

	/*	check if it is the first time to have multi-sec flush
	 */
	if ( fFirstMSFlush )
		{
		csecLGCheckpointCount = csecLGCheckpointPeriod;
		
		/*	update checkpoint
		/**/
		LGUpdateCheckpoint();
		
		/* rewrite file header
		/**/
		CallJ( ErrLGWriteFileHdr( plgfilehdrGlobal ), WriteFail );
		
		fDoneCheckPt = fTrue;
		}		
	
	/*  Go through the waiting list and wake those whose log records
	 *  were flushed in this batch.
	 */
WakeUp:
		{
		PIB *ppibT;
	
		/* wake it up! */
		EnterCriticalSection(critLGWaitQ);
			
		for (ppibT = ppibLGFlushQHead;
			 ppibT != ppibNil;
			 ppibT = ppibT->ppibNextWaitFlush)
			{
			if (CmpLgpos(ppibT->plgposCommit, &lgposToFlushT) <= 0)
				{
				Assert(ppibT->fLGWaiting);
				ppibT->fLGWaiting = fFalse;
	
				if (ppibT->ppibPrevWaitFlush)
					ppibT->ppibPrevWaitFlush->ppibNextWaitFlush =
					ppibT->ppibNextWaitFlush;
				else
					ppibLGFlushQHead = ppibT->ppibNextWaitFlush;
			
				if (ppibT->ppibNextWaitFlush)
					ppibT->ppibNextWaitFlush->ppibPrevWaitFlush =
					ppibT->ppibPrevWaitFlush;
				else
					ppibLGFlushQTail = ppibT->ppibPrevWaitFlush;
				
				SignalSend(ppibT->sigWaitLogFlush);
				}
			}
		LeaveCriticalSection(critLGWaitQ);
		}

	/*	it is time for check point.
	/**/
	if ( ( csecLGCheckpointCount -= ( csecWrapAround + csecToWrite ) ) < 0 )
		{
		csecLGCheckpointCount = csecLGCheckpointPeriod;
		
		/*	update checkpoint
		/**/
		LGUpdateCheckpoint();
		
		/* rewrite file header
		/**/
		CallJ( ErrLGWriteFileHdr( plgfilehdrGlobal ), WriteFail );
		
		fDoneCheckPt = fTrue;
		}		

#ifdef DEBUG
	if (!fRecovering && pbLastMSFlush)
		{
		LRMS *plrms = (LRMS *)pbLastMSFlush;
		Assert(plrms->lrtyp == lrtypMS);
		}
#endif
		
	/*
	 *  Check if new generation should be created. We create continuous
	 *  log generation file only when Multiple sectors flush occurs so
	 *  that no MS sector can be half flushed in one log file and the
	 *  other half in another log file.
	 */
	if (!fSingleSectorFlush &&		/* MS Flushed */
		isecWrite > csecLGFile )	/* larger than desired LG File size */
		{
		if (!fDoneCheckPt)
			{
			/* restart check point counter. */
			csecLGCheckpointCount = csecLGCheckpointPeriod;
		
			/* obtain checkpoint */
			LGUpdateCheckpoint( );
			}
		
		plgfilehdrGlobal->fEndWithMS = fTrue;
		
		CallJ( ErrLGWriteFileHdr( plgfilehdrGlobal ), WriteFail )
		
		CallJ( ErrLGNewLogFile(
			plgfilehdrGlobal->lgposLastMS.usGeneration,
			fOldLogExists ), WriteFail)
		
		strcpy( szFName, szJet );
		LGMakeLogName( szLogName, (CHAR *) szFName );
		
#ifdef OVERLAPPED_LOGGING
		err = ErrSysOpenFile( szLogName, &hfLog, 0L, fFalse, fTrue );
#else
 		err = ErrSysOpenFile( szLogName, &hfLog, 0L, fFalse, fFalse );
#endif
		if ( err < 0 )
			{
			BYTE szMessage[128];

			sprintf( szMessage, "Log Flush Open New File Fails. err = %d ", err );
			LGLogFailEvent( szMessage );
			fLGNoMoreLogWrite = fTrue;
			goto WriteFail;
			}
		CallJ( ErrLGReadFileHdr( hfLog, plgfilehdrGlobal ), WriteFail)
		Assert( isecWrite == sizeof( LGFILEHDR ) / cbSec * 2 );
			
		/* set up a special case for pbLastMSFlush */
		pbLastMSFlush = 0;
		memset( &lgposLastMSFlush, 0, sizeof(lgposLastMSFlush) );
		plgfilehdrGlobal->fEndWithMS = fFalse;
		}
	
WriteFail:
	LeaveCriticalSection(critLGFlush);
	
	return err;
	}


/*	Computes a new log checkpoint, which is the usGeneration, isec and ib
/*	of the oldest transaction which either modified a currently-dirty buffer
/*	an uncommitted version (RCE).  Recovery begins recovering from the
/*	most recent checkpoint.
/*
/*	The checkpoint is stored in the log file header, which is rewritten
/*	whenever a isecChekpointPeriod disk sectors are written.
/**/
VOID LGUpdateCheckpoint( VOID )
	{
	PIB		*ppibT;
	RCE		*prceLast;
	LGPOS	lgposCheckpoint;

#ifdef DEBUG
	if ( fDBGFreezeCheckpoint )
		return;
#endif
	
	if ( fLogDisabled )
		return;

	if ( fFreezeCheckpoint )
		return;

	/*	find the oldest transaction which dirtied a current buffer
	/**/
	BFOldestLgpos( &lgposCheckpoint );

	/*	find the oldest transaction with an uncommitted update
	/**/
	for ( ppibT = ppibAnchor; ppibT != NULL; ppibT = ppibT->ppibNext )
		{
		if ( ppibT->pbucket != NULL )
			{
			//	UNDONE:	decouple with nver.h macro
			prceLast = (RCE *)( (BYTE *)ppibT->pbucket + ppibT->pbucket->ibNewestRCE );
			
			if ( prceLast->trxCommitted == trxMax &&
				CmpLgpos( &ppibT->lgposStart, &lgposCheckpoint ) < 0 )
				lgposCheckpoint = ppibT->lgposStart;
			}
		}

	if ( CmpLgpos( &lgposCheckpoint, &lgposMax ) == 0 )
		{
		/*	nothing logged, up to the last fulsh point
		/**/
		plgfilehdrGlobal->lgposCheckpoint = lgposToFlush;
		plgfilehdrGlobal->lgposCheckpoint.usGeneration =
			plgfilehdrGlobal->lgposLastMS.usGeneration;
		}
	else
		{
		plgfilehdrGlobal->lgposCheckpoint = lgposCheckpoint;
		}
	
	LGStoreDBEnv( &plgfilehdrGlobal->dbenv );
	
	if ( lgposFullBackup.usGeneration )
		{
		/*	full backup in progress
		/**/
		plgfilehdrGlobal->lgposFullBackup = lgposFullBackup;
		plgfilehdrGlobal->logtimeFullBackup = logtimeFullBackup;
		}
		
	if ( lgposIncBackup.usGeneration )
		{
		/*	incremental backup in progress
		/**/
		plgfilehdrGlobal->lgposIncBackup = lgposIncBackup;
		plgfilehdrGlobal->logtimeIncBackup = logtimeIncBackup;
		}
		
	return;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\fucb.c ===
#include "config.h"

#include <string.h>

#include "daedef.h"
#include "pib.h"
#include "util.h"
#include "fmp.h"
#include "page.h"
#include "ssib.h"
#include "fcb.h"
#include "fucb.h"
#include "stapi.h"

DeclAssertFile;					/* Declare file name for assert macros */


static CSR csrTemplate =
	{
	ulDBTimeMin,			// page time stamp
	NULL,						// parent currency
	pgnoNull,				// pgno of node page
	sridNull,				//	bookmark of node
	sridNull,				// item
	csrstatBeforeFirst,	// status of csr relative to node
	itagNull,				// node itag
	isridNull,				// index of item in item list
	itagNull,	  			// itag of father
	ibSonNull,				// index of son in father son table
	};


ERR ErrFUCBAllocCSR( CSR **ppcsr )
	{
	CSR *pcsr;

	pcsr = PcsrMEMAlloc( );
	if ( !pcsr )
		return JET_errOutOfMemory;

	*pcsr = csrTemplate;

	Assert(	pcsr->csrstat == csrstatBeforeFirst );
	Assert(	pcsr->pgno == pgnoNull );
	Assert(	pcsr->itag == itagNull );
	Assert(	pcsr->itagFather == itagNull );
	Assert(	pcsr->ibSon	== ibSonNull );
	Assert(	pcsr->isrid	== isridNull );
	Assert(	pcsr->pcsrPath == NULL );

	*ppcsr = pcsr;
	return JET_errSuccess;
	}


//+api
//	ErrFUCBNewCSR
//	========================================================================
//	ERR ErrFUCBNewCSR( FUCB *pfucb )
//	
//	Insert a null csr in the bottom of path of pfucb.
//
//	PARAMETERS	pfucb
//
//	RETURNS		JET_errOutOfMemory
//-
ERR ErrFUCBNewCSR( FUCB *pfucb )
	{
	ERR err;
	CSR **ppcsr;
	CSR *pcsr;

	CallR( ErrFUCBAllocCSR( &pcsr ) );

	ppcsr = &PcsrCurrent( pfucb );
	pcsr->pcsrPath = *ppcsr;
	*ppcsr = pcsr;

	return JET_errSuccess;
	}


//+api
//	FUCBFreeCSR
//	========================================================================
//	VOID FUCBFreeCSR( FUCB *pfucb )
//
//	Delete the csr in the bottom of path of pfucb.
//
//	PARAMETERS	pfucb
//	RETURNS		JET_errOutOfMemory
//-
VOID FUCBFreeCSR( FUCB *pfucb )
	{
	CSR **ppcsr = &PcsrCurrent( pfucb );
	CSR *pcsr;

	*ppcsr = ( pcsr = *ppcsr )->pcsrPath;
	MEMReleasePcsr( pcsr );
	return;
	}


//+api
//	FUCBFreePath
//	========================================================================
//	VOID FUCBFreePath( CSR **ppcsr, CSR *pcsrMark )
//
//	Delete all the csr in the current path of pfucb.
//
//	PARAMETERS	pfucb
//
//	RETURNS		JET_errOutOfMemory
//-
VOID FUCBFreePath( CSR **ppcsr, CSR *pcsrMark )
	{
	while ( *ppcsr != pcsrMark )
		{
		CSR *pcsrTmp = *ppcsr;
		*ppcsr = pcsrTmp->pcsrPath;
		MEMReleasePcsr( pcsrTmp );
		}
	return;
	}



//+api
//	ErrFUCBOpen
//	------------------------------------------------------------------------
//	ERR ErrFUCBOpen( PIB *ppib, DBID dbid, FUCB **ppfucb );
//
//	Creates an open FUCB. At this point, no FCB is assigned yet.
//
//	PARAMETERS	ppib	PIB of this user
//				dbid	Database Id.
//				ppfucb	Address of pointer to FUCB.	 If *ppfucb == NULL, 
//						an FUCB is allocated and **ppfucb is set to its
//						address.  Otherwise, *ppfucb is assumed to be
//						pointing at a closed FUCB, to be reused in the open.
//
//	RETURNS		JET_errSuccess if successful.
//					JET_errNoMoreCursors
//					ErrFUCBNewCSR: JET_errOutOfMemory.
//
//	SIDE EFFECTS	links the newly opened FUCB into the chain of open FUCBs
//					for this session.
//
//	SEE ALSO		ErrFUCBClose
//-
ERR ErrFUCBOpen( PIB *ppib, DBID dbid, FUCB **ppfucb ) 
	{
	ERR err;
	FUCB *pfucb;
	
	/*	if no fucb allocate new fucb and initialize it
	/*	and allocate csr
	/*	pib must be set before call to NewCSR
	/**/

	pfucb = PfucbMEMAlloc( );
	if ( pfucb == pfucbNil )
		{
		err = JET_errNoMoreCursors;
		return err;
		}
	/*	memset implicitly clears pointer cache
	/**/
	//Assert( pfucb->pfucbNext == (FUCB *)0xffffffff );
	memset( (BYTE *)pfucb, '\0', sizeof( FUCB ) );

	if ( FDBIDReadOnly( dbid ) )
		FUCBResetUpdatable( pfucb );
	else
		FUCBSetUpdatable( pfucb );

	pfucb->dbid = dbid;
	SSIBSetDbid( &pfucb->ssib, dbid );
	pfucb->ssib.pbf = PbfBFMostUsed();
	pfucb->pbfEmpty = pbfNil;

	// set ppib before set NewCSR
	pfucb->ppib = ppib;
	pfucb->ssib.ppib = ppib;

	/* allocate a CSR for this fucb
	/**/
	Call( ErrFUCBNewCSR( pfucb ) );
	pfucb->levelOpen = ppib->level;

	/*	link new FUCB into user chain, only when success is sure
	/*	as unlinking NOT handled in error
	/**/
	if ( *ppfucb == pfucbNil )
		{
		*ppfucb = pfucb;
		// link the fucb now
		pfucb->pfucbNext = ( FUCB * )ppib->pfucb;
		ppib->pfucb = pfucb;
		return JET_errSuccess;
		}

	pfucb->pfucbCurIndex = pfucbNil;
	return JET_errSuccess;

HandleError:
	MEMReleasePfucb( pfucb );
	return err;
	}


//+api
//	FUCBClose
//	------------------------------------------------------------------------
//	FUCBClose( FUCB *pfucb )
//
//	Closes an active FUCB, optionally returning it to the free FUCB pool.
//	All the pfucb->pcsr are freed.
//
//	PARAMETERS		pfucb		FUCB to close.	Should be open. pfucb->ssib should
//									hold no page.
//
//	SIDE EFFECTS	Unlinks the closed FUCB from the FUCB chain of its
//					   associated PIB and FCB.
//
//	SEE ALSO		ErrFUCBOpen
//-
VOID FUCBClose( FUCB *pfucb )
	{
	FUCB		*pfucbPrev;

	FUCBFreePath( &PcsrCurrent( pfucb ), pcsrNil );

	/*	locate the pfucb in this thread and take it out of the fucb list
	/**/
	pfucbPrev = (FUCB *)( (BYTE *)&pfucb->ppib->pfucb - (BYTE *)&( (FUCB *)0 )->pfucbNext );
	while ( pfucbPrev->pfucbNext != pfucb )
		{
		pfucbPrev = pfucbPrev->pfucbNext;
		Assert( pfucbPrev != pfucbNil );
		}
	pfucbPrev->pfucbNext = pfucb->pfucbNext;

	/*	set ppibNil to detect bogus reusage.
	/**/
	#ifdef DEBUG
		pfucb->ppib = ppibNil;
	#endif

	/*	release key buffer if one was allocated.
	/**/
	if ( pfucb->pbKey != NULL )
		{
		LFree( pfucb->pbKey );
		pfucb->pbKey = NULL;
		}

	Assert( pfucb->pbfEmpty == pbfNil );

	/* release the fucb
	/**/
	MEMReleasePfucb( pfucb );
	return;
	}


VOID FUCBRemoveInvisible( CSR **ppcsr )
	{
	CSR	*pcsr;
	CSR	*pcsrPrev;
	
	Assert( ppcsr && *ppcsr );
	
	if ( (*ppcsr)->itag == itagNil)
		{
		CSR *pcsrT = *ppcsr;
		*ppcsr = (*ppcsr)->pcsrPath;
		MEMReleasePcsr( pcsrT );
		}

	pcsrPrev = *ppcsr;
	pcsr = pcsrPrev->pcsrPath;
	
	while ( pcsr )
		{
		if ( FCSRInvisible( pcsr ) )
			{
			CSR *pcsrT = pcsrPrev->pcsrPath;
			pcsr = pcsrPrev->pcsrPath = pcsr->pcsrPath;
			MEMReleasePcsr( pcsrT );
			}
		else
			{
			Assert( pcsr->itag != itagNil );
			pcsrPrev = pcsr;
			pcsr = pcsr->pcsrPath;
			}
		}

	return;
	}
	

VOID FUCBSetIndexRange( FUCB *pfucb, JET_GRBIT grbit )
	{
	/*	set limstat
	/**/
	FUCBSetLimstat( pfucb );
	if ( grbit & JET_bitRangeUpperLimit )
		{
		FUCBSetUpper( pfucb );
		}
	else
		{
		FUCBResetUpper( pfucb );
		}
	if ( grbit & JET_bitRangeInclusive )
		{
		FUCBSetInclusive( pfucb );
		}
	else
		{
		FUCBResetInclusive( pfucb );
		}

	return;
	}


VOID FUCBResetIndexRange( FUCB *pfucb )
	{
	FUCBResetLimstat( pfucb );
	}


ERR ErrFUCBCheckIndexRange( FUCB *pfucb )
	{
	ERR	err = JET_errSuccess;
	KEY	keyLimit;
	INT	cmp;

	Assert( pfucb->cbKey > 0 );
	keyLimit.pb = pfucb->pbKey + 1;
	keyLimit.cb = pfucb->cbKey - 1;
	cmp = CmpPartialKeyKey( &pfucb->keyNode, &keyLimit );

	if ( FFUCBUpper( pfucb ) )
		{
		if ( FFUCBInclusive( pfucb ) && cmp > 0 || !FFUCBInclusive( pfucb ) && cmp >= 0 )
			{
			PcsrCurrent( pfucb )->csrstat = csrstatAfterLast;
			FUCBResetLimstat( pfucb );
			err = JET_errNoCurrentRecord;
			}
		}
	else
		{
		if ( FFUCBInclusive( pfucb ) && cmp < 0 || !FFUCBInclusive( pfucb ) && cmp <= 0 )
			{
			PcsrCurrent( pfucb )->csrstat = csrstatBeforeFirst;
			FUCBResetLimstat( pfucb );
			err = JET_errNoCurrentRecord;
			}
		}

	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\logapi.c ===
#include "config.h"

#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "daedef.h"
#include "ssib.h"
#include "page.h"
#include "util.h"
#include "fmp.h"
#include "nver.h"
#include "fcb.h"
#include "fucb.h"
#include "stapi.h"
#include "dirapi.h"
#include "dbapi.h"
#include "pib.h"
#include "fdb.h"
#include "recint.h"
#include "recapi.h"
#include "logapi.h"
#include "log.h"

DeclAssertFile;					/* Declare file name for assert macros */

#define cbFlushLogStackSz	16384			/* UNDONE: temporary fix */

#ifdef	ASYNC_LOG_FLUSH
/*	thread control variables
/**/
HANDLE	handleLGFlushLog;
BOOL	fLGFlushLogTerm = 0;
INT		cmsLGFlushPeriod;
#endif

BOOL	fLGNoMoreLogWrite = fFalse;

BOOL	fLGIgnoreVersion = 0;

INT		cLGWaitingUserMax = 3;
PIB		*ppibLGFlushQHead = ppibNil;
PIB		*ppibLGFlushQTail = ppibNil;

#ifdef DEBUG
BOOL   	fDBGTraceLog = fFalse;
BOOL   	fDBGTraceLogWrite = fFalse;
BOOL   	fDBGFreezeCheckpoint = fFalse;	/* for backup */
BOOL   	fDBGTraceRedo = fFalse;
BOOL   	fDBGDontFlush = fFalse;
#endif

BOOL   	fNewLogRecordAdded = fFalse;
BOOL   	fFreezeNewGeneration = fFalse;
BOOL   	fLogDisabled = fTrue;
/*	environment variable RECOVERY
/**/
BOOL   	fRecovering = fFalse;
BOOL   	fHardRestore = fFalse;
BOOL   	fFreezeCheckpoint = fFalse;
BYTE   	szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
static BOOL	fLogInitialized = fFalse;


/*	macro for logging of deferred begin transactions
/**/
LOCAL VOID LGIDeferBeginTransaction( PIB *ppib );
#define	LGDeferBeginTransaction( ppib )					\
	{													\
	if ( ppib->clgOpenT != 0 )							\
		{												\
		LGIDeferBeginTransaction( ppib );				\
		}												\
	}


INT CmpLgpos( LGPOS *plgpos1, LGPOS *plgpos2 )
	{
 	if ( plgpos1->usGeneration != plgpos2->usGeneration )
		return plgpos1->usGeneration - plgpos2->usGeneration;
	else if ( plgpos1->isec != plgpos2->isec )
		return plgpos1->isec - plgpos2->isec;
	else
		return plgpos1->ib - plgpos2->ib;
	}


VOID LGMakeLogName( CHAR *szLogName, CHAR *szFName )
	{
	strcpy( szLogName, szLogCurrent );
	strcat( szLogName, szFName );
	strcat( szLogName, szLogExt );
	}


/*  open a generation file on CURRENT directory
/**/
ERR ErrOpenLogGenerationFile( USHORT usGeneration, HANDLE *phf )
	{
	LGSzFromLogId ( szFName, usGeneration );
	LGMakeLogName( szLogName, szFName );

#ifdef OVERLAPPED_LOGGING
	return ErrSysOpenFile ( szLogName, phf, 0L, fFalse, fTrue );
#else
	return ErrSysOpenFile ( szLogName, phf, 0L, fFalse, fFalse );
#endif
	}


/*  Open Jet.log. If failed, try to rename jettemp.log to jet.log.
/*	If soft failure occurred while new log generation file
/*	was being created, look for active log generation file
/*	in temporary name.  If found, rename and proceed.
/*	Assume rename cannot cause file loss.
/**/
ERR ErrOpenJetLog()
	{
	ERR		err;
	CHAR	szJetTmpLog[_MAX_PATH];

	strcpy( szFName, szJet );
	LGMakeLogName( szLogName, szFName );
	LGMakeLogName( szJetTmpLog, (CHAR *) szJetTmp );
#ifdef OVERLAPPED_LOGGING
	err = ErrSysOpenFile( szLogName, &hfLog, 0L, fFalse, fTrue );
#else
	err = ErrSysOpenFile( szLogName, &hfLog, 0L, fFalse, fFalse );
#endif
	if ( err < 0 )
		{
		/*	no current jet.log. Try renaming jettmp.log to jet.log
		/**/
		if ( ( err = ErrSysMove( szJetTmpLog, szLogName ) ) == JET_errSuccess )
			{
#ifdef OVERLAPPED_LOGGING
			CallS( ErrSysOpenFile( szLogName, &hfLog, 0L, fFalse, fTrue ) );
#else
			CallS( ErrSysOpenFile( szLogName, &hfLog, 0L, fFalse, fFalse ) );
#endif
			}
		}

	/*  we opened current jet.log successfully,
	/*	try to delete temporary log file in case failure
	/*	occurred after temp was created and possibly not
	/*	completed but before active log file was renamed
	/**/
	(VOID)ErrSysDeleteFile( szJetTmpLog );

	return err;
	}


/*  Open the proper log file where the redo point (in lgposRedoFrom) exists.
/*  The log file must be in current directory.
/**/
ERR ErrOpenRedoLogFile( LGPOS *plgposRedoFrom, INT *pfStatus )
	{
	ERR		err;

	/*	try to open the redo from file as a normal generation log file
	/**/
	err = ErrOpenLogGenerationFile( plgposRedoFrom->usGeneration, &hfLog );

	if( err < 0 )
		{
		/*	unable to open as a jetnnnnn.log, assume the redo point is
		/*	at the end of jetnnnn.log and the jetnnnn.log is moved to
		/*	backup directory already so we won't be able to open it.
		/*	Now try to open jetnnnn(n+1).log in current directory and
		/*	assume redo start from beginning of jetnnnn(n+1).log.
		/**/
		err = ErrOpenLogGenerationFile( ++plgposRedoFrom->usGeneration, &hfLog );
		if ( err < 0 )
			{
			/*	unable to open jetnnnn(n+1).log either. Maybe the redo
			/*	point is in jet.log. Try to open current jet.log.
			/**/
			--plgposRedoFrom->usGeneration; /* restore generation number */

			err = ErrOpenJetLog();
			if ( err < 0 )
				{
				/*	jet.log is not available either
				/**/
				*pfStatus = fNoProperLogFile;
				return JET_errSuccess;
				}
			}
		}

	/*	now the right log file is opened. Read the log
	/*	file's header, verify generation number
	/**/
	CallR( ErrLGReadFileHdr( hfLog, plgfilehdrGlobal ) );

	/*	set up a special case for pbLastMSFlush
	/**/
	pbLastMSFlush = 0;
	memset( &lgposLastMSFlush, 0, sizeof(lgposLastMSFlush) );

	/*	the following checks are necessary if the jet.log is opened
	/**/
	if( plgfilehdrGlobal->lgposLastMS.usGeneration == plgposRedoFrom->usGeneration)
		{
		*pfStatus = fRedoLogFile;
		}
	else if ( plgfilehdrGlobal->lgposLastMS.usGeneration ==
		plgposRedoFrom->usGeneration + 1 )
		{
		/*  this file starts next generation, set start
		/*  position for Redo.
		/**/
		plgposRedoFrom->usGeneration++;
		plgposRedoFrom->isec = plgfilehdrGlobal->lgposFirst.isec;
		plgposRedoFrom->ib	 = plgfilehdrGlobal->lgposFirst.ib;

		*pfStatus = fRedoLogFile;
		}
	else
		{
		/*	a generation gap is found. Current jet.log can not be
		/*  continuation of backed-up logfile. Return NoProperLogFile
		/*  for caller to recreate a new jet.log.
		/**/
		/*	close current logfile.
		/**/
		CallS( ErrSysCloseFile ( hfLog ) );
		hfLog = handleNil;

		strcpy( szFName, szJet );
		LGMakeLogName( szLogName, szFName );
		/*	delete current jet.log
		/**/
		CallS( ErrSysDeleteFile( szLogName ) );

		*pfStatus = fNoProperLogFile;
		}

	return JET_errSuccess;
	}

	
ERR ErrLGInitLogBuffers( LONG lIntendLogBuffers )
	{
	EnterCriticalSection(critLGBuf);
	
	csecLGBuf = lIntendLogBuffers;

	Assert( csecLGBuf > 4 );
	//	UNDONE: should be a real checking code
	//	UNDONE: the LGBuf > a data page

	/*	set buffer
	/**/
	pbLGBufMin = (BYTE *) PvSysAllocAndCommit( csecLGBuf * cbSec );
	if ( pbLGBufMin == NULL )
		{
		LeaveCriticalSection(critLGBuf);
		return JET_errOutOfMemory;
		}

	csecLGBuf--; /* reserve extra buffer for read ahead in redo */

	pbLGBufMax = pbLGBufMin + csecLGBuf * cbSec;

	LeaveCriticalSection(critLGBuf);
	return JET_errSuccess;
	}


/*
 *  Locate the real last log record entry in a given opened log file (hf) and
 *  the last recorded entry. Note that the real last log record entry may
 *  be different from the recorded one.
 *  Note if a mutli-sec flush is done, then several small transactions
 *  were following it and stay on the same page, they were written with
 *  Fill at the end. Then another multi-sec flush is issued again, since
 *  we overwrite the Fill record, we have no idea where the last single
 *  sec flush is done. We simply keep reading till the last log record with
 *  entry in the candidate page is met and make it is the last record.
 *  Rollback will undo the bogus log records between last effective single
 *  sec flush and the last record of the candidate sector.
 *
 *  Implicit Output parameter:
 *		INT   isecWrite
 *		CHAR  *pbEntry
 */
//	UNDONE:	review with Cheen Liao
ERR ErrLGCheckReadLastLogRecord( LGPOS *plgposLastMS, BOOL *pfCloseNormally )
	{
	ERR		err;
//	ERR		wrn = JET_errSuccess;
	LGPOS	lgposScan = *plgposLastMS;
	CHAR	*pbSecBoundary;
	LRMS	lrms;
	BOOL	fQuitWasRead = fFalse;
	BOOL	fVeryFirstByte;
	INT		csecToRead;
	LR		*plr;
	BOOL	fAbruptEnd;
	BYTE	*pbNextMS;

	*pfCloseNormally = fFalse;

	/*	read the last recorded MS
	/**/
	CallR( ErrLGRead( hfLog, lgposScan.isec, pbLGBufMin, 1 ) );
	csecToRead = 0;

	if ( lgposScan.isec == 2 && lgposScan.ib == 0 )
		{
		/* special case, the log file has not extend to multiple sectors
		/**/
		lgposScan.isec = plgfilehdrGlobal->lgposFirst.isec;
		lgposScan.ib = plgfilehdrGlobal->lgposFirst.ib;
		pbLastMSFlush = NULL;
		memset( &lgposLastMSFlush, 0, sizeof(lgposLastMSFlush) );

		pbEntry = pbLGBufMin + lgposScan.ib;
		pbWrite = pbLGBufMin;
		plr = (LR *)pbEntry;
		isecWrite = lgposScan.isec;

		fVeryFirstByte = fTrue;

		goto LastPage;
		}

	/*	now try to read the chain of lrms to the end
	/**/
	fVeryFirstByte = fFalse;
	fAbruptEnd = fFalse;
	pbNextMS = pbLGBufMin + lgposScan.ib;
	lrms = *(LRMS *)pbNextMS;

	while ( lrms.isecForwardLink != 0 )
		{
		LRMS lrmsNextMS;

		csecToRead = lrms.isecForwardLink - lgposScan.isec;

		if ( csecToRead + 1 > csecLGBuf )
			{
			BYTE *pbT = pbLGBufMin;

			/*	reallocate log buffers
			/**/
			CallR( ErrLGInitLogBuffers( csecToRead + 1 ) );
			memcpy( pbLGBufMin, pbT, cbSec );
			SysFree( pbT );
//			wrn = JET_errLogBufferSizeChanged;
			}

		if ( ErrLGRead(	hfLog, lgposScan.isec + 1, pbLGBufMin + cbSec, csecToRead ) < 0 )
			{
			/*	even when the read is fail, at least one sector
			/*	is read since the first sector was OK.
			/**/
			fAbruptEnd = fTrue;
			break;
			}

		/*	prepare to read next MS
		/**/
		pbNextMS = pbLGBufMin + csecToRead * cbSec + lrms.ibForwardLink;
		lrmsNextMS = *(LRMS *) pbNextMS;

		if ( lrmsNextMS.isecBackLink != lgposScan.isec &&
			lrmsNextMS.ibBackLink != lgposScan.ib )
			{
			fAbruptEnd = fTrue;
			break;
			}

		/*	shift the last sector to the beginning of LGBuf
		/**/
		memmove( pbLGBufMin, pbLGBufMin + ( csecToRead * cbSec ), cbSec );

		lgposScan.isec = lrms.isecForwardLink;
		lgposScan.ib = lrms.ibForwardLink;

		lrms = lrmsNextMS;
		}

	lgposLastMSFlush = lgposScan;
	pbLastMSFlush = pbLGBufMin + lgposScan.ib;
	if ( fAbruptEnd )
		{
		LRMS *plrms = (LRMS *)pbLastMSFlush;
		plrms->isecForwardLink = 0;
		plrms->ibForwardLink = 0;
		}

	/*	set return values for both global and parameters.
	/**/
	pbWrite = pbLGBufMin;
	isecWrite = lgposScan.isec;

	/*  we read to the end of last MS. Looking for Fill.
	/**/
	pbEntry = pbWrite + lgposScan.ib;
	plr = (LR *)pbEntry;
	/*	continue search from last MS
	/**/
	Assert( plr->lrtyp == lrtypMS );

	if ( !fAbruptEnd && plgfilehdrGlobal->fEndWithMS )
		{
		/*	pbEntry is pointing at MS which is the last record
		/**/
		*pfCloseNormally = fTrue;
		return JET_errSuccess;
		}

LastPage:
	/*	set pbEntry and *pfCloseNormally by traversing log records
	/*	in last log sector.
	/**/
	pbSecBoundary = pbLGBufMin + cbSec;
	Assert( pbWrite == pbLGBufMin );

	/*	pbEntry must be on log record in first sector of log buffer.
	/**/
	Assert( pbEntry >= pbLGBufMin && pbEntry < pbSecBoundary );

	forever
		{
		if ( plr->lrtyp == lrtypFill )
			{
			if ( fVeryFirstByte )
				{
				*pfCloseNormally = fTrue;
				}
			else if ( fQuitWasRead )
				{
				/*	a fQuit followed by Fill. Close normally last time
				/**/
				*pfCloseNormally = fTrue;
				}
			else
				{
				/*	we are reading a sector that is last flushed
				/**/
				*pfCloseNormally = fFalse;
				}

			/*	return the plr pointing at the Fill record
			/**/
			pbEntry = (CHAR *)plr;
			return JET_errSuccess;
			}
		else
			{
			/*	not a fill
			/**/
			if ( plr->lrtyp == lrtypQuit )
				{
				/*	check if it is last lrtypQuit in the log file. Advance
				/*	one more log rec and check if it is followed by Fill.
				/**/
				fQuitWasRead = fTrue;
				}
			}

		/*	move to next log record
		/**/
		pbEntry = (CHAR *)plr;
		plr = (LR *)( pbEntry + CbLGSizeOfRec( (LR *)pbEntry ) );
		fVeryFirstByte = fFalse;

		if ( plr >= (LR *)pbSecBoundary )
			{
			*pfCloseNormally = fFalse;
			return JET_errSuccess;
			}
		}

//	Assert( wrn == JET_errSuccess || wrn == JET_errLogBufferSizeChanged );
//	return wrn;
	return err;
	}


/*
 *	Database log based recovery initialization, creates first log
 *	generation file on first run.  On subseqent runs
 *	checks active log file to determine if failure has occurred.
 *	ErrLGRedo is called when failures detected to repair databases.
 *
 *	RETURNS		JET_errSuccess, or error code from failing routine
 */


/*
 *  Initialize global variablas and threads for log manager.
 */
ERR ErrLGInit( VOID )
	{
	ERR		err;
	INT		cbComputerName;

	if ( fLogInitialized )
		return JET_errSuccess;

	
#ifdef PERFCNT
//	{
//	CHAR	*sz;
//
//	if ( ( sz = GetEnv2 ( "PERFCNT" ) ) != NULL )
		fPERFEnabled = fTrue;
//	else
//		fPERFEnabled = fFalse;
//	}
#endif


#ifdef DEBUG
	{
	CHAR	*sz;

	if ( ( sz = GetEnv2 ( "TRACELOG" ) ) != NULL )
		fDBGTraceLog = fTrue;
	else
		fDBGTraceLog = fFalse;

	if ( ( sz = GetEnv2 ( "TRACELOGWRITE" ) ) != NULL )
		fDBGTraceLogWrite = fTrue;
	else
		fDBGTraceLogWrite = fFalse;

	if ( ( sz = GetEnv2 ( "FREEZECHECKPOINT" ) ) != NULL )
		fDBGFreezeCheckpoint = fTrue;
	else
		fDBGFreezeCheckpoint = fFalse;

	if ( ( sz = GetEnv2 ( "TRACEREDO" ) ) != NULL )
		fDBGTraceRedo = fTrue;
	else
		fDBGTraceRedo = fFalse;

	if ( ( sz = GetEnv2 ( "DONTFLUSH" ) ) != NULL )
		fDBGDontFlush = fTrue;
	else
		fDBGDontFlush = fFalse;
	
	if ( ( sz = GetEnv2 ( "IGNOREVERSION" ) ) != NULL )
		fLGIgnoreVersion = fTrue;
	else
		fLGIgnoreVersion = fFalse;
	}
#endif

	Assert( fLogDisabled == fFalse );

	/*	assuming everything will work out
	/**/
	fLGNoMoreLogWrite = fFalse;

	/*	initialize szLogFilePath
	/**/
	if ( szLogFilePath [ strlen( szLogFilePath ) - 1 ] != '\\' )
		strcat( szLogFilePath, "\\");

	/*	log file header must be aligned on correct boundary for device;
	/*	which is 16-byte for MIPS and 512-bytes for at least one NT
	/*	platform.
	/**/
	if (!(plgfilehdrGlobal = (LGFILEHDR *) PvSysAllocAndCommit( sizeof(LGFILEHDR) ) ))
		return JET_errOutOfMemory;
	/*	assert 512-byte aligned
	/**/
	Assert( ( (ULONG_PTR)plgfilehdrGlobal & 0x000001ff ) == 0 );

	//	UNDONE:	improve error handling
	/*  create and initialize semaphores
	/**/
	CallS( ErrInitializeCriticalSection( &critLGBuf ) );
	CallS( ErrInitializeCriticalSection( &critLGFlush ) );
	CallS( ErrInitializeCriticalSection( &critLGWaitQ ) );

	/*	adjust log resource parameters to legal and local optimal values
	 *	make cbLogSec an integral number of disk sectors
	 *	enforce log file size greater than or equal to log buffer
	 */
	CallR( ErrLGInitLogBuffers( lLogBuffers ) );

	/* at least a data page plus 2 page hdear and one page for overhead. */
	csecLGFile = max( lLogFileSectors, cbPage / cbSec + 2 + 1);

	/* set check point period */
	csecLGCheckpointCount =
	csecLGCheckpointPeriod = lLGCheckPointPeriod;

#ifdef ASYNC_LOG_FLUSH

	cmsLGFlushPeriod = lLogFlushPeriod;
	cLGWaitingUserMax = lLGWaitingUserMax;

#ifdef OVERLAPPED_LOGGING
	CallR( ErrSignalCreate( &rgolpLog[0].sigIO, NULL ) );
	CallR( ErrSignalCreate( &rgolpLog[1].sigIO, NULL ) );
	CallR( ErrSignalCreate( &rgolpLog[2].sigIO, NULL ) );
	rgsig[0] = rgolpLog[0].sigIO;
	rgsig[1] = rgolpLog[1].sigIO;
	rgsig[2] = rgolpLog[2].sigIO;
#endif

#endif
	cbComputerName = MAX_COMPUTERNAME_LENGTH + 1;
	CallS( ErrSysGetComputerName( szComputerName, &cbComputerName ) );
	Assert (szComputerName[cbComputerName] == '\0');

#ifdef	ASYNC_LOG_FLUSH
	/*	create log buffer flush thread
	/**/
	CallR( ErrSignalCreateAutoReset( &sigLogFlush, "log flush" ) );
	fLGFlushLogTerm = fFalse;
	CallR( ErrSysCreateThread( (ULONG(*)()) LGFlushLog,
		cbFlushLogStackSz, lThreadPriorityCritical,
		&handleLGFlushLog ) );
#endif	/* ASYNC_LOG_FLUSH */

	fLogInitialized = fTrue;

	return err;
	}


/*
 *  Soft start tries to start the system from current directory.
 *  The database maybe in one of the following state:
 *  1) no log files.
 *  2) database was shut down normally.
 *  3) database was aborted abruptly.
 *  In case 1, a new log file is generated.
 *  In case 2, the last log file is opened.
 *  In case 3, soft redo is incurred.
 *  At the end of the function, it a proper jet.log must exists.
 */
BOOL fJetLogGeneratedDuringSoftStart = fFalse;


ERR ErrLGSoftStart( BOOL fAllowNoJetLog )
	{
	ERR		err;
	BOOL	fCloseNormally;
	BOOL	fSoftRecovery = fFalse;
	
	fJetLogGeneratedDuringSoftStart = fFalse;

	/* try to open current log file to decide the status of
	 * log files.
	 */
	szLogCurrent = szLogFilePath;

	/*
	 * Hopefully the client will behave, not mess up the log files.
	 *
	 * CONSIDER: for tight check, we may check if all log files are
	 * CONSIDER: continuous by checking the generation number and
	 * CONSIDER: previous gen's creatiion date.
	 */

Start:
	err = ErrOpenJetLog();

	if ( err < 0 )
		{
		/*  neither jet.log nor jettmp.log exist. If no old generation
		 *  files exists, gen a new logfile at generation 1, otherwise
		 *  check if fAllowNoJetLog is true, if it is, then
		 *  change the last generation log file to log file.
		 */

		if ( fAllowNoJetLog )
			{
			INT		iGen;

			/*	get last generation log files
			/**/
			LGLastGeneration( szLogCurrent, &iGen );
			if ( iGen != 0 )
				{
				CHAR szJetOldLog[_MAX_PATH];

				/*	rename to jet.log and restart
				/**/
				LGSzFromLogId ( szFName, iGen );
				LGMakeLogName( szJetOldLog, szFName );
				strcpy(szFName, szJet);
				LGMakeLogName( szLogName, szFName );

				CallJ( ErrSysMove( szJetOldLog, szLogName ), ReturnErr );
				goto Start;
				}
			}

		pbEntry = pbLGBufMin;			/* start of data area */
		*(LRTYP *)pbEntry = lrtypFill;	/* add one "fill" record */
		pbWrite = pbLGBufMin;

		CallJ( ErrLGNewLogFile(
					0, /* generation 0 + 1 */
					fOldLogNotExists ), ReturnErr );
				
		/* set flag for IsamInit in tm.c */
		fJetLogGeneratedDuringSoftStart = fTrue;

		Assert( plgfilehdrGlobal->lgposLastMS.usGeneration == 1 );

		Assert( pbLastMSFlush == 0 );
		Assert( lgposLastMSFlush.usGeneration == 0 );
		Assert( plgfilehdrGlobal->fEndWithMS == fFalse );
		}
	else
		{
		/* read current log file header */
		CallJ( ErrLGReadFileHdr( hfLog, plgfilehdrGlobal ), CloseLog );

		/* re-initialize log buffers according to check pt env. */
		SysFree( pbLGBufMin );
		CallJ( ErrLGInitLogBuffers(
				plgfilehdrGlobal->dbenv.ulLogBuffers ), CloseLog);

		/* set up a special case for pbLastMSFlush */
		pbLastMSFlush = 0;
		memset( &lgposLastMSFlush, 0, sizeof(lgposLastMSFlush) );
		plgfilehdrGlobal->fEndWithMS = fFalse;

		/*	read last written log record recorded in file header
		/*	into buffer, access last record logged, determine if we
		/*	finished normally last time.
		/**/
		CallJ( ErrLGCheckReadLastLogRecord(
			&plgfilehdrGlobal->lgposLastMS,
			&fCloseNormally), CloseLog );

		CallS( ErrSysCloseFile( hfLog ) );
		hfLog = handleNil;

		if (!fCloseNormally)
			{
			/*  Did not finish normally - we need to Redo. Pick
			 *  up checkpoint, Find right generation to Redo from.
			 */
			LGPOS lgposRedoFrom = plgfilehdrGlobal->lgposCheckpoint;

			/* set log path to current directory */
			Assert( szLogCurrent == szLogFilePath );

#ifdef DEBUG
			UtilWriteEvent( evntypStart, "Jet Blue Start Soft recovery.\n", pNil, 0 );
#endif
			fSoftRecovery = fTrue;
	
			/* Redo from last chkpnt. */
			// LGMakeLogName( szLogName, szFName);
			CallJ( ErrLGRedo1( &lgposRedoFrom ), CloseLog )
				
			CallJ( ErrLGRedo2( &lgposRedoFrom ), CloseLog )
			CallS( ErrSysCloseFile( hfLog ) );
			hfLog = handleNil;
			}
		}

	/*
	 *  At this point, we have a jet.log file, reopen the log files.
	 */

	/*  re-initialize the buffer manager with user's setting. */
	SysFree( pbLGBufMin );
	CallJ( ErrLGInitLogBuffers( lLogBuffers ), ReturnErr );

	/*  reopen the log file */
	LGMakeLogName( szLogName, (CHAR *) szJet);
#ifdef OVERLAPPED_LOGGING
	CallJ( ErrSysOpenFile( szLogName, &hfLog, 0L, fFalse, fTrue ), ReturnErr );
#else
	CallJ( ErrSysOpenFile( szLogName, &hfLog, 0L, fFalse, fFalse ), ReturnErr );
#endif

	CallJ( ErrLGReadFileHdr( hfLog, plgfilehdrGlobal ), CloseLog );

	/* set up a special case for pbLastMSFlush */
	pbLastMSFlush = 0;
	memset( &lgposLastMSFlush, 0, sizeof(lgposLastMSFlush) );
	plgfilehdrGlobal->fEndWithMS = fFalse;

	/*	set up log variables properly
	/**/
	CallJ( ErrLGCheckReadLastLogRecord(
		&plgfilehdrGlobal->lgposLastMS,
		&fCloseNormally), CloseLog );

//	Assert( fCloseNormally && *(LRTYP *)pbEntry == lrtypFill );
	Assert( isecWrite != 0 ); /* should be set properly. */

	/*
	 *  pbEntry and pbWrite were set for next record in LocateLastLogRecord
	 */
	Assert(pbWrite == PbSecAligned(pbWrite) );
	Assert(pbWrite <= pbEntry && pbEntry <= pbWrite + cbSec);

	/*
	 *  setup log flushing starting point
	 */
	EnterCriticalSection(critLGBuf);
	GetLgposOfPbEntry(&lgposToFlush);
	LeaveCriticalSection(critLGBuf);

	Assert( fRecovering == fFalse );
 	Assert( fHardRestore == fFalse );

	/*
	 *  add the first log record
	 */
	return ErrLGStart( );

CloseLog:
	if ( hfLog != handleNil )
		{
		CallS( ErrSysCloseFile( hfLog ) );
		hfLog = handleNil;
		}
 	Assert( fHardRestore == fFalse );

ReturnErr:
	if ( fSoftRecovery )
		{
		BYTE szMessage[128];

		sprintf( szMessage,
			"Jet Blue Stop Soft recovery with err = %d.\n", err );
		UtilWriteEvent( evntypStop, szMessage, pNil, 0 );
		}

	Assert( hfLog == handleNil );
	return err;
	}


/*
 *	Terminates update logging.	Adds quit record to in-memory log,
 *	flushes log buffer to disk, updates checkpoint and closes active
 *	log generation file.  Frees buffer memory.
 *
 *  RETURNS	   JET_errSuccess, or error code from failing routine
 */

ERR ErrLGTerm( VOID )
	{
	ERR		err = JET_errSuccess;

	/*	if logging has been initialized, terminate it! */
	if ( ! ( fLogInitialized ) )
		return JET_errSuccess;

	if ( fLGNoMoreLogWrite || hfLog == handleNil )
		goto FreeResources;

	/*	last written sector should have been written during final flush */

#ifdef DEBUG
	{
	/* fDBGSimulateSoftCrash is set in buf.c. If we force certain
	 * flush pattern, then we should also simulate soft crash.
	 */
	extern BOOL fDBGSimulateSoftCrash;
	if (!fDBGSimulateSoftCrash)
		Call( ErrLGQuit(&lgposStart) );
	}
#else
	Call( ErrLGQuit( &lgposStart ) );
#endif


#ifdef PERFCNT
	Call( ErrLGFlushLog(0) );	/* semaphore not requested, not needed */
#else
	Call( ErrLGFlushLog() );	/* semaphore not requested, not needed */
#endif

	/*	flush must have checkpoint log so no need to do checkpoint again. */
	Call( ErrLGWriteFileHdr( plgfilehdrGlobal ) );

#ifdef PERFCNT
	if (fPERFEnabled)
		{
		INT i;

		printf("Group commit distribution:\n");

		printf("          ");
		for (i = 0; i < 10; i++)
			printf("%4d ", i);
		printf("\n By User  ");

		for (i = 0; i < 10; i++)
			printf("%4lu ", rgcCommitByUser[i]);
		printf("\n By LG    ");

		for (i = 0; i < 10; i++)
			printf("%4lu ", rgcCommitByLG[i]);
		printf("\n");
		}

#endif

#ifdef	ASYNC_LOG_FLUSH

	/*	terminate LGFlushLog thread.
	/**/
	Assert( handleLGFlushLog != 0 );

// ? no need ?
//	/* force the last flush! */
//#ifdef PERFCNT
//	(void) ErrLGFlushLog(0);
//#else
//	(void) ErrLGFlushLog();
//#endif

FreeResources:

	fLGFlushLogTerm = fTrue;
	while ( !FSysExitThread( handleLGFlushLog ) );
	SignalClose(sigLogFlush);

	DeleteCriticalSection( critLGBuf );
	DeleteCriticalSection( critLGFlush );
	DeleteCriticalSection( critLGWaitQ );

#ifdef OVERLAPPED_LOGGING
	SignalClose(rgolpLog[0].sigIO);
	SignalClose(rgolpLog[1].sigIO);
	SignalClose(rgolpLog[2].sigIO);
#endif

#endif

	/* Close the log file */
	if ( hfLog != handleNil )
		{
		CallS( ErrSysCloseFile( hfLog ) );
		hfLog = handleNil;
		}

	/*	clean up allocated resources */
	if (pbLGBufMin)
		SysFree( pbLGBufMin );
	if (plgfilehdrGlobal)
		SysFree( plgfilehdrGlobal );
	
	fLogInitialized = fFalse;
	
HandleError:
	return err;
	}


VOID AddLogRec( BYTE *pb, INT cb, BYTE **ppbET )
	{
	CHAR *pbET = *ppbET;

	if ( pbWrite < pbET )
		{
		INT cbT;

		/*	check wrapparound case
		/**/
		if ( ( cbT = (INT)(pbLGBufMax - pbET) ) < cb )
			{
			memcpy( pbET, pb, cbT );
			pb += cbT;
			cb -= cbT;
			pbET = pbLGBufMin;
			}
		}
	memcpy( pbET, pb, cb );

	/*	return next available entry
	/**/
	*ppbET = pbET + cb;
	return;
	}


/*
 *	Add log record to circular log buffer. Signal flush thread to flush log
 *	buffer if at least cThreshold disk sectors are ready for flushing.
 *	Wait on log flush if we run out of log buffer space. Log records with
 *  variable data portions are added in several parts: first the fixed
 *  length portion of the record, then the variable portions of the record.
 *  If fFlush is set, buffer is flushed as soon as log record has been added.
 *
 *	RETURNS		JET_errSuccess, or error code from failing routine
 */

ERR ErrLGLogRec( LINE *rgline, INT cline, PIB *ppib )
	{
	ERR		err = JET_errSuccess;
	INT		cbReq;
	INT		iline;
	LGPOS	lgposEntryT;

	AssertCriticalSection(critJet);
	Assert( fLogDisabled == fFalse );
	Assert( cline >= 1 && cline <= 4 + ilineDiffMax * 3 );
	Assert( rgline[0].pb != NULL );

	/*	cbReq is total net space required for record
	/**/
	for ( cbReq = 0, iline = 0; iline < cline; iline++ )
		cbReq += rgline[iline].cb;

	/*	get pbEntry in order to add log record
	/**/
	forever
		{
		INT		csecReady;
		INT		cbAvail;
		LGPOS	lgposLogRecT;

		EnterCriticalSection( critLGBuf );
		if ( fLGNoMoreLogWrite )
			{
			LeaveCriticalSection( critLGBuf );
			return JET_errLogWriteFail;
			}

		Assert( isecWrite == sizeof (LGFILEHDR) / cbSec * 2 ||
			lgposLastMSFlush.isec );

		GetLgposOfPbEntry( &lgposLogRecT );
		/*	if just initialized or no input since last flush
		/**/
		if ( pbEntry == pbWrite ||
			lgposLogRecT.isec == lgposToFlush.isec &&
			lgposLogRecT.ib == lgposToFlush.ib )
			break;
		else
			{
			if ( pbWrite > pbEntry )
				cbAvail = (INT)(pbWrite - pbEntry);
			else
				cbAvail = (INT)((pbLGBufMax - pbEntry) + (pbWrite - pbLGBufMin));
			csecReady = csecLGBuf - cbAvail / cbSec;
			}

		if ( csecReady > lLogFlushThreshold )
			{
			/*	reach the threshold, flush before adding new record
			/**/
#ifdef ASYNC_LOG_FLUSH
			SignalSend( sigLogFlush );
#else
			LeaveCriticalSection( critLGBuf );
			CallJ( ErrLGFlushLog(), Done );
			continue;
#endif
			}

		/*  in worst case, we may have fill Nop if aboundary of a sector
		/*  is hit and we have to append a LRMS. So make sure cbAvail is
		/*  big enough for the worst case, make sure exter 2 * szieof(LRMS)
		/*  is available.
		/**/
		if ( cbAvail >  (INT) ( cbReq + 2 * sizeof(LRMS) ) )
			{
			/*	no need to flush
			/**/
			break;
			}
		else
			{
			/*	restart.  Leave critical section for other users
			/**/
			LeaveCriticalSection( critLGBuf );
			BFSleep( cmsecWaitLogFlush );
			return errLGNotSynchronous;
			}
		}

	/*	now we are holding pbEntry, let's add the log record.
	/**/
	GetLgposOfPbEntry( &lgposLogRec );
	fNewLogRecordAdded = fTrue;

	/*	count level 0 commit
	/**/
	if ( ppib != ppibNil )
		cXactPerFlush++;

#ifdef DEBUG
	{
	CHAR *pbEntryT = (pbEntry == pbLGBufMax) ? pbLGBufMin : pbEntry;
#endif

	for ( iline = 0; iline < cline; iline++ )
		AddLogRec( rgline[iline].pb, rgline[iline].cb, &pbEntry );

	/*	add a dummy fill record to indicate end-of-data
	/**/
	((LR *) pbEntry)->lrtyp = lrtypFill;

#ifdef DEBUG
	if ( fDBGTraceLog )
		{
		PrintF2("\n%2u,%3u,%3u",
			plgfilehdrGlobal->lgposLastMS.usGeneration,
			lgposLogRec.isec, lgposLogRec.ib );
		ShowLR( (LR *)pbEntryT );
		}
	}
#endif

	GetLgposOfPbEntry( &lgposEntryT );

	/*	remember the minimum requirement to flush
	/**/
	if ( ppib != ppibNil )
		ppib->plgposCommit = &lgposEntryT;

	/*	now we are done with the insertion to buffer.
	/**/
	LeaveCriticalSection( critLGBuf );

	/*	if not must-flush then done
	/**/
	if ( ppib == ppibNil )
		return JET_errSuccess;

	/*	group commit: wait a while to give others a chance to flush it
	/**/

#ifdef ASYNC_LOG_FLUSH
	LeaveCriticalSection( critJet );

	/*  if there are too many user are waiting
	/*  or no wait time, then flush directly.
	/**/
	if ( cXactPerFlush >= cLGWaitingUserMax	|| ppib->lWaitLogFlush == 0 )
		{
#ifdef PERFCNT
		err = ErrLGFlushLog(0);
#else
		err = ErrLGFlushLog();
#endif
		goto Done;
		}

	EnterCriticalSection( critLGBuf );
	if ( CmpLgpos( ppib->plgposCommit, &lgposToFlush ) <= 0 )
		{
		/*	it is flushed, no need to wait
		/**/
		LeaveCriticalSection( critLGBuf );
		goto Done;
		}
	EnterCriticalSection( critLGWaitQ );

	Assert( !ppib->fLGWaiting );
	ppib->fLGWaiting = fTrue;
	ppib->ppibNextWaitFlush = ppibNil;

	if ( ppibLGFlushQHead == ppibNil )
		{
		ppibLGFlushQTail = ppibLGFlushQHead = ppib;
		ppib->ppibPrevWaitFlush = ppibNil;
		}
	else
		{
		Assert( ppibLGFlushQTail != ppibNil );
		ppib->ppibPrevWaitFlush = ppibLGFlushQTail;
		ppibLGFlushQTail->ppibNextWaitFlush = ppib;
		ppibLGFlushQTail = ppib;
		}

	LeaveCriticalSection( critLGWaitQ );
	LeaveCriticalSection( critLGBuf );

Wait:
	/*	wait for flushing task for a limited time
	/**/
	SignalWait( ppib->sigWaitLogFlush, ppib->lWaitLogFlush );

	/*	it is ok that we check fLGWaiting outside the critical section
	/*	since when it is being changed by LGFlush, it is flushed already
	/**/
	if ( ppib->fLGWaiting )
		{
		/*	it is not flushed still, wake up the flush process again!
		/**/
		SignalSend( sigLogFlush );
		
		/*	it is blocked already, jump out
		/**/
		if ( fLGNoMoreLogWrite )
			{
			err = JET_errLogWriteFail;
			goto Done;
			}

		goto Wait;
		}

	Assert( CmpLgpos( &lgposToFlush, &lgposEntryT ) >= 0 );
Done:
	EnterCriticalSection( critJet );

#else
	err = ErrLGFlushLog();
#endif

	if ( err < 0 )
		{
		fLGNoMoreLogWrite = fTrue;
		LGLogFailEvent( "Flush Fails while in buffering log records." );
		}
	
	return err;
	}


VOID LGLogFailEvent( BYTE *szLine )
	{
#ifdef DEBUG
	UtilWriteEvent( evntypLogDown, szLine, szAssertFilename, __LINE__ );
#endif
	}


#ifndef NOLOG

LOCAL VOID INLINE LGSetUlDBTime( BF *pbf, ULONG ulDBTime )
	{
	Assert( pbf->cPin );
	Assert( pbf->fDirty );
	AssertCriticalSection(critJet);
	
	pbf->ppage->pghdr.ulDBTime = ulDBTime;
	}


LOCAL VOID INLINE LGDepend( BF *pbf, LGPOS lgposLogRec )
	{
	Assert( pbf->cPin );
	Assert( pbf->fDirty );
	AssertCriticalSection(critJet);
	
	if ( CmpLgpos( &lgposLogRec, &pbf->lgposModify ) > 0 )
		pbf->lgposModify = lgposLogRec;
	}



/**********************************************************/
/*****     Page Oriented Operations                   *****/
/**********************************************************/


ERR ErrLGInsertNode(
	LRTYP			lrtyp,
	FUCB			*pfucb,
	INT				lHeader,
	KEY				*pkey,
	LINE			*plineData,
	INT				fDIRFlags)
	{
	ERR				err;
	LINE			rgline[3];
	LRINSERTNODE	lrinsertnode;
	CSR				*pcsr;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( pfucb->ppib->fLogDisabled )
		return JET_errSuccess;

	if ( !rgfmp[pfucb->dbid].fLogOn )
		return JET_errSuccess;

	/*	assert in a transaction since will not redo level 0 modifications
	/**/
	Assert( pfucb->ppib->level > 0 );

	LGDeferBeginTransaction( pfucb->ppib );

	pcsr = PcsrCurrent( pfucb );

	lrinsertnode.lrtyp		= lrtyp;
	lrinsertnode.cbKey		= (BYTE)pkey->cb;
	lrinsertnode.cbData		= (USHORT)plineData->cb;
	lrinsertnode.procid		= pfucb->ppib->procid;
	lrinsertnode.pn			= PnOfDbidPgno( pfucb->dbid, pcsr->pgno );
	lrinsertnode.fDIRFlags	= fDIRFlags;

	lrinsertnode.bHeader	= (BYTE)lHeader;
	Assert(	pcsr->itag >= 0 && pcsr->itag <= 255 );
	lrinsertnode.itagSon	= (BYTE)pcsr->itag;
	Assert(	pcsr->itagFather >= 0 && pcsr->itagFather <= 255 );
	lrinsertnode.itagFather = (BYTE)pcsr->itagFather;
	Assert(	pcsr->ibSon >= 0 &&	pcsr->ibSon <= 255 );
	lrinsertnode.ibSon		= (BYTE) pcsr->ibSon;

	rgline[0].pb = (BYTE *)&lrinsertnode;
	rgline[0].cb = sizeof(LRINSERTNODE);
	rgline[1].pb = pkey->pb;
	rgline[1].cb = pkey->cb;
	rgline[2].pb = plineData->pb;
	rgline[2].cb = plineData->cb;

	do
		{
		ULONG ulDBTime = ++rgfmp[ pfucb->dbid ].ulDBTime;

		LGSetUlDBTime( pfucb->ssib.pbf, ulDBTime );
		lrinsertnode.ulDBTime = ulDBTime;
		}
	while ( ( err = ErrLGLogRec( rgline, 3, ppibNil ) ) == errLGNotSynchronous );

	LGDepend( pfucb->ssib.pbf, lgposLogRec );
	return err;
	}


ERR ErrLGReplace( FUCB *pfucb, LINE *plineNew, INT fDIRFlags, INT cbData )
	{
	ERR			err;
	LINE		rgline[2 + ilineDiffMax * 3];
	INT			cline = 1;
	LRREPLACE	lrreplace;
	CSR			*pcsr;
	INT			cbInfo;
	INT			ilineDiff;
	LINE		*rglineDiff;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( pfucb->ppib->fLogDisabled )
		return JET_errSuccess;

	if ( !rgfmp[pfucb->dbid].fLogOn )
		return JET_errSuccess;

	/*	assert in a transaction since will not redo level 0 modifications
	/**/
	Assert( pfucb->ppib->level > 0 );

	LGDeferBeginTransaction( pfucb->ppib );

	pcsr = PcsrCurrent(pfucb);

	lrreplace.procid	= pfucb->ppib->procid;
	lrreplace.pn		= PnOfDbidPgno( pfucb->dbid, pcsr->pgno );
	lrreplace.fDIRFlags = fDIRFlags;

	Assert(	pcsr->itag >= 0 && pcsr->itag <= 255 );
	lrreplace.itag		= (BYTE)pcsr->itag;
	lrreplace.bm		= pcsr->bm;

	rgline[0].pb = (BYTE *)&lrreplace;
	rgline[0].cb = sizeof(LRREPLACE);

	lrreplace.cbNewData = (USHORT)plineNew->cb;
	
	/*	check if the fucb is for a regular table
	/**/
	if ( !pfucb->fCmprsLg )
		goto LogWholeRec;

	/*	set lrtyp from lrtypReplace to lrtypReplaceC (compressed)
	/**/
	lrreplace.lrtyp	= lrtypReplaceC;

	/*	make pline pointing to new value in RecDiff Format
	/*	make sure the rgline is in offset order, smallest first
	/**/

	rglineDiff = pfucb->rglineDiff;
	for ( ilineDiff = 0; ilineDiff < pfucb->clineDiff; ilineDiff++ )
		{
		INT  ilineInner;
		LINE lineT;
		LINE *pline = &rglineDiff[ilineDiff];

		for ( ilineInner = ilineDiff + 1;
			  ilineInner < pfucb->clineDiff;
			  ilineInner++)
			if ( pline->pb > rglineDiff[ilineInner].pb )
				pline = &rglineDiff[ilineInner];

		lineT = *pline;
		*pline = rglineDiff[ilineDiff];
		rglineDiff[ilineDiff] = lineT;
		}

	cbInfo = 0;
	for ( ilineDiff = 0; ilineDiff < pfucb->clineDiff; ilineDiff++ )
		{
		/*	offset
		/**/
		rgline[cline].cb = sizeof(SHORT);
		rgline[cline++].pb = (BYTE *) &((LONG_PTR)pfucb->rglineDiff[ilineDiff].pb);

		/*	data length
		/**/
		rgline[cline].cb = sizeof(BYTE);
		rgline[cline++].pb = (BYTE *)&pfucb->rglineDiff[ilineDiff].cb;

		/*	total data length
		/**/
		cbInfo += sizeof(SHORT) + sizeof(BYTE) +
			pfucb->rglineDiff[ilineDiff].cb;

		/* data
		/**/
		rgline[cline].cb = pfucb->rglineDiff[ilineDiff].cb;
		rgline[cline++].pb = ((LONG_PTR) pfucb->rglineDiff[ilineDiff].pb) +
			pfucb->lineWorkBuf.pb;
		}

	goto LogIt;

LogWholeRec:
	lrreplace.lrtyp	= lrtypReplace;

	cbInfo = rgline[cline].cb = plineNew->cb;
	rgline[cline++].pb = plineNew->pb;

LogIt:
	/*	set proper data length
	/**/
	lrreplace.cb = (USHORT)cbInfo;

	lrreplace.cbOldData = (USHORT)cbData;
	if ( pfucb->prceLast == NULL )
		{
		lrreplace.fOld = fFalse;
		}
	else
		{
		/*	save old version too
		/**/
		lrreplace.fOld = fTrue;
		Assert ( lrreplace.fDIRFlags & fDIRVersion );
		rgline[cline].pb = pfucb->prceLast->rgbData + cbReplaceRCEOverhead;
		Assert( (unsigned) cbData == pfucb->prceLast->cbData - cbReplaceRCEOverhead );
		rgline[cline++].cb = cbData;
		}

	do
		{
		ULONG ulDBTime = ++rgfmp[ pfucb->dbid ].ulDBTime;

		LGSetUlDBTime( pfucb->ssib.pbf, ulDBTime );
		lrreplace.ulDBTime = ulDBTime;
		}
	while ( ( err = ErrLGLogRec( rgline, cline, ppibNil ) ) == errLGNotSynchronous );

	Assert( lrreplace.lrtyp == lrtypReplaceC || lrreplace.cbNewData == lrreplace.cb );
	LGDepend( pfucb->ssib.pbf, lgposLogRec );
	return err;
	}


//	Cheen: Please review following code
/*	Log record for pessimistic locking
/**/
ERR ErrLGLockRecord( FUCB *pfucb, INT cbData )
	{
	ERR			err;
	LRLOCKREC	lrlockrec;
	LINE		rgline[2];
	CSR			*pcsr;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( pfucb->ppib->fLogDisabled )
		return JET_errSuccess;

	if ( !rgfmp[pfucb->dbid].fLogOn )
		return JET_errSuccess;

	/*	assert in a transaction since will not redo level 0 modifications
	/**/
	Assert( pfucb->ppib->level > 0 );

	LGDeferBeginTransaction( pfucb->ppib );

	pcsr = PcsrCurrent(pfucb);

	lrlockrec.lrtyp		= lrtypLockRec;
	lrlockrec.procid	= pfucb->ppib->procid;
	lrlockrec.pn		= PnOfDbidPgno( pfucb->dbid, pcsr->pgno );

	Assert(	pcsr->itag >= 0 && pcsr->itag <= 255 );
	lrlockrec.itag		= (BYTE)pcsr->itag;
	lrlockrec.bm		= pcsr->bm;
	lrlockrec.cbOldData	= (USHORT)cbData;
	
	rgline[0].pb = (BYTE *)&lrlockrec;
	rgline[0].cb = sizeof(LRLOCKREC);

	rgline[1].pb = pfucb->lineData.pb;
	rgline[1].cb = pfucb->lineData.cb;
	Assert( (unsigned) cbData == pfucb->lineData.cb );

	do
		{
		ULONG ulDBTime = ++rgfmp[ pfucb->dbid ].ulDBTime;

		LGSetUlDBTime( pfucb->ssib.pbf, ulDBTime );
		lrlockrec.ulDBTime = ulDBTime;
		}
	while ( ( err = ErrLGLogRec( rgline, 2, ppibNil ) ) == errLGNotSynchronous );

	LGDepend( pfucb->ssib.pbf, lgposLogRec );
	return err;
	}


ERR ErrLGFlagDelete( FUCB *pfucb, INT fDIRFlags )
	{
	ERR				err;
	LRFLAGDELETE	lrflagdelete;
	LINE			rgline[1];
	CSR				*pcsr;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( pfucb->ppib->fLogDisabled )
		return JET_errSuccess;

	if ( !rgfmp[pfucb->dbid].fLogOn )
		return JET_errSuccess;

	/*	assert in a transaction since will not redo level 0 modifications
	/**/
	Assert( pfucb->ppib->level > 0 );

	LGDeferBeginTransaction( pfucb->ppib );

	pcsr = PcsrCurrent(pfucb);

	lrflagdelete.lrtyp		= lrtypFlagDelete;
	lrflagdelete.procid		= pfucb->ppib->procid;
	lrflagdelete.pn			= PnOfDbidPgno( pfucb->dbid, pcsr->pgno );
	lrflagdelete.fDIRFlags	= fDIRFlags;

	Assert(	pcsr->itag >= 0 && pcsr->itag <= 255 );
	lrflagdelete.itag		= (BYTE)pcsr->itag;
	lrflagdelete.bm			= pcsr->bm;

	rgline[0].pb = (BYTE *)&lrflagdelete;
	rgline[0].cb = sizeof(LRFLAGDELETE);

	do
		{
		ULONG ulDBTime = ++rgfmp[ pfucb->dbid ].ulDBTime;

		LGSetUlDBTime( pfucb->ssib.pbf, ulDBTime );
		lrflagdelete.ulDBTime = ulDBTime;
		}
	while ( ( err = ErrLGLogRec( rgline, 1, ppibNil ) ) == errLGNotSynchronous );

	LGDepend( pfucb->ssib.pbf, lgposLogRec );
	return err;
	}


ERR ErrLGUpdateHeader( FUCB *pfucb, INT bHeader )
	{
	ERR				err;
	LRUPDATEHEADER	lr;
	LINE			rgline[1];
	CSR				*pcsr;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( pfucb->ppib->fLogDisabled )
		return JET_errSuccess;

	if ( !rgfmp[pfucb->dbid].fLogOn )
		return JET_errSuccess;

	/*	assert in a transaction since will not redo level 0 modifications
	/**/
	Assert( pfucb->ppib->level > 0 );

	LGDeferBeginTransaction( pfucb->ppib );

	pcsr = PcsrCurrent(pfucb);

	lr.lrtyp		= lrtypUpdateHeader;
	lr.procid		= pfucb->ppib->procid;
	lr.pn			= PnOfDbidPgno( pfucb->dbid, pcsr->pgno );
	lr.bHeader		= (BYTE)bHeader;

	Assert(	pcsr->itag >= 0 && pcsr->itag <= 255 );
	lr.itag			= (BYTE)pcsr->itag;
	lr.bm			= pcsr->bm;

	rgline[0].pb = (BYTE *)&lr;
	rgline[0].cb = sizeof(LRUPDATEHEADER);

	do
		{
		ULONG ulDBTime = ++rgfmp[ pfucb->dbid ].ulDBTime;

		LGSetUlDBTime( pfucb->ssib.pbf, ulDBTime );
		lr.ulDBTime	= ulDBTime;
		}
	while ( ( err = ErrLGLogRec( rgline, 1, ppibNil ) ) == errLGNotSynchronous );

	LGDepend( pfucb->ssib.pbf, lgposLogRec );
	return err;
	}
	
	
ERR ErrLGDelete( FUCB *pfucb )
	{
	ERR			err;
	LRDELETE	lrdelete;
	LINE		rgline[1];
	CSR			*pcsr;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( pfucb->ppib->fLogDisabled )
		return JET_errSuccess;

	if ( !rgfmp[pfucb->dbid].fLogOn )
		return JET_errSuccess;

	/*	assert in a transaction since will not redo level 0 modifications
	/**/
	Assert( pfucb->ppib->level > 0 );

	LGDeferBeginTransaction( pfucb->ppib );

	pcsr = PcsrCurrent(pfucb);

	lrdelete.lrtyp		= lrtypDelete;
	lrdelete.procid		= pfucb->ppib->procid;
	lrdelete.pn			= PnOfDbidPgno( pfucb->dbid, pcsr->pgno );

	Assert(	pcsr->itag >= 0 && pcsr->itag <= 255 );
	lrdelete.itag		= (BYTE)pcsr->itag;

	rgline[0].pb = (BYTE *)&lrdelete;
	rgline[0].cb = sizeof(LRDELETE);

	do
		{
		ULONG ulDBTime = ++rgfmp[ pfucb->dbid ].ulDBTime;

		LGSetUlDBTime( pfucb->ssib.pbf, ulDBTime );
		lrdelete.ulDBTime = ulDBTime;
		}
	while ( ( err = ErrLGLogRec( rgline, 1, ppibNil ) ) == errLGNotSynchronous );

	LGDepend( pfucb->ssib.pbf, lgposLogRec );
	return err;
	}


ERR ErrLGUndo(	RCE *prce )
	{
	FUCB   	*pfucb = prce->pfucb;
	LRUNDO	lrundo;
	LINE   	rgline[1];
	ERR		err;
	CSR		*pcsr;

	/*	NOTE: even during recovering, we want to record it
	/**/
	if ( fLogDisabled )
		return JET_errSuccess;

	if ( pfucb->ppib->fLogDisabled )
		return JET_errSuccess;

	if ( !rgfmp[pfucb->dbid].fLogOn )
		return JET_errSuccess;

	/*	assert in a transaction since will not redo level 0 modifications
	/**/
	Assert( pfucb->ppib->level > 0 );

	LGDeferBeginTransaction( pfucb->ppib );

	lrundo.lrtyp		= lrtypUndo;
	lrundo.procid		= pfucb->ppib->procid;
	lrundo.bm			= prce->bm;
	lrundo.dbid			= prce->pfucb->dbid;
	lrundo.level		= prce->level;
	lrundo.oper			= prce->oper;
	Assert( lrundo.oper != operNull );
	Assert( sizeof(lrundo.oper) == sizeof(prce->oper) );
	pcsr = PcsrCurrent( pfucb );
	lrundo.bmTarget		= SridOfPgnoItag( pcsr->pgno, pcsr->itag );

	if ( prce->oper == operInsertItem ||
		prce->oper == operFlagInsertItem ||
		prce->oper == operFlagDeleteItem )
		{
		Assert( prce->cbData == sizeof(SRID) );
		lrundo.item	= *(SRID *)prce->rgbData;
		}
	else
		{
		lrundo.item	= 0;
		}

	rgline[0].pb = (BYTE *)&lrundo;
	rgline[0].cb = sizeof(LRUNDO);

	do
		{
		ULONG ulDBTime = ++rgfmp[ pfucb->dbid ].ulDBTime;

		LGSetUlDBTime( pfucb->ssib.pbf, ulDBTime );
		lrundo.ulDBTime = ulDBTime;
		}
	while ( ( err = ErrLGLogRec( rgline, 1, ppibNil ) ) == errLGNotSynchronous );

	LGDepend( pfucb->ssib.pbf, lgposLogRec );
	return err;
	}


ERR ErrLGFreeSpace( RCE *prce, INT cbDelta )
	{
	FUCB		*pfucb = prce->pfucb;
	LRFREESPACE	lrfs;
	LINE		rgline[1];
	ERR			err;
	CSR			*pcsr;

	/* NOTE: even during recovering, we want to record it */
	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( pfucb->ppib->fLogDisabled )
		return JET_errSuccess;

	if ( !rgfmp[pfucb->dbid].fLogOn )
		return JET_errSuccess;

	/*	assert in a transaction since will not redo level 0 modifications
	/**/
	Assert( pfucb->ppib->level > 0 );

	LGDeferBeginTransaction( pfucb->ppib );

	lrfs.lrtyp		= lrtypFreeSpace;
	lrfs.procid		= pfucb->ppib->procid;
	lrfs.bm			= prce->bm;
	lrfs.dbid		= prce->pfucb->dbid;
	lrfs.level		= prce->level;
	pcsr = PcsrCurrent( pfucb );
	lrfs.bmTarget  	= SridOfPgnoItag( pcsr->pgno, pcsr->itag );

	lrfs.cbDelta	= (SHORT)cbDelta;

	rgline[0].pb = (BYTE *)&lrfs;
	rgline[0].cb = sizeof(LRFREESPACE);

	do {
		ULONG ulDBTime = ++rgfmp[ pfucb->dbid ].ulDBTime;
		LGSetUlDBTime( pfucb->ssib.pbf, ulDBTime );
		lrfs.ulDBTime = ulDBTime;
	} while ( ( err = ErrLGLogRec( rgline, 1, ppibNil ) ) == errLGNotSynchronous );
	
	LGDepend( pfucb->ssib.pbf, lgposLogRec );
	return err;
	}
	
	
ERR ErrLGExpungeLinkCommit( FUCB *pfucb, SSIB *pssibSrc, SRID sridSrc )
	{
	ERR	err;
	LRELC	lrelc;
	LINE	rgline[1];
	CSR	*pcsr;

	/* can be called at level 1 only
	/**/
	Assert( pfucb->ppib->level == 1 );

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( pfucb->ppib->fLogDisabled )
		return JET_errSuccess;

	if ( !rgfmp[pfucb->dbid].fLogOn )
		return JET_errSuccess;

	/*	assert in a transaction since will not redo level 0 modifications
	/**/
	Assert( pfucb->ppib->level > 0 );

	LGDeferBeginTransaction( pfucb->ppib );

	pcsr = PcsrCurrent(pfucb);

	lrelc.lrtyp		= lrtypELC;
	lrelc.procid	= pfucb->ppib->procid;
	lrelc.pn		= PnOfDbidPgno( pfucb->dbid, pcsr->pgno );

	Assert(	pcsr->itag >= 0 && pcsr->itag <= 255 );
	lrelc.itag		= (BYTE)pcsr->itag;
	lrelc.sridSrc	= sridSrc;

	rgline[0].pb = (BYTE *)&lrelc;
	rgline[0].cb = sizeof(LRELC);

	do {
		ULONG ulDBTime = ++rgfmp[ pfucb->dbid ].ulDBTime;
		LGSetUlDBTime( pfucb->ssib.pbf, ulDBTime );
		LGSetUlDBTime( pssibSrc->pbf, ulDBTime );
		lrelc.ulDBTime = ulDBTime;
	} while ( ( err = ErrLGLogRec( rgline, 1, ppibNil ) ) == errLGNotSynchronous );

	LGDepend( pfucb->ssib.pbf, lgposLogRec );
	LGDepend( pssibSrc->pbf, lgposLogRec );
	return err;
	}


ERR ErrLGInsertItem( FUCB *pfucb, INT fDIRFlags )
	{
	ERR				err;
	LINE			rgline[1];
	LRINSERTITEM	lrinsertitem;
	CSR				*pcsr;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( pfucb->ppib->fLogDisabled )
		return JET_errSuccess;

	if ( !rgfmp[pfucb->dbid].fLogOn )
		return JET_errSuccess;

	/*	assert in a transaction since will not redo level 0 modifications
	/**/
	Assert( pfucb->ppib->level > 0 );

	LGDeferBeginTransaction( pfucb->ppib );

	pcsr = PcsrCurrent( pfucb );

	lrinsertitem.lrtyp		= lrtypInsertItem;
	lrinsertitem.procid		= pfucb->ppib->procid;
	lrinsertitem.pn			= PnOfDbidPgno( pfucb->dbid, pcsr->pgno );
	lrinsertitem.fDIRFlags	= fDIRFlags;

	Assert(	pcsr->itag > 0 && pcsr->itag <= 255 );
	lrinsertitem.itag		= (BYTE)pcsr->itag;
	lrinsertitem.srid		= pcsr->item;
#ifdef ISRID
	lrinsertitem.isrid		= pcsr->isrid;
#endif
	lrinsertitem.sridItemList = pcsr->bm;

	rgline[0].pb = (BYTE *)&lrinsertitem;
	rgline[0].cb = sizeof(LRINSERTITEM);

	do
		{
		ULONG ulDBTime = ++rgfmp[ pfucb->dbid ].ulDBTime;

		LGSetUlDBTime( pfucb->ssib.pbf, ulDBTime );
		lrinsertitem.ulDBTime = ulDBTime;
		}
	while ( ( err = ErrLGLogRec( rgline, 1, ppibNil ) ) == errLGNotSynchronous );

	LGDepend( pfucb->ssib.pbf, lgposLogRec );
	return err;
	}


ERR ErrLGInsertItems( FUCB *pfucb, ITEM *rgitem, INT citem )
	{
	ERR				err;
	LINE			rgline[2];
	LRINSERTITEMS	lrinsertitems;
	CSR				*pcsr;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( pfucb->ppib->fLogDisabled )
		return JET_errSuccess;

	if ( !rgfmp[pfucb->dbid].fLogOn )
		return JET_errSuccess;

	/*	assert in a transaction since will not redo level 0 modifications
	/**/
	Assert( pfucb->ppib->level > 0 );

	LGDeferBeginTransaction( pfucb->ppib );

	pcsr = PcsrCurrent(pfucb);

	lrinsertitems.lrtyp		= lrtypInsertItems;
	lrinsertitems.procid	= pfucb->ppib->procid;
	lrinsertitems.pn		= PnOfDbidPgno( pfucb->dbid, pcsr->pgno );

	Assert(	pcsr->itag > 0 && pcsr->itag <= 255 );
	lrinsertitems.itag		= (BYTE)pcsr->itag;
	lrinsertitems.citem		= (WORD)citem;

	rgline[0].pb = (BYTE *)&lrinsertitems;
	rgline[0].cb = sizeof(LRINSERTITEMS);
	rgline[1].pb = (BYTE *)rgitem;
	rgline[1].cb = sizeof(ITEM) * citem;

	do {
		ULONG ulDBTime = ++rgfmp[ pfucb->dbid ].ulDBTime;
		LGSetUlDBTime( pfucb->ssib.pbf, ulDBTime );
		lrinsertitems.ulDBTime = ulDBTime;
	} while ( ( err = ErrLGLogRec( rgline, 2, ppibNil ) ) == errLGNotSynchronous );

	LGDepend( pfucb->ssib.pbf, lgposLogRec );
	return err;
	}


ERR	ErrLGDeleteItem( FUCB *pfucb )
	{
	ERR				err;
	LRDELETEITEM 	lrdeleteitem;
	LINE			rgline[1];
	CSR				*pcsr;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( pfucb->ppib->fLogDisabled )
		return JET_errSuccess;

	if ( !rgfmp[pfucb->dbid].fLogOn )
		return JET_errSuccess;

	/*	assert in a transaction since will not redo level 0 modifications
	/**/
	Assert( pfucb->ppib->level > 0 );

	LGDeferBeginTransaction( pfucb->ppib );

	pcsr = PcsrCurrent( pfucb );

	lrdeleteitem.lrtyp		= lrtypDeleteItem;
	lrdeleteitem.procid		= pfucb->ppib->procid;
	lrdeleteitem.pn			= PnOfDbidPgno( pfucb->dbid, pcsr->pgno );

	Assert(	pcsr->itag > 0 && pcsr->itag <= 255 );
	lrdeleteitem.itag		= (BYTE)pcsr->itag;
#ifdef ISRID
	lrdeleteitem.isrid		= pcsr->isrid;
#else
	lrdeleteitem.srid		= pcsr->item;
#endif
	lrdeleteitem.sridItemList	= pcsr->bm;

	rgline[0].pb = (BYTE *)&lrdeleteitem;
	rgline[0].cb = sizeof(LRDELETEITEM);

	do {
		ULONG ulDBTime = ++rgfmp[ pfucb->dbid ].ulDBTime;
		LGSetUlDBTime( pfucb->ssib.pbf, ulDBTime );
		lrdeleteitem.ulDBTime = ulDBTime;
	} while ( ( err = ErrLGLogRec( rgline, 1, ppibNil ) ) == errLGNotSynchronous );

	LGDepend( pfucb->ssib.pbf, lgposLogRec );
	return err;
	}


ERR ErrLGFlagItem( FUCB *pfucb, LRTYP lrtyp )
	{
	ERR			err;
	LRFLAGITEM	lrflagitem;
	LINE		rgline[1];
	CSR			*pcsr;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( pfucb->ppib->fLogDisabled )
		return JET_errSuccess;

	if ( !rgfmp[pfucb->dbid].fLogOn )
		return JET_errSuccess;

	/*	assert in a transaction since will not redo level 0 modifications
	/**/
	Assert( pfucb->ppib->level > 0 );

	LGDeferBeginTransaction( pfucb->ppib );

	pcsr = PcsrCurrent(pfucb);

	lrflagitem.lrtyp		= lrtyp;
	lrflagitem.procid		= pfucb->ppib->procid;
	lrflagitem.pn			= PnOfDbidPgno( pfucb->dbid, pcsr->pgno );

	Assert(	pcsr->itag > 0 && pcsr->itag <= 255 );
	lrflagitem.itag			= (BYTE)pcsr->itag;
#ifdef ISRID
	lrflagitem.isrid		= pfucb->pcsr->isrid;
#else
	lrflagitem.srid			= PcsrCurrent( pfucb )->item;
#endif
	lrflagitem.sridItemList	= PcsrCurrent( pfucb )->bm;

	rgline[0].pb = (BYTE *)&lrflagitem;
	rgline[0].cb = sizeof(LRFLAGITEM);

	do
		{
		ULONG ulDBTime = ++rgfmp[ pfucb->dbid ].ulDBTime;

		LGSetUlDBTime( pfucb->ssib.pbf, ulDBTime );
		lrflagitem.ulDBTime = ulDBTime;
		}
	while ( ( err = ErrLGLogRec( rgline, 1, ppibNil ) ) == errLGNotSynchronous );

	LGDepend( pfucb->ssib.pbf, lgposLogRec );
	return err;
	}


ERR ErrLGSplitItemListNode(
	FUCB	*pfucb,
	INT		cItem,
	INT		itagFather,
	INT		ibSon,
	INT		itagToSplit,
	INT		fFlags )
	{
	ERR		err;
	LINE	rgline[1];
	LRSPLITITEMLISTNODE lrsplititemlistnode;
	CSR		*pcsr;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( pfucb->ppib->fLogDisabled )
		return JET_errSuccess;

	if ( !rgfmp[pfucb->dbid].fLogOn )
		return JET_errSuccess;

	/*	assert in a transaction since will not redo level 0 modifications
	/**/
	Assert( pfucb->ppib->level > 0 );

	LGDeferBeginTransaction( pfucb->ppib );

	pcsr = PcsrCurrent(pfucb);

	lrsplititemlistnode.lrtyp	= lrtypSplitItemListNode;
	lrsplititemlistnode.procid	= pfucb->ppib->procid;
	lrsplititemlistnode.pn		= PnOfDbidPgno( pfucb->dbid, pcsr->pgno );
	lrsplititemlistnode.fFlags = fFlags;

	lrsplititemlistnode.cItem		= (WORD)cItem;
	Assert(	itagToSplit >= 0 && itagToSplit <= 255 );
	lrsplititemlistnode.itagToSplit	= (BYTE)itagToSplit;
	lrsplititemlistnode.itagFather	= (BYTE)itagFather;
	lrsplititemlistnode.ibSon		= (BYTE)ibSon;

	rgline[0].pb = (BYTE *)&lrsplititemlistnode;
	rgline[0].cb = sizeof(LRSPLITITEMLISTNODE);

	do {
		ULONG ulDBTime = ++rgfmp[ pfucb->dbid ].ulDBTime;
		LGSetUlDBTime( pfucb->ssib.pbf, ulDBTime );
		lrsplititemlistnode.ulDBTime = ulDBTime;
	} while ( ( err = ErrLGLogRec( rgline, 1, ppibNil ) ) == errLGNotSynchronous );

	LGDepend( pfucb->ssib.pbf, lgposLogRec );
	return err;
	}

ERR ErrLGDelta( FUCB *pfucb, LONG lDelta, INT fDIRFlags )
	{
	LINE		rgline[1];
	LRDELTA	lrdelta;
	ERR		err;
	CSR		*pcsr;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( pfucb->ppib->fLogDisabled )
		return JET_errSuccess;

	if ( !rgfmp[pfucb->dbid].fLogOn )
		return JET_errSuccess;

	/*	assert in a transaction since will not redo level 0 modifications
	/**/
	Assert( pfucb->ppib->level > 0 );

	LGDeferBeginTransaction( pfucb->ppib );

	pcsr = PcsrCurrent(pfucb);

	lrdelta.lrtyp		= lrtypDelta;
	lrdelta.procid		= pfucb->ppib->procid;
	lrdelta.pn			= PnOfDbidPgno( pfucb->dbid, pcsr->pgno );
	lrdelta.fDIRFlags	= fDIRFlags;

	Assert(	pcsr->itag > 0 && pcsr->itag <= 255 );
	lrdelta.itag		= (BYTE)pcsr->itag;
	lrdelta.bm			= pcsr->bm;
	lrdelta.lDelta		= lDelta;

	rgline[0].pb = (BYTE *)&lrdelta;
	rgline[0].cb = sizeof( LRDELTA );

	do {
		ULONG ulDBTime = ++rgfmp[ pfucb->dbid ].ulDBTime;
		LGSetUlDBTime( pfucb->ssib.pbf, ulDBTime );
		lrdelta.ulDBTime = ulDBTime;
	} while ( ( err = ErrLGLogRec( rgline, 1, ppibNil ) ) == errLGNotSynchronous );

	LGDepend( pfucb->ssib.pbf, lgposLogRec );
	return err;
	}


#ifdef DEBUG

ERR ErrLGCheckPage( FUCB *pfucb, SHORT cbFreeTotal, SHORT itagNext )
	{
	ERR				err;
	CSR				*pcsr = PcsrCurrent( pfucb );
	LINE 			rgline[1];
	LRCHECKPAGE		lrcheckpage;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( pfucb->ppib->fLogDisabled )
		return JET_errSuccess;

	if ( !rgfmp[pfucb->dbid].fLogOn )
		return JET_errSuccess;

	/*	assert in a transaction since will not redo level 0 modifications
	/**/
	Assert( pfucb->ppib->level > 0 );

	LGDeferBeginTransaction( pfucb->ppib );

	lrcheckpage.lrtyp		= lrtypCheckPage;
	lrcheckpage.procid		= pfucb->ppib->procid;
	lrcheckpage.pn			= PnOfDbidPgno( pfucb->dbid, pcsr->pgno );
	lrcheckpage.cbFreeTotal	= cbFreeTotal;
	lrcheckpage.itagNext = itagNext;

	rgline[0].pb = (BYTE *)&lrcheckpage;
	rgline[0].cb = sizeof( LRCHECKPAGE );

	do
		{
		ULONG ulDBTime = ++rgfmp[ pfucb->dbid ].ulDBTime;
		LGSetUlDBTime( pfucb->ssib.pbf, ulDBTime );
		lrcheckpage.ulDBTime = ulDBTime;
		}
	while ( ( err = ErrLGLogRec( rgline, 1, ppibNil ) ) == errLGNotSynchronous );

	LGDepend( pfucb->ssib.pbf, lgposLogRec );
	return err;
	}
#endif


		/****************************************************/
		/*     Transaction Operations                       */
		/****************************************************/


/*	logs deferred open transactions.  No error returned since
/*	failure to log results in termination.
/*/
LOCAL VOID LGIDeferBeginTransaction( PIB *ppib )
	{
	ERR	   		err;
	LINE		rgline[1];
	LRBEGIN		lrbegin;

	Assert( fLogDisabled == fFalse );
	Assert( ppib->fLogDisabled == fFalse );
	Assert( ppib->clgOpenT > 0 );
	Assert( fRecovering == fFalse );

	lrbegin.lrtyp = lrtypBegin;
	lrbegin.procid = ppib->procid;
	lrbegin.levelStart = ppib->levelStart;
	Assert(	lrbegin.levelStart >= 0 && lrbegin.levelStart <= levelMax );
	lrbegin.level = (BYTE) ppib->clgOpenT;
	Assert(	lrbegin.level >= 0 && lrbegin.level <= levelMax );
	rgline[0].pb = (BYTE *) &lrbegin;
	rgline[0].cb = sizeof(LRBEGIN);
	
	while ( ( err = ErrLGLogRec( rgline, 1, ppibNil ) ) == errLGNotSynchronous );

	/* reset deferred open transaction count
	/**/
	if ( err >= 0 )
		ppib->clgOpenT = 0;

	return;
	}


ERR ErrLGBeginTransaction( PIB *ppib, INT levelBeginFrom )
	{
	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( ppib->fLogDisabled )
		return JET_errSuccess;

	if ( !ppib->clgOpenT )
		ppib->levelStart = (LEVEL)levelBeginFrom;

	ppib->clgOpenT++;

	return JET_errSuccess;
	}


ERR ErrLGCommitTransaction( PIB *ppib, INT levelCommitTo )
	{
	ERR			err;
	LINE		rgline[1];
	LRCOMMIT	lrcommit;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( ppib->fLogDisabled )
		return JET_errSuccess;

	if ( ppib->clgOpenT > 0 )
		{
		ppib->clgOpenT--;
		return JET_errSuccess;
		}

	lrcommit.lrtyp = lrtypCommit;
	lrcommit.procid = (ppib)->procid;
	lrcommit.level = (LEVEL)levelCommitTo;

	rgline[0].pb = (BYTE *)&lrcommit;
	rgline[0].cb = sizeof(LRCOMMIT);
	
	while ( ( err = ErrLGLogRec( rgline, 1, levelCommitTo == 0 ? ppib : ppibNil ) ) == errLGNotSynchronous );
	
	Assert( err >= 0 || fLGNoMoreLogWrite );
	return err;
	}


ERR ErrLGAbort( PIB *ppib, INT levelsAborted )
	{
	ERR			err;
	LINE		rgline[1];
	LRABORT		lrabort;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( ppib->fLogDisabled )
		return JET_errSuccess;

	if ( ppib->clgOpenT > 0 )
		{
		if ( ppib->clgOpenT >= levelsAborted )
			{
			ppib->clgOpenT -= levelsAborted;
			return JET_errSuccess;
			}
		levelsAborted -= ppib->clgOpenT;
		ppib->clgOpenT = 0;
		}

	Assert( levelsAborted > 0 );
	lrabort.lrtyp = lrtypAbort;
	lrabort.procid = (ppib)->procid;
	lrabort.levelAborted = (LEVEL)levelsAborted;

	rgline[0].pb = (BYTE *)&lrabort;
	rgline[0].cb = sizeof(LRABORT);
	
	while ( ( err = ErrLGLogRec( rgline, 1, ppibNil ) ) == errLGNotSynchronous );
	return err;
	}


/****************************************************/
/*     Database Operations		                    */
/****************************************************/

ERR ErrLGCreateDB(
	PIB			*ppib,
	DBID		dbid,
	BOOL		fLogOn,
	JET_GRBIT	grbit,
	CHAR		*sz,
	INT			cch )
	{
	LINE rgline[2];
	LRCREATEDB lrcreatedb;
	ERR err;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( ppib->fLogDisabled )
		return JET_errSuccess;

	if ( !rgfmp[dbid].fLogOn )
		return JET_errSuccess;

	lrcreatedb.lrtyp = lrtypCreateDB;
	lrcreatedb.procid = ppib->procid;
	lrcreatedb.dbid = dbid;
	lrcreatedb.fLogOn = fLogOn;
	lrcreatedb.grbit = grbit;
	lrcreatedb.cb = (USHORT)cch;

	rgline[0].pb = (BYTE *)&lrcreatedb;
	rgline[0].cb = sizeof(LRCREATEDB);
	rgline[1].pb = sz;
	rgline[1].cb = cch;
	
	while ( ( err = ErrLGLogRec( rgline, 2, ppibNil ) ) == errLGNotSynchronous );
	return err;
	}


ERR ErrLGAttachDB(
	PIB *ppib,
	DBID dbid,
	BOOL fLogOn,
	CHAR *sz,
	INT cch)
	{
	LINE rgline[2];
	LRATTACHDB lrattachdb;
	ERR err;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( ppib->fLogDisabled )
		return JET_errSuccess;

	if ( !rgfmp[dbid].fLogOn )
		return JET_errSuccess;

	lrattachdb.lrtyp = lrtypAttachDB;
	lrattachdb.procid = ppib->procid;
	lrattachdb.dbid = dbid;
	lrattachdb.fLogOn = (BYTE)fLogOn;
	lrattachdb.cb = (USHORT)cch;

	rgline[0].pb = (BYTE *)&lrattachdb;
	rgline[0].cb = sizeof(LRATTACHDB);
	rgline[1].pb = sz;
	rgline[1].cb = cch;
	
	while ( ( err = ErrLGLogRec( rgline, 2, ppibNil ) ) == errLGNotSynchronous );
	return err;
	}


ERR ErrLGDetachDB(
	PIB *ppib,
	DBID dbid,
	BOOL fLogOn,
	CHAR *sz,
	INT cch)
	{
	LINE rgline[2];
	LRDETACHDB lrdetachdb;
	ERR err;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if (ppib->fLogDisabled)
		return JET_errSuccess;

	if (!rgfmp[dbid].fLogOn)
		return JET_errSuccess;

	lrdetachdb.lrtyp = lrtypDetachDB;
	lrdetachdb.procid = ppib->procid;
	lrdetachdb.dbid = dbid;
	lrdetachdb.fLogOn = fLogOn;
	lrdetachdb.cb = (USHORT)cch;

	rgline[0].pb = (BYTE *)&lrdetachdb;
	rgline[0].cb = sizeof(LRDETACHDB);
	rgline[1].pb = sz;
	rgline[1].cb = cch;
	
	while ( ( err = ErrLGLogRec( rgline, 2, ppibNil ) ) == errLGNotSynchronous );
	return err;
	}

ERR ErrLGMerge( FUCB *pfucb, SPLIT *psplit )
	{
	ERR		err;
	LINE	rgline[2];
	INT		cline;
	LRMERGE	lrmerge;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if (pfucb->ppib->fLogDisabled)
		return JET_errSuccess;

	if (!rgfmp[pfucb->dbid].fLogOn)
		return JET_errSuccess;

	LGDeferBeginTransaction( pfucb->ppib );

	memset(&lrmerge, 0, sizeof(LRMERGE) );
	lrmerge.lrtyp = lrtypMerge;
	lrmerge.procid = pfucb->ppib->procid;
	lrmerge.pn = PnOfDbidPgno( pfucb->dbid, psplit->pgnoSplit );
	lrmerge.pgnoRight = psplit->pgnoSibling;

	/* write the log record */
	/**/
	rgline[0].pb = (BYTE *) &lrmerge;
	rgline[0].cb = sizeof(LRMERGE);
	
	if ( psplit->cbklnk )
		{
		cline = 2;
		lrmerge.cbklnk = (BYTE)psplit->cbklnk;
		rgline[1].cb = sizeof(BKLNK) * psplit->cbklnk;
		rgline[1].pb = (BYTE *) psplit->rgbklnk;
		}
	else
		cline = 1;

	/* set proper timestamp for each touched page
	/**/
	do {
		ULONG	ulDBTime;
		ulDBTime = ++rgfmp[ pfucb->dbid ].ulDBTime;
		psplit->ulDBTimeRedo = ulDBTime;
		
		Assert( psplit->pbfSplit != pbfNil );
		LGSetUlDBTime( psplit->pbfSplit, ulDBTime );

		Assert ( psplit->pbfSibling != pbfNil );
		LGSetUlDBTime( psplit->pbfSibling, ulDBTime );

		if ( psplit->cpbf )
			{
			BF **ppbf = psplit->rgpbf;
			BF **ppbfMax = ppbf + psplit->cpbf;
			for (; ppbf < ppbfMax; ppbf++)
				LGSetUlDBTime( *ppbf, ulDBTime );
			}

		lrmerge.ulDBTime = ulDBTime;

	} while ( ( err = ErrLGLogRec( rgline, cline, ppibNil ) ) == errLGNotSynchronous );

	/* set the buffer-logrec dependency */
	/**/
	LGDepend( psplit->pbfSplit, lgposLogRec);	  	/* merged page */
	LGDepend( psplit->pbfSibling, lgposLogRec);		/* merged-to page */
	if ( psplit->cpbf )
		{
		BF **ppbf = psplit->rgpbf;
		BF **ppbfMax = ppbf + psplit->cpbf;
		for (; ppbf < ppbfMax; ppbf++)
			LGDepend( *ppbf, lgposLogRec);			/* backlink pages */
		}

	return err;
	}


/**********************************************************/
/*****     Split Operations			                  *****/
/**********************************************************/


ERR ErrLGSplit(
	SPLITT		splitt,
	FUCB		*pfucb,
	CSR			*pcsrPagePointer,
	SPLIT		*psplit,
	PGTYP		pgtypNew )
	{
	ERR			err;
	LINE		rgline[4];
	INT			cline;
	LRSPLIT		lrsplit;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( pfucb->ppib->fLogDisabled )
		return JET_errSuccess;

	if ( !rgfmp[pfucb->dbid].fLogOn )
		return JET_errSuccess;

	LGDeferBeginTransaction( pfucb->ppib );

	memset( &lrsplit, 0, sizeof(LRSPLIT) );

	lrsplit.lrtyp = lrtypSplit;
	lrsplit.procid = pfucb->ppib->procid;
	lrsplit.splitt = (BYTE)splitt;
	lrsplit.fLeaf = (BYTE)psplit->fLeaf;
	lrsplit.pn = PnOfDbidPgno( pfucb->dbid, psplit->pgnoSplit );

	Assert(	psplit->itagSplit >= 0 && psplit->itagSplit <= 255 );
	lrsplit.itagSplit = (BYTE)psplit->itagSplit;
//	Assert(	psplit->ibSon >= 0 && psplit->ibSon <= 255 );
	lrsplit.ibSonSplit = (SHORT)psplit->ibSon;
	lrsplit.pgtyp = pgtypNew;

	lrsplit.pgnoNew = psplit->pgnoNew;

	if ( splitt == splittDoubleVertical )
		{
		lrsplit.pgnoNew2 = psplit->pgnoNew2;
		lrsplit.pgnoNew3 = psplit->pgnoNew3;
		}
	else if ( splitt != splittVertical )
		{
		lrsplit.pgnoSibling = psplit->pgnoSibling;
		lrsplit.pgnoFather = pcsrPagePointer->pgno;
		lrsplit.itagFather = (SHORT)pcsrPagePointer->itag;
		Assert(	pcsrPagePointer->ibSon >= 0 &&
			pcsrPagePointer->ibSon <= 255 );
		lrsplit.ibSonFather = (BYTE) pcsrPagePointer->ibSon;
		lrsplit.itagGrandFather = (SHORT)pcsrPagePointer->itagFather;
		}

	/*	write the log record
	/**/
	rgline[0].pb = (BYTE *) &lrsplit;
	rgline[0].cb = sizeof(LRSPLIT);

	if ( splitt == splittVertical )
		cline = 1;
	else
		{
		rgline[1].cb = lrsplit.cbKey = (BYTE)psplit->key.cb;
		rgline[1].pb = psplit->key.pb;
		rgline[2].cb = lrsplit.cbKeyMac = (BYTE)psplit->keyMac.cb;
		rgline[2].pb = psplit->keyMac.pb;
		cline = 3;
		}

	if ( psplit->cbklnk )
		{
		lrsplit.cbklnk = (BYTE)psplit->cbklnk;
		rgline[cline].cb = sizeof( BKLNK ) * lrsplit.cbklnk;
		rgline[cline].pb = (BYTE *) psplit->rgbklnk;
		cline++;
		}

	do
		{
		ULONG		ulDBTime;
		
		/* set proper timestamp for each touched page
		/**/
		ulDBTime = ++rgfmp[ pfucb->dbid ].ulDBTime;
		psplit->ulDBTimeRedo = ulDBTime;

		psplit->pbfSplit->ppage->pghdr.ulDBTime = ulDBTime;
		LGSetUlDBTime( psplit->pbfSplit, ulDBTime );
		
		LGSetUlDBTime( psplit->pbfNew, ulDBTime );

		if ( psplit->pbfNew2 )
			{
			Assert( psplit->pbfNew3 );
			LGSetUlDBTime( psplit->pbfNew2, ulDBTime );
			LGSetUlDBTime( psplit->pbfNew3, ulDBTime );
			}
			
		if ( psplit->pbfSibling )
			LGSetUlDBTime( psplit->pbfSibling, ulDBTime );

		if ( psplit->pbfPagePtr )
			LGSetUlDBTime( psplit->pbfPagePtr, ulDBTime );

		if ( psplit->cpbf )
			{
			BF **ppbf = psplit->rgpbf;
			BF **ppbfMax = ppbf + psplit->cpbf;
			for (; ppbf < ppbfMax; ppbf++)
				LGSetUlDBTime( *ppbf, ulDBTime );
			}

		lrsplit.ulDBTime = ulDBTime;

		}
	while ( ( err = ErrLGLogRec( rgline, cline, ppibNil ) ) == errLGNotSynchronous );

	/*	set the buffer-logrec dependency
	/**/
	LGDepend( psplit->pbfSplit, lgposLogRec);	  	/* split page */

	LGDepend( psplit->pbfNew, lgposLogRec);		  	/* new page */

	if ( splitt == splittDoubleVertical )
		{
		Assert( psplit->pbfNew2 );
		Assert( psplit->pbfNew3 );
		LGDepend( psplit->pbfNew2, lgposLogRec);
		LGDepend( psplit->pbfNew3, lgposLogRec);
		}
	else
		{
		if ( psplit->pbfSibling )
			LGDepend( psplit->pbfSibling, lgposLogRec);

		if ( psplit->pbfPagePtr )
			LGDepend( psplit->pbfPagePtr, lgposLogRec);
		}

	if ( psplit->cpbf )
		{
		BF **ppbf = psplit->rgpbf;
		BF **ppbfMax = ppbf + psplit->cpbf;

		for (; ppbf < ppbfMax; ppbf++)
			LGDepend( *ppbf, lgposLogRec);
		}

	return err;
	}


ERR ErrLGEmptyPage( FUCB *pfucbFather, RMPAGE *prmpage )
	{
	ERR			err;
	LINE		rgline[1];
	LREMPTYPAGE	lremptypage;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( pfucbFather->ppib->fLogDisabled )
		return JET_errSuccess;

	if ( !rgfmp[pfucbFather->dbid].fLogOn )
		return JET_errSuccess;

	LGDeferBeginTransaction( pfucbFather->ppib );

	memset( &lremptypage, 0, sizeof(LREMPTYPAGE) );
	lremptypage.lrtyp = lrtypEmptyPage;
	lremptypage.procid = pfucbFather->ppib->procid;
	lremptypage.pn = PnOfDbidPgno( prmpage->dbid, prmpage->pgnoRemoved );
	lremptypage.pgnoLeft = prmpage->pgnoLeft;
	lremptypage.pgnoRight = prmpage->pgnoRight;
	lremptypage.pgnoFather = prmpage->pgnoFather;
	lremptypage.itag = (SHORT)prmpage->itagPgptr;
	Assert(	prmpage->itagFather >= 0 && prmpage->itagFather <= 255 );
	lremptypage.itagFather = (BYTE)prmpage->itagFather;
	lremptypage.ibSon = (SHORT)prmpage->ibSon;

	/* write the log record */
	rgline[0].pb = (BYTE *) &lremptypage;
	rgline[0].cb = sizeof(LREMPTYPAGE);

	/* set proper timestamp for each touched page
	/**/
	do
		{
		ULONG		ulDBTime;

		ulDBTime = ++rgfmp[ pfucbFather->dbid ].ulDBTime;
		lremptypage.ulDBTime = ulDBTime;
	
		LGSetUlDBTime( pfucbFather->ssib.pbf, ulDBTime );

		if ( prmpage->pbfLeft )
			LGSetUlDBTime( prmpage->pbfLeft, ulDBTime );

		if ( prmpage->pbfRight )
			LGSetUlDBTime( prmpage->pbfRight, ulDBTime );

		}
	while ( ( err = ErrLGLogRec( rgline, 1, ppibNil ) ) == errLGNotSynchronous );

	/* set buffer-logrec dependencies
	/**/
	LGDepend( prmpage->pbfFather, lgposLogRec);
	if ( prmpage->pbfLeft )
		LGDepend( prmpage->pbfLeft, lgposLogRec);
	if ( prmpage->pbfRight )
		LGDepend( prmpage->pbfRight, lgposLogRec);

	return err;
	}


		/****************************************************/
		/*     Misclanious Operations	                    */
		/****************************************************/


ERR ErrLGInitFDPPage(
	FUCB			*pfucb,
	PGNO			pgnoFDPParent,
	PN				pnFDP,
	INT				cpgGot,
	INT				cpgWish )
	{
	ERR				err;
	LINE			rgline[1];
	LRINITFDPPAGE	lrinitfdppage;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( pfucb->ppib->fLogDisabled )
		return JET_errSuccess;

	if ( !rgfmp[pfucb->dbid].fLogOn )
		return JET_errSuccess;

	lrinitfdppage.lrtyp = lrtypInitFDPPage;
	lrinitfdppage.procid = pfucb->ppib->procid;
	lrinitfdppage.pgnoFDPParent = pgnoFDPParent;
	lrinitfdppage.pn = pnFDP;
	lrinitfdppage.cpgGot = (USHORT)cpgGot;
	lrinitfdppage.cpgWish = (USHORT)cpgWish;

	rgline[0].pb = (BYTE *)&lrinitfdppage;
	rgline[0].cb = sizeof(LRINITFDPPAGE);
	
	do
		{
		ULONG ulDBTime = ++rgfmp[ pfucb->dbid ].ulDBTime;

		LGSetUlDBTime( pfucb->ssib.pbf, ulDBTime );
		lrinitfdppage.ulDBTime = ulDBTime;
		}
	while ( ( err = ErrLGLogRec( rgline, 1, ppibNil ) ) == errLGNotSynchronous );
	return err;
	}


ERR ErrLGStart( )
	{
	ERR		err;
	LINE	rgline[1];
	LRSTART	lr;

	Assert( !fRecovering );
	
	if ( fLogDisabled )
		return JET_errSuccess;

	lr.lrtyp = lrtypStart;
	LGStoreDBEnv( &lr.dbenv );

	rgline[0].pb = (BYTE *)&lr;
	rgline[0].cb = sizeof(lr);
	while ( ( err = ErrLGLogRec( rgline, 1, ppibNil ) ) == errLGNotSynchronous );
	lgposStart = lgposLogRec;
	
	return err;
	}
	

ERR ErrLGQuitRec( LRTYP lrtyp, LGPOS *plgpos, LGPOS *plgposRedoFrom, BOOL fHard )
	{
	ERR			err;
	LINE		rgline[1];
	LRQUITREC	lr;

	/* NOTE: even during recovering, we want to record it */
	if ( fLogDisabled )
		return JET_errSuccess;

	lr.lrtyp = lrtyp;
	lr.lgpos = *plgpos;
	if ( plgposRedoFrom )
		{
		Assert( lrtyp == lrtypRecoveryQuit1 ||
				lrtyp == lrtypRecoveryQuit2 );
		lr.lgpos = *plgposRedoFrom;
		lr.fHard = (BYTE)fHard;
		}
	rgline[0].pb = (BYTE *)&lr;
	rgline[0].cb = sizeof(lr);
	while ( ( err = ErrLGLogRec( rgline, 1, ppibNil ) ) == errLGNotSynchronous );
	return err;
	}

	
ERR ErrLGLogRestore( LRTYP lrtyp, CHAR * szLogRestorePath )
	{
	ERR				err;
	LINE			rgline[2];
	LRLOGRESTORE	lr;
	
	/* NOTE: even during recovering, we want to record it */
	if ( fLogDisabled )
		return JET_errSuccess;

	lr.lrtyp = lrtyp;
	lr.cbPath = (USHORT)strlen(szLogRestorePath);

	rgline[0].pb = (BYTE *)&lr;
	rgline[0].cb = sizeof(lr);
	rgline[1].pb = szLogRestorePath;
	rgline[1].cb = lr.cbPath;
	while ( ( err = ErrLGLogRec( rgline, 2, ppibNil ) ) == errLGNotSynchronous );
	return err;
	}


#ifdef HILEVEL_LOGGING

ERR ErrLGAddColumn(
	FUCB *pfucb,
	CHAR *sz,
	JET_COLUMNDEF *pcolumndef,
	BYTE *pdefault,
	ULONG cdefault,
	JET_COLUMNID *pcolid )
	{
	LINE	rgline[3];
	LR		lr;

	if ( !( FLoggable( pfucb->dbid) && FXactLoggable( pfucb->ppib ) ) )
		return JET_errSuccess;

	lr.lrtyp = lrtypAddCol;
	lr.lraddcol.procid = pfucb->ppib->procid;
	lr.lraddcol.pn = PnOfDbidPgno( pfucb->dbid, pfucb->u.pfcb->pgnoFDP );
	memcpy( &(lr.lraddcol.columndef), pcolumndef, sizeof(JET_COLUMNDEF) );
	memcpy( &(lr.lraddcol.columnid), pcolid, sizeof(JET_COLUMNID) );
	lr.lraddcol.timepage = rgfmp[ pfucb->dbid ].ulLogTimestamp;
	lr.lraddcol.cbname =  strlen( sz );
	lr.lraddcol.cbdefault =  cdefault;

	rgline[0].pb = (BYTE *)&lr;
	rgline[0].cb = sizeof(LRTYP) + sizeof(LRADDCOL);
	rgline[1].pb = sz;
	rgline[1].cb = strlen( sz );
	rgline[2].pb = pdefault;
	rgline[2].cb = cdefault;
	return ErrLGLogRec( rgline, 3, fFalse );
	}


ERR ErrLGRenameCol( FUCB *pfucb, CHAR *sz, CHAR *szNew )
	{
	LINE	rgline[3];
	LR		lr;

	if (!(FLoggable( pfucb->dbid) && FXactLoggable( pfucb->ppib ) ))
		return JET_errSuccess;

	lr.lrtyp = lrtypRenameCol;
	lr.lrrenamecol.procid = pfucb->ppib->procid;
	lr.lrrenamecol.pn = PnOfDbidPgno( pfucb->dbid, pfucb->ssib.pn );
	lr.lrrenamecol.cbname =  strlen( sz );
	lr.lrrenamecol.cbnamenew =  strlen( szNew );
	lr.lrrenamecol.timepage = rgfmp[ pfucb->dbid ].ulLogTimestamp;

	rgline[0].pb = (BYTE *) &lr;
	rgline[0].cb = sizeof(LRTYP) + sizeof(LRRENAMECOL);
	rgline[1].pb = sz;
	rgline[1].cb = lr.lrrenamecol.cbname;
	rgline[2].pb = szNew;
	rgline[2].cb = lr.lrrenamecol.cbnamenew;
	return ErrLGLogRec( rgline, 3, fFalse );
	}


ERR ErrLGDeleteCol( FUCB *pfucb, CHAR *sz )
	{
	LINE	rgline[2];
	LR		lr;

	if ( !( FLoggable( pfucb->dbid) && FXactLoggable( pfucb->ppib ) ) )
		return JET_errSuccess;

	lr.lrtyp = lrtypDeleteCol;
	lr.lrdeletecol.procid = pfucb->ppib->procid;
	lr.lrdeletecol.pn = PnOfDbidPgno( pfucb->dbid, pfucb->pcsr->pgno );
	lr.lrdeletecol.cbname =  strlen( sz );
	lr.lrdeletecol.timepage = rgfmp[ pfucb->dbid ].ulLogTimestamp;

	rgline[0].pb = (BYTE *)&lr;
	rgline[0].cb = sizeof(LRTYP) + sizeof(LRDELETECOL);
	rgline[1].pb = sz;
	rgline[1].cb = lr.lrdeletecol.cbname;
	return ErrLGLogRec( rgline, 2, fFalse );
	}


ERR ErrLGCreateFDP(
	FUCB *pfucb,
	PN pnDB,
	CHAR *szName,
	INT cpages,
	ULONG dens )
	{
	LINE	rgline[2];
	LR		lr;

	if ( !( FLoggable( pfucb->dbid) && FXactLoggable( pfucb->ppib ) ) )
		return JET_errSuccess;

	lr.lrtyp = lrtypCreatefdp;
	lr.lrcreatefdp.procid = pfucb->ppib->procid;
	lr.lrcreatefdp.cpages = cpages;
	lr.lrcreatefdp.density = dens;
	lr.lrcreatefdp.pn = pnDB;
	lr.lrcreatefdp.timepage = rgfmp[ pfucb->dbid ].ulLogTimestamp;
	lr.lrcreatefdp.cbdata = strlen(szName);

	rgline[0].pb = (BYTE *)&lr;
	rgline[0].cb = sizeof(LRTYP) + sizeof(LRCREATEFDP);
	rgline[1].pb = szName;
	rgline[1].cb = lr.lrcreatefdp.cbdata;
	return ErrLGLogRec( rgline, 2, fFalse );
	}


ERR ErrLGCreateIdx(
	FUCB *pfucb,
	CHAR *szName,
	ULONG ulFlags,
	CHAR *szKey,
	INT cchKey,
	ULONG ulDensity )
	{
	ERR		err;
	LINE	rgline[3];
	LR		lr;

	if ( !( FLoggable( pfucb->dbid) && FXactLoggable( pfucb->ppib ) ) )
		return JET_errSuccess;

	lr.lrtyp = lrtypCreateidx;
	lr.lrcreateidx.procid = pfucb->ppib->procid;
	lr.lrcreateidx.flags = ulFlags;
	lr.lrcreateidx.density = ulDensity;
	lr.lrcreateidx.pn = PnOfDbidPgno( pfucb->dbid, pfucb->u.pfcb->pgnoFDP);
	lr.lrcreateidx.timepage = rgfmp[ pfucb->dbid ].ulLogTimestamp;
	lr.lrcreateidx.cbname = strlen( szName );
	lr.lrcreateidx.cbkey = cchKey;

	rgline[0].pb = (BYTE *) &lr;
	rgline[0].cb = sizeof(LRTYP) + sizeof(LRCREATEIDX);
	rgline[1].pb = szName;
	rgline[1].cb = lr.lrcreateidx.cbname;
	rgline[2].pb = szKey;
	rgline[2].cb = cchKey;
	CallR( ErrLGLogRec( rgline, 3, fFalse ) )
	LGDepend( pfucb->ssib.pbf, lgposLogRec);
	return err;
	}


ERR ErrLGEndOp ( BF *pbffocus )
	{
	LINE	rgline[1];
	LR		lr;

	if ( !( FLoggable( DbidOfPn(pbffocus->pn) ) ) )
		return JET_errSuccess;

	lr.lrtyp = lrtypEndop;
	lr.lrendop.pn = pbffocus->pn;
	lr.lrendop.timepage = rgfmp[ DbidOfPn( pbffocus->pn ) ].ulLogTimestamp;

	rgline[0].pb = (BYTE *) &lr;
	rgline[0].cb = sizeof(LRTYP) + sizeof(LRENDOP);
    return ErrLGLogRec( rgline, 1, fFalse );
	}


#endif


#endif


#ifdef DEBUG

CHAR *mplrtypsz[ lrtypMax + 1 ] = {
		/* 	0 */		"NOP      ",
		/* 	1 */		"Start    ",
		/* 	2 */		"Quit     ",
		/* 	3 */		"MS       ",
		/* 	4 */		"Fill     ",

		/* 	5 */		"Begin    ",
		/*	6 */		"Commit   ",
		/*	7 */		"Abort    ",

		/*	8 */		"CreateDB ",
		/* 	9 */		"AttachDB ",
		/*	10*/		"DetachDB ",

		/*	11*/		"InitFDP  ",

		/*	12*/		"Split    ",
		/*	13*/		"EmptyPg  ",
		/*	14*/		"Merge    ",

		/* 	15*/		"InsertND ",
		/* 	16*/		"InsertIL ",
		/* 	17*/		"Replace  ",
		/* 	18*/		"ReplaceC ",
		/* 	19*/		"FDelete  ",
		/*	20*/		"LockRec  ",
										
		/* 	21*/		"UpdtHdr  ",
		/* 	22*/		"InsertI  ",
		/* 	23*/		"InsertIs ",
		/* 	24*/		"FDeleteI ",
		/* 	25*/		"FInsertI ",
		/*	26*/		"DeleteI  ",
		/*	27*/		"SplitItm ",

		/*	28*/		"Delta    ",
		/*	29*/		"DelNode  ",
		/*	30*/		"ELC      ",

		/*	31*/		"FreeSpace",
		/*	32*/		"Undo     ",
		
		/*	33*/		"RcvUndo1 ",
		/*	34*/		"RcvQuit1 ",
		/*	35*/		"RcvUndo2 ",
		/*	36*/		"RcvQuit2 ",
		
		/*	37*/		"FullBkUp ",
		/*	38*/		"IncBkUp  ",

		/*	39*/		"CheckPage",

		/*	40*/		"*UNKNOWN*"
};


/*	Prints log record contents.  If pb == NULL, then data is assumed
/*	to follow log record in contiguous memory.
/**/
VOID ShowLR( LR *plr )
	{
	LRTYP lrtyp;

	if ( plr->lrtyp >= lrtypMax )
		lrtyp = lrtypMax;
	else
		lrtyp = plr->lrtyp;

	PrintF2( " %s", mplrtypsz[lrtyp] );

	switch ( plr->lrtyp )
		{
		case lrtypNOP:
			break;

		case lrtypMS:
			{
			LRMS *plrms = (LRMS *)plr;

			PrintF2( " (%3u,%3u,%3u,%3u checksum %u)",
				plrms->isecForwardLink, plrms->ibForwardLink,
				plrms->isecBackLink, plrms->ibBackLink,
				plrms->ulCheckSum );
			break;
			}

		case lrtypInsertNode:
		case lrtypInsertItemList:
			{
			LRINSERTNODE	*plrinsertnode = (LRINSERTNODE *)plr;
			BYTE			*pb;
			USHORT			cb;

			pb = (BYTE *) plr + sizeof( LRINSERTNODE );
			cb = plrinsertnode->cbKey + plrinsertnode->cbData;
			
			if ( plr->lrtyp == lrtypInsertItemList )
				{
				ITEM item = *(UNALIGNED SRID *) (pb + plrinsertnode->cbKey);

				PrintF2( " %lu(%lx,([%u:%lu,%3d,%3u],%3u)%#4X,%3u,%5u,(%lu:%u))\n",
					plrinsertnode->ulDBTime,
					plrinsertnode->procid,
					DbidOfPn(plrinsertnode->pn),
					PgnoOfPn(plrinsertnode->pn),
					plrinsertnode->itagFather,
					plrinsertnode->ibSon,
					plrinsertnode->itagSon,
					plrinsertnode->bHeader,
					plrinsertnode->cbKey,
					plrinsertnode->cbData,
					PgnoOfSrid(BmNDOfItem(item)),
					ItagOfSrid(BmNDOfItem(item)) );
				}
			else
				{
				PrintF2( " %lu(%lx,([%u:%lu:%u,%3d],%3u)%#4X,%3u,%5u)",
					plrinsertnode->ulDBTime,
					plrinsertnode->procid,
					DbidOfPn(plrinsertnode->pn),
					PgnoOfPn(plrinsertnode->pn),
					plrinsertnode->itagFather,
					plrinsertnode->itagSon,
					plrinsertnode->ibSon,
					plrinsertnode->bHeader,
					plrinsertnode->cbKey,
					plrinsertnode->cbData );
				ShowData( pb, cb );
				}
			break;
			}

		case lrtypReplace :
		case lrtypReplaceC :
			{
			LRREPLACE *plrreplace = (LRREPLACE *)plr;
			BYTE	*pb;
			USHORT	cb;

			pb = (BYTE *) plrreplace + sizeof( LRREPLACE );
			cb = plrreplace->cb;

			PrintF2( " %lu(%lx,(%u:%lu:%u),%#4X,%5u,%5u,%1u,%5u)",
				plrreplace->ulDBTime,
				plrreplace->procid,
				DbidOfPn(plrreplace->pn),
				PgnoOfPn(plrreplace->pn),
				plrreplace->itag,
				plrreplace->fDIRFlags,
				cb,
				plrreplace->cbNewData,
				plrreplace->fOld,
				plrreplace->cbOldData);

			if ( plrreplace->fOld )
				{
				ShowData( plrreplace->szData + cb, plrreplace->cbOldData );
				PrintF2( " .. " );
				}
			ShowData( pb, cb );
			break;
			}

		case lrtypFlagDelete:
			{
			LRFLAGDELETE *plrdelete = (LRFLAGDELETE *)plr;
			PrintF2( " %lu(%lx,(%u:%lu:%u),%#4X)",
				plrdelete->ulDBTime,
				plrdelete->procid,
				DbidOfPn(plrdelete->pn),
				PgnoOfPn(plrdelete->pn),
				plrdelete->itag,
				plrdelete->fDIRFlags );
			break;
			}

		case lrtypDelete:
			{
			LRDELETE *plrdelete = (LRDELETE *)plr;
			PrintF2( " %lu(%lx,(%u:%lu:%u))",
				plrdelete->ulDBTime,
				plrdelete->procid,
				DbidOfPn(plrdelete->pn),
				PgnoOfPn(plrdelete->pn),
				plrdelete->itag );
			break;
			}

		case lrtypLockRec:
			{
			LRLOCKREC	*plrlockrec = (LRLOCKREC *)plr;
			PrintF2( " %lu,(%lx,(%u:%lu:%u))",
				plrlockrec->ulDBTime,
				plrlockrec->procid,
				DbidOfPn(plrlockrec->pn),
				PgnoOfPn(plrlockrec->pn),
				plrlockrec->itag);
			break;
			}

		case lrtypELC:
			{
			LRELC *plrelc = (LRELC *)plr;
			PrintF2( " %lu(%lx,(%u:%lu:%u), (%u:%lu:%u))",
				plrelc->ulDBTime,
				plrelc->procid,
				DbidOfPn(plrelc->pn),
				PgnoOfPn(plrelc->pn),
				plrelc->itag,
				DbidOfPn(plrelc->pn),
				PgnoOfSrid(plrelc->sridSrc),
				ItagOfSrid(plrelc->sridSrc) );
			break;
			}

		case lrtypInsertItem:
			{
			LRINSERTITEM *plrinsertitem = (LRINSERTITEM *)plr;
			PrintF2( " %lu(%lx,(%u:%lu:%d),%3u,(%u:%lu:%u))",
				plrinsertitem->ulDBTime,
				plrinsertitem->procid,
				DbidOfPn(plrinsertitem->pn),
				PgnoOfPn(plrinsertitem->pn),
				plrinsertitem->itag,
#ifdef ISRID
				plrinsertitem->isrid,
#else
				0,
#endif
				DbidOfPn(plrinsertitem->pn),
				PgnoOfSrid(BmNDOfItem(plrinsertitem->srid)),
				ItagOfSrid(plrinsertitem->srid) );
			break;
			}

		case lrtypInsertItems:
			{
			LRINSERTITEMS *plrinsertitems = (LRINSERTITEMS *)plr;
			ITEM	*pitemMax = plrinsertitems->rgitem + plrinsertitems->citem;
			ITEM	*pitem = plrinsertitems->rgitem;

			PrintF2( " %lu(%lx,(%u:%lu:%u),%3u)\n",
				plrinsertitems->ulDBTime,
				plrinsertitems->procid,
				DbidOfPn(plrinsertitems->pn),
				PgnoOfPn(plrinsertitems->pn),
				plrinsertitems->itag,
				plrinsertitems->citem
				);

			for ( ; pitem<pitemMax; pitem++ )
				{
				PrintF2( "[%u:%lu:%u]\n",
					DbidOfPn(plrinsertitems->pn),
					PgnoOfSrid( *(UNALIGNED ITEM *)pitem ),
					ItagOfSrid( *(UNALIGNED ITEM *)pitem )
					);
				}
			break;
			}

		case lrtypFlagDeleteItem:
		case lrtypFlagInsertItem:
			{
			LRFLAGITEM *plritem = (LRFLAGITEM *)plr;
			PrintF2( " %lu(%lx,(%u:%lu:%u),%u,(%u:%lu:%u))",
				plritem->ulDBTime,
				plritem->procid,
				DbidOfPn(plritem->pn),
				PgnoOfPn(plritem->pn),
				plritem->itag,
#ifdef ISRID
				plritem->isrid,
#else
				0,
#endif
				DbidOfPn(plritem->pn),
				PgnoOfSrid(plritem->srid),
				ItagOfSrid(plritem->srid) );
			break;
			}

		case lrtypDeleteItem:
			{
			LRDELETEITEM *plritem = (LRDELETEITEM *)plr;
			PrintF2( " %lu(%lx,(%u:%lu:%u),%u,(%u:%lu:%u))",
				plritem->ulDBTime,
				plritem->procid,
				DbidOfPn(plritem->pn),
				PgnoOfPn(plritem->pn),
				plritem->itag,
#ifdef ISRID
				plritem->isrid,
#else
				0,
#endif
				DbidOfPn(plritem->pn),
				PgnoOfSrid(plritem->sridItemList),
				ItagOfSrid(plritem->sridItemList));
			break;
			}

		case lrtypSplitItemListNode:
			{
			LRSPLITITEMLISTNODE *plrsiln = (LRSPLITITEMLISTNODE *)plr;

			PrintF2( " %lu(%lx,([%u:%lu:%u],%3d,%3u)%u)",
				plrsiln->ulDBTime,
				plrsiln->procid,
				DbidOfPn(plrsiln->pn),
				PgnoOfPn(plrsiln->pn),
				plrsiln->itagToSplit,
				plrsiln->itagFather,
				plrsiln->ibSon,
				plrsiln->cItem);
			break;
			}

		case lrtypDelta:
			{
			LRDELTA *plrdelta = (LRDELTA *)plr;

			PrintF2( " %lu(%lx,(%u:%lu:%u),%#4X,(%u:%lu:%u),%d)",
				plrdelta->ulDBTime,
				plrdelta->procid,
				DbidOfPn(plrdelta->pn),
				PgnoOfPn(plrdelta->pn),
				plrdelta->itag,
				plrdelta->fDIRFlags,
				DbidOfPn(plrdelta->pn),
				PgnoOfSrid(plrdelta->bm),
				ItagOfSrid(plrdelta->bm),
				plrdelta->lDelta );
			break;
			}

		case lrtypCheckPage:
			{
			LRCHECKPAGE *plrcheckpage = (LRCHECKPAGE *)plr;

			PrintF2( " %lu(%lx,([%u:%lu],%3u),%d)",
				plrcheckpage->ulDBTime,
				plrcheckpage->procid,
				DbidOfPn(plrcheckpage->pn),
				PgnoOfPn(plrcheckpage->pn),
				plrcheckpage->itagNext,
				plrcheckpage->cbFreeTotal );
			break;
			}

		case lrtypBegin:
			{
			LRBEGIN *plrbegin = (LRBEGIN *)plr;
			Assert(plrbegin->level >= 0);
			Assert(plrbegin->level <= levelMax);
	   		PrintF2( " (%lx,%d,%d)",
	   			plrbegin->procid,
	   			(USHORT) plrbegin->levelStart,
	   			(USHORT) plrbegin->level );
			break;
			}

		case lrtypCommit:
			{
			LRCOMMIT *plrcommit = (LRCOMMIT *)plr;
	   		PrintF2( " (%lx,%d)",
	   			plrcommit->procid,
	   			(USHORT) plrcommit->level );
			break;
			}

		case lrtypAbort:
			{
			LRABORT *plrabort = (LRABORT *)plr;
			PrintF2( " (%lx,%d)",
				plrabort->procid,
				(USHORT) plrabort->levelAborted );
			break;
			}

		case lrtypCreateDB:
			{
			LRCREATEDB *plrcreatedb = (LRCREATEDB *) plr;
			CHAR *sz;

			sz = (BYTE *)plr + sizeof(LRCREATEDB);
			PrintF2( " (%s,%3u)", sz, plrcreatedb->dbid );
			break;
			}

		case lrtypAttachDB:
			{
			LRATTACHDB *plrattachdb = (LRATTACHDB *) plr;
			CHAR *sz;

			sz = (BYTE *)plrattachdb + sizeof(LRATTACHDB);
			PrintF2( " (%s,%3u)", sz, plrattachdb->dbid );
			break;
			}

		case lrtypDetachDB:
			{
			LRDETACHDB *plrdetachdb = (LRDETACHDB *) plr;
			CHAR *sz;

			sz = (BYTE *)plrdetachdb + sizeof(LRDETACHDB);
			PrintF2( " (%s,%3u)", sz, plrdetachdb->dbid );
			break;
			}

		case lrtypInitFDPPage:
			{
			LRINITFDPPAGE *plrinitfdppage = (LRINITFDPPAGE *)plr;

			PrintF2( " %lu(%lx,([%d:%lu]),%3u,%3u,%6lu)",
				plrinitfdppage->ulDBTime,
				plrinitfdppage->procid,
				DbidOfPn(plrinitfdppage->pn),
				PgnoOfPn(plrinitfdppage->pn),
				(USHORT) plrinitfdppage->cpgGot,
				(USHORT) plrinitfdppage->cpgWish,
				plrinitfdppage->ulDBTime);
			break;
			}

		case lrtypSplit:
			{
			LRSPLIT *plrsplit = (LRSPLIT *)plr;

			if ( plrsplit->splitt == splittVertical )
				PrintF2( " Vertical" );
			else if ( plrsplit->splitt == splittDoubleVertical )
				PrintF2( " DoubleV" );
			else if ( plrsplit->splitt == splittLeft )
				PrintF2( " SplitLeft" );
			else if ( plrsplit->splitt == splittRight )
				PrintF2( " SplitRight" );
			else
				{
				Assert ( plrsplit->splitt == splittAppend );
				PrintF2(" Append");
				}

			if ( plrsplit->splitt == splittVertical )
				{
				PrintF2( " %lu(%lx,(%u:%lu:%u),%5lu)",
					plrsplit->ulDBTime,
					plrsplit->procid,
					DbidOfPn(plrsplit->pn),
					PgnoOfPn(plrsplit->pn),
					plrsplit->itagSplit,
					plrsplit->pgnoNew );
				}
			else if ( plrsplit->splitt == splittDoubleVertical )
				{
				PrintF2( " %lu(%lx,(%u:%lu:%u),%5lu,%5lu,%5lu)",
					plrsplit->ulDBTime,
					plrsplit->procid,
					DbidOfPn(plrsplit->pn),
					PgnoOfPn(plrsplit->pn),
					plrsplit->itagSplit,
					plrsplit->pgnoNew,
					plrsplit->pgnoNew2,
					plrsplit->pgnoNew3 );
				}
			else
				{
				PrintF2( " %lu(%lx,[(%u:%lu:%u),%3d,%3u],%5lu)",
					plrsplit->ulDBTime,
					plrsplit->procid,
					DbidOfPn(plrsplit->pn),
					PgnoOfPn(plrsplit->pn),
					plrsplit->itagSplit,
					plrsplit->itagFather,
					plrsplit->ibSonSplit,
					plrsplit->pgnoNew );
				}

			#if 1
				{
				BKLNK	*pbklnk = (BKLNK *)(plrsplit->rgb +
					plrsplit->cbKey +
					plrsplit->cbKeyMac);
				BKLNK	*pbklnkMax = pbklnk + plrsplit->cbklnk;

				for ( ; pbklnk < pbklnkMax; pbklnk++ )
					{
					PrintF2( " [%u:%lu:%u] [%u:%lu:%u]\n",
						DbidOfPn(plrsplit->pn),
						PgnoOfSrid( pbklnk->sridBackLink ),
						ItagOfSrid( pbklnk->sridBackLink ),
						DbidOfPn(plrsplit->pn),
						PgnoOfSrid( pbklnk->sridNew ),
						ItagOfSrid( pbklnk->sridNew ) );
					}
				}
			#endif

	
			break;
			}

		case lrtypEmptyPage:
			{
			LREMPTYPAGE *plrep = (LREMPTYPAGE *)plr;

			PrintF2( " %lu(%lx,(%u:%lu),(%u:%lu:%u),%5lu, %5lu)",
				plrep->ulDBTime,
				plrep->procid,
				DbidOfPn(plrep->pn),
				PgnoOfPn(plrep->pn),
				DbidOfPn(plrep->pn),
				plrep->pgnoFather,
				plrep->itag,
				plrep->pgnoLeft,
				plrep->pgnoRight );
			break;
			}

		case lrtypMerge:
			{
			LRMERGE *plrmerge = (LRMERGE *)plr;
			BKLNK *pbklnk = (BKLNK *) &plrmerge->rgb[0];

			PrintF2(" %lu(%lx,[%u:%lu],[%u:%lu],%3u,(%lu:%d),(%lu:%d))",
				plrmerge->ulDBTime,
				plrmerge->procid,
				DbidOfPn(plrmerge->pn),
				PgnoOfPn(plrmerge->pn),
				DbidOfPn(plrmerge->pn),
				plrmerge->pgnoRight,
				plrmerge->cbklnk,
				PgnoOfSrid(pbklnk->sridBackLink),
				(SHORT) ItagOfSrid(pbklnk->sridBackLink),
				PgnoOfSrid(pbklnk->sridNew),
				(SHORT) ItagOfSrid(pbklnk->sridNew) );
			break;
			}
			
		case lrtypFreeSpace:
			{
			LRFREESPACE *plrfreespace = (LRFREESPACE *)plr;
			PrintF2( " %lu(%lx,(%u:%lu:%u),%3u,%3u)",
				plrfreespace->ulDBTime,
				plrfreespace->procid,
				plrfreespace->dbid,
				PgnoOfSrid(plrfreespace->bm),
				(USHORT) ItagOfSrid(plrfreespace->bm),
				(USHORT) plrfreespace->level,
				(USHORT) plrfreespace->cbDelta
				);
			break;
			}

		case lrtypUndo:
			{
			LRUNDO *plrundo = (LRUNDO *)plr;
			PrintF2( " %lu(%lx,(%u:%lu:%u),%3u,%3u,(%u:%lu:%u))",
				plrundo->ulDBTime,
				plrundo->procid,
				plrundo->dbid,
				PgnoOfSrid(plrundo->bm),
				(USHORT) ItagOfSrid(plrundo->bm),
				(USHORT) plrundo->level,
				(USHORT) plrundo->oper,
				plrundo->dbid,
				PgnoOfSrid(BmNDOfItem(plrundo->item)),
				(USHORT) ItagOfSrid(plrundo->item)
				);
			break;
			}

		case lrtypStart:
			{
			DBENV *pdbenv = &((LRSTART *)plr)->dbenv;
			
			PrintF2( "\n      Env SysDbPath:%s\n",	pdbenv->szSysDbPath);
			PrintF2( "      Env LogFilePath:%s\n", pdbenv->szLogFilePath);
			PrintF2( "      Env (Session, Opentbl, VerPage, Cursors, LogBufs, Buffers)\n");
			PrintF2( "          (%7lu, %7lu, %7lu, %7lu, %7lu, %7lu)\n",
				pdbenv->ulMaxSessions,
				pdbenv->ulMaxOpenTables,
				pdbenv->ulMaxVerPages,
				pdbenv->ulMaxCursors,
				pdbenv->ulLogBuffers,
				pdbenv->ulMaxBuffers );
			}
			break;
			
		case lrtypQuit:
			break;
			
		case lrtypRecoveryQuit1:
		case lrtypRecoveryQuit2:
			{
			LRQUITREC *plrquit = (LRQUITREC *) plr;

			if ( plrquit->fHard )
				PrintF2( "\n      Quit on Hard Restore." );
			else
				PrintF2( "\n      Quit on Soft Restore." );
			
			PrintF2( "      RedoFrom:(%d,%d,%d)\n",
				(short) plrquit->lgposRedoFrom.usGeneration,
				(short) plrquit->lgposRedoFrom.isec,
				(short) plrquit->lgposRedoFrom.ib );
						
			PrintF2( "      UndoFrom:(%d,%d,%d)\n",
  				(short) plrquit->lgpos.usGeneration,
				(short) plrquit->lgpos.isec,
				(short) plrquit->lgpos.ib );
			}
			break;
			
		case lrtypRecoveryUndo1:
		case lrtypRecoveryUndo2:
		case lrtypFullBackup:
		case lrtypIncBackup:
			{
			LRLOGRESTORE *plrlr = (LRLOGRESTORE *) plr;
			CHAR *sz;

			sz = (BYTE *)plrlr + sizeof(LRLOGRESTORE);
			PrintF2( " %s", sz );
			break;
			}

		case lrtypUpdateHeader:
			{
			LRUPDATEHEADER *plruh = (LRUPDATEHEADER *)plr;
			PrintF2( " %lu(%lx,(%u:%lu:%d),(%u:%lu:%u)),%#4X",
				plruh->ulDBTime,
				plruh->procid,
				DbidOfPn(plruh->pn),
				PgnoOfPn(plruh->pn),
				plruh->itag,
				DbidOfPn(plruh->pn),
				PgnoOfSrid(plruh->bm),
				(USHORT) ItagOfSrid(plruh->bm),
				(USHORT) plruh->bHeader
				);
			break;
			}
			
		default:
			{
			Assert( fFalse );
			break;
			}
		}
	}


extern BYTE mpbb[];


VOID ShowData ( BYTE *pbData, WORD cbData )
	{
	BYTE	*pb;
	BYTE	*pbMax;
	BYTE	rgbPrint[200];
	BYTE	*pbPrint = rgbPrint;

	if ( cbData > 8 )
		pbMax = pbData + 3;
	else
		pbMax = pbData + cbData;

	for( pb = pbData; pb < pbMax; pb++ )
		{
		BYTE b = *pb;
		
		*pbPrint++ = mpbb[b >> 4];
		*pbPrint++ = mpbb[b & 0x0f];
		*pbPrint++ = ' ';
		
//		if ( isalnum( *pb ) )
//			PrintF2( "%c", *pb );
//		else
//			PrintF2( "%x", *pb );
		}

#if 0
	if ( cbData > 8 )
		{
		*pbPrint++ = '.';
		*pbPrint++ = '.';
		
//		PrintF2( ".." );

		pb = pbMax - 3;
		}

	for( ; pb < pbMax; pb++ )
		{
		BYTE b = *pb;
		
		*pbPrint++ = mpbb[b >> 4];
		*pbPrint++ = mpbb[b & 0x0f];
		*pbPrint++ = ' ';
		
//		if ( isalnum( *pb ) )
//			PrintF2( "%c", *pb );
//		else
//			PrintF2( "%x", *pb );
		}
#endif
	*pbPrint='\0';
	PrintF2( "%s", rgbPrint );
	}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\lv.c ===
#include "config.h"

#include <stdlib.h>
#include <string.h>
#include <stddef.h>

#include "daedef.h"
#include "pib.h"
#include "fdb.h"
#include "fcb.h"
#include "util.h"
#include "page.h"
#include "ssib.h"
#include "fucb.h"
#include "stapi.h"
#include "nver.h"
#include "node.h"
#include "dirapi.h"
#include "recint.h"
#include "recapi.h"

DeclAssertFile;					/* Declare file name for assert macros */

//#define XACT_REQUIRED
#define	semLV	semDBK
extern SEM __near semDBK;

ERR ErrRECIModifyField( FUCB *pfucb, FID fid, ULONG itagSequence, LINE *plineField );

LOCAL ERR ErrRECISetLid( FUCB *pfucb, FID fid, ULONG itagSequence, LID lid );
LOCAL ERR ErrRECSeparateLV( FUCB *pfucb, LINE *plineField, LID *plid, FUCB **ppfucb );
LOCAL ERR ErrRECAOSeparateLV( FUCB *pfucb, LID *plid, LINE *plineField, JET_GRBIT grbit, LONG ibLongValue, ULONG ulMax );
LOCAL ERR ErrRECAOIntrinsicLV(
	FUCB		*pfucb,
	FID			fid,
	ULONG		itagSequence,
	LINE		*pline,
	LINE		*plineField,
	JET_GRBIT	grbit,
	LONG		ibLongValue );
LOCAL ERR ErrRECAffectSeparateLV( FUCB *pfucb, LID *plid, ULONG fLVAffect );

/***BEGIN MACHINE DEPENDANT***/
#define	KeyFromLong( rgb, ul )				 			\
	{											  		\
	ULONG	ulT = ul;							  		\
	rgb[3] = (BYTE)(ulT & 0xff);				  		\
	ulT >>= 8;									  		\
	rgb[2] = (BYTE)(ulT & 0xff);	 	   				\
	ulT >>= 8;									  		\
	rgb[1] = (BYTE)(ulT & 0xff);				  		\
	ulT >>= 8;									  		\
	rgb[0] = (BYTE)(ulT);						  		\
	}

#define	LongFromKey( ul, rgb )							\
	{											  		\
	ul = (BYTE)rgb[0];			   						\
	ul <<= 8;									  		\
	ul |= (BYTE)rgb[1];			   						\
	ul <<= 8;									  		\
	ul |= (BYTE)rgb[2];			   						\
	ul <<= 8;									  		\
	ul |= (BYTE)rgb[3];			   						\
	}
/***END MACHINE DEPENDANT***/


//+api
//	ErrRECSetLongField
//	========================================================================
//	ErrRECSetLongField
//
//	Description.
//
//	PARAMETERS	pfucb
//	 			fid
//	 			itagSequence
//	 			plineField
//	 			grbit
//
//	RETURNS		Error code, one of:
//	 			JET_errSuccess
//
//-
ERR ErrRECSetLongField(
	FUCB 			*pfucb,
	FID 			fid,
	ULONG			itagSequence,
	LINE			*plineField,
	JET_GRBIT		grbit,
	LONG			ibLongValue,
	ULONG			ulMax )
	{
	ERR				err = JET_errSuccess;
	LINE			line;
	ULONG	  		cb;
	BYTE			fSLong;
	LID				lid;
	BOOL			fInitSeparate = fFalse;

	Assert( pfucb != pfucbNil );
	Assert( pfucb->u.pfcb != pfcbNil );
	Assert( pfucb->u.pfcb->pfdb != pfdbNil );

	grbit &= (JET_bitSetAppendLV|JET_bitSetOverwriteLV|JET_bitSetSizeLV|JET_bitSetZeroLength);
	Assert( grbit == 0 ||
		grbit == JET_bitSetAppendLV ||
		grbit == JET_bitSetOverwriteLV ||
		grbit == JET_bitSetSizeLV ||
		grbit == JET_bitSetZeroLength ||
		grbit == (JET_bitSetSizeLV | JET_bitSetZeroLength) );

	/*	flag cursor as having set a long value
	/**/
	FUCBSetUpdateSeparateLV( pfucb );

#ifdef XACT_REQUIRED
	if ( pfucb->ppib->level == 0 )
		return JET_errNotInTransaction;
#else
	CallR( ErrDIRBeginTransaction( pfucb->ppib ) );
#endif

	/*	sequence == 0 means that new field instance is to be set.
	/**/
	if ( itagSequence == 0 )
		{
		line.cb = 0;
		}
	else
		{
		Call( ErrRECExtractField( (FDB *)pfucb->u.pfcb->pfdb,
			&pfucb->lineWorkBuf,
			&fid,
			pNil,
			itagSequence,
			&line ) );
		}

//	UNDONE:	find better solution to the problem of visible
//			long value changes before update at level 0.

	/*	if grbit is new field or set size to 0
	/*	then null-field then NULL field.
	/**/
	if ( ( ( grbit & (JET_bitSetAppendLV|JET_bitSetOverwriteLV|JET_bitSetSizeLV) ) == 0 ) ||
		( grbit & JET_bitSetSizeLV ) && plineField->cb == 0 )
		{
		//	UNDONE:	confirm this block of code replaced by deferred
		//			removal of defunct long values at update time,
		//			when update assured, or rollback in a transaction
		//			possible.  May check for JET Blue client update of
		//			long values at transaction level 0 as cause of
		//			restricted clean up.
#if 0
		if ( line.cb >= sizeof(LV) )
			{
			Assert( err == wrnRECLongField );
			if ( pfucb->ppib->level > 1 )
				{
				if ( FFieldIsSLong( line.pb ) )
					{
					Assert( line.cb == sizeof(LV) );
					lid = LidOfLV( line.pb );
					err = ErrRECResetSLongValue( pfucb, &lid );
					if ( err != JET_errSuccess )
						goto HandleError;
					}
				}
			else
				{
				Assert( fFalse );
				}
			}
#endif

	 	/* if new length is zero and setting to NULL, set column to
		/*	NULL, commit and return.
		/**/
		if ( plineField->cb == 0 && ( grbit & JET_bitSetZeroLength ) == 0 )
			{
			Call( ErrRECIModifyField( pfucb, fid, itagSequence, NULL ) );
			Call( ErrDIRCommitTransaction( pfucb->ppib ) );
			goto HandleError;
			}

		line.cb = 0;
	 	line.pb = NULL;
		}

	/*	if intrinsic long field exists, if combined size exceeds
	/*	intrinsic long field maximum, separate long field and call
	/*	ErrRECSetSeparateLV
	/*	else call ErrRECSetIntrinsicLV
	/**/

	/*	set size requirement for existing long field
	/*	note that if fSLong is true then cb is length
	/*	of LV
	/**/
	if ( line.cb == 0 )
		{
		fSLong = fFalse;
		cb = offsetof(LV, rgb);
		}
	else
		{
		fSLong = FFieldIsSLong( line.pb );
		cb = line.cb;
		}

	/*	long field flag included in length thereby limiting
	/*	intrinsic long field to cbLVIntrinsicMost - sizeof(BYTE)
	/**/
	if ( fSLong )
		{
		Assert( line.cb == sizeof(LV) );
		Assert( ((LV *)line.pb)->fSeparated );
		lid = LidOfLV( line.pb );
		Call( ErrRECAOSeparateLV( pfucb, &lid, plineField, grbit, ibLongValue, ulMax ) );
		if ( err == JET_wrnCopyLongValue )
			{
			Call( ErrRECISetLid( pfucb, fid, itagSequence, lid ) );
			}
		}
	else if ( ( !(grbit & JET_bitSetOverwriteLV) && (cb + plineField->cb > cbLVIntrinsicMost) ) ||
		( (grbit & JET_bitSetOverwriteLV) && (offsetof(LV, rgb) + ibLongValue + plineField->cb > cbLVIntrinsicMost) ) )
		{
		fInitSeparate = fTrue;
		}
	else
		{
		err = ErrRECAOIntrinsicLV( pfucb, fid, itagSequence, &line, plineField, grbit, ibLongValue );

		if ( err == JET_errRecordTooBig )
			{
			fInitSeparate = fTrue;
			}
		else
			{
			Call( err );
			}
		}

	if ( fInitSeparate )
		{
		if ( line.cb > 0 )
			{
			Assert( !( FFieldIsSLong( line.pb ) ) );
			line.pb += offsetof(LV, rgb);
			line.cb -= offsetof(LV, rgb);
			}
		Call( ErrRECSeparateLV( pfucb, &line, &lid, NULL ) );
		Assert( err == JET_wrnCopyLongValue );
		Call( ErrRECISetLid( pfucb, fid, itagSequence, lid ) );
		Call( ErrRECAOSeparateLV( pfucb, &lid, plineField, grbit, ibLongValue, ulMax ) );
		Assert( err != JET_wrnCopyLongValue );
		}

	Call( ErrDIRCommitTransaction( pfucb->ppib ) );

HandleError:
	/*	if operation failed then rollback changes
	/**/
	if ( err < 0 )
		{
		CallS( ErrDIRRollback( pfucb->ppib ) );
		}
	return err;
	}


LOCAL ERR ErrRECISetLid( FUCB *pfucb, FID fid, ULONG itagSequence, LID lid )
	{
	ERR		err;
	LV		lv;
	LINE	line;

	/*	set field to separated long field id
	/**/
	lv.fSeparated = fSeparate;
	lv.lid = lid;
	line.pb = (BYTE *)&lv;
	line.cb = sizeof(LV);
	err = ErrRECIModifyField( pfucb, fid, itagSequence, &line );
	return err;
	}


/*	links tagged columid to already existing long value whose id is lid
/*	used only for compact
/*	also increments ref count of long value
/*	done inside a transaction
/**/
ERR ErrREClinkLid( JET_VTID tableid,
	JET_COLUMNID	ulFieldId,
	long			lid,
	unsigned long  	itagSequence )
	{
	ERR		err;
	FID		fid = (FID) ulFieldId;
	FUCB	*pfucb = (FUCB *) tableid;
	LINE	lineLV;
	LV		lvAdd;

	Assert( itagSequence > 0 );
	lvAdd.fSeparated = fTrue;
	lvAdd.lid = lid;
	lineLV.pb = (BYTE *) &lvAdd;
	lineLV.cb = sizeof(LV);

	/*	use it to modify field
	/**/
	CallR( ErrRECIModifyField( pfucb, fid, itagSequence, &lineLV ) );
	CallR( ErrDIRBeginTransaction( pfucb->ppib ) );
	Call( ErrRECReferenceLongValue( pfucb, &lid ) );
	Call( ErrDIRCommitTransaction( pfucb->ppib ) );

	return err;

HandleError:
	CallS( ErrDIRRollback( pfucb->ppib ) );
	return err;
	}


ERR ErrRECForceSeparatedLV( JET_VTID tableid, ULONG itagSequence )
	{
	ERR		err;
	FUCB	*pfucb = (FUCB *) tableid;
	LINE 	lineField;
	LID		lid;
	FID		fid = 0;
	ULONG	itagSeqT;
	
	/* extract fid and field for further operations
	/**/
	Assert( itagSequence != 0 );
	CallR( ErrRECExtractField( (FDB *)pfucb->u.pfcb->pfdb,
		&pfucb->lineWorkBuf,
		&fid,
		&itagSeqT,
		itagSequence,
		&lineField ) );

	CallR( ErrDIRBeginTransaction( pfucb->ppib ) );

	Call( ErrRECSeparateLV( pfucb, &lineField, &lid, NULL ) );
	Assert( err == JET_wrnCopyLongValue );
	Call( ErrRECISetLid( pfucb, fid, itagSeqT, lid ) );
	Call( ErrDIRCommitTransaction( pfucb->ppib ) );
	return JET_errSuccess;

HandleError:
	CallS( ErrDIRRollback( pfucb->ppib ) );
	return err;
	}


LOCAL ERR ErrRECIBurstSeparateLV( FUCB *pfucbTable, FUCB *pfucbSrc, LID *plid )
	{
	ERR		err;
	FUCB   	*pfucb = pfucbNil;
	KEY		key;
	BYTE   	rgbKey[sizeof(ULONG)];
	DIB		dib;
	LID		lid;
	LONG   	lOffset;
	LVROOT	lvroot;
	BF		*pbf = pbfNil;
	BYTE	*rgb;
	LINE   	line;

	Call( ErrBFAllocTempBuffer( &pbf ) );
	rgb = (BYTE *)pbf->ppage;

	/*	initialize key buffer
	/**/
	key.pb = rgbKey;
	dib.fFlags = fDIRNull;

	/*	get long value length
	/**/
	Call( ErrDIRGet( pfucbSrc ) );
	Assert( pfucbSrc->lineData.cb == sizeof(lvroot) );
	memcpy( &lvroot, pfucbSrc->lineData.pb, sizeof(lvroot) );

	/*	move source cursor to first chunk
	/**/
	Assert( dib.fFlags == fDIRNull );
	dib.pos = posFirst;
	Call( ErrDIRDown( pfucbSrc, &dib ) );
	Assert( err == JET_errSuccess );

	/*	make separate long value root, and insert first chunk
	/**/
	Call( ErrDIRGet( pfucbSrc ) );

	/*	remember length of first chunk.
	/**/
	lOffset = pfucbSrc->lineData.cb;

	line.pb = rgb;
	line.cb = pfucbSrc->lineData.cb;
	memcpy( line.pb, pfucbSrc->lineData.pb, line.cb );
	Call( ErrRECSeparateLV( pfucbTable, &line, &lid, &pfucb ) );

	/*	check for additional long value chunks
	/**/
	err = ErrDIRNext( pfucbSrc, &dib );
	if ( err >= 0 )
		{
		/*	initial key variable
		/**/
		key.pb = rgbKey;
		key.cb = sizeof(ULONG);

		/*	copy remaining chunks of long value.
		/**/
		do
			{
			Call( ErrDIRGet( pfucbSrc ) );
			line.pb = rgb;
			line.cb = pfucbSrc->lineData.cb;
			memcpy( line.pb, pfucbSrc->lineData.pb, line.cb );
			KeyFromLong( rgbKey, lOffset );
			/*	keys should be equivalent
			/**/
			Assert( rgbKey[0] == pfucbSrc->keyNode.pb[0] );
			Assert( rgbKey[1] == pfucbSrc->keyNode.pb[1] );
			Assert( rgbKey[2] == pfucbSrc->keyNode.pb[2] );
			Assert( rgbKey[3] == pfucbSrc->keyNode.pb[3] );
			err = ErrDIRInsert( pfucb, &line, &key, fDIRVersion | fDIRBackToFather );
			lOffset += (LONG)pfucbSrc->lineData.cb;
			Assert( err != JET_errKeyDuplicate );
			Call( err );
			err = ErrDIRNext( pfucbSrc, &dib );
			}
		while ( err >= 0 );
		}

	if ( err != JET_errNoCurrentRecord )
		goto HandleError;

	Assert( err == JET_errNoCurrentRecord );
	Assert( lOffset == (long)lvroot.ulSize );

	/*	move pfucbSrc to root of long value copy.
	/**/
	DIRUp( pfucbSrc, 1 );

	/*	decrement long value reference count.
	/**/
	Call( ErrDIRDelta( pfucbSrc, -1, fDIRVersion ) );

	/*	move cursor to new long value
	/**/
	DIRUp( pfucbSrc, 1 );
	key.pb = (BYTE *)&lid;
	key.cb = sizeof(LID);
	Assert( dib.fFlags == fDIRNull );
	dib.pos = posDown;
	dib.pkey = &key;
	Call( ErrDIRDown( pfucbSrc, &dib ) );
	Assert( err == JET_errSuccess );

	/*	update lvroot.ulSize to correct long value size.
	/**/
	line.cb = sizeof(LVROOT);
	line.pb = (BYTE *)&lvroot;
	Assert( lvroot.ulReference >= 1 );
	lvroot.ulReference = 1;
	Call( ErrDIRGet( pfucbSrc ) );
	Assert( pfucbSrc->lineData.cb == sizeof(lvroot) );
	Call( ErrDIRReplace( pfucbSrc, &line, fDIRVersion ) );
	Call( ErrDIRGet( pfucbSrc ) );

	/*	set warning and new long value id for return.
	/**/
	err = JET_wrnCopyLongValue;
	*plid = lid;
HandleError:
	if ( pfucb != pfucbNil )
		DIRClose( pfucb );
	if ( pbf != pbfNil )
		BFSFree( pbf );
	return err;
	}


//+api
//	ErrRECAOSeparateLV
//	========================================================================
//	ErrRECAOSeparateLV
//
//	Appends, overwrites and sets length of separate long value data.
//
//	PARAMETERS		pfucb
// 					pline
// 					plineField
//
//	RETURNS		Error code, one of:
//					JET_errSuccess
//
//	SEE ALSO
//-
	LOCAL ERR
ErrRECAOSeparateLV( FUCB *pfucb, LID *plid, LINE *plineField, JET_GRBIT grbit, LONG ibLongValue, ULONG ulMax )
	{
	ERR			err = JET_errSuccess;
	ERR			wrn = JET_errSuccess;
	FUCB	   	*pfucbT;
	DIB			dib;
	KEY			key;
	BYTE	   	rgbKey[sizeof(ULONG)];
	BYTE	   	*pbMax;
	BYTE	   	*pb;
	LINE	   	line;
	LONG	   	lOffset;
	LONG	   	lOffsetChunk;
	ULONG	   	ulSize;
	ULONG	   	ulNewSize;
	BF		   	*pbf = pbfNil;
	LVROOT		lvroot;

	Assert( pfucb != pfucbNil );
	Assert( pfucb->u.pfcb != pfcbNil );
	Assert( pfucb->u.pfcb->pfdb != pfdbNil );
	Assert( pfucb->ppib->level > 0 );
	Assert( ( grbit & JET_bitSetSizeLV ) || plineField->cb == 0 || plineField->pb != NULL );

	dib.fFlags = fDIRNull;

	/*	open cursor on LONG directory
	/*	seek to this field instance
	/*	find current field size
	/*	add new field segment in chunks no larger than max chunk size
	/**/
	CallR( ErrDIROpen( pfucb->ppib, pfucb->u.pfcb, 0, &pfucbT ) );
	FUCBSetIndex( pfucbT );

	/*	move down to LONG from FDP root
	/**/
	DIRGotoLongRoot( pfucbT );

	/*	move to long field instance
	/**/
	key.pb = (BYTE *)plid;
	key.cb = sizeof(LID);
	Assert( dib.fFlags == fDIRNull );
	dib.pos = posDown;
	dib.pkey = &key;
	err = ErrDIRDown( pfucbT, &dib );
	Assert( err != JET_errRecordNotFound );
	Call( err );
	Assert( err == JET_errSuccess );

	/*	burst long value if other references.
	/*	NOTE:	MUST ENSURE that no I/O occurs between this operation
	/*	and the operation to write lock the node if the
	/*	reference count is 1.
	/**/
	Call( ErrDIRGet( pfucbT ) );
	Assert( pfucbT->lineData.cb == sizeof(LVROOT) );
	memcpy( &lvroot, pfucbT->lineData.pb, sizeof(LVROOT) );
	Assert( lvroot.ulReference > 0 );

	/*	get offset of last byte from long value size
	/**/
	ulSize = lvroot.ulSize;

	if ( ibLongValue < 0 ||
		( ( grbit & JET_bitSetOverwriteLV ) && (ULONG)ibLongValue >= ulSize ) )
		{
		err = JET_errColumnNoChunk;
		goto HandleError;
		}

	if ( lvroot.ulReference > 1 || FDIRDelta( pfucbT, BmOfPfucb( pfucbT ) ) )
		{
		Call( ErrRECIBurstSeparateLV( pfucb, pfucbT, plid ) );
		Assert( err == JET_wrnCopyLongValue );
		wrn = err;
		Assert( pfucbT->lineData.cb == sizeof(LVROOT) );
		memcpy( &lvroot, pfucbT->lineData.pb, sizeof(LVROOT) );
		}

	Assert( ulSize == lvroot.ulSize );
	Assert( lvroot.ulReference == 1 );

	/*	determine new long field size
	/**/
	if ( grbit & JET_bitSetSizeLV )
		ulNewSize = (ULONG)plineField->cb;
	else if ( grbit & JET_bitSetOverwriteLV )
		ulNewSize = max( (ULONG)ibLongValue + plineField->cb, ulSize );
	else
		ulNewSize = ulSize + plineField->cb;

	/*	check for field too long
	/**/
	if ( ulMax > 0 && ulNewSize > ulMax )
		{
		err = JET_errColumnTooBig;
		goto HandleError;
		}

	/*	replace long value size with new size
	/**/
	Assert( lvroot.ulReference > 0 );
	lvroot.ulSize = ulNewSize;
	line.cb = sizeof(LVROOT);
	line.pb = (BYTE *)&lvroot;
	Call( ErrDIRReplace( pfucbT, &line, fDIRVersion ) );

	/*	allocate buffer for partial overwrite caching.
	/**/
	Call( ErrBFAllocTempBuffer( &pbf ) );

	/*	SET SIZE
	/**/
	/*	if truncating long value then delete chunks.  If truncation
	/*	lands in chunk, then save retained information for subsequent
	/*	append.
	/**/
	if ( grbit & JET_bitSetSizeLV )
		{
		/*	filter out do nothing set size
		/**/
		if ( plineField->cb == ulSize )
			{
			Assert( err == JET_errSuccess );
			goto HandleError;
			}

		/*	TRUNCATE long value
		/**/
		if ( plineField->cb < ulSize )
			{
			/*	seek to offset to begin deleting
			/**/
			lOffset = (LONG)plineField->cb;
			KeyFromLong( rgbKey, lOffset );
			key.pb = rgbKey;
			key.cb = sizeof(LONG);
			Assert( dib.fFlags == fDIRNull );
			Assert( dib.pos == posDown );
			dib.pkey = &key;
			err = ErrDIRDown( pfucbT, &dib );
			Assert( err != JET_errRecordNotFound );
			Call( err );
			Assert( err == JET_errSuccess ||
				err == wrnNDFoundLess ||
				err == wrnNDFoundGreater );
			if ( err != JET_errSuccess )
				Call( ErrDIRPrev( pfucbT, &dib ) );
			Call( ErrDIRGet( pfucbT ) );

			/*	get offset of last byte in current chunk
			/**/
			LongFromKey( lOffsetChunk, pfucbT->keyNode.pb );

			/*	replace current chunk with remaining data, or delete if
			/*	no remaining data.
			/**/
			Assert( lOffset >= lOffsetChunk );
			line.cb = lOffset - lOffsetChunk;
			if ( line.cb > 0 )
				{
				line.pb = (BYTE *)pbf->ppage;
				memcpy( line.pb, pfucbT->lineData.pb, line.cb );
				Call( ErrDIRReplace( pfucbT, &line, fDIRVersion ) );
				}
			else
				{
				Call( ErrDIRDelete( pfucbT, fDIRVersion ) );
				}

			/*	delete forward chunks
			/**/
			forever
				{
				err = ErrDIRNext( pfucbT, &dib );
				if ( err < 0 )
					{
					if ( err == JET_errNoCurrentRecord )
						break;
					goto HandleError;
					}
				Call( ErrDIRDelete( pfucbT, fDIRVersion ) );
				}

			/*	move to long value root for subsequent append
			/**/
			DIRUp( pfucbT, 1 );
			}
		else
			{
			/*	EXTEND long value with chunks of 0s
			/**/
			Assert( plineField->cb > ulSize );
			memset( (BYTE *)pbf->ppage, '\0', cbChunkMost );

			/*	try to extend last chunk.
			/**/
			Assert( dib.fFlags == fDIRNull );
			dib.pos = posLast;

			/*	long value chunk tree may be empty
			/**/
			err = ErrDIRDown( pfucbT, &dib );
			if ( err < 0 && err != JET_errRecordNotFound )
				goto HandleError;
			if ( err != JET_errRecordNotFound )
				{
				Call( ErrDIRGet( pfucbT ) );

				if ( pfucbT->lineData.cb < cbChunkMost )
					{
					line.cb = min( (LONG)plineField->cb - ulSize,
								(ULONG)cbChunkMost - (ULONG)pfucbT->lineData.cb );
					memcpy( (BYTE *)pbf->ppage, pfucbT->lineData.pb, pfucbT->lineData.cb );
					memset( (BYTE *)pbf->ppage +  pfucbT->lineData.cb, '\0', line.cb );

					ulSize += line.cb;

					line.cb += pfucbT->lineData.cb;
					line.pb = (BYTE *)pbf->ppage;
					Call( ErrDIRReplace( pfucbT, &line, fDIRVersion ) );
					}

				DIRUp( pfucbT, 1 );
				}

			/*	extend long value with chunks of 0s
			/**/
			memset( (BYTE *)pbf->ppage, '\0', cbChunkMost );

			/*	set lOffset to offset of next chunk
			/**/
			lOffset = (LONG)ulSize;

			/*	insert chunks to append lOffset - plineField + 1 bytes.
			/**/
			while( (LONG)plineField->cb > lOffset )
				{
				KeyFromLong( rgbKey, lOffset );
				key.pb = rgbKey;
				key.cb = sizeof(ULONG);
				line.cb = min( (LONG)plineField->cb - lOffset, cbChunkMost );
				(BYTE const *)line.pb = (BYTE *)pbf->ppage;
				err = ErrDIRInsert( pfucbT, &line, &key, fDIRVersion | fDIRBackToFather );
				Assert( err != JET_errKeyDuplicate );
				Call( err );

				lOffset += line.cb;
				}
			}
		err = JET_errSuccess;
		goto HandleError;
		}

	/*	OVERWRITE, APPEND
	/**/

	/*	prepare for overwrite and append
	/**/
	pbMax = plineField->pb + plineField->cb;
	pb	= plineField->pb;

	/*	overwrite long value
	/**/
	if ( grbit & JET_bitSetOverwriteLV )
		{
		/*	seek to offset to begin overwritting.
		/**/
		KeyFromLong( rgbKey, ibLongValue );
		key.pb = rgbKey;
		key.cb = sizeof(LONG);
		Assert( dib.fFlags == fDIRNull );
		dib.pos = posDown;
		dib.pkey = &key;
		err = ErrDIRDown( pfucbT, &dib );
		Assert( err != JET_errRecordNotFound );
		Call( err );
		Assert( err == JET_errSuccess ||
			err == wrnNDFoundLess ||
			err == wrnNDFoundGreater );
		if ( err != JET_errSuccess )
			Call( ErrDIRPrev( pfucbT, &dib ) );
		Call( ErrDIRGet( pfucbT ) );

		LongFromKey( lOffsetChunk, pfucbT->keyNode.pb );
		Assert( ibLongValue <= lOffsetChunk + (LONG)pfucbT->lineData.cb );

		/*	overwrite portions of and complete chunks to effect overwrite
		/**/
		while( err != JET_errNoCurrentRecord && pb < pbMax )
			{
			LONG	cbChunk;
			LONG	ibChunk;
			LONG	cb;
			LONG	ib;

			Call( ErrDIRGet( pfucbT ) );

			/*	get size and offset of current chunk.
			/**/
			cbChunk = (LONG)pfucbT->lineData.cb;
			LongFromKey( ibChunk, pfucbT->keyNode.pb );

			Assert( ibLongValue >= ibChunk && ibLongValue < ibChunk + cbChunk );
			ib = ibLongValue - ibChunk;
			cb = min( cbChunk - ib, (LONG)(pbMax - pb) );

			/*	special case overwrite of whole chunk
			/**/
			if ( cb == cbChunk )
				{
				line.cb = cb;
				line.pb = pb;
				}
			else
				{
				/*	copy chunk into copy buffer.  Overwrite and replace
				/*	node with copy buffer.
				/**/
				memcpy( (BYTE *)pbf->ppage, pfucbT->lineData.pb, cbChunk );
				memcpy( (BYTE *)pbf->ppage + ib, pb, cb );
				line.cb = cbChunk;
				line.pb = (BYTE *)pbf->ppage;
				}

			Call( ErrDIRReplace( pfucbT, &line, fDIRVersion ) );
			pb += cb;
			ibLongValue += cb;
			err = ErrDIRNext( pfucbT, &dib );
			if ( err < 0 && err != JET_errNoCurrentRecord )
				goto HandleError;
			}

		/*	move to long value root for subsequent append
		/**/
		DIRUp( pfucbT, 1 );
		}

	/*	coallesce new long value data with existing.
	/**/
	if ( pb < pbMax )
		{
		Assert( dib.fFlags == fDIRNull );
		dib.pos = posLast;
		/*	long value chunk tree may be empty.
		/**/
		err = ErrDIRDown( pfucbT, &dib );
		if ( err < 0 && err != JET_errRecordNotFound )
			goto HandleError;
		if ( err != JET_errRecordNotFound )
			{
			Call( ErrDIRGet( pfucbT ) );

			if ( pfucbT->lineData.cb < cbChunkMost )
				{
				line.cb = (ULONG)min( (ULONG_PTR)pbMax - (ULONG_PTR)pb, (ULONG_PTR)cbChunkMost - (ULONG_PTR)pfucbT->lineData.cb );
				memcpy( (BYTE *)pbf->ppage, pfucbT->lineData.pb, pfucbT->lineData.cb );
				memcpy( (BYTE *)pbf->ppage + pfucbT->lineData.cb, pb, line.cb );

				pb += line.cb;
				ulSize += line.cb;

				line.cb += pfucbT->lineData.cb;
				line.pb = (BYTE *)pbf->ppage;
				Call( ErrDIRReplace( pfucbT, &line, fDIRVersion ) );
				}

			DIRUp( pfucbT, 1 );
			}
		}

	/*	append remaining long value data
	/**/
	if ( pb < pbMax )
		{
		while( pb < pbMax )
			{
			KeyFromLong( rgbKey, ulSize );
			key.pb = rgbKey;
			key.cb = sizeof( ULONG );
			line.cb = min( (ULONG)(pbMax - pb), cbChunkMost );
			(BYTE const *)line.pb = pb;
 			err = ErrDIRInsert( pfucbT, &line, &key, fDIRVersion | fDIRBackToFather );
 			Assert( err != JET_errKeyDuplicate );
			Call( err );

			ulSize += line.cb;
			pb += line.cb;
			}
		}

	/*	err may be negative from called routine.
	/**/
	err = JET_errSuccess;

HandleError:
	if ( pbf != pbfNil )
		{
		BFSFree( pbf );
		}
	/* discard temporary FUCB
	/**/
	DIRClose( pfucbT );

	/*	return warning if no failure
	/**/
	err = err < 0 ? err : wrn;
	return err;
	}


//+api
//	ErrRECAOIntrinsicLV
//	========================================================================
//	ErrRECAOIntrinsicLV(
//
//	Description.
//
//	PARAMETERS	pfucb
//				fid
//				itagSequence
//				plineColumn
//				plineAOS
//				ibLongValue			if 0, then flags append.  If > 0
//									then overwrite at offset given.
//
//	RETURNS		Error code, one of:
//				JET_errSuccess
//
//-
	LOCAL ERR
ErrRECAOIntrinsicLV(
	FUCB		*pfucb,
	FID	  		fid,
	ULONG		itagSequence,
	LINE		*plineColumn,
	LINE		*plineAOS,
	JET_GRBIT	grbit,
	LONG		ibLongValue )
	{
	ERR			err = JET_errSuccess;
	BYTE		*rgb;
	LINE		line;
	BYTE		fFlag;
	LINE		lineColumn;

	Assert( pfucb != pfucbNil );
	Assert( plineColumn );
	Assert( plineAOS );

	/*	allocate working buffer
	/**/
	rgb = SAlloc( cbLVIntrinsicMost );
	if ( rgb == NULL )
		{
		return JET_errOutOfMemory;
		}

	/*	if field NULL, prepend fFlag
	/**/
	if ( plineColumn->cb == 0 )
		{
		fFlag = fIntrinsic;
		lineColumn.pb = (BYTE *)&fFlag,
		lineColumn.cb = sizeof(fFlag);
		}
	else
		{
		lineColumn.pb = plineColumn->pb;
		lineColumn.cb = plineColumn->cb;
		}

	/*	append new data to previous data and intrinsic long field
	/*	flag
	/**/
	Assert( ( !( grbit & JET_bitSetOverwriteLV ) && lineColumn.cb + plineAOS->cb <= cbLVIntrinsicMost )
		|| ( ( grbit & JET_bitSetOverwriteLV ) && ibLongValue + plineAOS->cb <= cbLVIntrinsicMost ) );
	Assert( lineColumn.cb > 0 && lineColumn.pb != NULL );

	/*	copy intrinsic long value into buffer, and set line to default.
	/**/
	memcpy( rgb, lineColumn.pb, lineColumn.cb );
	line.pb = rgb;

	/*	effect overwrite or append, depending on value of ibLongValue
	/**/
	if ( grbit & JET_bitSetOverwriteLV )
		{
		/*	adjust offset to be relative to LV structure data start
		/**/
		ibLongValue += offsetof(LV, rgb);
		/*	return error if overwriting byte not present in field
		/**/
		if ( ibLongValue >= (LONG)lineColumn.cb )
			{
			err = JET_errColumnNoChunk;
			goto HandleError;
			}
		Assert( ibLongValue + plineAOS->cb <= cbLVIntrinsicMost );
		Assert( plineAOS->pb != NULL );
		memcpy( rgb + ibLongValue, plineAOS->pb, plineAOS->cb );
		line.cb = max( lineColumn.cb, ibLongValue + plineAOS->cb );
		}
	else if ( grbit & JET_bitSetSizeLV )
		{
		/*	if extending then set 0 in extended area
		/*	else truncate long value.
		/**/
		memcpy( rgb, lineColumn.pb, lineColumn.cb );
		plineAOS->cb += offsetof(LV, rgb);
		if ( plineAOS->cb > lineColumn.cb )
			{
	  		memset( rgb + lineColumn.cb, '\0', plineAOS->cb - lineColumn.cb );
			}
		line.cb = plineAOS->cb;
		}
	else
		{
		/*	appending to a field or resetting a field and setting new data.
		/*	Be sure to handle case where long value is being NULLed.
		/**/
//		if ( plineAOS->cb > 0 )
//			{
			memcpy( rgb + lineColumn.cb, plineAOS->pb, plineAOS->cb );
			line.cb = lineColumn.cb + plineAOS->cb;
//			}
//		else
//			{
//			line.cb = 0;
//			}
		}

	Call( ErrRECIModifyField( pfucb, fid, itagSequence, &line ) );

HandleError:
	SFree( rgb );
	return err;
	}


//+api
//	ErrRECRetrieveSLongField
//	========================================================================
//	ErrRECRetrieveSLongField(
//
//	Description.
//
//	PARAMETERS	pfucb
//				pline
//				ibGraphic
//				plineField
//
//	RETURNS		Error code, one of:
//				JET_errSuccess
//
//-
ERR ErrRECRetrieveSLongField(
	FUCB	*pfucb,
	LID		lid,
	ULONG	ibGraphic,
	BYTE	*pb,
	ULONG	cbMax,
	ULONG	*pcbActual )
	{
	ERR		err = JET_errSuccess;
	FUCB	*pfucbT;
	DIB		dib;
	BYTE	*pbMax;
	KEY		key;
	BYTE	rgbKey[sizeof(ULONG)];
	ULONG	cb;
	ULONG	ulRetrieved;
	ULONG	ulActual;
	ULONG	lOffset;
	ULONG	ib;

	Assert( pfucb != pfucbNil );
	Assert( pfucb->u.pfcb != pfcbNil );
	Assert( pfucb->u.pfcb->pfdb != pfdbNil );

	dib.fFlags = fDIRNull;

	/*	open cursor on LONG, seek to long field instance
	/*	seek to ibGraphic
	/*	copy data from long field instance segments as
	/*	necessary
	/**/
	CallR( ErrDIROpen( pfucb->ppib, pfucb->u.pfcb, 0, &pfucbT ) );
	FUCBSetIndex( pfucbT );

	/*	move down to LONG from FDP root
	/**/
	DIRGotoLongRoot( pfucbT );

	/*	move to long field instance
	/**/
	Assert( dib.fFlags == fDIRNull );
	dib.pos = posDown;
	key.pb = (BYTE *)&lid;
	key.cb = sizeof( ULONG );
	dib.pkey = &key;
	err = ErrDIRDown( pfucbT, &dib );
	Assert( err != JET_errRecordNotFound );
	Call( err );
	Assert( err == JET_errSuccess );

	/*	get cbActual
	/**/
	Call( ErrDIRGet( pfucbT ) );
	Assert( pfucbT->lineData.cb == sizeof(LVROOT) );
	ulActual = ( (LVROOT *)pfucbT->lineData.pb )->ulSize;

	/*	set return value cbActual
	/**/
	if ( ibGraphic >= ulActual )
		{
		*pcbActual = 0;
		err = JET_errSuccess;
		goto HandleError;
		}
	else
		{
		*pcbActual = ulActual - ibGraphic;
		}

	/*	move to ibGraphic in long field
	/**/
	KeyFromLong( rgbKey, ibGraphic );
	key.pb = rgbKey;
	key.cb = sizeof( ULONG );
	Assert( dib.fFlags == fDIRNull );
	Assert( dib.pos == posDown );
	dib.pkey = &key;
	err = ErrDIRDown( pfucbT, &dib );
	/*	if long value has no data, then return JET_errSuccess
	/*	with no data retrieved.
	/**/
	if ( err == JET_errRecordNotFound )
		{
		*pcbActual = 0;
		err = JET_errSuccess;
		goto HandleError;
		}
	Assert( err != JET_errRecordNotFound );
	Call( err );
	Assert( err == JET_errSuccess ||
		err == wrnNDFoundLess ||
		err == wrnNDFoundGreater );
	if ( err != JET_errSuccess )
		Call( ErrDIRPrev( pfucbT, &dib ) );
	Call( ErrDIRGet( pfucbT ) );

	LongFromKey( lOffset, pfucbT->keyNode.pb );
	Assert( lOffset + pfucbT->lineData.cb - ibGraphic <= cbChunkMost );
	cb =  min( lOffset + pfucbT->lineData.cb - ibGraphic, cbMax );

	/*	set pbMax
	/**/
	pbMax = pb + cbMax;

	/*	offset in chunk
	/**/
	ib = ibGraphic - lOffset;
	memcpy( pb, pfucbT->lineData.pb + ib, cb );
	pb += cb;
	ulRetrieved = cb;

	while ( pb < pbMax )
		{
		err = ErrDIRNext( pfucbT, &dib );
		if ( err < 0 )
			{
			if ( err == JET_errNoCurrentRecord )
				break;
			goto HandleError;
			}
		Call( ErrDIRGet( pfucbT ) );
  		cb = pfucbT->lineData.cb;
		if ( pb + cb > pbMax )
			{
			Assert( pbMax - pb <= cbChunkMost );
			cb = (ULONG)(pbMax - pb);
			}

		memcpy( pb, pfucbT->lineData.pb, cb );
		pb += cb;
		ulRetrieved = cb;
		}

	/*	set return value
	/**/
	err = JET_errSuccess;

HandleError:
	/*	discard temporary FUCB
	/**/
	DIRClose( pfucbT );
	return err;
	}


//+api
//	ErrRECSeparateLV
//	========================================================================
//	ErrRECSeparateLV
//
//	Converts intrinsic long field into separated long field.
//	Intrinsic long field constraint of length less than cbLVIntrinsicMost bytes
//	means that breakup is unnecessary.  Long field may also be
//	null.
//
//	PARAMETERS	pfucb
//				fid
//				itagSequence
//				plineField
//				pul
//
//	RETURNS		Error code, one of:
//				JET_errSuccess
//-
LOCAL ERR ErrRECSeparateLV( FUCB *pfucb, LINE *plineField, LID *plid, FUCB **ppfucb )
	{
	ERR		err = JET_errSuccess;
	FUCB 	*pfucbT;
	ULONG 	ulLongId;
	BYTE  	rgbKey[sizeof(ULONG)];
	KEY		key;
	LINE  	line;
	LVROOT	lvroot;

	Assert( pfucb != pfucbNil );
	Assert( pfucb->u.pfcb != pfcbNil );
	Assert( pfucb->u.pfcb->pfdb != pfdbNil );
	Assert( pfucb->ppib->level > 0 );

	/*	get long field id
	/**/
	SgSemRequest( semLV );
	//	UNDONE:	use interlocked increment
	ulLongId = pfucb->u.pfcb->ulLongIdMax++;
	Assert( pfucb->u.pfcb->ulLongIdMax != 0 );
	SgSemRelease( semLV );

	/*	convert long column id to long column key.  Set return
	/*	long id since buffer will be overwritten.
	/**/
	KeyFromLong( rgbKey, ulLongId );
	*plid = *((LID *)rgbKey);

	/*	add long field node in long filed directory
	/**/
	CallR( ErrDIROpen( pfucb->ppib, pfucb->u.pfcb, 0, &pfucbT ) );
	FUCBSetIndex( pfucbT );

	/*	move down to LONG from FDP root
	/**/
	DIRGotoLongRoot( pfucbT );

	/*	add long field id with long value size
	/**/
	lvroot.ulReference = 1;
	lvroot.ulSize = plineField->cb;
	line.pb = (BYTE *)&lvroot;
	line.cb = sizeof(LVROOT);
	key.pb = (BYTE *)rgbKey;
	key.cb = sizeof(LID);
	Call( ErrDIRInsert( pfucbT, &line, &key, fDIRVersion ) );

	/*	if lineField is non NULL, add lineField
	/**/
	if ( plineField->cb > 0 )
		{
		Assert( plineField->pb != NULL );
		KeyFromLong( rgbKey, 0 );
		Assert( key.pb == (BYTE *)rgbKey );
		Assert( key.cb == sizeof(LID) );
		err = ErrDIRInsert( pfucbT, plineField, &key, fDIRVersion | fDIRBackToFather );
		Assert( err != JET_errKeyDuplicate );
		Call( err );
		}

	err = JET_wrnCopyLongValue;

HandleError:
	/* discard temporary FUCB, or return to caller if ppfucb is not NULL.
	/**/
	if ( err < 0 || ppfucb == NULL )
		{
		DIRClose( pfucbT );
		}
	else
		{
		*ppfucb = pfucbT;
		}
	return err;
	}


//+api
//	ErrRECAffectSeparateLV
//	========================================================================
//	ErrRECAffectSeparateLV( FUCB *pfucb, ULONG *plid, ULONG fLV )
//
//	Affect long value.
//
//	PARAMETERS		pfucb			Cursor
//		  			lid				Long field id
//		  			fLVAjust  		flag indicating action to be taken
//
//	RETURNS		Error code, one of:
//		  		JET_errSuccess
//-
LOCAL ERR ErrRECAffectSeparateLV( FUCB *pfucb, LID *plid, ULONG fLV )
	{
	ERR		err = JET_errSuccess;
	FUCB	*pfucbT;
	DIB		dib;
	KEY		key;
	LVROOT	lvroot;

	Assert( pfucb != pfucbNil );
	Assert( pfucb->u.pfcb != pfcbNil );
	Assert( pfucb->u.pfcb->pfdb != pfdbNil );
	Assert( pfucb->ppib->level > 0 );

	dib.fFlags = fDIRNull;

	/*	open cursor on LONG directory
	/*	seek to this field instance
	/*	find current field size
	/*	add new field segment in chunks no larger than max chunk size
	/**/
	CallR( ErrDIROpen( pfucb->ppib, pfucb->u.pfcb, 0, &pfucbT ) );
	FUCBSetIndex( pfucbT );

	/*	move down to LONG from FDP root
	/**/
	DIRGotoLongRoot( pfucbT );

	/*	move to long field instance
	/**/
	Assert( dib.fFlags == fDIRNull );
	dib.pos = posDown;
	key.pb = (BYTE *)plid;
	key.cb = sizeof(LID);
	dib.pkey = &key;
	err = ErrDIRDown( pfucbT, &dib );
	Assert( err != JET_errRecordNotFound );
	Call( err );
	Assert( err == JET_errSuccess );

	switch ( fLV )
		{
		case fLVDereference:
			{
			Call( ErrDIRGet( pfucbT ) );
			Assert( pfucbT->lineData.cb == sizeof(LVROOT) );
			memcpy( &lvroot, pfucbT->lineData.pb, sizeof(LVROOT) );
			Assert( lvroot.ulReference > 0 );
			if ( lvroot.ulReference == 1 && !FDIRDelta( pfucbT, BmOfPfucb( pfucbT ) ) )
				{
				/*	delete long field tree
				/**/
				err = ErrDIRDelete( pfucbT, fDIRVersion );
				}
			else
				{
				/*	decrement long value reference count.
				/**/
				Call( ErrDIRDelta( pfucbT, -1, fDIRVersion ) );
				}
			break;
			}
		default:
			{
			Assert( fLV == fLVReference );
			Call( ErrDIRGet( pfucbT ) );
			Assert( pfucbT->lineData.cb == sizeof(LVROOT) );
			memcpy( &lvroot, pfucbT->lineData.pb, sizeof(LVROOT) );
			Assert( lvroot.ulReference > 0 );

			/*	long value may already be in the process of being
			/*	modified for a specific record.  This can only
			/*	occur if the long value reference is 1.  If the reference
			/*	is 1, then check the root for any version, committed
			/*	or uncommitted.  If version found, then burst copy of
			/*	old version for caller record.
			/**/
			if ( lvroot.ulReference == 1 )
				{
				if ( !( FDIRMostRecent( pfucbT ) ) )
					{
					Call( ErrRECIBurstSeparateLV( pfucb, pfucbT, plid ) );
					break;
					}
				}
			/*	increment long value reference count.
			/**/
			Call( ErrDIRDelta( pfucbT, 1, fDIRVersion ) );
			break;
			}
		}
HandleError:
	/* discard temporary FUCB
	/**/
	DIRClose( pfucbT );
	return err;
	}


//+api
//	ErrRECAffectLongFields
//	========================================================================
//	ErrRECAffectLongFields( FUCB *pfucb, LINE *plineRecord, INT fFlag )
//
//	Affect all long fields in a record.
//
//	PARAMETERS	pfucb		  	cursor on record being deleted
//				plineRecord		copy or line record buffer
//				fFlag		  	operation to perform
//
//	RETURNS		Error code, one of:
//				JET_errSuccess
//-

/*	return fTrue if lid found in record
/**/
INLINE BOOL FLVFoundInRecord( FUCB *pfucb, LINE *pline, LID lid )
	{
	ERR		err;
	FID		fid;
	ULONG  	itag;
	ULONG  	itagT;
	LINE   	lineField;
	LID		lidT;

	Assert( pfucb != pfucbNil );
	Assert( pfucb->u.pfcb != pfcbNil );
	Assert( pfucb->u.pfcb->pfdb != pfdbNil );

	/*	walk record tagged columns.  Operate on any column is of type
	/*	long text or long binary.
	/**/
	itag = 1;
	forever
		{
		fid = 0;
		err = ErrRECExtractField( (FDB *)pfucb->u.pfcb->pfdb,
			pline,
			&fid,
			&itagT,
			itag,
			&lineField );
		Assert( err >= 0 );
		if ( err == JET_wrnColumnNull )
			break;
		if ( err == wrnRECLongField )
			{
			Assert( FTaggedFid( fid ) &&
				( pfucb->u.pfcb->pfdb->pfieldTagged[fid  - fidTaggedLeast].coltyp == JET_coltypLongText ||
				pfucb->u.pfcb->pfdb->pfieldTagged[fid  - fidTaggedLeast].coltyp == JET_coltypLongBinary ) );

			if ( FFieldIsSLong( lineField.pb ) )
				{
				Assert( lineField.cb == sizeof(LV) );
				lidT = LidOfLV( lineField.pb );
				if ( lidT == lid )
					return fTrue;
				}
			}

		itag++;
		}

	return fFalse;
	}


ERR ErrRECAffectLongFields( FUCB *pfucb, LINE *plineRecord, INT fFlag )
	{
	ERR		err;
	FID		fid;
	ULONG  	itagSequenceFound;
	ULONG  	itagSequence;
	LINE   	lineField;
	LID		lid;

	Assert( pfucb != pfucbNil );
	Assert( pfucb->u.pfcb != pfcbNil );
	Assert( pfucb->u.pfcb->pfdb != pfdbNil );

#ifdef XACT_REQUIRED
	if ( pfucb->ppib->level == 0 )
		return JET_errNotInTransaction;
#else
	CallR( ErrDIRBeginTransaction( pfucb->ppib ) );
#endif

	/*	walk record tagged columns.  Operate on any column is of type
	/*	long text or long binary.
	/**/
	itagSequence = 1;
	forever
		{
		fid = 0;
		if ( plineRecord != NULL )
			{
			err = ErrRECExtractField( (FDB *)pfucb->u.pfcb->pfdb,
				plineRecord,
				&fid,
				&itagSequenceFound,
				itagSequence,
				&lineField );
			}
		else
			{
			Call( ErrDIRGet( pfucb ) );
			err = ErrRECExtractField( (FDB *)pfucb->u.pfcb->pfdb,
				&pfucb->lineData,
				&fid,
				&itagSequenceFound,
				itagSequence,
				&lineField );
			}
		Assert( err >= 0 );
		if ( err == JET_wrnColumnNull )
			break;
		if ( err == wrnRECLongField )
			{
			Assert( FTaggedFid( fid ) &&
				( pfucb->u.pfcb->pfdb->pfieldTagged[fid  - fidTaggedLeast].coltyp == JET_coltypLongText ||
				pfucb->u.pfcb->pfdb->pfieldTagged[fid  - fidTaggedLeast].coltyp == JET_coltypLongBinary ) );

			switch ( fFlag )
				{
				case fSeparateAll:
					{
					/*	note that we do not separate those long values that are so
					/*	short that they take even less space in a record than a full
					/*	LV structure for separated long value would.
					/**/
 	  				if ( lineField.cb > sizeof(LV) )
						{
						Assert( !( FFieldIsSLong( lineField.pb ) ) );
	 					lineField.pb += offsetof(LV, rgb);
	  					lineField.cb -= offsetof(LV, rgb);
  						Call( ErrRECSeparateLV( pfucb, &lineField, &lid, NULL ) );
						Assert( err == JET_wrnCopyLongValue );
						Call( ErrRECISetLid( pfucb, fid, itagSequenceFound, lid ) );
						}
					break;
					}
				case fReference:
					{
	  				if ( FFieldIsSLong( lineField.pb ) )
						{
						Assert( lineField.cb == sizeof(LV) );
						lid = LidOfLV( lineField.pb );
						Call( ErrRECReferenceLongValue( pfucb, &lid ) );
						}
					break;
					}
				case fDereference:
					{
	  				if ( FFieldIsSLong( lineField.pb ) )
						{
			 			Assert( lineField.cb == sizeof(LV) );
						lid = LidOfLV( lineField.pb );
						Call( ErrRECDereferenceLongValue( pfucb, &lid ) );
						Assert( err != JET_wrnCopyLongValue );
						}
					break;
					}
				case fDereferenceRemoved:
					{
					/*	find all long vales in record that were
					/*	removed when new long value set over
					/*	long value.  Note that we a new long value
					/*	is set over another long value, the long
					/*	value is not deleted, since the update may
					/*	be cancelled.  Instead, the long value is
					/*	deleted at update.  Since inserts cannot have
					/*	set over long values, there is no need to
					/*	call this function for insert operations.
					/**/
					if ( FFieldIsSLong( lineField.pb ) )
						{
						Assert( lineField.cb == sizeof(LV) );
						lid = LidOfLV( lineField.pb );
						Assert( FFUCBReplacePrepared( pfucb ) );
						if ( !FLVFoundInRecord( pfucb, &pfucb->lineWorkBuf, lid ) )
							{
							/*	if long value in record not found in
							/*	copy buffer then it must be set over
							/*	and it is dereference.
							/**/
							Call( ErrRECDereferenceLongValue( pfucb, &lid ) );
							Assert( err != JET_wrnCopyLongValue );
							}
						}
					break;
					}
				default:
					{
					Assert( fFlag == fDereferenceAdded );

					/*	find all long vales created in copy buffer
					/*	and not in record and delete them.
					/**/
					if ( FFieldIsSLong( lineField.pb ) )
						{
						Assert( lineField.cb == sizeof(LV) );
						lid = LidOfLV( lineField.pb );
						Assert( FFUCBInsertPrepared( pfucb ) ||
							FFUCBReplacePrepared( pfucb ) );
						/*	refresh record cache
						/**/
						Call( ErrDIRGet( pfucb ) );
						if ( FFUCBInsertPrepared( pfucb ) ||
							!FLVFoundInRecord( pfucb, &pfucb->lineData, lid ) )
							{
							/*	if insert prepared then all found long
							/*	values are new, else if long value is new,
							/*	if it exists in copy buffer only.
							/**/
							Call( ErrRECDereferenceLongValue( pfucb, &lid ) );
							Assert( err != JET_wrnCopyLongValue );
							}
						}
					break;
					}

				/*	if called operation has caused new long value
				/*	to be created, then record new long value id
				/*	in record.
				/**/
				if ( err == JET_wrnCopyLongValue )
					{
					Call( ErrRECISetLid( pfucb, fid, itagSequenceFound, lid ) );
					}
  				}
			}
		itagSequence++;
		}
	Call( ErrDIRCommitTransaction( pfucb->ppib ) );
	return JET_errSuccess;
HandleError:
	CallS( ErrDIRRollback( pfucb->ppib ) );
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\mcm.c ===
#include "config.h"

#include "daedef.h"
#include "pib.h"
#include "ssib.h"
#include "util.h"
#include "page.h"
#include "fcb.h"
#include "fucb.h"
#include "stapi.h"
#include "dirapi.h"

#define	FPMValidItag( itag )	( itag >= itagFOP && itag < ctagMax )
			
#define	FMCMRequired( pfucb, pfucbT )							\
	( FFUCBFull( pfucbT ) && pfucbT->dbid == pfucb->dbid && !( FFUCBSort( pfucbT ) ) )

LOCAL VOID MCMMapItag( PGNO pgnoSplit, CSR *pcsr, CSR *pcsrUpdated, BYTE *mpitag );

DeclAssertFile;					/* Declare file name for assert macros */


VOID MCMRightHorizontalPageSplit( FUCB *pfucb, PGNO pgnoSplit, PGNO pgnoRight, INT ibSonSplit, BYTE *mpitag )
	{
	FUCB 	*pfucbT;

	if ( ibSonSplit == ibSonNull )
		{
		pfucb->pcsr->pgno = pgnoRight;
		pfucb->pcsr->ibSon = 0;
		return;
		}
	
	for (	pfucbT = pfucb->u.pfcb->pfucb;
		pfucbT != pfucbNil;
		pfucbT = pfucbT->pfucbNextInstance )
		{
		CSR		*pcsrT;

		if ( !( FMCMRequired( pfucb, pfucbT ) ) )
			continue;

		Assert( pfucbT->ppib == pfucb->ppib );
		Assert( !( FFUCBSort( pfucbT ) ) );
		Assert( PcsrCurrent( pfucbT ) != pcsrNil );

		for (	pcsrT = PcsrCurrent( pfucbT );
			pcsrT != pcsrNil;
			pcsrT = pcsrT->pcsrPath )
			{
			if ( pcsrT->pgno == pgnoSplit &&
				pcsrT->itagFather == itagFOP &&
				pcsrT->ibSon >= ibSonSplit )
				{
				Assert( pcsrT->csrstat == csrstatOnCurNode ||
					pcsrT->csrstat == csrstatBeforeCurNode ||
					pcsrT->csrstat == csrstatAfterCurNode );

				pcsrT->pgno = pgnoRight;
				pcsrT->ibSon -= ibSonSplit;
				Assert( pcsrT->itagFather == itagFOP );

				if ( pcsrT->itag != itagNil && pcsrT->itag != itagNull )
					{
					Assert( FPMValidItag( pcsrT->itag ) );
					/*	node may not have been moved if CSR was before
					/*	current node and node was first son or if CSR was
					/*	after node and node was last son.
					/**/
					Assert( mpitag[pcsrT->itag] != itagFOP ||
						( pcsrT->csrstat == csrstatBeforeCurNode && pcsrT->ibSon == 0 ) ||
						( pcsrT->csrstat == csrstatAfterCurNode ) );
					if ( mpitag[pcsrT->itag] != itagFOP )
						pcsrT->itag = mpitag[pcsrT->itag];
					}

				/*	adjust lower level CSRs that may be on subtrees
				/*	in this page.  Their ibSon is correct but their itags
				/*	must be corrected 'top down'.
				/**/
				if ( PcsrCurrent( pfucbT ) != pcsrT )
					MCMMapItag( pgnoSplit, PcsrCurrent( pfucbT ), pcsrT, mpitag );

				break;
				}
			}
		}

	return;
	}


VOID MCMLeftHorizontalPageSplit( FUCB *pfucb, PGNO pgnoSplit, PGNO pgnoNew, INT ibSonSplit, BYTE *mpitag )
	{
	FUCB 	*pfucbT;

	if ( ibSonSplit == ibSonNull )
		{
		pfucb->pcsr->pgno = pgnoNew;
		pfucb->pcsr->ibSon = 0;
		return;
		}
	
	for (	pfucbT = pfucb->u.pfcb->pfucb;
			pfucbT != pfucbNil;
			pfucbT = pfucbT->pfucbNextInstance )
		{
		CSR		*pcsrT;

		if ( !( FMCMRequired( pfucb, pfucbT ) ) )
			continue;

		Assert( pfucbT->ppib == pfucb->ppib );
		Assert( !( FFUCBSort( pfucbT ) ) );
		Assert( PcsrCurrent( pfucbT ) != pcsrNil );

		for (	pcsrT = PcsrCurrent( pfucbT );
	  		pcsrT != pcsrNil;
	  		pcsrT = pcsrT->pcsrPath )
			{
			if ( pcsrT->pgno == pgnoSplit && pcsrT->itagFather == itagFOP )
				{
				Assert( pcsrT->csrstat == csrstatOnCurNode ||
					pcsrT->csrstat == csrstatBeforeCurNode ||
					pcsrT->csrstat == csrstatAfterCurNode );

				if ( pcsrT->ibSon <= ibSonSplit )
					{
			   	pcsrT->pgno = pgnoNew;
					Assert( pcsrT->itagFather == itagFOP );

					if ( pcsrT->itag != itagNil && pcsrT->itag != itagNull )
						{
						Assert( FPMValidItag( pcsrT->itag ) );
						/*	node may not have been moved if CSR was before
						/*	current node and node was first son or if CSR was
						/*	after node and node was last son.
						/**/
						Assert( mpitag[pcsrT->itag] != itagFOP ||
							( pcsrT->csrstat == csrstatBeforeCurNode && pcsrT->ibSon == 0 ) ||
							( pcsrT->csrstat == csrstatAfterCurNode ) );
						if ( mpitag[pcsrT->itag] != itagFOP )
							pcsrT->itag = mpitag[pcsrT->itag];
						}

					/*	Adjust lower level CSRs that may be on subtrees
					/*	in this page.  Their ibSon is correct but their itags
					/*	must be corrected 'top down'.
					/**/
					if ( PcsrCurrent( pfucbT ) != pcsrT )
						MCMMapItag( pgnoSplit, PcsrCurrent( pfucbT ), pcsrT, mpitag );

					break;
					}
				else
					{
					/*	adjust ibSons for those sons moved to new page
					/**/
			   	pcsrT->ibSon -= ( ibSonSplit + 1 );
					Assert( pcsrT->itagFather == itagFOP );
					break;
					}
				}
			}
		}

	return;
	}


/*	MCMBurstIntrinsic corrects CSRs for burst intrinsic page pointer.
/**/
VOID MCMBurstIntrinsic( FUCB *pfucb,
	PGNO	pgnoFather,
	INT	itagFather,
	PGNO	pgnoNew,
	INT	itagNew )
	{
	FUCB 	*pfucbT;

	for (	pfucbT = pfucb->u.pfcb->pfucb;
		pfucbT != pfucbNil;
		pfucbT = pfucbT->pfucbNextInstance )
		{
		CSR		*pcsrT;

		if ( !( FMCMRequired( pfucb, pfucbT ) ) )
			continue;

		/*	only one session can split one domain at a time.
		/**/
		Assert( pfucbT->ppib == pfucb->ppib );
		Assert( !( FFUCBSort( pfucbT ) ) );
		Assert( PcsrCurrent( pfucbT ) != pcsrNil );

		/*	initialize pcsrT
		/**/
		pcsrT = PcsrCurrent( pfucbT );

		for (	; pcsrT != pcsrNil; pcsrT = pcsrT->pcsrPath )
			{
			Assert( pcsrT->csrstat == csrstatBeforeFirst ||
				pcsrT->csrstat == csrstatOnCurNode ||
				pcsrT->csrstat == csrstatOnFDPNode ||
				pcsrT->csrstat == csrstatBeforeCurNode ||
				pcsrT->csrstat == csrstatAfterCurNode ||
				pcsrT->csrstat == csrstatOnDataRoot );

			if ( pcsrT->pgno == pgnoFather && pcsrT->itagFather == itagFather )
				{
				pcsrT->pgno = pgnoNew;
				pcsrT->itag = itagNew;
				pcsrT->itagFather = itagFOP;
				pcsrT->csrstat = csrstatOnCurNode;

				break;
				}
			}
		}

	return;
	}


/*	MCM cursors to inserted page pointer nodes.  Must also handle case where
/*	original page pointer node was intrinsic.
/**/
VOID MCMInsertPagePointer( FUCB *pfucb, PGNO pgnoFather, INT itagFather )
	{
	FUCB 	*pfucbT;
	INT	cbSon;
	BYTE	*rgbSon;

	/*	cache father son table.
	/**/
	Assert( FReadAccessPage( pfucb, pgnoFather ) );
	NDGet( pfucb, itagFather );
	cbSon = CbNDSon( pfucb->ssib.line.pb );
	rgbSon = PbNDSon( pfucb->ssib.line.pb );

	for (	pfucbT = pfucb->u.pfcb->pfucb;
		pfucbT != pfucbNil;
		pfucbT = pfucbT->pfucbNextInstance )
		{
		CSR		*pcsrT;
		/*	pgno from lower level CSR to be used to determine which
		/*	page pointer to locate on.
		/**/
		PGNO		pgno = 0;

		if ( !( FMCMRequired( pfucb, pfucbT ) ) )
			continue;

		/*	only one session can split one domain at a time.
		/**/
		Assert( pfucbT->ppib == pfucb->ppib );
		Assert( !( FFUCBSort( pfucbT ) ) );
		Assert( PcsrCurrent( pfucbT ) != pcsrNil );

		/*	initialize pcsrT and set pgno to current page if
		/*	this page is pointed to by a page pointer node.
		/**/
		pcsrT = PcsrCurrent( pfucbT );
		if ( pcsrT->itagFather == itagFOP )
			pgno = pcsrT->pgno;

		for (	; pcsrT != pcsrNil; pcsrT = pcsrT->pcsrPath )
			{
			Assert( pcsrT->csrstat == csrstatBeforeFirst ||
				pcsrT->csrstat == csrstatOnCurNode ||
				pcsrT->csrstat == csrstatOnFDPNode ||
				pcsrT->csrstat == csrstatBeforeCurNode ||
				pcsrT->csrstat == csrstatAfterCurNode ||
				pcsrT->csrstat == csrstatOnDataRoot );

			if ( pcsrT->pgno == pgnoFather && pcsrT->itagFather == itagFather )
				{
				INT	ibSon;

				/*	find pgno in father page pointer sons and set itag
				/*	and ibSon when found.
				/**/
				for ( ibSon = 0;; ibSon++ )
					{
					Assert( ibSon < cbSon );
					NDGet( pfucb, rgbSon[ibSon] );
					if ( pgno == *((PGNO UNALIGNED *)PbNDData( pfucb->ssib.line.pb)) )
						{
						pcsrT->ibSon = ibSon;
						pcsrT->itag = rgbSon[ibSon];
						break;
						}
					}
				break;
				}

			/*	set pgno to current page if
			/*	this page is pointed to by a page pointer node.
			/**/
			if ( pcsrT->itagFather == itagFOP )
				pgno = pcsrT->pgno;
			}
		}

	return;
	}


VOID MCMVerticalPageSplit(
	FUCB	*pfucb,
	BYTE	*mpitag,
	PGNO	pgnoSplit,
	INT	itagSplit,
	PGNO	pgnoNew,
	SPLIT	*psplit )
	{
	CSR	*pcsr = PcsrCurrent( pfucb );
	FUCB	*pfucbT;

	for ( pfucbT = pfucb->u.pfcb->pfucb; pfucbT != pfucbNil; pfucbT = pfucbT->pfucbNextInstance )
		{
		CSR *pcsrT;
		CSR *pcsrNew;
		CSR *pcsrRoot;

		if ( !( FMCMRequired( pfucb, pfucbT ) ) )
			continue;

		Assert( pfucbT->ppib == pfucb->ppib );
		Assert( !( FFUCBSort( pfucbT ) ) );

		for (	pcsrT = PcsrCurrent( pfucbT );
			pcsrT != pcsrNil;
			pcsrT = pcsrT->pcsrPath )
			{
			if ( pcsrT->pgno != pgnoSplit )
				continue;

			if ( pcsrT->itag == itagSplit )
				break;

			Assert( pcsrT->csrstat == csrstatBeforeFirst ||
				pcsrT->csrstat == csrstatOnCurNode ||
				pcsrT->csrstat == csrstatOnFDPNode ||
				pcsrT->csrstat == csrstatBeforeCurNode ||
				pcsrT->csrstat == csrstatAfterCurNode ||
				pcsrT->csrstat == csrstatAfterLast ||
				pcsrT->csrstat == csrstatOnDataRoot );

			Assert( pcsrT->itagFather == itagNull ||
				pcsrT->itagFather == itagNil ||
				pcsrT->itag != itagNull ||
				pcsrT->itag != itagNil );

			Assert( pcsrT->itagFather != itagNil );
			if ( pcsrT->itagFather == itagNull )
				{
				Assert( pcsrT->itag != itagNil && pcsrT->itag != itagNull );
				Assert( FPMValidItag( pcsrT->itag ) );
				if ( mpitag[pcsrT->itag] == 0  )
					{
					continue;
					}
				}
			else
				{
				if ( pcsrT->itagFather != itagSplit )
					continue;
				}

			pcsrRoot = pcsrT;

			/*	insert CSR for new B-Tree level, for cursors
			/**/
			Assert( FFUCBFull( pfucbT ) );
			if ( pcsrT->pcsrPath != pcsrNil )
				{
				Assert(psplit->ipcsrMac > 0);
				psplit->ipcsrMac--;
				Assert( psplit->rgpcsr[psplit->ipcsrMac] );
				pcsrNew = psplit->rgpcsr[psplit->ipcsrMac];
#ifdef DEBUG
				psplit->rgpcsr[psplit->ipcsrMac] = pcsrNil;
#endif

				/*	the new csr will be the intrinsic page pointer
				/**/
				pcsrNew->csrstat = csrstatOnCurNode;
				pcsrNew->pgno = pcsrT->pgno;
				pcsrNew->itag = itagNil;
				pcsrNew->ibSon = 0;
				Assert( pcsrNew->item = sridNull );
				CSRSetInvisible( pcsrNew );
				Assert( pcsrNew->isrid = isridNull );
				pcsrNew->itagFather = ( pcsrT->itagFather == itagNull ) ?
					pfucbT->u.pfcb->itagRoot : pcsrT->itagFather;
				pcsrNew->pcsrPath = pcsrT->pcsrPath;

				pcsrT->pcsrPath = pcsrNew;
				}

			pcsrT->pgno = pgnoNew;

			/*	update itag if valid.  The itag may be itagNil if
			/*	inserting first son of father node.
			/**/
			if ( pcsrT->itag != itagNil && pcsrT->itag != itagNull )
				{
				Assert( mpitag[pcsrT->itag] != itagFOP ||
					( pcsrT->csrstat == csrstatBeforeCurNode && pcsrT->ibSon == 0 ) ||
					( pcsrT->csrstat == csrstatAfterCurNode ) );
				if ( mpitag[pcsrT->itag] != itagFOP )
					pcsrT->itag = mpitag[pcsrT->itag];
				}
			/*	isrid unchanged
			/**/
			/*	father is FOP
			/**/
			pcsrT->itagFather = itagFOP;
			/*	ibSon unchanged
			/**/

			/*	adjust lower level CSRs that may be on subtrees
			/*	in this page.  Their ibSon is correct but their itags
			/*	must be corrected 'top down'.
			/**/
			if ( PcsrCurrent( pfucbT ) != pcsrT )
				MCMMapItag( pgnoSplit, PcsrCurrent( pfucbT ), pcsrRoot, mpitag );
			
			break;
			}
		}

	return;
	}


VOID MCMDoubleVerticalPageSplit(
	FUCB	*pfucb,
	BYTE	*mpitag,
	PGNO	pgnoSplit,
	INT  	itagSplit,
	INT	ibSonDivision,
	PGNO	pgnoNew,
	PGNO	pgnoNew2,
	PGNO	pgnoNew3,
	SPLIT	*psplit ) 	
	{
	CSR	*pcsr = PcsrCurrent( pfucb );
	FUCB	*pfucbT;

	for ( pfucbT = pfucb->u.pfcb->pfucb; pfucbT != pfucbNil; pfucbT = pfucbT->pfucbNextInstance )
		{
		CSR	*pcsrT;
		CSR	*pcsrNew;
		CSR	*pcsrRoot;

		if ( !( FMCMRequired( pfucb, pfucbT ) ) )
			continue;

		Assert( pfucbT->ppib == pfucb->ppib );
		Assert( !( FFUCBSort( pfucbT ) ) );

		for (	pcsrT = PcsrCurrent( pfucbT );
			pcsrT != pcsrNil;
			pcsrT = pcsrT->pcsrPath )
			{
			if ( pcsrT->pgno != pgnoSplit )
				continue;

			Assert( pcsrT->csrstat == csrstatBeforeFirst ||
				pcsrT->csrstat == csrstatOnCurNode ||
				pcsrT->csrstat == csrstatOnFDPNode ||
				pcsrT->csrstat == csrstatBeforeCurNode ||
				pcsrT->csrstat == csrstatAfterCurNode ||
				pcsrT->csrstat == csrstatAfterLast ||
				pcsrT->csrstat == csrstatOnDataRoot );

			if ( pcsrT->itag == itagSplit )
				break;

			Assert( pcsrT->itagFather == itagNull ||
				pcsrT->itagFather == itagNil ||
				pcsrT->itag != itagNull ||
				pcsrT->itag != itagNil );

			Assert( pcsrT->itagFather != itagNil );
			if ( pcsrT->itagFather == itagNull )
				{
				Assert( pcsrT->itag != itagNil && pcsrT->itag != itagNull );
				if ( mpitag[pcsrT->itag] == 0  )
					{
					continue;
					}
				}
			else
				{
				if ( pcsrT->itagFather != itagSplit )
					continue;
				}

			pcsrRoot = pcsrT;

			/*	insert CSR for new B-Tree level, for cursors
			/**/
			Assert( FFUCBFull( pfucbT ) );
			if ( pcsrT->pcsrPath != pcsrNil )
				{
				/*	insert CSR for intrinsic page pointer node
				/**/
				Assert( psplit->ipcsrMac > 0 );
				psplit->ipcsrMac--;
				Assert( psplit->rgpcsr[psplit->ipcsrMac] );
				pcsrNew = psplit->rgpcsr[psplit->ipcsrMac];
#ifdef DEBUG
				psplit->rgpcsr[psplit->ipcsrMac] = pcsrNil;
#endif

				/*	the new csr will be son of the root
				/**/
				pcsrNew->csrstat = csrstatOnCurNode;
				pcsrNew->pgno = pgnoSplit;
				pcsrNew->itag = itagNil;
				Assert( pcsrNew->item == sridNull );
				CSRSetInvisible( pcsrNew );
				Assert( pcsrNew->isrid == isridNull );
				pcsrNew->itagFather = itagSplit;
				pcsrNew->ibSon = 0;
				pcsrNew->pcsrPath = pcsrT->pcsrPath;

				pcsrT->pcsrPath = pcsrNew;


				/*	insert CSR for intermediate page
				/**/
				Assert(psplit->ipcsrMac > 0);
				psplit->ipcsrMac--;
				Assert( psplit->rgpcsr[psplit->ipcsrMac] );
				pcsrNew = psplit->rgpcsr[psplit->ipcsrMac];
#ifdef DEBUG
				psplit->rgpcsr[psplit->ipcsrMac] = pcsrNil;
#endif

				/*	the new csr will be the new intermediat node
				/**/
				pcsrNew->csrstat = csrstatOnCurNode;
				pcsrNew->pgno = pgnoNew;
				if ( pcsrT->ibSon <= ibSonDivision )
					{
					pcsrNew->itag = itagDIRDVSplitL;
					pcsrNew->ibSon = 0;
					}
				else
					{
					pcsrNew->itag = itagDIRDVSplitR;
					pcsrNew->ibSon = 1;
					}
				Assert( pcsrNew->item == sridNull );
				CSRSetInvisible( pcsrNew );
				Assert( pcsrNew->isrid == isridNull );
				pcsrNew->itagFather = itagFOP;
				pcsrNew->pcsrPath = pcsrT->pcsrPath;

				pcsrT->pcsrPath = pcsrNew;
				}

			/*	update itag independant of which page node was
			/*	moved to via mpitag.  Only update itag if valid.
			/*	The itag may be itagNil if inserting first son
			/*	of father node.
			/**/
			if ( pcsrT->itag != itagNil && pcsrT->itag != itagNull )
				{
				Assert( mpitag[pcsrT->itag] != itagFOP ||
					( pcsrT->csrstat == csrstatBeforeCurNode && pcsrT->ibSon == 0 ) ||
					( pcsrT->csrstat == csrstatAfterCurNode ) );
				if ( mpitag[pcsrT->itag] != itagFOP )
					pcsrT->itag = mpitag[pcsrT->itag];
				}

			if ( pcsrT->ibSon <= ibSonDivision )
				{
				pcsrT->pgno = pgnoNew2;
				}
			else
				{
				pcsrT->pgno = pgnoNew3;
				pcsrT->ibSon = pcsrT->ibSon - ibSonDivision -1 ;
				}
				
			/*	father is FOP
			/**/
			pcsrT->itagFather = itagFOP;

			/*	adjust lower level CSRs that may be on subtrees
			/*	in this page.  Their ibSon is correct but their itags
			/*	must be corrected 'top down'.
			/**/
			if ( PcsrCurrent( pfucbT ) != pcsrT )
				MCMMapItag( pgnoSplit, PcsrCurrent( pfucbT ), pcsrRoot, mpitag );

			break;
			}
		}

	return;
	}


VOID MCMMapItag( PGNO pgnoSplit, CSR *pcsr, CSR *pcsrUpdated, BYTE *mpitag )
	{
	/*	assert trivial case is not called for
	/**/
	Assert( pcsr != pcsrUpdated );

	/*	advance pcsr to lowest level in vertical split new page
	/**/
	for ( ; pcsr->pgno != pgnoSplit && pcsr != pcsrUpdated; pcsr = pcsr->pcsrPath )
		;
	if ( pcsr == pcsrUpdated )
		return;
	for ( ; pcsr->pgno == pgnoSplit && pcsr != pcsrUpdated; pcsr = pcsr->pcsrPath )
		{
		pcsr->pgno = pcsrUpdated->pgno;
		Assert( pcsr->itagFather != itagNil );
		Assert( FPMValidItag( pcsr->itagFather ) );
	 	Assert( mpitag[pcsr->itagFather] != itagFOP );
		pcsr->itagFather = mpitag[pcsr->itagFather];
		Assert( pcsr->ibSon >= 0 );
		if ( pcsr->itag != itagNil && pcsr->itag != itagNull )
			{
			Assert( FPMValidItag( pcsr->itag ) );
			Assert( mpitag[pcsr->itag] != itagFOP );
			pcsr->itag = mpitag[pcsr->itag];
			}
		}

	return;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\node.c ===
#include "config.h"

#include <string.h>

#include "daedef.h"
#include "pib.h"
#include "util.h"
#include "fmp.h"
#include "ssib.h"
#include "page.h"
#include "fcb.h"
#include "fucb.h"
#include "stapi.h"
#include "dirapi.h"
#include "nver.h"
#include "node.h"
#include "logapi.h"
#include "log.h"
#include "bm.h"

DeclAssertFile;					/* Declare file name for assert macros */

#ifdef DEBUG
#define CHECK_LOG	1
#ifdef CHECK_LOG
		
#define	NDLGCheckPage( pfucb )						  	 	\
	{			 										   	\
	(VOID)ErrLGCheckPage( pfucb,						   	\
		pfucb->ssib.pbf->ppage->pghdr.cbFreeTotal,		   	\
		(SHORT)ItagPMQueryNextItag( &pfucb->ssib ) );    	\
	}

#else
#define NDLGCheckPage( pfucb )
#endif
#else
#define NDLGCheckPage( pfucb )
#endif

/*==========================================================
ErrNDNewPage

Initalizes a page to have a one line at itag 0, having no sons.

Inputs:	pgno									pgno of page
			pgnoFDP								pgnoFDP of page
			pgtyp									page type
			fVisible								flag indicating visibility of sons

Returns:	JET_errSuccess
			error from called routine

==========================================================*/
ERR ErrNDNewPage( FUCB *pfucb, PGNO pgno, PGNO pgnoFDP, PGTYP pgtyp, BOOL fVisibleSons )
	{
	ERR		err;
	SSIB	*pssib = &pfucb->ssib;
 	BYTE	rgb[2];
	LINE	line;

	/*	initialize new page to have all resources available and
	/*	no lines.
	/**/
	CallR( ErrBFNewPage( pfucb, pgno, pgtyp, pgnoFDP ) );
	PcsrCurrent( pfucb )->pgno = pgno;

	/*	new page is always dirty.
	/**/
	AssertBFDirty( pfucb->ssib.pbf );

	/*	insert FOP or FDP root node, with initial line.
	/**/
	rgb[0] = 0;
	if ( fVisibleSons )
		NDSetVisibleSons( rgb[0] );
	NDSetKeyLength( PbNDKeyCb( rgb ), 0 );
	Assert( rgb[1] == 0 );
	line.cb = 2;
	line.pb = rgb;
	CallS( ErrPMInsert( pssib, &line, 1 ) );
	Assert( pssib->itag == 0 );
	return err;
	}


VOID NDSeekSon( FUCB *pfucb, CSR *pcsr, KEY const *pkey, INT fFlags )
	{
	SSIB 	*pssib 			= &pfucb->ssib;
	PAGE 	*ppage 			= pssib->pbf->ppage;
	TAG		*rgbtag    		= ( TAG * ) ( ( BYTE * )ppage->rgtag );
	BYTE 	*pbNode			= ( BYTE * ) ( pssib->line.pb );
	BYTE 	*pbSonTable		= ( BYTE * ) pbNode + pbNode[1] + 2;

	BYTE 	*pitagStart		= pbSonTable + 1;
	BYTE 	*pitagEnd		= pbSonTable + *pbSonTable;
	BYTE 	*pitagMid;
	BYTE 	*stKeyRecord;
	INT		s;
	INT		sDiff;

	Assert( FReadAccessPage( pfucb, pcsr->pgno ) );
	AssertNDGet( pfucb, pcsr->itagFather );
	Assert( FNDSon( *pssib->line.pb ) );

	/*	seek son depending on replace or insert operation.
	/**/
	if ( !( fFlags & fDIRReplace ) )
		{
		while ( pitagEnd > pitagStart )
			{
			pitagMid = pitagStart + ( ( pitagEnd - pitagStart ) >> 1 );

			// skip flag byte
			stKeyRecord = ( BYTE * ) ppage + rgbtag[*pitagMid].ib + 1;

			sDiff = *stKeyRecord - pkey->cb;
			s = memcmp( stKeyRecord + 1, pkey->pb,
					sDiff < 0 ? ( INT )*stKeyRecord : pkey->cb );
			s = s ? s : sDiff;

			if ( s > 0 )
				{
				pitagEnd = pitagMid;
				}
			else
				{
				pitagStart = pitagMid + 1;
				}
			}
		}
	else
		{
		while ( pitagEnd > pitagStart )
			{
			pitagMid = pitagStart + ( ( pitagEnd - pitagStart ) >> 1 );

			// skip flag byte
			stKeyRecord = ( BYTE * )ppage + rgbtag[*pitagMid].ib + 1;

			sDiff = *stKeyRecord - pkey->cb;

			s = memcmp( stKeyRecord + 1, pkey->pb,
					sDiff < 0 ? ( INT )*stKeyRecord : pkey->cb );
			s = s ? s : sDiff;

			if ( s < 0 )
				{
				pitagStart = pitagMid + 1;
				}
			else
				{
				pitagEnd = pitagMid;
				}
			}
		}

	/*	get current node
	/**/
	pcsr->ibSon = (INT)(pitagEnd - ( pbSonTable + 1 ));
	pcsr->itag = *pitagEnd;
	NDGet( pfucb, pcsr->itag );
	return;
	}


VOID NDMoveFirstSon( FUCB *pfucb, CSR *pcsr )
	{
	SSIB   	*pssib = &pfucb->ssib;
	BYTE   	*pbSonTable;

	Assert( FReadAccessPage( pfucb, pcsr->pgno ) );
	AssertNDGet( pfucb, pcsr->itagFather );
	Assert( FNDNullSon( *pssib->line.pb ) || CbNDSon( pssib->line.pb ) != 0 );
	
	pcsr->ibSon = 0;
	pbSonTable = PbNDSonTable( pssib->line.pb );
	pcsr->itag = ( INT ) pbSonTable[ pcsr->ibSon + 1 ];
	NDGet( pfucb, pcsr->itag );
	}


VOID NDMoveLastSon( FUCB *pfucb, CSR *pcsr )
	{
	SSIB   	*pssib = &pfucb->ssib;
	BYTE   	*pbSonTable;

	Assert( FReadAccessPage( pfucb, pcsr->pgno ) );
	AssertNDGet( pfucb, pcsr->itagFather );

	pbSonTable = PbNDSonTable( pssib->line.pb );
	pcsr->ibSon = *pbSonTable - 1;
	pcsr->itag = ( INT ) pbSonTable[ pcsr->ibSon + 1 ];
	NDGet( pfucb, pcsr->itag );
	}


ERR ErrNDMoveSon( FUCB *pfucb, CSR *pcsr )
	{
	SSIB   	*pssib = &pfucb->ssib;
	BYTE   	*pbSonTable;

	Assert( FReadAccessPage( pfucb, pcsr->pgno ) );
	AssertNDGet( pfucb, pcsr->itagFather );

	if ( !( FNDSon( *pssib->line.pb ) ) )
		return errNDOutSonRange;

	pbSonTable = PbNDSonTable( pssib->line.pb );
	if ( pcsr->ibSon < 0 || pcsr->ibSon >= ( INT )*pbSonTable )
  		return errNDOutSonRange;

  	pcsr->itag = ( INT )pbSonTable[ pcsr->ibSon + 1 ];
	NDGet( pfucb, pcsr->itag );
	return JET_errSuccess;
	}


VOID NDGetNode( FUCB *pfucb )
	{
	SSIB   	*pssib 	= &pfucb->ssib;
	BYTE   	*pbNode	= pssib->line.pb;
	BYTE   	*pb		= pbNode + 1;
	INT		cb;

	/*	assert line currency.
	/**/
	Assert( FReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
	AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );

	pfucb->keyNode.cb = ( INT )*pb;
	pfucb->keyNode.pb = pb + 1;
	pb += *pb + 1;

	/* skip son
	/**/
	if ( FNDSon( *pbNode ) )
		{
		if ( FNDInvisibleSons( *pbNode ) && *pb == 1 )
			pb += sizeof( PGNO ) + 1;
		else
			pb += *pb + 1;
		}

	/*	skip back pointer
	/**/
	if ( FNDBackLink( *pbNode ) )
		pb += sizeof( SRID );

	/* get data
	/**/
	if ( ( cb = pssib->line.cb - (INT)( pb - pbNode ) ) == 0 )
		{
		pfucb->lineData.cb = 0;
		return;
		}

	pfucb->lineData.pb = pb;
	pfucb->lineData.cb = cb;
	return;
	}


#ifdef DEBUG
VOID AssertNDGetKey( FUCB *pfucb, INT itag )
	{
	SSIB   	*pssib = &pfucb->ssib;

	AssertNDGet( pfucb, itag );
	Assert( CbNDKey( pssib->line.pb ) == pfucb->keyNode.cb );
	Assert( CbNDKey( pssib->line.pb ) == 0 ||
		PbNDKey( pssib->line.pb ) == pfucb->keyNode.pb );
	return;
	}

VOID AssertNDGetNode( FUCB *pfucb, INT itag )
	{
	SSIB   	*pssib = &pfucb->ssib;

	AssertNDGet( pfucb, itag );
	Assert( CbNDKey( pssib->line.pb ) == pfucb->keyNode.cb );
	Assert( CbNDKey( pssib->line.pb ) == 0 ||
		PbNDKey( pssib->line.pb ) == pfucb->keyNode.pb );
	Assert( CbNDData( pssib->line.pb, pssib->line.cb ) == pfucb->lineData.cb );
	Assert( pfucb->lineData.cb == 0  ||
		PbNDData( pssib->line.pb ) == pfucb->lineData.pb );
	return;
	}
#endif


VOID NDGetBookmarkFromCSR( FUCB *pfucb, CSR *pcsr, SRID *psrid )
	{
	ERR		err = JET_errSuccess;

	Assert( FReadAccessPage( pfucb, pcsr->pgno ) );
	AssertNDGet( pfucb, pcsr->itag );

	NDIGetBookmarkFromCSR( pfucb, pcsr, psrid );
	return;
	}


LOCAL INLINE VOID NDInsertSon( FUCB *pfucb, CSR *pcsr )
	{
	SSIB	*pssib = &pfucb->ssib;
	BYTE	itag = ( BYTE ) pssib->itag;
	LINE	rgline[5];
	INT 	cline;
	BYTE	cbSon;
	BYTE	bNodeFlag;
	BYTE	rgbT[2];
	BYTE	*pb;
	UINT	cbCopied;

	/*	get father node
	/**/
	NDGet( pfucb, pcsr->itagFather );

	/*	assert father is not deleted
	/**/
	Assert( !( FNDDeleted( *pssib->line.pb ) ) );

	/*	insert the son into position indicated by pcsr->ibSon
	/*	skip key
	/**/
	pb = PbNDSonTable( pssib->line.pb );

	/*	copy up to son table
	/**/
	cbCopied = (UINT)(pb - pssib->line.pb);

	if ( FNDNullSon( *pssib->line.pb ) )
		{
		// copy the father node, create the the son table, insert it into
		// the son table

		// adjust the line pointer since we can not update the first
		// flag byte directly
		// set the son flag
		pcsr->ibSon = 0;

		bNodeFlag = *pssib->line.pb;
		NDSetSon( bNodeFlag );
		rgline[0].pb = &bNodeFlag;
		rgline[0].cb = 1;

		rgline[1].pb = pssib->line.pb + 1;
		rgline[1].cb = cbCopied - 1;

		rgbT[0] = 1;
		// son count: 1 son
		rgbT[1] = itag;
		// the itag entry of the son
		rgline[2].pb = rgbT;
		rgline[2].cb = 2;

		// copy the data of the node
		rgline[3].pb = pssib->line.pb + cbCopied;
		Assert( pssib->line.cb >= cbCopied );
		rgline[3].cb = pssib->line.cb - cbCopied;

		cline = 4;
		}
	else
		{
		// copy out the father node, shift the the son table, insert it
		// into the son table

		rgline[0].pb = pssib->line.pb;
		rgline[0].cb = cbCopied;

		// copy son count and increment it by one
		cbSon = ( *pb++ ) + ( BYTE )1;
		rgline[1].pb = &cbSon;
		rgline[1].cb = 1;

		// copy the first half of son table
		rgline[2].pb = pb;
		rgline[2].cb = pcsr->ibSon;
		pb += pcsr->ibSon;				// move cursor forward
		cbCopied += pcsr->ibSon + 1;	// count in the son count

		// copy the new entry
		rgline[3].pb = &itag;
		rgline[3].cb = 1;

		// copy the second half of the son table and data portion

		rgline[4].pb = pb;
		Assert( pssib->line.cb >= cbCopied );
		rgline[4].cb = pssib->line.cb - cbCopied;

		cline = 5;
		}

	/*	update the father node now cbRec is the new total length
	/**/
	pssib->itag = pcsr->itagFather;
	CallS( ErrPMReplace( pssib, rgline, cline ) );

	return;
	}


ERR ErrNDInsertNode( FUCB *pfucb, KEY const *pkey, LINE *plineData, INT fHeader )
	{
	ERR		err;
	CSR		*pcsr = PcsrCurrent( pfucb );
	SSIB	*pssib = &pfucb->ssib;
	INT		itag;
	SRID	bm;
	LINE	rgline[4];
	INT		cline = 0;

	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );

	if ( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) )
		{
		BFSleep( cmsecWaitWriteLatch );
		return errDIRNotSynchronous;
		}

	/*	query next itag to be used for insert
	/**/
	itag = ItagPMQueryNextItag( pssib );

	bm = SridOfPgnoItag( pcsr->pgno, itag );

	/*	create version entry for inserted node.  If version entry creation
	/*	fails, undo insert and return error.
	/**/
	if ( FNDVersion( fHeader ) )
		{
		Call( ErrVERInsert( pfucb, bm ) );
		}

	/*	write latch page from dirty until log completion
	/**/
	BFPin( pfucb->ssib.pbf );
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	/*	dirty page buffer
	/**/
	PMDirty( pssib );

	/*	insert the data into the page first
	/**/
	rgline[cline].pb = (BYTE *)&fHeader;

	/*	machine dependent see the macro
	/**/
	rgline[cline++].cb = 1;
	rgline[cline].pb = (BYTE *) &pkey->cb;

	/*	machine dependent
	/**/
	rgline[cline++].cb = 1;

	if ( !FKeyNull( pkey ) )
		{
		rgline[cline].pb = pkey->pb;
		rgline[cline++].cb = pkey->cb;
		}

	if ( !FLineNull( plineData ) )
		{
		rgline[cline++] = *plineData;
		}

	/*	insert son in father son table
	/**/
	pssib->itag = itag;
	NDInsertSon( pfucb, pcsr );

	/* insert the node and set CSR itag to inserted node
	/**/
	CallS( ErrPMInsert( pssib, rgline, cline ) );
	Assert( pssib->itag == itag );
	pcsr->itag = itag;
	Assert( bm == SridOfPgnoItag( pcsr->pgno, pcsr->itag ) );
	pcsr->bm = bm;

	/*	assert line currency to inserted node
	/**/
	AssertNDGet( pfucb, pcsr->itag );

	/* if log fail return to caller, system should crash by the caller
	/**/
	err = ErrLGInsert( pfucb, fHeader, (KEY *)pkey, plineData );
	NDLGCheckPage( pfucb );
	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
	BFUnpin( pfucb->ssib.pbf );

HandleError:
	return err;
	}


ERR ErrNDFlagDeleteNode( FUCB *pfucb, INT fFlags )
	{
	ERR		err;
	CSR    	*pcsr = PcsrCurrent( pfucb );
	SSIB   	*pssib = &pfucb->ssib;

	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );

	if ( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) )
		{
		BFSleep( cmsecWaitWriteLatch );
		return errDIRNotSynchronous;
		}

	AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );

	if ( fFlags & fDIRVersion )
		{
#ifdef DEBUG
			{
			SRID	srid;

			NDIGetBookmark( pfucb, &srid );
			Assert( pcsr->bm == srid );
			}
#endif
		/*	if node is flag deleted then access node and
		/*	return JET_errRecordDeleted if not there.
		/**/
		if ( FNDDeleted( *pfucb->ssib.line.pb ) )
			{
			NS		ns;

			ns = NsVERAccessNode( pfucb, pcsr->bm );
			if ( ns == nsDatabase )
				return JET_errRecordDeleted;
			}
		Call( ErrVERFlagDelete( pfucb, pcsr->bm ) );
		}

	/*	write latch page from dirty until log completion
	/**/
	BFPin( pfucb->ssib.pbf );
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	/*	dirty page buffer
	/**/
	PMDirty( pssib );

	AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );

	/*	flag node as versioned
	/**/
	if ( fFlags & fDIRVersion )
		NDSetVersion( *pssib->line.pb );

	/*	flag node as deleted
	/**/
	NDSetDeleted( *pssib->line.pb );

	/* if log fail return to caller, system should crash by the caller
	/**/
	err = ErrLGFlagDelete( pfucb, fFlags );
	NDLGCheckPage( pfucb );
	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
	BFUnpin( pfucb->ssib.pbf );

	if ( !fRecovering )
		{
		//	UNDONE:	find a better place to load MPL
		MPLRegister( pfucb->u.pfcb,
			pssib,
			PnOfDbidPgno( pfucb->dbid,
			pcsr->pgno ),
			pfucb->sridFather );
		}

HandleError:
	return err;
	}


/*	makes lone son of node intrinsic
/*
/*	PARAMETERS
/*		pfucb->pcsr->itag	node with one son to be made intrinsic
/**/
LOCAL VOID NDMakeSonIntrinsic( FUCB *pfucb )
	{
	CSR		*pcsr = PcsrCurrent( pfucb );
	SSIB	*pssib = &pfucb->ssib;
	LINE	lineNode;
	BYTE	*pb;
	INT		itagSon;
	LINE	rgline[3];
	PGNO	pgnoPagePointer;

	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
	Assert( !( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) ) );

	/* get node
	/**/
	NDGet( pfucb, pcsr->itag );

	Assert( !FNDNullSon( *pssib->line.pb ) );
	Assert( CbNDSon( pssib->line.pb ) == 1 );
	Assert( FNDInvisibleSons( *pssib->line.pb ) );

	lineNode.pb = pssib->line.pb;
	lineNode.cb = pssib->line.cb;
	pb = PbNDSonTable( lineNode.pb );
	Assert( *pb == 1 );
	/*	get son
	/**/
	itagSon = *(++pb);

	/*	copy up to and including to son count [which remains 1]
	/**/
	rgline[0].pb = lineNode.pb;
	rgline[0].cb = (UINT)(pb - lineNode.pb);

	/*	get the data portion of son node
	/**/
	NDGet( pfucb, itagSon );
	Assert( CbNDData( pssib->line.pb, pssib->line.cb ) == sizeof(PGNO) );
	pgnoPagePointer = *(UNALIGNED PGNO *)PbNDData( pssib->line.pb );
	rgline[1].pb = (BYTE *)&pgnoPagePointer;
	rgline[1].cb = sizeof(pgnoPagePointer);

	/*	there was only one son, do not copy the son count and this son
	/**/
	pb++;

	/*	copy the rest of record from end of son table
	/**/
	rgline[2].pb = pb;
	rgline[2].cb = (UINT)(lineNode.pb + lineNode.cb - pb);

	/* delete son (extrinsic copy)
	/**/
	pssib->itag = itagSon;
	PMDelete( pssib );

	/*	update node, do not log it
	/**/
	pssib->itag = pcsr->itag;
	CallS( ErrPMReplace( pssib, rgline, 3 ) );
	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );

	return;
	}


INLINE VOID NDDeleteSon( FUCB *pfucb )
	{
	CSR		*pcsr = PcsrCurrent( pfucb );
	SSIB	*pssib = &pfucb->ssib;
	BYTE	*pb;
	LINE	rgline[5];
	INT		cline;
	BYTE	bNodeFlag;
	BYTE	cbSon;

	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
	Assert( !( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) ) );

	/* first delete the son entry in father of node
	/**/
	NDGet( pfucb, pcsr->itagFather );

	Assert( !FNDNullSon( *pssib->line.pb ) );
	pb = PbNDSonTable( pssib->line.pb );

	/*	copy up to son count
	/**/
	rgline[0].pb = pssib->line.pb;
	rgline[0].cb = (UINT)(pb - pssib->line.pb);

	/*	pb is pointing to the son count, decrement the son count
	/*	copy first half of the son table
	/**/
	if ( *pb == 1 )
		{
		/* skip node header
		/**/
		rgline[1].pb = rgline[0].pb + 1;
		rgline[1].cb = rgline[0].cb - 1;
		
		/* set node header
		/**/
		bNodeFlag = *pssib->line.pb;
		NDResetSon( bNodeFlag );
		rgline[0].pb = &bNodeFlag;
		rgline[0].cb = 1;

		/*	there was only one son, do not copy the son count and this son
		/**/
		if ( pcsr->itagFather != itagFOP && FNDInvisibleSons( bNodeFlag ) )
			{
			/* intrinsic son
			/**/
			pb += 1 + 4;
			}
		else
			{
			/*	check for valid ibSon
			/**/
			Assert( pb[pcsr->ibSon + 1] == pcsr->itag );

			pb += 1 + 1;
			}
		NDSetVisibleSons( bNodeFlag );
		Assert( FNDVisibleSons( bNodeFlag ) || pcsr->itagFather != itagFOP );
		cline = 2;
		}
	else
		{
		/*	check for valid ibSon
		/**/
		Assert( pb[pcsr->ibSon + 1] == pcsr->itag );

		/*	copy the son count
		/**/
		cbSon = ( *pb++ ) - ( BYTE ) 1;
		/*	new son count
		/**/
		rgline[1].pb = &cbSon;
		rgline[1].cb = 1;

		/*	copy half of the table of the record
		/*	portion of son table
		/*	son count and portion of son table
		/**/
		rgline[2].pb = pb;
		rgline[2].cb = pcsr->ibSon;

		/*	skip those copied and the deleted son
		/**/
		pb += pcsr->ibSon + 1;

		/*	continue copying from this point
		/**/
		cline = 3;
		}

	/*	copy the rest of record from end of son table
	/**/
	rgline[cline].pb = pb;
	rgline[cline++].cb = (UINT)(pssib->line.pb + pssib->line.cb - pb);

	/*	update the father node, do not log it
	/**/
	pssib->itag = pcsr->itagFather;
	CallS( ErrPMReplace( pssib, rgline, cline ) );

	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
	//	UNDONE: if only invisible son -- make intrinsic

	return;
	}


LOCAL INLINE  VOID NDIReplaceNodeData( FUCB *pfucb, LINE *plineData, INT fFlags )
	{
	LINE	rgline[3];
	BYTE	bHeader;
	BYTE	*pbData;
	BYTE	*pbNode;
	BYTE	*pbT;

	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
	Assert( !( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) ) );
	AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );

	pbNode = pfucb->ssib.line.pb;
	pbData = PbNDData( pbNode );
	Assert( pbData <= pfucb->ssib.line.pb + pfucb->ssib.line.cb );
	Assert( pbData > pfucb->ssib.line.pb );

	/*	set predata line
	/**/
	bHeader = *pbNode;
	if ( fFlags & fDIRVersion )
		NDSetVersion( bHeader );
	rgline[0].pb = &bHeader;
	rgline[0].cb = sizeof( BYTE );

	/*	set predata line
	/**/
	rgline[1].pb =
	pbT = pbNode + 1;
	rgline[1].cb = (UINT)(pbData - pbT);
	Assert( rgline[1].cb != 0 );

	/*	append data line
	/**/
	rgline[2].pb = plineData->pb;
	rgline[2].cb = plineData->cb;

	/* update the node
	/**/
	pfucb->ssib.itag = PcsrCurrent( pfucb )->itag;
	CallS( ErrPMReplace( &pfucb->ssib, rgline, 3 ) );
	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
	return;
	}


ERR ErrNDDelta( FUCB *pfucb, LONG lDelta, INT fFlags )
	{
	ERR		err;
	BYTE	rgb[cbMaxCounterNode];
	CSR		*pcsr = PcsrCurrent( pfucb );
	LINE	line;

	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );

	if ( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) )
		{
		BFSleep( cmsecWaitWriteLatch );
		return errDIRNotSynchronous;
		}

	if ( fFlags & fDIRVersion )
		{
#ifdef DEBUG
			{
			SRID	srid;

			NDIGetBookmark( pfucb, &srid );
			Assert( pcsr->bm == srid );
			}
#endif
		Assert( !( FNDDeleted( *pfucb->ssib.line.pb ) ) );
		/*	version store information is delta rather than before image
		/**/
		pfucb->lineData.pb = (BYTE *)&lDelta;
		pfucb->lineData.cb = sizeof(lDelta);
		err = ErrVERDelta( pfucb, pcsr->bm );
		Call( err );

		/*	refresh node cache
		/**/
		NDGetNode( pfucb );
		}

	/*	write latch page from dirty until log completion
	/**/
	BFPin( pfucb->ssib.pbf );
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	/*	dirty page buffer
	/**/
	PMDirty( &pfucb->ssib );

	AssertNDGetNode( pfucb, pcsr->itag );
	memcpy( rgb, pfucb->lineData.pb, pfucb->lineData.cb );

	Assert( ibCounter <= (INT)(pfucb->lineData.cb - sizeof(ULONG)) );

	/*	delta cannot have negative results
	/**/
	Assert( (*(LONG *)(rgb + ibCounter)) + lDelta >= 0 );
	(*(LONG *)(rgb + ibCounter)) += lDelta;
	line.cb = pfucb->lineData.cb;
	line.pb = (BYTE *)rgb;

	/* should be an in-place replace
	/**/
	NDIReplaceNodeData( pfucb, &line, fFlags );

	/* if log fail return to caller, system should crash by the caller
	/**/
	err = ErrLGDelta( pfucb, lDelta, fFlags );
	NDLGCheckPage( pfucb );

	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
	BFUnpin( pfucb->ssib.pbf );

HandleError:
	return err;
	}


ERR ErrNDLockRecord( FUCB *pfucb )
	{
	ERR err;
	RCE	*prce;
	
	/*	if node is flag deleted then access node and
	/*	return JET_errRecordDeleted if not there.
	/**/
	if ( FNDDeleted( *pfucb->ssib.line.pb ) )
		{
		NS		ns;

		ns = NsVERAccessNode( pfucb, PcsrCurrent( pfucb )->bm );
		if ( ns == nsDatabase )
			{
			return JET_errRecordDeleted;
			}
		}
	pfucb->prceLast = prceNil;

	/*	write latch page from dirty until log completion
	/**/
	BFPin( pfucb->ssib.pbf );
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	/*	dirty page buffer
	/**/
	PMDirty( &pfucb->ssib );

	/*	put before image in version store as write lock.
	/*	no before image will be put in version store
	/*	during replacement.
	/**/
	Call( ErrVERModify( pfucb, PcsrCurrent( pfucb )->bm, operReplace, &prce ) );
	if ( prce != prceNil )
		{
		Call( ErrLGLockRecord( pfucb, pfucb->lineData.cb ) );
		}

HandleError:
	NDLGCheckPage( pfucb );
	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
	BFUnpin( pfucb->ssib.pbf );
	return err;
	}

	
ERR ErrNDReplaceNodeData( FUCB *pfucb, LINE *pline, INT fFlags )
	{
	ERR 	err;
	ERR		errT;
	INT		cbData = pfucb->lineData.cb;
	SRID	bm = PcsrCurrent( pfucb )->bm;
	RCE 	*prce;
	INT		cbReserved;

	/*	assert currency
	/**/
	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );

	if ( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) )
		{
		BFSleep( cmsecWaitWriteLatch );
		return errDIRNotSynchronous;
		}

	AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );

	/*	initialize "RCE created" indicator for logging.
	/**/
	pfucb->prceLast = prceNil;

	/*	if versioning, then create before image version for node data.
	/**/
	if ( fFlags & fDIRVersion )
		{
#ifdef DEBUG
		SRID		srid;

		NDIGetBookmark( pfucb, &srid );
		Assert( PcsrCurrent( pfucb )->bm == srid );
#endif
		/*	if node is flag deleted then access node and
		/*	return JET_errRecordDeleted if not there.
		/**/
		if ( FNDDeleted( *pfucb->ssib.line.pb ) )
			{
			NS		ns;

			ns = NsVERAccessNode( pfucb, PcsrCurrent( pfucb )->bm );
			if ( ns == nsDatabase )
				return JET_errRecordDeleted;
			return JET_errWriteConflict;
			}

		AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );
		Assert( !FNDDeleted( *pfucb->ssib.line.pb ) );

		/*	if data enlarged in size and versioning enable then
		/*	free page space. VERSetCbAdjust must be called before
		/*  replace to release reserved space so that reserved
		/*  space will be available for the replace operation.
		/**/
		if ( (INT)pline->cb > cbData )
			{
			err = ErrPMCheckFreeSpace( &pfucb->ssib, (INT)pline->cb - cbData );
			if ( err < 0 )
				{
				pfucb->ssib.itag = PcsrCurrent( pfucb )->itag;
				cbReserved = CbVERGetNodeReserve( pfucb, PcsrCurrent( pfucb )->bm );
				if ( cbReserved < 0 )
					cbReserved = 0;
				/*	if node expansion cannot be satisfied from
				/*	reserved space, then check for page having
				/*	sufficient free page, above that of the already
				/*	reserved space.
				/**/
				if ( (INT)pline->cb - cbData > cbReserved )
					{
					Assert( (INT)pline->cb - cbData - cbReserved > 0 );
					Call( ErrPMCheckFreeSpace( &pfucb->ssib, (INT)pline->cb - cbData - cbReserved ) );
					}
				}
			}

		errT = ErrVERReplace( pfucb, bm, &prce );
		Call( errT );
		Assert( prce != prceNil );
		
		if ( (INT)pline->cb > cbData )
			{
			VERSetCbAdjust( pfucb, prce, pline->cb, cbData, fDoUpdatePage );
			}

		/*	write latch page from dirty until log completion
		/**/
		BFPin( pfucb->ssib.pbf );
		BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

		/*	dirty page buffer
		/**/
		PMDirty( &pfucb->ssib );

		NDIReplaceNodeData( pfucb, pline, fFlags );

		/*	if data reduced in size and versioning enable then
		/*	allocate page space for rollback.
		/**/
		if ( (INT)pline->cb < cbData )
			{
			VERSetCbAdjust( pfucb, prce, pline->cb, cbData, fDoUpdatePage );
			}

		/* if log fail return to caller, system should crash by the caller
		/**/
		err = ErrLGReplace( pfucb, pline, fFlags, cbData );
		NDLGCheckPage( pfucb );
		BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
		BFUnpin( pfucb->ssib.pbf );
		}
	else
		{
		/*	if replace with larger then check for free space
		/**/
		if ( (INT)pline->cb > cbData )
			{
			Call( ErrPMCheckFreeSpace( &pfucb->ssib, (INT)pline->cb - cbData ) );
			}

		/*	write latch page from dirty until log completion
		/**/
		BFPin( pfucb->ssib.pbf );
		BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

		/*	dirty page buffer
		/**/
		PMDirty( &pfucb->ssib );

		AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );
		
		NDIReplaceNodeData( pfucb, pline, fFlags );
	
		/* if log fail return to caller, system should crash by the caller
		/**/
		err = ErrLGReplace( pfucb, pline, fFlags, cbData );
		NDLGCheckPage( pfucb );
		BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
		BFUnpin( pfucb->ssib.pbf );
		}

HandleError:
	return err;
	}


ERR ErrNDSetNodeHeader( FUCB *pfucb, BYTE bHeader )
	{
	ERR		err = JET_errSuccess;

	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
	AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );

	/*	write latch page from dirty until log completion
	/**/
	BFPin( pfucb->ssib.pbf );
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	/*	dirty page buffer.
	/**/
	PMDirty( &pfucb->ssib );

	/*	set node header byte with new value.
	/**/
	*pfucb->ssib.line.pb = bHeader;

	/* if log fail return to caller, system should crash by the caller
	/**/
	err = ErrLGUpdateHeader( pfucb, (int) bHeader );
	NDLGCheckPage( pfucb );
	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
	BFUnpin( pfucb->ssib.pbf );
	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );

	return err;
	}


VOID NDResetNodeVersion( FUCB *pfucb )
	{
	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
	AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );

 	/*	dirty page buffer. but no increment ulDBTime since not logged and
	/*	not affect directory cursor timestamp check.
	/**/
	BFSetDirtyBit( pfucb->ssib.pbf );

	PMDecVersion( pfucb->ssib.pbf->ppage );
	NDResetVersion( *( pfucb->ssib.line.pb ) );
	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
	}


/* called by ver to undo. Undo is logged, so use PMDirty to set ulDBTime
/**/
VOID NDResetNodeDeleted( FUCB *pfucb )
	{
	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );

	/*	write latch page from dirty until log completion
	/**/
	BFPin( pfucb->ssib.pbf );
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	/*	dirty page buffer.
	/**/
	PMDirty( &pfucb->ssib );

	AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );

	/*	reset node delete
	/**/
	NDResetDeleted( *( pfucb->ssib.line.pb ) );

	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
	BFUnpin( pfucb->ssib.pbf );
	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );

	return;
	}


/************************************/
/********* item operations **********/
/************************************/
#ifdef DEBUG
VOID NDICheckItemBookmark( FUCB *pfucb, SRID srid )
	{
	SRID	sridT;

	NDIGetBookmark( pfucb, &sridT );

	if( FNDFirstItem( *pfucb->ssib.line.pb ) )
		{
		Assert( srid == sridT );
		}
	else
		{
		Assert( srid != sridT );
		}

	return;
	}
#else
#define NDICheckItemBookmark( pfucb, srid )
#endif

ERR ErrNDGetItem( FUCB *pfucb )
	{
	CSR		*pcsr = PcsrCurrent( pfucb );
	SRID	srid;

	Assert( FReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
	AssertNDGetNode( pfucb, pcsr->itag );
	Assert( pfucb->lineData.cb >= sizeof( SRID ) );
	Assert( pcsr->isrid >= 0 );

	srid = *( (UNALIGNED SRID *)pfucb->lineData.pb + pcsr->isrid );
	pcsr->item = BmNDOfItem( srid );

	if ( FNDItemVersion( srid ) && !FPIBDirty( pfucb->ppib ) )
		{
		NS	ns;

		NDICheckItemBookmark( pfucb, pcsr->bm );
		ns = NsVERAccessItem( pfucb, pcsr->bm );
		if ( ns == nsInvalid || ( ns == nsDatabase && FNDItemDelete( srid ) ) )
			{
			return errNDNoItem;
			}
		}
	else
		{
		if ( FNDItemDelete( srid ) )
			{
			return errNDNoItem;
			}
		}

	/*	item should already be cached.
	/**/
	Assert( pcsr->item == BmNDOfItem( srid ) );

	return JET_errSuccess;
	}


ERR ErrNDFirstItem( FUCB *pfucb )
	{
	CSR		*pcsr = PcsrCurrent( pfucb );
	SRID	srid;

	Assert( FReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
	AssertNDGetNode( pfucb, pcsr->itag );
	Assert( pfucb->lineData.cb >= sizeof( SRID ) );

	/*	set isrid to first item.
	/**/
	pcsr->isrid = 0;

	srid = *(UNALIGNED SRID *)pfucb->lineData.pb;
	pcsr->item = BmNDOfItem( srid );

	if ( FNDItemVersion( srid ) && !FPIBDirty( pfucb->ppib ) )
		{
		NS	ns;

		NDICheckItemBookmark( pfucb, pcsr->bm );
		ns = NsVERAccessItem( pfucb, pcsr->bm );
		if ( ns == nsInvalid ||
			( ns == nsDatabase && FNDItemDelete( srid ) ) )
			{
			return errNDNoItem;
			}
		}
	else
		{
		if ( FNDItemDelete( srid ) )
			{
			return errNDNoItem;
			}
		}

	pcsr->item = BmNDOfItem( srid );
	return JET_errSuccess;
	}


ERR ErrNDLastItem( FUCB *pfucb )
	{
	CSR		*pcsr = PcsrCurrent( pfucb );
	SRID	srid;

	Assert( FReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
	AssertNDGetNode( pfucb, pcsr->itag );
	Assert( pfucb->lineData.cb >= sizeof( SRID ) );

	pcsr->isrid = ( pfucb->lineData.cb / sizeof( SRID ) ) - 1;
	Assert( pcsr->isrid >= 0 );
	srid = *( (UNALIGNED SRID *)pfucb->lineData.pb + pcsr->isrid );
	pcsr->item = BmNDOfItem( srid );

	if ( FNDItemVersion( srid ) && !FPIBDirty( pfucb->ppib ) )
		{
		NS		ns;

		NDICheckItemBookmark( pfucb, pcsr->bm );
		ns = NsVERAccessItem( pfucb, pcsr->bm );
		if ( ns == nsInvalid ||	( ns == nsDatabase && FNDItemDelete( srid ) ) )
			{
			return errNDNoItem;
			}
		}
	else
		{
		if ( FNDItemDelete( srid ) )
			{
			return errNDNoItem;
			}
		}

	pcsr->item = BmNDOfItem( srid );
	return JET_errSuccess;
	}


ERR ErrNDNextItem( FUCB *pfucb )
	{
	CSR		*pcsr = PcsrCurrent( pfucb );
	SRID	srid;

	Assert( FReadAccessPage( pfucb, pcsr->pgno ) );
	AssertNDGetNode( pfucb, pcsr->itag );
	Assert( pfucb->lineData.cb >= sizeof( SRID ) );

	forever
		{
		/*	common case will be no next srid.
		/**/
		Assert( pcsr->isrid < ( INT ) ( pfucb->lineData.cb / sizeof( SRID ) ) );
		if ( pcsr->isrid == ( INT ) ( pfucb->lineData.cb / sizeof( SRID ) ) - 1 )
			{
			if ( FNDLastItem( *( pfucb->ssib.line.pb ) ) )
				return errNDLastItemNode;
			else
				return errNDNoItem;
			}

		/*	move to next srid.
		/**/
		pcsr->isrid++;
		Assert( pcsr->isrid >= 0 && pcsr->isrid < ( INT ) ( pfucb->lineData.cb / sizeof( SRID ) ) );
		srid = *( (UNALIGNED SRID *)pfucb->lineData.pb + pcsr->isrid );
		pcsr->item = BmNDOfItem( srid );

		/*	break if find valid item.
		/**/
		if ( FNDItemVersion( srid ) && !FPIBDirty( pfucb->ppib ) )
			{
			NS	ns;

			NDICheckItemBookmark( pfucb, pcsr->bm );
			ns = NsVERAccessItem( pfucb, pcsr->bm );
			if ( ns == nsVersion ||
				( ns == nsDatabase && !FNDItemDelete( srid ) ) )
				{
				break;
				}
			}
		else
			{
			if ( !FNDItemDelete( srid ) )
				break;
			}
		}

	return JET_errSuccess;
	}


ERR ErrNDPrevItem( FUCB *pfucb )
	{
	CSR		*pcsr = PcsrCurrent( pfucb );
	SRID	srid;

	Assert( FReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
	AssertNDGetNode( pfucb, pcsr->itag );
	Assert( pfucb->lineData.cb >= sizeof( SRID ) );

	forever
		{
		/*	common case will be no next srid.
		/**/
		if ( pcsr->isrid < 1 )
			{
			if ( FNDFirstItem( *( pfucb->ssib.line.pb ) ) )
				return errNDFirstItemNode;
			else
				return errNDNoItem;
			}

		/*	move to next srid.
		/**/
		pcsr->isrid--;
		Assert( pcsr->isrid >= 0 && pcsr->isrid < ( INT ) ( pfucb->lineData.cb / sizeof( SRID ) ) );
		srid = *( (UNALIGNED SRID *)pfucb->lineData.pb + pcsr->isrid );
		pcsr->item = BmNDOfItem( srid );

		/*	break if find valid item.
		/**/
		if ( FNDItemVersion( srid ) && !FPIBDirty( pfucb->ppib ) )
			{
			NS		ns;

			NDICheckItemBookmark( pfucb, pcsr->bm );
			ns = NsVERAccessItem( pfucb, pcsr->bm );
			if ( ns == nsVersion ||
				( ns == nsDatabase && !FNDItemDelete( srid ) ) )
				{
				break;
				}
			}
		else
			{
			if ( !FNDItemDelete( srid ) )
				break;
			}
		}

	return JET_errSuccess;
	}


/* locate the location for this srid
/**/
ERR ErrNDSeekItem( FUCB *pfucb, SRID srid )
	{
	UNALIGNED SRID 	*psrid;
	INT				csrid;
	UNALIGNED SRID	*rgsrid;
	INT				isridLeft;
	INT				isridRight;
	INT				isridT;

	#ifdef DEBUG
		{
		SSIB 			*pssib = &pfucb->ssib;
		UNALIGNED SRID	*psrid;
		UNALIGNED SRID 	*psridMax;
		INT				csrid;
		LONG			l;

		Assert( FReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
		AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );
		Assert( pfucb->lineData.cb >= sizeof( SRID ) );

		/*	set max to last SRID less one, so that max plus one is last
		/**/
		psrid = (UNALIGNED SRID *)PbNDData( pssib->line.pb );
		Assert( (BYTE *)psrid < pssib->line.pb + pssib->line.cb );
		Assert( (BYTE *)psrid > pssib->line.pb );
		csrid = ( CbNDData( pssib->line.pb, pssib->line.cb ) ) / sizeof( SRID );
		psridMax = psrid + csrid - 1;

		/*	note that no srid may occur more than once in a srid list.
		/**/
		for ( ; psrid < psridMax; psrid++ )
			{
			l = LSridCmp( *(UNALIGNED SRID *)psrid, *(UNALIGNED SRID *)(psrid + 1) );
			Assert( l <= 0 );
			}
		}
	#endif

	Assert( FReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
	AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );
	Assert( pfucb->lineData.cb >= sizeof( SRID ) );

	/* get data
	/**/
	psrid = (UNALIGNED SRID *)pfucb->lineData.pb;
	csrid = pfucb->lineData.cb / sizeof( SRID );

	isridLeft = 0;
	isridRight = csrid - 1;
	rgsrid = psrid;

	/* binary search to locate the proper position of the given srid
	/**/
	while ( isridRight > isridLeft )
		{
		isridT = ( isridLeft + isridRight ) / 2;
		if ( BmNDOfItem( rgsrid[ isridT ] ) < srid )
			isridLeft = isridT + 1;
		else
			isridRight = isridT;
		}

	/*	check for srid greater than all srid in srid list
	/**/
	if ( BmNDOfItem( rgsrid[isridRight] ) < srid && isridRight == csrid - 1 )
		{
		PcsrCurrent( pfucb )->isrid = csrid;
		return errNDGreaterThanAllItems;
		}

	PcsrCurrent( pfucb )->isrid = isridRight;
	Assert( PcsrCurrent( pfucb )->isrid < csrid );

	return ( BmNDOfItem( rgsrid[isridRight] ) == srid ) ? wrnNDDuplicateItem : JET_errSuccess;
	}


INT CitemNDThere( FUCB *pfucb )
	{
	CSR				*pcsr = PcsrCurrent( pfucb );
	UNALIGNED SRID	*psrid;
	UNALIGNED SRID	*psridMax;
	INT				csrid;
	INT				csridThere = 0;
	NS				ns;
	INT				isridSav = PcsrCurrent( pfucb )->isrid;

	Assert( FReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
	AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );

	psrid = (UNALIGNED SRID *)pfucb->lineData.pb;
	PcsrCurrent( pfucb )->isrid = 0;
	csrid = pfucb->lineData.cb/sizeof( SRID );
	psridMax = psrid + csrid;
	for ( ; psrid < psridMax; psrid++, PcsrCurrent( pfucb )->isrid++ )
		{
		if ( FNDItemVersion( *psrid ) && !FPIBDirty( pfucb->ppib ) )
			{
			NDICheckItemBookmark( pfucb, pcsr->bm );
			pcsr->item = BmNDOfItem( *psrid );
			ns = NsVERAccessItem( pfucb, pcsr->bm );
			if ( ns == nsVerInDB ||
				( ns == nsDatabase && !FNDItemDelete( *psrid ) ) )
				csridThere++;
			}
		else
			{
			if ( !( FNDItemDelete( *psrid ) ) )
				csridThere++;
			}
		}

	/*	restore isrid
	/**/
	PcsrCurrent( pfucb )->isrid = isridSav;

	return csridThere;
	}


/*	Insert item list inserts a new item list node.  Since the item
/*	list is new, the node inserted is both the first and last
/*	item list node.  A version is created for the only item.
/**/
ERR ErrNDInsertItemList( FUCB *pfucb, KEY *pkey, SRID srid, INT fFlags )
	{
	ERR		err;
	CSR		*pcsr = PcsrCurrent( pfucb );
	SSIB   	*pssib = &pfucb->ssib;
	INT		itag;
	SRID   	bm;
	LINE   	rgline[4];
	LINE   	*plineData;
	INT		cline = 0;
	INT		bHeader;

	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );

	if ( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) )
		{
		BFSleep( cmsecWaitWriteLatch );
		return errDIRNotSynchronous;
		}

	/*	query next itag to be used for insert
	/**/
	itag = ItagPMQueryNextItag( pssib );

	/*	set bm from node just inserted since it is the first item
	/*	list node for this item list.
	/**/
	bm = SridOfPgnoItag( pcsr->pgno, itag );

	/*	set item in CSR for version
	/**/
	pcsr->item = srid;

	/*	create version for inserted item.  Note that there is no
	/*	version for item list node.
	/**/
	if ( fFlags & fDIRVersion )
		{
		Call( ErrVERInsertItem( pfucb, bm ) );
		/*	set item version bit
		/**/
		ITEMSetVersion( srid );
		}

	/*	write latch page from dirty until log completion
	/**/
	BFPin( pfucb->ssib.pbf );
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	/*	dirty page buffer
	/**/
	PMDirty( pssib );

	/*	set node header to first last item node
	/**/
	bHeader = fNDFirstItem | fNDLastItem;
	rgline[cline].pb = (BYTE *)&bHeader;
	rgline[cline++].cb = 1;

	/*	key length
	/**/
	rgline[cline].pb = ( BYTE * ) &pkey->cb;
	rgline[cline++].cb = 1;

	/*	key information
	/**/
	if ( !FKeyNull( pkey ) )
		{
		rgline[cline].pb = pkey->pb;
		rgline[cline++].cb = pkey->cb;
		}

	plineData = &rgline[cline];
  	rgline[cline].pb = (BYTE *)&srid;
  	rgline[cline++].cb = sizeof(srid);

	/*	insert son for item list node in father son table
	/**/
	pssib->itag = itag;
	NDInsertSon( pfucb, pcsr );

	/* insert item list node and set CSR itag to inserted item list node
	/**/
	CallS( ErrPMInsert( pssib, rgline, cline ) );
	Assert( pssib->itag == itag );
	pcsr->itag = itag;
	Assert( bm == SridOfPgnoItag( pcsr->pgno, itag ) );
	pcsr->bm = bm;

	AssertNDGet( pfucb, pcsr->itag );

	/* if log fail return to caller, system should crash by the caller
	/**/
	err = ErrLGInsertItemList( pfucb, bHeader, pkey, plineData, fFlags );
	NDLGCheckPage( pfucb );
	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
	BFUnpin( pfucb->ssib.pbf );
	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );

HandleError:
	return err;
	}


ERR ErrNDInsertItem( FUCB *pfucb, ITEM item, INT fFlags )
	{
	ERR		err;
	CSR		*pcsr = PcsrCurrent( pfucb );
	SSIB   	*pssib = &pfucb->ssib;
	LINE   	rgline[3];
	BYTE   	*pb;
	INT		cbCopied;

	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );

	if ( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) )
		{
		BFSleep( cmsecWaitWriteLatch );
		return errDIRNotSynchronous;
		}

	/*	set CSR item for version creation
	/**/
	pcsr->item = item;

	/*	create version for inserted item
	/**/
	if ( fFlags & fDIRVersion )
		{
		NDICheckItemBookmark( pfucb, pcsr->bm );
		Call( ErrVERInsertItem( pfucb, pcsr->bm ) );
		ITEMSetVersion( item );
		}

	/*	write latch page from dirty until log completion
	/**/
	BFPin( pfucb->ssib.pbf );
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	/*	dirty page buffer
	/**/
	PMDirty( pssib );

	AssertNDGetNode( pfucb, pcsr->itag );

	/* insert the srid into position indicated by pfucb->pcsr->isrid
	/**/
	pb = PbNDData( pssib->line.pb );
	Assert( pb < pssib->line.pb + pssib->line.cb );
	Assert( pb > pssib->line.pb );
	pb += pcsr->isrid * sizeof( SRID );

	/* copy out the current node, shift the srid list,
	/*	insert it into the srid list.
	/**/
	rgline[0].pb = pssib->line.pb;
	rgline[0].cb =
		cbCopied = (INT)(pb - pssib->line.pb);

	rgline[1].pb = (BYTE *)&item;
	rgline[1].cb = sizeof(item);

	rgline[2].pb = pb;
	rgline[2].cb = pssib->line.cb - cbCopied;

	/* now update the current node
	/**/
	pssib->itag = pcsr->itag;
	CallS( ErrPMReplace( pssib, rgline, 3 ) );

	#ifdef DEBUG
		{
		UNALIGNED SRID 	*psrid;
		UNALIGNED SRID 	*psridMax;
		INT				csrid;
		LONG 			l;

		/*	set max to last SRID less one, so that max plus one is last
		/**/
		psrid = (UNALIGNED SRID *)PbNDData( pssib->line.pb );
		Assert( (BYTE *) psrid < pssib->line.pb + pssib->line.cb );
		Assert( (BYTE *) psrid > pssib->line.pb );
		csrid = ( CbNDData( pssib->line.pb, pssib->line.cb ) ) / sizeof( SRID );
		psridMax = psrid + csrid - 1;

		/*	note that no srid may occur more than once in a srid list.
		/**/
		for ( ; psrid < psridMax; psrid++ )
			{
			l = LSridCmp( * (UNALIGNED SRID *) psrid, * (UNALIGNED SRID *) (psrid + 1) );
			Assert( l <= 0 );
			}
		}
	#endif

	/* if log fail return to caller, system should crash by the caller
	/**/
	err = ErrLGInsertItem( pfucb, fFlags );
	NDLGCheckPage( pfucb );
	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
	BFUnpin( pfucb->ssib.pbf );
	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );

HandleError:
	return err;
	}


#ifdef BULK_INSERT_ITEM
ERR ErrNDInsertItems( FUCB *pfucb, ITEM *rgitem, INT citem )
	{
	ERR		err;
	CSR		*pcsr = PcsrCurrent( pfucb );
	SSIB  	*pssib = &pfucb->ssib;
	LINE  	rgline[2];

	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
	Assert( !( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) ) );

	/*	write latch page from dirty until log completion
	/**/
	BFPin( pfucb->ssib.pbf );
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	/*	dirty page buffer
	/**/
	PMDirty( pssib );

	AssertNDGetNode( pfucb, pcsr->itag );

	/* copy out the current node, shift the srid list, insert it into
	/* the srid list.
	/**/
	rgline[0].pb = pssib->line.pb;
	rgline[0].cb = pssib->line.cb;

	rgline[1].pb = (BYTE *)rgitem;
	rgline[1].cb = citem * sizeof(SRID);

	/* now update the current node
	/**/
	pssib->itag = pcsr->itag;
	CallS( ErrPMReplace( pssib, rgline, 2 ) );

	#ifdef DEBUG
		{
		UNALIGNED SRID 	*psrid;
		UNALIGNED SRID	*psridMax;
		INT				csrid;
		LONG			l;

		/*	set max to last SRID less one, so that max plus one is last
		/**/
		psrid = (UNALIGNED SRID *)PbNDData( pssib->line.pb );
		Assert( (BYTE *) psrid < pssib->line.pb + pssib->line.cb );
		Assert( (BYTE *) psrid > pssib->line.pb );
		csrid = ( CbNDData( pssib->line.pb, pssib->line.cb ) ) / sizeof( SRID );
		psridMax = psrid + csrid - 1;

		/*	note that no srid may occur more than once in a srid list.
		/**/
		for ( ; psrid < psridMax; psrid++ )
			{
			l = LSridCmp( * (UNALIGNED SRID *) psrid, * (UNALIGNED SRID *) (psrid + 1) );
			Assert( l <= 0 );
			}
		}
	#endif

	/* if log fail return to caller, system should crash by the caller
	/**/
	err = ErrLGInsertItems( pfucb, rgitem, citem );
	NDLGCheckPage( pfucb );
	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
	BFUnpin( pfucb->ssib.pbf );
	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );

	return err;
	}
#else
ERR ErrNDInsertItems( FUCB *pfucb, ITEM *rgitem, INT citem )
	{
	NotUsed(pfucb);
	NotUsed(rgitem);
	NotUsed(citem);

	Assert( fFalse );
	return JET_errSuccess;
	}
#endif


/*	reset delete bit on delete item to show it as inserted.
/**/
ERR ErrNDFlagInsertItem( FUCB *pfucb )
	{
	ERR		err;
	CSR   	*pcsr = PcsrCurrent( pfucb );
	SSIB  	*pssib = &pfucb->ssib;
	SRID  	srid;

	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );

	if ( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) )
		{
		BFSleep( cmsecWaitWriteLatch );
		return errDIRNotSynchronous;
		}
	
	AssertNDGetNode( pfucb, pcsr->itag );

	/*	create version for deleted item
	/**/
	Assert( pcsr->isrid >= 0 );
	pcsr->item =
		srid = BmNDOfItem( *( (UNALIGNED SRID *)pfucb->lineData.pb + pcsr->isrid ) );
	NDICheckItemBookmark( pfucb, pcsr->bm );
	//	UNDONE:	check for write conflict
	Call( ErrVERFlagInsertItem( pfucb, pcsr->bm ) );

	/*	write latch page from dirty until log completion
	/**/
	BFPin( pfucb->ssib.pbf );
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	/*	dirty page buffer
	/**/
	PMDirty( pssib );

	/*	set item version
	/**/
	ITEMSetVersion( srid );
	Assert( !FNDItemDelete( srid ) );

	/*	overwrite deleted item with delete bit reset and version bit set
	/**/
	//	UNDONE:	call page operation
	Assert( pcsr->isrid >= 0 );
	memcpy( &( (UNALIGNED SRID *)PbNDData( pssib->line.pb ) )[pcsr->isrid], &srid, sizeof(srid) );

	/* if log fail return to caller, system should crash by the caller
	/**/
	err = ErrLGFlagInsertItem( pfucb );
	NDLGCheckPage( pfucb );
	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
	BFUnpin( pfucb->ssib.pbf );
	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );

HandleError:
	return err;
	}


ERR ErrNDDeleteItem( FUCB *pfucb )
	{
	ERR   	err;
	CSR   	*pcsr = PcsrCurrent( pfucb );
	SSIB  	*pssib = &pfucb->ssib;
	INT		itag = pfucb->ssib.itag;
	LINE  	rgline[2];
	BYTE  	*pb;
	INT		cbCopied;

	/* make current node addressible
	/**/
	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
	Assert( !( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) ) );
	
	/*	write latch page from dirty until log completion
	/**/
	BFPin( pfucb->ssib.pbf );
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	/*	dirty page buffer
	/**/
	PMDirty( pssib );
		
	AssertNDGetNode( pfucb, pcsr->itag );

	/* delete the srid indicated by pfucb->pcsr->isrid
	/* skip key
	/**/
	pb = PbNDData( pssib->line.pb );
	Assert( pb < pssib->line.pb + pssib->line.cb );
	Assert( pb > pssib->line.pb );

	pb += pcsr->isrid * sizeof( SRID );

	/* use the old node in page buffer, shift the srid list
	/**/
	rgline[0].pb = pssib->line.pb;
	rgline[0].cb = cbCopied = (INT)(pb - pssib->line.pb);

	rgline[1].pb = pb + sizeof( SRID );
	rgline[1].cb = pssib->line.cb - cbCopied - sizeof( SRID );

	/*	replace node with item list without deleted item
	/**/
	pssib->itag = pcsr->itag;
	CallS( ErrPMReplace( pssib, rgline, 2 ) );

	err = ErrLGDeleteItem( pfucb );
	NDLGCheckPage( pfucb );
	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
	BFUnpin( pfucb->ssib.pbf );
	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );

	return err;
	}


ERR ErrNDFlagDeleteItem( FUCB *pfucb )
	{
	ERR		err;
	CSR   	*pcsr = PcsrCurrent( pfucb );
	SSIB  	*pssib = &pfucb->ssib;
	SRID  	srid;

	Assert( FWriteAccessPage( pfucb, pcsr->pgno ) );
	AssertNDGetNode( pfucb, pcsr->itag );

	srid = *( (UNALIGNED SRID *)pfucb->lineData.pb + pcsr->isrid );

	/*	create version for deleted item
	/**/
	Assert( pcsr->isrid >= 0 );
	Assert( pcsr->item == BmNDOfItem( srid ) );
	NDICheckItemBookmark( pfucb, pcsr->bm );
	
	/*	if item is flag deleted then access item and
	/*	return JET_errRecordDeleted if not there.
	/**/
	if ( FNDItemDelete( srid ) )
		{
		NS		ns;

		ns = NsVERAccessItem( pfucb, pcsr->bm );
		if ( ns == nsDatabase )
			return JET_errRecordDeleted;
		return JET_errWriteConflict;
		}
	Call( ErrVERFlagDeleteItem( pfucb, pcsr->bm ) );

	/*	write latch page from dirty until log completion
	/**/
	BFPin( pfucb->ssib.pbf );
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	/*	dirty page buffer
	/**/
	PMDirty( pssib );

	AssertNDGet( pfucb, pcsr->itag );

	/*	flag node as deleted
	/**/
	srid = pcsr->item;
	ITEMSetVersion( srid );
	ITEMSetDelete( srid );

	/*	set delete bit on item
	/**/
	//	UNDONE:	use page operation
	Assert( pcsr->isrid >= 0 );
	memcpy( &( (UNALIGNED SRID *)PbNDData( pssib->line.pb ) )[pcsr->isrid],
		&srid,
		sizeof(SRID) );

	/* if log fail return to caller, system should crash by the caller
	/**/
	err = ErrLGFlagDeleteItem( pfucb );
	NDLGCheckPage( pfucb );
	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
	BFUnpin( pfucb->ssib.pbf );
	Assert( FWriteAccessPage( pfucb, pcsr->pgno ) );

HandleError:
	return err;
	}


ERR ErrNDSplitItemListNode( FUCB *pfucb, INT fFlags )
	{
	ERR		err;
	CSR		*pcsr = PcsrCurrent( pfucb );
	SSIB  	*pssib = &pfucb->ssib;
	INT		citem;
	BYTE  	rgbL[cbItemNodeMost];
	BYTE  	rgbR[cbHalfItemNodeMost];
	INT		iSplitItem;
	INT		cbLeft;
	INT		cb1;
	INT		cb2;
	INT		itagToSplit;
	LINE  	line;
	KEY		key;
	PIB		*ppib = pfucb->ppib;
	BOOL  	fPIBLogDisabledSave;

	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );

	if ( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) )
		{
		BFSleep( cmsecWaitWriteLatch );
		return errDIRNotSynchronous;
		}

	AssertNDGetNode( pfucb, pcsr->itag );

	/*	efficiency variables
	/**/
	citem = pfucb->lineData.cb / sizeof( SRID );
	Assert( citem > 1 );
	iSplitItem = ( fFlags & fDIRAppendItem ) ? citem - 1 : citem / 2;

	/* no logging for this particular function
	/**/
	fPIBLogDisabledSave = ppib->fLogDisabled;
	ppib->fLogDisabled = fTrue;

	/*	no versioning is need for item list node.
	/**/
	itagToSplit = pcsr->itag;
	NDGet( pfucb, itagToSplit );

	/*	create left son with iSplitItem srids
	/**/
	cbLeft = 1 + 1 + CbNDKey( pssib->line.pb );
	cbLeft += ( FNDBackLink( *pssib->line.pb ) ? sizeof( SRID ) : 0 );
	cbLeft += iSplitItem * sizeof( SRID );
	memcpy( rgbL, pssib->line.pb, cbLeft );
	Assert( !FNDDeleted( *rgbL ) );
	Assert( !FNDVersion( *rgbL ) );
	Assert( !FNDSon( *rgbL ) );

	/*	create right son, by first copying header and key.  Then
	/*	copy those srids that will be in right son.  Remember to
	/*	reset back link bit in right son header.
	/**/
	cb1 = 1 + 1 + CbNDKey( pssib->line.pb );
	memcpy( rgbR, rgbL, cb1 );
	NDResetBackLink( *rgbR );
	cb2 = ( citem - iSplitItem ) * sizeof( SRID );
	memcpy( rgbR + cb1,
		PbNDData( pssib->line.pb ) + ( iSplitItem * sizeof( SRID ) ),
		cb2 );
	Assert( !FNDVersion( *rgbR ) );
	Assert( !FNDDeleted( *rgbR ) );
	Assert( !FNDSon( *rgbR ) );
	Assert( !FNDBackLink( *rgbR ) );

	/* maintain the fLastItemListNode/fFirstItemListNode
	/**/
	NDResetLastItem( rgbL[0] );
	NDResetFirstItem( rgbR[0] );

	/*	write latch page from dirty until log completion
	/**/
	BFPin( pfucb->ssib.pbf );
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	/*	dirty page buffer
	/**/
	PMDirty( pssib );

	/* update the old son, this should cause no split
	/**/
	line.pb = rgbL;
	line.cb = cbLeft;
	pssib->itag = pcsr->itag;
	CallS( ErrPMReplace( pssib, &line, 1 ) );

	/*	insert right item list
	/**/
	pcsr->ibSon++;

	key.pb = PbNDKey( rgbR );
	key.cb = CbNDKey( rgbR );
	line.pb = PbNDData( rgbR );
	line.cb = cb2;
	CallS( ErrNDInsertNode( pfucb, &key, &line, *rgbR ) );
	AssertNDGet( pfucb, pcsr->itag );

	/* log the item node split, no versioning
	/**/
	ppib->fLogDisabled = fPIBLogDisabledSave;

	err = ErrLGSplitItemListNode(
	 	pfucb,
		citem,
		pcsr->itagFather,
		pcsr->ibSon - 1, 	/* it was incremented in this function */
		itagToSplit,
		fFlags );
	NDLGCheckPage( pfucb );
	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
	BFUnpin( pfucb->ssib.pbf );

	Assert( ppib->fLogDisabled == fPIBLogDisabledSave );
	return err;
	}


/* called by bm to expunge back link, only redo it. No undo it.
/**/
ERR ErrNDExpungeBackLink( FUCB *pfucb )
	{
	ERR		err;
	SSIB 	*pssib = &pfucb->ssib;
	LINE 	rgline[3];
	INT		cline;
	BYTE 	*pbNode;
	INT		cbNode;
	BYTE 	*pbData;
	BYTE 	*pbBackLink;
	BYTE 	bFlag;

	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );

	while( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) )
		{
		BFSleep( cmsecWaitWriteLatch );
		}

	/*	write latch page from dirty until log completion
	/**/
	BFPin( pfucb->ssib.pbf );
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	/*	dirty page buffer
	/**/
	PMDirty( pssib );

	/*	efficiency variables
	/**/
	cline = 0;
	pbNode = pssib->line.pb;
	cbNode = pssib->line.cb;
	pbData = PbNDData( pssib->line.pb );
	pbBackLink = PbNDBackLink( pssib->line.pb );
	bFlag = *pbNode;

	NDResetBackLink( bFlag );

	/* node header
	/**/
	rgline[cline].pb = &bFlag;
	rgline[cline++].cb = sizeof( bFlag );

	/* copy up to back link, including key and son table
	/**/
	rgline[cline].pb = pbNode + sizeof( bFlag );
	rgline[cline++].cb = (UINT)(pbBackLink - pbNode - sizeof( bFlag ));

	/* skip back link, continue copying data
	/**/
	rgline[cline].pb = pbData;
	rgline[cline++].cb = cbNode - (UINT)( pbData - pbNode );

	pssib->itag = PcsrCurrent( pfucb )->itag;

	err = ErrPMReplace( pssib, rgline, cline );

	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
	BFUnpin( pfucb->ssib.pbf );
	
	return err;
	}


/*	called by bookmark clean up to remove back link from node,
/*	free tag redirector, and to log operation for redo only.
/**/
ERR ErrNDExpungeLinkCommit( FUCB *pfucb, FUCB *pfucbSrc )
	{
	ERR		err;
	SSIB  	*pssib = &pfucb->ssib;
	SSIB  	*pssibSrc = &pfucbSrc->ssib;
	SRID  	sridSrc;

	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
	Assert( FWriteAccessPage( pfucbSrc, PcsrCurrent( pfucbSrc )->pgno ) );

	/*	remove back link from node
	/**/
	CallR( ErrNDExpungeBackLink( pfucb ) )

	/*	write latch page from dirty until log completion
	/**/
	BFPin( pfucb->ssib.pbf );
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	PMDirty( pssibSrc );

	/*	remove redirector
	/**/
	pssibSrc->itag = PcsrCurrent( pfucbSrc )->itag;
	PMExpungeLink( pssibSrc );

//	/* reset time tamp while it is being latched in critJet.
//	/* The statement must before LGExpungeLinkCommit so that
//	/* it stays in critJet and rgfmp[dbid].ulDBTime will not be changed.
//	/**/
//	PMSetUlDBTime( pssib, rgfmp[pfucb->dbid].ulDBTime );
//	PMSetUlDBTime( pssibSrc, rgfmp[pfucb->dbid].ulDBTime );

	/* if log fail return to caller, system should crash by the caller
	/**/
	sridSrc	= SridOfPgnoItag( PcsrCurrent(pfucbSrc)->pgno, PcsrCurrent(pfucbSrc)->itag );
	err = ErrLGExpungeLinkCommit( pfucb, pssibSrc, sridSrc );
	NDLGCheckPage( pfucb );
	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
	BFUnpin( pfucb->ssib.pbf );

	return err;
	}


/* used by OLC to remove page pointer that points to an empty page
/* that is about to be retrieved
/**/
VOID NDDeleteInvisibleSon(
	FUCB  	*pfucb,
	RMPAGE	*prmpage,
	BOOL  	fCheckRemoveParentOnly,
	BOOL  	*pfRmParent )
	{
	SSIB	*pssib = &pfucb->ssib;
	BOOL	fFatherFOP = ( prmpage->itagFather == itagFOP );
	LONG	cbSibling;

	Assert( FWriteAccessPage( pfucb, prmpage->pgnoFather ) );

	/*	initialize pfRmParent
	/**/
	*pfRmParent = fFalse;

	/*	get page pointer node
	/**/
	NDGet( pfucb, prmpage->itagFather );
	Assert( !FNDNullSon( *pssib->line.pb ) );
	cbSibling = CbNDSon( pssib->line.pb ) - 1;
	Assert( cbSibling >= 0 );

	/*	set currency to page pointer, to fool NDDeleteSon
	/**/
	PcsrCurrent( pfucb )->pgno = prmpage->pgnoFather;
	PcsrCurrent( pfucb )->itag = prmpage->itagPgptr;
	PcsrCurrent( pfucb )->itagFather = prmpage->itagFather;
	PcsrCurrent( pfucb )->ibSon = prmpage->ibSon;

	if ( fCheckRemoveParentOnly )
		{
		*pfRmParent = ( cbSibling == 0 &&
			fFatherFOP &&
			FPMLastNodeToDelete( pssib ) );
		}
	else
		{
		/*	write latch page from dirty until log completion
		/**/
		BFPin( pfucb->ssib.pbf );
		BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

		/*	dirty page buffer
		/**/
		PMDirty( pssib );

		NDDeleteSon( pfucb );

		/*	delete page pointer [if it is not intrinsic son of nonFOP].
		/*	Currency is maintained by the caller
		/**/
		if ( cbSibling == 0 && !fFatherFOP )
			{
			/* intrinsic page pointer
			/**/
			Assert( prmpage->itagPgptr == itagNil );
			}
		else
			{
			pssib->itag = prmpage->itagPgptr;
			PMDelete( pssib );
			}

		/*	set *pfRmParent
		/**/
		*pfRmParent = ( cbSibling == 0 &&
			fFatherFOP &&
			FPMEmptyPage( pssib ) );
				
		/*	if only one remaining son then convert to intrinsic
		/*	page pointer node.
		/**/
		if ( cbSibling == 1 && !fFatherFOP )
			{
			/*	make other sibling intrinsic page pointer node
			/**/
			Assert( prmpage->itagFather != itagFOP );
			PcsrCurrent( pfucb )->itag = prmpage->itagFather;
			NDMakeSonIntrinsic( pfucb );
			}

		BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
		BFUnpin( pfucb->ssib.pbf );
		}

	return;
	}


/*	delete node is called by bookmark clean up to delete *visible* nodes
/*	that have been flagged as deleted.  This operation is logged
/*	for redo only.
/**/
ERR ErrNDDeleteNode( FUCB *pfucb )
	{
	ERR 	err;
	CSR 	*pcsr = PcsrCurrent( pfucb );
	SSIB	*pssib = &pfucb->ssib;

	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
	Assert( !( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) ) );

	/*	write latch page from dirty until log completion
	/**/
	BFPin( pfucb->ssib.pbf );
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	/*	dirty page buffer
	/**/
	PMDirty( pssib );

	NDDeleteSon( pfucb );

	/*	delete the son node
	/**/
	pssib->itag = pcsr->itag;
#ifdef DEBUG
	NDGet( pfucb, pcsr->itag );
	Assert( fRecovering || FNDDeleted( *pssib->line.pb ) );
#endif
	PMDelete( pssib );

	/* if log fail return to caller, system should crash by the caller
	/**/
	err = ErrLGDelete( pfucb );
	NDLGCheckPage( pfucb );
	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
	BFUnpin( pfucb->ssib.pbf );

	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
	return err;
	}


ERR ErrNDReplaceWithLink( FUCB *pfucb, SRID sridLink )
	{
	ERR 	err = JET_errSuccess;
	CSR 	*pcsr = PcsrCurrent( pfucb );
	SSIB	*pssib = &pfucb->ssib;

	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
	Assert( !( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) ) );

	/*	write latch page from dirty until log completion
	/**/
	BFPin( pfucb->ssib.pbf );
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	/*	dirty page buffer
	/**/
	PMDirty( pssib );

	PMReplaceWithLink( pssib, sridLink );

	NDDeleteSon( pfucb );

	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
	BFUnpin( pfucb->ssib.pbf );

	return err;
	}


VOID NDResetItemVersion( FUCB *pfucb )
	{
	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
	AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );
	Assert( PcsrCurrent( pfucb )->isrid >= 0 );

 	/*	dirty page buffer. but no increment ulDBTime since not logged and
	/*	not affect directory cursor timestamp check.
	/**/
	BFSetDirtyBit( pfucb->ssib.pbf );

	ITEMResetVersion( *( (UNALIGNED SRID *)( pfucb->lineData.pb ) + PcsrCurrent( pfucb )->isrid ) );
	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
	}


VOID NDSetItemDelete( FUCB *pfucb )
	{
	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
	AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );
	Assert( PcsrCurrent( pfucb )->isrid >= 0 );

	/*	write latch page from dirty until log completion
	/**/
	BFPin( pfucb->ssib.pbf );
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	PMDirty( &pfucb->ssib );

	ITEMSetDelete( *( (UNALIGNED SRID *)( pfucb->lineData.pb ) + PcsrCurrent( pfucb )->isrid ) );
	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
	
	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
	BFUnpin( pfucb->ssib.pbf );

	return;
	}


VOID NDResetItemDelete( FUCB *pfucb )
	{
	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
	AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );
	Assert( PcsrCurrent( pfucb )->isrid >= 0 );

	/*	write latch page from dirty until log completion
	/**/
	BFPin( pfucb->ssib.pbf );
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	PMDirty( &pfucb->ssib );

	ITEMResetDelete( *( (UNALIGNED SRID *)( pfucb->lineData.pb ) + PcsrCurrent( pfucb )->isrid ) );
	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );

	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
	BFUnpin( pfucb->ssib.pbf );

	return;
	}


ERR ErrNDInsertWithBackLink(
	FUCB		*pfucb,
	BYTE 		bFlags,
	KEY 		const *pkey,
	LINE	 	*plineSonTable,
	SRID	 	sridBackLink,
	LINE 		*plineData )
	{
	ERR		err;
	SSIB   	*pssib = &pfucb->ssib;
	LINE   	rgline[6];
	INT		cline = 0;

	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
	Assert( !FNDFDPPtr( bFlags ) || (
		plineData != NULL && plineData->cb == sizeof( PGNO ) &&
		( *( UNALIGNED PGNO * )plineData->pb & 0xff000000 ) == 0 &&
		( *( UNALIGNED PGNO * )plineData->pb & 0x00ffffff ) != 0 ) );
	Assert( PgnoOfSrid( sridBackLink ) != pgnoNull );
	Assert( ItagOfSrid( sridBackLink ) != 0 );

	/* set node header
	/**/
	NDSetBackLink( bFlags );
	rgline[cline].pb = &bFlags;

	/* set key length
	/**/
	rgline[cline++].cb = 1;
	rgline[cline].pb = ( BYTE * ) &pkey->cb;
	rgline[cline++].cb = 1;

	/* set key
	/**/
	if ( !FKeyNull( pkey ) )
		{
		rgline[cline].pb = pkey->pb;
		rgline[cline++].cb = pkey->cb;
		}

	Assert( !FLineNull( plineSonTable ) || FNDNullSon( bFlags ) );

	/* set son table
	/**/
	if ( !FLineNull( plineSonTable ) )
		{
		Assert( FNDSon( bFlags ) );
		rgline[cline].pb = plineSonTable->pb;
		rgline[cline++].cb = plineSonTable->cb;
		}

	/* set back link */
	rgline[cline].pb = ( BYTE * )&sridBackLink;
	rgline[cline++].cb = sizeof( sridBackLink );

	/* set data
	/**/
	if ( !FLineNull( plineData ) )
		{
		rgline[cline++] = *plineData;
		}

	/*	write latch page from dirty until log completion
	/**/
	BFPin( pfucb->ssib.pbf );
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	/*	dirty page buffer
	/**/
	PMDirty( pssib );

	err = ErrPMInsert( pssib, rgline, cline );
	PcsrCurrent( pfucb )->itag = pssib->itag;

	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
	BFUnpin( pfucb->ssib.pbf );
	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );

	return err;
	}


VOID NDGetBackLink( FUCB *pfucb, PGNO *ppgno, INT *pitag )
	{
	Assert( FReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
	AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );
	Assert( FNDBackLink( *pfucb->ssib.line.pb ) );

	*ppgno = PgnoOfSrid( *(UNALIGNED SRID *)PbNDBackLink( pfucb->ssib.line.pb ) );
	*pitag = ItagOfSrid( *(UNALIGNED SRID *)PbNDBackLink( pfucb->ssib.line.pb ) );
	}


/* given a itag, find its corresponding itagFather and ibSon
 */
VOID NDGetItagFatherIbSon(
	INT *pitagFather,
	INT *pibSon,
	PAGE *ppage,
	INT itag )
	{
	INT itagFather;
	INT ibSon;
	
	/* current node is not FOP - scan all lines to find its father */
	Assert( itag != itagFOP );
	
	for ( itagFather = 0; ; itagFather++ )
		{
		TAG tag;
		BYTE *pbNode;
		BYTE *pbSonTable;
		INT cbSonTable;
		BYTE *pitagSon;
		
		Assert( itagFather < ppage->pghdr.ctagMac );
		
		if ( TsPMTagstatus( ppage, itagFather ) != tsLine )
			continue;

		tag = ppage->rgtag[ itagFather ];
		Assert( tag.cb != 0 );
		pbNode = (BYTE *)ppage + tag.ib;
		
		if ( FNDNullSon(*pbNode) )
			continue;
		
//		if ( FNDDeleted(*pbNode) )
//			continue;
		
		/* scan son table looking for current node	*/
		/* ptr to son table */
		pbSonTable = PbNDSonTable( pbNode );
		cbSonTable = CbNDSonTable( pbSonTable );
		pitagSon = pbSonTable + 1;
		for ( ibSon = 0; ibSon < cbSonTable; ibSon++, pitagSon++ )
			if ( *pitagSon == itag )
				{
				*pitagFather = itagFather;
				*pibSon = ibSon;
				return;
				}
		}
		
	*pitagFather = itagNil;
	*pibSon = ibSonNull;
	}


#ifdef DEBUG
/*	checks root tree for key order
/**/
VOID NDCheckPage( FUCB *pfucb )
	{
	SSIB  	*pssib = &pfucb->ssib;
	PAGE  	*ppage;
	TAG		*rgbtag;
	BYTE  	*pbNode;
	BYTE  	*pbSonTable;
	BYTE  	*pitagStart;
	BYTE  	*pitagMax;
	BYTE  	*pitagMid;
	INT		s;
	INT		sDiff;

	/*	may be called on non-leaf page.
	/**/
//	Assert( FReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );

	/*	cache FOP
	/**/
	NDGet( pfucb, itagFOP );

	/*	initialize variables
	/**/
	ppage = pssib->pbf->ppage;
	rgbtag = ( TAG * ) ( ( BYTE * )ppage->rgtag );
	pbNode = ( BYTE * ) ( pssib->line.pb );
	pbSonTable = ( BYTE * ) pbNode + pbNode[1] + 2;
	pitagStart = pbSonTable + 1;
	pitagMax = pbSonTable + *pbSonTable;
	/*	invisible sons have last page pointer key NULL since it is never compared
	/**/
	if ( FNDVisibleSons( *pbNode ) )
		pitagMax++;

	/*	validate key order
	/**/
	for ( pitagMid = pitagStart + 1; pitagMid < pitagMax; pitagMid++ )
		{
		BYTE	*st0 = ( BYTE * ) ppage + rgbtag[*( pitagMid - 1 )].ib + 1;
		BYTE	*st1 = ( BYTE * ) ppage + rgbtag[*pitagMid].ib + 1;
		sDiff = *st1 - *st0;
		s = memcmp( st1 + 1, st0 + 1, sDiff < 0 ? ( INT )*st1 : ( INT )*st0 );
		s = s ? s : sDiff;
		Assert( s >= 0 );
		}

	return;
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\page.c ===
#include "config.h"

#include <string.h>

#include "daedef.h"
#include "ssib.h"
#include "pib.h"
#include "fmp.h"
#include "page.h"
#include "node.h"
#include "fucb.h"
#include "stapi.h"
#include "stint.h"
#include "logapi.h"
#include "log.h"
#include "util.h"

DeclAssertFile;					/* Declare file name for assert macros */

LOCAL VOID PMIInsertReorganize( SSIB *pssib, LINE *rgline, INT cline );
LOCAL ERR ErrPMIReplaceReorganize( SSIB *pssib, LINE *rgline, INT cline, INT cbDif );


#ifdef DEBUG
VOID CheckPgno( PAGE *ppage, PN pn )
	{
	ULONG ulPgno;

	LFromThreeBytes(ulPgno, (ppage)->pgnoThisPage);
	Assert( ulPgno == PgnoOfPn(pn));
	Assert( ulPgno != 0 );
	}
#endif


#ifdef DEBUG
VOID CheckPage( PAGE *ppage )
	{
	Assert( (ppage)->pghdr.cbFreeTotal >= 0 );
	Assert( (ppage)->pghdr.cbFreeTotal < cbPage );
	Assert( (ppage)->pghdr.ibLastUsed >=
		( (INT)sizeof(PGHDR) + (ppage)->pghdr.ctagMac * (INT)sizeof(TAG) ) );
	Assert( (ppage)->pghdr.ibLastUsed <= cbPage - (INT)sizeof(PGTRLR) );
	Assert( (ppage)->pghdr.ctagMac >= 0 );
	Assert( (ppage)->pghdr.ctagMac <= 256 );
	Assert( (ppage)->pghdr.itagFree == itagNil ||
		(ppage)->pghdr.itagFree < (ppage)->pghdr.ctagMac );
	}
#else
#define CheckPage( ppage )
#endif


//+api---------------------------------------------------------------------
//
//	PMNewPage
//	========================================================================
//
//	PMNewPage( PAGE *ppage, PGNO pgno, PGTYP pgtyp, PGNO pgnoFDP )
//
//	PMNewPage takes a buffer and initializes it for use by other
//	page manager functions.
//
//	PARAMETERS	ppage 		pointer to buffer to be initialized
//				pgno  		pgno of page (ppage->pgnoThisPage)
//
//-------------------------------------------------------------------------

VOID PMNewPage( PAGE *ppage, PGNO pgno, PGTYP pgtyp, PGNO pgnoFDP )
	{
	#ifdef DEBUG
		memset( ppage, '_', sizeof(PAGE) );
	#endif
	memset( ppage, 0, sizeof(PGHDR) );
	ppage->pghdr.ibLastUsed		= cbPage - sizeof(PGTRLR);

	ppage->pghdr.cbFreeTotal	= CbLastFreeSpace(ppage);
	Assert( ppage->pghdr.cbFreeTotal >= 0 && ppage->pghdr.cbFreeTotal < cbPage );
	Assert( ppage->pghdr.ctagMac == 0 );
	ppage->pghdr.itagFree		= itagNil;

	/*	reset "last-flushed" counter
	/**/
	Assert( ppage->pghdr.ulDBTime == 0 );
	/* ThreeBytesFromL( ppage->pghdr.pgnoPrev, 0 ); */
	/* ThreeBytesFromL( ppage->pghdr.pgnoNext, 0 ); */

	SetPgno( ppage, pgno );
	PMSetPageType( ppage, pgtyp );
	PMSetPgnoFDP( ppage, pgnoFDP );
	}



//+api---------------------------------------------------------------------
//
//	ErrPMInsert
//	===========================================================================
//
//	ErrPMInsert( SSIB *pssib, LINE *rgline, INT cline )
//
//	ErrPMInsert concatenates the buffers (pointed to by rgline) and inserts
//	them into the page indicated by pssib.  ErrPMInsert is guaranteed to work
//	if a tag can be allocated, and there is enough free room in page.  If page
//	is too fragmented to insert new lines, it will be reorganized.  NB: this
//	implies that real pointers into a page may be invalid across calls to
//	ErrPMInsert (the same is true for ErrPMUpdate).
//
//	PARAMETERS  pssib->ppage		points to page to insert into
//			   	rgline				LINES (buffers) to be inserted into page
//			   	cline  				number of LINES in rgline
//
//	RETURNS
//		JET_errSuccess;
//		errPMOutOfPageSpace			not enough free space in page
//		errPMTagsUsedUp				if !fNoTagLimit
//			   						no free tags ( !fUseNewTag )
//			   						no new tags ( fUseNewTag )
//									  	
//-------------------------------------------------------------------------

INT ItagPMQueryNextItag( SSIB *pssib )
	{
	PAGE	*ppage = pssib->pbf->ppage;

	CheckSSIB( pssib );

	if ( ppage->pghdr.itagFree == itagNil )
		{
#ifdef DEBUG
		if ( ppage->pghdr.ctagMac == ctagMax )
			return itagNil;
#endif
		Assert( ppage->pghdr.ctagMac < ctagMax );
		return ppage->pghdr.ctagMac;
		}
	else
		{
		return ppage->pghdr.itagFree;
		}
	}


ERR ErrPMInsert( SSIB *pssib, LINE *rgline, INT cline )
	{
	PAGE	*ppage = pssib->pbf->ppage;
	LINE	*pline;
	LINE	*plineMax;
	BYTE	*pb;
	INT		ib;
	INT		cb;
	INT		itag;

	CheckSSIB( pssib );
	CheckPage( ppage );
	AssertBFDirty( pssib->pbf );
	Assert( cline > 0 );
	Assert( !( FBFWriteLatchConflict( pssib->ppib, pssib->pbf ) ) );

	/*	calculate size of line
	/**/
	cb = 0;
	plineMax = rgline + cline;
	for ( pline = rgline; pline < plineMax; pline++ )
		cb += pline->cb;
	Assert( cb != 0 );

	if ( ppage->pghdr.itagFree == itagNil )
		{
		if ( ppage->pghdr.ctagMac == ctagMax )
			return errPMTagsUsedUp;

		if ( cb + (INT) sizeof(TAG) > ppage->pghdr.cbFreeTotal )
			return errPMOutOfPageSpace;

		/*	allocate tag from end of tag array
		/*	if new tag overlaps data then reorganize
		/**/
		pssib->itag = itag = ppage->pghdr.ctagMac;
		if ( (INT) sizeof(PGHDR) + (INT) sizeof(TAG) * ( itag + 1 ) + cb > ppage->pghdr.ibLastUsed )
			{
			PMIInsertReorganize( pssib, rgline, cline );
			goto Succeed;
			}

		++ppage->pghdr.ctagMac;
		ppage->pghdr.cbFreeTotal -= (SHORT)( cb + sizeof(TAG) );
		Assert( ppage->pghdr.cbFreeTotal >= 0 && ppage->pghdr.cbFreeTotal < cbPage );
		}
	else
		{
		if ( cb > ppage->pghdr.cbFreeTotal )
			return errPMOutOfPageSpace;

		pssib->itag =
		itag = ppage->pghdr.itagFree;
		Assert( itag < ppage->pghdr.ctagMac );
		ppage->pghdr.itagFree = ppage->rgtag[ itag ].ib;

		if ( (INT) CbLastFreeSpace(ppage) < cb )
			{
			PMIInsertReorganize( pssib, rgline, cline );
			goto Succeed;
			}

		ppage->pghdr.cbFreeTotal -= (SHORT)cb;
		Assert( ppage->pghdr.cbFreeTotal >= 0 && ppage->pghdr.cbFreeTotal < cbPage );
		}

	ppage->pghdr.ibLastUsed -= (SHORT)cb;
	ib = ppage->pghdr.ibLastUsed;

	Assert( (UINT) ib < (UINT) sizeof( PAGE ) );
	Assert( (UINT) sizeof(PGHDR) + ppage->pghdr.ctagMac * (SHORT) sizeof(TAG)
		<= (UINT) ib );

	Assert( itag < ppage->pghdr.ctagMac );
	Assert( (SHORT) sizeof(PGHDR) + ppage->pghdr.ctagMac * (SHORT) sizeof(TAG)
		<= ppage->pghdr.ibLastUsed );

	/*	add line
	/**/
	pssib->line.pb = pb = (BYTE *)ppage + ib;
	for ( pline = rgline; pline < plineMax; pline++ )
		{
		Assert( pline->cb < cbPage );
		memcpy( pb, pline->pb, pline->cb );
		Assert( (UINT) ib < (UINT) sizeof( PAGE ) );
		pb += pline->cb;
		}

	PtagFromIbCb( &ppage->rgtag[itag], ib, cb);
	Assert( (UINT) ib < (UINT) sizeof( PAGE ) );

	/*	set return values
	/**/
	Assert( pssib->itag == itag );
	pssib->line.cb = cb;
	Assert( pssib->line.pb == (BYTE *)ppage + ib );

	Assert( pssib->itag < ctagMax );
	
Succeed:

#ifdef DEBUG
	{
	/*	if intrinsic son, then node space should exist for pgno in
	/*	son table, and first byte of pgno should be 0.
	/**/
	if ( !pssib->fDisableAssert &&
		pssib->itag != 0 &&
		( ( *pssib->line.pb & 0x08 ) != 0 ) &&
		!( ( ( *pssib->line.pb & 0x04 ) != 0 ) ) &&
		*(pssib->line.pb + 2 + *( pssib->line.pb + 1 )) ==  1 )
		{
		Assert( ( ( *pssib->line.pb & 0x20 ) != 0 ) || pssib->line.cb != 9 );
//		Assert( *(pssib->line.pb + 4 + *( pssib->line.pb + 1 )) != 0 );
		}
	}
#endif

	AssertBTFOP(pssib);
	CheckPage( ppage );
	return JET_errSuccess;
	}



//+api------------------------------------------------------------------------
//
//	ErrPMReplace
//	===========================================================================
//
//	ErrPMReplace( SSIB *pssib, LINE *rgline, INT cline )
//
//	ErrPMReplace will replace the contents of line pssib->itag with the
//	contents of the buffers indicated by rgline.
//
//	SEE ALSO ErrPMInsert
//
//----------------------------------------------------------------------------
ERR ErrPMReplace( SSIB *pssib, LINE *rgline, INT cline )
	{
	ERR		err;
	PAGE	*ppage = pssib->pbf->ppage;
	INT		cbLine;
	INT		cbDif;
	INT		ibReplace;
	INT		cbReplace;
	LINE	*pline;
	LINE	*plineMax = rgline + cline;

	#ifdef DEBUG
		INT	itag = pssib->itag;
		Assert( TsPMTagstatus( ppage, itag ) == tsLine );
	#endif

	#ifdef DEBUG
		{
		BYTE	bT = *rgline[0].pb;
		BOOL	fSon = (bT & 0x08);
		BOOL	fVis = (bT & 0x04);
//		Assert( pssib->itag != 0 || fVis || fSon );
		}
	#endif

	CheckSSIB( pssib );
	CheckPage( ppage );
	AssertBFDirty( pssib->pbf );
	Assert( cline > 0 );
	Assert( pssib->itag < ppage->pghdr.ctagMac );
	Assert( !( FBFWriteLatchConflict( pssib->ppib, pssib->pbf ) ) );

	cbLine = 0;
	for ( pline = rgline; pline < plineMax; pline++ )
		{
		cbLine += pline->cb;
		}

	IbCbFromPtag( ibReplace, cbReplace, &ppage->rgtag[pssib->itag] );

	/*	tag should not be of deleted line
	/**/
	Assert( cbReplace > 0 );

	cbDif = cbLine - cbReplace;

	/*	if new line is same size or smaller then update in place
	/*	dont reclaim space at end of line if new line is smaller
	/**/
	if ( cbDif == 0 )
		{
		BYTE	*pb = pssib->line.pb = (BYTE *)ppage + ibReplace;
		for ( pline = rgline; pline < plineMax; pline++ )
			{
			Assert( pline->cb < cbPage );
			memcpy( pb, pline->pb, pline->cb );
			pb += pline->cb;
			}
		pssib->line.cb = cbLine;
		goto Succeed;
		}

	if ( cbDif < 0 )
		{
		BYTE	*pb = pssib->line.pb = (BYTE *)ppage + ibReplace;
		for ( pline = rgline; pline < plineMax; pline++ )
			{
			Assert( pline->cb < cbPage );
			memcpy( pb, pline->pb, pline->cb );
			pb += pline->cb;
			}
		pssib->line.cb = cbLine;
		PtagFromIbCb( &ppage->rgtag[pssib->itag], ibReplace, cbLine );
		ppage->pghdr.cbFreeTotal -= (SHORT)cbDif;
		Assert( ppage->pghdr.cbFreeTotal >= 0 && ppage->pghdr.cbFreeTotal < cbPage );
		goto Succeed;
		}

	/*	if line is ibLastUsed then try to copy/overwrite line.
	/*	Note that this can only be done when buffer is not write
	/*	latched, since overwrite will modify data that pointer may
	/*	be cached on.
	/*
	/*	Note that we must check cbFreeTotal since some space may be
	/*	reserved for rollback.
	/**/
	if ( ibReplace == ppage->pghdr.ibLastUsed &&
		(INT) CbLastFreeSpace(ppage) >= cbDif &&
		(INT) ppage->pghdr.cbFreeTotal >= cbDif )
		{
		BYTE	*pb;

		Assert( (SHORT) sizeof(PGHDR) + ppage->pghdr.ctagMac * (SHORT) sizeof(TAG) <= ppage->pghdr.ibLastUsed );
		Assert( cbDif > 0 );
		pssib->line.pb = pb = (BYTE *)ppage + ibReplace - cbDif;
		ppage->pghdr.ibLastUsed -= (SHORT)cbDif;
		ppage->pghdr.cbFreeTotal -= (SHORT)cbDif;
		Assert( ppage->pghdr.cbFreeTotal >= 0 && ppage->pghdr.cbFreeTotal < cbPage );

		for ( pline = rgline; pline < plineMax; pline++ )
			{
			Assert( pline->cb < cbPage );
			memcpy( pb, pline->pb, pline->cb );
			pb += pline->cb;
			}

		/*	set return values
		/**/
		pssib->line.cb = cbLine;
		PtagFromIbCb( &ppage->rgtag[pssib->itag], ibReplace - cbDif, cbLine );
		goto Succeed;
		}

	/*	try to move line to ibLastUsed
	/**/
	if ( (INT) CbLastFreeSpace(ppage) >= cbLine &&
		ppage->pghdr.cbFreeTotal >= cbLine )
		{
		INT	ib;
		BYTE	*pb;

		Assert( cbDif > 0 );
		ppage->pghdr.cbFreeTotal -= (SHORT)cbDif;
		Assert( ppage->pghdr.cbFreeTotal >= 0 && ppage->pghdr.cbFreeTotal < cbPage );
		ppage->pghdr.ibLastUsed -= (SHORT)cbLine;
		ib = ppage->pghdr.ibLastUsed;
		Assert( (SHORT) sizeof(PGHDR) + ppage->pghdr.ctagMac * (SHORT) sizeof(TAG) <= ppage->pghdr.ibLastUsed );

		/*	insert line
		/**/
		pssib->line.pb = pb = (BYTE *)ppage + ib;
		for ( pline = rgline; pline < plineMax; pline++ )
			{
			Assert( pline->cb < cbPage );
			memcpy( pb, pline->pb, pline->cb );
			pb += pline->cb;
			}

		PtagFromIbCb( &ppage->rgtag[pssib->itag], ib, cbLine );

		/*	set return values
		/**/
		pssib->line.cb = cbLine;
		Assert( pssib->line.pb == (BYTE *)ppage + ib );
		goto Succeed;
		}

	/*	if insufficient space return error
	/**/
	Assert( cbDif > 0 );
	if ( ppage->pghdr.cbFreeTotal < cbDif )
		{
		return errPMOutOfPageSpace;
		}

	/*	replace line while reorganizing page
	/**/
	err = ErrPMIReplaceReorganize( pssib, rgline, cline, cbDif );
	CheckPage( ppage );
	return err;
	
Succeed:

#ifdef DEBUG
	{
	/*	if intrinsic son, then node space should exist for pgno in
	/*	son table, and first byte of pgno should be 0.
	/**/
	if ( !pssib->fDisableAssert &&
		pssib->itag != 0 &&
		( ( *pssib->line.pb & 0x08 ) != 0 ) &&
		!( ( ( *pssib->line.pb & 0x04 ) != 0 ) ) &&
		*(pssib->line.pb + 2 + *( pssib->line.pb + 1 )) ==  1 )
		{
		Assert( pssib->line.cb == 8 || (int)pssib->line.cb >= (int)(1 + *( pssib->line.pb + 1 ) + 1 + 4 ) );
//		Assert( ( 0xff000000 & (*(PGNO *)(pssib->line.pb + 1 + *( pssib->line.pb + 1 ) + 1)) ) == 0 );
		}
	}
#endif

	AssertBTFOP(pssib);
	CheckPage( ppage );
	return JET_errSuccess;
	}



//+api------------------------------------------------------------------------
//
//	PMDelete
//	===========================================================================
//
//	PMDelete( PAGE *ppage, INT itag )
//
//	PMDelete will free up space allocated to a line of data in a PAGE.
//
//----------------------------------------------------------------------------

VOID PMDelete( SSIB *pssib )
	{
	PAGE	*ppage = pssib->pbf->ppage;
	INT		itag = pssib->itag;
	INT		ib;
	INT		cb;

	CheckSSIB( pssib );
	CheckPage( ppage );
	AssertBFDirty( pssib->pbf );
	Assert( itag < ppage->pghdr.ctagMac );
	Assert( TsPMTagstatus( ppage, itag ) == tsLine );
	IbCbFromPtag( ib, cb, &ppage->rgtag[itag] );
	Assert( cb );

	//	FREE DATA
	if ( ib == ppage->pghdr.ibLastUsed )
		{
		ppage->pghdr.ibLastUsed += (SHORT)cb;
		}
	ppage->pghdr.cbFreeTotal += (SHORT)cb;
	Assert( ppage->pghdr.cbFreeTotal >= 0 && ppage->pghdr.cbFreeTotal < cbPage );

	//	FREE TAG
	cb = 0;
	ib = ppage->pghdr.itagFree;
	PtagFromIbCb( &ppage->rgtag[itag], ib, cb );
	ppage->pghdr.itagFree = (SHORT)itag;
	Assert( ppage->pghdr.itagFree < ppage->pghdr.ctagMac );

	CheckPage( ppage );
	return;
	}


//+api------------------------------------------------------------------------
//	ErrPMGet
//	===========================================================================
//
//	ErrPMGet( SSIB *pssib, INT itag )
//
//	ErrPMGet will calculate and return a real pointer to a given line within
//	the page.
//
//	PARAMETERS		pssib->pbf->ppage		ppage to read line from
//						itag						itag of line
//
//----------------------------------------------------------------------------
ERR ErrPMGet( SSIB *pssib, INT itag )
	{
	PAGE	*ppage = pssib->pbf->ppage;
	INT		ib;
	INT		cb;

#ifdef DEBUG
	PGNO pgnoP;
	PGNO pgnoN;
	LFromThreeBytes( pgnoP, pssib->pbf->ppage->pghdr.pgnoPrev );
	Assert(pgnoP != PgnoOfPn(pssib->pbf->pn));
	LFromThreeBytes( pgnoN, pssib->pbf->ppage->pghdr.pgnoNext );
	Assert(pgnoN != PgnoOfPn(pssib->pbf->pn));
	Assert(pgnoN == 0 || pgnoN != pgnoP);
#endif

	CheckSSIB( pssib );
	CheckPage( ppage );
	if ( itag >= ppage->pghdr.ctagMac )
		{
		return errPMItagTooBig;
		}
	IbCbFromPtag( ib, cb, &ppage->rgtag[itag] );
	if ( !cb )
		{
		return errPMRecDeleted;
		}
	//	UNDONE:	fix goto bookmark logic and remove line check
	if ( TsPMTagstatus( ppage, itag ) != tsLine )
		{
		return errPMRecDeleted;
		}
	Assert( TsPMTagstatus( ppage, itag ) == tsLine );
	pssib->line.cb = cb;
	pssib->line.pb = (BYTE *)ppage + ib;
	return JET_errSuccess;
	}


//======Local Routines ====================================================

#ifdef MULTI_PROCESS
SemDefine( semPMReorganize );
#endif

static BYTE	rgbCopy[ cbPage - sizeof(PGTRLR) ];


LOCAL VOID PMIInsertReorganize( SSIB *pssib, LINE *rgline, INT cline )
	{
	UINT 	ibT = sizeof( rgbCopy );
	PAGE 	*ppage = pssib->pbf->ppage;
	TAG		*ptag;
	TAG		*ptagMax;
	INT		ibAdd;
	INT		cbAdd;
	LINE  	*pline;

	/* ulDBTime of the page maybe not effective any more,
	 * lets reset it again
	 */
	BFDirty( pssib->pbf );

	#ifdef MULTI_PROCESS
	SgSemRequest( semPMReorganize );
	#endif

	/*	add line
	/**/
	cbAdd = 0;
	for ( pline = rgline + cline - 1; pline >= rgline; pline-- )
		{
		ibT -= pline->cb;
		Assert( ibT <= sizeof(rgbCopy) );
		Assert( pline->cb < cbPage );
		memcpy( rgbCopy + ibT, pline->pb, pline->cb );
		cbAdd += pline->cb;
		}
	ibAdd = ibT;

	/*	copy and compact existing page lines
	/**/
	ptag = ppage->rgtag;
	ptagMax = ptag + ppage->pghdr.ctagMac;
	for ( ; ptag < ptagMax; ptag++ )
		{
		INT ib, cb;

		IbCbFromPtag( ib, cb, ptag );
		if ( ( *(LONG *)ptag & bitLink ) == 0 && cb > 0 )
			{
			ibT -= cb;
			Assert( ibT <= sizeof(rgbCopy) );
			Assert( cb >= 0 && cb < cbPage );
			memcpy( rgbCopy + ibT, (BYTE *)ppage + ib, cb );
			ib = ibT;
			PtagFromIbCb( ptag, ib, cb );
			}
		}

	Assert( ibT <= sizeof(rgbCopy) );
	memcpy( (BYTE *)ppage + ibT, rgbCopy + ibT, sizeof(rgbCopy) - ibT );

	#ifdef MULTI_PROCESS
	SgSemRelease( semPMReorganize );
	#endif

	PtagFromIbCb( &ppage->rgtag[pssib->itag], ibAdd, cbAdd );

	/* set page header
	/**/
	ppage->pghdr.ibLastUsed = (SHORT)ibT;
	if ( pssib->itag == ppage->pghdr.ctagMac )
		{
		ppage->pghdr.ctagMac++;
		ppage->pghdr.cbFreeTotal -= (SHORT)(cbAdd + sizeof(TAG));
		Assert( ppage->pghdr.cbFreeTotal >= 0 && ppage->pghdr.cbFreeTotal < cbPage );
		}
	else
		{
		ppage->pghdr.cbFreeTotal -= (SHORT)cbAdd;
		Assert( ppage->pghdr.cbFreeTotal >= 0 && ppage->pghdr.cbFreeTotal < cbPage );
		}

	/*	set return values
	/**/
	pssib->line.cb = cbAdd;
	pssib->line.pb = (BYTE *) ppage + ibAdd;

	return;
	}


LOCAL ERR ErrPMIReplaceReorganize( SSIB *pssib, LINE *rgline, INT cline, INT cbDif )
	{
	UINT  	ibT				= sizeof( rgbCopy );
	PAGE  	*ppage			= pssib->pbf->ppage;
	TAG		*ptagReplace	= &ppage->rgtag[pssib->itag];
	TAG		*ptag;
	TAG		*ptagMax;
	INT		ibReplace;
	INT		cbReplace;
	LINE  	*pline;

	/*	ulDBTime of the page maybe not effective any more,
	/*	lets reset it again
	/**/
	BFDirty( pssib->pbf );

	#ifdef MULTI_PROCESS
	SgSemRequest( semPMReorganize );
	#endif

	/*	insert replace line in reorganize buffer
	/**/
	cbReplace = 0;
	for ( pline = rgline + cline - 1; pline >= rgline; pline-- )
		{
		ibT -= pline->cb;
		Assert( ibT <= sizeof(rgbCopy) );
		Assert( pline->cb < cbPage );
		memcpy( rgbCopy + ibT, pline->pb, pline->cb );
		cbReplace += pline->cb;
		}
	ibReplace = ibT;

	/*	copy and compact existing page lines, but not the line being
	/*	replaced since it has already been copied.
	/**/
	ptag = ppage->rgtag;
	ptagMax = ptag + ppage->pghdr.ctagMac;
	for ( ; ptag < ptagMax; ptag++ )
		{
		INT ib, cb;

		if ( ptag == ptagReplace )
			{
			PtagFromIbCb( ptag, ibReplace, cbReplace );
			continue;
			}

		IbCbFromPtag( ib, cb, ptag );
		if ( ( *(LONG *)ptag & bitLink ) == 0 && cb > 0 )
			{
			ibT -= cb;
			Assert( ibT <= sizeof(rgbCopy) );
			memcpy( rgbCopy + ibT, (BYTE *)ppage + ib, cb );
			ib = ibT;
			PtagFromIbCb( ptag, ib, cb );
			}
		}

	Assert( ibT <= sizeof(rgbCopy) );
	memcpy( (BYTE *)ppage + ibT, rgbCopy + ibT, sizeof(rgbCopy) - ibT );

	#ifdef MULTI_PROCESS
	SgSemRelease( semPMReorganize );
	#endif

	/* set page header
	/**/
	ppage->pghdr.ibLastUsed = (SHORT)ibT;
	ppage->pghdr.cbFreeTotal -= (SHORT)cbDif;
	Assert( ppage->pghdr.cbFreeTotal >= 0 && ppage->pghdr.cbFreeTotal < cbPage );

	/*	set return values
	/**/
	pssib->line.cb = cbReplace;
	pssib->line.pb = (BYTE *) ppage + ibReplace;

#ifdef DEBUG
	{
	/*	if intrinsic son, then node space should exist for pgno in
	/*	son table, and first byte of pgno should be 0.
	/**/
	if ( !pssib->fDisableAssert &&
		pssib->itag != 0 &&
		( ( *pssib->line.pb & 0x08 ) != 0 ) &&
		!( ( ( *pssib->line.pb & 0x04 ) != 0 ) ) &&
		*(pssib->line.pb + 2 + *( pssib->line.pb + 1 )) ==  1 )
		{
		Assert( pssib->line.cb == 8 || (int)pssib->line.cb >= (int)(1 + *( pssib->line.pb + 1 ) + 1 + 4 ) );
//		Assert( ( 0xff000000 & (*(PGNO *)(pssib->line.pb + 1 + *( pssib->line.pb + 1 ) + 1)) ) == 0 );
		}
	}
#endif

	return JET_errSuccess;
	}


TS TsPMTagstatus( PAGE *ppage, INT itag )
	{
	TAG	tag;

	Assert( itag < ppage->pghdr.ctagMac );
	tag = ppage->rgtag[itag];
	if ( *(LONG *)&tag & bitLink )
		{
		return tsLink;
		}
	if ( tag.cb == 0 )
		return tsVacant;
	return tsLine;
	}


#ifdef DEBUG
VOID PMSetModified( SSIB *pssib )
	{
	PGTYP	pgtyp;

	CheckSSIB( pssib );
	CheckPage( pssib->pbf->ppage );
	AssertBFDirty( pssib->pbf );
	pgtyp = (PGTYP)PgtypPMSetModified( pssib->pbf->ppage );
	pssib->pbf->ppage->pgtyp = pgtyp;
	CheckPgno( pssib->pbf->ppage, pssib->pbf->pn );
	}


VOID PMResetModified( SSIB *pssib )
	{
	PGTYP	pgtyp;

	CheckSSIB( pssib );
	CheckPage( pssib->pbf->ppage );
	AssertBFDirty( pssib->pbf );
	pgtyp = PgtypPMPageTypeOfPage( pssib->pbf->ppage );
	pssib->pbf->ppage->pgtyp = pgtyp;
	CheckPgno( pssib->pbf->ppage, pssib->pbf->pn );
	}
#endif


VOID PMGetLink( SSIB *pssib, INT itag, LINK *plink )
	{
	CheckSSIB( pssib );
	CheckPage( pssib->pbf->ppage );
	*plink = *(LINK *)&(pssib->pbf->ppage->rgtag[itag]);
	Assert( *(LONG *)plink & bitLink );
	*(LONG *)plink &= ~bitLink;
	}


VOID PMReplaceWithLink( SSIB *pssib, SRID srid )
	{
	PAGE  	*ppage = pssib->pbf->ppage;
	INT		ib;
	INT		cb;

	CheckSSIB( pssib );
	CheckPage( pssib->pbf->ppage );
	AssertBFDirty( pssib->pbf );
	Assert( pssib->itag != 0 );
	Assert( pssib->itag < ppage->pghdr.ctagMac );
	IbCbFromPtag( ib, cb, &ppage->rgtag[pssib->itag] );
	Assert( cb > 0 );

	/*	free data space
	/**/
	if ( ib == ppage->pghdr.ibLastUsed )
		{
		ppage->pghdr.ibLastUsed += (SHORT)cb;
		}
	ppage->pghdr.cbFreeTotal += (SHORT)cb;
	Assert( ppage->pghdr.cbFreeTotal >= 0 && ppage->pghdr.cbFreeTotal < cbPage );

	/*	convert tag to link
	/**/
	Assert( ( *(LONG *)&srid & bitLink ) == 0 );
	*(SRID *)&ppage->rgtag[pssib->itag] = srid | bitLink;
	}


VOID PMReplaceLink( SSIB *pssib, SRID srid )
	{
	PAGE	*ppage = pssib->pbf->ppage;

	CheckSSIB( pssib );
	CheckPage( pssib->pbf->ppage );
	AssertBFDirty( pssib->pbf );
	Assert( pssib->itag != 0 );
	Assert( pssib->itag < ppage->pghdr.ctagMac );
	Assert( ( *(LONG *)&srid & bitLink ) == 0 );
	Assert( ( *(LONG *)&ppage->rgtag[pssib->itag] & bitLink ) != 0 );
	*(SRID *)&ppage->rgtag[pssib->itag] = srid | bitLink;
	}


VOID PMExpungeLink( SSIB *pssib )
	{
	PAGE  	*ppage = pssib->pbf->ppage;
	TAG		*ptag;
	INT		itag = pssib->itag;

	CheckSSIB( pssib );
	CheckPage( pssib->pbf->ppage );
	AssertBFDirty( pssib->pbf );
	Assert( itag != 0 );
	Assert( itag < ppage->pghdr.ctagMac );

	/*	free tag
	/**/
	ptag = &ppage->rgtag[itag];
	ptag->cb = 0;
	ptag->ib = ppage->pghdr.itagFree;
	ppage->pghdr.itagFree = (SHORT)itag;
	Assert( ppage->pghdr.itagFree < ppage->pghdr.ctagMac );
	}

/* checks if current node is the only node in the page [other than the FOP]
/**/
BOOL FPMLastNodeToDelete( SSIB *pssib )
	{
	INT cFreeTags = CPMIFreeTag( pssib->pbf->ppage );
	INT cUsedTags = ctagMax - cFreeTags;

	CheckSSIB( pssib );
	CheckPage( pssib->pbf->ppage );

#ifdef DEBUG
#define itagFOP	0		// same as in dirapi.h
	Assert( cUsedTags >= 2 );
	if ( cUsedTags == 1 )
		{
		AssertPMGet( pssib, itagFOP );
		}
#endif
	return( cUsedTags == 2 );
	}


/* checks if page has only one line -- that holding FOP
/**/
BOOL FPMEmptyPage( SSIB *pssib )
	{
	INT cFreeTags = CPMIFreeTag( pssib->pbf->ppage );
	INT cUsedTags = ctagMax - cFreeTags;

	CheckSSIB( pssib );
//	CheckPage( pssib->pbf->ppage );
	Assert( cUsedTags >= 1 );

#ifdef DEBUG
#define itagFOP	0		// same as in dirapi.h
	if ( cUsedTags == 1 )
		{
		AssertPMGet( pssib, itagFOP );
		}
#endif

	return( cUsedTags == 1 );
	}


/* returns number of free tags in page
/**/
INT CPMIFreeTag( PAGE *ppage )
 	{
 	INT	citag = ctagMax - ppage->pghdr.ctagMac;
 	INT	itag = ppage->pghdr.itagFree;
 	TAG	*ptag;

//	CheckPage( ppage );

	for (; itag != itagNil; )
 		{
 		citag++;
 		ptag = &ppage->rgtag[itag];
 		Assert( ptag->cb == 0 );
 		itag = ptag->ib;
 		}
 	return ( citag );
 	}


BOOL FPMFreeTag( SSIB *pssib, INT citagReq )
	{
	PAGE *ppage = pssib->pbf->ppage;

	CheckSSIB( pssib );
//	CheckPage( pssib->pbf->ppage );
	
	return ( ppage->pghdr.ctagMac + citagReq <= ctagMax ||
		CPMIFreeTag( ppage ) >= citagReq );
	}


/*	returns count of bytes used for links.  Called by split
/*	to determine total count of data and data node tags in
/*	page for split selection.
/**/
INT CbPMLinkSpace( SSIB *pssib )
	{
	INT		itag;
	INT		cLinks = 0;
	PAGE	*ppage = pssib->pbf->ppage;

	CheckSSIB( pssib );
//	CheckPage( pssib->pbf->ppage );

	for ( itag = 0; itag < ppage->pghdr.ctagMac; itag++ )
		{
		if ( *(LONG *)&ppage->rgtag[itag] & bitLink )
			cLinks++;
		}

	return cLinks*sizeof(TAG);
	}


VOID PMDirty( SSIB *pssib )
	{
	PAGE	*ppage = pssib->pbf->ppage;

	CheckSSIB( pssib );
	CheckPage( pssib->pbf->ppage );

	/* if current transaction is oldest then timestamp the BF
	/**/
	if ( FLGOn() && CmpLgpos( &pssib->pbf->lgposRC, &pssib->ppib->lgposStart ) > 0 )
		pssib->pbf->lgposRC = pssib->ppib->lgposStart;
	BFDirty( pssib->pbf );
	}

//====== Debugging Routines ===============================================

#ifdef DEBUG
VOID AssertPMGet( SSIB *pssib, INT itag )
	{
	ERR		err;
	SSIB 	ssib;

	CheckSSIB( pssib );
	CheckPage( pssib->pbf->ppage );

#ifdef DEBUG
		{
		ULONG ulPgno;
		LFromThreeBytes(ulPgno, pssib->pbf->ppage->pgnoThisPage);
		Assert( ulPgno == PgnoOfPn(pssib->pbf->pn));
		Assert( ulPgno != 0 );
		}
#endif

	ssib.pbf = pssib->pbf;
	err = ErrPMGet( &ssib, itag );
	Assert( err == JET_errSuccess );
	Assert( ssib.line.pb == pssib->line.pb );
	Assert( ssib.line.cb == pssib->line.cb );
	}


VOID PageConsistent( PAGE *ppage )
	{
	INT		cbTotal = 0;
	INT		itag, itagTmp;
	TAG		tag, tagTmp;
	INT		ibStart, ibEnd;
	INT		ibLastUsed = sizeof(PAGE) - sizeof(PGTRLR);
	BYTE	*pbFirstFree = (BYTE *)(&ppage->rgtag[ppage->pghdr.ctagMac]);
	BYTE	*pbLine;

#if DEBUGGING
	{
	ULONG ulTmp;

	LFromThreeBytes(ulTmp, ppage->pgnoThisPage);
	printf("Checking if Page Consistent %lu\n", ulTmp);
	}
#endif

	for ( itag = 0; itag < ppage->pghdr.ctagMac; itag++ )
		{
		tag = ppage->rgtag[itag];
		if ( !tag.cb )
			continue;
		if ( *(LONG *)&tag & bitLink )
			continue;
		Assert( tag.ib > sizeof(PGHDR) );
		Assert( tag.ib < sizeof(PAGE) - sizeof(PGTRLR) );
		Assert( tag.cb <= sizeof(PAGE) - sizeof(PGHDR) - sizeof(PGTRLR) );
		cbTotal += tag.cb;
		ibStart = tag.ib;
		ibEnd = tag.ib + tag.cb;

		if ( ibStart < ibLastUsed )
			ibLastUsed = ibStart;

		pbLine = (BYTE*) ppage + tag.ib;
		Assert( FNDNullSon(*pbLine) || CbNDSon(pbLine) != 0);

		Assert( pbFirstFree <= (BYTE *)ppage + ibStart );
		Assert( ibEnd <= cbPage - sizeof(PGTRLR) );

		/* make sure there is no overlap */
		for ( itagTmp = 0; itagTmp < ppage->pghdr.ctagMac; itagTmp++ )
			{
			tagTmp = ppage->rgtag[itagTmp];
			if ( itag != itagTmp && ( ( *(LONG *)&tagTmp & bitLink ) == 0 ) )
				Assert( tagTmp.ib < ibStart || tagTmp.ib >= ibEnd );
			}
		}

	Assert( ibLastUsed >= ppage->pghdr.ibLastUsed );
	Assert( ibLastUsed - ( pbFirstFree - (BYTE *)ppage) <= ppage->pghdr.cbFreeTotal );

	cbTotal += sizeof(PGHDR);
	cbTotal += sizeof(TAG) * ppage->pghdr.ctagMac;
	cbTotal += ppage->pghdr.cbFreeTotal;
	cbTotal += sizeof(PGTRLR);
	Assert( cbTotal == cbPage );
	}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\logutil.c ===
#include "config.h"

#include <string.h>
#include <direct.h>
#include <stdlib.h>
#include <sys\stat.h>

#ifdef WIN32
#include <io.h>
#else
#include <dos.h>
#include <errno.h>
#endif

#include "daedef.h"
#include "ssib.h"
#include "pib.h"
#include "util.h"
#include "fmp.h"
#include "page.h"
#include "fcb.h"
#include "fucb.h"
#include "stapi.h"
#include "stint.h"
#include "dirapi.h"
#include "nver.h"
#include "logapi.h"
#include "log.h"
#include "fileapi.h"
#include "dbapi.h"


DeclAssertFile;					/* Declare file name for assert macros */

extern INT itibGlobal;

#define 	dbidMinBackup		1		/* min dbid for db that can be backed up */
										/* this leaves out temp_db */

CHAR	szDrive[_MAX_DRIVE];
CHAR	szDir[_MAX_DIR + 1];
CHAR	szExt[_MAX_EXT + 1];
CHAR	szFName[_MAX_FNAME + 1];
CHAR	szLogName[_MAX_PATH + 1];		/* name of log file wiht .log */

CHAR	szBackup [_MAX_PATH + 1];		/* name of backup file with .mdb */
CHAR	szBackupB[_MAX_PATH + 1];		/* name of backup file with .bak */
CHAR	szBackupPath[_MAX_PATH + 1];

CHAR	*szLogCurrent;

CODECONST(CHAR) szSystem[] = "System";
CODECONST(CHAR) szJet[] = "Jet";
CODECONST(CHAR) szTempDir[] = "Temp\\";
CODECONST(CHAR) szJetLog[] = "Jet.Log";
CODECONST(CHAR) szJetTmp[] = "JetTmp";
CODECONST(CHAR) szBakExt[] = ".bak";
CODECONST(CHAR) szLogExt[] = ".log";
CODECONST(CHAR) szMdbExt[] = ".mdb";
CODECONST(CHAR) szPatExt[] = ".pat";
CODECONST(CHAR) szRestoreMap[] = "Restore.Map";

BOOL	fBackupInProgress = fFalse;


LOCAL ERR ErrLGValidateLogSequence( CHAR *szBackup, CHAR *szLog );
LOCAL VOID LGFirstGeneration( CHAR *szSearchPath, INT *piGeneration );
LOCAL ERR ErrLGDeleteInvalidLogs( CHAR *szLogDir, INT iGeneration );


VOID LGMakeName(
	CHAR *szName,
	CHAR *szPath,
	CHAR *szFName,
	CODECONST(CHAR) *szExt )
	{
	CHAR szFNameT[_MAX_FNAME];
	CHAR szExtT[_MAX_EXT];

	_splitpath( szPath, szDrive, szDir, szFNameT, szExtT );
	_makepath( szName, szDrive, szDir, szFName, szExt );
	}


/*	caller has to make sure szDirTemp has enough space for appending "\*"
/**/
LOCAL ERR ErrLGDeleteAllFiles( CHAR *szDirTemp )
	{
	ERR		err;
	CHAR	szT[_MAX_PATH + 1];

#ifdef WIN32
        intptr_t  hFind;
	struct	_finddata_t fileinfo;
#else
	struct	find_t fileinfo;		/* data structure for _dos_findfirst */
									/* and _dos_findnext */
#endif

	strcat( szDirTemp, "*" );

#ifdef WIN32
	fileinfo.attrib = _A_NORMAL;
	hFind = _findfirst( szDirTemp, &fileinfo );
	if ( hFind == -1 )
		{
		/*	done! no file to delete
		/**/
		return JET_errSuccess;
		}
	else
		err = JET_errSuccess;
#else
	err = _dos_findfirst( szDirTemp, _A_NORMAL, &fileinfo );
#endif

	/*	restore szDirTemp
	/**/
	szDirTemp[strlen( szDirTemp ) - 1] = '\0';

	while( err == JET_errSuccess )
		{
		/* not . , and .. and not temp
		/**/
		if ( fileinfo.name[0] != '.' &&
			SysCmpText( fileinfo.name, "temp" ) != 0 )
			{
			strcpy( szT, szDirTemp );
			strcat( szT, fileinfo.name );
			if ( ErrSysDeleteFile( szT ) != JET_errSuccess )
				{
				err = JET_errFailToCleanTempDirectory;
				goto Close;
				}
			}

#ifdef WIN32
		/*	find next backup file
		/**/
		err = _findnext( hFind, &fileinfo );
#else
		/*	find next backup file
		/**/
		err = _dos_findnext( &fileinfo );
#endif
		}
	err = JET_errSuccess;

Close:

#ifdef WIN32
	/* find next backup file
	/**/
	(VOID) _findclose( hFind );
#endif

	return err;
	}


/*	caller has to make sure szDirTemp has enough space for appending "\*"
/*	szDirTo is not used if fOverWriteExisting is false.
/**/
LOCAL ERR ErrLGMoveAllFiles(CHAR *szDirFrom, CHAR *szDirTo, BOOL fOverwriteExisting)
	{
	ERR		err;
	CHAR	szFrom[_MAX_PATH + 1];
	CHAR	szTo[_MAX_PATH + 1];
#ifdef WIN32
        intptr_t    hFind;
	struct	_finddata_t fileinfo;
#else
	struct	find_t fileinfo;		/* data structure for _dos_findfirst */
									/* and _dos_findnext */
#endif

	strcat( szDirFrom, "*" );

#ifdef WIN32
	fileinfo.attrib = _A_NORMAL;
	hFind = _findfirst( szDirFrom, &fileinfo );
	if ( hFind == -1 )
		{
		/*	done! no file to move
		/**/
		return JET_errSuccess;
		}
	else
		{
		err = JET_errSuccess;
		}
#else
	err = _dos_findfirst( szDirFrom, _A_NORMAL, &fileinfo );
#endif

	/*	restore szDirTemp
	/**/
	szDirFrom[ strlen(szDirFrom) - 1 ] = '\0';

	while( err == JET_errSuccess )
		{
		_splitpath( fileinfo.name, szDrive, szDir, szFName, szExt );

		/* not . , and .. not temp
		/**/
		if ( fileinfo.name[0] != '.' &&
			SysCmpText( fileinfo.name, "temp" ) != 0 )
			{
			if ( !fOverwriteExisting )
				{
				err = JET_errBackupDirectoryNotEmpty;
				goto Close;
				}
			strcpy( szTo, szDirTo );
			strcat( szTo, szFName );
			if ( szExt[0] != '\0' )
				strcat( szTo, szExt );

			strcpy( szFrom, szDirFrom );
			strcat( szFrom, fileinfo.name );
			rename( szFrom, szTo );
			}

#ifdef WIN32
		/*	find next backup file
		/**/
		err = _findnext( hFind, &fileinfo );
#else
		/*	find next backup file
		/**/
		err = _dos_findnext( &fileinfo );
#endif
		}
	err = JET_errSuccess;

Close:

#ifdef WIN32
	/*	find next backup file
	/**/
	(VOID) _findclose( hFind );
#endif

	return err;
	}


/*	size of rgbFName should be >= 9 to hold "jetnnnnn"
/**/
ERR ErrOpenLastGenerationLogFile( CHAR *szPath, CHAR *rgbFName, HANDLE *phf )
	{
	ERR		err;
	CHAR	szLogPath[_MAX_PATH + 1];
	INT		iGen;

	/*	open jet.log
	/**/
	strcpy( szLogPath, szPath );
	strcpy( rgbFName, szJet );
	strcat( szLogPath, szJetLog );
	err = ErrSysOpenFile( szLogPath, phf, 0, fFalse, fFalse );
	if ( err == JET_errFileNotFound )
		{
		/*	find the last generation of log files
		/**/
		LGLastGeneration( szLogPath, &iGen );
		if ( iGen == 0 )
			{
			err = JET_errMissingLogFile;
			}
		else
			{
			LGSzFromLogId( rgbFName, iGen );
			strcpy( szLogPath, szPath );
			strcat( szLogPath, rgbFName );
			strcat( szLogPath, szLogExt );
			/*	open the last generation file, jetnnnnn.log
			/**/
			err = ErrSysOpenFile( szLogPath, phf, 0, fFalse, fFalse );
			}
		}

	return err;
	}


/*	copies database files and logfile generations starting at checkpoint
 *  record to directory specified by the environment variable BACKUP.
 *  No flushing or switching of log generations is involved.
 *  The Backup call may be issued at any time, and does not interfere
 *  with the normal functioning of the system - nothing gets locked.
 *
 *  The database page is copied page by page in page sequence number. If
 *  a copied page is dirtied after it is copied, the page has to be
 *  recopied again. A flag is indicated if a database is being copied. If
 *  BufMan is writing a dirtied page and the page is copied, then BufMan
 *  has to copy the dirtied page to both the backup copy and the current
 *  database.
 *
 *  If the copy is later used to Restore without a subsequent log file, the
 *  restored database will be consistent and will include any transaction
 *  committed prior to backing up the very last log record; if there is a
 *  subsequent log file, that file will be used during Restore as a
 *  continuation of the backed-up log file.
 *
 *	PARAMETERS
 *
 *	RETURNS
 *		JET_errSuccess, or the following error codes:
 *					+errNoBackupDirectory
 *					-errFailCopyDatabase
 *					-errFailCopyLogFile
 */

ERR ISAMAPI ErrIsamBackup( const CHAR __far *szBackupTo, JET_GRBIT grbit )
	{
	ERR			err = JET_errSuccess;
	DBID		dbid;
	PAGE		*ppage;
	PAGE		*ppageMin = pNil;
	PAGE		*ppageMax;
	LGFILEHDR	*plgfilehdrT = pNil;

	PIB			*ppib = ppibNil;
	DBID		dbidT = 0;
	FUCB		*pfucb = pfucbNil;
	HANDLE		hfRead = handleNil;
	HANDLE		hfBK = handleNil;
	HANDLE		hfLg = handleNil;
	HANDLE		hfLgB = handleNil;
	FMP			*pfmpCur = pNil;
		   		
	BOOL		fIncrementalBackup = ( grbit & JET_bitBackupIncremental );
	BOOL		fOverwriteExisting = !fIncrementalBackup && ( grbit & JET_bitOverwriteExisting );
	BOOL		fAllMovedToTemp = fFalse;
	BOOL		fMovingToTemp = fFalse;
	USHORT		usGenCopying;
	CHAR		szT[_MAX_PATH + 1];
	CHAR		szT2[_MAX_PATH + 1];
	LGPOS		lgposCheckpointIncB;

	BOOL		fInCritJet = fTrue;
	DBENV		dbenvB;

	// UNDONE: cpage should be a system parameter
#define	cpagePatchBufferMost	20
	INT cpagePatchBuffer = cpagePatchBufferMost;
	if ( fBackupInProgress )
		return JET_errBackupInProgress;

	if ( fLogDisabled )
		return JET_errLoggingDisabled;

	if ( fLGNoMoreLogWrite )
		{
		return JET_errLogWriteFail;
		}

	fBackupInProgress = fTrue;

	/*	write file header via flush log after compute usGenCopying
	/*	to avoid copying subset of log files required by log file
	/*	header in jet.log file.  An error could occur if the
	/*	cached usGenCopying was newer than the checkpoint in the
	/*	jet.log file.
	/**/
	Call( ErrLGFlushLog( ) );

	EnterCriticalSection( critLGFlush );
	Call( ErrLGWriteFileHdr( plgfilehdrGlobal ) );
	LeaveCriticalSection( critLGFlush );

	/*	temporary disable checkpoint
	/**/
	fFreezeCheckpoint = fTrue;

	/*	get backup directory path from environment variable
	/**/
	if	( szBackupTo == NULL || szBackupTo[0] == '\0' )
		{
		/*	clean up log files, do no copies
		/**/
		EnterCriticalSection( critLGFlush );
		usGenCopying = plgfilehdrGlobal->lgposCheckpoint.usGeneration;
		LeaveCriticalSection( critLGFlush );
		LeaveCriticalSection( critJet );
		fInCritJet = fFalse;
		goto ChkKeepOldLogs;
		}

	/*	to prevent _splitpath from treating directory name as filename
	/**/
	strcpy( szBackupPath, szBackupTo );
	strcat( szBackupPath, "\\" );

	/*	initialize the copy buffer
	/**/
	ppageMin = (PAGE *)PvSysAllocAndCommit( cpagePatchBuffer * sizeof(PAGE) );
	if ( ppageMin == NULL )
		{
		Error( JET_errOutOfMemory, HandleError );
		}

	if ( fIncrementalBackup )
		{
		LOGTIME		tmCreate;
		ULONG  		ulRup;				// typically 2000
		ULONG  		ulVersion;			// of format: 125.1
		BYTE   		szComputerName[MAX_COMPUTERNAME_LENGTH];
		BYTE   		rgbFName[_MAX_FNAME + 1];

		plgfilehdrT = (LGFILEHDR *)PvSysAllocAndCommit( sizeof(LGFILEHDR) );
		if ( plgfilehdrT == NULL )
			{
			Error( JET_errOutOfMemory, HandleError );
			}

		//	UNDONE:	review with Cheen Liao. Why do we log backup and
		//			restore?
		/*  write a backup start log file
		/**/
		Call( ErrLGIncBackup( (CHAR *)szBackupTo ) );
		lgposIncBackup = lgposLogRec;
		LGGetDateTime( &logtimeIncBackup );

		LeaveCriticalSection( critJet );
		fInCritJet = fFalse;

		/* set up the starting generation of log files to copy
		/* i.e. last generation in backup directory.
		/**/
		Call( ErrOpenLastGenerationLogFile( szBackupPath, rgbFName, &hfLgB ) );
		Call( ErrLGReadFileHdr( hfLgB, plgfilehdrT ) );

		/* keep the right check point for the backed up databases
		/* it also needs to copy the db env of the check point
		/* also keep the old fullbackup information.
		/**/
		lgposCheckpointIncB = plgfilehdrT->lgposCheckpoint;
		dbenvB = plgfilehdrT->dbenv;

		lgposFullBackup = plgfilehdrT->lgposFullBackup;
		logtimeFullBackup = plgfilehdrT->logtimeFullBackup;

		/*	keep the time stamp of the last jet.log in backup directory
		/**/
		usGenCopying = plgfilehdrT->lgposLastMS.usGeneration;
		tmCreate = plgfilehdrT->tmCreate;
		ulRup = plgfilehdrT->ulRup;
		ulVersion = plgfilehdrT->ulVersion;
		strcpy( szComputerName, plgfilehdrT->szComputerName );
		CallS( ErrSysCloseFile( hfLgB ) );
		hfLgB = handleNil;

		if ( usGenCopying == plgfilehdrGlobal->lgposLastMS.usGeneration )
			{
			/*	the jet.log or last log generation file in backup directory has
			/*	the same generation number as current jet.log generation number.
			/**/
#ifdef CHECK_LG_VERSION
			/*	check version
			/**/
			if ( !fLGIgnoreVersion )
				{
				if ( !FSameTime( &plgfilehdrGlobal->tmCreate,
					&plgfilehdrT->tmCreate ) ||
					plgfilehdrGlobal->ulRup != plgfilehdrT->ulRup ||
					plgfilehdrGlobal->ulVersion != plgfilehdrT->ulVersion )
					{
					/* return fail if the version does not match
					/**/
					err = JET_errBadNextLogVersion;
					goto HandleError;
					}
				}
#endif
			}

#if 0
		/*	if last generation in backup directory is jet.log, rename it
		/*	to proper last generation jetnnnnn.log.
		/**/
		if ( _stricmp( rgbFName, szJet ) == 0 )
			{
			/*	make sure the name of last generation is correct
			/**/
			LGSzFromLogId( szFName, usGenCopying );
//	UNDONE:	review with Cheen
			LGMakeName( szT, szLogFilePath, szFName, szLogExt );
//			LGMakeName( szT, szBackupPath, szFName, szLogExt );

//	UNDONE:	review with Cheen
			strcpy( szT2, szLogFilePath );
//			strcpy( szT2, szBackupPath );
			strcat( szT2, szJetLog );
			rename( szT2, szT );
			}
#endif

		/*	copy the jetnnnnn.log that has the same generation number
		/*	as the jet.log, renamed to last generation, or to
		/*	last log generation file in the backup directory.
		/**/
		LGSzFromLogId( szFName, usGenCopying );
		LGMakeName( szT, szLogFilePath, szFName, szLogExt );

		if ( ErrSysOpenFile( szT, &hfLgB, 0, fFalse, fFalse ) == JET_errSuccess )
			{
#ifdef CHECK_LG_VERSION
			if ( !fLGIgnoreVersion )
				{
				Call( ErrLGReadFileHdr( hfLgB, plgfilehdrT ) );
				if ( !FSameTime( &tmCreate, &plgfilehdrT->tmCreate ) ||
					ulRup != plgfilehdrT->ulRup ||
					ulVersion != plgfilehdrT->ulVersion )
					{
					/*	return fail if the version does not match
					/**/
					err = JET_errBadNextLogVersion;
					goto HandleError;
					}
				}
#endif
			}
		else
			{
 			/*	if the last generation is not the same as the current generation
 			/*	try next generation if the no overlapped generations
 			/*	found in current directory.
 			/**/
 			BOOL fNextGen = fFalse;

 			if ( usGenCopying != plgfilehdrGlobal->lgposLastMS.usGeneration )
 				{
 				usGenCopying++;
 				fNextGen = fTrue;
 				}

			if ( usGenCopying == plgfilehdrGlobal->lgposLastMS.usGeneration )
				{
#ifdef CHECK_LG_VERSION
				if ( !fLGIgnoreVersion )
					{
					/*	allow on different computer
					/**/
					if ( !( !fNextGen || FSameTime( &tmCreate, &plgfilehdrGlobal->tmPrevGen ) ) ||
						ulRup != plgfilehdrGlobal->ulRup ||
						ulVersion != plgfilehdrGlobal->ulVersion )
						{
						/*	return fail if the version does not match
						/**/
						err = JET_errBadNextLogVersion;
						goto HandleError;
						}
					}
#endif
				/*	time to copy
				/**/
				goto BackupLogFiles;
				}

			LGSzFromLogId( szFName, usGenCopying );
			LGMakeName( szT, szLogFilePath, szFName, szLogExt );
			if ( ErrSysOpenFile( szT, &hfLgB, 0, fFalse, fFalse ) )
				{
				/*	check contiguity
				/**/
				err = JET_errLogNotContigous;
				goto HandleError;
				}

#ifdef CHECK_LG_VERSION
			if ( !fLGIgnoreVersion )
				{
				CallJ( ErrLGReadFileHdr( hfLgB, plgfilehdrT ), HandleError)
				if ( !FSameTime( &tmCreate, &plgfilehdrT->tmPrevGen ) ||
					ulRup != plgfilehdrT->ulRup ||
					ulVersion != plgfilehdrT->ulVersion )
					{
					/*	return fail if the version does not match
					/**/
					err = JET_errBadNextLogVersion;
					goto HandleError;
					}
				}
#endif
			}

		CallS( ErrSysCloseFile( hfLgB ) );
		hfLgB = handleNil;

		goto BackupLogFiles;
		}

	/*  make sure the backup directory is empty
	/*  search string for any file in backup directory
	/**/
	if ( fOverwriteExisting )
		{
		/*	make a temp directory
		/**/
		strcpy( szT, szBackupPath );
		strcat( szT, szTempDir );

		if ( _mkdir( szT ) )
			{
			/*	make fail, assume temp exist, remove all files in TempDir
			/**/
			err = ErrLGDeleteAllFiles( szT );
			if ( err < 0 )
				{
				Call( JET_errFailToMakeTempDirectory );
				}
			}
		}

	fMovingToTemp = fTrue;
	Call( ErrLGMoveAllFiles( szBackupPath, szT, fOverwriteExisting) );
	fMovingToTemp = fFalse;

	if ( fOverwriteExisting )
		{
		fAllMovedToTemp = fTrue;
		}

	/*  copy all databases opened by this user. If the database is not
	/*  being opened, then copy the database file into the backup directory,
	/*  otheriwse, the database page by page. Also copy all the logfiles
	/**/
	Call( ErrPIBBeginSession( &ppib ) );

	/*	write a backup start log file
	/**/
	Call( ErrLGFullBackup( (CHAR *)szBackupTo ) );
	lgposFullBackup = lgposLogRec;
	LGGetDateTime( &logtimeFullBackup );

	memset( &lgposIncBackup, 0, sizeof(LGPOS) );
	memset( &logtimeIncBackup, 0, sizeof(LOGTIME) );

	for ( dbid = dbidMinBackup; dbid < dbidUserMax; dbid++ )
		{
		INT		cbWritten;
		INT		cbRead;
		PGNO	pgnoLast;
		DIB		dib;
		ULONG	ulNewPos;

		pfmpCur = &rgfmp[dbid];

		if ( !pfmpCur->szDatabaseName )
			continue;

		_splitpath( pfmpCur->szDatabaseName, szDrive, szDir, szFName, szExt );
		LGMakeName( szBackup, szBackupPath, szFName, szExt );

		if ( !FIODatabaseOpen( dbid ) )
			{
			/*	lock the database and do the file copy
			/**/
			Call( ErrIOLockDbidByDbid( dbid ) )

			LeaveCriticalSection( critJet );
			fInCritJet = fFalse;
			err = ErrSysCopy( pfmpCur->szDatabaseName, szBackup, fFalse );
			EnterCriticalSection( critJet );
			fInCritJet = fTrue;

			/*	free the lock
			/**/
			DBIDResetWait( dbid );

			// Call( err );
			continue;
			}

		/*  read database page by page till the last page is read.
		/*  and then patch the pages that are not changed during the copy.
		/**/

		/* get a temporary fucb
		/**/
		CallJ( ErrDBOpenDatabase( ppib,
			pfmpCur->szDatabaseName,
			&dbidT,
			0 ), HandleError )
		Assert( dbidT == dbid );
		Call( ErrDIROpen( ppib, pfcbNil, dbid, &pfucb ) )

		/*	get last page number
		/**/
		DIRGotoOWNEXT( pfucb, PgnoFDPOfPfucb( pfucb ) );
		dib.fFlags = fDIRNull;
		dib.pos = posLast;
		Call( ErrDIRDown( pfucb, &dib ) )
		Assert( pfucb->keyNode.cb == sizeof(THREEBYTES) );
		PgnoFromTbKey( pgnoLast, *(THREEBYTES *)pfucb->keyNode.pb );

		/*	create a local patch file. it should be local to for speed
		/**/
		LGMakeName( szBackupB, ".\\", szFName, szPatExt );
		pfmpCur->cpage = 0;

		LeaveCriticalSection( critJet );
		fInCritJet = fFalse;

		(VOID) ErrSysDeleteFile( szBackupB );
		Call( ErrSysOpenFile( szBackupB, &pfmpCur->hfPatch, 10 * cbPage, fFalse, fTrue ) )
		SysChgFilePtr( pfmpCur->hfPatch, 0, NULL, FILE_BEGIN, &ulNewPos );
		Assert( ulNewPos == 0 );

		/*	create a new copy of the database in back up directory
		/*	initialize it as a 10 page file.
		/**/
		Call( ErrSysOpenFile( szBackup, &hfBK, 10 * cbPage, fFalse, fFalse ) );
		SysChgFilePtr( hfBK, 0, NULL, FILE_BEGIN, &ulNewPos );
		Assert( ulNewPos == 0 );

		/*	open the database as an open file for reading to copy
		/**/
		Call( ErrSysOpenReadFile( pfmpCur->szDatabaseName, &hfRead ) )
		SysChgFilePtr( hfRead, 0, NULL, FILE_BEGIN, &ulNewPos );
		Assert(ulNewPos == 0);

		EnterCriticalSection( critJet );
		fInCritJet = fTrue;

		/*  read pages into buffers, and copy them to the backup file.
		/*  also set up pfmp->pgnoCopied.
		/**/
		Assert( pfmpCur->pgnoCopied == 0 );
		do	{
			INT		cpageWrite;
			INT		cbWrite;
			INT		cbRW;

			if ( pfmpCur->pgnoCopied + cpagePatchBuffer >= pgnoLast )
				{
				/*	last page will be copied
				/**/
				cpageWrite = pgnoLast - pfmpCur->pgnoCopied;
				}
			else
				{
				cpageWrite = cpagePatchBuffer;
				}
			cbWrite = cpageWrite * sizeof(PAGE);

			pfmpCur->pgnoCopied += cpageWrite;

			LeaveCriticalSection( critJet );
			fInCritJet = fFalse;

			// UNDONE:	asynchronous read/write

			err = ErrSysReadBlock( hfRead, (CHAR *)ppageMin, (UINT)cbWrite, &cbRW );
			//	Assert( cbRW == cbWrite );
			//	UNDONE:	can we write data that has not been read?
			Call( ErrSysWriteBlock( hfBK, (BYTE *)ppageMin, (UINT)cbWrite, &cbRW ) )
			Assert( cbRW == cbWrite );

			EnterCriticalSection( critJet );
			fInCritJet = fTrue;
			}
		while ( pfmpCur->pgnoCopied < pgnoLast );

		/*	no need for buffer manager to make extra copy from now on
		/**/
		pfmpCur->pgnoCopied = 0;

		LeaveCriticalSection( critJet );
		fInCritJet = fFalse;

		CallS( ErrSysCloseFile( hfRead ) );
		hfRead = handleNil;

		CallS( ErrSysCloseFile( pfmpCur->hfPatch ) );
		pfmpCur->hfPatch = handleNil;
			
		/*	UNDONE: to make the backup operation truely sequential, the patch file should
		/*	UNDONE: be copied to backup directory too. And later on, the patch should
		/*	UNDONE: be done during recovery time instead.
		/*/

		/*	patch the pages in file szPatch
		/**/
		_splitpath( pfmpCur->szDatabaseName, szDrive, szDir, szFName, szExt );
		LGMakeName( szBackupB, ".\\", szFName, szPatExt );

		Call( ErrSysOpenReadFile( szBackupB, &pfmpCur->hfPatch ) )
		SysChgFilePtr( pfmpCur->hfPatch, 0, NULL, FILE_BEGIN, &ulNewPos );
		Assert( ulNewPos == 0 );

		while ( pfmpCur->cpage > 0 )
			{
			INT		cpageRead;
			PGNO	pgnoT;

			if ( pfmpCur->cpage > cpagePatchBuffer )
				cpageRead = cpagePatchBuffer;
			else
				cpageRead = pfmpCur->cpage;

			CallJ( ErrSysReadBlock(
				pfmpCur->hfPatch,
				(BYTE *) ppageMin,
				(UINT)( sizeof(PAGE) * cpageRead ),
				&cbRead ), HandleError );
			Assert( cbRead == (INT)( sizeof(PAGE) * cpageRead ) );

			pfmpCur->cpage -= cpageRead;

			ppage = ppageMin;
			ppageMax = ppageMin + cpageRead;
			while ( ppage < ppageMax )
				{
				LONG	lRel;
				LONG	lRelHigh;
				ULONG	ulNewPos;

				LFromThreeBytes( pgnoT, ppage->pgnoThisPage );
				lRel = LOffsetOfPgnoLow( pgnoT );
				lRelHigh = LOffsetOfPgnoHigh( pgnoT );

				SysChgFilePtr( hfBK,
					lRel,
					&lRelHigh,
					FILE_BEGIN,
					&ulNewPos );
				Assert( ulNewPos ==	( sizeof(PAGE) * (pgnoT - 1) ) );

				CallJ( ErrSysWriteBlock(
					hfBK,
					(BYTE *)ppage,
					sizeof(PAGE),
					&cbWritten ), HandleError )
				Assert( cbWritten == (UINT) sizeof(PAGE) );

				ppage++;
				}
			}

		/*	close backup file and patch file
		/**/
		CallS( ErrSysCloseFile( hfBK ) );
		hfBK = handleNil;
		CallS( ErrSysCloseFile( pfmpCur->hfPatch ) );
		pfmpCur->hfPatch = handleNil;
		pfmpCur = pNil;

		(VOID)ErrSysDeleteFile( szBackupB );

		EnterCriticalSection( critJet );
		fInCritJet = fTrue;

		/*	close fucb
		/**/
		DIRClose( pfucb );
		pfucb = pfucbNil;
		CallS( ErrDBCloseDatabase( ppib, dbidT, 0 ) );
		dbidT = 0;
		}

	/*	successfully copy all the databases
	/**/
	pfmpCur = pNil;

	PIBEndSession( ppib );
	ppib = ppibNil;

	/*  copy logfiles beginning with the one containing
	/*  current checkpoint
	/**/
	LeaveCriticalSection( critJet );
	fInCritJet = fFalse;

	{
	USHORT usGen;

	Assert( fInCritJet == fFalse );

	EnterCriticalSection( critLGFlush );
	usGenCopying = plgfilehdrGlobal->lgposCheckpoint.usGeneration;
	LeaveCriticalSection( critLGFlush );

BackupLogFiles:
	for ( usGen = usGenCopying; ; usGen++ )
		{
		typedef struct { BYTE rgb[cbSec]; } SECTOR;

		/*	isecWrite start with 0
		/**/
		INT		csec = isecWrite + 1;
		INT		csecBuf = cpagePatchBuffer * (sizeof(PAGE) / cbSec );
		SECTOR	*psecMin = (SECTOR *)ppageMin;
		SECTOR	*psecMax = psecMin + csecBuf;

		ULONG  	ulNewPos;
		BOOL   	fCopyHeader;
		INT		isecWriteOld;

		/*	get proper log generation name
		/**/
		EnterCriticalSection( critLGFlush );

		LGSzFromLogId( szFName, usGen );
		if ( usGen == plgfilehdrGlobal->lgposLastMS.usGeneration )
			{
			/*	latest generation, cut off the extension at "jet"
			/**/
			szFName[ 3 ] = '\0';
			fFreezeNewGeneration = fTrue;

			LGMakeName( szT, szBackupPath, szFName, szLogExt );
			LGMakeName( szT2,  szBackupPath, (CHAR *) szJetTmp, szLogExt );
			rename( szT, szT2);
			}
		else
			{
			/*	cut off the extension at "jetnnnnn"
			/**/
			szFName[ 8 ] = '\0';
			}

		LeaveCriticalSection( critLGFlush );

		/*	copy the log file in current directory
		/**/
		LGMakeName( szLogName, szLogFilePath, szFName, szLogExt );
		LGMakeName( szBackup, (CHAR *) szBackupPath, szFName, szLogExt );

		csecBuf = cpagePatchBuffer * ( sizeof(PAGE) / cbSec );

		/*	determin number of sectors to copy
		/**/
		if ( fFreezeNewGeneration )
			{
			isecWriteOld = isecWrite;
			/* isecWrite start with 0
			/**/
			//	UNDONE: get around for NT bug
			csec = isecWriteOld + 1 + 1;
			}
		else
			{
			struct _stat statFile;

			if ( _stat ( szLogName, &statFile ) )
				{
				err = JET_errFileAccessDenied;
				goto HandleError;
				}
			csec = statFile.st_size / cbSec;
			}

		psecMin = (SECTOR *)ppageMin;
		psecMax = psecMin + csecBuf;
		fCopyHeader = fTrue;

		Call( ErrSysOpenReadFile( szLogName, &hfLg) );
		SysChgFilePtr( hfLg, 0, NULL, FILE_BEGIN, &ulNewPos );
		Assert( ulNewPos == 0 );
	
		Call( ErrSysOpenFile( szBackup, &hfLgB, cbSec, fFalse, fFalse ) );
		SysChgFilePtr( hfLgB, 0, NULL, FILE_BEGIN, &ulNewPos );
		Assert( ulNewPos == 0 );

		while ( csec > 0 )
			{
			INT		csecRead;
			INT		cbWritten;
			INT		cbRead;

			if ( csec > csecBuf )
				csecRead = csecBuf;
			else
				csecRead = csec;

			CallJ( ErrSysReadBlock(
				hfLg,
				(BYTE *)psecMin,
				(UINT)( cbSec * csecRead ),
				&cbRead ), HandleError );
			Assert( cbRead == ( cbSec * csecRead ) );

			if ( fIncrementalBackup && fCopyHeader )
				{
				/* udpate log file header to carry the right checkpoint
				/* for the old backup database.
				/**/
				Assert( csec >= 2 );
				((LGFILEHDR *) psecMin)->lgposCheckpoint = lgposCheckpointIncB;
				((LGFILEHDR *) psecMin)->dbenv = dbenvB;

				((LGFILEHDR *) psecMin)->lgposFullBackup = lgposFullBackup;
				((LGFILEHDR *) psecMin)->logtimeFullBackup = logtimeFullBackup;
				
				((LGFILEHDR *) psecMin)->ulChecksum = UlLGHdrChecksum( (LGFILEHDR*)psecMin );
				memcpy( (BYTE *) psecMin + sizeof(LGFILEHDR), psecMin, sizeof(LGFILEHDR) );

				fCopyHeader = fFalse;
				}
			csec -= csecRead;

			CallJ( ErrSysWriteBlock(
				hfLgB,
				(BYTE *) psecMin,
				(UINT)(cbSec * csecRead),
				&cbWritten ), HandleError );
			Assert( cbWritten == cbSec * csecRead );

#if 0
			//	UNDONE:	may not need this code if it never catch up
			//	UNDONE:	review this code with Cheen Liao
			/*	if we are copying current jet.log, it may have grown
			/*	a little bit more while we are copying, adjust it.
			/**/
			if ( fFreezeNewGeneration )
				csec += ( isecWriteOld - isecWrite );
#endif
			}

		CallS( ErrSysCloseFile( hfLg ) );
		hfLg = handleNil;
		CallS( ErrSysCloseFile( hfLgB ) );
		hfLgB = handleNil;

		/*	last log generation file is copied, done!
		/**/
		if ( fFreezeNewGeneration )
			break;
		}

	/*	delete jettemp.log if any
	/**/
	(VOID)ErrSysDeleteFile( szT2 );

	if ( !fOverwriteExisting )
		goto ChkKeepOldLogs;

	/*	remove all the files in temp
	/**/
	strcpy( szT, szBackupPath );
	strcat( szT, szTempDir );
	err = ErrLGDeleteAllFiles( szT );
	Call( err );

	if ( _rmdir( szT ) )
		{
		err = JET_errFailToCleanTempDirectory;
		}
	Call( err );

ChkKeepOldLogs:
	if ( !( grbit & JET_bitKeepOldLogs ) )
		{
		usGenCopying = plgfilehdrGlobal->lgposCheckpoint.usGeneration;
		for ( usGen = usGenCopying - 1; usGen > 0; usGen-- )
			{
			LGSzFromLogId( szFName, usGen );
			LGMakeName( szLogName, szLogFilePath, szFName, szLogExt );
			if ( ErrSysDeleteFile( szLogName ) != JET_errSuccess )
				{
				/*	assuming no more generation file exists
				/**/
				break;
				}
			}
		}
	}

	EnterCriticalSection( critJet );
	fInCritJet = fTrue;

HandleError:
	if ( !fInCritJet )
		EnterCriticalSection( critJet );

	if ( ppageMin != NULL )
		SysFree( ppageMin );

	if ( plgfilehdrT != NULL )
		SysFree( plgfilehdrT );
	
	if ( pfucb != pfucbNil )
		DIRClose( pfucb );

	if ( dbidT != 0 )
		CallS( ErrDBCloseDatabase( ppib, dbidT, 0 ) );

	if ( ppib != ppibNil )
		PIBEndSession( ppib );

	if ( pfmpCur != pNil && pfmpCur->hfPatch != handleNil )
		{
		CallS( ErrSysCloseFile( pfmpCur->hfPatch ) );
		pfmpCur->hfPatch = handleNil;
		}

	if ( hfRead != handleNil )
		{
		CallS( ErrSysCloseFile( hfRead ) );
		hfRead = handleNil;
		}

	if ( hfBK != handleNil )
		{
		CallS( ErrSysCloseFile( hfBK ) );
		hfBK = handleNil;
		}

	if ( hfLg != handleNil )
		{
		CallS( ErrSysCloseFile( hfLg ) );
		hfBK = handleNil;
		}

	if ( hfLgB != handleNil )
		{
		CallS( ErrSysCloseFile( hfLgB ) );
		hfLgB = handleNil;
		}

	LeaveCriticalSection( critJet );

	if ( err < 0 && fMovingToTemp )
		{
		/* failed during moving files to temp,
		/*	move all files in temp back
		/**/
		strcat( szT, szTempDir );
		(VOID)ErrLGMoveAllFiles( szT, szBackupPath, fOverwriteExisting );
		}

	if ( err < 0 && fAllMovedToTemp )
		{
		/*	del all files and move all temp files back
		/**/
		strcpy( szT, szBackupPath );
		(VOID)ErrLGDeleteAllFiles( szT );

		/*	move all files in temp back
		/**/
		strcat( szT, szTempDir );
		(VOID)ErrLGMoveAllFiles( szT, szBackupPath, fOverwriteExisting );
		}

	EnterCriticalSection( critJet );
	
	fFreezeNewGeneration =
		fBackupInProgress =
		fFreezeCheckpoint = fFalse;

	return err;
	}


/*  locate the last generation log file.  FName, etc. will set to the log file.
/*  Return JET_errSuccess if exists, otherwise, return missing log file.
/**/
VOID LGLastGeneration( CHAR *szSearchPath, INT *piGeneration )
	{
	INT		iGenNum = 0;
        intptr_t    hFind;
	struct	_finddata_t fileinfo;
	CHAR	szPath[_MAX_PATH + 1];
	ERR		err;

	/* to prevent _splitpath from treating directory name as filename
	/**/
	strcpy( szPath, szSearchPath );

	/*	search string for any file in backup directory
	/**/
	strcat( szPath,"*" );

	fileinfo.attrib = _A_NORMAL;
	hFind = _findfirst( szPath, &fileinfo );
	if ( hFind == -1 )
		{
		*piGeneration = 0;
		return;
		}

	/*	search latest jetnnnnn.log file
	/**/
	iGenNum = 0;
	err = JET_errSuccess;
	while( err == JET_errSuccess )
		{
		BYTE szT[6];

		/*	fileinfo.name contains no szDrive and szDir info
		/*	call splitpath to get szFName and szExt
		/**/
		_splitpath( fileinfo.name, szDrive, szDir, szFName, szExt );

		/* length of Jet00000 a *.log
		/**/
		if ( strlen( szFName ) == 8 && SysCmpText( szExt, szLogExt ) == 0 )
			{
			memcpy( szT, szFName, 3 );
			szT[3] = '\0';
			/* a Jet*.log
			/**/
			if ( SysCmpText( szT, szJet ) == 0 )
				{
				INT 	ib = 3;
				INT 	ibMax = 8;
				INT		iT = 0;

				for ( ; ib < ibMax; ib++ )
					{
					BYTE b = szFName[ ib ];
					if ( b > '9' || b < '0' )
						break;
					else
						iT = iT * 10 + b - '0';
					}
				if ( ib == ibMax )
					if ( iT > iGenNum )
						iGenNum = iT;
				}
			}
		err = _findnext( hFind, &fileinfo ); /* find next backup file */
		}

	/*	find next backup file
	/**/
	(VOID) _findclose( hFind );
	*piGeneration = iGenNum;
	}


/*
 *	Restores databases from database backups and log generations.  Redoes
 *	log from latest checkpoint record. After the backed-up logfile is
 *  Restored, the initialization process continues with Redo of the current
 *  logfile as long as the generation numbers are contiguous. There must be a
 *  log file jet.log in the backup directory, else the Restore process fails.
 *
 *	GLOBAL PARAMETERS
 *		szRestorePath (IN) 	pathname of the directory with backed-up files.
 *		lgposRedoFrom(OUT)	is the position (generation, logsec, displacement)
 *							of the last saved log record; Redo of the
 *							current logfile will continue from this point.
 *
 *	RETURNS
 *		JET_errSuccess, or error code from failing routine, or one
 *				of the following "local" errors:
 *				-AfterInitialization
 *				-errFailRestoreDatabase
 *				-errNoRestoredDatabases
 *				-errMissingJetLog
 *  FAILS ON
 *		missing Jet.log or System.mdb on backup directory
 *		noncontiguous log generation
 *
 *  SIDE EFFECTS:
 *		All databases may be changed.
 *
 *  COMMENTS
 *		this call is executed during the normal first JetInit call,
 *  	if the environment variable RESTORE is set. Subsequent to
 *		the successful execution of Restore,
 *		system operation continues normally.
 */

/*	a global flag to indicate if DbPath is set
/**/
BOOL fSysDbPathSet = fFalse;

ERR ISAMAPI ErrIsamRestore(
	CHAR *szRestoreFromPath,
	INT crstmap,
	JET_RSTMAP *rgrstmap,
	JET_PFNSTATUS pfn )
	{
	ERR			err;
	ERR			errStop;
	JET_RSTMAP	*prstmap = 0;
	INT			irstmap = 0;
	INT			irstmapMac = 0;
	INT			cRestore = 0;			/* count of restored databases */
	INT			iGenNum = 0;
	DBID		dbid;
  	LGPOS		lgposRedoFrom;

	fHardRestore = fTrue;
	fLogDisabled = fFalse;

	strcpy( szRestorePath, szRestoreFromPath );
	strcat( szRestorePath, "\\" );

	{
	CHAR	szLogDirPath[cbFilenameMost + 1];
	strcpy( szLogDirPath, szLogFilePath );
	strcat( szLogDirPath, "\\" );
	/*	check for valid log sequence
	/**/
	err = ErrLGValidateLogSequence( szRestorePath, szLogDirPath );
	Assert( err == JET_errBadNextLogVersion || err == JET_errSuccess );
#if 0
	if ( err == JET_errBadNextLogVersion )
		{
		INT	iGeneration;

		LGFirstGeneration( szLogDirPath, &iGeneration );
		CallR( ErrLGDeleteInvalidLogs( szLogDirPath, iGeneration ) );
		}
#else
	CallR( err );
#endif
	}

	CallR( ErrFMPInit() );

	/*  initialize log manager and set working log file path
	/**/
	CallR( ErrLGInit( ) );

	/*	all saved log generation files and database backups must be in
	/*  szRestorePath.
	/**/
	Assert( fSTInit == fSTInitDone || fSTInit == fSTInitNotDone );
	if ( fSTInit == fSTInitDone )
		{
		err = JET_errAfterInitialization;
		goto HandleError;
		}

	fHardRestore = fTrue;

#ifdef DEBUG
	 	/*	write start hard recovery event
		/**/
 		{
 		CHAR rgb[256];

 		sprintf( rgb, "Jet Blue Start hard recovery from %s.\n",
 	  		szRestoreFromPath );
 		UtilWriteEvent( evntypStart, rgb, pNil, 0 );
 		}
#endif

	/*  redo backed-up logfiles beginning with the one containing current
	/*  checkpoint. Pick up the checkpoint from latest log generation.
	/**/
	Call( ErrOpenLastGenerationLogFile( szRestorePath, szFName, &hfLog ) );
	szLogCurrent = szRestorePath;
	LGMakeLogName( szLogName, szFName );

	/*	read log file header
	/**/
	Call( ErrLGReadFileHdr( hfLog, plgfilehdrGlobal ) );

	if ( !fSysDbPathSet )
		{
		strcpy( szSysDbPath, plgfilehdrGlobal->dbenv.szSysDbPath );

		Call( ErrDBStoreDBPath(
			plgfilehdrGlobal->dbenv.szSysDbPath,
			&rgfmp[dbidSystemDatabase].szDatabaseName ) );
		}

	/*	restore the system database from backup
	/**/
	LGMakeName( szBackup, szRestorePath, (CHAR *)szSystem, szMdbExt );
#ifdef NJETNT
	if ( ErrSysCopy( szBackup, rgtib[UtilGetItibOfCurTask()].szSysDbPath, fFalse ) )
		{
		return JET_errFailRestoreDatabase;
		}
#else
	if ( ErrSysCopy( szBackup, szSysDbPath, fFalse ) )
		{
		return JET_errFailRestoreDatabase;
		}
#endif

	/*	initialize the global variable which LGRedo relies on
	/**/
	Assert( szLogCurrent == szRestorePath );
  	lgposRedoFrom = plgfilehdrGlobal->lgposCheckpoint;
	/*	close current logfile
	/**/
	CallS( ErrSysCloseFile( hfLog ) );
	hfLog = handleNil;

	Call( ErrLGRedo1( &lgposRedoFrom ) );

#ifdef DEBUG
		{
		FILE	*hf;

		/*	need to callback to tell the user about the database to choose,
		/*	copy the information into a file, create file of the format
		/*		lgposBackup,
		/*		machine name, backup directory, date/time of backup,
		/*		lgposRedoFrom
		/*		<database no.> <database path>
		/**/
		(VOID)ErrSysDeleteFile( szRestoreMap );

		hf = fopen( szRestoreMap, "w+b" );

		if ( hf == pNil )
			goto EndOfDebug;

		fprintf( hf, "%d %d %d\n",
			(INT) plgfilehdrGlobal->lgposFullBackup.usGeneration,
			(INT) plgfilehdrGlobal->lgposFullBackup.isec,
			(INT) plgfilehdrGlobal->lgposFullBackup.ib );

		fprintf( hf, "%d %d %d %d %d %d\n",
			(INT) plgfilehdrGlobal->logtimeFullBackup.bMonth,
			(INT) plgfilehdrGlobal->logtimeFullBackup.bDay,
			(INT) plgfilehdrGlobal->logtimeFullBackup.bYear,
			(INT) plgfilehdrGlobal->logtimeFullBackup.bHours,
			(INT) plgfilehdrGlobal->logtimeFullBackup.bMinutes,
			(INT) plgfilehdrGlobal->logtimeFullBackup.bSeconds );

		fprintf( hf, "%d,%d,%d\n",
			(INT) lgposRedoFrom.usGeneration,
			(INT) lgposRedoFrom.isec,
			(INT) lgposRedoFrom.ib);

		for ( dbid = dbidMin; dbid < dbidUserMax; dbid++ )
			{
			FMP		*pfmp = &rgfmp[dbid];

			if ( pfmp->cDetach < 0 )
				continue;

			if ( pfmp->szDatabaseName )
				{
				fprintf( hf, "%d %s\n", (INT)dbid, pfmp->szDatabaseName );
				}
			}

		fclose( hf );
		}
EndOfDebug:
#endif

	/*	build rstmap, skip temp and system database
	/**/
	for ( dbid = dbidSystemDatabase + 1; dbid < dbidUserMax; dbid++ )
		{
		FMP		*pfmp = &rgfmp[dbid];

		if ( pfmp->cDetach < 0 )
			continue;

		if ( !pfmp->szDatabaseName )
			continue;

		if ( irstmap == irstmapMac )
			{
			prstmap = SAlloc( sizeof(JET_RSTMAP) * ( irstmap + 3 ) );
			if ( prstmap == NULL )
				{
				Error( JET_errOutOfMemory, HandleError );
				}
			memcpy( prstmap, rgrstmap, sizeof(JET_RSTMAP) * irstmap );
			if ( rgrstmap )
				{
				SFree( rgrstmap );
				}
			rgrstmap = prstmap;
			irstmapMac += 3;
			}

		rgrstmap[ irstmap ].dbid = dbid;
		strcpy( rgrstmap[irstmap].szDatabaseName, pfmp->szDatabaseName);
		/*	by default, recover to original place
		/**/
		strcpy( rgrstmap[irstmap].szNewDatabaseName, pfmp->szDatabaseName);
		irstmap++;
		}

	if ( rgrstmap )
		{
		/*	set sentinal
		/**/
		rgrstmap[ irstmap ].dbid = 0;
		}

	crstmap = irstmap;

	if ( pfn )
		{
		/*	callback and pass back the map array,
		/*	so that user can modify the map table.
		/**/
		(*pfn)( 0, JET_snpRestore, JET_sntRestoreMap, &rgrstmap );
		}

	/*  for hard restore, we have to copy the files from restore path,
	/*  while skipping temporary database and system database.
	/**/
	for ( dbid = dbidSystemDatabase + 1; dbid < dbidUserMax; dbid++ )
		{
		CHAR	szCopyFrom [_MAX_PATH + 1];
		CHAR	szFName[_MAX_FNAME];
		FMP		*pfmp = &rgfmp[dbid];
		INT		cb;
		BYTE	*sz;

		if ( !pfmp->szDatabaseName )
			continue;

		if ( pfmp->cDetach < 0 )
			continue;

		/* user pass map or a map has created after callback,
		/* select certain database to recover.
		/**/
		Assert( crstmap );
		for ( irstmap = 0; irstmap < crstmap; irstmap++ )
			{
			if ( rgrstmap[ irstmap ].dbid == dbid )
				{
				Assert( strcmp( rgrstmap[ irstmap ].szDatabaseName,
				  	pfmp->szDatabaseName ) == 0 );

				/* no new destination specified. no recovery
				/**/
				if ( rgrstmap[ irstmap ].szNewDatabaseName[0] == '\0' )
					{
					pfmp->cDetach = -1;
					goto NextDb;
					}
				break;
				}
			}

		_splitpath( pfmp->szDatabaseName, szDrive, szDir, szFName, szExt);
		strcpy(szCopyFrom, szRestorePath);
		strcat(szCopyFrom, szFName);
		if ( szExt[0] != '\0')
			{
			strcat( szCopyFrom, szExt );
			}

		if ( !FFileExists( szCopyFrom ) )
			{
			/* may be created after backup
			/**/
			continue;
			}

		(VOID)ErrSysDeleteFile( rgrstmap[irstmap].szNewDatabaseName );

//		if ( FFileExists( pfmp->szDatabaseName ) )
//			{
// 			/* not recovery from backup database
//			/**/
//			continue;
//			}

		if ( ErrSysCopy( szCopyFrom, rgrstmap[ irstmap ].szNewDatabaseName, fFalse ) )
			{
			return JET_errFailRestoreDatabase;
			}

		Assert( pfmp->szDatabaseName );
		cb = strlen( rgrstmap[ irstmap ].szNewDatabaseName ) + 1;
		sz = SAlloc( cb );
		if ( sz == NULL )
			{
			Error( JET_errOutOfMemory, HandleError );
			}
		memcpy( sz, rgrstmap[irstmap].szNewDatabaseName, cb );
		Assert( sz[cb - 1] == '\0' );
		pfmp->szRestorePath = sz;

NextDb:
		;
		}

	Call( ErrLGRedo2( &lgposRedoFrom ) );

HandleError:
	errStop = err;
	
	if ( prstmap )
		SFree( prstmap );

	fHardRestore = fFalse;

	CallR( ErrLGTerm( ) );
	FMPTerm();

	/*	reset initialization state
	/**/
	fSTInit = fSTInitNotDone;

#ifdef DEBUG
	if ( errStop )
		{
		CHAR rgb[256];

		sprintf( rgb, "Jet Blue hard recovery Stops with error %d.",errStop);
		UtilWriteEvent( evntypStop, rgb, pNil, 0 );
		}
	else
		{
		UtilWriteEvent( evntypStop, "Jet Blue hard recovery Stops.\n", pNil, 0 );
		}
#endif

	return errStop;
	}


LOCAL ERR ErrLGValidateLogSequence( CHAR *szBackup, CHAR *szLog )
	{
	ERR			err = JET_errSuccess;
	INT			iGeneration = 0;
	HANDLE		hfT = handleNil;
	LGFILEHDR	*plgfilehdrT = NULL;
	BYTE   		rgbFName[_MAX_FNAME + 1];
	CHAR		szLogPath[_MAX_PATH + 1];
	BOOL		fRunTimeLogs = fFalse;

	plgfilehdrT = (LGFILEHDR *)PvSysAllocAndCommit( sizeof(LGFILEHDR) );
	if ( plgfilehdrT == NULL )
		{
		Error( JET_errOutOfMemory, HandleError );
		}

	strcpy( szLogPath, szBackup );
	strcat( szLogPath, szJetLog );
	err = ErrSysOpenFile( szLogPath, &hfT, 0, fFalse, fFalse );
	if ( err < 0 && err != JET_errFileNotFound )
		{
		Error( err, HandleError );
		}
	if ( err == JET_errFileNotFound )
		{
		/*	get last backup log generation number from numbered
		/*	log generation file.
		/**/
		LGLastGeneration( szBackup, &iGeneration );
		/*	if no log files in backup directory, then we cannot determine
		/*	validity of log sequence
		/**/
		if ( iGeneration == 0 )
			{
			Error( JET_errBadNextLogVersion, HandleError );
			}
		}
	else
		{
		Call( ErrLGReadFileHdr( hfT, plgfilehdrT ) );
		iGeneration = plgfilehdrT->lgposLastMS.usGeneration;
		CallS( ErrSysCloseFile( hfT ) );
		hfT = handleNil;
		}

	Assert( iGeneration != 0 );

	/*	open each subsequent generation in log directory
	/*	until file not found.  Then check that jet.log is log
	/*	following file not found.
	/**/
	forever
		{
		LGSzFromLogId( rgbFName, iGeneration );
		strcpy( szLogPath, szLog );
		strcat( szLogPath, rgbFName );
		strcat( szLogPath, szLogExt );
		err = ErrSysOpenFile( szLogPath, &hfT, 0, fFalse, fFalse );
		if ( err < 0 && err != JET_errFileNotFound )
			{
			Error( err, HandleError );
			}
		if ( err == JET_errFileNotFound )
			break;
		CallS( ErrSysCloseFile( hfT ) );
		hfT = handleNil;
		fRunTimeLogs = fTrue;
		iGeneration++;
		}

	strcpy( szLogPath, szLog );
	strcat( szLogPath, szJetLog );
	err = ErrSysOpenFile( szLogPath, &hfT, 0, fFalse, fFalse );
	if ( err < 0 && err != JET_errFileNotFound )
		{
		goto HandleError;
		}
	/*	if there is at least one numbered log file in run time
	/*	directory then there must be a szJetLog file.
	/**/
	if ( fRunTimeLogs && err == JET_errFileNotFound )
		{
		Error( JET_errBadNextLogVersion, HandleError );
		}
	if ( err != JET_errFileNotFound )
		{
		Call( ErrLGReadFileHdr( hfT, plgfilehdrT ) );
		if ( iGeneration != plgfilehdrT->lgposLastMS.usGeneration )
			{
			Error( JET_errBadNextLogVersion, HandleError );
			}
		CallS( ErrSysCloseFile( hfT ) );
		hfT = handleNil;
		}

	/*	set success code
	/**/
	err = JET_errSuccess;

HandleError:
	if ( err < 0 )
		err = JET_errBadNextLogVersion;
	if ( hfT != handleNil )
		CallS( ErrSysCloseFile( hfT ) );
	if ( plgfilehdrT != NULL )
		SysFree( plgfilehdrT );
	return err;
	}


/*	when a discontiguous log sequence is present, we can delete all
/*	logs begining with the discontiguous log, and rename the previous log
/*	to jet.log in the runtime directory.  A simplification is to delete all
/*	log files in the run-time directory.
/**/
LOCAL ERR ErrLGDeleteInvalidLogs( CHAR *szLogDir, INT iGeneration )
	{
	ERR			err = JET_errSuccess;
	BYTE   		rgbFName[_MAX_FNAME + 1];
	CHAR		szLogFile[_MAX_PATH + 1];

	Assert( iGeneration != 0 );

	/*	open each subsequent generation in log directory
	/*	until file not found.  Then check that jet.log is log
	/*	following file not found.
	/**/
	forever
		{
		LGSzFromLogId( rgbFName, iGeneration );
		strcpy( szLogFile, szLogDir );
		strcat( szLogFile, rgbFName );
		strcat( szLogFile, szLogExt );
		Call( ErrSysDeleteFile( szLogFile ) );
		iGeneration++;
		}

	strcpy( szLogFile, szLogDir );
	strcat( szLogFile, szJetLog );
	Call( ErrSysDeleteFile( szLogFile ) );

HandleError:
	return err;
	}


LOCAL VOID LGFirstGeneration( CHAR *szSearchPath, INT *piGeneration )
	{
	INT		iReturn;
	INT		iGeneration = 0;
        intptr_t    hFind;
	struct	_finddata_t fileinfo;
	CHAR	szPath[_MAX_PATH + 1];

	/* to prevent _splitpath from treating directory name as filename
	/**/
	strcpy( szPath, szSearchPath );

	/*	search string for any file in backup directory
	/**/
	strcat( szPath, "*" );

	fileinfo.attrib = _A_NORMAL;
	hFind = _findfirst( szPath, &fileinfo );
	if ( hFind == -1 )
		{
		*piGeneration = 0;
		return;
		}

	/*	search latest jetnnnnn.log file
	/**/
	iGeneration = 0;
	iReturn = 0;
	while( iReturn == 0 )
		{
		BYTE szT[6];

		/*	fileinfo.name contains no szDrive and szDir info
		/*	call splitpath to get szFName and szExt
		/**/
		_splitpath( fileinfo.name, szDrive, szDir, szFName, szExt );

		/* if length of a jet?????.log and a *.log
		/**/
		if ( strlen( szFName ) == 8 && SysCmpText( szExt, szLogExt ) == 0 )
			{
			memcpy( szT, szFName, 3 );
			szT[3] = '\0';

			/* if a jet*.log
			/**/
			if ( SysCmpText( szT, szJet ) == 0 )
				{
				INT		ib = 3;
				INT		ibMax = 8;

				iGeneration = 0;
				for ( ; ib < ibMax; ib++ )
					{
					BYTE	b = szFName[ib];

					if ( b > '9' || b < '0' )
						break;
					else
						iGeneration = iGeneration * 10 + b - '0';
					}
				if ( ib == ibMax )
					{
					break;
					}
				}
			}

		/*	find next file
		/**/
		iReturn = _findnext( hFind, &fileinfo );
		}

	(VOID)_findclose( hFind );
	*piGeneration = iGeneration;
	return;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\pib.c ===
#include "config.h"

#include <stddef.h>
#include <string.h>

#include "daedef.h"
#include "pib.h"
#include "util.h"
#include "page.h"
#include "ssib.h"
#include "fucb.h"
#include "stapi.h"
#include "dbapi.h"
#include "logapi.h"

DeclAssertFile;					/* Declare file name for assert macros */

PIB * __near ppibAnchor = ppibNil;


ERR ErrPIBBeginSession( PIB **pppib )
	{
	PIB	*ppib;

	SgSemRequest( semST );

	/*	allocate inactive PIB on anchor list.
	/**/
	for ( ppib = ppibAnchor; ppib != ppibNil; ppib = ppib->ppibNext )
		{
		if ( ppib->level == levelNil )
			{
			*pppib = ppib;
			ppib->level = 0;
			break;
			}
		}

	SgSemRelease( semST );

	/*	return success if found PIB
	/**/
	if ( ppib != ppibNil )
		{
		/*	default mark this a system session
		/**/
		ppib->fUserSession = fFalse;

		Assert( ppib->level == 0 );
		Assert( ppib->pdabList == pdabNil );
#ifdef DEBUG
		{
		DBID	dbidT;

		/*	skip over system database
		/**/
		//	UNDONE:	have code open system database explicitly
		//			when needed and loop from dbidUserMin
		for ( dbidT = dbidUserMin + 1; dbidT < dbidUserMax; dbidT++ )
			{
			Assert( ppib->rgcdbOpen[dbidT] == 0 );
			}
		}
#endif
		Assert( ppib->pfucb == pfucbNil );
		
		ppib->procid = (PROCID)OffsetOf(ppib);
		Assert( ppib->procid != procidNil );
		
		ppib->levelStart = 0;
		ppib->fAfterFirstBT = fFalse;

		*pppib = ppib;
		return JET_errSuccess;
		}

	/*	allocate PIB from free list
	/**/
	ppib  = PpibMEMAlloc();
	if ( ppib == NULL )
		return JET_errCantBegin;
	
	/*	initialize PIB
	/**/
	memset( (BYTE * )ppib, 0, sizeof( PIB ));
	
	ppib->lgposStart = lgposMax;
//	ppib->lgstat = lgstatAll;
	ppib->trx = trxMax;
	/*	default mark this a system session
	/**/
	ppib->fUserSession = fFalse;

	Assert( ppib->pbucket == pbucketNil );
	Assert( ppib->ibOldestRCE == 0 );

	Assert( !ppib->fLogDisabled );

	/*	the temporary database is always open
	/**/
	SetOpenDatabaseFlag( ppib, dbidTemp );

	CallS( ErrSignalCreateAutoReset( &ppib->sigWaitLogFlush, "proc wait log" ) );
	ppib->lWaitLogFlush = lWaitLogFlush;	/* set default log flush value */
	cLGUsers++;

	/*	link PIB into list
	/**/
	SgSemRequest( semST );
	ppib->ppibNext = ppibAnchor;
	ppibAnchor = ppib;
	SgSemRelease( semST );

	Assert( !FPIBDeferFreeNodeSpace( ppib ) );

	/*	return PIB
	/**/
	ppib->procid = (PROCID)OffsetOf(ppib);
	Assert( ppib->procid != procidNil );
	*pppib = ppib;

	return JET_errSuccess;
	}


VOID PIBEndSession( PIB *ppib )
	{
	/*	all session resources except version buckets should have been
	/*	released to free pools.
	/**/
	Assert( ppib->pfucb == pfucbNil );

	ppib->level = levelNil;
	}


ERR VTAPI ErrIsamSetWaitLogFlush( JET_SESID sesid, long lmsec )
	{
	((PIB *)sesid)->lWaitLogFlush = lmsec;
	return JET_errSuccess;
	}


#ifdef DEBUG
VOID PIBPurge( VOID )
	{
	PIB	*ppib;

	for ( ppib = ppibAnchor; ppib != ppibNil; ppib = ppibAnchor )
		{
		PIB		*ppibCur;
		PIB		*ppibPrev;

		SgSemRequest( semST );

		/*	fLGWaiting may be fTrue if disk full
		/**/
//		Assert( !ppib->fLGWaiting );
		SignalClose( ppib->sigWaitLogFlush );
		cLGUsers--;

		ppibPrev = (PIB *)((BYTE *)&ppibAnchor - offsetof(PIB, ppibNext));
		while( ( ppibCur = ppibPrev->ppibNext ) != ppib && ppibCur != ppibNil )
			{
			ppibPrev = ppibCur;
			}

		if ( ppibCur != ppibNil )
			{
			ppibPrev->ppibNext = ppibCur->ppibNext;
			}

		SgSemRelease( semST );
		MEMReleasePpib( ppib );
		}
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\recdel.c ===
#include "config.h"

#include <string.h>

#include "daedef.h"
#include "pib.h"
#include "util.h"
#include "fmp.h"
#include "ssib.h"
#include "page.h"
#include "fucb.h"
#include "fcb.h"
#include "stapi.h"
#include "fdb.h"
#include "idb.h"
#include "nver.h"
#include "dirapi.h"
#include "logapi.h"
#include "recapi.h"
#include "spaceapi.h"
#include "recint.h"

DeclAssertFile;					/* Declare file name for assert macros */

/**************************** INTERNAL STUFF ***************************/
typedef struct DFIPB {			/*** DeleteFromIndexParameterBlock ***/
	FUCB	*pfucb;
	FUCB	*pfucbIdx;				// index's FUCB (can be pfucbNil)
	LINE	lineRecord;				// deleted data record
	SRID	sridRecord;				// SRID of deleted record
	BOOL	fFreeFUCB;				// free index FUCB?
} DFIPB;
ERR ErrRECIDeleteFromIndex( FCB *pfcbIdx, DFIPB *pdfipb );


//+API
// ErrIsamDelete
// ========================================================================
// ErrIsamDelete(ppib, pfucb)
//		PIB		*ppib;		// IN	   PIB of this user
//		FUCB		*pfucb;		// INOUT   FUCB for file to delete from
// Deletes the current record from data file.  All indexes on the data
// file are updated to reflect the deletion.
//
// PARAMETERS
//				ppib		PIB of this user
//				pfucb		FUCB for file to delete from
// RETURNS
//		Error code, one of the following:
//			JET_errSuccess					Everything went OK.
//			-NoCurrentRecord			There is no current record
//												to delete.
// SIDE EFFECTS 
//			After the deletion, file currency is left just before
//			the next record.  Index currency (if any) is left just
//			before the next index entry.  If the deleted record was
//			the last in the file, the currencies are left after the
//			new last record.  If the deleted record was the only record
//			in the entire file, the currencies are left in the
//			"beginning of file" state.	On failure, the currencies are
//			returned to their initial states.
//			If there is a working buffer for SetField commands,
//			it is discarded.
// COMMENTS		
//			If the currencies are not ON a record, the delete will fail.
//			A transaction is wrapped around this function.	Thus, any
//			work done will be undone if a failure occurs.
//			Index entries are not made for entirely-null keys.
//			For temporary files, transaction logging is deactivated
//			for the duration of the routine.
//-
ERR VTAPI ErrIsamDelete( PIB *ppib, FUCB *pfucb )
	{
	ERR		err;
	FCB		*pfcbFile;				// file's FCB
	FCB		*pfcbIdx;				// loop variable for each index on file
	DFIPB  	dfipb;					// parameter to ErrRECIDeleteFromIndex

	CheckPIB( ppib );
	CheckTable( ppib, pfucb );
	CheckNonClustered( pfucb );

	/* ensure that table is updatable
	/**/
	CallR( FUCBCheckUpdatable( pfucb )  );

	/*	reset copy buffer status on record delete
	/**/
	if ( FFUCBUpdatePrepared( pfucb ) )
		{
		CallR( ErrIsamPrepareUpdate( ppib, pfucb, JET_prepCancel ) );
		}

	/*	efficiency variables
	/**/
	pfcbFile = pfucb->u.pfcb;
	Assert( pfcbFile != pfcbNil );

	CallR( ErrDIRBeginTransaction( ppib ) );
	/* abort if index is being built on file 
	/**/
	if ( FFCBDenyDDL( pfcbFile, ppib ) )
		{ 
		err = JET_errWriteConflict;
		goto HandleError;
		}

	/*	refresh currency since pfucb->lineData may be invalid
	/**/
	Call( ErrDIRGet( pfucb ) );

	/*	allocate working buffer if needed
	/**/
	if ( pfucb->pbfWorkBuf == NULL )
		{
		Call( ErrBFAllocTempBuffer( &pfucb->pbfWorkBuf ) );
		}
	pfucb->lineWorkBuf.pb = (BYTE *)pfucb->pbfWorkBuf->ppage;
	Assert( pfucb->pbfWorkBuf != pbfNil );
	/*	copy record to be deleted into copy buffer
	/**/
	LineCopy( &pfucb->lineWorkBuf, &pfucb->lineData );

	/*	cache record pointer for delete index and 
	/*	delete long value operations.
	/**/
	dfipb.lineRecord = pfucb->lineWorkBuf;

	/*	get SRID of record being deleted for updating indexes
	/**/
	Assert( ppib->level < levelMax );
	Assert( PcsrCurrent( pfucb ) != pcsrNil );
	DIRGetBookmark( pfucb, &dfipb.sridRecord );

	/*	delete record
	/**/
	Call( ErrDIRDelete( pfucb, fDIRVersion ) );

	/*	delete from non-clustered indexes
	/**/
	dfipb.pfucb = pfucb;
	dfipb.fFreeFUCB = fFalse;
	for( pfcbIdx = pfcbFile->pfcbNextIndex;
		pfcbIdx != pfcbNil;
		pfcbIdx = pfcbIdx->pfcbNextIndex )
		{
		dfipb.fFreeFUCB = pfcbIdx->pfcbNextIndex == pfcbNil;
		Call( ErrRECIDeleteFromIndex( pfcbIdx, &dfipb ) );
		}

	//	UNDONE:	optimize record deletion by  detecting presence of long values
	//			on table basis.

	/*	delete record long values
	/**/
	Call( ErrRECAffectLongFields( pfucb, &dfipb.lineRecord, fDereference ) );

	/*	commit transaction if we started it and everything went OK
	/**/
	Call( ErrDIRCommitTransaction( ppib ) );
	return err;

HandleError:
	/*	if operation failed then rollback changes.
	/**/
	Assert( err < 0 );
	CallS( ErrDIRRollback( ppib ) );
	return err;
	}


//+INTERNAL
// ErrRECIDeleteFromIndex
// ========================================================================
// ErrRECIDeleteFromIndex( FCB *pfcbIdx, DFIPB *pdfipb )
//
// Extracts key from data record, opens the index, deletes the key with
// the given SRID, and closes the index.
//
// PARAMETERS	
//				pfcbIdx							FCB of index to delete from
//				pdfipb->ppib					who is calling this routine
//				pdfipb->pfucbIdx				pointer to index's FUCB.
//				pdfipb->lineRecord.cb		length of deleted record
//				pdfipb->lineRecord.pb	   deleted record to extract key from
//				pdfipb->sridRecord  			SRID of deleted record
//				pdfipb->fFreeFUCB				free index FUCB?
// RETURNS		
//				JET_errSuccess, or error code from failing routine
// SIDE EFFECTS 
//				If fFreeFUCB is fFalse, patipb->pfucbIdx should
//				be used in a subsequent ErrDIROpen.
// SEE ALSO		ErrRECDelete
//-
ERR ErrRECIDeleteFromIndex( FCB *pfcbIdx, DFIPB *pdfipb )
	{
	ERR		err;										// error code of various utility
	KEY		keyDead;									// key extracted from old data record
	BYTE		rgbDeadKeyBuf[ JET_cbKeyMost ];	// buffer for keyDead
	ULONG		itagSequence; 							// used to extract keys
	BOOL		fHasMultivalue;  						// index key has a tagged field?

	Assert( pfcbIdx != pfcbNil );
	Assert( pfcbIdx->pfdb != pfdbNil );
	Assert( pfcbIdx->pidb != pidbNil );
	Assert( pdfipb != NULL );
	Assert( !FLineNull( &pdfipb->lineRecord ) );
	Assert( pdfipb->pfucb != pfucbNil );

	/*	open FUCB on this index
	/**/
	CallR( ErrDIROpen( pdfipb->pfucb->ppib, pfcbIdx, 0, &pdfipb->pfucbIdx ) );
	Assert( pdfipb->pfucbIdx != pfucbNil );
	FUCBSetIndex( pdfipb->pfucbIdx );
	FUCBSetNonClustered( pdfipb->pfucbIdx );

	/*	delete all keys from this index for dying data record
	/**/
	fHasMultivalue = pfcbIdx->pidb->fidb & fidbHasMultivalue;
	keyDead.pb = rgbDeadKeyBuf;
	for ( itagSequence = 1; ; itagSequence++ )
		{
//		Call( ErrDIRGet( pdfipb->pfucb ) );
//		pdfipb->lineRecord = pdfipb->pfucb->lineData;
		Call( ErrRECExtractKey( pdfipb->pfucb, (FDB *)pfcbIdx->pfdb, pfcbIdx->pidb,
		   &pdfipb->lineRecord, &keyDead, itagSequence ) );
		Assert( err == wrnFLDNullKey ||
			err == wrnFLDOutOfKeys ||
			err == wrnFLDNullSeg ||
			err == JET_errSuccess );
		if ( err == wrnFLDOutOfKeys )
			{
			Assert( itagSequence > 1 );
			break;
			}

		/*	record must honor index no NULL segment requirements
		/**/
		Assert( !( pfcbIdx->pidb->fidb & fidbNoNullSeg ) ||
			( err != wrnFLDNullSeg && err != wrnFLDNullKey ) );

		if ( err == wrnFLDNullKey )
			{
			if ( pfcbIdx->pidb->fidb & fidbAllowAllNulls )
				{
				/*	move to DATA root and seek to index entry and delete it
				/**/
				DIRGotoDataRoot( pdfipb->pfucbIdx );
				Call( ErrDIRDownKeyBookmark( pdfipb->pfucbIdx, &keyDead, pdfipb->sridRecord ) );
				Call( ErrDIRDelete( pdfipb->pfucbIdx, fDIRVersion ) );
				}
			break;
			}
		else
			{
			if ( err == wrnFLDNullSeg && !( pfcbIdx->pidb->fidb & fidbAllowSomeNulls ) )
				break;
			}

		DIRGotoDataRoot( pdfipb->pfucbIdx );
		Call( ErrDIRDownKeyBookmark( pdfipb->pfucbIdx, &keyDead, pdfipb->sridRecord ) );
		Call( ErrDIRDelete( pdfipb->pfucbIdx, fDIRVersion ) );

		/* dont keep extracting for keys with no tagged segments
		/**/
		if ( !fHasMultivalue )
			break;
		}

	/*	supress warnings
	/**/
	Assert( err == wrnFLDNullKey ||
		err == wrnFLDOutOfKeys ||
		err == wrnFLDNullSeg ||
		err == JET_errSuccess );
	err = JET_errSuccess;

HandleError:
	/* close the FUCB
	/**/
	DIRClose( pdfipb->pfucbIdx );
	Assert( err < 0 || err == JET_errSuccess );
	return err;
	}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\recmisc.c ===
#include "config.h"

#include <string.h>

#include "daedef.h"
#include "util.h"
#include "fmp.h"
#include "pib.h"
#include "page.h"
#include "ssib.h"
#include "fcb.h"
#include "fucb.h"
#include "stapi.h"
#include "dirapi.h"
#include "fdb.h"
#include "idb.h"
#include "recapi.h"
#include "recint.h"

DeclAssertFile;					/* Declare file name for assert macros */


ERR VTAPI ErrIsamSetCurrentIndex( PIB *ppib, FUCB *pfucb, const CHAR *szName )
	{
	ERR		err;
	CHAR		szIndex[ (JET_cbNameMost + 1) ];

	CheckPIB( ppib );
	CheckTable( ppib, pfucb );
	CheckNonClustered( pfucb );

	/*	index name may be Null string for no index
	/**/
	if ( szName == NULL || *szName == '\0' )
		{
		*szIndex = '\0';
		}
	else
		{
		CallR( ErrCheckName( szIndex, szName, (JET_cbNameMost + 1) ) );
		}

	CallR( ErrRECChangeIndex( pfucb, szIndex ) );
	
#ifndef NO_DEFER_MOVE_FIRST
	if ( pfucb->pfucbCurIndex )
		{
		pfucb->pfucbCurIndex->pcsr->csrstat = csrstatDeferMoveFirst;
		DIRSetRefresh(pfucb->pfucbCurIndex);
		}
	pfucb->pcsr->csrstat = csrstatDeferMoveFirst;
	DIRSetRefresh(pfucb);
#else
	err = ErrIsamMove( ppib, pfucb, JET_MoveFirst, 0 );
	if ( err == JET_errNoCurrentRecord )
		err = JET_errSuccess;
#endif
	
	return err;
	}


ERR ErrRECChangeIndex( FUCB *pfucb, CHAR *szIndex )
	{
	ERR		err;
	FCB		*pfcbFile;
	FCB		*pfcb2ndIdx;
	FUCB		**ppfucbCurIdx;
	BOOL		fChangingToClusteredIndex = fFalse;

	Assert( pfucb != pfucbNil );
	Assert( FFUCBIndex( pfucb ) );

	pfcbFile = pfucb->u.pfcb;
	Assert(pfcbFile != pfcbNil);
	ppfucbCurIdx = &pfucb->pfucbCurIndex;

	/*	szIndex == clustered index or NULL
	/**/
	if ( szIndex == NULL || *szIndex == '\0' ||
		( pfcbFile->pidb != pidbNil &&
		SysCmpText( szIndex, pfcbFile->pidb->szName ) == 0 ) )
		{
		fChangingToClusteredIndex = fTrue;
		}

	/*	have a current secondary index
	/**/
	if ( *ppfucbCurIdx != pfucbNil )
		{
		Assert( FFUCBIndex( *ppfucbCurIdx ) );
		Assert( (*ppfucbCurIdx)->u.pfcb != pfcbNil );
		Assert( (*ppfucbCurIdx)->u.pfcb->pidb != pidbNil );
		Assert( (*ppfucbCurIdx)->u.pfcb->pidb->szName != NULL );

		/* changing to the current secondary index: NO-OP
		/**/
		if ( szIndex != NULL && *szIndex != '\0' &&
			SysCmpText( szIndex, (*ppfucbCurIdx)->u.pfcb->pidb->szName ) == 0 )
			{
			return JET_errSuccess;
			}

		/*	really changing index, so close old one
		/**/
		DIRClose( *ppfucbCurIdx );
		*ppfucbCurIdx = pfucbNil;
		}
	else
		{
		/*	using clustered index or sequential scanning.
		/**/
		if ( fChangingToClusteredIndex )
			return JET_errSuccess;
		}

	/*	at this point:	 there is NO current secondary index
	/*	and the index really is being changed
	/**/
	if ( fChangingToClusteredIndex )
		{
		/*	changing to clustered index.  Reset currency to beginning
		/**/
		ppfucbCurIdx = &pfucb;
		goto ResetCurrency;
		}

	/*	switching to a new secondary index: look it up
	/**/
	for ( pfcb2ndIdx = pfcbFile->pfcbNextIndex;
		pfcb2ndIdx != pfcbNil;
		pfcb2ndIdx = pfcb2ndIdx->pfcbNextIndex )
		{
		Assert(pfcb2ndIdx->pidb != pidbNil);
		Assert(pfcb2ndIdx->pidb->szName != NULL);

		if ( SysCmpText( pfcb2ndIdx->pidb->szName, szIndex ) == 0 )
			break;
		}
	if ( pfcb2ndIdx == pfcbNil ||	FFCBDeletePending( pfcb2ndIdx ) )
		return JET_errIndexNotFound;
	Assert( !( FFCBDenyRead( pfcb2ndIdx, pfucb->ppib ) ) );

	/*	open an FUCB for the new index
	/**/
	Assert(pfucb->ppib != ppibNil);
	Assert(pfucb->dbid == pfcb2ndIdx->dbid);
	if ((err = ErrDIROpen(pfucb->ppib, pfcb2ndIdx, 0, ppfucbCurIdx)) < 0)
		return err;
	(*ppfucbCurIdx)->wFlags = fFUCBIndex | fFUCBNonClustered;

	/*** Reset the index's and file's currency ***/
ResetCurrency:
	Assert( PcsrCurrent(*ppfucbCurIdx) != pcsrNil );
	DIRBeforeFirst( *ppfucbCurIdx );
	if ( pfucb != *ppfucbCurIdx )
		{
		DIRBeforeFirst( pfucb );
		}
	return JET_errSuccess;
	}


BOOL FRECIIllegalNulls( FDB *pfdb, LINE *plineRec )
	{
	FIELD *pfield;
	LINE lineField;
	FID fid;
	ERR err;

	/*** Check fixed fields ***/
	for (fid = fidFixedLeast; fid <= pfdb->fidFixedLast; fid++)
		{
		pfield = &pfdb->pfieldFixed[fid-fidFixedLeast];
		if ( pfield->coltyp == JET_coltypNil || !( pfield->ffield & ffieldNotNull ) )
			continue;
		err = ErrRECExtractField(pfdb, plineRec, &fid, pNil, 1, &lineField);
		Assert(err >= 0);
		if ( err == JET_wrnColumnNull )
			return fTrue;
		}

	/*** Check variable fields ***/
	for (fid = fidVarLeast; fid <= pfdb->fidVarLast; fid++)
		{
		pfield = &pfdb->pfieldVar[fid-fidVarLeast];
		if (pfield->coltyp == JET_coltypNil || !(pfield->ffield & ffieldNotNull))
			continue;
		err = ErrRECExtractField(pfdb, plineRec, &fid, pNil, 1, &lineField);
		Assert(err >= 0);
		if ( err == JET_wrnColumnNull )
			return fTrue;
		}

	return fFalse;
	}


ERR VTAPI ErrIsamGetCurrentIndex( PIB *ppib, FUCB *pfucb, CHAR *szCurIdx, ULONG cbMax )
	{
	CHAR szIndex[ (JET_cbNameMost + 1) ];

	CheckPIB( ppib );
	CheckTable( ppib, pfucb );
	CheckNonClustered( pfucb );

	if ( pfucb->pfucbCurIndex != pfucbNil )
		{
		Assert( pfucb->pfucbCurIndex->u.pfcb != pfcbNil );
		Assert( pfucb->pfucbCurIndex->u.pfcb->pidb != pidbNil );
		strcpy( szIndex, pfucb->pfucbCurIndex->u.pfcb->pidb->szName );
		}
	else if ( pfucb->u.pfcb->pidb != pidbNil )
		{
		strcpy( szIndex, pfucb->u.pfcb->pidb->szName );
		}
	else
		{
		szIndex[0] = '\0';
		}

	if ( cbMax > JET_cbNameMost )
		cbMax = JET_cbNameMost;
	strncpy( szCurIdx, szIndex, (USHORT)cbMax - 1 );
	szCurIdx[cbMax-1] = '\0';
	return JET_errSuccess;
	}


ERR VTAPI ErrIsamGetChecksum( PIB *ppib, FUCB *pfucb, ULONG *pulChecksum )
	{
	ERR 		err = JET_errSuccess;

	CheckPIB( ppib );
 	CheckFUCB( ppib, pfucb );
	CallR( ErrDIRGet( pfucb ) );
	*pulChecksum = UlChecksum( pfucb->lineData.pb, pfucb->lineData.cb );
	return err;
	}


ULONG UlChecksum( BYTE *pb, ULONG cb )
	{
	//	UNDONE:	find a way to compute check sum in longs independant
	//				of pb, byte offset in page

	/*	compute checksum by adding bytes in data record and shifting
	/*	result 1 bit to left after each operation.
	/**/
	BYTE	 	*pbT = pb;
	BYTE		*pbMax = pb + cb;
	ULONG	 	ulChecksum = 0;

	/*	compute checksum
	/**/
	for ( ; pbT < pbMax; pbT++ )
		{
		ulChecksum += *pb;
		ulChecksum <<= 1;
		}

	return ulChecksum;
	}


#ifdef JETSER
	ERR VTAPI
ErrIsamRetrieveFDB( PIB *ppib, FUCB *pfucb, void *pvFDB, unsigned long cbMax, unsigned long *pcbActual, unsigned long ibFDB )
	{
	ERR	err = JET_errSuccess;
	FDB	*pfdb;
	int	cfieldFixed;
	int	cfieldVar;
	int	cfieldTagged;
	long	cbFDB;

	CheckPIB( ppib );
	CheckFUCB( ppib, pfucb );

	/*	set pfdb for sort or base table
	/**/
	pfdb = (FDB *)pfucb->u.pfcb->pfdb;

	cfieldFixed = pfdb->fidFixedLast + 1 - fidFixedLeast;
	cfieldVar = pfdb->fidVarLast + 1 - fidVarLeast;
	cfieldTagged = pfdb->fidTaggedLast + 1	- fidTaggedLeast;

	cbFDB = sizeof(FDB) +
		 ( cfieldFixed +
		   cfieldVar +
		   cfieldTagged ) * sizeof(FIELD) +
		 ( cfieldFixed + 1 ) * sizeof(WORD);

	if ( pcbActual != NULL )
		*pcbActual = cbFDB - ibFDB;

	if ( pvFDB != NULL && cbMax > 0 && ibFDB < cbFDB )
		{
		ULONG	cb;
		cb = cbFDB - ibFDB;
		if ( cb > cbMax )
			cb = cbMax;
		memcpy( pvFDB, (char *)pfdb + ibFDB, cb );
		}

HandleError:
	return err;
	}


	ERR VTAPI
ErrIsamRetrieveRecords( PIB *ppib, FUCB *pfucb, void *pvRecord, unsigned long cbMax, unsigned long *pcbActual, unsigned long ulRecords )
	{
	ERR			err = JET_errSuccess;
	unsigned		iline = 0;
	unsigned 	ilineMax = (unsigned)ulRecords;
	int			ib;
	int			ibBound;
	LINE			*rgline;
	BOOL			fEnd = fFalse;
	unsigned long	cbActual;

	CheckPIB( ppib );
	CheckFUCB( ppib, pfucb );

	/*	buffer must be large enough to hold largest possible record plus
	/*	per record overhead.
	/**/
	Assert( pvRecord != NULL && cbMax >=
		cbNodeMost +
		sizeof(SRID) +
		sizeof(WORD) +
		sizeof(WORD) +
		sizeof(CHAR *) +
		sizeof(ULONG) );

	/*	begin copying records to the end of the buffer
	/**/
	ib = cbMax;
	rgline = (LINE *)((char *)pvRecord +
		sizeof(USHORT) +
		sizeof(USHORT) );

	/*	if not sort cursor, then set lineData
	/**/
	if ( FFUCBSort( pfucb ) )
		{
		while( iline < ilineMax )
			{
			/*	determine current data boundary
			/**/
			ibBound = sizeof(USHORT);
			ibBound += sizeof(USHORT);
			ibBound += (iline + 1) * sizeof(LINE);
			ibBound += pfucb->lineData.cb;
			if ( ib <= ibBound )
				{
				CallS( ErrIsamSortMove( ppib, pfucb, JET_MovePrevious, 0 ) );
				break;
				}

			/*	else copy another record into REX buffer
			/**/
			ib -= pfucb->lineData.cb;
			memcpy( (char *)pvRecord + ib,
				pfucb->lineData.pb,
				pfucb->lineData.cb );
			/*	set line for record
			/**/
			rgline[iline].pb = (char *)ib;
			rgline[iline].cb = pfucb->lineData.cb;
			if ( ++iline < ilineMax )
				{
				err = ErrIsamSortMove( ppib, pfucb, JET_MoveNext, 0 );
				if ( err == JET_errNoCurrentRecord )
					{
					/*	position on last record
					/**/
					CallS( ErrIsamSortMove( ppib, pfucb, JET_MovePrevious, 0 ) );
					fEnd = fTrue;
					err = JET_errSuccess;
					break;
					}
				if ( err < 0 )
					{
					//	UNDONE:	if error occurs, currency may be incorrect
					Assert( fFalse );
					goto HandleError;
					}
				}
			else
				{
				Assert( err == JET_errSuccess );
				break;
				}
			}
		}
	else
		{
		while( iline < ilineMax )
			{
			Call( ErrIsamMove( ppib, pfucb, 0, 0 ) );

			/*	determine current data boundary
			/**/
			ibBound = sizeof(USHORT);
			ibBound += sizeof(USHORT);
			ibBound += (iline + 1) * sizeof(LINE);
			ibBound += pfucb->lineData.cb;
			ibBound += sizeof(SRID);
			if ( ib <= ibBound )
				{
				CallS( ErrIsamMove( ppib, pfucb, JET_MovePrevious, 0 ) );
				break;
				}

			/*	else copy another record into REX buffer
			/**/
			ib -= pfucb->lineData.cb;
			memcpy( (char *)pvRecord + ib,
				pfucb->lineData.pb,
				pfucb->lineData.cb );
			Call( ErrIsamGetBookmark( ppib, pfucb, (SRID*)((char *)pvRecord + ib - sizeof(SRID)), sizeof(SRID), &cbActual ) );
			/*	set line for record
			/**/
			rgline[iline].pb = (char *)ib;
			rgline[iline].cb = pfucb->lineData.cb;
			ib -= sizeof(SRID);
			if ( ++iline < ilineMax )
				{
				err = ErrIsamMove( ppib, pfucb, JET_MoveNext, 0 );
				if ( err == JET_errNoCurrentRecord )
					{
					/*	position on last record
					/**/
					CallS( ErrIsamMove( ppib, pfucb, JET_MovePrevious, 0 ) );
					fEnd = fTrue;
					err = JET_errSuccess;
					break;
					}
				if ( err < 0 )
					{
					//	UNDONE:	if error occurs, currency may be incorrect
					Assert( fFalse );
					goto HandleError;
					}
				}
			else
				{
				Assert( err == JET_errSuccess );
				break;
				}
			}
		}

	/*	set number of lines
	/**/
	*(USHORT *)pvRecord = iline;
	*(USHORT *)((char *)pvRecord + sizeof(USHORT)) = fEnd;
	*pcbActual = cbMax;

HandleError:
	return err;
	}


	ERR VTAPI
ErrIsamRetrieveBookmarks( PIB *ppib, FUCB *pfucb, void *pvBookmarks, unsigned long cbMax, unsigned long *pcbActual )
	{
	ERR		err = JET_errSuccess;
	SRID		*psrid = (SRID *)pvBookmarks;
	SRID 		*psridMax = psrid + cbMax/sizeof(SRID);
	unsigned long cb;

	CheckPIB( ppib );
	CheckFUCB( ppib, pfucb );
#ifndef WIN32
	Assert( cbMax < 0xffff );
#endif

	/*	support both sort and base tables
	/**/
	for ( ; psrid < psridMax; )
		{
		Call( ErrIsamGetBookmark( ppib, pfucb, psrid, sizeof(SRID), &cb ) );
		psrid++;
		Call( ErrIsamMove( ppib, pfucb, JET_MoveNext, 0 ) );
		}

HandleError:
	/*	if traversed last record, then convert error into success
	/**/
	if ( err == JET_errNoCurrentRecord )
		err = JET_errSuccess;

	/*	compute cbActual
	/**/
	*pcbActual = (BYTE *)psrid - (BYTE *)pvBookmarks;

	return err;
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\recget.c ===
#include "config.h"

#include <stdlib.h>
#include <string.h>

#include "daedef.h"
#include "util.h"
#include "pib.h"
#include "page.h"
#include "ssib.h"
#include "fmp.h"
#include "fucb.h"
#include "stapi.h"
#include "dirapi.h"
#include "fcb.h"
#include "fdb.h"
#include "idb.h"
#include "scb.h"
#include "recapi.h"
#include "recint.h"
#include "nver.h"
#include "logapi.h"
#include "fileint.h"
#include "sortapi.h"
#include "fileapi.h"

DeclAssertFile; 				/* Declare file name for assert macros */

CRIT 				critTempDBName;
static ULONG 	ulTempNum = 0;

ULONG NEAR
	ulTempNameGen()
{	ULONG ulNum;
	SgSemRequest(critTempDBName);
	ulNum = ulTempNum++;
	SgSemRelease(critTempDBName);
	return(ulNum);
	}


/*=================================================================
ErrIsamSortMaterialize

Description: Converts a SORT file into a temporary file so that it
			 may be accessed using the normal file access functions.


/*	1.	create temporary table
/*	2.	use DIR operations to convert SORT data to FILE data
/*	3.	fake SORT cursor to be FILE cursor
/*	4.	close SORT cursor and return SORT resources
/**/
/*
Parameters:	FUCB *pfucbSort 	pointer to the FUCB for the sort file

Return Value: standard error return

Errors/Warnings:
<List of any errors or warnings, with any specific circumstantial
 comments supplied on an as-needed-only basis>

Side Effects:
=================================================================*/

	ERR VTAPI
ErrIsamSortMaterialize( PIB *ppib, FUCB *pfucbSort, BOOL fIndex )
	{
	ERR		err;
	INT		crun;
	INT		irun;
	INT		cPages;
	RUN		*rgrun;
	FUCB		*pfucbTable = pfucbNil;
	FCB		*pfcbTable;
	FCB		*pfcbSort;
	FDB		*pfdb;
	IDB		*pidb;
	BYTE		szName[JET_cbNameMost+1];

	CheckPIB( ppib );
	CheckSort( ppib, pfucbSort );

	Assert( ppib->level < levelMax );
	Assert( pfucbSort->ppib == ppib );
	Assert( !( FFUCBIndex( pfucbSort ) ) );

	/*	causes remaining runs to be flushed to disk
	/**/
	if ( FSCBInsert( pfucbSort->u.pscb ) )
		{
		CallR( ErrSORTEndRead( pfucbSort ) );
		}

	CallR( ErrDIRBeginTransaction( ppib ) );

	crun = pfucbSort->u.pscb->crun;

	if ( crun > 0 )
		{
		rgrun = pfucbSort->u.pscb->rgrun;

		for (irun = 0, cPages=0; irun < crun; irun++)
			{
			cPages += rgrun[irun].cbfRun;
			}
		}
	else
		{
		cPages = 4;
		}

	/* generate temporary file name
	/**/
	sprintf(szName, "TEMP%lu", ulTempNameGen());
	/* create table
	/**/
	Call( ErrFILECreateTable( ppib, dbidTemp, szName, 16, 100, &pfucbTable ) );

	/*	move to DATA root
	/**/
	DIRGotoDataRoot( pfucbTable );

	pfcbSort = &(pfucbSort->u.pscb->fcb);
	pfcbTable = pfucbTable->u.pfcb;

	err = ErrSORTFirst( pfucbSort );

	if ( fIndex )
		{
		while ( err >= 0 )
			{
			Call( ErrDIRInsert( pfucbTable,
				&pfucbSort->lineData,
				&pfucbSort->keyNode,
				fDIRVersion | fDIRBackToFather ) );
			err = ErrSORTNext( pfucbSort );
			}
		}
	else
		{
		DBK		dbk = 0;
		BYTE		rgbDbk[4];
		KEY		keyDbk;

		keyDbk.cb = sizeof(DBK);
		keyDbk.pb = rgbDbk;

		while ( err >= 0 )
			{
			keyDbk.pb[0] = (BYTE)(dbk >> 24);
			keyDbk.pb[1] = (BYTE)((dbk >> 16) & 0xff);
			keyDbk.pb[2] = (BYTE)((dbk >> 8) & 0xff);
			keyDbk.pb[3] = (BYTE)(dbk & 0xff);
			dbk++;

			Call( ErrDIRInsert( pfucbTable,
				&pfucbSort->lineData,
				&keyDbk,
				fDIRVersion | fDIRBackToFather ) );
			err = ErrSORTNext(pfucbSort);
			}
		pfcbTable->dbkMost = dbk;
		}

	if ( err < 0 && err != JET_errNoCurrentRecord )
		{
		goto HandleError;
		}

	Call( ErrDIRCommitTransaction( ppib ) );

	/*	convert sort cursor into table cursor by changing flags.
	/**/
	Assert( pfcbTable->pfcbNextIndex == pfcbNil );
	Assert( pfcbTable->dbid == dbidTemp );
	pfcbTable->cbDensityFree = 0;
	pfcbTable->wFlags = fFCBTemporaryTable | fFCBClusteredIndex;

	/*	switch sort and table FDP so FDP preserved and ErrFILECloseTable.
	/**/
	pfdb = (FDB *)pfcbSort->pfdb;
	pfcbSort->pfdb = pfcbTable->pfdb;
	pfcbTable->pfdb = pfdb;

	/*	switch sort and table IDB so IDB preserved and ErrFILECloseTable,
	/*	only if fIndex.
	/**/
	if ( fIndex )
		{
		pidb = pfcbSort->pidb;
		pfcbSort->pidb = pfcbTable->pidb;
		pfcbTable->pidb = pidb;
		}

	/*	convert sort cursor flags to table flags, with fFUCBOrignallySort
	/**/
	Assert( pfucbSort->dbid == dbidTemp );
	Assert( pfucbSort->pfucbCurIndex == pfucbNil );
	FUCBSetIndex( pfucbSort );
	FUCBResetSort( pfucbSort );

	/*	release SCB and close table cursor
	/**/
	SORTClosePscb( pfucbSort->u.pscb );
	FCBLink( pfucbSort, pfcbTable );
	CallS( ErrFILECloseTable( ppib, pfucbTable ) );
	pfucbTable = pfucbNil;

	/* move to the first record ignoring error if table empty
	/**/
	err = ErrIsamMove( ppib, pfucbSort, JET_MoveFirst, 0 );
	if ( err < 0  )
		{
		if ( err != JET_errNoCurrentRecord )
			goto HandleError;
		}

	Assert( err == JET_errSuccess || err == JET_errNoCurrentRecord );
	return err;

HandleError:
	if ( pfucbTable != pfucbNil )
		CallS( ErrFILECloseTable( ppib, pfucbTable ) );
	CallS( ErrDIRRollback( ppib ) );
	return err;
	}


/*=================================================================
ErrIsamMove

Description:
	Retrieves the first, last, (nth) next, or (nth) previous
	record from the specified file.

Parameters:

	PIB			*ppib				PIB of user
	FUCB			*pfucb	  		FUCB for file
	LONG			crow				number of rows to move
	JET_GRBIT	grbit 			options

Return Value: standard error return

Errors/Warnings:
<List of any errors or warnings, with any specific circumstantial
 comments supplied on an as-needed-only basis>

Side Effects:
=================================================================*/

ERR VTAPI ErrIsamMove( PIB *ppib, FUCB *pfucb, LONG crow, JET_GRBIT grbit )
	{
	ERR		err = JET_errSuccess;
	FUCB	*pfucb2ndIdx;			// FUCB for secondary index (if any)
	FUCB	*pfucbIdx;				// FUCB of selected index (pri or sec)
	SRID	srid;					// bookmark of record
	DIB		dib;					// Information block for DirMan

	CheckPIB( ppib );
	CheckTable( ppib, pfucb );
	CheckNonClustered( pfucb );

	if ( FFUCBUpdatePrepared( pfucb ) )
		{
		CallR( ErrIsamPrepareUpdate( ppib, pfucb, JET_prepCancel ) );
		}

#ifdef INPAGE
	/*	check to see if search can cross page boundary
	/*	and set flag accordingly.
	/**/
	if ( grbit & JET_bitMoveInPage )
		dib.fFlags = fDIRInPage;
	else
		dib.fFlags = fDIRNull;
#else
	Assert( ( grbit & JET_bitMoveInPage ) == 0 );
	dib.fFlags = fDIRNull;
#endif

	// Get secondary index FUCB if any
	pfucb2ndIdx = pfucb->pfucbCurIndex;
	if ( pfucb2ndIdx == pfucbNil )
		pfucbIdx = pfucb;
	else
		pfucbIdx = pfucb2ndIdx;

	if ( crow == JET_MoveLast )
		{
		DIRResetIndexRange( pfucb );

		dib.pos = posLast;
		dib.fFlags |= fDIRPurgeParent;

		/*	move to DATA root
		/**/
		DIRGotoDataRoot( pfucbIdx );

		err = ErrDIRDown( pfucbIdx, &dib );
		}
	else if ( crow > 0 )
		{
		LONG crowT = crow;

		if ( ( grbit & JET_bitMoveKeyNE ) != 0 )
			dib.fFlags |= fDIRNeighborKey;

		// Move forward number of rows given
		while ( crowT-- > 0 )
			{
			err = ErrDIRNext( pfucbIdx, &dib );
			if (err < 0)
				break;
			}
		}
	else if ( crow == JET_MoveFirst )
		{
		DIRResetIndexRange( pfucb );

		dib.pos = posFirst;
		dib.fFlags |= fDIRPurgeParent;

		/*	move to DATA root
		/**/
		DIRGotoDataRoot( pfucbIdx );

		err = ErrDIRDown( pfucbIdx, &dib );
		}
	else if ( crow == 0 )
		{
		err = ErrDIRGet( pfucb );
		}
	else
		{
		LONG crowT = crow;

		if ( ( grbit & JET_bitMoveKeyNE ) != 0)
			dib.fFlags |= fDIRNeighborKey;

		while ( crowT++ < 0 )
			{
			err = ErrDIRPrev( pfucbIdx, &dib );
			if ( err < 0 )
				break;
			}
		}

	/*	if the movement was successful and a non-clustered index is
	/*	in use, then position clustered index to record.
	/**/
	if ( err == JET_errSuccess && pfucb2ndIdx != pfucbNil && crow != 0 )
		{
		Assert( pfucb2ndIdx->lineData.pb != NULL );
		Assert( pfucb2ndIdx->lineData.cb >= sizeof(SRID) );
		srid = PcsrCurrent( pfucb2ndIdx )->item;
		DIRDeferGotoBookmark( pfucb, srid );
		Assert( PgnoOfSrid( srid ) != pgnoNull );
		}

	if ( err == JET_errSuccess )
		return err;
	if ( err == JET_errPageBoundary )
		return JET_errNoCurrentRecord;

	if ( crow > 0 )
		{
		PcsrCurrent(pfucbIdx)->csrstat = csrstatAfterLast;
		PcsrCurrent(pfucb)->csrstat = csrstatAfterLast;
		}
	else if ( crow < 0 )
		{
		PcsrCurrent(pfucbIdx)->csrstat = csrstatBeforeFirst;
		PcsrCurrent(pfucb)->csrstat = csrstatBeforeFirst;
		}

	switch ( err )
		{
		case JET_errRecordNotFound:
			err = JET_errNoCurrentRecord;
		case JET_errNoCurrentRecord:
		case JET_errRecordDeleted:
			break;
		default:
			PcsrCurrent( pfucbIdx )->csrstat = csrstatBeforeFirst;
			if ( pfucb2ndIdx != pfucbNil )
				PcsrCurrent( pfucb2ndIdx )->csrstat =	csrstatBeforeFirst;
		}

	return err;
	}


/*=================================================================
ErrIsamSeek

Description:
	Retrieve the record specified by the given key or the
	one just after it (SeekGT or SeekGE) or the one just
	before it (SeekLT or SeekLE).

Parameters:

	PIB			*ppib					PIB of user
	FUCB			*pfucb 				FUCB for file
	JET_GRBIT 	grbit					grbit

Return Value: standard error return

Errors/Warnings:
<List of any errors or warnings, with any specific circumstantial
 comments supplied on an as-needed-only basis>

Side Effects:
=================================================================*/

ERR VTAPI ErrIsamSeek( PIB *ppib, FUCB *pfucb, JET_GRBIT grbit )
	{
	ERR			err = JET_errSuccess;
	KEY			key;					  		//	key
	KEY			*pkey = &key; 				// pointer to the input key
	FUCB			*pfucb2ndIdx;				// pointer to index FUCB (if any)
	BOOL			fFoundLess;
	SRID			srid;							//	bookmark of record
	JET_GRBIT	grbitMove = 0;

	CheckPIB( ppib );
	CheckTable( ppib, pfucb );
	CheckNonClustered( pfucb );

	if ( ! ( FKSPrepared( pfucb ) ) )
		{
		return(JET_errKeyNotMade);
		}

	/*	Reset copy buffer status
	/**/
	if ( FFUCBUpdatePrepared( pfucb ) )
		{
		CallR( ErrIsamPrepareUpdate( ppib, pfucb, JET_prepCancel ) );
		}

	/*	reset index range limit
	/**/
	DIRResetIndexRange( pfucb );

	/*	ignore segment counter
	/**/
	pkey->pb = pfucb->pbKey + 1;
	pkey->cb = pfucb->cbKey - 1;

	pfucb2ndIdx = pfucb->pfucbCurIndex;

	if ( pfucb2ndIdx == pfucbNil )
		{
		err = ErrDIRDownFromDATA( pfucb, pkey );
		}
	else
		{
		Assert( FFUCBNonClustered( pfucb2ndIdx ) );
		err = ErrDIRDownFromDATA( pfucb2ndIdx, pkey );

		/*	if the movement was successful and a non-clustered index is
		/*	in use, then position clustered index to record.
		/**/
		if ( err == JET_errSuccess )
			{
			Assert(pfucb2ndIdx->lineData.pb != NULL);
			Assert(pfucb2ndIdx->lineData.cb >= sizeof(SRID));
			srid = PcsrCurrent( pfucb2ndIdx )->item;
			DIRDeferGotoBookmark( pfucb, srid );
			Assert( PgnoOfSrid( srid ) != pgnoNull );
			}
		}

	if ( err == JET_errSuccess && ( grbit & JET_bitSeekEQ ) != 0 )
		{
		/*	found equal on seek equal.  If index range grbit is
		/*	set then set index range upper inclusive.
		/**/
		if ( grbit & JET_bitSetIndexRange )
			{
			CallR( ErrIsamSetIndexRange( ppib, pfucb, JET_bitRangeInclusive | JET_bitRangeUpperLimit ) );
			}
		/*	reset key status.
		/**/
		KSReset( pfucb );

		return err;
		}

	/*	reset key status.
	/**/
	KSReset( pfucb );

	/*	remember if found less.
	/**/
	fFoundLess = ( err == wrnNDFoundLess );

	if ( err == wrnNDFoundLess || err == wrnNDFoundGreater )
		{
		err = JET_errRecordNotFound;
		}
	else if ( err < 0 )
		{
		PcsrCurrent( pfucb )->csrstat = csrstatBeforeFirst;
		if ( pfucb2ndIdx != pfucbNil )
			{
			PcsrCurrent( pfucb2ndIdx )->csrstat = csrstatBeforeFirst;
			}
		}

#define bitSeekAll (JET_bitSeekEQ | JET_bitSeekGE | JET_bitSeekGT |	\
	JET_bitSeekLE | JET_bitSeekLT)

	/*	adjust currency for seek request.
	/**/
	switch ( grbit & bitSeekAll )
		{
		case JET_bitSeekEQ:
			return err;

		case JET_bitSeekGE:
			if ( err != JET_errRecordNotFound )
				return err;
			err = ErrIsamMove( ppib, pfucb, +1L, grbitMove );
			if ( err == JET_errNoCurrentRecord )
				return JET_errRecordNotFound;
			else
				return JET_wrnSeekNotEqual;

		case JET_bitSeekGT:
			if ( err < 0 && err != JET_errRecordNotFound )
				return err;
			if ( err >= 0 || fFoundLess )
				grbitMove |= JET_bitMoveKeyNE;
			err = ErrIsamMove( ppib, pfucb, +1L, grbitMove );
			if ( err == JET_errNoCurrentRecord )
				return JET_errRecordNotFound;
			else
				return err;

		case JET_bitSeekLE:
			if ( err != JET_errRecordNotFound )
			    return err;
			err = ErrIsamMove( ppib, pfucb, JET_MovePrevious, grbitMove );
			if ( err == JET_errNoCurrentRecord )
			    return JET_errRecordNotFound;
			else
			    return JET_wrnSeekNotEqual;

		case JET_bitSeekLT:
			if ( err < 0 && err != JET_errRecordNotFound )
				return err;
			if ( err >= 0 || !fFoundLess )
				grbitMove |= JET_bitMoveKeyNE;
			err = ErrIsamMove( ppib, pfucb, JET_MovePrevious, grbitMove );
			if ( err == JET_errNoCurrentRecord )
				return JET_errRecordNotFound;
			else
				return err;
		}
        return err;
	}


	ERR VTAPI
ErrIsamGotoBookmark( PIB *ppib, FUCB *pfucb, BYTE *pbBookmark, ULONG cbBookmark )
	{
	ERR		err;
	LINE		key;

	CheckPIB( ppib );
	CheckTable( ppib, pfucb );
	Assert( FFUCBIndex( pfucb ) );
	CheckNonClustered( pfucb );

	if ( cbBookmark != sizeof(SRID) )
		return JET_errInvalidBookmark;
	Assert( cbBookmark == sizeof(SRID) );

	/*	reset copy buffer status
	/**/
	if ( FFUCBUpdatePrepared( pfucb ) )
		{
		CallR( ErrIsamPrepareUpdate( ppib, pfucb, JET_prepCancel ) );
		}

	/*	reset index range limit
	/**/
	DIRResetIndexRange( pfucb );

	/*	get node, and return error if this node is not there for caller.
	/**/
	DIRGotoBookmark( pfucb, *(SRID *)pbBookmark );
	Call( ErrDIRGet( pfucb ) );

	/*	bookmark must be for node in table cursor is on
	/**/
	Assert( PgnoPMPgnoFDPOfPage( pfucb->ssib.pbf->ppage ) == pfucb->u.pfcb->pgnoFDP );

	/*	goto bookmark record build key for secondary index
	/*	to bookmark record
	/**/
	if ( pfucb->pfucbCurIndex != pfucbNil )
		{
		/*	get non-clustered index cursor
		/**/
		FUCB		*pfucbIdx = pfucb->pfucbCurIndex;

		/*	allocate goto bookmark resources
		/**/
		if ( pfucb->pbKey == NULL )
			{
			pfucb->pbKey = LAlloc( 1L, JET_cbKeyMost );
			if ( pfucb->pbKey == NULL )
				return JET_errOutOfMemory;
			}

		/* make key for record for non-clustered index
		/**/
		key.pb = pfucb->pbKey;
		Call( ErrRECExtractKey( pfucb, (FDB *)pfucb->u.pfcb->pfdb, pfucbIdx->u.pfcb->pidb, &pfucb->lineData, &key, 1 ) );
		Assert( err != wrnFLDOutOfKeys );

		/*	record must honor index no NULL segment requirements
		/**/
		Assert( !( pfucbIdx->u.pfcb->pidb->fidb & fidbNoNullSeg ) ||
			( err != wrnFLDNullSeg && err != wrnFLDNullKey ) );

		/*	if item is not index,
		/*	then move before first instead of seeking
		/**/
		if ( ( err == wrnFLDNullKey && !( pfucbIdx->u.pfcb->pidb->fidb & fidbAllowAllNulls ) ) ||
			( err == wrnFLDNullSeg && !( pfucbIdx->u.pfcb->pidb->fidb & fidbAllowSomeNulls ) ) )
			{
			/*	This assumes that NULLs sort low.
			/**/
			DIRBeforeFirst( pfucbIdx );
			err = JET_errNoCurrentRecord;
			}
		else
			{
			/*	move to DATA root
			/**/
			DIRGotoDataRoot( pfucbIdx );

			/*	seek on secondary key
			/**/
			Call( ErrDIRDownKeyBookmark( pfucbIdx, &key, *(SRID *)pbBookmark ) );
			Assert( err == JET_errSuccess );

			/*	item must be same as bookmark and
			/*	clustered cursor must be on record.
			/**/
			Assert( pfucbIdx->lineData.pb != NULL );
			Assert( pfucbIdx->lineData.cb >= sizeof(SRID) );
			Assert( PcsrCurrent( pfucbIdx )->csrstat == csrstatOnCurNode );
			Assert( PcsrCurrent( pfucbIdx )->item == *(SRID *)pbBookmark );
			}
		}

HandleError:
	KSReset( pfucb );
	return err;
	}


	ERR VTAPI
ErrIsamGotoPosition( PIB *ppib, FUCB *pfucb, JET_RECPOS *precpos )
	{
	ERR		err;
	FUCB		*pfucb2ndIdx;
	SRID	 	srid;

	CheckPIB( ppib );
	CheckTable( ppib, pfucb );
	CheckNonClustered( pfucb );

	/*	Reset copy buffer status
	/**/
	if ( FFUCBUpdatePrepared( pfucb ) )
		{
		CallR( ErrIsamPrepareUpdate( ppib, pfucb, JET_prepCancel ) );
		}

	/*	reset index range limit
	/**/
	DIRResetIndexRange( pfucb );

	/*	reset key stat
	/**/
	KSReset( pfucb );

	/*	set non clustered index pointer, may be null
	/**/
	pfucb2ndIdx = pfucb->pfucbCurIndex;

	if ( pfucb2ndIdx == pfucbNil )
		{
		/*	move to DATA root
		/**/
		DIRGotoDataRoot( pfucb );

		err = ErrDIRGotoPosition( pfucb, precpos->centriesLT, precpos->centriesTotal );
		}
	else
		{
		/*	move to DATA root
		/**/
		DIRGotoDataRoot( pfucb2ndIdx );

		err = ErrDIRGotoPosition( pfucb2ndIdx, precpos->centriesLT, precpos->centriesTotal );

		/*	if the movement was successful and a non-clustered index is
		/*	in use, then position clustered index to record.
		/**/
		if ( err == JET_errSuccess )
			{
			Assert( pfucb2ndIdx->lineData.pb != NULL );
			Assert( pfucb2ndIdx->lineData.cb >= sizeof(SRID) );
			srid = PcsrCurrent( pfucb2ndIdx )->item;
			DIRDeferGotoBookmark( pfucb, srid );
			Assert( PgnoOfSrid( srid ) != pgnoNull );
			}
		}

	/*	if no records then return JET_errRecordNotFound
	/*	otherwise return error from called routine
	/**/
	if ( err < 0 )
		{
		PcsrCurrent( pfucb )->csrstat = csrstatBeforeFirst;

		if ( pfucb2ndIdx != pfucbNil )
			{
			PcsrCurrent( pfucb2ndIdx )->csrstat = csrstatBeforeFirst;
			}
		}
	else
		{
		Assert (err==JET_errSuccess || err==wrnNDFoundLess || err==wrnNDFoundGreater );
		err = JET_errSuccess;
		}

	return err;
	}

ERR VTAPI ErrIsamSetIndexRange( PIB *ppib, FUCB *pfucb, JET_GRBIT grbit )
	{
	ERR		err;
	FUCB		*pfucbIdx;

	/*	ppib is not used in this function.
	/**/
	NotUsed( ppib );

	/*	must be on index
	/**/
	if ( pfucb->u.pfcb->pidb == pidbNil && pfucb->pfucbCurIndex == pfucbNil )
      return JET_errNoCurrentIndex;

	/*	key must be prepared
	/**/
	if ( ! ( FKSPrepared( pfucb ) ) )
      return JET_errKeyNotMade;

	/*	get cursor for current index.  If non-clustered index,
	/*	then copy index range key to non-clustered index.
	/**/
	if ( pfucb->pfucbCurIndex != pfucbNil )
		{
		pfucbIdx = pfucb->pfucbCurIndex;
		if ( pfucbIdx->pbKey == NULL )
			{
			pfucbIdx->pbKey = LAlloc( 1L, JET_cbKeyMost );
			if ( pfucbIdx->pbKey == NULL )
				return JET_errOutOfMemory;
			}
		pfucbIdx->cbKey = pfucb->cbKey;
		memcpy( pfucbIdx->pbKey, pfucb->pbKey, pfucbIdx->cbKey );
		}
	else
		pfucbIdx = pfucb;

	/*	set index range and check current position.
	/**/
	DIRSetIndexRange( pfucbIdx, grbit );
	err = ErrDIRCheckIndexRange( pfucbIdx );

	/*	reset key status.
	/**/
	KSReset( pfucb );

	return err;
	}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\redo.c ===
#include "config.h"

#include <stdlib.h>
#include <string.h>

#include "daedef.h"
#include "ssib.h"
#include "pib.h"
#include "fmp.h"
#include "util.h"
#include "info.h"
#include "page.h"
#include "dbapi.h"
#include "node.h"
#include "fcb.h"
#include "fucb.h"
#include "stapi.h"
#include "stint.h"
#include "nver.h"
#include "recint.h"
#include "fdb.h"
#include "fileapi.h"
#include "fileint.h"
#include "dirapi.h"
#include "spaceapi.h"
#include "spaceint.h"
#include "logapi.h"
#include "log.h"
#include "bm.h"

DeclAssertFile;					/* Declare file name for assert macros */

extern INT itibGlobal;

static	CPPIB	*rgcppib = NULL;
static	CPPIB	*pcppibNext;
/*	points to cppib entry for current user
/**/
static	CPPIB	*pcppib;

LOCAL ERR ErrLGInitSession( DBENV *pdbenv );
LOCAL PIB *PpibOfProcid( PROCID procid );
LOCAL ERR ErrPpibFromProcid( PROCID procid, PIB **pppib );
LOCAL ERR ErrLGGetFucb( PIB *ppib, PN fdp, FUCB **ppfucb );
LOCAL ERR ErrLGBeginSession( PROCID procid, PIB **pppib );
ERR ErrFILEIGenerateFCB( FUCB *pfucb, FCB **ppfcb );
LOCAL ERR ErrRedoSplitPage( FUCB *pfucb, LRSPLIT *plrsplit,
	INT splitt, BOOL fRedoOnly );
LOCAL ERR ErrLGSetCSR( FUCB *pfucb );


/*	validate that page needs redoing, returns buffer pointer pbf.
/*	Also set ulDBTimeCurrent properly.
/**/
ERR ErrLGRedoable( PIB *ppib, PN pn, ULONG ulDBTime, BF **ppbf, BOOL *pfRedoable )
	{
	ERR		err;
	PAGE	*ppage;

	Call( ErrBFAccessPage( ppib, ppbf, pn ) );

	ppage = (*ppbf)->ppage;

	/* system database is run twice. 2nd time when we run
	/* the system database, the ulDBTimeCurrent is always >= ulDBTime
	/**/
	Assert ( DbidOfPn(pn) == dbidSystemDatabase ||
		rgfmp[ DbidOfPn(pn) ].ulDBTimeCurrent <= ulDBTime );

	rgfmp[ DbidOfPn(pn) ].ulDBTimeCurrent = ulDBTime;

	*pfRedoable = ulDBTime > ppage->pghdr.ulDBTime;

HandleError:
	/* succeed or page is not ready
	/**/
	Assert( err == JET_errSuccess || err == JET_errDiskIO );
	return err;
	}


ERR ErrDBStoreDBPath( CHAR *szDBName, CHAR **pszDBPath )
	{
	CHAR 	szFullName[JET_cbFullNameMost + 1];
	INT		cb;
	CHAR  	*sz;

	if ( _fullpath( szFullName, szDBName, JET_cbFullNameMost ) == NULL )
		{
		// UNDONE: should be illegal name or name too long etc.
		return JET_errDatabaseNotFound;
		}

	cb = strlen(szFullName) + 1;
	if (!(sz = SAlloc( cb )))
	{
		*pszDBPath = NULL;
		return JET_errOutOfMemory;
	}
	memcpy(sz, szFullName, cb);
	Assert(sz[cb - 1] == '\0');
	if (*pszDBPath != NULL)
		SFree(*pszDBPath);
	*pszDBPath = sz;

	return JET_errSuccess;
	}


/*
 *	Redo database operations in log from lgposRedoFrom to end.
 *
 *  GLOBAL PARAMETERS
 *			szLogName	  (IN)		full path to jet.log (blank if current)
 *			lgposRedoFrom (INOUT)	starting/ending usGeneration and ilgsec.
 *
 *  RETURNS
 *			JET_errSuccess				Everything went OK.
 *			-JET_errRestoreFailed 		Logs could not be interpreted
 */

ERR ErrLGRedo1( LGPOS *plgposRedoFrom )
	{
	ERR		err;
	PIB		*ppibRedo = ppibNil;
	DBID	dbid;
	LGPOS	lgposSave;
	CHAR	*szSav;
	CHAR	szLogNameSave[_MAX_PATH];
	INT		fStatus;

	/*	set flag to suppress logging
	/**/
	fRecovering = fTrue;

	/*	open the proper log file
	/**/
	CallR( ErrOpenRedoLogFile( plgposRedoFrom, &fStatus ) );
	if ( fStatus != fRedoLogFile )
		return JET_errMissingPreviousLogFile;
	Assert( hfLog != handleNil );

	/*  Rebuild system database to a consistent state at the
	 *  end of log file so that we can have a consistent attached
	 *  database.
	 *  No need to redo the detached file.
	 *  For hard restore, we still have to redo the detached file.
	 */

	/*	First initialize database aliasing avoidance logic:
	 *	 set all entries to zero.
	 *	 on first pass, each detach record will decrement
	 *	 on second pass each attach or create will increment
	 *	 when flag becomes zero or positive, redo for that database
	 *   is enabled
	 *
	 *  Also restore system db:
	 *    For both hard and Soft Restore, we know which database are attached
	 *	  at the end of logging; in 2nd pass, only redo those
	 *    attached database.
	 */

	/*	save starting log file name and position
	/**/
	szSav = szLogCurrent;
	lgposSave = *plgposRedoFrom;
	strcpy( szLogNameSave, szLogName );

	pbLastMSFlush = 0;
	memset( &lgposLastMSFlush, 0, sizeof(lgposLastMSFlush) );

	CallR( ErrLGInitSession( &plgfilehdrGlobal->dbenv ) );
	CallJ( ErrLGRedoOperations( plgposRedoFrom, fTrue ), Abort );
	CallJ( ErrLGEndAllSessions( fTrue, fTrue, plgposRedoFrom ), Abort );
	Assert( hfLog != handleNil );
	CallS( ErrSysCloseFile( hfLog ) );
	hfLog = handleNil;

	/*	restore starting log file name and position, reopen the log file
	/*	also restore some global variables.
	/**/
	*plgposRedoFrom = lgposSave;
	szLogCurrent = szSav;
	strcpy( szLogName, szLogNameSave );

#ifdef OVERLAPPED_LOGGING
	CallJ( ErrSysOpenFile( szLogName, &hfLog, 0L, fFalse, fTrue ), Abort);
#else
	CallJ( ErrSysOpenFile( szLogName, &hfLog, 0L, fFalse, fFalse ), Abort);
#endif
	CallJ( ErrLGReadFileHdr( hfLog, plgfilehdrGlobal ), Abort)
	_splitpath( szLogName, szDrive, szDir, szFName, szExt );

	/*	end of initialization logic redo all attached database
	/**/
	pbLastMSFlush = 0;
	memset( &lgposLastMSFlush, 0, sizeof(lgposLastMSFlush) );

	CallJ( ErrLGInitSession( &plgfilehdrGlobal->dbenv ), Abort );

	/*	at this point, we have a consistent system database
	/**/
	CallJ( ErrPIBBeginSession( &ppibRedo ), Abort );
	dbid = dbidSystemDatabase;
	CallJ( ErrDBOpenDatabase( ppibRedo,
		rgfmp[dbidSystemDatabase].szDatabaseName,
		&dbid,
		0 ), Abort );

	/*	in the middle of recovery, better set ulDBTimeCurrent properly
	/**/
	rgfmp[dbidSystemDatabase].ulDBTimeCurrent =
		rgfmp[dbidSystemDatabase].ulDBTime;

	CallJ( ErrFMPSetDatabases( ppibRedo ), Abort );

	/*	adjust cDetach such that those attached from beginning to the end
	/*	will be treated as attached in the beginning.
	/**/
	for ( dbid = 0; dbid < dbidUserMax; dbid++ )
		{
		FMP		*pfmp = &rgfmp[dbid];

		if ( !pfmp->szDatabaseName )
			continue;
		if ( pfmp->cDetach == 0 )
			{
			/*	no detach involved
			/**/
			pfmp->cDetach++;
			}
		}

Abort:
	if ( ppibRedo != ppibNil )
		PIBEndSession( ppibRedo );

	return err;
	}


ERR ErrLGRedo2( LGPOS *plgposRedoFrom )
	{
	INT		fStatus;
	ERR		err;

#ifdef PERFCNT
	CallR( ErrLGFlushLog(0) );
#else
	CallR( ErrLGFlushLog() );
#endif
	
	Assert ( hfLog != handleNil );
	CallR( ErrSysCloseFile( hfLog ) );
	hfLog = handleNil;
	
	/*	open the proper log file again
	/**/
	CallR( ErrOpenRedoLogFile( plgposRedoFrom, &fStatus ) );
	
	CallJ( ErrLGRedoOperations( plgposRedoFrom, fFalse ), Abort );
	CallJ( ErrLGEndAllSessions( fFalse, fTrue, plgposRedoFrom ), Abort );
	Assert ( hfLog != handleNil );

Abort:
	/*	set flag to suppress logging
	/**/
	fRecovering = fFalse;
	return err;
	}


/*
 *	Returns ppib for a given procid from log record.
 *
 *	PARAMETERS	procid		process id of session being redone
 *				pppib		out ppib
 *
 *	RETURNS		JET_errSuccess or error from called routine
 */

LOCAL PIB *PpibOfProcid( PROCID procid )
	{
	CPPIB	*pcppibMax = rgcppib + rgres[iresPIB].cblockAlloc;

	/*	find pcppib corresponding to procid if it exists
	/**/

	for( pcppib = rgcppib; pcppib < pcppibMax; pcppib++ )
		{
		if ( procid == pcppib->procid )
			{
			return pcppib->ppib;
			}
		}
	return ppibNil;
	}


LOCAL ERR ErrPpibFromProcid( PROCID procid, PIB **pppib )
	{
	ERR		err = JET_errSuccess;

	/*	if no record for procid then start new session
	/**/
	if ( ( *pppib = PpibOfProcid( procid ) ) == ppibNil )
		{
		CallR( ErrLGBeginSession( procid, pppib ) );
		/* recover the procid. This is used to record undo record
		/**/
		(*pppib)->procid = procid;
		(*pppib)->fAfterFirstBT = fFalse;
		}

	return JET_errSuccess;
	}


/*
 *	Returns pfucb for given pib and FDP.
 *
 *	PARAMETERS	ppib	pib of session being redone
 *				fdp		FDP page for logged page
 *				pbf		buffer for logged page
 *				ppfucb	out FUCB for open table for logged page
 *
 *	RETURNS		JET_errSuccess or error from called routine
 */

LOCAL ERR ErrLGGetFucb( PIB *ppib, PN pnFDP, FUCB **ppfucb )
	{
	ERR		err = JET_errSuccess;
	FCB		*pfcbTable;
	FCB		*pfcb;
	FUCB 	*pfucb;
	PGNO 	pgnoFDP = PgnoOfPn( pnFDP );
	DBID 	dbid = DbidOfPn ( pnFDP );

	/*	allocate an all-purpose fucb for this database if necessary
	/**/
	if ( pcppib->rgpfucbOpen[ dbid ] == pfucbNil )
		{
		CallR( ErrFUCBOpen( ppib, dbid, &pcppib->rgpfucbOpen[ dbid ] ) );
		Assert(pcppib->rgpfucbOpen[ dbid ] != pfucbNil);
		PcsrCurrent(pcppib->rgpfucbOpen[ dbid ])->pcsrPath = pcsrNil;
		(pcppib->rgpfucbOpen[ dbid ])->pfucbNextInstance = pfucbNil;
		}

	/*	reset copy buffer and key buffer
	/**/
	*ppfucb = pfucb = pcppib->rgpfucbOpen[ dbid ];
	FUCBResetUpdateSeparateLV( pfucb );
	FUCBResetCbstat( pfucb );
	pfucb->pbKey = NULL;
	KSReset( pfucb );

	if ( pfucb->u.pfcb != pfcbNil && pfucb->u.pfcb->pgnoFDP == pgnoFDP )
		{
		pfcb = (*ppfucb)->u.pfcb;
		}
	else
		{
		/*	we need to switch FCBs
		/**/
		if ( pfucb->u.pfcb != pfcbNil )	/* there was an old fcb */
			FCBUnlink( *ppfucb );		/* Unlink this fucb from it */

		/*	find fcb corresponding to pqgnoFDP, if it exists.
		 *	search all FCBs on global FCB list.  Search each table index,
		 *	and then move on to next table.
		 */
		for ( pfcbTable = pfcbGlobalList;
			  pfcbTable != pfcbNil;
			  pfcbTable = pfcbTable->pfcbNext )
			{
			for ( pfcb = pfcbTable;
				  pfcb != pfcbNil;
				  pfcb = pfcb->pfcbNextIndex )
				{
				if ( pgnoFDP == pfcb->pgnoFDP && dbid == pfcb->dbid )
					goto FoundFCB;
				}
			}

		/*  no existing fcb for FDP: open new fcb. Always open the FCB as
		 *  a regular table FCB and not a secondary index FCB. This is
		 *  will (hopefully) work for redo operations even for Dir operations
		 *  on secondary indexes (the FCB will already exist).
		 */
			{
			/* allocate an FCB and set up for FUCB
			/**/
			CallR( ErrFCBAlloc( ppib, &pfcb ) )
			memset( pfcb, 0, sizeof(FCB) );

			/*  Note: pfcb->pgnoRoot is not used in page oriented op so
			 *  it is OK to set it to an incorrect root.
			 *  But it is used in database operations, which need the
			 *  pgnoRoot being set to the system Root so that we can
			 *  add/delete entrys in system database.
			 */
			Assert( dbid != dbidSystemDatabase || pgnoFDP == pgnoSystemRoot);
			pfcb->pgnoRoot =
			pfcb->pgnoFDP = pgnoFDP;
			pfcb->bmRoot = SridOfPgnoItag( pgnoFDP, 0 );
			pfcb->pidb = pidbNil;
			pfcb->dbid = dbid;
			Assert(pfcb->wRefCnt == 0);
			Assert(pfcb->wFlags == 0);
			pfucb->u.pfcb = pfcb;

			/* put into global list */
			pfcb->pfcbNext = pfcbGlobalList;
			pfcbGlobalList = pfcb;

			}
FoundFCB:
		FCBLink( pfucb, pfcb);	/* link in the FUCB to new FCB */
		}	/* End "need to switch FCB's"	*/

	pfucb->dbid = dbid;				/* set dbid */

	return JET_errSuccess;
	}


//+------------------------------------------------------------------------
//
//	ErrLGSetCSR
//	=======================================================================
//
//	LOCAL ERR ErrLGSetCSR( pfucb )
//
//	Returns sets up the CSR for a given pfucb. The SSIB including pbf
//	must have been set up previously, and the page must be in the buffer.
//
//	PARAMETERS	pfucb  FUCB with SSIB and BF set up
//
//	RETURNS		JET_errSuccess (asserts on bad log record).
//
//-------------------------------------------------------------------------

LOCAL ERR ErrLGSetCSR( FUCB *pfucb )
	{
	CSR		*pcsr = pfucb->pcsr;
	PAGE	*ppage = pfucb->ssib.pbf->ppage;
	INT		itag = pfucb->ssib.itag;
	INT		itagFather = 0;
	INT		ibSon = 0;

	/*	current node is FOP
	/**/
	if	( itag != 0 )
		{
		/*	current node is not FOP, scan all lines to find its father
		/**/
		NDGetItagFatherIbSon( &itagFather, &ibSon, ppage, itag );
		if ( ibSon == ibSonNull )
			{
			Assert( fFalse );

			/*	cannot find father node, return failure
			/**/
			return JET_errRestoreFailed;
			}
		}

	/*	set up CSR and exit
	/**/
		{
//		LINE *pline;

		pcsr->csrstat = csrstatOnCurNode;
		Assert(pcsr->pgno);
		pcsr->ibSon = ibSon;
		pcsr->itagFather = itagFather;
		pcsr->itag = itag;

//		pline = &pfucb->lineData;
//		pline->cb = ppage->rgtag[itag].cb;
//		pline->pb = (BYTE *)ppage + ppage->rgtag[(itag)].ib;
		}

	return JET_errSuccess;
	}


//+------------------------------------------------------------------------
//
//	ErrLGBeginSession
//	=======================================================================
//
//	LOCAL ERR ErrLGBeginSession( procid, pppib )
//
//	Initializes a redo information block for a session to be redone.
//	A BeginSession is performed and the corresponding ppib is stored
//	in the block.  Start transaction level and transaction level
//	validity are initialized.  Future references to this sessions
//	information block will be identified by the given procid.
//
//	PARAMETERS	procid	process id of session being redone
//				pppib
//
//	RETURNS		JET_errSuccess, or error code from failing routine
//
//-------------------------------------------------------------------------
LOCAL ERR ErrLGBeginSession( PROCID procid, PIB **pppib )
	{
	ERR		err;

	/*	check if have run out of ppib table lookup
	/*	positions.	This could happen if between the
	/*	failure and redo, the number of system PIBs
	/*	set in CONFIG.DAE has been changed.
	/**/
	if ( (BYTE *) pcppibNext > (BYTE *)( rgcppib + rgres[iresPIB].cblockAlloc ) )
		return JET_errTooManyActiveUsers;
	pcppibNext->procid = procid;

	/*	use procid as unique user name
	/**/
	Call( ErrPIBBeginSession( &pcppibNext->ppib ) );

	*pppib = pcppibNext->ppib;
	pcppibNext++;
HandleError:
	return err;
	}


VOID LGStoreDBEnv( DBENV *pdbenv )
	{
	CHAR	rgbT[JET_cbFullNameMost + 1];
	INT		cbT;
	CHAR	*sz;

#ifdef NJETNT
	sz = _fullpath( pdbenv->szSysDbPath, rgtib[itibGlobal].szSysDbPath, JET_cbFullNameMost );
#else
	sz = _fullpath( pdbenv->szSysDbPath, szSysDbPath, JET_cbFullNameMost );
#endif
	Assert( sz != NULL );

	cbT = strlen( szLogFilePath );

	while ( szLogFilePath[ cbT ] == '\\' )
		cbT--;

	memcpy( rgbT, szLogFilePath, cbT );
	rgbT[ cbT ] = '\0';
	sz = _fullpath( pdbenv->szLogFilePath, rgbT, JET_cbFullNameMost );
	Assert( sz != NULL );

	Assert( lMaxSessions > 0 );
	Assert( lMaxOpenTables > 0 );
	Assert( lMaxVerPages > 0 );
	Assert( lMaxCursors > 0 );
	Assert( lLogBuffers > 0 );
	Assert( lMaxBuffers > 0 );

	pdbenv->ulMaxSessions = lMaxSessions;
	pdbenv->ulMaxOpenTables = lMaxOpenTables;
	pdbenv->ulMaxVerPages = lMaxVerPages;
	pdbenv->ulMaxCursors = lMaxCursors;
	pdbenv->ulLogBuffers = lLogBuffers;
	pdbenv->ulMaxBuffers = lMaxBuffers;

	return;
	}


LOCAL VOID LGRestoreDBEnv( DBENV *pdbenv )
	{
#ifdef NJETNT
	strcpy( rgtib[itibGlobal].szSysDbPath, pdbenv->szSysDbPath );
#else
	strcpy( szSysDbPath, pdbenv->szSysDbPath );
#endif
	strcpy( szLogFilePath, pdbenv->szLogFilePath );
	strcat( szLogFilePath, "\\" );

	lMaxSessions = pdbenv->ulMaxSessions;
	lMaxOpenTables = pdbenv->ulMaxOpenTables;
	lMaxVerPages = pdbenv->ulMaxVerPages;
	lMaxCursors = pdbenv->ulMaxCursors;
	lLogBuffers = pdbenv->ulLogBuffers;
	lMaxBuffers = pdbenv->ulMaxBuffers;

	Assert( lMaxSessions > 0 );
	Assert( lMaxOpenTables > 0 );
	Assert( lMaxVerPages > 0 );
	Assert( lMaxCursors > 0 );
	Assert( lLogBuffers > 0 );
	Assert( lMaxBuffers > 0 );

	return;
	}


LOCAL ERR ErrLGInitSession( DBENV *pdbenv )
	{
	ERR		err;
	INT		idbid;
	CPPIB	*pcppib;
	CPPIB	*pcppibMax;

	/*	set log stored db environment
	/**/
	LGRestoreDBEnv( pdbenv );

	CallR( ErrSTInit() );

	/*	initialize CPPIB structure
	/**/
	Assert( rgcppib == NULL );
	rgcppib = (CPPIB *) LAlloc( (LONG)rgres[iresPIB].cblockAlloc, sizeof(CPPIB) );
	if ( rgcppib == NULL )
		return JET_errOutOfMemory;

	pcppibMax = rgcppib + rgres[iresPIB].cblockAlloc;
	for ( pcppib = rgcppib; pcppib < pcppibMax; pcppib++ )
		{
		pcppib->procid = procidNil;
		pcppib->ppib = NULL;
		for( idbid = 0; idbid < dbidUserMax; idbid++ )
			pcppib->rgpfucbOpen[idbid] = pfucbNil;
		}
	pcppibNext = rgcppib;

	return err;
	}


VOID SetUlDBTime( BOOL fPass1 )
	{
	DBID	dbid;
	DBID	dbidFirst;
	DBID	dbidLast;

	if ( fPass1 )
		{
		dbidFirst = dbidSystemDatabase;
		dbidLast = dbidSystemDatabase + 1;
		}
	else
		{
		dbidFirst = dbidSystemDatabase + 1;
		dbidLast = dbidUserMax;
		}

	for ( dbid = dbidFirst; dbid < dbidLast; dbid++ )
		{
		FMP *pfmp = &rgfmp[ dbid ];

		/*	if there were operations and the file was opened for theose
		/*	operations, then set the time stamp.
		/**/
		if ( pfmp->ulDBTimeCurrent != 0 && pfmp->hf != handleNil )
			pfmp->ulDBTime = pfmp->ulDBTimeCurrent;
		}

	return;
	}


/*
 *	Ends redo session.
 *  If fEndOfLog, then write log records to indicate the operations
 *  for recovery. If fPass1 is true, then it is for phase1 operations,
 *  otherwise for phase 2.
 */

ERR ErrLGEndAllSessions( BOOL fPass1, BOOL fEndOfLog, LGPOS *plgposRedoFrom )
	{
	ERR		err = JET_errSuccess;
	CPPIB	*pcppib;
	CPPIB	*pcppibMax = rgcppib + rgres[iresPIB].cblockAlloc;
	LGPOS	lgposRecoveryUndo;

	SetUlDBTime( fPass1 );

	/*	set up pbWrite pbEntry etc for writing out the undo records
	/**/
	EnterCriticalSection( critLGBuf );
	
	Assert( pbRead >= pbLGBufMin + cbSec );
	pbEntry = pbNext;
	if ( pbLastMSFlush )
		{
		/*	should flush from last MS
		/**/
		isecWrite = lgposLastMSFlush.isec;
		pbWrite = PbSecAligned( pbLastMSFlush );
		}
	else
		{
		/*	no MS was read. continue flush from currently read page
		/**/
		pbWrite = PbSecAligned( pbEntry );
		isecWrite = sizeof( LGFILEHDR ) / cbSec * 2;
		}
	LeaveCriticalSection( critLGBuf );

	/*	write a RecoveryUndo record to indicate start to undo
	/**/
	if ( fEndOfLog )
		{
		if ( fPass1 )
			{
			CallR( ErrLGRecoveryUndo1( szRestorePath ) );
			}
		else
			{
			CallR( ErrLGRecoveryUndo2( szRestorePath ) );
			}
		}

	lgposRecoveryUndo = lgposLogRec;

	//	UNDONE:	is this call needed
 	(VOID)ErrRCECleanAllPIB();

	for ( pcppib = rgcppib; pcppib < pcppibMax; pcppib++ )
		{
		if ( pcppib->ppib != NULL )
			{
			Assert( sizeof(JET_VSESID) == sizeof(pcppib->ppib) );
			/*	rollback performed by ErrIsamEndSession
			/**/
			CallS( ErrIsamEndSession( (JET_VSESID)pcppib->ppib, 0 ) );
			pcppib->procid = procidNil;
			pcppib->ppib = NULL;
			}
		else
			break;
		}
	pcppibNext = rgcppib;

 	(VOID)ErrRCECleanAllPIB();

 	FCBResetAfterRedo();

	if ( fEndOfLog )
		{
		if ( fPass1 )
			{
			CallR( ErrLGRecoveryQuit1( &lgposRecoveryUndo,
				plgposRedoFrom,
				fHardRestore ) );
			}
		else
			{
			CallR( ErrLGRecoveryQuit2( &lgposRecoveryUndo,
				plgposRedoFrom,
				fHardRestore ) );
			}
		}

	/*	Note: flush is needed in case a new generation is generated and
	/*	the global variable szLogName is set while it is changed to new names.
	/*	critical section not requested, not needed
	/**/
#ifdef PERFCNT
	CallR( ErrLGFlushLog(0) );
#else
	CallR( ErrLGFlushLog() );
#endif

	/*	close the redo sesseion incurred in previous ErrLGRedo
	/**/
	Assert( rgcppib != NULL );
	LFree( rgcppib );
	rgcppib = NULL;

	CallS( ErrSTTerm() );

	return err;
	}


#define cbSPExt	30

#ifdef DEBUG
static	INT iSplit = 0;
#endif

#define	cbFirstPagePointer	sizeof(PGNO)

VOID UpdateSiblingPtr(SSIB *pssib, PGNO pgno, BOOL fLeft)
	{
	THREEBYTES tb;

	ThreeBytesFromL( tb, pgno );
	if (fLeft)
		pssib->pbf->ppage->pghdr.pgnoPrev = tb;
	else
		pssib->pbf->ppage->pghdr.pgnoNext = tb;
	}


ERR ErrLGRedoBackLinks(
	SPLIT	*psplit,
	FUCB	*pfucb,
	BKLNK	*rgbklnk,
	INT		cbklnk,
	ULONG	ulDBTimeRedo )
	{
	ERR		err;
	INT		ibklnk;
	SSIB	*pssib = &pfucb->ssib;
	BOOL	fLatched;

	/* backlinks maybe used by both split and merge
	/*
	/* when used by MERGE only:
	/*  sridBackLink != pgnoSplit
	/*      ==> a regular backlink
	/*  sridBackLink == pgnoSplit && sridNew == sridNull
	/*      ==> move the node from old page to new page,
	/*			delete node on old page.
	/*  sridBackLink == pgnoSplit && sridNew != sridNull
	/*      ==> replace link on old page with new link.
	/**/
	for ( ibklnk = 0; ibklnk < cbklnk; ibklnk++ )
		{
		BKLNK	*pbklnk = &rgbklnk[ ibklnk ];
		PGNO	pgno = PgnoOfSrid( ( SRID ) ( (UNALIGNED BKLNK *) pbklnk )->sridBackLink );
		INT		itag = ItagOfSrid( ( SRID ) ( (UNALIGNED BKLNK *) pbklnk )->sridBackLink );
		SRID	sridNew = (SRID ) ( (UNALIGNED BKLNK *) pbklnk )->sridNew; //efficiency variable

		PcsrCurrent( pfucb )->pgno = pgno;
		CallR( ErrSTWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
		Assert( fRecovering );
		if ( pssib->pbf->ppage->pghdr.ulDBTime >= ulDBTimeRedo )
			continue;

		pssib->itag = itag;
		PMDirty( pssib );

		if ( sridNew == sridNull )
			{
			INT itagFather;
			INT ibSon;

			NDGetItagFatherIbSon( &itagFather, &ibSon, pssib->pbf->ppage, pssib->itag );
			PcsrCurrent(pfucb)->itag = pssib->itag;
			PcsrCurrent(pfucb)->itagFather = itagFather;
			PcsrCurrent(pfucb)->ibSon = ibSon;
			CallR( ErrNDDeleteNode( pfucb ) );
			}
		else if ( pgno == psplit->pgnoSplit )
			{
			INT itagFather;
			INT ibSon;

			/* locate FOP, and delete its sons entry
			/**/
			NDGetItagFatherIbSon( &itagFather, &ibSon, pssib->pbf->ppage, pssib->itag );
			PcsrCurrent(pfucb)->itag = pssib->itag;
			PcsrCurrent(pfucb)->itagFather = itagFather;
			PcsrCurrent(pfucb)->ibSon = ibSon;
			Assert( PgnoOfSrid( sridNew ) != pgnoNull );
			Assert( (UINT) ItagOfSrid( sridNew ) > 0 );
			Assert( (UINT) ItagOfSrid( sridNew ) < (UINT) ctagMax );
			CallS( ErrNDReplaceWithLink( pfucb, sridNew ) );
			}
		else
			{
			Assert( PgnoOfSrid( sridNew ) != pgnoNull );
			Assert( (UINT) ItagOfSrid( sridNew ) > 0 );
			Assert( (UINT) ItagOfSrid( sridNew ) < (UINT) ctagMax );
			PMReplaceLink( pssib, sridNew );
			}

		/* store backlink page buffers
		/**/
		CallR( ErrBTStoreBackLinkBuffer( psplit, pssib->pbf, &fLatched ) );

		if ( fLatched )
			continue;

		/* do latch such that it will be released in ReleaseSplitBfs
		/**/
		BFPin( pssib->pbf );
		BFSetWriteLatch( pssib->pbf, pssib->ppib );

		//	UNDONE:	improve this code
		/*	set uldbTime in such a way that it will be redo if the same
		/*	page is referenced again. 3 is a magic number that is the
		/*	biggest ulDBTime increment for any one page operation.
		/**/
		pssib->pbf->ppage->pghdr.ulDBTime = ulDBTimeRedo - 3;
		}

	return JET_errSuccess;
	}


//	UNDONE:	have Cheen/Sriram review this routine as it has been changed considerably
/*	LOCAL ERR ErrLGRedoMergePage(
/*		FUCB		*pfucb,
/*		LRMERGE		*plrmerge,
/*		BOOL		fCheckBackLinkOnly )
/**/
LOCAL ERR ErrLGRedoMergePage(
	FUCB		*pfucb,
	LRMERGE		*plrmerge,
	BOOL		fCheckBackLinkOnly )
	{
	ERR			err;
	SPLIT		*psplit;
	SSIB 		*pssib = &pfucb->ssib;
	FUCB		*pfucbRight = pfucbNil;
	SSIB		*pssibRight;

	/******************************************************
	/*	initialize local variables and allocate split resources
	/**/
	psplit = SAlloc( sizeof(SPLIT) );
	if ( psplit == NULL )
		{
		return JET_errOutOfMemory;
		}

	memset( (BYTE *)psplit, 0, sizeof(SPLIT) );
	psplit->ppib = pfucb->ppib;
	psplit->ulDBTimeRedo = plrmerge->ulDBTime;
	psplit->pgnoSplit = PgnoOfPn( plrmerge->pn );
	psplit->pgnoSibling = plrmerge->pgnoRight;

	if ( fCheckBackLinkOnly )
		{
		/* only need to check backlinks
		/**/
		err = ErrLGRedoBackLinks(
			psplit,
			pfucb,
			(BKLNK *)&plrmerge->rgb,
			plrmerge->cbklnk, psplit->ulDBTimeRedo );
		}
	else
		{
		/*	access merged and sibling pages, and latch buffers
		/**/
		psplit->ibSon = 0;
		psplit->splitt = splittRight;

		/*	access page to free and remove buffer dependencies
		/**/
		PcsrCurrent( pfucb )->pgno = PgnoOfPn( plrmerge->pn );
		forever
			{
			Call( ErrSTWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
			Assert( !( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) ) );

			/*	if no dependencies, then break
			/**/
			if ( pfucb->ssib.pbf->cDepend == 0 &&
				pfucb->ssib.pbf->pbfDepend == pbfNil )
				{
				break;
				}

			/*	remove dependencies on buffer of page to be removed, to
			/*	prevent buffer anomalies after buffer is reused.
			/**/
			BFRemoveDependence( pfucb->ppib, pfucb->ssib.pbf );
			}
		Assert( pfucb->ssib.pbf->cDepend == 0 );

		BFPin( pssib->pbf );
		BFSetWriteLatch( pssib->pbf, pfucb->ppib );
		psplit->pbfSplit = pssib->pbf;

		/*	allocate cursor for right page
		/**/
		Call( ErrDIROpen( pfucb->ppib, pfucb->u.pfcb, 0, &pfucbRight ) );
		pssibRight = &pfucbRight->ssib;

		/*	access page to free and remove buffer dependencies
		/**/
		PcsrCurrent( pfucbRight )->pgno = plrmerge->pgnoRight;
		forever
			{
			Call( ErrSTWriteAccessPage( pfucbRight, PcsrCurrent( pfucbRight )->pgno ) );
			Assert( !( FBFWriteLatchConflict( pfucbRight->ppib, pfucbRight->ssib.pbf ) ) );

			/*	if no dependencies, then break
			/**/
			if ( pfucbRight->ssib.pbf->cDepend == 0 &&
				pfucbRight->ssib.pbf->pbfDepend == pbfNil )
				{
				break;
				}

			/*	remove dependencies on buffer of page to be removed, to
			/*	prevent buffer anomalies after buffer is reused.
			/**/
			BFRemoveDependence( pfucbRight->ppib, pfucbRight->ssib.pbf );
			}
		Assert( pfucbRight->ssib.pbf->cDepend == 0 );

		BFPin( pssibRight->pbf );
		BFSetWriteLatch( pssibRight->pbf, pfucbRight->ppib );
		psplit->pbfSibling = pssibRight->pbf;

		err = ErrBMDoMerge( pfucb, pfucbRight, psplit );
		Assert( err == JET_errSuccess );
		}

HandleError:
	if ( pfucbRight != pfucbNil )
		{
		DIRClose( pfucbRight );
		}

	/* release allocated buffers
	/**/
	BTReleaseSplitBfs( fTrue, psplit, err );
	Assert( psplit != NULL );
	SFree( psplit );

	return err;
	}


/*
 *	ERR ErrRedoSplitPage(
 *		FUCB		*pfucb,
 *		LRSPLIT		*plrsplit,
 *		INT			splitt,
 *		BOOL		fSkipMoves )
 *
 *		pfucb		cursor pointing at node which is to be split
 *		pgnonew	new page which has already been allocated for the split
 *		ibSplitSon is node at which to split for R or L, 0 for V, and
 *					total sons of FOP for Addend
 *		pgnoFather	page which contains pointer to page being split
 *					(V: unused)
 *		itagFather itag of the father node in the page
 *		splitt	type of split
 *		pgtyp		page type for new page
 *		fSkipMoves	Do not do moves, do correct links and insert parent
 */

ERR ErrRedoSplitPage(
	FUCB		*pfucb,
	LRSPLIT		*plrsplit,
	INT			splitt,
	BOOL		fSkipMoves )
	{
	ERR			err = JET_errSuccess;
	SPLIT		*psplit;

	SSIB 		*pssib = &pfucb->ssib;
	CSR			*pcsr = pfucb->pcsr;
	FUCB		*pfucbNew;
	FUCB		*pfucbNew2 = pfucbNil;
	FUCB		*pfucbNew3 = pfucbNil;
	SSIB 		*pssibNew;
	SSIB 		*pssibNew2;
	SSIB 		*pssibNew3;
	static	 	BYTE rgb[cbPage];
	BOOL		fAppend;

	/*	allocate additional cursor
	/**/
	pfucbNew = pfucbNil;
	Call( ErrDIROpen( pfucb->ppib, pfucb->u.pfcb, 0, &pfucbNew ) );
	pssibNew = &pfucbNew->ssib;
	if ( splitt == splittDoubleVertical )
		{
		Call( ErrDIROpen( pfucb->ppib, pfucb->u.pfcb, 0, &pfucbNew2 ) );
		pssibNew2 = &pfucbNew2->ssib;
		Call( ErrDIROpen( pfucb->ppib, pfucb->u.pfcb, 0, &pfucbNew3 ) );
		pssibNew3 = &pfucbNew3->ssib;
		}

	/*	initialize local variables and
	/*	allocate and set up split resources
	/**/
	SetupSSIB( pssibNew, pfucb->ppib );
	SSIBSetDbid( pssibNew, pfucb->dbid );

	psplit = SAlloc( sizeof(SPLIT) );
	if ( psplit == NULL )
		{
		err = JET_errOutOfMemory;
		goto HandleError;
		}

	memset( (BYTE *)psplit, '\0', sizeof(SPLIT) );

	psplit->ppib = pfucb->ppib;
	psplit->ulDBTimeRedo = plrsplit->ulDBTime;
	psplit->dbid = pfucb->dbid;
	psplit->pgnoSplit = PgnoOfPn(plrsplit->pn);
	psplit->itagSplit = plrsplit->itagSplit;
	psplit->ibSon = plrsplit->ibSonSplit;
	psplit->pgnoNew = plrsplit->pgnoNew;
	psplit->pgnoNew2 = plrsplit->pgnoNew2;
	psplit->pgnoNew3 = plrsplit->pgnoNew3;
	psplit->pgnoSibling = plrsplit->pgnoSibling;
	psplit->splitt = splitt;
	psplit->fLeaf = plrsplit->fLeaf;
	psplit->key.cb = plrsplit->cbKey;
	psplit->key.pb = plrsplit->rgb;
	psplit->keyMac.cb = plrsplit->cbKeyMac;
	psplit->keyMac.pb = plrsplit->rgb + plrsplit->cbKey;
	fAppend = ( splitt == splittAppend );

	/*	set up FUCB
	/**/
	pfucb->ssib.itag =
		PcsrCurrent(pfucb)->itag = psplit->itagSplit;
	PcsrCurrent(pfucb)->pgno = psplit->pgnoSplit;

	/*	set up the two split pages
	/*	always update new page for append
	/**/
	if ( fAppend || !fSkipMoves )
		{
	    Call( ErrBTSetUpSplitPages( pfucb,
			pfucbNew,
			pfucbNew2,
			pfucbNew3,
			psplit,
			plrsplit->pgtyp,
			fAppend,
			fSkipMoves ) );

		if ( psplit->pbfSplit != pbfNil )
			{
			BFSetDirtyBit(pssib->pbf);
			}
		else
			{
			/*	give up the buffer
			/**/
			pssib->pbf = pbfNil;
			}

		BFSetDirtyBit( pssibNew->pbf );
		}

	/******************************************************
	 *	perform split
	 */

	switch ( psplit->splitt )
		{
		case splittVertical:
			{
			if ( fSkipMoves )
				break;

			CallR( ErrBTSplitVMoveNodes( pfucb,
				pfucbNew,
				psplit,
				pcsr,
				rgb,
				fDoMove ) );
			break;
			}

		case splittDoubleVertical:
			{
			if ( fSkipMoves )
				break;

			BFSetDirtyBit( pssibNew2->pbf );
			BFSetDirtyBit( pssibNew3->pbf );

			CallR( ErrBTSplitDoubleVMoveNodes( pfucb,
				pfucbNew,
				pfucbNew2,
				pfucbNew3,
				psplit,
				pcsr,
				rgb,
				fDoMove ) );
			break;
			}

		case splittLeft:
		case splittRight:
		case splittAppend:
			{
			CSR 	csrPagePointer;
			BOOL	fLeft =	psplit->splitt == splittLeft;

			/*	do not call the following function if it is not redoable
			/**/
			Assert( pssib == &pfucb->ssib );

			if ( psplit->pbfSplit == pbfNil )
				{
				Assert ( fAppend || fSkipMoves );

				if ( fAppend )
					{
					/*	always update new page links for append
					/**/
					UpdateSiblingPtr( pssibNew, psplit->pgnoSplit, !fLeft );
					UpdateSiblingPtr( pssibNew, psplit->pgnoSibling, fLeft );
					AssertBFDirty( pssibNew->pbf );
					}

				goto RedoLink;
				}

			/*	we check the time stamp in redoable function
			/**/
			Assert(	plrsplit->ulDBTime > pssib->pbf->ppage->pghdr.ulDBTime );

			CallR( ErrLGSetCSR( pfucb ) );
			CallR( ErrBTSplitHMoveNodes( pfucb, pfucbNew, psplit, rgb, fDoMove ) );

			UpdateSiblingPtr( pssib, psplit->pgnoNew, fLeft );
			AssertBFDirty( pssib->pbf );

			UpdateSiblingPtr( pssibNew, psplit->pgnoSplit, !fLeft );
			UpdateSiblingPtr( pssibNew, psplit->pgnoSibling, fLeft );
			AssertBFDirty( pssibNew->pbf );

RedoLink:
			/*  make sure ulDBTime is set properly in btsplit and
			/*  then check if link is necessary.
			/**/
			Assert( pssib == &pfucb->ssib );
			Assert( pssibNew == &pfucbNew->ssib );

			if ( plrsplit->pgnoSibling == 0 )
				goto UpdateParentPage;

			CallR( ErrSTWriteAccessPage( pfucb, plrsplit->pgnoSibling ) );
			if ( plrsplit->ulDBTime <= pssib->pbf->ppage->pghdr.ulDBTime )
				goto UpdateParentPage;

			psplit->pbfSibling = pssib->pbf;
			BFPin( pssib->pbf );
			BFSetWriteLatch( pssib->pbf, pssib->ppib );
			BFSetDirtyBit( pssib->pbf );
			UpdateSiblingPtr( pssib,
				psplit->pgnoNew,
				psplit->splitt != splittLeft );

UpdateParentPage:
			/*	set page pointer to point to father node
			/**/
			CallR( ErrSTWriteAccessPage( pfucb, plrsplit->pgnoFather ) );

			/*  make sure ulDBTime is set properly in InsertPage.
			/*  check the page's db time stamp to see if insert is necessary.
			/**/
			Assert( pssib == &pfucb->ssib );
			if ( plrsplit->ulDBTime <= pssib->pbf->ppage->pghdr.ulDBTime )
				break;

			csrPagePointer.pgno = plrsplit->pgnoFather;
			csrPagePointer.itag = plrsplit->itagFather;
			csrPagePointer.itagFather = plrsplit->itagGrandFather;
			csrPagePointer.ibSon = plrsplit->ibSonFather;

			Call( ErrBTInsertPagePointer( pfucb,
				&csrPagePointer,
				psplit,
				rgb ) );
			break;
			}
		}

	/*	check if any backlinks needs update even we did not do moves
	/**/
	if ( fSkipMoves )
		{
		CallR( ErrLGRedoBackLinks(
			psplit,
			pfucb,
			(BKLNK *)( plrsplit->rgb + plrsplit->cbKey + plrsplit->cbKeyMac ),
			plrsplit->cbklnk,
			psplit->ulDBTimeRedo ) );
		}

HandleError:
//	Assert( psplit->splitt != splittNull );
	#ifdef SPLIT_TRACE
		PrintF2( "Split............................... %d\n", iSplit++);
		switch ( psplit->splitt )
			{
			case splittNull:
				PrintF2( "split split type = null\n" );
				break;
			case splittVertical:
				PrintF2( "split split type = vertical\n" );
				break;
			case splittRight:
				if	( fAppend )
					PrintF2( "split split type = append\n" );
				else
					PrintF2( "split split type = right\n" );
				break;
			case splittLeft:
				PrintF2( "split split type = left\n" );
			};
		PrintF2( "split page = %lu\n", psplit->pgnoSplit );
		PrintF2( "dbid = %u\n", psplit->dbid );
		PrintF2( "fFDP = %d\n", psplit->fFDP );
		PrintF2( "fLeaf = %d\n", FNDVisibleSons( *pssib->line.pb ) );
		PrintF2( "split itag = %d\n", psplit->itagSplit );
		PrintF2( "split ibSon = %d\n", psplit->ibSon );
		PrintF2( "new page = %lu\n", psplit->pgnoNew );
		PrintF2( "\n" );
	#endif

	/*	release split resources
	/**/
	Assert( psplit != NULL );
	BTReleaseSplitBfs( fTrue, psplit, err );
	Assert( psplit != NULL );
	SFree( psplit );

	if ( pfucbNew != pfucbNil )
		DIRClose( pfucbNew );
	if ( pfucbNew2 != pfucbNil )
		DIRClose( pfucbNew2 );
	if ( pfucbNew3 != pfucbNil )
		DIRClose( pfucbNew3 );

	return err;
	}


#ifdef DEBUG
LGPOS lgposRedo;

void TraceRedo(LR *plr)
	{
	/* easier to debug */
	GetLgposOfPbNext(&lgposRedo);

	if (fDBGTraceRedo)
		{
		PrintLgposReadLR();
		ShowLR(plr);
		}
	}
#else
#define TraceRedo
#endif


#ifdef DEBUG
#ifndef RFS2

#undef CallJ
#undef CallR

#define CallJ(f, hndlerr)									\
		{													\
		if ((err = (f)) < 0)								\
			{												\
			AssertSz(0,"Debug Only: ignore this assert");	\
			goto hndlerr;									\
			}												\
		}

#define CallR(f)											\
		{													\
		if ((err = (f)) < 0)								\
			{												\
			AssertSz(0,"Debug Only: ignore this assert");	\
			return err;										\
			}												\
		}

#endif
#endif


/*  pbline contains the diffs, this function then expand the diff and
 *  put the result record in rgbRecNew.
 */
VOID BTIMergeReplaceC( LINE *pline, BYTE *pbNDData, INT cbNDData, BYTE *rgbRecNew )
	{
	BYTE *pb, *pbOld, *pbDif, *pbDifMax;
	BYTE *pbOldLeast, *pbOldMax;
	INT cb;

	/* restore new data from RecDif */
	pb = rgbRecNew;

	pbOldLeast =
	pbOld = pbNDData;

	pbOldMax = pbOldLeast +	cbNDData;
	pbDif = pline->pb;
	pbDifMax = pbDif + pline->cb;

	while( pbDif < pbDifMax )
		{
		/* get offset, stored in cb */
		cb = *(UNALIGNED SHORT *)pbDif;
		pbDif += sizeof(SHORT);

		/* copy unchanged data */
		cb -= (INT)(pbOld - pbOldLeast);
		memcpy(pb, pbOld, cb );
		pbOld += cb;
		pb += cb;

		/* get data length */
		cb = *(BYTE *)pbDif;
		pbDif += sizeof(BYTE);

		/* copy new data */
		memcpy(pb, pbDif, cb);
		pbOld += cb;
		pb += cb;

		/* skip data */
		pbDif += cb;
		}

	cb = (INT)(pbOldMax - pbOld);
	memcpy(pb, pbOld, cb);
	pb += cb;

	pline->pb = rgbRecNew;
	pline->cb = (UINT)(pb - rgbRecNew);
	}


ERR ErrLGIRedoOnePageOperation( LR *plr, BOOL fPass1 )
	{
	ERR				err;
	PIB				*ppib;
	FUCB			*pfucb;
	PN				pn;
	BF				*pbf;
	PROCID			procid;
	DBID			dbid;
	KEY				key;
	BOOL			fRedoNeeded;
	ULONG			ulDBTime;
	CSR				*pcsr;
	LRINSERTNODE	*plrinsertnode = (LRINSERTNODE *) plr;

	procid = plrinsertnode->procid;
	pn = plrinsertnode->pn;
	ulDBTime = plrinsertnode->ulDBTime;

	CallR( ErrPpibFromProcid( procid, &ppib ) );
	if ( !ppib->fAfterFirstBT )
		return JET_errSuccess;

	/*	check if we have to redo the database.
 	/*	1) Redo sysDB for 1st pass for both soft/hard restore.
 	/*	2) Redo for 2nd pass soft/hard restore which db is last attached.
	/**/
	dbid = DbidOfPn( pn );
 	if ( !( fPass1 && dbid == dbidSystemDatabase || !fPass1 && rgfmp[dbid].cDetach > 0 ) )
		return JET_errSuccess;

	/*	check if database needs opening
	/**/
	if ( !FUserOpenedDatabase( ppib, dbid ) )
		{
		DBID dbidT = dbid;
		CallR( ErrDBOpenDatabase( ppib, rgfmp[dbid].szDatabaseName, &dbidT, 0 ) );
		Assert( dbidT == dbid);
		/*	reset to prevent interference
		/**/
		rgfmp[ dbid ].ulDBTime = 0;
		}

	err = ErrLGRedoable( ppib, pn, ulDBTime, &pbf, &fRedoNeeded );
	if ( err < 0 )
		return err;

	/*	latch buffer, lest it gets flushed
	/**/
	BFPin( pbf );
	
	TraceRedo( plr );

	Call( ErrLGGetFucb( ppib,
		PnOfDbidPgno( dbid, pbf->ppage->pghdr.pgnoFDP ),
		&pfucb ) );

	/* operation on the node on the page; prepare for it
	/**/
	pcsr = PcsrCurrent( pfucb );

	pfucb->ssib.pbf = pbf;
	pcsr->pgno = PgnoOfPn( pn );

	switch ( plr->lrtyp )
		{
		case lrtypInsertNode:
		case lrtypInsertItemList:
			{
			LRINSERTNODE	*plrinsertnode = (LRINSERTNODE *)plr;
			LINE			line;
			BYTE			bHeader = plrinsertnode->bHeader;

			/*	set CSR
			/**/
			pcsr->itag = plrinsertnode->itagSon;
			pcsr->itagFather = plrinsertnode->itagFather;
			pcsr->ibSon = plrinsertnode->ibSon;

			key.pb = plrinsertnode->szKey;
			key.cb = plrinsertnode->cbKey;
			line.pb = key.pb + key.cb;
			line.cb = plrinsertnode->cbData;

			if ( plr->lrtyp == lrtypInsertItemList )
				{
				pcsr->isrid = 0;
				pcsr->bm = SridOfPgnoItag( pcsr->pgno, pcsr->itag );
				/*	cach item for later reference
				/**/
				Assert( line.cb == sizeof(SRID) );
				pcsr->item = *(UNALIGNED SRID *)line.pb;
				}

			/*	even if operation is not redone, create version
			/*	for rollback support.
			/**/
			if ( !fRedoNeeded )
				{
				if ( plr->lrtyp == lrtypInsertItemList )
					{
					if ( !( plrinsertnode->fDIRFlags & fDIRVersion ) )
						{
						err = JET_errSuccess;
						goto HandleError;
						}
					while ( ( err = ErrVERInsertItem( pfucb, pcsr->bm ) ) == errDIRNotSynchronous );
					Call( err );
					}
				else if ( FNDVersion( bHeader ) )
					{
					/*	set ssib pointing to node flags
					/**/
					pfucb->ssib.line.pb = &bHeader;
					pfucb->ssib.line.cb = sizeof(BYTE);

					pfucb->lineData.pb = pbNil;
					pfucb->lineData.cb = 0;

					while ( ( err = ErrVERInsert( pfucb,
						SridOfPgnoItag( pcsr->pgno, pcsr->itag ) ) )
						==  errDIRNotSynchronous );
					Call( err );
					}

				err = JET_errSuccess;
				goto HandleError;
				}

			if ( plr->lrtyp == lrtypInsertItemList )
				{
				do
					{
					Assert( PcsrCurrent( pfucb )->isrid == 0 );
					err = ErrNDInsertItemList( pfucb,
						&key,
						pcsr->item,
						plrinsertnode->fDIRFlags );
					}
				while ( err == errDIRNotSynchronous );
				Call( err );
				}
			else
				{
				/*	pfucb->ssib, key, line must be set correctly
				/**/
				do
					{
					err = ErrNDInsertNode( pfucb, &key, &line, bHeader );
					}
				while( err == errDIRNotSynchronous );
				Call( err );
				}
			Assert( pfucb->pcsr->itag == plrinsertnode->itagSon );
			Assert( pfucb->pcsr->ibSon == plrinsertnode->ibSon );
			}
			break;

		case lrtypReplace:
		case lrtypReplaceC:
			{
			LRREPLACE	*plrreplace = (LRREPLACE *)plr;
			LINE		line;
			BYTE		rgbRecNew[cbNodeMost];
			UINT		cbOldData = plrreplace->cbOldData;
			UINT		cbNewData = plrreplace->cbNewData;

			/*	set CSR
			/**/
			pcsr->itag = plrreplace->itag;
			pcsr->bm = plrreplace->bm;

			if ( plrreplace->fOld )
				{
				/*	make replace idempotent!
				/*	set ssib so that VERModify can work properly
				/**/
				pfucb->ssib.line.cb =
					pfucb->lineData.cb = cbOldData;

				pfucb->ssib.line.pb =
					pfucb->lineData.pb = plrreplace->szData + plrreplace->cb;
				}

			/*	even if operation is not redone, create version
			/*	for rollback support.
			/**/
			if ( !fRedoNeeded )
				{
				RCE *prce;

				if ( !( plrreplace->fDIRFlags & fDIRVersion ) )
					{
					err = JET_errSuccess;
					goto HandleError;
					}

				if ( !plrreplace->fOld )
					{
					/*  no before image, and same transaction level so
					/*  get the rce and adjust its cbAdjust.
					/**/
					prce = PrceRCEGet( pfucb->dbid, pcsr->bm );
					}
				else
					{
					while( ErrVERModify( pfucb,
						pcsr->bm,
						operReplace,
						&prce )
						== errDIRNotSynchronous );
					Call( err );
					}

				if ( prce != prceNil && cbNewData != cbOldData )
					{
					VERSetCbAdjust( pfucb,
						prce,
						cbNewData,
						cbOldData,
						fDoNotUpdatePage );
					}

				err = JET_errSuccess;
				goto HandleError;
				}

			/*  cache node
			/**/
			NDGet( pfucb, pcsr->itag );
			NDGetNode( pfucb );

			/*	line to point to the data/diffs of lrreplace/lrreplaceC
			/**/
			line.pb = plrreplace->szData;
			line.cb = plrreplace->cb;

			if ( plr->lrtyp == lrtypReplaceC )
				{
				BTIMergeReplaceC( &line,
					PbNDData( pfucb->ssib.line.pb ),
					CbNDData( pfucb->ssib.line.pb, pfucb->ssib.line.cb ),
					rgbRecNew );
				}
			Assert( line.cb == cbNewData );

			/*  cache node
			/**/
			NDGet( pfucb, PcsrCurrent( pfucb )->itag );
			NDGetNode( pfucb );

			/*	replace node may return not synchronous error if out of
			/*  version buckets so call in loop to ensure this case handled.
			/**/
			while ( ( err = ErrNDReplaceNodeData( pfucb, &line, plrreplace->fDIRFlags ) )
					== errDIRNotSynchronous );
			Call( err );
			}
			break;

		case lrtypFlagDelete:
			{
			LRFLAGDELETE *plrflagdelete = (LRFLAGDELETE *) plr;

			/*	set CSR
			/**/
			pcsr->itag = plrflagdelete->itag;
			pcsr->bm = plrflagdelete->bm;

			/*	even if operation is not redone, create version
			/*	for rollback support.
			/**/
			if ( !fRedoNeeded )
				{
				if ( ! ( plrflagdelete->fDIRFlags & fDIRVersion ) )
					{
					err = JET_errSuccess;
					goto HandleError;
					}

				while( ( err = ErrVERModify( pfucb,
					pcsr->bm,
					operFlagDelete,
					pNil ) )
					== errDIRNotSynchronous );
				goto HandleError;
				}

			/*	cache node
			/**/
			NDGet( pfucb, pcsr->itag );

			/*	redo operation
			/**/
			while( ( err = ErrNDFlagDeleteNode( pfucb,
				plrflagdelete->fDIRFlags ) ) == errDIRNotSynchronous );
			Call( err );
			}
			break;

		case lrtypLockRec:
			{
			LRLOCKREC	*plrlockrec = (LRLOCKREC *) plr;
			RCE 		*prce;

			/*	set CSR
			/**/
			pcsr->itag = plrlockrec->itag;
			pcsr->bm = plrlockrec->bm;

			/*	set ssib so that VERModify can work properly
			/**/
			pfucb->ssib.line.cb =
				pfucb->lineData.cb = plrlockrec->cbOldData;

			pfucb->ssib.line.pb =
				pfucb->lineData.pb = plrlockrec->szData;

			while( ErrVERModify( pfucb,
					pcsr->bm,
					operReplace,
					&prce )
					== errDIRNotSynchronous );
			Call( err );

			if ( !fRedoNeeded )
				{
				goto HandleError;
				}
			BFSetDirtyBit( pbf );
			}
			break;

		case lrtypUpdateHeader:
			{
			LRUPDATEHEADER *plrupdateheader = (LRUPDATEHEADER *) plr;

			/*	set CSR
			/**/
			pcsr->itag = plrupdateheader->itag;
			pcsr->bm = plrupdateheader->bm;

			if ( !fRedoNeeded )
				{
				err = JET_errSuccess;
				goto HandleError;
				}

			/*	redo operation
			/**/
			err = ErrNDSetNodeHeader( pfucb, plrupdateheader->bHeader );
			Call( err );
			}
			break;

		case lrtypDelete:
			{
			LRDELETE	*plrdelete = (LRDELETE *) plr;
			SSIB		*pssib = &pfucb->ssib;

			/*	set CSR
			/**/
			pssib->itag =
				pcsr->itag = plrdelete->itag;

			if ( !fRedoNeeded )
				{
				err = JET_errSuccess;
				goto HandleError;
				}

			/*	redo the node delete
			/**/
			Call( ErrLGSetCSR ( pfucb ) );
			while( ( err = ErrNDDeleteNode( pfucb ) ) == errDIRNotSynchronous );
			Call( err );
			}
			break;

		case lrtypInsertItem:
			{
			LRINSERTITEM	*plrinsertitem = (LRINSERTITEM *)plr;

			/*	set CSR
			/**/
#ifdef ISRID
			pcsr->isrid = plrinsertitem->isrid;
#else
			pcsr->item = plrinsertitem->srid;
#endif
			pcsr->itag = plrinsertitem->itag;
			pcsr->bm = plrinsertitem->sridItemList;

			/*	even if operation is not redone, create version
			/*	for rollback support.
			/**/
			if ( !fRedoNeeded )
				{
				if ( !( plrinsertitem->fDIRFlags & fDIRVersion ) )
					{
					err = JET_errSuccess;
					goto HandleError;
					}
//	UNDONE:	review with Cheen Liao
//				while( ( err = ErrVERInsertItem( pfucb,
//					SridOfPgnoItag( pcsr->pgno, pcsr->itag ) ) )
//					== errDIRNotSynchronous );
				while( ( err = ErrVERInsertItem( pfucb,
					pcsr->bm ) ) == errDIRNotSynchronous );
				Call( err );
				err = JET_errSuccess;
				goto HandleError;
				}

			/*	cache node
			/**/
			NDGet( pfucb, pcsr->itag );
			NDGetNode( pfucb );
#ifndef ISRID
			Assert( pcsr == PcsrCurrent( pfucb ) );
			err = ErrNDSeekItem( pfucb, plrinsertitem->srid );
			Assert( err == JET_errSuccess ||
				err == wrnNDDuplicateItem ||
				err == errNDGreaterThanAllItems );
#endif

			/*	redo operation
			/**/
			while( ( err = ErrNDInsertItem( pfucb, plrinsertitem->srid,
				plrinsertitem->fDIRFlags ) ) == errDIRNotSynchronous );
			Call( err );
			}
			break;

		case lrtypInsertItems:
			{
			LRINSERTITEMS *plrinsertitems = (LRINSERTITEMS *) plr;

			/*	set CSR
			/**/
			pcsr->itag = plrinsertitems->itag;

			/*	if necessary, create an Insert RCE for node
			/**/
			if ( !fRedoNeeded )
				{
				err = JET_errSuccess;
				goto HandleError;
				}

			Assert( pcsr == PcsrCurrent( pfucb ) );

			/*  cache node
			/**/
			NDGet( pfucb, pcsr->itag );
			NDGetNode( pfucb );

			/*	do the item operation
			/**/
			while( ( err = ErrNDInsertItems( pfucb, plrinsertitems->rgitem, plrinsertitems->citem ) ) == errDIRNotSynchronous );
			Call( err );
			}
			break;

		case lrtypFlagInsertItem:
			{
			LRFLAGITEM *plrflagitem = (LRFLAGITEM *) plr;

			/*	set CSR
			/**/
#ifdef ISRID
			pcsr->isrid = plrflagitem->isrid;
#else
			pcsr->item = plrflagitem->srid;
#endif
			pcsr->itag = plrflagitem->itag;
			pcsr->bm = plrflagitem->sridItemList;

			/*	even if operation is not redone, create version
			/*	for rollback support.
			/**/
			if ( !fRedoNeeded )
				{
//	UNDONE:	review by Cheen Liao
//				while ( err = ErrVERFlagInsertItem( pfucb,
//					SridOfPgnoItag( pcsr->pgno, pcsr->itag ) )
//					== errDIRNotSynchronous );
				while ( err = ErrVERFlagInsertItem( pfucb,
					pcsr->bm ) == errDIRNotSynchronous );
				Call( err );
				err = JET_errSuccess;
				goto HandleError;
				}

			/*	cache node
			/**/
			NDGet( pfucb, pcsr->itag );
			NDGetNode( pfucb );
#ifndef ISRID
			err = ErrNDSeekItem( pfucb, pcsr->item );
			Assert( err == wrnNDDuplicateItem );
#endif

			/*	redo operation
			/**/
			while( ( err = ErrNDFlagInsertItem( pfucb ) ) == errDIRNotSynchronous );
			Call( err );
			}
			break;

		case lrtypFlagDeleteItem:
			{
			LRFLAGITEM *plrflagitem = (LRFLAGITEM *) plr;

			/*	set CSR
			/**/
#ifdef ISRID
			pcsr->isrid = plrflagitem->isrid;
#else
			pcsr->item = plrflagitem->srid;
#endif
			pcsr->itag = plrflagitem->itag;
			pcsr->bm = plrflagitem->sridItemList;

			/*	even if operation is not redone, create version
			/*	for rollback support.
			/**/
			if ( !fRedoNeeded )
				{
//	UNDONE:	review with Cheen Liao
//				while ( err = ErrVERFlagDeleteItem( pfucb, SridOfPgnoItag( pcsr->pgno, pcsr->itag ) ) == errDIRNotSynchronous );
				while ( err = ErrVERFlagDeleteItem( pfucb, pcsr->bm ) == errDIRNotSynchronous );
				Call( err );
				err = JET_errSuccess;
				goto HandleError;
				}

			/*	cache node
			/**/
			NDGet( pfucb, pcsr->itag );
			NDGetNode( pfucb );
#ifndef ISRID
			err = ErrNDSeekItem( pfucb, pcsr->item );
			Assert( err == JET_errSuccess ||
				err == wrnNDDuplicateItem ||
				err == errNDGreaterThanAllItems );
#endif

			/*	redo operation
			/**/
#ifdef ISRID
			pcsr->item = BmNDOfItem( *( ( UNALIGNED SRID * )pfucb->lineData.pb + pcsr->isrid ) );
#endif
			while( ( err = ErrNDFlagDeleteItem( pfucb ) ) == errDIRNotSynchronous );
			Call( err );
			}
			break;

		case lrtypSplitItemListNode:
			{
			LRSPLITITEMLISTNODE *plrsplititemlistnode = (LRSPLITITEMLISTNODE *)plr;

			if ( !fRedoNeeded )
				{
				err = JET_errSuccess;
				goto HandleError;
				}

			/*	set CSR
			/**/
			pcsr->itag = plrsplititemlistnode->itagToSplit;
			pcsr->itagFather = plrsplititemlistnode->itagFather;
			pcsr->ibSon = plrsplititemlistnode->ibSon;

			/*  cache node
			/**/
			NDGet( pfucb, pcsr->itag );
			NDGetNode( pfucb );

			while( ( err = ErrNDSplitItemListNode( pfucb, plrsplititemlistnode->fFlags ) ) == errDIRNotSynchronous );
			Call( err );
			}
			break;

		case lrtypDeleteItem:
			{
			SSIB			*pssib = &pfucb->ssib;
			LRDELETEITEM	*plrdeleteitem = (LRDELETEITEM *) plr;

			/*	set CSR
			/**/
			pssib->itag =
				pcsr->itag = plrdeleteitem->itag;
#ifdef ISRID
			pcsr->isrid = plrdeleteitem->isrid;
#else
			pcsr->item = plrdeleteitem->srid;
#endif
			pcsr->bm = plrdeleteitem->sridItemList;

			/*	delete item does not support transactions and
			/*	hence does not require rollback support during
			/*	recovery.
			/**/
			if ( !fRedoNeeded )
				{
				err = JET_errSuccess;
				goto HandleError;
				}

			/*	cache node
			/**/
			NDGet( pfucb, pcsr->itag );
			NDGetNode( pfucb );
#ifndef ISRID
			err = ErrNDSeekItem( pfucb, pcsr->item );
			Assert( err == wrnNDDuplicateItem );
#endif

			/*	redo operation
			/**/
			while( ( err = ErrNDDeleteItem( pfucb ) ) == errDIRNotSynchronous );
			Call( err );
			}
			break;

		case lrtypDelta:
			{
			SSIB	*pssib = &pfucb->ssib;
			LRDELTA *plrdelta = (LRDELTA *) plr;
			LONG	lDelta;

			/*	set CSR
			/**/
			pssib->itag =
				pcsr->itag = plrdelta->itag;
			pcsr->bm = plrdelta->bm;
			lDelta = plrdelta->lDelta;

			/*	even if operation is not redone, create version
			/*	for rollback support.
			/**/
			if ( !fRedoNeeded )
				{
				if ( !( plrdelta->fDIRFlags & fDIRVersion ) )
					{
					err = JET_errSuccess;
					goto HandleError;
					}

				pfucb->lineData.pb = (BYTE *)&lDelta;
				pfucb->lineData.cb = sizeof(lDelta);
				while ( ( err = ErrVERDelta( pfucb, pcsr->bm ) ) == errDIRNotSynchronous );
				Call( err );
				err = JET_errSuccess;
				goto HandleError;
				}

			/*  cache node
			/**/
			NDGet( pfucb, pcsr->itag );
			NDGetNode( pfucb );
			while( ( err = ErrNDDelta( pfucb, lDelta, plrdelta->fDIRFlags ) ) == errDIRNotSynchronous );
			Call( err );
			}
			break;

#ifdef DEBUG
		case lrtypCheckPage:
			{
			LRCHECKPAGE *plrcheckpage = (LRCHECKPAGE *)plr;

			if ( !fRedoNeeded )
				{
				err = JET_errSuccess;
				goto HandleError;
				}

			/*	check page parameters, including cbFreeTotal,
			/*	and next tag.
			/**/
			Assert( pfucb->ssib.pbf->ppage->pghdr.cbFreeTotal ==
				plrcheckpage->cbFreeTotal );
			Assert( (SHORT)ItagPMQueryNextItag( &pfucb->ssib ) ==
				plrcheckpage->itagNext );

			/*	dirty buffer to conform to other redo logic
			/**/
			BFSetDirtyBit( pfucb->ssib.pbf );
			}
			break;
#endif

		default:
			Assert( fFalse );
		}

	Assert( fRedoNeeded );
	Assert( FWriteAccessPage( pfucb, PgnoOfPn(pn) ) );
	Assert( pfucb->ssib.pbf->pn == pn );
	Assert( pbf->fDirty );
	Assert( pbf->ppage->pghdr.ulDBTime <= ulDBTime );
	/*	the timestamp set in ND operation is not correct so reset it
	/**/
	pbf->ppage->pghdr.ulDBTime = ulDBTime;

	err = JET_errSuccess;

HandleError:
	BFUnpin( pbf );
	return err;
	}


#define fNSGotoDone		1
#define fNSGotoCheck	2


ERR ErrLGIRedoFill(
	LR **pplr,
	BOOL fLastLRIsQuit,
	INT *pfNSNextStep )
	{
	ERR		err;
	USHORT	usGeneration;
	BOOL	fCloseNormally;
	LOGTIME tmOldLog = plgfilehdrGlobal->tmCreate;
	ULONG	ulRupOldLog = plgfilehdrGlobal->ulRup;
	ULONG	ulVersionOldLog = plgfilehdrGlobal->ulVersion;
 	CHAR	szLogNameT[ _MAX_PATH ];

	/* end of redoable logfile */
	/* read next generation */

	if ( SysCmpText( szFName, "jet" ) == 0 )
		{
		LGPOS lgposT;
		INT fStatus;
		USHORT usGenerationT;
		LGPOS lgposLastMSFlushSav;

		if (szLogCurrent != szRestorePath)
			{
			/* we have done all the log records. */
			*pfNSNextStep = fNSGotoDone;
			return JET_errSuccess;
			}

		lgposLastMSFlushSav = lgposLastMSFlush;

		/* try current working directory */
		szLogCurrent = szLogFilePath;
		GetLgposOfPbNext(&lgposT);
		usGenerationT = plgfilehdrGlobal->lgposLastMS.usGeneration;
		CallR( ErrSysCloseFile( hfLog ) );
		hfLog = handleNil;
		CallR( ErrOpenRedoLogFile( &lgposT, &fStatus ));

		if (fStatus == fRedoLogFile)
			{
			/* continue to retrieve next record */
			/* set cursor to the corresponding position in new file */

			CallR( ErrLGCheckReadLastLogRecord(
					&plgfilehdrGlobal->lgposLastMS, &fCloseNormally))
			GetLgposOfPbEntry(&lgposLastRec);

			if (usGenerationT == plgfilehdrGlobal->lgposLastMS.usGeneration)
				{
#ifdef CHECK_LG_VERSION
				if ( !fLGIgnoreVersion )
					{
					if (!FSameTime( &tmOldLog, &plgfilehdrGlobal->tmCreate) ||
						ulRupOldLog != plgfilehdrGlobal->ulRup ||
						ulVersionOldLog != plgfilehdrGlobal->ulVersion)
						return JET_errBadNextLogVersion;
					}
#endif
				CallR( ErrLGLocateFirstRedoLogRec(
						&lgposLastMSFlushSav,
						&lgposT,
						(BYTE **)pplr));
				}

			else
				{
				/* usGenerationT != plgfilehdrGlobal->lgposLastMS.usGeneration
				 */
				Assert( usGenerationT + 1
						== plgfilehdrGlobal->lgposLastMS.usGeneration);

#ifdef CHECK_LG_VERSION
				if ( !fLGIgnoreVersion )
					{
					if (!FSameTime( &tmOldLog, &plgfilehdrGlobal->tmPrevGen)||
						ulRupOldLog != plgfilehdrGlobal->ulRup ||
						ulVersionOldLog != plgfilehdrGlobal->ulVersion)
						return JET_errBadNextLogVersion;
					}
#endif
				/* keep the same ib offset, but set isec to first sector */
				lgposT.isec = 2;

				CallR( ErrLGLocateFirstRedoLogRec(
						pNil,
						&lgposT,
						(BYTE **)pplr));
				}

			*pfNSNextStep = fNSGotoCheck;
			return JET_errSuccess;
			}
		else
			{
 			/*	log file is missing or not continuous
 			/*	copy the last generation of log file in backup directory
 			/*	to current directory and continue logging from there.
 			/*/

 			Assert( hfLog == handleNil );
 			Assert( SysCmpText( szFName, "jet" ) == 0 );

 			szLogCurrent = szRestorePath;
 			LGMakeLogName( szLogNameT, (char *) szFName );
 			
 			szLogCurrent = szLogFilePath;
 			LGMakeLogName( szLogName, (char *) szFName );

 			CallR ( ErrSysCopy ( szLogNameT, szLogName, fTrue ) );

#ifdef OVERLAPPED_LOGGING
			CallR( ErrSysOpenFile(
					szLogName, &hfLog, 0L, fFalse, fTrue ))
#else
			CallR( ErrSysOpenFile(
					szLogName, &hfLog, 0L, fFalse, fFalse ))
#endif
			CallR( ErrLGReadFileHdr( hfLog, plgfilehdrGlobal ))

 			/*	Move cursor to make a seamless continuation
 			 *	between the last generation in backup directory and
 			 *	the newly copied log file.
			 */
 			CallR( ErrLGCheckReadLastLogRecord(
 					&plgfilehdrGlobal->lgposLastMS,
 					&fCloseNormally) );
 			
			*pfNSNextStep = fNSGotoDone;
			return JET_errSuccess;
			}
		}
	else
		{
		/* close current logfile, open next generation */
		CallS( ErrSysCloseFile( hfLog ) );
		/* set hfLog as handleNil to indicate it is closed. */
		hfLog = handleNil;

		usGeneration = plgfilehdrGlobal->lgposLastMS.usGeneration + 1;
		LGSzFromLogId( szFName, usGeneration );
		LGMakeLogName( szLogName, szFName );
#ifdef OVERLAPPED_LOGGING
		err = ErrSysOpenFile( szLogName, &hfLog, 0L, fFalse, fTrue );
#else
		err = ErrSysOpenFile( szLogName, &hfLog, 0L, fFalse, fFalse );
#endif
		if (err == JET_errFileNotFound)
			{
			Assert( hfLog == handleNil ); /* Open Fails */
			/* try jet.log */
			strcpy(szFName, "jet");
			LGMakeLogName( szLogName, szFName );
#ifdef OVERLAPPED_LOGGING
			err = ErrSysOpenFile( szLogName, &hfLog, 0L, fFalse, fTrue );
#else
			err = ErrSysOpenFile( szLogName, &hfLog, 0L, fFalse, fFalse );
#endif
			}
		if (err < 0)
			{
			Assert( hfLog == handleNil ); /* Open Fails */
			if (fLastLRIsQuit)
				{
				/* we are lucky, we have a normal end. */
				*pfNSNextStep = fNSGotoDone;
				return JET_errSuccess;
				}
			return err;
			}

		/* reset the log buffers. */
		CallR( ErrLGReadFileHdr( hfLog, plgfilehdrGlobal ))

#ifdef CHECK_LG_VERSION
		if ( !fLGIgnoreVersion )
			{
			if (!FSameTime( &tmOldLog, &plgfilehdrGlobal->tmPrevGen) ||
				ulRupOldLog != plgfilehdrGlobal->ulRup ||
				ulVersionOldLog != plgfilehdrGlobal->ulVersion)
				return JET_errBadNextLogVersion;
			}
#endif

		CallR( ErrLGCheckReadLastLogRecord(
				&plgfilehdrGlobal->lgposLastMS, &fCloseNormally) )
		GetLgposOfPbEntry(&lgposLastRec);

		CallR( ErrLGLocateFirstRedoLogRec(
					pNil,
					&plgfilehdrGlobal->lgposFirst,
					(BYTE **) pplr))

		*pfNSNextStep = fNSGotoCheck;
		return JET_errSuccess;
		}
	}


/*
 *  ErrLGRedoOperations( BOOL fPass1 )
 *
 *	Scan from lgposRedoFrom to end of usable log generations. For each log
 *  record, perform operations to redo original operation.
 *  Each redo function must call ErrLGRedoable to set ulDBTimeCurrent. If
 *  the function is not called, then ulDBTimeCurrent should manually set.
 *
 *	RETURNS		JET_errSuccess, or error code from failing routine, or one
 *				of the following "local" errors:
 *				-LogCorrupted	Logs could not be interpreted
 */

ERR	ErrLGRedoOperations( LGPOS *plgposRedoFrom, BOOL fPass1 )
	{
	ERR		err;
	LR		*plr;
	BOOL	fLastLRIsQuit = fFalse;
	BOOL	fCloseNormally;

	CallR( ErrLGCheckReadLastLogRecord( &plgfilehdrGlobal->lgposLastMS, &fCloseNormally))
	GetLgposOfPbEntry(&lgposLastRec);

	/*	reset pbLastMSFlush before restart
	/**/
	CallR( ErrLGLocateFirstRedoLogRec( pNil, plgposRedoFrom, (BYTE **) &plr ) );

	/*	initialize all the system parameters
	/**/

	do
		{
		BF		*pbf;
		PIB		*ppib;
		FUCB	*pfucb;
		PN		pn;
		DBID	dbid;
		FMP		*pfmp;
		LEVEL	levelCommitTo;

		if ( err == errLGNoMoreRecords )
			goto NextGeneration;

CheckNextRec:
		switch ( plr->lrtyp )
			{

		default:
			{
#ifndef RFS2
			AssertSz( fFalse, "Debug Only, Ignore this Assert" );
#endif
			err = JET_errLogCorrupted;
			goto Abort;
			}

		case lrtypFill:
 			{
			INT	fNSNextStep;

NextGeneration:
			CallJ( ErrLGIRedoFill( &plr, fLastLRIsQuit, &fNSNextStep), Abort )

			switch( fNSNextStep )
				{
				case fNSGotoDone:
					goto Done;
				case fNSGotoCheck:
					goto CheckNextRec;
				}
			}
			break;

		case lrtypFullBackup:
		case lrtypIncBackup:
		case lrtypRecoveryUndo1:
		case lrtypRecoveryUndo2:
			break;

		case lrtypNOP:
			continue;

		case lrtypRecoveryQuit1:
		case lrtypRecoveryQuit2:
		case lrtypQuit:

			/*	quit marks the end of a normal run. All sessions
			/*	have ended or must be forced to end. Any further
			/*	sessions will begin with a BeginT.
			/**/
			fLastLRIsQuit = fTrue;
			continue;

		case lrtypStart:
			{
			/*	start mark the jet init. Abort all active seesions.
			/**/
			LRSTART	*plrstart = (LRSTART *)plr;
			DBENV	dbenvT;

			TraceRedo( plr );

			/*	store it so that it will not be overwritten in
			/*	LGEndAllSession call.
			/**/
			memcpy( &dbenvT, &plrstart->dbenv, sizeof( DBENV ) );

			CallJ( ErrLGEndAllSessions( fPass1, fFalse, plgposRedoFrom), Abort );
			CallJ( ErrLGInitSession( &dbenvT ), Abort );
			}
			break;

		/****************************************************
		 *     Page Oriented Operations                     *
		 ****************************************************/

		case lrtypInsertNode:
		case lrtypInsertItemList:
		case lrtypReplace:
		case lrtypReplaceC:
		case lrtypFlagDelete:
		case lrtypUpdateHeader:
		case lrtypDelete:
		case lrtypInsertItem:
		case lrtypInsertItems:
		case lrtypFlagInsertItem:
		case lrtypFlagDeleteItem:
		case lrtypSplitItemListNode:
		case lrtypDeleteItem:
		case lrtypDelta:
		case lrtypLockRec:
#ifdef DEBUG
		case lrtypCheckPage:
#endif
			CallJ( ErrLGIRedoOnePageOperation( plr, fPass1 ), Abort );
			break;

		/****************************************************
		 *     Transaction Operations                       *
		 ****************************************************/

		case lrtypBegin:
			{
			LRBEGIN *plrbegin = (LRBEGIN *)plr;

			TraceRedo( plr );

			Assert(	plrbegin->level >= 0 && plrbegin->level <= levelMax );
			CallJ( ErrPpibFromProcid( plrbegin->procid, &ppib ), Abort )

			/*	do BT only after first BT based on level 0 is executed
			/**/
			if ( ( ppib->fAfterFirstBT ) ||
				( !ppib->fAfterFirstBT && plrbegin->levelStart == 0 ) )
				{
				LEVEL levelT = plrbegin->level;

				Assert( ppib->level <= plrbegin->levelStart );

				/*	issue begin transactions
				/**/
				while ( ppib->level < plrbegin->levelStart + plrbegin->level )
					{
					CallS( ErrVERBeginTransaction( ppib ) );
					}

				/*	assert at correct transaction level
				/**/
				Assert( ppib->level == plrbegin->levelStart + plrbegin->level );

				ppib->fAfterFirstBT = fTrue;
				}
			break;
			}

		case lrtypCommit:
			{
			LRCOMMIT *plrcommit = (LRCOMMIT *)plr;

			CallJ( ErrPpibFromProcid( plrcommit->procid, &ppib ), Abort );
			if ( !ppib->fAfterFirstBT )
				break;

			/*	check transaction level
			/**/
//			if ( ppib->level <= 0 )
//				break;
			Assert( ppib->level >= 1 );

			TraceRedo( plr );

			levelCommitTo = plrcommit->level;

//			UNDONE:	review with Cheenl Liao
//			/*	no need to free space at this point, all deferred space
//			/*	allocation has been done by redoing lrFreeSpace.
//			/**/
//			if ( levelCommitTo == 1 )
//				{
//				PIBResetDeferFreeNodeSpace( ppib );
//				}

			while ( ppib->level != levelCommitTo )
				{
				VERPrecommitTransaction( ppib );
				VERCommitTransaction( ppib );
				}

			break;
			}

		case lrtypAbort:
			{
			LRABORT *plrabort = (LRABORT *)plr;
			LEVEL	level = plrabort->levelAborted;

			CallJ( ErrPpibFromProcid( plrabort->procid, &ppib ), Abort );
			if ( !ppib->fAfterFirstBT )
				break;

			/*	check transaction level
			/**/
//			if ( ppib->level <= 0 )
//				break;
			Assert( ppib->level >= level );

			TraceRedo( plr );

			while ( level-- && ppib->level > 0 )
				{
				CallS( ErrVERRollback( ppib ) );
				}

			break;
			}

		case lrtypFreeSpace:
			{
			BOOL			fRedoNeeded;
			LRFREESPACE		*plrfs = (LRFREESPACE *)plr;
			FUCB			*pfucb;
			SRID			bm = plrfs->bm;
			RCE				*prce;

			dbid = plrfs->dbid;
			CallJ( ErrPpibFromProcid( plrfs->procid, &ppib ), Abort );
			if ( !ppib->fAfterFirstBT )
				break;

 			if ( !( fPass1 && dbid == dbidSystemDatabase || !fPass1 && rgfmp[dbid].cDetach > 0 ) )
				break;

			/*	check transaction level
			/**/
			Assert( ppib->level > 0 );

			TraceRedo( plr );

			pn = PnOfDbidPgno( dbid, PgnoOfSrid( plrfs->bmTarget ) );
			err = ErrLGRedoable( ppib, pn, plrfs->ulDBTime, &pbf, &fRedoNeeded );
			if ( err < 0 )
				return err;

			CallJ( ErrLGGetFucb( ppib,
				PnOfDbidPgno( dbid, pbf->ppage->pghdr.pgnoFDP ),
				&pfucb ), Abort)

			/*	locate the version entry out of version store
			/**/
			prce = PrceRCEGet( dbid, bm );
			Assert( prce != prceNil );

			Assert( plrfs->level == prce->level &&
				prce->oper == operReplace &&
				PpibOfProcid( plrfs->procid ) == pfucb->ppib );

			if ( !fRedoNeeded )
				{
				Assert( prce->bmTarget == sridNull );
				Assert( plrfs->bmTarget != sridNull );
				Assert( plrfs->bmTarget != 0 );

				/*  reset deferred space so that there will be no redo for commit
				/**/
				*( (SHORT *)prce->rgbData + 1 ) = 0;
				}

			break;
			}

		case lrtypUndo:
			{
			BOOL	fRedoNeeded;
			LRUNDO	*plrundo = (LRUNDO *)plr;
			FUCB	*pfucb;
			SRID	bm = plrundo->bm;
			SRID	item = plrundo->item;
			RCE		*prce;

			dbid = plrundo->dbid;
			CallJ( ErrPpibFromProcid( plrundo->procid, &ppib ), Abort );
			if ( !ppib->fAfterFirstBT )
				break;

 			if ( !( fPass1 && dbid == dbidSystemDatabase || !fPass1 && rgfmp[dbid].cDetach > 0 ) )
				break;

			/*	check transaction level
			/**/
			if ( ppib->level <= 0 )
				break;

			TraceRedo( plr );

			pn = PnOfDbidPgno( dbid, PgnoOfSrid( plrundo->bmTarget ) );
			err = ErrLGRedoable( ppib, pn, plrundo->ulDBTime, &pbf, &fRedoNeeded );
			if ( err < 0 )
				return err;

			CallJ( ErrLGGetFucb( ppib,
				PnOfDbidPgno( dbid, pbf->ppage->pghdr.pgnoFDP ),
				&pfucb ), Abort );

			/*	take the version entry out of version store
			/**/
			prce = PrceRCEGet( dbid, bm );
			while ( prce != prceNil )
				{
				if ( plrundo->oper == operInsertItem ||
					plrundo->oper == operFlagInsertItem ||
					plrundo->oper == operFlagDeleteItem )
					{
					while ( prce != prceNil &&
						*(SRID *)prce->rgbData != item )
						{
						prce = prce->prcePrev;
						}
					}

				if ( prce == prceNil )
					break;

				if ( plrundo->level == prce->level &&
					plrundo->oper  == prce->oper  &&
					PpibOfProcid( plrundo->procid ) == pfucb->ppib )
					{
					if ( fRedoNeeded )
						{
						Assert( prce->bmTarget == sridNull );
						Assert( plrundo->bmTarget != sridNull );
						Assert( plrundo->bmTarget != 0 );
						prce->bmTarget = plrundo->bmTarget;
						prce->ulDBTime = plrundo->ulDBTime;
						}
					else
						{
						VERDeleteRce( prce );
						prce->oper = operNull;
						}
					break;
					}
				else
					prce = prce->prcePrev;
				}

			break;
			}

		/****************************************************/
		/*     Database Operations		                    */
		/****************************************************/

		case lrtypCreateDB:
			{
			LRCREATEDB	*plrcreatedb = (LRCREATEDB *)plr;
			CHAR		*szName = plrcreatedb->szPath;

			dbid = plrcreatedb->dbid;
			Assert ( dbid != dbidSystemDatabase );

			TraceRedo(plr);

 			/* 1st pass, do nothing, just keep track of cDetach
 			/*/
 			if ( fPass1 )
 				{
 				++rgfmp[dbid].cDetach;
 				break;
 				}

 			Assert( !fPass1 );
			if ( rgfmp[dbid].cDetach > 0 )
				{
				extern	CODECONST(char) szBakExt[];
				CHAR	szDrive[_MAX_DRIVE];
				CHAR	szDir[_MAX_DIR];
				CHAR	szFName[_MAX_FNAME];
				CHAR	szExt[_MAX_EXT];

				pfmp = &rgfmp[dbid];

				/*  Check if the database is created in IsamRestore()
				 *  This is possible since in hard restore, we recovered
				 *  all the database and NOT close it. So check if it is
				 *  created and opened, then skip this redo for createdb.
				 */
				if ( pfmp->hf != handleNil )
					break;

				/* Set FMP such that the database will be opened with dbid! */
				CallJ( ErrDBStoreDBPath( szName, &pfmp->szDatabaseName), Abort )
				pfmp->ffmp = 0;

				/*  create the db for redo */
				CallJ( ErrPpibFromProcid( plrcreatedb->procid, &ppib ), Abort)

				/*  If database exist, do not recovery this file.
				 */
				Assert( _stricmp( szName, rgfmp[dbid].szDatabaseName ) == 0 );
				_splitpath( szName, szDrive, szDir, szFName, szExt);

				if ( pfmp->szRestorePath )
					szName = pfmp->szRestorePath;

				if ( FIOFileExists( szName ) )
					CallJ ( ErrSysDeleteFile( szName ), Abort )

#ifdef DEBUG
				/*	mask out flush pattern bits
				/**/
				CallJ( ErrDBCreateDatabase(
					ppib, rgfmp[dbid].szDatabaseName, NULL, &dbid,
					plrcreatedb->grbit & 0x00ffffff ),
					Abort );
#else
				CallJ( ErrDBCreateDatabase(
					ppib, rgfmp[dbid].szDatabaseName, NULL, &dbid,
					plrcreatedb->grbit ),
					Abort );
#endif

				/*	close it: it will get reopened on first use
				/**/
				CallJ( ErrDBCloseDatabase( ppib, dbid, plrcreatedb->grbit ), Abort )

				/*	restore information stored in database file
				/**/
				pfmp->ulDBTimeCurrent = pfmp->ulDBTime;
				/*	reset to prevent interference
				/**/
				pfmp->ulDBTime = 0;
				}
			Assert( rgfmp[dbid].cDetach <= 2 );
			}
			break;

		case lrtypAttachDB:
			{
			LRATTACHDB	*plrattachdb = (LRATTACHDB *)plr;

			dbid = plrattachdb->dbid;

			Assert ( dbid != dbidSystemDatabase );

			TraceRedo( plr );

 			/* 1st pass, do nothing, just keep track of cDetach
 			/*/
 			if ( fPass1 )
				{
				++rgfmp[dbid].cDetach;
				break;
				}

 			/* 2nd pass for soft/hard restore
 			/**/
 			Assert( !fPass1 );
 			if ( rgfmp[dbid].cDetach > 0 )
				{
				/*	set FMP such that the database will be opened with dbid!
				/**/
				pfmp = &rgfmp[dbid];
				CallJ( ErrDBStoreDBPath( plrattachdb->szPath, &pfmp->szDatabaseName), Abort )
				pfmp->ffmp = 0;
				DBIDSetAttached( dbid );
				pfmp->ulDBTimeCurrent =
				pfmp->ulDBTime = 0;
				pfmp->fLogOn = pfmp->fDBLoggable = plrattachdb->fLogOn;
				}
			Assert( rgfmp[dbid].cDetach <= 2 );
			}
			break;

		case lrtypDetachDB:
			{
			LRDETACHDB	*plrdetachdb = (LRDETACHDB *)plr;
			DBID		dbid = plrdetachdb->dbid;

			Assert( dbid != dbidSystemDatabase );
			pfmp = &rgfmp[dbid];

 			TraceRedo(plr);
			
			/*	special handling for counting detach DB.
			/**/
			if ( fPass1 )
				{
 				/*	redo operations after last Attach.
				/**/
				pfmp->cDetach--;
				break;
				}

			/*	2nd pass, do nothing
			/**/
			TraceRedo(plr);

			Assert( pfmp->cDetach <= 1 );
			}
			break;

		/****************************************************
		 *     Split Operations			                    *
		 ****************************************************/

		case lrtypSplit:
			{
			LRSPLIT		*plrsplit = (LRSPLIT *)plr;
			INT			splitt = plrsplit->splitt;
			BOOL		fRedoNeeded;
			BOOL		fSkipMoves;

			CallJ( ErrPpibFromProcid( plrsplit->procid, &ppib ), Abort )
			if (!ppib->fAfterFirstBT)
				break;

			pn = plrsplit->pn;
			dbid = DbidOfPn( pn );

			if ( !( fPass1 && dbid == dbidSystemDatabase || !fPass1 && rgfmp[dbid].cDetach > 0 ) )
				break;

			/*	check if database needs opening
			/**/
			if ( !FUserOpenedDatabase( ppib, dbid ) )
				{
				DBID dbidT = dbid;
				CallJ( ErrDBOpenDatabase( ppib, rgfmp[dbid].szDatabaseName,
					&dbidT, 0 ), Abort );
				Assert( dbidT == dbid);
				/*	reset to prevent interference
				/**/
				rgfmp[ dbid ].ulDBTime = 0;
				}

			/* check if the split page need be redone.
			/**/
			if ( ErrLGRedoable( ppib, pn, plrsplit->ulDBTime, &pbf, &fRedoNeeded )
				== JET_errSuccess && fRedoNeeded == fFalse )
				fSkipMoves = fTrue;
			else
				fSkipMoves = fFalse;

			TraceRedo( plr );

			CallJ( ErrLGGetFucb( ppib,
				PnOfDbidPgno( dbid, pbf->ppage->pghdr.pgnoFDP ),
				&pfucb ), Abort );

			/* redo the split, set time stamp accordingly
			/**/
			CallJ( ErrRedoSplitPage( pfucb,
				plrsplit,
				splitt,
				fSkipMoves ), Abort );
			}
			break;

		case lrtypMerge:
			{
			LRMERGE	*plrmerge = (LRMERGE *)plr;
			BOOL	fRedoNeeded;
			BOOL	fCheckBackLinkOnly;
			INT		crepeat = 0;

			CallJ( ErrPpibFromProcid( plrmerge->procid, &ppib ), Abort );
			if ( !( ppib->fAfterFirstBT ) )
				break;

			pn = plrmerge->pn;
			dbid = DbidOfPn( pn );

			/*	if not redo system database,
			/*	or softrestore in second page then continue to next.
			/**/
 			if ( !( fPass1 && dbid == dbidSystemDatabase || !fPass1 && rgfmp[dbid].cDetach > 0 ) )
				break;

			/* check if database needs opening
			/**/
			if ( !FUserOpenedDatabase( ppib, dbid ) )
				{
				DBID	dbidT = dbid;

				CallJ( ErrDBOpenDatabase( ppib, rgfmp[dbid].szDatabaseName, &dbidT, 0 ), Abort );
				Assert( dbidT == dbid);
				/* reset to prevent interference
				/**/
				rgfmp[ dbid ].ulDBTime = 0;
				}

			/* check if the split page need be redone.
			/**/
			if	( ( ErrLGRedoable( ppib, pn, plrmerge->ulDBTime, &pbf, &fRedoNeeded )
				== JET_errSuccess ) && ( fRedoNeeded == fFalse ) )
				{
				fCheckBackLinkOnly = fTrue;
				}
			else
				{
				/* if split page does need to be done, but merge page does not,
				/* then it is same as skip moves.
				/**/
				pn = PnOfDbidPgno( dbid, plrmerge->pgnoRight );
				if	( ( ErrLGRedoable( ppib, pn, plrmerge->ulDBTime, &pbf, &fRedoNeeded )
					== JET_errSuccess ) && ( fRedoNeeded == fFalse ) )
					{
					fCheckBackLinkOnly = fTrue;
					}
				else
					{
					fCheckBackLinkOnly = fFalse;
					}
				}

			TraceRedo( plr );

			CallJ( ErrLGGetFucb( ppib,
				PnOfDbidPgno( dbid, pbf->ppage->pghdr.pgnoFDP ),
				&pfucb ), Abort );

			/* redo the split, set time stamp accordingly
			/* conflict at redo time is not admissible
			/**/
			do
				{
				SignalSend( sigBFCleanProc );

				if ( crepeat++ )
					{
					BFSleep( cmsecWaitGeneric );
					}
				Assert( crepeat < 20 );
				CallJ( ErrLGRedoMergePage( pfucb, plrmerge, fCheckBackLinkOnly ), Abort );
				}
			while( err == wrnBMConflict );
			}
			break;

		case lrtypEmptyPage:
			{
			LREMPTYPAGE	*plrep = (LREMPTYPAGE *)plr;
			BOOL 		fRedoNeeded;
			BOOL 		fSkipDelete;
			RMPAGE		rmpage;
			BOOL		fDummy;

			ULONG ulDBTime = plrep->ulDBTime;

			memset( (BYTE *)&rmpage, 0, sizeof(RMPAGE) );
			rmpage.ulDBTimeRedo = ulDBTime;
			rmpage.dbid = DbidOfPn( plrep->pn );
			rmpage.pgnoRemoved = PgnoOfPn( plrep->pn );
			rmpage.pgnoLeft = plrep->pgnoLeft;
			rmpage.pgnoRight = plrep->pgnoRight;
			rmpage.pgnoFather = plrep->pgnoFather;
			rmpage.itagFather = plrep->itagFather;
			rmpage.itagPgptr = plrep->itag;
			rmpage.ibSon = plrep->ibSon;

			CallJ( ErrPpibFromProcid( plrep->procid, &ppib ), Abort );
			rmpage.ppib = ppib;
			if ( !ppib->fAfterFirstBT )
				break;

			dbid = DbidOfPn( plrep->pn );

 			if ( !( fPass1 && dbid == dbidSystemDatabase || !fPass1 && rgfmp[dbid].cDetach > 0 ) )
				break;

			/*	check if database needs opening
			/**/
			if ( !FUserOpenedDatabase( ppib, dbid ) )
				{
				DBID dbidT = dbid;

				CallR( ErrDBOpenDatabase( ppib,
					rgfmp[dbid].szDatabaseName,
					&dbidT,
					0 ) );
				Assert( dbidT == dbid);
				rgfmp[ dbid ].ulDBTime = 0; /* reset to prevent interference */
				}

			/* check if the remove pointer to empty page need be redone
			/**/
			pn = PnOfDbidPgno( dbid, plrep->pgnoFather );
			if ( ErrLGRedoable( ppib, pn, ulDBTime, &pbf, &fRedoNeeded )
				== JET_errSuccess && fRedoNeeded == fFalse )
				fSkipDelete = fTrue;
			else
				fSkipDelete = fFalse;

			CallJ( ErrLGGetFucb( ppib,
				PnOfDbidPgno( dbid, pbf->ppage->pghdr.pgnoFDP ),
				&pfucb ), Abort );

			TraceRedo( plr );

			/* latch parent and sibling pages as needed
			/**/
			if ( !fSkipDelete )
				{
				CallJ( ErrBFAccessPage( ppib, &rmpage.pbfFather,
					PnOfDbidPgno( dbid, plrep->pgnoFather ) ), Abort);
				err = ErrBMAddToLatchedBFList( &rmpage, rmpage.pbfFather );
				Assert( err != JET_errWriteConflict );
				CallJ( err, Abort );
				}
			else
				{
				Assert( rmpage.pbfFather == pbfNil );
				}

			if ( plrep->pgnoLeft == pgnoNull )
				{
				rmpage.pbfLeft = pbfNil;
				}
			else
				{
				CallJ( ErrBFAccessPage( ppib,
					&rmpage.pbfLeft,
					PnOfDbidPgno( dbid, plrep->pgnoLeft ) ),
					EmptyPageFail );
				if ( rmpage.pbfLeft->ppage->pghdr.ulDBTime >= ulDBTime )
					rmpage.pbfLeft = pbfNil;
				else
					{
					err = ErrBMAddToLatchedBFList( &rmpage, rmpage.pbfLeft );
					Assert( err != JET_errWriteConflict );
					CallJ( err,	EmptyPageFail );
					}
				}

			if ( plrep->pgnoRight == pgnoNull )
				{
				rmpage.pbfRight = pbfNil;
				}
			else
				{
				CallJ( ErrBFAccessPage( ppib, &rmpage.pbfRight,
					PnOfDbidPgno( dbid, plrep->pgnoRight ) ), EmptyPageFail);
				if ( rmpage.pbfRight->ppage->pghdr.ulDBTime >= ulDBTime )
					rmpage.pbfRight = pbfNil;
				else
					{
					err = ErrBMAddToLatchedBFList( &rmpage, rmpage.pbfRight );
					Assert( err != JET_errWriteConflict );
					CallJ( err,	EmptyPageFail );
					}
				}
			err = ErrBMDoEmptyPage( pfucb, &rmpage, fFalse, &fDummy, fSkipDelete);
			Assert( err == JET_errSuccess );
EmptyPageFail:

			/*	release latches
			/**/
			BTReleaseRmpageBfs( fTrue, &rmpage );
			CallJ( err, Abort );
			}
			break;

		/****************************************************
		 *     Misc Operations			                    *
		 ****************************************************/

		case lrtypInitFDPPage:
			{
			BOOL			fRedoNeeded;
			LRINITFDPPAGE	*plrinitfdppage = (LRINITFDPPAGE*)plr;
			PGNO			pgnoFDP;

			CallJ( ErrPpibFromProcid( plrinitfdppage->procid, &ppib ), Abort );
			if ( !ppib->fAfterFirstBT )
				break;

			pn = plrinitfdppage->pn;
			dbid = DbidOfPn( pn );
			pgnoFDP = PgnoOfPn(pn);

 			if ( !( fPass1 && dbid == dbidSystemDatabase || !fPass1 && rgfmp[dbid].cDetach > 0 ) )
				break;

			/*	check if database needs opening
			/**/
			if ( !FUserOpenedDatabase( ppib, dbid ) )
				{
				DBID dbidT = dbid;

				CallR( ErrDBOpenDatabase( ppib, rgfmp[dbid].szDatabaseName,
					&dbidT, 0 ) );
				Assert( dbidT == dbid);
				/*	reset to prevent interference
				/**/
				rgfmp[ dbid ].ulDBTime = 0;
				}

			/*	check if the FDP page need be redone
			/*	always redo since it is a new page, if we do not use checksum.
			/*	The ulDBTime could be larger than the given ulDBTime since the
			/*	page is not initialized.
			/**/
#ifdef CHECKSUM
			if ( ErrLGRedoable(ppib, pn,plrinitfdppage->ulDBTime, &pbf, &fRedoNeeded )
					== JET_errSuccess && fRedoNeeded == fFalse )
				break;
#endif
			TraceRedo(plr);

			CallJ( ErrLGGetFucb( ppib, pn, &pfucb ), Abort );

			CallJ( ErrSPInitFDPWithExt(
				pfucb,
				plrinitfdppage->pgnoFDPParent,
				pgnoFDP,
				plrinitfdppage->cpgGot + 1,   /* include fdp page again */
				plrinitfdppage->cpgWish ), Abort );

			CallJ( ErrBFAccessPage( ppib, &pbf, pn ), Abort )
			BFSetDirtyBit(pbf);
			pbf->ppage->pghdr.ulDBTime = plrinitfdppage->ulDBTime;
			}
			break;

		case lrtypELC:
			{
			BOOL	fRedoNeeded;
			LRELC	*plrelc = (LRELC*)plr;
			PGNO	pgno, pgnoSrc;
			PN		pn, pnSrc;
			ULONG	ulDBTime = plrelc->ulDBTime;
			SSIB	*pssib;
			CSR		*pcsr;

			pn = plrelc->pn;
			dbid = DbidOfPn( pn );
			pgno = PgnoOfPn(pn);
			pgnoSrc = PgnoOfSrid(plrelc->sridSrc);
			pnSrc = PnOfDbidPgno(dbid, pgnoSrc);

			CallJ( ErrPpibFromProcid( plrelc->procid, &ppib ), Abort );
			if ( !ppib->fAfterFirstBT )
				break;

			Assert( ppib->level == 1 );
 			if ( !( fPass1 && dbid == dbidSystemDatabase || !fPass1 && rgfmp[dbid].cDetach > 0 ) )
				{
				Assert( ppib->level == 1 );
				/*	excute only commit operations
				/**/
				goto ELCCommit;
				}

			/*	check if database needs opening
			/**/
			if ( !FUserOpenedDatabase( ppib, dbid ) )
				{
				DBID dbidT = dbid;

				CallR( ErrDBOpenDatabase( ppib, rgfmp[dbid].szDatabaseName,
					&dbidT, 0 ) );
				Assert( dbidT == dbid);
				/*	reset to prevent interference
				/**/
				rgfmp[ dbid ].ulDBTime = 0;
				}

			err = ErrLGRedoable( ppib, pn, ulDBTime, &pbf, &fRedoNeeded );
			if ( err < 0 )
				return err;

			TraceRedo(plr);

			CallJ( ErrLGGetFucb( ppib,
				PnOfDbidPgno( dbid, pbf->ppage->pghdr.pgnoFDP ),
				&pfucb), Abort)

			pssib = &pfucb->ssib;
			pcsr = PcsrCurrent( pfucb );

			pssib->pbf = pbf;
			pcsr->pgno = pgno;
			pssib->itag =
				pcsr->itag = plrelc->itag;
			if ( pgno == pgnoSrc )
				{
				// UNDONE: the following special casing is a hack to
				// handle ELC when src and destination pages are same
				// fix this by changing ErrBTMoveNode in merge/split
				if ( ulDBTime > pssib->pbf->ppage->pghdr.ulDBTime )
					{
					BF *pbf;

					/*  cache node
					/**/
					NDGet( pfucb, pcsr->itag );
					(VOID)ErrNDExpungeBackLink( pfucb );

					pbf = pssib->pbf;
					Assert( pbf->pn == pn );
					AssertBFDirty(pbf);

					pssib->itag =
					pcsr->itag = ItagOfSrid(plrelc->sridSrc);

					PMDirty( pssib );
					PMExpungeLink( pssib );

					pbf = pssib->pbf;
					Assert( pbf->pn == pnSrc );
					AssertBFDirty( pbf );
					pbf->ppage->pghdr.ulDBTime = plrelc->ulDBTime;
					}

				}
			else
				{
				if ( ulDBTime > pssib->pbf->ppage->pghdr.ulDBTime )
					{
					BF *pbf;

					/*  cache node
					/**/
					NDGet( pfucb, pcsr->itag );
					(VOID)ErrNDExpungeBackLink( pfucb );

					pbf = pssib->pbf;
					Assert( pbf->pn == pn );
					AssertBFDirty(pbf);
					pbf->ppage->pghdr.ulDBTime = plrelc->ulDBTime;
					}

				pcsr->pgno = pgnoSrc;
				CallJ( ErrSTAccessPage( pfucb, pgnoSrc ), Abort );
				if ( ulDBTime > pssib->pbf->ppage->pghdr.ulDBTime )
					{
					BF *pbf;

					pssib->itag =
					pcsr->itag = ItagOfSrid(plrelc->sridSrc);

					PMDirty( pssib );
					PMExpungeLink( pssib );

					pbf = pssib->pbf;
					Assert( pbf->pn == pnSrc );
					AssertBFDirty( pbf );
					pbf->ppage->pghdr.ulDBTime = plrelc->ulDBTime;
					}
				}

ELCCommit:
			Assert( ppib->level == 1 );
//			levelCommitTo = 0;
			VERPrecommitTransaction( ppib );
			VERCommitTransaction( ppib );
			CallS( ErrRCECleanPIB( ppib, ppib, fRCECleanAll ) );
			}

			break;
			} /*** end of switch statement ***/

		fLastLRIsQuit = fFalse;

		}
	while ( ( err = ErrLGGetNextRec( (BYTE **) &plr ) ) ==
		JET_errSuccess || err == errLGNoMoreRecords );

Done:
	err = JET_errSuccess;

Abort:
	/*	assert all operations successful for restore from consistent
	/*	backups
	/**/
#ifndef RFS2
	AssertSz( err >= 0,	"Debug Only, Ignore this Assert");
#endif

	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\recupd.c ===
#include "config.h"

#include <string.h>
#include <stdlib.h>

#include "daedef.h"
#include "util.h"
#include "pib.h"
#include "fmp.h"
#include "page.h"
#include "ssib.h"
#include "fcb.h"
#include "fucb.h"
#include "stapi.h"
#include "nver.h"
#include "dirapi.h"
#include "fdb.h"
#include "idb.h"
#include "spaceapi.h"
#include "recapi.h"
#include "recint.h"
#include "logapi.h"

DeclAssertFile; 				/* Declare file name for assert macros */

/**************************** INTERNAL STUFF ***************************/
typedef struct ATIPB {			/*** AddToIndexParameterBlock ***/
	FUCB	*pfucb;
	FUCB	*pfucbIdx; 			// index's FUCB (can be pfucbNil)
	LINE	lineNewData;  		// data to extract key from
	SRID	srid;					// srid of data record
	BOOL	fFreeFUCB; 			// free index FUCB?
	} ATIPB;

/*	define semaphore to guard dbk counter
/**/
SgSemDefine( semDBK );

typedef struct UIPB {			/*** UpdateIndexParameterBlock ***/
	FUCB	*pfucb;
	FUCB	*pfucbIdx; 			// index's FUCB (can be pfucbNil)
	LINE	lineOldData;  		// old data record
	SRID	srid;					// SRID of record
	LINE	lineNewData;  		// new data record
	BOOL	fOpenFUCB; 			// open index FUCB?
	BOOL	fFreeFUCB; 			// free index FUCB?
} UIPB;


INLINE LOCAL ERR ErrRECInsert( PIB *ppib, FUCB *pfucb, SRID *psrid );
INLINE LOCAL ERR ErrRECIAddToIndex( FCB *pfcbIdx, ATIPB *patipb );
INLINE LOCAL ERR ErrRECReplace( PIB *ppib, FUCB *pfucb );
INLINE LOCAL ERR ErrRECIUpdateIndex( FCB *pfcbIdx, UIPB *puipb );


	ERR VTAPI
ErrIsamUpdate( PIB *ppib, FUCB *pfucb, BYTE *pb, ULONG cbMax, ULONG *pcbActual )
	{
	ERR		err;
	SRID		srid;

	CheckPIB( ppib );
	CheckTable( ppib, pfucb );
	CheckNonClustered( pfucb );

	if ( pcbActual != NULL )
		*pcbActual = sizeof(srid);

	if ( FFUCBReplacePrepared( pfucb ) )
		{
		if ( cbMax > 0 )
			{
			FUCBSetGetBookmark( pfucb );
			CallR( ErrDIRGetBookmark( pfucb, &srid ) );
			memcpy( pb, &srid, min( cbMax, sizeof(srid) ) );
			}
		err = ErrRECReplace( ppib, pfucb );
		}
	else if ( FFUCBInsertPrepared( pfucb ) )
		{
		err = ErrRECInsert( ppib, pfucb, &srid );
		if ( pb != NULL && cbMax > 0 && err >= 0 )
			{
			FUCBSetGetBookmark( pfucb );
			memcpy( pb, &srid, min( cbMax, sizeof(srid) ) );
			}
		}
	else
		err = JET_errUpdateNotPrepared;

	Assert( err != errDIRNotSynchronous );
	return err;
	}


//+local
// ErrRECInsert
// ========================================================================
// ErrRECInsert( PIB *ppib, FUCB *pfucb, OUTLINE *plineBookmark )
//
// Adds a record to a data file.  All indexes on the data file are
// updated to reflect the addition.
//
// PARAMETERS	ppib						PIB of user
//		 		pfucb						FUCB for file
//		 		plineBookmark				if this parameter is not NULL,
//		 									then bookmark of record is returned
//
// RETURNS		Error code, one of the following:
//					 JET_errSuccess		Everything went OK.
//					-KeyDuplicate		The record being added causes
//										an illegal duplicate entry in an index.
//					-NullKeyDisallowed	A key of the new record is NULL.
//					-RecordNoCopy		There is no working buffer to add from.
//					-NullInvalid		The record being added contains
//										at least one null-valued field
//										which is defined as NotNull.
// SIDE EFFECTS
//		After addition, file currency is left on the new record.
//		Index currency (if any) is left on the new index entry.
//		On failure, the currencies are returned to their initial states.
//
//	COMMENTS
//		No currency is needed to add a record.
//		Index entries are not made for entirely-null keys.
//		A transaction is wrapped around this function.	Thus, any
//		work done will be undone if a failure occurs.
//		Adding a record to a sequential file increments the
//		file's highest Database Key (DBK) and uses that DBK as
//		the key for the new record.	 However, if the PUT fails,
//		the max DBK is not reset to its former value.  This can
//		create gaps in the DBK sequence.
//		This routine is also the interface for adding record to a
//		SORT process.  The sort key is extracted and passed with
//		the data record to SORTAdd.
//		For temporary files, transaction logging is deactivated
//		for the duration of the routine.
//-
INLINE LOCAL ERR ErrRECInsert( PIB *ppib, FUCB *pfucb, SRID *psrid )
	{
	ERR		err = JET_errSuccess;  		 	// error code of various utility
	KEY		keyToAdd;					 	// key of new data record
	BYTE	rgbKeyBuf[ JET_cbKeyMost ];	 	// key buffer
	FCB		*pfcbFile;					 	// file's FCB
	FDB		*pfdb;						 	// field descriptor info
	FCB		*pfcbIdx;					 	// loop variable for each index on file
	ATIPB	atipb;						 	// parm block to ErrRECIAddToIndex
	FUCB	*pfucbT;
	LINE	*plineData;
	DBK		dbk;
	LINE	line;
	ULONG	ulRecordAutoIncrement;
	ULONG	ulTableAutoIncrement;
	BOOL	fPrepareInsertIndex = fFalse;
	BOOL	fCommit = fFalse;

	CheckPIB( ppib );
	CheckTable( ppib, pfucb );
	CheckNonClustered( pfucb );

	/* should have been checked in PrepareUpdate
	/**/
	Assert( FFUCBUpdatable( pfucb ) );
	Assert( FFUCBInsertPrepared( pfucb ) );

	/*	assert reset rglineDiff delta logging
	/**/
	Assert( pfucb->clineDiff == 0 );
	Assert( pfucb->fCmprsLg == fFalse );

	/* efficiency variables
	/**/
	pfcbFile = pfucb->u.pfcb;
	Assert( pfcbFile != pfcbNil );
	pfdb = (FDB *)pfcbFile->pfdb;
	Assert( pfdb != pfdbNil );

	/*	record to use for put
	/**/
	plineData = &pfucb->lineWorkBuf;
	Assert( !( FLineNull( plineData ) ) );
	if ( FRECIIllegalNulls( pfdb, plineData ) )
		return JET_errNullInvalid;

	/*	if necessary, start a transaction in case anything fails
	/**/
	if ( ppib->level == 0 || !FPIBAggregateTransaction( ppib )  )
		{
		CallR( ErrDIRBeginTransaction( ppib ) );
		fCommit = fTrue;
		}

	/*	open temp FUCB on data file
	/**/
	CallJ( ErrDIROpen( ppib, pfcbFile, 0, &pfucbT ), Abort );
	Assert(pfucbT != pfucbNil);
	FUCBSetIndex( pfucbT );

	/* abort if index is being built on file
	/**/
	if ( FFCBDenyDDL( pfcbFile, ppib ) )
		{
		err = JET_errWriteConflict;
		goto HandleError;
		}

	/*	set version and autoinc fields
	/**/
	Assert( pfcbFile != pfcbNil );
	if ( pfdb->fidVersion != 0 && ! ( FFUCBColumnSet( pfucb, pfdb->fidVersion - fidFixedLeast ) ) )
		{
		LINE	lineField;
		ULONG	ul = 0;
		/*	set field to zero
		/**/
		lineField.pb = (BYTE *)&ul;
		lineField.cb = sizeof(ul);
		Call( ErrRECIModifyField( pfucb, pfdb->fidVersion, 0, &lineField ) );
		}

	if ( pfdb->fidAutoInc != 0 )
		{
		Assert( FFUCBColumnSet( pfucb, pfdb->fidAutoInc - fidFixedLeast ) );
		// get the value of autoinc that the user sets to
		Call( ErrRECIRetrieve( pfucb, &pfdb->fidAutoInc, 0, &line, JET_bitRetrieveCopy ) );
		Assert( line.cb == sizeof(ulRecordAutoIncrement) );
		ulRecordAutoIncrement = *(UNALIGNED ULONG *)line.pb;

		/*	move to FDP root and seek to autoincrement
		/**/
		DIRGotoFDPRoot( pfucbT );
		err = ErrDIRSeekPath( pfucbT, 1, pkeyAutoInc, fDIRPurgeParent );
		if ( err != JET_errSuccess )
			{
			if ( err > 0 )
				err = JET_errDatabaseCorrupted;
			goto HandleError;
			}
		Call( ErrDIRGet( pfucbT ) );
		Assert( pfucbT->lineData.cb == sizeof(ulTableAutoIncrement) );
		ulTableAutoIncrement = *(UNALIGNED ULONG *)pfucbT->lineData.pb;
		Assert( ulTableAutoIncrement != 0 );

		/*	update FDP autoinc to be one greater than set value.
		/**/
		if ( ulRecordAutoIncrement >= ulTableAutoIncrement)
			{
			ulTableAutoIncrement = ulRecordAutoIncrement + 1;
			line.pb = (BYTE *)&ulTableAutoIncrement;
			line.cb = sizeof(ulTableAutoIncrement);
			Call( ErrDIRReplace( pfucbT, &line, fDIRNoVersion ) );
			}
		}

	/*	get key to add with new record
	/**/
	keyToAdd.pb = rgbKeyBuf;
	if ( pfcbFile->pidb == pidbNil )
		{
		/*	file is sequential
		/**/
		SgSemRequest( semDBK );
		dbk = ++pfcbFile->dbkMost;
		SgSemRelease( semDBK );
		keyToAdd.cb = sizeof(DBK);
		keyToAdd.pb[0] = (BYTE)((dbk >> 24) & 0xff);
		keyToAdd.pb[1] = (BYTE)((dbk >> 16) & 0xff);
		keyToAdd.pb[2] = (BYTE)((dbk >> 8) & 0xff);
		keyToAdd.pb[3] = (BYTE)(dbk & 0xff);
		}
	else
		{
		/*	file is clustered
		/**/
		Call( ErrRECExtractKey( pfucbT, pfdb, pfcbFile->pidb, plineData, &keyToAdd, 1 ) );
		Assert( err == wrnFLDNullKey ||
			err == wrnFLDNullSeg ||
			err == JET_errSuccess );

		if ( ( pfcbFile->pidb->fidb & fidbNoNullSeg ) && ( err == wrnFLDNullKey || err == wrnFLDNullSeg ) )
			Error( JET_errNullKeyDisallowed, HandleError )
		}

	/*	insert record.  Move to DATA root.
	/**/
	DIRGotoDataRoot( pfucbT );

	if ( pfcbFile->pidb == pidbNil )
		{
		/*	file is sequential
		/**/
		Call( ErrDIRInsert( pfucbT, plineData, &keyToAdd,
			fDIRVersion | fDIRPurgeParent ) );
		}
	else
		{
		Call( ErrDIRInsert( pfucbT, plineData, &keyToAdd,
			fDIRVersion | fDIRPurgeParent |
			( pfcbFile->pidb->fidb&fidbUnique ? 0 : fDIRDuplicate ) ) );
		}

	/*	return bookmark of inserted record
	/**/
	DIRGetBookmark( pfucbT, psrid );

	/*	insert item in non-clustered indexes
	/**/
	for ( pfcbIdx = pfcbFile->pfcbNextIndex;
		pfcbIdx != pfcbNil;
		pfcbIdx = pfcbIdx->pfcbNextIndex )
		{
		if ( !fPrepareInsertIndex )
			{
			/*	get SRID of inserted record
			/**/
			DIRGetBookmark( pfucbT, &atipb.srid );

			/*	set atipb for index insertion.
			/**/
			atipb.pfucb = pfucbT;
			atipb.lineNewData = *plineData;
//			atipb.pfucbIdx = pfucbNil;
			atipb.fFreeFUCB = fFalse;
			fPrepareInsertIndex = fTrue;
			}
		atipb.fFreeFUCB = pfcbIdx->pfcbNextIndex == pfcbNil;
		Call( ErrRECIAddToIndex( pfcbIdx, &atipb ) );
		}

	/*	commit transaction
	/**/
	if ( fCommit )
		{
		Call( ErrDIRCommitTransaction( ppib ) );
		}
	FUCBResetUpdateSeparateLV( pfucb );
	FUCBResetCbstat( pfucb );

	/*	discard temp FUCB
	/**/
	DIRClose( pfucbT );
	return err;

HandleError:
	Assert( err < 0 );
	DIRClose( pfucbT );

Abort:
	if ( fCommit )
		CallS( ErrDIRRollback( ppib ) );

	return err;
	}


//+local
// ErrRECIAddToIndex
// ========================================================================
// ERR ErrRECIAddToIndex( FCB *pfcbIdx, ATIPB patipb )
//
// Extracts key from data record, opens the index, adds that key with
// the given SRID to the index, and closes the index.
//
// PARAMETERS	pfcbIdx 		  			FCB of index to insert into
// 				patipb->ppib				who is calling this routine
// 				patipb->pfucbIdx			pointer to index's FUCB.      If pfucbNil,
//											an FUCB will be allocated by DIROpen.
//				patipb->lineNewData.cb		length of data record
//				patipb->lineNewData.pb		data to extract key from
//				patipb->srid	  			SRID of data record
//				patipb->fFreeFUCB			free index FUCB?
//
// RETURNS		JET_errSuccess, or error code from failing routine
//
// SIDE EFFECTS if patipb->pfucbIdx==pfucbNil, ErrDIROpen will allocate
//				an FUCB and it will be pointed at it.
//				If fFreeFUCB is fFalse, patipb->pfucbIdx should
//				be used in a subsequent ErrDIROpen.
// SEE ALSO		Insert
//-
INLINE LOCAL ERR ErrRECIAddToIndex( FCB *pfcbIdx, ATIPB *patipb )
	{
	ERR		err = JET_errSuccess;			// error code of various utility
	CSR		**ppcsrIdx; 				  	// index's currency
	KEY		keyToAdd;					  	// key to add to secondary index
	BYTE	rgbKeyBuf[ JET_cbKeyMost ];		// key extracted from data
	LINE	lineSRID;						// SRID to add to index
	ULONG	itagSequence; 					// used to extract keys
	ULONG	ulAddFlags; 					// flags to DIRAdd
	BOOL	fNullKey = fFalse;				// extracted NullTaggedKey -- so no more keys to extract

	Assert( pfcbIdx != pfcbNil );
	Assert( pfcbIdx->pfdb != pfdbNil );
	Assert( pfcbIdx->pidb != pidbNil );
	Assert( patipb != NULL );
	Assert( !FLineNull( &patipb->lineNewData ) );
	Assert( patipb->pfucb != pfucbNil );
	Assert( patipb->pfucb->ppib != ppibNil );
	Assert( patipb->pfucb->ppib->level < levelMax );

	/*	open FUCB on this index
	/**/
	CallR( ErrDIROpen( patipb->pfucb->ppib, pfcbIdx, 0, &patipb->pfucbIdx ) )
	Assert( patipb->pfucbIdx != pfucbNil );

	/*	cursor on non-clustering index
	/**/
	FUCBSetIndex( patipb->pfucbIdx );
	FUCBSetNonClustered( patipb->pfucbIdx );

	ppcsrIdx = &PcsrCurrent( patipb->pfucbIdx );
	Assert( *ppcsrIdx != pcsrNil );
	lineSRID.cb = sizeof(SRID);
	lineSRID.pb = (BYTE *) &patipb->srid;
	ulAddFlags = ( pfcbIdx->pidb->fidb&fidbUnique ?
		0 : fDIRDuplicate ) | fDIRPurgeParent;

	/*	add all keys for this index from new data record
	/**/
	keyToAdd.pb = rgbKeyBuf;
	for ( itagSequence = 1; ; itagSequence++ )
		{
		Call( ErrDIRGet( patipb->pfucb ) );
		patipb->lineNewData = patipb->pfucb->lineData;
		Call( ErrRECExtractKey( patipb->pfucb, (FDB *)pfcbIdx->pfdb, pfcbIdx->pidb, &patipb->lineNewData, &keyToAdd, itagSequence ) );
		Assert( err == wrnFLDNullKey ||
			err == wrnFLDOutOfKeys ||
			err == wrnFLDNullSeg ||
			err == JET_errSuccess );
		if ( err == wrnFLDOutOfKeys )
			{
			Assert( itagSequence > 1 );
			break;
			}

		if ( ( pfcbIdx->pidb->fidb & fidbNoNullSeg ) && ( err == wrnFLDNullKey || err == wrnFLDNullSeg ) )
			{
			err = JET_errNullKeyDisallowed;
			goto HandleError;
			}

		if ( err == wrnFLDNullKey )
			{
			if ( pfcbIdx->pidb->fidb & fidbAllowAllNulls )
				{
				ulAddFlags |= fDIRDuplicate;
				fNullKey = fTrue;
				}
			else 
				break;
			}
		else
			{
			if ( err == wrnFLDNullSeg && !( pfcbIdx->pidb->fidb & fidbAllowSomeNulls ) )
				break;
			}

		/*	move to DATA root and insert index node
		/**/
		DIRGotoDataRoot( patipb->pfucbIdx );
		Call( ErrDIRInsert( patipb->pfucbIdx, &lineSRID, &keyToAdd, fDIRVersion | ulAddFlags ) )

		/*	dont keep extracting for keys with no tagged segments
		/**/
		if ( !( pfcbIdx->pidb->fidb & fidbHasMultivalue ) || fNullKey )
			break;
		}

	/*	supress warnings
	/**/
	Assert( err == wrnFLDNullKey ||
		err == wrnFLDOutOfKeys ||
		err == wrnFLDNullSeg ||
		err == JET_errSuccess );
	err = JET_errSuccess;

HandleError:
	/* close the FUCB
	/**/
	DIRClose( patipb->pfucbIdx );
	patipb->pfucbIdx = pfucbNil;

	Assert( err < 0 || err == JET_errSuccess );
	return err;
	}


//+local
// ErrRECReplace
// ========================================================================
//	ErrRECReplace( PIB *ppib, FUCB *pfucb )
//
// Updates a record in a data file.	 All indexes on the data file are
// updated to reflect the updated data record.
//
// PARAMETERS	ppib		 PIB of this user
//			  		pfucb		 FUCB for file
// RETURNS		Error code, one of the following:
//					 JET_errSuccess					 Everything went OK.
//					-NoCurrentRecord			 There is no current record
//													 to update.
//					-RecordNoCopy				 There is no working buffer
//													 to update from.
//					-KeyDuplicate				 The new record data causes an
//													 illegal duplicate index entry
//													 to be generated.
//					-RecordClusteredChanged	 The new data causes the clustered
//													 key to change.
// SIDE EFFECTS
//		After update, file currency is left on the updated record.
//		Similar for index currency.
//		The effect of a GetNext or GetPrevious operation will be
//		the same in either case.  On failure, the currencies are
//		returned to their initial states.
//		If there is a working buffer for SetField commands,
//		it is discarded.
//
// COMMENTS
//		If currency is not ON a record, the update will fail.
//		A transaction is wrapped around this function.	Thus, any
//		work done will be undone if a failure occurs.
//		For temporary files, transaction logging is deactivated
//		for the duration of the routine.
//		Index entries are not made for entirely-null keys.
//-
INLINE LOCAL ERR ErrRECReplace( PIB *ppib, FUCB *pfucb )
	{
	ERR		err = JET_errSuccess;	// error code of various utility
	FCB		*pfcbFile;				// file's FCB
	FCB		*pfcbIdx;				// loop variable for each index on file
	FCB		*pfcbCurIdx;			// FCB of current index (if any)
	IDB		*pidbFile;				// IDB of table (if any)
	UIPB   	uipb;					// parameter block to ErrRECIUpdateIndex
	BOOL   	fTaggedChanged; 		// SetField done on any tagged field?
	BF	   	*pbf = pbfNil;
	LINE   	*plineNewData;
	FID		fidFixedLast;
	FID		fidVarLast;
	FID		fid;
	BOOL   	fUpdateIndex;
	BOOL   	fCommit = fFalse;
	INT		fFlags;

	CheckPIB( ppib );
	CheckTable( ppib, pfucb );
	CheckNonClustered( pfucb );

	/* should have been checked in PrepareUpdate
	/**/
	Assert( FFUCBUpdatable( pfucb ) );
	Assert( FFUCBReplacePrepared( pfucb ) );

	/* efficiency variables
	/**/
	fTaggedChanged = FFUCBTaggedSet( pfucb );
	pfcbFile = pfucb->u.pfcb;
	Assert( pfcbFile != pfcbNil );
	fidFixedLast = pfcbFile->pfdb->fidFixedLast;
	fidVarLast = pfcbFile->pfdb->fidVarLast;

	/*	must initialize pfucb for error handling.
	/**/
	uipb.pfucbIdx = pfucbNil;

	/*	record to use for update
	/**/
	plineNewData = &pfucb->lineWorkBuf;
	Assert( !( FLineNull( plineNewData ) ) );

	/*	start a transaction in case anything fails
	/**/
	if ( ppib->level == 0 || !FPIBAggregateTransaction( ppib )  )
		{
		CallR( ErrDIRBeginTransaction( ppib ) );
		fCommit = fTrue;
		}

	/* optimistic locking -- ensure that record has not changed since PrepareUpdate
	/**/
	if ( FFUCBReplaceNoLockPrepared( pfucb ) )
		{
		Call( ErrDIRGet( pfucb ) );
		if ( !FChecksum( pfucb ) )
			Call( JET_errWriteConflict );
		}
		
	/* abort if index is being built on file
	/**/
	if ( FFCBDenyDDL( pfcbFile, ppib ) )
		{
		Call( JET_errWriteConflict );
		}

	/*	if need to update indexes, then cache old record.
	/**/
	fUpdateIndex = ( pfcbFile->fAllIndexTagged && fTaggedChanged ) ||
		FIndexedFixVarChanged( pfcbFile->rgbitAllIndex,
		pfucb->rgbitSet, fidFixedLast, fidVarLast );

	if ( fUpdateIndex )
		{
		/*	get a temp buffer to hold old data.
		/**/
		Call( ErrBFAllocTempBuffer( &pbf ) );
		Assert( pbf->ppage != 0 );
		uipb.lineOldData.pb = (BYTE*)pbf->ppage;

		/*	refresh currency.
		/**/
		Call( ErrDIRGet( pfucb ) );

		/*	copy old data for index update.
		/**/
		LineCopy( &uipb.lineOldData, &pfucb->lineData );

		/* make sure clustered key did not change.
		/**/
		pidbFile = pfcbFile->pidb;
		if ( pidbFile != pidbNil )
			{
			/*
		 	* Quick check for unchanged key:  if no fixed or var index segment
		 	* has changed, and either (1) there are no tagged index segments,
		 	* or (2) there is a tagged segment, but no tagged field (indexed
		 	* or not) has changed, then the key has not changed.
		 	*/
			if ( ( ( pidbFile->fidb & fidbHasTagged ) && fTaggedChanged ) ||
				FIndexedFixVarChanged( pidbFile->rgbitIdx, pfucb->rgbitSet, fidFixedLast, fidVarLast ) )
				{
				KEY	keyOld;
				KEY	keyNew;
				BYTE	rgbOldKeyBuf[ JET_cbKeyMost ];
				BYTE	rgbNewKeyBuf[ JET_cbKeyMost ];

				Assert( fUpdateIndex );

				/*	get new key from copy buffer
				/**/
				keyNew.pb = rgbNewKeyBuf;
				Call( ErrRECExtractKey( pfucb, (FDB *)pfcbFile->pfdb, pidbFile, plineNewData, &keyNew, 1 ) );
				Assert( err == wrnFLDNullKey ||
					err == wrnFLDNullSeg ||
					err == JET_errSuccess );

				/*	get the old key from the node
				/**/
				keyOld.pb = rgbOldKeyBuf;
				Call( ErrRECExtractKey( pfucb, (FDB *)pfcbFile->pfdb, pidbFile, &uipb.lineOldData, &keyOld, 1 ) );
				Assert( err == wrnFLDNullKey ||
					err == wrnFLDNullSeg ||
					err == JET_errSuccess );

				/*	record must honor index no NULL segment requirements
				/**/
				Assert( !( pidbFile->fidb & fidbNoNullSeg ) ||
					( err != wrnFLDNullSeg && err != wrnFLDNullKey ) );

				if ( keyOld.cb != keyNew.cb || memcmp( keyOld.pb, keyNew.pb, keyOld.cb ) != 0 )
					{
					Error( JET_errRecordClusteredChanged, HandleError )
					}
				}
			}
		}

	/*	set autoinc and version fields if they are present
	/**/
	Assert( FFUCBIndex( pfucb ) );
	fid = pfcbFile->pfdb->fidVersion;
	if ( fid != 0 )
		{
		LINE	lineField;
		ULONG	ul;

		/*	increment field from value in current record
		/**/
		Call( ErrRECIRetrieve( pfucb, &fid, 0, &lineField, 0 ) );

		/*	handle case where field is NULL when column added
		/*	to table with records present
		/**/
		if ( lineField.cb == 0 )
			{
			ul = 1;
			lineField.cb = sizeof(ul);
			lineField.pb = (BYTE *)&ul;
			}
		else
			{
			Assert( lineField.cb == sizeof(ULONG) );
			++*(UNALIGNED ULONG *)lineField.pb;
			}

		Call( ErrRECIModifyField( pfucb, fid, 0, &lineField ) );
		}

	/*	replace data.
	/*	Do not version if before image already exists and record size
	/*	has not changed.
	/**/
//	UNDONE:	reenable optimization on not versioning when already
//			versioned for pessomistic locking but with indication
//			to loggging recovery for rollback.
//	if ( FFUCBReplaceNoLockPrepared( pfucb ) )
//		{
		fFlags = fDIRVersion;
//		}
//	else
//		{
//		Assert( pfucb->cbRecord > 0 );
//		if ( pfucb->cbRecord != plineNewData->cb )
//			fFlags = fDIRVersion;
//		else
//			fFlags = 0;
//		}

	/*	if updated separate long values then delete
	/*	removed long values.
	/**/
	if ( FFUCBUpdateSeparateLV( pfucb ) )
		{
		Call( ErrRECAffectLongFields( pfucb, NULL, fDereferenceRemoved ) );
		}

	Call( ErrDIRReplace( pfucb, plineNewData, fFlags ) );

	/*	update indexes
	/**/
	if ( fUpdateIndex )
		{
		uipb.pfucb = pfucb;
		uipb.lineNewData = *plineNewData;
		uipb.fOpenFUCB = fTrue;
		uipb.fFreeFUCB = fFalse;

		/*	get SRID of record
		/**/
		DIRGetBookmark( pfucb, &uipb.srid );

		pfcbCurIdx = pfucb->pfucbCurIndex != pfucbNil ?	pfucb->pfucbCurIndex->u.pfcb : pfcbNil;

		for ( pfcbIdx = pfcbFile->pfcbNextIndex;
				pfcbIdx != pfcbNil;
				pfcbIdx = pfcbIdx->pfcbNextIndex )
			{
			if ( ( pfcbIdx->pidb->fidb & fidbHasTagged && fTaggedChanged ) ||
				FIndexedFixVarChanged( pfcbIdx->pidb->rgbitIdx,
					pfucb->rgbitSet,
					fidFixedLast,
					fidVarLast ) )
				{
				Call( ErrRECIUpdateIndex( pfcbIdx, &uipb ) );
				}
			}
		}

	/*	commit transaction
	/**/
	if ( fCommit )
		{
		Call( ErrDIRCommitTransaction( ppib ) );
		}

	FUCBResetUpdateSeparateLV( pfucb );
	FUCBResetCbstat( pfucb );

	/*	reset rglineDiff delta logging
	/**/
	pfucb->clineDiff = 0;
	pfucb->fCmprsLg = fFalse;

HandleError:
	if ( uipb.pfucbIdx != pfucbNil )
		DIRClose( uipb.pfucbIdx );

	if ( pbf != pbfNil )
		BFSFree( pbf );

	/*	rollback if necessary
	/**/
	if ( err < 0 && fCommit )
		{
		CallS( ErrDIRRollback( ppib ) );
		}

	return err;
	}


BOOL FIndexedFixVarChanged( BYTE *rgbitIdx, BYTE *rgbitSet, FID fidFixedLast, FID fidVarLast )
	{
	LONG	*plIdx;
	LONG	*plIdxMax;
	LONG	*plSet;

	/* check fixed fields (only those defined)
	/**/
	plIdx = (LONG *)rgbitIdx;
	plSet = (LONG *)rgbitSet;
	plIdxMax = plIdx + ( fidFixedLast + 31 ) / 32;
	while ( plIdx < plIdxMax && !( *plIdx & *plSet ) )
		plIdx++, plSet++;

	/*	indexed fixed field changed
	/**/
	if ( plIdx < plIdxMax )
		return fTrue;

	/* check variable fields (only those defined)
	/**/
	plIdx = (LONG *)rgbitIdx + 4;
	plSet = (LONG *)rgbitSet + 4;
	plIdxMax = plIdx + ( fidVarLast - ( fidVarLeast - 1 ) + 31 ) / 32;
	while ( plIdx < plIdxMax && !( *plIdx & *plSet ) )
		plIdx++, plSet++;

	return ( plIdx < plIdxMax );
	}


//+local
// ErrRECIUpdateIndex
// ========================================================================
// ERR ErrRECIUpdateIndex(pfcbIdx, puipb)
//	  FCB *pfcbIdx; 	// IN	   FCB of index to insert into
//	  UIPB *puipb;		// INOUT   parameter block
// Extracts keys from old and new data records, and if they are different,
// opens the index, adds the new index entry, deletes the old index entry,
// and closes the index.
//
// PARAMETERS
//				pfcbIdx							FCB of index to insert into
//				puipb->ppib						who is calling this routine
//				puipb->pfucbIdx				pointer to index's FUCB.  If pfucbNil,
//													an FUCB will be allocated by DIROpen.
//				puipb->lineOldData.cb		length of old data record
//				puipb->lineOldData.pb		old data to extract old key from
//				puipb->srid						SRID of record
//				puipb->lineNewData.cb		length of new data record
//				puipb->lineNewData.pb		new data to extract new key from
//				puipb->fFreeFUCB				free index FUCB?
// RETURNS		JET_errSuccess, or error code from failing routine
// SIDE EFFECTS if patipb->pfucbIdx==pfucbNil, ErrDIROpen will allocate
//				an FUCB and it will be pointed at it.
//				If fFreeFUCB is fFalse, patipb->pfucbIdx should
//				be used in a subsequent ErrDIROpen.
// SEE ALSO		Replace
//-
INLINE LOCAL ERR ErrRECIUpdateIndex( FCB *pfcbIdx, UIPB *puipb )
	{
	ERR		err = JET_errSuccess;				// error code of various utility
	LINE		lineSRID;								// SRID to add to index
	KEY		keyOld;				  					// key extracted from old record
	BYTE		rgbOldKeyBuf[ JET_cbKeyMost];		// buffer for old key
	KEY		keyNew;				  					// key extracted from new record
	BYTE		rgbNewKeyBuf[ JET_cbKeyMost ]; 	// buffer for new key
	ULONG		itagSequenceOld; 						// used to extract keys
	ULONG		itagSequenceNew;						// used to extract keys
	BOOL		fHasMultivalue;								// index has tagged segment?
	BOOL		fMustDelete;							// record no longer generates key?
	BOOL		fMustAdd;								// record now generates this key?
	BOOL		fAllowNulls;							// this index allows NULL keys?
	BOOL		fAllowSomeNulls;						// this index allows keys with NULL segment(s)?
	BOOL		fNoNullSeg;								// this index prohibits any NULL key segment?
	BOOL		fDoOldNullKey;
	BOOL		fDoNewNullKey;

	Assert( pfcbIdx != pfcbNil );
	Assert( pfcbIdx->pfdb != pfdbNil );
	Assert( pfcbIdx->pidb != pidbNil );
	Assert( puipb != NULL );
	Assert( puipb->pfucb != pfucbNil );
	Assert( puipb->pfucb->ppib != ppibNil );
	Assert( puipb->pfucb->ppib->level < levelMax );
	Assert( !FLineNull( &puipb->lineOldData ) );
	Assert( !FLineNull( &puipb->lineNewData ) );

	/*** open FUCB on this index ***/
	CallR( ErrDIROpen( puipb->pfucb->ppib, pfcbIdx, 0, &puipb->pfucbIdx ) );
	Assert( puipb->pfucbIdx != pfucbNil );
	FUCBSetIndex( puipb->pfucbIdx );
	FUCBSetNonClustered( puipb->pfucbIdx );

	fHasMultivalue = pfcbIdx->pidb->fidb & fidbHasMultivalue;
	fAllowNulls = pfcbIdx->pidb->fidb & fidbAllowAllNulls;
	fAllowSomeNulls = pfcbIdx->pidb->fidb & fidbAllowSomeNulls;
	fNoNullSeg = pfcbIdx->pidb->fidb & fidbNoNullSeg;

#if DBFORMATCHANGE	
	Assert( ( fAllowNulls || fAllowSomeNulls ) ^ fNoNullSeg );
	// if fAllowNulls, then fAllowSomeNulls needs to be true
	Assert( !fAllowNulls || fAllowSomeNulls );
#endif

	keyOld.pb = rgbOldKeyBuf;
	keyNew.pb = rgbNewKeyBuf;

	/* delete the old key from the index 
	/**/
	fDoOldNullKey = fFalse;
	for ( itagSequenceOld = 1; ; itagSequenceOld++ )
		{
		Call( ErrRECExtractKey( puipb->pfucb, (FDB *)pfcbIdx->pfdb, pfcbIdx->pidb, &puipb->lineOldData, &keyOld, itagSequenceOld ) );
		Assert( err == wrnFLDNullKey ||
			err == wrnFLDOutOfKeys ||
			err == wrnFLDNullSeg ||
			err == JET_errSuccess );

		if ( err == wrnFLDOutOfKeys )
			{
			Assert( itagSequenceOld > 1 );
			break;
			}

		/*	record must honor index no NULL segment requirements
		/**/
		Assert( !fNoNullSeg || ( err != wrnFLDNullSeg && err != wrnFLDNullKey ) );

		if ( err == wrnFLDNullKey )
			{
			if ( fAllowNulls )
				fDoOldNullKey = fTrue;
			else
				break;
			}
		else
			{
			if ( err == wrnFLDNullSeg && !fAllowSomeNulls )
				break;
			}

		fMustDelete = fTrue;
		fDoNewNullKey = fFalse;
		for ( itagSequenceNew = 1; ; itagSequenceNew++ )
			{
			/*	extract key from new data in copy buffer
			/**/
			Call( ErrRECExtractKey( puipb->pfucb, (FDB *)pfcbIdx->pfdb, pfcbIdx->pidb, &puipb->lineNewData, &keyNew, itagSequenceNew ) );
			Assert( err == wrnFLDNullKey ||
				err == wrnFLDOutOfKeys ||
				err == wrnFLDNullSeg ||
				err == JET_errSuccess );
			if ( err == wrnFLDOutOfKeys )
				{
				Assert( itagSequenceNew > 1 );
				break;
				}

			if ( err == wrnFLDNullKey )
				{
				if ( fAllowNulls )
					fDoNewNullKey = fTrue;
				else
					break;
				}
			else
				{
				if ( err == wrnFLDNullSeg && !fAllowSomeNulls )
					break;
				}

			if ( keyOld.cb == keyNew.cb && memcmp( keyOld.pb, keyNew.pb, keyOld.cb ) == 0 )
				{
				fMustDelete = fFalse;
				break;
				}

			if ( !fHasMultivalue || fDoNewNullKey )
				break;
			}

		if ( fMustDelete )
			{
			/*	move to DATA root.  Seek to index entry.
			/**/
			DIRGotoDataRoot( puipb->pfucbIdx );
			Call( ErrDIRDownKeyBookmark( puipb->pfucbIdx, &keyOld, puipb->srid ) );
			Call( ErrDIRDelete( puipb->pfucbIdx, fDIRVersion ) );
			}

		if ( !fHasMultivalue || fDoOldNullKey )
			break;
		}

	/* insert the new key into the index 
	/**/
	lineSRID.cb = sizeof(SRID);
	lineSRID.pb = (BYTE *)&puipb->srid;
	fDoNewNullKey = fFalse;
	for ( itagSequenceNew = 1; ; itagSequenceNew++ )
		{
		/*	extract key from new data in copy buffer
		/**/
		Call( ErrRECExtractKey( puipb->pfucb, (FDB *)pfcbIdx->pfdb, pfcbIdx->pidb,
		   &puipb->lineNewData, &keyNew, itagSequenceNew ) );
		Assert( err == wrnFLDNullKey ||
			err == wrnFLDOutOfKeys ||
			err == wrnFLDNullSeg ||
			err == JET_errSuccess );
		if ( err == wrnFLDOutOfKeys )
			{
			Assert( itagSequenceNew > 1 );
			break;
			}

		if ( fNoNullSeg && ( err == wrnFLDNullSeg || err == wrnFLDNullKey ) )
			{
			err = JET_errNullKeyDisallowed;
			goto HandleError;
			}

		if ( err == wrnFLDNullKey )
			{
			if ( fAllowNulls )
				fDoNewNullKey = fTrue;
			else
				break;
			}
		else
			{
			if ( err == wrnFLDNullSeg && !fAllowSomeNulls )
				break;
			}

		fMustAdd = fTrue;
		fDoOldNullKey = fFalse;
		for ( itagSequenceOld = 1; ; itagSequenceOld++ )
			{
			Call( ErrRECExtractKey( puipb->pfucb, (FDB *)pfcbIdx->pfdb, pfcbIdx->pidb,
			   &puipb->lineOldData, &keyOld, itagSequenceOld ) );
			Assert( err == wrnFLDNullKey ||
				err == wrnFLDOutOfKeys ||
				err == wrnFLDNullSeg ||
				err == JET_errSuccess );
			if ( err == wrnFLDOutOfKeys )
				{
				Assert( itagSequenceOld > 1 );
				break;
				}

			/*	record must honor index no NULL segment requirements
			/**/
			Assert( !( pfcbIdx->pidb->fidb & fidbNoNullSeg ) ||
				( err != wrnFLDNullSeg && err != wrnFLDNullKey ) );

			if ( err == wrnFLDNullKey )
				{
				if ( fAllowNulls )
					fDoOldNullKey = fTrue;
				else
					break;
				}
			else
				{
				if ( err == wrnFLDNullSeg && !fAllowSomeNulls )
					break;
				}

			if ( keyOld.cb == keyNew.cb &&
				memcmp( keyOld.pb, keyNew.pb, keyOld.cb ) ==0 )
				{
				fMustAdd = fFalse;
				break;
				}

			if ( !fHasMultivalue || fDoOldNullKey )
				break;
			}

		if ( fMustAdd )
			{
			BOOL fAllowDupls = fDoNewNullKey ||	!(pfcbIdx->pidb->fidb & fidbUnique);

			/*	move to DATA root and insert new index entry.
			/**/
			DIRGotoDataRoot( puipb->pfucbIdx );
			Call( ErrDIRInsert(puipb->pfucbIdx, &lineSRID, &keyNew,
				(fAllowDupls ? fDIRDuplicate : 0) |
				fDIRPurgeParent | fDIRVersion ) );
			}

		if ( !fHasMultivalue || fDoNewNullKey )
			break;
		}

	/*	supress warnings
	/**/
	Assert( err == wrnFLDNullKey ||
		err == wrnFLDOutOfKeys ||
		err == wrnFLDNullSeg ||
		err == JET_errSuccess );
	err = JET_errSuccess;

HandleError:
	/* close the FUCB.
	/**/
	DIRClose( puipb->pfucbIdx );
	puipb->pfucbIdx = pfucbNil;

	Assert( err < 0 || err == JET_errSuccess );
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\redut.c ===
#include "config.h"

#include <string.h>
#include <stdlib.h>

#include "daedef.h"
#include "ssib.h"
#include "pib.h"
#include "util.h"
#include "page.h"
#include "fucb.h"
#include "stapi.h"
#include "dirapi.h"
#include "logapi.h"
#include "log.h"

#include "fileapi.h"
#include "dbapi.h"
DeclAssertFile;					/* Declare file name for assert macros */


/* variables used in redo only */
BYTE		*pbNext;		// redo only - location of next buffer entry
BYTE		*pbRead; 		// redo only - location of next rec to flush
INT			isecRead;		/* redo only - next disk to read. */
BOOL		fOnLastSec;		/* redo only - on last sector of cur lg file */

LGPOS		lgposLastRec;	/* mark for end of rec */


VOID GetLgposOfPbNext(LGPOS *plgpos)
	{
	char *pb = PbSecAligned(pbNext);
	int ib = (int)(pbNext - pb);
	int isec;

	if (pb > pbRead)
		isec = (int)(pbRead + csecLGBuf * cbSec - pb) / cbSec;
	else
		isec = (int)(pbRead - pb) / cbSec;
	isec = isecRead - isec;

	plgpos->isec = (USHORT)isec;
	plgpos->ib = (USHORT)ib;
	plgpos->usGeneration = plgfilehdrGlobal->lgposLastMS.usGeneration;
	}


#ifdef DEBUG

/* calculate the lgpos of the LR */
VOID PrintLgposReadLR ( VOID )
	{
	LGPOS lgpos;

	GetLgposOfPbNext(&lgpos);
	PrintF2("\n%2u,%3u,%3u",
			plgfilehdrGlobal->lgposLastMS.usGeneration,
			lgpos.isec, lgpos.ib);
	}

#endif


/*
 *  Read first record pointed by plgposFirst.
 *  Initialize isecRead, pbRead, and pbNext.
 */
ERR ErrLGLocateFirstRedoLogRec(
	LGPOS *plgposPrevMS,
	LGPOS *plgposFirst,				/* lgpos for first redo record */
	BYTE **ppbLR)
	{
	ERR err;
	char *pbNextT;

	/*  read first sector, actually we read 2 pages such that we can
	 *  guarrantee that when calculate the length of the record, the
	 *  fixed part of the record is read in.
	 */
	if (pbLGBufMin + 3 * cbSec > pbLGBufMax)
		return JET_errLogBufferTooSmall;

	if ( plgposPrevMS && plgposPrevMS->isec != 0 )
		{
		CallR(ErrLGRead(hfLog, plgposPrevMS->isec, pbLGBufMin, 1))
		CallS(ErrLGRead(hfLog, plgposPrevMS->isec + 1, pbLGBufMin + cbSec, 1));
		isecRead = plgposPrevMS->isec + 1;	/* sector next to read. */
		pbRead = pbLGBufMin + cbSec;
		pbNext = pbLGBufMin + plgposPrevMS->ib;
		pbLastMSFlush = pbNext;
		lgposLastMSFlush = *plgposPrevMS;
		}
	else
		{
		CallR(ErrLGRead(hfLog, plgposFirst->isec, pbLGBufMin, 1))
		CallS(ErrLGRead(hfLog, plgposFirst->isec + 1, pbLGBufMin + cbSec, 1));
		isecRead = plgposFirst->isec + 1;	/* sector next to read. */
		pbRead = pbLGBufMin + cbSec;
		pbNext = pbLGBufMin + plgposFirst->ib;

		/* initialize global variables */
		if ( lgposLastMSFlush.isec == plgposFirst->isec )
			{
			pbLastMSFlush = pbLGBufMin + lgposLastMSFlush.ib;
			}
		else
			{
			pbLastMSFlush = 0;
			memset( &lgposLastMSFlush, 0, sizeof(lgposLastMSFlush) );
			}
		}

	/*  continue reading more sectors till next MS log record or
	 *  a Fill log record is reached.
	 */
	pbNextT = pbNext;
	while (*(LRTYP*)pbNextT != lrtypFill)
		{
		char *pbAligned;

		/* goto next record */
		pbNextT += (ULONG) CbLGSizeOfRec((LR*)pbNextT);

		if (pbNextT > pbLGBufMax)
			return JET_errLogFileCorrupt;

		pbAligned = PbSecAligned(pbNextT);
		if (pbAligned >= pbRead)
			{
			int csecToRead;

			if ( plgposFirst->isec <= 2 &&
				 plgfilehdrGlobal->lgposLastMS.ib == 0 &&
				 plgfilehdrGlobal->lgposLastMS.isec <= 2 )
				{
				/* a special case where we tried to scan through this page and
				 * realize that no MS or fill record is read. Should not read
				 * beyond this page. Do not continue reading.
				 */
				break;
				}

			/*  physically read one more page to guarrantee that
			 *  the fix part of the log record is read in the
			 *  memory.
			 */
			csecToRead = (int)(pbAligned - pbRead) / cbSec + 1;
			if (pbRead + csecToRead * cbSec > pbLGBufMax)
				return JET_errLogBufferTooSmall;

			CallR( ErrLGRead(hfLog, isecRead, pbRead, csecToRead ))
			isecRead += csecToRead;
			pbRead += csecToRead * cbSec;

			CallS( ErrLGRead(hfLog, isecRead, pbRead, 1 ));
			}

		/* reach next MS, break */
		if ( *(LRTYP*)pbNextT == lrtypMS )
			break;
		}

	if ( plgposPrevMS && plgposPrevMS->isec != 0 )
		{
		pbNext = pbLGBufMin + cbSec * ( plgposFirst->isec - plgposPrevMS->isec );		pbNext += plgposFirst->ib;
		}

	/* set up returned value. */
	*ppbLR = pbNext;

	return JET_errSuccess;
	}


/*
 *  Set pbNext to next available log record.
 */
ERR ErrLGGetNextRec( BYTE **ppbLR )
	{
	ERR		err;
	int		cb;
	char	*pb;
	LR		*plr;
	LGPOS	lgposT;
	BYTE	*pbNextOld;

	/* caller should have taken care of the Fill case. */
	Assert (*(LRTYP *)pbNext != lrtypFill);

	/* move to next log record. */
	pbNextOld = pbNext;
	pbNext += (ULONG) CbLGSizeOfRec((LR*)pbNext);

	/* check if next log record is out of buffer range. */

	if (pbNext == pbRead)
		{
		/* the record ends on the sector boundary */
		pbNext = pbLGBufMin;
		pbRead = pbNext;

		/* read in one more page. */
		if (pbLGBufMin + cbSec > pbLGBufMax)
			return JET_errLogBufferTooSmall;

		CallR(ErrLGRead(hfLog, isecRead, pbLGBufMin, 1))
		isecRead += 1;
		pbRead = pbLGBufMin + cbSec;
		}

	if (pbNext > pbRead)
		{
		pbNext = pbNextOld;
		return errLGNoMoreRecords;
		}

	GetLgposOfPbNext(&lgposT);
	if ( CmpLgpos( &lgposT, &lgposLastRec ) > 0 )
		{
		pbNext = pbNextOld;
		return errLGNoMoreRecords;
		}

	plr = (LR *) pbNext;

	if (plr->lrtyp == lrtypFill)
		{
		/* end of current log file. */
		goto Done;
		}
	else if (plr->lrtyp == lrtypMS)
		{
		LRMS *plrms = (LRMS *)plr;

#ifdef DEBUG
		// same as TraceRedo() in redo.c
		if (fDBGTraceRedo)
			{
			PrintLgposReadLR();
			ShowLR(plr);
			}
#endif

		/*  check if this MS was done completely by reading
		 *  the whole sector in. If it fails, then the sector
		 *  is the last sector available in the log file.
		 */
		fOnLastSec = ( plrms->isecForwardLink == 0 ||
						(  lgposLastMSFlush.isec != 0 &&
							(
							plrms->isecBackLink != lgposLastMSFlush.isec ||
							plrms->ibBackLink != lgposLastMSFlush.ib
					 )	)	);

		/*  The MS were read in successfully, reset LastMSFlush
		 *  so that when switching from read mode to write mode,
		 *  we will have a correct LastMSFlush pointers.
		 */
		pbLastMSFlush = (CHAR *) plrms;
		lgposLastMSFlush = lgposT;

		if ( !fOnLastSec )
			{
			if (isecRead <= plrms->isecForwardLink)
				{
				int csecToRead = plrms->isecForwardLink - isecRead + 1;

				Assert( csecToRead > 0 );
				
				pb = PbSecAligned(pbNext);
				cb = (int)(pbRead - pb);
				if (csecToRead + isecRead > csecLGBuf)
					{
					/* the multiple sector will not fit in rest of */
					/* the available buffer. Shift the buffer. */
					memmove(pbLGBufMin, pb, cb);
					
					pbRead = pbLGBufMin + cb;				/* pbRead */
					pbNext = pbNext - pb + pbLGBufMin;		/* pbNext */
					pbLastMSFlush = (CHAR *) plrms - pb + pbLGBufMin;
					}

				/* bring in multiple sectors */
				if (pbRead + csecToRead * cbSec > pbLGBufMax)
					{
					BYTE *pbLGBufMinT = pbLGBufMin;
					CallR( ErrLGInitLogBuffers( lLogBuffers ) );
					memcpy( pbLGBufMin, pbLGBufMinT, cb );
					
					pbRead = pbRead - pbLGBufMinT + pbLGBufMin;
					pbNext = pbNext - pbLGBufMinT + pbLGBufMin;
					pbLastMSFlush = pbLastMSFlush - pbLGBufMinT + pbLGBufMin;
					
					SysFree( pbLGBufMinT );
					}

				err = ErrLGRead(hfLog, isecRead, pbRead, csecToRead);
				if (err < 0)
					fOnLastSec = fTrue;
				else
					{
					/*	Get pb of new lrms
					/*/
					CHAR *pbLrmsNew = pbRead + ( csecToRead - 1 ) * cbSec + ((LRMS *)pbLastMSFlush)->ibForwardLink;
					LRMS *plrmsNew = (LRMS *) pbLrmsNew;

					/*	check if the check sum is correct
					/*/
					if ( plrmsNew->ulCheckSum != UlLGMSCheckSum( pbLrmsNew ) )
						fOnLastSec = fTrue;
					else
						{
						isecRead += csecToRead;
						pbRead += csecToRead * cbSec;
						}
					}
				}
			}

		/* skip MS and continue to read next record. */
		pbNextOld = pbNext;
		pbNext += CbLGSizeOfRec((LR*)pbNext);

		/* nomal end of generation */
		if ( fOnLastSec && plgfilehdrGlobal->fEndWithMS )
			return errLGNoMoreRecords;
		
		/* or abnormal end of log file */
		if ( fOnLastSec && PbSecAligned(pbNextOld) != PbSecAligned(pbNext))
		    {
			pbNext = pbNextOld;
			return errLGNoMoreRecords;
			}
		}
Done:
	*ppbLR = pbNext;
	return JET_errSuccess;
	}


//+------------------------------------------------------------------------
//
//	CbLGSizeOfRec
//	=======================================================================
//
//	ERR CbLGSizeOfRec( plgrec )
//
//	Returns the length of a log record.
//
//	PARAMETER	plgrec	pointer to log record
//
//	RETURNS		size of log record in bytes
//
//-------------------------------------------------------------------------
INT mplrtypcb[ lrtypMax ] = {
	/* 	0 	NOP      */			sizeof( LRTYP ),
	/* 	1 	Start    */			0,
	/* 	2 	Quit     */			0,
	/* 	3 	MS       */			sizeof( LRMS ),
	/* 	4 	Fill     */			sizeof( LRTYP ),

	/* 	5 	Begin    */			sizeof( LRBEGIN ),
	/*	6 	Commit   */			sizeof( LRCOMMIT ),
	/*	7 	Abort    */			sizeof( LRABORT ),

	/*	8 	CreateDB */			0,
	/* 	9 	AttachDB */			0,
	/*	10	DetachDB */			0,

	/*	11	InitFDP  */			sizeof( LRINITFDPPAGE ),

	/*	12	Split    */			0,
	/*	13	EmptyPage*/			sizeof( LREMPTYPAGE ),
	/*	14	PageMerge*/			0,

	/* 	15	InsertND */			0,
	/* 	16	InsertIL */			0,
	/* 	17	Replace  */			0,
	/* 	18	ReplaceC */			0,
	/* 	19	FDelete  */			sizeof( LRFLAGDELETE ),
	/*	20	LockRec	 */			0,
	
	/*  21  UpdtHdr  */			sizeof( LRUPDATEHEADER ),
	/* 	22	InsertI  */			sizeof( LRINSERTITEM ),
	/* 	23	InsertIS */			0,
	/* 	24	FDeleteI */			sizeof( LRFLAGITEM ),
	/* 	25	FInsertI */			sizeof( LRFLAGITEM ),
	/*	26	DeleteI  */			sizeof( LRDELETEITEM ),
	/*	27	SplitItm */			sizeof( LRSPLITITEMLISTNODE ),

	/*	28	Delta	 */			sizeof( LRDELTA ),

	/*	29	DelNode  */			sizeof( LRDELETE ),
	/*	30	ELC      */			sizeof( LRELC ),

	/*	31	FreeSpace*/			sizeof( LRFREESPACE ),
	/*	32	Undo     */			sizeof( LRUNDO ),
	/*  33  RcvrUndo1*/			0,
	/*  34  RcvrQuit1*/			0,
	/*  35  RcvrUndo2*/			0,
	/*  36  RcvrQuit2*/			0,
	/*  37  FullBkUp */			0,
	/*  38  IncBkUp  */			0,
	/*  39  CheckPage  */		sizeof( LRCHECKPAGE ),
	};


INT CbLGSizeOfRec( LR *plr )
	{
	INT		cb;

	Assert( plr->lrtyp < lrtypMax );

	if ( ( cb = mplrtypcb[plr->lrtyp] ) != 0 )
		return cb;

	switch ( plr->lrtyp )
		{
	case lrtypStart:
		return sizeof(LRSTART);

	case lrtypQuit:
	case lrtypRecoveryQuit1:
	case lrtypRecoveryQuit2:
		return sizeof(LRQUITREC);

	case lrtypRecoveryUndo1:
	case lrtypRecoveryUndo2:
	case lrtypFullBackup:
	case lrtypIncBackup:
		{
		LRLOGRESTORE *plrlogrestore = (LRLOGRESTORE *) plr;
		return sizeof(LRLOGRESTORE) + plrlogrestore->cbPath;
		}

	case lrtypCreateDB:
		{
		LRCREATEDB *plrcreatedb = (LRCREATEDB *)plr;
		Assert( plrcreatedb->cb != 0 );
		return sizeof(LRCREATEDB) + plrcreatedb->cb;
		}
	case lrtypAttachDB:
		{
		LRATTACHDB *plrattachdb = (LRATTACHDB *)plr;
		Assert( plrattachdb->cb != 0 );
		return sizeof(LRATTACHDB) + plrattachdb->cb;
		}
	case lrtypDetachDB:
		{
		LRDETACHDB *plrdetachdb = (LRDETACHDB *)plr;
		Assert( plrdetachdb->cb != 0 );
		return sizeof( LRDETACHDB ) + plrdetachdb->cb;
		}
	case lrtypSplit:
		{
		LRSPLIT *plrsplit = (LRSPLIT *) plr;
		return sizeof( LRSPLIT ) + plrsplit->cbKey + plrsplit->cbKeyMac +
				sizeof( BKLNK ) * plrsplit->cbklnk;
		}
	case lrtypMerge:
		{
		LRMERGE *plrmerge = (LRMERGE *) plr;
		return sizeof( LRMERGE ) + sizeof( BKLNK ) * plrmerge->cbklnk;
		}
	case lrtypInsertNode:
	case lrtypInsertItemList:
		{
		LRINSERTNODE *plrinsertnode = (LRINSERTNODE *) plr;
		return	sizeof(LRINSERTNODE) +
				plrinsertnode->cbKey + plrinsertnode->cbData;
		}
	case lrtypInsertItems:
		{
		LRINSERTITEMS *plrinsertitems = (LRINSERTITEMS *) plr;
		return	sizeof(LRINSERTITEMS) +
				plrinsertitems->citem * sizeof(ITEM);
		}
	case lrtypReplace:
	case lrtypReplaceC:
		{
		LRREPLACE *plrreplace = (LRREPLACE *) plr;
		return sizeof(LRREPLACE) + plrreplace->cb +
			( plrreplace->fOld ? plrreplace->cbOldData : 0 );
		}
	case lrtypLockRec:
		{
		LRLOCKREC *plrlockrec = (LRLOCKREC *) plr;
		return sizeof(LRLOCKREC) + plrlockrec->cbOldData;
		}
	default:
		Assert( fFalse );
		}
    return 0;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\sortapi.c ===
#include "config.h"

#include <string.h>

#include "daedef.h"
#include "fmp.h"
#include "util.h"
#include "pib.h"
#include "ssib.h"
#include "page.h"
#include "fucb.h"
#include "fcb.h"
#include "stapi.h"
#include "fdb.h"
#include "idb.h"
#include "scb.h"
#include "dirapi.h"
#include "sortapi.h"
#include "recint.h"
#include "recapi.h"
#include "fileapi.h"
#include "fileint.h"

DeclAssertFile; 				/* Declare file name for assert macros */

extern int itibGlobal;

LOCAL ERR ErrSORTTableOpen( PIB *ppib, JET_COLUMNDEF *rgcolumndef, ULONG ccolumndef, JET_GRBIT grbit, FUCB **ppfucb, JET_COLUMNID *rgcolumnid );

ERR VTAPI ErrIsamSortOpen( PIB *ppib, JET_COLUMNDEF *rgcolumndef, ULONG ccolumndef, JET_GRBIT grbit, FUCB **ppfucb, JET_COLUMNID *rgcolumnid )
	{
	ERR		err;
	FUCB 		*pfucb;
#ifdef	DISPATCHING
	JET_TABLEID	tableid;
	CallR( ErrAllocateTableid( &tableid, (JET_VTID) 0, &vtfndefTTSortIns ) );
#endif	/* DISPATCHING */

	Call( ErrSORTTableOpen( ppib, rgcolumndef, ccolumndef, grbit, &pfucb, rgcolumnid ) );
	Assert( pfucb->u.pscb->fcb.wRefCnt == 1 );

	/* Sort is done on the temp database which is always updatable */
	/**/
	FUCBSetUpdatable( pfucb );

#ifdef	DISPATCHING
	/* Inform dispatcher of correct JET_VTID
	/**/
	CallS( ErrSetVtidTableid( (JET_SESID) ppib, tableid, (JET_VTID) pfucb ) );
	pfucb->fVtid = fTrue;
	*(JET_TABLEID *) ppfucb = tableid;
#else	/* !DISPATCHING */
	*ppfucb = pfucb;
#endif	/* !DISPATCHING */

	return JET_errSuccess;

HandleError:
#ifdef	DISPATCHING
	ReleaseTableid( tableid );
#endif	/* DISPATCHING */
	return err;
	}


LOCAL ERR ErrSORTTableOpen( PIB *ppib, JET_COLUMNDEF *rgcolumndef, ULONG ccolumndef, JET_GRBIT grbit, FUCB **ppfucb, JET_COLUMNID *rgcolumnid )
	{
	ERR				err;
	INT				icolumndefMax = (INT)ccolumndef;
	INT				wFlags = (INT)grbit;
	FUCB  			*pfucb = pfucbNil;
	IDB				*pidb;
	FDB				*pfdb;
	JET_COLUMNDEF	*pcolumndef;
	JET_COLUMNID	*pcolumnid;
	JET_COLUMNDEF	*pcolumndefMax = rgcolumndef+icolumndefMax;
	FID				fidFixedLast, fidVarLast, fidTaggedLast;
	INT				iidxsegMac;
	IDXSEG			rgidxseg[JET_ccolKeyMost];
	//	UNDONE:	find better way to set these values.  Note that this causes
	//				a problem because QJET would have to notify us of locale and
	//				it does not do this.
	LANGID			langid = 0x409;
	WORD  			wCountry = 1;

	CheckPIB( ppib );

	CallJ( ErrSORTOpen( ppib, &pfucb, ( wFlags & JET_bitTTUnique ? fSCBUnique : 0 ) ), SimpleError )
	*ppfucb = pfucb;

	/* save open flags
	/**/
	pfucb->u.pscb->grbit = grbit;

	/*** Determine max field ids and fix up lengths ***/
	//====================================================
	// Determine field "mode" as follows:
	// if ( JET_bitColumnTagged given ) or "long" ==> TAGGED
	// else if ( numeric type || JET_bitColumnFixed given ) ==> FIXED
	// else ==> VARIABLE
	//====================================================
	// Determine maximum field length as follows:
	// switch ( field type )
	//	   case numeric:
	//		   max = <exact length of specified type>;
	//	   case "short" textual:
	//		   if ( specified max == 0 ) max = JET_cbColumnMost
	//		   else max = MIN( JET_cbColumnMost, specified max )
	//====================================================
	fidFixedLast = fidFixedLeast - 1;
	fidVarLast = fidVarLeast - 1;
	fidTaggedLast = fidTaggedLeast - 1;
	for ( pcolumndef = rgcolumndef, pcolumnid = rgcolumnid; pcolumndef < pcolumndefMax; pcolumndef++, pcolumnid++ )
		{
		INT	fTagged;

		if ( pcolumndef->coltyp == JET_coltypLongBinary || pcolumndef->coltyp == JET_coltypLongText )
			fTagged = fTrue;
		else
			fTagged = fFalse;

		if ( ( pcolumndef->grbit & JET_bitColumnTagged ) || fTagged )
			{
			if ( ( *pcolumnid = ++fidTaggedLast ) > fidTaggedMost )
				{
				Error( JET_errTooManyColumns, HandleError );
				}
			}
		else if ( pcolumndef->coltyp == JET_coltypBit ||
				 pcolumndef->coltyp == JET_coltypUnsignedByte ||
				 pcolumndef->coltyp == JET_coltypShort ||
				 pcolumndef->coltyp == JET_coltypLong ||
				 pcolumndef->coltyp == JET_coltypCurrency ||
				 pcolumndef->coltyp == JET_coltypIEEESingle ||
				 pcolumndef->coltyp == JET_coltypIEEEDouble ||
				 pcolumndef->coltyp == JET_coltypDateTime ||
				 ( pcolumndef->grbit & JET_bitColumnFixed ) )
			{
			if ( ( *pcolumnid = ++fidFixedLast ) > fidFixedMost )
				{
				Error( JET_errTooManyFixedColumns, HandleError );
				}
			}
		else
			{
			if ( ( *pcolumnid = ++fidVarLast ) > fidVarMost )
				Error( JET_errTooManyVariableColumns, HandleError );
			}
		}

	Call( ErrRECNewFDB( &pfdb, fidFixedLast, fidVarLast, fidTaggedLast ) );

	pfucb->u.pscb->fcb.pfdb = pfdb;
	Assert( pfucb->u.pscb->fcb.pidb == pidbNil );

	iidxsegMac = 0;
	for ( pcolumndef = rgcolumndef, pcolumnid = rgcolumnid; pcolumndef < pcolumndefMax; pcolumndef++, pcolumnid++ )
		{
		FIELD field;

		field.coltyp = pcolumndef->coltyp;
		field.ffield = 0;
		field.szFieldName[0] = '\0';
		if ( field.coltyp == JET_coltypText || field.coltyp == JET_coltypLongText )
			{
			field.cp 	 	= pcolumndef->cp;
			field.langid 	= pcolumndef->langid;
			field.wCountry = pcolumndef->wCountry;
			}
		/*	determine field length
		/**/
		switch ( pcolumndef->coltyp )
			{
			case JET_coltypBit:
			case JET_coltypUnsignedByte:
				field.cbMaxLen = 1;
				break;
			case JET_coltypShort:
				field.cbMaxLen = 2;
				break;
			case JET_coltypLong:
			case JET_coltypIEEESingle:
				field.cbMaxLen = 4;
				break;
			case JET_coltypCurrency:
			case JET_coltypIEEEDouble:
			case JET_coltypDateTime:
				field.cbMaxLen = 8;
				break;
			case JET_coltypBinary:
			case JET_coltypText:
				if ( pcolumndef->cbMax == 0 || pcolumndef->cbMax >= JET_cbColumnMost )
					field.cbMaxLen = JET_cbColumnMost;
				else
					field.cbMaxLen = pcolumndef->cbMax;
				break;
			case JET_coltypLongBinary:
			case JET_coltypLongText:
				field.cbMaxLen = 0;
				break;
			}

		Call( ErrRECAddFieldDef( pfdb, (FID)*pcolumnid, &field ) );
		if ( ( pcolumndef->grbit & JET_bitColumnTTKey ) && iidxsegMac < JET_ccolKeyMost )
			{
			rgidxseg[iidxsegMac++] = ( pcolumndef->grbit & JET_bitColumnTTDescending ) ?
						-(IDXSEG)*pcolumnid : (IDXSEG)*pcolumnid;
			}
		}

	/*	set up the IDB and index definition if necessary
	/**/
	if ( iidxsegMac > 0 )
		{
		Call( ErrRECNewIDB( &pidb ) );
		pfucb->u.pscb->fcb.pidb = pidb;

		/*	Note:	this call used to test wFlags for JET_bitIndexIgnoreNull
		/*	and pass fidbAllowAllNulls if it was not set.  It also checked
		/*	wFlags for JET_bitIndexUnique instead of JET_bitTTUnique.
		/**/
		Call( ErrRECAddKeyDef(
			pfdb,
			pidb,
			(BYTE)iidxsegMac,
			rgidxseg,
			(BYTE)( fidbAllowAllNulls | fidbAllowSomeNulls | ( wFlags & JET_bitTTUnique ? fidbUnique : 0 ) ),
			langid ) );
		}

	/*	reset copy buffer
	/**/
	pfucb->pbfWorkBuf = pbfNil;
	pfucb->lineWorkBuf.pb = NULL;
	Assert( !FFUCBUpdateSeparateLV( pfucb ) );
	FUCBResetCbstat( pfucb );

	/*	reset key buffer
	/**/
	pfucb->pbKey = NULL;
	KSReset( pfucb );

	return JET_errSuccess;

HandleError:
	(VOID)ErrSORTClose( pfucb );
SimpleError:
	*ppfucb = pfucbNil;
	return err;
	}


ERR VTAPI ErrIsamSortEndInsert( PIB *ppib, FUCB *pfucb, ULONG *pgrbit )
	{
	ERR	err;
	ERR	wrn;

	*pgrbit = (ULONG)pfucb->u.pscb->grbit;

	/*	must return warning from ErrSORTEndRead since it is used
	/*	in decision to materialize sort.
	/**/
	Call( ErrSORTEndRead( pfucb ) );
	wrn = err;
	Call( ErrSORTFirst( pfucb ) );
	return wrn;

HandleError:
	return err;
	}


ERR VTAPI ErrIsamSortSetIndexRange( PIB *ppib, FUCB *pfucb, JET_GRBIT grbit )
	{
	ERR		err = JET_errSuccess;

	CheckPIB( ppib );
	CheckSort( ppib, pfucb );
	Assert( pfucb->u.pscb->grbit & JET_bitTTScrollable|JET_bitTTIndexed );

	if ( !FKSPrepared( pfucb ) )
		{
		return JET_errKeyNotMade;
		}

	FUCBSetIndexRange( pfucb, grbit );
	err =  ErrSORTCheckIndexRange( pfucb );

	return err;
	}


ERR VTAPI ErrIsamSortMove( PIB *ppib, FUCB *pfucb, long csrid, JET_GRBIT grbit )
	{
	ERR		err;
	BOOL  	fLast = ( csrid == JET_MoveLast );
#ifdef KEYCHANGED
	BOOL  	fNoKey;
	KEY		key;
	BYTE  	rgbKey[JET_cbKeyMost];
#endif

	Assert( !FSCBInsert( pfucb->u.pscb ) );

	CheckPIB( ppib );
	CheckSort( ppib, pfucb );

	/*	reset copy buffer status
	/**/
	Assert( !FFUCBUpdateSeparateLV( pfucb ) );
	FUCBResetCbstat( pfucb );

#ifdef KEYCHANGED
	/*	if sort non-unique then cache key of current node.
	/**/
	if ( !pfucb->u.pscb->fUnique )
		{
		key.pb = rgbKey;
		if ( ( pfucb->u.pscb->wRecords > 0 &&
			pfucb->ppbCurrent < pfucb->u.pscb->rgpb + pfucb->u.pscb->wRecords &&
			pfucb->ppbCurrent >= pfucb->u.pscb->rgpb ) )
			{
			fNoKey = fFalse;
			key.cb = pfucb->keyNode.cb;
			memcpy( rgbKey, pfucb->keyNode.pb, key.cb );
			}
		else
			fNoKey = fTrue;
		}
#endif

	/*	move forward csrid records
	/**/
	if ( csrid > 0 )
		{
		while ( csrid-- > 0 )
			{
			if ( ( err = ErrSORTNext( pfucb ) ) < 0 )
				{
				if ( fLast )
					err = JET_errSuccess;
				return err;
				}
			}
		}
	else if ( csrid < 0 )
		{
		Assert( ( pfucb->u.pscb->grbit & ( JET_bitTTScrollable | JET_bitTTIndexed ) ) );
		if ( csrid == JET_MoveFirst )
			{
			err = ErrSORTFirst( pfucb );
			return err;
			}
		else
			{
			while ( csrid++ < 0 )
				{
				if ( ( err = ErrSORTPrev( pfucb ) ) < 0 )
					return err;
				}
			}
		}
	else
		{
		/*	return currency status for move 0
		/**/
		SCB	*pscb = pfucb->u.pscb;

		Assert( csrid == 0 );
		if ( ! ( pscb->wRecords > 0 &&
			pfucb->ppbCurrent < pscb->rgpb + pscb->wRecords &&
			pfucb->ppbCurrent >= pfucb->u.pscb->rgpb ) )
			{
			return JET_errNoCurrentRecord;
			}
		else
			{
			return JET_errSuccess;
			}
		}

	Assert( err == JET_errSuccess );

#ifdef KEYCHANGED
	/*	if sort is unique then always return JET_wrnKeyChanged.
	/*	if duplicates allowed then compare new key against previous	key.
	/**/
	if ( pfucb->u.pscb->fUnique || fNoKey )
		{
		err = JET_wrnKeyChanged;
		}
	else
		{
		Assert( !fNoKey );
		if ( pfucb->keyNode.cb != key.cb ||
			memcpy( pfucb->keyNode.pb, key.pb, key.cb ) )
			{
			err = JET_wrnKeyChanged;
			}
		}
#endif

	return err;
	}


ERR VTAPI ErrIsamSortSeek( PIB *ppib, FUCB *pfucb, JET_GRBIT grbit )
	{
	ERR		err;
	KEY		key;
	BOOL		fGT = ( grbit & ( JET_bitSeekGT | JET_bitSeekGE ) );

	CheckPIB( ppib );
	CheckSort( ppib, pfucb );
	/*	assert reset copy buffer status
	/**/
	Assert( !FFUCBSetPrepared( pfucb ) );
	Assert( ( pfucb->u.pscb->grbit & ( JET_bitTTIndexed ) ) );

	if ( ! ( FKSPrepared( pfucb ) ) )
		{
		return JET_errKeyNotMade;
		}

	/*	ignore segment counter
	/**/
	key.pb = pfucb->pbKey + 1;
	key.cb = pfucb->cbKey - 1;

	/*	perform seek for equal to or greater than
	/**/
	err = ErrSORTSeek( pfucb, &key, fGT );
	if ( err >= 0 )
		{
		KSReset( pfucb );
		}

	Assert( err == JET_errSuccess ||
		err == JET_errRecordNotFound ||
		err == JET_wrnSeekNotEqual );

#define bitSeekAll (JET_bitSeekEQ | JET_bitSeekGE | JET_bitSeekGT |	\
	JET_bitSeekLE | JET_bitSeekLT)

	/*	take additional action if necessary or polymorph error return
	/*	based on grbit
	/**/
	switch ( grbit & bitSeekAll )
		{
	case JET_bitSeekEQ:
		if ( err == JET_wrnSeekNotEqual )
			err = JET_errRecordNotFound;
	case JET_bitSeekGE:
	case JET_bitSeekLE:
		break;
	case JET_bitSeekLT:
		if ( err == JET_wrnSeekNotEqual )
			err = JET_errSuccess;
		else if ( err == JET_errSuccess )
			{
			err = ErrIsamSortMove( ppib, pfucb, JET_MovePrevious, 0 );
			if ( err == JET_errNoCurrentRecord )
				err = JET_errRecordNotFound;
			}
		break;
	default:
		Assert( grbit == JET_bitSeekGT );
		if ( err == JET_wrnSeekNotEqual )
			err = JET_errSuccess;
		else if ( err == JET_errSuccess )
			{
			err = ErrIsamSortMove( ppib, pfucb, JET_MoveNext, 0 );
			if ( err == JET_errNoCurrentRecord )
				err = JET_errRecordNotFound;
			}
		break;
		}

	return err;
	}


ERR VTAPI ErrIsamSortGetBookmark(
	PIB					*ppib,
	FUCB					*pfucb,
	void					*pv,
	unsigned long		cbMax,
	unsigned long		*pcbActual )
	{
	SCB		*pscb = pfucb->u.pscb;
	long		ipb;

	CheckPIB( ppib );
	CheckSort( ppib, pfucb );
	Assert( pv != NULL );
	Assert( pscb->crun == 0 );

	if ( cbMax < sizeof( ipb ) )
		return JET_errBufferTooSmall;

	/*	bookmark on sort is index to pointer to byte
	/**/
	ipb = (long)( (BYTE *)pfucb->ppbCurrent - (BYTE *)pscb->rgpb ) / sizeof( BYTE * );
	if ( ipb < 0 || ipb >= pscb->wRecords )
		return JET_errNoCurrentRecord;
	
	if ( cbMax >= sizeof( ipb ) )
		{
		*(long *)pv = ipb;
		}

	if ( pcbActual )
		*pcbActual = sizeof(ipb);

	return JET_errSuccess;
	}


ERR VTAPI ErrIsamSortGotoBookmark(
	PIB				*ppib,
	FUCB				*pfucb,
	void				*pv,
	unsigned long	cbBookmark )
	{
	CheckPIB( ppib );
	CheckSort( ppib, pfucb );
	Assert( pfucb->u.pscb->crun == 0 );
	/*	assert reset copy buffer status
	/**/
	Assert( !FFUCBSetPrepared( pfucb ) );

	if ( cbBookmark != sizeof( long ) )
		{
		return JET_errInvalidBookmark;
		}

	Assert( *( long *)pv < pfucb->u.pscb->wRecords );
	pfucb->ppbCurrent = (BYTE **)pfucb->u.pscb->rgpb + *( long * )pv;

	return JET_errSuccess;
	}


#ifdef DEBUG

ERR VTAPI ErrIsamSortMakeKey(	
	PIB	 	*ppib,
	FUCB		*pfucb,
	BYTE		*pbKeySeg,
	ULONG		cbKeySeg,
	ULONG		grbit )
	{
	return ErrIsamMakeKey( ppib, pfucb, pbKeySeg, cbKeySeg, grbit );
	}


ERR VTAPI ErrIsamSortRetrieveColumn(	
	PIB				*ppib,
	FUCB				*pfucb,
	JET_COLUMNID	columnid,
	BYTE				*pb,
	ULONG				cbMax,
	ULONG				*pcbActual,
	ULONG				grbit,
	JET_RETINFO		*pretinfo )
	{
	return ErrIsamRetrieveColumn( ppib, pfucb, columnid, pb, cbMax,
		pcbActual, grbit, pretinfo );
	}


ERR VTAPI ErrIsamSortRetrieveKey(
	PIB					*ppib,
	FUCB					*pfucb,
	void					*pv,
	unsigned long		cbMax,
	unsigned long		*pcbActual,
	JET_GRBIT			grbit )
	{
	return ErrIsamRetrieveKey( ppib, pfucb, (BYTE *)pv, cbMax, pcbActual, 0L );
	}


ERR VTAPI ErrIsamSortSetColumn(	
	PIB				*ppib,
	FUCB				*pfucb,
	JET_COLUMNID	columnid,
	BYTE				*pbData,
	ULONG				cbData,
	ULONG				grbit,
	JET_SETINFO		*psetinfo )
	{
	return ErrIsamSetColumn( ppib, pfucb, columnid, pbData, cbData, grbit, psetinfo );
	}

#endif


/*	update only supports insert.
/**/
ERR VTAPI ErrIsamSortUpdate( PIB *ppib, FUCB *pfucb, BYTE *pb, ULONG cbMax, ULONG *pcbActual )
	{
	ERR		err = JET_errSuccess;
	BYTE  	rgbKeyBuf[ JET_cbKeyMost ];		// key buffer
	FDB		*pfdb;							// field descriptor info
	LINE  	*plineData;
	LINE  	rgline[2];

	CheckPIB( ppib );
	CheckSort( ppib, pfucb );

	/*** Efficiency variables ***/
	Assert( FFUCBSort( pfucb ) );
	if ( !( FFUCBInsertPrepared( pfucb ) ) )
		return JET_errUpdateNotPrepared;
	Assert( pfucb->u.pscb != pscbNil );
	pfdb = (FDB *)((FCB *)pfucb->u.pscb)->pfdb;
	Assert( pfdb != pfdbNil );
	/*	cannot get bookmark before sorting.
	/**/
	//	*pcbActual = 0

	/*** Record to use for put ***/
	plineData = &pfucb->lineWorkBuf;
	if ( FLineNull( plineData ) )
		return JET_errRecordNoCopy;
	else if ( FRECIIllegalNulls( pfdb, plineData ) )
		return JET_errNullInvalid;

	rgline[0].pb = rgbKeyBuf;
	Assert(((FCB *)pfucb->u.pscb)->pidb != pidbNil);
	//	UNDONE:	sort to support tagged columns
	CallR( ErrRECExtractKey( pfucb, pfdb, ((FCB *)pfucb->u.pscb)->pidb, plineData, (KEY*)&rgline[0], 1 ) );
	Assert( err != wrnFLDOutOfKeys );
	Assert( err == JET_errSuccess ||
		err == wrnFLDNullSeg ||
		err == wrnFLDNullKey );

	/*	return err if sort requires no NULL segment and segment NULL
	/**/
	if ( ( ((FCB *)pfucb->u.pscb)->pidb->fidb & fidbNoNullSeg ) && ( err == wrnFLDNullSeg || err == wrnFLDNullKey ) )
		{
		return JET_errNullKeyDisallowed;
		}

	/*	add if sort allows
	/**/
	rgline[1] = *plineData;
	if ( err == JET_errSuccess ||
		err == wrnFLDNullKey && ( ( (FCB*)pfucb->u.pscb )->pidb->fidb & fidbAllowAllNulls ) ||
		err == wrnFLDNullSeg &&	( ( (FCB*)pfucb->u.pscb )->pidb->fidb & fidbAllowSomeNulls ) )
		{
		CallR( ErrSORTInsert( pfucb, rgline ) );
		}

	Assert( !FFUCBUpdateSeparateLV( pfucb ) );
	FUCBResetCbstat( pfucb );
	return err;
	}


ERR VTAPI ErrIsamSortDupCursor(
	PIB				*ppib,
	FUCB   			*pfucb,
	JET_TABLEID		*ptableid,
	JET_GRBIT		grbit )
	{
	ERR				err;
	FUCB   			**ppfucbDup	= (FUCB **)ptableid;
	FUCB   			*pfucbDup = pfucbNil;
#ifdef	DISPATCHING
	JET_TABLEID		tableid;
#endif	/* DISPATCHING */

	if ( FFUCBIndex( pfucb ) )
		{
		err = ErrIsamDupCursor( ppib, pfucb, ppfucbDup, grbit );
		return err;
		}

#ifdef	DISPATCHING
	CallR( ErrAllocateTableid(&tableid, (JET_VTID) 0, &vtfndefTTSortIns) );
#endif	/* DISPATCHING */

	Call( ErrFUCBOpen( ppib, dbidTemp, &pfucbDup ) );
  	FCBLink( pfucbDup, &(pfucb->u.pscb->fcb) );

	pfucbDup->wFlags = pfucb->wFlags;

	pfucbDup->pbKey = NULL;
	KSReset( pfucbDup );

	/*	initialize working buffer to unallocated
	/**/
	pfucbDup->pbfWorkBuf = pbfNil;
	pfucbDup->lineWorkBuf.pb = NULL;
	Assert( !FFUCBUpdateSeparateLV( pfucbDup ) );
	FUCBResetCbstat( pfucbDup );

	/* move currency to the first record and ignore error if no records
	/**/
	err = ErrIsamSortMove( ppib, pfucbDup, (ULONG)JET_MoveFirst, 0 );
	if ( err < 0  )
		{
		if ( err != JET_errNoCurrentRecord )
			goto HandleError;
		err = JET_errSuccess;
		}

#ifdef	DISPATCHING
	/* Inform dispatcher of correct JET_VTID */
	CallS( ErrSetVtidTableid( (JET_SESID) ppib, tableid, (JET_VTID) pfucbDup ) );
	pfucbDup->fVtid = fTrue;
	*(JET_TABLEID *) ppfucbDup = tableid;
#else	/* !DISPATCHING */
	*ppfucbDup = pfucbDup;
#endif	/* !DISPATCHING */

	return JET_errSuccess;

HandleError:
	if ( pfucbDup != pfucbNil )
		FUCBClose( pfucbDup );
#ifdef	DISPATCHING
	ReleaseTableid(tableid);
#endif	/* DISPATCHING */
	return err;
	}


ERR VTAPI ErrIsamSortClose( PIB *ppib, FUCB *pfucb )
	{
	ERR		err = JET_errSuccess;

#ifdef	DISPATCHING
	JET_TABLEID		tableid;
#endif	/* DISPATCHING */

	CheckPIB( ppib );
	Assert( pfucb->fVtid );

	/*	reset fVtid for ErrFILECloseTable
	/**/
	pfucb->fVtid = fFalse;

	if ( FFUCBIndex( pfucb ) )
		{
		CheckTable( ppib, pfucb );
		CallS( ErrFILECloseTable( ppib, pfucb ) );
		}
	else
		{
		CheckSort( ppib, pfucb );
		Assert( FFUCBSort( pfucb ) );
		
		/*	release key buffer
		/**/
		if ( pfucb->pbKey != NULL )
			{
			LFree( pfucb->pbKey );
			pfucb->pbKey = NULL;
			}

		/*	release working buffer
		/**/
		if ( pfucb->pbfWorkBuf != pbfNil )
			{
			BFSFree( pfucb->pbfWorkBuf );
			pfucb->pbfWorkBuf = pbfNil;
			pfucb->lineWorkBuf.pb = NULL;
			}

		err = ErrSORTClose( pfucb );
		}

#ifdef	DISPATCHING
	tableid = TableidFromVtid( (JET_VTID) pfucb, &vtfndefTTSortRet );
	if ( tableid == JET_tableidNil )
		{
		tableid = TableidFromVtid( (JET_VTID) pfucb, &vtfndefTTSortIns );
		if ( tableid == JET_tableidNil )
			tableid = TableidFromVtid( (JET_VTID) pfucb, &vtfndefTTBase );
		}
	Assert(tableid != JET_tableidNil);
	ReleaseTableid( tableid );
	pfucb->fVtid = fFalse;
#endif	/* DISPATCHING */
	Assert( pfucb->fVtid == fFalse );
	return err;
	}


ERR VTAPI ErrIsamSortGetTableInfo(
	PIB 				*ppib,
	FUCB				*pfucb,
	void				*pv,
	unsigned long	cbOutMax,
	unsigned long	lInfoLevel )
	{
	if ( lInfoLevel != JET_TblInfo )
		return JET_errInvalidOperation;

	/* check buffer size
	/**/
	if ( cbOutMax < sizeof(JET_OBJECTINFO) )
		{
		return JET_errInvalidParameter;
		}

	memset( (BYTE *)pv, 0x00, (SHORT)cbOutMax );
	( (JET_OBJECTINFO *)pv )->cbStruct = sizeof(JET_OBJECTINFO);
	( (JET_OBJECTINFO *)pv )->objtyp   = JET_objtypTable;
	( (JET_OBJECTINFO *)pv )->cRecord  = pfucb->u.pscb->wRecords;

	return JET_errSuccess;
	}


ERR VTAPI ErrIsamCopyBookmarks(
	PIB				*ppib,
	FUCB				*pfucbSrc,
	FUCB				*pfucbDest,
	JET_COLUMNID	columnidDest,
	unsigned long	crecMax,
	unsigned long	*pcrecCopied,
	unsigned long	*precidLast )
	{
#ifdef QUERY
	ERR			err = JET_errSuccess;
	LONG			csridMax = (LONG)crecMax;
	LONG			dsrid = 0;
	SRID			sridLast = 0xffffffff;
	JET_GRBIT	grbit;
	SRID			srid;
	LONG			cbSrid;

	/*	pfucbSrc is base table and pfucbDest is sort.
	/**/
	CheckTable( ppib, pfucbSrc );
	CheckSort( ppib, pfucbDest );

	/*	convert csridMax to positive.
	/**/
	if ( csridMax < 0 )
		{
		grbit = (ULONG) JET_MovePrevious;
		csridMax = ( csridMax == JET_MoveFirst ) ? JET_MoveLast : -csridMax;
		}
	else
		{
		grbit = JET_MoveNext;
		}

	do
		{
		dsrid++;

		/*	get bookmark from source table record
		/**/
		Call( ErrIsamGetBookmark( ppib, pfucbSrc, (CHAR *)&srid, sizeof(SRID), &cbSrid ) );
		Assert( cbSrid == sizeof(SRID) );
		
		/*	insert bookmark into destination table
		/**/
		Call( ErrIsamPrepareUpdate( ppib, pfucbDest, JET_prepInsert ) );
		Call( ErrIsamSetColumn( ppib, pfucbDest, columnidDest, (CHAR *)&srid, sizeof(SRID), 0, NULL ) );
		Call( ErrIsamSortUpdate( ppib, pfucbDest, NULL, 0, 0L ) );

		/*	move to next source table record
		/**/
		err = ErrIsamMove( ppib, pfucbSrc, grbit, 0 );
		}
	while ( --csridMax && err >= 0 );

	if ( pcrecCopied )
		*pcrecCopied = dsrid;
	if ( precidLast )
		*precidLast = sridLast;

HandleError:
	return err;
#else
	return JET_wrnNyi;
#endif
	}


#ifdef QUERY
LOCAL ERR ErrNotIsamBaseTable( PIB *ppib, JET_TABLEID tableidSrc, BOOL *pfBase )
	{
	ERR		err;
	VTFNDEF 	*pvtfndef;

	if ( ( err = ErrGetPvtfndefTableid( SesidOfPib( ppib ), tableidSrc, &pvtfndef ) ) >= 0 )
		*pfBase = ((pvtfndef == ( VTFNDEF * )( &vtfndefIsam ) ) ? fFalse : fTrue );
	
	return err;
	}
#endif


//	UNDONE:	performance tune
/*	tableidSrc may be system or installable ISAM base table
/*	tableidDest may be system base table or sort
/**/
ERR ISAMAPI ErrIsamCopyRecords(
	JET_VSESID		vsesid,
	JET_TABLEID		tableidSrc,
	JET_TABLEID		tableidDest,
	CPCOL				*rgcpcol,
	unsigned long	ccpcolMax,
	long				crecMax,
	unsigned long 	*pcsridCopied,
	unsigned long	*precidLast )
	{
#ifdef QUERY
	ERR			err;
	PIB			*ppib = (PIB *)vsesid;
	FUCB			*pfucbSrc;
	FUCB			*pfucbDest;
	BOOL			fIsam;
	LONG			csridMax = crecMax;
	LONG			dsrid = 0;
	SRID			sridLast = 0xffffffff;
	JET_GRBIT	grbit;
	CPCOL			*pcpcol;
	CPCOL			*pcpcolMax;
	BYTE			rgb[JET_cbColumnMost];
	LONG			cb;
#ifndef ANSIAPI
	BYTE			rgbXlt[JET_cbColumnMost];
	FDB			*pfdb;
	JET_COLTYP	coltyp;
#endif /* ANSIAPI */

	CallR( ErrGetVtidTableid( SesidOfPib( ppib ), tableidSrc, (JET_VTID *) &pfucbSrc ) );
	CallR( ErrGetVtidTableid( SesidOfPib( ppib ), tableidDest, (JET_VTID *) &pfucbDest ) );
	/*	determine if tableidSrc is system ISAM
	/**/
	CallR( ErrNotIsamBaseTable( ppib, tableidSrc, &fIsam ) );
	/* ensure that destination table is updatable */
	/**/
	CallR( FUCBCheckUpdatable( pfucbDest ) );

	if ( fIsam && ccpcolMax == 1 && rgcpcol[0].columnidDest == columnidBookmark )
		{
		err = ErrIsamCopyBookmarks( ppib,
			pfucbSrc,
			pfucbDest,
			rgcpcol[0].columnidDest,
			crecMax,
			pcsridCopied,
			precidLast );
		return err;
		}

	/*	set csridMax and grbit
	/**/
	if ( csridMax < 0 )
		{
		grbit = (ULONG) JET_MovePrevious;
		csridMax = ( csridMax == JET_MoveFirst ) ? JET_MoveLast : -csridMax;
		}
	else
		{
		grbit = JET_MoveNext;
		}

	/*	implement copy records at dispatch level.  Performance improvement
	/*	may be made later by reimplementing at a lower level.
	/**/
	pcpcolMax = rgcpcol + ccpcolMax;
	forever
		{
		dsrid++;

		Call( ErrDispPrepareUpdate( vsesid, tableidDest, JET_prepInsert ) );
		for ( pcpcol = rgcpcol; pcpcol < pcpcolMax; pcpcol++ )
			{
			/*	retreive column or bookmark from source table
			/**/
			if ( pcpcol->columnidSrc == columnidBookmark )
				{
				Call( ErrDispGetBookmark( vsesid, tableidSrc, rgb, sizeof(rgb), &cb ) );
				}
			else
				{
				Call( ErrDispRetrieveColumn( vsesid, tableidSrc, pcpcol->columnidSrc, rgb, sizeof(rgb), &cb, 0, NULL ) );

#ifndef ANSIAPI
				/*	if column is text then process for ANSI
				/*	get column type.  The following code must work independant
				/*	of whether the dest cursor is on a base table or sort.
				/**/
				pfdb = pfucbDest->u.pfcb->pfdb;
				if ( FFixedFid( pcpcol->columnidSrc ) )
					{
					coltyp = pfdb->pfieldFixed[pcpcol->columnidSrc - fidFixedLeast].coltyp;
					}
				else if ( FVarFid( pcpcol->columnidSrc ) )
					{
					coltyp = pfdb->pfieldVar[pcpcol->columnidSrc - fidVarLeast].coltyp;
					}
				else
					{
					Assert( FTaggedFid( pcpcol->columnidSrc ) );
					coltyp = pfdb->pfieldTagged[pcpcol->columnidSrc - fidTaggedLeast].coltyp;
					}

				/* Translate text back from OEM to ANSI character set.
				/**/
				if ( coltyp == JET_coltypText )
					{
					XlatOemToAnsi( rgb, rgbXlt, cb );
					/* Make sure QJET never creates fixed length text.
					/*	If this assert fails, need to add code to fill
					/*	out to fixed text length with spaces.
					/**/
					/*	copy conversion back to rgb for set column
					/**/
					memcpy( rgb, rgbXlt, cb );
					Assert( !FFixedFid( pcpcol->columnidDest ) );
					}
#endif	/* !ANSIAPI */
				}

			/*	set column in dest table
			/**/
			Call( ErrDispSetColumn( vsesid, tableidDest, pcpcol->columnidDest, rgb, cb, 0, NULL ) );
			}

		/*	insert record
		/**/
		Call( ErrDispUpdate( vsesid, tableidDest, NULL, 0, NULL ) );

		/*	break if copied required records or if no next/prev record
		/**/
		if ( !--csridMax )
			break;
		Call( ErrDispMove( vsesid, tableidSrc, grbit, 0 ) );
		}

	if ( pcsridCopied )
		*pcsridCopied = dsrid;
	if ( precidLast )
		*precidLast = sridLast;
		
HandleError:
	return err;
#else
	return JET_wrnNyi;
#endif
	}


#ifdef QUERY

unsigned long FAR PASCAL sdCreateTempStrC(char FAR *lpstr, int cch);
char * FAR PASCAL pDerefStrC(int itib, unsigned long sd);
int FAR PASCAL cbGetStrLenC(int itib, unsigned long sd);

unsigned long FAR PASCAL sdCreateTempStr( char FAR *lpstr, int cch )
	{
	return( 0xffffffff );     /* Return "out of memory" */
	}


char * FAR PASCAL pDerefStrCb( unsigned long l )
	{
	return NULL;
	}

/*** SetVl() GetVL() ***/

static CODECONST(unsigned char) mpcoltypvlt[] =
	{
	0,			/* JET_coltypNil */
	0x8002,	/* JET_coltypBit				vltI2 */
	0x8002,	/* JET_coltypUnsignedByte	vltI2 */
	0x8002,	/* JET_coltypShort			vltI2 */
	0x8003,	/* JET_coltypLong				vltI4 */
	0x8006,	/* JET_coltypCurrency		vltCY */
	0x8004,	/* JET_coltypIEEESingle		vltR4 */
	0x8005,	/* JET_coltypIEEEDouble		vltR8 */
	0x8007,	/* JET_coltypDateTime		vltDT */
	0x8008,	/* JET_coltypBinary			vltSd */
	0x8008,	/* JET_coltypText				vltSd */
	0x8008,	/* JET_coltypLongBinary		vltSd */
	0x8008,	/* JET_coltypLongText		vltSd */
	};

extern unsigned char __far mpcoltypcb[];

ERR VTAPI ErrIsamGetVL( PIB *ppib, JET_TABLEID tableid, JET_COLUMNID columnid, VL __far *pvl )
	{
	ERR			err = JET_errSuccess;
	FID			fid = (FID)columnid;
	FUCB			*pfucb;
	FDB			*pfdb;
	JET_COLTYP	coltyp;
	LINE			line;

	CallS( ErrGetVtidTableid( SesidOfPib( ppib ), tableid, (JET_VTID *)&pfucb ) );

	/*	get pointer to column in record
	/**/
	Call( ErrRECIRetrieve( pfucb, &fid, 1, &line, 0 ) );

	/*	get column type
	/**/
	pfdb = (FDB *)pfucb->u.pfcb->pfdb;
	if ( FFixedFid( fid ) )
		{
		coltyp = pfdb->pfieldFixed[fid - fidFixedLeast].coltyp;
		}
	else if ( FVarFid( fid ) )
		{
		coltyp = pfdb->pfieldVar[fid - fidVarLeast].coltyp;
		}
	else
		{
		Assert( FTaggedFid( fid ) );
		coltyp = pfdb->pfieldTagged[fid - fidTaggedLeast].coltyp;
		}

	if ( coltyp == JET_coltypBit )
		{
		pvl->vlt = 2; /* vltI2 */
		pvl->i2 = line.pb[0] ? -1 : 0;
		return JET_errSuccess;
		}

	if ( err == JET_wrnColumnNull )
		{
		pvl->vlt = 1; /* vltNull */
		}
	else
		{
		pvl->vlt = (short)mpcoltypvlt[coltyp];
		if ( coltyp >= JET_coltypBinary )
			{
			Assert( coltyp == JET_coltypBinary || coltyp == JET_coltypText );

#ifndef ANSIAPI
			if ( coltyp == JET_coltypText )
				{
				WORD cb;
				pvl->sd = sdCreateTempStr( NULL, line.cb );
				XlatAnsiToOem( line.pb, pDerefStrCb( pvl->sd ), line.cb );
				}
			else
#endif	/* !ANSIAPI */
				pvl->sd = sdCreateTempStr( line.pb, line.cb );

			if ( HIWORD( pvl->sd ) == -1 )
    			err = JET_errOutOfMemory;
			}
		else
			{
			Assert( line.cb == mpcoltypcb[coltyp] );
			/* handles UnsigedByte */
			pvl->i2 = 0;
			memcpy( pvl->rgb, line.pb, line.cb );
			}
		}

HandleError:
	return err;
	}


/* NOTE: only used for UPDATE not INSERT! */
ERR VTAPI ErrIsamSetVL( PIB *ppib, JET_TABLEID tableid, JET_COLUMNID columnid, VL __far *pvl )
	{
	ERR	     	err = JET_errSuccess;
	ERR			wrn = JET_errSuccess;
	FID			fid = (FID)columnid;
	FUCB	 	*pfucb;
	FDB			*pfdb;
	WORD	 	cb;
	JET_COLTYP	coltyp;
	BYTE	 	u;
	BYTE	 	*pb;
	BOOL	 	fPrepared;

#ifndef ANSIAPI
	unsigned char  rgbValue[JET_cbColumnMost];
#endif /* !ANSIAPI */

	CallS( ErrGetVtidTableid( SesidOfPib( ppib ), tableid, (JET_VTID *)&pfucb ) );

	/*	is copy buffer prepared.
	/**/
	fPrepared = FFUCBSetPrepared( pfucb );

	/*	get column type
	/**/
	pfdb = (FDB *)pfucb->u.pfcb->pfdb;
	if ( FFixedFid( fid ) )
		{
		coltyp = pfdb->pfieldFixed[fid - fidFixedLeast].coltyp;
		}
	else if ( FVarFid( fid ) )
		{
		coltyp = pfdb->pfieldVar[fid - fidVarLeast].coltyp;
		}
	else
		{
		Assert( FTaggedFid( fid ) );
		coltyp = pfdb->pfieldTagged[fid - fidTaggedLeast].coltyp;
		}

	/*	get data
	/**/
	if ( pvl->vlt == 1 /* vltNull */ )
		{
		pb = pbNil;
		cb = 0;
		}
	else if ( ( pvl->vlt & 0x7f ) == 8 /* vltSd */ )
		{
		int itib = UtilGetItibOfSesid(SesidOfPib(ppib));
		cb = cbGetStrLenC(itib, pvl->sd );
		pb = pDerefStrC(itib, pvl->sd );
		}
	else if ( coltyp < JET_coltypShort )
		{
		Assert( coltyp == JET_coltypBit || coltyp == JET_coltypUnsignedByte );
		if ( coltyp == JET_coltypBit )
			{
			u = (BYTE)( ( pvl->i2 != 0 ) ? 0xff : 0 );
			}
		else
			{
			u = (BYTE) pvl->i2;
			Assert( (unsigned)pvl->i2 <= 0xffU );
			}
		pb = &u;
		cb = 1;
		}
	else
		{
		pb = pvl->rgb;
		cb = mpcoltypcb[coltyp];
		}

	/*	prepare copy buffer if not prepared
	/**/
	if ( !fPrepared )
		{
		Call( ErrIsamPrepareUpdate( pfucb->ppib, pfucb, JET_prepReplaceNoLock ) );
		wrn = -( JET_errUpdateNotPrepared );
		}

	/*	set column
	/**/
	if ( coltyp == JET_coltypBit )
		{
		Call( ErrIsamSetColumn( pfucb->ppib, pfucb, columnid, pb, cb, 0, NULL ) );
		}
	else
		{
#ifndef ANSIAPI
		/* Translate text from the OEM to the ANSI character set.
	  	/**/
		if ( coltyp == JET_coltypText )
			{
			XlatOemToAnsi( pb, LpDefIb( rgbValue ), cb );
			pb = rgbValue;
			/* make sure qjet never creates fixed length text.
			/* If this assert fails, need to add
			/* code to fill out to the fixed text length with spaces.
			/**/
			Assert( ib >= 0 );
			}
#endif	/* !ANSIAPI */
		Call( ErrIsamSetColumn( pfucb->ppib, pfucb, columnid, pb, cb, 0, NULL ) );
		}

	/*	return warning
	/**/
	err = wrn;
HandleError:
	return err;
	}


/*	call given function for each bookmark from the current record until
/*	the preset index range is reached.  This function is not dispatched.
/**/
ERR VTAPI ErrIsamCollectRecids(
	PIB				*ppib,
	JET_TABLEID		tableid,
	FNBMPSET 		*pfnSet,
	void   			*pbmpSet,
	void   			*pbmpTest,
	CHAR   			*szFind,
	ULONG  			cbFind,
	JET_COLUMNID	columnidFind,
	ULONG  			sort )
	{
	ERR				err;
	FUCB   			*pfucb;
	SRID   			srid;
	LONG   			cbT;

	/*	derefence tableid to get pfucb
	/**/
	CallR( ErrGetVtidTableid( SesidOfPib( ppib ), tableid, (JET_VTID *)&pfucb ) );

	CheckPIB( pfucb->ppib );
	CheckTable( pfucb->ppib, pfucb );

	Call( ErrIsamMove( pfucb->ppib, pfucb, 0, 0 ) );
	do
		{
		Call( ErrIsamGetBookmark( pfucb->ppib, pfucb, (BYTE *)&srid, sizeof(SRID), &cbT ) );
		(*pfnSet)( pbmpSet, pbmpTest, srid );
		err = ErrIsamMove( pfucb->ppib, pfucb, JET_MoveNext, 0 );
		}
	while ( err >= 0 );

	if ( err == JET_errNoCurrentRecord )
		err = JET_errSuccess;
HandleError:
	return err;
	}


typedef short PASCAL FNFBMPTEST( void *pbmpTest, unsigned long ul );


ERR VTAPI ErrIsamScanBinary(
	PIB					*ppib,
	JET_TABLEID			tableid,
	JET_COLUMNID		columnid, 				/* column to search */
	BYTE   				*pbData,	 				/* buffer of values to search for */
	ULONG  				cbData,					/* size of buffer */
	struct BMP			*pbmp,					/* bitmap of bookmarks */
	FNFBMPTEST			*pfnTest,				/* and test function */
	LONG   				csridSearchMax, 		/* max records to search */
	LONG   		 		*pcsridMoveActual, 	/* records searched before match */
	BYTE   	 			*pbBookmarkLimit,		/* record to stop search on */
	BOOL   				*pfHitLimit				/* returns true if limit was hit */
	)													/*  (only if JET_errRecordNotFound) */
	{
	ERR			err;
	FUCB   		*pfucb;
	FID			fid = (FID)columnid;
	LINE   		line;
	LONG   		bitMove;
	LONG   		csridMax = csridSearchMax;
	LONG   		csrid = 0;
	SRID   		sridLimit = pbBookmarkLimit ? *(SRID *)pbBookmarkLimit : sridNull;
	BOOL   		fFound = fFalse;
	BYTE   		*pbValue;

	/*	check input parameters
	/**/
#ifdef DEBUG
	Assert( pbData || pbmp );
	if ( pbData )
		Assert( cbData );
	else
		Assert( pfnTest );
#endif

	/*	derefernce tableid to system ISAM base table
	/**/
	CallR( ErrGetVtidTableid( SesidOfPib( ppib ), tableid, (JET_VTID *)&pfucb ) );

	/*	convert csridMax to positive
	/**/
	if ( csridMax < 0 )
		{
		bitMove = JET_MovePrevious;
		csridMax = ( csridMax == JET_MoveFirst ) ? JET_MoveLast : -csridMax;
		}
	else
		{
		bitMove = JET_MoveNext;
		}

#define	SridOfFucb( pfucb )	pfucb->pcsr->bm

	forever
		{
		if ( sridLimit == SridOfFucb( pfucb ) )
			break;

		CallR( ErrRECIRetrieve( pfucb, &fid, 1, &line, 0 ) );
		Assert( fid == (FID)columnid );

		if ( pbData )
			{
			for ( pbValue = pbData;
				pbValue < pbData + cbData;
				pbValue += *pbValue + 1 )
				{
				if ( *pbValue == line.cb &&
					( !line.cb || !memcmp( pbValue + 1, line.pb, line.cb ) ) )
					{
					fFound = fTrue;
					break;
					}
				}
			}
		else
			{
			Assert( line.cb == sizeof(ULONG) );
			fFound = (*pfnTest)(pbmp, *(ULONG *)line.pb );
			}

		Assert( csrid < csridMax );
		if ( fFound || ++csrid == csridMax )
			break;

		err = ErrIsamMove( ppib, pfucb, bitMove, 0 );
		if ( err == JET_errNoCurrentRecord )
			break;
		CallR( err );
		}

	*pcsridMoveActual = ( csridSearchMax < 0 ) ? -csrid : csrid;

	if ( fFound )
		return JET_errSuccess;

	*pfHitLimit = sridLimit == SridOfFucb( pfucb );
	if ( *pfHitLimit || csrid == csridMax )
		return JET_errRecordNotFound;
		
	return JET_errNoCurrentRecord;
	}

#endif /* QUERY */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\space.c ===
#include "config.h"

#include <stdlib.h>

#include "daedef.h"
#include "util.h"
#include "fmp.h"
#include "pib.h"
#include "page.h"
#include "ssib.h"
#include "fcb.h"
#include "fucb.h"
#include "stapi.h"
#include "nver.h"
#include "spaceint.h"
#include "spaceapi.h"
#include "dirapi.h"
#include "logapi.h"
#include "recint.h"
#include "bm.h"

#ifdef DEBUG
//#define SPACECHECK
//#define TRACE
#endif

DeclAssertFile;						/* Declare file name for assert macros */

extern CRIT __near critSplit;
extern LINE lineNull;
long	lPageFragment;


LOCAL ERR ErrSPIAddExt( FUCB *pfucb, PGNO pgnoLast, CPG *pcpgSize, const INT fExtent );
LOCAL ERR ErrSPIGetSE( PIB *ppib, FUCB *pfucb, CPG const cpgReq, CPG const cpgMin );
LOCAL ERR ErrSPIWasAlloc( PIB *ppib, DBID dbid, PGNO pgnoFDP, PGNO pgnoFirst, CPG cpgSize );
LOCAL ERR ErrSPIValidFDP( DBID dbid, PGNO pgnoFDP, PIB *ppib );


ERR ErrSPInitFDPWithExt( FUCB *pfucb, PGNO pgnoFDPFrom, PGNO pgnoFirst, INT cpgReqRet, INT cpgReqWish )
	{
	ERR				err;
	LINE	  		line;
	KEY				key;
	SSIB	  		*pssib = &pfucb->ssib;
	THREEBYTES		tbSize;
	THREEBYTES 		tbLast;
	BOOL	  		fPIBLogDisabledSave;

	/* logging aggregate operation
	/**/
	fPIBLogDisabledSave = pfucb->ppib->fLogDisabled;
	pfucb->ppib->fLogDisabled = fTrue;

	/*	set pgno to initialize in current CSR pgno
	/**/
	PcsrCurrent( pfucb )->pgno = pgnoFirst;
	CallJ( ErrNDNewPage( pfucb, pgnoFirst, pgnoFirst, pgtypFDP, fTrue ), DontUnpin );

	BFPin( pfucb->ssib.pbf );

	/*	goto FDP root
	/**/
	DIRGotoPgnoItag( pfucb, pgnoFirst, itagFOP )

	/*	build OwnExt tree with primary extent request size, not
	/*	actual secondary extent size returned from parent FDP.
	/*	Since the actual primary extent size is stored in an entry of
	/*	OwnExt the prefered primary extent size may be stored as requested
	/*	thus allowing future secondary extents which are fractions of
	/*	the prefered primary extent size to be requested as initially
	/*	expected.
	/**/
	/* must store cpgReq, initial request, as primary extent size
	/**/
	ThreeBytesFromL( tbSize, cpgReqWish );
	line.pb = ( BYTE * ) &tbSize;
	line.cb = sizeof( THREEBYTES );

	/*	add OWNEXT node as itagOWNEXT
	/**/
	Call( ErrDIRInsert( pfucb, &line, pkeyOwnExt, fDIRNoVersion | fDIRSpace | fDIRBackToFather ) );

	/* build AvailExt tree
	/**/
	ThreeBytesFromL( tbSize, pgnoFDPFrom );
	Assert( line.pb == ( BYTE * ) &tbSize );
	Assert( line.cb == sizeof( THREEBYTES ) );
	Call( ErrDIRInsert( pfucb, &line, pkeyAvailExt, fDIRNoVersion | fDIRSpace | fDIRBackToFather ) );

	/* build Long tree
	/**/
	Call( ErrDIRInsert( pfucb, &lineNull, pkeyLong, fDIRNoVersion | fDIRSpace | fDIRBackToFather ) );

	/*	goto OWNEXT node
	/**/
	DIRGotoPgnoItag( pfucb, pgnoFirst, itagOWNEXT );

	/* add ownext entry
	/**/
	TbKeyFromPgno( tbLast, pgnoFirst + cpgReqRet - 1 );
	key.cb = sizeof( THREEBYTES );
	key.pb = ( BYTE * ) &tbLast;
	ThreeBytesFromL( tbSize, cpgReqRet );
	Assert( line.pb == ( BYTE * ) &tbSize );
	Assert( line.cb == sizeof( THREEBYTES ) );
	Call( ErrDIRInsert( pfucb, &line, &key, fDIRNoVersion | fDIRSpace | fDIRBackToFather ) );

	/*	Add availext entry if extent less FDP page is one or more pages.
	/*	Decrement the page count to show that the first page was used for
	/*	the FDP.  *ppgnoFirst does not need to be incremented as the
	/*	AvailExt entry is keyed with pgnoLast which remains unchanged and
	/*	the page number of the FDP is the desired return in *ppgnoFirst.
	/**/
	if ( --cpgReqRet > 0 )
		{
		/*	goto AVAILEXT node.
		/**/
		DIRGotoPgnoItag( pfucb, pgnoFirst, itagAVAILEXT );

		//tbLast should contain pgnoLast
		Assert( key.cb == sizeof( THREEBYTES ) );
		Assert( key.pb == ( BYTE * ) &tbLast );
		ThreeBytesFromL( tbSize, cpgReqRet );
		Assert( line.pb == ( BYTE * ) &tbSize );
		Assert( line.cb == sizeof( THREEBYTES ) );
		Call( ErrDIRInsert( pfucb, &line, &key, fDIRNoVersion | fDIRSpace | fDIRBackToFather ) );
		}

	if ( pfucb->dbid != dbidTemp );
		{
		/*	the FDP page is initialized
		/**/
		pfucb->ppib->fLogDisabled = fPIBLogDisabledSave;
		Call( ErrLGInitFDPPage(
			pfucb,
			pgnoFDPFrom,
			PnOfDbidPgno( pfucb->dbid, pgnoFirst ),
			cpgReqRet,
			cpgReqWish ) );
		}

	err = JET_errSuccess;

HandleError:
	BFUnpin( pfucb->ssib.pbf );
DontUnpin:
	pfucb->ppib->fLogDisabled = fPIBLogDisabledSave;
	return err;
	}


//+api--------------------------------------------------------------------------
//	ErrSPGetExt
//	========================================================================
//	ERR ErrSPGetExt( ppib, dbid, pgnoFDP, pcpgReq, cpgMin, ppgnoFirst, fNewFDP )
//		PIB	*ppib;				 // IN
//		DBID	dbid;					 // IN
//		PGNO	pgnoFDP;				 // IN
//		LONG	*pcpgReq;			 // INOUT
//		CPG	cpgMin;				 // IN
//		PGNO	*ppgnoFirst;		 // OUT
//		BOOL	fNewFDP;				 // IN
//
//	Allocates an extent of at least cpgMin, and as much as cpgReq + lPageFragment.
//	The allocated extent is removed from the AvailExt tree.	 If the minimum
//	extent size cannot be allocated from the AvailExt tree at the time of the
//	call, secondary extents are allocated from the parent FDP, or OS/2 for
//	the device level FDP, until an extent of at least cpgMin can be allocated.
//	If fNewFDP is set, the first page of the allocated extent, pgnoFirst, is
//	setup as an FDP, with built AvailExt and OwnExt trees.	The allocated extent
//	is added to the OwnExt tree and the available portion of the extent is
//	added to AvailExt.
//
// PARAMETERS  ppib		   process identification block
//				   pgnoFDP	   page number of FDP to allocate from
//				   pcpgReq	   requested extent size
//				   cpgMin	   minimum acceptable extent size
//				   ppgnoFirst  first page of allocated extent
//				   fNewFDP		Various flags:
//						VALUE				  MEANING
//					  ========================================
//					  fTrue	   Setup first page of extent as FDP.
//					  fFalse   Do not setup first page of extent as FDP.
//
// RETURNS
//		JET_errSuccess, or error code from failing routine, or one
//		of the following "local" errors:
//			-JET_errDiskFull	no space in FDP or parent to satisfy
//									minimum extent size
//		  +errSPFewer			allocated extent smaller than requested
//		  +errSPMore			allocated extent larger than requested
//
//	FAILS ON
//		given extent size less than 0
//		given minimum size greater than requested size
//
// SIDE EFFECTS
// COMMENTS
//-

ERR ErrSPIGetExt(
	FUCB		*pfucbTable,
	PGNO		pgnoFDP,
	CPG		*pcpgReq,
	CPG		cpgMin,
	PGNO		*ppgnoFirst,
	BOOL		fNewFDP )
	{
	ERR 		err;
	CPG 		cpgReq = *pcpgReq;
	FUCB 		*pfucb;
	DIB 		dib;
	THREEBYTES	tbSize;
	LINE		line;
	CPG		cpgAvailExt;
	PGNO		pgnoAELast;

	AssertCriticalSection( critSplit );

	/*	check parameters.  If setting up new FDP, increment requested number of
	/*	pages to account for consumption of first page to make FDP.
	/**/
	Assert( *pcpgReq > 0 || ( fNewFDP && *pcpgReq == 0 ) );
	Assert( *pcpgReq >= cpgMin );
#ifdef SPACECHECK
	Assert( !( ErrSPIValidFDP( pfucbTable->dbid, pgnoFDP, pfucbTable->ppib ) < 0 ) );
#endif

	/*	if a new FDP is requested, increment the request count so a page
	/*	may be provided for the new FDP.  The available page request remains
	/*	the same, as the first page will be removed.  A comparison will be
	/*	made of the available page request against the available pages
	/*	received to generate the return code.
	/**/
	if ( fNewFDP )
		{
		++*pcpgReq;
		}

	/* get temporary FUCB, setup and use to search AvailExt for page
	/**/
	CallR( ErrDIROpen( pfucbTable->ppib,
		PgnoFDPOfPfucb( pfucbTable ) == pgnoFDP ?
			pfucbTable->u.pfcb :
			PfcbFCBGet( pfucbTable->dbid, pgnoFDP ),
			pfucbTable->dbid, &pfucb ) );
	Assert( PgnoFDPOfPfucb( pfucb ) == pgnoFDP );
	FUCBSetIndex( pfucb );

	/*	For secondary extent allocation, only the normal DIR operations
	/* are logged. For allocating a new FDP, a special CreateFDP
	/* record is logged instead (since the new FDP page needs to be
	/* initialized as part of Redo).	/**/

	/*	move to AVAILEXT.
	/**/
	DIRGotoAVAILEXT( pfucb, PgnoFDPOfPfucb( pfucb ) );

	/*	begin search for first extent with size greater than request, allocate
	/*	secondary extent recursively until satisfactory extent found
	/**/
	dib.pos = posFirst;
	dib.fFlags = fDIRNull;
	if ( ( err = ErrDIRDown( pfucb, &dib ) ) < 0 )
		{
		Assert( err != JET_errNoCurrentRecord );
		if ( err == JET_errRecordNotFound )
			{
			goto GetFromSecondaryExtent;
			}
		#ifdef DEBUG
			FPrintF2( "ErrSPGetExt could not down into AvailExt.\n" );
		#endif
		goto HandleError;
		}

	/*	loop through extents looking for one large enough for allocation
	/**/
	Assert( dib.fFlags == fDIRNull );
	do
		{
		Assert( pfucb->lineData.cb == sizeof( THREEBYTES ) );
		LFromThreeBytes( cpgAvailExt, *pfucb->lineData.pb );
		Assert( cpgAvailExt > 0 );
		if ( cpgAvailExt >= cpgMin )
			{
			goto AllocateCurrent;
			}
		err = ErrDIRNext( pfucb, &dib );
		}
	while ( err >= 0 );

	if ( err != JET_errNoCurrentRecord )
		{
		#ifdef DEBUG
			FPrintF2( "ErrSPGetExt could not scan AvailExt.\n" );
		#endif
		Assert( err < 0 );
		goto HandleError;
		}

	DIRUp( pfucb, 1 );

GetFromSecondaryExtent:
	/*	get secondary extents until request can be satisfied.  Setup
	/*	FUCB work area prior to adding extent to OwnExt.
	/**/

	/* do not loop here if the db is being extended, instead, loop
	 * on SPGetExt. See SPGetExt function.
	 */
	Call( ErrSPIGetSE( pfucbTable->ppib, pfucb, *pcpgReq, cpgMin ) );
	Assert( pfucb->lineData.cb == sizeof( THREEBYTES ) );
	LFromThreeBytes( cpgAvailExt, *pfucb->lineData.pb );
	Assert( cpgAvailExt > 0 );

AllocateCurrent:
	Assert( pfucb->keyNode.cb == sizeof( THREEBYTES ) );
	PgnoFromTbKey( pgnoAELast, *pfucb->keyNode.pb );
	*ppgnoFirst = pgnoAELast - cpgAvailExt + 1;
	if ( cpgAvailExt > *pcpgReq && ( *pcpgReq < lPageFragment || cpgAvailExt > *pcpgReq + lPageFragment ) )
		{
		/* *pcpgReq is already set to the return value
		/**/
		Assert( cpgAvailExt - *pcpgReq > 0 );
		ThreeBytesFromL( tbSize, cpgAvailExt - *pcpgReq );
		line.cb = sizeof( THREEBYTES );
		line.pb = ( BYTE * ) &tbSize;
		Call( ErrDIRReplace( pfucb, &line, fDIRNoVersion ) );
		err = JET_errSuccess;
		}
	else
		{
		*pcpgReq = cpgAvailExt;
		Call( ErrDIRDelete( pfucb, fDIRNoVersion ) );
		}

	/*	if extent is to be setup as a new FDP, setup the first page of the extent
	/*	as an FDP page and build OwnExt and AvailExt trees.	 Add extent to OwnExt,
	/*	add extent less first page to AvailExt.
	/**/
	if ( fNewFDP )
		{
		VEREXT	verext;

		Assert( pgnoFDP != *ppgnoFirst );
		verext.pgnoFDP = pgnoFDP;
		verext.pgnoChildFDP = *ppgnoFirst;
		verext.pgnoFirst = *ppgnoFirst;
		verext.cpgSize = *pcpgReq;

		DIRUp( pfucb, 1 );
		Call( ErrSPInitFDPWithExt( pfucb, pgnoFDP, *ppgnoFirst, *pcpgReq, cpgReq ) );
		/* decremented since one of it is FDP page
		/**/
		(*pcpgReq)--;
		Assert( pfucbTable->dbid == dbidTemp || pfucbTable->ppib->level > 0 );
		if ( pfucbTable->ppib->level > 0 && pgnoFDP != pgnoSystemRoot )
			{
			Call( ErrVERFlag( pfucb, operAllocExt, &verext, sizeof(verext) ) );
			}
		}

	/* assign error
	/**/
	err = JET_errSuccess;
//	if ( *pcpgReq > cpgReq )
//		err = errSPMore;
//	if ( *pcpgReq < cpgReq )
//		err = errSPFewer;

#ifdef TRACE
	if ( fNewFDP )
		{
		INT cpg = 0;
		for ( ; cpg < *pcpgReq + 1; cpg++ )
			FPrintF2( "get space 1 at %lu from FDP %d.%lu\n", *ppgnoFirst + cpg, pfucbTable->dbid, pgnoFDP );
//		FPrintF2( "get space %lu at %lu from FDP %d.%lu\n", *pcpgReq + 1, *ppgnoFirst, pfucbTable->dbid, pgnoFDP );
		}
	else
		{
		INT cpg = 0;
		for ( ; cpg < *pcpgReq; cpg++ )
			FPrintF2( "get space 1 at %lu from %d.%lu \n", *ppgnoFirst + cpg, pfucbTable->dbid, pgnoFDP );
//		FPrintF2( "get space %lu at %lu from %d.%lu\n", *pcpgReq, *ppgnoFirst, pfucbTable->dbid, pgnoFDP );
		}
#endif

HandleError:
	DIRClose( pfucb );
	return err;
	}

ERR ErrSPGetExt(
	FUCB	*pfucbTable,
	PGNO	pgnoFDP,
	CPG		*pcpgReq,
	CPG		cpgMin,
	PGNO	*ppgnoFirst,
	BOOL	fNewFDP )
	{
	ERR 	err;

	LgLeaveCriticalSection( critJet );
	EnterNestableCriticalSection( critSplit );
	LgEnterCriticalSection(critJet);

	/* try to get Ext. If the database file is being extended,
	/* try again until it is done.
	/**/
	while ( ( err = ErrSPIGetExt( pfucbTable,
		pgnoFDP,
		pcpgReq,
		cpgMin,
		ppgnoFirst,
		fNewFDP ) ) == errSPConflict )
		{
		BFSleep( cmsecWaitGeneric );
		}

	LeaveNestableCriticalSection( critSplit );

	return err;
	}


//+api--------------------------------------------------------------------------
//	ErrSPGetPage
//	========================================================================
//	ERR ErrSPGetPage( FUCB *pfucb, PGNO *ppgnoLast, BOOL fContig )
//
//	Allocates page from AvailExt.  If AvailExt is empty, a secondary extent is
//	allocated from the parent FDP to satisfy the page request.  The caller
//	may set the fContig flag to allocate a page following one that has
//	already been allocated.	If the page following the page number given cannot
//	be allocated, the first available page is allocated.
//
//	PARAMETERS	
//		pfucb  		FUCB providing FDP page number and process identifier block
//		ppgnoLast   may contain page number of last allocated page on
//		   			input, on output contains the page number of the allocated page
//		fContig		Various flags:
//		 			VALUE				  MEANING
//			 		========================================
//			 		fTrue		allocate the page following pgnoLast, or if
//			 			   		not available, allocate any page
//			 		fFalse	allocate any available page
//
//	RETURNS		JET_errSuccess, or error code from failing routine, or one
//		   		of the following "local" errors:
// 		-JET_errDiskFull		no space FDP and secondary extent could
// 					   			not be allocated
// 		+errSPNotContig			page allocated does not follow pgnoLast
// 		-errSPSecExtEmpty  		secondary extent in FUCB work area has been
// 	 				   			fully allocated during add of secondary extent to OwnExt
// 	 				   			and AvailExt trees, and page request cannot be satisfied
//								as infinite recursion may result from normal allocation
//
//	FAILS ON	NULL last page pointer
//		invalid FDP page
//		allocating contiguous page to unowned last page
//		allocating contiguous page to unallocated last page
//
//-
ERR ErrSPGetPage( FUCB *pfucb, PGNO *ppgnoLast, BOOL fContig )
	{
	ERR			err;
	/* AvailExt page search
	/**/
	FUCB 		*pfucbT;
	DIB			dib;
	KEY			key;
	LINE		line;
	CPG			cpgAvailExt;
	PGNO		pgnoAvailLast;

	/* search for next contiguous page
	/**/
	PGNO		pgnoPrev = *ppgnoLast;
	THREEBYTES	tbLast;
	THREEBYTES	tbSize;

	/* check for valid input
	/**/
	Assert( ppgnoLast != NULL );

	/*	check FUCB work area for active extent and allocate first available
	/*	page of active extent
	/**/
	Assert( pfucb->fExtent != fFreed || pfucb->cpgAvail >= 0 );
	Assert( pfucb->fExtent != fSecondary || pfucb->cpgAvail >= 0 );

	if ( pfucb->fExtent == fSecondary )
		{
		Assert( pfucb->cpgAvail > 0 );
  		*ppgnoLast = pfucb->pgnoLast - --pfucb->cpgAvail;
  		return JET_errSuccess;
		}

	if ( pfucb->fExtent == fFreed && pfucb->cpgAvail > 0 )
		{
		*ppgnoLast = pfucb->pgnoLast - --pfucb->cpgAvail;
		return JET_errSuccess;
		}

	/* check for valid input when alocating page from FDP
	/**/
#ifdef SPACECHECK
	Assert( !( ErrSPIValidFDP( pfucb->dbid, PgnoFDPOfPfucb( pfucb ), pfucb->ppib ) < 0 ) );
	Assert( !fContig ||
		*ppgnoLast == 0 ||
		( ErrSPIWasAlloc(
			pfucb->ppib,
			pfucb->dbid,
			PgnoFDPOfPfucb( pfucb ),
			*ppgnoLast,
			(CPG) 1 ) == JET_errSuccess )	);
#endif

	LgLeaveCriticalSection( critJet );
	EnterNestableCriticalSection( critSplit );
	LgEnterCriticalSection(critJet);

	/* get temporary FUCB, setup and use to search AvailExt for page
	/**/
	CallJ( ErrDIROpen( pfucb->ppib, pfucb->u.pfcb, 0, &pfucbT ), HandleError2 );
	FUCBSetIndex( pfucbT );

	/*	save logging status and set logging status to on
	/*	below this point in code, must exit via HandleError to
	/*	clean up logging setting in pib
	/**/

	/*	move to AVAILEXT
	/**/
	DIRGotoAVAILEXT( pfucbT, PgnoFDPOfPfucb( pfucbT ) );

	/* get node of next contiguous page if requested
	/**/
	if ( fContig )
		{
		TbKeyFromPgno( tbLast, *ppgnoLast );
		key.cb = sizeof( THREEBYTES );
		key.pb = ( BYTE * ) &tbLast;
		dib.pos = posDown;
		dib.pkey = &key;
		dib.fFlags = fDIRNull;

		if ( ( err = ErrDIRDown( pfucbT, &dib ) ) < 0 )
			{
			Assert( err != JET_errNoCurrentRecord );
			if ( err == JET_errRecordNotFound )
				{
				while ( ( err = ErrSPIGetSE( pfucbT->ppib,
					pfucbT,
					(CPG)1,
					(CPG)1 ) ) == errSPConflict )
					{
					BFSleep( cmsecWaitGeneric );
					}
				Call( err );
				}
			else
				{
				#ifdef DEBUG
					FPrintF2( "ErrSPGetPage could not go down into AvailExt.\n" );
				#endif
				goto HandleError;
				}
			}
		else
			{
			/* should already be on correct node, can replace next call
			/*	with csrstat correction ???
			/**/
			if ( err == wrnNDFoundGreater )
				{
				Call( ErrDIRNext( pfucbT, &dib ) );
				}
			else if ( err == wrnNDFoundLess )
				{
				Call( ErrDIRPrev( pfucbT, &dib ) );
				}
			}

		goto AllocFirst;
		}

	/*	get node of first available page, or allocate secondary extents
	/*	from parent FDP until a node can be found
	/**/
	dib.pos = posFirst;
	dib.fFlags = fDIRNull;
	if ( ( err = ErrDIRDown( pfucbT, &dib ) ) < 0 )
		{
		Assert( err != JET_errNoCurrentRecord );
		if ( err == JET_errRecordNotFound )
			{
			while ( ( err = ErrSPIGetSE( pfucbT->ppib, pfucbT, (CPG)1, (CPG)1 ) ) == errSPConflict )
				{
				BFSleep( cmsecWaitGeneric );
				}
			Call( err );

			goto AllocFirst;
			}
		else
			{
			#ifdef DEBUG
				FPrintF2( "ErrSPGetPage could not go down into AvailExt.\n" );
			#endif
			goto HandleError;
			}
		}

	/* allocate first page in node and return code
	/**/
AllocFirst:
	Assert( !( err < 0 ) );
	Assert( pfucbT->lineData.cb == sizeof( THREEBYTES ) );
	LFromThreeBytes( cpgAvailExt, *pfucbT->lineData.pb );
	Assert( cpgAvailExt > 0 );

	Assert( pfucbT->keyNode.cb == sizeof( THREEBYTES ) );
	PgnoFromTbKey( pgnoAvailLast, *pfucbT->keyNode.pb );

	*ppgnoLast = pgnoAvailLast - cpgAvailExt + 1;

	/*	do not return the same page
	/**/
	Assert( *ppgnoLast != pgnoPrev );

	if ( --cpgAvailExt == 0 )
		{
		Call( ErrDIRDelete( pfucbT, fDIRNoVersion ) );
		}
	else
		{
		ThreeBytesFromL( tbSize, cpgAvailExt );
		line.cb = sizeof( THREEBYTES );
		line.pb = ( BYTE * ) &tbSize;
		Call( ErrDIRReplace( pfucbT, &line, fDIRNoVersion ) );
		}

	err = JET_errSuccess;
//	if ( fContig && *ppgnoLast != pgnoPrev + 1 )
//		err = errSPNotContig;
#ifdef TRACE
	FPrintF2( "get space 1 at %lu from %d.%lu\n", *ppgnoLast, pfucb->dbid, PgnoFDPOfPfucb( pfucb ) );
#endif
HandleError:
	DIRClose( pfucbT );
	
HandleError2:
	LeaveNestableCriticalSection( critSplit );
	
	return err;
	}


//+api--------------------------------------------------------------------------
//	ErrSPFreeExt
//	========================================================================
//	ERR ErrSPFreeExt( PIB *ppib, DBID dbid, PGNO pgnoFDP, PGNO pgnoFirst, CPG cpgSize )
//
//	Frees an extent to an FDP.	The extent, starting at page pgnoFirst
//	and cpgSize pages long, is added to AvailExt of the FDP.  If the
//	extent freed is a complete secondary extent of the FDP, or can be
//	coalesced with other available extents to form a complete secondary
//	extent, the complete secondary extent is freed to the parent FDP.
//
//	PARAMETERS	ppib			process identifier block of user process
// 				pgnoFDP			page number of FDP extent is to be freed
// 				pgnoFirst  		page number of first page in extent to be freed
// 				cpgSize			number of pages in extent to be freed
//
//	RETURNS		JET_errSuccess, or error code from failing routine.
//
//	FAILS ON	invalid FDP page
//			   	extent to be freed not fully owned by FDP
//			   	extent to be freed not fully allocated from FDP
//
//
//	SIDE EFFECTS
//	COMMENTS
//-
INLINE LOCAL VOID SPDeferFreeExt( FUCB *pfucbTable, PGNO pgnoFDP, PGNO pgnoChildFDP, PGNO pgnoFirst, CPG cpgSize )
	{
	ERR			err;
	VEREXT		verext;

	Assert( pgnoFDP != pgnoChildFDP );
	Assert( pgnoFDP != pgnoFirst );
	verext.pgnoFDP = pgnoFDP;
	verext.pgnoChildFDP = pgnoChildFDP;
	verext.pgnoFirst = pgnoFirst;
	verext.cpgSize = cpgSize;

	err = ErrVERFlag( pfucbTable, operDeferFreeExt, &verext, sizeof(verext) );
	Assert( err != errDIRNotSynchronous );
 
	return;
	}



ERR ErrSPFreeExt( FUCB *pfucbTable, PGNO pgnoFDP, PGNO pgnoFirst, CPG cpgSize )
	{
	ERR			err;
	PGNO  		pgnoLast = pgnoFirst + cpgSize - 1;

	/* FDP AvailExt and OwnExt operation variables
	/**/
	FUCB 		*pfucb;
	DIB 		dib;
	KEY 	  	key;
	LINE 	  	line;
	THREEBYTES	tbLast;
	THREEBYTES	tbSize;

	/* owned extent and avail extent variables
	/**/
	PGNO	  	pgnoOELast;
	CPG			cpgOESize;
	PGNO	  	pgnoAELast;
	CPG			cpgAESize;

	/* recursive free to parent FDP variables
	/**/
	PGNO	  	pgnoParentFDP;
	
	/* check for valid input
	/**/
	Assert( cpgSize > 0 && cpgSize < ( 1L<<18 ) );
#ifdef SPACECHECK
	Assert( ErrSPIValidFDP( pfucbTable->dbid, pgnoFDP, pfucbTable->ppib ) == JET_errSuccess );
	Assert( ErrSPIWasAlloc( pfucbTable->ppib, pfucbTable->dbid, pgnoFDP, pgnoFirst, cpgSize ) == JET_errSuccess );
#endif

	MPLPurgePgno( pfucbTable->dbid, pgnoFirst, pgnoLast );
	
#ifdef DEBUG
	if ( pfucbTable->ppib != ppibBMClean )
		AssertNotInMPL( pfucbTable->dbid, pgnoFirst, pgnoLast );
#endif

	LgLeaveCriticalSection( critJet );
	EnterNestableCriticalSection( critSplit );
	LgEnterCriticalSection(critJet);

	/*	make temporary cursor for parent FDP
	/**/
	CallJ( ErrDIROpen( pfucbTable->ppib,
		PgnoFDPOfPfucb( pfucbTable ) == pgnoFDP ?
			pfucbTable->u.pfcb :
			PfcbFCBGet( pfucbTable->dbid, pgnoFDP ), 0, &pfucb ),
		HandleError2 );
	Assert( PgnoFDPOfPfucb( pfucb ) == pgnoFDP );
	FUCBSetIndex( pfucb );

	/*	move to OWNEXT.
	/**/
	DIRGotoOWNEXT( pfucb, PgnoFDPOfPfucb( pfucb ) );

	/* find bounds of owned extent which contains the extent to be freed
	/**/
	TbKeyFromPgno( tbLast, pgnoFirst );
	key.cb = sizeof( THREEBYTES );
	key.pb = ( BYTE * ) &tbLast;
	dib.pos = posDown;
	dib.pkey = &key;
	dib.fFlags = fDIRNull;
	Call( ErrDIRDown( pfucb, &dib ) );
	if ( err == wrnNDFoundGreater )
		{
		Call( ErrDIRNext( pfucb, &dib ) );
		}
	Assert( pfucb->keyNode.cb == sizeof( THREEBYTES ) );
	PgnoFromTbKey( pgnoOELast, *( THREEBYTES * )pfucb->keyNode.pb );
	Assert( pfucb->lineData.cb == sizeof( THREEBYTES ) );
	LFromThreeBytes( cpgOESize, *( THREEBYTES * )pfucb->lineData.pb );
	DIRUp( pfucb, 1 );

	/*	If AvailExt empty, add extent to be freed.	Otherwise, coalesce with
	/*	left extents by deleting left extents and augmenting size.	Coalesce
	/*	right extent replacing size of right extent.  Otherwise add extent.
	/*	Record parent page number for use later with secondary extent free to
	/*	parent.
	/**/
	DIRGotoAVAILEXT( pfucb, PgnoFDPOfPfucb( pfucb ) );
	Call( ErrDIRGet( pfucb ) );
	LFromThreeBytes( pgnoParentFDP, *( THREEBYTES * )pfucb->lineData.pb );

	TbKeyFromPgno( tbLast, pgnoFirst - 1 );
	Assert( key.cb == sizeof( THREEBYTES ) );
	Assert( key.pb == ( BYTE * ) &tbLast );
	Assert( dib.pos == posDown );
	Assert( dib.pkey == ( KEY* )&key );
	Assert( dib.fFlags == fDIRNull );
	if ( ( err = ErrDIRDown( pfucb, &dib ) ) < 0 )
		{
		Assert( err != JET_errNoCurrentRecord );
		if ( err == JET_errRecordNotFound )
			{
			Call( ErrSPIAddExt( pfucb, pgnoLast, &cpgSize, fFreed ) );
			}
		else
			{
			#ifdef DEBUG
				FPrintF2( "ErrSPFreeExt could not go down into nonempty AvailExt.\n" );
			#endif
			goto HandleError;
			}
		}
	else
		{
		if ( pgnoFirst > pgnoOELast - cpgOESize + 1 && err == JET_errSuccess )
			{
			LFromThreeBytes( cpgAESize, *( THREEBYTES * ) pfucb->lineData.pb );
			cpgSize += cpgAESize;
			Call( ErrDIRDelete( pfucb, fDIRNoVersion ) );
			}

		err = ErrDIRNext( pfucb, &dib );
		if ( err >= 0 )
			{
			PgnoFromTbKey( pgnoAELast, *( THREEBYTES * )pfucb->keyNode.pb );
			LFromThreeBytes( cpgAESize, *( THREEBYTES * )pfucb->lineData.pb );
			if ( pgnoLast == pgnoAELast - cpgAESize && pgnoAELast <= pgnoOELast )
				{
				ThreeBytesFromL( tbSize, cpgAESize + cpgSize );
				line.pb = ( BYTE * ) &tbSize;
				line.cb = sizeof( THREEBYTES );
				Call( ErrDIRReplace( pfucb, &line, fDIRNoVersion ) );
				}
			else
				{
				DIRUp( pfucb, 1 );
				Call( ErrSPIAddExt( pfucb, pgnoLast, &cpgSize, fFreed ) );
				}
			}
		else
			{
			if ( err != JET_errNoCurrentRecord )
				goto HandleError;
			DIRUp( pfucb, 1 );
			Call( ErrSPIAddExt( pfucb, pgnoLast, &cpgSize, fFreed ) );
			}
		}

	/*	if extent freed coalesced with available extents within the same
	/*	owned extent form a complete secondary extent, remove the secondary
	/*	extent from the FDP and free it to the parent FDP.	Since FDP is
	/*	first page of primary extent, do not have to guard against freeing
	/*	primary extents.  If parent FDP is NULL, FDP is device level and
	/*	complete secondary extents are freed to device.
	/**/
	PgnoFromTbKey( pgnoAELast, *pfucb->keyNode.pb );
	LFromThreeBytes( cpgAESize, *pfucb->lineData.pb );
	if ( pgnoAELast == pgnoOELast && cpgAESize == cpgOESize )
		{
//	UNDONE:	this code has been disabled due to a doubly allocated
//			space bug in which it appears that an index is deleted
//			and has its space defer freed.  At the same time a table
//			is deleted and defer frees its space to the database.  When
//			the index defer freed space is freed, it cascades to the
//			database and when the table space is freed, the shared
//			extents are freed twice.
#if 0
		FCB		*pfcbT;
		
		/*	parent must always be in memory
		/**/
		pfcbT = PfcbFCBGet( pfucbTable->dbid, pgnoParentFDP );
		Assert( pfcbT != pfcbNil );

		/*	Note that we cannot free space to parent FDP if current FDP
		/*	is pending deletion since this space has already been defer
		/*	freed.
		/**/
		if ( !FFCBDeletePending( pfcbT ) )
			{
			if ( pgnoParentFDP != pgnoNull )
				{
				Call( ErrDIRDelete( pfucb, fDIRNoVersion ) );
				DIRUp( pfucb, 1 );
				DIRGotoOWNEXT( pfucb, PgnoFDPOfPfucb( pfucb ) );
				TbKeyFromPgno( tbLast, pgnoOELast );
				Assert( key.cb == sizeof(THREEBYTES) );
				Assert( key.pb == (BYTE *)&tbLast );
				Assert( dib.pos == posDown );
				Assert( dib.pkey == (KEY *)&key );
				Assert( dib.fFlags == fDIRNull );
				Call( ErrDIRDown( pfucb, &dib ) );
				Assert( err == JET_errSuccess );
				Call( ErrDIRDelete( pfucb, fDIRNoVersion ) );

				Call( ErrSPFreeExt( pfucbTable, pgnoParentFDP, pgnoAELast-cpgAESize+1, cpgAESize ) );
				}
			else
				{
				//	UNDONE:	free secondary extents to device
				}
			}
#endif
		}

HandleError:
	DIRClose( pfucb );
#ifdef TRACE
		{
		INT cpg = 0;
		for ( ; cpg < cpgSize; cpg++ )
			FPrintF2( "free space 1 at %lu to FDP %d.%lu\n", pgnoFirst + cpg, pfucbTable->dbid, pgnoFDP );
		}
//	FPrintF2( "free space %lu at %lu to FDP %d.%lu\n", cpgSize, pgnoFirst, pfucbTable->dbid, pgnoFDP );
#endif
	Assert( err != JET_errKeyDuplicate );

HandleError2:
	LeaveNestableCriticalSection( critSplit );

	return err;
	}


//+api--------------------------------------------------------------------------
// ErrSPFreeFDP
// ========================================================================
// ERR ErrSPFreeFDP( FUCB *pfucbTable, PGNO pgnoFDP )
//
//	Frees all owned extents of an FDP to its parent FDP.  The FDP page is freed
//	with the owned extents to the parent FDP.
//
// PARAMETERS  	pfucbTable		table file use currency block
//						pgnoFDP			page number of FDP to be freed
//
//
// RETURNS
//		JET_errSuccess, or error code from failing routine, or one
//		of the following "local" errors:
//
// SIDE EFFECTS
// COMMENTS
//-
ERR ErrSPFreeFDP( FUCB *pfucbTable, PGNO pgnoFDP )
	{
	ERR			err;
	FUCB  		*pfucb = pfucbNil;
	DIB			dib;
	PGNO  		pgnoParentFDP;
	CPG			cpgSize;
	PGNO  		pgnoLast;
	PGNO  		pgnoFirst;
	PGNO		pgnoPrimary = pgnoNull;
	CPG			cpgPrimary = 0;

	/* check for valid parameters.
	/**/
#ifdef SPACECHECK
	Assert( ErrSPIValidFDP( pfucbTable->dbid, pgnoFDP, pfucbTable->ppib ) == JET_errSuccess );
	Assert( ErrSPIWasAlloc( pfucbTable->ppib, pfucbTable->dbid, pgnoFDP, pgnoFDP, ( CPG ) 1 ) == JET_errSuccess );
#endif

#ifdef TRACE
	FPrintF2( "free space FDP at %d.%lu\n", pfucbTable->dbid, pgnoFDP );
#endif

	LgLeaveCriticalSection( critJet );
	EnterNestableCriticalSection( critSplit );
	LgEnterCriticalSection(critJet);

	/* get temporary FUCB, setup and use to search AvailExt for page
	/**/
	CallJ( ErrDIROpen( pfucbTable->ppib, pfucbTable->u.pfcb, 0, &pfucb ),
			HandleError2 );
	FUCBSetIndex( pfucb );

	/*	move to AVAILEXT.
	/**/
	DIRGotoAVAILEXT( pfucb, pgnoFDP );

	/*	Get page number of parent FDP, to which all owned extents will be
	/*	freed.	If the parent FDP is Null, the FDP to be freed is the device
	/*	level FDP which cannot be freed.
	/**/
	Call( ErrDIRGet( pfucb ) );
	LFromThreeBytes( pgnoParentFDP, *pfucb->lineData.pb );
	Assert( pgnoParentFDP != pgnoNull );

	/*	go down to first owned extent.	Free each extent in OwnExt to the
	/*	the parent FDP.
	/**/
	DIRGotoOWNEXT( pfucb, pgnoFDP );
	dib.pos = posFirst;
	dib.fFlags = fDIRNull;
	Call( ErrDIRDown( pfucb, &dib ) );
	Assert( err == JET_errSuccess );
	do {
		LFromThreeBytes( cpgSize, *pfucb->lineData.pb );
		PgnoFromTbKey( pgnoLast, *pfucb->keyNode.pb );
		pgnoFirst = pgnoLast - cpgSize + 1;

		if ( pgnoFirst == pgnoFDP )
			{
			pgnoPrimary = pgnoFirst;
			cpgPrimary = cpgSize;
			}
		else
			{
			SPDeferFreeExt( pfucbTable, pgnoParentFDP, pgnoPrimary, pgnoFirst, cpgSize );
			}

		err = ErrDIRNext( pfucb, &dib );
		}
	while ( err >= 0 );
	if ( err != JET_errNoCurrentRecord )
		{
		Assert( err < 0 );
		goto HandleError;
		}

	/*	defer free primary extent must be last, so that
	/*	RCECleanUp does not free FCB until all extents
	/*	cleaned.  Pass pgnoFDP with primary extent to have
	/*	FCB flushed.
	/**/
	Assert( pgnoPrimary != pgnoNull );
	Assert( cpgPrimary != 0 );
	SPDeferFreeExt( pfucbTable, pgnoParentFDP, pgnoFDP, pgnoPrimary, cpgPrimary );

	/* UNDONE: either each OWNEXT node should be deleted (and logged)
	/* prior to releasing to father FDP, or the son FDP pointer node
	/* should be deleted. We risk having it marked deleted in father but
	/* still present in son.
	/**/

	err = JET_errSuccess;

HandleError:
	if ( pfucb != pfucbNil )
		DIRClose( pfucb );
	
HandleError2:
	LeaveNestableCriticalSection( critSplit );
	
	return err;
	}


LOCAL ERR ErrSPIAddExt( FUCB *pfucb, PGNO pgnoLast, CPG *pcpgSize, const INT fExtent )
	{
	ERR				err;
	KEY				key;
	LINE	   		line;
	THREEBYTES		tbLast;
	THREEBYTES		tbSize;

#ifdef TRACE
	{
	INT cpg = 0;
	for ( ; cpg < *pcpgSize; cpg++ )
		FPrintF2( "add space 1 at %lu to FDP %d.%lu\n", pgnoLast - *pcpgSize + 1 + cpg, pfucb->dbid, pfucb->u.pfcb->pgnoFDP );
	}
//	FPrintF2( "add space %lu at %lu to FDP %d.%lu\n", *pcpgSize, pgnoLast - *pcpgSize + 1, pfucb->dbid, pfucb->u.pfcb->pgnoFDP );
#endif

	AssertCriticalSection( critSplit );

	pfucb->fExtent = fExtent;
	pfucb->pgnoLast = pgnoLast;
	pfucb->cpgExtent = *pcpgSize;
	pfucb->cpgAvail = *pcpgSize;

	TbKeyFromPgno( tbLast, pgnoLast );
	key.cb = sizeof(THREEBYTES);
	key.pb = (BYTE *)&tbLast;
	ThreeBytesFromL( tbSize, *pcpgSize );
	line.cb = sizeof(THREEBYTES);
	line.pb = (BYTE *)&tbSize;

	if ( fExtent == fSecondary )
		{
		DIRGotoOWNEXT( pfucb, PgnoFDPOfPfucb( pfucb ) );
		Call( ErrDIRInsert( pfucb, &line, &key, fDIRNoVersion | fDIRSpace | fDIRBackToFather ) );
		DIRGotoAVAILEXT( pfucb, PgnoFDPOfPfucb( pfucb ) );
		}

	Call( ErrDIRInsert( pfucb, &line, &key, fDIRNoVersion | fDIRSpace ) );
	Call( ErrDIRGet( pfucb ) );

	/* correct page count with remaining number of pages
	/**/
	if ( pfucb->cpgAvail != *pcpgSize )
		{
		if ( pfucb->cpgAvail > 0 )
			{
			ThreeBytesFromL( tbSize, pfucb->cpgAvail );
			Assert( line.cb == sizeof( THREEBYTES ) );
			Assert( line.pb == ( BYTE * ) &tbSize );
			Call( ErrDIRReplace( pfucb, &line, fDIRNoVersion ) );
			Call( ErrDIRGet( pfucb ) );
			}
		else
			{
			Assert( pfucb->cpgAvail == 0 );
			Call( ErrDIRDelete( pfucb, fDIRNoVersion ) );
			}
		}
	*pcpgSize = pfucb->cpgAvail;

HandleError:
	/* return fExtent to initial fNone value.	Only necessary for
	/*	path GetPage GetSE as in all other cases fucb is temporary and
	/*	released before subsequent space allocating DIR call.
	/**/
	pfucb->fExtent = fNone;
	return err;
	}


LOCAL ERR ErrSPIGetSE( PIB *ppib, FUCB *pfucb, CPG const cpgReq, CPG const cpgMin )
	{
	ERR		err;
	PGNO   	pgnoParentFDP;
	CPG		cpgPrimary;
	PGNO   	pgnoSEFirst;
	PGNO   	pgnoSELast;
	CPG		cpgSEReq;
	CPG		cpgSEMin;
	CPG		cpgAvailExt;
	DIB		dib;
	BOOL   	fBeingExtend;
	BOOL   	fDBIDExtendingDB = fFalse;

	AssertCriticalSection( critSplit );
	
	/*	get parent FDP page number
	/*	should be at head of AvailExt
	/**/
	DIRGotoAVAILEXT( pfucb, PgnoFDPOfPfucb( pfucb ) );
	Call( ErrDIRGet( pfucb ) );
	LFromThreeBytes( pgnoParentFDP, *pfucb->lineData.pb );

	/* store primary extent size
	/**/
	DIRGotoOWNEXT( pfucb, PgnoFDPOfPfucb( pfucb ) );
	Call( ErrDIRGet( pfucb ) );
	LFromThreeBytes( cpgPrimary, *pfucb->lineData.pb );

	/*	pages of allocated extent may be used to split OWNEXT and
	/*	AVAILEXT trees.  If this happens, then subsequent added
	/*	extent will not have to split and will be able to satisfy
	/*	requested allocation.
	/**/
	cpgSEMin = max( cpgMin, cpgSESysMin );
	cpgSEReq = max( cpgReq, max( cpgPrimary/cSecFrac, cpgSEMin ) );

	if ( pgnoParentFDP != pgnoNull )
		{
		DIRGotoAVAILEXT( pfucb, PgnoFDPOfPfucb( pfucb ) );
		forever
			{
			cpgAvailExt = cpgSEReq;
		
			/* try to get Ext. If the database file is being extended,
			/* try again until it is done.
			/**/
			while ( ( err = ErrSPIGetExt( pfucb,
				pgnoParentFDP,
				&cpgAvailExt,
				cpgSEMin,
				&pgnoSEFirst,
				0 ) ) == errSPConflict )
				{
				BFSleep( cmsecWaitGeneric );
				}
			Call( err );

			pgnoSELast = pgnoSEFirst + cpgAvailExt - 1;
			Call( ErrSPIAddExt( pfucb, pgnoSELast, &cpgAvailExt, fSecondary ));

			if ( cpgAvailExt >= cpgMin )
				{
				goto HandleError;
				}

			/* move to head of Avail/Own Ext trees for next insert
			/**/
			DIRUp( pfucb, 1 );
			}
		}
	else
		{
		/*	allocate a secondary extent from the operating system
		/*	by getting page number of last owned page, extending the
		/*	file as possible and adding the sized secondary extent
		/*	NOTE: only one user can do this at one time. Protect it
		/*	NOTE: with critical section.
		/**/
		EnterCriticalSection( rgfmp[pfucb->dbid].critExtendDB );
		if ( FDBIDExtendingDB( pfucb->dbid ) )
			{
			fBeingExtend = fTrue;
			}
		else
			{
			DBIDSetExtendingDB( pfucb->dbid );
			fDBIDExtendingDB = fTrue;
			fBeingExtend = fFalse;
			}
		LeaveCriticalSection( rgfmp[pfucb->dbid].critExtendDB );

		if ( fBeingExtend )
			{
			Error( errSPConflict, HandleError );
			}

		dib.pos = posLast;
		dib.fFlags = fDIRNull;
		Call( ErrDIRDown( pfucb, &dib ) );
		Assert( pfucb->keyNode.cb == sizeof( THREEBYTES ) );
		PgnoFromTbKey( pgnoSELast, *pfucb->keyNode.pb );
		DIRUp( pfucb, 1 );

		/*	allocate more space from device.
		/**/
		if ( pgnoSELast + cpgSEMin > pgnoSysMax )
			{
			err = JET_errCantAllocatePage;
			goto HandleError;
			}
		cpgSEReq = min( cpgSEReq, (CPG)(pgnoSysMax - pgnoSELast) );
		Assert( cpgSEMin <= cpgSEReq && cpgSEMin >= cpgSESysMin );

		err = ErrIONewSize( pfucb->dbid, pgnoSELast + cpgSEReq );
		if ( err < 0 )
			{
			Call( ErrIONewSize( pfucb->dbid, pgnoSELast + cpgSEMin ) );
			cpgSEReq = cpgSEMin;
			}

		/* calculate last page of device level secondary extent
		/**/
		pgnoSELast += cpgSEReq;
		DIRGotoAVAILEXT( pfucb, PgnoFDPOfPfucb( pfucb ) );

		/*	allocation may not satisfy requested allocation if OWNEXT
		/*	or AVAILEXT had to be split during the extent insertion.  As
		/*	a result, we may have to allocate more than one secondary
		/*	extent for a given space requirement.
		/**/
		err = ErrSPIAddExt( pfucb, pgnoSELast, &cpgSEReq, fSecondary );
		}

HandleError:
	if ( fDBIDExtendingDB )
		{
		EnterCriticalSection( rgfmp[pfucb->dbid].critExtendDB );
		Assert( FDBIDExtendingDB( pfucb->dbid ) );
		DBIDResetExtendingDB( pfucb->dbid );
//		fDBIDExtendingDB = fFalse;
		LeaveCriticalSection( rgfmp[pfucb->dbid].critExtendDB );
		}
	return err;
	}


#ifdef SPACECHECK

LOCAL ERR ErrSPIValidFDP( DBID dbid, PGNO pgnoFDP, PIB *ppib )
	{
	ERR			err;
	FUCB			*pfucb = pfucbNil;
	DIB			dib;
	THREEBYTES	tbFDPPage;
	KEY			keyFDPPage;
	PGNO			pgnoOELast;
	CPG			cpgOESize;

	Assert( pgnoFDP != pgnoNull );

	/*	get temporary FUCB, set currency pointers to OwnExt and use to
	/*	search OwnExt for pgnoFDP
	/**/
	Call( ErrDIROpen( ppib, PfcbFCBGet( dbid, pgnoFDP ), 0, &pfucb ) );
	DIRGotoOWNEXT( pfucb, pgnoFDP );

	/* validate head of OwnExt
	/**/
	Call( ErrDIRGet( pfucb ) );
	Assert( pfucb->keyNode.cb == ( *( (KEY *) pkeyOwnExt ) ).cb &&
		memcmp( pfucb->keyNode.pb, ((KEY *) pkeyOwnExt)->pb, pfucb->keyNode.cb ) == 0 );

	/* search for pgnoFDP in OwnExt tree
	/**/
	TbKeyFromPgno( tbFDPPage, pgnoFDP );
	keyFDPPage.pb = (BYTE *) &tbFDPPage;
	keyFDPPage.cb = sizeof(THREEBYTES);
	dib.pos = posDown;
	dib.pkey = &keyFDPPage;
	dib.fFlags = fDIBNull;
	Call( ErrDIRDown( pfucb, &dib ) );
	if ( err == wrnNDFoundGreater )
		{
		Call( ErrDIRNext( pfucb, &dib ) );
		}
	Assert( pfucb->keyNode.cb == sizeof( THREEBYTES ) );
	PgnoFromTbKey( pgnoOELast, *pfucb->keyNode.pb );

	Assert( pfucb->lineData.cb == sizeof( THREEBYTES ) );
	LFromThreeBytes( cpgOESize, *pfucb->lineData.pb );

	/* FDP page should be first page of primary extent
	/**/
	Assert( pgnoFDP == pgnoOELast - cpgOESize + 1 );

HandleError:
	DIRClose( pfucb );
	return JET_errSuccess;
	}


LOCAL ERR ErrSPIWasAlloc( PIB *ppib, DBID dbid, PGNO pgnoFDP, PGNO pgnoFirst, CPG cpgSize )
	{
	ERR			err;
	FUCB			*pfucb;
	DIB			dib;
	KEY			key;
	THREEBYTES	tbLast;
	PGNO			pgnoOwnLast;
	CPG			cpgOwnExt;
	PGNO			pgnoAvailLast;
	CPG  			cpgAvailExt;

	/* get temporary FUCB, setup and use to search AvailExt for page
	/**/
	pfucb = pfucbNil;
	Call( ErrDIROpen( ppib, PfcbFCBGet( dbid, pgnoFDP ), 0, &pfucb ) );
	DIRGotoOWNEXT( pfucb, pgnoFDP );

	/* check that the given extent is owned by the given FDP but not
	/*	available in the FDP AvailExt
	/**/
	TbKeyFromPgno( tbLast, pgnoFirst + cpgSize - 1 );
	key.cb = sizeof( THREEBYTES );
	key.pb = (BYTE *) &tbLast;
	dib.pos = posDown;
	dib.pkey = &key;
	dib.fFlags = fDIBNull;
	Assert( PcsrCurrent( pfucb )->itag == itagOWNEXT );
	Call( ErrDIRDown( pfucb, &dib ) );
	if ( err == wrnNDFoundGreater )
		{
		Call( ErrDIRNext( pfucb, &dib ) );
		}
	Assert( pfucb->keyNode.cb == sizeof( THREEBYTES ) );
	PgnoFromTbKey( pgnoOwnLast, *pfucb->keyNode.pb );
	Assert( pfucb->lineData.cb == sizeof( THREEBYTES ) );
	LFromThreeBytes( cpgOwnExt, *pfucb->lineData.pb );
	Assert( pgnoFirst >= pgnoOwnLast - cpgOwnExt + 1 );
	DIRUp( pfucb, 1 );

	/* check that the extent is not still in AvailExt.  Since the DIR search
		is keyed with the last page of the extent to be freed, it is sufficient
		to check that the last page of the extent to be freed is in the found
		extent to determine the full extent has not been allocated.  Since that
		last page of the extent should not be the key of a tree node, csrstat
		correction may be required after the search via Next.  If AvailExt is
		empty then the extent cannot be in AvailExt and has been allocated.
		*/
	DIRGotoAVAILEXT( pfucb, pgnoFDP );
	if ( ( err = ErrDIRDown( pfucb, &dib ) ) < 0 )
		{
		if ( err == JET_errRecordNotFound )
			{
			err = JET_errSuccess;
			goto CleanUp;
			}
		goto HandleError;
		}
	if ( err == wrnNDFoundGreater )
		{
		Call( ErrDIRNext( pfucb, &dib ) );
		}
	if ( err >= 0 )
		{
		Assert( pfucb->keyNode.cb == sizeof( THREEBYTES ) );
		PgnoFromTbKey( pgnoAvailLast, *pfucb->keyNode.pb );
		Assert( pfucb->lineData.cb == sizeof( THREEBYTES ) );
		LFromThreeBytes( cpgAvailExt, *pfucb->lineData.pb );
		Assert( pgnoFirst + cpgSize - 1 < pgnoAvailLast - cpgAvailExt + 1 );
		}
HandleError:
CleanUp:
	DIRClose( pfucb );
	return JET_errSuccess;
	}

#endif


ERR ErrSPGetInfo( FUCB *pfucb, BYTE *pbResult, INT cbMax )
	{
	ERR			err = JET_errSuccess;
	CPG			cpgOwnExtTotal = 0;
	CPG			cpgAvailExtTotal = 0;
	CPG			*pcpgOwnExtTotal = (CPG *)pbResult;
	CPG			*pcpgAvailExtTotal = (CPG *)pbResult + 1;
	CPG			*pcpg = (CPG *)pbResult + 2;
	CPG			*pcpgMax = (CPG *)(pbResult + cbMax );
	FUCB 			*pfucbT = pfucbNil;
	DIB			dib;
	PGNO			pgno;
	CPG			cpg;

	/*	structure must be large enough for total pages owned and
	/*	total pages available.
	/**/
	if ( cbMax < sizeof(CPG) + sizeof(CPG) )
		return JET_errBufferTooSmall;
	memset( pbResult, '\0', cbMax );

	/* get temporary FUCB, setup and use to search AvailExt for page
	/**/
	Call( ErrDIROpen( pfucb->ppib, pfucb->u.pfcb, 0, &pfucbT ) );
	FUCBSetIndex( pfucbT );

	/*	move to OWNEXT.
	/**/
	DIRGotoOWNEXT( pfucbT, PgnoFDPOfPfucb( pfucbT ) );

	/* find bounds of owned extent which contains the extent to be freed
	/**/
	dib.fFlags = fDIRNull;
	dib.pos = posFirst;
	Call( ErrDIRDown( pfucbT, &dib ) );

	Assert( pfucbT->keyNode.cb == sizeof( THREEBYTES ) );
	PgnoFromTbKey( pgno, *( THREEBYTES * )pfucbT->keyNode.pb );
	Assert( pfucbT->lineData.cb == sizeof( THREEBYTES ) );
	LFromThreeBytes( cpg, *( THREEBYTES * )pfucbT->lineData.pb );

	while ( pcpg + 3 < pcpgMax )
		{
		cpgOwnExtTotal += cpg;

		*pcpg++ = pgno;
		*pcpg++ = cpg;

		err = ErrDIRNext( pfucbT, &dib );
		if ( err < 0 )
			{
			if ( err != JET_errNoCurrentRecord )
				goto HandleError;
			break;
			}

		Assert( pfucbT->keyNode.cb == sizeof( THREEBYTES ) );
		PgnoFromTbKey( pgno, *( THREEBYTES * )pfucbT->keyNode.pb );
		Assert( pfucbT->lineData.cb == sizeof( THREEBYTES ) );
		LFromThreeBytes( cpg, *( THREEBYTES * )pfucbT->lineData.pb );
		}

	*pcpg++ = 0;
	*pcpg++ = 0;

	DIRUp( pfucbT, 1 );

	/*	move to AVAILEXT.
	/**/
	DIRGotoAVAILEXT( pfucbT, PgnoFDPOfPfucb( pfucbT ) );

	/* find bounds of owned extent which contains the extent to be freed
	/**/
	dib.fFlags = fDIRNull;
	dib.pos = posFirst;
	err = ErrDIRDown( pfucbT, &dib );
	if ( err < 0 )
		{
		if ( err != JET_errRecordNotFound )
			goto HandleError;
		}

	if ( err != JET_errRecordNotFound )
		{
		Assert( pfucbT->keyNode.cb == sizeof( THREEBYTES ) );
		PgnoFromTbKey( pgno, *( THREEBYTES * )pfucbT->keyNode.pb );
		Assert( pfucbT->lineData.cb == sizeof( THREEBYTES ) );
		LFromThreeBytes( cpg, *( THREEBYTES * )pfucbT->lineData.pb );

		while ( pcpg + 1 < pcpgMax )
			{
			cpgAvailExtTotal += cpg;

			*pcpg++ = pgno;
			*pcpg++ = cpg;

			err = ErrDIRNext( pfucbT, &dib );
			if ( err < 0 )
				{
				if ( err != JET_errNoCurrentRecord )
					goto HandleError;
				break;
				}

			Assert( pfucbT->keyNode.cb == sizeof( THREEBYTES ) );
			PgnoFromTbKey( pgno, *( THREEBYTES * )pfucbT->keyNode.pb );
			Assert( pfucbT->lineData.cb == sizeof( THREEBYTES ) );
			LFromThreeBytes( cpg, *( THREEBYTES * )pfucbT->lineData.pb );
			}
		}

	if ( pcpg + 1 < pcpgMax )
		{
		*pcpg++ = 0;
		*pcpg++ = 0;
		}

	*pcpgOwnExtTotal = cpgOwnExtTotal;
	*pcpgAvailExtTotal = cpgAvailExtTotal;

	err = JET_errSuccess;

HandleError:
	DIRClose( pfucbT );
	return err;
	}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\sysdb.c ===
/***********************************************************************
* Microsoft Jet
*
* Microsoft Confidential.  Copyright 1991-1992 Microsoft Corporation.
*
* Component:
*
* File: mktmplts.c
*
* File Comments:
*
* Revision History:
*
*  [0]  29-Jul-92  paulv	Copied sysdb.c and made changes
*
***********************************************************************/

#include "config.h"
#include "daedef.h"
#include "page.h"
#define cbPageSize cbPage

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys\types.h>
#include <sys\stat.h>

#include "sysqry.c" /* System Queries */

DeclAssertFile;

#define chPlus '+'
#define chZero '\0'
#define cbBufMax 512

PUBLIC ERR ISAMAPI	ErrIsamOpenDatabase(JET_SESID sesid, const char __far *szDatabase, const char __far *szConnect, JET_DBID __far *pdbid, JET_GRBIT grbit);

typedef struct {
	void	*pb;
	unsigned long cbMax;
	unsigned long cbReturned;
	unsigned long cbActual;
} OUTDATA;

typedef struct {
	const void    *pb;
	unsigned long cb;
} INDATA;

/*	Engine OBJIDs:

	0..0x10000000 reserved for engine use, divided as follows:

	0x00000000..0x0000FFFF	reserved for TBLIDs under RED
	0x00000000..0x0EFFFFFF	reserved for TBLIDs under BLUE
	0x0F000000..0x0FFFFFFF	reserved for container IDs
	0x10000000				reserved for ObjectId of DbObject

	Client OBJIDs begin at 0x10000001 and go up from there.
*/
#define objidNil			((OBJID) 0x00000000)
#define objidRoot			((OBJID) 0x0F000000)
#define objidTblContainer	((OBJID) 0x0F000001)
#define objidDbContainer	((OBJID) 0x0F000002)
#define objidRcContainer 	((OBJID) 0x0F000003)
#define objidDbObject		((OBJID) 0x10000000)


/*	SID data
*/
typedef unsigned char JET_SID[];

/* THIS MUST MATCH ITS PARTNER IN CRTSYSDB.C!!! */
static JET_SID __near sidAdmins = {
	0x01, 0x0c, 0x17, 0x21, 0x2b, 0x35, 0x3f, 0x49, 0x53, 0x5d,
	0x02, 0x0d, 0x18, 0x22, 0x2c, 0x36, 0x40, 0x4a, 0x54, 0x5e,
	0x03, 0x0e, 0x19, 0x23, 0x2d, 0x37, 0x41, 0x4b, 0x55, 0x5f,
	0x04, 0x0f, 0x1a, 0x24, 0x2e, 0x38, 0x42, 0x4c, 0x56, 0x60,
	0x05, 0x10, 0x1b, 0x25, 0x2f, 0x39, 0x43, 0x4d, 0x57, 0x61,
	0x06, 0x11, 0x1c, 0x26, 0x30, 0x3a, 0x44, 0x4e, 0x58, 0x62,
	0x07, 0x12, 0x1d, 0x27, 0x31, 0x3b, 0x45, 0x4f, 0x59, 0x63,
	0x08, 0x13, 0x1e, 0x28, 0x32, 0x3c, 0x46, 0x50, 0x5a, 0x64,
	0x09, 0x14, 0x1f, 0x29, 0x33, 0x3d, 0x47, 0x51, 0x5b, 0x65,
	0x0a, 0x15, 0x20, 0x2a, 0x34, 0x3e, 0x48, 0x52, 0x5c, 0x66,
	0x0b, 0x16
};
#define cbsidAdmins sizeof(sidAdmins)
static JET_SID __near sidUsers = {0x02, 0x01};
#define cbsidUsers sizeof(sidUsers)
static JET_SID __near sidGuests = {0x02, 0x02};
#define cbsidGuests sizeof(sidGuests)
static JET_SID __near sidEngine = {0x02, 0x03};
#define cbsidEngine sizeof(sidEngine)
static JET_SID __near sidCreator = {0x02, 0x04};
#define cbsidCreator sizeof(sidCreator)
static JET_SID __near sidGuestUser = {0x02, 0x05};
#define cbsidGuestUser sizeof(sidGuestUser)

static JET_SID __near sidAdminUser = {0x03, 0x01};
#define cbsidAdminUser sizeof(sidAdminUser)


/*	general data
*/
static CODECONST(char) chFalse = 0;
static CODECONST(char) chTrue = 1;

static CODECONST(char) szAdmins[] = "Admins";
static CODECONST(char) szUsers[] = "Users";
static CODECONST(char) szGuests[] = "Guests";
static CODECONST(char) szEngine[]  = "Engine";
static CODECONST(char) szCreator[] = "Creator";
static CODECONST(char) szGuestUser[] = "guest";
static CODECONST(char) szGuestPswd[] = "";
static CODECONST(char) szAdminUser[] = "admin";
static CODECONST(char) szAdminPswd[] = "";

static CODECONST(char) szIdxSoName[] = "ParentIdName";
static CODECONST(char) szIdxScName[] = "ObjectIdName";
static CODECONST(char) szTrue[] = "TRUE";
static CODECONST(char) szFalse[] = "FALSE";
static CODECONST(char) szLine[] =
	"---------------------------------------------------";

#define ENG_ONLY	1

static CODECONST(char *) rgszConnect[] = {
	";COUNTRY=1;LANGID=0x0409;CP=1252",		/* iCollateEng */
#ifndef ENG_ONLY
	";COUNTRY=1;LANGID=0x0013;CP=1252",		/* iCollateDut */
	";COUNTRY=1;LANGID=0x000A;CP=1252",		/* iCollateSpa */
	";COUNTRY=1;LANGID=0x040B;CP=1252",		/* iCollateSweFin (default) */
	";COUNTRY=1;LANGID=0x0406;CP=1252",		/* iCollateNorDan (default) */
	";COUNTRY=1;LANGID=0x040F;CP=1252",		/* iCollateIcelandic (default) */
	";COUNTRY=1;LANGID=0x0419;CP=1251",		/* iCollateCyrillic (default) */
	";COUNTRY=1;LANGID=0x0405;CP=1250",		/* iCollateCzech (default) */
	";COUNTRY=1;LANGID=0x040E;CP=1250",		/* iCollateHungarian (default) */
	";COUNTRY=1;LANGID=0x0415;CP=1250",		/* iCollatePolish (default) */
	";COUNTRY=1;LANGID=0x0401;CP=1256",		/* iCollateArabic (default) */
	";COUNTRY=1;LANGID=0x040D;CP=1255",		/* iCollateHebrew (default) */
	";COUNTRY=1;LANGID=0x0408;CP=1253",		/* iCollateGreek (default) */
	";COUNTRY=1;LANGID=0x041F;CP=1254"		/* iCollateTurkish (default) */
#endif

#ifdef DBCS	/* johnta: Add the new Japanese sorting order */
	,";COUNTRY=1;LANGID=0x0081;CP=1252"		/* iCollateJpn */
#endif /* DBCS */
};

#define cCollate (sizeof(rgszConnect) / sizeof(CODECONST(char *)))

static unsigned char rgbBuf[cbBufMax];
static unsigned char rgbKey[cbBufMax];
static char szOut[cbBufMax];


/*	database data
**	BEWARE: these arrays MUST be maintained to agree with rgszConnect (above)
*/
static CODECONST(char *) rgszSystemMdb[] = {
	"systemen.mdb", "systemdu.mdb", "systemsp.mdb", "systemsf.mdb", "systemnd.mdb", "systemil.mdb",
	"systemcy.mdb", "systemcz.mdb", "systemhu.mdb", "systempo.mdb", "systemar.mdb", "systemhe.mdb",
	"systemgr.mdb", "systemtu.mdb"

#ifdef DBCS	/* johnta: Add the new Japanese sorting order */
	, "systemjp.mdb"
#endif /* DBCS */
};
static CODECONST(char *) rgszCTmplt[] = {
	"tmplteng.c", "tmpltdut.c", "tmpltspa.c", "tmpltswe.c", "tmpltnor.c", "tmpltice.c",
	"tmpltcyr.c", "tmpltcze.c", "tmplthun.c", "tmpltpol.c", "tmpltara.c", "tmplthew.c",
	"tmpltgre.c", "tmplttur.c"

#ifdef DBCS	/* johnta: Add the new Japanese sorting order */
	, "tmpltjpn.c"
#endif /* DBCS */
};
static CODECONST(char *) rgszCollNam[] = {
	"Eng", "Dut", "Spa", "Swe", "Nor", "Ice", "Cyr", "Cze", "Hun", "Pol", "Ara", "Hew", "Gre", "Tur"

#ifdef DBCS	/* johnta: Add the new Japanese sorting order */
	, "Jpn"
#endif /* DBCS */
};
static JET_SESID sesid;
static JET_DBID dbid;
static FILE *fhResults;

/*	non-table database data
*/
static CODECONST(char) szTblContainer[] = "Tables";
static CODECONST(char) szDbContainer[] = "Databases";
static CODECONST(char) szRcContainer[] = "Relationships";
static CODECONST(char) szDbObject[] = "MSysDb";

/*	MSysQueries data
*/
static CODECONST(char) szMSysQueries[] = "MSysQueries";

static CODECONST(char) szSqAttribute[] = "Attribute";
static CODECONST(char) szSqExpression[] =  "Expression";
static CODECONST(char) szSqFlag[] = "Flag";
static CODECONST(char) szSqName1[] = "Name1";
static CODECONST(char) szSqName2[] = "Name2";
static CODECONST(char) szSqObjectId[] = "ObjectId";
static CODECONST(char) szSqOrder[] = "Order";

/* MSysRelationships data 
 */
static CODECONST(char) szMSysRelationships[] = "MSysRelationships";

/*	MSysObjects data
*/
static CODECONST(char) szMSysObjects[] = "MSysObjects";

static JET_TABLEID tableidSo;

static CODECONST(char) szSoId[] = "Id";
static CODECONST(char) szSoParentId[] = "ParentId";
static CODECONST(char) szSoName[] = "Name";
static CODECONST(char) szSoType[] = "Type";
static CODECONST(char) szSoOwnerSID[] = "Owner";
static CODECONST(char) szSoFlags[] = "Flags";

static JET_COLUMNDEF columndefSoId;
static JET_COLUMNDEF columndefSoParentId;
static JET_COLUMNDEF columndefSoName;
static JET_COLUMNDEF columndefSoType;
static JET_COLUMNDEF columndefSoOwnerSID;
static JET_COLUMNDEF columndefSoFlags;


/*	MSysColumns data
*/
static CODECONST(char) szMSysColumns[] = "MSysColumns";

static JET_TABLEID tableidSc;

static CODECONST(char) szScObjectId[] = "ObjectId";
static CODECONST(char) szScName[] = "Name";
static CODECONST(char) szScFRestricted[] = "FRestricted";

static JET_COLUMNDEF columndefScObjectId;
static JET_COLUMNDEF columndefScName;
static JET_COLUMNDEF columndefScFRestricted;


/*	MSysIndexes data
*/
static CODECONST(char) szMSysIndexes[] = "MSysIndexes";


/*	MSysAccounts data
*/
static CODECONST(char) szMSysAccounts[] = "MSysAccounts";

static JET_TABLEID tableidSa;

static CODECONST(char) szSaName[] = "Name";
static CODECONST(char) szSaSID[] = "SID";
static CODECONST(char) szSaPassword[] = "Password";
static CODECONST(char) szSaFGroup[] = "FGroup";

static JET_COLUMNDEF columndefSaName;
static JET_COLUMNDEF columndefSaSID;
static JET_COLUMNDEF columndefSaPassword;
static JET_COLUMNDEF columndefSaFGroup;

static CODECONST(char) szSaIdxName[] = "Name";
static CODECONST(char) szSaIdxSID[] = "SID";

/*	MSysGroups data
*/
static CODECONST(char) szMSysGroups[] = "MSysGroups";

static JET_TABLEID tableidSg;

static CODECONST(char) szSgGroup[] = "GroupSID";
static CODECONST(char) szSgUser[] = "UserSID";

static JET_COLUMNDEF columndefSgGroup;
static JET_COLUMNDEF columndefSgUser;

static CODECONST(char) szSgIdxGroup[] = "GroupSID";
static CODECONST(char) szSgIdxUser[] = "UserSID";

/*	MSysACEs data
*/
static CODECONST(char) szMSysACEs[] = "MSysACEs";

static JET_TABLEID tableidSp;

static CODECONST(char) szSpObjectID[] = "ObjectId";
static CODECONST(char) szSpSID[] = "SID";
static CODECONST(char) szSpACM[] = "ACM";
static CODECONST(char) szSpFInheritable[] = "FInheritable";

static JET_COLUMNDEF columndefSpObjectID;
static JET_COLUMNDEF columndefSpSID;
static JET_COLUMNDEF columndefSpACM;
static JET_COLUMNDEF columndefSpFInheritable;


/*	forward function prototypes:
*/
STATIC void NEAR InstallSecurity(void);
STATIC void NEAR InstallSysQueries(void);

STATIC void NEAR ModifySysAccounts(void);
STATIC void NEAR ModifySysGroups(void);

STATIC void NEAR UpdateSysObjects(void);
STATIC void NEAR UpdateSysColumns(void);
STATIC void NEAR UpdateSysAccounts(void);
STATIC void NEAR UpdateSysGroups(void);
STATIC void NEAR UpdateSysACEs(void);
STATIC void NEAR UpdateSysQueries(void);

STATIC void NEAR ReportSecurity(char *szDatabaseName);

STATIC void NEAR PrintSysObjects(void);
STATIC void NEAR PrintSysColumns(void);
STATIC void NEAR PrintSysAccounts(void);
STATIC void NEAR PrintSysGroups(void);
STATIC void NEAR PrintSysACEs(void);
STATIC void NEAR FormatOutdata(OUTDATA *pout, JET_COLTYP coltyp);

STATIC void NEAR GatherColumnInfo(void);
STATIC void NEAR BuildIndata(INDATA *pin, const void *pv, JET_COLTYP coltyp);
STATIC void NEAR CreateQryObjects(OBJID *rgobjid);

STATIC void NEAR CreateCFile(int iCollate);


/*	MAIN: entry point and driver
*/

#ifdef	WINDOWS
void _cdecl main(void);

int _pascal WinMain(void)
	{
	main();
	return 0;
	}
#endif	/* WINDOWS */

void _cdecl main(void)
	{
	JET_ERR err;
	int i;

	/*	Open the report file
	*/
	fhResults = fopen("results.txt", "wt");

	/*	Begin the session...
	*/
	err = JetInit();
	Assert(err >= 0);

	err = JetBeginSession(&sesid, szAdminUser, szAdminPswd);
	Assert(err >= 0);

#ifndef ENG_ONLY
	for (i = 0; i < cCollate; i++)
#endif
		{
		/*	Try to create the system database for this collating sequence.
		 *  If it does not exist (which will be the case for the red engine),
		 *  it should be created properly.  If it does exist (which will be
		 *  the case with the blue engine), it should fail with an appropriate
		 * error value.
		 */

		err = JetCreateDatabase(sesid, rgszSystemMdb[i], rgszConnect[i], &dbid, JET_bitDbEncrypt);
		Assert(err >= 0 || err == JET_errDatabaseDuplicate);

		if (err == JET_errDatabaseDuplicate)
			JetOpenDatabase(sesid, rgszSystemMdb[i], "", &dbid, 0);

		/*	Install security data...
		*/
		InstallSecurity();

		/*	Report on security data...
		*/
		ReportSecurity(rgszSystemMdb[i]);

		err = JetCloseDatabase(sesid, dbid, 0);
		Assert(err >= 0);

		/*  Create compressed C arrays...
		 */

		CreateCFile(i);
		}

	/*	End the session...
	*/
	err = JetEndSession(sesid, 0);
	Assert(err >= 0);

	/*	Terminate...
	*/
	err = JetTerm();
	Assert(err >= 0);

	/*	Close the report file
	*/
	fclose(fhResults);
	}

/*  CreateCFile

	Creates a C file of the compressed version of the database as an
	array of bytes.
*/
#pragma optimize("", off)
STATIC void NEAR CreateCFile(int iCollate)
	{
	FILE	*fh;
	FILE	*sfh;
	WORD	cpage;
	WORD	ib;
	PGNO	pgno;
	long	cbWritten;
	long	cbArray;
	BYTE	rgbPageBuf[cbPageSize];

	struct _stat sfstat;

	if ((fh = fopen(rgszCTmplt[iCollate], "wt")) == NULL)
		return;
	if ((sfh = fopen(rgszSystemMdb[iCollate], "rb")) == NULL)
		return;

	_fstat(_fileno(sfh), &sfstat);
	cpage = (WORD)(sfstat.st_size / cbPageSize);	/* Cast ok because system databases are small */

	fprintf(fh, "\n/* %s Database Def */\n"
			"\n"
			"unsigned char far rgb%sSysDbDef[] = {\n"
			"\t0x%02X, 0x%02X,",
			rgszSystemMdb[iCollate], rgszCollNam[iCollate],
			cpage / 256, cpage % 256);

	cbWritten = 2;

	for (pgno = 0; pgno < cpage; pgno++)
		{
		BYTE *pb = rgbPageBuf;
		BYTE *pbTmp;
		int	cbRun;

		fread(rgbPageBuf, cbPageSize, 1, sfh);
		fprintf(fh, "\n\n\t/* Database Page %u */\n", pgno);

		ib = 8; /* Force new line. */

		while ((pb - rgbPageBuf) < cbPageSize)
			{
			cbRun = 1;
			if (*pb++ == 0)
				{
				while (((pb - rgbPageBuf) < cbPageSize) && (*pb == 0))
					{
					pb++;
					if (cbRun++ >= 127)
						break;
					}

				if (ib++ == 8)
					{
					fputc('\n', fh);
					fputc('\t', fh);
					ib = 1;
					}

					fprintf(fh, "0x%02X, ", cbRun-1);

					if (++cbWritten % 65536 == 0)
						fprintf(fh, "\n\t};\n\nunsigned char far rgb%sSysDbDef%ld[] = {\n", rgszCollNam[iCollate], cbWritten / 65536);
				}
			else
				{
				/* stop when we hit 2 consecutive 0s, */
				/* one 0 in last byte of page, or end of page */
				while ((pb - rgbPageBuf) < cbPageSize)
					{
					if (((pb - rgbPageBuf) < cbPageSize-1) &&
						((*pb == 0) && (*(pb+1) == 0)))
						break;
					else if (((pb - rgbPageBuf) == cbPageSize-1) && (*pb == 0))
						break;

					pb++;
					if (cbRun++ >= 127)
						break;
					}

				if (ib++ == 8)
					{
					fputc('\n', fh);
					fputc('\t', fh);
					ib = 1;
					}

				fprintf(fh, "0x%02X, ", (cbRun-1 | 128));

				if (++cbWritten % 65536 == 0)
					fprintf(fh, "\n\t};\n\nunsigned char far rgb%sSysDbDef%ld[] = {\n", rgszCollNam[iCollate], cbWritten / 65536);

				pbTmp = pb - cbRun;
				while (cbRun-- > 0)
					{
					if (ib++ == 8)
						{
						fputc('\n', fh);
						fputc('\t', fh);
						ib = 1;
						}

					fprintf(fh, "0x%02X, ", *pbTmp++);

					if (++cbWritten % 65536 == 0)
						fprintf(fh, "\n\t};\n\nunsigned char far rgb%sSysDbDef%ld[] = {\n", rgszCollNam[iCollate], cbWritten / 65536);
					}
				}
			}
		}

	fprintf(fh, "\n\t};\n"
			"\n"
			"unsigned char far *rgb%sSysDb[] = {rgb%sSysDbDef",
			rgszCollNam[iCollate], rgszCollNam[iCollate]);

	for (cbArray = 65536; cbArray < cbWritten; cbArray += 65536)
		fprintf(fh, ", rgb%sSysDbDef%ld", rgszCollNam[iCollate], cbArray / 65536);

	fprintf(fh, "};\n");

	fclose(fh);
	fclose(sfh);
	}

#pragma optimize("", on)
/*	InstallSecurity

	Installs security-related data in database.
*/

STATIC void NEAR InstallSecurity(void)
	{
	JET_ERR err;

	LgEnterCriticalSection( critJet );

	/*	Open/Create all affected tables...
	*/
	err = ErrDispCreateTable(sesid, dbid, szMSysAccounts, 1, 80, &tableidSa);
	Assert(err >= 0);
	err = ErrDispCreateTable(sesid, dbid, szMSysGroups, 1, 80, &tableidSg);
	Assert(err >= 0);

	/*	Make data dictionary modifications...
	*/
	ModifySysAccounts();
	ModifySysGroups();

	/*	Re-open tables...
	*/
	err = ErrDispOpenTable(sesid, dbid, &tableidSo, szMSysObjects, 0x80000000);
	Assert(err >= 0);
	err = ErrDispOpenTable(sesid, dbid, &tableidSc, szMSysColumns, 0x80000000);
	Assert(err >= 0);
	err = ErrDispOpenTable(sesid, dbid, &tableidSp, szMSysACEs, 0x80000000);
	Assert(err >= 0);

	/*	Gather all column information...
	*/
	GatherColumnInfo();

	/*  Update system queries...
	*/
	UpdateSysQueries();

	/*	Update security-related data in all tables...
	*/
	UpdateSysObjects();
	UpdateSysColumns();
	UpdateSysAccounts();
	UpdateSysGroups();
	UpdateSysACEs();

	/*	we're done, close the tables...
	*/
	err = ErrDispCloseTable(sesid, tableidSo);
	Assert(err >= 0);
	err = ErrDispCloseTable(sesid, tableidSc);
	Assert(err >= 0);
	err = ErrDispCloseTable(sesid, tableidSa);
	Assert(err >= 0);
	err = ErrDispCloseTable(sesid, tableidSg);
	Assert(err >= 0);
	err = ErrDispCloseTable(sesid, tableidSp);
	Assert(err >= 0);

	LgLeaveCriticalSection( critJet );
	}


/*	ModifySysAccounts

	Adds all columns for the table.
*/

STATIC void NEAR ModifySysAccounts(void)
	{
	JET_ERR 		err;
	INDATA		    in;
	JET_COLUMNDEF	columndef;
	JET_COLUMNID	columnid;
	long			cp;
	long			langid;
	long			wCountry;

	err = ErrDispGetDatabaseInfo(sesid, dbid, &cp, sizeof(cp), JET_DbInfoCp);
	Assert(err >= 0);
	err = ErrDispGetDatabaseInfo(sesid, dbid, &langid, sizeof(langid), JET_DbInfoLangid);
	Assert(err >= 0);
	err = ErrDispGetDatabaseInfo(sesid, dbid, &wCountry, sizeof(wCountry), JET_DbInfoCountry);
	Assert(err >= 0);

	/*	create all columns for the table...
	*/
	columndef.cbStruct = sizeof(columndef);
	columndef.coltyp = JET_coltypText;
	columndef.cp = (short)cp;
	columndef.langid = (short)langid;
	columndef.wCountry = (short)wCountry;
	columndef.wCollate = 0;
	columndef.cbMax = 30;
	columndef.grbit = 0;
	err = ErrDispAddColumn(sesid, tableidSa, szSaName, &columndef, NULL, 0, &columnid);
	Assert(err >= 0);

	columndef.cbStruct = sizeof(columndef);
	columndef.coltyp = JET_coltypBinary;
	columndef.cbMax = 0;
	columndef.grbit = 0;
	err = ErrDispAddColumn(sesid, tableidSa, szSaSID, &columndef, NULL, 0, &columnid);
	Assert(err >= 0);

	columndef.cbStruct = sizeof(columndef);
	columndef.coltyp = JET_coltypBinary;
	columndef.cbMax = 0;
	columndef.grbit = 0;
	err = ErrDispAddColumn(sesid, tableidSa, szSaPassword, &columndef, NULL, 0, &columnid);
	Assert(err >= 0);

	columndef.cbStruct = sizeof(columndef);
	columndef.coltyp = JET_coltypBit;
	columndef.cbMax = 0;
	columndef.grbit = 0;
	err = ErrDispAddColumn(sesid, tableidSa, szSaFGroup, &columndef, NULL, 0, &columnid);
	Assert(err >= 0);

	/*	create the index on the Name column...
	*/
	in.pb = rgbBuf;
	rgbBuf[0] = chPlus;
	in.cb = 1;
	strcpy((char *) rgbBuf+1, szSaName);
	in.cb += (strlen(szSaName)+1);
	rgbBuf[in.cb] = chZero;
	in.cb++;
	err = ErrDispCreateIndex(sesid, tableidSa, szSaIdxName, JET_bitIndexUnique, in.pb, in.cb, 80);
	Assert(err >= 0);

	/*	create the index on the SID column...
	*/
	in.pb = rgbBuf;
	rgbBuf[0] = chPlus;
	in.cb = 1;
	strcpy((char *) rgbBuf+1, szSaSID);
	in.cb += (strlen(szSaSID)+1);
	rgbBuf[in.cb] = chZero;
	in.cb++;
	err = ErrDispCreateIndex(sesid, tableidSa, szSaIdxSID, JET_bitIndexUnique, in.pb, in.cb, 80);
	Assert(err >= 0);
	}


/*	ModifySysGroups

	Adds all columns for the table.
*/

STATIC void NEAR ModifySysGroups(void)
	{
	JET_ERR 		err;
	INDATA		    in;
	JET_COLUMNDEF	columndef;
	JET_COLUMNID	columnid;

	/*	create all columns for the table...
	*/
	columndef.cbStruct = sizeof(columndef);
	columndef.coltyp = JET_coltypBinary;
	columndef.cbMax = 0;
	columndef.grbit = 0;
	err = ErrDispAddColumn(sesid, tableidSg, szSgGroup, &columndef, NULL, 0, &columnid);
	Assert(err >= 0);

	columndef.cbStruct = sizeof(columndef);
	columndef.coltyp = JET_coltypBinary;
	columndef.cbMax = 0;
	columndef.grbit = 0;
	err = ErrDispAddColumn(sesid, tableidSg, szSgUser, &columndef, NULL, 0, &columnid);
	Assert(err >= 0);

	/*	create the index on the GroupSID column...
	*/
	in.pb = rgbBuf;
	rgbBuf[0] = chPlus;
	in.cb = 1;
	strcpy((char *) rgbBuf+1, szSgGroup);
	in.cb += (strlen(szSgGroup)+1);
	rgbBuf[in.cb] = chZero;
	in.cb++;
	err = ErrDispCreateIndex(sesid, tableidSg, szSgIdxGroup, 0, in.pb, in.cb, 80);
	Assert(err >= 0);

	/*	create the index on the UserSID column...
	*/
	in.pb = rgbBuf;
	rgbBuf[0] = chPlus;
	in.cb = 1;
	strcpy((char *) rgbBuf+1, szSgUser);
	in.cb += (strlen(szSgUser)+1);
	rgbBuf[in.cb] = chZero;
	in.cb++;
	err = ErrDispCreateIndex(sesid, tableidSg, szSgIdxUser, 0, in.pb, in.cb, 80);
	Assert(err >= 0);
	}

/*  Create objects in MSysObjects for each system query
	Set the objtyp to JET_objtypQuery and return array of objids.
*/
STATIC void NEAR CreateQryObjects(OBJID *rgobjid)
	{
	JET_ERR err;
	unsigned irg;
	unsigned long cbActual;
	JET_OBJTYP objtypQry = JET_objtypQuery;

	/*  Add new object using JetCreateObject with objtypClientMin 
	*/

	for (irg = 0; irg < cqryMax; irg++)
		{
		LgLeaveCriticalSection( critJet );
		err = JetCreateObject(sesid, dbid, szTblContainer, rgszSysQry[irg], JET_objtypClientMin);
		LgEnterCriticalSection( critJet );
		Assert(err >= 0);
		}

	/*	collect OBJIDs for new queries, using the
		SoName <SoParentId:UnsignedLong, SoName:Text> index...
	*/

	err = ErrDispSetCurrentIndex(sesid, tableidSo, szIdxSoName);
	Assert(err >= 0);

	for (irg = 0; irg < cqryMax; irg++)
		{
		*(unsigned long *)rgbBuf = (unsigned long) objidTblContainer;
		err = ErrDispMakeKey(sesid, tableidSo, rgbBuf, sizeof(unsigned long), JET_bitNewKey);
		Assert(err >= 0);

		err = ErrDispMakeKey(sesid, tableidSo, rgszSysQry[irg], strlen(rgszSysQry[irg]), 0UL);
		Assert(err >= 0);

		err = ErrDispSeek(sesid, tableidSo, JET_bitSeekEQ);
		Assert(err >= 0);

		err = ErrDispRetrieveColumn(sesid, tableidSo, columndefSoId.columnid, &rgobjid[irg], sizeof(rgobjid[irg]), &cbActual, 0L, NULL);
		Assert(err >= 0);
		Assert(cbActual == sizeof(rgobjid[irg]));

		/* 	Reset objtyp to objtypQuery using direct MSysObjectsAccess
		*/
		err = ErrDispPrepareUpdate(sesid, tableidSo, JET_prepReplace);
		Assert(err >= 0);

		err = ErrDispSetColumn(sesid, tableidSo, columndefSoType.columnid, &objtypQry, sizeof (short), 0, NULL);
		Assert(err >= 0);

		err = ErrDispUpdate(sesid, tableidSo, NULL, 0, NULL);
		Assert(err >= 0);
		}
	}
		

/*	UpdateSysQueries

	Installs system-related queries in database.
*/

STATIC void NEAR UpdateSysQueries(void)
	{
	JET_ERR err;
	JET_TABLEID tableidSq;
	JET_COLUMNDEF columndefSqAttribute;
	JET_COLUMNDEF columndefSqExpression;
	JET_COLUMNDEF columndefSqFlag;
	JET_COLUMNDEF columndefSqName1;
	JET_COLUMNDEF columndefSqName2;
	JET_COLUMNDEF columndefSqObjectId;
	JET_COLUMNDEF columndefSqOrder;
	OBJID rgobjid[cqryMax];
	unsigned int iqryrow;
	unsigned int iobjid;
	OBJID objidPrev;
	OBJID objidNew;


	/*  Create objects in MSysObjects for each system query...
	*/
	CreateQryObjects(rgobjid);

	/*	Open MSysQueries
	*/
	err = ErrDispOpenTable(sesid, dbid, &tableidSq, szMSysQueries, 0x80000000);
	Assert(err >= 0);

	/*	Get column information for MSysQueries columns...
	*/
	err = ErrDispGetTableColumnInfo(sesid, tableidSq, szSqAttribute, &columndefSqAttribute, sizeof(JET_COLUMNDEF), 0L);
	Assert(err >= 0);

	err = ErrDispGetTableColumnInfo(sesid, tableidSq, szSqExpression, &columndefSqExpression, sizeof(JET_COLUMNDEF), 0L);
	Assert(err >= 0);

	err = ErrDispGetTableColumnInfo(sesid, tableidSq, szSqFlag, &columndefSqFlag, sizeof(JET_COLUMNDEF), 0L);
	Assert(err >= 0);

	err = ErrDispGetTableColumnInfo(sesid, tableidSq, szSqName1, &columndefSqName1, sizeof(JET_COLUMNDEF), 0L);
	Assert(err >= 0);

	err = ErrDispGetTableColumnInfo(sesid, tableidSq, szSqName2, &columndefSqName2, sizeof(JET_COLUMNDEF), 0L);
	Assert(err >= 0);

	err = ErrDispGetTableColumnInfo(sesid, tableidSq, szSqObjectId, &columndefSqObjectId, sizeof(JET_COLUMNDEF), 0L);
	Assert(err >= 0);

	err = ErrDispGetTableColumnInfo(sesid, tableidSq, szSqOrder, &columndefSqOrder, sizeof(JET_COLUMNDEF), 0L);
	Assert(err >= 0);

	/* Set all fields in MSysQueries from global QRYROW array...
	*/

	objidPrev = rgqryrow[0].ObjectId;
	objidNew = rgobjid[0];

	for (iqryrow = 0, iobjid = 0; iqryrow < cqryrowMax; iqryrow++)
		{
		/* test to see if this is row for next query
		*/
		if (objidPrev != rgqryrow[iqryrow].ObjectId)
			{
			/* Use objid from rgobjid, NOT from global qryrow struct
			*/
			iobjid++;
			objidNew = rgobjid[iobjid];
			objidPrev = rgqryrow[iqryrow].ObjectId;
			Assert(iobjid < cqryMax);
			}

		/* append records to MSysQueries...
		*/				

		err = ErrDispPrepareUpdate(sesid, tableidSq, JET_prepInsert);
		Assert(err >= 0);

		err = ErrDispSetColumn(sesid, tableidSq, columndefSqAttribute.columnid, &(rgqryrow[iqryrow].Attribute), sizeof(unsigned char), 0, NULL);
		Assert(err >= 0);

		if (rgqryrow[iqryrow].szExpression[0] != 0)
			{
			err = ErrDispSetColumn(sesid, tableidSq, columndefSqExpression.columnid,
				rgqryrow[iqryrow].szExpression,
				strlen(rgqryrow[iqryrow].szExpression), 0, NULL);
			Assert(err >= 0);
			}

		if (rgqryrow[iqryrow].szName1[0] != 0)
			{
			err = ErrDispSetColumn(sesid, tableidSq, columndefSqName1.columnid,
				rgqryrow[iqryrow].szName1,
				strlen(rgqryrow[iqryrow].szName1), 0, NULL);
			Assert(err >= 0);
			}

		if (rgqryrow[iqryrow].szName2[0] != 0)
			{
			err = ErrDispSetColumn(sesid, tableidSq, columndefSqName2.columnid,
				rgqryrow[iqryrow].szName2,
				strlen(rgqryrow[iqryrow].szName2), 0, NULL);
			Assert(err >= 0);
			}

		if (rgqryrow[iqryrow].Flag != -1)
			{
			err = ErrDispSetColumn(sesid, tableidSq, columndefSqFlag.columnid, &(rgqryrow[iqryrow].Flag), sizeof(short), 0, NULL);
			Assert(err >= 0);
			}

		err = ErrDispSetColumn(sesid, tableidSq, columndefSqObjectId.columnid, &(objidNew), sizeof(OBJID), 0, NULL);
		Assert(err >= 0);

		err = ErrDispSetColumn(sesid, tableidSq, columndefSqOrder.columnid, rgqryrow[iqryrow].szOrder, cbOrderMax, 0, NULL);
		Assert(err >= 0);

		err = ErrDispUpdate(sesid, tableidSq, NULL, 0, NULL);
		Assert(err >= 0);
		}

	err = ErrDispCloseTable(sesid, tableidSq);
	Assert(err >= 0);
	}


/*	UpdateSysObjects

	Updates all table data to reflect a proper unsecured state.
*/

STATIC void NEAR UpdateSysObjects(void)
	{
	JET_ERR err;
	unsigned long flags;

	/* CONSIDER: Everything except MSysAccounts and */
	/* CONSIDER: MSysGroups is owned by 'Engine'. */

	/*	don't care about current index; move to first
		record and process the table serially...
	*/
	err = ErrDispSetCurrentIndex(sesid, tableidSo, NULL);
	Assert(err >= 0);
	err = ErrDispMove(sesid, tableidSo, JET_MoveFirst, 0UL);
	Assert(err >= 0);

	flags = JET_bitObjectSystem;

	do
		{
		/* For all objects, set Owner to 'Engine' and set System Object bit */

		err = ErrDispPrepareUpdate(sesid, tableidSo, JET_prepReplace);
		Assert(err >= 0);

		err = ErrDispSetColumn(sesid, tableidSo, columndefSoOwnerSID.columnid, sidEngine, cbsidEngine, 0, NULL);
		Assert(err >= 0);

		err = ErrDispSetColumn(sesid, tableidSo, columndefSoFlags.columnid, &flags, sizeof(flags), 0, NULL);
		Assert(err >= 0);

		err = ErrDispUpdate(sesid, tableidSo, NULL, 0, NULL);
		Assert(err >= 0);
		} while (ErrDispMove(sesid, tableidSo, JET_MoveNext, 0UL) >= 0);
	}


/*	UpdateSysColumns

	Updates all table data to reflect a proper unsecured state.
*/
STATIC void NEAR UpdateSysColumns(void)
	{
	JET_ERR err;
	unsigned long cbActual;
#define irgSo	0
#define irgSc	1
#define irgSa	2
#define irgSg	3
#define irgSp	4
#define irgMax	5
	static CODECONST(CODECONST(char) *) rgszSysTbl[irgMax] =
		{
		szMSysObjects, szMSysColumns, szMSysAccounts,
		szMSysGroups, szMSysACEs
		};
	OBJID rgobjid[irgMax];
	unsigned irg;
typedef struct	/* Denied (Restricted) Column Description */
	{
	unsigned irg;		       /* irg into rgobjid */
	CODECONST(char) *szCol;        /* column name */
	} DCD;
	static CODECONST(DCD) rgdcd[] =
		{
		{irgSa, szSaPassword},
		{irgSp, szSpACM}
		};
#define idcdMax (sizeof(rgdcd)/sizeof(DCD))
	unsigned idcd;

	/*	collect OBJIDs for system tables, using the
		SoName <SoParentId:UnsignedLong, SoName:Text> index...
	*/
	err = ErrDispSetCurrentIndex(sesid, tableidSo, szIdxSoName);
	Assert(err >= 0);
	for (irg = 0; irg < irgMax; irg++)
		{
		*(unsigned long *)rgbBuf = (unsigned long) objidTblContainer;
		err = ErrDispMakeKey(sesid, tableidSo, rgbBuf, sizeof(unsigned long), JET_bitNewKey);
		Assert(err >= 0);

		err = ErrDispMakeKey(sesid, tableidSo, rgszSysTbl[irg], strlen(rgszSysTbl[irg]), 0UL);
		Assert(err >= 0);

		err = ErrDispSeek(sesid, tableidSo, JET_bitSeekEQ);
		Assert(err >= 0);

		err = ErrDispRetrieveColumn(sesid, tableidSo, columndefSoId.columnid, &rgobjid[irg], sizeof(rgobjid[irg]), &cbActual, 0L, NULL);
		Assert(err >= 0);
		Assert(cbActual == sizeof(rgobjid[irg]));
		}

	/*	update FRestricted columns of SysColumns records,
		using the ScName <ScObjectId:UnsignedLong, ScName:Text> index...
	*/
	err = ErrDispSetCurrentIndex(sesid, tableidSc, szIdxScName);
	Assert(err >= 0);
	for (idcd = 0; idcd < idcdMax; idcd++)
		{
		err = ErrDispMakeKey(sesid, tableidSc, &rgobjid[rgdcd[idcd].irg], sizeof(rgobjid[rgdcd[idcd].irg]), JET_bitNewKey);
		Assert(err >= 0);

		err = ErrDispMakeKey(sesid, tableidSc, rgdcd[idcd].szCol, strlen(rgdcd[idcd].szCol), 0UL);
		Assert(err >= 0);

		err = ErrDispSeek(sesid, tableidSc, JET_bitSeekEQ);
		Assert(err >= 0);

		err = ErrDispPrepareUpdate(sesid, tableidSc, JET_prepReplace);
		Assert(err >= 0);

		err = ErrDispSetColumn(sesid, tableidSc, columndefScFRestricted.columnid, &chTrue, sizeof(chTrue), 0, NULL);
		Assert(err >= 0);

		err = ErrDispUpdate(sesid, tableidSc, NULL, 0, NULL);
		Assert(err >= 0);
		}
#undef irgSo
#undef irgSc
#undef irgSa
#undef irgSg
#undef irgSp
#undef irgMax
#undef idcdMax
	}


/*	UpdateSysAccounts

	Updates all table data to reflect a proper unsecured state.
*/

STATIC void NEAR UpdateSysAccounts(void)
	{
	OUTDATA out;
	JET_ERR err;

	/*	Build row for 'Admins' group
	*/
	err = ErrDispPrepareUpdate(sesid, tableidSa, JET_prepInsert);
	Assert(err >= 0);
	err = ErrDispSetColumn(sesid, tableidSa, columndefSaName.columnid, szAdmins, sizeof(szAdmins)-1, 0, NULL);
	Assert(err >= 0);
	err = ErrDispSetColumn(sesid, tableidSa, columndefSaSID.columnid, sidAdmins, cbsidAdmins, 0, NULL);
	Assert(err >= 0);
	err = ErrDispSetColumn(sesid, tableidSa, columndefSaFGroup.columnid, &chTrue, sizeof(chTrue), 0, NULL);
	Assert(err >= 0);
	err = ErrDispUpdate(sesid, tableidSa, NULL, 0, NULL);
	Assert(err >= 0);

	/*	Build row for 'Users' group
	*/
	err = ErrDispPrepareUpdate(sesid, tableidSa, JET_prepInsert);
	Assert(err >= 0);
	err = ErrDispSetColumn(sesid, tableidSa, columndefSaName.columnid, szUsers, sizeof(szUsers)-1, 0, NULL);
	Assert(err >= 0);
	err = ErrDispSetColumn(sesid, tableidSa, columndefSaSID.columnid, sidUsers, cbsidUsers, 0, NULL);
	Assert(err >= 0);
	err = ErrDispSetColumn(sesid, tableidSa, columndefSaFGroup.columnid, &chTrue, sizeof(chTrue), 0, NULL);
	Assert(err >= 0);
	err = ErrDispUpdate(sesid, tableidSa, NULL, 0, NULL);
	Assert(err >= 0);

	/*	Build row for 'Guests' group
	*/
	err = ErrDispPrepareUpdate(sesid, tableidSa, JET_prepInsert);
	Assert(err >= 0);
	err = ErrDispSetColumn(sesid, tableidSa, columndefSaName.columnid, szGuests, sizeof(szGuests)-1, 0, NULL);
	Assert(err >= 0);
	err = ErrDispSetColumn(sesid, tableidSa, columndefSaSID.columnid, sidGuests, cbsidGuests, 0, NULL);
	Assert(err >= 0);
	err = ErrDispSetColumn(sesid, tableidSa, columndefSaFGroup.columnid, &chTrue, sizeof(chTrue), 0, NULL);
	Assert(err >= 0);
	err = ErrDispUpdate(sesid, tableidSa, NULL, 0, NULL);
	Assert(err >= 0);

	/*	Build row for 'Engine' user
	*/
	err = ErrDispPrepareUpdate(sesid, tableidSa, JET_prepInsert);
	Assert(err >= 0);
	err = ErrDispSetColumn(sesid, tableidSa, columndefSaName.columnid, szEngine, sizeof(szEngine)-1, 0, NULL);
	Assert(err >= 0);
	err = ErrDispSetColumn(sesid, tableidSa, columndefSaSID.columnid, sidEngine, cbsidEngine, 0, NULL);
	Assert(err >= 0);
	err = ErrDispSetColumn(sesid, tableidSa, columndefSaFGroup.columnid, &chFalse, sizeof(chFalse), 0, NULL);
	Assert(err >= 0);
	err = ErrDispUpdate(sesid, tableidSa, NULL, 0, NULL);
	Assert(err >= 0);

	/*	Build row for 'Creator' user
	*/
	err = ErrDispPrepareUpdate(sesid, tableidSa, JET_prepInsert);
	Assert(err >= 0);
	err = ErrDispSetColumn(sesid, tableidSa, columndefSaName.columnid, szCreator, sizeof(szCreator)-1, 0, NULL);
	Assert(err >= 0);
	err = ErrDispSetColumn(sesid, tableidSa, columndefSaSID.columnid, sidCreator, cbsidCreator, 0, NULL);
	Assert(err >= 0);
	err = ErrDispSetColumn(sesid, tableidSa, columndefSaFGroup.columnid, &chFalse, sizeof(chFalse), 0, NULL);
	Assert(err >= 0);
	err = ErrDispUpdate(sesid, tableidSa, NULL, 0, NULL);
	Assert(err >= 0);

	/*	Build row for 'admin' user
	*/
	err = ErrDispPrepareUpdate(sesid, tableidSa, JET_prepInsert);
	Assert(err >= 0);
	err = ErrDispSetColumn(sesid, tableidSa, columndefSaName.columnid, szAdminUser, sizeof(szAdminUser)-1, 0, NULL);
	Assert(err >= 0);
	err = ErrDispSetColumn(sesid, tableidSa, columndefSaSID.columnid, sidAdminUser, cbsidAdminUser, 0, NULL);
	Assert(err >= 0);
	SecEncryptPassword(szAdminPswd, rgbBuf, &out.cbActual);
	err = ErrDispSetColumn(sesid, tableidSa, columndefSaPassword.columnid, rgbBuf, out.cbActual, 0, NULL);
	Assert(err >= 0);
	err = ErrDispSetColumn(sesid, tableidSa, columndefSaFGroup.columnid, &chFalse, sizeof(chFalse), 0, NULL);
	Assert(err >= 0);
	err = ErrDispUpdate(sesid, tableidSa, NULL, 0, NULL);
	Assert(err >= 0);

	/*	Build row for 'guest' user
	*/
	err = ErrDispPrepareUpdate(sesid, tableidSa, JET_prepInsert);
	Assert(err >= 0);
	err = ErrDispSetColumn(sesid, tableidSa, columndefSaName.columnid, szGuestUser, sizeof(szGuestUser)-1, 0, NULL);
	Assert(err >= 0);
	err = ErrDispSetColumn(sesid, tableidSa, columndefSaSID.columnid, sidGuestUser, cbsidGuestUser, 0, NULL);
	Assert(err >= 0);
	SecEncryptPassword(szGuestPswd, rgbBuf, &out.cbActual);
	err = ErrDispSetColumn(sesid, tableidSa, columndefSaPassword.columnid, rgbBuf, out.cbActual, 0, NULL);
	Assert(err >= 0);
	err = ErrDispSetColumn(sesid, tableidSa, columndefSaFGroup.columnid, &chFalse, sizeof(chFalse), 0, NULL);
	Assert(err >= 0);
	err = ErrDispUpdate(sesid, tableidSa, NULL, 0, NULL);
	Assert(err >= 0);
	}


/*	UpdateSysGroups

	Updates all table data to reflect a proper unsecured state.
*/

STATIC void NEAR UpdateSysGroups(void)
	{
	JET_ERR err;

	/*	Build row for 'Admins/admin'
	*/
	err = ErrDispPrepareUpdate(sesid, tableidSg, JET_prepInsert);
	Assert(err >= 0);
	err = ErrDispSetColumn(sesid, tableidSg, columndefSgGroup.columnid, sidAdmins, cbsidAdmins, 0, NULL);
	Assert(err >= 0);
	err = ErrDispSetColumn(sesid, tableidSg, columndefSgUser.columnid, sidAdminUser, cbsidAdminUser, 0, NULL);
	Assert(err >= 0);
	err = ErrDispUpdate(sesid, tableidSg, NULL, 0, NULL);
	Assert(err >= 0);

	/*	Build row for 'Users/admin'
	*/
	err = ErrDispPrepareUpdate(sesid, tableidSg, JET_prepInsert);
	Assert(err >= 0);
	err = ErrDispSetColumn(sesid, tableidSg, columndefSgGroup.columnid, sidUsers, cbsidUsers, 0, NULL);
	Assert(err >= 0);
	err = ErrDispSetColumn(sesid, tableidSg, columndefSgUser.columnid, sidAdminUser, cbsidAdminUser, 0, NULL);
	Assert(err >= 0);
	err = ErrDispUpdate(sesid, tableidSg, NULL, 0, NULL);
	Assert(err >= 0);

	/*	Build row for 'Guests/guest'
	*/
	err = ErrDispPrepareUpdate(sesid, tableidSg, JET_prepInsert);
	Assert(err >= 0);
	err = ErrDispSetColumn(sesid, tableidSg, columndefSgGroup.columnid, sidGuests, cbsidGuests, 0, NULL);
	Assert(err >= 0);
	err = ErrDispSetColumn(sesid, tableidSg, columndefSgUser.columnid, sidGuestUser, cbsidGuestUser, 0, NULL);
	Assert(err >= 0);
	err = ErrDispUpdate(sesid, tableidSg, NULL, 0, NULL);
	Assert(err >= 0);
	}


/*	UpdateSysACEs

	Updates all table data to reflect a proper unsecured state.
*/

STATIC void NEAR UpdateSysACEs(void)
	{
	INDATA in;
	OUTDATA outKey;
	OUTDATA out;
	JET_ERR err;
#define irgSo	0
#define irgSc	1
#define irgSi	2
#define irgSp	3
#define irgSq	4
#define	irgSr	5	/* relationships */
#define irgSa	6
#define irgSg	7
#define irgTc	8	/* table container */
#define irgDc	9	/* database container */
#define	irgRc	10	/* relationships container */
#define irgDb	11	/* database object */
#define irgQu	12	/* MSysUserList query */
#define irgQg	13	/* MSysGroupList query */
#define irgQm	14	/* MSysUserMemberships query */
#define irgMax	15
	static CODECONST(CODECONST(char) *) rgszSysTbl[irgMax] =
		{
		szMSysObjects,	szMSysColumns,	szMSysIndexes,
		szMSysACEs,	szMSysQueries,	szMSysRelationships,
		szMSysAccounts, szMSysGroups,	
		szTblContainer, szDbContainer, szRcContainer,
		szDbObject, szMSysUserList, szMSysGroupList, 
		szMSysUserMemberships
		};
	static CODECONST(OBJID) rgobjidParentId[irgMax] =
		{
		objidTblContainer, objidTblContainer, objidTblContainer,
		objidTblContainer, objidTblContainer, objidTblContainer,
		objidTblContainer, objidTblContainer, 
		objidRoot,	       objidRoot,		  objidRoot,
		objidDbContainer,  objidTblContainer, objidTblContainer,
		objidTblContainer
		};
	unsigned long rgObjectID[irgMax];
	unsigned short irg;

typedef struct	/* ACE Description */
	{
	unsigned short irg;		     /* irg into rgObjectID */
	const unsigned char __near *sid;     /* SID */
	unsigned short cbsid;		     /* size of SID */
	unsigned fInheritable;		     /* is ACE inheritable? */
	JET_ACM acm;			     /* ACM */
	} ACE;

static CODECONST(ACE) rgace[] =
	{
		{irgSo, sidAdmins, cbsidAdmins, fFalse,
			(
			JET_acmReadControl |
			JET_acmWriteDac
		       )
		},
		{irgSc, sidAdmins, cbsidAdmins, fFalse,
			(
			JET_acmReadControl |
			JET_acmWriteDac
		       )
		},
		{irgSi, sidAdmins, cbsidAdmins, fFalse,
			(
			JET_acmReadControl |
			JET_acmWriteDac
		       )
		},
		{irgSp, sidAdmins, cbsidAdmins, fFalse,
			(
			JET_acmReadControl |
			JET_acmWriteDac
		       )
		},
		{irgSq, sidAdmins, cbsidAdmins, fFalse,
			(
			JET_acmReadControl |
			JET_acmWriteDac
		       )
		},
		{irgSr, sidAdmins, cbsidAdmins, fFalse,
			(
			JET_acmReadControl |
			JET_acmWriteDac
		       )
		},
		{irgSa, sidAdmins, cbsidAdmins, fFalse,
			(
			JET_acmReadControl |
			JET_acmWriteDac |
			JET_acmTblReadDef |
			JET_acmTblRetrieveData |
			JET_acmTblInsertData |
			JET_acmTblReplaceData |
			JET_acmTblDeleteData |
			JET_acmTblAccessRcols
		       )
		},
		{irgSa, sidEngine, cbsidEngine, fFalse,
			(
			JET_acmTblReadDef |
			JET_acmTblRetrieveData 
		       )
		},
		{irgSg, sidAdmins, cbsidAdmins, fFalse,
			(
			JET_acmReadControl |
			JET_acmWriteDac |
			JET_acmTblReadDef |
			JET_acmTblRetrieveData |
			JET_acmTblInsertData |
			JET_acmTblReplaceData |
			JET_acmTblDeleteData |
			JET_acmTblAccessRcols
		       )
		},
		{irgSg, sidEngine, cbsidEngine, fFalse,
			(
			JET_acmTblReadDef |
			JET_acmTblRetrieveData 
		       )
		},
/* Removed because JetCreateDatabase does this for free.
** Enable this if ErrIsamCreateDatabase is used instead.
		{irgTc, sidCreator, cbsidCreator, fTrue,
			(
			JET_acmReadControl |
			JET_acmWriteDac |
			JET_acmWriteOwner |
			JET_acmDelete |
			JET_acmTblReadDef |
			JET_acmTblWriteDef |
			JET_acmTblRetrieveData |
			JET_acmTblInsertData |
			JET_acmTblReplaceData |
			JET_acmTblDeleteData |
			JET_acmTblAccessRcols
			)
		},
*/
		{irgTc, sidAdmins, cbsidAdmins, fFalse,
			(
			JET_acmReadControl |
			JET_acmWriteDac |
			JET_acmTblCreate
			)
		},
		{irgRc, sidAdmins, cbsidAdmins, fFalse,
			(
			JET_acmReadControl |
			JET_acmWriteDac |
			JET_acmTblCreate
			)
		},
		{irgDc, sidAdmins, cbsidAdmins, fFalse,
			(
			JET_acmReadControl |
			JET_acmWriteDac |
			JET_acmDbCreate
			)
		},
		{irgDc, sidUsers, cbsidUsers, fFalse,
			(
			JET_acmDbCreate
			)
		},
		{irgDc, sidGuests, cbsidGuests, fFalse,
			(
			JET_acmDbCreate
			)
		},
		{irgDb, sidAdmins, cbsidAdmins, fFalse,
			(
			JET_acmReadControl |
			JET_acmWriteDac
			)
		},
		{irgQu, sidAdmins, cbsidAdmins, fFalse,
			(
			JET_acmTblReadDef |
			JET_acmTblRetrieveData 
			)
		},
/* Removed because JetCreateObject supplies these and more
** Enable if ErrIsamCreateObject is used instead
		{irgQu, sidUsers, cbsidUsers, fFalse,
			(
			JET_acmTblReadDef |
			JET_acmTblRetrieveData 
			)
		},
		{irgQu, sidGuests, cbsidGuests, fFalse,
			(
			JET_acmTblReadDef |
			JET_acmTblRetrieveData 
			)
		},
*/
		{irgQg, sidAdmins, cbsidAdmins, fFalse,
			(
			JET_acmTblReadDef |
			JET_acmTblRetrieveData 
			)
		},
/* Removed because JetCreateObject supplies these and more
** Enable if ErrIsamCreateObject is used instead
		{irgQg, sidUsers, cbsidUsers, fFalse,
			(
			JET_acmTblReadDef |
			JET_acmTblRetrieveData 
			)
		},
		{irgQg, sidGuests, cbsidGuests, fFalse,
			(
			JET_acmTblReadDef |
			JET_acmTblRetrieveData 
			)
		},
*/
		{irgQm, sidAdmins, cbsidAdmins, fFalse,
			(
			JET_acmTblReadDef |
			JET_acmTblRetrieveData 
			)
		}
/* Removed because JetCreateObject supplies these and more
** Enable if ErrIsamCreateObject is used instead
		{irgQm, sidUsers, cbsidUsers, fFalse,
			(
			JET_acmTblReadDef |
			JET_acmTblRetrieveData 
			)
		},
		{irgQm, sidGuests, cbsidGuests, fFalse,
			(
			JET_acmTblReadDef |
			JET_acmTblRetrieveData 
			)
		}
*/
	};

#define iaceMax (sizeof(rgace) / sizeof(ACE))

	unsigned short iace;

	outKey.pb = &rgbKey[0];
	outKey.cbMax = cbBufMax;

	/*	collect ObjectIDs for all objects, using the
		SoName <SoParentId:UnsignedLong, SoName:Text> index...
	*/
	err = ErrDispSetCurrentIndex(sesid, tableidSo, szIdxSoName);
	Assert(err >= 0);
	for (irg = 0; irg < irgMax; irg++)
		{
		*(unsigned long *)rgbBuf = rgobjidParentId[irg];
		err = ErrDispMakeKey(sesid, tableidSo, rgbBuf, sizeof(unsigned long), JET_bitNewKey);
		Assert(err >= 0);
		err = ErrDispMakeKey(sesid, tableidSo, rgszSysTbl[irg], strlen(rgszSysTbl[irg]), 0UL);
		Assert(err >= 0);
		err = ErrDispSeek(sesid, tableidSo, JET_bitSeekEQ);
		Assert(err >= 0);
		out.cbMax = sizeof(unsigned long);
		out.pb = &rgObjectID[irg];
		err = ErrDispRetrieveColumn(sesid, tableidSo, columndefSoId.columnid, out.pb, out.cbMax, &out.cbActual, 0L, NULL);
		Assert(err >= 0);
		}

	Assert(rgObjectID[irgTc] == (unsigned long) objidTblContainer);
	Assert(rgObjectID[irgDc] == (unsigned long) objidDbContainer);
	Assert(rgObjectID[irgRc] == (unsigned long) objidRcContainer);
	Assert(rgObjectID[irgDb] == (unsigned long) objidDbObject);

	/*	go add all records to MSysACEs...
	*/
	for (iace = 0; iace < iaceMax; iace++)
		{
		err = ErrDispPrepareUpdate(sesid, tableidSp, JET_prepInsert);
		Assert(err >= 0);

		/*	set the 'ObjectID' column properly...
		*/
		BuildIndata(&in, &rgObjectID[rgace[iace].irg], columndefSpObjectID.coltyp);
		err = ErrDispSetColumn(sesid, tableidSp, columndefSpObjectID.columnid, in.pb, in.cb, 0, NULL);
		Assert(err >= 0);

		/*	set the 'SID' column properly...
		*/
		BuildIndata(&in, rgace[iace].sid, columndefSpSID.coltyp);
		in.cb = rgace[iace].cbsid;
		err = ErrDispSetColumn(sesid, tableidSp, columndefSpSID.columnid, in.pb, in.cb, 0, NULL);
		Assert(err >= 0);

		/*	set the 'ACM' column properly...
		*/
		BuildIndata(&in, &rgace[iace].acm, columndefSpACM.coltyp);
		err = ErrDispSetColumn(sesid, tableidSp, columndefSpACM.columnid, in.pb, in.cb, 0, NULL);
		Assert(err >= 0);

		/*	set the 'FInheritable' column properly...
		*/
		BuildIndata(&in, &rgace[iace].fInheritable, columndefSpFInheritable.coltyp);
		err = ErrDispSetColumn(sesid, tableidSp, columndefSpFInheritable.columnid, in.pb, in.cb, 0, NULL);
		Assert(err >= 0);

		/*	insert the permission record...
		*/
		err = ErrDispUpdate(sesid, tableidSp, NULL, 0, NULL);
		Assert(err >= 0);
		}
#undef irgSo
#undef irgSc
#undef irgSi
#undef irgSp
#undef irgSq
#undef irgSr
#undef irgSa
#undef irgSg
#undef irgTc
#undef irgDc
#undef irgRc
#undef irgDb
#undef irgMax
#undef iaceMax
	}


/*	ReportSecurity

	Performs a report of security-related data in database.
*/

STATIC void NEAR ReportSecurity(char *szDatabaseName)
	{
	JET_ERR 	err;

	if (fhResults == NULL)
		return;

	LgEnterCriticalSection( critJet );

	fprintf(fhResults, "============ Database: %s ============\n\n", szDatabaseName);

	/*	Open tables...
	*/
	err = ErrDispOpenTable(sesid, dbid, &tableidSo, szMSysObjects, 0);
	Assert(err >= 0);
	err = ErrDispOpenTable(sesid, dbid, &tableidSc, szMSysColumns, 0);
	Assert(err >= 0);
	err = ErrDispOpenTable(sesid, dbid, &tableidSa, szMSysAccounts, 0);
	Assert(err >= 0);
	err = ErrDispOpenTable(sesid, dbid, &tableidSg, szMSysGroups, 0);
	Assert(err >= 0);
	err = ErrDispOpenTable(sesid, dbid, &tableidSp, szMSysACEs, 0);
	Assert(err >= 0);

	/*	Gather all column information...
	*/
	GatherColumnInfo();

	/*	Print out security-related data from all tables...
	*/
	PrintSysObjects();
	PrintSysColumns();
	PrintSysAccounts();
	PrintSysGroups();
	PrintSysACEs();

	/*	we're done, close the tables...
	*/
	err = ErrDispCloseTable(sesid, tableidSo);
	Assert(err >= 0);
	err = ErrDispCloseTable(sesid, tableidSc);
	Assert(err >= 0);
	err = ErrDispCloseTable(sesid, tableidSa);
	Assert(err >= 0);
	err = ErrDispCloseTable(sesid, tableidSg);
	Assert(err >= 0);
	err = ErrDispCloseTable(sesid, tableidSp);
	Assert(err >= 0);
	
	LgLeaveCriticalSection( critJet );
	}

/*	PrintSysObjects

	Prints all security-related data for each row of the table.
*/

STATIC void NEAR PrintSysObjects(void)
	{
	OUTDATA out;
	JET_ERR err;
	int cchSoName = max(strlen(szSoName), 30);
	int cchSoType = max(strlen(szSoType), 5);
	int cchSoId = max(strlen(szSoId), 10);
	int cchSoParentId = max(strlen(szSoParentId), 10);
	int cchSoOwnerSID = max(strlen(szSoOwnerSID), 20);

	/*	print a table header...
	*/
	fprintf(fhResults, "MSysObjects:\n");
	fprintf(fhResults, "============\n");
	fprintf(fhResults, "%-*s %*s %*s %*s %-*s\n",
		cchSoName, (const char *) szSoName,
		cchSoType, (const char *) szSoType,
		cchSoId, (const char *) szSoId,
		cchSoParentId, (const char *) szSoParentId,
		cchSoOwnerSID, (const char *) szSoOwnerSID);
	fprintf(fhResults, "%-*.*s %*.*s %*.*s %*.*s %-*.*s\n",
		cchSoName, cchSoName, (const char *) szLine,
		cchSoType, cchSoType, (const char *) szLine,
		cchSoId, cchSoId, (const char *) szLine,
		cchSoParentId, cchSoParentId, (const char *) szLine,
		cchSoOwnerSID, cchSoOwnerSID, (const char *) szLine);

	/*	print the data from each row...
	*/
	err = ErrDispSetCurrentIndex(sesid, tableidSo, NULL);
	Assert(err >= 0);
	err = ErrDispMove(sesid, tableidSo, JET_MoveFirst, 0UL);
	Assert(err >= 0);
	do
		{
		/*	SoName...
		*/
		out.cbMax = cbBufMax;
		out.pb = rgbBuf;
		err = ErrDispRetrieveColumn(sesid, tableidSo, columndefSoName.columnid, out.pb, out.cbMax, &out.cbActual, 0L, NULL);
		Assert(err >= 0);
		FormatOutdata(&out, columndefSoName.coltyp);
		fprintf(fhResults, "%-*.*s ", cchSoName, cchSoName, szOut);

		/*	SoType...
		*/
		out.cbMax = cbBufMax;
		out.pb = rgbBuf;
		err = ErrDispRetrieveColumn(sesid, tableidSo, columndefSoType.columnid, out.pb, out.cbMax, &out.cbActual, 0L, NULL);
		Assert(err >= 0);
		FormatOutdata(&out, columndefSoType.coltyp);
		fprintf(fhResults, "%*.*s ", cchSoType, cchSoType, szOut);

		/*	SoId...
		*/
		err = ErrDispRetrieveColumn(sesid, tableidSo, columndefSoId.columnid, rgbBuf, cbBufMax, &out.cbActual, 0L, NULL);
		Assert(err >= 0);
		sprintf(szOut, "%08lX", *(long *)rgbBuf);
		fprintf(fhResults, "%*.*s ", cchSoId, cchSoId, szOut);

		/*	SoParentId...
		*/
		err = ErrDispRetrieveColumn(sesid, tableidSo, columndefSoParentId.columnid, rgbBuf, cbBufMax, &out.cbActual, 0L, NULL);
		Assert(err >= 0);
		sprintf(szOut, "%08lX", *(long *)rgbBuf);
		fprintf(fhResults, "%*.*s ", cchSoParentId, cchSoParentId, szOut);

		/*	SoOwnerSID...
		*/
		out.cbMax = cbBufMax;
		out.pb = rgbBuf;
		err = ErrDispRetrieveColumn(sesid, tableidSo, columndefSoOwnerSID.columnid, out.pb, out.cbMax, &out.cbActual, 0L, NULL);
		Assert(err >= 0);
		FormatOutdata(&out, columndefSoOwnerSID.coltyp);
		fprintf(fhResults, "%-*.*s\n", cchSoOwnerSID, cchSoOwnerSID, szOut);
		} while (ErrDispMove(sesid, tableidSo, JET_MoveNext, 0UL) >= 0);

	fprintf(fhResults, "\n\n");
	}


/*	PrintSysColumns

	Prints all security-related data for each row of the table.
*/

STATIC void NEAR PrintSysColumns(void)
	{
	OUTDATA out;
	JET_ERR err;
	int cchScName = max(strlen(szScName), 20);
	int cchScObjectId = max(strlen(szScObjectId), 10);
	int cchScFRestricted = max(strlen(szScFRestricted), 5);

	/*	print a table header...
	*/
	fprintf(fhResults, "MSysColumns:\n");
	fprintf(fhResults, "============\n");
	fprintf(fhResults, "%-*s %*s %-*s\n",
		cchScName, (const char *) szScName,
		cchScObjectId, (const char *) szScObjectId,
		cchScFRestricted, (const char *) szScFRestricted);
	fprintf(fhResults, "%-*.*s %*.*s %-*.*s\n",
		cchScName, cchScName, (const char *) szLine,
		cchScObjectId, cchScObjectId, (const char *) szLine,
		cchScFRestricted, cchScFRestricted, (const char *) szLine);

	/*	print the data from each row...
	*/
	err = ErrDispSetCurrentIndex(sesid, tableidSc, NULL);
	Assert(err >=0);
	err = ErrDispMove(sesid, tableidSc, JET_MoveFirst, 0UL);
	Assert(err >= 0);
	do
		{
		/*	ScName...
		*/
		out.cbMax = cbBufMax;
		out.pb = rgbBuf;
		err = ErrDispRetrieveColumn(sesid, tableidSc, columndefScName.columnid, out.pb, out.cbMax, &out.cbActual, 0L, NULL);
		Assert(err >= 0);
		FormatOutdata(&out, columndefScName.coltyp);
		fprintf(fhResults, "%-*.*s ", cchScName, cchScName, szOut);

		/*	ScObjectId...
		*/
		err = ErrDispRetrieveColumn(sesid, tableidSc, columndefScObjectId.columnid, rgbBuf, cbBufMax, &out.cbActual, 0L, NULL);
		Assert(err >= 0);
		sprintf(szOut, "%08lX", *(long *)rgbBuf);
		fprintf(fhResults, "%*.*s ", cchScObjectId, cchScObjectId, szOut);

		/*	ScFRestricted...
		*/
		out.cbMax = cbBufMax;
		out.pb = rgbBuf;
		err = ErrDispRetrieveColumn(sesid, tableidSc, columndefScFRestricted.columnid, out.pb, out.cbMax, &out.cbActual, 0L, NULL);
		Assert(err >= 0);
		FormatOutdata(&out, columndefScFRestricted.coltyp);
		fprintf(fhResults, "%-*.*s\n", cchScFRestricted, cchScFRestricted, szOut);
		} while (ErrDispMove(sesid, tableidSc, JET_MoveNext, 0UL) >= 0);

	fprintf(fhResults, "\n\n");
	}


/*	PrintSysAccounts

	Prints all security-related data for each row of the table.
*/

STATIC void NEAR PrintSysAccounts(void)
	{
	OUTDATA out;
	JET_ERR err;
	int cchSaName = max(strlen(szSaName), 20);
	int cchSaSID = max(strlen(szSaSID), 20);
	int cchSaPassword = max(strlen(szSaPassword), 20);
	int cchSaFGroup = max(strlen(szSaFGroup), 5);

	/*	print a table header...
	*/
	fprintf(fhResults, "MSysAccounts:\n");
	fprintf(fhResults, "=============\n");
	fprintf(fhResults, "%-*s %-*s %-*s %-*s\n",
		cchSaName, (const char *) szSaName,
		cchSaSID, (const char *) szSaSID,
		cchSaPassword, (const char *) szSaPassword,
		cchSaFGroup, (const char *) szSaFGroup);
	fprintf(fhResults, "%-*.*s %-*.*s %-*.*s %-*.*s\n",
		cchSaName, cchSaName, (const char *) szLine,
		cchSaSID, cchSaSID, (const char *) szLine,
		cchSaPassword, cchSaPassword, (const char *) szLine,
		cchSaFGroup, cchSaFGroup, (const char *) szLine);

	/*	print the data from each row...
	*/
	err = ErrDispSetCurrentIndex(sesid, tableidSa, NULL);
	Assert(err >=0);
	err = ErrDispMove(sesid, tableidSa, JET_MoveFirst, 0);
	Assert(err >= 0);
	do
		{
		/*	SaName...
		*/
		out.cbMax = cbBufMax;
		out.pb = rgbBuf;
		err = ErrDispRetrieveColumn(sesid, tableidSa, columndefSaName.columnid, out.pb, out.cbMax, &out.cbActual, 0L, NULL);
		Assert(err >= 0);
		FormatOutdata(&out, columndefSaName.coltyp);
		fprintf(fhResults, "%-*.*s ", cchSaName, cchSaName, szOut);

		/*	SaSID...
		*/
		out.cbMax = cbBufMax;
		out.pb = rgbBuf;
		err = ErrDispRetrieveColumn(sesid, tableidSa, columndefSaSID.columnid, out.pb, out.cbMax, &out.cbActual, 0L, NULL);
		Assert(err >= 0);
		FormatOutdata(&out, columndefSaSID.coltyp);
		fprintf(fhResults, "%-*.*s ", cchSaSID, cchSaSID, szOut);

		/*	SaPassword...
		*/
		out.cbMax = cbBufMax;
		out.pb = rgbBuf;
		err = ErrDispRetrieveColumn(sesid, tableidSa, columndefSaPassword.columnid, out.pb, out.cbMax, &out.cbActual, 0L, NULL);
		Assert(err >= 0);
		FormatOutdata(&out, columndefSaPassword.coltyp);
		fprintf(fhResults, "%-*.*s ", cchSaPassword, cchSaPassword, szOut);

		/*	SaFGroup...
		*/
		out.cbMax = cbBufMax;
		out.pb = rgbBuf;
		err = ErrDispRetrieveColumn(sesid, tableidSa, columndefSaFGroup.columnid, out.pb, out.cbMax, &out.cbActual, 0L, NULL);
		Assert(err >= 0);
		FormatOutdata(&out, columndefSaFGroup.coltyp);
		fprintf(fhResults, "%-*.*s\n", cchSaFGroup, cchSaFGroup, szOut);
		} while (ErrDispMove(sesid, tableidSa, JET_MoveNext, 0UL) >= 0);

	fprintf(fhResults, "\n\n");
	}


/*	PrintSysGroups

	Prints all security-related data for each row of the table.
*/

STATIC void NEAR PrintSysGroups(void)
	{
	OUTDATA out;
	JET_ERR err;
	int cchSgGroup = max(strlen(szSgGroup), 20);
	int cchSgUser = max(strlen(szSgUser), 20);

	/*	print a table header...
	*/
	fprintf(fhResults, "MSysGroups:\n");
	fprintf(fhResults, "===========\n");
	fprintf(fhResults, "%-*s %-*s\n",
		cchSgGroup, (const char *) szSgGroup,
		cchSgUser, (const char *) szSgUser);
	fprintf(fhResults, "%-*.*s %-*.*s\n",
		cchSgGroup, cchSgGroup, (const char *) szLine,
		cchSgUser, cchSgUser, (const char *) szLine);

	/*	print the data from each row...
	*/
	err = ErrDispSetCurrentIndex(sesid, tableidSg, NULL);
	Assert(err >= 0);
	err = ErrDispMove(sesid, tableidSg, JET_MoveFirst, 0UL);
	Assert(err >= 0);
	do
		{
		/*	SgGroup...
		*/
		out.cbMax = cbBufMax;
		out.pb = rgbBuf;
		err = ErrDispRetrieveColumn(sesid, tableidSg, columndefSgGroup.columnid, out.pb, out.cbMax, &out.cbActual, 0L, NULL);
		Assert(err >= 0);
		FormatOutdata(&out, columndefSgGroup.coltyp);
		fprintf(fhResults, "%-*.*s ", cchSgGroup, cchSgGroup, szOut);

		/*	SgUser...
		*/
		out.cbMax = cbBufMax;
		out.pb = rgbBuf;
		err = ErrDispRetrieveColumn(sesid, tableidSg, columndefSgUser.columnid, out.pb, out.cbMax, &out.cbActual, 0L, NULL);
		Assert(err >= 0);
		FormatOutdata(&out, columndefSgUser.coltyp);
		fprintf(fhResults, "%-*.*s\n", cchSgUser, cchSgUser, szOut);
		} while (ErrDispMove(sesid, tableidSg, JET_MoveNext, 0UL) >= 0);

	fprintf(fhResults, "\n\n");
	}


/*	PrintSysACEs

	Prints all security-related data for each row of the table.
*/

STATIC void NEAR PrintSysACEs(void)
	{
	OUTDATA out;
	JET_ERR err;
	int cchSpObjectID = max(strlen(szSpObjectID), 11);
	int cchSpSID = max(strlen(szSpSID), 20);
	int cchSpACM = max(strlen(szSpACM), 11);
	int cchSpFInheritable = max(strlen(szSpFInheritable), 5);

	/*	print a table header...
	*/
	fprintf(fhResults, "MSysACEs:\n");
	fprintf(fhResults, "=========\n");
	fprintf(fhResults, "%*s %-*s %*s %-*s\n",
		cchSpObjectID, (const char *) szSpObjectID,
		cchSpSID, (const char *) szSpSID,
		cchSpACM, (const char *) szSpACM,
		cchSpFInheritable, (const char *) szSpFInheritable);
	fprintf(fhResults, "%*.*s %-*.*s %*.*s %-*.*s\n",
		cchSpObjectID, cchSpObjectID, (const char *) szLine,
		cchSpSID, cchSpSID, (const char *) szLine,
		cchSpACM, cchSpACM, (const char *) szLine,
		cchSpFInheritable, cchSpFInheritable, (const char *) szLine);

	/*	print the data from each row...
	*/
	err = ErrDispSetCurrentIndex(sesid, tableidSp, NULL);
	Assert(err >= 0);
	err = ErrDispMove(sesid, tableidSp, JET_MoveFirst, 0UL);
	Assert(err >= 0);
	do
		{
		/*	SpObjectID...
		*/
		err = ErrDispRetrieveColumn(sesid, tableidSp, columndefSpObjectID.columnid, rgbBuf, cbBufMax, &out.cbActual, 0L, NULL);
		Assert(err >= 0);
		sprintf(szOut, "%08lX", *(long *)rgbBuf);
		fprintf(fhResults, "%*.*s ", cchSpObjectID, cchSpObjectID, szOut);

		/*	SpSID...
		*/
		out.cbMax = cbBufMax;
		out.pb = rgbBuf;
		err = ErrDispRetrieveColumn(sesid, tableidSp, columndefSpSID.columnid, out.pb, out.cbMax, &out.cbActual, 0L, NULL);
		Assert(err >= 0);
		FormatOutdata(&out, columndefSpSID.coltyp);
		fprintf(fhResults, "%-*.*s ", cchSpSID, cchSpSID, szOut);

		/*	SpACM...
		*/
		err = ErrDispRetrieveColumn(sesid, tableidSp, columndefSpACM.columnid, rgbBuf, cbBufMax, &out.cbActual, 0L, NULL);
		Assert(err >= 0);
		sprintf(szOut, "%08lX", *(long *)rgbBuf);
		fprintf(fhResults, "%*.*s ", cchSpACM, cchSpACM, szOut);

		/*	SpFInheritable...
		*/
		out.cbMax = cbBufMax;
		out.pb = rgbBuf;
		err = ErrDispRetrieveColumn(sesid, tableidSp, columndefSpFInheritable.columnid, out.pb, out.cbMax, &out.cbActual, 0L, NULL);
		Assert(err >= 0);
		FormatOutdata(&out, columndefSpFInheritable.coltyp);
		fprintf(fhResults, "%-*.*s\n", cchSpFInheritable, cchSpFInheritable, szOut);
		} while (ErrDispMove(sesid, tableidSp, JET_MoveNext, 0UL) >= 0);

	fprintf(fhResults, "\n\n");
	}


/*	FormatOutdata

	Given an outdata containing column data and a coltyp for the data,
	converts the data to printable string form into buffer szOut.
*/

STATIC void NEAR FormatOutdata(OUTDATA *pout, JET_COLTYP coltyp)
	{
	unsigned ib;
	static char szNULL[] = "NULL";
	unsigned char *pb = (unsigned char *)(pout->pb);

	if (pout->cbActual == 0)
		{
		sprintf(szOut, szNULL);

		return;
		}

	switch (coltyp)
		{
	default:
		sprintf(szOut, "???");
		break;

	case JET_coltypBit:
		/* 1 byte, zero or non-zero, no NULLs */
		sprintf(szOut, "%s", (pb[0] == 0) ? (const char *) szFalse : (const char *) szTrue);
		break;

	case JET_coltypUnsignedByte:
		/* 1-byte integer, unsigned */
		sprintf(szOut, "%02X", (unsigned short) pb[0]);
		break;

	case JET_coltypShort:
		/* 2-byte integer, signed */
		sprintf(szOut, "%d", *(signed short *)&pb[0]);
		break;

	case JET_coltypLong:
		/* 4-byte integer, signed */
		sprintf(szOut, "%ld", *(signed long *)&pb[0]);
		break;

	case JET_coltypCurrency:
		/* 8 bytes, +-9.2E14, accuracy .0001 dollar */
		for (ib = 0; ib < 8; ib++)
			sprintf(szOut, "%02x ", pb[ib]);
		break;

	case JET_coltypIEEESingle:
		/* 4-byte floating-point number */
		sprintf(szOut, "%f", *(float *)&pb[0]);
		break;

	case JET_coltypIEEEDouble:
		/* 8-byte floating-point number */
		sprintf(szOut, "%lf", *(double *)&pb[0]);
		break;

	case JET_coltypDateTime:
		/* Integral date, fractional time */
		sprintf(szOut, "%lf", *(double *)&pb[0]);
		break;

	case JET_coltypBinary:
		/* Binary string, case-sen., length <= 255 */
	case JET_coltypLongBinary:
		/* Binary string, case-sen., any length */
		for (ib = 0; ib < (unsigned) pout->cbActual; ib++)
			sprintf(szOut+2*ib, "%02uX", pb[ib]);
		szOut[2*ib] = '\0';
		break;

	case JET_coltypText:
		/* ASCII strng, case-insen., length <= 255 */
	case JET_coltypLongText:
		/* ASCII string, case-insen., any length */
		szOut[0] = '\"';
		for (ib = 0; ib < (unsigned) pout->cbActual; ib++)
			sprintf(szOut+1+ib, "%c", (char) pb[ib]);
		szOut[ib+1] = '\"';
		szOut[ib+2] = '\0';
		break;
		}
	}


/*	GatherColumnInfo

	Collects COLUMNDEF data for all security-related columns of system
	tables.  Assumes tables are open, and leaves them open when done.
*/

STATIC void NEAR GatherColumnInfo(void)
	{
	JET_ERR err;

	/*	get column information for MSysObjects columns...
	*/
	err = ErrDispGetTableColumnInfo(sesid, tableidSo, szSoId, &columndefSoId, sizeof(columndefSoId), 0L);
	Assert(err >= 0);
	err = ErrDispGetTableColumnInfo(sesid, tableidSo, szSoParentId, &columndefSoParentId, sizeof(columndefSoParentId), 0L);
	Assert(err >= 0);
	err = ErrDispGetTableColumnInfo(sesid, tableidSo, szSoName, &columndefSoName, sizeof(columndefSoName), 0L);
	Assert(err >= 0);
	err = ErrDispGetTableColumnInfo(sesid, tableidSo, szSoType, &columndefSoType, sizeof(columndefSoType), 0L);
	Assert(err >= 0);
	err = ErrDispGetTableColumnInfo(sesid, tableidSo, szSoOwnerSID, &columndefSoOwnerSID, sizeof(columndefSoOwnerSID), 0L);
	Assert(err >= 0);
	err = ErrDispGetTableColumnInfo(sesid, tableidSo, szSoFlags, &columndefSoFlags, sizeof(columndefSoFlags), 0L);
	Assert(err >= 0);

	/*	get column information for MSysColumns columns...
	*/
	err = ErrDispGetTableColumnInfo(sesid, tableidSc, szScObjectId, &columndefScObjectId, sizeof(columndefScObjectId), 0L);
	Assert(err >= 0);
	err = ErrDispGetTableColumnInfo(sesid, tableidSc, szScName, &columndefScName, sizeof(columndefScName), 0L);
	Assert(err >= 0);
	err = ErrDispGetTableColumnInfo(sesid, tableidSc, szScFRestricted, &columndefScFRestricted, sizeof(columndefScFRestricted), 0L);
	Assert(err >= 0);

	/*	get column information for MSysAccounts columns...
	*/
	err = ErrDispGetTableColumnInfo(sesid, tableidSa, szSaName, &columndefSaName, sizeof(columndefSaName), 0L);
	Assert(err >= 0);
	err = ErrDispGetTableColumnInfo(sesid, tableidSa, szSaSID, &columndefSaSID, sizeof(columndefSaSID), 0L);
	Assert(err >= 0);
	err = ErrDispGetTableColumnInfo(sesid, tableidSa, szSaPassword, &columndefSaPassword, sizeof(columndefSaPassword), 0L);
	Assert(err >= 0);
	err = ErrDispGetTableColumnInfo(sesid, tableidSa, szSaFGroup, &columndefSaFGroup, sizeof(columndefSaFGroup), 0L);
	Assert(err >= 0);

	/*	get column information for MSysGroups columns...
	*/
	err = ErrDispGetTableColumnInfo(sesid, tableidSg, szSgGroup, &columndefSgGroup, sizeof(columndefSgGroup), 0L);
	Assert(err >= 0);
	err = ErrDispGetTableColumnInfo(sesid, tableidSg, szSgUser, &columndefSgUser, sizeof(columndefSgUser), 0L);
	Assert(err >= 0);

	/*	get column information for MSysACEs columns...
	*/
	err = ErrDispGetTableColumnInfo(sesid, tableidSp, szSpObjectID, &columndefSpObjectID, sizeof(columndefSpObjectID), 0L);
	Assert(err >= 0);
	err = ErrDispGetTableColumnInfo(sesid, tableidSp, szSpSID, &columndefSpSID, sizeof(columndefSpSID), 0L);
	Assert(err >= 0);
	err = ErrDispGetTableColumnInfo(sesid, tableidSp, szSpACM, &columndefSpACM, sizeof(columndefSpACM), 0L);
	Assert(err >= 0);
	err = ErrDispGetTableColumnInfo(sesid, tableidSp, szSpFInheritable, &columndefSpFInheritable, sizeof(columndefSpFInheritable), 0L);
	Assert(err >= 0);
	}


/*	BuildIndata

	Given an SZ of data and a coltyp for the data, fills in the supplied
	INDATA structure with converted data ready for deposit via JetSetColumn.
*/

STATIC void NEAR BuildIndata(INDATA *pin, const void *pv, JET_COLTYP coltyp)
	{
	pin->pb = rgbBuf;

	switch (coltyp)
		{
	default:
		pin->cb = 0;
		pin->pb = NULL;
		break;

	case JET_coltypBit:
		/* 1 byte, zero or non-zero, no NULLs */
		/*	set cb = 1 byte for blue engine, set supplied data to two
			'0' bytes to passify red engine
		*/
		*((signed short *) rgbBuf) = (signed short) *((char *) pv);
		pin->cb = sizeof(unsigned char);
		break;

	case JET_coltypUnsignedByte:
		/* 1-byte integer, unsigned */
		*((unsigned char *) rgbBuf) = *(unsigned char *) pv;
		pin->cb = sizeof(unsigned char);
		break;

	case JET_coltypShort:
		/* 2-byte integer, signed */
		*((signed short *) rgbBuf) = *(signed short *) pv;
		pin->cb = sizeof(signed short);
		break;

	case JET_coltypLong:
		/* 4-byte integer, signed */
		*((signed long *) rgbBuf) = *(signed long *) pv;
		pin->cb = sizeof(signed long);
		break;

	case JET_coltypIEEESingle:
		/* 4-byte floating-point number */
		memcpy(rgbBuf, pv, sizeof(float));
		pin->cb = sizeof(float);
		break;

	case JET_coltypCurrency:
		/* 8 bytes, +-9.2E14, accuracy .0001 dollar */
	case JET_coltypIEEEDouble:
		/* 8-byte floating-point number */
	case JET_coltypDateTime:
		/* Integral date, fractional time */
		memcpy(rgbBuf, pv, sizeof(double));
		pin->cb = sizeof(double);
		break;

	case JET_coltypBinary:
		/* Binary string, case-sen., length <= 255 */
	case JET_coltypText:
		/* ASCII strng, case-insen., length <= 255 */
	case JET_coltypLongBinary:
		/* Binary string, case-sen., any length */
	case JET_coltypLongText:
		/* ASCII string, case-insen., any length */
		pin->cb = (unsigned long) strlen((char *) pv);
		pin->pb = (void *) pv;
		break;
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\sort.c ===
#include "config.h"

#include <stdlib.h>
#include <string.h>

#include "daedef.h"
#include "util.h"
#include "pib.h"
#include "page.h"
#include "fmp.h"
#include "ssib.h"
#include "fucb.h"
#include "fcb.h"
#include "stapi.h"
#include "dirapi.h"	
#include "spaceapi.h"
#include "idb.h"
#include "fdb.h"
#include "scb.h"
#include "sortapi.h"	
#include "recapi.h"
#include "recint.h"
#include "fileapi.h"
#include "fileint.h"

DeclAssertFile;				/* Declare file name for assert macros */

#define SORTInternal( pscb, p, c )	SORTQuick( pscb, p, c )

LOCAL VOID 	SORTQuick( SCB *pscb, BYTE **rgpb, LONG cpb );
LOCAL LONG 	CpbSORTUnique( BYTE **rgpb, LONG cpb );
LOCAL LONG 	IpbSeek( SCB *pscb, BYTE **rgpb, LONG cpb, BYTE *pbKey, BOOL fGT );
LOCAL LONG 	IpbSeekByKey( BYTE **rgpb, LONG cpb, KEY *pkey, BOOL fGT );

LOCAL INT  	stdiff( BYTE *st1, BYTE *st2 );

LOCAL VOID  SORTInitPscb( SCB *pscb );
LOCAL ERR 	ErrSORTOutputRun( SCB *pscb );

LOCAL ERR 	ErrMERGEInit( SCB *pscb, INT crun );
LOCAL ERR 	ErrMERGEToDisk( SCB *pscb );
LOCAL ERR 	ErrMERGENext( SCB *pscb, BYTE **ppb );
LOCAL ERR	ErrMERGEFirst( SCB *pscb, BYTE **ppb );

LOCAL ERR 	ErrRUNBegin( SCB *pscb );
LOCAL ERR 	ErrRUNAdd( SCB *pscb, BYTE *pb );
LOCAL ERR 	ErrRUNEnd( SCB *pscb );

#ifdef WIN32
#define	cbSortBuffer 					( 64*1024L )
#else
// use 63Kb to avoid pointer overflow problems under OS/2 v1.2
#define	cbSortBuffer 					( 63*1024L )
#endif
#define	PnOfSortPage(ppage)			(*(PN *) ((BYTE *)ppage + sizeof(ULONG)))
#define	SetPnOfSortPage(ppage, pn)	(*(PN *) ((BYTE *)ppage + sizeof(ULONG)) = pn)



LOCAL INLINE INT ISORTCmpStSt( SCB *pscb, BYTE *stKey1, BYTE *stKey2 )
	{
	INT		w;

	w = memcmp( stKey1 + 1, stKey2 + 1, min( *stKey1, *stKey2 ) );
	if ( w == 0 )
		{
		w = (INT)*stKey1 - (INT)*stKey2;
		if ( w == 0 && FSCBIndex( pscb ) )
			{
			/*	compare SRIDs
			/**/
#ifdef WIN32
			w = *(SRID *)(stKey1 + 1 + *stKey1) - *(SRID *)(stKey2 + 1 + *stKey2);
#else
			if ( *(SRID *)(stKey1 + 1 + *stKey1) > *(SRID *)(stKey2 + 1 + *stKey2) )
				w = 1;
			else
				w = -1;
#endif
			}
		}

	return w;
	}


LOCAL INLINE INT ISORTCmpKeyStSt( BYTE *stKey1, BYTE *stKey2 )
	{
	INT		w;
	w = memcmp( stKey1+1, stKey2+1, min( *stKey1, *stKey2 ) );
	return w ? w : ( INT ) *stKey1 - ( INT ) *stKey2;
	}


//---------------------------------------------------------------------------
// ErrSORTOpen( PIB *ppib, FUCB **pfucb, INT fFlags )
//
// This function returns a pointer to an FUCB which can be use to add records
// to a collection of records to be sorted.  Then the records can be retrieved
// in sorted order.
//	
//	The fFlags fUnique flag indicates that records with duplicate
// keys should be eliminated.
//
//---------------------------------------------------------------------------

ERR ErrSORTOpen( PIB *ppib, FUCB **ppfucb, INT fFlags )
	{
	ERR		err = JET_errSuccess;
	FUCB		*pfucb = pfucbNil;
	SCB		*pscb = pscbNil;
	BYTE		*rgbSort = NULL;
	PGNO		cpgReq;
	PGNO		cpgMin;
	INT		ipbf;

	cpgReq = cpgMin = (PGNO) 1;

	CallR( ErrFUCBOpen( ppib, dbidTemp, &pfucb ) );
	if ( ( pscb = PscbMEMAlloc() ) == pscbNil )
		{
		Error( JET_errTooManySorts, HandleError );
		}

	/*	need CSR to mark transaction level of creation for abort
	/**/
	Assert( PcsrCurrent( pfucb ) != pcsrNil );
	Assert( PcsrCurrent( pfucb )->pcsrPath == pcsrNil );
	memset( &pscb->fcb, '\0', sizeof(FCB) );

	FUCBSetSort( pfucb );

	pscb->fFlags = fSCBInsert|fFlags;
	pscb->fcb.pidb	= NULL;
	pscb->fcb.pfdb	= NULL;
	pscb->cbSort	= cbSortBuffer;
#ifdef DEBUG
	pscb->cbfPin	= 0;
	pscb->lInput	= 0;
	pscb->lOutput	= 0;
#endif

	rgbSort = LAlloc( pscb->cbSort, 1 );
	if ( rgbSort == NULL )
		{
		Error( JET_errOutOfMemory, HandleError );
		}
	pscb->rgbSort = rgbSort;
	pscb->crun = 0;

	/*	link FUCB to FCB in SCB
	/**/
	FCBLink( pfucb, &( pscb->fcb ) );

	/*	allocate space from temporary database
	/**/
	Call( ErrSPGetExt( pfucb, pgnoSystemRoot, &cpgReq, cpgMin, &( pscb->fcb.pgnoFDP ), fTrue ) );

	/*	initialize buffer array
	/**/
	for ( ipbf = 0; ipbf < crunMergeMost; ipbf++ )
		{
		pscb->rgpbf[ipbf] = pbfNil;
		}

	pscb->pbfOut = pbfNil;

	SORTInitPscb( pscb );

	*ppfucb = pfucb;
	return JET_errSuccess;

HandleError:
	if ( rgbSort != NULL )
		LFree( rgbSort );
	if ( pscb != pscbNil )
		{
		Assert( pscb->cbfPin == 0 );
		MEMReleasePscb( pscb );
		}
	if ( pfucb != pfucbNil )
		FUCBClose( pfucb );
	return err;
	}


LOCAL VOID SORTInitPscb( SCB *pscb )
	{
	// initialize sort buffer

	pscb->pbEnd		= pscb->rgbSort;
	pscb->ppbMax	= (BYTE **)( pscb->rgbSort + pscb->cbSort );
	pscb->rgpb		= pscb->ppbMax;
	pscb->wRecords	= 0;
	}


ERR ErrSORTClose( FUCB *pfucb )
	{
	ERR		err = JET_errSuccess;
	SCB		*pscb = pfucb->u.pscb;
	INT		ipbf;

	/*	unlatch buffers
	/**/
	if ( pscb->pbfOut != pbfNil )
		{
		BFUnpin( pscb->pbfOut );
		SCBUnpin( pscb );
		pscb->pbfOut = pbfNil;
		}

	for ( ipbf = 0; ipbf < crunMergeMost; ipbf++ )
		{
		if ( pscb->rgpbf[ipbf] != pbfNil )
			{
			BFUnpin( pscb->rgpbf[ipbf] );
			SCBUnpin( pscb );
			pscb->rgpbf[ipbf] = pbfNil;
			}
		}

	/*	if this is the last cursor on sort, then release sort space.
	/**/
	if ( pscb->fcb.wRefCnt == 1 )
		{
		CallS( ErrDIRBeginTransaction( pfucb->ppib ) );
		(VOID)ErrSPFreeFDP( pfucb, pscb->fcb.pgnoFDP );
		err = ErrDIRCommitTransaction( pfucb->ppib );
		if ( err < 0 )
			CallS( ErrDIRRollback( pfucb->ppib ) );
		}
  	FCBUnlink( pfucb );
	FUCBClose( pfucb );

	if ( !pscb->fcb.wRefCnt )
		SORTClosePscb( pscb );

	return JET_errSuccess;
	}


VOID SORTClosePscb( SCB *pscb )
	{
	if ( pscb->rgbSort )
		{
		LFree( pscb->rgbSort );
		}
	if ( pscb->fcb.pidb != NULL )
		{
		MEMReleasePidb( pscb->fcb.pidb );
//		pscb->fcb.pidb = pidbNil;
		}
	if ( pscb->fcb.pfdb != NULL )
		{
		FDBDestruct( (FDB *)pscb->fcb.pfdb );
//		pscb->fcb.pfdb = pfdbNil;
		}
	Assert( pscb->cbfPin == 0 );
	MEMReleasePscb( pscb );
	}


//---------------------------------------------------------------------------
// ErrSORTInsert
//
// Add the record rglineKeyRec[1] with key rglineKeyRec[0] to the collection of
// sort records.
//
//---------------------------------------------------------------------------

ERR ErrSORTInsert( FUCB *pfucb, LINE rglineKeyRec[] )
	{
	ERR		err = JET_errSuccess;
	SCB		*pscb = pfucb->u.pscb;
	BYTE		*pb = pscb->pbEnd;
	UINT		cb;

	Assert( rglineKeyRec[0].cb <= JET_cbKeyMost );
	Assert( FSCBInsert( pscb ) );
	Assert( pscb->pbEnd <= (BYTE *)pscb->rgpb );

	cb = rglineKeyRec[0].cb + rglineKeyRec[1].cb + sizeof(SHORT) + sizeof(BYTE);
	if ( (UINT)((BYTE *)(pscb->rgpb) - pb) < cb + sizeof( BYTE *) )
		{
		SORTInternal( pscb, pscb->rgpb, pscb->wRecords );
		if ( FSCBUnique( pscb ) )
			{
			pscb->wRecords = CpbSORTUnique( pscb->rgpb, pscb->wRecords );
			pscb->rgpb = pscb->ppbMax - pscb->wRecords;
			}
		Call( ErrSORTOutputRun( pscb ) );
		pb = pscb->pbEnd;
		}

	// add record to pointer array (pointer to key)
	--pscb->rgpb;
	pscb->rgpb[0] = pb + sizeof(SHORT);
	pscb->wRecords++;

	// copy total record length (SHORT)
	*((UNALIGNED SHORT *)pb)++ = (SHORT)cb;

	// copy length of key (BYTE)
	*pb++ = (BYTE) rglineKeyRec[0].cb;

	// copy key
	memcpy( pb, rglineKeyRec[0].pb, rglineKeyRec[0].cb );
	pb += rglineKeyRec[0].cb;

	// copy and record
	memcpy( pb, rglineKeyRec[1].pb, rglineKeyRec[1].cb );
	pb += rglineKeyRec[1].cb;

	pscb->pbEnd = pb;
	Assert( pscb->pbEnd <= (BYTE *)pscb->rgpb );
#ifdef DEBUG
	pscb->lInput++;
#endif

HandleError:
	return err;
	}


//---------------------------------------------------------------------------
// ErrSORTEndRead
//
// This functions is called to indicate that no more records will be added
// to the sort.  It performs all work needs to be done before the first
// record can be retrieved.  Currently, calling this routine is optional for
// the user.  If this routine is not called explicitly, it will be called by
// the first routine used to retrieve a record.
//---------------------------------------------------------------------------

ERR ErrSORTEndRead( FUCB *pfucb )
	{
	ERR		err = JET_errSuccess;
	SCB		*pscb = pfucb->u.pscb;

	Assert( FSCBInsert( pscb ) );
	SCBResetInsert( pscb );

	SORTInternal( pscb, pscb->rgpb, pscb->wRecords );
	if ( FSCBUnique( pscb ) )
		{
		pscb->wRecords = CpbSORTUnique( pscb->rgpb, pscb->wRecords );
		pscb->rgpb = pscb->ppbMax - pscb->wRecords;
		}
	pfucb->ppbCurrent = pscb->rgpb - 1;

	if ( pscb->wRecords && pscb->crun )
		{
		// empty sort buffer into final run
		Call( ErrSORTOutputRun( pscb ) );

		// execute all but last merge pass
		while ( pscb->crun > crunMergeMost )
			{
			Call( ErrMERGEToDisk( pscb ) );
			}

		// initiate final merge pass
		Assert( pscb->crun <= crunMergeMost );
		Call( ErrMERGEInit( pscb, pscb->crun ) );
		}

	return pscb->crun ? JET_wrnSortOverflow: JET_errSuccess;

HandleError:
	return err;
	}


ERR ErrSORTCheckIndexRange( FUCB *pfucb )
	{
	ERR	err;
	SCB	*pscb = pfucb->u.pscb;

	err =  ErrFUCBCheckIndexRange( pfucb );
	Assert( err == JET_errSuccess || err == JET_errNoCurrentRecord );
	if ( err == JET_errNoCurrentRecord )
		{
		if ( FFUCBUpper( pfucb ) )
			{
			/*	move sort cursor to after last
			/**/
			pfucb->ppbCurrent = pscb->rgpb + pscb->wRecords;
			}
		else
			{
			/*	move sort cursor to before first
			/**/
			pfucb->ppbCurrent = pscb->rgpb - 1;
			}
		}

	return err;
	}


//---------------------------------------------------------------------------
// ErrSORTFirst
//
//	Move to first record in sort and return error is sort has no records.
//
//---------------------------------------------------------------------------
ERR ErrSORTFirst( FUCB *pfucb )
	{
	ERR		err = JET_errSuccess;
	SCB		*pscb = pfucb->u.pscb;
	BYTE	*pb;
	INT		cb;

	Assert( !FSCBInsert( pscb ) );

	/*	reset index range if present
	/**/
	if ( FFUCBLimstat( pfucb ) )
		{
		FUCBResetLimstat( pfucb );
		}

	if ( pscb->wRecords == 0 && pscb->crun == 0 )
		{
		PcsrCurrent( pfucb )->csrstat = csrstatBeforeFirst;
		return JET_errNoCurrentRecord;
		}
	else
		{
		if ( pscb->crun > 0 )
			{
			CallR( ErrMERGEFirst( pscb, &pb ) );
			}
		else
			{
			/*	move to first record
			/**/
			pfucb->ppbCurrent = pscb->rgpb;
			pb = *pfucb->ppbCurrent;
			}

		/*	get current record
		/**/
		Assert( ((UNALIGNED SHORT *)pb)[-1] );
		PcsrCurrent( pfucb )->csrstat = csrstatOnCurNode;
		cb = ((UNALIGNED SHORT *)pb)[-1];
		cb -= *pb + sizeof(SHORT) + sizeof(BYTE);		// size of data
		pfucb->lineData.cb = cb;						// sizeof(data)
		cb = *pb++;										// size of key
		pfucb->keyNode.cb  = cb;						// sizeof(key)
		pfucb->keyNode.pb  = pb;						// key
		pfucb->lineData.pb = pb + cb;					// data (key+cb)
		}

	return err;
	}


//---------------------------------------------------------------------------
// ErrSORTNext
//
// Return the next record, in sort order, after the previously returned record.
// If no records have been returned yet, or the currency has been reset, this
// function returns the first record.
//---------------------------------------------------------------------------

ERR ErrSORTNext( FUCB *pfucb )
	{
	ERR		err = JET_errSuccess;
	SCB		*pscb = pfucb->u.pscb;
	BYTE	*pb;
	INT		cb;

	Assert( !FSCBInsert( pscb ) );

	if ( pscb->crun )
		{
		CallR( ErrMERGENext( pscb, &pb ) );
		}
	else
		{
		if ( ++pfucb->ppbCurrent < pscb->rgpb + pscb->wRecords )
			pb = *pfucb->ppbCurrent;
		else
			{
			pfucb->ppbCurrent = pscb->rgpb + pscb->wRecords;
			//	UNDONE:	can cursor be after last
			//				if so will break some code
			return JET_errNoCurrentRecord;
			}
		}

	Assert( ((UNALIGNED SHORT *)pb)[-1] );

	PcsrCurrent( pfucb )->csrstat = csrstatOnCurNode;
	cb = ((UNALIGNED SHORT *)pb)[-1];
	cb -= *pb + sizeof(SHORT) + sizeof(BYTE);	// size of data
	pfucb->lineData.cb = cb;						// sizeof(data)
	cb = *pb++;											// size of key
	pfucb->keyNode.cb  = cb;						// sizeof(key)
	pfucb->keyNode.pb  = pb;						// key
	pfucb->lineData.pb = pb + cb;					// data (key+cb)

#ifdef DEBUG
	pscb->lOutput++;
#endif

	Assert( err == JET_errSuccess );
	if ( FFUCBLimstat( pfucb ) && FFUCBUpper( pfucb ) )
		{
		CallR( ErrSORTCheckIndexRange( pfucb ) );
		}

	return err;
	}


ERR ErrSORTPrev( FUCB *pfucb )
	{
	ERR		err;
	SCB		*pscb = pfucb->u.pscb;
	BYTE		*pb;
	INT		cb;

	Assert( !FSCBInsert( pscb ) );
	Assert( pscb->crun == 0 );

	if ( --pfucb->ppbCurrent >= pscb->rgpb )
		pb = *pfucb->ppbCurrent;
	else
		{
		pfucb->ppbCurrent = pscb->rgpb - 1;
		PcsrCurrent( pfucb )->csrstat = csrstatBeforeFirst;
		return JET_errNoCurrentRecord;
		}

	Assert( ((UNALIGNED SHORT *)pb)[-1] );

	PcsrCurrent( pfucb )->csrstat = csrstatOnCurNode;
	cb = ((UNALIGNED SHORT *)pb)[-1];
	cb -= *pb + sizeof(SHORT) + sizeof(BYTE);	// size of data
	pfucb->lineData.cb = cb;						// sizeof(data)
	cb = *pb++;											// size of key
	pfucb->keyNode.cb  = cb;						// sizeof(key)
	pfucb->keyNode.pb  = pb;						// key
	pfucb->lineData.pb = pb + cb;					// data (key+cb)

#ifdef DEBUG
	pscb->lOutput++;
#endif

	if ( FFUCBLimstat( pfucb ) && !FFUCBUpper( pfucb ) )
		{
		CallR( ErrSORTCheckIndexRange( pfucb ) );
		}

	return JET_errSuccess;
	}


//---------------------------------------------------------------------------
// ErrSORTSeek
//
// Return the first record with key >= pkey.  If pkey == NULL then return the
// first record.
//
// Return Value
//		JET_errSuccess					record with key == pkey is found
//		JET_wrnSeekNotEqual			record with key > pkey is found
//		JET_errNoCurrentRecord		no record with key >= pkey is found
//---------------------------------------------------------------------------
ERR ErrSORTSeek( FUCB *pfucb, KEY *pkey, BOOL fGT )
	{
	SCB		*pscb = pfucb->u.pscb;
	BYTE		*pb;
	INT		ipb;
	INT		cb;

	Assert( !FSCBInsert( pscb ) );
	Assert( FFUCBSort( pfucb ) );
	Assert( ( pfucb->u.pscb->grbit & JET_bitTTScrollable ) ||
		( pfucb->u.pscb->grbit & JET_bitTTIndexed ) ||
		( pkey == NULL ) );
	Assert( pscb->crun == 0 );

	if ( pscb->wRecords == 0 )
		return JET_errRecordNotFound;

	Assert( pkey->cb <= JET_cbKeyMost );
	ipb = (INT)IpbSeekByKey( pscb->rgpb, pscb->wRecords, pkey, fGT );
	if ( ipb == (INT)pscb->wRecords )
		return JET_errRecordNotFound;
	pfucb->ppbCurrent = &pscb->rgpb[ipb];
	pb = pscb->rgpb[ipb];

	PcsrCurrent( pfucb )->csrstat = csrstatOnCurNode;
	cb = ((UNALIGNED SHORT *)pb)[-1];
	cb -= *pb + sizeof(SHORT) + sizeof(BYTE);	// size of data
	pfucb->lineData.cb = cb;						// sizeof(data)
	cb = *pb;											// size of key
	pfucb->keyNode.cb  = cb;						// sizeof(key)
	pfucb->keyNode.pb  = pb + 1;					// key
	pfucb->lineData.pb = pb + 1 + cb;			// data ( key + cb )

	return CmpStKey( pb, pkey ) ? JET_wrnSeekNotEqual: JET_errSuccess;
	}


/*	returns index of first entry >= pbKey or if none such exists returns cpb
/**/
LOCAL LONG IpbSeek( SCB *pscb, BYTE **rgpb, LONG cpb, BYTE *pbKey, BOOL fGT )
	{
	BYTE		**ppbStart = rgpb;
	BYTE		**ppbEnd = rgpb + cpb;
	BYTE		**ppbMid;
	INT		wCmp;

	if ( !cpb )
		return cpb;

	do  {
		ppbMid = ppbStart + ( ( ppbEnd - ppbStart ) >> 1 );
		wCmp = ISORTCmpStSt( pscb, *ppbMid, pbKey );
		if ( fGT ? wCmp <= 0 : wCmp < 0 )
			ppbStart = ppbMid + 1;
		else
			ppbEnd = ppbMid;
		}
	while ( ppbStart != ppbEnd );

	return (LONG)(ppbEnd - rgpb);
	}


/*	returns index of first entry >= pbKey or if none such exists returns cpb
/**/
LOCAL LONG IpbSeekByKey( BYTE **rgpb, LONG cpb, KEY *pkey, BOOL fGT )
	{
	BYTE		**ppbStart = rgpb;
	BYTE		**ppbEnd = rgpb + cpb;
	BYTE		**ppbMid;
	INT		wCmp;

	if ( !cpb )
		return cpb;

	do  {
		ppbMid = ppbStart + ( ( ppbEnd - ppbStart ) >> 1 );
		wCmp = CmpStKey( *ppbMid, pkey );
		if ( fGT ? wCmp <= 0 : wCmp < 0 )
			ppbStart = ppbMid + 1;
		else
			ppbEnd = ppbMid;
		}
	while ( ppbStart != ppbEnd );

	return (LONG)(ppbEnd - rgpb);
	}


//---------------------------------------------------------------------------
//
//  MEMORY SORT ROUTINES
//
STATIC void SORTIns( SCB *pscb, BYTE **rgpb, unsigned cpb )
	{
	BYTE	**ppbLeast = (BYTE **)rgpb;
	BYTE	**ppbMax = ppbLeast + cpb;
	BYTE	**ppbOut;
	BYTE	**ppbIn;

	for ( ppbOut = ppbLeast + 1; ppbOut < ppbMax; ppbOut++ )
		{
		BYTE	*pbT = *ppbOut;

		ppbIn = ppbOut;

		while ( ppbIn > ppbLeast && ISORTCmpStSt( pscb, *( ppbIn - 1 ), pbT ) > 0 )
			{
			*ppbIn	= *( ppbIn - 1 );
			--ppbIn;
			}
		*ppbIn = pbT;
		}
	}


#define SWAP( a, b, t )		(t = a, a = b, b = t)
#define cpartMost				16
#define cpbPartitionMin		16


LOCAL VOID SORTQuick( SCB *pscb, BYTE **rgpb, LONG cpb )
	{
	BYTE	**ppb = rgpb;
	struct
		{
		BYTE	**ppb;
		LONG	cpb;
		} rgpart[cpartMost];
	INT		cpart = 0;
	LONG	ipbT;

	forever
		{
		if ( cpb < cpbPartitionMin )
			{
			SORTIns( pscb, ppb, cpb );
			if ( !cpart )
				break;
			--cpart;
			ppb = rgpart[cpart].ppb;
			cpb = rgpart[cpart].cpb;
			continue;
			}

		// PARTITION ipbT = IpbPartition( ppb, cpb )
		{
		BYTE	*pbPivot;
		BYTE	*pbT;
		BYTE	**ppbLow	= ppb;
		BYTE	**ppbHigh = ppb + cpb -1;

		// SORT( ppb[ipbMid-1], ppb[ipbMid], ppb[ipbMid+1] );
		BYTE	**ppbT = ppb + (cpb>>1) - 1;
		if ( ISORTCmpStSt( pscb, ppbT[0], ppbT[1] ) > 0 )
			SWAP( ppbT[0], ppbT[1], pbT );
		if ( ISORTCmpStSt( pscb, ppbT[0], ppbT[2] ) > 0 )
			SWAP( ppbT[0], ppbT[2], pbT );
		if ( ISORTCmpStSt( pscb, ppbT[1], ppbT[2] ) > 0 )
			SWAP( ppbT[1], ppbT[2], pbT );

		SWAP( *ppbHigh, ppbT[0], pbT );
		SWAP( *ppbLow,  ppbT[2], pbT );
		pbPivot = ppbT[1];
		do	{
			SWAP( *ppbLow, *ppbHigh, pbT );
			while ( ISORTCmpStSt( pscb, *++ppbLow,  pbPivot ) < 0 );
			while ( ISORTCmpStSt( pscb, *--ppbHigh, pbPivot ) > 0 );
			}
		while ( ppbLow < ppbHigh );
		ipbT = (LONG)(ppbLow - ppb);
		}

		// "RECURSE" add one partition to stack
		// handle stack overflow
		if ( cpart == cpartMost )
			SORTIns( pscb, ppb + ipbT, cpb - ipbT );
		else
			{
			rgpart[cpart].ppb = ppb + ipbT;
			rgpart[cpart].cpb = cpb - ipbT;
			++cpart;
			}
		cpb = ipbT;
		}
	}


LOCAL LONG CpbSORTUnique( BYTE **rgpb, LONG cpb )
	{
	BYTE	**ppbFrom;
	BYTE	**ppbTo;

	if ( !cpb )
		return cpb;

	ppbTo   = rgpb + cpb - 1;
	for ( ppbFrom = rgpb + cpb - 2 ; ppbFrom >= rgpb ; --ppbFrom )
		if ( ISORTCmpKeyStSt( *ppbFrom, *ppbTo ) )
			*--ppbTo = *ppbFrom;
	return cpb - (LONG)(ppbTo - rgpb);
	}


//---------------------------------------------------------------------------
//
//  MEMORY TO DISK (COPY)
//

LOCAL ERR ErrSORTOutputRun( SCB *pscb )
	{
	ERR		err;

	Assert( pscb->wRecords );

	Call( ErrRUNBegin( pscb ) );
	for ( ; pscb->rgpb < pscb->ppbMax ; ++pscb->rgpb )
		{
		Call( ErrRUNAdd( pscb, *pscb->rgpb - sizeof(SHORT) ) );
		}
	Call( ErrRUNEnd( pscb ) );

	SORTInitPscb( pscb );					// reinit pscb variables
HandleError:
	return err;
	}


//---------------------------------------------------------------------------
//
//  DISK TO DISK (MERGE)
//



LOCAL ERR ErrMERGEToDisk( SCB *pscb )
	{
	ERR		err;
	BYTE	*pb;
	INT		crunMerge;

	crunMerge = pscb->crun % (crunMergeMost - 1);
	if ( pscb->crun > 1 && crunMerge <= 1 )
		{
		crunMerge += crunMergeMost - 1;
		}

	Call( ErrMERGEInit( pscb, crunMerge ) );
	pscb->crun -= crunMerge;
	Call( ErrRUNBegin( pscb ) );

	while ( ( err = ErrMERGENext( pscb, &pb ) ) >= 0 )
		{
		Assert( pb );
		Call( ErrRUNAdd( pscb, pb - sizeof(SHORT) ) );
		}
	if ( err != JET_errNoCurrentRecord )
		goto HandleError;
	Call( ErrRUNEnd( pscb ) );
HandleError:
	return err;
	}


/* CONSIDER: rgpb does not need to be completely sorted
// CONSIDER: if this is a bottle neck, consider using a
// CONSIDER: heap sort.  It not clear that this will be
// CONSIDER: a win since the array is small
*/

LOCAL ERR ErrMERGENextPageInRun( SCB *pscb, BYTE **ppb );

LOCAL ERR ErrMERGENext( SCB *pscb, BYTE **ppb )
	{
	ERR		err = JET_errSuccess;
	BYTE  	*pb;
	BYTE  	**rgpb = pscb->rgpbMerge;
	INT		ipb;

	/*	get next record
	/**/
	pb = rgpb[0];
MERGENext:
	if ( ((UNALIGNED SHORT *)pb)[-1] == 0 )
		{
		Call( ErrMERGENextPageInRun( pscb, &pb ) );
		Assert( pb == NULL || ((UNALIGNED SHORT *)pb)[-1] );
		}

	if ( pb == NULL )
		{
		ipb = --pscb->cpbMerge;
		}
	else
		{
		Assert( ((UNALIGNED SHORT *)pb)[-1] );
		ipb = (INT)IpbSeek( pscb, rgpb + 1, pscb->cpbMerge - 1, pb, 0 );

		/*	if unique no duplicates are output to the original runs
		/*	here we check that the new record is not identical to any records
		/*	from the other runs.
		/**/
		if ( FSCBUnique( pscb ) &&
			ipb < pscb->cpbMerge - 1 &&
			!ISORTCmpKeyStSt( pb, rgpb[ ipb + 1 ] ) )
			{
			pb += ((UNALIGNED SHORT *)pb)[-1];
			goto MERGENext;
			}
		}
	memmove( rgpb, rgpb + 1, ipb * sizeof(BYTE *) );
	rgpb[ipb] = pb;

	if ( (*ppb = rgpb[0]) == NULL )
		{
		return JET_errNoCurrentRecord;
		}

	rgpb[0] = (*ppb) + ((UNALIGNED SHORT *)*ppb)[-1];

HandleError:
	return err;
	}

#define PbDataStart( ppage )	((BYTE *)ppage + sizeof(ULONG) + sizeof(PN))
#define PbDataEnd( ppage )		((BYTE *)&(ppage)->pgtyp)


LOCAL ERR ErrMERGEFirst( SCB *pscb, BYTE **ppb )
	{
	ERR		err = JET_errSuccess;
	INT		i;
	BF		**rgpbf = pscb->rgpbf;
	BYTE	**rgpb = pscb->rgpbMerge;

	/*  This assert verifies that ErrMERGEInit has been called.
	**/
	Assert( pscb->cpbMerge == pscb->crun );

	/*  Rewind to the beginning of each first(hopefully) page
	**/
	// NOTE:  This assumes that the callers will NOT
	// NOTE:  move forward through the sort and then move
	// NOTE:  back to first.  However, we do have to handle
	// NOTE:  the move first twice problem.  So, we re-init the
	// NOTE:  rgpbMerge array
	for ( i = 0 ; i < pscb->cpbMerge ; ++i )
		rgpb[i] = PbDataStart( rgpbf[i]->ppage ) + sizeof(SHORT);

	/*	sort the record pointers (init for MERGENext)
	/**/
	SORTInternal( pscb, rgpb, (LONG)pscb->cpbMerge );

	/*  ErrMERGENext handles the first case
	**/
	err = ErrMERGENext( pscb, ppb );

	return ( err );
	}


LOCAL ERR ErrMERGENextPageInRun( SCB *pscb, BYTE **ppb )
	{
	ERR		err = JET_errSuccess;
	PN			pnNext;
	PGNO		pgno;
	PAGE		*ppage;
	BF			**ppbf;

	Assert( ((UNALIGNED SHORT *)*ppb)[-1] == 0 );

	/*	find pbf and ppage for *ppb
	/**/
#ifdef WIN32
	for ( ppbf = pscb->rgpbf;
		(*ppbf) == pbfNil ||
		(BYTE *)(*ppb) < (BYTE *)(*ppbf)->ppage ||
		(BYTE *)(*ppb) > (BYTE *)(*ppbf)->ppage + cbPage;
		ppbf++ );
#else
	for ( ppbf = pscb->rgpbf;
		(*ppbf) == pbfNil ||
		(BYTE _huge *)(*ppb) < (BYTE _huge *)(*ppbf)->ppage ||
		(BYTE _huge *)(*ppb) > (BYTE _huge *)(*ppbf)->ppage + cbPage;
		ppbf++ );
#endif
	ppage = (*ppbf)->ppage;
	pnNext = PnOfSortPage(ppage);
	
	/* make sure pn can be used as pgno in next ErrSPFreeExt call
	/**/
	pgno = PgnoOfPn((*ppbf)->pn);

	BFUnpin( *ppbf );
	SCBUnpin( pscb );
	BFAbandon( ppibNil, *ppbf );
	
	SgSemRequest( semST );
	Assert( pscb->fcb.dbid == dbidTemp );
	Call( ErrSPFreeExt( pscb->fcb.pfucb, pscb->fcb.pgnoFDP, pgno, 1 ) );

	if ( pnNext == pnNull )
		{
		*ppb  = NULL;
		*ppbf = pbfNil;
		}
	else
		{
		PAGE	*ppageT;

		Call( ErrBFAccessPage( pscb->fcb.pfucb->ppib, ppbf, pnNext ) );
		BFPin( *ppbf );
		SCBPin( pscb );

		ppageT = (*ppbf)->ppage;
		*ppb = PbDataStart( ppageT ) + sizeof(SHORT);

		/*	request next page be read asynchronously if not pnNull
		/**/
		pnNext = PnOfSortPage(ppageT);
		if ( pnNext != pnNull )
			BFReadAsync( pnNext, 1 );
		}
HandleError:
	SgSemRelease( semST );
	return err;
	}


LOCAL ERR ErrMERGEInit( SCB *pscb, INT crunMerge )
	{
	ERR		err;
	BF			**rgpbf = pscb->rgpbf;
	BYTE		**rgpb = pscb->rgpbMerge;
	RUN		*rgrunMerge;
	PN			pn;
	INT		i;

	rgrunMerge = &pscb->rgrun[ pscb->crun - crunMerge ];

	SgSemRequest( semST );

	// get all first pages of each run
	for ( i = 0 ; i < crunMerge ; ++i )
		{
		pn = rgrunMerge[i].pn;
		Call( ErrBFAccessPage( pscb->fcb.pfucb->ppib, &rgpbf[i], pn ) );
		BFPin( rgpbf[i] );
		SCBPin( pscb );
		rgpb[i] = PbDataStart( rgpbf[i]->ppage ) + sizeof(SHORT);
		}
	pscb->cpbMerge = (SHORT)crunMerge;

	// start the read of each 2nd page
	for ( i = 0 ; i < crunMerge ; ++i )
		{
		pn = PnOfSortPage( rgpbf[i]->ppage );
		if ( pn != pnNull )
			{
			BFReadAsync( pn, 1 );
			}
		}

	/*	sort the record pointers (init for MERGENext)
	/**/
	SORTInternal( pscb, rgpb, (LONG)crunMerge );

HandleError:
	SgSemRelease( semST );
	return err;
	}


//---------------------------------------------------------------------------
//
// RUN CREATION ROUTINES
//

LOCAL ERR ErrRUNBegin( SCB *pscb )
	{
	ERR		err;
	PN		pn = pnNull;
	BF		*pbf;
	BOOL	fGotSem = fFalse;

	// if run directory is full, do a merge now to make more room
	if ( pscb->crun == crunMost )
		{
		Call( ErrMERGEToDisk( pscb ) );
		Assert( pscb->crun < crunMost );
		}

	Call( ErrSPGetPage( pscb->fcb.pfucb, &pn, fTrue ) );
	SgSemRequest( semST );
	fGotSem = fTrue;
	Call( ErrBFAllocPageBuffer( pscb->fcb.pfucb->ppib, &pbf, pn, lgposMax, pgtypSort ) );
	BFPin( pbf );
	SCBPin( pscb );
	BFSetDirtyBit( pbf );
	Assert( pbf->fDirty == fTrue );
	PMSetPageType( pbf->ppage, pgtypSort );
	SetPgno( pbf->ppage, pn );

	pscb->rgrun[pscb->crun].pn		= pn;
	pscb->rgrun[pscb->crun].cbfRun	= 1;
	pscb->pbfOut	= pbf;
	pscb->pbOut		= PbDataStart( pbf->ppage );
	pscb->pbMax		= PbDataEnd( pbf->ppage ) - sizeof(SHORT);
HandleError:
	if (fGotSem)
		SgSemRelease( semST );
	return err;
	}

LOCAL ERR ErrRUNNewPage( SCB *pscb );

LOCAL ERR ErrRUNAdd( SCB *pscb, BYTE *pb )
	{
	ERR	  	err = JET_errSuccess;
	UINT  	cb;

	cb = (UINT)*(UNALIGNED SHORT *)pb;
	if ( (UINT)(pscb->pbMax - pscb->pbOut) < cb )
		{
		Call( ErrRUNNewPage( pscb ) );
		}
	memcpy( pscb->pbOut, pb, cb );
	pscb->pbOut += cb;
HandleError:
	return err;
	}


LOCAL ERR ErrRUNNewPage( SCB *pscb )
	{
	ERR	err;
	BF		*pbf;
	PN		pn = pnNull;

	SgSemRequest( semST );
	Call( ErrSPGetPage( pscb->fcb.pfucb, &pn, fTrue ) );
	SetPnOfSortPage(pscb->pbfOut->ppage, pn);
	*(UNALIGNED SHORT *)pscb->pbOut = 0;		// indicate end of page
	BFUnpin( pscb->pbfOut );
	SCBUnpin( pscb );
	Call( ErrBFAllocPageBuffer( pscb->fcb.pfucb->ppib, &pbf, pn, lgposMax, pgtypSort ) );
	BFPin( pbf );
	SCBPin( pscb );
	BFSetDirtyBit( pbf );
	Assert( pbf->fDirty == fTrue );

	PMSetPageType( pbf->ppage, pgtypSort );
	SetPgno(  pbf->ppage, pn );

	pscb->pbfOut	= pbf;
	pscb->pbOut		= PbDataStart( pbf->ppage );
	pscb->pbMax		= PbDataEnd( pbf->ppage ) - sizeof(SHORT);
	++pscb->rgrun[pscb->crun].cbfRun;
HandleError:
	SgSemRelease( semST );
	return err;
	}


LOCAL ERR ErrRUNEnd( SCB *pscb )
	{
	RUN		runNew = pscb->rgrun[pscb->crun];
	RUN		*rgrun = pscb->rgrun;
	INT		irun;

	/*	finish last page in run
	/**/
	*(UNALIGNED SHORT *)pscb->pbOut = 0;
	/*	indicate end of page
	/**/
	SetPnOfSortPage( pscb->pbfOut->ppage, pnNull );
	BFUnpin( pscb->pbfOut );
	SCBUnpin( pscb );
	pscb->pbfOut = pbfNil;

	/*	sort entry into run directory, longest to shortest
	/**/
	irun = pscb->crun - 1;
	while ( irun >= 0 && rgrun[irun].cbfRun < runNew.cbfRun )
		{
		--irun;
		}
	irun++;
	memmove( rgrun+irun+1, rgrun+irun, (pscb->crun-irun) * sizeof(RUN) );
	rgrun[irun] = runNew;

	++pscb->crun;
	return JET_errSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\stats.c ===
#include "config.h"

#include <string.h>
#include <stdlib.h>

#include "daedef.h"
#include "pib.h"
#include "util.h"
#include "fmp.h"
#include "page.h"
#include "ssib.h"
#include "fucb.h"
#include "fcb.h"
#include "stapi.h"
#include "fdb.h"
#include "idb.h"
#include "util.h"
#include "nver.h"
#include "dirapi.h"
#include "recapi.h"
#include "fileapi.h"
#include "stats.h"
#include "node.h"
#include "recint.h"

DeclAssertFile; 				/* Declare file name for assert macros */

LOCAL ERR ErrSTATWriteStats( FUCB *pfucb, SR *psr )
	{
	ERR	  	err = JET_errSuccess;
	FCB	  	*pfcb;
	DIB	  	dib;
	LINE  	line;
	KEY	  	key;

	Assert( pfucb->ppib->level < levelMax );
	pfcb = pfucb->u.pfcb;
	Assert( pfcb != pfcbNil );

	/*	move to FDP root.
	/**/
	DIRGotoFDPRoot( pfucb );

	/*	if clustered index then go down to INDEXES\<clustered>
	/**/
	if ( FFCBClusteredIndex( pfcb ) )
		{
		CHAR szNameNorm[ JET_cbKeyMost ];

		dib.fFlags = fDIRNull;
		dib.pos = posDown;
		dib.pkey = (KEY *)pkeyIndexes;
		Call( ErrDIRDown( pfucb, &dib ) );

		dib.fFlags = fDIRNull;
		if ( pfcb->pidb == pidbNil )
			{
			dib.pos = posFirst;
			dib.pkey = NULL;
			}
		else
			{
			/*	normalize index name and set key
			/**/
			SysNormText( pfcb->pidb->szName,
				strlen( pfcb->pidb->szName ),
				szNameNorm,
				sizeof( szNameNorm ),
				&key.cb );
			key.pb = szNameNorm;

			dib.pos = posDown;
			dib.pkey = &key;
			}

		Call( ErrDIRDown( pfucb, &dib ) );
		}

	/*	go to stats node
	/**/
	dib.pos = posDown;
	dib.fFlags = fDIRNull;
	dib.pkey = (KEY *)pkeyStats;
	Call( ErrDIRDown( pfucb, &dib ) );

	/*	insert new stats node if one does not exist, or replace
	/*	existing stats node with new one.
	/**/
	line.pb = (BYTE *)psr;
	line.cb = sizeof(SR);

	if ( err == JET_errSuccess )
		{
		/*	replace with new stats node
		/**/
		Call( ErrDIRReplace( pfucb, &line, fDIRVersion ) );
		}
	else
		{
		DIRUp( pfucb, 1 );
		err = ErrDIRInsert( pfucb, &line, pkeyStats, fDIRVersion );
		/*	if other session has inserted stats node, then err will
		/*	be key duplicate, and it must be polymorphed to write conflict.
		/**/
		if ( err == JET_errKeyDuplicate )
			err = JET_errWriteConflict;
		Call( err );
		}

	err = JET_errSuccess;
HandleError:
	Assert( err != JET_errKeyDuplicate );
	return err;
	}


ERR ErrSTATComputeIndexStats( PIB *ppib, FCB *pfcbIdx )
	{
	ERR				err = JET_errSuccess;
	FUCB			*pfucbIdx;
	SR				sr;
	JET_DATESERIAL	dt;

	CallR( ErrDIROpen( ppib, pfcbIdx, 0, &pfucbIdx ) );
	Assert( pfucbIdx != pfucbNil );
	FUCBSetIndex( pfucbIdx );

	/*	initialize stats record
	/**/
	sr.cPages = sr.cItems = sr.cKeys = 0L;
	UtilGetDateTime( &dt );
	memcpy( &sr.dtWhenRun, &dt, sizeof sr.dtWhenRun );

	if ( !FFCBClusteredIndex( pfcbIdx ) )
		FUCBSetNonClustered( pfucbIdx );
	Call( ErrDIRComputeStats( pfucbIdx, &sr.cItems, &sr.cKeys, &sr.cPages ) );
	FUCBResetNonClustered( pfucbIdx );

	/*	write stats
	/**/
	err = ErrSTATWriteStats( pfucbIdx, &sr );

HandleError:
	/*	set non-clustered for cursor reuse support.
	/**/
	if ( !FFCBClusteredIndex( pfcbIdx ) )
		FUCBSetNonClustered( pfucbIdx );
	DIRClose( pfucbIdx );
	return err;
	}


ERR VTAPI ErrIsamComputeStats( PIB *ppib, FUCB *pfucb )
	{
	ERR		err = JET_errSuccess;
	FCB		*pfcbIdx;

	CheckPIB( ppib );
	CheckTable( ppib, pfucb );

	/*	start a transaction, in case anything fails
	/**/
	CallR( ErrDIRBeginTransaction( ppib ) );

	/*	compute stats for each index
	/**/
	Assert( pfucb->u.pfcb != pfcbNil );
	for ( pfcbIdx = pfucb->u.pfcb; pfcbIdx != pfcbNil; pfcbIdx = pfcbIdx->pfcbNextIndex )
		{
		Call( ErrSTATComputeIndexStats( ppib, pfcbIdx ) );
		}

	/*	commit transaction if everything went OK
	/**/
	Call( ErrDIRCommitTransaction( ppib ) );

	return err;

HandleError:
	CallS( ErrDIRRollback( ppib ) );
	return err;
	}


/*=================================================================
ErrSTATSRetrieveStats

Description: Returns the number of records and pages used for a table

Parameters:		ppib				pointer to PIB for current session or ppibNil
				dbid				database id or 0
				pfucb				cursor or pfucbNil
				szTableName			the name of the table or NULL
				pcRecord			pointer to count of records
				pcPage				pointer to count of pages

Errors/Warnings:
				JET_errSuccess or error from called routine.

=================================================================*/
ERR ErrSTATSRetrieveTableStats(
	PIB		*ppib,
	DBID   	dbid,
	char   	*szTable,
	long   	*pcRecord,
	long   	*pcKey,
	long   	*pcPage )
	{
	ERR		err;
	FUCB   	*pfucb;
	DIB		dib;
	KEY		key;
	CHAR   	szIndexNorm[ JET_cbKeyMost ];
	long   	cRecord = 0;
	long   	cKey = 0;
	long   	cPage = 0;

	CallR( ErrFILEOpenTable( ppib, dbid, &pfucb, szTable, 0 ) );

	/*	go to root of FPD
	/**/
	DIRGotoFDPRoot( pfucb );

	/*	down to indexes node
	/**/
	dib.fFlags = fDIRNull;
	dib.pos = posDown;
	dib.pkey = (KEY *)pkeyIndexes;
	Call( ErrDIRDown( pfucb, &dib ) );

	/*	down to clustered index or sequential index node
	/**/
	if ( pfucb->u.pfcb->pidb == NULL )
		{
		key.pb = NULL;
		key.cb = 0;
		}
	else
		{
		/*	normalize index name and set key
		/**/
		SysNormText( pfucb->u.pfcb->pidb->szName,
			strlen( pfucb->u.pfcb->pidb->szName ),
			szIndexNorm,
			sizeof( szIndexNorm ),
			&key.cb );
		key.pb = szIndexNorm;
		}
	Assert( dib.fFlags == fDIRNull );
	Assert( dib.pos == posDown );
	dib.pkey = &key;
	Call( ErrDIRDown( pfucb, &dib ) );

	/* down to stats node
	/**/
	Assert( dib.fFlags == fDIRNull );
	Assert( dib.pos == posDown );
	dib.pkey = (KEY *)pkeyStats;
	/*	stats node may not be present if statistics have not
	/*	been created for this table/index, but INDEXES should
	/*	have at least one son DATA so no need to handle error
	/**/
	Call( ErrDIRDown( pfucb, &dib ) );

	if ( err == JET_errSuccess )
		{
		Call( ErrDIRGet( pfucb ) );
		Assert( pfucb->lineData.cb == sizeof(SR) );
		cRecord = ((UNALIGNED SR *)pfucb->lineData.pb)->cItems;
		cPage = ((UNALIGNED SR *)pfucb->lineData.pb)->cPages;
		cKey = ((UNALIGNED SR *)pfucb->lineData.pb)->cKeys;
		}

	/*	set output variables
	/**/
	if ( pcRecord )
		*pcRecord = cRecord;
	if ( pcPage )
		*pcPage = cPage;
	if ( pcKey )
		*pcKey = cKey;

	/*	set success code
	/**/
	err = JET_errSuccess;

HandleError:
	CallS( ErrFILECloseTable( ppib, pfucb ) );
	return err;
	}


ERR ErrSTATSRetrieveIndexStats(
	FUCB   	*pfucbTable,
	char   	*szIndex,
	long   	*pcItem,
	long   	*pcKey,
	long   	*pcPage )
	{
	ERR		err;
	FUCB   	*pfucb = NULL;
	DIB		dib;
	KEY		key;
	CHAR   	szIndexNorm[ JET_cbKeyMost ];
	long   	cItem = 0;
	long   	cKey = 0;
	long   	cPage = 0;

	/*	open cursor on table domain.
	/**/
	Call( ErrDIROpen( pfucbTable->ppib, pfucbTable->u.pfcb, 0, &pfucb ) );

	/*	down to indexes node
	/**/
	dib.fFlags = fDIRNull;
	dib.pos = posDown;
	dib.pkey = (KEY *)pkeyIndexes;
	Call( ErrDIRDown( pfucb, &dib ) );

	/*	normalize index name and set key
	/**/
	SysNormText( szIndex, strlen( szIndex ), szIndexNorm, sizeof( szIndexNorm ), &key.cb );
	key.pb = szIndexNorm;

	/*	down to index
	/**/
	Assert( dib.fFlags == fDIRNull );
	Assert( dib.pos == posDown );
	dib.pkey = &key;
	Call( ErrDIRDown( pfucb, &dib ) );

	/* down to stats node
	/**/
	Assert( dib.fFlags == fDIRNull );
	Assert( dib.pos == posDown );
	dib.pkey = (KEY *)pkeyStats;
	Call( ErrDIRDown( pfucb, &dib ) );

	if ( err == JET_errSuccess )
		{
		Call( ErrDIRGet( pfucb ) );
		Assert( pfucb->lineData.cb == sizeof(SR) );
		cItem = ((UNALIGNED SR *)pfucb->lineData.pb)->cItems;
		cPage = ((UNALIGNED SR *)pfucb->lineData.pb)->cPages;
		cKey = ((UNALIGNED SR *)pfucb->lineData.pb)->cKeys;
		}

	/*	set output variables
	/**/
	if ( pcItem )
		*pcItem = cItem;
	if ( pcPage )
		*pcPage = cPage;
	if ( pcKey )
		*pcKey = cKey;

HandleError:
    if (pfucb != NULL)
	    DIRClose( pfucb );
	return err;
	}


	ERR VTAPI
ErrIsamGetRecordPosition( PIB *ppib, FUCB *pfucb, JET_RECPOS *precpos, ULONG cbRecpos )
	{
	ERR		err;
	ULONG  	ulLT;
	ULONG	ulTotal;

	CheckPIB( ppib );
	CheckTable( ppib, pfucb );
	Assert( FFUCBIndex( pfucb ) );

	if ( cbRecpos < sizeof(JET_RECPOS) )
		return JET_errInvalidParameter;
	precpos->cbStruct = sizeof(JET_RECPOS);

	/*	get position of non-clustered or clustered cursor
	/**/
	if ( pfucb->pfucbCurIndex != pfucbNil )
		{
		Call( ErrDIRGetPosition( pfucb->pfucbCurIndex, &ulLT, &ulTotal ) );
		}
	else
		{
		Call( ErrDIRGetPosition( pfucb, &ulLT, &ulTotal ) );
		}

	precpos->centriesLT = ulLT;
	//	UNDONE:	remove this bogus field
	precpos->centriesInRange = 1;
	precpos->centriesTotal = ulTotal;

HandleError:
	return err;
	}


ERR ISAMAPI ErrIsamIndexRecordCount( JET_SESID sesid, JET_TABLEID tableid, unsigned long *pulCount, unsigned long ulCountMost )
	{
	ERR	 	err;
	PIB	 	*ppib = (PIB *)sesid;
	FUCB 	*pfucb;
	FUCB 	*pfucbIdx;

	CheckPIB( ppib );

	/*	get pfucb from tableid
	/**/
	CallR( ErrGetVtidTableid( sesid, tableid, (JET_VTID *)&pfucb ) );

	CheckTable( ppib, pfucb );

	/*	get cursor for current index
	/**/
	if ( pfucb->pfucbCurIndex != pfucbNil )
		pfucbIdx = pfucb->pfucbCurIndex;
	else
		pfucbIdx = pfucb;

	err = ErrDIRIndexRecordCount( pfucbIdx, pulCount, ulCountMost, fTrue );
	return err;
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\systab.c ===
#include "config.h"

#ifdef	SYSTABLES		/* whole file */

#include <string.h>

#include "daedef.h"
#include "pib.h"
#include "ssib.h"
#include "page.h"
#include "fucb.h"
#include "fcb.h"
#include "stapi.h"
#include "fdb.h"
#include "idb.h"
#include "dbapi.h"
#include "nver.h"
#include "dirapi.h"
#include "fileapi.h"
#include "systab.h"
#include "info.h"
#include "recapi.h"
#include "util.h"

DeclAssertFile; 				/* Declare file name for assert macros */

#define sidEngine	{0x02, 0x03}

static CODECONST(BYTE ) rgbSidEngine[] = sidEngine;

typedef struct
	{
	OBJID						objidParent;
	const CHAR 				*szName;
	OBJID						objid;
	OBJTYP  					objtyp;
	} SYSOBJECTDEF;

#define szSoObjid 						rgcdescSo[iMSO_Id].szColName
#define szSoType 					 		rgcdescSo[iMSO_Type].szColName
#define szSoName 							rgcdescSo[iMSO_Name].szColName
#define szSoDateUpdate 	 				rgcdescSo[iMSO_DateUpdate].szColName
#define szSoDateCreate 	 				rgcdescSo[iMSO_DateCreate].szColName
#define szSoFlags 						rgcdescSo[iMSO_Flags].szColName
#define szSoParentId 	 				rgcdescSo[iMSO_ParentId].szColName
#define szSoParentIdNameIndex  		rgidescSo[0].szIdxName
#define szSoIdIndex 				 		rgidescSo[1].szIdxName

#define szSiObjectId 					rgcdescSi[iMSI_ObjectId].szColName
#define szSiName                    rgcdescSi[iMSI_Name].szColName
//#define szSiObjectIdNameIndex  		rgidescSi[0].szIdxName

#define szScObjectId 		 			rgcdescSc[iMSC_ObjectId].szColName
#define szScName 							rgcdescSc[iMSC_Name].szColName
#define szScObjectIdNameIndex  		rgidescSc[0].szIdxName

#define szSqObjid     					rgcdescSq[0].szColName
#define szSqAttribute 					rgidescSq[0].szIdxName

#define szSaObjId 						rgcdescSp[0].szColName
#define szSaceId  						rgidescSp[0].szIdxName

static CODECONST(SYSOBJECTDEF) rgsysobjdef[] =
	{
	{ objidRoot,			szTcObject, 	 	objidTblContainer, 	JET_objtypContainer },
	{ objidRoot,			szDcObject, 		objidDbContainer,  	JET_objtypContainer },
	{ objidRoot,			"Relationships", 	objidRcContainer,   	JET_objtypContainer },
	{ objidDbContainer,	szDbObject, 	 	objidDbObject,     	JET_objtypDb }
	};

static CODECONST(CDESC) rgcdescSo[] =
	{
	"Id", 				JET_coltypLong, 				JET_bitColumnNotNULL, 	0,
	"ParentId", 		JET_coltypLong, 				JET_bitColumnNotNULL, 	0,
	"Name", 				JET_coltypText, 				JET_bitColumnNotNULL, 	JET_cbColumnMost,
	"Type", 				JET_coltypShort, 				JET_bitColumnNotNULL, 	0,
	"DateCreate", 		JET_coltypDateTime, 			JET_bitColumnNotNULL, 	0,
	"DateUpdate", 		JET_coltypDateTime, 			0,		 						0,
	"Rgb",				JET_coltypBinary,				0,								JET_cbColumnMost,
	"Lv",					JET_coltypLongBinary,		0,								0,
	"Owner", 			JET_coltypBinary, 			0, 							JET_cbColumnMost,
	"Database", 		JET_coltypLongText, 			0, 							0,
	"Connect", 			JET_coltypLongText, 			0, 							0,
	"ForeignName", 	JET_coltypText, 				0, 							JET_cbColumnMost,
	"RmtInfoShort",	JET_coltypBinary,				0,								JET_cbColumnMost,
	"RmtInfoLong",		JET_coltypLongBinary,		0,								0,
	"Flags", 			JET_coltypLong, 				0, 							0,
	"LvExtra", 			JET_coltypLongBinary, 		0, 							0,
	"Description", 	JET_coltypLongText, 			0, 							0,
	"LvModule", 		JET_coltypLongBinary, 		0, 							0,
	"LvProp",			JET_coltypLongBinary,		0,			 					0,
	/*	JET Blue tables only
	/**/
	"Pages", 			JET_coltypLong, 				0, 							0,
	"Density", 			JET_coltypLong, 				0, 							0
	};

JET_COLUMNID rgcolumnidSo[sizeof(rgcdescSo)/sizeof(CDESC)];

static CODECONST(CDESC) rgcdescSc[] =
	{
	"ObjectId", 		JET_coltypLong, 				JET_bitColumnNotNULL, 	0,
	"Name", 				JET_coltypText, 				JET_bitColumnNotNULL, 	JET_cbColumnMost,
	"ColumnId",			JET_coltypLong,				JET_bitColumnNotNULL,	0,
	"Coltyp", 			JET_coltypUnsignedByte, 	JET_bitColumnNotNULL, 	0,
	"FAutoincrement", JET_coltypBit, 				JET_bitColumnNotNULL, 	0,
	"FDisallowNull", 	JET_coltypBit, 				JET_bitColumnNotNULL, 	0,
	"FVersion", 		JET_coltypBit, 				JET_bitColumnNotNULL, 	0,
	"CodePage", 		JET_coltypShort, 				JET_bitColumnNotNULL, 	0,
	"LanguageId", 		JET_coltypShort, 				JET_bitColumnNotNULL,  	0,
	"Country",			JET_coltypShort,				JET_bitColumnNotNULL,	0,
	"FRestricted", 	JET_coltypBit, 				JET_bitColumnNotNULL, 	0,
	"RmtInfoShort",	JET_coltypBinary,				0,								JET_cbColumnMost,
	"RmtInfoLong",		JET_coltypLongBinary,		0,								0,
	"LvExtra", 			JET_coltypLongBinary, 		0, 							0,
	"Description", 	JET_coltypLongText, 			0, 							0,
	"PresentationOrder", JET_coltypLong, 			0, 							0,
	};

JET_COLUMNID rgcolumnidSc[sizeof(rgcdescSc)/sizeof(CDESC)];

static CODECONST(CDESC) rgcdescSi[] =
	{
	"ObjectId",				JET_coltypLong, 				JET_bitColumnNotNULL, 	0,
	"Name", 					JET_coltypText, 				JET_bitColumnNotNULL, 	JET_cbColumnMost,
	"FUnique", 				JET_coltypBit, 				JET_bitColumnNotNULL, 	0,
	"FPrimary", 			JET_coltypBit, 				JET_bitColumnNotNULL, 	0,
	"FExcludeAllNull", 	JET_coltypBit, 				JET_bitColumnNotNULL, 	0,
	"FIgnoreNull",			JET_coltypBit, 				JET_bitColumnNotNULL, 	0,
	"FClustered", 			JET_coltypBit, 				JET_bitColumnNotNULL, 	0,
	"MatchType",			JET_coltypUnsignedByte,		0,							 	0,
	"UpdateAction",		JET_coltypUnsignedByte,		0, 							0,
	"DeleteAction",		JET_coltypUnsignedByte,		0, 							0,
	"ObjectIdReference",	JET_coltypLong,				0,								0,
	"IdxidReference",		JET_coltypShort,				0,								0,
	"RgkeydReference",	JET_coltypBinary,				0,								JET_cbColumnMost,
	"RglocaleReference",	JET_coltypBinary,				0,								JET_cbColumnMost,
	"FDontEnforce",		JET_coltypBit,					0,								0,
	"RmtInfoShort",		JET_coltypBinary,				0,								JET_cbColumnMost,
	"RmtInfoLong",			JET_coltypLongBinary,		0,								0,
	"LvExtra", 				JET_coltypLongBinary,	 	0, 							0,
	"Description", 		JET_coltypLongText, 			0, 							0,
	/*	JET Blue indexes only
	/**/
	"Density",				JET_coltypLong, 				JET_bitColumnNotNULL, 	0
	};

JET_COLUMNID rgcolumnidSi[sizeof(rgcdescSi)/sizeof(CDESC)];

static CODECONST(CDESC) rgcdescSp[] =
	{
	"ObjectId", 		JET_coltypLong, 				JET_bitColumnNotNULL, 	0,
	"SID", 				JET_coltypBinary, 			JET_bitColumnNotNULL, 	JET_cbColumnMost,
	"ACM", 				JET_coltypLong, 				JET_bitColumnNotNULL, 	0,
	"FInheritable",	JET_coltypBit, 				JET_bitColumnNotNULL, 	0
	};

JET_COLUMNID rgcolumnidSp[sizeof(rgcdescSp)/sizeof(CDESC)];

static CODECONST(CDESC) rgcdescSq[] =
	{
	"ObjectId", 		JET_coltypLong, 				JET_bitColumnNotNULL,	0,
	"Attribute", 		JET_coltypUnsignedByte,		0, 							0,
	"Order", 			JET_coltypBinary, 			0, 							128,
	"Name1", 			JET_coltypText, 				0, 							JET_cbColumnMost,
	"Name2", 			JET_coltypText, 				0, 							JET_cbColumnMost,
	"Expression", 		JET_coltypLongText, 			0, 							0,
	"Flag", 				JET_coltypShort, 				0, 							0
	};

JET_COLUMNID rgcolumnidSq[sizeof(rgcdescSq)/sizeof(CDESC)];

static CODECONST(CDESC) rgcdescSr[] =
	{
	"szRelationship",			JET_coltypText,	JET_bitColumnNotNULL,	JET_cbColumnMost,
	"grbit",						JET_coltypLong,	JET_bitColumnNotNULL,	0,					
	"ccolumn",					JET_coltypLong,	JET_bitColumnNotNULL,	0,					
	"icolumn",					JET_coltypLong,	JET_bitColumnNotNULL,	0,					
	"szObject",					JET_coltypText,	JET_bitColumnNotNULL,	JET_cbColumnMost,
	"szColumn",					JET_coltypText,	JET_bitColumnNotNULL,	JET_cbColumnMost,
	"szReferencedObject",	JET_coltypText,	JET_bitColumnNotNULL,	JET_cbColumnMost,
	"szReferencedColumn",	JET_coltypText,	JET_bitColumnNotNULL,	JET_cbColumnMost,
	};

JET_COLUMNID rgcolumnidSr[sizeof(rgcdescSr)/sizeof(CDESC)];

static CODECONST(IDESC) rgidescSo[] =
	{
	"ParentIdName", 	"+ParentId\0+Name\0", 	JET_bitIndexUnique | JET_bitIndexDisallowNull,
	"Id", 				"+Id\0", 					JET_bitIndexClustered | JET_bitIndexPrimary | JET_bitIndexUnique | JET_bitIndexDisallowNull
	};

static CODECONST(IDESC) rgidescSc[] =
	{
	"ObjectIdName", 	"+ObjectId\0+Name\0", 	JET_bitIndexClustered | JET_bitIndexPrimary | JET_bitIndexUnique | JET_bitIndexDisallowNull
	};

static CODECONST(IDESC) rgidescSi[] =
	{
	"ObjectIdName", 	"+ObjectId\0+Name\0", 	JET_bitIndexClustered | JET_bitIndexUnique
	};

static CODECONST(IDESC) rgidescSp[] =
	{
	"ObjectId", 		"+ObjectId\0", 		JET_bitIndexClustered | JET_bitIndexDisallowNull
	};

static CODECONST(IDESC) rgidescSq[] =
	{
	"ObjectIdAttribute", 	"+ObjectId\0+Attribute\0+Order\0", JET_bitIndexClustered | JET_bitIndexPrimary | JET_bitIndexUnique | JET_bitIndexDisallowNull
	};

static CODECONST(IDESC) rgidescSr[] =
	{
	"szRelationship", "+szRelationship\0", JET_bitIndexClustered,
	"szObject", "+szObject\0", 0,
	"szReferencedObject", "+szReferencedObject\0", 0
	};

CODECONST(SYSTABLEDEF) rgsystabdef[] =
	{
	szSoTable, rgcdescSo, rgidescSo, sizeof(rgcdescSo)/sizeof(CDESC), sizeof(rgidescSo)/sizeof(IDESC), 1, rgcolumnidSo,
	szScTable, rgcdescSc, rgidescSc, sizeof(rgcdescSc)/sizeof(CDESC), sizeof(rgidescSc)/sizeof(IDESC),	4, rgcolumnidSc,
	szSiTable, rgcdescSi, rgidescSi, sizeof(rgcdescSi)/sizeof(CDESC), sizeof(rgidescSi)/sizeof(IDESC),	1, rgcolumnidSi,
#ifdef NJETNT
	szSpTable, rgcdescSp, rgidescSp, sizeof(rgcdescSp)/sizeof(CDESC), sizeof(rgidescSp)/sizeof(IDESC),	0, rgcolumnidSp,
	szSqTable, rgcdescSq, rgidescSq, sizeof(rgcdescSq)/sizeof(CDESC), sizeof(rgidescSq)/sizeof(IDESC),	0, rgcolumnidSq,
	"MSysRelationships", rgcdescSr, rgidescSr, sizeof(rgcdescSr)/sizeof(CDESC), sizeof(rgidescSr)/sizeof(IDESC),	3, rgcolumnidSr,
#endif
	};

#define csystabs ( sizeof(rgsystabdef) / sizeof(SYSTABLEDEF) )


JET_COLUMNID	*pcolumnidSc;

/*=================================================================
ErrSysTabCreate

Description:

	Called from ErrIsamCreateDatabase; creates all system tables

Parameters:

	PIB		*ppib		; PIB of user
	DBID	dbid		; dbid of database that needs tables

Return Value:

	whatever error it encounters along the way

=================================================================*/

ERR ErrSysTabCreate( PIB *ppib, DBID dbid )
	{
	/* NOTE:	Since the System Tables are inserted as records into
	/*			themselves, we have to special-case in the beginning
	/*			to avoid trying to insert a record into a table with
	/*			no columns. CreateTable, CreateIndex and AddColumn thus
	/*			do as their first action a check of their dbid. If it's
	/*			>= dbidMax, then they don't Call STI ( they fix it up by
	/*			subrtracting dbidMax, as well ). Thus, all of these Calls
	/*			to CT, CI, AC must add dbidMax to the dbid before making the
	/*			Call.
	/**/

	ERR				err;
	unsigned			i;
	unsigned			j;
	LINE				line;
	JET_DATESERIAL	dtNow;
	OBJTYP  			objtypTemp;
	OBJID				objidParentId;
	static LINE		rgline[ilineSxMax];
	FUCB				*rgpfucb[csystabs];
	ULONG				rgobjid[csystabs];
	ULONG				ulFlag;

	//	UNDONE:		international support.  Set these values from
	//					create database connect string.
	USHORT  			cp = usEnglishCodePage;
	USHORT 			langid = 0x0409;
	WORD				wCountry = 1;

	BYTE				fAutoincrement = 0;
	BYTE				fDisallowNull = 0;
	BYTE				fVersion = 0;
	BYTE				fRestricted = 0;
	BYTE				fUnique = 0;
	BYTE				fPrimary = 0;
	BYTE				fIgnoreNull = 0;
	BYTE				fClustered = 0;
	JET_COLUMNID	*pcolumnid;
	ULONG				ulDensity = ulDefaultDensity;

	/* init rgpfucb[] to pfucbNil to allow error recovery
	/**/
	for ( i = 0; i < csystabs; i++)
		rgpfucb[i] = pfucbNil;

	/* setup dbid flag to put off STI Calls
	/**/
	dbid += dbidMax;

	/* create System Tables
	/**/
	for ( i = 0; i < csystabs; i++ )
		{
		CODECONST(CDESC)	*pcdesc;
		CODECONST(IDESC)	*pidesc;

		Call( ErrFILECreateTable( ppib, dbid, rgsystabdef[i].szName, rgsystabdef[i].cpg, ulDensity, &rgpfucb[i] ) )

		/*	create columns
		/**/
		pcdesc = rgsystabdef[i].pcdesc;
		pcolumnid = rgsystabdef[i].rgcolumnid;

		for ( j = 0; j < rgsystabdef[i].ccolumn; j++, pcdesc++ )
			{
			JET_COLUMNDEF	columndef;
			columndef.cbStruct = sizeof(columndef);
			columndef.coltyp = pcdesc->coltyp;
			columndef.cp = cp;
			columndef.langid = langid;
			columndef.wCountry = wCountry;
			columndef.cbMax = pcdesc->ulMaxLen;
			columndef.grbit = pcdesc->grbit;

			rgpfucb[i]->dbid = dbid;
			Call( ErrIsamAddColumn( ppib,
		  		rgpfucb[i],
		  		pcdesc->szColName,
		  		&columndef,
		  		NULL,
		  		0,
		  		(JET_COLUMNID *)( pcolumnid + j ) ) );
			}

		/*	create indexes
		/**/
		pidesc = rgsystabdef[i].pidesc;
		for ( j = 0; j < rgsystabdef[i].cindex; j++, pidesc++ )
			{
			const BYTE *pTemp;

			rgpfucb[i]->dbid = dbid;
			line.pb = pidesc->szIdxKeys;

			pTemp = line.pb;
			forever
				{
				while ( *pTemp != '\0' )
					pTemp++;
				if ( *(++pTemp) == '\0' )
					break;
				}
			line.cb = (UINT)(pTemp - line.pb) + 1;
			Call( ErrIsamCreateIndex( ppib,
				rgpfucb[i],
				pidesc->szIdxName,
				pidesc->grbit,
				(CHAR *) line.pb,
				(ULONG) line.cb,
				ulDensity ) );
			}
		}

	/* unset dbid flag to do the postponed STI Calls
	/**/
	dbid -= dbidMax;

	/* close system tables
	/**/
	for ( i = 0; i < csystabs; i++ )
		{
		rgobjid[i] = rgpfucb[i]->u.pfcb->pgnoFDP;
		CallS( ErrFILECloseTable( ppib, rgpfucb[i] ) );
		rgpfucb[i] = pfucbNil;
		}

	/*	table records
	/**/
	memset( &dtNow, 0, sizeof(dtNow) );
	ulFlag = JET_bitObjectSystem;

	rgline[iMSO_DateCreate].pb		= (BYTE *)&dtNow;
	rgline[iMSO_DateCreate].cb		= sizeof(JET_DATESERIAL);
	rgline[iMSO_DateUpdate].pb		= (BYTE *)&dtNow;
	rgline[iMSO_DateUpdate].cb		= sizeof(JET_DATESERIAL);
	rgline[iMSO_Rgb].cb				= 0;
	rgline[iMSO_Lv].cb				= 0;
	rgline[iMSO_Owner].pb			= (BYTE *)rgbSidEngine;
	rgline[iMSO_Owner].cb			= sizeof(rgbSidEngine);
	rgline[iMSO_Database].cb		= 0;
	rgline[iMSO_Connect].cb 		= 0;
	rgline[iMSO_ForeignName].cb	= 0;
	rgline[iMSO_RmtInfoShort].cb	= 0;
	rgline[iMSO_RmtInfoLong].cb	= 0;
	rgline[iMSO_Flags].pb			= (BYTE *)&ulFlag;
	rgline[iMSO_Flags].cb			= sizeof(ULONG);
	rgline[iMSO_LvExtra].cb 		= 0;
	rgline[iMSO_Description].cb	= 0;
	rgline[iMSO_LvModule].cb 		= 0;
	rgline[iMSO_LvProp].cb			= 0;
	rgline[iMSO_Pages].pb 			= (BYTE *) &rgsystabdef[i].cpg;
	rgline[iMSO_Pages].cb 			= sizeof(rgsystabdef[i].cpg);
	rgline[iMSO_Density].pb 		= (BYTE *) &ulDensity;
	rgline[iMSO_Density].cb			= sizeof(ulDensity);

	for ( i = 0; i < ( sizeof(rgsysobjdef) / sizeof(SYSOBJECTDEF) ); i++ )
		{
		rgline[iMSO_Id].pb			= (BYTE *) &rgsysobjdef[i].objid;
		rgline[iMSO_Id].cb			= sizeof(OBJID);
		rgline[iMSO_ParentId].pb	= (BYTE *) &rgsysobjdef[i].objidParent;
		rgline[iMSO_ParentId].cb	= sizeof(OBJID);
		rgline[iMSO_Name].pb			= (BYTE *) rgsysobjdef[i].szName;
		rgline[iMSO_Name].cb			= strlen( rgsysobjdef[i].szName );
		rgline[iMSO_Type].pb			= (BYTE *) &rgsysobjdef[i].objtyp;
		rgline[iMSO_Type].cb			= sizeof(OBJTYP);

		Call( ErrSysTabInsert( ppib, dbid, itableSo, rgline, 0 ) )
		}

	objidParentId = objidTblContainer;
	objtypTemp  = JET_objtypTable;

	rgline[iMSO_ParentId].pb		= (BYTE *)&objidParentId;
	rgline[iMSO_ParentId].cb		= sizeof(objidParentId);
	rgline[iMSO_Type].pb				= (BYTE *)&objtypTemp;
	rgline[iMSO_Type].cb				= sizeof(objtypTemp);

	for ( i = 0; i < csystabs; i++ )
		{
		rgline[iMSO_Id].pb			= (BYTE *)&rgobjid[i];
		rgline[iMSO_Id].cb			= sizeof(LONG);
		rgline[iMSO_Name].pb			= (BYTE *)rgsystabdef[i].szName;
		rgline[iMSO_Name].cb			= strlen( rgsystabdef[i].szName );

		Call( ErrSysTabInsert( ppib, dbid, itableSo, rgline, 0 ) )
		}

	/*	column records
	/**/
	rgline[iMSC_FAutoincrement].pb 	= &fAutoincrement;
	rgline[iMSC_FAutoincrement].cb 	= sizeof(BYTE);
	rgline[iMSC_FDisallowNull].pb		= &fDisallowNull;
	rgline[iMSC_FDisallowNull].cb		= sizeof(BYTE);
	rgline[iMSC_FVersion].pb			= &fVersion;
	rgline[iMSC_FVersion].cb			= sizeof(BYTE);
	rgline[iMSC_CodePage].pb			= (BYTE *)&cp;
	rgline[iMSC_CodePage].cb			= sizeof(cp);
	rgline[iMSC_LanguageId].pb			= (BYTE *)&langid;
	rgline[iMSC_LanguageId].cb			= sizeof(langid);
	rgline[iMSC_Country].pb				= (BYTE *)&wCountry;
	rgline[iMSC_Country].cb				= sizeof(wCountry);
	rgline[iMSC_FRestricted].pb	 	= &fRestricted;
	rgline[iMSC_FRestricted].cb	 	= sizeof(BYTE);
	rgline[iMSC_RmtInfoShort].cb	 	= 0;
	rgline[iMSC_RmtInfoLong].cb	 	= 0;
	rgline[iMSC_Description].cb	 	= 0;
	rgline[iMSC_LvExtra].cb 			= 0;
	rgline[iMSC_POrder].cb				= 0;

	for ( i = 0; i < csystabs; i++ )
		{
		CODECONST( CDESC ) *pcdesc;

		pcdesc = rgsystabdef[i].pcdesc;
		pcolumnid = rgsystabdef[i].rgcolumnid;
		
		rgline[iMSC_ObjectId].pb 		= (BYTE *)&rgobjid[i];
		rgline[iMSC_ObjectId].cb 		= sizeof(LONG);

		for ( j = 0; j < rgsystabdef[i].ccolumn; j++, pcdesc++ )
			{
			rgline[iMSC_Name].pb 		= pcdesc->szColName;
			rgline[iMSC_Name].cb 		= strlen( pcdesc->szColName );
			rgline[iMSC_ColumnId].pb	= (BYTE *)( pcolumnid + j );
			rgline[iMSC_ColumnId].cb  	= sizeof(JET_COLUMNID);
			rgline[iMSC_Coltyp].pb 		= (BYTE *) &pcdesc->coltyp;
			rgline[iMSC_Coltyp].cb 		= sizeof(BYTE);

			Call( ErrSysTabInsert( ppib, dbid, itableSc, rgline, 0 ) )
			}
		}

	/*	index records
	/**/
	rgline[iMSI_FUnique].pb 				= (BYTE *) &fUnique;
	rgline[iMSI_FUnique].cb 				= sizeof(BYTE);
	rgline[iMSI_FPrimary].pb 				= (BYTE *) &fPrimary;
	rgline[iMSI_FPrimary].cb 				= sizeof(BYTE);
	rgline[iMSI_FDisallowNull].pb 		= (BYTE *) &fDisallowNull;
	rgline[iMSI_FDisallowNull].cb 		= sizeof(BYTE);
	rgline[iMSI_FExcludeAllNull].pb 		= (BYTE *) &fIgnoreNull;
	rgline[iMSI_FExcludeAllNull].cb 		= sizeof(BYTE);
	rgline[iMSI_FClustered].pb 			= (BYTE *) &fClustered;
	rgline[iMSI_FClustered].cb 			= sizeof(BYTE);
	rgline[iMSI_MatchType].cb 				= 0;
	rgline[iMSI_UpdateAction].cb 			= 0;
	rgline[iMSI_DeleteAction].cb 			= 0;
	rgline[iMSI_ObjectIdReference].cb	= 0;
	rgline[iMSI_IdxidReference].cb 		= 0;
	rgline[iMSI_RgkeydReference].cb 		= 0;
	rgline[iMSI_RglocaleReference].cb 	= 0;
	rgline[iMSI_FDontEnforce].cb 			= 0;
	rgline[iMSI_LvExtra].cb		 			= 0;
	rgline[iMSI_Description].cb	 		= 0;
	rgline[iMSI_Density].pb					= (BYTE *) &ulDensity;
	rgline[iMSI_Density].cb 				= sizeof(ulDensity);

	for ( i = 0; i < csystabs; i++ )
		{
		CODECONST( IDESC ) *pidesc;

		pidesc = rgsystabdef[i].pidesc;

		rgline[iMSI_ObjectId].pb 			= (BYTE *)&rgobjid[i];
		rgline[iMSI_ObjectId].cb 			= sizeof(LONG);

		for ( j = 0; j < rgsystabdef[i].cindex; j++, pidesc++ )
			{
			rgline[iMSI_Name].pb 			= pidesc->szIdxName;
			rgline[iMSI_Name].cb 			= strlen( pidesc->szIdxName );

			Call( ErrSysTabInsert( ppib, dbid, itableSi, rgline, 0 ) )
			}
		}

	return JET_errSuccess;

HandleError:

	/* close any system tables that are still open
	/**/
	for ( i = 0; i < csystabs; i++ )
		if ( rgpfucb[i] != pfucbNil )
			CallS( ErrFILECloseTable( ppib, rgpfucb[i] ) );
		
	/* fall out, passing on the error that got us here */
	return( err );
	}


/*=================================================================
ErrSysTabInsert

Description:

	Inserts a record into a system table when new tables, indexes,
	or columns are added to the database.

Parameters:

	PIB		*ppib;
	DBID		dbid;
	INT		itable;
	LINE		rgline[];

Return Value:

	whatever error it encounters along the way

=================================================================*/

ERR ErrSysTabInsert( PIB *ppib, DBID dbid, INT itable, LINE rgline[], OBJID objid )
	{
	ERR						err;
	FUCB						*pfucb;
	CODECONST( CDESC )	*pcdesc;
	unsigned					i;
	JET_COLUMNID			columnid;

	/*	open system table
	/**/
	CallR( ErrFILEOpenTable( ppib, dbid, &pfucb, rgsystabdef[itable].szName, 0 ) )
	Call( ErrIsamPrepareUpdate( ppib, pfucb, JET_prepInsert ) )

	pcdesc = rgsystabdef[itable].pcdesc;

	for ( i = 0; i < rgsystabdef[itable].ccolumn; i++, pcdesc++ )
		{
		if ( rgline[i].cb == 0 )
			continue;
		Call( ErrFILEGetColumnId( ppib, pfucb, pcdesc->szColName, &columnid ) )
		Call( ErrIsamSetColumn( ppib, pfucb, columnid, rgline[i].pb, rgline[i].cb, 0, NULL ) )
		}

	/* insert record into system table
	/**/
	Call( ErrIsamUpdate( ppib, pfucb, NULL, 0, NULL ) )

	/* close system table
	/**/
	CallS( ErrFILECloseTable( ppib, pfucb ) );

	/* timestamp owning table if applicable
	/**/
	if ( objid != 0 && ( ( itable == itableSi ) || ( itable == itableSc ) ) )
		{
		CallR( ErrSysTabTimestamp( ppib, dbid, objid ) )
		}

	return JET_errSuccess;

HandleError:
	CallS( ErrFILECloseTable( ppib, pfucb ) );
	return( err );
	}

/*=================================================================
ErrSysTabDelete

Description:

	Deletes records from System Tables when tables, indexes, or
	columns are removed from the database.

Parameters:

	PIB		*ppib;
	DBID		dbid;
	INT		itable;
	CHAR		*szName;
	OBJID		objid;

=================================================================*/
ERR ErrSysTabDelete( PIB *ppib, DBID dbid, INT itable, CHAR *szName, OBJID objid )
	{
	ERR				err;
	FUCB				*pfucb;
	JET_COLUMNID	columnid;
	LINE				line;
	OBJID				objidFound;
	OBJID				objidParentId;
	ULONG				cbActual;

	Call( ErrFILEOpenTable( ppib, dbid, &pfucb, rgsystabdef[itable].szName, 0 ) )

	switch ( itable )
		{
		case itableSo:
			Call( ErrIsamSetCurrentIndex( ppib, pfucb, szSoParentIdNameIndex ) )
			/* set up key and seek for record in So
			/**/
			objidParentId = objidTblContainer;
			line.pb = (BYTE *)&objidParentId;
			line.cb = sizeof(objidParentId);
			Call( ErrIsamMakeKey( ppib, pfucb, line.pb, line.cb, JET_bitNewKey ) )
			line.pb = szName;
			line.cb = strlen( szName );
			Call( ErrIsamMakeKey( ppib, pfucb, line.pb, line.cb, 0 ) )

			err = ErrIsamSeek( ppib, pfucb, JET_bitSeekEQ );
			if ( err != JET_errSuccess )
				goto HandleError;

			/* get the table id, then delete it
			/**/
			Call( ErrFILEGetColumnId( ppib, pfucb, szSoObjid, &columnid ) );
			Call( ErrIsamRetrieveColumn( ppib,
				pfucb,
				columnid,
				(BYTE *)&objid,
				sizeof(objid),
				&cbActual,
				0,
				NULL ) );
			Call( ErrIsamDelete( ppib, pfucb ) );
			CallS( ErrFILECloseTable( ppib, pfucb ) );

			/* delete associated indexes
			/**/
			Call( ErrFILEOpenTable( ppib, dbid, &pfucb, szSiTable, 0 ) );
			Call( ErrIsamSetCurrentIndex( ppib, pfucb, szSiObjectIdNameIndex ) );

			/* set up key and seek for first record in itableSi
			/**/
			line.pb = (BYTE *)&objid;
			line.cb = sizeof(objid);
			Call( ErrIsamMakeKey( ppib, pfucb, line.pb, line.cb, JET_bitNewKey ) );

			/*	seek may not find anything
		 	/**/
			if ( ( ErrIsamSeek( ppib, pfucb, JET_bitSeekGE ) ) >= 0 )
				{
				Call( ErrFILEGetColumnId( ppib, pfucb, szSiObjectId, &columnid ) );
				while ( ( ( ErrIsamRetrieveColumn( ppib,
					pfucb,
					columnid,
					(BYTE *)&objidFound,
					sizeof(objidFound),
					&cbActual,
					0,
					NULL ) ) >= 0 ) &&
					( objidFound == objid ) )
					{
					Call( ErrIsamDelete( ppib, pfucb ) );
					err = ErrIsamMove( ppib, pfucb, JET_MoveNext, 0 );
					if ( err == JET_errNoCurrentRecord )
						err = JET_errSuccess;
					if ( err < 0 )
						goto HandleError;
					}
				}

			CallS( ErrFILECloseTable( ppib, pfucb ) );

			/* delete associated columns
			/**/
			Call( ErrFILEOpenTable( ppib, dbid, &pfucb, szScTable, 0 ) )
			Call( ErrIsamSetCurrentIndex( ppib, pfucb, szScObjectIdNameIndex ) )

			/* set up key and seek for first record in itableSi
			/**/
			line.pb = (BYTE *)&objid;
			line.cb = sizeof(objid);
			Call( ErrIsamMakeKey( ppib, pfucb, line.pb, line.cb, JET_bitNewKey ) )

			if ( ( ErrIsamSeek( ppib, pfucb, JET_bitSeekGE ) ) >= 0 )
				{
				Call( ErrFILEGetColumnId( ppib, pfucb, szScObjectId, &columnid ) )
				while ( ( ( ErrIsamRetrieveColumn( ppib,
					pfucb,
					columnid,
					(BYTE *) &objidFound,
					sizeof(objidFound),
					&cbActual,
					0,
					NULL ) ) >= 0 ) &&
					( objidFound == objid ) )
					{
					Call( ErrIsamDelete( ppib, pfucb ) );
					err = ErrIsamMove( ppib, pfucb, JET_MoveNext, 0 );
					if ( err == JET_errNoCurrentRecord )
						err = JET_errSuccess;
					if ( err < 0 )
						goto HandleError;
					}
				}
			CallS( ErrFILECloseTable( ppib, pfucb ) );
			break;

		case itableSi:
			Call( ErrIsamSetCurrentIndex( ppib, pfucb, szSiObjectIdNameIndex ) )

			/* set up key and seek for record in itableSi
			/**/
			line.pb = (BYTE *) &objid;
			line.cb = sizeof(objid);
			Call( ErrIsamMakeKey( ppib, pfucb, line.pb, line.cb, JET_bitNewKey ) )
			line.pb = (BYTE *) szName;
			line.cb = strlen( szName );
			Call( ErrIsamMakeKey( ppib, pfucb, line.pb, line.cb, 0 ) )

			err = ErrIsamSeek( ppib, pfucb, JET_bitSeekEQ );
			if ( err != JET_errSuccess )
				goto HandleError;
			Call( ErrIsamDelete( ppib, pfucb ) )
			break;
		default:
			Assert( itable == itableSc );
			Call( ErrIsamSetCurrentIndex( ppib, pfucb, szScObjectIdNameIndex ) )

			/* set up key and seek for record in itableSc
			/**/
			line.pb = (BYTE *)&objid;
			line.cb = sizeof(objid);
			Call( ErrIsamMakeKey( ppib, pfucb, line.pb, line.cb, JET_bitNewKey ) )
			line.pb = (BYTE *) szName;
			line.cb = strlen( szName );
			Call( ErrIsamMakeKey( ppib, pfucb, line.pb, line.cb, 0 ) )

			err = ErrIsamSeek( ppib, pfucb, JET_bitSeekEQ );
			if ( err != JET_errSuccess )
				goto HandleError;
			Call( ErrIsamDelete( ppib, pfucb ) )
			break;
		}
	
	/* close table and timestamp owning table if applicable
	/**/
	if ( objid != 0 && ( ( itable == itableSi ) || ( itable == itableSc ) ) )
		{
		CallS( ErrFILECloseTable( ppib, pfucb ) );
		Call( ErrSysTabTimestamp( ppib, dbid, objid ) )
		}

	return JET_errSuccess;

HandleError:
	return err;
	}


/*=================================================================
ErrSysTabRename

Description:

	Alters system table records.

Parameters:

	PIB		*ppib;
	DBID		dbid;
	CHAR		*szNew;
	CHAR		*szName;
	OBJID		objid;
	INT		itable;

=================================================================*/

ERR ErrSysTabRename(
	PIB					*ppib,
	DBID					dbid,
	CHAR					*szNew,
	CHAR					*szName,
	OBJID					objid,
	INT					itable )
	{
	ERR					err;
	ERR					errDuplicate;
   const CHAR		  	*szIndexToUse;
   CHAR					*szRenameField;
	FUCB					*pfucb;
	JET_COLUMNID		columnid;
	JET_DATESERIAL		dtNow;

	switch ( itable )
		{
		case itableSo:
			szIndexToUse  = szSoParentIdNameIndex;
			szRenameField = szSoName;
			errDuplicate  = JET_errObjectDuplicate;
			break;
		case itableSi:
			szIndexToUse  = szSiObjectIdNameIndex;
			szRenameField = szSiName;
			errDuplicate  = JET_errIndexDuplicate;
			break;
		default:
			Assert( itable == itableSc );
			szIndexToUse  = szScObjectIdNameIndex;
			szRenameField = szScName;
			errDuplicate  = JET_errColumnDuplicate;
		}

	CallR( ErrFILEOpenTable( ppib, dbid, &pfucb, rgsystabdef[itable].szName, 0 ) );
	Call( ErrIsamSetCurrentIndex( ppib, pfucb, szIndexToUse ) );

	// Set up key and seek for table record.
	Call( ErrIsamMakeKey( ppib, pfucb, (BYTE *)&objid, sizeof(objid), JET_bitNewKey ) );
	Call( ErrIsamMakeKey( ppib, pfucb, szName, strlen( szName ), 0 ) );

	err = ErrIsamSeek( ppib, pfucb, JET_bitSeekEQ );
	if ( err != JET_errSuccess )
		goto HandleError;

	if ( itable == itableSc || itable == itableSi )
   	{
		// When the name to change is part of the clustered index (as
		// is the case for columns and indexes), we can't simply replace
		// the old name with the new name because the physical position
		// of the record would change, thus invalidating any bookmarks.
		// Hence, we must do a manual delete, then insert.
		// This part is a little tricky.  Our call to PrepareUpdate
		// provided us with a copy buffer.  So now, when we call Delete,
		// we'll still have a copy of the record we just deleted.
		// Here, we're inserting a new record, but we're using the
		// information from the copy buffer.

		Call( ErrIsamPrepareUpdate( ppib, pfucb, JET_prepInsertCopy ) );
		Call( ErrFILEGetColumnId( ppib, pfucb, szRenameField, &columnid ) );
		Call( ErrIsamSetColumn( ppib, pfucb, columnid, szNew, strlen( szNew ), 0, NULL ) );
		Call( ErrIsamUpdate( ppib, pfucb, NULL, 0, NULL ) );

		Call( ErrIsamDelete( ppib, pfucb ) );

		/*	update the timestamp of the corresponding object
		/**/
		Call( ErrSysTabTimestamp( ppib, dbid, objid ) );
		}
	else
		{
		// Right now, if we get here, we must be trying to rename an
		// object (later on, if we want to support more MSys things,
		// we might expand this 'if' construct into a 'switch').
		Assert( itable == itableSo );

		Call( ErrIsamPrepareUpdate( ppib, pfucb, JET_prepReplaceNoLock ) );

		// The name is not part of the clustered index, so a simple
		// replace is okay.
		Call( ErrFILEGetColumnId( ppib, pfucb, szRenameField, &columnid ) );
		Call( ErrIsamSetColumn( ppib, pfucb, columnid, szNew, strlen( szNew ), 0, NULL ) );

		// Update date/time stamp.
		Call( ErrFILEGetColumnId( ppib, pfucb, szSoDateUpdate, &columnid ) );
		UtilGetDateTime( &dtNow );
		Call( ErrIsamSetColumn( ppib, pfucb, columnid, (BYTE *)&dtNow, sizeof(dtNow), 0, NULL ) );
		Call( ErrIsamUpdate( ppib, pfucb, NULL, 0, NULL ) );
		}

	CallS( ErrFILECloseTable( ppib, pfucb ) );
	return JET_errSuccess;

HandleError:
	CallS( ErrFILECloseTable( ppib, pfucb ) );
	return( err == JET_errKeyDuplicate ? errDuplicate : err );
	}


/*=================================================================
ErrSysTabTimestamp

Description:

	Updates the DateUpdate field of the affected table's entry in
	So. This function is called indirectly, via ErrSysTabInsert
	and ErrSysTabDelete.

Parameters:

	PIB 		*ppib		; PIB of user
	DBID		dbid		; database ID of new table
	OBJID		objid;

=================================================================*/

ERR ErrSysTabTimestamp( PIB *ppib, DBID dbid, OBJID objid )
	{
	ERR				err;
	FUCB				*pfucb; 			/* working fucb 					*/
	LINE				line;				/* input to MakeKey				*/
	JET_DATESERIAL	dtNow;			/* for timestamping				*/
	JET_COLUMNID	columnid;		/* field id for dateUpdate		*/

	/* open MSysObjects
	/**/
	Call( ErrFILEOpenTable( ppib, dbid, &pfucb, szSoTable, 0 ) )
	Call( ErrIsamSetCurrentIndex( ppib, pfucb, szSoIdIndex ) )

	Assert( objid != 0 );
	line.pb = (BYTE *)&objid;
	line.cb = sizeof(objid);
	Call( ErrIsamMakeKey( ppib, pfucb, line.pb, line.cb, JET_bitNewKey ) )

	err = ErrIsamSeek( ppib, pfucb, JET_bitSeekEQ );
	if ( err != JET_errSuccess )
		goto HandleError;

	Call( ErrIsamPrepareUpdate( ppib, pfucb , JET_prepReplaceNoLock ) )
	UtilGetDateTime( &dtNow );
	line.pb = (BYTE *)&dtNow;
	line.cb = sizeof(JET_DATESERIAL);
	Call( ErrFILEGetColumnId( ppib, pfucb, szSoDateUpdate, &columnid ) )
	Call( ErrIsamSetColumn( ppib, pfucb, columnid, line.pb, line.cb, 0, NULL ) )
	Call( ErrIsamUpdate( ppib, pfucb, NULL, 0, NULL ) )
	
	CallS( ErrFILECloseTable( ppib, pfucb ) );
	return JET_errSuccess;

HandleError:
	return err;
	}



/*		ErrFindObjidFromIdName
/*		This routine can be used for getting the OBJID and OBJTYP of any existing
/*		database object using the SoName <ParentId, Name> index on So.
/**/

ERR ErrFindObjidFromIdName(
	PIB			*ppib,
	DBID			dbid,
	OBJID			objidParentId,
	const CHAR	*lszName,
	OBJID			*pobjid,
	JET_OBJTYP	*pobjtyp )
	{
	ERR				err;
	FUCB				*pfucb;
	JET_COLUMNID	columnid;
	LINE				line;
	OBJID				objidObject;
	OBJTYP			objtypObject;
	BOOL				fSoOpen = fFalse;
	ULONG				cbActual;

	Call( ErrFILEOpenTable( ppib, dbid, &pfucb, szSoTable, 0 ) )
	fSoOpen = fTrue;
	Call( ErrIsamSetCurrentIndex( ppib, pfucb, szSoParentIdNameIndex ) )

	/* set up key and seek for record in So */
	line.pb = (BYTE *)&objidParentId;
	line.cb = sizeof(objidParentId);
	Assert( sizeof(objidParentId) == sizeof(unsigned long) );
	Call( ErrIsamMakeKey( ppib, pfucb, line.pb, line.cb, JET_bitNewKey ) )
	line.pb = (BYTE *) lszName;
	line.cb = strlen( lszName );
	Call( ErrIsamMakeKey( ppib, pfucb, line.pb, line.cb, 0 ) )

	if ( ( err = ErrIsamSeek( ppib, pfucb, JET_bitSeekEQ ) ) !=
		JET_errSuccess )
		{
		if ( err == JET_errRecordNotFound )
			err = JET_errObjectNotFound;
		goto HandleError;
		}

	/* get the Object Id */
	Call( ErrFILEGetColumnId( ppib, pfucb, szSoObjid, &columnid ) )
	Call( ErrIsamRetrieveColumn( ppib, pfucb, columnid, (BYTE *) &objidObject,
		sizeof(objidObject), &cbActual, 0, NULL ) )

	/* get the Object Type */
	Call( ErrFILEGetColumnId( ppib, pfucb, szSoType, &columnid ) )
	Call( ErrIsamRetrieveColumn( ppib, pfucb, columnid, (BYTE *) &objtypObject,
		sizeof(objtypObject), &cbActual, 0, NULL ) )

	CallS( ErrFILECloseTable( ppib, pfucb ) );

	Assert( pobjid != NULL );
	*pobjid = objidObject;
	if ( pobjtyp != NULL )
		*pobjtyp = ( JET_OBJTYP ) objtypObject;

	return JET_errSuccess;

HandleError:

	if ( fSoOpen )
		{
		CallS( ErrFILECloseTable( ppib, pfucb ) );
		}

	return( err );
	}


/*		ErrFindNameFromObjid
/*
/*		This routine can be used for getting the name of any existing
/*		database object using the Id <Id> index on So.
/**/

ERR ErrFindNameFromObjid( PIB *ppib, DBID dbid, OBJID objid, OUTLINE *poutName )
	{			 	
	ERR				err;
	FUCB				*pfucb;
	JET_COLUMNID	columnid;
	LINE				line;
	BOOL				fSoOpen = fFalse;

	Call( ErrFILEOpenTable( ppib, dbid, &pfucb, szSoTable, 0 ) )
	fSoOpen = fTrue;
	Call( ErrIsamSetCurrentIndex( ppib, pfucb, szSoIdIndex ) )

	/* set up key and seek for record in So */
	line.pb = (BYTE *) &objid;
	line.cb = sizeof(objid);
	Assert( sizeof(objid) == sizeof(unsigned long) );
	Call( ErrIsamMakeKey( ppib, pfucb, line.pb, line.cb, JET_bitNewKey ) )

	err = ErrIsamSeek( ppib, pfucb, JET_bitSeekEQ );
	if ( err != JET_errSuccess )
		{
		if ( err == JET_errRecordNotFound )
			err = JET_errObjectNotFound;
		goto HandleError;
		}

	/* get the Object Name */
	Call( ErrFILEGetColumnId( ppib, pfucb, szSoName, &columnid ) )
	Call( ErrIsamRetrieveColumn( ppib, pfucb, columnid, poutName->pb,
		poutName->cbMax, &poutName->cbActual, 0, NULL ) )

	poutName->pb[poutName->cbActual] = '\0';

	CallS( ErrFILECloseTable( ppib, pfucb ) );
	return JET_errSuccess;

HandleError:
	if ( fSoOpen )
		{
		CallS( ErrFILECloseTable( ppib, pfucb ) );
		}
	return( err );
	}


/*		ErrIsamGetObjidFromName
/*
/*		This routine can be used for getting the OBJID of any existing
/*		database object from its container/object name pair.
/**/

	ERR VTAPI
ErrIsamGetObjidFromName( JET_SESID sesid, JET_DBID vdbid, const char *lszCtrName, const char *lszObjName, OBJID *pobjid )
	{
	/*	Follow these rules:
	/*
	/*		ParentId		+	Name		-->		Id
	/*		--------			----				--
	/*		1.	( objidRoot )			ContainerName		objidOfContainer
	/*		2.	objidOfContainer	ObjectName			objidOfObject
	/**/

	ERR			err;
	DBID			dbid = DbidOfVDbid( vdbid );
	PIB			*ppib = (PIB *) sesid;
	OBJID 		objid;
	JET_OBJTYP	objtyp;

	/*	get container information first...
	/**/
	if ( lszCtrName == NULL || *lszCtrName == '\0' )
		objid = objidRoot;
	else
		{
		CallR( ErrFindObjidFromIdName( ppib, dbid, objidRoot, lszCtrName, &objid, &objtyp ) );
		Assert( objid != objidNil );
		if ( objtyp != JET_objtypContainer )
			return( JET_errObjectNotFound );
		}

	/*	get object information next...
	*/
	CallR( ErrFindObjidFromIdName( ppib, dbid, objid, lszObjName, &objid, NULL ) );
	Assert( objid != objidNil );

	*pobjid = objid;
	return JET_errSuccess;
	}


/*=================================================================
ErrIsamCreateObject

Description:
  This routine is used to create an object record in So.

  It is expected that at the time this routine is called, all parameters
  will have been checked and all security constraints will have been
  satisfied.

Parameters:
  sesid 		identifies the session uniquely.
  dbid			identifies the database in which the object resides.
  objidParentId identifies the parent container object by OBJID.
  szObjectName	identifies the object within said container.
  objtyp		the value to be set for the appropriate So column.

Return Value:
  JET_errSuccess if the routine can perform all operations cleanly;
  some appropriate error value otherwise.

Errors/Warnings:
  None specific to this routine.

Side Effects:
=================================================================*/
	ERR VTAPI
ErrIsamCreateObject( JET_SESID sesid, JET_DBID vdbid, OBJID objidParentId, const char *szName, JET_OBJTYP objtyp )
	{
	/*	Build a new record for So using the supplied data,
	/*	and insert the record into So.
	/*
	/*	Assumes that warning values returned by ErrIsamFoo routines mean
	/*	that it is still safe to proceed.
	/**/

	ERR				err;
	DBID				dbid = DbidOfVDbid( vdbid );
	CHAR				szObject[ (JET_cbNameMost + 1) ];
	PIB				*ppib = ( PIB *) sesid;
	FUCB				*pfucb;
	JET_COLUMNID	columnid;
	LINE				line;
	OBJID				objidNewObject;
	OBJTYP			objtypSet = (OBJTYP)objtyp;
	JET_DATESERIAL	dtNow;
	ULONG				cbActual;
	ULONG				ulFlags = 0;

	/* Ensure that database is updatable */
	/**/
	CallR( VDbidCheckUpdatable( vdbid ) );

	CallR( ErrCheckName( szObject, szName, (JET_cbNameMost + 1) ) );

	/* start a transaction so we get a consistent object id value
	/**/
	CallR( ErrDIRBeginTransaction( ppib ) );

	/*	open the So table and set the current index to Id...
	/**/
	Call( ErrFILEOpenTable( ppib, dbid, &pfucb, szSoTable, 0 ) )
	Call( ErrIsamSetCurrentIndex( ppib, pfucb, szSoIdIndex ) )

	/*	get the new object's OBJID value: find the highest-valued OBJID
	/*	in the index, increment it by one and use the result...
	/**/
	Call( ErrIsamMove( ppib, pfucb, JET_MoveLast, 0 ) )
	Call( ErrFILEGetColumnId( ppib, pfucb, szSoObjid, &columnid ) )

	Call( ErrIsamRetrieveColumn( ppib, pfucb, columnid,
		(BYTE *) &objidNewObject, sizeof(objidNewObject), &cbActual,
		0, NULL ) )

	/*	prepare to create the new user account record...
	/**/
	Call( ErrIsamPrepareUpdate( ppib, pfucb, JET_prepInsert ) )

	/*	set the Objid column...
	/**/
	objidNewObject++;
	line.pb = (BYTE *) &objidNewObject;
	line.cb = sizeof(objidNewObject);
	Call( ErrIsamSetColumn( ppib, pfucb, columnid, line.pb, line.cb, 0, NULL ) )

	/*	set the ParentId column...
	/**/
	Call( ErrFILEGetColumnId( ppib, pfucb, szSoParentId, &columnid ) )
	line.pb = (BYTE *) &objidParentId;
	line.cb = sizeof(objidParentId);
	Call( ErrIsamSetColumn( ppib, pfucb, columnid, line.pb, line.cb, 0, NULL ) )

	/*	set the ObjectName column...
	/**/
	Call( ErrFILEGetColumnId( ppib, pfucb, szSoName, &columnid ) )
	line.pb = (BYTE *) szObject;
	line.cb = strlen( szObject );
	Call( ErrIsamSetColumn( ppib, pfucb, columnid, line.pb, line.cb, 0, NULL ) )

	/*	set the Type column...
	/**/
	Call( ErrFILEGetColumnId( ppib, pfucb, szSoType, &columnid ) )
	line.pb = (BYTE *)&objtypSet;
	line.cb = sizeof(objtypSet);
	Call( ErrIsamSetColumn( ppib, pfucb, columnid, line.pb, line.cb, 0, NULL ) )

	/*	set the DateCreate column...
	/**/
	UtilGetDateTime( &dtNow );
	Call( ErrFILEGetColumnId( ppib, pfucb, szSoDateCreate, &columnid ) )
	line.pb = (BYTE *) &dtNow;
	line.cb = sizeof(JET_DATESERIAL);
	Call( ErrIsamSetColumn( ppib, pfucb, columnid, line.pb, line.cb, 0, NULL ) )

	/*	set the DateUpdate column...
	/**/
	Call( ErrFILEGetColumnId( ppib, pfucb, szSoDateUpdate, &columnid ) )
	line.pb = (BYTE *) &dtNow;
	line.cb = sizeof(JET_DATESERIAL);
	Call( ErrIsamSetColumn( ppib, pfucb, columnid, line.pb, line.cb, 0, NULL ) )

	/* set the Flags column...
	/**/
	Call( ErrFILEGetColumnId( ppib, pfucb, szSoFlags, &columnid ) )
	Call( ErrIsamSetColumn( ppib, pfucb, columnid, (BYTE *)&ulFlags, sizeof(ulFlags), 0, NULL ) )

	/*	Add the record to the table.  Note that an error returned here
	/*	means that the transaction has already been rolled back and
	/*	So has been closed.
	/**/
	err = ErrIsamUpdate( ppib, pfucb, NULL, 0, NULL );
	if ( err < 0 )
		{
		if ( err == JET_errKeyDuplicate )
			err = JET_errObjectDuplicate;
		goto HandleError;
		}

	/*	close table
	/**/
	CallS( ErrFILECloseTable( ppib, pfucb ) );
	err = ErrDIRCommitTransaction( ppib );
	if ( err >= 0 )
		return JET_errSuccess;

HandleError:
	/*	close table by aborting
	/**/
	CallS( ErrDIRRollback( ppib ) );
	return err;
	}


/*=================================================================
ErrIsamDeleteObject

Description:
  This routine is used to delete an object record from So.

  It is expected that at the time this routine is called, all parameters
  will have been checked and all security constraints will have been
  satisfied.

Parameters:
  sesid 		identifies the session uniquely.
  dbid			identifies the database in which the object resides.
  objid 		identifies the object uniquely for dbid; obtained from
				ErrIsamGetObjidFromName.

Return Value:
  JET_errSuccess if the routine can perform all operations cleanly;
  some appropriate error value otherwise.

Errors/Warnings:
  JET_errObjectNotFound:
    There does not exist an object bearing the specfied objid in dbid.

Side Effects:
=================================================================*/
	ERR VTAPI
ErrIsamDeleteObject( JET_SESID sesid, JET_DBID vdbid, OBJID objid )
	{
	/*	The specified database, based on the supplied objid.
	/*	Delete the object record based on the object type.
	/*
	/*	Assumes that warning values returned by ErrIsamFoo routines mean
	/*	that it is still safe to proceed.
	/**/

	ERR				err;
	DBID				dbid = DbidOfVDbid( vdbid );
	PIB				*ppib = (PIB *) sesid;
	FUCB				*pfucb = pfucbNil;
	FUCB				*pfucbSoDup = pfucbNil;
	FUCB				*pfucbSq = pfucbNil;
	OUTLINE 			outline;
	BYTE				rgbBuf[JET_cbNameMost];
	char				szObject[(JET_cbNameMost + 1)];
	OBJTYP			objtyp;
	OBJID				objidSo = objidNil;
	OBJID				objidSq;
	JET_COLUMNID	columnid;
#ifdef SEC
	/* delete the entries from Sp
	/**/
	FUCB				*pfucbSace = pfucbNil;
	OBJID				objidSace;
#endif

	/* Ensure that database is updatable */
	/**/
	CallR( VDbidCheckUpdatable( vdbid ) );

	outline.pb = rgbBuf;
	outline.cbMax = sizeof(rgbBuf);

	/*	open the So table and set the current index to Id...
	/**/
	CallR( ErrFILEOpenTable( ppib, dbid, &pfucb, szSoTable, 0 ) )
	Call( ErrIsamSetCurrentIndex( ppib, pfucb, szSoIdIndex ) )

	/* set up key and seek for record in So
	/**/
	Assert( sizeof(objid) == sizeof(unsigned long) );
	Call( ErrIsamMakeKey( ppib, pfucb, (BYTE *)&objid, sizeof(objid), JET_bitNewKey ) )

	if ( ( err = ErrIsamSeek( ppib, pfucb, JET_bitSeekEQ ) ) !=
		JET_errSuccess )
		{
		if ( err == JET_errRecordNotFound )
			err = JET_errObjectNotFound;
		goto HandleError;
		}

	/* Make sure we can delete this object
	/**/
	Call( ErrFILEGetColumnId( ppib, pfucb, szSoType, &columnid ) );
	Call( ErrIsamRetrieveColumn( ppib, pfucb, columnid, (BYTE *)&objtyp, sizeof(objtyp), NULL, 0, NULL ) );

	switch ( objtyp )
		{
		default:
		case JET_objtypDb:
		case JET_objtypLink:
			/* delete the object record
			/**/
			Call( ErrIsamDelete( ppib, pfucb ) )
			break;

		case JET_objtypTable:
		case JET_objtypSQLLink:
			/* get the table name
			/**/
			outline.pb = szObject;
			outline.cbMax = sizeof(szObject);
			Call( ErrFindNameFromObjid( ppib, dbid, objid, &outline ) )
			Assert( outline.cbActual <= outline.cbMax );

			Call( ErrIsamDeleteTable( ppib, vdbid, outline.pb ) )
			break;

		case JET_objtypContainer:
			/* use a new cursor to make sure the container is empty
			/**/
			Call( ErrFILEOpenTable( ppib, dbid, &pfucbSoDup, szSoTable, 0 ) )
			Call( ErrIsamSetCurrentIndex( ppib, pfucbSoDup, szSoParentIdNameIndex ) )

			/* find any object with a ParentId matching the container's id
			/**/
			Call( ErrIsamMakeKey( ppib, pfucbSoDup, (BYTE *)&objid, sizeof(objid), JET_bitNewKey ) )
			err = ErrIsamSeek( ppib, pfucbSoDup, JET_bitSeekGE );
			if ( err >= 0 )
				{
				Call( ErrFILEGetColumnId( ppib, pfucbSoDup, szSoParentId, &columnid ) )
				Call( ErrIsamRetrieveColumn( ppib, pfucbSoDup, columnid, (BYTE *)&objidSo, sizeof(objidSo), NULL, 0, NULL ) )
				}

			/* we have the info we want; close the table ( dropping tableid )
			/**/
			CallS( ErrFILECloseTable( ppib, pfucbSoDup ) );
			pfucbSoDup = pfucbNil;

			/* if the container is empty, then delete its record
			/**/
			if ( objid != objidSo )
				Call( ErrIsamDelete( ppib, pfucb ) )
			else
				{
				err = JET_errContainerNotEmpty;
				goto HandleError;
				}
			break;

		case JET_objtypQuery:
			/* open a cursor on Sq
			/**/
			Call( ErrFILEOpenTable( ppib, dbid, &pfucbSq, szSqTable, 0 ) )
			Call( ErrIsamSetCurrentIndex( ppib, pfucbSq, szSqAttribute ) )
			Call( ErrFILEGetColumnId( ppib, pfucbSq, szSqObjid, &columnid ) )

			/* position to the first entry for the query being deleted ( if any )
			/**/
			Call( ErrIsamMakeKey( ppib, pfucbSq, (BYTE *)&objid, sizeof(objid), JET_bitNewKey ) )
			err = ErrIsamSeek( ppib, pfucbSq, JET_bitSeekGE );

			/* delete all records in Sq for the query being deleted
			/**/
			while ( err >= 0 )
				{
				Call( ErrIsamRetrieveColumn( ppib, pfucbSq, columnid, (BYTE *)&objidSq, sizeof(objidSq), NULL, 0, NULL ) )
				if ( objid != objidSq )
					break;
				Call( ErrIsamDelete( ppib, pfucbSq ) )
				err = ErrIsamMove( ppib, pfucbSq, JET_MoveNext, 0 );
				}

			CallS( ErrFILECloseTable( ppib, pfucbSq ) );
			pfucbSq = pfucbNil;

			/* delete the query record from So */
			Call( ErrIsamDelete( ppib, pfucb ) )
			break;
		}

	CallS( ErrFILECloseTable( ppib, pfucb ) );
	pfucb = pfucbNil;

#ifdef SEC
	Call( ErrFILEOpenTable( ppib, dbid, &pfucbSace, szSpTable, 0 ) )
	Call( ErrIsamSetCurrentIndex( ppib, pfucbSace, szSaceId ) )
	Call( ErrFILEGetColumnId( ppib, pfucbSace, szSaObjId, &columnid ) )
	Call( ErrIsamMakeKey( ppib, pfucbSace, (BYTE *)&objid, sizeof(objid), JET_bitNewKey ) )
	err = ErrIsamSeek( ppib, pfucbSace, JET_bitSeekGE );

	while ( err >= 0 )
		{
		Call( ErrIsamRetrieveColumn( ppib, pfucbSace, columnid, (BYTE *)&objidSace, sizeof(objidSace), NULL, 0, NULL ) )
		if ( objid != objidSace )
			break;
		Call( ErrIsamDelete( ppib, pfucbSace ) )
		err = ErrIsamMove( ppib, pfucbSace, JET_MoveNext, 0 );
		}

	CallS( ErrFILECloseTable( ppib, pfucbSace ) );
#endif
	return JET_errSuccess;

HandleError:
	if ( pfucb != pfucbNil )
		CallS( ErrFILECloseTable( ppib, pfucb ) );
	if ( pfucbSoDup != pfucbNil )
		CallS( ErrFILECloseTable( ppib, pfucbSoDup ) );
	if ( pfucbSq != pfucbNil )
		CallS( ErrFILECloseTable( ppib, pfucbSq ) );
#ifdef SEC
	if ( pfucbSace != pfucbNil )
		CallS( ErrFILECloseTable( ppib, pfucbSace ) );
#endif
	return err;
	}

#endif	/* SYSTABLES */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\sysinit.c ===
#include "config.h"

#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <io.h>

#include "daedef.h"
#include "util.h"
#include "pib.h"
#include "page.h"
#include "ssib.h"
#include "fmp.h"
#include "fcb.h"
#include "fucb.h"
#include "stapi.h"
#include "stint.h"
#include "logapi.h"
#include "dirapi.h"
#include "idb.h"
#include "fileapi.h"
#include "dbapi.h"
#include "spaceapi.h"
#include "sortapi.h"
#include "scb.h"
#include "bm.h"
#include "nver.h"

DeclAssertFile;					/* Declare file name for assert macros */

extern int itibGlobal;

BOOL fSTInit = fSTInitNotDone;

#ifdef	DEBUG
STATIS	rgstatis[istatisMac] =
	{
	0, "BF evict bg",
	0, "BF evict fg",
	0, "BF evict clean",
	0, "BF evict dirty"
	};
#endif	/* DEBUG */

/*	system parameter constants
/**/
long	lMaxBufferGroups = cbgcbDefault;
long	lMaxDBOpen = cDBOpenDefault;
long	lMaxBuffers = cbufDefault;
long	lMaxSessions = cpibDefault;
long	lMaxOpenTables = cfcbDefault;
long	lMaxOpenTableIndexes = cidbDefault;
long	lMaxTemporaryTables = cscbDefault;
long	lMaxCursors = cfucbDefault;
long	lMaxVerPages = cbucketDefault;
long	lLogBuffers = clgsecBufDefault;
long	lLogFileSectors = clgsecGenDefault;
long	lLogFlushThreshold = clgsecFTHDefault;
long	lBufThresholdLowPercent = cbufThresholdLowDefault;
long	lBufThresholdHighPercent = cbufThresholdHighDefault;
long	lWaitLogFlush = lWaitLogFlushDefault;
long	lLogFlushPeriod = lLogFlushPeriodDefault;
long	lLGCheckPointPeriod = lLGCheckpointPeriodDefault;
long	lLGWaitingUserMax = lLGWaitingUserMaxDefault;
long	lPageFragment = lPageFragmentDefault;
CHAR	szLogFilePath[cbFilenameMost + 1] = ".\0";	/* cur dir as default */
CHAR	szRestorePath[cbFilenameMost + 1] = "";		/* none by default */
CHAR	szRecovery[cbFilenameMost + 1] = "off";		/* on by default */
BOOL	fOLCompact = 0;

long lBufLRUKCorrelationInterval = lBufLRUKCorrelationIntervalDefault;
long lBufBatchIOMax = lBufBatchIOMaxDefault;
long lPageReadAheadMax = lPageReadAheadMaxDefault;
long lAsynchIOMax = lAsynchIOMaxDefault;

/*  szSysDbPath is defined in Jet initterm.c as
/*  CHAR szSysDbPath[cbFilenameMost] = "system.mdb";
/**/
extern CHAR szSysDbPath[];
extern CHAR szTempPath[];

#ifdef NJETNT
#define	szTempDbPath	( *rgtib[itibGlobal].szTempPath == '\0' ? szTempDBFileName : rgtib[itibGlobal].szTempPath )
#else
#define	szTempDbPath	( *szTempPath == '\0' ? szTempDBFileName : szTempPath )
#endif

/* NOTE: whenever this is changed, also update the #define's in util.h */
RES __near rgres[] = {
/* 0*/	sizeof(BGCB),		0,	NULL,	0,	NULL, 0,	0,
/* 1*/	sizeof(CSR),		0,	NULL,	0,	NULL, 0,	0,
/* 2*/	sizeof(FCB),		0,	NULL,	0,	NULL, 0,	0,
/* 3*/	sizeof(FUCB),		0,	NULL,	0,	NULL, 0,	0,
/* 4*/	sizeof(IDB),		0,	NULL,	0,	NULL, 0,	0,
/* 5*/	sizeof(PIB),		0,	NULL,	0,	NULL, 0,	0,
/* 6*/	sizeof(SCB),		0,	NULL,	0,	NULL, 0,	0,
/* 7*/	sizeof(BUCKET),		0,	NULL,	0,	NULL, 0,	0,
/* 8*/	sizeof(DAB),		0,	NULL,	0,	NULL, 0,	0,
/* 9*/	sizeof(BF),			0,	NULL,	0,	NULL, 0,	0,
/*10*/	0,					0,	NULL,	0,	NULL, 0,	0,
/*11*/	0,					0,	NULL,	0,	NULL, 0,	0,
/*12*/	0,					0,	NULL,	0,	NULL, 0,	0 };

#ifdef	WIN16
extern PHA * __near phaCurrent;
/* Current process handle array	*/
/* Valid only during ErrSTInit	*/
#endif	/* WIN16 */

extern BOOL fDBGPrintToStdOut;


#ifdef DEBUG

ERR ErrSTSetIntrinsicConstants( VOID )
	{
	CHAR	*sz;

	if ( ( sz = GetEnv2 ( "PrintToStdOut" ) ) != NULL )
		fDBGPrintToStdOut = fTrue;
	else
		fDBGPrintToStdOut = fFalse;

	/*  get the following system parameter right away:
	/*  SysDbPath, LogfilePath, and Recovery
	/**/
	if ( ( sz = GetEnv2 ( "JETUSEENV" ) ) == NULL )
		return JET_errSuccess;
	
	if ( ( sz = GetEnv2 ( "JETRecovery" ) ) != NULL )
		{
		if (strlen(sz) > sizeof(szRecovery))
			return JET_errInvalidParameter;
		strcpy(szRecovery, sz);
		}
		
	if ( ( sz = GetEnv2 ( "JETLogFilePath" ) ) != NULL )
		{
		if (strlen(sz) > sizeof( szLogFilePath ) )
			return JET_errInvalidParameter;
		strcpy( szLogFilePath, sz );
		}

	return JET_errSuccess;
	}

#endif


LOCAL ERR ErrSTSetConstants( VOID )
	{
#ifdef DEBUG
	CHAR		*sz;

	/*	use system environment variables to overwrite the default.
	/*	if the JETUSEENV is set.
	/**/
	if ( ( sz = GetEnv2 ( "JETUSEENV" ) ) != NULL )
		{
		if ( ( sz = GetEnv2 ( "JETBfThrshldLowPrcnt" ) ) != NULL )
			lBufThresholdLowPercent = atol(sz);

		if ( ( sz = GetEnv2 ( "JETBfThrshldHighPrcnt" ) ) != NULL )
			lBufThresholdHighPercent = atol(sz);

		if ( ( sz = GetEnv2 ( "JETMaxBuffers" ) ) != NULL )
			lMaxBuffers = atol(sz);

		if ( ( sz = GetEnv2 ( "JETBufLRUKCorrelationInterval" ) ) != NULL )
			lBufLRUKCorrelationInterval = atol(sz);

		if ( ( sz = GetEnv2 ( "JETBufBatchIOMax" )) != NULL )
			lBufBatchIOMax = atol(sz);
	
		if ( ( sz = GetEnv2 ( "JETPageReadAheadMax" ) ) != NULL )
			lPageReadAheadMax = atol(sz);
	
		if ( ( sz = GetEnv2 ( "JETPageAsynchIOMax" ) ) != NULL )
			lAsynchIOMax = atol(sz);
	
		if ( ( sz = GetEnv2 ( "JETMaxDBOpen" ) ) != NULL )
			lMaxDBOpen = atol(sz);

		if ( ( sz = GetEnv2 ( "JETMaxSessions" ) ) != NULL )
			lMaxSessions = atol(sz);
	
		if ( ( sz = GetEnv2 ( "JETMaxOpenTables" ) ) != NULL )
			lMaxOpenTables = atol(sz);
	
		if ( ( sz = GetEnv2 ( "JETMaxOpenTableIndexes" ) ) != NULL )
			lMaxOpenTableIndexes = atol(sz);
	
		if ( ( sz = GetEnv2 ( "JETMaxTemporaryTables" ) ) != NULL )
			lMaxTemporaryTables = atol(sz);
	
		if ( ( sz = GetEnv2 ( "JETMaxCursors" ) ) != NULL )
			lMaxCursors = atol(sz);
	
		if ( ( sz = GetEnv2 ( "JETMaxVerPages" ) ) != NULL )
			lMaxVerPages = atol(sz);

		if ( ( sz = GetEnv2 ( "JETLogBuffers" ) ) != NULL )
			lLogBuffers = atol(sz);

		if ( ( sz = GetEnv2 ( "JETLogFlushThreshold" ) ) != NULL )
			lLogFlushThreshold = atol(sz);

		if ( ( sz = GetEnv2 ( "JETCheckPointPeriod" ) ) != NULL )
			lLGCheckPointPeriod = atol(sz);

		if ( ( sz = GetEnv2 ( "JETLogWaitingUserMax" ) ) != NULL )
			lLGWaitingUserMax = atol(sz);

		if ( ( sz = GetEnv2 ( "JETLogFileSectors" ) ) != NULL )
			lLogFileSectors = atol(sz);

		if ( ( sz = GetEnv2 ( "JETWaitLogFlush" ) ) != NULL )
			lWaitLogFlush = atol(sz);

		if ( ( sz = GetEnv2 ( "JETLogFlushPeriod" ) ) != NULL )
			lLogFlushPeriod = atol(sz);
		}
#endif

	/*	initialize rgres.  system database path in rgtib[itib].szSysDbPath,
	/*	is initialized by JET layer.
	/**/
	rgres[iresBGCB].cblockAlloc = lMaxBufferGroups;
	rgres[iresFCB].cblockAlloc = lMaxOpenTables;
	rgres[iresFUCB].cblockAlloc = lMaxCursors;
	rgres[iresIDB].cblockAlloc = lMaxOpenTableIndexes;
	rgres[iresPIB].cblockAlloc = lMaxSessions + cpibSystem;
	rgres[iresSCB].cblockAlloc = lMaxTemporaryTables;
	rgres[iresVersionBucket].cblockAlloc = lMaxVerPages + cbucketSystem;
	rgres[iresBF].cblockAlloc = lMaxBuffers;
	rgres[iresDAB].cblockAlloc = lMaxDBOpen;

	/*	compute derived parameters
	/**/
	rgres[iresCSR].cblockAlloc = lCSRPerFUCB * rgres[iresFUCB].cblockAlloc;
	
	return JET_errSuccess;
	}


BOOL FFileExists( CHAR *szFileName )
	{
	BOOL fFound;
	
#ifdef WIN32
        intptr_t    hFind;
	struct	_finddata_t fileinfo;
	
	fileinfo.attrib = _A_NORMAL;
	hFind = _findfirst( szFileName, &fileinfo );
	if (hFind != -1)
		fFound = fTrue;
	else
		fFound = fFalse;
	(void) _findclose( hFind );

#else
	struct	find_t fileinfo;

	err = _dos_findfirst( szFileName, _A_NORMAL, &fileinfo );
	if (err == 0)
		fFound = fTrue;
	else
		fFound = fFalse;
#endif

	return fFound;
	}


//+API
//	ErrSTInit
//	========================================================
//	ERR ErrSTInit( VOID )
//
//	Initialize the storage system: page buffers, log buffers, and the
//	database files.
//
//	RETURNS		JET_errSuccess
//-
ERR ErrSTInit( VOID )
	{
	extern SEM 	__near semDBK;
	extern SEM	__near semPMReorganize;
	extern void * __near critSplit;
	ERR			err;
	PIB			*ppib = ppibNil;
	BOOL		fNoSystemDatabase = fFalse;
	DBID		dbidTempDb;
	CHAR		szFullName[JET_cbFullNameMost];

	/*	sleep while initialization is in progress
	/**/
	while ( fSTInit == fSTInitInProgress )
		{
		SysSleep( 1000 );
		}

	/*	DAE system initialization is guarded against simultaneous
	/*	initializations
	/**/
	if ( fSTInit == fSTInitDone )
		{
#ifdef	WIN16
		/*	open the system files for this process if this is its first session
		/**/
		if ( Hf(dbidTemp) == handleNil )
			{
			err = ErrSysOpenFile( szTempDbPath, &Hf(dbidTemp), 0L, fFalse/*fReadWrite*/ );
			if ( err < 0 )
				return JET_errInvalidPath;
#ifdef NJETNT
			err = ErrSysOpenFile( rgtib[itibGlobal].szSysDbPath, &Hf(dbidSystemDatabase), 0L, fFalse/*fReadWrite*/ );
#else
			err = ErrSysOpenFile( szSysDbPath, &Hf(dbidSystemDatabase), 0L, fFalse/*fReadWrite*/ );
#endif
			if ( err < 0 )
				{
				(VOID)ErrSysCloseFile( Hf(dbidTemp ) );
				return JET_errInvalidPath;
				}
			}

#endif	/* WIN16 */
		return JET_errSuccess;
		}

	/*	initialization in progress
	/**/
	fSTInit = fSTInitInProgress;

	/*	initialize semaphores
	/**/
	Call( SgErrSemCreate( &semST, "storage mutex" ) );
	Call( SgErrSemCreate( &semGlobalFCBList, "fcb mutex" ) );
	Call( SgErrSemCreate( &semLinkUnlink, "link unlink mutex" ) );
	Call( SgErrSemCreate( &semDBK, "dbk mutex" ) );
	Call( SgErrSemCreate( &semPMReorganize, "page reorganize mutex" ) );
#ifdef MUTEX
	Call( ErrInitializeCriticalSection( &critSplit ) );
#endif

	Call( ErrSTSetConstants( ) );

	/*	initialize subcomponents
	/**/
	Call( ErrMEMInit() );
	CallJ( ErrIOInit(), TermMem ) ;
	CallJ( ErrBFInit(), TermIO );
	CallJ( ErrVERInit(), TermBF );
	CallJ( ErrMPLInit(), TermVER );
	FCBHashInit();

	/*	begin storage level session to support all future system
	/*	initialization activites that require a user for
	/*	transaction control
	/**/
	CallJ( ErrPIBBeginSession( &ppib ), TermMPL );

#ifdef	WIN16
	ppib->phaUser = phaCurrent;
#endif	/* WIN16 */

	/* if first to open system database
	/**/
	if ( Hf(dbidSystemDatabase) == handleNil )
		{
		DBID dbidT = dbidSystemDatabase;
		CallJ( ErrDBOpenDatabase(
			ppib,
			rgfmp[dbidSystemDatabase].szDatabaseName,
			&dbidT,
			0 ), ClosePIB );
		Assert( dbidT == dbidSystemDatabase );
		}

	if ( FDBIDAttached( dbidTemp ) )
		{
		DBIDResetAttached( dbidTemp );
		SFree(rgfmp[dbidTemp].szDatabaseName);
		rgfmp[dbidTemp].szDatabaseName = 0;
		rgfmp[dbidTemp].hf = handleNil;
		}

	if ( _fullpath( szFullName, szTempDbPath, JET_cbFullNameMost ) != NULL )
		{
		(VOID)ErrSysDeleteFile( szFullName );
		}

	dbidTempDb = dbidTemp;
	CallJ( ErrDBCreateDatabase( ppib,
		szTempDbPath,
		NULL,
		&dbidTempDb,
		JET_bitDbNoLogging ), ClosePIB );
	Assert( dbidTempDb == dbidTemp );

	PIBEndSession( ppib );
	ppib = ppibNil;
	
	/*	must initialize BM after log is initialized so that no interference
	/*	from BMClean thread to recovery operations.
	/**/
	CallJ( ErrBMInit(), DeleteTempDB );

	fSTInit = fSTInitDone;
	/*	give theads a chance to initialize
	/**/
	SysSleep( 1000 );
	return JET_errSuccess;

DeleteTempDB:
	/*	close temporary database if opened
	/**/
	(VOID)ErrDBCloseDatabase( ppib, dbidTemp, 0 );

ClosePIB:
	Assert( ppib != ppibNil );
	PIBEndSession( ppib );

TermMPL:
	MPLTerm();

TermVER:
	VERTerm();

TermBF:
	BFTermProc();
	BFReleaseBF();

TermIO:
	CallS( ErrIOTerm() );

TermMem:
	MEMTerm();

HandleError:
	ppibAnchor = ppibNil;
	pfcbGlobalList = pfcbNil;

	fSTInit = fSTInitNotDone;
	return err;
	}  	


//+api------------------------------------------------------
//
//	ErrSTTerm
//	========================================================
//
//	ERR ErrSTTerm( VOID )
//
//	Flush the page buffers to disk so that database file be in consistent
//	state.  If error in RCCleanUp or in BFFlush, then DO NOT
//	terminate log, thereby forcing redo on next initialization.
//
//----------------------------------------------------------

ERR ErrSTTerm( VOID )
	{
	ERR						err;
	extern void * __near	critSplit;
	extern BOOL				fBackupInProgress;

	/*	sleep while initialization is in progress
	/**/
	while ( fSTInit == fSTInitInProgress )
		{
		SysSleep( 1000 );
		}

	/*	make sure no other transactions in progress
	/**/
	/*	if write error on page, RCCleanup will return -err
	/*	if write error on buffer, BFFlush will return -err
	/*	-err passed to LGTerm will cause correctness flag to
	/*	be omitted from log thereby forcing recovery on next
	/*	startup, and causing LGTerm to return +err, which
	/*	may be used by JetQuit to show error
	/**/
	if ( fSTInit == fSTInitNotDone )
		return JET_errNotInitialized;
	fSTInit = fSTInitNotDone;

	if ( fBackupInProgress )
		return JET_errBackupInProgress;

	/*	return err if not all sessions ended
	/**/
	SgSemRequest( semST );

	#ifdef DEBUG
		MEMPrintStat();
	#endif

#ifndef	WIN16
	/* clean up all entries.
	/**/
	CallR( ErrRCECleanAllPIB() );
#endif

	/* stop bookmark clean up to prevent from interfering buffer flush
	/**/
	Call( ErrBMTerm() );

	MPLTerm();
	
	if ( trxOldest != trxMax )
		{
		SgSemRelease( semST );
		return JET_errTooManyActiveUsers;
		}

#ifndef	WIN16
	/*	This work is done at every EndSession for Windows runs.
	/*	By the time we get here, there is nothing left to do and
	/*	no more buffers left to flush.
	/**/

	VERTerm();

	/* flush all buffers, including update all database root
	/**/
	err = ErrBFFlushBuffers( 0, fBFFlushAll );
	if ( err < 0 )
		{
		SgSemRelease( semST );
		goto HandleError;
		}

	/* finish on-going buffer clean up
	/**/
	BFTermProc();
#endif

	SgSemRelease( semST );

	BFReleaseBF();

	Call( ErrIOTerm() );

#ifdef MUTEX
	DeleteCriticalSection( critSplit );
#endif
	
	(VOID)ErrSysDeleteFile( szTempDbPath );

	/*	reset initialization flag
	/**/
	fSTInit = fSTInitNotDone;
	FCBPurgeDatabase( 0 );
	
#ifdef DEBUG
	PIBPurge();
#else
	ppibAnchor = ppibNil;
	pfcbGlobalList = pfcbNil;
#endif

	MEMTerm();

HandleError:

#ifdef DEBUG
	if ( ( GetEnv2( szVerbose ) ) != NULL )
		{
		int	istatis;

		for ( istatis = 0 ; istatis < istatisMac ; ++istatis )
			PrintF( "%5ld %s\n", rgstatis[istatis].l, rgstatis[istatis].sz );
		}
#endif

	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\sysw32.c ===
#include "config.h"

#define HANDLE WINHANDLE
#include <windows.h>
#undef HANDLE
#include <dos.h>
#include <malloc.h>
#include <string.h>
#include <time.h>
#include <ctype.h>
#include <io.h>
#include <stdarg.h>
#include <stdlib.h>

/*	this build is for DAYTONA
/**/
#define DAYTONA 1

/* make sure the definition between os.h/_jet.h is the same as in windows.h */
#undef FAR
#undef NEAR
#undef PASCAL
#undef far
#undef near
#undef cdecl
#undef pascal
#undef MAKELONG
#undef HIWORD

#include "daedef.h"
#include "util.h"
#include "b71iseng.h"

DeclAssertFile;					/* Declare file name for assert macros */


VOID SysGetDriveGeometry( HANDLE handle );


DWORD DwSYSGetLastError( VOID )
	{
	DWORD		dw = GetLastError();

	return dw;
	}


LOCAL ERR ErrCheckError( VOID );

LOCAL ERR ErrSYSIGetLastError( ERR errDefault )
	{
	ERR		err = errDefault;
	DWORD	dw = GetLastError();

	/*	maps system error to JET error, or sets err to given
	/*	default error.
	/**/
	switch ( dw )
		{
	case ERROR_TOO_MANY_OPEN_FILES:
		err = JET_errNoMoreFiles;
		break;
	default:
		break;
		}

	return err;
	}


ERR ErrSysCheckLangid( LANGID langid )
	{
	ERR		err;
	WCHAR	rgwA[1];
	WCHAR	rgwB[1];

//NOTE: Julie Bennett said that starting with DAYTONA, the best call to use
//		is IsValidLocale().  I don't have libraries to link to for that yet.
//		She said that the best thing (for performance reasons) to do in NT
//		(pre-daytona) is call CompareStringW with counts of -1.  This will
//		determine if the langid is currently configured on the machine.
//		(not just a valid langid somewhere in the universe).

	rgwA[0] = 0;
	rgwB[0] = 0;

	if ( CompareStringW( MAKELCID( langid, 0 ), NORM_IGNORECASE, rgwA, -1, rgwB, -1 ) == 0 )
		{
		Assert( GetLastError() == ERROR_INVALID_PARAMETER );
		err = JET_errInvalidLanguageId;
		}
	else
		{
		err = JET_errSuccess;
		}
				
	return err;
	}

				
ERR ErrSysMapString(
	LANGID	langid,
	BYTE 	*pbColumn,
	INT		cbColumn,
	BYTE 	*rgbSeg,
	INT		cbMax,
	INT		*pcbSeg )
	{
	ERR		err = JET_errSuccess;

//	UNDONE:	refine this constant based on unicode key format
/*	3 * number of unicode character bytes + 7 overhead bytes + 10 fudge
/**/
#define	JET_cbUnicodeKeyMost	( 3 * JET_cbColumnMost + 7 + 10 )
	BYTE	rgbKey[JET_cbUnicodeKeyMost];
	INT		cwKey;
	INT		cbKey;
#ifndef DATABASE_FORMAT_CHANGE
	WORD	rgwUpper[ JET_cbColumnMost / sizeof(WORD) ];
#endif

#ifndef _X86_
	/*	convert pbColumn to aligned pointer for MIPS/Alpha builds
	/**/
	BYTE	rgbColumn[JET_cbColumnMost];

	memcpy( rgbColumn, pbColumn, cbColumn );
	pbColumn = (BYTE *)&rgbColumn[0];
#endif

#ifdef DATABASE_FORMAT_CHANGE
	/*	assert non-zero length unicode string
	/**/
	Assert( cbColumn =< JET_cbColumnMost );
	Assert( cbColumn > 0 );
	Assert( cbColumn % 2 == 0 );

	//	UNDONE:	after shipping with Daytona, remove this ifdef and
	//			document database format change.
 	cbKey = LCMapStringW(
	 	MAKELCID( langid, 0 ),
#ifdef DAYTONA
		LCMAP_SORTKEY | NORM_IGNORECASE,
#else
		LCMAP_SORTKEY | NORM_IGNORECASE | SORT_STRINGSORT,
#endif
		(const unsigned short *)pbColumn,
		(int) cbColumn / sizeof(WORD),
		(unsigned short *)rgbKey,
  		JET_cbUnicodeKeyMost );
	Assert( cbKey > 0 );

	if ( cbKey > cbMax )
		{
		err = wrnFLDKeyTooBig;
		*pcbSeg = cbMax;
		}
	else
		{
		Assert( err == JET_errSuccess );
		*pcbSeg = cbKey;
		}
	memcpy( rgbSeg, rgbKey, *pcbSeg );

	return err;
#else
	/*	assert non-zero length unicode string
	/**/
	Assert( cbColumn <= JET_cbColumnMost );
	Assert( cbColumn > 0 );
	Assert( cbColumn % 2 == 0 );

 	cwKey = LCMapStringW(
	 	MAKELCID( langid, 0 ),
		LCMAP_UPPERCASE,
		(const unsigned short *) pbColumn,
		(INT) cbColumn / sizeof(WORD),
		rgwUpper,
		JET_cbColumnMost / sizeof(WORD) );
	Assert( cwKey == (INT)(cbColumn / sizeof(WORD)) );

	cbKey = LCMapStringW(
 		MAKELCID( langid, 0 ),
#ifdef DAYTONA
		LCMAP_SORTKEY,
#else
		LCMAP_SORTKEY | SORT_STRINGSORT,
#endif
		(const unsigned short *)rgwUpper,
		cbColumn / sizeof(WORD),
		(unsigned short *) rgbKey,
		JET_cbUnicodeKeyMost );

	Assert( cbKey > 0 );

	if ( cbKey > cbMax )
		{
		err = wrnFLDKeyTooBig;
		*pcbSeg = cbMax;
		}
	else
		{
		Assert( err == JET_errSuccess );
		*pcbSeg = cbKey;
		}
	memcpy( rgbSeg, rgbKey, *pcbSeg );

	return err;
#endif
	}


//+api------------------------------------------------------
//
//	ErrSysCreateThread( ULONG (*pulfn)(), ULONG cbStack, LONG lThreadPriority );
//	========================================================
//
//	ErrSysCreateThread( ULONG (*pulfn)(), TID *ptid, ULONG cbStack );
//
//	Creates a thread with the given stack size.
//
//----------------------------------------------------------
ERR ErrSysCreateThread( ULONG (*pulfn)(), ULONG cbStackSize, LONG lThreadPriority, HANDLE *phandle )
	{
	HANDLE	handle;
	TID		tid;

	Assert( sizeof(HANDLE) == sizeof(HFILE) );
	handle = (HANDLE) CreateThread( NULL,
		cbStackSize,
		(LPTHREAD_START_ROUTINE) pulfn,
		NULL,
		(DWORD) 0,
		(LPDWORD) &tid );
	if ( handle == 0 )
		return JET_errNoMoreThreads;

	if ( lThreadPriority == lThreadPriorityNormal )
		SetThreadPriority( handle, THREAD_PRIORITY_NORMAL );
	if ( lThreadPriority == lThreadPriorityEnhanced )
		SetThreadPriority( handle, THREAD_PRIORITY_ABOVE_NORMAL );
	if ( lThreadPriority == lThreadPriorityCritical )
		SetThreadPriority( handle, THREAD_PRIORITY_HIGHEST);

	/*	return handle to thread.
	/**/
	*phandle = handle;
	return JET_errSuccess;
	}


//+api------------------------------------------------------
//
//	SysExitThread( ULONG ulExitCode );
//	========================================================
//
//	SysExitThread( ULONG ulExitCode );
//
//	Exits thread.
//
//----------------------------------------------------------
VOID SysExitThread( ULONG ulExitCode )
	{
	(VOID)ExitThread( ulExitCode );
	return;
	}


//+api------------------------------------------------------
//
//	FSysExitThread
//	========================================================
//
//	FSysExitThread( HANDLE handle );
//
//	Returns fTrue if thread has exited.
//
//----------------------------------------------------------
BOOL FSysExitThread( HANDLE handle )
	{
	BOOL   	f;
	DWORD  	dwExitCode;
	DWORD	dw;

	f = GetExitCodeThread( handle, &dwExitCode );
	if ( !f )
		{
		dw = GetLastError();
		//	UNDONE:	handle error here
		Assert( fFalse );
		}

	return !(dwExitCode == STILL_ACTIVE);
	}


//+api------------------------------------------------------
//
//	ULONG UlSysThreadId( VOID )
//	========================================================
//
//	PARAMETERS
//
//----------------------------------------------------------
ULONG UlSysThreadId( VOID )
	{
	return GetCurrentThreadId();
	}


/*  open a file that was opened as for write but shared to read.
/**/
ERR ErrSysOpenReadFile( CHAR *szFileName, HANDLE *phf )
	{
	*phf = CreateFile( szFileName,
		GENERIC_READ,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		0,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL |
		FILE_FLAG_NO_BUFFERING |
		FILE_FLAG_RANDOM_ACCESS,
		0 );

	if ( *phf == handleNil )
		{
		ERR	err;

		err = ErrSYSIGetLastError( JET_errFileNotFound );
		return err;
		}

	return JET_errSuccess;
	}


//+api------------------------------------------------------
//
//	ErrSysOpenFile
//	========================================================
//
//	Open given file.
//
//----------------------------------------------------------

ERR ErrSysOpenFile(
	CHAR	*szFileName,
	HANDLE	*phf,
	ULONG	ulFileSize,
	BOOL	fReadOnly,
	BOOL	fOverlapped)
	{
	ERR		err = JET_errSuccess;
	DWORD  	fdwAccess;
	DWORD  	fdwShare;
	DWORD  	fdwAttrsAndFlags;
	BOOL   	f;

	Assert( !ulFileSize || ulFileSize && !fReadOnly );
	*phf = handleNil;

	/*	set access to read or read-write
	/**/
	if ( fReadOnly )
		fdwAccess = GENERIC_READ;
	else
		fdwAccess = GENERIC_READ | GENERIC_WRITE;

	/*	do not allow sharing on database file
	/**/
#ifdef JETSER
	fdwShare = FILE_SHARE_READ | FILE_SHARE_WRITE;
#else
	fdwShare = FILE_SHARE_READ;
#endif

	if ( fOverlapped )
		{
		fdwAttrsAndFlags =	FILE_ATTRIBUTE_NORMAL |
			FILE_FLAG_NO_BUFFERING |
			FILE_FLAG_WRITE_THROUGH |
			FILE_FLAG_RANDOM_ACCESS |
			FILE_FLAG_OVERLAPPED;
		}
	else
		{
		fdwAttrsAndFlags =	FILE_ATTRIBUTE_NORMAL |
			FILE_FLAG_NO_BUFFERING |
			FILE_FLAG_WRITE_THROUGH |
			FILE_FLAG_RANDOM_ACCESS;
		}

	if ( ulFileSize != 0L )
		{
		/* create a new file
		/**/
		fdwAttrsAndFlags = FILE_ATTRIBUTE_NORMAL |
			FILE_FLAG_WRITE_THROUGH |
			FILE_FLAG_RANDOM_ACCESS;

		*phf = CreateFile( szFileName,
			fdwAccess,
			fdwShare,
			0,
			CREATE_NEW,
			fdwAttrsAndFlags,
			0 );

		if ( *phf == handleNil )
			{
			err = ErrSYSIGetLastError( JET_errFileNotFound );
			return err;
			}

		/* no overlapped, it does not work!
		/**/
		Call( ErrSysNewSize( *phf, ulFileSize, 0, fFalse ) );

		/* force log file pre-allocation to be effective
		/**/
		Assert(sizeof(HANDLE) == sizeof(HFILE));
		f = CloseHandle( (HANDLE) *phf );
		Assert( f );

		//	UNDONE:	is this still necessary in Daytona
		/*	this bogus code works around an NT bug which
		/*	causes network files not to have file usage
		/*	restrictions reset until a GENERIC_READ file
		/*	handle is closed.
		/**/				
		if ( fOverlapped )
			{
			fdwAttrsAndFlags = FILE_ATTRIBUTE_NORMAL |
				FILE_FLAG_NO_BUFFERING |
				FILE_FLAG_WRITE_THROUGH |
				FILE_FLAG_RANDOM_ACCESS |
				FILE_FLAG_OVERLAPPED;
			}
		else
			{
			fdwAttrsAndFlags =	FILE_ATTRIBUTE_NORMAL |
				FILE_FLAG_NO_BUFFERING |
				FILE_FLAG_WRITE_THROUGH |
				FILE_FLAG_RANDOM_ACCESS;
			}

		*phf = CreateFile( szFileName,
			GENERIC_READ,
			fdwShare,
			0,
			OPEN_EXISTING,
			fdwAttrsAndFlags,
			0 );

		if ( *phf == handleNil )
			{
			err = ErrSYSIGetLastError( JET_errFileNotFound );
			return err;
			}

		f = CloseHandle( (HANDLE) *phf );
		Assert( f );
		}

	if ( fOverlapped )
		{
		fdwAttrsAndFlags =	FILE_ATTRIBUTE_NORMAL |
			FILE_FLAG_NO_BUFFERING |
			FILE_FLAG_WRITE_THROUGH |
			FILE_FLAG_RANDOM_ACCESS |
			FILE_FLAG_OVERLAPPED;
		}
	else
		{
		fdwAttrsAndFlags =	FILE_ATTRIBUTE_NORMAL |
			FILE_FLAG_NO_BUFFERING |
			FILE_FLAG_WRITE_THROUGH |
			FILE_FLAG_RANDOM_ACCESS;
		}

	*phf = CreateFile( szFileName,
		fdwAccess,
		fdwShare,
		0,
		OPEN_EXISTING,
		fdwAttrsAndFlags,
		0 );

	/* open in read_only mode if open in read_write mode failed
	/**/
	if ( *phf == handleNil && !fReadOnly && !ulFileSize )
		{
		/*	try to open file read only
		/**/
		fdwAccess = GENERIC_READ;

		*phf = CreateFile( szFileName,
			fdwAccess,
			fdwShare,
			0,
			OPEN_EXISTING,
			fdwAttrsAndFlags,
			0 );

		err = JET_wrnFileOpenReadOnly;
		}

	/*	if file could not be opened, return NULL file handle.
	/**/
	if ( *phf == handleNil )
		{
		err = ErrSYSIGetLastError( JET_errFileNotFound );
		return err;
		}
#if 0
#ifdef DEBUG
	else
		{
		SysGetDriveGeometry( *phf );
		}
#endif
#endif

HandleError:
	if ( err < 0 && *phf != handleNil )
		{
		f = CloseHandle( (HANDLE) *phf );
		Assert(f);
		*phf = handleNil;
		}
	return err;
	}


//+api------------------------------------------------------
//
//	ErrSysDeleteFile
//	========================================================
//
//	ERR ErrSysDeleteFile( const CHAR *szFileName )
//
//	Delete given file.
//
//----------------------------------------------------------
ERR ErrSysDeleteFile( const CHAR *szFileName )
	{
	if ( DeleteFile( szFileName ) )
		return JET_errSuccess;
	return JET_errFileNotFound;
	}


//+api------------------------------------------------------
//
//	ERR ErrSysNewSize( HANDLE hf, ULONG ulSize, ULONG ulSizeHigh, BOOL fOverlapped )
//	========================================================
//
//	Resize database file.  Not semaphore protected as new size
//	operation will not conflict with chgfileptr, read or write.
//
//	PARAMETERS
//		hf		 	file handle
//		cpg			new size of database file in pages
//
//----------------------------------------------------------

	
#if 0
// UNDONE: this scheme of write 1024 bytes before the end of file will not work
// UNDONE: for shrinking files.
ERR ErrSysNewSize( HANDLE hf, ULONG ulFileSize, ULONG ulFileSizeHigh, BOOL fOverlapped )
	{
#if 0
	ERR		err = JET_errSuccess;
	INT		cbT;
	ULONG 	ul;
	#define	cbSec	1024
	/*	memory must be 16-byte aligned and mulitple of 1024 bytes
	/**/
	BYTE  	*pb = (BYTE *) PvSysAllocAndCommit( cbSec + 15 );
	BYTE  	*pbAligned = (BYTE *)( (ULONG)(pb + 15) & ~0x0f );
	
	if ( pb == NULL )
		return JET_errOutOfMemory;
	Assert( sizeof(HANDLE) == sizeof(HFILE) );
	if ( ulFileSize >= cbSec )
		{
		ulFileSize -= cbSec;
		}
	else
		{
		Assert( ulFileSize == 0 );
		ulFileSizeHigh--;
		ulFileSize = (ULONG) ~cbSec + 1;
		}
	ul = SetFilePointer( (HANDLE) hf, ulFileSize, &ulFileSizeHigh, FILE_BEGIN );
	if ( ul != ulFileSize )
		{
		//	UNDONE:	check for other errors
		return JET_errDiskFull;
		}

	/* the mask bits are to satisfy the 16-byte boundary alignment in MIPS
	/**/
	(VOID)ErrSysWriteBlock( hf, pbAligned, cbSec, &cbT );
	if ( GetLastError() == ERROR_DISK_FULL )
		err = JET_errDiskFull;

	if ( pb != NULL )
		SysFree( pb );

	return err;
#else
	int		cb;
	ULONG	ul;
	
	/* the extra 15 bytes are for the sake of 16-byte
	/* boundary alignment in MIPS
	/**/
#define cbSec 1024	// must be same as in page.h
	STATIC BYTE	rgb[cbSec + 15];
	
	Assert(sizeof(HANDLE) == sizeof(HFILE));
	if ( ulFileSize >= cbSec )
		ulFileSize -= cbSec;
	else
		{
		Assert( ulFileSize == 0 );
		ulFileSizeHigh--;
		ulFileSize = (ULONG) ~cbSec + 1;
		}
	ul = SetFilePointer(
		(HANDLE) hf, ulFileSize, &ulFileSizeHigh, FILE_BEGIN );
	if ( ul != ulFileSize )
		goto CheckError;

	/* the mask bits are to satisfy the 16-byte boundary alignment in MIPS
	/**/
	(void) ErrSysWriteBlock( hf,(BYTE *) ( (ULONG)(rgb+15) & ~0x0f ), cbSec, &cb );
	if ( GetLastError() == ERROR_DISK_FULL )
		return JET_errDiskFull;

	return JET_errSuccess;

CheckError:
	if ( GetLastError() == ERROR_DISK_FULL )
		return JET_errDiskFull;

	return JET_errDiskIO;
#endif
	}
#endif


/*	the following function should work -- if FAT FS bug fixed
/**/
ERR ErrSysNewSize( HANDLE hf, ULONG ulSize, ULONG ulSizeHigh, BOOL fOverlapped )
	{
	ULONG	ul;
	BOOL	f;

	ul = SetFilePointer( hf, ulSize, &ulSizeHigh, FILE_BEGIN );
	if ( ul != ulSize )
		goto HandleError;

	f = SetEndOfFile( hf );
	if ( !( f ) )
		goto HandleError;
	
	return JET_errSuccess;

HandleError:
	if ( GetLastError() == ERROR_DISK_FULL )
		return JET_errDiskFull;

	return JET_errDiskIO;
	}

//+api------------------------------------------------------
//
// ErrSysCloseFile
// =========================================================
//
//	ERR ErrSysCloseFile( HANDLE hf )
//
//	Close file.
//
//----------------------------------------------------------
ERR ErrSysCloseHandle( HANDLE hf )
	{
	BOOL	f;

	Assert(sizeof(HANDLE) == sizeof(HFILE));
	f = CloseHandle( (HANDLE) hf );
	if ( !f )
		return JET_errFileClose;
	return JET_errSuccess;
	}


LOCAL ERR ErrCheckError( VOID )
	{
	DWORD	dw = GetLastError();
		
	if ( dw == ERROR_IO_PENDING )
		return JET_errSuccess;

	if ( dw == ERROR_INVALID_USER_BUFFER ||
		 dw == ERROR_NOT_ENOUGH_MEMORY )
		return JET_errTooManyIO;
		
	if ( dw == ERROR_DISK_FULL )
		return JET_errDiskFull;

	if ( dw == ERROR_HANDLE_EOF )
		return JET_errDiskIO;
	
	/*	if this assert is hit, then we need another error code
	/**/
	Assert( fFalse );
	return JET_errDiskIO;
	}


//+api------------------------------------------------------
//
//	ErrSysReadBlock( hf, pvBuf, cbBuf, pcbRead )
//	========================================================
//
//	ERR	ErrSysReadBlock( hf, pvBuf, cbBuf, pcbRead )
//
//	Reads cbBuf bytes of data into pvBuf.  Returns error if DOS error
//	or if less than expected number of bytes retured.
//
//----------------------------------------------------------
ERR ErrSysReadBlock( HANDLE hf, VOID *pvBuf, UINT cbBuf, UINT *pcbRead )
	{
	BOOL	f;
	INT		msec = 1;

	Assert( sizeof(HANDLE) == sizeof(HFILE) );
IssueRead:
	f = ReadFile( (HANDLE) hf, pvBuf, cbBuf, pcbRead, NULL );
	if ( f )
		{
		if ( cbBuf != *pcbRead )
			return JET_errDiskIO;
		else
			return JET_errSuccess;
		}
	else
		{
		ERR err = ErrCheckError();

		if ( err == JET_errTooManyIO )
			{
			msec <<= 1;
			Sleep( msec - 1 );
			goto IssueRead;
			}
		else
			return err;
		}
	}


//+api------------------------------------------------------
//
// ERR ErrSysWriteBlock( hf, pvBuf, cbBuf, pcbWritten )
// =========================================================
//
//	ERR	ErrSysWriteBlock( hf, pvBuf, cbBuf, pcbWritten )
//
//	Writes cbBuf bytes from pbBuf to file hf.
//
//----------------------------------------------------------
ERR ErrSysWriteBlock( HANDLE hf, VOID *pvBuf, UINT cbBuf, UINT *pcbWritten )
	{
	BOOL	f;
	INT		msec = 1;

	Assert( sizeof(HANDLE) == sizeof(HFILE) );
IssueWrite:
	f = WriteFile( (HANDLE) hf, pvBuf, cbBuf, pcbWritten, NULL );
	if ( f )
		{
		if ( cbBuf != *pcbWritten )
			{
			if ( GetLastError() == ERROR_DISK_FULL )
				return JET_errDiskFull;
			else
				return JET_errDiskIO;
			}
		else
			return JET_errSuccess;
		}
	else
		{
		ERR err = ErrCheckError();

		if ( err == JET_errTooManyIO )
			{
			msec <<= 1;
			Sleep(msec - 1);
			goto IssueWrite;
			}
		else
			return err;
		}
	}


//+api------------------------------------------------------
//
// ErrSysReadBlockOverlapped( hf, pvBuf, cbBuf, pcbRead )
// =========================================================
//
//	ERR	ErrSysReadBlock( hf, pvBuf, cbBuf, pcbRead )
//
//	Reads cbBuf bytes of data into pvBuf.  Returns error if DOS error
//	or if less than expected number of bytes retured.
//
//----------------------------------------------------------
ERR ErrSysReadBlockOverlapped(
	HANDLE	hf,
	VOID	*pvBuf,
	UINT	cbBuf,
	DWORD	*pcbRead,
	OLP		*polp)
	{
	BOOL	f;

	Assert( sizeof(HANDLE) == sizeof(HFILE) );
	Assert( sizeof(OLP) == sizeof(OVERLAPPED) );
	f = ReadFile( (HANDLE) hf, pvBuf, cbBuf, pcbRead, (OVERLAPPED *) polp );
	if ( f )
		return JET_errSuccess;
	else
		return ErrCheckError();
	}


//+api------------------------------------------------------
//
// Err	ErrSysWriteBlockOverlapped( hf, pvBuf, cbBuf, pcbWritten )
// =========================================================
//
//	ERR	ErrSysWriteBlock( hf, pvBuf, cbBuf, pcbWritten )
//
//	Writes cbBuf bytes from pbBuf to file hf.
//
//----------------------------------------------------------
ERR ErrSysWriteBlockOverlapped(
	HANDLE	hf,
	VOID	*pvBuf,
	UINT	cbBuf,
	DWORD	*pcbWritten,
	OLP		*polp)
	{
	BOOL	f;

	Assert( sizeof(HANDLE) == sizeof(HFILE) );
	Assert( sizeof(OLP) == sizeof(OVERLAPPED) );

	f = WriteFile( (HANDLE) hf, pvBuf, cbBuf, pcbWritten, (OVERLAPPED *)polp );
	if ( f )
		{
		return JET_errSuccess;
		}
	else
		{
		return ErrCheckError();
		}
	}


//+api------------------------------------------------------
//
//	ErrSysReadBlockEx( hf, pvBuf, cbBuf, pcbRead )
//	========================================================
//
//	ERR	ErrSysReadBlock( hf, pvBuf, cbBuf, pcbRead )
//
//	Reads cbBuf bytes of data into pvBuf.  Returns error if DOS error
//	or if less than expected number of bytes retured.
//
//----------------------------------------------------------
ERR ErrSysReadBlockEx(
	HANDLE	hf,
	VOID	*pvBuf,
	UINT	cbBuf,
	OLP		*polp,
	VOID	*pfnCompletion)
	{
	BOOL	f;

	Assert( sizeof(HANDLE) == sizeof(HFILE) );
	Assert( sizeof(OLP) == sizeof(OVERLAPPED) );

	f = ReadFileEx( (HANDLE) hf,
		pvBuf,
		cbBuf,
		(OVERLAPPED *) polp,
		(LPOVERLAPPED_COMPLETION_ROUTINE) pfnCompletion );

	if ( f )
		return JET_errSuccess;
	else
		return ErrCheckError();
	}


//+api------------------------------------------------------
//
//	ERR ErrSysWriteBlockEx( hf, pvBuf, cbBuf, pcbWritten )
//	========================================================
//
//	ERR	ErrSysWriteBlock( hf, pvBuf, cbBuf, pcbWritten )
//
//	Writes cbBuf bytes from pbBuf to file hf.
//
//----------------------------------------------------------
ERR ErrSysWriteBlockEx(
	HANDLE	hf,
	VOID	*pvBuf,
	UINT	cbBuf,
	OLP		*polp,
	VOID	*pfnCompletion )
	{
	BOOL	f;
	ERR		err;

	Assert( sizeof(HANDLE) == sizeof(HFILE) );
	Assert( sizeof(OLP) == sizeof(OVERLAPPED) );

	f = WriteFileEx( (HANDLE) hf,
		pvBuf,
		cbBuf,
		(OVERLAPPED *)polp,
		(LPOVERLAPPED_COMPLETION_ROUTINE)pfnCompletion );

	if ( f )
		err = JET_errSuccess;
	else
		err = ErrCheckError();

	return err;
	}


ERR ErrSysGetOverlappedResult(
	HANDLE	hf,
	OLP		*polp,
	UINT	*pcb,
	BOOL	fWait)
	{
	Assert( sizeof(HANDLE) == sizeof(HFILE) );
	Assert( sizeof(OLP) == sizeof(OVERLAPPED) );
	
	if ( GetOverlappedResult( (HANDLE) hf, (OVERLAPPED *)polp, pcb, fWait ) )
		return JET_errSuccess;

	if ( GetLastError() == ERROR_DISK_FULL )
		return JET_errDiskFull;

	return JET_errDiskIO;
	}


//+api------------------------------------------------------
//
// VOID SysChgFilePtr( HANDLE hf, LONG lRel, LONG *plRelHigh, ULONG ulRef, ULONG *pul )
// =========================================================
//
//	Changes file hf pointer to position lRef relative to position :
//
//	wRef	FILE_BEGIN	file beginnging
//
//----------------------------------------------------------
VOID SysChgFilePtr( HANDLE hf, LONG lRel, LONG *plRelHigh, ULONG ulRef, ULONG *pul )
	{
	Assert( sizeof(HANDLE) == sizeof(HFILE) );
	*pul = SetFilePointer( (HANDLE)hf, lRel, plRelHigh, ulRef );
	Assert( ulRef != FILE_BEGIN || *pul == (ULONG)lRel );
	return;
	}


//+api------------------------------------------------------
//
// ErrSysMove( CHAR *szFrom, CHAR *szTo )
// =========================================================
//
//	ERR	ErrSysMove( CHAR *szFrom, CHAR *szTo )
//
//	Renames file szFrom to file name szTo.
//
//----------------------------------------------------------
ERR ErrSysMove( CHAR *szFrom, CHAR *szTo )
	{
	if ( MoveFile( szFrom, szTo ) )
		return JET_errSuccess;
	else
		return JET_errFileAccessDenied;
	}


//+api------------------------------------------------------
//
//	ERR ErrSysCopy( CHAR *szFrom, CHAR *szTo, BOOL fFailIfExists )
//	========================================================
//
//	Copies file szFrom to file name szTo.
//	If szTo already exists, the function either fails or overwrites
//	the existing file, depending on the flag fFailIfExists
//
//----------------------------------------------------------
ERR ErrSysCopy( CHAR *szFrom, CHAR *szTo, BOOL fFailIfExists )
	{
	if ( CopyFile( szFrom, szTo, fFailIfExists ) )
		return JET_errSuccess;
	else
		return JET_errFileAccessDenied;
	}


//+api------------------------------------------------------
//
// ERR ErrSysGetComputerName( CHAR *sz, INT *pcb )
// =========================================================
//
//----------------------------------------------------------
ERR ErrSysGetComputerName( CHAR	*sz,  INT *pcb)
	{
	if ( GetComputerName( sz, pcb ) )
		return JET_errSuccess;
	else
		return JET_errNoComputerName;
	}


//+api------------------------------------------------------
//
// SysSleep( ULONG ulTime )
// =========================================================
//
//	ERR	ErrSysSleep( ULONG ulTime )
//
//	Waits ulTime milliseconds.
//
//----------------------------------------------------------
VOID SysSleep( ULONG ulTime )
	{
	Sleep( ulTime );
	return;
	}


//+api------------------------------------------------------
//
//	VOID SysSleepEx( ULONG ulTime )
//	========================================================
//
//	Waits ulTime milliseconds.
//
//----------------------------------------------------------
VOID SysSleepEx( ULONG ulTime, BOOL fAlert )
	{
	SleepEx( ulTime, fAlert );
	return;
	}


//+api------------------------------------------------------
//
//	HANDLE SysGetCurrentTask( VOID )
//	========================================================
//
//	Gets curren task handle for Windows.
//
//----------------------------------------------------------
HANDLE SysGetCurrentTask( VOID )
	{
	return LongToHandle(GetCurrentProcessId());
	}


//+api------------------------------------------------------
//
// SysNormText( CHAR *rgchText, INT cchText, CHAR *rgchNorm, INT cchNorm, INT *pchNorm )
// =========================================================
//
//	VOID SysNormText( CHAR *rgchText, INT cchText, CHAR *rgchNorm, INT cchNorm, INT *pchNorm )
//
//	Normalizes text string.
//
//----------------------------------------------------------
VOID SysNormText( CHAR *rgchText, INT cchText, BYTE *rgbNorm, INT cbNorm, INT *pbNorm )
	{
	ERR	err;

	Assert( cbNorm <= JET_cbKeyMost );
	err = ErrSysNormText( rgchText, cchText, cbNorm, rgbNorm, pbNorm );
	Assert( err == JET_errSuccess || err == wrnFLDKeyTooBig );

	return;
	}


//+api------------------------------------------------------
//
//	VOID SysCmpText( const CHAR *sz1, const CHAR sz2 )
//	========================================================
//
//	Compares two unnormalized text strings by first normalizing them
//	and then comparing them.
//
//	Returns:		> 0			if sz1 > sz2
//					== 0		if sz1 == sz2
//					< 0			if sz1 < sz2
//
//----------------------------------------------------------
INT SysCmpText( const CHAR *sz1, const CHAR *sz2 )
	{
	ERR		err;
	INT		cch1;
	INT		cch2;
	CHAR	rgch1Norm[ JET_cbKeyMost ];
	INT		cch1Norm;
	CHAR	rgch2Norm[ JET_cbKeyMost ];
	INT		cch2Norm;
	INT		cchDiff;
	INT		iCmp;

	/*	get text string lengths
	/**/
	cch1 = strlen( sz1 );
	Assert( cch1 <= JET_cbKeyMost );
	cch2 = strlen( sz2 );
	Assert( cch2 <= JET_cbKeyMost );

	err = ErrSysNormText( sz1, cch1, JET_cbKeyMost, rgch1Norm, &cch1Norm );
	Assert( err == JET_errSuccess || err == wrnFLDKeyTooBig );

	err = ErrSysNormText( sz2, cch2, JET_cbKeyMost, rgch2Norm, &cch2Norm );
	Assert( err == JET_errSuccess || err == wrnFLDKeyTooBig );
	
	cchDiff = cch1Norm - cch2Norm;
	iCmp = memcmp( rgch1Norm, rgch2Norm, cchDiff < 0 ? cch1Norm : cch2Norm );
	return iCmp ? iCmp : cchDiff;
	}


VOID SysStringCompare( char __far *pb1,
	unsigned long cb1,
	char __far *pb2,
	unsigned long cb2,
	unsigned long sort,
	long __far *plResult )
	{
	CHAR	rgb1[JET_cbColumnMost + 1];
	CHAR	rgb2[JET_cbColumnMost + 1];

	/*	ensure NULL terminated
	/**/
	memcpy( rgb1, pb1, min( JET_cbColumnMost, cb1 ) );
	rgb1[ min( JET_cbColumnMost, cb1 ) ] = '\0';
	memcpy( rgb2, pb2, min( JET_cbColumnMost, cb2 ) );
	rgb2[ min( JET_cbColumnMost, cb2 ) ] = '\0';

	*plResult = SysCmpText( (const char *)rgb1, (const char *)rgb2 );

	return;
	}


ERR ErrSysNormText(
	const BYTE	*pbText,
	INT	  		cbText,
	INT	  		cbKeyBufLeft,
	BYTE  		*pbNorm,
	INT	  		*pcbNorm )
	{
#ifdef DBCS
	INT	iLoop;
#endif

	BYTE		*pbNormBegin = pbNorm;
	BYTE		rgbAccent[ (JET_cbKeyMost + 1) / 2 + 1 ];
	BYTE		*pbAccent = rgbAccent;
	BYTE		*pbBeyondKeyBufLeft = pbNorm + cbKeyBufLeft;
	const BYTE	*pbBeyondText;
	const BYTE	*pbTextLastChar = pbText + cbText - 1;
	BYTE		bAccentTmp = 0;

    if (cbKeyBufLeft > 0)
        *pbNorm = '\0';

	while ( *pbTextLastChar-- == ' ' )
		cbText--;

	/*	add one back to the pointer
	/**/
	pbTextLastChar++;

	Assert( pbTextLastChar == pbText + cbText - 1 );
	pbBeyondText = pbTextLastChar + 1;

	while ( pbText <  pbBeyondText && pbNorm < pbBeyondKeyBufLeft )
		{
#ifdef DBCS
		if ( pbText < pbTextLastChar )
			{
			/*	two or more char remaining
			/*	check for double char to single char
			/*	for translation tables of some languages
			/**/
			for ( iLoop = 0; iLoop < cchDouble; iLoop++ )
				{
				BYTE bFirst = *pbText;

				if ( bFirst == BFirstByteOfDouble(iLoop)
					&& *(pbText + 1) == BSecondByteOfDouble(iLoop) )
					{
					/*	don't do a "pbText++" above
					/*	do a double to single conversion
					/**/
					*pbNorm++ = BThirdByteOfDouble(iLoop);

					/*	pointing at char for accent map
					/**/
					pbText++;
					
					/*	no need to loop any more
					/**/
					break;
					}
				}
			}
		else
#endif
			{
			BYTE	bTmp;

			/*	do a single to single char conversion
			/**/
			*pbNorm = bTmp = BGetTranslation(*pbText);

			if ( bTmp >= 250 )
				{
				/*	do a single to double char conversion
				/**/
				*pbNorm++	= BFirstByteForSingle(bTmp);
				if ( pbNorm < pbBeyondKeyBufLeft )
					*pbNorm	= BSecondByteForSingle(bTmp);
				else
					break;

				/*	no need to do accent any more,
				/*	so break out of while loop
				/**/
				}

			pbNorm++;
			}

		/*	at this point, pbText should point to the char for accent mapping
		/**/

		/*	do accent now
		/*	the side effect is to increment pbText
		/**/
		if ( bAccentTmp == 0 )
			{
			/*	first nibble of accent
			/**/
			bAccentTmp = (BYTE)( BGetAccent( *pbText++ ) << 4 );
			Assert( bAccentTmp > 0 );
			}
		else
			{
			/*	already has first nibble
			/**/
			*pbAccent++ = BGetAccent(*pbText++) | bAccentTmp;
			bAccentTmp = 0;
			/*	reseting the accents
			/**/
			}
		}

	if ( pbNorm < pbBeyondKeyBufLeft )
		{
		/*	need to do accent
		/**/
		*pbNorm++ = 0;

		/*	key-accent separator
		/**/
		if ( bAccentTmp != 0 && bAccentTmp != 0x10 )
			{
			/*	an trailing accent which is not 0x10 should be kept
			/**/
			*pbAccent++ = bAccentTmp;
			}

		/*	at this point, pbAccent is pointing at one char
		/*	beyond the accent bytes.  clear up trailing 0x11's
		/**/
		while (--pbAccent >= rgbAccent && *pbAccent == 0x11)
			;
		*( pbAccent + 1 ) = 0;

		/*	append accent to text.
		/*	copy bytes up to and including '\0'.
		/*	case checked for rgbAccent being empty.
		/**/
		pbAccent = rgbAccent;
		Assert( pbNorm <= pbBeyondKeyBufLeft );
		while ( pbNorm < pbBeyondKeyBufLeft  &&  (*pbNorm++  =  *pbAccent++ ) )
			;
		}

	/*	compute the length of the normalized key and return
	/**/
	*pcbNorm = (INT)(pbNorm - pbNormBegin);

	if ( pbNorm < pbBeyondKeyBufLeft )
		return JET_errSuccess;
	else
		return wrnFLDKeyTooBig;
	/*	UNDONE: even if >=, maybe
	/*	just fit, but not "too big"
	/*	Do we want KeyBufFull or TooBig?
	/**/
	}


#if 0
VOID SysGetDriveGeometry( HANDLE handle )
	{
	BOOL			f;
	DISK_GEOMETRY	disk_geometry;
	DWORD			cb;

	f = DeviceIoControl( handle,
		IOCTL_DISK_GET_DRIVE_GEOMETRY,
		NULL,
		0,
		&disk_geometry,
		sizeof(disk_geometry),
		&cb,
		NULL );
	Assert( f == fTrue );

	return;
	}
#endif


//==========================================================
//	Memory Routines
//==========================================================

#ifdef DEBUG

#ifdef MEM_CHECK
#define	icalMax	10000

typedef struct	{
	VOID	*pv;
	ULONG	cbAlloc;
	} CAL;

STATIC CAL		rgcal[icalMax];
STATIC ULONG	cbAllocTotal = 0;
STATIC ULONG	cblockAlloc = 0;
STATIC ULONG	cblockFree = 0;
STATIC BOOL		fInit = fFalse;


LOCAL VOID UtilIInsertAlloc( VOID *pv, ULONG cbAlloc )
	{
	INT	ical;

	/*	do not track failed allocations
	/**/
	if ( pv == NULL )
		return;

	/*	initialize array of allocations if not yet initialized.
	/**/
	if ( fInit == fFalse )
		{
		memset( rgcal, '\0', sizeof(rgcal) );
		fInit = fTrue;
		}

	for ( ical = 0; ical < icalMax; ical++ )
		{
		if ( rgcal[ical].pv == NULL )
			{
			rgcal[ical].pv = pv;
			rgcal[ical].cbAlloc = cbAlloc;
			cbAllocTotal += cbAlloc;
			cblockAlloc++;
			return;
			}
		}
	Assert( fFalse );
	}


LOCAL VOID UtilIDeleteAlloc( VOID *pv )
	{
	INT	ical;

	Assert( pv != NULL );
	Assert( fInit == fTrue );

	for ( ical = 0; ical < icalMax; ical++ )
		{
		if ( rgcal[ical].pv == pv )
			{
			cblockFree++;
			cbAllocTotal -= rgcal[ical].cbAlloc;
			rgcal[ical].pv = NULL;
			rgcal[ical].cbAlloc = 0;
			return;
			}
		}
	AssertSz( fFalse, "Attempt to Free a bad pointer" );
	}
#else
#define UtilIInsertAlloc( pv, cb )
#define UtilIDeleteAlloc( pv )
#endif

VOID *SAlloc( ULONG cbBlock )
	{
	VOID *pv;

#ifdef RFS2
	if ( !RFSAlloc( SAllocMemory ) )
		return NULL;
#endif

	pv =  malloc(cbBlock);
	UtilIInsertAlloc( pv, cbBlock );
	return pv;
	}


VOID OSSFree( void *pv )
	{
	UtilIDeleteAlloc( pv );
	free(pv);
	}


VOID *LAlloc( ULONG cBlock, USHORT cbBlock )
	{
	VOID *pv;

#ifdef RFS2
	if ( !RFSAlloc( LAllocMemory ) )
		return NULL;
#endif

	pv =  malloc(cBlock * cbBlock);
	UtilIInsertAlloc( pv, cBlock * cbBlock );
	return pv;
	}


VOID OSLFree( void *pv )
	{
	UtilIDeleteAlloc( pv );
	free(pv);
	}

VOID *PvSysAlloc( ULONG dwSize )
	{
	VOID		*pv;

#ifdef RFS2
	if ( !RFSAlloc( PvSysAllocMemory ) )
		return NULL;
#endif

	pv = VirtualAlloc( NULL, dwSize, MEM_RESERVE, PAGE_READWRITE );
	UtilIInsertAlloc( pv, dwSize );
	return pv;
	}


VOID *PvSysCommit( VOID *pv, ULONG ulSize )
	{
	VOID *pvCommit;

	pvCommit = VirtualAlloc( pv, ulSize, MEM_COMMIT, PAGE_READWRITE );

	return pvCommit;
	}


VOID SysFree( VOID *pv )
	{
	UtilIDeleteAlloc( pv );
	VirtualFree( pv, 0, MEM_RELEASE );
	return;
	}

#else

VOID *PvSysAlloc( ULONG dwSize )
	{
	return VirtualAlloc( NULL, dwSize, MEM_RESERVE, PAGE_READWRITE );
	}


VOID *PvSysCommit( VOID *pv, ULONG ulSize )
	{
	return VirtualAlloc( pv, ulSize, MEM_COMMIT, PAGE_READWRITE );
	}


VOID SysFree( VOID *pv )
	{
	VirtualFree( pv, 0, MEM_RELEASE );
	return;
	}

#endif


VOID *PvSysAllocAndCommit( ULONG ulSize )
	{
	VOID *pv;
	
	if ( ( pv = PvSysAlloc( ulSize ) ) == NULL )
		return pv;
	if ( PvSysCommit( pv, ulSize ) == NULL )
		{
		SysFree( pv );
		return NULL;
		}			
	return pv;
	}

	
VOID SysTerm( VOID )
	{
#ifdef MEM_CHECK
	ULONG cbTrueAllocTotal = cbAllocTotal;  /*  Alloc total not counting critJet  */
	INT	ical;

	Assert( critJet != NULL );

		/*  find critJet in store and delete size from true alloc total  */

	for ( ical = 0; ical < icalMax; ical++ )
		{
		if ( rgcal[ical].pv == critJet )
			{
			cbTrueAllocTotal -= rgcal[ical].cbAlloc;
			break;
			}
		}
		
	if (cbTrueAllocTotal != 0)
	{
		char szAllocTotal[256];
		sprintf( szAllocTotal, "%ld bytes unfreed memory on termination.", cbTrueAllocTotal );
		AssertFail((const char *)szAllocTotal, szAssertFilename, __LINE__ );
	}
#endif
	return;
	}


VOID SysDebugBreak( VOID )
	{
	DebugBreak();
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\ver.c ===
#include "config.h"

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>

#include "daedef.h"
#include "util.h"
#include "fmp.h"
#include "pib.h"
#include "dbapi.h"
#include "ssib.h"
#include "page.h"
#include "node.h"
#include "fcb.h"
#include "nver.h"
#include "fucb.h"
#include "stapi.h"
#include "stint.h"
#include "dirapi.h"
#include "bm.h"
#include "spaceapi.h"
#include "fdb.h"
#include "idb.h"
#include "fileapi.h"
#include "fileint.h"
#include "logapi.h"
#include "log.h"

DeclAssertFile;                                 /* Declare file name for assert macros */

/* On-line Compact system parameter
/**/
extern BOOL fOLCompact;

/*	transaction counters.
/**/
TRX  __near      trxOldest = trxMax;
TRX  __near      trxNewest = 0;

#ifdef ASYNC_VER_CLEANUP
/*	thread control variables.
/**/
HANDLE	handleRCECleanProc = 0;
BOOL   	fRCECleanProcTerm = fFalse;
#endif

/*	RCE clean signal
/**/
PIB		*ppibRCEClean = ppibNil;
SIG		sigRCECleanProc;
CRIT   	critBMRCEClean;

#ifdef DEBUG
INT	cVersion = 0;
#endif

/****************** Bucket Layer ***************************
/***********************************************************

A "bucket chain" is a set of bucket(s) for a user.
A bucket chain is empty when pbucket is pbucketNil.
When bucket chain has only one bucket, then ibNewestRCE has some
value.  it *cannot* be the case that this only bucket is empty.
pbucketNext and pbucketPrev are both pbucketNil.

When a bucket chain has more than one bucket, then pbucketNext and
pbucketPrev in all these buckets have the value of a traditional
doubly-linked list.  ibNewestRCE in all buckets do point to the
newest RCE in that bucket.

When it is the newest bucket, then the pbucketNext is pbucketNil.

The pbucket in the PIB will point to the newest bucket. so that
commit/rollback/createRCE will be fast.  RCE clean will need to
traverse if more than one bucket.  (maybe able to use a stack to keep
track of the buckets, and thus need no pbucketPrev.)

There needs to be ibOldestRCE per bucket chain.  We put it in PIB,
together with pbucket.  It is init to 0, and if we insert an RCE and
see that it is 0, then we set it to the right value.  RCEClean
will change it after throwing away any RCE.  Commit/Rollback may need
set it back to 0, when they throw the bucket away after cleaning up
the oldest RCE (at the bottom of the oldest bucket)

We know we have reached the top of the bucket when we clean up an RCE which
is pointed to by ibNewest RCE.

************************************************************
***********************************************************/

#define IbDoubleWordBoundary(ib)                                                                \
	( (INT) ( ((DWORD_PTR) (ib) + 3) & ~3 ) )

#define PbDoubleWordBoundary(pb)                                                                \
	( (BYTE *) ( ((DWORD_PTR) (pb) + 3) & ~3 ) )

/*	to align an RCE in a bucket
/**/
#define IbAlignRCE(ib)  IbDoubleWordBoundary(ib)
#define PbAlignRCE(pb)  PbDoubleWordBoundary(pb)

#define FBucketNew(pbucket)                                                                     \
	( (pbucket)->ibNewestRCE == 0 )

#define IbFreeInNewBucket(pbucket)                                                      \
	IbAlignRCE( cbBucketHeader )

#define PrceNewestRCE(pbucket)                                                          \
	( (RCE *) ( (BYTE *) (pbucket) + (pbucket)->ibNewestRCE )   )

#define IbOfPrce( prce, pbucket )        ( (BYTE *)prce - (BYTE *)pbucket )

// CONSIDER: Optimize
// New RCE located at: look at ibNewestRCE, skip that RCE with
//	the data portion if any.  However, if bucket is new, then
//	it is IbAlignRCE(sizeof(BUCKET_HEADER))

#define IbFreeInBucket(pbucket)										\
	( FBucketNew(pbucket) ? IbFreeInNewBucket(pbucket)				\
		: IbAlignRCE(												\
			(pbucket)->ibNewestRCE                                  \
			+ sizeof(RCE)											\
			+ (PrceNewestRCE(pbucket)) ->cbData ) )


/*	the cast to (INT) below is necessary to catch the negative case
/**/
#define CbFreeInBucket(pbucket)										\
	( ( (pbucket == pbucketNil) ?									\
		0 : ((INT) sizeof(BUCKET) - (INT) IbFreeInBucket(pbucket) ) ) )


#define FNoVersionExists( prce )									\
	( PrceRCEGet( prce->dbid, prce->bm ) == prceNil )


/*	given prce == prceNil, return the first RCE in bucket.
/**/
INLINE LOCAL RCE *PrceRCENext( BUCKET *pbucket, RCE *prce )
	{
	Assert( pbucket == NULL || prce != PrceNewestRCE(pbucket) );

	return (RCE *) PbAlignRCE (
		(BYTE *) ( prce == prceNil ?
		(BYTE *) pbucket + cbBucketHeader :
		(BYTE *) prce + sizeof(RCE) + prce->cbData ) );
	}


//+local
//	ErrBUAllocBucket( PIB *ppib )
//	========================================================
//	Inserts a bucket to the top of the bucket chain, so that new RCEs
//	can be inserted.  Note that the caller must set ibNewestRCE himself.
//-
LOCAL ERR ErrBUAllocBucket( PIB *ppib )
	{
	BUCKET	*pbucket = PbucketMEMAlloc();

#ifdef ASYNC_VER_CLEANUP
	if ( rgres[iresVersionBucket].cblockAvail < cbucketLowerThreshold )
		{
		SignalSend( sigRCECleanProc );
		}
#endif

	/*	if no bucket available, then try to free one by
	/*	cleanning all PIBs.
	/**/
	if ( pbucket == pbucketNil )
		{
		(VOID) ErrRCECleanAllPIB();

		pbucket = PbucketMEMAlloc();
		if ( pbucket == pbucketNil )
			{
			BFSleep( 1000 );
			(VOID) ErrRCECleanAllPIB();
	
			pbucket = PbucketMEMAlloc();
			}

		if ( pbucket == pbucketNil )
			{
			return JET_errOutOfMemory;
			}
	
		MEMReleasePbucket( pbucket );
		return errDIRNotSynchronous;
		}

	Assert( pbucket != NULL );

	if ( ppib->pbucket != pbucketNil )
		{
		pbucket->pbucketNext = pbucketNil;
		pbucket->pbucketPrev = (BUCKET *)ppib->pbucket;
		Assert( ppib->pbucket->pbucketNext == pbucketNil );
		ppib->pbucket->pbucketNext = pbucket;
		ppib->pbucket = pbucket;
		pbucket->ibNewestRCE = 0;
		}
	else
		{
		pbucket->pbucketNext = pbucketNil;
		pbucket->pbucketPrev = pbucketNil;
		ppib->pbucket = pbucket;
		pbucket->ibNewestRCE = 0;
		Assert( ppib->ibOldestRCE == 0 );
		}

	return JET_errSuccess;
	}


//+local
//	BUFreeNewestBucket(PIB *ppib)
//	==========================================================================
//	Delete the newest bucket of a bucket chain.
//
//-
LOCAL VOID BUFreeNewestBucket( PIB *ppib )
	{
	BUCKET *pbucket = (BUCKET *)ppib->pbucket;

	Assert( pbucket != pbucketNil );
	Assert( pbucket->pbucketNext == pbucketNil );

	if ( pbucket->pbucketPrev != pbucketNil )
		{
		ppib->pbucket = pbucket->pbucketPrev;
		ppib->pbucket->pbucketNext = pbucketNil;
		}
	else
		{
		ppib->pbucket = pbucketNil;
		ppib->ibOldestRCE = 0;
		}

	MEMReleasePbucket( pbucket );
	return;
	}


//+local
//	PbucketBUOldest( PIB *ppib )
//	==========================================================================
//	Given a pbucket pointer to the newest or newer bucket, find
//	the oldest bucket in the bucket chain.
//
//-
LOCAL BUCKET *PbucketBUOldest( PIB *ppib )
	{
	BUCKET  *pbucket = (BUCKET *)ppib->pbucket;

	if ( pbucket != pbucketNil )
		{
		while ( pbucket->pbucketPrev != pbucketNil )
			{
			pbucket = pbucket->pbucketPrev;
			}
		}

	return pbucket;
	}


//+local
//	BUFreeOldestBucket( PIB *ppib )
//	==========================================================================
//	Delete the bottom (oldest) bucket of a bucket chain.
//
//-
LOCAL VOID BUFreeOldestBucket( PIB *ppib )
	{
	BUCKET *pbucket = PbucketBUOldest( ppib );

	Assert( pbucket != pbucketNil );
	Assert( pbucket->pbucketPrev == pbucketNil );

	/*	unlink bucket from bucket chain and free.
	/**/
	if ( pbucket->pbucketNext != pbucketNil )
		{
		pbucket->pbucketNext->pbucketPrev = pbucketNil;
		}
	else
		{
		Assert( ppib->pbucket == pbucket );
		ppib->pbucket = pbucketNil;
		ppib->ibOldestRCE = 0;
		}

	MEMReleasePbucket( pbucket );
	return;
	}


/****************** RCE Layer ******************************
/***********************************************************

Different node may hash to same bucket, but there will be a chain of
struct RCEHEAD for different node.  Each of these contains a pointer
to the next RCEHEAD, ptr to RCE (the chain), and the DBID and SRID.

Same as before, younger RCEs precede older ones in the chain.

A hash entry (a prcehead) can be prceNil, but a prcehead.prcechain can't
be (ie, the rcehead must be deleted totally).

************************************************************
***********************************************************/

/*	RCE hash table size
/**/
#define cprceHeadHashTable              4096

/*	RCE hash table is an array of pointers to RCEHEAD
/**/
RCE *rgprceHeadNodeHashTable[cprceHeadHashTable];

/*	XOR the lower byte of the page number and the itag.
/*	See V2 Storage spec for rationale.
/**/
#define UiRCHashFunc( bm )      (UINT) ( (((UINT)ItagOfSrid(bm)) << 4) ^ (PgnoOfSrid(bm) & 0x00000fff) )

LOCAL RCE **PprceHeadRCEGet( DBID dbid, SRID bm );
LOCAL RCE *PrceRCENext( BUCKET *pbucket, RCE *prce );
LOCAL VOID RCEInsert( DBID dbid, SRID bm, RCE *prce );
LOCAL ULONG RCECleanProc( VOID );

VOID AssertRCEValid( RCE *prce )
	{
	Assert( prce->oper == operReplace ||
		prce->oper == operInsert ||
		prce->oper == operFlagDelete ||
		prce->oper == operNull ||
		prce->oper == operDelta ||
		prce->oper == operInsertItem ||
		prce->oper == operFlagDeleteItem ||
		prce->oper == operFlagInsertItem );
	Assert( prce->level <= levelMax );
	Assert( prce->ibUserLinkBackward < sizeof(BUCKET) );
	}


//+local
//	FRCECorrect( DBID dbid1, SRID srid1, DBID dbid2, SRID srid2 )
//	==========================================================================
//	Checks whether two node are the same after hashing.  Since two
//	bookmarks with same pgno but different itag would hash to different
//	RCHashTable entry, if they hash to same entry and has same pgno, then
//	their itag must be the same.  A && ~B => ~C,  C && A => B.
//	(Where A == same pgno.  B == same itag.  C == same hash value.)
//-
#ifdef DEBUG
LOCAL BOOL FRCECorrect( DBID dbid1, SRID srid1, DBID dbid2, SRID srid2 )
	{
	Assert( PgnoOfSrid( srid1 ) != PgnoOfSrid( srid2 ) ||
		ItagOfSrid( srid1 ) == ItagOfSrid( srid2 ) );
	return ( srid1 == srid2 && dbid1 == dbid2 );
	}
#else
#define FRCECorrect( dbid1, srid1, dbid2, srid2 )       \
	( srid1 == srid2 && dbid1 == dbid2 )
#endif


//+local
//	PrceRCEGet( DBID dbid, SRID srid, RCEHEAD *rgprceheadHashTable)
//	==========================================================================
//	Given a DBID and SRID, get the correct hash chain of RCEs.
//-
RCE *PrceRCEGet( DBID dbid, SRID bm )
	{
	RCE *prceHead;

	SgSemRequest( semST );

	prceHead = rgprceHeadNodeHashTable[ UiRCHashFunc( bm ) ];

	while( prceHead != prceNil )
		{
		if ( FRCECorrect( dbid, bm, prceHead->dbid, prceHead->bm ) )
			{
			/*	assert hash chain not prceNil since empty chains are
			/*	removed from hash table.
			/**/
			SgSemRelease( semST );
			return prceHead;
			}
		prceHead = prceHead->prceHeadNext;
		}

	SgSemRelease( semST );

	/*	no such node found
	/**/
	return prceNil;
	}


//+local
//	PrceheadRCEGet(DBID dbid, SRID bm )
//	==========================================================================
//	Given a SRID, get the correct RCEHEAD.
//-
LOCAL RCE **PprceHeadRCEGet( DBID dbid, SRID bm )
	{
	RCE **pprceHead;

	SgSemAssert( semST );

	pprceHead = &rgprceHeadNodeHashTable[ UiRCHashFunc( bm ) ];
	while ( *pprceHead != prceNil )
		{
		RCE *prceT = *pprceHead;

		if ( FRCECorrect( dbid, bm, prceT->dbid, prceT->bm ) )
			{
			return pprceHead;
			}
		pprceHead = &prceT->prceHeadNext;
		}

	/*	no version chain found for node
	/**/
	return pNil;
	}


//+local
//	ErrRCEInsert( DBID dbid, SRID bm, RCE *prce )
//	==========================================================================
//	Inserts an RCE to hash table
//-
LOCAL VOID RCEInsert( DBID dbid, SRID bm, RCE *prce )
	{
	RCE	**pprceHead;

	SgSemRequest( semST );

	pprceHead = PprceHeadRCEGet( dbid, bm );

	if ( pprceHead )
		{
		/*	hash chain for node already exist
		/**/
		RCE *prcePrevHead = *pprceHead;

		Assert( *pprceHead != prceNil );

		/* adjust head links
		/**/
		*pprceHead = prce;
		prce->prceHeadNext = prcePrevHead->prceHeadNext;
		prcePrevHead->prceHeadNext = prceNil;

		/* adjust RCE links
		/**/
		prce->prcePrev = prcePrevHead;
		}
	else
		{
		/*	hash chain for node not yet exists
		/**/
		UINT    uiRCHashValue = UiRCHashFunc( bm );

		/*	create new rcehead
		/**/
		prce->prceHeadNext = rgprceHeadNodeHashTable[ uiRCHashValue ];
		rgprceHeadNodeHashTable[ uiRCHashValue ] = prce;

		/*	chain new RCE
		/**/
		prce->prcePrev = prceNil;
		}

	SgSemRelease( semST );
	}


//+local
//	VOID VERDeleteRce( RCE *prce )
//	==========================================================================
//	Deals with the hash chain and may delete the RCEHEAD, but it doesn't
//	do anything to the RCE that is still in the bucket.
//-
VOID VERDeleteRce( RCE *prce )
	{
	RCE	**pprce;

	Assert( prce != prceNil );

	SgSemRequest( semST );

	pprce = PprceHeadRCEGet( prce->dbid, prce->bm );
	Assert( pprce != pNil );

	if ( *pprce == prce )
		{
		if ( prce->prcePrev )
			{
			*pprce = prce->prcePrev;
			(*pprce)->prceHeadNext = prce->prceHeadNext;
			}
		else
			*pprce = prce->prceHeadNext;
		}
	else
		{
		/* search for the entry in the rce list
		/**/
		RCE *prceT = *pprce;

		while ( prceT->prcePrev != prce )
			{
			prceT = prceT->prcePrev;

			/* must be found
			/**/
			Assert( prceT != prceNil );
			}

		prceT->prcePrev = prce->prcePrev;
		}

	/*	set prcePrev to prceNil to prevent it from
	/*	being deleted again by commit/rollback.
	/**/
	prce->prcePrev = prceNil;

	SgSemRelease( semST );
	return;
	}


/****************** Version Layer *************************
/**********************************************************
/**/


//+API
//	ErrVERInit( VOID )
//	=========================================================
//	Creates background version bucket clean up thread.
//-
ERR ErrVERInit( VOID )
	{
	ERR     err = JET_errSuccess;

	memset( rgprceHeadNodeHashTable, 0, sizeof(rgprceHeadNodeHashTable) );

#ifdef WIN32
	CallR( ErrSignalCreateAutoReset( &sigRCECleanProc, "ver proc signal" ) );
#else
	CallR( ErrSignalCreate( &sigRCECleanProc, "ver proc signal" ) );
#endif
	CallR( ErrInitializeCriticalSection( &critBMRCEClean ) );
#ifdef ASYNC_VER_CLEANUP
	/*	allocate session for RCE clean up
	/**/
	CallR( ErrPIBBeginSession( &ppibRCEClean ) );

	fRCECleanProcTerm = fFalse;
	err = ErrSysCreateThread( (ULONG (*) ()) RCECleanProc, cbStack,
		lThreadPriorityCritical, &handleRCECleanProc );
	if ( err < 0 )
		PIBEndSession( ppibRCEClean );
	Call( err );
#endif

HandleError:
	return err;
	}


//+API
//	VOID VERTerm( VOID )
//	=========================================================
//	Terminates background thread and releases version store
//	resources.
//-
VOID VERTerm( VOID )
	{
#ifdef ASYNC_VER_CLEANUP
	/*	terminate RCECleanProc.
	/**/
	Assert( handleRCECleanProc != 0 );
	fRCECleanProcTerm = fTrue;
	do
		{
		SignalSend( sigRCECleanProc );
		BFSleep( cmsecWaitGeneric );
		}
	while ( !FSysExitThread( handleRCECleanProc ) );
	CallS( ErrSysCloseHandle( handleRCECleanProc ) );
	handleRCECleanProc = 0;

	Assert( trxOldest == trxMax );
	CallS( ErrRCECleanAllPIB() );

	SignalClose(sigRCECleanProc);
	DeleteCriticalSection( critBMRCEClean );
	PIBEndSession( ppibRCEClean );
	ppibRCEClean = ppibNil;
#endif
//	Assert( cVersion == 0 );
	return;
	}


//+API
//	FVERNoVersion
//	==========================================================================
//	Used by asynchronous clean process to reset version bits orphaned
//	by system crash.  Returns fTrue if no version exists for
//	given dbid:bm.
//
BOOL FVERNoVersion( DBID dbid, SRID bm )
	{
	return PrceRCEGet( dbid, bm ) == prceNil;
	}


//+API
//	VsVERCheck( FUCB *pfucb, SRID bm )
//	==========================================================================
//	Given a SRID, returns the version status
//
//	RETURN VALUE
//		vsCommitted
//		vsUncommittedByCaller
//		vsUncommittedByOther
//
//-
VS VsVERCheck( FUCB *pfucb, SRID bm )
	{
	RCE *prce;

	/*	get the RCE of node from hash table
	/**/
	prce = PrceRCEGet( pfucb->dbid, bm );

	Assert( prce == prceNil || prce->oper != operNull);

	/*	if no RCE for node then version bit in node header must
	/*	have been orphaned due to crash.  Remove node bit.
	/**/
	if ( prce == prceNil )
		{
		if ( FFUCBUpdatable( pfucb ) )
			NDResetNodeVersion( pfucb );
		return vsCommitted;
		}

	if ( prce->trxPrev != trxMax )
		{
		/*	committed
		/**/
		return vsCommitted;
		}
	else if ( prce->pfucb->ppib != pfucb->ppib )
		{
		/*	not modifier (uncommitted)
		/**/
		return vsUncommittedByOther;
		}
	else
		{
		/*	modifier (uncommitted)
		/**/
		return vsUncommittedByCaller;
		}

	/*	invalid function return
	/**/
	Assert( fFalse );
	}


//+API
//	NsVERAccessNode( FUCB *pfucb, SRID bm )
//	==========================================================================
//	Finds the correct version of a node.
//
//	PARAMETERS
//		pfucb			various fields used/returned.
//		pfucb->line		the returned prce or NULL to tell caller to
//						use the node in the DB page.
//
//	RETURN VALUE
//		nsVersion
//		nsDatabase
//		nsInvalid
//-
NS NsVERAccessNode( FUCB *pfucb, SRID bm )
	{
	RCE		*prce;
	TRX		trxSession;
	NS		nsStatus;

	/*	session with dirty cursor isolation model should never
	/*	call NsVERAccessNode.
	/**/
	Assert( !FPIBDirty( pfucb->ppib ) );

	/*	get trx for session.  Set to trxSession to trxMax if session
	/*	has committed or dirty cursor isolation model.
	/**/
	if ( FPIBVersion( pfucb->ppib ) )
		trxSession = pfucb->ppib->trx;
	else
		trxSession = trxMax;

	SgSemRequest ( semST );

	/*	get first version for node
	/**/
	prce = PrceRCEGet( pfucb->dbid, bm );
	Assert( prce == prceNil ||
		prce->oper == operReplace ||
		prce->oper == operInsert ||
		prce->oper == operFlagDelete ||
		prce->oper == operDelta );

	while ( prce != NULL && prce->oper == operDelta )
		prce = prce->prcePrev;

	/*	if no RCE for node then version bit in node header must
	/*	have been orphaned due to crash.  Remove node bit.
	/**/
	if ( prce == prceNil )
		{
		if ( FFUCBUpdatable( pfucb ) )
			NDResetNodeVersion( pfucb );
		nsStatus = nsDatabase;
		}
	else if ( prce->trxCommitted == trxMax &&
		prce->pfucb->ppib == pfucb->ppib )
		{
		/*	if caller is modifier of uncommitted version    then database
		/**/
		nsStatus = nsDatabase;
		}
	else if ( prce->trxCommitted < trxSession )
		{
		/*	if no uncommitted version, or committed version
		/*	younger than our transaction then database
		/**/
		Assert( prce->trxPrev != trxMax );
		nsStatus = nsDatabase;
		}
	else
		{
		/*	look for correct version.  If caller is not in a transaction
		/*	then find the newest committed version.
		/**/
		if ( trxSession == trxMax )
			{
			RCE *prceT;

			for ( prceT = prce->prcePrev;
				prce->trxPrev == trxMax;
				prce = prceT, prceT = prce->prcePrev )
				{
				Assert( prce->oper == operReplace ||
					prce->oper == operInsert ||
					prce->oper == operFlagDelete );
				while ( prceT != prceNil && prceT->oper == operDelta )
					prceT = prceT->prcePrev;
				if ( prceT == prceNil )
					break;
				}
			}
		else
			{
			while ( prce->prcePrev != prceNil &&
				( prce->oper == operDelta ||
				prce->trxPrev >= trxSession ) )
				{
				Assert( prce->oper == operReplace ||
					prce->oper == operInsert ||
					prce->oper == operFlagDelete );
				prce = prce->prcePrev;
				}
			}

		if ( prce->oper == operReplace )
			{
			nsStatus = nsVersion;

			Assert( prce->cbData >= 4 );
			pfucb->lineData.pb = prce->rgbData + cbReplaceRCEOverhead;
			pfucb->lineData.cb = prce->cbData - cbReplaceRCEOverhead;
			}
		else if ( prce->oper == operInsert )
			{
			nsStatus = nsInvalid;
			}
		else
			{
			Assert( prce->oper == operFlagDelete );
			nsStatus = nsVerInDB;
			}
		}

	SgSemRelease( semST );
	return nsStatus;
	}


/*	returns fTrue if uncommitted increment or decrement version
/**/
BOOL FVERDelta( FUCB *pfucb, SRID bm )
	{
	RCE     *prce;
	BOOL    fUncommittedVersion = fFalse;

	/*	get prce for node and look for uncommitted increment/decrement
	/*	versions.  Note that these versions can only exist in
	/*	uncommitted state.
	/**/
	SgSemRequest ( semST );

	prce = PrceRCEGet( pfucb->dbid, bm );
	if ( prce != prceNil && prce->trxCommitted == trxMax )
		{
		forever
			{
			Assert( prce->level > 0 );
			if ( prce->oper == operDelta )
				{
				fUncommittedVersion = fTrue;
				break;
				}
			prce = prce->prcePrev;
			if ( prce == prceNil || prce->trxCommitted != trxMax )
				{
				Assert( fUncommittedVersion == fFalse );
				break;
				}
			}
		}

	SgSemRelease( semST );
	return fUncommittedVersion;
	}


//+API
//	ErrVERCreate( FUCB *pfucb, SRID bm, OPER oper, RCE **pprce )
//	==========================================================================
//	Creates an RCE in a bucket and chain it up in the hash chain
//
//-
ERR ErrVERCreate( FUCB *pfucb, SRID bm, OPER oper, RCE **pprce )
	{
	ERR		err = JET_errSuccess;
	RCE		*prce;
	INT		cbNewRCE;
	INT		ibFreeInBucket;
	BUCKET	*pbucket;

	Assert( PgnoOfSrid( bm ) != pgnoNull );
	Assert( bm != sridNull );
	Assert( pfucb->ppib->level > 0 );

#ifdef DEBUG
	/*	assert correct bookmark
	/**/
	if ( !fRecovering && ( oper == operReplace || oper == operFlagDelete ) )
		{
		SRID	bmT;

		NDGetBookmark( pfucb, &bmT );
		Assert( bm == bmT );

		Assert( !FNDDeleted( *pfucb->ssib.line.pb ) );
		}
#endif

	/* set default return value
	/**/
	if ( pprce )
		*pprce = prceNil;

	if ( pfucb->ppib->level == 0 )
		return JET_errSuccess;

	SgSemRequest( semST );

	/*	get bucket pointer
	/**/
	pbucket = (BUCKET *)pfucb->ppib->pbucket;

	/*	find the starting point of the RCE in the bucket.
	/*	make sure the DBID with SRID is starting on a double-word boundary.
	/*	calculate the length of the RCE in the bucket.
	/*	if updating node, set cbData in RCE to length of data. (w/o the key).
	/*	set cbNewRCE as well.
	/**/
	if ( oper == operReplace )
		cbNewRCE = sizeof(RCE) + cbReplaceRCEOverhead + pfucb->lineData.cb;
	else if ( FOperItem( oper ) )
		cbNewRCE = sizeof(RCE) + sizeof(SRID);
	else if ( oper == operDelta )
	  	cbNewRCE = sizeof(RCE) + sizeof(LONG);
	else
		{
		Assert( oper == operInsert || oper == operFlagDelete );
		cbNewRCE = sizeof(RCE);
		}

	/*	if insufficient bucket space, then allocate new bucket.
	/**/
	Assert( CbFreeInBucket( pbucket ) >= 0 &&
		CbFreeInBucket( pbucket ) < sizeof(BUCKET) );
	if ( cbNewRCE > CbFreeInBucket( pbucket ) )
		{
		/*	ensure that buffer is not overlayed during
		/*	bucket allocation.
		/**/
		Call( ErrBUAllocBucket( pfucb->ppib ) );
		pbucket = (BUCKET *)pfucb->ppib->pbucket;
		}
	Assert( cbNewRCE <= CbFreeInBucket( pbucket ) );
	Assert( pbucket == (BUCKET *)pfucb->ppib->pbucket );
	/*	pbucket always on double-word boundary
	/**/
	Assert( (BYTE *) pbucket == (BYTE *) PbAlignRCE ( (BYTE *) pbucket ));

	ibFreeInBucket = IbFreeInBucket( pbucket );
	Assert( ibFreeInBucket < sizeof(BUCKET) );

	/*	set prce to next RCE location, and assert aligned
	/**/
	prce = (RCE *)( (BYTE *) pbucket + ibFreeInBucket );
	Assert( prce == (RCE *) PbAlignRCE( (BYTE *) pbucket + ibFreeInBucket ) );

	/*	set cbData
	/**/
	if ( oper == operReplace )
		prce->cbData = (USHORT)(pfucb->lineData.cb + cbReplaceRCEOverhead);
	else if ( FOperItem( oper ) )
		prce->cbData = sizeof(SRID);
	else if ( oper == operDelta )
		prce->cbData = sizeof(LONG);
	else
		prce->cbData = 0;

	/*	oper must be set prior to calling ErrRCEInsert
	/**/
	prce->oper = oper;

	/*	if RCE for this operation should be chained to the
	/*	hash table then chain it.  Do this prior to setting version
	/*	bit in node, and incrementing page version count to simply
	/*	clean up.
	/**/
	Assert( prce->oper != operNull &&
		prce->oper != operDeferFreeExt &&
		prce->oper != operAllocExt &&
		!FOperDDL( prce->oper ) );

	/*	check RCE
	/**/
	Assert( prce == (RCE *) PbAlignRCE ( (BYTE *) prce ) );
	Assert( (BYTE *)prce - (BYTE *)pbucket == ibFreeInBucket );

	/*	if it is not item operations, and it is not in recovering, then we
	/*	can set Version count. Note that ssib.line is not available during
	/*	recovering
	/**/
	if ( !FOperItem( oper ) && !fRecovering )
		{
		/*	if new RCE has no ancestor then set the version bit
		/*	and increment page version count.
		/**/
		Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
		if ( !FNDVersion( *pfucb->ssib.line.pb ) )
			{
			/*	dirty page buffer. but no increment ulDBTime since not logged and
			/*	not affect directory cursor timestamp check.
			/**/
			if ( !FBFDirty( pfucb->ssib.pbf ) )
				{
				BFDirty( pfucb->ssib.pbf );
				}
			PMIncVersion( pfucb->ssib.pbf->ppage );
			}
		}

	/*	set trx to max, to indicate RCE is uncommitted.  If previous RCE
	/*	then copy its trx into trxCommitted.  Later trxCommitted will
	/*	be updated with the commit time of this RCE, so that it may supply
	/*	this trx to subsequent RCEs on this node.
	/**/
	prce->dbid = pfucb->dbid;
	prce->bm = bm;
	prce->trxCommitted = trxMax;
	prce->pfucb = pfucb;
	prce->pfcb = pfcbNil;

	/* null bookmark
	/**/
	prce->bmTarget = sridNull;

	/* pfucb must be assigned before InsertRce is called
	/**/
	RCEInsert( pfucb->dbid, bm, prce );

	/*	if previous version then set trx to commit time
	/*	of previous version.  When this version commits, this time
	/*	will be moved to trx, and the commit time of this version will
	/*	be stored in the trx for subsequent version.
	/*	If there is no previous version, then store trxMax in trx.
	/**/
	if ( prce->prcePrev != prceNil )
		prce->trxPrev = prce->prcePrev->trxCommitted;
	else
		prce->trxPrev = trxMax;

	prce->level = pfucb->ppib->level;

	/*	If replacing node, rather than inserting or deleting node,
	/*	copy the data to RCE for before image for version readers.
	/*	Data size may be 0.
	/**/
	if ( oper == operReplace )
		{
		SHORT	*ps = (SHORT *)prce->rgbData;

		/* set cbMax
		/**/
		if ( prce->prcePrev != prceNil &&
			prce->prcePrev->level > 0 &&
			prce->prcePrev->oper == operReplace )
			{
			RCE		*prcePrev = prce->prcePrev;
			SHORT	*psPrev = (SHORT *)prcePrev->rgbData;

			psPrev = (SHORT *)prcePrev->rgbData;
			*ps = max( (*psPrev), (SHORT)pfucb->lineData.cb );
			}
		else
			{
			/* set cbMax
			/**/
			*ps = (SHORT) pfucb->lineData.cb;
			}

		/* initialize cbAdjust
		/**/
		ps++;
		*ps = 0;

		/* move to data byte
		/**/
		ps++;

		/* copy data
		/**/
		memcpy( (BYTE *)ps, pfucb->lineData.pb, pfucb->lineData.cb );

		Assert( prce->cbData >= cbReplaceRCEOverhead );

		/*	set RCE created indicator for logging
		/**/
		if ( prce->cbData != cbReplaceRCEOverhead )
			pfucb->prceLast = prce;
		else
			pfucb->prceLast = prceNil;
		}
	else if ( FOperItem( oper ) )
		{
		*(SRID *)prce->rgbData = BmNDOfItem( PcsrCurrent(pfucb)->item );
		}
	else if ( oper == operDelta )
		{
		Assert( pfucb->lineData.cb == sizeof(LONG) );
		*(LONG *)prce->rgbData = *(LONG *)pfucb->lineData.pb;
		}

	/*	set index to last RCE in bucket, and set new last RCE in bucket.
	/*	If this is the first RCE in bucket, then set index to 0.
	/**/
	prce->ibUserLinkBackward = pbucket->ibNewestRCE;
	Assert( prce->ibUserLinkBackward < sizeof(BUCKET) );
	pbucket->ibNewestRCE = (USHORT)ibFreeInBucket;

	/*	if this is first RCE for session, then record
	/*	index of RCE in bucked in PIB.
	/**/
	if ( pfucb->ppib->ibOldestRCE == 0 )
		{
		Assert( pbucket == (BUCKET *) pfucb->ppib->pbucket );
		Assert( pbucket != pbucketNil );
		Assert( pbucket->pbucketNext == pbucketNil &&
			pbucket->pbucketPrev == pbucketNil );
		pfucb->ppib->ibOldestRCE = ibFreeInBucket;
		Assert( pfucb->ppib->ibOldestRCE != 0 );
		}

	if ( pprce )
		*pprce = prce;

	/*	no RCE follows delete in regular run.
	/*  BM clean up check the old version is not there before
	/*  starting, but in redo we do not know when to clean up old
	/*  versions. So ignore the following assert for redo.
	/**/
	Assert( fRecovering ||
		prce->prcePrev == prceNil ||
		prce->prcePrev->oper != operFlagDelete );

#ifdef DEBUG
	if ( FOperItem( prce->oper ) )
		{
		Assert( prce->oper == operFlagDeleteItem ||
			prce->oper == operInsertItem ||
			prce->oper == operFlagInsertItem );

//	UNDONE:	assert does not execute correctly.  Recode as neste if
//			and reenable.
#if 0
		/*	if previous RCE is at level 0, then flag insert
		/*	item may have been committed and cleaned up
		/*	out of order to the flag delete item version
		/**/
		Assert( fRecovering ||
			prce->prcePrev == prceNil ||
			prce->prcePrev->level == 0 ||
			prce->oper == operFlagInsertItem ||
			prce->prcePrev->oper != operFlagDeleteItem ||
			*(SRID *)prce->rgbData != *(SRID *)prce->prcePrev->rgbData );
#endif
		}

	/*	no RCE at same level unless belong to same user.  Note that
	/*	item delete item operations may have operations on
	/*	other items as the prev RCE.
	/*
	/*	Note that this assert is only applicable for non-item operations,
	/*	since item operations on different items are keyed with the same
	/*	bookmark, i.e. first item list node bookmark.
	/**/
	if ( !fRecovering &&
		prce->prcePrev != prceNil &&
		( !FOperItem( prce->oper ) ) &&
		prce->oper != operDelta &&
		prce->prcePrev->level > 0 )
		{
		/*	check FOperItem filter
		/**/
		Assert( prce->oper != operFlagDeleteItem &&
			prce->oper != operFlagInsertItem );
		Assert( prce->oper != operDelta );
		Assert( prce->level > 0 && prce->prcePrev->level > 0 );
		Assert( prce->prcePrev->pfucb->ppib == prce->pfucb->ppib );
		}
#endif
	
	Assert( err == JET_errSuccess );

	/*	flag FUCB version
	/**/
	FUCBSetVersioned( pfucb );

	if ( pfucb->u.pfcb->dbid != dbidTemp )
		{
		Assert( prce->oper != operDeferFreeExt );
		prce->pfcb = pfucb->u.pfcb;
		FCBVersionIncrement( pfucb->u.pfcb );
		Assert( ++cVersion > 0 );
		}

HandleError:
	SgSemRelease( semST );
	return err;
	}


/*	adjust delta of version with new delta from same session at
/*	same transaction level, or from version committed to same
/*	transaction level as version.
/**/
#define VERAdjustDelta( prce, lDelta )	*(LONG *)(prce)->rgbData += (lDelta)


//+API
//	ErrVERModify( FUCB *pfucb, OPER oper, RCE **pprce )
//	=======================================================
//	Create an RCE for the modification for session.
//
//	RETURN VALUE
//		Jet_errWriteConflict for two cases:
//			-for any committed node, caller's transaction begin time
//			is less than node's level 0 commit time.
//			-for any uncommitted node at all by another session
//-
ERR ErrVERModify( FUCB *pfucb, SRID bm, OPER oper, RCE **pprce )
	{
	ERR     err = JET_errSuccess;
	RCE     *prce;
	TRX     trxSession;

#ifdef DEBUG
	/* set default return value
	/**/
	if ( pprce )
		*pprce= prceNil;
#endif

	/*	set trxSession based on cim model
	/**/
	if ( FPIBVersion( pfucb->ppib ) )
		trxSession = pfucb->ppib->trx;
	else
		trxSession = trxMax;

	/*	get RCE
	/**/
	prce = PrceRCEGet( pfucb->dbid, bm );

	/*	if it is for item operation, need go down further to the
	/*	RCE for item list node and for item if present.  Note that
	/*	this search does not have to be done for operInsertItem
	/*	versions since no previous item can exist when an item is
	/*	being inserted.
	/**/
	if ( prce != prceNil && ( oper == operFlagInsertItem || oper == operFlagDeleteItem ) )
		{
		while ( *(SRID *)prce->rgbData != PcsrCurrent( pfucb )->item )
			{
			Assert( oper == operFlagInsertItem ||
				oper == operFlagDeleteItem );
			prce = prce->prcePrev;
			if ( prce == prceNil )
				break;
			}
		}

	Assert( prce == prceNil || prce->oper != operNull);

	if ( prce == prceNil )
		{
#ifdef DEBUG
		if ( !fRecovering && ( oper == operReplace || oper == operFlagDelete ))
			{
			if ( !fRecovering )
				{
				AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );
				Assert( !( FNDDeleted( *pfucb->ssib.line.pb ) ) );
				}
			}
#endif
		Call( ErrVERCreate( pfucb, bm, oper, pprce ) );
		}
	else
		{
		if ( prce->pfucb->ppib == pfucb->ppib )
			{
			/* BM clean up check the old version is not there before
			/* starting, but in redo we do not know when to clean up old
			/* versions. So ignore the following assert for redo.
			/**/
			Assert( fRecovering || prce->oper != operFlagDelete );

			/*	if this RCE was created by the requestor
			/*	If no RCE exists for this user at this Xact level.
			/**/
			Assert ( prce->level <= pfucb->ppib->level );
			if ( prce->level != pfucb->ppib->level )
				{
				/*	RCE not exists at this level
				/**/
				Call( ErrVERCreate( pfucb, bm, oper, pprce ) );
				}
			else
				{
				//	RCE exists at this level
				//-------------------------------------------------
				//	Action table.  Nine cases, all within same Xact level:
				//	the table reduces to create RCE if operDelete
				//-------------------------------------------------
				//	Situation			Action
				//-------------------------------------------------
				//	Del after Del		impossible
				//	Del after Ins		create another RCE
				//	Del after Rep		create another RCE
				//	Ins after Del		impossible
				//	Ins after Rep		impossible
				//	Ins after Ins		impossible
				//	Rep after Del		impossible
				//	Rep after Ins		do nothing
				//	Rep after Rep		do nothing
				//-------------------------------------------------
				if ( oper == operReplace )
					{
					//	UNDONE:	fix handling of prceLast so
					//	that in place updates are efficient but
					//	still logged as undoable.
					if ( pprce != NULL )
						{
						*pprce = prce;
						Assert( err == JET_errSuccess );
						}
					}
				else if ( oper == operDelta )
					{
					Assert( pfucb->lineData.cb == sizeof(LONG) );
					Assert( prce->pfucb->ppib == pfucb->ppib );
					VERAdjustDelta( prce, *( (LONG *)pfucb->lineData.pb ) );
					}
				else
					{
					Assert( oper == operFlagDelete ||
						oper == operFlagDeleteItem ||
						oper == operFlagInsertItem );
					Call( ErrVERCreate( pfucb, bm, oper, pprce ) );
					}
				}
			}
		else
			{
			/*	RCE was not created by requestor
			/*	If RCE committed and is older than caller's Xact begin
			/**/
			if ( prce->trxCommitted < trxSession )
				{
				/*	if previous RCE is at level 0, then flag insert
				/*	item may have been committed and cleaned up
				/*	out of order to the flag delete item version
				/**/
				Assert( fRecovering || prce->oper != operFlagDelete );
				Assert( oper == operFlagInsertItem ||
					prce->level == 0 ||
					prce->oper != operFlagDeleteItem );
				Assert( (ULONG)prce->trxCommitted < trxSession );

				/*	if prce->trxPrev is less than transaction trx then
				/*	it must be committed.
				/**/
				Call( ErrVERCreate( pfucb, bm, oper, pprce ) );
				}
			else
				{
				/*	caller is looking at a versioned node in an RCE, so
				/*	disallow any modification/delete
				/**/
				err = JET_errWriteConflict;
				}
			}
		}

HandleError:
	Assert( err < 0 || pprce == NULL || *pprce != prceNil );
	return err;
	}

	
INT CbVERGetCbReserved( RCE *prce )
	{
	/*	the total reserved space cannot be negative
	/**/
	SHORT 	cbReserved = 0;
	RCE		*prceT;

	for (	prceT = prce;
			(	prceT != prceNil &&
				prceT->pfucb->ppib == prce->pfucb->ppib &&
				prceT->level > 0 &&
				prceT->oper == operReplace
			);
			prceT = prceT->prcePrev )
		{
		cbReserved += *((SHORT *)prceT->rgbData + 1);
		}

	Assert( cbReserved >= 0 );

	return cbReserved;
	}


VOID VERSetCbAdjust( FUCB *pfucb, RCE *prce, INT cbDataNew, INT cbData, BOOL fNoUpdatePage )
	{
	SHORT 	*ps;
	INT		cbMax;
	INT		cbDelta = cbDataNew - cbData;

	Assert( prce != prceNil );
	Assert( prce->bm == PcsrCurrent( pfucb )->bm );
	Assert( prce->oper != operReplace || *(SHORT *)prce->rgbData >= 0 );
	Assert( cbDelta != 0 );
	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );

	if ( prce->oper != operReplace )
		return;

	/*	flag PIB as defer free node space
	/**/
	PIBSetDeferFreeNodeSpace( pfucb->ppib );

	ps = (SHORT *)prce->rgbData;
	cbMax = *ps;
	/*	set new node maximum size.
	/**/
	if ( cbDataNew > cbMax )
		*ps = (SHORT)cbDataNew;
	ps++;

	/*  *ps is to record how much the operation contribute to deferred
	 *  space reservation. -cbDelta means cbDelta bytes less are reserved.
	 *  cbDelta means cbDelta bytes more are reserved.
	 */
	if ( cbDelta > 0 )
		{
		/*	node is enlarged.  Free any allocated free space.
		/**/
		Assert( cbData <= cbMax );
	
		/*  check if cbDelta is greater then the reserved bytes so far,
		 *  if so, then free all the reserved space.
		 */
 		if ( cbDelta > cbMax - cbData )
			{
			/* new data is largest one, free all previous reserved space */
			cbDelta = cbMax - cbData;
			}

		if ( !fNoUpdatePage )
			PMFreeFreeSpace( &pfucb->ssib, cbDelta );
		}
	else
		{
		if ( !fNoUpdatePage )
			PMAllocFreeSpace( &pfucb->ssib, -cbDelta );
		}

	*ps -= (SHORT)cbDelta;

#ifdef DEBUG
	{
	INT cb = CbVERGetCbReserved( prce );
	Assert( cb == 0 || cb == (*(SHORT *)prce->rgbData) - cbDataNew );
	}
#endif

	return;
	}


LOCAL VOID VERResetCbAdjust( FUCB *pfucb, RCE *prce, BOOL fBefore )
	{
	SHORT		*ps;

	Assert( prce != prceNil );
	Assert( fRecovering && prce->bmTarget == PcsrCurrent( pfucb )->bm ||
			prce->bm == PcsrCurrent( pfucb )->bm );
	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
	Assert( prce->oper == operReplace );

	ps = (SHORT *)prce->rgbData + 1;

	if ( *ps > 0 )
		{
		if ( fBefore )
			PMFreeFreeSpace( &pfucb->ssib, *ps );
		}
	else
		{
		if ( !fBefore )
			PMAllocFreeSpace( &pfucb->ssib, -(*ps) );
		}

	return;
	}


INT CbVERGetNodeMax( FUCB *pfucb, SRID bm )
	{
	RCE	*prce;

	prce = PrceRCEGet( pfucb->dbid, bm );
	if ( prce == prceNil )
		return 0;
	Assert( prce->bm == bm );
	if ( prce->oper != operReplace )
		return 0;

	return *(SHORT *)prce->rgbData;
	}


INT CbVERGetNodeReserve( FUCB *pfucb, SRID bm )
	{
	RCE	*prce;
	INT	cbReserved;
	
	prce = PrceRCEGet( pfucb->dbid, bm );
	if ( prce == prceNil )
		return 0;
	Assert( prce->bm == bm );
	if ( prce->oper != operReplace )
		return 0;

	cbReserved = CbVERGetCbReserved( prce );
		
	AssertNDGet( pfucb, pfucb->ssib.itag );
	Assert( cbReserved == 0 ||
		cbReserved == ( *(SHORT *)prce->rgbData) -
		(INT)CbNDData( pfucb->ssib.line.pb, pfucb->ssib.line.cb ) );

	return cbReserved;
	}


//+API
//	NS NsVERAccessItem( FUCB *pfucb, SRID bm )
//	==========================================================================
//	Finds the correct version of an item.
//
//	PARAMETERS
//		pfucb			various fields used/returned.
//		bm				bookmark of first node in item list
//		pnsStatus		code to indicate the right place for the node.
//
//	RETURN VALUE
//		nsVersion
//		nsDatabase
//		nsInvalid
//-
NS NsVERAccessItem( FUCB *pfucb, SRID bm )
	{
	RCE		*prce;
	SRID	bmT = BmNDOfItem( PcsrCurrent(pfucb)->item );
	TRX		trxSession;
	NS		nsStatus;

	/*	session with dirty cursor isolation model should never
	/*	call ErrVERAccess*.
	/**/
	Assert( !FPIBDirty( pfucb->ppib ) );

	/*	get trx for session.  Set to trxSession to trxMax if session
	/*	has committed or dirty cursor isolation model.
	/**/
	if ( FPIBVersion( pfucb->ppib ) )
		trxSession = pfucb->ppib->trx;
	else
		trxSession = trxMax;

	SgSemRequest ( semST );

	/*	get first version for node.
	/**/
	prce = PrceRCEGet( pfucb->dbid, bm );
	Assert( prce == prceNil || FOperItem( prce->oper ) );

	/*	if this RCE is not for fucb index, then move back in
	/*	RCE chain until prceNil or until latest RCE for item and
	/*	current index found.
	/**/
	while ( prce != prceNil && *(SRID *)prce->rgbData != bmT )
		{
		prce = prce->prcePrev;
		Assert( prce == prceNil || FOperItem( prce->oper ) );
		}

	/*	if no RCE for node then version bit in node header must
	/*	have been orphaned due to crash.  Remove node bit.
	/**/
	if ( prce == prceNil )
		{
		if ( FFUCBUpdatable( pfucb ) )
			NDResetItemVersion( pfucb );
		nsStatus = nsDatabase;
		}
	else if ( prce->trxCommitted == trxMax &&
		prce->pfucb->ppib == pfucb->ppib )
		{
		/*	if caller is modifier of uncommitted version then database
		/**/
		nsStatus = nsDatabase;
		}
	else if ( trxSession > prce->trxCommitted )
		{
		/*	if no uncommitted version and committed version
		/*	younger than our transaction then database
		/**/
		Assert( prce->trxPrev != trxMax || prce->trxCommitted == trxMax );
		nsStatus = nsDatabase;
		}
	else
		{
		/*	get correct RCE for this item and session trx.
		/**/
		if ( trxSession == trxMax )
			{
			/*	caller is at transaction level 0
			/**/
			RCE     *prceT;

			/*	this loop will set prce to oldest uncommitted RCE or
			/*	latest committed RCE.
			/**/
			for ( prceT = prce->prcePrev;
				prce->trxPrev == trxMax;
				prce = prceT, prceT = prce->prcePrev )
				{
				/*	get next RCE for this item.
				/**/
				while ( prceT != prceNil && *(SRID *)prceT->rgbData != bmT )
					{
					Assert( FOperItem( prceT->oper ) );
					prceT = prceT->prcePrev;
					}

				/*	if no more RCE then break;
				/**/
				if ( prceT == prceNil )
					break;
				}
			}
		else
			{
			/*	find RCE with time stamp older than our timestamp.
			/**/
			while ( prce->prcePrev != prceNil &&
				( *(SRID *)prce->rgbData != bmT ||
				prce->trxPrev >= trxSession ) )
				{
				Assert( FOperItem( prce->oper ) );
				prce = prce->prcePrev;
				}
			}

		Assert( prce != prceNil );

		/*	if RCE is uncommitted without previous committed RCE or
		/*	RCE was committed before session transcation start or
		/*	RCE is not committed then if not insert then the item is there.
		/*	otherwise it is not there.
		/*	Note that >= must be used when comparing trxCommitted to trxSession
		/*	so that case of trxCommitted == trxMax is handled properly.
		/**/
		if ( ( prce->trxPrev == trxMax || prce->trxCommitted >= trxSession ) ^ ( prce->oper == operInsertItem ) )
			nsStatus = nsVersion;
		else
			nsStatus = nsInvalid;
		}

	SgSemRelease( semST );
	return nsStatus;
	}


ERR ErrVERFlag( FUCB *pfucb, OPER oper, VOID *pv, INT cb )
	{
	ERR		err = JET_errSuccess;
	BUCKET	*pbucket;
	INT		cbT;
	INT		ibFreeInBucket;
	RCE		*prce;

	Assert( pfucb->ppib->level > 0 );
	Assert( oper == operAllocExt ||
		oper == operDeferFreeExt ||
		FOperDDL( oper ) );

	SgSemRequest( semST );

	pbucket = (BUCKET *)pfucb->ppib->pbucket;
	cbT = sizeof(RCE) + cb;

	/*	if insufficient bucket space, then allocate new bucket.
	/**/
	Assert( CbFreeInBucket( pbucket ) >= 0 &&
		CbFreeInBucket( pbucket ) < sizeof(BUCKET) );
	if ( cbT > CbFreeInBucket( pbucket ) )
		{
		Call( ErrBUAllocBucket( pfucb->ppib ) );
		pbucket = (BUCKET *)pfucb->ppib->pbucket;
		}
	Assert( cbT <= CbFreeInBucket( pbucket ) );

	/*	pbucket always on double-word boundary
	/**/
	Assert( (BYTE *) pbucket == (BYTE *) PbAlignRCE ( (BYTE *) pbucket ) );
	ibFreeInBucket = IbFreeInBucket( pbucket );
	Assert( ibFreeInBucket < sizeof(BUCKET) );

	/*	set prce to next RCE location, and assert aligned
	/**/
	prce = (RCE *)( (BYTE *) pbucket + ibFreeInBucket );
	Assert( prce == (RCE *) PbAlignRCE( (BYTE *) pbucket + ibFreeInBucket ) );
	prce->prcePrev = prceNil;
	prce->dbid = pfucb->dbid;
	prce->bm = sridNull;
	prce->trxPrev = trxMax;
	prce->trxCommitted = trxMax;
	prce->oper = oper;
	prce->level = pfucb->ppib->level;
	prce->pfucb = pfucb;
	prce->pfcb = pfcbNil;
	prce->bmTarget = sridNull;
	prce->cbData = (WORD)cb;
	memcpy( prce->rgbData, pv, cb );

	/*	set index to last RCE in bucket, and set new last RCE in bucket.
	/*	If this is the first RCE in bucket, then set index to 0.
	/**/
	prce->ibUserLinkBackward = pbucket->ibNewestRCE;
	Assert( prce->ibUserLinkBackward < sizeof(BUCKET) );
	pbucket->ibNewestRCE = (USHORT)ibFreeInBucket;

	/*	if this is first RCE for session, then record
	/*	index of RCE in bucket in PIB.
	/**/
	if ( pfucb->ppib->ibOldestRCE == 0 )
		{
		Assert( pbucket == pfucb->ppib->pbucket );
		Assert( pbucket != pbucketNil );
		Assert( pbucket->pbucketNext == pbucketNil &&
			pbucket->pbucketPrev == pbucketNil );
		pfucb->ppib->ibOldestRCE = ibFreeInBucket;
		Assert( pfucb->ppib->ibOldestRCE != 0 );
		}

	/*	flag FUCB version
	/**/
	FUCBSetVersioned( pfucb );

	if ( pfucb->u.pfcb->dbid != dbidTemp )
		{
		if ( prce->oper == operDeferFreeExt )
			{
			/*	increment reference version against parent domain FCB
			/*	and reference space operation against domain
			/**/
			FCB *pfcbT = PfcbFCBGet( prce->dbid, ((VEREXT *)prce->rgbData)->pgnoFDP );
			Assert( pfcbT != NULL );

			prce->pfcb = pfcbT;
			FCBVersionIncrement( pfcbT );
			Assert( ++cVersion > 0 );
			}
		else
			{
			prce->pfcb = pfucb->u.pfcb;
			FCBVersionIncrement( pfucb->u.pfcb );
			Assert( ++cVersion > 0 );
			}
		}

HandleError:
	SgSemRelease( semST );
	return err;
	}


/********************* RCE CLEANUP ************************
/**********************************************************
/**/

LOCAL VOID VERFreeExt( DBID dbid, PGNO pgnoFDP, PGNO pgnoFirst, CPG cpg )
	{
	ERR     err;
	PIB     *ppib = ppibNil;
	FUCB    *pfucb = pfucbNil;

	Call( ErrPIBBeginSession( &ppib ) );
	Call( ErrDBOpenDatabaseByDbid( ppib, dbid ) );
	Call( ErrDIROpen( ppib, pfcbNil, dbid, &pfucb ) );
	Call( ErrDIRBeginTransaction( ppib ) );
	(VOID)ErrSPFreeExt( pfucb, pgnoFDP, pgnoFirst, cpg );
	err = ErrDIRCommitTransaction( ppib );
	if ( err < 0 )
		{
		CallS( ErrDIRRollback( ppib ) );
		}

HandleError:
	if ( pfucb != pfucbNil )
		{
		DIRClose( pfucb );
		}

	if ( ppib != ppibNil )
		{
		/*	may not have opened database but close in
		/*	case we did open database.
		/**/
		(VOID)ErrDBCloseDatabase( ppib, dbid, 0 );
		PIBEndSession( ppib );
		}

	return;
	}


//	ERR ErrVERDeleteItem( PIB *ppib, RCE *prce )
//	=======================================================
//	Part of OLC -- deletes item in index
//	if operFlagDeleteItem
//	if first or last item node, delete node.
LOCAL ERR ErrVERDeleteItem( PIB *ppib, RCE *prce )
	{
	ERR		err;
	ITEM	item = *(ITEM *) prce->rgbData;
	FUCB    *pfucb = pfucbNil;

	Assert( prce->cbData == sizeof( ITEM ) );

	CallJ( ErrDBOpenDatabaseByDbid( ppib, prce->dbid ) , EndSession );
	Call( ErrDIROpen( ppib, pfcbNil, prce->dbid, &pfucb ) );
	CallS( ErrDIRBeginTransaction( ppib ) );

	/* goto the bookmark/item
	/**/
	CheckCSR( pfucb );
	FUCBSetIndex( pfucb );
	FUCBSetNonClustered( pfucb );

	DIRGotoBookmarkItem( pfucb, prce->bm, item );

	CallS( ErrDIRDelete( pfucb, fDIRNoVersion | fDIRDeleteItem ) );

	CallS( ErrDIRCommitTransaction( ppib ) );

HandleError:
	if ( pfucb != pfucbNil )
		{
		DIRClose( pfucb );
		}

	CallS( ErrDBCloseDatabase( ppib, prce->dbid, 0 ) );

EndSession:
	Assert( err == JET_errSuccess || err == JET_errDatabaseNotFound );
	err = JET_errSuccess;
	return err;
	}


//+API
//	ERR ErrRCECleanPIB( PIB *ppibAccess, PIB *ppib, BOOL fRCEClean )
//	==========================================================================
//	Given a ppib, it cleans RCEs in the bucket chain of the PIB.
//	We only clean up the RCEs that has a commit timestamp older
//	that the oldest XactBegin of any user.
//
//	PARAMETER
//		ppibAccess				the user id of calling function
//		ppib					the user id to be cleaned
//		ppib->pbucket			the user's bucket chain
//		ppib->ibOldestRCE		oldest RCE in bucket chain
//-
ERR ErrRCECleanPIB( PIB *ppibAccess, PIB *ppib, INT fRCEClean )
	{
	ERR     err = JET_errSuccess;
	BUCKET  *pbucket;
	RCE     *prce;
	TRX     trxMic;

	Assert( ppib != ppibNil );

	/*	clean PIB in critical section held across IO operations
	/**/
	LeaveCriticalSection( critJet );
	EnterNestableCriticalSection( critBMRCEClean );
	EnterCriticalSection( critJet );

	/*	if fRCEClean is clean all then clean all
	/*	RCEs outside of transaction semantics.  This
	/*	will be called from bookmark clean up
	/*	to make rollbackable changes coincide with
	/*	unversioned expunge operations.
	/**/
	if ( fRCEClean == fRCECleanAll )
		{
		trxMic = trxMax;
		}
	else
		{
		SgSemRequest( semST );
		trxMic = trxOldest;
		SgSemRelease( semST );
		}

	/*	get oldest bucket for user and clean RCEs from oldest to youngest
	/**/
	pbucket = PbucketBUOldest( ppib );

	/*	return if PIB has no buckets, or if oldest bucket is has RCE
	/*	younger than oldest transaction.
	/**/
	if ( pbucket == pbucketNil || PrceNewestRCE( pbucket )->trxCommitted > trxMic )
		{
		Assert( err == JET_errSuccess );
		goto HandleError;
		}

	/*	set prce for oldest bucket
	/**/
	Assert( ppib->ibOldestRCE != 0 );
	prce = (RCE *)PbAlignRCE( (BYTE *) pbucket + ppib->ibOldestRCE );

	/*	loop through buckets, oldest to newest, and check the trx of
	/*	the PrceNewestRCE in each bucket.  We can clean the bucket
	/*	if the PrceNewestRCE has a trx less than trxMic.
	/**/
	while ( pbucket != pbucketNil &&
		PrceNewestRCE( pbucket )->trxCommitted < trxMic )
		{
		Assert( pbucket->pbucketPrev == pbucketNil );
		Assert( PrceNewestRCE( pbucket )->level == 0 );

		/*	for each RCE which has no successor, delete hash table
		/*	head for version chain and reset node version bit.
		/*	If can complete these operations without error for
		/*	each such RCE, then free bucket.
		/**/
		forever
			{
			if ( prce->oper != operNull &&
				prce->trxCommitted >= trxMic )
				goto Done;
			Assert( prce->oper == operNull || prce->trxCommitted != trxMax );
			Assert( prce->oper == operNull || prce->level == 0 );
			Assert( prce <= PrceNewestRCE( pbucket ) );

			//	UNDONE: reset version bit.  This must be done by beginning a
			//	new session, opening a cursor on each version
			//	database, and resetting the bit via a node operation.
			//	It would be best to perform these ErrDIROpen calls
			//	in a transaction so that resources may be retained
			//	until clean up is complete.  Note that this could be made
			//	much more efficient by only reseting bit if buffer
			//	containing node still in memory, and possibly, only
			//	if buffer is dirty.

			//	UNDONE: remove all posibility of access of RCE older
			//	than trxOldest, and only delete RCE head
			//	structures when this RCE has no subsequent RCEs

			/*********************************************/
			/*	BEFORE FCB decrement processing
			/*	this clean up code needs the FCB
			/*********************************************/

			if ( prce->oper == operDeleteIndex )
				{
				/*	if index has versions remaining, then
				/*	defer clean up so that aliasing of verisons does
				/*	not occur, when space is reused.
				/**/
				if ( (*(FCB **)prce->rgbData)->cVersion > 0 )
					{
					goto Done;
					}
				}
			else if ( prce->oper == operDeleteTable )
				{
				FCB	*pfcbT;

				/*	if index has versions remaining, then
				/*	defer clean up so that aliasing of verisons does
				/*	not occur, when space is reused.
				/**/

				/*	may be pfcbNil if sentinel
				/**/
				pfcbT = PfcbFCBGet( prce->dbid, *(PGNO *)prce->rgbData );
				if ( pfcbT != pfcbNil && pfcbT->cVersion > 0 )
					{
					goto Done;
					}
				}
			else if ( prce->oper == operDeferFreeExt )
				{
				/*	free defer freed space must be done
				/*	before FCB version reference count on parent FDP
				/*	is released, since parent FCB must be in memory
				/*	for space operation.
				/**/
				Assert( prce->dbid == dbidTemp || prce->pfcb != pfcbNil );
#ifdef DEBUG
				{
				FCB		*pfcbT;

				/*	if child FDP FCB has versions remaining, then
				/*	defer clean up so that aliasing of verisons does
				/*	not occur, when space is reused.
				/**/
				pfcbT = PfcbFCBGet( prce->dbid, ((VEREXT *)prce->rgbData)->pgnoChildFDP );
				Assert( pfcbT == pfcbNil );
				}
#endif

				/*	free child FDP space to parent FDP
				/**/
				Assert( prce->cbData == sizeof(VEREXT) );
				VERFreeExt( prce->dbid,
					((VEREXT *)prce->rgbData)->pgnoFDP,
					((VEREXT *)prce->rgbData)->pgnoFirst,
					((VEREXT *)prce->rgbData)->cpgSize );

				Assert( prce->oper != operNull && prce->level == 0 );
				prce->oper = operNull;
				}
			else if ( prce->oper == operFlagDeleteItem )
				{
				/* delete item [cleanup]
				/**/
				if ( fOLCompact)
					{
// UNDONE:	commented out for stability reasons.
//			Fix bugs and reinstate.
//					Call( ErrVERDeleteItem( ppibAccess, prce ) );
					}

				/* delete RCE from hash chain.
				/**/
				VERDeleteRce( prce );
				Assert( prce->oper != operNull && prce->level == 0 );
				prce->oper = operNull;
				}

			/*********************************************/
			/*	FCB DECREMENT
			/*********************************************/

			/*	finished processing version for FCB
			/**/
			if ( prce->pfcb != pfcbNil )
				{
				Assert( cVersion-- > 0 );
				FCBVersionDecrement( prce->pfcb );
				prce->pfcb = pfcbNil;
				}

			/*********************************************/
			/*	AFTER FCB decrement processing
			/*	this clean up code does not need the FCB
			/*********************************************/

			/*	handle special case of delete index and
			/*	remaining outstanding versions.  Must clean
			/*	other buckets first.
			/**/
			if ( prce->oper == operDeleteIndex )
				{
				Assert( (*(FCB **)prce->rgbData)->cVersion == 0 );
				Assert( (*(FCB **)prce->rgbData)->pfcbNextIndex == pfcbNil );
				RECFreeIDB( (*(FCB **)prce->rgbData)->pidb );
				Assert( (*(FCB **)prce->rgbData)->cVersion == 0 );
				MEMReleasePfcb( (*(FCB **)prce->rgbData) );
				Assert( prce->oper != operNull && prce->level == 0 );
				prce->oper = operNull;
				}
			else if ( prce->oper == operDeleteTable )
				{
				Assert( (PGNO *)prce->rgbData != pgnoNull );
				/*	FCB may be either sentinel or table FCB
				/**/
				FCBPurgeTable( prce->dbid, *(PGNO *)prce->rgbData );
				}
			else if ( prce->oper != operNull &&
				prce->oper != operAllocExt &&
				!FOperDDL( prce->oper ) )
				{
				/*	delete RCE from hash chain.
				/**/
				VERDeleteRce( prce );
				Assert( prce->oper != operNull && prce->level == 0 );
				prce->oper = operNull;
				}

			/*	if RCE unlinked was newest in bucket then free bucket.
			/**/
			if ( prce == PrceNewestRCE( pbucket ) )
				{
				break;
				}

			/*	not newest RCE in bucket
			/**/
			prce = PrceRCENext( pbucket, prce );
			Assert( prce != prceNil );
			}

		/*	all RCEs in bucket cleaned.  Now get next bucket and free
		/*	cleaned bucket.
		/**/
		pbucket = pbucket->pbucketNext;
		BUFreeOldestBucket( ppib );
		/*	get RCE in next bucket
		/**/
		prce = PrceRCENext( pbucket, prceNil );
		}

	/*	stop as soon as find RCE commit time younger than oldest
	/*	transaction.  If bucket left then set ibOldestRCE and
	/*	unlink back offset of last remaining RCE.
	/*	If no error then set warning code if some buckets could
	/*	not be cleaned.
	/**/
	if ( ppib->pbucket != pbucketNil )
		{
Done:
		Assert( pbucket != pbucketNil );
		ppib->ibOldestRCE = (INT)((BYTE *)prce - (BYTE *)pbucket);
		Assert( ppib->ibOldestRCE != 0 );
		Assert( ppib->ibOldestRCE < sizeof(BUCKET) &&
			ppib->ibOldestRCE >= IbAlignRCE( cbBucketHeader ) );
		prce->ibUserLinkBackward = 0;
		err = JET_wrnRemainingVersions;
		}

HandleError:
	/*	return warning if remaining versions
	/**/
	if ( err == JET_errSuccess && ppib->pbucket != pbucketNil )
		err = JET_wrnRemainingVersions;
	LeaveNestableCriticalSection( critBMRCEClean );
	return err;
	}


//+API
//	ERR ErrRCECleanAllPIB( VOID )
//	=======================================================
//	Cleans up RCEs in each user's bucket chain.
//	It loops thru all the PIBs and calls RCECleanPIB
//	to perform the clean up job, and then it gives up its CPU time slice.
//-
ERR ErrRCECleanAllPIB( VOID )
	{
	ERR		err = JET_errSuccess;
	ERR		wrn;
#define cErrRCECleanAllPIBMost	10
	INT		cRCECleanAllPIB = 0;
	PIB		*ppib;

	/*	read ppibNext in ppib or read ppibAnchor only in
	/*	semST critical section.
	/**/
	SgSemRequest( semST );
	ppib = ppibAnchor;
	SgSemRelease( semST );

	do
		{
		/*	reset warning cumulator
		/**/
		wrn = JET_errSuccess;

		while ( ppib != ppibNil )
			{
			/*	clean this PIB
			/**/
			Call( ErrRCECleanPIB( ppibRCEClean, ppib, 0 ) );
			if ( wrn == JET_errSuccess )
				wrn = err;

			SgSemRequest( semST );
			ppib = ppib->ppibNext;
			SgSemRelease( semST );
			}

		cRCECleanAllPIB++;
		}
	while ( wrn == JET_wrnRemainingVersions && cRCECleanAllPIB < cErrRCECleanAllPIBMost );

HandleError:
	return err;
	}


/*==========================================================
	VOID RCECleanProc( VOID )

	Go through all sessions, cleaning buckets as versions are
	no longer needed.  Only those versions older than oldest
	transaction are cleaned up.

	Returns:
		void

	Side Effects:
		frees buckets.

==========================================================*/
#ifdef ASYNC_VER_CLEANUP
ULONG RCECleanProc( VOID )
	{
	forever
		{
		SignalWait( sigRCECleanProc, -1 );
#ifndef WIN32
		SignalReset( sigRCECleanProc );
#endif
		EnterCriticalSection( critJet );
		(VOID) ErrRCECleanAllPIB();
		LeaveCriticalSection( critJet );

		if ( fRCECleanProcTerm )
			{
			break;
			}
		}

//	/*	exit thread on system termination.
//	/**/
//	SysExitThread( 0 );
	return 0;
	}
#endif /* ASYNC_VER_CLEANUP */


//+local----------------------------------------------------
//	UpdateTrxOldest
//	========================================================
//
//	LOCAL VOID UpdateTrxOldest( PIB *ppib )
//
//	finds the oldest transaction among all transactions
//	other than ppib->trx [this is the one being deleted]
//----------------------------------------------------------
LOCAL VOID UpdateTrxOldest( PIB *ppib )
	{
	TRX		trxMinTmp = trxMax;
	PIB		*ppibT = ppibAnchor;

	SgSemAssert( semST );
	Assert( ppib->trx == trxOldest );
	for ( ; ppibT ; ppibT = ppibT->ppibNext )
		{
		if ( ppibT->trx < trxMinTmp && ppibT->trx != ppib->trx)
			trxMinTmp = ppibT->trx;
		}

	trxOldest = trxMinTmp;
	}


//+api------------------------------------------------------
//	ErrVERBeginTransaction
//	========================================================
//
//	ERR ErrVERBeginTransaction( PIB *ppib )
//
//	Increment the session transaction level.
//----------------------------------------------------------
ERR ErrVERBeginTransaction( PIB *ppib )
	{
	ERR		err = JET_errSuccess;

	/*	increment session transaction level.
	/**/
	ppib->level++;
	Assert( ppib->level < levelMax );
	if ( ppib->level == 1 )
		{
		SgSemRequest( semST );
		ppib->trx = ++trxNewest;
		if ( trxOldest == trxMax )
			trxOldest = ppib->trx;

		if ( !( fLogDisabled || fRecovering ) )
			{
			EnterCriticalSection(critLGBuf);
			GetLgposOfPbEntry( &ppib->lgposStart );
			LeaveCriticalSection(critLGBuf);
			}
		SgSemRelease( semST );
		}

	Assert( err == JET_errSuccess );
	return err;
	}


VOID VERPrecommitTransaction( PIB *ppib )
	{
	ERR		err = JET_errSuccess;
	BUCKET	*pbucket;
	LEVEL	level = ppib->level;
	RCE		*prce;

	SgSemRequest( semST );

	/*	if session defer freed node space in transaction, then
	/*	release deferred freed node space.
	/**/
	if ( level != 1 || !FPIBDeferFreeNodeSpace( ppib ) )
		return;
	
	pbucket = (BUCKET *)ppib->pbucket;
	while( pbucket != pbucketNil )
		{
		/*	get newest RCE in this bucket
		/**/
		prce = PrceNewestRCE( pbucket );

		forever
			{
			/*	if this RCE is from a previous transaction, then
			/*	terminate commit processing.  All RCEs from committed
			/*	transaction must already have been committed.
			/**/
			Assert( prce->level <= level );
			if ( prce->level != level )
				{
				/*	at this point err may be JET_errSuccess or left
				/*	over code from previous operation.
				/**/
				goto DoneReleaseNodeSpace;
				}

			/*	if replace has reserved space then free
			/*	reserved space
			/**/
			if ( prce->oper == operReplace )
				{
				INT	cbDelta = *((SHORT *)prce->rgbData + 1 );

				Assert( cbDelta >= 0 );
				if ( cbDelta > 0 )
					{
					FUCB	*pfucb = pfucbNil;

					err = ErrDIROpen( ppib, prce->pfcb, 0, &pfucb );
					if ( err >= 0 )
						{
						DIRGotoBookmark( prce->pfucb, prce->bm );
						err = ErrDIRGet( prce->pfucb );
						
						/* for now, loose space if failed to get the page
						/**/
						if ( err >= 0 )
							{
							SSIB *pssib = &prce->pfucb->ssib;
							
							/*  latch the page for log manager
							/*  to set LGDepend
							/**/
							BFPin( prce->pfucb->ssib.pbf );
							
							PMDirty( pssib );
							PMFreeFreeSpace( pssib, cbDelta );
						
							//	UNDONE:	in version 4.0, use version store
							//			to version page free space and avoid
							//			complexities of defer freed node space

							/* log free space
							/**/
							CallS( ErrLGFreeSpace( prce, cbDelta ) );
						
							BFUnpin( prce->pfucb->ssib.pbf );

							*((SHORT *)prce->rgbData + 1 ) = 0;
							}

						DIRClose( pfucb );
						}
					}
				}
	
			/*	break if at end of bucket.
			/**/
			do
				{
				if ( prce->ibUserLinkBackward == 0 )
					goto NextReleaseNodeSpaceBucket;
				prce = (RCE *) ( (BYTE *) pbucket + prce->ibUserLinkBackward );
				}
			while ( prce->oper == operNull );
			}

NextReleaseNodeSpaceBucket:
		/*	get next bucket
		/**/
		pbucket = pbucket->pbucketPrev;
		}

DoneReleaseNodeSpace:
	Assert( level == 1 );
	PIBResetDeferFreeNodeSpace( ppib );

	SgSemRelease( semST );
	}


VOID VERCommitTransaction( PIB *ppib )
	{
	BUCKET	*pbucket;
	LEVEL	level = ppib->level;
	RCE		*prce;
	TRX		trxCommit;

	/*	must be in a transaction in order to commit
	/**/
	Assert( level > 0 );

	SgSemRequest( semST );

	/*	timestamp RCEs with commit time.  Preincrement trxNewest so
	/*	that all transaction timestamps and commit timestamps are
	/*	unique.  Commit MUST be done in MUTEX.
	/**/
	trxCommit = ++trxNewest;

	pbucket = (BUCKET *)ppib->pbucket;
	while( pbucket != pbucketNil )
		{
#ifdef UNLIKELY_RECLAIM
NextBucket:
#endif
		/*	get newest RCE in this bucket.  Commit RCEs in
		/*	reverse chronological order.
		/**/
		prce = PrceNewestRCE( pbucket );

		/*	handle commit to intermediate transaction level and
		/*	commit to transaction level 0 differently.
		/**/
		if ( level > 1 )
			{
			forever
				{
				/*	if this RCE is from a previous transaction, then
				/*	terminate commit processing.  All RCEs from committed
				/*	transaction must already have been committed.
				/**/
				Assert( prce->level <= level );
				if ( prce->level != level )
					{
					goto Done;
					}

				/*	merge replace RCEs with previous level RCEs if exist
				/**/
				if ( prce->oper == operReplace )
					{
					if ( prce->prcePrev != prceNil &&
						prce->prcePrev->oper == operReplace &&
						prce->prcePrev->level == prce->level - 1 )
						{
						Assert( prce->prcePrev->level > 0 );

						/*	progate maximum to previous RCE
						/**/
						*(SHORT *)prce->prcePrev->rgbData = max(
							*(SHORT *)prce->prcePrev->rgbData,
							*(SHORT *)prce->rgbData );

						/*	merge reserved node space
						/**/
						*( (SHORT *)prce->prcePrev->rgbData + 1) =
							*( (SHORT *)prce->prcePrev->rgbData + 1) +
							*( (SHORT *)prce->rgbData + 1);

						VERDeleteRce( prce );
						prce->oper = operNull;
						}
					}
				else if ( prce->oper == operDelta &&
					prce->prcePrev != prceNil &&
					prce->prcePrev->oper == operDelta &&
					prce->prcePrev->level == prce->level - 1 &&
					prce->prcePrev->pfucb->ppib == prce->pfucb->ppib )
					{
					/*	merge delta with previous delta
					/**/
					Assert( prce->prcePrev->level > 0 );
					Assert( prce->cbData == sizeof(LONG) );
					Assert( prce->pfucb->ppib == prce->prcePrev->pfucb->ppib );
					VERAdjustDelta( prce->prcePrev, *((LONG *)prce->rgbData) );
					VERDeleteRce( prce );
					prce->oper = operNull;
					}

				Assert( prce->level > 1 );
				prce->level--;

#if 0
				//	UNDONE: should we try to reclaim space
				//			at the new end of the bucket.
				/*	at this point RCE is not needed and has oper == operNull.
				/*	If RCE is newest in bucket, the free RCE space.
				/**/
				if ( prce->oper == operNull && prce == PrceNewestRCE( pbucket ) )
					{
					if ( prce->ibUserLinkBackward == 0 )
						{
						pbucket = pbucket->pbucketPrev;
						BUFreeNewestBucket( ppib );
						goto NextBucket;
						}
					else
						{
						pbucket->ibNewestRCE = prce->ibUserLinkBackward;
						}
					}
#endif

				/*	break if at end of bucket.
				/**/
				do
					{
					if ( prce->ibUserLinkBackward == 0 )
						goto DoneGTOne;
					prce = (RCE *) ( (BYTE *) pbucket + prce->ibUserLinkBackward );
					} while ( prce->oper == operNull );
				}
DoneGTOne:
				NULL;                                           // NOP to prevent syntax error
			}
		else
			{
			forever
				{
				/*	if this RCE is from a previous transaction, then
				/*	terminate commit processing.  All RCEs from committed
				/*	transaction must already have been committed.
				/**/
				Assert( prce->level <= level );
				if ( prce->level != level )
					{
					goto Done;
					}

				/*	if version for DDL operation then reset deny DDL
				/*	and perform special handling
				/**/
				if ( FOperDDL( prce->oper ) )
					{
					Assert( prce->oper == operCreateTable ||
						prce->oper == operDeleteTable ||
						prce->oper == operRenameTable ||
						prce->oper == operAddColumn ||
						prce->oper == operDeleteColumn ||
						prce->oper == operRenameColumn ||
						prce->oper == operCreateIndex ||
						prce->oper == operDeleteIndex ||
						prce->oper == operRenameIndex );

					if ( prce->oper == operAddColumn ||
						prce->oper == operDeleteColumn )
						{
						/*	release deferred destructed FDB
						/**/
						Assert( prce->cbData == sizeof(FDB *) );
						FDBDestruct( *(FDB **)prce->rgbData );
						prce->oper = operNull;
						}
					else if ( prce->oper == operCreateIndex )
						{
						prce->oper = operNull;
						}
					else if ( prce->oper == operDeleteIndex )
						{
						/*	unlink index FCB from index list
						/**/
						FCBUnlinkIndex( prce->pfcb, (*(FCB **)prce->rgbData) );

						/*	update all index mask
						/**/
						FILESetAllIndexMask( prce->pfcb );
						}

					/*	all DDL operations set deny DDL bit in
					/*	FCB and this must be decremented during
					/*	commit transaction to level 0.
					/**/
					/*	operation should not be rename table since
					/*	flag of version and set deny DDL have not
					/*	been added for rename table.
					/**/
					Assert( prce->oper != operRenameTable );
					FCBResetDenyDDL( prce->pfucb->u.pfcb );
					}
				else
					{
					Assert( prce->oper != operCreateTable &&
						prce->oper != operDeleteTable &&
						prce->oper != operRenameTable &&
						prce->oper != operAddColumn &&
						prce->oper != operDeleteColumn &&
						prce->oper != operRenameColumn &&
						prce->oper != operCreateIndex &&
						prce->oper != operDeleteIndex &&
						prce->oper != operRenameIndex );

					/*	RCEs for flag delete/delete item/insert item
					/*	must be retained even if there are previous RCEs
					/*	at the same transaction level.
					/**/
					if ( prce->oper == operDelta )
						{
						/*	discard uneeded increment and decrement RCEs
						/**/
						VERDeleteRce( prce );
						prce->oper = operNull;
						}
					else if ( prce->oper == operReplace &&
						prce->prcePrev != prceNil &&
						prce->prcePrev->level == prce->level )
						{
						/*	discard uneeded increment and decrement RCEs.
						/**/
						VERDeleteRce( prce );
						prce->oper = operNull;
						}
					}

				/*	set trx of committed RCE for proper access.
				/**/
				Assert( level == 1 );
				Assert( prce->level == 1 );
				prce->level = 0;
				if ( prce->trxPrev == trxMax )
					prce->trxPrev = trxMin;
				Assert( prce->trxCommitted == trxMax );
				prce->trxCommitted = trxCommit;

				/*	break if at end of bucket.
				/**/
				do
					{
					if ( prce->ibUserLinkBackward == 0 )
						goto DoneEQZero;
					prce = (RCE *) ( (BYTE *) pbucket + prce->ibUserLinkBackward );
					} while ( prce->oper == operNull );
				}
DoneEQZero:
				NULL;                                           // NOP to prevent syntax error
			}

		/*	get next bucket
		/**/
		pbucket = pbucket->pbucketPrev;
		}

Done:
	/*	adjust session transaction level and system oldest transaction.
	/**/
	if ( ppib->level == 1 )
		{
		if ( ppib->trx == trxOldest )
			{
			UpdateTrxOldest( ppib );
			}

		/* set the session as having no transaction
		/**/
		ppib->trx = trxMax;
		}

	Assert( ppib->level > 0 );
	--ppib->level;

#ifndef ASYNC_VER_CLEANUP
	/*	reset PIB flags if rollback to transaction level 0.
	/**/
	if ( ppib->level == 0 )
		{
		(VOID)ErrRCECleanPIB( ppib, 0 );
		}
#endif

	/*	trxNewest should not have changed during commmit.
	/**/
	Assert( trxCommit == trxNewest );
	SgSemRelease( semST );
	return;
	}


/*local====================================================
This routine purges all FUCBs on given FCB as FUCB
given.
=========================================================*/
LOCAL VOID FUCBPurgeIndex( PIB *ppib, FCB *pfcb )
	{
	FUCB	*pfucbT;
	FUCB	*pfucbNext;

	for ( pfucbT = ppib->pfucb; pfucbT != pfucbNil; pfucbT = pfucbNext )
		{
		pfucbNext = pfucbT->pfucbNext;
		/*	if cursor opened on same table, then close cursor
		/**/
		if ( pfucbT->u.pfcb == pfcb )
			{
			/*	no other session could be on index being rolled back.
			/**/
			Assert( pfucbT->ppib == ppib );
			FCBUnlink( pfucbT );
			FUCBClose( pfucbT );
			}
		}
	}


/*	Purges all FUCBs on given FCB as FUCB given.
/**/
LOCAL VOID FUCBPurgeTable( PIB *ppib, FCB *pfcb )
	{
	FCB		*pfcbT;

	for ( pfcbT = pfcb; pfcbT != pfcbNil; pfcbT = pfcbT->pfcbNextIndex )
		{
		if ( pfcbT->wRefCnt > 0 )
			{
			FUCBPurgeIndex( ppib, pfcbT );
			}
		}
	}


LOCAL ERR ErrVERUndoReplace( RCE *prce )
	{
	ERR		err = JET_errSuccess;
	LINE  	line;
	BOOL  	fNonClustered = FFUCBNonClustered( prce->pfucb );
	BOOL  	fRedoUndo = prce->bmTarget != sridNull;
	BOOL	fPIBLogDisabledSave;
	PIB		*ppib;

	Assert( prce->oper == operReplace );
	
	/*	set to clustered index cursor.
	/**/
	FUCBResetNonClustered( prce->pfucb );

	line.pb = prce->rgbData + cbReplaceRCEOverhead;
	line.cb = prce->cbData - cbReplaceRCEOverhead;
	
	DIRGotoBookmark( prce->pfucb, fRedoUndo ? prce->bmTarget : prce->bm );
	err = ErrDIRGet( prce->pfucb );
	Assert( err != JET_errRecordDeleted );

	CallJ( err, HandleError2 );

	/*  latch the page for log manager to set LGDepend
	/**/
	BFPin( prce->pfucb->ssib.pbf );
	
	/*	replace should not fail since splits are avoided at undo
	/*	time via deferred page space release.  This refers to space
	/*	within a page and not pages freed when indexes and tables
	/*	are deleted.
	/**/
	VERResetCbAdjust( prce->pfucb, prce, fTrue /* before replace */ );

	ppib = prce->pfucb->ppib;
	fPIBLogDisabledSave = ppib->fLogDisabled;
	ppib->fLogDisabled = fTrue;
	CallS( ErrDIRReplace( prce->pfucb, &line, fDIRNoVersion ) );
	ppib->fLogDisabled = fPIBLogDisabledSave;
	
	VERResetCbAdjust( prce->pfucb, prce, fFalse /* not before replace */ );
	AssertBFDirty( prce->pfucb->ssib.pbf );

	if ( fRedoUndo )
		{
		BF *pbf = prce->pfucb->ssib.pbf;
		
		Assert( prce->ulDBTime != ulDBTimeNull );
		BFSetDirtyBit(pbf);
		pbf->ppage->pghdr.ulDBTime = prce->ulDBTime;
		}
	else
		{
		Call( ErrLGUndo( prce ) );
		}

HandleError:
	BFUnpin( prce->pfucb->ssib.pbf );
	
HandleError2:
	if ( fNonClustered )
		FUCBSetNonClustered( prce->pfucb );
	
#undef BUG_FIX
#ifdef BUG_FIX
	/*	reset cursor currency
	/**/
	Assert( prce->pfucb->pcsr->pcsrPath == pcsrNil );
	DIRBeforeFirst( prce->pfucb );
#endif

	return err;
	}


/*	set delete bit in node header and let bookmark clean up
/*	remove the node later.
/**/
LOCAL ERR ErrVERUndoInsert( RCE *prce )
	{
	ERR		err;
	BOOL	fNonClustered = FFUCBNonClustered( prce->pfucb );
	BOOL	fRedoUndo = prce->bmTarget != sridNull;

	Assert( prce->oper == operInsert );

	/*	set to clustered index cursor
	/**/
	FUCBResetNonClustered( prce->pfucb );

	DIRGotoBookmark( prce->pfucb, fRedoUndo ? prce->bmTarget : prce->bm );

	err = ErrDIRGet( prce->pfucb );
	if ( err < 0 )
		{
		if ( err != JET_errRecordDeleted )
			goto HandleError2;
		}
	Assert( err == JET_errRecordDeleted || err == JET_errSuccess );
	
	/*  latch the page for log manager to set LGDepend
	/**/
	BFPin( prce->pfucb->ssib.pbf );
	
	PMDirty( &prce->pfucb->ssib );
	NDSetDeleted( *prce->pfucb->ssib.line.pb );

	if ( fRedoUndo )
		{
		BF *pbf = prce->pfucb->ssib.pbf;
		
		Assert( prce->ulDBTime != ulDBTimeNull );
		BFSetDirtyBit(pbf);
		pbf->ppage->pghdr.ulDBTime = prce->ulDBTime;
		}
	else
		{
		Call( ErrLGUndo( prce ) );
		}

	err = JET_errSuccess;
	
HandleError:
	BFUnpin( prce->pfucb->ssib.pbf );
	
HandleError2:
	if ( fNonClustered )
		FUCBSetNonClustered( prce->pfucb );
	
#ifdef BUG_FIX
	/*	reset cursor currency
	/**/
	Assert( prce->pfucb->pcsr->pcsrPath == pcsrNil );
	DIRBeforeFirst( prce->pfucb );
#endif

	return err;
	}


/*	reset delete bit
/**/
LOCAL ERR ErrVERUndoFlagDelete(RCE *prce)
	{
	ERR     err;
	BOOL    fNonClustered = FFUCBNonClustered( prce->pfucb );
	BOOL    fRedoUndo = prce->bmTarget != sridNull;

	Assert( prce->oper == operFlagDelete );

	/*	set to clustered index cursor
	/**/
	FUCBResetNonClustered( prce->pfucb );

	DIRGotoBookmark( prce->pfucb, fRedoUndo ? prce->bmTarget : prce->bm );

	err = ErrDIRGet( prce->pfucb );
	if ( err < 0 )
		{
		if ( err != JET_errRecordDeleted )
			goto HandleError2;
		}
	Assert( err == JET_errRecordDeleted || err == JET_errSuccess );
	
	/*  latch the page for log manager to set LGDepend
	/**/
	BFPin( prce->pfucb->ssib.pbf );
	
	PMDirty( &prce->pfucb->ssib );
	NDResetNodeDeleted( prce->pfucb );
	Assert( prce->pfucb->ssib.pbf->fDirty );

	if ( fRedoUndo )
		{
		BF *pbf = prce->pfucb->ssib.pbf;
		
		Assert( prce->ulDBTime != ulDBTimeNull );
		BFSetDirtyBit(pbf);
		pbf->ppage->pghdr.ulDBTime = prce->ulDBTime;
		}
	else
		{
		Call( ErrLGUndo( prce ) );
		}

	err = JET_errSuccess;
	
HandleError:
	BFUnpin( prce->pfucb->ssib.pbf );
	
HandleError2:
	if ( fNonClustered )
		FUCBSetNonClustered( prce->pfucb );
	
#ifdef BUG_FIX
	/*	reset cursor currency
	/**/
	Assert( prce->pfucb->pcsr->pcsrPath == pcsrNil );
	DIRBeforeFirst( prce->pfucb );
#endif

	return err;
	}


LOCAL ERR ErrVERUndoInsertItem( RCE *prce )
	{
	ERR     err;
	BOOL    fClustered = !FFUCBNonClustered( prce->pfucb );
	BOOL    fRedoUndo = prce->bmTarget != sridNull;

	Assert( prce->oper == operInsertItem ||
		prce->oper == operFlagInsertItem );

	/*	set to non-clustered index cursor
	/**/
	FUCBSetNonClustered( prce->pfucb );

	/*	set currency to bookmark of item list and item.
	/**/
	DIRGotoBookmarkItem( prce->pfucb,
		fRedoUndo ? prce->bmTarget : prce->bm,
		*(SRID *)prce->rgbData );
	err = ErrDIRGet( prce->pfucb );
	if ( err < 0 )
		{
		if ( err != JET_errRecordDeleted )
			goto HandleError2;
		}
	/* since we do not log item, so the pfucb->pcsr->item is bogus for redo
	/**/
	Assert( fRecovering ||
		BmNDOfItem(((UNALIGNED SRID *)prce->pfucb->lineData.pb)[prce->pfucb->pcsr->isrid]) ==
		*(SRID *)prce->rgbData );

	/*  latch the page for log manager to set LGDepend
	/**/
	BFPin( prce->pfucb->ssib.pbf );

	PMDirty( &prce->pfucb->ssib );
	NDSetItemDelete( prce->pfucb );
	if ( prce->prcePrev == prceNil )
		NDResetItemVersion( prce->pfucb );
	Assert( prce->pfucb->ssib.pbf->fDirty );

	if ( fRedoUndo )
		{
		BF *pbf = prce->pfucb->ssib.pbf;
		
		Assert( prce->ulDBTime != ulDBTimeNull );
		BFSetDirtyBit( pbf );
		pbf->ppage->pghdr.ulDBTime = prce->ulDBTime;
		}
	else
		{
		Call( ErrLGUndo( prce ) );
		}

	err = JET_errSuccess;
	
HandleError:
	BFUnpin( prce->pfucb->ssib.pbf );
	
HandleError2:
	if ( fClustered )
		FUCBResetNonClustered( prce->pfucb );
	
#ifdef BUG_FIX
	/*	reset cursor currency
	/**/
	Assert( prce->pfucb->pcsr->pcsrPath == pcsrNil );
	DIRBeforeFirst( prce->pfucb );
#endif

	return err;
	}


LOCAL ERR ErrVERUndoFlagDeleteItem( RCE *prce )
	{
	ERR     err;
	BOOL    fClustered = !FFUCBNonClustered( prce->pfucb );
	BOOL    fRedoUndo = prce->bmTarget != sridNull;

	Assert( prce->oper == operFlagDeleteItem );

	/*	set to non-clustered index cursor
	/**/
	FUCBSetNonClustered( prce->pfucb );

	/*	set currency to bookmark of item list and item
	/**/
	DIRGotoBookmarkItem( prce->pfucb,
		fRedoUndo ? prce->bmTarget : prce->bm,
		*(SRID *)prce->rgbData );
	err = ErrDIRGet( prce->pfucb );
	if ( err < 0 )
		{
		if ( err != JET_errRecordDeleted )
			goto HandleError2;
		}

	/* since we do not log item, so the pfucb->pcsr->item is bogus for redo
	/**/
	Assert( fRecovering ||
		BmNDOfItem(((UNALIGNED SRID *)prce->pfucb->lineData.pb)[prce->pfucb->pcsr->isrid]) ==
		*(SRID *)prce->rgbData );

	/*  latch the page for log manager to set LGDepend
	/**/
	BFPin( prce->pfucb->ssib.pbf );

	PMDirty( &prce->pfucb->ssib );
	NDResetItemDelete( prce->pfucb );
	if ( prce->prcePrev == prceNil )
		NDResetItemVersion( prce->pfucb );
	Assert( prce->pfucb->ssib.pbf->fDirty );

	if ( fRedoUndo )
		{
		BF *pbf = prce->pfucb->ssib.pbf;
		
		Assert( prce->ulDBTime != ulDBTimeNull );
		BFSetDirtyBit( pbf );
		pbf->ppage->pghdr.ulDBTime = prce->ulDBTime;
		}
	else
		{
		Call( ErrLGUndo( prce ) );
		}

	err = JET_errSuccess;
	
HandleError:
	BFUnpin( prce->pfucb->ssib.pbf );
	
HandleError2:
	if ( fClustered )
		FUCBResetNonClustered( prce->pfucb );
	
#ifdef BUG_FIX
	/*	reset cursor currency
	/**/
	Assert( prce->pfucb->pcsr->pcsrPath == pcsrNil );
	DIRBeforeFirst( prce->pfucb );
#endif

	return err;
	}


/*	undo delta change
/**/
LOCAL ERR ErrVERUndoDelta( RCE *prce )
	{
	ERR		err;
	BOOL  	fNonClustered = FFUCBNonClustered( prce->pfucb );
	BOOL  	fRedoUndo = prce->bmTarget != sridNull;
	BOOL  	fPIBLogDisabledSave;
	PIB	  	*ppib;

	Assert( prce->oper == operDelta );

	/*	set to clustered index cursor
	/**/
	FUCBResetNonClustered( prce->pfucb );

	DIRGotoBookmark( prce->pfucb, fRedoUndo ? prce->bmTarget : prce->bm );

	err = ErrDIRGet( prce->pfucb );
	if ( err < 0 )
		{
		if ( err != JET_errRecordDeleted )
			goto HandleError2;
		}
		
	/*  latch the page for log manager to set LGDepend
	/**/
	BFPin( prce->pfucb->ssib.pbf );

	ppib = prce->pfucb->ppib;
	fPIBLogDisabledSave = ppib->fLogDisabled;
	ppib->fLogDisabled = fTrue;
	while( ( err = ErrNDDelta( prce->pfucb, -*((INT *)prce->rgbData), fDIRNoVersion ) ) == errDIRNotSynchronous );
	ppib->fLogDisabled = fPIBLogDisabledSave;
	Call( err );
	
	AssertBFDirty( prce->pfucb->ssib.pbf );

	if ( fRedoUndo )
		{
		BF *pbf = prce->pfucb->ssib.pbf;
		
		Assert( prce->ulDBTime != ulDBTimeNull );
		BFSetDirtyBit( pbf );
		pbf->ppage->pghdr.ulDBTime = prce->ulDBTime;
		}
	else
		{
		Call( ErrLGUndo( prce ) );
		}

	err = JET_errSuccess;
	
HandleError:
	BFUnpin( prce->pfucb->ssib.pbf );
	
HandleError2:
	if ( fNonClustered )
		FUCBSetNonClustered( prce->pfucb );
	
#ifdef BUG_FIX
	/*	reset cursor currency
	/**/
	Assert( prce->pfucb->pcsr->pcsrPath == pcsrNil );
	DIRBeforeFirst( prce->pfucb );
#endif

	return err;
	}


VOID VERUndoCreateTable( RCE *prce )
	{
	FUCB  	*pfucb = prce->pfucb;
	PIB		*ppib = pfucb->ppib;
	FUCB  	*pfucbT;
	PGNO  	pgno = pfucb->u.pfcb->pgnoFDP;
	DBID  	dbid = pfucb->dbid;
	FCB		*pfcb = pfucb->u.pfcb;

	Assert( prce->oper == operCreateTable );

	Assert( !FFUCBNonClustered( pfucb ) );

	/*	close all cursors on this table
	/**/
	pfucb = pfcb->pfucb;
	for ( pfucb = pfcb->pfucb; pfucb != pfucbNil; pfucb = pfucbT )
		{
		pfucbT = pfucb->pfucbNextInstance;

		/*	if defer closed then continue
		/**/
		if ( FFUCBDeferClosed( pfucb ) )
			continue;

		if( pfucb->fVtid )
			{
			CallS( ErrDispCloseTable( (JET_SESID)pfucb->ppib, TableidOfVtid( pfucb ) ) );
			}
		else
			{
			CallS( ErrFILECloseTable( pfucb->ppib, pfucb ) );
			}
		pfucb = pfucbT;
		}

	FCBResetDenyDDL( prce->pfucb->u.pfcb );

	/*	cursors may have been deferred closed so force close them and
	/*	purge table FCBs.
	/**/
	FUCBPurgeTable( ppib, pfcb );
	FCBPurgeTable( dbid, pgno );
	
	/*	cursor is defunct
	/**/

	return;
	}


VOID VERUndoAddColumn( RCE *prce )
	{
	Assert( prce->oper == operAddColumn );

	Assert( FFCBDenyDDLByUs( prce->pfucb->u.pfcb, prce->pfucb->ppib ) );
	Assert( prce->cbData == sizeof(FDB *) );
	if ( prce->pfucb->u.pfcb->pfdb != *(FDB **)prce->rgbData )
		{
		FDBDestruct( (FDB *)prce->pfucb->u.pfcb->pfdb );
		FDBSet( prce->pfucb->u.pfcb, *(FDB **)prce->rgbData );
		}
	FCBResetDenyDDL( prce->pfucb->u.pfcb );
	
#ifdef BUG_FIX
	/*	assert reset cursor currency
	/**/
	Assert( prce->pfucb->pcsr->pcsrPath == pcsrNil );
	Assert( prce->pfucb->pcsr->csrstat == csrstatBeforeFirst );
#endif

	return;
	}


VOID VERUndoDeleteColumn( RCE *prce )
	{
	Assert( prce->oper == operDeleteColumn );

	Assert( FFCBDenyDDLByUs( prce->pfucb->u.pfcb, prce->pfucb->ppib ) );
	Assert( prce->cbData == sizeof(FDB *) );
	if ( prce->pfucb->u.pfcb->pfdb != *(FDB **)prce->rgbData )
		{
		FDBDestruct( (FDB *)prce->pfucb->u.pfcb->pfdb );
		FDBSet( prce->pfucb->u.pfcb, *(FDB **)prce->rgbData );
		}
	FCBResetDenyDDL( prce->pfucb->u.pfcb );

#ifdef BUG_FIX
	/*	assert reset cursor currency
	/**/
	Assert( prce->pfucb->pcsr->pcsrPath == pcsrNil );
	Assert( prce->pfucb->pcsr->csrstat == csrstatBeforeFirst );
#endif

	return;
	}


VOID VERUndoDeleteTable( RCE *prce )
	{
	Assert( prce->oper == operDeleteTable );

	FCBResetDenyDDL( prce->pfucb->u.pfcb );
	FCBResetDeleteTable( prce->dbid, *(PGNO *)prce->rgbData );
	
#ifdef BUG_FIX
	/*	assert reset cursor currency
	/**/
	Assert( prce->pfucb->pcsr->pcsrPath == pcsrNil );
	Assert( prce->pfucb->pcsr->csrstat == csrstatBeforeFirst );
#endif

	return;
	}


VOID VERUndoCreateIndex( RCE *prce )
	{
	/*	pfcb of non-clustered index FCB or pfcbNil for clustered
	/*	index creation
	/**/
	FCB	*pfcb = *(FCB **)prce->rgbData;

	Assert( prce->oper == operCreateIndex );
	Assert( FFCBDenyDDLByUs( prce->pfucb->u.pfcb, prce->pfucb->ppib ) );
	Assert( prce->cbData == sizeof(FDB *) );

	/*	if non-clustered index then close all cursors on index
	/*	and purge index FCB, else free IDB for clustered index.
	/**/
	if ( pfcb != pfcbNil )
		{
		/*	close all cursors on defunct index
		/**/
		while ( pfcb->pfucb )
			{
			FUCB	*pfucbT = pfcb->pfucb;

			FCBUnlink( pfucbT );
			FUCBClose( pfucbT );
			}

		if ( FFCBUnlinkIndexIfFound( prce->pfucb->u.pfcb, pfcb ) )
			{
			if ( pfcb->pidb != NULL )
				RECFreeIDB( pfcb->pidb );
			Assert( pfcb->cVersion == 0 );
			MEMReleasePfcb( pfcb );
			}
		}
	else
		{
		if ( prce->pfucb->u.pfcb->pidb != NULL )
			{
			RECFreeIDB( prce->pfucb->u.pfcb->pidb );
			prce->pfucb->u.pfcb->pidb = NULL;
			}
		}

	FCBResetDenyDDL( prce->pfucb->u.pfcb );
	
#ifdef BUG_FIX
	/*	assert reset cursor currency
	/**/
	Assert( prce->pfucb->pcsr->pcsrPath == pcsrNil );
	Assert( prce->pfucb->pcsr->csrstat == csrstatBeforeFirst );
#endif

	return;
	}


VOID VERUndoDeleteIndex( RCE *prce )
	{
	Assert( prce->oper == operDeleteIndex );

	Assert( FFCBDenyDDLByUs( prce->pfucb->u.pfcb, prce->pfucb->ppib ) );
	Assert( prce->cbData == sizeof(FDB *) );

	FCBResetDeleteIndex( *(FCB **)prce->rgbData );
	FCBResetDenyDDL( prce->pfucb->u.pfcb );
	
#ifdef BUG_FIX
	/*	assert reset cursor currency
	/**/
	Assert( prce->pfucb->pcsr->pcsrPath == pcsrNil );
	Assert( prce->pfucb->pcsr->csrstat == csrstatBeforeFirst );
#endif

	return;
	}


VOID VERUndoRenameColumn( RCE *prce )
	{
	CHAR	*szNameNew;
	CHAR	*szName;

	Assert( prce->oper == operRenameColumn );

	szName = (CHAR *)((VERRENAME *)prce->rgbData)->szName;
	szNameNew = (CHAR *)((VERRENAME *)prce->rgbData)->szNameNew;
	strcpy( PfieldFCBFromColumnName( prce->pfucb->u.pfcb, szNameNew )->szFieldName, szName );

	Assert( FFCBDenyDDLByUs( prce->pfucb->u.pfcb, prce->pfucb->ppib ) );
	FCBResetDenyDDL( prce->pfucb->u.pfcb );
	
#ifdef BUG_FIX
	/*	assert reset cursor currency
	/**/
	Assert( prce->pfucb->pcsr->pcsrPath == pcsrNil );
	Assert( prce->pfucb->pcsr->csrstat == csrstatBeforeFirst );
#endif

	return;
	}


VOID VERUndoRenameIndex( RCE *prce )
	{
	CHAR	*szNameNew;
	CHAR	*szName;
	FCB		*pfcb;

	Assert( prce->oper == operRenameIndex );

	szName = (CHAR *)((VERRENAME *)prce->rgbData)->szName;
	szNameNew = (CHAR *)((VERRENAME *)prce->rgbData)->szNameNew;
	pfcb = PfcbFCBFromIndexName( prce->pfucb->u.pfcb, szNameNew );
	Assert( pfcb != NULL );
	strcpy( pfcb->pidb->szName, szName );

	Assert( FFCBDenyDDLByUs( prce->pfucb->u.pfcb, prce->pfucb->ppib ) );
	FCBResetDenyDDL( prce->pfucb->u.pfcb );
	
#ifdef BUG_FIX
	/*	assert reset cursor currency
	/**/
	Assert( prce->pfucb->pcsr->pcsrPath == pcsrNil );
	Assert( prce->pfucb->pcsr->csrstat == csrstatBeforeFirst );
#endif

	return;
	}


ERR ErrVERRollback( PIB *ppib )
	{
	ERR		err = JET_errSuccess;
	BUCKET	*pbucket = (BUCKET *)ppib->pbucket;
	LEVEL  	level = ppib->level;
	RCE		*prce;

	/*	must be in a transaction in order to rollback
	/**/
	Assert( level > 0 );

	while( pbucket != pbucketNil )
		{
		prce = PrceNewestRCE( pbucket );

		forever
			{
			Assert( prce->level <= level );
			if ( prce->level != level )
				{
				/*	polymorph warnings to JET_errSuccess.
				/**/
				err = JET_errSuccess;
				pbucket->ibNewestRCE = (USHORT)IbOfPrce( prce, pbucket );
				goto Done;
				}

			Assert( err == JET_errSuccess );

			/*	after we undo an operation on a page, let us
			/*	remember it in log file. Use prce to pass
			/*	prce->pfucb, prce->bm, and prce->rgdata for item if it
			/*	is item operations.
			/**/
			switch( prce->oper )
				{
				case operReplace:
					{
					err = ErrVERUndoReplace( prce );
					break;
					}
				case operInsert:
					{
					err = ErrVERUndoInsert( prce );
					break;
					}
				case operFlagDelete:
					{
					err = ErrVERUndoFlagDelete( prce );
					break;
					}
				case operNull:
					{
					break;
					}
				case operExpungeLink:
				case operExpungeBackLink:
				case operWriteLock:
					{
					break;
					}
				case operDeferFreeExt:
					{
					break;
					}
				case operAllocExt:
					{
					Assert( prce->cbData == sizeof(VEREXT) );
					VERFreeExt( prce->dbid,
						((VEREXT *)prce->rgbData)->pgnoFDP,
						((VEREXT *)prce->rgbData)->pgnoFirst,
						((VEREXT *)prce->rgbData)->cpgSize );
					break;
					}
				case operInsertItem:
				case operFlagInsertItem:
					{
					err = ErrVERUndoInsertItem( prce );
					break;
					}
				case operFlagDeleteItem:
					{
					err = ErrVERUndoFlagDeleteItem( prce );
					break;
					}
				case operDelta:
					{
					err = ErrVERUndoDelta( prce );
					break;
					}
				case operCreateTable:
					{
					/*	decrement version count since about to purge
					/**/
					if ( prce->pfcb != pfcbNil )
						{
						Assert( cVersion-- > 0 );
						FCBVersionDecrement( prce->pfcb );
						prce->pfcb = pfcbNil;
						}

					VERUndoCreateTable( prce );
					break;
					}
				case operDeleteTable:
					{
					VERUndoDeleteTable( prce );
					break;
					}
				case operRenameTable:
					{
					break;
					}
				case operAddColumn:
					{
					VERUndoAddColumn( prce );
					break;
					}
				case operDeleteColumn:
					{
					VERUndoDeleteColumn( prce );
					break;
					}
				case operRenameColumn:
					{
					VERUndoRenameColumn( prce );
					break;
					}
				case operCreateIndex:
					{
					VERUndoCreateIndex( prce );
					break;
					}
				case operDeleteIndex:
					{
					VERUndoDeleteIndex( prce );
					break;
					}
				default:
					{
					Assert( prce->oper == operRenameIndex );
					VERUndoRenameIndex( prce );
					break;
					}
				}

			/*	if rollback fail due to diskfull, then we simply ignore
			/*	the error and ask the system administrator to shut down
			/*	the system and recover it.
			/**/
			if ( err < 0 )
				{
				if ( err == JET_errLogWriteFail ||
					err == JET_errDiskFull ||
					err == JET_errDiskIO )
					{
					err = JET_errSuccess;
					}
				else
					{
					goto HandleError;
					}
				}

			/*	finished processing version for FCB
			/**/
			if ( prce->pfcb != pfcbNil && err >= 0 )
				{
				Assert( cVersion-- > 0 );
				FCBVersionDecrement( prce->pfcb );
				prce->pfcb = pfcbNil;
				}

			Assert( err == JET_errSuccess );
			
			if ( prce->oper != operNull &&
				prce->oper != operDeferFreeExt &&
				prce->oper != operAllocExt )
				{
				if ( FOperDDL( prce->oper ) )
					{
					/*	although RCE will be deallocated, set
					/*	oper to operNull in case error in rollback
					/*	causes premature termination and does not
					/*	set ibNewestRce above this RCE.
					/**/
					prce->oper = operNull;
					}
				else
					{
					VERDeleteRce( prce );

					/*	although RCE will be deallocated, set
					/*	oper to operNull in case error in rollback
					/*	causes premature termination and does not
					/*	set ibNewestRce above this RCE.
					/**/
					prce->oper = operNull;

#if 0
					//	UNDONE:	enable reseting version flags.
					//			Should be good since node page already
					//			in memory and dirty.
					//	UNDONE:	item version flags
					/*	if rolling back to Xact level 0 and no older version exists,
					/*	reset fVersion in node to signal that no version exists
					/*	and decrement cVersion in page.
					/**/
					if ( level == 1 && FNoVersionExists( prce ) )
						{
						DIRGotoBookmark( prce->pfucb, prce->bm );
						err = ErrDIRGet( prce->pfucb );
						if ( err < 0 )
							{
							if ( err == JET_errRecordDeleted ||
								err == JET_errLogWriteFail ||
								err == JET_errDiskFull ||
								err == JET_errDiskIO )
								{
								err = JET_errSuccess;
								}
							else
								{
								goto HandleError;
								}
							}
						Assert( err == JET_errSuccess );
						NDResetNodeVersion( prce->pfucb );
#ifdef BUG_FIX
						/*	reset cursor currency
						/**/
						Assert( prce->pfucb->pcsr->pcsrPath == pcsrNil );
						DIRBeforeFirst( prce->pfucb );
#endif
						}
#endif
					}
				}

			/*	break if at end of bucket.  Skip operNull RCEs.
			/**/
			do
				{
				if ( prce->ibUserLinkBackward == 0 )
					goto DoneLoop;

				prce = (RCE *) ( (BYTE *) pbucket + prce->ibUserLinkBackward );

				/*	finished processing version for FCB
				/**/
				if ( prce->pfcb != pfcbNil )
					{
					Assert( cVersion-- > 0 );
					FCBVersionDecrement( prce->pfcb );
					prce->pfcb = pfcbNil;
					}
				}
			while ( prce->oper == operNull );
			}

DoneLoop:
		/*	get next bucket
		/**/
		BUFreeNewestBucket( ppib );
		pbucket = (BUCKET *)ppib->pbucket;
		}

Done:
	if ( err < 0 )
		{
		Assert( err == JET_errLogWriteFail ||
			err == JET_errDiskFull ||
			err == JET_errDiskIO );
		err = JET_errSuccess;
		}
	Assert( err == JET_errSuccess );

	/*	decrement session transaction level
	/**/
	if ( ppib->level == 1 )
		{
		SgSemRequest( semST );

		if ( ppib->trx == trxOldest )
			UpdateTrxOldest( ppib );

		/* set the session as having no transaction
		/**/
		ppib->trx = trxMax;

		SgSemRelease( semST );
		}

	Assert( ppib->level > 0 );
	ppib->level--;

HandleError:
	//	UNDONE:	remove assertion and handle errors by retry
	Assert( err == JET_errSuccess );

	/*	some errors can occur when out of resources necessary
	/*	for rollback.
	/**/
	Assert( err == JET_errSuccess || err < 0 );
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\compact\comp.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    compact.c

Abstract:

    This file contains the "compact" utility program to off line compact
    a jet database.

Author:

    Madan Appiah (madana) 22-Aug-1994

Revision History:

--*/

#include "basetsd.h"
#include <esent.h>
#include <comp.h>
#include "msgs.h"

#if DBG
#define DBGPrint(_x_)   PrintF _x_
#else
#define DBGPrint(_x_)
#endif // DBG

BOOL GlobalDynLoadJet = LoadJet600;
LPTSTR  GlobalDllName = NULL;

#define JETFUNC_TABLE_ITEM( _Func, _FuncI )    \
    {   (_Func), &(#_Func)[1], (_FuncI), NULL }


JETFUNC_TABLE  JetFuncTable[] = {
	JETFUNC_TABLE_ITEM( _JetAttachDatabase	,102	),
	JETFUNC_TABLE_ITEM( _JetBeginSession		,104	),
	JETFUNC_TABLE_ITEM( _JetCompact		,110	),
	JETFUNC_TABLE_ITEM( _JetDetachDatabase	,121	),
	JETFUNC_TABLE_ITEM( _JetEndSession		,124	),
	JETFUNC_TABLE_ITEM( _JetInit			,145	),
	JETFUNC_TABLE_ITEM( _JetSetSystemParameter	,165	),
	JETFUNC_TABLE_ITEM( _JetTerm			,167	),
//
//  These are Jet500 only apis.
	JETFUNC_TABLE_ITEM( _JetTerm2  		,0	),
//  Last Api
	JETFUNC_TABLE_ITEM( _JetLastFunc		,999	)
    };

//
// Local functions.
//
DWORD
LoadDatabaseDll();

DWORD PrintF(DWORD nMsgId, ...)
{
    va_list arglist;
    LPSTR   pBuffer = NULL;

    va_start(arglist, nMsgId);
    if (FormatMessageA(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
            NULL,
            nMsgId,
            0,
            (LPSTR)(&pBuffer),
            1,
            &arglist))
    {
        CharToOemA(pBuffer, pBuffer);
        printf("%s", pBuffer);
        LocalFree(pBuffer);
    }
    return GetLastError();
}

DWORD __cdecl
main(
    DWORD argc,
    LPSTR argv[]
    )
{
    JET_INSTANCE Instance;
    JET_ERR JetError;
    JET_ERR JetError1;
    JET_SESID SessionId;
    LPSTR DatabaseName;
    LPSTR CompactDBName;

    DWORD Time;
    BOOL TerminateJet = FALSE;
    BOOL DetachDatabase = FALSE;
    BOOL DetachCompactDatabase = FALSE;
    BOOL EndSession = FALSE;
    BOOL DeleteCompactFile = FALSE;

    OFSTRUCT OpenBuff;

    if ( (argc < 3) || (argc > 4) || !strcmp(argv[0],"-?") || !strcmp(argv[0],"/?") ) {
        PrintF(JPMSG_USAGE, argv[0]);
        return(1);
    }

    if ( !strcmp(argv[1],"-351db")  ) {
        GlobalDynLoadJet = LoadJet200;
        DatabaseName = argv[2];
        CompactDBName = argv[3];
    } else if ( !strcmp(argv[1],"-40db")  ) {
        GlobalDynLoadJet = LoadJet500;
        DatabaseName = argv[2];
        CompactDBName = argv[3];
    } else {
        GlobalDynLoadJet = LoadJet600;
        DatabaseName = argv[1];
        CompactDBName = argv[2];
    }

    if ( LoadDatabaseDll() != ERROR_SUCCESS ) {
        PrintF( JPMSG_NOTLOADED, GlobalDllName);
        return(1);
    }


    if ( GlobalDynLoadJet == LoadJet500 || GlobalDynLoadJet == LoadJet600) {
        JetError = JetSetSystemParameter(
                            0,
                            (JET_SESID)0,       //SesId - ignored
                            JET_paramBaseName,
                            0,
                            "j50" );

        if( JetError != JET_errSuccess ) {
            DBGPrint( (JPDBGMSG_SETSYSPARM_FAILED, JetError) );
            if( JetError < JET_errSuccess ) {
                PrintF( JPMSG_FAILED, argv[0], JetError ) ;
                goto Cleanup;
            }
        }

        JetError = JetSetSystemParameter(
                            0,
                            (JET_SESID)0,       //SesId - ignored
                            JET_paramLogFileSize,
                            1024,               // 1024kb - default is 5mb
                            NULL );

        if( JetError != JET_errSuccess ) {
            DBGPrint( (JPDBGMSG_SETSYSPARM_FAILED, JetError) );
            if( JetError < JET_errSuccess ) {
                PrintF( JPMSG_FAILED, argv[0], JetError ) ;
                goto Cleanup;
            }
        }
    }

    JetError = JetInit( &Instance );

    if( JetError != JET_errSuccess ) {
        DBGPrint( (JPDBGMSG_CALL_FAILED, JetError) );
        if( JetError < JET_errSuccess ) {
            PrintF( JPMSG_FAILED, argv[0], JetError ) ;
            goto Cleanup;
        }
    }

    TerminateJet = TRUE;
    JetError = JetBeginSession(
                    Instance,
                    &SessionId,
                    "admin",        // UserName,
                    "");            // Password

    if( JetError != JET_errSuccess ) {
        DBGPrint( (JPDBGMSG_BEGSESS_FAILED, JetError) );
        if( JetError < JET_errSuccess ) {
            goto Cleanup;
        }
    }

    EndSession = TRUE;
    JetError = JetAttachDatabase( SessionId, DatabaseName, 0 );

    if( JetError != JET_errSuccess ) {
        DBGPrint( (JPDBGMSG_ATTDB_FAILED, JetError) );
        if( JetError < JET_errSuccess ) {
            goto Cleanup;
        }
    }

    DetachDatabase =
        (JetError == JET_wrnDatabaseAttached) ? FALSE : TRUE;

    if( OpenFile( CompactDBName, &OpenBuff, OF_READ | OF_EXIST ) !=
                    HFILE_ERROR ) {
        PrintF( JPMSG_DBEXISTS, CompactDBName );
        JetError = ERROR_FILE_EXISTS;
        goto Cleanup;
    }

    Time = GetTickCount();

    if ( GlobalDynLoadJet == LoadJet200) {
        JetError = JetCompact(
                        SessionId,
                        DatabaseName,
                        NULL,       // connect sources, ignored
                        CompactDBName,
                        NULL,       // connect destination
                        NULL,       // call back function
                        0 );        // grbits.
    } else {
        JetError = JetCompact(
                        SessionId,
                        DatabaseName,
                        CompactDBName,
                        NULL,       // connect destination
                        NULL,       // call back function
                        0 );        // grbits.

    }

    if( JetError != JET_errSuccess ) {
        DBGPrint( (JPDBGMSG_COMPCT_FAILED, JetError) );
        if( JetError < JET_errSuccess ) {
            goto Cleanup;
        }
    }

    DetachCompactDatabase = TRUE;
    DeleteCompactFile = TRUE;
    Time = GetTickCount() - Time;

    PrintF(JPMSG_COMPACTED, DatabaseName, Time / 1000, Time % 1000 );

    JetError = JET_errSuccess;

Cleanup:

    //
    // detach temporary database
    //

    if( DetachDatabase ) {
        JetError1 = JetDetachDatabase(
                        SessionId,
                        DatabaseName
                        );

        if( JetError1 != JET_errSuccess ) {
            DBGPrint( (JPDBGMSG_DETDB_FAILED, JetError1) );
        }
    }

    //
    // detach temporary compact database
    //

    if( DetachCompactDatabase ) {
        JetError1 = JetDetachDatabase(
                        SessionId,
                        CompactDBName
                        );

        if( JetError1 != JET_errSuccess ) {
            DBGPrint( (JPDBGMSG_DETDB_FAILED, JetError1) );
        }
    }


    if( EndSession ) {
        JetError1 = JetEndSession( SessionId, 0 );

        if( JetError1 != JET_errSuccess ) {
            DBGPrint( (JPDBGMSG_ENDSESS_FAILED, JetError1) );
        }
    }

    if( EndSession ) {
        if ( GlobalDynLoadJet == LoadJet200) {
            JetError1 = JetTerm( Instance );
        } else {
            JetError1 = JetTerm2( Instance, JET_bitTermComplete );
        }
        if( JetError1 != JET_errSuccess ) {
            DBGPrint( (JPDBGMSG_TERM_FAILED, JetError1) );
        }

    }

    if( JetError != JET_errSuccess ) {

        PrintF( JPMSG_FAILED, argv[0], JetError ) ;

        //
        // delete temporary compact database
        //

        if( DeleteCompactFile ) {
            if( !DeleteFileA( CompactDBName ) ) {
                DBGPrint( (JPDBGMSG_DELFILE_FAILED, GetLastError()) );
            }
        }

        return( 1 );
    }

    //
    // rename compacted database to source name
    //

    PrintF( JPMSG_MOVING, CompactDBName, DatabaseName );
    if( !MoveFileExA(
            CompactDBName,
            DatabaseName,
            MOVEFILE_REPLACE_EXISTING ) ) {

        JetError = GetLastError();
        DBGPrint( (JPDBGMSG_MOVEFILE_FAILED, JetError) );
    }

    PrintF( JPMSG_COMPLETED, argv[0] );
    return( 0 );
}

DWORD
LoadDatabaseDll(
    )
/*++

Routine Description:

    This function maps loads the jet.dll or jet500.dll and populates the
    JetFunctionTable.

Arguments:


Return Value:

    Windows Error.

--*/
{
    HMODULE DllHandle;
    DWORD   Error;

    if ( LoadJet600 == GlobalDynLoadJet)
    {
      GlobalDllName = TEXT("esent.dll");
    }
    else if ( LoadJet500 == GlobalDynLoadJet)
    {
      GlobalDllName = TEXT("jet500.dll");
    }
    else
    {
      GlobalDllName = TEXT("jet.dll");
    }

    DBGPrint(( JPDBGMSG_LOADDB, GlobalDllName ));

    //
    // Load the DLL that contains the service.
    //

    DllHandle = LoadLibrary( GlobalDllName );
    if ( DllHandle == NULL )
    {
          Error = GetLastError();
          return(Error);
    }
    else
    {
           DWORD i;
           for (i=0; i < _JetLastFunc; i++)
           {
              //
              // If we are loading jet200 and this api doesnt exist in jet200
              // then skip it. e.g JetTerm2
              //
              if ( ( GlobalDynLoadJet == LoadJet200 ) && !JetFuncTable[i].FIndex ) {
                  continue;
              }

              if ((JetFuncTable[i].pFAdd = GetProcAddress(DllHandle,
                       ( GlobalDynLoadJet != LoadJet200 ) ? JetFuncTable[i].pFName : (LPCSTR)ULongToPtr(JetFuncTable[i].FIndex))) == NULL)
              {
                  Error = GetLastError();
                  DBGPrint(( JPDBGMSG_NOFUNC, JetFuncTable[i].pFName, Error ));
                  return ( Error );
              }
              else
              {
                  DBGPrint(( JPDBGMSG_GOTFUNC, JetFuncTable[i].pFName, i, JetFuncTable[i].pFAdd ));
              }
           }

    }
    return(ERROR_SUCCESS);

} /* LoadDatabaseDll */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\ttapi.c ===
#include "config.h"

#include "daedef.h"

#ifndef DEBUG
#define ErrIsamSortMakeKey				ErrIsamMakeKey
#define ErrIsamSortSetColumn			ErrIsamSetColumn
#define ErrIsamSortRetrieveColumn	ErrIsamRetrieveColumn
#define ErrIsamSortRetrieveKey		ErrIsamRetrieveKey
#endif

DeclAssertFile;

ERR VTAPI ErrIsamSortMaterialize(JET_SESID sesid, JET_VTID vtid, BOOL fIndex);
ERR VTAPI ErrIsamSortEndInsert(JET_SESID sesid, JET_VTID vtid, JET_GRBIT *pgrbit);
ERR VTAPI ErrIsamSortOpen( PIB *ppib, JET_COLUMNDEF *rgcolumndef, ULONG ccolumndef, JET_GRBIT grbit, FUCB **ppfucb, JET_COLUMNID *rgcolumnid );

extern VDBFNCapability			ErrIsamCapability;
extern VDBFNCloseDatabase		ErrIsamCloseDatabase;
extern VDBFNCreateObject		ErrIsamCreateObject;
extern VDBFNCreateTable 		ErrIsamCreateTable;
extern VDBFNDeleteObject		ErrIsamDeleteObject;
extern VDBFNDeleteTable 		ErrIsamDeleteTable;
extern VDBFNGetColumnInfo		ErrIsamGetColumnInfo;
extern VDBFNGetDatabaseInfo 	ErrIsamGetDatabaseInfo;
extern VDBFNGetIndexInfo		ErrIsamGetIndexInfo;
extern VDBFNGetObjectInfo		ErrIsamGetObjectInfo;
extern VDBFNOpenTable			ErrIsamOpenTable;
extern VDBFNRenameTable 		ErrIsamRenameTable;
extern VDBFNGetObjidFromName	ErrIsamGetObjidFromName;
extern VDBFNRenameObject		ErrIsamRenameObject;


CODECONST(VDBFNDEF) vdbfndefIsam =
	{
	sizeof(VDBFNDEF),
	0,
	NULL,
	ErrIsamCapability,
	ErrIsamCloseDatabase,
	ErrIsamCreateObject,
	ErrIsamCreateTable,
	ErrIsamDeleteObject,
	ErrIsamDeleteTable,
	ErrIllegalExecuteSql,
	ErrIsamGetColumnInfo,
	ErrIsamGetDatabaseInfo,
	ErrIsamGetIndexInfo,
	ErrIsamGetObjectInfo,
	ErrIllegalGetReferenceInfo,
	ErrIsamOpenTable,
	ErrIsamRenameObject,
	ErrIsamRenameTable,
	ErrIsamGetObjidFromName,
	};


extern VTFNAddColumn					ErrIsamAddColumn;
extern VTFNCloseTable				ErrIsamCloseTable;
#ifdef NJETNT
extern VTFNCollectRecids			ErrIsamCollectRecids;
#endif
extern VTFNComputeStats 			ErrIsamComputeStats;
extern VTFNCopyBookmarks			ErrIsamCopyBookmarks;
extern VTFNCreateIndex				ErrIsamCreateIndex;
extern VTFNDelete						ErrIsamDelete;
extern VTFNDeleteColumn 			ErrIsamDeleteColumn;
extern VTFNDeleteIndex				ErrIsamDeleteIndex;
extern VTFNDupCursor					ErrIsamDupCursor;
extern VTFNGetBookmark				ErrIsamGetBookmark;
extern VTFNGetChecksum				ErrIsamGetChecksum;
extern VTFNGetCurrentIndex			ErrIsamGetCurrentIndex;
extern VTFNGetCursorInfo			ErrIsamGetCursorInfo;
extern VTFNGetRecordPosition		ErrIsamGetRecordPosition;
extern VTFNGetTableColumnInfo		ErrIsamGetTableColumnInfo;
extern VTFNGetTableIndexInfo		ErrIsamGetTableIndexInfo;
extern VTFNGetTableInfo 			ErrIsamGetTableInfo;
extern VTFNGotoBookmark 			ErrIsamGotoBookmark;
extern VTFNGotoPosition 			ErrIsamGotoPosition;
extern VTFNVtIdle						ErrIsamVtIdle;
extern VTFNMakeKey					ErrIsamMakeKey;
extern VTFNMove 						ErrIsamMove;
extern VTFNNotifyBeginTrans		ErrIsamNotifyBeginTrans;
extern VTFNNotifyCommitTrans		ErrIsamNotifyCommitTrans;
extern VTFNNotifyRollback			ErrIsamNotifyRollback;
extern VTFNPrepareUpdate			ErrIsamPrepareUpdate;
extern VTFNRenameColumn 			ErrIsamRenameColumn;
extern VTFNRenameIndex				ErrIsamRenameIndex;
extern VTFNRetrieveColumn			ErrIsamRetrieveColumn;
extern VTFNRetrieveKey				ErrIsamRetrieveKey;
extern VTFNSeek 						ErrIsamSeek;
extern VTFNSeek 						ErrIsamSortSeek;
extern VTFNSetCurrentIndex			ErrIsamSetCurrentIndex;
extern VTFNSetColumn					ErrIsamSetColumn;
extern VTFNSetIndexRange			ErrIsamSetIndexRange;
extern VTFNSetIndexRange			ErrIsamSortSetIndexRange;
extern VTFNUpdate						ErrIsamUpdate;
extern VTFNRetrieveColumn			ErrIsamInfoRetrieveColumn;
extern VTFNSetColumn					ErrIsamInfoSetColumn;
extern VTFNUpdate						ErrIsamInfoUpdate;

extern VTFNDupCursor					ErrIsamSortDupCursor;
extern VTFNGetTableInfo		 		ErrIsamSortGetTableInfo;
extern VTFNCloseTable				ErrIsamSortClose;
extern VTFNMove 						ErrIsamSortMove;
extern VTFNGetBookmark				ErrIsamSortGetBookmark;
extern VTFNGotoBookmark 			ErrIsamSortGotoBookmark;
extern VTFNRetrieveKey				ErrIsamSortRetrieveKey;
extern VTFNUpdate						ErrIsamSortUpdate;

extern VTFNDupCursor					ErrTTSortRetDupCursor;

extern VTFNDupCursor					ErrTTBaseDupCursor;
extern VTFNMove 						ErrTTSortInsMove;
extern VTFNSeek 						ErrTTSortInsSeek;


CODECONST(VTFNDEF) vtfndefIsam =
	{
	sizeof(VTFNDEF),
	0,
	NULL,
	ErrIsamAddColumn,
	ErrIsamCloseTable,
	ErrIsamComputeStats,
	ErrIllegalCopyBookmarks,
	ErrIsamCreateIndex,
	ErrIllegalCreateReference,
	ErrIsamDelete,
	ErrIsamDeleteColumn,
	ErrIsamDeleteIndex,
	ErrIllegalDeleteReference,
	ErrIsamDupCursor,
	ErrIsamGetBookmark,
	ErrIsamGetChecksum,
	ErrIsamGetCurrentIndex,
	ErrIsamGetCursorInfo,
	ErrIsamGetRecordPosition,
	ErrIsamGetTableColumnInfo,
	ErrIsamGetTableIndexInfo,
	ErrIsamGetTableInfo,
	ErrIllegalGetTableReferenceInfo,
	ErrIsamGotoBookmark,
	ErrIsamGotoPosition,
	ErrIllegalVtIdle,
	ErrIsamMakeKey,
	ErrIsamMove,
	ErrIllegalNotifyBeginTrans,
	ErrIllegalNotifyCommitTrans,
	ErrIllegalNotifyRollback,
	ErrIllegalNotifyUpdateUfn,
	ErrIsamPrepareUpdate,
	ErrIsamRenameColumn,
	ErrIsamRenameIndex,
	ErrIllegalRenameReference,
	ErrIsamRetrieveColumn,
	ErrIsamRetrieveKey,
	ErrIsamSeek,
	ErrIsamSetCurrentIndex,
	ErrIsamSetColumn,
	ErrIsamSetIndexRange,
	ErrIsamUpdate,
	ErrIllegalEmptyTable,
#ifdef NJETNT
#ifdef QUERY
	ErrIsamCollectRecids
#else
	ErrIllegalCollectRecids
#endif
#endif
	};


CODECONST(VTFNDEF) vtfndefIsamInfo =
	{
	sizeof(VTFNDEF),
	0,
	NULL,
	ErrIllegalAddColumn,
	ErrIsamCloseTable,
	ErrIllegalComputeStats,
	ErrIllegalCopyBookmarks,
	ErrIllegalCreateIndex,
	ErrIllegalCreateReference,
	ErrIllegalDelete,
	ErrIllegalDeleteColumn,
	ErrIllegalDeleteIndex,
	ErrIllegalDeleteReference,
	ErrIllegalDupCursor,
	ErrIllegalGetBookmark,
	ErrIllegalGetChecksum,
	ErrIllegalGetCurrentIndex,
	ErrIllegalGetCursorInfo,
	ErrIllegalGetRecordPosition,
	ErrIsamGetTableColumnInfo,
	ErrIllegalGetTableIndexInfo,
	ErrIllegalGetTableInfo,
	ErrIllegalGetTableReferenceInfo,
	ErrIllegalGotoBookmark,
	ErrIllegalGotoPosition,
	ErrIllegalVtIdle,
	ErrIllegalMakeKey,
	ErrIllegalMove,
	ErrIllegalNotifyBeginTrans,
	ErrIllegalNotifyCommitTrans,
	ErrIllegalNotifyRollback,
	ErrIllegalNotifyUpdateUfn,
	ErrIsamPrepareUpdate,
	ErrIllegalRenameColumn,
	ErrIllegalRenameIndex,
	ErrIllegalRenameReference,
	ErrIsamInfoRetrieveColumn,
	ErrIllegalRetrieveKey,
	ErrIllegalSeek,
	ErrIllegalSetCurrentIndex,
	ErrIsamInfoSetColumn,
	ErrIllegalSetIndexRange,
	ErrIsamInfoUpdate,
	ErrIllegalEmptyTable,
#ifdef NJETNT
	ErrIllegalCollectRecids
#endif
	};


CODECONST(VTFNDEF) vtfndefTTSortIns =
	{
	sizeof(VTFNDEF),
	0,
	NULL,
	ErrIllegalAddColumn,
	ErrIsamSortClose,
	ErrIllegalComputeStats,
	ErrIllegalCopyBookmarks,
	ErrIllegalCreateIndex,
	ErrIllegalCreateReference,
	ErrIllegalDelete,
	ErrIllegalDeleteColumn,
	ErrIllegalDeleteIndex,
	ErrIllegalDeleteReference,
	ErrIllegalDupCursor,
	ErrIllegalGetBookmark,
	ErrIllegalGetChecksum,
	ErrIllegalGetCurrentIndex,
	ErrIllegalGetCursorInfo,
	ErrIllegalGetRecordPosition,
	ErrIllegalGetTableColumnInfo,
	ErrIllegalGetTableIndexInfo,
	ErrIllegalGetTableInfo,
	ErrIllegalGetTableReferenceInfo,
	ErrIllegalGotoBookmark,
	ErrIllegalGotoPosition,
	ErrIllegalVtIdle,
	ErrIsamMakeKey,
	ErrTTSortInsMove,
	ErrIllegalNotifyBeginTrans,
	ErrIllegalNotifyCommitTrans,
	ErrIllegalNotifyRollback,
	ErrIllegalNotifyUpdateUfn,
	ErrIsamPrepareUpdate,
	ErrIllegalRenameColumn,
	ErrIllegalRenameIndex,
	ErrIllegalRenameReference,
	ErrIllegalRetrieveColumn,
	ErrIsamSortRetrieveKey,
	ErrTTSortInsSeek,
	ErrIllegalSetCurrentIndex,
	ErrIsamSetColumn,
	ErrIllegalSetIndexRange,
	ErrIsamSortUpdate,
	ErrIllegalEmptyTable,
#ifdef NJETNT
	ErrIllegalCollectRecids
#endif
	};


CODECONST(VTFNDEF) vtfndefTTSortRet =
	{
	sizeof(VTFNDEF),
	0,
	NULL,
	ErrIllegalAddColumn,
	ErrIsamSortClose,
	ErrIllegalComputeStats,
	ErrIllegalCopyBookmarks,
	ErrIllegalCreateIndex,
	ErrIllegalCreateReference,
	ErrIllegalDelete,
	ErrIllegalDeleteColumn,
	ErrIllegalDeleteIndex,
	ErrIllegalDeleteReference,
	ErrTTSortRetDupCursor,
	ErrIsamSortGetBookmark,
	ErrIllegalGetChecksum,
	ErrIllegalGetCurrentIndex,
	ErrIllegalGetCursorInfo,
	ErrIllegalGetRecordPosition,
	ErrIllegalGetTableColumnInfo,
	ErrIllegalGetTableIndexInfo,
	ErrIsamSortGetTableInfo,
	ErrIllegalGetTableReferenceInfo,
	ErrIsamSortGotoBookmark,
	ErrIllegalGotoPosition,
	ErrIllegalVtIdle,
	ErrIsamMakeKey,
	ErrIsamSortMove,
	ErrIllegalNotifyBeginTrans,
	ErrIllegalNotifyCommitTrans,
	ErrIllegalNotifyRollback,
	ErrIllegalNotifyUpdateUfn,
	ErrIllegalPrepareUpdate,
	ErrIllegalRenameColumn,
	ErrIllegalRenameIndex,
	ErrIllegalRenameReference,
	ErrIsamRetrieveColumn,
	ErrIsamSortRetrieveKey,
	ErrIsamSortSeek,
	ErrIllegalSetCurrentIndex,
	ErrIllegalSetColumn,
	ErrIsamSortSetIndexRange,
	ErrIllegalUpdate,
	ErrIllegalEmptyTable,
#ifdef NJETNT
	ErrIllegalCollectRecids
#endif
	};


CODECONST(VTFNDEF) vtfndefTTBase =
	{
	sizeof(VTFNDEF),
	0,
	NULL,
	ErrIllegalAddColumn,
	ErrIsamSortClose,
	ErrIllegalComputeStats,
	ErrIllegalCopyBookmarks,
	ErrIllegalCreateIndex,
	ErrIllegalCreateReference,
	ErrIsamDelete,
	ErrIllegalDeleteColumn,
	ErrIllegalDeleteIndex,
	ErrIllegalDeleteReference,
	ErrTTBaseDupCursor,
	ErrIsamGetBookmark,
	ErrIsamGetChecksum,
	ErrIllegalGetCurrentIndex,
	ErrIsamGetCursorInfo,
	ErrIllegalGetRecordPosition,
	ErrIllegalGetTableColumnInfo,
	ErrIllegalGetTableIndexInfo,
	ErrIsamSortGetTableInfo,
	ErrIllegalGetTableReferenceInfo,
	ErrIsamGotoBookmark,
	ErrIllegalGotoPosition,
	ErrIllegalVtIdle,
	ErrIsamMakeKey,
	ErrIsamMove,
	ErrIllegalNotifyBeginTrans,
	ErrIllegalNotifyCommitTrans,
	ErrIllegalNotifyRollback,
	ErrIllegalNotifyUpdateUfn,
	ErrIsamPrepareUpdate,
	ErrIllegalRenameColumn,
	ErrIllegalRenameIndex,
	ErrIllegalRenameReference,
	ErrIsamRetrieveColumn,
	ErrIsamRetrieveKey,
	ErrIsamSeek,
	ErrIllegalSetCurrentIndex,
	ErrIsamSetColumn,
	ErrIsamSetIndexRange,
	ErrIsamUpdate,
	ErrIllegalEmptyTable,
#ifdef NJETNT
	ErrIllegalCollectRecids
#endif
	};


JET_TABLEID TableidOfVtid( FUCB *pfucb )
	{
	JET_TABLEID	tableid;

	tableid = TableidFromVtid( (JET_VTID) pfucb, &vtfndefIsam );
	if ( tableid == JET_tableidNil )
		{
		tableid = TableidFromVtid( (JET_VTID) pfucb, &vtfndefIsamInfo );
		if ( tableid == JET_tableidNil )
			{
			tableid = TableidFromVtid((JET_VTID) pfucb, &vtfndefTTSortRet );
			if ( tableid == JET_tableidNil )
				{
				tableid = TableidFromVtid( (JET_VTID) pfucb, &vtfndefTTBase );
		  		if ( tableid == JET_tableidNil )
					tableid = TableidFromVtid( (JET_VTID)pfucb, &vtfndefTTSortIns );
				}
			}
		}
	Assert( tableid != JET_tableidNil );
	return tableid;
	}


/*=================================================================
// ErrIsamOpenTempTable
//
// Description:
//
//	Returns a tableid for a temporary (lightweight) table.	The data
//	definitions for the table are specified at open time.
//
// Parameters:
//	JET_SESID			sesid				user session id
//	JET_TABLEID			*ptableid		new JET (dispatchable) tableid
//	ULONG					csinfo			count of JET_COLUMNDEF structures
//												(==number of columns in table)
//	JET_COLUMNDEF		*rgcolumndef	An array of column and key defintions
//												Note that TT's do require that a key be
//												defined. (see jet.h for JET_COLUMNDEF)
//	JET_GRBIT			grbit				valid values
//												JET_bitTTUpdatable (for insert and update)
//												JET_bitTTScrollable (for movement other then movenext)
//
// Return Value:
//	err			jet error code or JET_errSuccess.
//	*ptableid	a dispatchable tableid
//
// Errors/Warnings:
//
// Side Effects:
//
=================================================================*/
ERR VDBAPI ErrIsamOpenTempTable(
	JET_SESID				sesid,
	const JET_COLUMNDEF	*rgcolumndef,
	unsigned long			ccolumndef,
	JET_GRBIT				grbit,
	JET_TABLEID				*ptableid,
	JET_COLUMNID			*rgcolumnid)
	{
	ERR				err;
	JET_TABLEID		tableid;
	JET_VTID			vtid;
	INT				fIndexed;
	INT				fLongValues;
	INT				i;

	CallR( ErrIsamSortOpen( (PIB *)sesid, (JET_COLUMNDEF *) rgcolumndef, ccolumndef, grbit, (FUCB **)&tableid, rgcolumnid ) );
	CallS( ErrGetVtidTableid( sesid, tableid, &vtid ) );

	fIndexed = fFalse;
	fLongValues = fFalse;
	for ( i = 0; i < (INT)ccolumndef; i++ )
		{
		fIndexed |= ((rgcolumndef[i].grbit & JET_bitColumnTTKey) != 0);
		fLongValues |= (rgcolumndef[i].coltyp == JET_coltypLongText ||
			rgcolumndef[i].coltyp == JET_coltypLongBinary);
		}

	if ( !fIndexed || fLongValues )
		{
		err = ErrIsamSortMaterialize( sesid, vtid, fIndexed );
		if ( err < 0 && err != JET_errNoCurrentRecord )
			{
			CallS( ErrIsamSortClose( sesid, vtid ) );
			return err;
			}
		/*	supress JET_errNoCurrentRecord error when opening
		/*	empty temporary table.
		/**/
		err = JET_errSuccess;

		CallS( ErrSetPvtfndefTableid( sesid, tableid, &vtfndefTTBase ) );
		}
	else
		{
		CallS( ErrSetPvtfndefTableid( sesid, tableid, &vtfndefTTSortIns ) );
		}

	*ptableid = tableid;
	return err;
	}


ERR ErrTTEndInsert( JET_SESID sesid, JET_VTID vtid, JET_TABLEID tableid )
	{
	ERR				err;
	INT				fMaterialize;
	JET_GRBIT		grbitOpen;

	/*	ErrIsamSortEndInsert returns JET_errNoCurrentRecord if sort empty
	/**/
	err = ErrIsamSortEndInsert( sesid, vtid, &grbitOpen );

	fMaterialize = ( grbitOpen & JET_bitTTUpdatable ) ||
		( grbitOpen & ( JET_bitTTScrollable | JET_bitTTIndexed ) ) &&
		( err == JET_wrnSortOverflow );

	if ( fMaterialize )
		{
		err = ErrIsamSortMaterialize( sesid, vtid, ( grbitOpen & JET_bitTTIndexed ) != 0 );
		CallS( ErrSetPvtfndefTableid( sesid, tableid, &vtfndefTTBase ) );
		}
	else
		{
		CallS( ErrSetPvtfndefTableid( sesid, tableid, &vtfndefTTSortRet ) );
		/*	ErrIsamSortEndInsert returns currency on first record
		/**/
		}

	return err;
	}


/*=================================================================
// ErrTTSortInsMove
//
// Description:
//	Functionally the same as JetMove().  This routine traps the first
//	move call on a TT, to perform any necessary transformations.
//	Routine should only be used by ttapi.c via disp.asm.
//
// Parameters:
//	see JetMove()
//
// Return Value:
//
// Errors/Warnings:
//
// Side Effects:
//	May cause a sort to be materialized
=================================================================*/
ERR VTAPI ErrTTSortInsMove( JET_SESID sesid, JET_VTID vtid, long crow, JET_GRBIT grbit )
	{
	ERR				err;
	JET_TABLEID		tableid = TableidFromVtid(vtid, &vtfndefTTSortIns);

	CallR( ErrTTEndInsert( sesid, vtid, tableid ) );

	if ( crow == JET_MoveFirst || crow == 0 || crow == 1 )
		return JET_errSuccess;

	err = ErrDispMove( sesid, tableid, crow, grbit );
	return err;
	}


/*=================================================================
// ErrTTSortInsSeek
//
// Description:
//	Functionally the same as JetSeek().  This routine traps the first
//	seek call on a TT, to perform any necessary transformations.
//	Routine should only be used by ttapi.c via disp.asm.
//
// Parameters:
//	see JetSeek()
//
// Return Value:
//
// Errors/Warnings:
//
// Side Effects:
//	May cause a sort to be materialized
=================================================================*/
ERR VTAPI ErrTTSortInsSeek( JET_SESID sesid, JET_VTID vtid, JET_GRBIT grbit )
	{
	ERR				err;
	JET_TABLEID		tableid;

	tableid = TableidFromVtid(vtid, &vtfndefTTSortIns);

	Call( ErrTTEndInsert(sesid, vtid, tableid ) );
	err = ErrDispSeek(sesid, tableid, grbit );

HandleError:
	if ( err == JET_errNoCurrentRecord )
		err = JET_errRecordNotFound;
	return err;
	}


ERR VTAPI ErrTTSortRetDupCursor( JET_SESID sesid, JET_VTID vtid, JET_TABLEID *ptableidDup, JET_GRBIT grbit )
	{
	ERR				err;

	err = ErrIsamSortDupCursor( sesid, vtid, ptableidDup, grbit );
	if ( err >= 0 )
		{
		CallS( ErrSetPvtfndefTableid( sesid, *ptableidDup, &vtfndefTTSortRet ) );
		}

	return err;
	}


ERR VTAPI ErrTTBaseDupCursor( JET_SESID sesid, JET_VTID vtid, JET_TABLEID *ptableidDup, JET_GRBIT grbit )
	{
	ERR				err;

	err = ErrIsamSortDupCursor( sesid, vtid, ptableidDup, grbit );
	if ( err >= 0 )
		{
		CallS( ErrSetPvtfndefTableid( sesid, *ptableidDup, &vtfndefTTBase ) );
		}

	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\inc\err.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\dae\src\tm.c ===
#include "config.h"

#include <stdlib.h>
#include <string.h>

#include "daedef.h"
#include "util.h"
#include "pib.h"
#include "fmp.h"
#include "page.h"
#include "ssib.h"
#include "fcb.h"
#include "fucb.h"
#include "stapi.h"
#include "nver.h"
#include "dirapi.h"
#include "fdb.h"
#include "recapi.h"
#include "recint.h"
#include "spaceapi.h"
#include "fileapi.h"
#include "fileint.h"
#include "sortapi.h"
#include "logapi.h"
#include "log.h"
#include "dbapi.h"
#include "bm.h"

DeclAssertFile;						/* Declare file name for assert macros */

INT itibGlobal = 0;

extern PIB * __near ppibAnchor;

#ifdef	WIN16

/*	current PHA for ErrSTInit to use
/**/
extern PHA * __near phaCurrent = NULL;

/*	first PHA in list of all PHAs
/**/
static PHA * phaFirst = NULL;

/*	current user's array of file handles
/**/
extern HANDLE * __near rghfUser = NULL;

#endif	/* WIN16 */

//+api
//	ErrIsamBeginSession
//	========================================================
//	ERR ErrIsamBeginSession( PIB **pppib )
//
//	Begins a session with DAE.  Creates and initializes a PIB for the
//	user and returns a pointer to it.  Calls system initialization.
//
//	PARAMETERS	pppib			Address of a PIB pointer.  On return, *pppib
//		   						will point to the new PIB.
//
//	RETURNS		Error code, one of:
//					JET_errSuccess
//					JET_errTooManyActiveUsers
//
//	COMMENTS		Calls ErrSTInit the first time here.
//
//	SEE ALSO		ErrIsamEndSession
//-
ERR ISAMAPI ErrIsamBeginSession( JET_SESID *psesid )
	{
	ERR			err;
	JET_SESID	sesid = *psesid;
	PIB			**pppib;

#ifdef	WIN16
	HANDLE	htask;
#endif	/* WIN16 */

	Assert( psesid != NULL );
	Assert( sizeof(JET_SESID) == sizeof(PIB *) );
	pppib = (PIB **)psesid;

#ifdef	WIN16
	/*	Get current task handle
	/**/
	htask = SysGetCurrentTask();

	/*	locate the process handle array if any
	/**/
	phaCurrent = phaFirst;
	while ( phaCurrent != NULL && htask != phaCurrent->htask )
		{
		phaCurrent = phaCurrent->phaNext;
		}

	/*	allocate a process handle array if necessary
	/**/
	if ( phaCurrent == NULL )
		{
		phaCurrent = SAlloc( sizeof(PHA) );
		if ( phaCurrent == NULL )
			{
			return JET_errOutOfMemory;
			}

		phaCurrent->phaNext = phaFirst;
		phaCurrent->htask	= htask;
		phaCurrent->csesid = 1;

		memset( phaCurrent->rghfDatabase, 0, sizeof( phaCurrent->rghfDatabase ) );

		phaFirst = phaCurrent;
		}
	else
		phaCurrent->csesid++;

	/*	set pointer to the current process handle array and log file handle
	/**/
	rghfUser = phaCurrent->rghfDatabase;
	hfLog	 = phaCurrent->hfLog;
#endif	/* WIN16 */

	/*	initialize the Storage System
	/**/
	Call( ErrSTInit( ) );
	Call( ErrPIBBeginSession( pppib ) );
	(*pppib)->fUserSession = fTrue;

	/*	store session id in pib.  If passes JET_sesidNil, then
	/*	store ppib in place of sesid.
	/**/
	if ( sesid != JET_sesidNil )
		{
		(*pppib)->sesid = sesid;
		}
	else
		{
		(*pppib)->sesid = (JET_SESID)(*pppib);
		}

#ifdef	WIN16
	phaCurrent->hfLog = hfLog;			// Save the log file handle
	(*pppib)->phaUser = phaCurrent;		// Save PHA pointer in the PIB
	return err;
#endif	/* WIN16 */

HandleError:

#ifdef	WIN16
	/*	free the process handle array if it was just allocated
	/**/
	if ( phaCurrent != NULL && phaCurrent->csesid == 1 )
		{
		SFree( phaCurrent );
		}
	else
		phaCurrent->csesid--;
#endif	/* WIN16 */

	return err;
	}


//+api
// ErrIsamEndSession
// =========================================================
// ERR ErrIsamEndSession( PIB *ppib, JET_GRBIT grbit )
//
// Ends the session associated with a PIB.
//
// PARAMETERS	ppib		Pointer to PIB for ending session.
//
// RETURNS		JET_errSuccess
//
// SIDE EFFECTS Aborts all transaction levels active for this PIB.
//				Closes all FUCBs for files and sorts open for this PIB.
//
// SEE ALSO		BeginSession
//-
ERR ISAMAPI ErrIsamEndSession( JET_SESID sesid, JET_GRBIT grbit )
	{		
	ERR	 	err;
	DBID  	dbid;
	PIB	 	*ppib = (PIB *)sesid;
	
	CheckPIB( ppib );

	NotUsed( grbit );

	/*	rollback all transactions
	/**/
	while( ppib->level > 0 )
		{
		Assert( sizeof(JET_VSESID) == sizeof(ppib) );
		CallR( ErrIsamRollback( (JET_VSESID)ppib, JET_bitRollbackAll ) );
		}

	/*	close all databases for this PIB 
	/**/
	CallR( ErrDABCloseAllDBs( ppib ) );
	
	/*	close all open databases for this PIB 
	/**/
	for ( dbid = dbidUserMin; dbid < dbidUserMax; dbid++ )
		{
		if ( FUserOpenedDatabase( ppib, dbid ) )
			{
			/* if not for recovering, ErrDABCloseAllDBs has closed all others
			/**/
			Assert( fRecovering || dbid == dbidSystemDatabase );
			CallR( ErrDBCloseDatabase( ppib, dbid, 0 ) );
			}
		}

	/*	close all cursors still open
	/*	should only be sort and temporary file cursors
	/**/
	while( ppib->pfucb != pfucbNil )
		{
		FUCB	*pfucb	= ppib->pfucb;

		/*	close materialized or unmaterialized temporary tables
		/**/
		if ( FFUCBSort( pfucb ) )
			{
			Assert( !( FFUCBIndex( pfucb ) ) );
			CallR( ErrIsamSortClose( ppib, pfucb ) );
			}
		else if ( fRecovering || FFUCBNonClustered( pfucb ) )
			{
			/*  If the fucb is used for redo (recovering), then it is
			/*  always being opened as a cluster fucb with no index.
			/*  use DIRClose to close such a fucb.
			/*  Else, it is not for recovering, cursor is on index fucb,
			/*  main fucb may still be ahead. Close this index fucb.
			/**/  
			DIRClose( pfucb );
			}
		else
			{
			while ( FFUCBNonClustered( pfucb ) )
				{
				pfucb = pfucb->pfucbNext;
				}
			
			Assert( FFUCBIndex( pfucb ) );
			
			if( pfucb->fVtid )
				{
				CallS( ErrDispCloseTable( (JET_SESID)ppib, TableidOfVtid( pfucb ) ) );
				}
			else
				{
				CallS( ErrFILECloseTable( ppib, pfucb ) );
				}
			}
		}
	Assert( ppib->pfucb == pfucbNil );

#ifdef	WIN16
	if ( --ppib->phaUser->csesid == 0 )
		{
		CallR( ErrFlushDatabases() );

		for ( dbid = 0; dbid < dbidUserMax; dbid++ )
			{
			if ( Hf(dbid) != handleNil && Hf(dbid) != 0 )
				{
				ErrSysCloseFile( Hf(dbid) );
				Hf(dbid) = handleNil;
				}
			}

		phaCurrent = ppib->phaUser;

		if ( phaFirst == phaCurrent )
			{
			phaFirst = phaCurrent->phaNext;
			}
		else
			{
			PHA	* phaPrior = phaFirst;

			while ( phaPrior->phaNext != phaCurrent )
				{
				phaPrior = phaCurrent->phaNext;
				}

			phaPrior->phaNext = phaCurrent->phaNext;
			}

		SFree( ppib->phaUser );
		}
#endif	/* WIN16 */

#ifndef ASYNC_VER_CLEANUP
	(VOID)ErrRCECleanPIB( ppib );
#endif

	PIBEndSession( ppib );

	return JET_errSuccess;
	}


/*	ErrIsamSetSessionInfo  =================================
	
Description:

	Sets cursor isolation model to valid JET_CIM value.

Parameters:
	sesid		session id
	grbit		grbit 

==========================================================*/
ERR ISAMAPI ErrIsamSetSessionInfo( JET_SESID sesid, JET_GRBIT grbit )
	{
	( (PIB *)sesid )->grbit = grbit;
	return JET_errSuccess;
	}


ERR ISAMAPI ErrIsamIdle( JET_SESID sesid, JET_GRBIT grbit )
	{
	ERR		err = JET_errSuccess;
	ERR		wrn = JET_errSuccess;
	PIB		*ppib = (PIB *)sesid;
	INT		icall;

	CheckPIB( ppib );

	/*	clean all version buckets.
	/**/
	if ( grbit == 0 || grbit == JET_bitIdleCompact )
		{
		Call( ErrRCECleanAllPIB() );
		if ( wrn == JET_errSuccess )
			wrn = err;
		}

	/*	clean all modified pages.
	/**/
	if ( grbit == 0 || grbit == JET_bitIdleCompact )
		{
		icall = 0;
		do
			{
			Call( ErrBMClean( ppibBMClean ) );
			if ( wrn == JET_errSuccess )
				wrn = err;
			if ( err < 0 )
				break;
  			} while ( ++icall < icallIdleBMCleanMax && err != JET_wrnNoIdleActivity );
		}

	/*	flush all dirty buffers
	/**/
	if ( grbit == 0 || grbit == JET_bitIdleFlushBuffers )
		{
		Call( ErrBFFlushBuffers( 0, fBFFlushSome ) );
		if ( wrn == JET_errSuccess )
			wrn = err;
		}

HandleError:
	return err == JET_errSuccess ? wrn : err;
	}


ERR VTAPI ErrIsamCapability( PIB *ppib, 
	ULONG dbid, 
	ULONG ulArea, 
	ULONG ulFunction, 
	ULONG *pgrbitFeature )
	{
	CheckPIB( ppib );

	NotUsed( dbid );
	NotUsed( ulArea );
	NotUsed( ulFunction );
	NotUsed( pgrbitFeature );
	
	return JET_errSuccess;
	}


extern BOOL fOLCompact;

#ifdef DEBUG
VOID WriteStartEvent( VOID )
	{
	/* write jet start event
	/**/
	BYTE szMessage[256];

	sprintf( szMessage, "Jet Blue Starts (LOG,OLC)=(%d,%d)",
		(INT) (fLogDisabled == 0),
		(INT) (fOLCompact != 0) );
	UtilWriteEvent( evntypStart, szMessage, pNil, 0 );
	}
#else
#define WriteStartEvent()	0
#endif


extern CHAR szRecovery[];
#define szOn "on"			/* UNDONE: system parameter */


ERR ISAMAPI ErrIsamInit( INT iinstance )
	{
	ERR		err;
	BOOL	fExistSysDB;
	BOOL	fLGInitIsDone = fFalse;
	PIB		*ppibT;
	DBID	dbid;

	//	UNDONE:	fix this bogosity for multi-process support
	/*	assign itib to global
	/**/
#ifdef NJETNT
	itibGlobal = ItibOfInstance( iinstance );
#endif

#ifdef DEBUG
	CallR( ErrSTSetIntrinsicConstants( ) );
#endif
	
	/*	initialize LG manager, and check the last generation of log files
	/*	to decide if a soft recovery is needed.
	/**/
	fLogDisabled = ( szRecovery[0] == '\0' || _stricmp ( szRecovery, szOn ) != 0 );

	WriteStartEvent();

	/*	initialize FMP
	/**/
	CallR( ErrFMPInit() );

	if ( fLogDisabled )
		{
		Assert( rgfmp[dbidSystemDatabase].hf == handleNil );

#ifdef NJETNT
		fExistSysDB = FFileExists( rgtib[itibGlobal].szSysDbPath);
#else
		fExistSysDB = FFileExists( szSysDbPath );
#endif
		if ( !fExistSysDB )
			{
			err = JET_errFileNotFound;
			goto TermFMP;
			}
		}
	else
		{
		/*	recovery is on, initialize Log manager, and check soft restart.
		/**/
		Assert( fLogDisabled == fFalse );

		/*  initialize log manager and set working log file path
		/**/
		CallJ( ErrLGInit(), TermFMP );
		fLGInitIsDone = fTrue;

		/* soft restore, system database should be kept open
		/**/
		fJetLogGeneratedDuringSoftStart = fFalse;
		CallJ( ErrLGSoftStart( fFalse ), TermLG );
		
		/* continue initialize the database
		/**/
		}

	/*  initialize the rest part of the system
	/**/
	CallJ( ErrSTInit(), TermLG );
	
	CallJ( ErrPIBBeginSession( &ppibT ), TermST );
	
	dbid = dbidSystemDatabase;
	CallJ( ErrDBOpenDatabase(
		ppibT,
		rgfmp[dbid].szDatabaseName,
		&dbid,
		0), PIBEnd );
	err = ErrFMPSetDatabases( ppibT );
	CallS( ErrDBCloseDatabase( ppibT, dbid, 0 ) );
	
	PIBEndSession( ppibT );

	if ( err == JET_errSuccess )
		return err;
		
PIBEnd:
	PIBEndSession( ppibT );
	
TermST:
	CallS( ErrSTTerm() );
	
TermLG:
	if ( fLGInitIsDone )
		{
		CallS( ErrLGTerm() );
		}
	
	if ( fJetLogGeneratedDuringSoftStart )
		{
		(VOID)ErrSysDeleteFile( szLogName );
		}
	
TermFMP:
	FMPTerm();
	
	return err;
	}


#ifdef OLDWAY
/*	system sessions
/**/
extern PIB *ppibRCEClean;
extern PIB *ppibBMClean;
#endif


ERR ISAMAPI ErrIsamTerm( VOID )
	{
	ERR		err = JET_errSuccess;
	PIB		*ppibT;
	INT		cpibActive = 0;

	/*	determine number of open user sessions
	/**/
	for ( ppibT = ppibAnchor; ppibT != ppibNil; ppibT = ppibT->ppibNext )
		{
		if ( ppibT->fUserSession && FPIBActive( ppibT ) )
#ifdef OLDWAY
		if ( ppibT != ppibRCEClean &&
			ppibT != ppibBMClean &&
			FPIBActive( ppibT ) )
#endif
			{
			cpibActive++;
			}
		}

	/*	system termination must be called after all sessions ended
	/**/
	if ( cpibActive > 0 )
		{
		return JET_errTooManyActiveUsers;
		}

	CallS( ErrSTTerm( ) );
	CallS( ErrLGTerm( ) );

	FMPTerm();

#ifdef DEBUG
	MEMCheck();
#endif

	SysTerm();

#ifdef DEBUG
	/* write jet stop event
	/**/
	UtilWriteEvent( evntypStop, "Jet Blue Stops.\n", pNil, 0 );
#endif
	
	return err;
	}


#ifdef DEBUG
ERR ISAMAPI ErrIsamGetTransaction( JET_VSESID vsesid, unsigned long *plevel )
	{
	PIB	*ppib = (PIB *)vsesid;

	CheckPIB( ppib );

	*plevel = (LONG)ppib->level;
	return JET_errSuccess;
	}
#endif


//+api
// ErrIsamBeginTransaction
// =========================================================
//	ERR ErrIsamBeginTransaction( PIB *ppib )
//
//	Starts a transaction for the current user.  The user's transaction
//	level increases by one.
//
//	PARAMETERS	ppib 			pointer to PIB for user
//
//	RETURNS		JET_errSuccess
//
//	SIDE EFFECTS	
//		The CSR stack for each active FUCB of this user is copied
//		to the new transaction level.
//
// SEE ALSO		ErrIsamCommitTransaction, ErrIsamRollback
//-
ERR ISAMAPI ErrIsamBeginTransaction( JET_VSESID vsesid )
	{
	PIB		*ppib = (PIB *)vsesid;

	CheckPIB( ppib );
	Assert( ppib != ppibNil );

	Assert( ppib->level <= levelUserMost );
	if ( ppib->level == levelUserMost )
		return JET_errTransTooDeep;

	return ErrDIRBeginTransaction( ppib );
	}


//+api
//	ErrIsamCommitTransaction
//	========================================================
//	ERR ErrIsamCommitTransaction( JET_VSESID vsesid, JET_GRBIT grbit )
//
//	Commits the current transaction for this user.  The transaction level
//	for this user is decreased by the number of levels committed.
//
//	PARAMETERS	
//
//	RETURNS		JET_errSuccess
//
//	SIDE EFFECTS 
//		The CSR stack for each active FUCB of this user is copied
//		from the old ( higher ) transaction level to the new ( lower )
//		transaction level.
//
//	SEE ALSO	ErrIsamBeginTransaction, ErrIsamRollback
//-
ERR ISAMAPI ErrIsamCommitTransaction( JET_VSESID vsesid, JET_GRBIT grbit )
	{
	PIB		*ppib = (PIB *)vsesid;

	CheckPIB( ppib );
	NotUsed( grbit );

	if ( ppib->level == 0 )
		return JET_errNotInTransaction;

	return ErrDIRCommitTransaction( ppib );
	}


#if 0
LOCAL ERR ErrFILEILevelCreate( FUCB *pfucb, BOOL *pfValid )
	{
	ERR		err;
	BOOL	fClosed;
	FUCB	*pfucbT;
	INT		wFlagsSav = pfucb->wFlags;

	/*	determine if domain is valid by checking the data length
	/*	of the FDP root node.
	/**/
	fClosed = FFUCBDeferClosed( pfucb );
	if ( fClosed )
		{
		FUCBResetDeferClose(pfucb);
		pfucb->levelOpen = pfucb->ppib->level;
		pfucb->wFlags = 0;
		pfucbT = pfucb;
		}
	else
		{
		CallR( ErrDIROpen( pfucb->ppib, pfucb->u.pfcb, 0, &pfucbT ) );
		}
	DIRGotoFDPRoot( pfucbT );
	Call( ErrDIRGet( pfucbT ) );
	*pfValid = ( pfucbT->lineData.cb > 0 );

HandleError:
	if ( fClosed )
		{
		FUCBSetDeferClose( pfucbT );
		}
	else
		{
		DIRClose( pfucbT );
		}
	pfucb->wFlags = wFlagsSav;

	return err;
	}
#endif


//+api
//	ErrIsamRollback
//	========================================================
//	ERR ErrIsamRollback( PIB *ppib, JET_GRBIT grbit )
//
//	Rolls back transactions for the current user.  The transaction level of
//	the current user is decreased by the number of levels aborted.
//
//	PARAMETERS	ppib		pointer to PIB for user
//				grbit		unused
//
//	RETURNS		
//		JET_errSuccess
//
// SIDE EFFECTS 
//
//	SEE ALSO
//-
ERR ISAMAPI ErrIsamRollback( JET_VSESID vsesid, JET_GRBIT grbit )
	{
	ERR    	err;
	PIB    	*ppib = (PIB *)vsesid;
	FUCB   	*pfucb;
	FUCB   	*pfucbNext;
	LEVEL  	levelRollback = ppib->level - 1;

	CheckPIB( ppib );
	
	if ( ppib->level == 0 )
		return JET_errNotInTransaction;

	do
		{
		/*	get first clustered index cusor
		/**/
		for ( pfucb = ppib->pfucb;
			pfucb != pfucbNil && FFUCBNonClustered( pfucb );
			pfucb = pfucb->pfucbNext )
			NULL;

		/*	LOOP 1 -- first go through all open cursors, and close them
		/*	or reset	non-clustered index cursors, if opened in transaction
		/*	rolled back.  Reset copy buffer status and move before first.
		/*	Some cursors will be fully closed, if they have not performed any
		/*	updates.  This will include non-clustered index cursors
		/*	attached to clustered index cursors, so pfucbNext must
		/*	always be a clustered index cursor, to ensure that it will
		/*	be valid for the next loop iteration.  Note that no information
		/*	necessary for subsequent rollback processing is lost, since
		/*	the cursors will only be released if they have performed no
		/*	updates including DDL.
		/**/
		for ( ; pfucb != pfucbNil; pfucb = pfucbNext )
			{
			/*	get next clustered index cusor
			/**/
			for ( pfucbNext = pfucb->pfucbNext;
			  	pfucbNext != pfucbNil && FFUCBNonClustered( pfucbNext );
			  	pfucbNext = pfucbNext->pfucbNext )
				NULL;

			/*	if defer closed then continue
			/**/
			if ( FFUCBDeferClosed( pfucb ) )
				continue;

			/*	reset copy buffer status for each cursor on rollback
			/**/
			if ( FFUCBUpdatePrepared( pfucb ) )
				{
				FUCBResetUpdateSeparateLV( pfucb );
				FUCBResetCbstat( pfucb );
				}
		
			/*	if current cursor is a table, and was opened in rolled back
			/*	transaction, then close cursor.
			/**/
			if ( FFUCBIndex( pfucb ) && FFCBClusteredIndex( pfucb->u.pfcb ) )
				{
				if ( pfucb->levelOpen > levelRollback )
					{
					if ( pfucb->fVtid )
						{
						CallS( ErrDispCloseTable( (JET_SESID)ppib, TableidOfVtid( pfucb ) ) );
						}
					else
						{
						CallS( ErrFILECloseTable( ppib, pfucb ) );
						}
					continue;
					}

				/*	if clustered index cursor, and non-clustered index set
				/*	in rolled back transaction, then change index to clustered
				/*	index.  This must be done, since non-clustered index
				/*	definition may be rolled back, if the index was created
				/*	in the rolled back transaction.
				/**/
				if ( pfucb->pfucbCurIndex != pfucbNil )
					{
					if ( pfucb->pfucbCurIndex->levelOpen > levelRollback )
						{
						CallS( ErrRECChangeIndex( pfucb, NULL ) );
						}
					}
				}

			/*	if current cursor is a sort, and was opened in rolled back
			/*	transaction, then close cursor.
			/**/
			if ( FFUCBSort( pfucb ) )
				{
				if ( pfucb->levelOpen > levelRollback )
					{
					CallS( ErrSORTClose( pfucb ) );
					continue;
					}
				}

			/*	if not sort and not index, and was opened in rolled back
			/*	transaction, then close DIR cursor directly.
			/**/
			if ( pfucb->levelOpen > levelRollback )
				{
				DIRClose( pfucb );
				continue;
				}
			}

		/*	call lower level abort routine
		/**/
		CallR( ErrDIRRollback( ppib ) );
		}
	while ( ( grbit & JET_bitRollbackAll ) != 0 && ppib->level > 0 );

	err = JET_errSuccess;

	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\inc\config.h ===
#if DBG

#define BLUE	1
#define JETINTERNAL	1

#define DEBUG		1
#define PARAMFILL	1

#define NTWINDOWS	1
#define PMODE		1

#define FLAT		1

#define ANSIAPI 	1

#define MUTEX 1
#define BATCH

	/* DAE project specific configuration */

#define SYSTABLES	1
#define CALLBACKS	1
#define DISPATCHING	1
#define SPIN_LOCK 1

#else

#define BLUE	1
#define JETINTERNAL	1

#define RETAIL		1

#define NTWINDOWS	1
#define PMODE		1

#define FLAT		1

#define ANSIAPI 	1

#define MUTEX 1

	/* DAE project specific configuration */

#define SYSTABLES	1
#define CALLBACKS	1
#define DISPATCHING	1
#define SPIN_LOCK	1

#endif

#include "basetsd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\inc\dbgcpl.h ===
#define ID_Dlg_ControlPanel	    100

#define ID_Btn_APITraceEnter	    1000
#define ID_Btn_APITraceExit	    1001
#define ID_Btn_APITraceExitError    1002
#define ID_Btn_APIBreakOnError	    1003
#define ID_Btn_APITraceCount	    1004

#define ID_Btn_AssertExit	    2000
#define ID_Btn_AssertBreak	    2001
#define ID_Btn_AssertMsgBox	    2002

#define ID_Btn_IOTraceAlloc	    3000
#define ID_Btn_IOTraceFree	    3001
#define ID_Btn_IOTraceRead	    3002
#define ID_Btn_IOTraceWrite	    3003
#define ID_Btn_IOTraceError	    3004

#define ID_Btn_MemTraceAlloc	    4000
#define ID_Btn_MemTraceRealloc	    4001
#define ID_Btn_MemTraceFree	    4002

#define ID_Btn_RmtTraceError	    5000
#define ID_Btn_RmtTraceSql	    5001
#define ID_Btn_RmtTraceAPI	    5002
#define ID_Btn_RmtTraceODBC	    5003

#define ID_Btn_ListActiveSessions  10000
#define ID_Btn_ListOpenDatabases   10001
#define ID_Btn_ListOpenTables	   10002
#define ID_Btn_ListBufferCache	   10003
#define ID_Btn_ListCacheSummary	   10004
#define ID_Btn_APITraceNoIdle       1005
#define ID_Btn_APITraceParameters   1006
#define ID_Btn_RmtSyncODBC          5004
#define ID_Btn_IdleTraceCursor      6000
#define ID_Btn_IdleTraceBuffer      6001
#define ID_Btn_IdleTraceFlush       6002
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\compact\comp.h ===
#ifndef _COMP_H_
#define _COMP_H_
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    comp.h

Abstract:


Author:

    Munil Shah (munils) 03-Jan-1995

Revision History:

--*/
#include <windows.h>
#include <stdio.h>

//
// JET function table for dynamic loading
//
typedef struct _JETFUNC_TABLE {
    BYTE   Index;  //index into array
    LPCSTR pFName; //function name for jet 500
    DWORD  FIndex; //function index for jet 200
    FARPROC pFAdd;
} JETFUNC_TABLE, *PJETFUNC_TABLE;

//
// This stuff is a cut and paste from net\jet\jet\src\jet.def
// we actually dont use all the jet functions. some of these
// are removed in jet500.dll - those are commented out.
//
enum {
    LoadJet200 = 0,
    LoadJet500 = 1,
    LoadJet600 = 2,
    };

typedef enum {
    _JetAttachDatabase
    ,_JetBeginSession
    ,_JetCompact
    ,_JetDetachDatabase
    ,_JetEndSession
    ,_JetInit
    ,_JetSetSystemParameter
    ,_JetTerm
    ,_JetTerm2
    ,_JetLastFunc
} JETFUNC_TABLE_INDEX;

#define JetAttachDatabase              (JET_ERR)(*(JetFuncTable[ _JetAttachDatabase       ].pFAdd))
#define JetBeginSession                (JET_ERR)(*(JetFuncTable[ _JetBeginSession         ].pFAdd))
#define JetCompact                     (JET_ERR)(*(JetFuncTable[ _JetCompact              ].pFAdd))
#define JetDetachDatabase              (JET_ERR)(*(JetFuncTable[ _JetDetachDatabase       ].pFAdd))
#define JetEndSession                  (JET_ERR)(*(JetFuncTable[ _JetEndSession           ].pFAdd))
#define JetInit                        (JET_ERR)(*(JetFuncTable[ _JetInit                 ].pFAdd))
#define JetSetSystemParameter          (JET_ERR)(*(JetFuncTable[ _JetSetSystemParameter   ].pFAdd))
#define JetTerm                        (JET_ERR)(*(JetFuncTable[ _JetTerm                 ].pFAdd))
#define JetTerm2                       (JET_ERR)(*(JetFuncTable[ _JetTerm2                ].pFAdd))

#endif _COMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\inc\disp.h ===
/***********************************************************************
* Microsoft Jet
*
* Microsoft Confidential.  Copyright 1991-1992 Microsoft Corporation.
*
* Component: VDB and VT Dispatchers
*
* File: disp.h
*
* File Comments:
*
*     External header file for VDB and VT dispatchers.
*
* Revision History:
*
*    [0]  17-Oct-90  richards	Created
*
***********************************************************************/

#ifndef DISP_H
#define DISP_H

#include "vdbapi.h"
#include "vtapi.h"


	/* The following APIs are ISAM APIs are are dispatched using the */
	/* DBID parameter.  For more information see vdbapi.h */

extern VDBFNCapability		ErrDispCapability;
extern VDBFNCloseDatabase	ErrDispCloseDatabase;
extern VDBFNCreateObject	ErrDispCreateObject;
extern VDBFNCreateTable 	ErrDispCreateTable;
extern VDBFNDeleteObject	ErrDispDeleteObject;
extern VDBFNDeleteTable 	ErrDispDeleteTable;
extern VDBFNExecuteSql		ErrDispExecuteSql;
extern VDBFNGetColumnInfo	ErrDispGetColumnInfo;
extern VDBFNGetDatabaseInfo	ErrDispGetDatabaseInfo;
extern VDBFNGetIndexInfo	ErrDispGetIndexInfo;
extern VDBFNGetObjectInfo	ErrDispGetObjectInfo;
extern VDBFNGetReferenceInfo	ErrDispGetReferenceInfo;
extern VDBFNOpenTable		ErrDispOpenTable;
extern VDBFNRenameObject	ErrDispRenameObject;
extern VDBFNRenameTable 	ErrDispRenameTable;
extern VDBFNGetObjidFromName	ErrDispGetObjidFromName;



	/* The following APIs are VT APIs are are dispatched using the */
	/* TABLEID parameter.  For more information see vtapi.h */

extern VTFNAddColumn			ErrDispAddColumn;
extern VTFNCloseTable			ErrDispCloseTable;
extern VTFNComputeStats 		ErrDispComputeStats;
extern VTFNCopyBookmarks		ErrDispCopyBookmarks;
extern VTFNCreateIndex			ErrDispCreateIndex;
extern VTFNCreateReference		ErrDispCreateReference;
extern VTFNDelete			ErrDispDelete;
extern VTFNDeleteColumn 		ErrDispDeleteColumn;
extern VTFNDeleteIndex			ErrDispDeleteIndex;
extern VTFNDeleteReference		ErrDispDeleteReference;
extern VTFNDupCursor			ErrDispDupCursor;
extern VTFNEmptyTable			ErrDispEmptyTable;
extern VTFNGetBookmark			ErrDispGetBookmark;
extern VTFNGetChecksum			ErrDispGetChecksum;
extern VTFNGetCurrentIndex		ErrDispGetCurrentIndex;
extern VTFNGetCursorInfo		ErrDispGetCursorInfo;
extern VTFNGetRecordPosition		ErrDispGetRecordPosition;
extern VTFNGetTableColumnInfo		ErrDispGetTableColumnInfo;
extern VTFNGetTableIndexInfo		ErrDispGetTableIndexInfo;
extern VTFNGetTableReferenceInfo	ErrDispGetTableReferenceInfo;
extern VTFNGetTableInfo 		ErrDispGetTableInfo;
extern VTFNGotoBookmark 		ErrDispGotoBookmark;
extern VTFNGotoPosition 		ErrDispGotoPosition;
extern VTFNVtIdle			ErrDispVtIdle;
extern VTFNMakeKey			ErrDispMakeKey;
extern VTFNMove 			ErrDispMove;
extern VTFNNotifyBeginTrans		ErrDispNotifyBeginTrans;
extern VTFNNotifyCommitTrans		ErrDispNotifyCommitTrans;
extern VTFNNotifyRollback		ErrDispNotifyRollback;
extern VTFNNotifyUpdateUfn		ErrDispNotifyUpdateUfn;
extern VTFNPrepareUpdate		ErrDispPrepareUpdate;
extern VTFNRenameColumn 		ErrDispRenameColumn;
extern VTFNRenameIndex			ErrDispRenameIndex;
extern VTFNRenameReference		ErrDispRenameReference;
extern VTFNRetrieveColumn		ErrDispRetrieveColumn;
extern VTFNRetrieveKey			ErrDispRetrieveKey;
extern VTFNSeek 			ErrDispSeek;
extern VTFNSetCurrentIndex		ErrDispSetCurrentIndex;
extern VTFNSetColumn			ErrDispSetColumn;
extern VTFNSetIndexRange		ErrDispSetIndexRange;
extern VTFNUpdate			ErrDispUpdate;

#endif	/* !DISP_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\compact\test.h ===
#define	crecordTable1Max		1000
#define	crecordTable2Max		200
#define	crecordT1Present		506
#define	crecordT1Present2		253

#define	cbMaxKeyLen				255
#define	cbMaxFieldLen			1024
#define	cbKeyMax					255

#define columnidF1Const 		1L
#define columnidF2Const			2L
#define columnidF3Const 		3L
#define columnidV1Const 		128L
#define columnidT1Const 		256L
#define columnidT2Const 		257L

#define	fCompareF1	 			( 1<<0 )
#define	fCompareF2	 			( 1<<1 )
#define	fCompareF3	 			( 1<<2 )
#define	fCompareV1	 			( 1<<3 )
#define	fCompareT1	 			( 1<<4 )
#define	fCompareT2	 			( 1<<5 )

#define	szUser					"admin"
#define	szPassword				"\0"
#define	szUser2					"dummy"
#define	szPassword2			"opensesame"

#define	szDB1						"db1"
#define	szDB2						"db2.mdb"

#define	szTable1					"table1"
#define	szTable2					"table2"

#define	szF1Name					"F1"
#define	szF2Name					"F2"
#define	szF3Name					"F3"
#define	szV1Name					"V1"
#define	szT1Name					"T1"
#define	szT2Name					"T2"
				 	
#define	szXF1Name				"XF1"
#define	szXF3F2Name				"XF3F2"
#define	szXV1Name				"XV1"
#define	szXT1Name				"XT1"
#define	szXT2Name				"XT2"

#define Call( fn )	{ if ( ( err = fn ) < 0  ) goto HandleError; }

void MakeRecordColumns( long irec, long *pwF1, char *pbF2, long *plF3, char **ppbInV1, unsigned long	*pcbInV1, char **ppbInT1, unsigned long *pcbInT1, unsigned long *plT2 );
void ValidateColumns( JET_SESID sesid, long irec, long fCompare, long itagSequence, JET_TABLEID tableid );
void ValidateTable1Record( JET_SESID sesid, JET_TABLEID tableid, long irec );
void ValidateTable2Record( JET_SESID sesid, JET_TABLEID tableid, long irec );
void SetTime( long *pdwSetTime );
void GetTime( long *pdwSetTime, long *pdwSec, long *pdwMSec );

char szResult[256];

#define	usUniCodePage			1200		/* code page for Unicode strings */
#define	usEnglishCodePage		1252		/* code page for English */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\inc\isamapi.h ===
/***********************************************************************
* Microsoft Jet
*
* Microsoft Confidential.  Copyright 1991-1992 Microsoft Corporation.
*
* Component: Installable ISAM Manager
*
* File: isamapi.h
*
* File Comments:
*
*     External header file for Installable ISAMs.
*
* Revision History:
*
*    [0]  04-Jan-92  richards	Added this header
*
***********************************************************************/

#ifndef ISAMAPI_H
#define ISAMAPI_H

#ifdef	WIN32 		       /* 0:32 Flat Model (Intel 80x86) */

#pragma message ("ISAMAPI is __cdecl")

#define ISAMAPI __cdecl

#elif	defined(M_MRX000)	       /* 0:32 Flat Model (MIPS Rx000) */

#define ISAMAPI

#else	/* !WIN32 */		       /* 16:16 Segmented Model */

#ifdef	_MSC_VER

#ifdef	JETINTERNAL

#define ISAMAPI __far __pascal

#else	/* !JETINTERNAL */

#define ISAMAPI __far __pascal __loadds  /* Installable ISAMs need __loadds */

#endif	/* !JETINTERNAL */

#else	/* !_MSC_VER */

#define ISAMAPI export

#endif	/* !_MSC_VER */

#endif	/* !WIN32 */


#define ISAMAPI_VERSION 1

typedef struct
	{
	JET_COLUMNID columnidSrc;
	JET_COLUMNID columnidDest;
	} CPCOL;

#define columnidBookmark 0xFFFFFFFF


	/* Typedefs for dispatched APIs. */
	/* Please keep in alphabetical order */

typedef ERR ISAMAPI ISAMFNAttachDatabase(JET_VSESID sesid, const char __far *szFileName, JET_GRBIT grbit );

typedef ERR ISAMAPI ISAMFNBackup( const char __far *szBackupPath, JET_GRBIT grbit );

typedef ERR ISAMAPI ISAMFNBeginSession(JET_VSESID __far *pvsesid);

typedef ERR ISAMAPI ISAMFNSetSessionInfo( JET_VSESID sesid, JET_GRBIT grbit );

typedef ERR ISAMAPI ISAMFNSetWaitLogFlush( JET_VSESID sesid, long lmsec );

typedef ERR ISAMAPI ISAMFNBeginTransaction(JET_VSESID sesid);

typedef ERR ISAMAPI ISAMFNCommitTransaction(JET_VSESID sesid, JET_GRBIT grbit);

typedef ERR ISAMAPI ISAMFNCopyRecords(JET_VSESID sesid, JET_TABLEID tableidSrc,
		JET_TABLEID tableidDest, CPCOL __far *rgcpcol, unsigned long ccpcolMax,
		long crecMax, unsigned long __far *pcrowCopy, unsigned long __far *precidLast);

typedef ERR ISAMAPI ISAMFNCreateDatabase(JET_VSESID sesid,
	const char __far *szDatabase, const char __far *szConnect,
	JET_DBID __far *pdbid, JET_GRBIT grbit);

typedef ERR ISAMAPI ISAMFNDetachDatabase(JET_VSESID sesid, const char __far *szFileName);

typedef ERR ISAMAPI ISAMFNEndSession(JET_VSESID sesid, JET_GRBIT grbit);

typedef ERR ISAMAPI ISAMFNIdle(JET_VSESID sesid, JET_GRBIT grbit);

typedef ERR ISAMAPI ISAMFNIndexRecordCount(JET_SESID sesid,
	JET_TABLEID tableid, unsigned long __far *pcrec, unsigned long crecMax);

typedef ERR ISAMAPI ISAMFNInit( int itib );

typedef ERR ISAMAPI ISAMFNLoggingOn(JET_VSESID sesid);

typedef ERR ISAMAPI ISAMFNLoggingOff(JET_VSESID sesid);

typedef ERR ISAMAPI ISAMFNOpenDatabase(JET_VSESID sesid,
	const char __far *szDatabase, const char __far *szConnect,
	JET_DBID __far *pdbid, JET_GRBIT grbit);

typedef ERR ISAMAPI ISAMFNOpenTempTable(JET_VSESID sesid,
	const JET_COLUMNDEF __far *prgcolumndef, unsigned long ccolumn,
	JET_GRBIT grbit, JET_TABLEID __far *ptableid,
	JET_COLUMNID __far *prgcolumnid);

typedef ERR ISAMAPI ISAMFNRepairDatabase(JET_VSESID sesid, const char __far *szFilename,
	JET_PFNSTATUS pfnStatus);

typedef ERR ISAMAPI ISAMFNRestore(	char *szRestoreFromPath,
	int crstmap, JET_RSTMAP *rgrstmap, JET_PFNSTATUS pfn );

typedef ERR ISAMAPI ISAMFNRollback(JET_VSESID sesid, JET_GRBIT grbit);

typedef ERR ISAMAPI ISAMFNSetSystemParameter(JET_VSESID sesid,
	unsigned long paramid, unsigned long l, const void __far *sz);

typedef ERR ISAMAPI ISAMFNTerm(void);

typedef ERR ISAMAPI FNDeleteFile(const char __far *szFilename);

typedef struct ISAMDEF {
   ISAMFNAttachDatabase 		*pfnAttachDatabase;
   ISAMFNBackup 			*pfnBackup;
   ISAMFNBeginSession			*pfnBeginSession;
   ISAMFNBeginTransaction		*pfnBeginTransaction;
   ISAMFNCommitTransaction		*pfnCommitTransaction;
   ISAMFNCreateDatabase 		*pfnCreateDatabase;
   ISAMFNDetachDatabase 		*pfnDetachDatabase;
   ISAMFNEndSession			*pfnEndSession;
   ISAMFNIdle				*pfnIdle;
   ISAMFNInit				*pfnInit;
   ISAMFNLoggingOn			*pfnLoggingOn;
   ISAMFNLoggingOff			*pfnLoggingOff;
   ISAMFNOpenDatabase			*pfnOpenDatabase;
   ISAMFNOpenTempTable			*pfnOpenTempTable;
   ISAMFNRepairDatabase 		*pfnRepairDatabase;
   ISAMFNRestore			*pfnRestore;
   ISAMFNRollback			*pfnRollback;
   ISAMFNSetSystemParameter		*pfnSetSystemParameter;
   ISAMFNTerm				*pfnTerm;
} ISAMDEF;


	/* The following ISAM APIs are not dispatched */

typedef ERR ISAMAPI ISAMFNLoad(ISAMDEF __far * __far *ppisamdef);


	/* Declarations for the built-in ISAM which is called directly. */

extern ISAMFNAttachDatabase		ErrIsamAttachDatabase;
extern ISAMFNBackup			ErrIsamBackup;
extern ISAMFNBeginSession		ErrIsamBeginSession;
extern ISAMFNSetSessionInfo		ErrIsamSetSessionInfo;
extern ISAMFNSetWaitLogFlush	ErrIsamSetWaitLogFlush;
extern ISAMFNBeginTransaction		ErrIsamBeginTransaction;
extern ISAMFNCommitTransaction		ErrIsamCommitTransaction;
extern ISAMFNCopyRecords		ErrIsamCopyRecords;
extern ISAMFNCreateDatabase		ErrIsamCreateDatabase;
extern ISAMFNDetachDatabase		ErrIsamDetachDatabase;
extern ISAMFNEndSession 		ErrIsamEndSession;
extern ISAMFNIdle			ErrIsamIdle;
extern ISAMFNIndexRecordCount		ErrIsamIndexRecordCount;
extern ISAMFNInit			ErrIsamInit;
extern ISAMFNLoggingOn			ErrIsamLoggingOn;
extern ISAMFNLoggingOff 		ErrIsamLoggingOff;
extern ISAMFNOpenDatabase		ErrIsamOpenDatabase;
extern ISAMFNOpenTempTable		ErrIsamOpenTempTable;
extern ISAMFNRepairDatabase		ErrIsamRepairDatabase;
extern ISAMFNRestore			ErrIsamRestore;
extern ISAMFNRollback			ErrIsamRollback;
extern ISAMFNSetSystemParameter 	ErrIsamSetSystemParameter;
extern ISAMFNTerm			ErrIsamTerm;
extern FNDeleteFile			ErrDeleteFile;

#endif	/* !ISAMAPI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\inc\jetdef.h ===
/*	bogus include for jet project compatibility
/**/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\inc\taskmgr.h ===
/*	bogus include file for jet compatibility
/**/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\inc\jetord.h ===
#define	ordJetAddColumn					101
#define	ordJetAttachDatabase				102
#define	ordJetBackup						103
#define	ordJetBeginSession 				104
#define	ordJetBeginTransaction			105
#define	ordJetCapability					106
#define	ordJetCloseDatabase				107
#define	ordJetCloseTable					108
#define	ordJetCommitTransaction			109
#define	ordJetCompact						110
#define	ordJetComputeStats 				111
#define	ordJetCreateDatabase				112
#define	ordJetCreateIndex					113
#define	ordJetCreateObject 				114
#define	ordJetCreateTable					115
#define	ordJetDelete						116
#define	ordJetDeleteColumn 				117
#define	ordJetDeleteIndex					118
#define	ordJetDeleteObject 				119
#define	ordJetDeleteTable					120
#define	ordJetDetachDatabase				121
#define	ordJetDupCursor					122
#define	ordJetDupSession					123
#define	ordJetEndSession					124
#define	ordJetGetBookmark					125
#define	ordJetGetChecksum					126
#define	ordJetGetColumnInfo				127
#define	ordJetGetCurrentIndex			128
#define	ordJetGetCursorInfo				129
#define	ordJetGetDatabaseInfo			130
#define	ordJetGetIndexInfo 				131
#define	ordJetGetLastErrorInfo			132
#define	ordJetGetObjidFromName			133
#define	ordJetGetObjectInfo				134
#define	ordJetGetRecordPosition			135
#define	ordJetGetSystemParameter		136
#define	ordJetGetTableColumnInfo		137
#define	ordJetGetTableIndexInfo			138
#define	ordJetGetTableInfo 				139
#define	ordJetGetVersion					140
#define	ordJetGotoBookmark 				141
#define	ordJetGotoPosition 				142
#define	ordJetIdle 							143
#define	ordJetIndexRecordCount			144
#define	ordJetInit 							145
#define	ordJetMakeKey						146
#define	ordJetMove 							147
#define	ordJetOpenDatabase 				148
#define	ordJetOpenTable					149
#define	ordJetOpenTempTable				150
#define	ordJetPrepareUpdate				151
#define	ordJetRenameColumn 				152
#define	ordJetRenameIndex					153
#define	ordJetRenameObject				154
#define	ordJetRenameTable					155
#define	ordJetRestore						156
#define	ordJetRetrieveColumn				157
#define	ordJetRetrieveColumns    		158
#define	ordJetRetrieveKey					159
#define	ordJetRollback						160
#define	ordJetSeek 							161
#define	ordJetSetColumn					162
#define	ordJetSetColumns					163
#define	ordJetSetCurrentIndex			164
#define	ordJetSetSystemParameter		165
#define	ordJetSetIndexRange				166
#define	ordJetTerm 							167
#define	ordJetUpdate						168
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\inc\isammgr.h ===
/***********************************************************************
* Microsoft Jet
*
* Microsoft Confidential.  Copyright 1991-1992 Microsoft Corporation.
*
* Component: Installable ISAM Manager
*
* File: isammgr.h
*
* File Comments:
*
*     External header for the installable ISAM manager.
*
* Revision History:
*
*    [0]  24-May-91  bobcr	Created
*
***********************************************************************/

#ifndef ISAMMGR_H
#define ISAMMGR_H

/* Data Types */

typedef unsigned IIT;		       /* Installable ISAM type */

/* Constants */

#define iitBuiltIn	((IIT) 0xFFFF) /* ISAM type for built-in ISAM */
#define iitODBC 	((IIT) 0xFFFE) /* ISAM type for ODBC */

/* Function Prototypes */

ERR ErrIsammgrInit(void);
ERR ErrIsammgrTerm(void);

ERR ErrGetIsamType(const char __far *szConnect, IIT __far *piit);

#ifdef	INSTISAM

ERR ErrGetIsamSesid(JET_SESID sesid, IIT iit, JET_VSESID __far *pvsesid);
ERR ErrOpenForeignDatabase(JET_SESID sesid, IIT iit, const char __far *szDatabase, const char *szClient, JET_DBID __far *pdibd, unsigned long grbit);

void CloseIsamSessions(JET_SESID sesid);

void BeginIsamTransactions(JET_SESID sesid);
void CommitIsamTransactions(JET_SESID sesid, JET_GRBIT grbit);
void RollbackIsamTransactions(JET_SESID sesid, JET_GRBIT grbit);
ERR  ErrIdleIsam(JET_SESID sesid);

#endif	/* INSTISAM */

#endif	/* !ISAMMGR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\inc\valtag.h ===
#define HardType	0x8000

#ifndef FV_VALUE
#define FV_VALUE 1		       /* Default ON */
#endif	/* !FV_VALUE */

#ifndef FV_CURRENCY
#define FV_CURRENCY -1		       /* Default ON */
#endif	/* !FV_CURRENCY */

enum {
#if	FV_VALUE
	tagEmpty,		       /* Uninitialized */
	tagNull,		       /* Database NULL */
#endif	/* FV_VALUE */
	tagI2,
	tagI4,
	tagR4,
	tagR8,
#if	FV_CURRENCY
	tagCY,
#endif	/* FV_CURRENCY */
#if	FV_VALUE
	tagDT,			       /* Date */
#endif	/* FV_VALUE */
	tagSD,			       /* String */
	tagOB,			       /* Object */
	tagR10, 		       /* Intermediate FP value */

	tagMaxNum = tagSD-1,
	tagMax = tagSD, 	       /* Max standard tag */
	tagMaxExt =tagR10	       /* Max extended tag */
};


	/* Operator constants for users of EB's expression service */

enum {
	operUMi = 0,
	operNot = 2,
	operAdd = 4,
	operSub = 6,
	operMul = 8,
	operDiv = 10,
	operPwr = 12,
	operMod = 14,
	operIDv = 16,
	operXor = 18,
	operEqv = 20,
	operComp= 22,
	operLike= 24,
	operConcat= 26
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\inc\sesmgr.h ===
/***********************************************************************
* Microsoft Jet
*
* Microsoft Confidential.  Copyright 1991-1992 Microsoft Corporation.
*
* Component: Session manager
*
* File: sesmgr.h
*
* File Comments:
*
*     External header file for the session manager
*
* Revision History:
*
*    [0]  26-Apr-92  richards	Split from _jet.h
*
***********************************************************************/


typedef struct SIB			/* Session Information Block */
	{
	JET_SESID	sesid;		/* The session ID for this session */
	JET_PFNSTATUS	pfnStatus;	/* Status callback function */
	JET_EXTERR	exterr; 	/* Extended error cache */
	char __far	*sz1;		/* Extended error cache */
	char __far	*sz2;		/* Extended error cache */
	char __far	*sz3;		/* Extended error cache */
#ifdef	SEC
	JET_DBID	dbidSys;	/* The DBID of the session's system database */
	void __far	*pUserToken;	/* Pointer to alloc'ed user token for session */
#endif	/* SEC */
	char __far	*pUserName;	/* Pointer to alloc'ed user name for session */
#ifdef	RMT
	unsigned long	hwndODBC;	/* Window handle */
#endif	/* RMT */
	int		isibNext;	/* Next SIB in chain */
	unsigned	tl;		/* Transaction level */
	int		iiscb;		/* Active installed ISAM chain */
	} SIB;

#define csibMax 256		/* CONSIDER */
extern SIB __near rgsib[csibMax];


int IsibAllocate(void);
JET_ERR ErrInitSib(JET_SESID sesid, int isib, const char __far *szUsername);
BOOL FValidSesid(JET_SESID sesid);
void ReleaseIsib(int isib);
int IsibNextIsibPsesid(int isib, JET_SESID __far *psesid);
int UtilGetIsibOfSesid(JET_SESID sesid);
void EXPORT UtilGetNameOfSesid(JET_SESID sesid, char __far *szUserName);
void EXPORT UtilGetpfnStatusOfSesid(JET_SESID sesid, JET_PFNSTATUS __far *ppfnStatus);

#ifdef	SEC

JET_DBID UtilGetDbidSysOfSesid(JET_SESID sesid);

#endif	/* SEC */

void ClearErrorInfo(JET_SESID sesid);

/* Cover macro to hide 3rd str arg unneeded by all but rmt */
#define UtilSetErrorInfo(sesid, sz1, sz2, err, ul1, ul2, ul3) \
	UtilSetErrorInfoReal(sesid, sz1, sz2, NULL, err, ul1, ul2, ul3)

void EXPORT UtilSetErrorInfoReal(JET_SESID sesid, const char __far *sz1, const char __far *sz2, const char __far *sz3, ERR err, unsigned long ul1, unsigned long ul2, unsigned long ul3);

#ifndef RETAIL

void AssertValidSesid(JET_SESID sesid);
void DebugListActiveSessions(void);

#endif	/* !RETAIL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\inc\std.h ===
/***********************************************************************
* Microsoft Jet
*
* Microsoft Confidential.  Copyright 1991-1992 Microsoft Corporation.
*
* Component: JET
*
* File: <File description/purpose>
*
* File Comments:
* <comments>
*
* Revision History:
*
*    [0]  18-Feb-92  richards	Created
*
***********************************************************************/

#include "config.h"		       /* Build configuration file */

	/* C 6.00A has a bug with PLM calling convention and /Od */
	/* that results in bad PUBDEF records.	To work around this */
	/* bug we need to specify /Ot which has the side effect of */
	/* causing some code reordering.  To work around this we */
	/* disable this optimization here. */

#include "jet.h"		       /* Public JET API definitions */
#include "_jet.h"		       /* Private JET definitions */

#include "sesmgr.h"

#include "isamapi.h"		       /* Direct ISAM APIs */
#include "vdbapi.h"		       /* Dispatched database APIs */
#include "vtapi.h"		       /* Dispatched table APIs */

#include "disp.h"		       /* ErrDisp prototypes */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\inc\vdbmgr.h ===
/***********************************************************************
* Microsoft Jet
*
* Microsoft Confidential.  Copyright 1991-1992 Microsoft Corporation.
*
* Component: VDB Dispatcher
*
* File: vdbmgr.h
*
* File Comments:
*
*     External header file for VDB Dispatcher.
*
* Revision History:
*
*    [0]  03-Apr-91  kellyb	Created
*
***********************************************************************/

	/* C6BUG: The EXPORTs are in this file only because QJET */
	/* C6BUG: fails when compiled with __fastcall under C 6.00A. */

ERR ErrVdbmgrInit(void);

ERR EXPORT ErrAllocateDbid(JET_DBID __far *pdbid, JET_VDBID vdbid, const struct tagVDBFNDEF __far *pvdbfndef);

ERR EXPORT ErrUpdateDbid(JET_DBID dbid, JET_VDBID vdbid, const struct tagVDBFNDEF __far *pvdbfndef);

PUBLIC BOOL EXPORT FValidDbid(JET_SESID sesid, JET_DBID dbid);

JET_DBID EXPORT DbidOfVdbid(JET_VDBID vdbid, const struct tagVDBFNDEF __far *pvdbfndef);

PUBLIC ERR EXPORT ErrVdbidOfDbid(JET_SESID sesid, JET_DBID dbid, JET_VDBID *pvdbid);

const struct tagVDBFNDEF *PvdbfndefOfDbid(JET_DBID dbid);
#define FJetDbid(dbid) (PvdbfndefOfDbid(dbid) == &vdbfndefIsam)
#define FRemoteDbid(dbid) (PvdbfndefOfDbid(dbid) == &vdbfndefRdb)

JET_SESID EXPORT VsesidOfDbid(JET_VDBID vdbid);

void EXPORT ReleaseDbid(JET_DBID dbid);


#ifndef RETAIL
void DebugListOpenDatabases(void);
#endif	/* RETAIL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\inc\vdbapi.h ===
/***********************************************************************
* Microsoft Jet
*
* Microsoft Confidential.  Copyright 1991-1992 Microsoft Corporation.
*
* Component: VDB Dispatcher
*
* File: vdbapi.h
*
* File Comments:
*
*     External header file for VDB providers.
*
* Revision History:
*
*    [0]  05-Nov-90  richards	Created
*
***********************************************************************/

#ifndef VDBAPI_H
#define VDBAPI_H

#ifdef	WIN32 		       /* 0:32 Flat Model (Intel 80x86) */

#pragma message ("VDBAPI is cdecl")
#define VDBAPI __cdecl

#elif	defined(M_MRX000)	       /* 0:32 Flat Model (MIPS Rx000) */

#define VDBAPI

#else	/* !WIN32 */		       /* 16:16 Segmented Model */

#ifdef	_MSC_VER

#ifdef	JETINTERNAL

#define VDBAPI __far __pascal

#else	/* !JETINTERNAL */

#define VDBAPI __far __pascal __loadds /* Installable ISAMs need __loadds */

#endif	/* !JETINTERNAL */

#else	/* !_MSC_VER */

#define VDBAPI export

#endif	/* !_MSC_VER */

#endif	/* !WIN32 */


	/* Typedefs for dispatched APIs. */
	/* Please keep in alphabetical order */

typedef ERR VDBAPI VDBFNCapability(JET_VSESID sesid, JET_VDBID vdbid,
	unsigned long lArea, unsigned long lFunction, JET_GRBIT __far *pgrbit);

typedef ERR VDBAPI VDBFNCloseDatabase(JET_VSESID sesid, JET_VDBID vdbid,
	JET_GRBIT grbit);

typedef ERR VDBAPI VDBFNCreateObject(JET_VSESID sesid, JET_VDBID vdbid,
	OBJID objidParentId, const char __far *szObjectName,
	JET_OBJTYP objtyp);

typedef ERR VDBAPI VDBFNCreateTable(JET_VSESID sesid, JET_VDBID vdbid,
	const char __far *szTableName, unsigned long lPages,
	unsigned long lDensity, JET_TABLEID __far *ptableid);

typedef ERR VDBAPI VDBFNDeleteObject(JET_VSESID sesid, JET_VDBID vdbid,
	OBJID objid);

typedef ERR VDBAPI VDBFNRenameObject(JET_VSESID sesid, JET_VDBID vdbid,
	const char __far *szContainerName, const char __far *szObjectName,
	const char __far *szObjectNew);

typedef ERR VDBAPI VDBFNDeleteTable(JET_VSESID sesid, JET_VDBID vdbid,
	const char __far *szTableName);

typedef ERR VDBAPI VDBFNExecuteSql(JET_VSESID sesid, JET_VDBID vdbid,
	const char __far *szSql);

typedef ERR VDBAPI VDBFNGetColumnInfo(JET_VSESID sesid, JET_VDBID vdbid,
	const char __far *szTableName, const char __far *szColumnName,
	OLD_OUTDATA __far *poutdata, unsigned long InfoLevel);

typedef ERR VDBAPI VDBFNGetDatabaseInfo(JET_VSESID sesid, JET_VDBID vdbid,
	void __far *pvResult, unsigned long cbMax, unsigned long InfoLevel);

typedef ERR VDBAPI VDBFNGetIndexInfo(JET_VSESID sesid, JET_VDBID vdbid,
	const char __far *szTableName, const char __far *szIndexName,
	OLD_OUTDATA __far *poutdata, unsigned long InfoLevel);

typedef ERR VDBAPI VDBFNGetObjectInfo(JET_VSESID sesid, JET_VDBID vdbid,
	JET_OBJTYP objtyp,
	const char __far *szContainerName, const char __far *szObjectName,
	OLD_OUTDATA __far *poutdataInfo, unsigned long InfoLevel);

typedef ERR VDBAPI VDBFNGetReferenceInfo(JET_VSESID sesid, JET_VDBID vdbid,
	const char __far *szTableName, const char __far *szReferenceName,
	void __far *pvResult, unsigned long cbResult,
	unsigned long InfoLevel);

typedef ERR VDBAPI VDBFNOpenTable(JET_VSESID sesid, JET_VDBID vdbid,
	JET_TABLEID __far *ptableid, const char __far *szTableName,
	JET_GRBIT grbit);

typedef ERR VDBAPI VDBFNRenameTable(JET_VSESID sesid, JET_VDBID vdbid,
	const char __far *szTableName, const char __far *szTableNew);

typedef ERR VDBAPI VDBFNGetObjidFromName(JET_VSESID sesid, JET_VDBID vdbid,
	const char __far *szContainerName, const char __far *szObjectName,
	OBJID __far *pobjid);

	/* The following structure is that used to allow dispatching to */
	/* a DB provider.  Each DB provider must create an instance of */
	/* this structure and give the pointer to this instance when */
	/* allocating a database id. */

typedef struct VDBDBGDEF {
	unsigned short			cbStruct;
	unsigned short			filler;
	char						szName[32];
	unsigned long			dwRFS;
	unsigned long			dwRFSMask[4];
} VDBDBGDEF;

	/* Please keep entries in alphabetical order */

typedef struct tagVDBFNDEF{
	unsigned short		cbStruct;
	unsigned short		filler;
	const VDBDBGDEF __far	*pvdbdbgdef;
	VDBFNCapability 	*pfnCapability;
	VDBFNCloseDatabase	*pfnCloseDatabase;
	VDBFNCreateObject	*pfnCreateObject;
	VDBFNCreateTable	*pfnCreateTable;
	VDBFNDeleteObject	*pfnDeleteObject;
	VDBFNDeleteTable	*pfnDeleteTable;
	VDBFNExecuteSql 	*pfnExecuteSql;
	VDBFNGetColumnInfo	*pfnGetColumnInfo;
	VDBFNGetDatabaseInfo	*pfnGetDatabaseInfo;
	VDBFNGetIndexInfo	*pfnGetIndexInfo;
	VDBFNGetObjectInfo	*pfnGetObjectInfo;
	VDBFNGetReferenceInfo	*pfnGetReferenceInfo;
	VDBFNOpenTable		*pfnOpenTable;
	VDBFNRenameObject	*pfnRenameObject;
	VDBFNRenameTable	*pfnRenameTable;
	VDBFNGetObjidFromName	*pfnGetObjidFromName;
} VDBFNDEF;


	/* The following entry points are to be used by ISAM providers */
	/* in their ISAMDEF structures for any function that is not */
	/* provided.  These functions return JET_errIllegalOperation */


extern VDBFNCapability		ErrIllegalCapability;
extern VDBFNCloseDatabase	ErrIllegalCloseDatabase;
extern VDBFNCreateObject	ErrIllegalCreateObject;
extern VDBFNCreateTable 	ErrIllegalCreateTable;
extern VDBFNDeleteObject	ErrIllegalDeleteObject;
extern VDBFNDeleteTable 	ErrIllegalDeleteTable;
extern VDBFNExecuteSql		ErrIllegalExecuteSql;
extern VDBFNGetColumnInfo	ErrIllegalGetColumnInfo;
extern VDBFNGetDatabaseInfo	ErrIllegalGetDatabaseInfo;
extern VDBFNGetIndexInfo	ErrIllegalGetIndexInfo;
extern VDBFNGetObjectInfo	ErrIllegalGetObjectInfo;
extern VDBFNGetReferenceInfo	ErrIllegalGetReferenceInfo;
extern VDBFNOpenTable		ErrIllegalOpenTable;
extern VDBFNRenameObject	ErrIllegalRenameObject;
extern VDBFNRenameTable 	ErrIllegalRenameTable;
extern VDBFNGetObjidFromName	ErrIllegalGetObjidFromName;


#endif	/* !VDBAPI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\inc\version.h ===
#define rmj		203
#define rmm		6
#define rup		0
#define szVerName	""
#define szVerUser	"IANJO1"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\inc\verstamp.h ===
/***********************************************************************
* Microsoft Jet
*
* Microsoft Confidential.  Copyright 1991-1992 Microsoft Corporation.
*
* Component:
*
* File: verstamp.h
*
* File Comments:
*
*     Header file used to define Windows version resource.
*
* Revision History:
*
*    [0]  23-Nov-91  richards	Created
*
***********************************************************************/

#include "version.h"		       /* SLM maintained version file */

#ifdef	WIN32
#include <winver.h>
#else	/* !WIN32 */
#include <ver.h>
#endif	/* !WIN32 */

#if	(rmm < 10)
#define rmmpad "0"
#else
#define rmmpad
#endif

#if	(rup == 0)

#define VERSION_STR1(a,b,c)	    #a "." rmmpad #b

#else	/* !(rup == 0) */

#define VERSION_STR1(a,b,c)	    #a "." rmmpad #b "." ruppad #c

#if	(rup < 10)
#define ruppad "000"
#elif	(rup < 100)
#define ruppad "00"
#elif	(rup < 1000)
#define ruppad "0"
#else
#define ruppad
#endif

#endif	/* !(rup == 0) */

#define VERSION_STR2(a,b,c)	    VERSION_STR1(a,b,c)
#define VER_PRODUCTVERSION_STR	    VERSION_STR2(rmj,rmm,rup)
#define VER_PRODUCTVERSION	    rmj,rmm,0,rup

/*--------------------------------------------------------------*/
/* the following section defines values used in the version	*/
/* data structure for all files, and which do not change.	*/
/*--------------------------------------------------------------*/

#ifdef	RETAIL
#define VER_DEBUG		    0
#else
#define VER_DEBUG		    VS_FF_DEBUG
#endif

#if	(rup == 0)		    /* CONSIDER */
#define VER_PRIVATEBUILD	    0
#else
#define VER_PRIVATEBUILD	    VS_FF_PRIVATEBUILD
#endif

#if	(rup == 0)
#define VER_PRERELEASE		    0
#else
#define VER_PRERELEASE		    VS_FF_PRERELEASE
#endif

#define VER_FILEFLAGSMASK	    VS_FFI_FILEFLAGSMASK
#define VER_FILEOS		    VOS_DOS_WINDOWS16
#define VER_FILEFLAGS		    (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR	    "Microsoft Corporation"
#define VER_PRODUCTNAME_STR	    "Microsoft\256 JET Engine"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation."
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\inc\vtapi.h ===
/***********************************************************************
* Microsoft Jet
*
* Microsoft Confidential.  Copyright 1991-1992 Microsoft Corporation.
*
* Component: VT Dispatcher
*
* File: vtapi.h
*
* File Comments:
*
*     External header file for VT providers.
*
* Revision History:
*
*    [0]  17-Oct-90  richards	Created
*
***********************************************************************/

#ifndef VTAPI_H
#define VTAPI_H

#ifdef	WIN32 		       /* 0:32 Flat Model (Intel 80x86) */

#define VTAPI __cdecl

#elif	defined(M_MRX000)	       /* 0:32 Flat Model (MIPS Rx000) */

#define VTAPI

#else	/* !WIN32 */		       /* 16:16 Segmented Model */

#ifdef	_MSC_VER

#ifdef	JETINTERNAL

#define VTAPI __far __pascal

#else	/* !JETINTERNAL */

#define VTAPI __far __pascal __loadds  

#endif	/* !JETINTERNAL */

#else	/* !_MSC_VER */

#define VTAPI export

#endif	/* !_MSC_VER */

#endif	/* !WIN32 */


	/* Typedefs for dispatched APIs. */
	/* Please keep in alphabetical order */

typedef ERR VTAPI VTFNAddColumn(JET_VSESID sesid, JET_VTID vtid,
	const char __far *szColumn, const JET_COLUMNDEF __far *pcolumndef,
	const void __far *pvDefault, unsigned long cbDefault,
	JET_COLUMNID __far *pcolumnid);

typedef ERR VTAPI VTFNCloseTable(JET_VSESID sesid, JET_VTID vtid);

typedef ERR VTAPI VTFNComputeStats(JET_VSESID sesid, JET_VTID vtid);

typedef ERR VTAPI VTFNCopyBookmarks(JET_SESID sesid, JET_VTID vtidSrc, 
	JET_TABLEID tableidDest, JET_COLUMNID columnidDest,
	unsigned long crecMax);

typedef ERR VTAPI VTFNCreateIndex(JET_VSESID sesid, JET_VTID vtid,
	const char __far *szIndexName, JET_GRBIT grbit,
	const char __far *szKey, unsigned long cbKey, unsigned long lDensity);

typedef ERR VTAPI VTFNCreateReference(JET_VSESID sesid, JET_VTID vtid,
	const char __far *szReferenceName, const char __far *szColumns,
	const char __far *szReferencedTable,
	const char __far *szReferencedColumns, JET_GRBIT grbit);

typedef ERR VTAPI VTFNDelete(JET_VSESID sesid, JET_VTID vtid);

typedef ERR VTAPI VTFNDeleteColumn(JET_VSESID sesid, JET_VTID vtid,
	const char __far *szColumn);

typedef ERR VTAPI VTFNDeleteIndex(JET_VSESID sesid, JET_VTID vtid,
	const char __far *szIndexName);

typedef ERR VTAPI VTFNDeleteReference(JET_VSESID sesid, JET_VTID vtid,
	const char __far *szReferenceName);

typedef ERR VTAPI VTFNDupCursor(JET_VSESID sesid, JET_VTID vtid,
	JET_TABLEID __far *ptableid, JET_GRBIT grbit);

typedef ERR VTAPI VTFNEmptyTable(JET_VSESID sesid, JET_VTID vtid);

typedef ERR VTAPI VTFNGetBookmark(JET_VSESID sesid, JET_VTID vtid,
	void __far *pvBookmark, unsigned long cbMax,
	unsigned long __far *pcbActual);

typedef ERR VTAPI VTFNGetChecksum(JET_VSESID sesid, JET_VTID vtid,
	unsigned long __far *pChecksum);

typedef ERR VTAPI VTFNGetCurrentIndex(JET_VSESID sesid, JET_VTID vtid,
	char __far *szIndexName, unsigned long cchIndexName);

typedef ERR VTAPI VTFNGetCursorInfo(JET_VSESID sesid, JET_VTID vtid,
	void __far *pvResult, unsigned long cbMax, unsigned long InfoLevel);

typedef ERR VTAPI VTFNGetRecordPosition(JET_VSESID sesid, JET_VTID vtid,
	JET_RECPOS __far *pkeypos, unsigned long cbKeypos);

typedef ERR VTAPI VTFNGetTableColumnInfo(JET_VSESID sesid, JET_VTID vtid,
	const char __far *szColumnName, void __far *pvResult,
	unsigned long cbMax, unsigned long InfoLevel);

typedef ERR VTAPI VTFNGetTableIndexInfo(JET_VSESID sesid, JET_VTID vtid,
	const char __far *szIndexName, void __far *pvResult,
	unsigned long cbMax, unsigned long InfoLevel);

typedef ERR VTAPI VTFNGetTableReferenceInfo(JET_VSESID sesid, JET_VTID vtid,
	const char __far *szReferenceName, void __far *pvResult,
	unsigned long cbMax, unsigned long InfoLevel);

typedef ERR VTAPI VTFNGetTableInfo(JET_VSESID sesid, JET_VTID vtid,
	void __far *pvResult, unsigned long cbMax, unsigned long InfoLevel);

typedef ERR VTAPI VTFNGotoBookmark(JET_VSESID sesid, JET_VTID vtid,
	void __far *pvBookmark, unsigned long cbBookmark);

typedef ERR VTAPI VTFNGotoPosition(JET_VSESID sesid, JET_VTID vtid,
	JET_RECPOS *precpos);

typedef ERR VTAPI VTFNVtIdle(JET_VSESID sesid, JET_VTID vtid);

typedef ERR VTAPI VTFNMakeKey(JET_VSESID sesid, JET_VTID vtid,
	const void __far *pvData, unsigned long cbData, JET_GRBIT grbit);

typedef ERR VTAPI VTFNMove(JET_VSESID sesid, JET_VTID vtid,
	long cRow, JET_GRBIT grbit);

typedef ERR VTAPI VTFNNotifyBeginTrans(JET_VSESID sesid, JET_VTID vtid);

typedef ERR VTAPI VTFNNotifyCommitTrans(JET_VSESID sesid, JET_VTID vtid,
	JET_GRBIT grbit);

typedef ERR VTAPI VTFNNotifyRollback(JET_VSESID sesid, JET_VTID vtid,
	JET_GRBIT grbit);

typedef ERR VTAPI VTFNNotifyUpdateUfn(JET_VSESID sesid, JET_VTID vtid);

typedef ERR VTAPI VTFNPrepareUpdate(JET_VSESID sesid, JET_VTID vtid,
	unsigned long prep);

typedef ERR VTAPI VTFNRenameColumn(JET_VSESID sesid, JET_VTID vtid,
	const char __far *szColumn, const char __far *szColumnNew);

typedef ERR VTAPI VTFNRenameIndex(JET_VSESID sesid, JET_VTID vtid,
	const char __far *szIndex, const char __far *szIndexNew);

typedef ERR VTAPI VTFNRenameReference(JET_VSESID sesid, JET_VTID vtid,
	const char __far *szReference, const char __far *szReferenceNew);

typedef ERR VTAPI VTFNRetrieveColumn(JET_VSESID sesid, JET_VTID vtid,
	JET_COLUMNID columnid, void __far *pvData, unsigned long cbData,
	unsigned long __far *pcbActual, JET_GRBIT grbit,
	JET_RETINFO __far *pretinfo);

typedef ERR VTAPI VTFNRetrieveKey(JET_VSESID sesid, JET_VTID vtid,
	void __far *pvKey, unsigned long cbMax,
	unsigned long __far *pcbActual, JET_GRBIT grbit);

typedef ERR VTAPI VTFNSeek(JET_VSESID sesid, JET_VTID vtid, JET_GRBIT grbit);

typedef ERR VTAPI VTFNSetCurrentIndex(JET_VSESID sesid, JET_VTID vtid,
	const char __far *szIndexName);

typedef ERR VTAPI VTFNSetColumn(JET_VSESID sesid, JET_VTID vtid,
	JET_COLUMNID columnid, const void __far *pvData,
	unsigned long cbData, JET_GRBIT grbit, JET_SETINFO __far *psetinfo);

typedef ERR VTAPI VTFNSetIndexRange(JET_VSESID sesid, JET_VTID vtid,
	JET_GRBIT grbit);

typedef ERR VTAPI VTFNUpdate(JET_VSESID sesid, JET_VTID vtid,
	void __far *pvBookmark, unsigned long cbBookmark,
	unsigned long __far *pcbActual);


	/* The following structure is that used to allow dispatching to */
	/* a VT provider.  Each VT provider must create an instance of */
	/* this structure and give the pointer to this instance when */
	/* allocating a table id. */

typedef struct VTDBGDEF {
	unsigned short			cbStruct;
	unsigned short			filler;
	char				szName[32];
	unsigned long			dwRFS;
	unsigned long			dwRFSMask[4];
} VTDBGDEF;

	/* Please add to the end of the table */

typedef struct tagVTFNDEF {
	unsigned short			cbStruct;
	unsigned short			filler;
	const VTDBGDEF __far		*pvtdbgdef;
	VTFNAddColumn			*pfnAddColumn;
	VTFNCloseTable			*pfnCloseTable;
	VTFNComputeStats		*pfnComputeStats;
	VTFNCopyBookmarks		*pfnCopyBookmarks;
	VTFNCreateIndex 		*pfnCreateIndex;
	VTFNCreateReference		*pfnCreateReference;
	VTFNDelete			*pfnDelete;
	VTFNDeleteColumn		*pfnDeleteColumn;
	VTFNDeleteIndex 		*pfnDeleteIndex;
	VTFNDeleteReference		*pfnDeleteReference;
	VTFNDupCursor			*pfnDupCursor;
	VTFNGetBookmark 		*pfnGetBookmark;
	VTFNGetChecksum 		*pfnGetChecksum;
	VTFNGetCurrentIndex		*pfnGetCurrentIndex;
	VTFNGetCursorInfo		*pfnGetCursorInfo;
	VTFNGetRecordPosition		*pfnGetRecordPosition;
	VTFNGetTableColumnInfo		*pfnGetTableColumnInfo;
	VTFNGetTableIndexInfo		*pfnGetTableIndexInfo;
	VTFNGetTableInfo		*pfnGetTableInfo;
	VTFNGetTableReferenceInfo	*pfnGetTableReferenceInfo;
	VTFNGotoBookmark		*pfnGotoBookmark;
	VTFNGotoPosition		*pfnGotoPosition;
	VTFNVtIdle			*pfnVtIdle;
	VTFNMakeKey			*pfnMakeKey;
	VTFNMove			*pfnMove;
	VTFNNotifyBeginTrans		*pfnNotifyBeginTrans;
	VTFNNotifyCommitTrans		*pfnNotifyCommitTrans;
	VTFNNotifyRollback		*pfnNotifyRollback;
	VTFNNotifyUpdateUfn		*pfnNotifyUpdateUfn;
	VTFNPrepareUpdate		*pfnPrepareUpdate;
	VTFNRenameColumn		*pfnRenameColumn;
	VTFNRenameIndex 		*pfnRenameIndex;
	VTFNRenameReference		*pfnRenameReference;
	VTFNRetrieveColumn		*pfnRetrieveColumn;
	VTFNRetrieveKey 		*pfnRetrieveKey;
	VTFNSeek			*pfnSeek;
	VTFNSetCurrentIndex		*pfnSetCurrentIndex;
	VTFNSetColumn			*pfnSetColumn;
	VTFNSetIndexRange		*pfnSetIndexRange;
	VTFNUpdate			*pfnUpdate;
	VTFNEmptyTable		*pfnEmptyTable;
} VTFNDEF;


	/* The following entry points are to be used by VT providers */
	/* in their VTFNDEF structures for any function that is not */
	/* provided.  This functions return JET_errIllegalOperation */


extern VTFNAddColumn			ErrIllegalAddColumn;
extern VTFNCloseTable			ErrIllegalCloseTable;
extern VTFNComputeStats 		ErrIllegalComputeStats;
extern VTFNCopyBookmarks		ErrIllegalCopyBookmarks;
extern VTFNCreateIndex			ErrIllegalCreateIndex;
extern VTFNCreateReference		ErrIllegalCreateReference;
extern VTFNDelete			ErrIllegalDelete;
extern VTFNDeleteColumn 		ErrIllegalDeleteColumn;
extern VTFNDeleteIndex			ErrIllegalDeleteIndex;
extern VTFNDeleteReference		ErrIllegalDeleteReference;
extern VTFNDupCursor			ErrIllegalDupCursor;
extern VTFNEmptyTable			ErrIllegalEmptyTable;
extern VTFNGetBookmark			ErrIllegalGetBookmark;
extern VTFNGetChecksum			ErrIllegalGetChecksum;
extern VTFNGetCurrentIndex		ErrIllegalGetCurrentIndex;
extern VTFNGetCursorInfo		ErrIllegalGetCursorInfo;
extern VTFNGetRecordPosition		ErrIllegalGetRecordPosition;
extern VTFNGetTableColumnInfo		ErrIllegalGetTableColumnInfo;
extern VTFNGetTableIndexInfo		ErrIllegalGetTableIndexInfo;
extern VTFNGetTableInfo 		ErrIllegalGetTableInfo;
extern VTFNGetTableReferenceInfo	ErrIllegalGetTableReferenceInfo;
extern VTFNGotoBookmark 		ErrIllegalGotoBookmark;
extern VTFNGotoPosition			ErrIllegalGotoPosition;
extern VTFNVtIdle			ErrIllegalVtIdle;
extern VTFNMakeKey			ErrIllegalMakeKey;
extern VTFNMove 			ErrIllegalMove;
extern VTFNNotifyBeginTrans		ErrIllegalNotifyBeginTrans;
extern VTFNNotifyCommitTrans		ErrIllegalNotifyCommitTrans;
extern VTFNNotifyRollback		ErrIllegalNotifyRollback;
extern VTFNNotifyUpdateUfn		ErrIllegalNotifyUpdateUfn;
extern VTFNPrepareUpdate		ErrIllegalPrepareUpdate;
extern VTFNRenameColumn 		ErrIllegalRenameColumn;
extern VTFNRenameIndex			ErrIllegalRenameIndex;
extern VTFNRenameReference		ErrIllegalRenameReference;
extern VTFNRetrieveColumn		ErrIllegalRetrieveColumn;
extern VTFNRetrieveKey			ErrIllegalRetrieveKey;
extern VTFNSeek 			ErrIllegalSeek;
extern VTFNSetCurrentIndex		ErrIllegalSetCurrentIndex;
extern VTFNSetColumn			ErrIllegalSetColumn;
extern VTFNSetIndexRange		ErrIllegalSetIndexRange;
extern VTFNUpdate			ErrIllegalUpdate;

#endif	/* !VTAPI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\inc\vtmgr.h ===
/***********************************************************************
* Microsoft Jet
*
* Microsoft Confidential.  Copyright 1991-1992 Microsoft Corporation.
*
* Component: VT Dispatcher
*
* File: vtmgr.h
*
* File Comments:
*
*     External header file for the VT dispatcher.
*
* Revision History:
*
*    [0]  10-Nov-90  richards	Added this header
*
***********************************************************************/

	/* C6BUG: The EXPORTs are in this file only because QJET */
	/* C6BUG: fails when compiled with __fastcall under C 6.00A. */

ERR ErrVtmgrInit(void);

ERR EXPORT ErrAllocateTableid(JET_TABLEID __far *ptableid, JET_VTID vtid, const struct tagVTFNDEF __far *pvtfndef);

#ifdef	SEC

JET_ACM AcmDispGetACM(JET_SESID sesid, JET_TABLEID tableid);

ERR EXPORT ErrGetAcmTableid(JET_SESID sesid, JET_TABLEID tableid, JET_ACM __far *pacm);

ERR EXPORT ErrSetAcmTableid(JET_SESID sesid, JET_TABLEID tableid, JET_ACM acmMask, JET_ACM acmSet);

#endif	/* SEC */

ERR EXPORT ErrGetPvtfndefTableid(JET_SESID sesid, JET_TABLEID tableid, const struct tagVTFNDEF __far * __far *ppvtfndef);

ERR EXPORT ErrSetPvtfndefTableid(JET_SESID sesid, JET_TABLEID tableid, const struct tagVTFNDEF __far *pvtfndef);

ERR EXPORT ErrGetVtidTableid(JET_SESID sesid, JET_TABLEID tableid, JET_VTID __far *pvtid);

ERR EXPORT ErrSetVtidTableid(JET_SESID sesid, JET_TABLEID tableid, JET_VTID vtid);

	/* CONSIDER: Replace the following with the ErrGet/Set routines above */

ERR EXPORT ErrUpdateTableid(JET_TABLEID tableid, JET_VTID vtid, const struct tagVTFNDEF __far *pvtfndef);

void EXPORT ReleaseTableid(JET_TABLEID tableid);

	/* CONSIDER: This next routine should die. */

JET_TABLEID EXPORT TableidFromVtid(JET_VTID vtid, const struct tagVTFNDEF __far *pvtfndef);


void NotifyBeginTransaction(JET_SESID sesid);
void NotifyCommitTransaction(JET_SESID sesid, JET_GRBIT grbit);
void NotifyRollbackTransaction(JET_SESID sesid, JET_GRBIT grbit);
void NotifyUpdateUserFunctions(JET_SESID sesid);

#ifndef RETAIL
void DebugListOpenTables(void);
#endif	/* RETAIL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\inc\_jet.h ===
/***********************************************************************
* Microsoft Jet
*
* Microsoft Confidential.  Copyright 1991-1992 Microsoft Corporation.
*
* Component:
*
* File: _jet.h
*
* File Comments:
*
*     Internal header file for JET.
*
* Revision History:
*
*    [0]  06-Apr-90  kellyb	Created
*
***********************************************************************/

#ifndef _JET_H
#define _JET_H

	/* Start of Microsoft C vs CSL compiler specific definitions */

#ifdef	_MSC_VER

#if	(_MSC_VER == 600)

	/* ANSI compatible keywords */

#define __near	     _near
#define __far	     _far
#define __based(b)   _based(b)
#define __self	     _self
#define __segment    _segment
#define __segname(s) _segname(s)
#define __cdecl      _cdecl
#define __pascal     _pascal
#define __export     _export
#define __loadds     _loadds
#define __asm	     _asm

#define __max(a,b)	max(a,b)
#define __min(a,b)	min(a,b)

#endif	/* (_MSC_VER == 600) */

#define FAR	  __far
#define NEAR	  __near
#define PASCAL	  __pascal

#define far	  __DONT_USE_FAR__
#define near	  __DONT_USE_NEAR__
#define huge	  __DONT_USE_HUGE__
#define cdecl	  __DONT_USE_CDECL__
#define pascal	  __DONT_USE_PASCAL__

#ifdef	FLAT			       /* 0:32 Flat Model */

#define EXPORT			       /* Called from assembly code */
#define VARARG			       /* Variable number of arguments */

#else	/* !FLAT */		       /* 16:16 Segmented Model */

#define EXPORT	  __pascal	       /* Called from assembly code */
#define VARARG	  __cdecl	       /* Variable number of arguments */

#endif	/* FLAT */

#define PUBLIC	  extern	       /* Visible to other modules */
#ifdef	RETAIL
#define STATIC	  static	       /* Private within a module */
#else	/* !RETAIL */
#define STATIC			       /* Private within a module */
#endif	/* !RETAIL */

#ifndef _H2INC
#include <string.h>
#endif	/* !_H2INC */

#define bltb(pFrom, pTo, cb)	(memcpy((pTo), (pFrom), (cb)), (void) 1)
#define bltbx(lpFrom, lpTo, cb) (memcpy((lpTo), (lpFrom), (cb)), (void) 1)
#define bltcx(w, lpw, cw)	(memset((lpw), (w), (cw)*2), (void) 1)
#define bltbcx(b, lpb, cb)	(memset((lpb), (b), (cb)), (void) 1)
#define hbltb(hpFrom, hpTo, cb) (memcpy((hpTo), (hpFrom), (cb)), (void) 1)

	/* C6BUG: The commented out definition is correct but causes C 6.00 */
	/* C6BUG: to run out of near heap space.  This is fixed in C 7.00 */
	/* C6BUG: and should be enabled when we switch compilers. */

#if	_MSC_VER >= 700
#define CODECONST(type) type const __based(__segname("_CODE"))
#else	/* _MSC_VER < 700 */
#define CODECONST(type) type __based(__segname("_CODE"))
#endif	/* _MSC_VER < 700 */

#ifdef WIN32
#define __export
#endif /* WIN32 */

#define CbFromSz(sz) strlen(sz)

#ifdef	M_MRX000

#define __export		       /* Not supported by MIPS Rx000 compiler */

#endif	/* M_MRX000 */

#else	/* !_MSC_VER */

#define const
#define volatile

#define _near
#define __near
#define _far	  far
#define __far	  far
#define _pascal   pascal
#define __pascal  pascal
#define _export
#define __export
#define _loadds
#define __loadds

#define FAR	  far
#define NEAR
#define PASCAL	  pascal

#define EXPORT	  _export	       /* Called from assembly code */

#define PUBLIC			       /* Visible to other modules */
#define STATIC			       /* Private within a module */

uop long LUOP_QWIN();

#define MAKELONG(lo,hi) LUOP_QWIN(0,(WORD)(hi),(WORD)(lo))
#define LOWORD(l)	(((WORD *) &(l))[0])
#define HIWORD(l)	(((WORD *) &(l))[1])
#define LOBYTE(w)	((BYTE)(w) & 0xff)
#define HIBYTE(w)	(((WORD)(w) >> 8) & 0xff)

#include "qsetjmp.h"
#include "uops.h"

#define ISAMAPI _export		       /* Defined in jet\inc\isam.h */
#define VDBAPI	_export		       /* Defined in jet\inc\vdbapi.h */
#define VTAPI	_export		       /* Defined in jet\inc\vtapi.h */

#define bltb(pFrom, pTo, cb)	BLTB(pFrom, pTo, cb)
#define bltbx(lpFrom, lpTo, cb) BLTBX(lpFrom, lpTo, cb)
#define bltcx(w, lpw, cw)	BLTCX(w, lpw, cw)	 /* word fill */
#define bltbcx(b, lpb, cb)	BLTBCX(b, lpb, cb)	 /* byte fill */
#define hbltb(hpFrom, hpTo, cb) BLTBH(hpFrom, hpTo, cb)

#define CODECONST(type) csconst type

#define CbFromSz(sz) lstrlen(sz)

#endif	/* !_MSC_VER */

	/* End of Microsoft C vs CSL compiler specific definitions */

	/* Start of memory management model specific definitions */

#ifdef	FLAT			       /* 0:32 Flat Model */

#define __near
#define __far
#define __based(p)

#endif	/* FLAT */

	/* End of memory management model specific definitions */

#ifndef NULL
#define NULL	((void *)0)
#endif

#define fFalse 0
#define fTrue  (!0)

	/* The following types should be used internally instead of the */
	/* JET_xxx analogs.  These types result in smaller faster code. */

typedef int ERR;
typedef double DATESERIAL;
typedef ULONG_PTR OBJID;
typedef unsigned short OBJTYP;
typedef unsigned short COLTYP;
typedef int BOOL;

#ifdef	FLAT			       /* 0:32 Flat Model */

typedef int (*PFN)();

#else	/* !FLAT */		       /* 16:16 Segmented Model */

typedef int (__far __pascal *PFN)();

#endif	/* !FLAT */


/* CONSIDER: ErrIsamFoo functions should stop using OUTDATA */

typedef struct			       /* CONSIDER: OUTDATA */
	{
	unsigned long cbMax;	       /* size of buffer */
	unsigned long cbActual;        /* true size of return value */
	unsigned long cbReturned;      /* length of value returned */
	void __far *pb; 	       /* output data from routine */
	} OLD_OUTDATA;

typedef struct
	{
	int month;
	int day;
	int year;
	int hour;
	int minute;
	int second;
	} _JET_DATETIME;
	

	/* CONSIDER: Can this be replaced by !JET_bitTableScrollable? */

#define JET_bitTableInsertOnly		0x10000000	/* QJET internal for bulk insert */
#define JET_bitTableBulkAppend		0x20000000	/* QJET internal for bulk insert */

	/* cbFilenameMost includes the trailing null terminator */

	/* CONSIDER: The Windows ISAM may be used with WLO and should */
	/* CONSIDER: support OS/2 filename length limits. */

#define cbFilenameMost		260		/* Windows NT limit */

	/*** Global system initialization variables ***/

extern BOOL __near fJetInitialized;

extern BOOL fSysDbPathSet;						/* if path is set */
extern char __near szSysDbPath[cbFilenameMost]; /* Path to the system database */
extern char __near szTempPath[cbFilenameMost];	/* Path to temp file directory */
extern char __near szIniPath[cbFilenameMost];	/* Path to the ini file */
#ifdef	LATER
extern char __near szLogPath[cbFilenameMost];	/* Path to log file directory */
#endif	/* LATER */

	/* Default indicated by zero */

#ifdef	LATER
extern unsigned long __near cbBufferMax;	/* bytes to use for page buffers */
extern unsigned long __near cSesionMax; 	/* max number of sessions */
extern unsigned long __near cOpenTableMax;	/* max number of open tables */
extern unsigned long __near cVerPageMax;	/* max number of page versions */
extern unsigned long __near cCursorMax; 	/* max number of open cursors */
#endif	/* LATER */

/*	Engine OBJIDs:

	0..0x10000000 reserved for engine use, divided as follows:

	0x00000000..0x0000FFFF	reserved for TBLIDs under RED
	0x00000000..0x0EFFFFFF	reserved for TBLIDs under BLUE
	0x0F000000..0x0FFFFFFF	reserved for container IDs
	0x10000000		reserved for ObjectId of DbObject

	Client OBJIDs begin at 0x10000001 and go up from there.
*/
#define objidNil			((OBJID) 0x00000000)
#define objidRoot			((OBJID) 0x0F000000)
#define objidTblContainer 		((OBJID) 0x0F000001)
#define objidDbContainer 		((OBJID) 0x0F000002)
#define objidDbObject			((OBJID) 0x10000000)

#define JET_sortIgnoreAccents 0x00010000
/* NOTE: this must be different than any legal JET_sort value and JET_sortUnknown */
#define JET_sortUninit		  0xfffeU

/* NOTE: these must be defined somewhere else? */
#define langidEnglish 0x0409
#define langidSwedish 0x041D
#define langidSpanish 0x040A
#define langidDutch	  0x0413

typedef enum {
	evntypStart = 0,
	evntypStop,
	evntypAssert,
	evntypDiskIO,
	evntypInfo,
	evntypActivated,
	evntypLogDown,
	} EVNTYP;

extern int fNoWriteAssertEvent;

void UtilWriteEvent( EVNTYP evntyp, const char *sz,	const char *szFilename,
	unsigned Line );

	/* Start of RELEASE vs DEBUG build definitions */

#ifdef	RETAIL

#define DeclAssertFile
#define Assert(exp)		((void)1)
#define ExpAssert(exp)		((void)1)
#define AssertSz(exp, sz)	((void)1)
#define AssertConst(exp)	((void)1)

#define AssertEq(exp, exp2)	(exp)
#define AssertGe(exp, exp2)	(exp)
#define AssertNe(exp, exp2)	(exp)
#define SideAssert(f)		(f)

#define MarkTableidExported(err,tableid)
#define CheckTableidExported(tableid)

#define DeclAPIDebug(Name, pParamFirst, szPDesc)

#define AssertValidSesid(sesid) ((void) 1)

#else	/* !RETAIL */

#ifdef	_MSC_VER

#define DeclAssertFile static CODECONST(char) szAssertFilename[] = __FILE__

#else	/* !_MSC_VER */ 	       /* CSL pcode compiler */

#define DeclAssertFile CODECONST(char) szAssertFilename[] = __FILE__

#endif	/* !_MSC_VER */


#define AssertSz(exp, sz) { \
		static CODECONST(char) szMsg[] = sz; \
		(exp) ? (void) 0 : AssertFail( szMsg, szAssertFilename, __LINE__ ); \
	}

#define Assert( exp ) \
	( (exp) ? (void) 0 : AssertFail( #exp, szAssertFilename, __LINE__) )
#define ExpAssert(exp)		Assert(exp)

#define AssertConst(exp)	Assert(*szAssertFilename != '\0' && (exp))

#define AssertEq(exp, exp2)	Assert((exp) == (exp2))
#define AssertGe(exp, exp2)	Assert((exp) >= (exp2))
#define AssertNe(exp, exp2)	Assert((exp) != (exp2))
#define SideAssert(f)		Assert(f)

#define DeclAPIDebug(Name, pParamFirst, szPDesc)	\
	static CODECONST(char) szNameAPI[] = #Name;	\
	static CODECONST(unsigned) ordAPI = ord ## Name;\
	void *pvParamsAPI = pParamFirst;		\
	static CODECONST(char) szParamDesc[] = szPDesc;

#define AssertValidSesid(sesid) AssertValidSesid(sesid)

BOOL FTableidExported(JET_TABLEID tableid);
void MarkTableidExportedR(JET_TABLEID tableid);
#define MarkTableidExported(err,tableid)		\
		if (err >= 0)							\
			MarkTableidExportedR(tableid)
#define CheckTableidExported(tableid)			\
		if (!FTableidExported(tableid))			\
			APIReturn(JET_errInvalidTableId)

#endif	/* !RETAIL */

	/* End of RELEASE vs DEBUG build definitions */


#ifndef PARAMFILL

#define FillClientBuffer(pv, cb) ((void)1)

#endif	/* !PARAMFILL */

	/* apirare.c */

PUBLIC ERR ErrOpenDatabase(JET_SESID sesid, const char __far *szDatabase,
	const char __far *szConnect, JET_DBID __far *pdbid, JET_GRBIT grbit);


	/* initterm.c */

extern unsigned __near EXPORT wSQLTrace;
JET_ERR JET_API ErrInit(BOOL fSkipIsamInit);

#ifndef RETAIL

extern unsigned __near EXPORT wAssertAction;

extern unsigned __near EXPORT wTaskId;

#ifdef RFS2
extern BOOL __near EXPORT	fLogDebugBreak;
extern BOOL __near EXPORT	fLogJETCall;
extern BOOL __near EXPORT	fLogRFS;
extern long __near EXPORT	cRFSAlloc;
extern BOOL __near EXPORT	fDisableRFS;
#endif /*  RFS2  */

#endif	/* !RETAIL */


	/* util.c */

PUBLIC unsigned EXPORT CchValidateName(char __far *pchName, const char __far *lpchName, unsigned cchName);

#ifdef	PARAMFILL

PUBLIC void EXPORT FillClientBuffer(void __far *pv, unsigned long cb);

#endif	/* PARAMFILL */

#ifndef RETAIL

PUBLIC void EXPORT AssertFail( const char *szExpr, const char *szFilename, unsigned Line );

#ifndef DOS
PUBLIC void VARARG DebugPrintf(const char __far *szFmt, ...);
#endif	/* !DOS */

#endif	/* !RETAIL */

	/* utilw32.c */

PUBLIC ERR EXPORT ErrSysInit(void);
PUBLIC BOOL FUtilLoadLibrary(const char __far *pszLibrary, ULONG_PTR __far *phmod);
PUBLIC PFN PfnUtilGetProcAddress(ULONG_PTR hmod, unsigned ordinal);
PUBLIC void UtilFreeLibrary(ULONG_PTR hmod);
PUBLIC void EXPORT UtilGetDateTime(DATESERIAL *pdt);
PUBLIC void EXPORT UtilGetDateTime2(_JET_DATETIME *pdt);
PUBLIC unsigned EXPORT UtilGetProfileInt(const char __far *szSectionName, const char __far *szKeyName, int iDefault);
PUBLIC unsigned UtilGetProfileString(const char __far *szSectionName, const char __far *szKeyName, const char __far *szDefault, char __far *szReturnedString, unsigned cchMax);

	/*  RFS functions in utilw32.c  */

#ifdef RFS2
PUBLIC int UtilRFSAlloc(const char __far *szType);
PUBLIC int UtilRFSLog(const char __far *szType,int fPermitted);
PUBLIC void UtilRFSLogJETCall(const char __far *szFunc,ERR err,const char __far *szFile,unsigned Line);
PUBLIC void UtilRFSLogJETErr(ERR err,const char __far *szLabel,const char __far *szFile,unsigned szLine);
#endif /*  RFS2  */

extern void __far * __near critJet;

//#ifdef SPIN_LOCK
#if 0
PUBLIC void UtilEnterNestableCriticalSection(void __far *pv);
PUBLIC void UtilLeaveNestableCriticalSection(void __far *pv);
#else
#define UtilEnterNestableCriticalSection(pv)  UtilEnterCriticalSection(pv)
#define UtilLeaveNestableCriticalSection(pv)  UtilLeaveCriticalSection(pv)
#endif
PUBLIC void UtilEnterCriticalSection(void __far *pv);
PUBLIC void UtilLeaveCriticalSection(void __far *pv);
PUBLIC ERR ErrUtilInitializeCriticalSection(void __far * __far *ppv);
PUBLIC void UtilDeleteCriticalSection(void __far *pv);
PUBLIC ERR ErrUtilSemCreate(void __far * __far *ppv, const char __far *szSem);
PUBLIC void UtilSemRelease(void __far *pv);
PUBLIC void UtilSemRequest(void __far *pv);
PUBLIC ERR ErrUtilSignalCreate(void __far * __far *ppv, const char __far *szSig);
PUBLIC ERR ErrUtilSignalCreateAutoReset(void **ppv, const char *szSig);
PUBLIC void UtilSignalReset(void __far *pv);
PUBLIC void UtilSignalSend(void __far *pv);
PUBLIC void UtilSignalWait(void __far *pv, long lTimeOut);
PUBLIC void UtilSignalWaitEx( void *pv, long lTimeOut, BOOL fAlertable );
PUBLIC void UtilMultipleSignalWait(
		int csig, void __far *pv, int fWaitAll, long lTimeOut);
PUBLIC void UtilCloseSignal(void *pv);
PUBLIC int UtilCreateThread( void (*pfn)(), int *ptid, int cbStack );
PUBLIC int UtilSuspendThread( int *tid );
PUBLIC void UtilSleep( unsigned cmsec );

#ifdef RETAIL
#define UtilAssertSEM( pv )	0
#define UtilAssertCrit( pv )	0
#define UtilHoldCriticalSection( pv ) 	0
#define UtilReleaseCriticalSection( pv )	0
#else

PUBLIC unsigned EXPORT DebugGetTaskId(void);
PUBLIC void VARARG DebugWriteString(BOOL fHeader, const char __far *szFormat, ...);

PUBLIC void UtilAssertSEM(void __far *pv);
PUBLIC void UtilAssertCrit(void __far *pv);
PUBLIC void UtilHoldCriticalSection(void __far *pv);
PUBLIC void UtilReleaseCriticalSection(void __far *pv);

#endif	/* !RETAIL */

	/*  sysw32.c  */

#ifdef	DEBUG

void	*SAlloc( unsigned long );
void	OSSFree( void * );
void	*LAlloc( unsigned long, unsigned short );
void	OSLFree( void * );

#define SFree( pv )		{ OSSFree( pv ); pv = 0; }
#define LFree( pv )		{ OSLFree( pv ); pv = 0; }

#else	/* !DEBUG */

#define	SAlloc( __cb_ )		malloc( __cb_ )
#define	SFree( __pv_ )		free( __pv_ )
#define	LAlloc( __c_, __cb_ )  	malloc( (__c_) * (__cb_) )
#define	LFree( __pv_ )			free( __pv_ )

#endif	/* !DEBUG */

	/* utilxlat.asm */

#ifndef ANSIAPI

extern unsigned char __far EXPORT mpchAnsichOem[256];
extern unsigned char __far EXPORT mpchOemchAnsi[256];

PUBLIC void EXPORT XlatAnsiToOem(const char __far *pchSource, char __far *pchDest, unsigned cb);
PUBLIC void EXPORT XlatOemToAnsi(const char __far *pchSource, char __far *pchDest, unsigned cb);

#endif	/* !ANSIAPI */

	/*  API Enter/Leave macros assuming that critJet has been initialized  */

#define APIEnter()						{	\
	Assert(critJet != NULL);				\
	UtilEnterCriticalSection(critJet);	}
	
#define APIReturn(err)					{	\
	ERR errT = (err);						\
	Assert(critJet != NULL);				\
	UtilLeaveCriticalSection(critJet);		\
	return errT;						}

	/*  APIInitEnter inits critJet (if necessary) on an initializing API call  */

#define APIInitEnter()					{							\
	if (critJet == NULL)	{										\
		ERR errT = ErrUtilInitializeCriticalSection( &critJet );	\
		if ( errT < 0 )												\
			return errT;	}										\
	UtilEnterCriticalSection(critJet);	}

	/*  APITermReturn frees critJet on return from a terminating API call  */

#define APITermReturn(err)				{	\
	ERR errT = (err);						\
	Assert(critJet != NULL);				\
	UtilLeaveCriticalSection(critJet);		\
	UtilDeleteCriticalSection(critJet);		\
	critJet = NULL;							\
	return errT;						}

#endif /* !_JET_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\inc\_vdbmgr.h ===
/***********************************************************************
* Microsoft Jet
*
* Microsoft Confidential.  Copyright 1991-1992 Microsoft Corporation.
*
* Component: VDB Dispatcher
*
* File: _vdbmgr.h
*
* File Comments:
*
*     Internal header file for VDB dispatcher.
*
* Revision History:
*
*    [0]  03-Apr-91  kellyb	Created
*
***********************************************************************/

#ifndef _VDBMGR_H
#define _VDBMGR_H

#include "vdbapi.h"

	/* CONSIDER: Allocate these tables per session, and/or allow */
	/* CONSIDER: configuration of their sizes */

#define dbidMax 	512	       /* Maximum open dbids */

extern JET_VDBID	      __near EXPORT mpdbiddbid[dbidMax];
extern const VDBFNDEF __far * __near EXPORT mpdbidpvdbfndef[dbidMax];
extern JET_SESID	      __near EXPORT mpdbidvsesid[dbidMax];

#endif	/* _VDBMGR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\inc\_vtmgr.h ===
/***********************************************************************
* Microsoft Jet
*
* Microsoft Confidential.  Copyright 1991-1992 Microsoft Corporation.
*
* Component: VT Dispatcher
*
* File: _vtmgr.h
*
* File Comments:
*
*     Internal header file for VT dispatcher.
*
* Revision History:
*
*    [0]  10-Nov-90  richards	Added this header
*
***********************************************************************/

#ifndef _VTMGR_H
#define _VTMGR_H

#include "vtapi.h"

	/* CONSIDER: Allocate these tables per session, and/or allow */
	/* CONSIDER: configuration of their sizes */


#define tableidMax	2048


typedef struct _VTDEF
{
   JET_VSESID		vsesid;        /* Session id for VT provider. */
   JET_VTID		vtid;	       /* Tableid for VT provider. */
   JET_ACM		acm;	       /* ACM for JET security layer. */
   const VTFNDEF __far *pvtfndef;      /* VT function dispatch table. */
#ifdef DEBUG
   BOOL			fExported;     /* Returned by an API call? */
#endif
} VTDEF;


extern VTDEF __near EXPORT rgvtdef[tableidMax];

#endif	/* !_VTMGR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\src\apicore.c ===
/***********************************************************************
* Microsoft Jet
*
* Microsoft Confidential.  Copyright 1991-1992 Microsoft Corporation.
*
* Component:
*
* File: apicore.c
*
* File Comments:
*
* Revision History:
*
*    [0]  09-Sep-91  richards	Split from isamapi.c
*
***********************************************************************/

#include "std.h"

#include "jetord.h"
#include "_jetstr.h"		       /* global strings */

#include "vdbmgr.h"		       /* database id manager prototypes */
#include "vtmgr.h"		       /* table id manager prototypes */
#include "_vtmgr.h"		       /* table id manager prototypes */

#include "isammgr.h"		       /* installable ISAMs */

#include <stdlib.h>
#include <string.h>

ERR VTAPI ErrIsamSetColumn( JET_VSESID ppib, JET_VTID pfucb, unsigned long ulFieldId,
	char *pbData, unsigned long cbData, JET_GRBIT grbit, JET_SETINFO *psetinfo );

ERR VTAPI ErrIsamRetrieveColumn( JET_VSESID ppib, JET_VTID pfucb, unsigned long ulFieldId,
	char *pbData, unsigned long cbDataMax, unsigned long *pcbDataActual,
	JET_GRBIT grbit, JET_RETINFO *pretinfo );

ERR VTAPI ErrIsamSetColumns(
	JET_VSESID		ppib,
	JET_VTID			pfucb,
	JET_SETCOLUMN	*psetcols,
	unsigned long	csetcols );

ERR VTAPI ErrIsamRetrieveColumns(
	JET_VSESID					ppib,
	JET_VTID						pfucb,
	JET_RETRIEVECOLUMN 	*pretcols,
	unsigned long				cretcols );

DeclAssertFile;


/* C6BUG: Remove this when the compiler can handle C functions in plmf */

STATIC void NEAR StrNCpy(char __far *szDest, char __far *szSrc,size_t cb)
	{
	(void) strncpy(szDest, szSrc, cb);
	}


/***********************************************************************/
/***********************  JET API FUNCTIONS  ***************************/
/***********************************************************************/


	/* The following pragma affects the code generated by the C */
	/* compiler for all FAR functions.  Do NOT place any non-API */
	/* functions beyond this point in this file. */

/* NOTE: This will be the shipping version of JetIdle */
/*=================================================================
JetIdle

Description:
  Performs idle time processing.

Parameters:
  sesid			uniquely identifies session
  grbit			processing options

Return Value:
  Error code

Errors/Warnings:
  JET_errSuccess		some idle processing occurred
  JET_wrnNoIdleActivity no idle processing occurred
=================================================================*/

JET_ERR JET_API JetIdle(JET_SESID sesid, JET_GRBIT grbit)
	{
	ERR	err;

	APIEnter();

	if (!FValidSesid(sesid))
		APIReturn(JET_errInvalidSesid);

	/* Let the built-in ISAM do some idle processing */
	err = ErrIsamIdle(sesid, grbit);

	APIReturn(err);

	/* CONSIDER: This API cannot fail.  Any errors generated should be */
	/* CONSIDER: suppressed and reported by a later API call. */
	}


/*=================================================================
JetGetLastErrorInfo

Description:
  Returns extended error info to the user.

Parameters:
  sesid			uniquely identifies session
  pexterr		pointer to JET_EXTERR structure (NULL if not desired)
  cbexterrMax	size of buffer pointed to by pexterr
  sz1			pointer to buffer for error string #1 (NULL if not desired)
  cch1Max		size of buffer pointed to by sz1
  sz2			pointer to buffer for error string #2 (NULL if not desired)
  cch2Max		size of buffer pointed to by sz2

Return Value:
  JET error code

Errors/Warnings:
  JET_errSuccess		if error info was retrieved.
  JET_wrnNoErrorInfo	if there was no error info to retrieve.  In this case,
					    none of the output parameters are filled in.
=================================================================*/
JET_ERR JET_API JetGetLastErrorInfo(JET_SESID sesid,
	JET_EXTERR __far *pexterr, unsigned long cbexterrMax,
	char __far *sz1, unsigned long cch1Max,
	char __far *sz2, unsigned long cch2Max,
	char __far *sz3, unsigned long cch3Max,
	unsigned long __far *pcch3Actual)
	{
	int isib;
	SIB __near *psib;

	APIEnter();

	FillClientBuffer(pexterr, cbexterrMax);
	FillClientBuffer(sz1, cch1Max);
	FillClientBuffer(sz2, cch2Max);
	FillClientBuffer(sz3, cch3Max);

	/*** Get SIB for this session ***/
	if ((isib = UtilGetIsibOfSesid(sesid)) == -1)
		APIReturn(JET_errInvalidSesid);

	psib = rgsib + isib;

	/*** No error info?  Return ***/
	if (psib->exterr.err == JET_wrnNoErrorInfo)
		{
		pexterr->cbStruct = 0;
		APIReturn(JET_wrnNoErrorInfo);
		}

	/*** Fill in return values ***/
	if (pexterr != NULL && cbexterrMax >= sizeof(JET_EXTERR))
		{
		pexterr->cbStruct = sizeof(JET_EXTERR);
		pexterr->err = psib->exterr.err;
		pexterr->ul1 = psib->exterr.ul1;
		pexterr->ul2 = psib->exterr.ul2;
		pexterr->ul3 = psib->exterr.ul3;
		}

	if (sz1 != NULL && cch1Max > 0)
		{
		if (psib->sz1 == NULL)
			*sz1 = '\0';
		else
			{
			StrNCpy(sz1, psib->sz1, (size_t)cch1Max);
			sz1[cch1Max-1] = '\0';
			}
		}

	if (sz2 != NULL && cch2Max > 0)
		{
		if (psib->sz2 == NULL)
			*sz2 = '\0';
		else
			{
			StrNCpy(sz2, psib->sz2, (size_t)cch2Max);
			sz2[cch2Max-1] = '\0';
			}
		}

	if (sz3 != NULL && cch3Max > 0)
		{
		if (psib->sz3 == NULL)
			*sz3 = '\0';
		else
			{
			StrNCpy(sz3, psib->sz3, (size_t)cch3Max);
			sz3[cch3Max-1] = '\0';
			if (pcch3Actual != NULL && (unsigned long)strlen(psib->sz3) > cch3Max-1)
				*pcch3Actual = strlen(psib->sz3);
			}
		}

	APIReturn(JET_errSuccess);
	}


JET_ERR JET_API JetGetTableIndexInfo(JET_SESID sesid, JET_TABLEID tableid,
	const char __far *szIndexName, void __far *pvResult,
	unsigned long cbResult, unsigned long InfoLevel)
	{
	ERR err;

	APIEnter();

	FillClientBuffer(pvResult, cbResult);

	if (!FValidSesid(sesid))
		APIReturn(JET_errInvalidSesid);

	CheckTableidExported(tableid);

	switch (InfoLevel)
		{
	case JET_IdxInfo :
	case JET_IdxInfoList :
		if (cbResult < sizeof(JET_INDEXLIST))
			APIReturn(JET_errBufferTooSmall);
		break;
	case JET_IdxInfoSysTabCursor :
		if (cbResult < sizeof(JET_TABLEID))
			APIReturn(JET_errBufferTooSmall);
		break;
		}

	err = ErrDispGetTableIndexInfo(sesid, tableid, szIndexName, pvResult, cbResult, InfoLevel);
#ifdef DEBUG
	switch (InfoLevel)
		{
	case JET_IdxInfo :
	case JET_IdxInfoList :
		MarkTableidExported(err, ((JET_INDEXLIST*)pvResult)->tableid);
		break;
	case JET_IdxInfoSysTabCursor :
		MarkTableidExported(err, *(JET_TABLEID*)pvResult);
		break;
		}
#endif
	APIReturn(err);
	}


JET_ERR JET_API JetGetIndexInfo(JET_SESID sesid, JET_DBID dbid,
	const char __far *szTableName, const char __far *szIndexName,
	void __far *pvResult, unsigned long cbResult,
	unsigned long InfoLevel)
	{
	ERR	err;
	OLD_OUTDATA	outdata;       /* CONSIDER: OUTDATA */

	APIEnter();

	FillClientBuffer(pvResult, cbResult);

	if (!FValidSesid(sesid))
		APIReturn(JET_errInvalidSesid);

	switch (InfoLevel)
		{
	case JET_IdxInfo :
	case JET_IdxInfoList :
		if (cbResult < sizeof(JET_INDEXLIST))
			APIReturn(JET_errBufferTooSmall);
		break;
	case JET_IdxInfoSysTabCursor :
		if (cbResult < sizeof(JET_TABLEID))
			APIReturn(JET_errBufferTooSmall);
		break;
		}

	outdata.cbMax = cbResult;      /* CONSIDER: OUTDATA */
	outdata.pb    = pvResult;      /* CONSIDER: OUTDATA */

	err = ErrDispGetIndexInfo(sesid, dbid, szTableName, szIndexName,
		&outdata, InfoLevel);

#ifdef DEBUG
	switch (InfoLevel)
		{
	case JET_IdxInfo :
	case JET_IdxInfoList :
		MarkTableidExported(err, ((JET_INDEXLIST*)pvResult)->tableid);
		break;
	case JET_IdxInfoSysTabCursor :
		MarkTableidExported(err, *(JET_TABLEID*)pvResult);
		break;
		}
#endif
	APIReturn(err);
	}


JET_ERR JET_API JetGetObjectInfo(JET_SESID sesid, JET_DBID dbid,
	JET_OBJTYP objtyp, const char __far *szContainerName,
	const char __far *szObjectName, void __far *pvResult,
	unsigned long cbMax, unsigned long InfoLevel)
	{
	OLD_OUTDATA	outdata;       /* CONSIDER: OUTDATA */
	JET_ERR err;

	APIEnter();

	FillClientBuffer(pvResult, cbMax);

	if (!FValidSesid(sesid))
		APIReturn(JET_errInvalidSesid);

	switch (InfoLevel)
		{
	case JET_ObjInfo :
	case JET_ObjInfoNoStats :
		if (cbMax < sizeof(JET_OBJECTINFO))
			APIReturn(JET_errBufferTooSmall);
		break;
	case JET_ObjInfoListNoStats :
	case JET_ObjInfoList :
		if (cbMax < sizeof(JET_OBJECTLIST))
			APIReturn(JET_errBufferTooSmall);
		break;
	case JET_ObjInfoSysTabCursor :
	case JET_ObjInfoSysTabReadOnly:
		if (cbMax < sizeof(JET_TABLEID))
			APIReturn(JET_errBufferTooSmall);
		break;
	default:
		APIReturn(JET_errInvalidParameter);
		}

	outdata.cbMax = cbMax;	       /* CONSIDER: OUTDATA */
	outdata.pb    = pvResult;      /* CONSIDER: OUTDATA */

	err = ErrDispGetObjectInfo(sesid, dbid, objtyp, szContainerName,
		szObjectName, &outdata, InfoLevel);
#ifdef DEBUG
	switch (InfoLevel)
		{
	case JET_ObjInfoListNoStats :
	case JET_ObjInfoList :
		MarkTableidExported(err, ((JET_OBJECTLIST*)pvResult)->tableid);
		break;
	case JET_ObjInfoSysTabCursor :
	case JET_ObjInfoSysTabReadOnly:
		MarkTableidExported(err, *(JET_TABLEID*)pvResult);
		break;
		}
#endif
	APIReturn(err);
	}


JET_ERR JET_API JetGetTableInfo(JET_SESID sesid, JET_TABLEID tableid,
	void __far *pvResult, unsigned long cbMax, unsigned long InfoLevel)
	{
	APIEnter();

	FillClientBuffer(pvResult, cbMax);

	if (!FValidSesid(sesid))
		APIReturn(JET_errInvalidSesid);

	if (cbMax < sizeof(JET_OBJECTINFO))
		APIReturn(JET_errBufferTooSmall);

	CheckTableidExported(tableid);

	APIReturn(ErrDispGetTableInfo(sesid, tableid, pvResult, cbMax, InfoLevel));
	}


JET_ERR JET_API JetCreateObject(JET_SESID sesid, JET_DBID dbid,
	const char __far *szContainerName, const char __far *szObjectName,
	JET_OBJTYP objtyp)
	{
	OBJID objidParentId;
	OBJID objidNewObject;
	BOOL fContainerObj;
	ERR err;

	APIEnter();

	if (!FValidSesid(sesid))
		APIReturn(JET_errInvalidSesid);

#ifdef	LATER
	if (szObjectName == NULL)
		{
		APIReturn(JET_errInvalidParameter);
		}
#endif	/* LATER */

	/*	validate szContainerName & szObjectName...
	*/
	fContainerObj = (szContainerName == NULL) || (szContainerName[0] == '\0');

	/*	deal with the container issue...
	*/
	if (fContainerObj)
		{
		/*	Container objects must have OBJTYP of JET_objtypContainer...
		*/
		if (objtyp != JET_objtypContainer)
			{
			APIReturn(JET_errInvalidParameter);
			}

		objidParentId = objidRoot;
		}
	else	/* !fContainerObj */
		{
		/*	Non-container objects cannot have OBJTYP < JET_objtypClientMin...
		*/
		if ((objtyp < JET_objtypClientMin) || (objtyp > 0xffff))
			{
			APIReturn(JET_errInvalidParameter);
			}

		/*	get the objid of the Container object (objidParentId)...
		*/
		if ((err = ErrDispGetObjidFromName(sesid, dbid, NULL,
			szContainerName, &objidParentId)) < 0)
			APIReturn(err);
		}

	/*	Create the object record in MSysObjects...
	*/
	if ((err = ErrDispCreateObject(sesid, dbid, objidParentId, szObjectName,
		objtyp)) < 0)
		APIReturn(err);

	/*	set object owner and propagate ACEs...
	*/
	for(;;) /* Dummy loop - break out on error */
		{
		if ((err = ErrDispGetObjidFromName(sesid, dbid,
	 	       szContainerName, szObjectName, &objidNewObject)) < 0)
		break;

		APIReturn(err);
		}

/*  Error Recovery Delete the newly created object */
	AssertGe(ErrDispDeleteObject(sesid, dbid, objidNewObject), 0);
	APIReturn(err);
	}


JET_ERR JET_API JetDeleteObject(JET_SESID sesid, JET_DBID dbid,
	const char __far *szContainerName, const char __far *szObjectName)
	{
	OBJID objidObject;
	ERR err;

	APIEnter();

	if (!FValidSesid(sesid))
		APIReturn(JET_errInvalidSesid);

	if ((err = ErrDispGetObjidFromName(sesid, dbid,
		szContainerName, szObjectName, &objidObject)) < 0)
		APIReturn(err);

	APIReturn(ErrDispDeleteObject(sesid, dbid, objidObject));
	}


JET_ERR JET_API JetRenameObject(JET_SESID sesid, JET_DBID dbid,
	const char __far *szContainerName, const char __far *szObjectName,
	const char __far *szObjectNew)
	{
	APIEnter();

	if (!FValidSesid(sesid))
		APIReturn(JET_errInvalidSesid);

	APIReturn(ErrDispRenameObject(sesid, dbid, szContainerName, szObjectName, szObjectNew));
	}


#ifdef WIN32
JET_ERR JET_API JetStringCompare(char __far *pb1, unsigned long cb1,
	char __far *pb2, unsigned long cb2, unsigned long sort,
	long __far *plResult)
{
return -1;
}
#endif


JET_ERR JET_API JetBeginTransaction(JET_SESID sesid)
	{
	ERR	err = 0;

	APIEnter();

	if (!FValidSesid(sesid))
		APIReturn(JET_errInvalidSesid);

	err = ErrIsamBeginTransaction(sesid);

	APIReturn(err);
	}


JET_ERR JET_API JetCommitTransaction(JET_SESID sesid, JET_GRBIT grbit)
	{
	ERR	err = 0;

	APIEnter();

	if (!FValidSesid(sesid))
		APIReturn(JET_errInvalidSesid);

	if (grbit & ~JET_bitCommitFlush)
		APIReturn(JET_errInvalidParameter);

	err = ErrIsamCommitTransaction(sesid, grbit);

	APIReturn(err);
	}


JET_ERR JET_API JetRollback(JET_SESID sesid, JET_GRBIT grbit)
	{
	ERR	err = 0;

	APIEnter();

	if (!FValidSesid(sesid))
		APIReturn(JET_errInvalidSesid);

	if (grbit & ~JET_bitRollbackAll)
		APIReturn(JET_errInvalidParameter);

	err = ErrIsamRollback(sesid, grbit);

	APIReturn(err);
	}


JET_ERR JET_API JetOpenTable(JET_SESID sesid, JET_DBID dbid,
	const char __far *szTableName, const void __far *pvParameters,
	unsigned long cbParameters, JET_GRBIT grbit,
	JET_TABLEID __far *ptableid)
	{
	ERR err;

	APIEnter();

	if ( !FValidSesid(sesid) )
		APIReturn(JET_errInvalidSesid);

	err = ErrDispOpenTable(sesid, dbid, ptableid, szTableName, grbit);

// AllDone:
#ifdef DEBUG
	if (!(grbit & JET_bitTableBulk))
		MarkTableidExported(err, *ptableid);
#endif
	APIReturn(err);
	}


JET_ERR JET_API JetDupCursor(JET_SESID sesid, JET_TABLEID tableid,
	JET_TABLEID *ptableid, JET_GRBIT grbit)
	{
	ERR	err;

	APIEnter();

	if (!FValidSesid(sesid))
		APIReturn(JET_errInvalidSesid);

	CheckTableidExported(tableid);

	err = ErrDispDupCursor(sesid, tableid, ptableid, grbit);

	MarkTableidExported(err, *ptableid);
	APIReturn(err);
	}


JET_ERR JET_API JetCloseTable(JET_SESID sesid, JET_TABLEID tableid)
	{
	APIEnter();

	if (!FValidSesid(sesid))
		APIReturn(JET_errInvalidSesid);

	CheckTableidExported(tableid);

	APIReturn(ErrDispCloseTable(sesid, tableid));
	}


JET_ERR JET_API JetGetTableColumnInfo(JET_SESID sesid, JET_TABLEID tableid,
	const char __far *szColumnName, void __far *pvResult,
	unsigned long cbMax, unsigned long InfoLevel)
	{
	ERR err;

	APIEnter();

	FillClientBuffer(pvResult, cbMax);

	if (!FValidSesid(sesid))
		APIReturn(JET_errInvalidSesid);

	CheckTableidExported(tableid);

	switch (InfoLevel)
		{
	case JET_ColInfo :
		if (cbMax < sizeof(JET_COLUMNDEF))
			APIReturn(JET_errBufferTooSmall);
		break;
	case JET_ColInfoList :
	case 2 :
		if (cbMax < sizeof(JET_COLUMNLIST))
			APIReturn(JET_errBufferTooSmall);
		break;
	case JET_ColInfoSysTabCursor :
		if (cbMax < sizeof(JET_TABLEID))
			APIReturn(JET_errBufferTooSmall);
		break;

	case JET_ColInfoBase :
		if (cbMax < sizeof(JET_COLUMNBASE))
			APIReturn(JET_errBufferTooSmall);
		break;
		}

	err = ErrDispGetTableColumnInfo(sesid, tableid, szColumnName,
		pvResult, cbMax, InfoLevel);
#ifdef DEBUG
	switch (InfoLevel)
		{
	case JET_ColInfoList :
	case 2 :
		MarkTableidExported(err, ((JET_COLUMNLIST*)pvResult)->tableid);
		break;
	case JET_ColInfoSysTabCursor :
		MarkTableidExported(err, *(JET_TABLEID*)pvResult);
		break;
		}
#endif
	APIReturn(err);
	}


JET_ERR JET_API JetGetColumnInfo(JET_SESID sesid, JET_DBID dbid,
	const char __far *szTableName, const char __far *szColumnName,
	void __far *pvResult, unsigned long cbMax, unsigned long InfoLevel)
	{
	ERR	err;
	OLD_OUTDATA	outdata;       /* CONSIDER: OUTDATA */

	APIEnter();

	FillClientBuffer(pvResult, cbMax);

	if (!FValidSesid(sesid))
		APIReturn(JET_errInvalidSesid);

	switch (InfoLevel)
		{
	case JET_ColInfo :
		if (cbMax < sizeof(JET_COLUMNDEF))
			APIReturn(JET_errBufferTooSmall);
		break;
	case JET_ColInfoList :
	case 2 :
		if (cbMax < sizeof(JET_COLUMNLIST))
			APIReturn(JET_errBufferTooSmall);
		break;
	case JET_ColInfoSysTabCursor :
		if (cbMax < sizeof(JET_TABLEID))
			APIReturn(JET_errBufferTooSmall);
		break;
	case JET_ColInfoBase :
		if (cbMax < sizeof(JET_COLUMNBASE))
			APIReturn(JET_errBufferTooSmall);
		break;
		}

	outdata.cbMax = cbMax;	       /* CONSIDER: OUTDATA */
	outdata.pb    = pvResult;      /* CONSIDER: OUTDATA */

	err = ErrDispGetColumnInfo(sesid, dbid, szTableName, szColumnName,
		&outdata, InfoLevel);

	Assert(err != JET_errSQLLinkNotSupported);

#ifdef DEBUG
	switch (InfoLevel)
		{
	case JET_ColInfoList :
	case 2 :
		MarkTableidExported(err, ((JET_COLUMNLIST*)pvResult)->tableid);
		break;
	case JET_ColInfoSysTabCursor :
		MarkTableidExported(err, *(JET_TABLEID*)pvResult);
		break;
		}
#endif
	APIReturn(err);
	}


JET_ERR JET_API JetRetrieveColumn(JET_SESID sesid, JET_TABLEID tableid,
	JET_COLUMNID columnid, void __far *pvData, unsigned long cbData,
	unsigned long __far *pcbActual, JET_GRBIT grbit,
	JET_RETINFO __far *pretinfo)
	{
	APIEnter();

	if (!FValidSesid(sesid))
		{
		FillClientBuffer(pvData, cbData);

		APIReturn(JET_errInvalidSesid);
		}

	CheckTableidExported(tableid);

	APIReturn(ErrDispRetrieveColumn(sesid, tableid, columnid, pvData,
		cbData, pcbActual, grbit, pretinfo));
	}


JET_ERR JET_API JetRetrieveColumns( JET_SESID sesid, JET_TABLEID tableid,
	JET_RETRIEVECOLUMN *pretrievecolumn, unsigned long cretrievecolumn )
	{
	JET_ERR					err = JET_errSuccess;
	JET_RETRIEVECOLUMN	*pretrievecolumnMax = pretrievecolumn + cretrievecolumn;
	JET_VSESID			vsesid;
	JET_VTID				vtid;

	APIEnter();

	if (!FValidSesid(sesid))
		{
#ifdef DEBUG
		unsigned long iretrievecolumn = 0;
		for ( ; iretrievecolumn < cretrievecolumn; iretrievecolumn++ )
			{
			FillClientBuffer( pretrievecolumn[iretrievecolumn].pvData,
				pretrievecolumn[iretrievecolumn].cbData );
			}
#endif

		APIReturn(JET_errInvalidSesid);
		}

	CheckTableidExported(tableid);

	vsesid = rgvtdef[tableid].vsesid;
  if (vsesid == (JET_VSESID) 0xFFFFFFFF)
     vsesid = (JET_VSESID) sesid;

	vtid = rgvtdef[tableid].vtid;

	err = ErrIsamRetrieveColumns( vsesid, vtid, pretrievecolumn, cretrievecolumn );

/*	for ( ; pretrievecolumn < pretrievecolumnMax; pretrievecolumn++ )
		{
		err = ErrIsamRetrieveColumn( vsesid, vtid, pretrievecolumn->columnid,
				pretrievecolumn->pvData, pretrievecolumn->cbData,
				&pretrievecolumn->cbActual, pretrievecolumn->grbit,
				pretrievecolumn->pretinfo );
		if ( err < 0 )
			break;
		} */

	APIReturn( err );
	}


JET_ERR JET_API JetSetColumn(JET_SESID sesid, JET_TABLEID tableid,
	JET_COLUMNID columnid, const void __far *pvData, unsigned long cbData,
	JET_GRBIT grbit, JET_SETINFO __far *psetinfo)
	{
	APIEnter();

	if (!FValidSesid(sesid))
		APIReturn(JET_errInvalidSesid);

	CheckTableidExported(tableid);

	APIReturn(ErrDispSetColumn(sesid, tableid, columnid, pvData, cbData,
		grbit, psetinfo));
	}


JET_ERR JET_API JetSetColumns(JET_SESID sesid, JET_TABLEID tableid,
	JET_SETCOLUMN *psetcolumn, unsigned long csetcolumn )
	{
	JET_ERR					err = JET_errSuccess;
	JET_SETCOLUMN		*psetcolumnMax = psetcolumn + csetcolumn;
	JET_VSESID			vsesid;
	JET_VTID				vtid;

	APIEnter();

	if (!FValidSesid(sesid))
		APIReturn(JET_errInvalidSesid);

	CheckTableidExported(tableid);

	vsesid = rgvtdef[tableid].vsesid;
  if (vsesid == (JET_VSESID) 0xFFFFFFFF)
     vsesid = (JET_VSESID) sesid;

	vtid = rgvtdef[tableid].vtid;

	err = ErrIsamSetColumns( vsesid, vtid, psetcolumn, csetcolumn );

/*	for ( ; psetcolumn < psetcolumnMax; psetcolumn++ )
		{
		err = ErrIsamSetColumn( vsesid, vtid, psetcolumn->columnid,
			psetcolumn->pvData, psetcolumn->cbData, psetcolumn->grbit,
			psetcolumn->psetinfo );
		if ( err < 0 )
			break;
		} */

	APIReturn( err );
	}


JET_ERR JET_API JetPrepareUpdate(JET_SESID sesid, JET_TABLEID tableid,
	unsigned long prep)
	{
	APIEnter();

	if (!FValidSesid(sesid))
		APIReturn(JET_errInvalidSesid);

	CheckTableidExported(tableid);

	switch (prep)
		{
	case JET_prepCancel:
		APIReturn(ErrDispPrepareUpdate(sesid, tableid, JET_prepCancel));

	case JET_prepInsert:
	case JET_prepInsertCopy:
	case JET_prepInsertBeforeCurrent:
		APIReturn(ErrDispPrepareUpdate(sesid, tableid, prep));

	case JET_prepReplace:
	case JET_prepReplaceNoLock:
		APIReturn(ErrDispPrepareUpdate(sesid, tableid, prep));

	default:
		APIReturn(JET_errInvalidParameter);
		}
	}


JET_ERR JET_API JetUpdate(JET_SESID sesid, JET_TABLEID tableid,
	void __far *pvBookmark, unsigned long cbMax,
	unsigned long __far *pcbActual)
	{
	APIEnter();

	if (!FValidSesid(sesid))
		{
		FillClientBuffer(pvBookmark, cbMax);

		APIReturn(JET_errInvalidSesid);
		}

	if (cbMax == 0) 	       /* Protect against benign reference */
		pvBookmark = NULL;

	CheckTableidExported(tableid);

	APIReturn(ErrDispUpdate(sesid, tableid, pvBookmark, cbMax, pcbActual));
	}


JET_ERR JET_API JetDelete(JET_SESID sesid, JET_TABLEID tableid)
	{
	APIEnter();

	if (!FValidSesid(sesid))
		APIReturn(JET_errInvalidSesid);

	CheckTableidExported(tableid);

	APIReturn(ErrDispDelete(sesid, tableid));
	}


JET_ERR JET_API JetGetCursorInfo(JET_SESID sesid, JET_TABLEID tableid,
	void __far *pvResult, unsigned long cbMax, unsigned long InfoLevel)
	{
	APIEnter();

	if (!FValidSesid(sesid))
		{
		FillClientBuffer(pvResult, cbMax);

		APIReturn(JET_errInvalidSesid);
		}

	CheckTableidExported(tableid);

	APIReturn(ErrDispGetCursorInfo(sesid, tableid, pvResult, cbMax, InfoLevel));
	}


JET_ERR JET_API JetGetCurrentIndex(JET_SESID sesid, JET_TABLEID tableid,
	char __far *szIndexName, unsigned long cchIndexName)
	{
	APIEnter();

	if (!FValidSesid(sesid))
		{
		FillClientBuffer(szIndexName, cchIndexName);

		APIReturn(JET_errInvalidSesid);
		}

	CheckTableidExported(tableid);

	APIReturn(ErrDispGetCurrentIndex(sesid, tableid, szIndexName, cchIndexName));
	}


JET_ERR JET_API JetSetCurrentIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char __far *szIndexName)
	{
	APIEnter();

	if (!FValidSesid(sesid))
		APIReturn(JET_errInvalidSesid);

	CheckTableidExported(tableid);

	APIReturn(ErrDispSetCurrentIndex(sesid, tableid, szIndexName));
	}


JET_ERR JET_API JetMove(JET_SESID sesid, JET_TABLEID tableid,
	signed long cRow, JET_GRBIT grbit)
	{
	APIEnter();

	if (!FValidSesid(sesid))
		APIReturn(JET_errInvalidSesid);

	CheckTableidExported(tableid);

	APIReturn(ErrDispMove(sesid, tableid, cRow, grbit));
	}


JET_ERR JET_API JetMakeKey(JET_SESID sesid, JET_TABLEID tableid,
	const void __far *pvData, unsigned long cbData, JET_GRBIT grbit)
	{
	APIEnter();

	if (!FValidSesid(sesid))
		APIReturn(JET_errInvalidSesid);

	CheckTableidExported(tableid);

	APIReturn(ErrDispMakeKey(sesid, tableid, pvData, cbData, grbit));
	}


JET_ERR JET_API JetSeek(JET_SESID sesid, JET_TABLEID tableid, JET_GRBIT grbit)
	{
	APIEnter();

	if (!FValidSesid(sesid))
		APIReturn(JET_errInvalidSesid);

	CheckTableidExported(tableid);

	APIReturn(ErrDispSeek(sesid, tableid, grbit));
	}


JET_ERR JET_API JetGetBookmark(JET_SESID sesid, JET_TABLEID tableid,
	void __far *pvBookmark, unsigned long cbMax,
	unsigned long __far *pcbActual)
	{
	APIEnter();

	if (!FValidSesid(sesid))
		{
		FillClientBuffer(pvBookmark, cbMax);

		APIReturn(JET_errInvalidSesid);
		}

	if (cbMax == 0) 	       /* Protect against benign reference */
		pvBookmark = NULL;

	CheckTableidExported(tableid);

	APIReturn(ErrDispGetBookmark(sesid, tableid, pvBookmark, cbMax, pcbActual));
	}


JET_ERR JET_API JetGotoBookmark(JET_SESID sesid, JET_TABLEID tableid,
	void __far *pvBookmark, unsigned long cbBookmark)
	{
	APIEnter();

	if (!FValidSesid(sesid))
		APIReturn(JET_errInvalidSesid);

	CheckTableidExported(tableid);

	APIReturn(ErrDispGotoBookmark(sesid, tableid, pvBookmark, cbBookmark));
	}


JET_ERR JET_API JetGetRecordPosition(JET_SESID sesid, JET_TABLEID tableid,
	JET_RECPOS __far *precpos, unsigned long cbKeypos)
	{
	APIEnter();

	if (!FValidSesid(sesid))
		{
		FillClientBuffer(precpos, cbKeypos);

		APIReturn(JET_errInvalidSesid);
		}

	CheckTableidExported(tableid);

	APIReturn(ErrDispGetRecordPosition(sesid, tableid, precpos, cbKeypos));
	}


JET_ERR JET_API JetGotoPosition(JET_SESID sesid, JET_TABLEID tableid,
	JET_RECPOS *precpos)
	{
	APIEnter();

	if (!FValidSesid(sesid))
		APIReturn(JET_errInvalidSesid);

	CheckTableidExported(tableid);

	APIReturn(ErrDispGotoPosition(sesid, tableid, precpos));
	}


JET_ERR JET_API JetRetrieveKey(JET_SESID sesid, JET_TABLEID tableid,
	void __far *pvKey, unsigned long cbMax,
	unsigned long __far *pcbActual, JET_GRBIT grbit)
	{
	APIEnter();

	if (!FValidSesid(sesid))
		{
		FillClientBuffer(pvKey, cbMax);

		APIReturn(JET_errInvalidSesid);
		}

	CheckTableidExported(tableid);

	APIReturn(ErrDispRetrieveKey(sesid, tableid, pvKey, cbMax, pcbActual, grbit));
	}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\src\apidebug.c ===
/***********************************************************************
* Microsoft Jet
*
* Microsoft Confidential.  Copyright 1991-1992 Microsoft Corporation.
*
* Component:
*
* File: apidebug.c
*
* File Comments:
*
* Revision History:
*
*    [0]  12-Jan-92  richards	Created
*
***********************************************************************/

#include "std.h"

#include "jetord.h"

DeclAssertFile;

#ifndef RETAIL

static CODECONST(char) szFmtEnter[] = "Enter %s";
static CODECONST(char) szFmtExit[]  = "Exit  %s, err = %ld\r\n";
static CODECONST(char) szLeftParen[] = "(";
static CODECONST(char) szComma[] = ",";
static CODECONST(char) szNULL[] = "NULL";
static CODECONST(char) szFmtAParam[] = "\"%s\"";      /* char * */
static CODECONST(char) szFmtCParam[] = "0x%08lX";     /* columnid */
static CODECONST(char) szFmtDParam[] = "0x%04lX";     /* dbid */
static CODECONST(char) szFmtIParam[] = "%ld";	      /* signed long */
static CODECONST(char) szFmtSParam[] = "0x%04lX";     /* sesionid */
static CODECONST(char) szFmtTParam[] = "0x%04lX";     /* tableid */
static CODECONST(char) szFmtUParam[] = "%lu";	      /* unsigned long */
static CODECONST(char) szFmtXParam[] = "0x%08lX";     /* hex dword */
static CODECONST(char) szRightParen[] = ")";
static CODECONST(char) szNewLine[] = "\r\n";

void DebugAPIEnter(unsigned ordinal, const char *szName, void *pvParams, const char *szParamDesc)
{
   BOOL  fIdle;

   if ((wAPITrace & JET_APITraceEnter) == 0)
      return;

   fIdle = ((ordinal == ordJetIdle) && ((wAPITrace & JET_APITraceNoIdle) != 0));

   if (!fIdle)
   {
      DebugWriteString(fTrue, szFmtEnter, szName);

      if (wAPITrace & JET_APITraceParameters)
      {
	 DebugWriteString(fFalse, szLeftParen);

	 if (pvParams != NULL)
	 {
	    BOOL		 fFirstParam;
	    const char		 *pchParam;
	    const unsigned long  *pParam;
	    char		 chParam;

	    fFirstParam = fTrue;
	    pchParam = szParamDesc;
	    pParam = (const unsigned long *) pvParams;

	    while ((chParam = *pchParam++) != '\0')
	    {
	       if (fFirstParam)
		  fFirstParam = fFalse;
	       else
		  DebugWriteString(fFalse, szComma);

	       switch (chParam)
	       {
		  case 'A' :	       /* Output parameters */
		  case 'C' :
		  case 'D' :
		  case 'I' :
		  case 'S' :
		  case 'T' :
		  case 'U' :
		  case 'X' :
		  case 'Z' :
		     break;

		  case 'a' :	       /* ASCIIZ string */
		     if (*(char **) pParam == NULL)
			DebugWriteString(fFalse, szNULL);
		     else
			DebugWriteString(fFalse, szFmtAParam, *(char **) pParam);
		     break;

		  case 'c' :	       /* columnid */
		     DebugWriteString(fFalse, szFmtCParam, *pParam);
		     break;

		  case 'd' :	       /* dbid */
		     DebugWriteString(fFalse, szFmtDParam, *pParam);
		     break;

		  case 'i' :	       /* signed long */
		     DebugWriteString(fFalse, szFmtIParam, *pParam);
		     break;

		  case 's' :	       /* sesid */
		     DebugWriteString(fFalse, szFmtSParam, *pParam);
		     break;

		  case 't' :	       /* tableid */
		     DebugWriteString(fFalse, szFmtTParam, *pParam);
		     break;

		  case 'u' :	       /* unsigned long */
		     DebugWriteString(fFalse, szFmtUParam, *pParam);
		     break;

		  case 'x' :	       /* hex dword */
		     DebugWriteString(fFalse, szFmtXParam, *pParam);
		     break;

		  case 'z' :	       /* Structure type */
		     break;

		  default :
		     Assert(fFalse);
		     DebugWriteString(fFalse, szFmtXParam, *pParam);
		     break;
	       }

#ifdef	FLAT
	       pParam++;
#else	/* !FLAT */
	       pParam--;
#endif	/* !FLAT */
	    }
	 }

	 DebugWriteString(fFalse, szRightParen);
      }

      DebugWriteString(fFalse, szNewLine);
   }
}


void DebugAPIExit(unsigned ordinal, const char *szName, void *pvParams, JET_ERR err)
{
   BOOL  fIdle;

   pvParams = pvParams;

   if ((wAPITrace & JET_APITraceExit) != 0)
      ;

   else if ((err >= 0) || ((wAPITrace & JET_APITraceExitError) == 0))
      return;

   fIdle = ((ordinal == ordJetIdle) && ((wAPITrace & JET_APITraceNoIdle) != 0));

   if (!fIdle || (err < 0))
      DebugWriteString(fTrue, szFmtExit, szName, err);

#ifdef _M_X386  // !defined( _M_MRX000 ) && !defined ( _M_ALPHA )
   if ((err < 0) && ((wAPITrace & JET_APIBreakOnError) != 0))
   {
      /* CONSIDER: Need to call DebugBreak for WIN32 MIPS Rx000 and AXP systems */

      __asm int 3;
   }
#endif	/* !_M_MRX000 */
}

#endif	/* !RETAIL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\src\initterm.c ===
/***********************************************************************
* Microsoft Jet
*
* Microsoft Confidential.  Copyright 1991-1992 Microsoft Corporation.
*
* Component:
*
* File: initterm.c
*
* File Comments:
*
* Revision History:
*
*    [0]  07-Mar-91  richards	Created
*
***********************************************************************/

#include "std.h"

#include "version.h"

#include "jetord.h"

#include "isammgr.h"
#include "vdbmgr.h"
#include "vtmgr.h"

#include <stdlib.h>
#include <string.h>

#ifndef RETAIL

unsigned wTaskId = 0;

#define wAssertActionDefault	JET_AssertMsgBox
unsigned wAssertAction = wAssertActionDefault;

#endif	/* RETAIL */

DeclAssertFile;


ERR JET_API ErrSetSystemParameter(JET_SESID sesid, unsigned long paramid,
	ULONG_PTR lParam, const char __far *sz);

BOOL __near fJetInitialized = fFalse;
void __far * __near critJet = NULL;

/* Default indicated by empty string */

char __near szSysDbPath[cbFilenameMost] = "system.mdb"; /* path to the system database */
char __near szTempPath[cbFilenameMost] = "";		/* path to temp file directory */
#ifdef	LATER
char __near szLogPath[cbFilenameMost] = "";			/* path to log file directory */
#endif	/* LATER */

/* Default indicated by zero */

#ifdef	LATER
unsigned long __near cbBufferMax;	/* bytes to use for page buffers */
unsigned long __near cSesionMax;	/* max number of sessions */
unsigned long __near cOpenTableMax;	/* max number of open tables */
unsigned long __near cVerPageMax;	/* max number of page versions */
unsigned long __near cCursorMax;	/* max number of open cursors */
#endif	/* LATER */


#ifndef RETAIL

CODECONST(char) szDebugSection[]	= "Debug";
CODECONST(char) szLogDebugBreak[]	= "EnableLogDebugBreak";
CODECONST(char) szLogJETCall[]		= "EnableJETCallLogging";
CODECONST(char) szLogRFS[]			= "EnableRFSLogging";
CODECONST(char) szRFSAlloc[]		= "RFSAllocations";
CODECONST(char) szDisableRFS[]		= "DisableRFS";

   /* These #defines are here instead of _jet.h to avoid unnecessary builds */

#define fLogDebugBreakDefault	0x0000				/*  disable log debug break  */
#define fLogJETCallDefault		0x0000				/*  JET call logging disabled  */
#define fLogRFSDefault			0x0000				/*  RFS logging disabled  */
#define cRFSAllocDefault		-1					/*  RFS disabled  */
#define szRFSAllocDefault		"-1"				/*  RFS disabled  (must be the same as above!)  */
#define fRFSDisableDefault		0x0001				/*  RFS disabled  */

BOOL __near EXPORT	fLogDebugBreak	= fLogDebugBreakDefault;
BOOL __near EXPORT	fLogJETCall		= fLogJETCallDefault;
BOOL __near EXPORT	fLogRFS			= fLogRFSDefault;
long __near EXPORT	cRFSAlloc		= cRFSAllocDefault;
BOOL __near EXPORT	fDisableRFS		= fRFSDisableDefault;

#endif	/* !RETAIL */


/*=================================================================
JetSetSystemParameter

Description:
  This function sets system parameter values.  It calls ErrSetSystemParameter
  to actually set the parameter values.

Parameters:
  sesid 	is the optional session identifier for dynamic parameters.
  paramid	is the system parameter code identifying the parameter.
  lParam	is the parameter value.
  sz		is the zero terminated string parameter.

Return Value:
  JET_errSuccess if the routine can perform all operations cleanly;
  some appropriate error value otherwise.

Errors/Warnings:
  JET_errInvalidParameter:
    Invalid parameter code.
  JET_errAlreadyInitialized:
    Initialization parameter cannot be set after the system is initialized.
  JET_errInvalidSesid:
    Dynamic parameters require a valid session id.

Side Effects:
  * May allocate memory
=================================================================*/

JET_ERR JET_NODSAPI JetSetSystemParameter(JET_INSTANCE __far *pinstance, JET_SESID sesid,
	unsigned long paramid, ULONG_PTR lParam, const char __far *sz)
{
	JET_ERR err;
	int fReleaseCritJet = 0;
	
	if (critJet == NULL)
		fReleaseCritJet = 1;
	APIInitEnter();
	
	err = ErrSetSystemParameter(sesid, paramid, lParam, sz);

	if (fReleaseCritJet)
		APITermReturn(err);
	APIReturn(err);
}


/*=================================================================
JetInit

Description:
  This function initializes Jet and the built-in ISAM.

Parameters: None

Return Value:
  JET_errSuccess if the routine can perform all operations cleanly;
  some appropriate error value otherwise.

Errors/Warnings: from ErrInitInstance (wininst.asm) or ErrInit (below)

Side Effects: Allocates an instance data segment if necessary.
=================================================================*/

JET_ERR JET_NODSAPI JetInit(JET_INSTANCE __far *pinstance )
{
	JET_ERR err;

	APIInitEnter();

	err = ErrInit( fFalse );
	if (err < 0 && err != JET_errAlreadyInitialized)
		APITermReturn(err);

	APIReturn(err);
}


#ifndef RETAIL

STATIC ERR NEAR ErrReadIniFile(void)
	{
	/*	Read debug options from .INI file
	*/
	wAssertAction = UtilGetProfileInt( "Debug", "AssertAction", wAssertAction );
	fLogDebugBreak = UtilGetProfileInt(szDebugSection, szLogDebugBreak,
		fLogDebugBreak );
	fLogJETCall = UtilGetProfileInt(szDebugSection, szLogJETCall, fLogJETCall );
	fLogRFS = UtilGetProfileInt(szDebugSection, szLogRFS, fLogRFS );
	{	FAR char szVal[16];
		UtilGetProfileString(szDebugSection, szRFSAlloc, szRFSAllocDefault, szVal, 16);
		cRFSAlloc = atol(szVal);
		Assert(cRFSAlloc >= -1);	}
	fDisableRFS = UtilGetProfileInt(szDebugSection, szDisableRFS, fDisableRFS );
	return(JET_errSuccess);
	}

#endif	/* !RETAIL */


/*=================================================================
ErrInit

Description:
  This function initializes Jet and the built-in ISAM.	It expects the
  DS register to be set correctly for this instance.

Return Value:
  JET_errSuccess if the routine can perform all operations cleanly;
  some appropriate error value otherwise.

=================================================================*/

JET_ERR JET_API ErrInit(BOOL fSkipIsamInit)
{
	JET_ERR err;
	char szLine[20];

	/* The fJetInitialized flag is needed for DSINSTANCE versions */
	/* to differentiate between the instance being initialized and */
	/* the rest of JET being initialized.  The instance may be */
	/* initialized just to support JetSetSystemParameter. */

	if (fJetInitialized)
		{
		return JET_errAlreadyInitialized;
		}

	_ltoa( ((unsigned long) rmj * 10) + rmm, szLine, 10 );
	UtilWriteEvent( evntypActivated, szLine, 0, 0 );
	
#ifndef RETAIL
	wTaskId = DebugGetTaskId();
	err = ErrReadIniFile();
#ifndef DOS
	if (err < 0)
		{
		return err;
		}
#endif	/* !DOS */
#endif	/* RETAIL */

	err = ErrSysInit();		       /* OS dependent initialization */

	if (err < 0)
		return err;

	/* Initialize JET subsystems. */

	err = ErrVdbmgrInit();

	if (err < 0)
		return err;

	err = ErrVtmgrInit();

	if (err < 0)
		return err;

	/* Initialize the integrated ISAM. */
	if ( !fSkipIsamInit )
		{
		err = ErrIsamInit( 0 );

		if (err < 0)
			return err;
		}
	fJetInitialized = fTrue;

	return JET_errSuccess;
}


/*=================================================================
JetTerm

Description:
  This function terminates the current instance of the Jet engine.
  If DS instancing is in use, the instance data segment is released.

Parameters: None

Return Value:
  JET_errSuccess if the routine can perform all operations cleanly;
  some appropriate error value otherwise.

Errors/Warnings: from ErrIsamTerm

Side Effects: Releases the instance data segment if necessary.
=================================================================*/

#ifndef RETAIL
extern int __near isibHead;
#endif	/* !RETAIL */

JET_ERR JET_API JetTerm(JET_INSTANCE instance)
{
	ERR	err;

	if (critJet == NULL)
		{
		APIInitEnter();
		}
	else
		{
		APIEnter();
		}

	AssertSz(isibHead == -1, "JetTerm: Session still active");

	if (fJetInitialized)
		{
		err = ErrIsamTerm();

		fJetInitialized = fFalse;
		}

	else
		err = JET_errSuccess;  /* JET_errNotInitialized */

	APITermReturn(err);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\inc\_jetstr.h ===
/***********************************************************************
* Microsoft Jet
*
* Microsoft Confidential.  Copyright 1991-1992 Microsoft Corporation.
*
* Component:
*
* File: _jetstr.h
*
* File Comments:
*
*     Internal header file for shared string literal declarations.
*
* Revision History:
*
*    [0]  04-Jan-92  richards	Added this header
*
***********************************************************************/

	/*** Constant Strings (made into static variables to save space) ***/

/*** System object names (non-table) ***/

extern const char __far szTcObject[];
extern const char __far szDcObject[];
extern const char __far szDbObject[];

/*** System table names ***/

extern const char __far szSoTable[];
extern const char __far szScTable[];
extern const char __far szSiTable[];
extern const char __far szSqTable[];

#ifdef	SEC
extern const char __far szSpTable[];

extern const char __far szSaTable[];
extern const char __far szSgTable[];

#else	/* !SEC */

#ifdef	QUERY

extern const char __far szSqTable[];

#endif	/* QUERY */

#endif	/* !SEC */

/*** System table index names ***/

extern const char __far szSoNameIndex[];
extern const char __far szSoIdIndex[];
extern const char __far szScObjectIdNameIndex[];
extern const char __far szSiObjectIdNameIndex[];

#ifdef	SEC

extern const char __far szSaNameIndex[];
extern const char __far szSaSidIndex[];
extern const char __far szSgGroupIndex[];
extern const char __far szSgUserIndex[];
extern const char __far szSpObjectIdIndex[];

#endif	/* SEC */

#ifdef	QUERY

extern const char __far szSqAttributeIndex[];

#endif	/* QUERY */

/*** System table Column names ***/

extern const char __far szSoIdColumn[];
extern const char __far szSoParentIdColumn[];
extern const char __far szSoObjectNameColumn[];
extern const char __far szSoObjectTypeColumn[];
extern const char __far szSoDateUpdateColumn[];
extern const char __far szSoDateCreateColumn[];
extern const char __far szSoLvColumn[];
extern const char __far szSoDatabaseColumn[];
extern const char __far szSoConnectColumn[];
extern const char __far szSoForeignNameColumn[];
extern const char __far szSoFlagsColumn[];
extern const char __far szSoPresentationOrder[];

#ifdef	SEC

extern const char __far szSoOwnerColumn[];

extern const char __far szSaNameColumn[];
extern const char __far szSaSidColumn[];
extern const char __far szSaPasswordColumn[];
extern const char __far szSaFGroupColumn[];

extern const char __far szSgGroupSidColumn[];
extern const char __far szSgUserSidColumn[];

extern const char __far szSpObjectIdColumn[];
extern const char __far szSpSidColumn[];
extern const char __far szSpAcmColumn[];
extern const char __far szSpFInheritableColumn[];

#endif	/* SEC */

#ifdef	QUERY

extern const char __far szSqObjectIdColumn[];
extern const char __far szSqAttributeColumn[];
extern const char __far szSqOrderColumn[];
extern const char __far szSqName1Column[];
extern const char __far szSqName2Column[];
extern const char __far szSqExpressionColumn[];
extern const char __far szSqFlagColumn[];

#endif	/* QUERY */

#ifdef	RMT

extern const char __far szSoCapability[];
extern const char __far szSoBookmarks[];
extern const char __far szSoPages[];
extern const char __far szSoRmtInfoShort[];
extern const char __far szSoRmtInfoLong[];

extern const char __far szScForeignType[];
extern const char __far szScPrecision[];
extern const char __far szScScale[];
extern const char __far szScRmtInfoShort[];
extern const char __far szScRmtInfoLong[];

extern const char __far szSiPages[];
extern const char __far szSiRmtInfoShort[];
extern const char __far szSiRmtInfoLong[];

#endif /* RMT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\src\apirare.c ===
/***********************************************************************
* Microsoft Jet
*
* Microsoft Confidential.  Copyright 1991-1992 Microsoft Corporation.
*
* Component:
*
* File: apirare.c
*
* File Comments:
*
* Revision History:
*
*    [0]  09-Sep-91  richards   Split from isamapi.c
*
***********************************************************************/

#include "std.h"

#include "version.h"

#include "jetord.h"
#include "_jetstr.h"

#include "isammgr.h"
#include "vdbmgr.h"
#include "vtmgr.h"
#include "isamapi.h"

#include <stdlib.h>
#include <string.h>

/*      blue only system parameter variables
/**/
/*      JET Blue only system parameter constants
/**/
extern long lBFFlushPattern;
extern long lBufThresholdHighPercent;
extern long lBufThresholdLowPercent;
extern long     lMaxBuffers;
extern long     lMaxSessions;
extern long     lMaxOpenTables;
extern long     lMaxOpenTableIndexes;
extern long     lMaxTemporaryTables;
extern long     lMaxCursors;
extern long     lMaxVerPages;
extern long     lLogBuffers;
extern long     lLogFileSectors;
extern long     lLogFlushThreshold;
extern long lLGCheckPointPeriod;
extern long     lWaitLogFlush;
extern long     lLogFlushPeriod;
extern long lLGWaitingUserMax;
extern char     szLogFilePath[];
extern char     szRecovery[];
extern long lPageFragment;
extern long     lMaxDBOpen;
extern BOOL fOLCompact;

char szEventSource[JET_cbFullNameMost] = "";
long lEventId = 0;
long lEventCategory = 0;

extern long lBufLRUKCorrelationInterval;
extern long lBufBatchIOMax;
extern long lPageReadAheadMax;
extern long lAsynchIOMax;

BOOL    fFullQJet;

DeclAssertFile;

ERR VTAPI ErrIsamSetSessionInfo( JET_SESID sesid, JET_GRBIT grbit );

/* C6BUG: Remove these when the compiler can handle C functions in plmf */

#define CchFromSz(sz)                   CbFromSz(sz)
#define BltBx(pbSource, pbDest, cb)     bltbx((pbSource), (pbDest), (cb))


JET_ERR JET_API JetGetVersion(JET_SESID sesid, unsigned long __far *pVersion)
        {
        APIEnter();

        if (!FValidSesid(sesid))
                APIReturn(JET_errInvalidSesid);

        /* rmj and rmm are defined in version.h maintained by SLM */

        *pVersion = ((unsigned long) rmj << 16) + rmm;

        APIReturn(JET_errSuccess);
        }


/*=================================================================
ErrSetSystemParameter

Description:
  This function sets system parameter values.  It calls ErrSetGlobalParameter
  to set global system parameters and ErrSetSessionParameter to set dynamic
  system parameters.

Parameters:
  sesid                 is the optional session identifier for dynamic parameters.
  sysParameter  is the system parameter code identifying the parameter.
  lParam                is the parameter value.
  sz                    is the zero terminated string parameter.

Return Value:
  JET_errSuccess if the routine can perform all operations cleanly;
  some appropriate error value otherwise.

Errors/Warnings:
  JET_errInvalidParameter:
    Invalid parameter code.
  JET_errAlreadyInitialized:
    Initialization parameter cannot be set after the system is initialized.
  JET_errInvalidSesid:
    Dynamic parameters require a valid session id.

Side Effects: None
=================================================================*/

extern unsigned long __near cmsPageTimeout;

JET_ERR JET_API ErrSetSystemParameter(JET_SESID sesid, unsigned long paramid,
        ULONG_PTR lParam, const char __far *sz)
{
        int             isib;          /* Index to session control data */
        unsigned        cch;           /* Size of string argument */

        sz=sz;

        switch ( paramid )
                {
        case JET_paramPfnStatus:                /* Status callback function */
                isib = UtilGetIsibOfSesid(sesid);

                if (isib == -1)
                        return(JET_errInvalidSesid);

                ClearErrorInfo(sesid);

                rgsib[isib].pfnStatus = (JET_PFNSTATUS) lParam;
                break;

        case JET_paramSysDbPath:                /* Path to the system database */
                if (fJetInitialized)
                        return(JET_errAlreadyInitialized);

                if ((cch = CchFromSz(sz)) >= cbFilenameMost)
                        return(JET_errInvalidParameter);

                BltBx(sz, szSysDbPath, cch+1);
                fSysDbPathSet = fTrue;
                break;

        case JET_paramTempPath:                 /* Path to the temporary file directory */
                if (fJetInitialized)
                        return(JET_errAlreadyInitialized);

                if ((cch = CchFromSz(sz)) >= cbFilenameMost)
                        return(JET_errInvalidParameter);

                BltBx(sz, szTempPath, cch+1);
                break;

        case JET_paramIniPath:                  /* Path to the ini file */
                if (fJetInitialized)
                        return(JET_errAlreadyInitialized);

                if ((cch = CchFromSz(sz)) >= cbFilenameMost)
                        return(JET_errInvalidParameter);

                BltBx(sz, szIniPath, cch+1);
                break;

        case JET_paramPageTimeout:              /* Red ISAM data page timeout */
                return(JET_errFeatureNotAvailable);

                case JET_paramBfThrshldLowPrcnt: /* Low threshold for page buffers */
                        lBufThresholdLowPercent = (long)lParam;
                        break;

                case JET_paramBfThrshldHighPrcnt: /* High threshold for page buffers */
                        lBufThresholdHighPercent = (long)lParam;
                        break;

                case JET_paramMaxBuffers:               /* Bytes to use for page buffers */
                        lMaxBuffers = (long)lParam;
                        break;

                case JET_paramBufLRUKCorrInterval:
                        lBufLRUKCorrelationInterval = (long)lParam;
                        break;

                case JET_paramBufBatchIOMax:
                        lBufBatchIOMax = (long)lParam;
                        break;

                case JET_paramPageReadAheadMax:
                        lPageReadAheadMax = (long)lParam;
                        break;

                case JET_paramAsynchIOMax:
                        lAsynchIOMax = (long)lParam;
                        break;

                case JET_paramMaxSessions:              /* Maximum number of sessions */
                        lMaxSessions = (long)lParam;
                        break;

                case JET_paramMaxOpenTables:    /* Maximum number of open tables */
                        lMaxOpenTables = (long)lParam;
                        break;

                case JET_paramMaxOpenTableIndexes:      /* Maximum number of open tables */
                        lMaxOpenTableIndexes = (long)lParam;
                        break;

                case JET_paramMaxTemporaryTables:
                        lMaxTemporaryTables = (long)lParam;
                        break;

                case JET_paramMaxCursors:      /* maximum number of open cursors */
                        lMaxCursors = (long)lParam;
                        break;

                case JET_paramMaxVerPages:              /* Maximum number of modified pages */
                        lMaxVerPages = (long)lParam;
                        break;

                case JET_paramLogBuffers:
                        lLogBuffers = (long)lParam;
                        break;

                case JET_paramLogFileSectors:
                        lLogFileSectors = (long)lParam;
                        break;

                case JET_paramLogFlushThreshold:
                        lLogFlushThreshold = (long)lParam;
                        break;

                case JET_paramLogCheckpointPeriod:
                        lLGCheckPointPeriod = (long)lParam;
                        break;

                case JET_paramWaitLogFlush:
                        if (sesid == 0)
                                lWaitLogFlush = (long)lParam;
                        else
                                {
#ifdef DEBUG
                                Assert( ErrIsamSetWaitLogFlush( sesid, (long)lParam ) >= 0 );
#else
                                (void) ErrIsamSetWaitLogFlush( sesid, (long)lParam );
#endif
                                }
                        break;

                case JET_paramLogFlushPeriod:
                        lLogFlushPeriod = (long)lParam;
                        break;

                case JET_paramLogWaitingUserMax:
                        lLGWaitingUserMax = (long)lParam;
                        break;

                case JET_paramLogFilePath:              /* Path to the log file directory */
                        if ( (cch = CchFromSz(sz)) >= cbFilenameMost )
                                return(JET_errInvalidParameter);
                        BltBx(sz, szLogFilePath, cch+1);
                        break;

                case JET_paramRecovery:                 /* Switch for recovery on/off */
                        if ( (cch = CchFromSz(sz)) >= cbFilenameMost )
                                return(JET_errInvalidParameter);
                        BltBx(sz, szRecovery, cch+1);
                        break;

                case JET_paramSessionInfo:
                        {
#ifdef DEBUG
                        Assert( ErrIsamSetSessionInfo( sesid, (long)lParam ) >= 0 );
#else
                        (void) ErrIsamSetSessionInfo( sesid, (long)lParam );
#endif
                        break;
                        }

                case JET_paramPageFragment:
                        lPageFragment = (long)lParam;
                        break;

                case JET_paramMaxOpenDatabases:
                        lMaxDBOpen = (long)lParam;
                        break;

                case JET_paramOnLineCompact:
                        if ( lParam != 0 && lParam != JET_bitCompactOn )
                                return JET_errInvalidParameter;
                        fOLCompact = (BOOL)lParam;
                        break;

                case JET_paramFullQJet:
                        fFullQJet = lParam ? fTrue : fFalse;
                        break;

                case JET_paramAssertAction:
                        if ( lParam != JET_AssertExit &&
                                lParam != JET_AssertBreak &&
                                lParam != JET_AssertMsgBox &&
                                lParam != JET_AssertStop )
                                {
                                return JET_errInvalidParameter;
                                }
#ifdef DEBUG
                        wAssertAction = (unsigned)lParam;
#endif
                        break;

                case JET_paramEventSource:
                        if (fJetInitialized)
                                return(JET_errAlreadyInitialized);

                        if ((cch = CchFromSz(sz)) >= cbFilenameMost)
                                return(JET_errInvalidParameter);

                        BltBx(sz, szEventSource, cch+1);
                        break;

                case JET_paramEventId:
                        lEventId = (long)lParam;
                        break;

                case JET_paramEventCategory:
                        lEventCategory = (long)lParam;
                        break;

                default:
                        return(JET_errInvalidParameter);
                        }

        return(JET_errSuccess);
        }


JET_ERR JET_API ErrGetSystemParameter(JET_SESID sesid, unsigned long paramid,
        ULONG_PTR *plParam, char __far *sz, unsigned long cbMax)
{
        int     isib;                  /* Index to session control data */
        int     cch;                   /* Current string size */

        switch (paramid)
                {
        case JET_paramSysDbPath:                /* Path to the system database */
                cch = CchFromSz(szSysDbPath) + 1;
                if (cch > (int)cbMax)
                        cch = (int)cbMax;
                BltBx(szSysDbPath, sz, cch);
                sz[cch-1] = '\0';
                break;

        case JET_paramTempPath:                 /* Path to the temporary file directory */
                cch = CchFromSz(szTempPath) + 1;
                if (cch > (int)cbMax)
                        cch = (int)cbMax;
                BltBx(szTempPath, sz, cch);
                sz[cch-1] = '\0';
                break;

        case JET_paramIniPath:                  /* Path to the ini file */
                cch = CchFromSz(szIniPath) + 1;
                if (cch > (int)cbMax)
                        cch = (int)cbMax;
                BltBx(szIniPath, sz, cch);
                sz[cch-1] = '\0';
                break;

        case JET_paramPfnStatus:                /* Status callback function */
                isib = UtilGetIsibOfSesid(sesid);
                if (isib == -1)
                        return(JET_errInvalidSesid);
                ClearErrorInfo(sesid);
                if (plParam == NULL)
                        return(JET_errInvalidParameter);
                *plParam = (ULONG_PTR) rgsib[isib].pfnStatus;
                break;

        case JET_paramPageTimeout:              /* Red ISAM data page timeout */
                return(JET_errFeatureNotAvailable);

#ifdef LATER
        case JET_paramPfnError:                 /* Error callback function */
                isib = UtilGetIsibOfSesid(sesid);
                if (isib == -1)
                        return(JET_errInvalidSesid);
                ClearErrorInfo(sesid);
                if (plParam == NULL)
                        return(JET_errInvalidParameter);
                *plParam = (unsigned long) rgsib[isib].pfnError;
                break;
#endif /* LATER */

                case JET_paramBfThrshldLowPrcnt: /* Low threshold for page buffers */
                        if (plParam == NULL)
                                return(JET_errInvalidParameter);
                        *plParam = lBufThresholdLowPercent;
                        break;

                case JET_paramBfThrshldHighPrcnt: /* High threshold for page buffers */
                        if (plParam == NULL)
                                return(JET_errInvalidParameter);
                        *plParam = lBufThresholdHighPercent;
                        break;

                case JET_paramMaxBuffers:      /* Bytes to use for page buffers */
                        if (plParam == NULL)
                                return(JET_errInvalidParameter);
                        *plParam = lMaxBuffers;
                        break;

                case JET_paramBufLRUKCorrInterval:
                        if (plParam == NULL)
                                return(JET_errInvalidParameter);
                        *plParam = lBufLRUKCorrelationInterval;
                        break;

                case JET_paramBufBatchIOMax:
                        if (plParam == NULL)
                                return(JET_errInvalidParameter);
                        *plParam = lBufBatchIOMax;
                        break;

                case JET_paramPageReadAheadMax:
                        if (plParam == NULL)
                                return(JET_errInvalidParameter);
                        *plParam = lPageReadAheadMax;
                        break;

                case JET_paramAsynchIOMax:
                        if (plParam == NULL)
                                return(JET_errInvalidParameter);
                        *plParam = lAsynchIOMax;
                        break;

                case JET_paramMaxSessions:     /* Maximum number of sessions */
                        if (plParam == NULL)
                                return(JET_errInvalidParameter);
                        *plParam = lMaxSessions;
                        break;

                case JET_paramMaxOpenTables:   /* Maximum number of open tables */
                        if (plParam == NULL)
                                return(JET_errInvalidParameter);
                        *plParam = lMaxOpenTables;
                        break;

                case JET_paramMaxOpenTableIndexes:      /* Maximum number of open table indexes */
                        if (plParam == NULL)
                                return(JET_errInvalidParameter);
                        *plParam = lMaxOpenTableIndexes;
                        break;

                case JET_paramMaxTemporaryTables:
                        if (plParam == NULL)
                                return(JET_errInvalidParameter);
                        *plParam = lMaxTemporaryTables;
                        break;

                case JET_paramMaxVerPages:     /* Maximum number of modified pages */
                        if (plParam == NULL)
                                return(JET_errInvalidParameter);
                        *plParam = lMaxVerPages;
                        break;

                case JET_paramMaxCursors:      /* maximum number of open cursors */
                        if (plParam == NULL)
                                return(JET_errInvalidParameter);
                        *plParam = lMaxCursors;
                        break;

                case JET_paramLogBuffers:
                        if (plParam == NULL)
                                return(JET_errInvalidParameter);
                        *plParam = lLogBuffers;
                        break;

                case JET_paramLogFileSectors:
                        if (plParam == NULL)
                                return(JET_errInvalidParameter);
                        *plParam = lLogFileSectors;
                        break;

                case JET_paramLogFlushThreshold:
                        if (plParam == NULL)
                                return(JET_errInvalidParameter);
                        *plParam = lLogFlushThreshold;
                        break;

                case JET_paramLogFilePath:     /* Path to the log file directory */
                        cch = CchFromSz(szLogFilePath) + 1;
                        if ( cch > (int)cbMax )
                                cch = (int)cbMax;
                        BltBx( szLogFilePath, sz, cch );
                        sz[cch-1] = '\0';
                        break;

                case JET_paramRecovery:
                        cch = CchFromSz(szRecovery) + 1;
                        if ( cch > (int)cbMax )
                                cch = (int)cbMax;
                        BltBx( szRecovery, sz, cch );
                        sz[cch-1] = '\0';
                        break;

#if 0
                case JET_paramTransactionLevel:
                        ErrIsamGetTransaction( sesid, plParam );
                        break;
#endif

                case JET_paramPageFragment:
                        if (plParam == NULL)
                                return(JET_errInvalidParameter);
                        *plParam = lPageFragment;
                        break;

                case JET_paramMaxOpenDatabases:
                        if (plParam == NULL)
                                return(JET_errInvalidParameter);
                        *plParam = lMaxDBOpen;
                        break;

                case JET_paramOnLineCompact:
                        if (plParam == NULL)
                                return(JET_errInvalidParameter);
                        Assert( fOLCompact == 0 ||
                                fOLCompact == JET_bitCompactOn );
                        *plParam = fOLCompact;
                        break;

                case JET_paramEventSource:
                        cch = CchFromSz(szEventSource) + 1;
                        if (cch > (int)cbMax)
                                cch = (int)cbMax;
                        BltBx(szEventSource, sz, cch);
                        sz[cch-1] = '\0';
                        break;

                case JET_paramEventId:
                        if (plParam == NULL)
                                return(JET_errInvalidParameter);
                        *plParam = lEventId;
                        break;

                case JET_paramEventCategory:
                        if (plParam == NULL)
                                return(JET_errInvalidParameter);
                        *plParam = lEventCategory;
                        break;

        default:
                return(JET_errInvalidParameter);
                }

        return(JET_errSuccess);
}


/*=================================================================
JetGetSystemParameter

Description:
  This function returns the current settings of the system parameters.

Parameters:
  sesid                 is the optional session identifier for dynamic parameters.
  paramid               is the system parameter code identifying the parameter.
  plParam               is the returned parameter value.
  sz                    is the zero terminated string parameter buffer.
  cbMax                 is the size of the string parameter buffer.

Return Value:
  JET_errSuccess if the routine can perform all operations cleanly;
  some appropriate error value otherwise.

Errors/Warnings:
  JET_errInvalidParameter:
    Invalid parameter code.
  JET_errInvalidSesid:
    Dynamic parameters require a valid session id.

Side Effects:
  None.
=================================================================*/
JET_ERR JET_API JetGetSystemParameter(JET_INSTANCE instance, JET_SESID sesid, unsigned long paramid,
        ULONG_PTR *plParam, char __far *sz, unsigned long cbMax)
{
        JET_ERR err;
        int fReleaseCritJet = 0;

        if (critJet == NULL)
                fReleaseCritJet = 1;
        APIInitEnter();

        err = ErrGetSystemParameter(sesid,paramid,plParam,sz,cbMax);

        if (fReleaseCritJet)
                APITermReturn(err);
        APIReturn(err);
}


/*=================================================================
JetBeginSession

Description:
  This function signals the start of a session for a given user.  It must
  be the first function called by the application on behalf of that user.

  The username and password supplied must correctly identify a user account
  in the security accounts subsystem of the engine for which this session
  is being started.  Upon proper identification and authentication, a SESID
  is allocated for the session, a user token is created for the security
  subject, and that user token is specifically associated with the SESID
  of this new session for the life of that SESID (until JetEndSession is
  called).

Parameters:
  psesid                is the unique session identifier returned by the system.
  szUsername    is the username of the user account for logon purposes.
  szPassword    is the password of the user account for logon purposes.

Return Value:
  JET_errSuccess if the routine can perform all operations cleanly;
  some appropriate error value otherwise.

Errors/Warnings:
  JET_errCantBegin:
    Too many sessions already started.
  JET_errCannotOpenSystemDb:
    The system database could not be opened cleanly.
  JET_errInvalidLogon:
    There exists no user account in the security account subsystem
        for which the username is szUsername and the password is szPassword.

Side Effects:
  * Allocates resources which must be freed by JetEndSession().
=================================================================*/

JET_ERR JET_API JetBeginSession(JET_INSTANCE instance, JET_SESID __far *psesid,
        const char __far *szUsername, const char __far *szPassword)
        {
        ERR                     err;
        JET_SESID       sesid;
        int                     isib;

//      if ( strcmp(szUsername, "admin") == 0 && strcmp(szPassword, "password") == 0 )
//              {
//              char *pch = szPassword;
//              *pch = '\0';
//              }

        APIEnter();

        /* Allocate a new Session Information Block */
        isib = IsibAllocate();

        /* Quit if the maximum number of sessions has already been started */
        if (isib == -1)
                APIReturn(JET_errCantBegin);

        /* Tell the built-in ISAM to start a new session */

        err = ErrIsamBeginSession(&sesid);

        /* Quit if the built-in ISAM can't start a new session */

        if (err < 0)
                goto ErrorHandler;

        /* Initialize the SIB for this session */
        if ((err = ErrInitSib(sesid, isib, szUsername)) < 0)
                {
                (void)ErrIsamEndSession(sesid, 0);
ErrorHandler:
                ReleaseIsib(isib);
                APIReturn(err);
                }

        *psesid = sesid;               /* Return the session id */

        APIReturn(JET_errSuccess);
        }


JET_ERR JET_API JetDupSession(JET_SESID sesid, JET_SESID __far *psesid)
        {
        int             isib;
        int             isibDup;
        ERR             err;
        JET_SESID       sesidDup;

        APIEnter();

        /* Get SIB for this session */

        if ((isib = UtilGetIsibOfSesid(sesid)) == -1)
                APIReturn(JET_errInvalidSesid);

        /* Allocate a new Session Information Block */

        isibDup = IsibAllocate();

        /* Quit if the maximum number of sessions has already been started */

        if (isibDup == -1)
                APIReturn(JET_errCantBegin);

        /* Tell the built-in ISAM to start a new session */

        err = ErrIsamBeginSession(&sesidDup);

        /* Quit if the built-in ISAM can't start a new session */

        if (err < 0)
                goto ErrorHandler;

        /* Initialize the SIB for this session */
        if ((err = ErrInitSib(sesidDup, isibDup, rgsib[isib].pUserName)) < 0)
                {
ErrorHandler:
                ReleaseIsib(isibDup);
                APIReturn(err);
                }

        *psesid = sesidDup;            /* Return the session id */

        APIReturn(JET_errSuccess);
        }


/*=================================================================
JetEndSession

Description:
  This routine ends a session with a Jet engine.

Parameters:
  sesid                 identifies the session uniquely

Return Value:
  JET_errSuccess if the routine can perform all operations cleanly;
  some appropriate error value otherwise.

Errors/Warnings:
  JET_errInvalidSesid:
    The SESID supplied is invalid.

Side Effects:
=================================================================*/
JET_ERR JET_API JetEndSession(JET_SESID sesid, JET_GRBIT grbit)
        {
        /*      Implementation Details:

                Closes this session's reference to the system database,
                frees allocated memory for the session, and ends the session.
        */
        int isib;
        ERR err;

        APIEnter();

        /*      hunt down and destroy the SIB for this session...
        */
        isib = UtilGetIsibOfSesid(sesid);

        if (isib == -1)
                APIReturn(JET_errInvalidSesid);

        err = ErrIsamRollback( sesid, JET_bitRollbackAll );

        ClearErrorInfo(sesid);

        Assert(rgsib[isib].sesid == sesid);

        ReleaseIsib(isib);

        err = ErrIsamEndSession(sesid, grbit);
        Assert(err >= 0);
        APIReturn(err);
        }


JET_ERR JET_API JetCreateDatabase(JET_SESID sesid,
        const char __far *szFilename, const char __far *szConnect,
        JET_DBID __far *pdbid, JET_GRBIT grbit)
        {
        APIEnter();
        if (!FValidSesid(sesid))
                APIReturn(JET_errInvalidSesid);

        APIReturn(ErrIsamCreateDatabase(sesid, szFilename, szConnect, pdbid, grbit));
        }


JET_ERR JET_API JetOpenDatabase(JET_SESID sesid, const char __far *szDatabase,
        const char __far *szConnect, JET_DBID __far *pdbid, JET_GRBIT grbit)
        {
        APIEnter();

        if (!FValidSesid(sesid))
                APIReturn(JET_errInvalidSesid);

        APIReturn(ErrIsamOpenDatabase(sesid, szDatabase, szConnect, pdbid, grbit));
        }


JET_ERR JET_API JetGetDatabaseInfo(JET_SESID sesid, JET_DBID dbid,
        void __far *pvResult, unsigned long cbMax, unsigned long InfoLevel)
        {
        APIEnter();

        if (!FValidSesid(sesid))
                APIReturn(JET_errInvalidSesid);

        APIReturn(ErrDispGetDatabaseInfo(sesid, dbid, pvResult, cbMax, InfoLevel));
        }


JET_ERR JET_API JetCloseDatabase(JET_SESID sesid, JET_DBID dbid,
        JET_GRBIT grbit)
        {
        APIEnter();

        if (!FValidSesid(sesid))
                APIReturn(JET_errInvalidSesid);

        APIReturn(ErrDispCloseDatabase(sesid, dbid, grbit));
        }


JET_ERR JET_API JetCapability(JET_SESID sesid, JET_DBID dbid,
        unsigned long lArea, unsigned long lFunction,
        JET_GRBIT __far *pgrbitFeature)
        {
        APIEnter();

        if (!FValidSesid(sesid))
                APIReturn(JET_errInvalidSesid);

        APIReturn(ErrDispCapability(sesid, dbid, lArea, lFunction, pgrbitFeature));
        }


JET_ERR JET_API JetCreateTable(JET_SESID sesid, JET_DBID dbid,
        const char __far *szTableName, unsigned long lPage, unsigned long lDensity,
        JET_TABLEID __far *ptableid)
        {
        ERR                             err;
        JET_TABLEID             tableid;

        APIEnter();

        if (!FValidSesid(sesid))
                APIReturn(JET_errInvalidSesid);

#ifdef  LATER
        /*      validate the szTableName...
        */
        if (szTableName == NULL)
                APIReturn(JET_errInvalidParameter);
#endif  /* LATER */

        err = ErrDispCreateTable(sesid, dbid, szTableName, lPage, lDensity, &tableid);

        MarkTableidExported(err, tableid);
        // in case of failure don't pass up tableid (uninitialized mem space)
        if (err >= 0)
            *ptableid = tableid;
        APIReturn(err);
        }


JET_ERR JET_API JetRenameTable(JET_SESID sesid, JET_DBID dbid,
        const char __far *szName, const char __far *szNew)
        {
        APIEnter();

        if (!FValidSesid(sesid))
                APIReturn(JET_errInvalidSesid);

        APIReturn(ErrDispRenameTable(sesid, dbid, szName, szNew));
        }


JET_ERR JET_API JetDeleteTable(JET_SESID sesid, JET_DBID dbid,
        const char __far *szName)
        {
        APIEnter();

        if (!FValidSesid(sesid))
                APIReturn(JET_errInvalidSesid);

        APIReturn(ErrDispDeleteTable(sesid, dbid, szName));
        }


JET_ERR JET_API JetAddColumn(JET_SESID sesid, JET_TABLEID tableid,
        const char __far *szColumn, const JET_COLUMNDEF __far *pcolumndef,
        const void __far *pvDefault, unsigned long cbDefault,
        JET_COLUMNID __far *pcolumnid)
        {
        APIEnter();

        if (!FValidSesid(sesid))
                APIReturn(JET_errInvalidSesid);

        APIReturn(ErrDispAddColumn(sesid, tableid, szColumn, pcolumndef,
                pvDefault, cbDefault, pcolumnid));
        }


JET_ERR JET_API JetRenameColumn(JET_SESID sesid, JET_TABLEID tableid,
        const char __far *szColumn, const char __far *szColumnNew)
        {
        APIEnter();

        if (!FValidSesid(sesid))
                APIReturn(JET_errInvalidSesid);

        APIReturn(ErrDispRenameColumn(sesid, tableid, szColumn, szColumnNew));
        }


JET_ERR JET_API JetDeleteColumn(JET_SESID sesid, JET_TABLEID tableid,
        const char __far *szColumn)
        {
        APIEnter();

        if (!FValidSesid(sesid))
                APIReturn(JET_errInvalidSesid);

        APIReturn(ErrDispDeleteColumn(sesid, tableid, szColumn));
        }


JET_ERR JET_API JetCreateIndex(JET_SESID sesid, JET_TABLEID tableid,
        const char __far *szIndexName, JET_GRBIT grbit,
        const char __far *szKey, unsigned long cbKey, unsigned long lDensity)
        {
        APIEnter();

        if (!FValidSesid(sesid))
                APIReturn(JET_errInvalidSesid);

        APIReturn(ErrDispCreateIndex(sesid, tableid, szIndexName, grbit,
                szKey, cbKey, lDensity));
        }


JET_ERR JET_API JetRenameIndex(JET_SESID sesid, JET_TABLEID tableid,
        const char __far *szIndex, const char __far *szIndexNew)
        {
        APIEnter();

        if (!FValidSesid(sesid))
                APIReturn(JET_errInvalidSesid);

        APIReturn(ErrDispRenameIndex(sesid, tableid, szIndex, szIndexNew));
        }


JET_ERR JET_API JetDeleteIndex(JET_SESID sesid, JET_TABLEID tableid,
        const char __far *szIndexName)
        {
        APIEnter();

        if (!FValidSesid(sesid))
                APIReturn(JET_errInvalidSesid);

        APIReturn(ErrDispDeleteIndex(sesid, tableid, szIndexName));
        }


JET_ERR JET_API JetComputeStats(JET_SESID sesid, JET_TABLEID tableid)
        {
        APIEnter();

        if (!FValidSesid(sesid))
                APIReturn(JET_errInvalidSesid);

        CheckTableidExported(tableid);

        APIReturn(ErrDispComputeStats(sesid, tableid));
        }


JET_ERR JET_API JetAttachDatabase(JET_SESID sesid, const char __far *szFilename, JET_GRBIT grbit )
        {
        APIEnter();

        if (!FValidSesid(sesid))
                APIReturn(JET_errInvalidSesid);

        APIReturn(ErrIsamAttachDatabase(sesid, szFilename, grbit));
        }


JET_ERR JET_API JetDetachDatabase(JET_SESID sesid, const char __far *szFilename)
        {
        APIEnter();

        if (!FValidSesid(sesid))
                APIReturn(JET_errInvalidSesid);

        APIReturn(ErrIsamDetachDatabase(sesid, szFilename));
        }


JET_ERR JET_API JetBackup( const char __far *szBackupPath, JET_GRBIT grbit )
        {
        APIEnter();

        APIReturn( ErrIsamBackup( szBackupPath, grbit ) );
        }


JET_ERR JET_API JetRestore(     const char __far *sz, int crstmap, JET_RSTMAP *rgrstmap, JET_PFNSTATUS pfn)
        {
        ERR err;

        if ( fJetInitialized )
        {
                /* UNDONE: store environment varialbes */
                JetTerm(0);
                fJetInitialized = fFalse;
        }

        APIInitEnter();

        /* initJet without init Isam */
        err = ErrInit( fTrue );
        Assert( err != JET_errAlreadyInitialized );
        if (err < 0)
                APITermReturn( err );

        err = ErrIsamRestore( (char *)sz, crstmap, rgrstmap, pfn );

        fJetInitialized = fFalse;

        APITermReturn( err );
        }


JET_ERR JET_API JetOpenTempTable(JET_SESID sesid,
        const JET_COLUMNDEF __far *prgcolumndef, unsigned long ccolumn,
        JET_GRBIT grbit, JET_TABLEID __far *ptableid,
        JET_COLUMNID __far *prgcolumnid)
        {
        ERR err;

        APIEnter();

        if (!FValidSesid(sesid))
                APIReturn(JET_errInvalidSesid);

        err = ErrIsamOpenTempTable(sesid, prgcolumndef, ccolumn,
                        grbit, ptableid, prgcolumnid);
        MarkTableidExported(err, *ptableid);
        APIReturn(err);
        }

JET_ERR JET_API JetSetIndexRange(JET_SESID sesid,
        JET_TABLEID tableidSrc, JET_GRBIT grbit)
        {
        APIEnter();

        if (!FValidSesid(sesid))
                APIReturn(JET_errInvalidSesid);

        APIReturn(ErrDispSetIndexRange(sesid, tableidSrc, grbit));
        }


JET_ERR JET_API JetIndexRecordCount(JET_SESID sesid,
        JET_TABLEID tableid, unsigned long __far *pcrec, unsigned long crecMax)
        {
        ERR err;

        APIEnter();

        if (!FValidSesid(sesid))
                APIReturn(JET_errInvalidSesid);

        /* this must return 'feature not avail' for installable isams */
        err = ErrIsamIndexRecordCount(sesid, tableid, pcrec, crecMax);
        APIReturn(err);
        }

JET_ERR JET_API JetGetChecksum(JET_SESID sesid,
        JET_TABLEID tableid, unsigned long __far *pulChecksum )
        {
        ERR err;

        APIEnter();

        if (!FValidSesid(sesid))
                APIReturn(JET_errInvalidSesid);

        err = ErrDispGetChecksum(sesid, tableid, pulChecksum );

        APIReturn(err);
        }

JET_ERR JET_API JetGetObjidFromName(JET_SESID sesid,
        JET_DBID dbid, const char __far *szContainerName,
        const char __far *szObjectName,
        ULONG_PTR __far *pulObjectId )
        {
        ERR err;

        APIEnter();

        if (!FValidSesid(sesid))
                APIReturn(JET_errInvalidSesid);

        err = ErrDispGetObjidFromName(sesid, dbid,
                szContainerName, szObjectName, pulObjectId );

        APIReturn(err);
        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\src\isammgr.c ===
/***********************************************************************
* Microsoft Jet
*
* Microsoft Confidential.  Copyright 1991-1992 Microsoft Corporation.
*
* Component: Installable ISAM Manager
*
* File: isammgr.c
*
* File Comments:
*
* Revision History:
*
*    [0]  24-May-91  bobcr	Created
*
***********************************************************************/

#include "std.h"

#include "isammgr.h"		       /* Installable ISAM definitions */

#include "_vdbmgr.h"		       /* Internal VDB manager definitions */

#include <string.h>		       /* For strnicmp() */

DeclAssertFile;


CODECONST(char) szODBC[]     = "ODBC";

#ifdef	INSTISAM

CODECONST(char) szInstISAM[] = "Installable ISAMs";
CODECONST(char) szNull[]     = "";

#define ciicbMax	10	/* Maximum number of installed ISAMS */
#define ciscbMax	50	/* Maximum number of installed ISAM sessons */
#define cchIdMax	10	/* Maximum length of ISAM type identifier */
#define cchIdListMax	256	/* Maximum length of ISAM type id list */
#define cchPathMax	260	/* Maximum length of ISAM DLL path string */
#define handleNil	0	/* Unused library handle */


/* Data Types */

typedef unsigned HANDLE;		/* Windows compatible handle */

typedef struct				/* Installable ISAM Control Block */
{
	ISAMDEF __far	*pisamdef;	/* Pointer to ISAMDEF structure */
	char		szId[cchIdMax]; /* ISAM type identifier string */
	HANDLE		handle; 	/* System handle for loaded library */
	unsigned	cSession;	/* Current session count */
	unsigned	iitControl;	/* Master for this alias */
} IICB;

typedef struct				/* ISAM Session Control Block */
{
	JET_VSESID	vsesid; 	/* ISAM specific session id */
	IIT		iit;		/* Installable ISAM type */
	int		iiscbNext;	/* Subscript of next ISCB */
} ISCB;


/* Local variables */

static unsigned __near	iitMac;       /* Number of currently installed ISAMs */
static int	__near	iiscbFree;	/* Next free ISCB */

static IICB __near rgiicb[ciicbMax];	/* List of currently installed ISAMs */
static ISCB __near rgiscb[ciscbMax];	/* ISCB pool */

/*=================================================================
ErrIsammgrInit

Description: Determine the possible installable ISAMs

Parameters: None

Return Value: error code

Errors/Warnings:
<List of any errors or warnings, with any specific circumstantial
 comments supplied on an as-needed-only basis>

Side Effects: rgiicb is modified
=================================================================*/

ERR ErrIsammgrInit(void)
{
   unsigned iiscb;		       /* Index to current ISCB */
   unsigned cchIdListMac;	       /* Length of current ISAM type list */
   unsigned cchIdList;		       /* Offset to current ISAM type id string */
   char     szIdList[cchIdListMax];    /* List of valid ISAM identifiers */

   /* Get the current list of Installable ISAM type identifiers */

   cchIdListMac = UtilGetProfileString(szInstISAM, NULL, szNull, szIdList, cchIdListMax);

   /* Set up the list of currently installed ISAMs */

   cchIdList = 0;	/* Start with the first ISAM type id */

   while (cchIdList < cchIdListMac)
   {
      /* Reset the control information */

      rgiicb[iitMac].handle	= handleNil;
      rgiicb[iitMac].cSession	= 0;
      rgiicb[iitMac].iitControl = iitMac;

      /* Copy the ISAM identifier into the IICB */

      /* CONSIDER: Don't use strncpy.  Fail/ignore if too long. */

      strncpy(rgiicb[iitMac].szId, &szIdList[cchIdList], cchIdMax);
      rgiicb[ciicbMax].szId[cchIdMax-1] = '\0';

      /* Increment the count of installed ISAMs */
      iitMac++;

      /* Step to the next installable ISAM identifier */
      cchIdList += strlen(&szIdList[cchIdList]) + 1;
   }

   /* Create list of free ISCBs */
   for (iiscb = 0; iiscb < ciscbMax; iiscb++)
   {
      rgiscb[iiscb].iiscbNext = iiscb + 1;
   }

   /* Mark the end of the free ISCB list */
   rgiscb[ciscbMax-1].iiscbNext = -1;

   /* Set up index to first free ISCB */
   iiscbFree = 0;

   return(JET_errSuccess);
}


ERR ErrIsammgrTerm(void)
{
   unsigned iit;

   /* Look up the identifier among the possible installable ISAMs */

   for (iit = 0; iit < iitMac; iit++)
   {
      /* Ignore installable ISAMs that haven't yet been loaded. */

      if (rgiicb[iit].handle == handleNil)
	 continue;

      /* Don't terminate aliased ISAMs more than once. */

      if (rgiicb[iit].iitControl == iit)
	 rgiicb[iit].pisamdef->pfnTerm();

      /* Free the DLL. The same handle may occur several times. */

      UtilFreeLibrary(rgiicb[iit].handle);
   }

   iitMac = 0;

   return(JET_errSuccess);
}


/*=================================================================
ErrGetIsamDef

Description: Returns the pointer to the ISAMDEF structure

Parameters:	handle		handle for the loaded ISAM library
		ppisamdef	returned pointer to ISAMDEF structure

Return Value: error code

Errors/Warnings:

JET_errInvalidParameter	the ErrIsamLoad entry point is not defined

Side Effects: Updates the pointer to the ISAMDEF
=================================================================*/

STATIC ERR NEAR ErrGetIsamDef(HANDLE handle, ISAMDEF __far * __far *ppisamdef)
{
	ERR (ISAMAPI *pfnErrIsamLoad)(ISAMDEF __far * __far *);

	pfnErrIsamLoad = (ERR (ISAMAPI *)(ISAMDEF __far * __far *)) PfnUtilGetProcAddress(handle, 1);

	if (pfnErrIsamLoad == NULL)
		return(JET_errInvalidParameter);

	return((*pfnErrIsamLoad)(ppisamdef));
}

#endif	/* INSTISAM */

/*=================================================================
ErrGetIsamType

Description: Determines the type of ISAM (built-in or installable)

Parameters:	szConnect	string used to connect to the database
		piit		returned ISAM type

Return Value:	error code
				piit (ISAM type)

Errors/Warnings:
<List of any errors or warnings, with any specific circumstantial
 comments supplied on an as-needed-only basis>

Side Effects: The installable ISAM library is loaded if necessary
=================================================================*/

ERR ErrGetIsamType(const char __far *szConnect, IIT __far *piit)
{
#ifdef	INSTISAM
	ERR			err;
	unsigned		iit;
#endif	/* INSTISAM */
	unsigned		cchType;
	const char __far	*pchType;

	cchType = 0;

	if (szConnect != NULL)
		{
		const char __far *pch;
		char		 ch;

		pch = pchType = szConnect;

		while (((ch = *pch++) != ';') && (ch != '\0'))
			cchType++;
		}

	if (cchType == 0)
		{
		/* If no type specified use built-in ISAM */

		*piit = iitBuiltIn;

		return(JET_errSuccess);
		}

	else if ((cchType == 4) && (_strnicmp(pchType, szODBC, 4) == 0))
		{
		*piit = iitODBC;

		return(JET_errSuccess);
		}

#ifdef	INSTISAM
	/* Look up the identifier among the possible installable ISAMs */

	for (iit = 0; iit < iitMac; iit++)
		if ((_strnicmp(pchType, rgiicb[iit].szId, cchType) == 0) &&
		    (rgiicb[iit].szId[cchType] == '\0'))
			break;

	/* If the type isn't found, fail */

	if (iit == iitMac)
		{
		return(JET_errInstallableIsamNotFound);
		}

	/* Load the installable ISAM library if necessary */

	if (rgiicb[iit].handle == handleNil)
		{
		HANDLE		handle;
		unsigned	cchIsamPath;
		unsigned	iitControl;
		char		szIsamPath[cchPathMax];

		/* Get the path to the DLL for the installable ISAM */

		cchIsamPath = UtilGetProfileString(szInstISAM, rgiicb[iit].szId, szNull, szIsamPath, sizeof(szIsamPath));

		/* Quit if the path is invalid */

		if ((cchIsamPath == 0) || (cchIsamPath >= cchPathMax))
			return(JET_errInstallableIsamNotFound);

		/* Try to load the DLL for the installable ISAM */

		if (!FUtilLoadLibrary(szIsamPath, &handle))
			return(JET_errInstallableIsamNotFound);

		/* See if this is an alias for an already loaded ISAM */

		for (iitControl = 0; iitControl < iitMac; iitControl++)
			if (rgiicb[iitControl].handle == handle)
				break;

		/* Don't reinitialize if this is an alias. */

		if (iitControl == iitMac)
			{
			/* Get the pointer to the ISAMDEF structure */

			/* CONSIDER: Pass type name to installable ISAM */
			/* CONSIDER: This allows one DLL to more easily */
			/* CONSIDER: handle multiple ISAM types. */

			err = ErrGetIsamDef(handle, &rgiicb[iit].pisamdef);

			/* Initialize the installable ISAM */

			if (err >= 0)
				err = rgiicb[iit].pisamdef->pfnInit();

			if (err < 0)
				{
				UtilFreeLibrary(handle);
				return(err);
				}

			iitControl = iit;
			}

		/* The installable ISAM is loaded. Save the handle. */

		rgiicb[iit].handle = handle;
		rgiicb[iit].cSession = 0;
		rgiicb[iit].iitControl = iitControl;
		}

	/* Return the controling type for aliases. */

	*piit = rgiicb[iit].iitControl;

	return(JET_errSuccess);

#else	/* !INSTISAM */

	return(JET_errInstallableIsamNotFound);

#endif	/* !INSTISAM */
}


/*=================================================================
ErrBeginIsamSession

Description: Start a new session for an installable ISAM

Parameters:	sesid	session id for the built-in ISAM
			iit		installed ISAM type
			pvsesid  returned session id for the installed ISAM

Return Value:	error code
				session id for installed ISAM

Errors/Warnings: returned by installed ISAM's ErrIsamBeginSession

Side Effects: A session is started for the installed ISAM
=================================================================*/

#ifdef	INSTISAM

STATIC ERR NEAR ErrBeginIsamSession(JET_SESID sesid, IIT iit, JET_VSESID __far *pvsesid)
{
	ERR		err;		/* Return code from ErrIsamBeginSession */
	int		isib;		/* Index to SIB for built-in ISAM session */
	int		iiscb;		/* Index to current ISCB */
	unsigned	ctl;		/* Current transaction level */

	Assert((iit != iitBuiltIn) && (iit != iitODBC) && (iit <= iitMac));

	/* Get the external Jet session id */
	*pvsesid = (JET_VSESID) sesid;

	/* Start a new session in the installed ISAM */
	err = rgiicb[iit].pisamdef->pfnBeginSession(pvsesid);

	if (err < 0)
		return err;

	/* Increment the count of sessions using the installable ISAM */
	rgiicb[iit].cSession++;

	/* Locate the SIB for the built-in ISAM session */
	isib = UtilGetIsibOfSesid(sesid);

	Assert(isib != -1);

	/* Locate the proper ISCB and store the sesid in it */
	for (iiscb = rgsib[isib].iiscb; iiscb != -1; iiscb = rgiscb[iiscb].iiscbNext)
		if (rgiscb[iiscb].iit == iit)
			{
			rgiscb[iiscb].vsesid = *pvsesid;
			break;
			}

	Assert(iiscb != -1);

	/* CONSIDER: Check for error returned by pfnBeginTransaction. */

	/* Start a transaction for each level started in the built-in ISAM */
	for (ctl = 0; ctl < rgsib[isib].tl; ctl++)
		rgiicb[iit].pisamdef->pfnBeginTransaction(*pvsesid);

	return(err);
}


/*=================================================================
ErrOpenForeignDatabase

Description: Open a database in an installed ISAM

Parameters:	sesid		session id for built-in ISAM
			iit			installed ISAM type
			szDatabase	database name as required by installed ISAM
			szConnect	connect string as required by installed ISAM
			pdbid		returned DBID
			grbit		options passed to installed ISAM

Return Value:	error code
				database id from installed ISAM

Errors/Warnings:

JET_errInvalidSesid		built-in session id is invalid
JET_errCantBegin		unable to allocate an ISCB
JET_errObjectNotFound	installable ISAM session control block allocated

Side Effects: An ISCB may be allocated
=================================================================*/

ERR ErrOpenForeignDatabase(JET_SESID sesid, IIT iit, const char __far *szDatabase, const char __far *szConnect, JET_DBID __far *pdbid, unsigned long grbit)
{
	ERR	err;				/* Return code from ErrIsamBeginSession */
	int	isib;				/* Index to SIB for built-in ISAM session */
	int	iiscb;				/* Index to current ISCB */

	/* Locate the SIB for the built-in ISAM's session */
	isib = UtilGetIsibOfSesid(sesid);

	Assert(isib != -1);

	/* Find the ISCB for the installed ISAM's session */
	for (iiscb = rgsib[isib].iiscb; iiscb != -1; iiscb = rgiscb[iiscb].iiscbNext)
		if (rgiscb[iiscb].iit == iit)
			break;

	Assert(iiscb != -1);

	/* Open the database for the installed ISAM */
	err = rgiicb[iit].pisamdef->pfnOpenDatabase(rgiscb[iiscb].vsesid,
			szDatabase, szConnect, pdbid, grbit);

	return err;
}


/*=================================================================
ErrGetIsamSesid

Description: Get the session id for an installed ISAM

Parameters:	sesid	session id for built-in ISAM
		iit	installed ISAM type
		pvsesid returned session id for installed ISAM

Return Value:	error code
				session id for installed ISAM

Errors/Warnings:

JET_errInvalidSesid		built-in session id is invalid
JET_errCantBegin		unable to allocate an ISCB
JET_errObjectNotFound	installable ISAM session control block allocated

Side Effects: An ISCB may be allocated
=================================================================*/

ERR ErrGetIsamSesid(JET_SESID sesid, IIT iit, JET_VSESID __far *pvsesid)
{
	int	isib;				/* Index to SIB for built-in ISAM session */
	int	iiscb;				/* Index to current ISCB */
	int	*piiscb;			/* Pointer to last ISCB in session's chain */

	Assert(iit <= iitMac);		      /* Valid type? */
	Assert(rgiicb[iit].handle != handleNil);      /* ISAM loaded? */

	/* Locate the SIB for the built-in ISAM session */
	isib = UtilGetIsibOfSesid(sesid);

	Assert(isib != -1);

	/* Point to place to link in a new ISCB (if a new one is necessary) */
	piiscb = &rgsib[isib].iiscb;

	/* Search list in SIB for installable ISAM of type specified */

	for (iiscb = *piiscb; iiscb != -1; iiscb = rgiscb[iiscb].iiscbNext)
		{
		if (rgiscb[iiscb].iit == iit)
			break;
		piiscb = &rgiscb[iiscb].iiscbNext;
		}

	/* If installable ISAM not found, add a new entry to the list in SIB */

	if (iiscb == -1)
		{
		if (iiscbFree == -1)			/* Error if no free ISCBs */
			return(JET_errCantBegin);

		iiscb = iiscbFree;			/* Allocate a new ISCB */
		iiscbFree = rgiscb[iiscb].iiscbNext;
		*piiscb = iiscb;			/* Link it to SIB chain */

		rgiscb[iiscb].iiscbNext = -1;		/* Flag it as the last ISCB */
		rgiscb[iiscb].iit	= iit;		/* Save the ISAM type */

		return(ErrBeginIsamSession(sesid, iit, pvsesid));
		}

	/* Return the session id if the installable ISAM has already been started */

	*pvsesid = rgiscb[iiscb].vsesid;

	return(JET_errSuccess);
}


/*=================================================================
CloseIsamSessions

Description: Traverse list of installed ISAMs and close each open session

Parameters: sesid	session id for the built-in ISAM

Return Value: None

Errors/Warnings: None

Side Effects: All ISCBs are freed
=================================================================*/

void CloseIsamSessions(JET_SESID sesid)
{
	int		isib;		/* Index to SIB for built-in ISAM session */
	unsigned	iit;	      /* Index to the IICB for current ISAM */
	int		iiscb;		/* Index to current ISCB */
	int		iiscbLast;	/* Index to last ISCB in session's chain */

	/* Locate the SIB for the current session */
	isib = UtilGetIsibOfSesid(sesid);

	Assert(isib != -1);

	/* Just in case there aren't any ISCBs in the session's chain */
	iiscbLast = -1;

	/* Close every installable ISAM session in the built-in sessions's chain */
	for (iiscb = rgsib[isib].iiscb; iiscb != -1; iiscb = rgiscb[iiscb].iiscbNext)
		{
		iit = rgiscb[iiscb].iit;

		/* Close the installable ISAM session */
		Assert(rgiicb[iit].cSession > 0);
		rgiicb[iit].pisamdef->pfnEndSession(rgiscb[iiscb].vsesid, 0);
		rgiicb[iit].cSession--;

		iiscbLast = iiscb;
		}

	/* Push the session's chain onto the free list */
	if (iiscbLast != -1)
		{
		rgiscb[iiscbLast].iiscbNext = iiscbFree;
		iiscbFree = rgsib[isib].iiscb;
		rgsib[isib].iiscb = -1;
		}
}


/*=================================================================
BeginIsamTransactions

Description: Traverse list of installed ISAMs and start a transaction for each

Parameters: sesid	session id for the built-in ISAM

Return Value: None

Errors/Warnings: None

Side Effects: A transaction is started for each installed ISAM
=================================================================*/

void BeginIsamTransactions(JET_SESID sesid)
{
	int	isib;				/* Index to SIB for built-in ISAM session */
	int	iiscb;				/* Index to current ISCB */

	isib = UtilGetIsibOfSesid(sesid);

	Assert(isib != -1);

	for (iiscb = rgsib[isib].iiscb; iiscb != -1; iiscb = rgiscb[iiscb].iiscbNext)
		rgiicb[rgiscb[iiscb].iit].pisamdef->pfnBeginTransaction(rgiscb[iiscb].vsesid);
}


/*=================================================================
CommitIsamTransactions

Description: Traverse list of installed ISAMs and commit transactions for each

Parameters: sesid	session id for the built-in ISAM
			levels	number of transaction levels to commit

Return Value: None

Errors/Warnings: None

Side Effects: Transaction levels are commited for each installed ISAM
=================================================================*/

void CommitIsamTransactions(JET_SESID sesid, JET_GRBIT grbit)
{
	int	isib;				/* Index to SIB for built-in ISAM session */
	int	iiscb;				/* Index to current ISCB */

	isib = UtilGetIsibOfSesid(sesid);

	Assert(isib != -1);

	for (iiscb = rgsib[isib].iiscb; iiscb != -1; iiscb = rgiscb[iiscb].iiscbNext)
		rgiicb[rgiscb[iiscb].iit].pisamdef->pfnCommitTransaction(rgiscb[iiscb].vsesid, grbit);
}


/*=================================================================
RollbackIsamTransactions

Description: Traverse list of installed ISAMs and rollback transactions for each

Parameters: sesid	session id for the built-in ISAM
			levels	number of transaction levels to rollback

Return Value: None

Errors/Warnings: None

Side Effects: Transaction levels are rolled back for each installed ISAM
=================================================================*/

void RollbackIsamTransactions(JET_SESID sesid, JET_GRBIT grbit)
{
	int	isib;				/* Index to SIB for built-in ISAM session */
	int	iiscb;				/* Index to current ISCB */

	isib = UtilGetIsibOfSesid(sesid);

	Assert(isib != -1);

	for (iiscb = rgsib[isib].iiscb; iiscb != -1; iiscb = rgiscb[iiscb].iiscbNext)
		rgiicb[rgiscb[iiscb].iit].pisamdef->pfnRollback(rgiscb[iiscb].vsesid, grbit);
}


/*=================================================================
ErrIdleIsam

Description: Call one active ISAM for idle processing

Parameters: sesid	session id for the built-in ISAM

Return Value: JET_errSuccess		- One ISAM performed idle processing
			  JET_wrnNoIdleActivity	- No idle processing was performed

Errors/Warnings: None

Side Effects: Depends on installable ISAM idle processing
			  The ISAM chosen is placed last in the list
=================================================================*/

ERR ErrIdleIsam(JET_SESID sesid)
{
	ERR		err;
	int		isib;			/* Index to session information block */
	int		iiscbFirst;		/* First iscb for the session */
	int		iiscb;			/* Current iscb for the session */
	int		*piiscb;		/* Pointer to current iiscb */

	/* Find the SIB for this session */
	isib = UtilGetIsibOfSesid(sesid);

	/* Get the first ISCB for the session */
	iiscbFirst = rgsib[isib].iiscb;

	/* If no active installable ISAMs, there's nothing to do */
	if (iiscbFirst == -1)
		return(JET_wrnNoIdleActivity);

	/* Remember the first ISCB so we don't loop forever */
	iiscb = iiscbFirst;

	/* Call each ISAM's idle processor until one does something or */
	/* all have been given a chance. */
	do
		{
		err = rgiicb[rgiscb[iiscb].iit].pisamdef->pfnIdle(rgiscb[iiscb].vsesid, 0);

		/* Point to the first ISCB */
		piiscb = &rgsib[isib].iiscb;

		/* Remove the current ISCB from the list */
		*piiscb = rgiscb[iiscb].iiscbNext;
		rgiscb[iiscb].iiscbNext = -1;

		/* Move the current ISCB to the end of the list for the session */
		while (*piiscb != -1)
			piiscb = &rgiscb[*piiscb].iiscbNext;

		*piiscb = iiscb;

		/* Move to the next ISCB */
		iiscb = rgsib[isib].iiscb;
		}
	while (err == JET_wrnNoIdleActivity && iiscb != iiscbFirst);

	return(err);
}

#endif	/* INSTISAM */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\src\compact.c ===
/*=================================================================
Microsoft Jet

Microsoft Confidential.  Copyright 1991 Microsoft Corporation.

Component: Jet Utilities

File: convert.c

File Comments: This file defines the JetCompact API.

=================================================================*/

#include "std.h"
#include "_jetstr.h"
#include "jetord.h"

#include <stdlib.h>
#include <string.h>

#include "vtmgr.h"

DeclAssertFile;

/*** System table names ***/

extern const char __far szSoTable[];
extern const char __far szScTable[];
extern const char __far szSiTable[];

/*** System object names ( non-table ) ***/

extern const char __far szTcObject[];
extern const char __far szDcObject[];
extern const char __far szDbObject[];

/*** System table index names ***/

CODECONST( char ) szSpObjectIdIndex[]	= "ObjectId";

/*** System table Column names ***/

CODECONST( char ) szDescriptionColumn[] = "Description";
CODECONST( char ) szLvExtraColumn[]	  = "LvExtra";

CODECONST( char ) szSoRmtInfoShort[]		= "RmtInfoShort";
CODECONST( char ) szSoRmtInfoLong[]		= "RmtInfoLong";

extern const char __far szSoFlagsColumn[];
extern const char __far szSoDateUpdateColumn[];
extern const char __far szSoDatabaseColumn[];
extern const char __far szSoConnectColumn[];
extern const char __far szSoForeignNameColumn[];

CODECONST( char ) szSoOwnerColumn[]		= "Owner";

CODECONST( char ) szScPresentationOrderColumn[] = "PresentationOrder";

CODECONST( char ) szScRmtInfoShort[]			  = "RmtInfoShort";
CODECONST( char ) szScRmtInfoLong[]			  = "RmtInfoLong";

CODECONST( char ) szSiRmtInfoShort[]	= "RmtInfoShort";
CODECONST( char ) szSiRmtInfoLong[]	= "RmtInfoLong";

CODECONST( char ) szSpSidColumn[] 			= "SID";
CODECONST( char ) szSpAcmColumn[] 			= "ACM";
CODECONST( char ) szSpObjectIdColumn[]		= "ObjectId";
CODECONST( char ) szSpFInheritableColumn[]	= "FInheritable";

CODECONST( char ) szSlash[] = "\\";

CODECONST( char ) szCountry[] = ";COUNTRY=";
CODECONST( char ) szLangid[]  = ";LANGID=";
CODECONST( char ) szCp[] 		= ";CP=";

#define cbSidMost		256
#define cbLvMax 		1990*16		/* CONSIDER: Optimized for ISAM V1 */
#define cTransMax		100

#define ulDefaultDensity		100L /* to be fine-tuned later */

#define JET_columnidNil ( ( JET_COLUMNID ) -1 )

#define callr( func )			{if ( ( err = ( func ) ) < 0 ) return err;}
#define callh( func, label )	{if ( ( err = ( func ) ) < 0 ) goto label;}
#define Call( func )			callh( func, HandleError )
#ifdef	DEBUG
#define calls( func )	{ ERR errT; Assert( ( errT = ( func ) ) == JET_errSuccess ); }
#else
#define calls( func )	func
#endif

#define JET_acmFTblRetrieveData	\
	( JET_acmTblRetrieveData | 	\
	JET_acmTblReplaceData | 	\
	JET_acmTblDeleteData )

#define JET_acmFTblReadDef		\
	( JET_acmTblReadDef | 		\
	JET_acmTblWriteDef | 		\
	JET_acmTblRetrieveData |	\
	JET_acmTblInsertData |		\
	JET_acmTblReplaceData |		\
	JET_acmTblDeleteData )

#define NO_GRBIT	0


	/* Column positions for MSysObjects */

#define icolSoDescription	0
#define icolSoLvExtra		1
#define icolSoFlags			2
#define icolSoDateCreate	3
#define icolSoDateUpdate	4
#define icolSoOwner			5

	/* These are the columns in MSysObjects to be copied for all objects */

#define icolSoMax1			6

#define icolSoType			6
#define icolSoDatabase		7
#define icolSoConnect		8
#define icolSoForeignName	9
#define icolSoRmtInfoShort	10
#define icolSoRmtInfoLong	11

	/* These are all the columns in MSysObjects which will be */
	/* copied including the link information */

#define icolSoMax			12


	/* Column positions for MSysColumns */

#define icolScDescription		0
#define icolScLvExtra			1
#define icolScPresentationOrder 2
#define icolScRmtInfoShort		3
#define icolScRmtInfoLong		4
#define icolScMax				5


	/* Column positions for MSysIndexes */

#define icolSiDescription	0
#define icolSiLvExtra		1
#define icolSiRmtInfoShort	2
#define icolSiRmtInfoLong	3
#define icolSiMax			4


	/* Column positions for MSysACEs */

#define icolSpObjectId		0
#define icolSpSid			1
#define icolSpAcm			2
#define icolSpFInheritable	3
#define icolSpMax			4


/* typedefs */

typedef unsigned long OBJECTID;

typedef struct COLUMNIDINFO
	{
	JET_COLUMNID	columnidSrc;
	JET_COLUMNID	columnidDest;
	} COLUMNIDINFO;

typedef struct COMPACTINFO
	{
	JET_PFNSTATUS	pfnStatus;
	JET_SESID		sesid;
	JET_DBID		dbidSrc;
	JET_DBID		dbidDest;
	unsigned short	langid;
	unsigned short	wCountry;
	unsigned long	cunitTotal;
	unsigned long	cunitDone;
	JET_OBJECTLIST	objectlist;
	COLUMNIDINFO	rgcolumnidsSo[icolSoMax];
	COLUMNIDINFO	rgcolumnidsSc[icolScMax];
	COLUMNIDINFO	rgcolumnidsSi[icolSiMax];
	COLUMNIDINFO	rgcolumnids[JET_ccolTableMost];
	BOOL			fDontCopyLocale;
	BOOL			fHaveSoColumnids;
	BOOL			fHaveScColumnids;
	BOOL			fHaveSiColumnids;
	char			rgbBuf[cbLvMax];
	} COMPACTINFO;

/* table definition of LIDMap table -- LIDSrc and LIDDest
/**/
CODECONST( JET_COLUMNDEF ) columndefLIDMap[] =
	{
	{sizeof( JET_COLUMNDEF ), 0, JET_coltypLong, 0, 0, 0, 0, sizeof( long ), JET_bitColumnFixed | JET_bitColumnTTKey},
	{sizeof( JET_COLUMNDEF ), 0, JET_coltypLong, 0, 0, 0, 0, sizeof( long ), JET_bitColumnFixed}
	};

#define ccolumndefLIDMap ( sizeof( columndefLIDMap ) / sizeof( JET_COLUMNDEF ) )

#define icolumnLidSrc		0		/* column index for columndefLIDMap */
#define icolumnLidDest	1		/* column index for columndefLIDMap */

/* CONSIDER: what code page and langid should be used in columninfoTagged? */

CODECONST( JET_COLUMNDEF ) columndefTagged[] =
	{
	{sizeof( JET_COLUMNDEF ), 0, JET_coltypLong, 0, 0, 0, 0, sizeof( long ), JET_bitColumnFixed | JET_bitColumnTTKey},
	{sizeof( JET_COLUMNDEF ), 0, JET_coltypLong, 0, 0, 0, 0, sizeof( long ), JET_bitColumnFixed}
	};

#define ccolumndefTaggedMax ( sizeof( columndefTagged ) / sizeof( JET_COLUMNDEF ) )

#define icolumnColumnidSrc	0	/* column indexes for columndefTagged */
#define icolumnColumnidDest	1	/* column indexes for columndefTagged */

/* procedure prototypes */

ERR ErrGetQueryColumnids( JET_SESID sesid, JET_COLUMNLIST *columnList,
			JET_TABLEID tableidDest, COLUMNIDINFO *columnidInfo );

ERR ErrCopyTaggedColumns( JET_SESID sesid, JET_TABLEID tableidSrc,
			JET_TABLEID tableidDest, JET_TABLEID tableidTagged,
			JET_TABLEID		tableidLIDMap, JET_COLUMNDEF *rgcolumndefTagged,
			JET_COLUMNDEF	*rgcolumndefLIDMap, void *pvBuf );

ERR ErrGetColumnIds( COMPACTINFO	*pcompactinfo, JET_TABLEID tableidSrc,
			JET_TABLEID	tableidDest, const char	*szColumn,
			COLUMNIDINFO *pcolumnidinfo );

ERR ErrRECExtrinsicLong( JET_VTID tableid,
			unsigned long lSeqNum, BOOL *pfSeparated,
			long *plid, unsigned long *plrefcnt, JET_GRBIT grbit );

ERR ErrREClinkLid( JET_VTID tableid, JET_COLUMNID ulFieldId,
			long lid, unsigned long lSeqNum );

ERR ErrRECForceSeparatedLV( JET_VTID tableid, unsigned long ulSeqNum );

/*---------------------------------------------------------------------------
*									     									*
*	Procedure: ErrReportProgress					     					*
*									     									*
*	Arguments: pcompactinfo	- Compact information segment					*
*									     									*
*	Returns : JET_ERR returned by the status call back function	     		*
*									     									*
*	Procedure fill up the correct details in the SNMSG structure and call	*
*	the status call back function.					     					*
*									     									*
---------------------------------------------------------------------------*/

ERR ErrReportProgress( COMPACTINFO *pcompactinfo )
	{
	JET_SNPROG snprog;

	if ( pcompactinfo->pfnStatus == NULL )
		return( JET_errSuccess );

	memset( &snprog, 0, sizeof( snprog ) );
	snprog.cbStruct = sizeof( JET_SNPROG );

	snprog.cunitDone = pcompactinfo->cunitDone;
	snprog.cunitTotal = pcompactinfo->cunitTotal;

	return ( ( ERR )( *( pcompactinfo->pfnStatus ) )( pcompactinfo->sesid, JET_snpCompact, JET_sntProgress, &snprog ) );
	}


/*---------------------------------------------------------------------------
*									     									*
*	Procedure: ErrReportMessage					     						*
*									     									*
*	Arguments: pcompactnfo	- Compact information segment					*
*			   snc			- status notification code	     				*
*			   szIdentifier - a name associated with the snc     			*
*									     									*
*	Returns : JET_ERR returned by the status call back function	     		*
*									     									*
*	Procedure fill up the correct details in the SNMSG structure and call	*
*	the status call back function.					     					*
*									     									*
---------------------------------------------------------------------------*/

ERR ErrReportMessage(
COMPACTINFO	*pcompactinfo,
JET_SNC 	snc,
const char	*szIdentifier )
	{
	JET_SNMSG snmsg;

	if ( pcompactinfo->pfnStatus == NULL )
		return( JET_errSuccess );

	memset( &snmsg, 0, sizeof( snmsg ) );
	snmsg.cbStruct = sizeof( snmsg );

	snmsg.snc = snc;
	strcpy( snmsg.sz, szIdentifier );

	return( ( ERR )( *( pcompactinfo->pfnStatus ) )( pcompactinfo->sesid, JET_snpCompact, JET_sntMessage, &snmsg ) );
	}


/*---------------------------------------------------------------------------
*									     									*
*	Procedure: ErrCompactInit						     							*
*									     									*
*	Arguments: pcompactinfo		- Compact information segment				*
*			   szDatabaseSrc	- Source database that will be converted    *
*			   szConnectSrc		- Connect string for source database		*
*			   szDatabaseDest	- Destination database name  				*
*			   szConnectDest	- Connect string for destination database	*
*			   grbitCompact		- Compact options							*
*									     									*
*	Returns : JET_ERR						     							*
*									     									*
*	Procedure Opens the source database.  It creates and opens	     		*
*	the destination database.												*
*									     									*
---------------------------------------------------------------------------*/

ERR ErrCompactInit(
COMPACTINFO	*pcompactinfo,
const char	*szDatabaseSrc,
const char	*szConnectSrc,
const char	*szDatabaseDest,
const char	*szConnectDest,
JET_GRBIT	grbitCompact )
{
	JET_SESID		sesid;
	ERR 			err;
	JET_DBID		dbidSrc;
	JET_DBID		dbidDest;
	JET_GRBIT 		grbit = 0;
	char			*pch;
	unsigned long	lCountry;
	unsigned long	lLangid;
	unsigned long	lcp;
	OLD_OUTDATA		outdata;

	sesid = pcompactinfo->sesid;

	/* Open the source DB Exclusive and ReadOnly. */

	if ( ( err = ErrIsamOpenDatabase( sesid, szDatabaseSrc, szConnectSrc,
		&dbidSrc, JET_bitDbExclusive | JET_bitDbReadOnly ) ) < 0 )
			return( err );

	/* Create and then open the destination database. */

	/* Set JET_bitDbEncrypt if source is encrypted, or Encrypt requested. */

	if ( ( grbitCompact & JET_bitCompactEncrypt ) != 0 )
		grbit |= JET_bitDbEncrypt;
	else if ( ( grbitCompact & JET_bitCompactDecrypt ) != 0 )
		grbit &= ~JET_bitDbEncrypt;
	else if ( err == JET_wrnDatabaseEncrypted )
		grbit |= JET_bitDbEncrypt;

	/* JET_bitCompactDontCopyLocale is set when the user */
	/* wants to ensure that all locales are homogeneous */
	/* throughout the new compacted db - there are to be no */
	/* mixed-language indexes or tables. */

	/* Build a connect string for the destination database if the user */
	/* hasn't supplied one. */

	/* CONSIDER: Always build the connect substring and insert it into */
	/* CONSIDER: the user supplied connect string following the first */
	/* CONSIDER: semicolon ( if any ).  If the user has specified a locale, */
	/* CONSIDER: it will override the one from the connect substring. */

	if ( szConnectDest == NULL )
		{
		/* build LOCALE string from src db */
		pch = pcompactinfo->rgbBuf;

		err = ErrDispGetDatabaseInfo( sesid, dbidSrc, &lCountry, sizeof( lCountry ),
			JET_DbInfoCountry );

		Assert( err >= 0 );

		strcpy( pch, szCountry );
		_ultoa( lCountry, pch+sizeof( szCountry )-1, 10 );
		pch += strlen( pch );

		err = ErrDispGetDatabaseInfo( sesid, dbidSrc, &lLangid, sizeof( lLangid ),
			JET_DbInfoLangid );

		Assert( err >= 0 );

		strcpy( pch, szLangid );
		_ultoa( lLangid, pch+sizeof( szLangid )-1, 10 );
		pch += strlen( pch );

		err = ErrDispGetDatabaseInfo( sesid, dbidSrc, &lcp, sizeof( lcp ),
			JET_DbInfoCp );

		Assert( err >= 0 );

		strcpy( pch, szCp );
		_ultoa( lcp, pch+sizeof( szCp )-1, 10 );

		pch = pcompactinfo->rgbBuf;
		}
	else
		pch = ( char * ) szConnectDest;


	callh( ErrIsamCreateDatabase( sesid, szDatabaseDest, pch,
		&dbidDest, grbit ), CloseIt1 );

	/* CONSIDER: Should the destination database be deleted if it already */
	/* CONSIDER: exists? */

	pcompactinfo->dbidSrc = dbidSrc;
	pcompactinfo->dbidDest = dbidDest;

	/* Get the country code of the source database */

	err = ErrDispGetDatabaseInfo( sesid, dbidDest, &lCountry, sizeof( lCountry ),
		JET_DbInfoCountry );

	Assert( err >= 0 );

	pcompactinfo->wCountry = ( unsigned short ) lCountry;

	/* Get the language id of the source database */

	err = ErrDispGetDatabaseInfo( sesid, dbidDest, &lLangid, sizeof( lLangid ),
		JET_DbInfoLangid );

	Assert( err >= 0 );

	pcompactinfo->langid = ( unsigned short ) lLangid;

	/* Get the list of all objects in the source database */

	outdata.cbMax = sizeof( pcompactinfo->objectlist );
	outdata.pb = &pcompactinfo->objectlist;

	callh( ErrDispGetObjectInfo( sesid, dbidSrc, JET_objtypNil, NULL, NULL,
			 &outdata, 1 ), CloseIt2 );

	return( JET_errSuccess );

CloseIt2:
	ErrDispCloseDatabase( sesid, dbidDest, 0 );

CloseIt1:
	ErrDispCloseDatabase( sesid, dbidSrc, 0 );

	return( err );
}


/*---------------------------------------------------------------------------
*									    									*
*	Procedure: ErrCreateContainers					    					*
*									    									*
*	Arguments: pcompactinfo - Compact information segment					*
*									    									*
*	Returns : JET_ERR						    							*
*									    									*
*	Procedure creates the containers from the source database	    		*
*	to the destination databse					    						*
*									    									*
---------------------------------------------------------------------------*/

ERR ErrCreateContainers( COMPACTINFO *pcompactinfo )
{
	JET_SESID		sesid;
	JET_DBID			dbidDest;
	JET_DBID			dbidSrc;
	JET_TABLEID		tableid;
	JET_COLUMNID	columnidObjtyp;
	JET_COLUMNID	columnidObjectName;
	long				cRow;
	ERR 				err;
	JET_OBJTYP		objtyp;
	unsigned long	cbActual;
	char				szObjectName[JET_cbNameMost+1];

	sesid = pcompactinfo->sesid;
	dbidSrc = pcompactinfo->dbidSrc;
	dbidDest = pcompactinfo->dbidDest;
	tableid = pcompactinfo->objectlist.tableid;
	columnidObjtyp = pcompactinfo->objectlist.columnidobjtyp;
	columnidObjectName = pcompactinfo->objectlist.columnidobjectname;

	/* Copy all existing containers except system containers. */

	cRow = JET_MoveFirst;

	while ( ( err = ErrDispMove( sesid, tableid, cRow, 0 ) ) >= 0 )
		{
		cRow = JET_MoveNext;

		callr( ErrDispRetrieveColumn( sesid, tableid, columnidObjtyp,
				&objtyp, sizeof( objtyp ),
				&cbActual, 0, NULL ) );

		if ( objtyp != JET_objtypContainer )
			continue;

		callr( ErrDispRetrieveColumn( sesid, tableid, columnidObjectName,
					szObjectName, JET_cbNameMost,
					&cbActual, 0, NULL ) );
		szObjectName[cbActual] = '\0';

		/* Don't try to create system containers. */

		if ( ( strcmp( szObjectName, szTcObject ) != 0 ) &&
		   ( strcmp( szObjectName, szDcObject ) != 0 ) &&
			( strcmp( szObjectName, "Relationships" ) != 0 ) )
			{
			callr( ErrDispCreateObject( sesid, dbidDest, objidRoot, szObjectName, JET_objtypContainer ) );
			}
		}

	if ( err == JET_errNoCurrentRecord )
		err = JET_errSuccess;

	return( err );
}


/*---------------------------------------------------------------------------
*									    									*
*	Procedure: ErrCopyColumnData					    					*
*									    									*
*	Arguments: sesid	- session id in which the work is done	    		*
*		   tableidSrc	- tableid pointing to the row in the SrcTbl 		*
*		   tableidDest	- tableid pointing to the row in the DestTbl		*
*		   columnidSrc	- the columnid of the column in the srcDb   		*
*		   columnidDest - the columnid of the column in the DestDb  		*
*		   pvBuf		- the segment for copying long values	    		*
*									    									*
*	Returns : JET_ERR						    							*
*									    									*
*	Procedure copies a column for the from the source to dest db.	    	*
*									    									*
---------------------------------------------------------------------------*/

ERR ErrCopyColumnData(
JET_SESID		sesid,
JET_TABLEID		tableidSrc,
JET_TABLEID		tableidDest,
JET_COLUMNID	columnidSrc,
JET_COLUMNID	columnidDest,
void			*pvBuf )
{
	unsigned long	cbActual;
	JET_RETINFO		retinfo;
	ERR 			err;

	retinfo.cbStruct = sizeof( retinfo );
	retinfo.ibLongValue = 0;
	retinfo.itagSequence = 1;
	retinfo.columnidNextTagged = 0;

#ifndef RETAIL
	/* Try reading into a 64 byte buffer.  If the value is small, */
	/* this is much much faster than the default 32K buffer. */

//	err = ErrDispRetrieveColumn( sesid, tableidSrc, columnidSrc, pvBuf,
//			64, &cbActual, NO_GRBIT, &retinfo );

//	if ( err == JET_errSuccess )
//		goto GotData;
#endif	/* !RETAIL */

	callr( ErrDispRetrieveColumn( sesid, tableidSrc, columnidSrc, pvBuf,
			cbLvMax, &cbActual, NO_GRBIT, &retinfo ) );

#ifndef RETAIL
//GotData:
#endif	/* !RETAIL */

	if ( cbActual > 0 )
		{
		if ( cbActual > cbLvMax )
			cbActual = cbLvMax;

		callr( ErrDispSetColumn( sesid, tableidDest, columnidDest, pvBuf,
				cbActual, NO_GRBIT, NULL ) );

		/* while the long value is not all copied */

		while ( cbActual == cbLvMax )
			{
			retinfo.ibLongValue += cbLvMax;

			callr( ErrDispRetrieveColumn( sesid, tableidSrc, columnidSrc, pvBuf,
						cbLvMax, &cbActual, NO_GRBIT, &retinfo ) );

			if ( cbActual > 0 )
				{
				if ( cbActual > cbLvMax )
					cbActual = cbLvMax;

				callr( ErrDispSetColumn( sesid, tableidDest, columnidDest, pvBuf,
							cbActual, JET_bitSetAppendLV, NULL ) );
				}
			}
		}

	return( JET_errSuccess );
}


ERR ErrGetColumnIds(
COMPACTINFO		*pcompactinfo,
JET_TABLEID		tableidSrc,
JET_TABLEID		tableidDest,
const char		*szColumn,
COLUMNIDINFO	*pcolumnidinfo )
{
	ERR				err;
	JET_COLUMNDEF	columndef;

	if ( tableidSrc != JET_tableidNil )
		{
		err = ErrDispGetTableColumnInfo( pcompactinfo->sesid, tableidSrc,
				szColumn, &columndef, sizeof( JET_COLUMNDEF ), 0 );
		if ( err >= 0 )
			pcolumnidinfo->columnidSrc = columndef.columnid;
		else if ( err == JET_errColumnNotFound )
			pcolumnidinfo->columnidSrc = JET_columnidNil;
		else
			return err;
		}

	if ( tableidDest != JET_tableidNil )
		{
		callr( ErrDispGetTableColumnInfo( pcompactinfo->sesid, tableidDest,
				szColumn, &columndef, sizeof( JET_COLUMNDEF ), 0 ) );

		pcolumnidinfo->columnidDest = columndef.columnid;
		}

	return( JET_errSuccess );
}


/*---------------------------------------------------------------------------
*																			*
*	Procedure: ErrGetSoColumnids										    *
*																			*
*	Arguments: pcompactinfo		- Compact information segment				*
*			   tableidSrc		- Tableid of the source table				*
*			   tableidDest		- Tableid of the destination table			*
*																			*
*	Returns : JET_ERR														*
*																			*
*	Procedure gets information on columns in the MSysObjects tables 		*
*																			*
---------------------------------------------------------------------------*/

ERR ErrGetSoColumnids(
COMPACTINFO	*pcompactinfo,
JET_TABLEID	tableidSrc,
JET_TABLEID	tableidDest )
{
	ERR 	err;

	callr( ErrGetColumnIds( pcompactinfo, tableidSrc, tableidDest,
			      szDescriptionColumn,
			      &pcompactinfo->rgcolumnidsSo[icolSoDescription] ) );

	callr( ErrGetColumnIds( pcompactinfo, tableidSrc, tableidDest,
			      szLvExtraColumn,
			      &pcompactinfo->rgcolumnidsSo[icolSoLvExtra] ) );

	callr( ErrGetColumnIds( pcompactinfo, tableidSrc, tableidDest,
			      szSoFlagsColumn,
			      &pcompactinfo->rgcolumnidsSo[icolSoFlags] ) );

	callr( ErrGetColumnIds( pcompactinfo, tableidSrc, tableidDest,
			      szSoDateCreateColumn,
			      &pcompactinfo->rgcolumnidsSo[icolSoDateCreate] ) );

	callr( ErrGetColumnIds( pcompactinfo, tableidSrc, tableidDest,
			      szSoDateUpdateColumn,
			      &pcompactinfo->rgcolumnidsSo[icolSoDateUpdate] ) );

	callr( ErrGetColumnIds( pcompactinfo, tableidSrc, tableidDest,
			      szSoOwnerColumn,
			      &pcompactinfo->rgcolumnidsSo[icolSoOwner] ) );

	callr( ErrGetColumnIds( pcompactinfo, tableidSrc, tableidDest,
			      szSoObjectTypeColumn,
			      &pcompactinfo->rgcolumnidsSo[icolSoType] ) );

	callr( ErrGetColumnIds( pcompactinfo, tableidSrc, tableidDest,
			      szSoDatabaseColumn,
			      &pcompactinfo->rgcolumnidsSo[icolSoDatabase] ) );

	callr( ErrGetColumnIds( pcompactinfo, tableidSrc, tableidDest,
			      szSoConnectColumn,
			      &pcompactinfo->rgcolumnidsSo[icolSoConnect] ) );

	callr( ErrGetColumnIds( pcompactinfo, tableidSrc, tableidDest,
			      szSoForeignNameColumn,
			      &pcompactinfo->rgcolumnidsSo[icolSoForeignName] ) );

	callr( ErrGetColumnIds( pcompactinfo, tableidSrc, tableidDest,
			      szSoRmtInfoShort,
			      &pcompactinfo->rgcolumnidsSo[icolSoRmtInfoShort] ) );

	callr( ErrGetColumnIds( pcompactinfo, tableidSrc, tableidDest,
			      szSoRmtInfoLong,
			      &pcompactinfo->rgcolumnidsSo[icolSoRmtInfoLong] ) );

	pcompactinfo->fHaveSoColumnids = fTrue;

	return( JET_errSuccess );
}

/*---------------------------------------------------------------------------
*																			*
*	Procedure: ErrGetScColumnids										    *
*																			*
*	Arguments: pcompactinfo		- Compact information segment				*
*			   tableidSrc		- Tableid of source table					*
*			   tableidDest		- Tableid of destination database			*
*																			*
*	Returns : JET_ERR														*
*																			*
*	Procedure gets information on columns in the MSysColumns tables 		*
*																			*
---------------------------------------------------------------------------*/

ERR ErrGetScColumnids(
COMPACTINFO	*pcompactinfo,
JET_TABLEID	tableidSrc,
JET_TABLEID	tableidDest )
{
	JET_SESID	sesid;
	ERR 		err;

	sesid = pcompactinfo->sesid;

	/* Get the column id's for the columns in the MSysColumns table */

	callr( ErrGetColumnIds( pcompactinfo, tableidSrc, tableidDest,
			      szDescriptionColumn,
			      &pcompactinfo->rgcolumnidsSc[icolScDescription] ) );

	callr( ErrGetColumnIds( pcompactinfo, tableidSrc, tableidDest,
			      szLvExtraColumn,
			      &pcompactinfo->rgcolumnidsSc[icolScLvExtra] ) );

	callr( ErrGetColumnIds( pcompactinfo, tableidSrc, tableidDest,
			      szScPresentationOrderColumn,
			      &pcompactinfo->rgcolumnidsSc[icolScPresentationOrder] ) );

	callr( ErrGetColumnIds( pcompactinfo, tableidSrc, tableidDest,
			      szScRmtInfoShort,
			      &pcompactinfo->rgcolumnidsSc[icolScRmtInfoShort] ) );

	callr( ErrGetColumnIds( pcompactinfo, tableidSrc, tableidDest,
			      szScRmtInfoLong,
			      &pcompactinfo->rgcolumnidsSc[icolScRmtInfoLong] ) );

	pcompactinfo->fHaveScColumnids = fTrue;

	return( JET_errSuccess );
}

/*---------------------------------------------------------------------------
*																			*
*	Procedure: ErrCopyScColumns												*
*																			*
*	Arguments: pcompactinfo		- Compact information segment				*
*			   szTableName		- Name of table to copy columns of			*
*			   szColumnName 	- Name of column to copy					*
*			   tableid			- tableid of the table for this index		*
*																			*
*	Returns : JET_ERR														*
*																			*
*	Procedure copies the LvExtra, Description and Presenation Order columns *
*	for the MSysColumns table												*
*																			*
---------------------------------------------------------------------------*/

ERR ErrCopyScColumns(
COMPACTINFO	*pcompactinfo,
const char	*szTableName,
const char	*szColumnName,
JET_TABLEID	tableid )
{
	JET_SESID		sesid;
	JET_DBID		dbidSrc;
	void			*pvBuf;
	ERR 			err;
	JET_TABLEID		tableidSrc;
	JET_TABLEID		tableidDest;
	unsigned		icol;
	unsigned long	cbActual;
	OLD_OUTDATA		outdata;

	sesid = pcompactinfo->sesid;
	dbidSrc = pcompactinfo->dbidSrc;
	pvBuf = pcompactinfo->rgbBuf;

	outdata.cbMax = sizeof( tableidSrc );
	outdata.pb = &tableidSrc;

	callr( ErrDispGetColumnInfo( sesid, dbidSrc, szTableName, szColumnName,
				&outdata, 3 ) );

	callh( ErrDispGetTableColumnInfo( sesid, tableid, szColumnName,
				&tableidDest, sizeof( tableidDest ), 3 ), CloseIt1 );

	if ( !pcompactinfo->fHaveScColumnids )
		callh( ErrGetScColumnids( pcompactinfo, tableidSrc, tableidDest ), CloseIt2 );

	callh( ErrDispPrepareUpdate( sesid, tableidDest, JET_prepReplaceNoLock ), CloseIt2 );

	for ( icol = 0; icol < icolScMax; icol++ )
		{
		JET_COLUMNID columnidSrc = pcompactinfo->rgcolumnidsSc[icol].columnidSrc;
		if ( columnidSrc == JET_columnidNil )
			continue;
		callh( ErrCopyColumnData( sesid, tableidSrc, tableidDest,
			pcompactinfo->rgcolumnidsSc[icol].columnidSrc,
			pcompactinfo->rgcolumnidsSc[icol].columnidDest, pvBuf ), CloseIt2 );
		}

	callh( ErrDispUpdate( sesid, tableidDest, NULL, 0, &cbActual ), CloseIt2 );

CloseIt2:
	ErrDispCloseTable( sesid, tableidDest );

CloseIt1:
	ErrDispCloseTable( sesid, tableidSrc );

	return( err );
}

/*---------------------------------------------------------------------------
*																			*
*	Procedure: ErrCreateCols												*
*																			*
*	Arguments: pcompactinfo		- Compact information segment				*
*			   tableidDest		- table on which to build the index			*
*			   szTableName		- table name on which the index is based    *
*			   columnList		- struct returned from GetTableColumnInfo	*
*			   columnidInfo 	- the columnid's of the user table			*
*			   tableidTagged	- the tableid of the tagged columns			*
*																			*
*	Returns : JET_ERR														*
*																			*
*	Procedure copies the columns for a table from the source db				*
*	to the destination databases											*
*																			*
---------------------------------------------------------------------------*/

ERR ErrCreateCols(
COMPACTINFO		*pcompactinfo,
JET_TABLEID		tableidDest,
const char		*szTableName,
JET_COLUMNLIST	*columnList,
COLUMNIDINFO	*columnidInfo,
JET_TABLEID		*ptableidTagged,
JET_COLUMNDEF	*rgcolumndef )
{
	JET_SESID		sesid;
	JET_DBID			dbidSrc;
	void				*pvBuf;
	BOOL				fDontCopyLocale;
	ERR 				err;
	char				szColumnName[JET_cbNameMost+1];
	JET_COLUMNDEF	columndef;
	unsigned			cColumns = 0;
	unsigned long	cbDefault;
	int				fTagged = fFalse;
	JET_COLUMNID	columnidSrc;
	JET_COLUMNID	columnidDest;
	unsigned long	cbActual;

	sesid = pcompactinfo->sesid;
	dbidSrc = pcompactinfo->dbidSrc;
	pvBuf = pcompactinfo->rgbBuf;

	fDontCopyLocale = pcompactinfo->fDontCopyLocale;

	err = ErrDispMove( sesid, columnList->tableid, JET_MoveFirst, NO_GRBIT );

	/* loop though all the columns in the table for the src tbl and */
	/* copy the information in the destination database				*/

	while ( err >= 0 )
		{
		/* retrieve info from table and create all the columns */

		callr( ErrDispRetrieveColumn( sesid, columnList->tableid,
					columnList->columnidcolumnname, szColumnName,
					JET_cbNameMost, &cbActual, NO_GRBIT, NULL ) );

		szColumnName[cbActual] = '\0';

		columndef.cbStruct = sizeof( JET_COLUMNDEF );

		callr( ErrDispRetrieveColumn( sesid, columnList->tableid,
					columnList->columnidcoltyp, &columndef.coltyp,
					sizeof( columndef.coltyp ), &cbActual, NO_GRBIT, NULL ) );

		callr( ErrDispRetrieveColumn( sesid, columnList->tableid,
					columnList->columnidcbMax, &columndef.cbMax,
					sizeof( columndef.cbMax ), &cbActual, NO_GRBIT, NULL ) );

		if ( fDontCopyLocale )
		{
			columndef.wCountry = pcompactinfo->wCountry;
			columndef.langid = pcompactinfo->langid;
		}
		else
		{
			callr( ErrDispRetrieveColumn( sesid, columnList->tableid,
						columnList->columnidCountry, &columndef.wCountry,
						sizeof( columndef.wCountry ), &cbActual, NO_GRBIT, NULL ) );

			callr( ErrDispRetrieveColumn( sesid, columnList->tableid,
						columnList->columnidLangid, &columndef.langid,
						sizeof( columndef.langid ), &cbActual, NO_GRBIT, NULL ) );
		}

		callr( ErrDispRetrieveColumn( sesid, columnList->tableid,
					columnList->columnidCp, &columndef.cp,
					sizeof( columndef.cp ), &cbActual, NO_GRBIT, NULL ) );

		columndef.wCollate = 0;

		callr( ErrDispRetrieveColumn( sesid, columnList->tableid,
					columnList->columnidgrbit, &columndef.grbit,
					sizeof( columndef.grbit ), &cbActual, NO_GRBIT, NULL ) );

		/* Retrieve default value into temporary buffer */

		callr( ErrDispRetrieveColumn( sesid, columnList->tableid,
				columnList->columnidDefault, pvBuf, cbLvMax,
				&cbDefault, NO_GRBIT, NULL ) );

		callr( ErrDispAddColumn( sesid, tableidDest, szColumnName, &columndef,
					cbDefault ? pvBuf : NULL, cbDefault,
					&columnidDest ) );

		callr( ErrDispRetrieveColumn( sesid, columnList->tableid,
					columnList->columnidcolumnid, &columnidSrc,
					sizeof( JET_GRBIT ), &cbActual, NO_GRBIT, NULL ) );

		/* CONSIDER: Should the column id be checked here? */

		/* if there is a tagged column create a temp. table to	*/
		/* store the column id's in                              */

		if ( columndef.grbit & JET_bitColumnTagged )
			{
			if ( !fTagged )
				{
				JET_COLUMNID rgcolumnid[ccolumndefTaggedMax];
				unsigned icol;

				memcpy( rgcolumndef, columndefTagged, sizeof( columndefTagged ) );
				callr( ErrIsamOpenTempTable( sesid, rgcolumndef, ccolumndefTaggedMax,
					 JET_bitTTIndexed, ptableidTagged, rgcolumnid ) );

				/* CONSIDER: Replace all rgcolumndef references */
				/* CONSIDER: with rgcolumnid references. */

				for ( icol = 0; icol < ccolumndefTaggedMax; icol++ )
					rgcolumndef[icol].columnid = rgcolumnid[icol];

				fTagged = fTrue;
				}

			callr( ErrDispPrepareUpdate( sesid, *ptableidTagged, JET_prepInsert ) );

			callr( ErrDispSetColumn( sesid, *ptableidTagged,
					rgcolumndef[icolumnColumnidSrc].columnid,
					&columnidSrc, sizeof( columnidSrc ), NO_GRBIT, NULL ) );

			callr( ErrDispSetColumn( sesid, *ptableidTagged,
					rgcolumndef[icolumnColumnidDest].columnid,
					&columnidDest, sizeof( columnidDest ), NO_GRBIT, NULL ) );

			callr( ErrDispUpdate( sesid, *ptableidTagged, NULL, 0, NULL ) );
			}

		/* else add the columnids to the columnid array */

		else
			{
			columnidInfo[cColumns].columnidDest = columnidDest;
			columnidInfo[cColumns].columnidSrc  = columnidSrc;

			cColumns++;
			}

		/* copy the user defined columns in the MSysColumn table*/
		/* for this column										*/

		err = ErrCopyScColumns( pcompactinfo, szTableName,
					szColumnName, tableidDest );
		if ( err < JET_errSuccess && err != JET_errAccessDenied )
			{
			return( err );
			}

		err = ErrDispMove( sesid, columnList->tableid, JET_MoveNext, NO_GRBIT );
		}

	/* to set up a spot so that we know when to stop searching
		through the columns while coping data */

	columnidInfo[cColumns].columnidSrc = 0;

	if ( err == JET_errNoCurrentRecord )
		err = JET_errSuccess;

	return( err );
}


/*---------------------------------------------------------------------------
*																			*
*	Procedure: ErrGetSiColumnids										    *
*																			*
*	Arguments: pcompactinfo		- Compact information segment				*
*			   tableidSrc		- Tableid of source table					*
*			   tableidDest		- Tableid of destination table				*
*																			*
*	Returns : JET_ERR														*
*																			*
*	Procedure gets information on Indexes in the MSysIndexes tables 		*
*																			*
---------------------------------------------------------------------------*/

ERR ErrGetSiColumnids(
COMPACTINFO	*pcompactinfo,
JET_TABLEID	tableidSrc,
JET_TABLEID	tableidDest )
{
	JET_SESID	sesid;
	ERR 		err;

	sesid = pcompactinfo->sesid;

	/* get the column id's for the columns in the MSysIndexes table */

	callr( ErrGetColumnIds( pcompactinfo, tableidSrc, tableidDest,
			      szDescriptionColumn,
			      &pcompactinfo->rgcolumnidsSi[icolSiDescription] ) );

	callr( ErrGetColumnIds( pcompactinfo, tableidSrc, tableidDest,
			      szLvExtraColumn,
			      &pcompactinfo->rgcolumnidsSi[icolSiLvExtra] ) );

	callr( ErrGetColumnIds( pcompactinfo, tableidSrc, tableidDest,
			      szSiRmtInfoShort,
			      &pcompactinfo->rgcolumnidsSi[icolSiRmtInfoShort] ) );

	callr( ErrGetColumnIds( pcompactinfo, tableidSrc, tableidDest,
			      szSiRmtInfoLong,
			      &pcompactinfo->rgcolumnidsSi[icolSiRmtInfoLong] ) );

	pcompactinfo->fHaveSiColumnids = fTrue;

	return( JET_errSuccess );
}


/*---------------------------------------------------------------------------
*																			*
*	Procedure: ErrCopySiColumns										 		*
*																			*
*	Arguments: pcompactinfo		- Compact information segment				*
*			   szTableName		- Table name for which the index exists		*
*			   szIndexName		- Name of index to copy						*
*			   tableid			- tableid of the table for this index		*
*																			*
*	Returns : JET_ERR														*
*																			*
*	Procedure copies the LvExtra and Description columns in the				*
*	for the MSysIndexes table												*
*																			*
---------------------------------------------------------------------------*/

ERR ErrCopySiColumns(
COMPACTINFO	*pcompactinfo,
const char	*szTableName,
const char	*szIndexName,
JET_TABLEID	tableid )
{
	JET_SESID		sesid;
	JET_DBID		dbidSrc;
	void			*pvBuf;
	ERR 			err;
	JET_TABLEID		tableidSrc;
	JET_TABLEID		tableidDest;
	unsigned		icol;
	unsigned long	cbActual;
	OLD_OUTDATA		outdata;

	sesid = pcompactinfo->sesid;
	dbidSrc = pcompactinfo->dbidSrc;
	pvBuf = pcompactinfo->rgbBuf;

	outdata.cbMax = sizeof( tableidSrc );
	outdata.pb = &tableidSrc;

	callr( ErrDispGetIndexInfo( sesid, dbidSrc, szTableName, szIndexName,
				&outdata, 2 ) );

	callh( ErrDispGetTableIndexInfo( sesid, tableid, szIndexName,
				&tableidDest, sizeof( tableidDest ), 2 ), CloseIt1 );

	if ( !pcompactinfo->fHaveSiColumnids )
		callh( ErrGetSiColumnids( pcompactinfo, tableidSrc, tableidDest ), CloseIt2 );

	callh( ErrDispPrepareUpdate( sesid, tableidDest, JET_prepReplaceNoLock ), CloseIt2 );

	for ( icol = 0; icol < icolSiMax; icol++ )
		{
		JET_COLUMNID columnidSrc = pcompactinfo->rgcolumnidsSi[icol].columnidSrc;
		if ( columnidSrc == JET_columnidNil )
			continue;
		callh( ErrCopyColumnData( sesid, tableidSrc, tableidDest,
				pcompactinfo->rgcolumnidsSi[icol].columnidSrc,
				pcompactinfo->rgcolumnidsSi[icol].columnidDest,
				pvBuf ), CloseIt2 );
		}

	callh( ErrDispUpdate( sesid, tableidDest, NULL, 0, &cbActual ), CloseIt2 );

CloseIt2:
	ErrDispCloseTable( sesid, tableidDest );

CloseIt1:
	ErrDispCloseTable( sesid, tableidSrc );

	return( err );
}

/*---------------------------------------------------------------------------
*																			*
*	Procedure: ErrCopyOneIndex												*
*																			*
*	Arguments: pcompactinfo		- Compact information segment				*
*			   tableidDest		- table on which to build the index			*
*			   szTableName		- table name on which the index is based    *
*			   indexList		- struct return from JetGetTableIndexInfo   *
*																			*
*	Returns : JET_ERR														*
*																			*
*	Procedure copies the columns for a table from the source db				*
*	to the destination databases											*
*																			*
---------------------------------------------------------------------------*/

ERR ErrCopyOneIndex(
COMPACTINFO		*pcompactinfo,
JET_TABLEID		tableidDest,
const char		*szTableName,
JET_INDEXLIST	*indexList )
{
	JET_SESID		sesid;
	char			*szSeg;
	ERR 			err;
	char			szIndexName[JET_cbNameMost+1];
	char			rgchColumnName[JET_cbNameMost];
	JET_GRBIT		grbit;
	JET_GRBIT		grbitColumn;
	unsigned long	ichKey;
	unsigned long	cbActual;

	sesid = pcompactinfo->sesid;
	szSeg = pcompactinfo->rgbBuf;

	/* retrieve info from table and create the index */

	callr( ErrDispRetrieveColumn( sesid, indexList->tableid,
				indexList->columnidindexname, szIndexName,
				JET_cbNameMost, &cbActual, NO_GRBIT, NULL ) );

	szIndexName[cbActual] = '\0';

	callr( ErrDispRetrieveColumn( sesid, indexList->tableid,
				indexList->columnidgrbitIndex, &grbit,
				sizeof( JET_GRBIT ), &cbActual, NO_GRBIT, NULL ) );

	/* create the szkey used in ErrIsamCreateIndex */

	ichKey = 0;

	for ( ;; )
		{
		unsigned long	iColumn;

		/* Get the individual columns that make up the index */

		callr( ErrDispRetrieveColumn( sesid, indexList->tableid,
					indexList->columnidgrbitColumn, &grbitColumn,
					sizeof( JET_GRBIT ), &cbActual, NO_GRBIT, NULL ) );

		callr( ErrDispRetrieveColumn( sesid, indexList->tableid,
					indexList->columnidcolumnname, rgchColumnName,
					JET_cbNameMost, &cbActual, NO_GRBIT, NULL ) );

		if ( grbitColumn == JET_bitKeyDescending )
			szSeg[ichKey++] = '-';
		else
			szSeg[ichKey++] = '+';

		/* Append the column name to the description */

		memcpy( szSeg+ichKey, rgchColumnName, ( size_t ) cbActual );

		ichKey += cbActual;
		szSeg[ichKey++] = '\0';

		err = ErrDispMove( sesid, indexList->tableid, JET_MoveNext, NO_GRBIT );

		if ( err == JET_errNoCurrentRecord )
			break;

		if ( err < 0 )
			{
			return( err );
			}

		callr( ErrDispRetrieveColumn( sesid, indexList->tableid,
				indexList->columnidiColumn, &iColumn,
				sizeof( iColumn ), &cbActual, NO_GRBIT, NULL ) );

		if ( iColumn == 0 )
			break;	       /* Start of a new Index */
		}

	szSeg[ichKey++] = '\0';

	callr( ErrDispCreateIndex( sesid, tableidDest, szIndexName, grbit,
				szSeg, ichKey, ulDefaultDensity ) );

	/* copy the user defined columns in the MSysIndexes table	*/
	/* for this index											*/

	err = ErrCopySiColumns( pcompactinfo, szTableName,
			szIndexName, tableidDest );
	if ( err < JET_errSuccess && err != JET_errAccessDenied )
		{
		return( err );
		}

	err = ErrDispMove( sesid, indexList->tableid, JET_MovePrevious, NO_GRBIT );

	return( err );
}


/*---------------------------------------------------------------------------
*																			*
*	Procedure: ErrCopyClusteredIndex										*
*																			*
*	Arguments: pcompactinfo		- Compact information segment				*
*			   tableidDest		- table on which to build the index			*
*			   szTableName		- table name on which the index is based    *
*			   indexList		- struct return from JetGetTableIndexInfo   *
*																			*
*	Returns : JET_ERR														*
*																			*
*	Procedure checks to see if there is cluster index for the function		*
*	if there is it creates the clustered index								*
*																			*
---------------------------------------------------------------------------*/

ERR ErrCopyClusteredIndex(
COMPACTINFO		*pcompactinfo,
JET_TABLEID		tableidDest,
const char		*szTableName,
JET_INDEXLIST	*indexList )
{
	JET_SESID		sesid;
	ERR 			err;
	JET_GRBIT		grbit;
	unsigned long	cbActual;

	sesid = pcompactinfo->sesid;

	err = ErrDispMove( sesid, indexList->tableid, JET_MoveFirst, NO_GRBIT );

	/* while there are still index rows or a cluster index has been found */

	while ( err >= 0 )
		{
		callr( ErrDispRetrieveColumn( sesid, indexList->tableid,
					indexList->columnidgrbitIndex, &grbit,
					sizeof( JET_GRBIT ), &cbActual, NO_GRBIT, NULL ) );

		/* Don't copy references here */

		if ( ( grbit & JET_bitIndexReference ) == 0 )
			{
			/* If the index is clustered then create it */

			if ( grbit & JET_bitIndexClustered )
				{
				callr( ErrCopyOneIndex( pcompactinfo, tableidDest,
						szTableName, indexList ) );

				break;
				}
			}

		err = ErrDispMove( sesid, indexList->tableid, JET_MoveNext, NO_GRBIT );
		}

	if ( err == JET_errNoCurrentRecord )
		err = JET_errSuccess;

	return( err );
}

/*---------------------------------------------------------------------------
*																			*
*	Procedure: ErrCopyTableData												*
*																			*
*	Arguments: sesid			- session id in which the work is done		*
*			   tableidDest		- tableid of the table in the dest db		*
*			   tableidSrc		- tableid of the table in the src db		*
*			   columnidInfo 	- the columnid's of the user table      	*
*			   tableidTagged	- the tableid of the tagged columns			*
*			   pvBuf			- the segment for copying long values		*
*																			*
*	Returns : JET_ERR														*
*																			*
*	Procedure copies data from the source table to the destination table	*
*																			*
---------------------------------------------------------------------------*/

ERR ErrCopyTableData(
JET_SESID		sesid,
JET_TABLEID		tableidDest,
JET_TABLEID		tableidSrc,
COLUMNIDINFO	*columnidInfo,
JET_TABLEID		tableidTagged,
JET_COLUMNDEF	*rgcolumndef,
void			*pvBuf )
{
	ERR 				err;
	unsigned			icol;
	unsigned long	cbActual;
	JET_TABLEID		tableidLIDMap;
	JET_COLUMNDEF	rgcolumndefLIDMap[ccolumndefLIDMap];

#ifdef	LATER
	int				cTransaction = 0;

	callh( JetBeginTransaction( sesid ), CloseIt );
#endif	/* LATER */

	if ( tableidTagged != JET_tableidNil )
		{
		JET_COLUMNID 	rgcolumnid[ccolumndefLIDMap];
		unsigned long icol;

		memcpy( rgcolumndefLIDMap, columndefLIDMap, sizeof( columndefLIDMap ) );

		/* Open temporary table
		/**/
		callr( ErrIsamOpenTempTable( sesid,
													rgcolumndefLIDMap,
													ccolumndefLIDMap,
													JET_bitTTUpdatable|JET_bitTTIndexed,
													&tableidLIDMap,
													rgcolumnid ) );

		for ( icol = 0; icol < ccolumndefLIDMap; icol++ )
			rgcolumndefLIDMap[icol].columnid = rgcolumnid[icol];

		}

	/* Copy each of the records in the table */

	err = ErrDispMove( sesid, tableidSrc, JET_MoveFirst, NO_GRBIT );

	while ( err >= 0 )
		{
#ifdef	LATER
		/* if there have been cTransMax transactions commit the
			transaction and start a new one */

		cTransaction++;

		if ( cTransaction == cTransMax )
			{
			callh( ErrDispCommitTransaction( sesid, 1 ), CloseIt );

			cTransaction = 0;

			callh( ErrDispBeginTransaction( sesid ), CloseIt );
			}
#endif	/* LATER */

		callh( ErrDispPrepareUpdate( sesid, tableidDest, JET_prepInsert ), CloseIt );

		/* if there are tagged columns ( BLUE ) then copy them */

		if ( tableidTagged != JET_tableidNil )
			{
			callh( ErrCopyTaggedColumns( sesid, tableidSrc,
								tableidDest, tableidTagged, tableidLIDMap,
								rgcolumndef, rgcolumndefLIDMap, pvBuf ), CloseIt );
			}

		icol = 0;

		/* While there are columns left to copy in the */

		while ( columnidInfo[icol].columnidSrc != 0 )
			{
			err = ErrCopyColumnData( sesid, tableidSrc,
					tableidDest, columnidInfo[icol].columnidSrc,
					columnidInfo[icol].columnidDest, pvBuf );

			if ( err < JET_errSuccess && err != JET_errAccessDenied )
				{
				break;
				}
			icol++;
			}

		callh( ErrDispUpdate( sesid, tableidDest, NULL, 0, &cbActual ), CloseIt );

		err = ErrDispMove( sesid, tableidSrc, JET_MoveNext, NO_GRBIT );
		}

	if ( err == JET_errNoCurrentRecord )
		err = JET_errSuccess;

CloseIt:

#ifdef	LATER
	ErrDispCommitTransaction( sesid, 1 );
#endif	/* LATER */
	if ( tableidTagged != JET_tableidNil )
		{
		ERR errT;

		/* how do we close/delete the temporary table? don't need it anymore
		/**/
		errT = ErrDispCloseTable( sesid, tableidLIDMap );
		if ( err == 0 || err > 0 && errT < 0 )
			err = errT;
		}

	return( err );
}


/*---------------------------------------------------------------------------
*									    									*
*	Procedure: ErrCopyTableIndexes					    					*
*									    									*
*	Arguments: pcompactinfo													*
*		   tableidDest	- table on which to build the index	    			*
*		   szTableName	- table name on which the index is based    		*
*		   indexList	- struct return from JetGetTableIndexInfo   		*
*									    									*
*	Returns : JET_ERR						    							*
*									    									*
*	Procedure copies all the indexes except for the clustered index     	*
*									    									*
---------------------------------------------------------------------------*/

ERR ErrCopyTableIndexes(
COMPACTINFO		*pcompactinfo,
JET_TABLEID		tableidDest,
const char		*szTableName,
JET_INDEXLIST	*indexList )
{
	JET_SESID		sesid;
	ERR 			err;
	JET_GRBIT		grbit;
	unsigned long	cbActual;

	sesid = pcompactinfo->sesid;

	err = ErrDispMove( sesid, indexList->tableid, JET_MoveFirst, NO_GRBIT );

	/* loop through all the indexes for this table		*/

	while ( err >= 0 )
		{
		callr( ErrDispRetrieveColumn( sesid, indexList->tableid,
					indexList->columnidgrbitIndex,
					&grbit, sizeof( JET_GRBIT ), &cbActual,
					NO_GRBIT, NULL ) );

		/* Don't copy references here */

		if ( ( grbit & JET_bitIndexReference ) == 0 )
			{
			/* If the index is not cluster create the index using CopyOneIndex */

			if ( ( grbit & JET_bitIndexClustered ) == 0 )
				{
				callr( ErrCopyOneIndex( pcompactinfo, tableidDest,
						szTableName, indexList ) );
				}
			}

		err = ErrDispMove( sesid, indexList->tableid, JET_MoveNext, NO_GRBIT );
		}

	if ( err == JET_errNoCurrentRecord )
		err = JET_errSuccess;

	return( err );
}

/**** REMOVE BEFORE SHIPPING *****/
CODECONST( char ) szMSysScripts[] = "MSysScripts";
CODECONST( char ) szMSysMacros[] = "MSysMacros";
/***** END OF REMOVAL *****/

/*---------------------------------------------------------------------------
*																			*
*	Procedure: ErrCopyTable 												*
*																			*
*	Arguments: pcompactinfo		- Compact information segment				*
*			   szObjectName 	- object name to copy the owner of	    	*
*			   szContainerName	- Container name in which the object exists *
*																			*
*	Returns : JET_ERR														*
*																			*
*	Procedure copies the table from the source database to the				*
*	destination database.  It can also copy queries, invoked by				*
*	ErrCopyObjects															*
*																			*
---------------------------------------------------------------------------*/

ERR ErrCopyTable(
COMPACTINFO	*pcompactinfo,
const char	*szContainerName,
const char	*szObjectName )
{
	JET_SESID		sesid;
	JET_DBID		dbidSrc;
	JET_DBID		dbidDest;
	void			*pvBuf;
	ERR 			err;
	ERR 			errT;
	JET_TABLEID		tableidSrc;
	JET_TABLEID		tableidDest;
	JET_COLUMNDEF	rgcolumndef[ccolumndefTaggedMax];
	JET_TABLEID		tableidTagged = JET_tableidNil;
	JET_COLUMNLIST	columnList;
	JET_INDEXLIST	indexList;

	sesid = pcompactinfo->sesid;
	dbidSrc = pcompactinfo->dbidSrc;
	dbidDest = pcompactinfo->dbidDest;
	pvBuf = pcompactinfo->rgbBuf;

	callr( ErrDispOpenTable( sesid, dbidSrc, &tableidSrc, szObjectName, NO_GRBIT ) );

/***** REMOVE BEFORE SHIPPING *****/
	if ( strcmp( szObjectName, szMSysScripts ) == 0 )
		{
		callh( ErrDispCreateTable( sesid, dbidDest, szMSysMacros, 0, ulDefaultDensity, &tableidDest ), CloseIt1 );
		}
	else
/***** END OF REMOVAL *****/

// UNDONE: fine-tune the density parameter
	callh( ErrDispCreateTable( sesid, dbidDest, szObjectName, 0, ulDefaultDensity, &tableidDest ), CloseIt1 );

	/* get a table with the column information for the query in it */

	callh( ErrDispGetTableColumnInfo( sesid, tableidSrc, NULL,
			&columnList, sizeof( columnList ), 1 ), CloseIt2 );

	/* if a table create the columns in the Dest Db the same as in	*/
	/* the src Db.	Get the information on the indexes and check if */
	/* there is a clustered index ( BLUE only )						*/

	callh( ErrCreateCols( pcompactinfo, tableidDest, szObjectName,
			&columnList, pcompactinfo->rgcolumnids,
			&tableidTagged, rgcolumndef ), CloseIt3 );

	callh( ErrDispGetTableIndexInfo( sesid, tableidSrc, NULL, &indexList,
				sizeof( indexList ), 1 ), CloseIt4 );

	callh( ErrCopyClusteredIndex( pcompactinfo, tableidDest, szObjectName, &indexList ), CloseIt5 );

	/* Copy the data in the table */

	callh( ErrCopyTableData( sesid, tableidDest, tableidSrc,
				pcompactinfo->rgcolumnids, tableidTagged, rgcolumndef, pvBuf ), CloseIt5 );

	err = ErrCopyTableIndexes( pcompactinfo, tableidDest, szObjectName, &indexList );

CloseIt5:
	errT = ErrDispCloseTable( sesid, indexList.tableid );

	if ( ( errT < 0 ) && ( err >= 0 ) )
		err = errT;

CloseIt4:
	if ( tableidTagged != JET_tableidNil )
		{
		errT = ErrDispCloseTable( sesid, tableidTagged );

		if ( ( errT < 0 ) && ( err >= 0 ) )
			err = errT;
		}

CloseIt3:
	errT = ErrDispCloseTable( sesid, columnList.tableid );

	if ( ( errT < 0 ) && ( err >= 0 ) )
		err = errT;

CloseIt2:
	errT = ErrDispCloseTable( sesid, tableidDest );

	if ( ( errT < 0 ) && ( err >= 0 ) )
		err = errT;

CloseIt1:
	errT = ErrDispCloseTable( sesid, tableidSrc );

	if ( ( errT < 0 ) && ( err >= 0 ) )
		err = errT;

	return( err );
}


/*---------------------------------------------------------------------------
*																			*
*	Procedure: ErrCopySoColumns												*
*																			*
*	Arguments: pcompactinfo		- Compact information segment				*
*			   szContainerName	- Container name in which the object exists *
*			   szObjectName 	- object name to copy the owner of	    	*
*																			*
*	Returns : JET_ERR														*
*																			*
*	Procedure copies the exta info columns in the MSysObjects table 		*
*																			*
---------------------------------------------------------------------------*/

ERR ErrCopySoColumns(
COMPACTINFO	*pcompactinfo,
const char	*szContainerName,
const char	*szObjectName )
{
	JET_SESID		sesid;
	JET_DBID		dbidDest;
	JET_DBID		dbidSrc;
	void			*pvBuf;
	ERR 			err;
	JET_TABLEID		tableidSrc;
	JET_TABLEID		tableidDest;
	unsigned		i;
	unsigned long	cbActual;
	OLD_OUTDATA		outdata;

	sesid = pcompactinfo->sesid;
	dbidSrc = pcompactinfo->dbidSrc;
	dbidDest = pcompactinfo->dbidDest;
	pvBuf = pcompactinfo->rgbBuf;

	/* open the record in the MSysObjects table for this object */

	outdata.cbMax = sizeof( tableidSrc );
	outdata.pb = &tableidSrc;

	callr( ErrDispGetObjectInfo( sesid, dbidSrc, 0, szContainerName,
				szObjectName, &outdata, 3 ) );

	outdata.cbMax = sizeof( tableidDest );
	outdata.pb = &tableidDest;

/***** REMOVE BEFORE SHIPPING *****/
	if ( strcmp( szObjectName, szMSysScripts ) == 0 )
		{
		callh( ErrDispGetObjectInfo( sesid, dbidDest, 0, szContainerName, szMSysMacros, &outdata, 3 ), CloseIt1 );
		}
	else
/***** END OF REMOVAL *****/

	callh( ErrDispGetObjectInfo( sesid, dbidDest, 0, szContainerName,
				szObjectName, &outdata, 3 ), CloseIt1 );

	if ( !pcompactinfo->fHaveSoColumnids )
		callh( ErrGetSoColumnids( pcompactinfo, tableidSrc, tableidDest ), CloseIt2 );

	callh( ErrDispPrepareUpdate( sesid, tableidDest, JET_prepReplaceNoLock ), CloseIt2 );

	/* Copy the information for these columns from the src to dest db */

	for ( i = 0; i < icolSoMax1; i++ )
		{
		callh( ErrCopyColumnData( sesid, tableidSrc, tableidDest,
				pcompactinfo->rgcolumnidsSo[i].columnidSrc,
				pcompactinfo->rgcolumnidsSo[i].columnidDest, pvBuf ), CloseIt2 );
		}

	callh( ErrDispUpdate( sesid, tableidDest, NULL, 0, &cbActual ), CloseIt2 );

CloseIt2:
	ErrDispCloseTable( sesid, tableidDest );

CloseIt1:
	ErrDispCloseTable( sesid, tableidSrc );

	return( err );
}


/*---------------------------------------------------------------------------
*																			*
*	Procedure: ErrCopyObjects												*
*																			*
*	Arguments: pcompactinfo		- Compact information segment				*
*			   szContainerName	- Container name in which the object exists *
*			   szObjectName 	- object name to copy						*
*			   objtyp			- object type								*
*																			*
*	Returns : JET_ERR														*
*																			*
*	Procedure copies the exta info columns in the MSysObjects table 		*
*																			*
---------------------------------------------------------------------------*/

ERR ErrCopyObject(
COMPACTINFO	*pcompactinfo,
const char	*szContainerName,
const char	*szObjectName,
JET_OBJTYP	objtyp )
{
	ERR		err;
	char	szMessage[3+2*JET_cbNameMost];

	strcpy( szMessage, szSlash );

	if ( objtyp != JET_objtypContainer )
		{
		strcat( szMessage, szContainerName );
		strcat( szMessage, szSlash );
		}

	strcat( szMessage, szObjectName );

#ifndef RETAIL
	err = ErrReportMessage( pcompactinfo, JET_sncCopyObject, szMessage );

	if ( err < 0 )
		return( err );
#endif /* !RETAIL */

	switch ( objtyp )
		{
	case JET_objtypDb:
		err = JET_errSuccess;  /* Present after CreateDatabase */
		break;

	case JET_objtypContainer:
		err = JET_errSuccess;  /* Containers already copied. */
		break;

	case JET_objtypTable:
		if ( ( strcmp( szObjectName, szSiTable ) == 0 ) ||
		    ( strcmp( szObjectName, szSoTable ) == 0 ) ||
		    ( strcmp( szObjectName, szScTable ) == 0 ) ||
#ifdef SEC
		    ( strcmp( szObjectName, szSpTable ) == 0 ) ||
#endif
		    ( strcmp( szObjectName, "MSysRelationships" ) == 0 ) ||
		    ( strcmp( szObjectName, szSqTable ) == 0 ) )
			{
			/* The object is a system table. */

			err = JET_errSuccess;
			}
		else
			err = ErrCopyTable( pcompactinfo, szContainerName, szObjectName );
		break;

	default :
		if ( objtyp >= JET_objtypClientMin )
			{
			OBJID objidContainer;

			if ( ( err = ErrDispGetObjidFromName( pcompactinfo->sesid, pcompactinfo->dbidDest, NULL, szContainerName, &objidContainer ) ) >= 0 )
				err = ErrDispCreateObject( pcompactinfo->sesid, pcompactinfo->dbidDest, objidContainer, szObjectName, objtyp );
			}
		else
			{
			/* Don't know how to handle this.  Skip it. */

			err = JET_errAccessDenied;
			}
		break;
		}

#ifndef RETAIL
	if ( err < 0 )
		{
		if ( err == JET_errDiskFull )
			return( err );

		ErrReportMessage( pcompactinfo, JET_sncCopyFailed, szMessage );
		}
#endif /* !RETAIL */

	return( err );
}


/*---------------------------------------------------------------------------
*
*	Procedure: ErrCopyObjects
*
*	Arguments: pcompactinfo	- Compact information segment
*
*	Returns : JET_ERR
*
*	Procedure copies the objects from the source
*	database to the destination databse.  It then copies the extra
*	information in the msysobjects table ( eg Description ) and copies the
*	security rights for all the objects in the database to which it has
*	access.
*	If fCopyContainers is fTrue, copy only container info into destination
*	If fCopyContainers is fFalse, copy only non-container info.
*	NOTE: progress callbacks are currently set up to work such that the
*	NOTE: first call to ErrCopyObjects must be with fCopyContainers set FALSE.
*
---------------------------------------------------------------------------*/

ERR ErrCopyObjects( COMPACTINFO *pcompactinfo )
{
	JET_SESID		sesid;
	JET_TABLEID		tableid;
	JET_COLUMNID	columnidObjtyp;
	JET_COLUMNID	columnidObjectName;
	JET_COLUMNID	columnidContainerName;
	long			cRow;
	ERR 			err;
	JET_OBJTYP		objtyp;
	unsigned long	cbActual;
	char			szObjectName[JET_cbNameMost+1];
	char			szContainerName[JET_cbNameMost+1];

	sesid = pcompactinfo->sesid;
	tableid = pcompactinfo->objectlist.tableid;
	columnidObjtyp = pcompactinfo->objectlist.columnidobjtyp;
	columnidObjectName = pcompactinfo->objectlist.columnidobjectname;
	columnidContainerName = pcompactinfo->objectlist.columnidcontainername;

	/* loop through all the objects in the src db to do the following:	*/
	/*	- create the same object in the dest db 						*/
	/*	- copy the extra info. in the MSysObjects table 				*/
	/*	- copy the security rights										*/

	cRow = JET_MoveFirst;

	while ( ( err = ErrDispMove( sesid, tableid, cRow, 0 ) ) >= 0 )
		{
		cRow = JET_MoveNext;

		/* Get the object's type and name */

		callr( ErrDispRetrieveColumn( sesid, tableid, columnidObjtyp,
				&objtyp, sizeof( objtyp ),
				&cbActual, 0, NULL ) );

		callr( ErrDispRetrieveColumn( sesid, tableid, columnidContainerName,
					szContainerName, JET_cbNameMost,
					&cbActual, 0, NULL ) );
		szContainerName[cbActual] = '\0';

		callr( ErrDispRetrieveColumn( sesid, tableid, columnidObjectName,
					szObjectName, JET_cbNameMost,
					&cbActual, 0, NULL ) );
		szObjectName[cbActual] = '\0';

		callr( ErrReportProgress( pcompactinfo ) );

		callr( ErrCopyObject( pcompactinfo, szContainerName, szObjectName, objtyp ) );

		pcompactinfo->cunitDone++;
		}

	if ( err == JET_errNoCurrentRecord )
		err = JET_errSuccess;

	return( err );
}


/*---------------------------------------------------------------------------
*																			*
*	Procedure: ErrCopyOneReference											*
*																			*
*	Arguments: pcompactinfo		- Compact information segment				*
*			   szTableName		- Name of table to copy						*
*			   tableidDest		- Tableid of the destination table			*
*			   reflist			- Reference list							*
*																			*
*	Returns : JET_ERR														*
*																			*
*	Procedure copies the exta info columns in the MSysObjects table 		*
*																			*
---------------------------------------------------------------------------*/

ERR ErrCopyOneReference(
COMPACTINFO			*pcompactinfo,
const char			*szTableName,
JET_TABLEID			tableidDest,
JET_REFERENCELIST	*reflist )
{
	JET_SESID		sesid;
	char			*pchReferencing;
	char			*pchReferenced;
	ERR 			err;
	char			szReferenceName[JET_cbNameMost+1];
	unsigned long	cbActual;
	JET_GRBIT		grbit;
	unsigned long	cColumn;
	char			szReferencedTableName[JET_cbNameMost+1];
	char			rgchColumnName[JET_cbNameMost];

	sesid = pcompactinfo->sesid;
	pchReferencing = pcompactinfo->rgbBuf;
	pchReferenced = pcompactinfo->rgbBuf+1000;  /* CONSIDER */

	callr( ErrDispRetrieveColumn( sesid, reflist->tableid,
				reflist->columnidReferenceName,
				szReferenceName, JET_cbNameMost, &cbActual, 0, NULL ) );
	szReferenceName[cbActual] = '\0';

	callr( ErrDispRetrieveColumn( sesid, reflist->tableid,
				reflist->columnidgrbit,
				&grbit, sizeof( grbit ), &cbActual, 0, NULL ) );

	callr( ErrDispRetrieveColumn( sesid, reflist->tableid,
				reflist->columnidcColumn,
				&cColumn, sizeof( cColumn ), &cbActual, 0, NULL ) );

	callr( ErrDispRetrieveColumn( sesid, reflist->tableid,
				reflist->columnidReferencedTableName,
				szReferencedTableName, JET_cbNameMost, &cbActual, 0, NULL ) );
	szReferencedTableName[cbActual] = '\0';

	/* Create the column lists */

	while ( cColumn != 0 )
		{
		cColumn--;

		callr( ErrDispRetrieveColumn( sesid, reflist->tableid,
					reflist->columnidReferencingColumnName,
					rgchColumnName, JET_cbNameMost, &cbActual, 0, NULL ) );

		memcpy( pchReferencing, rgchColumnName, ( size_t ) cbActual );

		pchReferencing += ( size_t ) cbActual;
		*pchReferencing++ = '\0';

		callr( ErrDispRetrieveColumn( sesid, reflist->tableid,
					reflist->columnidReferencedColumnName,
					rgchColumnName, JET_cbNameMost, &cbActual, 0, NULL ) );

		memcpy( pchReferenced, rgchColumnName, ( size_t ) cbActual );

		pchReferenced += ( size_t ) cbActual;
		*pchReferenced++ = '\0';

		err = ErrDispMove( sesid, reflist->tableid, JET_MoveNext, 0 );

		if ( err < 0 )
			break;
		}

	if ( ( cColumn != 0 ) || ( err < 0 && err != JET_errNoCurrentRecord ) )
		return( err );

	*pchReferencing = '\0';
	*pchReferenced = '\0';

	pchReferencing = pcompactinfo->rgbBuf;
	pchReferenced = pcompactinfo->rgbBuf+1000;  /* CONSIDER */

	callr( ErrDispCreateReference( sesid, tableidDest,
				szReferenceName, pchReferencing,
				szReferencedTableName, pchReferenced,
				grbit ) );

	err = ErrCopySiColumns( pcompactinfo, szTableName, szReferenceName, tableidDest );

	if ( ( err < 0 ) && ( err != JET_errAccessDenied ) )
		{
		return( err );
		}

	return( JET_errSuccess );
}


/*---------------------------------------------------------------------------
*																			*
*	Procedure: ErrCopyTableReferences										*
*																			*
*	Arguments: pcompactinfo		- Compact information segment				*
*			   szObjectName 	- Name of object to copy					*
*																			*
*	Returns : JET_ERR														*
*																			*
*	Procedure copies the exta info columns in the MSysObjects table 		*
*																			*
---------------------------------------------------------------------------*/

ERR ErrCopyTableReferences(
COMPACTINFO	*pcompactinfo,
const char	*szObjectName )
{
	JET_SESID			sesid;
	JET_DBID			dbidDest;
	JET_DBID			dbidSrc;
	void				*pvBuf;
	ERR 				err;
	JET_TABLEID			tableidSrc;
	JET_TABLEID			tableidDest;
	JET_REFERENCELIST	reflist;

	sesid = pcompactinfo->sesid;
	dbidSrc = pcompactinfo->dbidSrc;
	dbidDest = pcompactinfo->dbidDest;
	pvBuf = pcompactinfo->rgbBuf;

	callr( ErrDispOpenTable( sesid, dbidSrc, &tableidSrc, szObjectName, 0 ) );

/***** REMOVE BEFORE SHIPPING *****/
	if ( strcmp( szObjectName, szMSysScripts ) == 0 )
		{
		callh( ErrDispOpenTable( sesid, dbidDest, &tableidDest, szMSysMacros, JET_bitTableDenyRead ), CloseIt1 );
		}
	else
/***** END OF REMOVAL *****/

	callh( ErrDispOpenTable( sesid, dbidDest, &tableidDest, szObjectName, JET_bitTableDenyRead ), CloseIt1 );

	callh( ErrDispGetTableReferenceInfo( sesid, tableidSrc, NULL, &reflist,
				sizeof( reflist ), 1 ), CloseIt2 );

	err = ErrDispMove( sesid, reflist.tableid, JET_MoveFirst, 0 );

	/* Loop through all the references for this table */

	while ( err >= 0 )
		{
		err = ErrCopyOneReference( pcompactinfo, szObjectName, tableidDest, &reflist );
		}

	if ( err == JET_errNoCurrentRecord )
		err = JET_errSuccess;

	ErrDispCloseTable( sesid, reflist.tableid );

CloseIt2:
	ErrDispCloseTable( sesid, tableidDest );

CloseIt1:
	ErrDispCloseTable( sesid, tableidSrc );

	return( err );
}


/*---------------------------------------------------------------------------
*																			*
*	Procedure: ErrCopyReferences											*
*																			*
*	Arguments: pcompactinfo		- Compact information segment				*
*																			*
*	Returns : JET_ERR														*
*																			*
*	Procedure copies the exta info columns in the MSysObjects table 		*
*																			*
---------------------------------------------------------------------------*/

ERR ErrCopyReferences( COMPACTINFO *pcompactinfo )
{
	JET_SESID		sesid;
	JET_TABLEID		tableid;
	JET_COLUMNID	columnidObjtyp;
	JET_COLUMNID	columnidObjectName;
	long				cRow;
	ERR 				err;
	JET_OBJTYP		objtyp;
	unsigned long	cbActual;
	char				szObjectName[JET_cbNameMost+1];

	sesid = pcompactinfo->sesid;
	tableid = pcompactinfo->objectlist.tableid;
	columnidObjtyp = pcompactinfo->objectlist.columnidobjtyp;
	columnidObjectName = pcompactinfo->objectlist.columnidobjectname;

	cRow = JET_MoveFirst;

	while ( ( err = ErrDispMove( sesid, tableid, cRow, 0 ) ) >= 0 )
		{
		cRow = JET_MoveNext;

		/* Get the object's type and name */

		callr( ErrDispRetrieveColumn( sesid, tableid, columnidObjtyp,
				&objtyp, sizeof( objtyp ),
				&cbActual, 0, NULL ) );

		if ( objtyp != JET_objtypTable )
			continue;

		callr( ErrDispRetrieveColumn( sesid, tableid, columnidObjectName,
					szObjectName, JET_cbNameMost,
					&cbActual, 0, NULL ) );
		szObjectName[cbActual] = '\0';

		if ( ( strcmp( szObjectName, szSiTable ) == 0 ) ||
		    ( strcmp( szObjectName, szSoTable ) == 0 ) ||
		    ( strcmp( szObjectName, szScTable ) == 0 ) ||
#ifdef SEC
		    ( strcmp( szObjectName, szSpTable ) == 0 ) ||
#endif
		    ( strcmp( szObjectName, szSqTable ) == 0 ) )
			{
			/* The object is a system table. */

			continue;
			}

// REMOVED:		err = ErrCopyTableReferences( pcompactinfo, szObjectName );
		callr( ErrCopyTableReferences( pcompactinfo, szObjectName ) );

		if ( err == JET_errDiskFull )
			return( err );

#ifndef RETAIL
		if ( err < 0 )
			{
			char	szMessage[3+2*JET_cbNameMost];

			strcpy( szMessage, szSlash );
			strcat( szMessage, szTcObject );
			strcat( szMessage, szSlash );
			strcat( szMessage, szObjectName );

			ErrReportMessage( pcompactinfo, JET_sncCopyFailed, szMessage );
			}
#endif /* !RETAIL */
		}

	if ( err == JET_errNoCurrentRecord )
		err = JET_errSuccess;

	return( err );
}


/*---------------------------------------------------------------------------
*																			*
*	Procedure: ErrCleanup													*
*																			*
*	Arguments: pcompactinfo	- Compact information segment					*
*																			*
*	Returns : JET_ERR														*
*																			*
*	Procedure closes the databases											*
*																			*
---------------------------------------------------------------------------*/

ERR ErrCleanup(
COMPACTINFO	*pcompactinfo )
{
	JET_SESID	sesid;
	ERR 		err;
	ERR 		errT;

	sesid = pcompactinfo->sesid;

	/* Close the databases */

	err = ErrDispCloseTable( sesid, pcompactinfo->objectlist.tableid );

	errT = ErrDispCloseDatabase( sesid, pcompactinfo->dbidSrc, 0 );
	if ( ( errT < 0 ) && ( err != JET_errSuccess ) )
		err = errT;

	errT = ErrDispCloseDatabase( sesid, pcompactinfo->dbidDest, 0 );
	if ( ( errT < 0 ) && ( err != JET_errSuccess ) )
		err = errT;

	return( err );
}

/*---------------------------------------------------------------------------
*																			*
*	Procedure: ErrGetQueryColumnids 										*
*																			*
*	Arguments: sesid			- session id in which the work is done		*
*			   columnList		- struct returned from GetTableColumnInfo	*
*			   tableidDest		- table on which to build the index			*
*			   columnidInfo 	- the columnid's of the user table			*
*																			*
*	Returns : JET_ERR														*
*																			*
*	Procedure gets the columnids for the query so that the data can be		*
*   copied like that of table												*
*																			*
---------------------------------------------------------------------------*/

ERR ErrGetQueryColumnids(
JET_SESID		sesid,
JET_COLUMNLIST	*columnList,
JET_TABLEID		tableidDest,
COLUMNIDINFO	*columnidInfo )
{
	ERR 			err;
	char			szColumnName[JET_cbNameMost+1];
	unsigned long	cbActual;
	JET_COLUMNDEF	columndef;
	unsigned		cColumns = 0;

	err = ErrDispMove( sesid, columnList->tableid, JET_MoveFirst, NO_GRBIT );

	/* loop though all the columns in the table for the src tbl and     */
	/* get the columnid's for both databases and store the information  */

	while ( err >= 0 )
		{
		callr( ErrDispRetrieveColumn( sesid, columnList->tableid,
					columnList->columnidcolumnid, &columnidInfo[cColumns].columnidSrc,
					sizeof( columnidInfo[cColumns].columnidSrc ), &cbActual, NO_GRBIT, NULL ) );

		callr( ErrDispRetrieveColumn( sesid, columnList->tableid,
					columnList->columnidcolumnname, szColumnName,
					JET_cbNameMost, &cbActual, NO_GRBIT, NULL ) );

		szColumnName[cbActual] = '\0';

		callr( ErrDispGetTableColumnInfo( sesid, tableidDest, szColumnName,
					    &columndef, sizeof( columndef ), 0 ) );

		columnidInfo[cColumns].columnidDest = columndef.columnid;

		cColumns++;

		err = ErrDispMove( sesid, columnList->tableid, JET_MoveNext, NO_GRBIT );
		}

	if ( err == JET_errNoCurrentRecord )
		err = JET_errSuccess;

	/* to set up a spot so that we know when to stop searching
		through the columns while coping data */

	columnidInfo[cColumns].columnidSrc	= 0;

	return( err );
}



ERR ErrCopyOneTaggedColumn(
	JET_SESID			sesid,
	JET_TABLEID			tableidSrc,
	JET_TABLEID			tableidDest,
	JET_COLUMNID		columnidDest,
	JET_COLUMNDEF		*rgcolumndef,
	void					*pvBuf,
	unsigned long	 	*pcbData,
	JET_RETINFO			*pretinfo,
	BOOL					fForceSeparated )
	{
	ERR 					err;
	int					cLV = 0;
	JET_SETINFO			setinfo;

	/* set up the setinfo structure */

	setinfo.ibLongValue = 0;
	setinfo.itagSequence = pretinfo->itagSequence;
	setinfo.cbStruct = sizeof( setinfo );

	if ( *pcbData > cbLvMax )
		*pcbData = cbLvMax;

	Call( ErrDispSetColumn( sesid, tableidDest, columnidDest,
		pvBuf, *pcbData, NO_GRBIT, &setinfo ) );

	if ( fForceSeparated )
		{
		BOOL 					fSeparated;
		unsigned long	lidDest, lrefcnt;
		JET_VTID			vtidDest;

		Call( ErrGetVtidTableid( sesid, tableidDest, &vtidDest ) );

		Call( ErrRECExtrinsicLong( vtidDest, pretinfo->itagSequence,
										&fSeparated, &lidDest, &lrefcnt, JET_bitRetrieveCopy ) );

		/* force separation, since long value is separated in source
		/**/
		if ( !fSeparated )
			Call( ErrRECForceSeparatedLV( vtidDest, pretinfo->itagSequence ) );

		}
	/* while the long value is not all copied */

	while ( *pcbData == cbLvMax )
		{
		cLV++;
		pretinfo->ibLongValue = cLV * cbLvMax;
		Call( ErrDispRetrieveColumn( sesid, tableidSrc, 0, pvBuf,
						cbLvMax, pcbData, NO_GRBIT, pretinfo ) );

		if ( *pcbData > 0 )
			{
			if ( *pcbData > cbLvMax )
				*pcbData = cbLvMax;
			Call( ErrDispSetColumn( sesid, tableidDest, columnidDest, pvBuf, *pcbData,
							JET_bitSetAppendLV, NULL ) );
			}
		}

	return( err );

HandleError:
	return( err );
}


/*---------------------------------------------------------------------------
*																			*
*	Procedure: ErrCopyTaggedColumns 										*
*																			*
*	Arguments: sesid			- session id in which the work is done		*
*			   tableidSrc			- tableid of the table in the src db		*
*			   tableidDest		- tableid of the table in the dest db		*
*			   tableidTagged	- tableid of the temp table containing the  *
*													tagged columninfo						*
*				 tableidLIDMap 	- tableid of mapping between LIDSrc and LIDDest *
*			   pvBuf					-	the segment for copying long values		*
*																			*
*	Returns : JET_ERR														*
*																			*
*	Procedure copies data from the source table to the destination table
*	if LID of Src is already found in tableidLIDMap, then just adds reference	*
*																			*
---------------------------------------------------------------------------*/

ERR ErrCopyTaggedColumns(
JET_SESID			sesid,
JET_TABLEID		tableidSrc,
JET_TABLEID		tableidDest,
JET_TABLEID		tableidTagged,
JET_TABLEID		tableidLIDMap,
JET_COLUMNDEF	*rgcolumndefTagged,
JET_COLUMNDEF	*rgcolumndefLIDMap,
void					*pvBuf )
{
	ERR 					err;
	JET_RETINFO		retinfo;
	JET_COLUMNID 	columnidDest;
	unsigned long	cbData;
	BOOL					fSeparated;
	long 					lidSrc;
	long					lidDest;
	long					lrefcnt;
	unsigned long	cbActual;
	JET_VTID			vtidSrc, vtidDest; // for REC functions

	/* set up the retinfo structure */

	retinfo.ibLongValue = 0;
	retinfo.itagSequence = 1;
	retinfo.columnidNextTagged = 0;
	retinfo.cbStruct = sizeof( retinfo );

	Call( ErrDispRetrieveColumn( sesid, tableidSrc, 0,
			pvBuf, cbLvMax, &cbData, NO_GRBIT, &retinfo ) );

	/* get the vtid's for the REC functions
	/**/
	Call( ErrGetVtidTableid( sesid, tableidSrc, &vtidSrc ) );
	Call( ErrGetVtidTableid( sesid, tableidDest, &vtidDest ) );

	/* as long as there is a tagged column	*/
	while ( cbData > 0 )
		{
		/* check for extrinsic long values
		/**/
		Call( ErrRECExtrinsicLong( vtidSrc, retinfo.itagSequence,
								&fSeparated, &lidSrc, &lrefcnt, NO_GRBIT ) );

		/* retrieve the columnid for the destination database */
		/**/
		Call( ErrDispMakeKey( sesid, tableidTagged,
				&retinfo.columnidNextTagged, sizeof( JET_COLUMNID ),
				JET_bitNewKey ) );

		Call( ErrDispSeek( sesid, tableidTagged, JET_bitSeekEQ ) );

		Call( ErrDispRetrieveColumn( sesid, tableidTagged,
						rgcolumndefTagged[icolumnColumnidDest].columnid,
						&columnidDest, sizeof( JET_COLUMNID ), &cbActual, NO_GRBIT, NULL ) );

		/* special case extrinsic long values to handle single instance store
		/**/
		if ( !fSeparated )
			{
			/* insert one tagged column
			/**/
			Call( ErrCopyOneTaggedColumn( sesid, tableidSrc, tableidDest,
										columnidDest, rgcolumndefLIDMap, pvBuf, &cbData, &retinfo, fSeparated ) );
			}
		else
			{
			/* check for lidSrc in LVMapTable
			/**/
			Call( ErrDispMakeKey( sesid, tableidLIDMap, ( void * ) &lidSrc,
											sizeof( long ), JET_bitNewKey ) );
			err = ErrDispSeek( sesid, tableidLIDMap, JET_bitSeekEQ );

			if ( err < 0 && err != JET_errRecordNotFound )
				{
				Assert( 0 );
				Call( err );
				}
			else if ( err == JET_errRecordNotFound )
				{
				/* first occurance of this long value
				/* copy one tagged column
				/* UNDONE: may have to force separation
				/**/
				Call( ErrCopyOneTaggedColumn( sesid, tableidSrc, tableidDest,
									columnidDest, rgcolumndefLIDMap, pvBuf, &cbData, &retinfo, fSeparated ) );

				/* get LID of field at destination table -- potential problem?
				/**/
				Call( ErrRECExtrinsicLong( vtidDest, retinfo.itagSequence,
										&fSeparated, &lidDest, &lrefcnt, JET_bitRetrieveCopy ) );
				Assert( fSeparated );

				/* insert lidSrc and lidDest into the LIDMapTable
				/**/
				Call( ErrDispPrepareUpdate( sesid, tableidLIDMap, JET_prepInsert ) );

				Call( ErrDispSetColumn( sesid, tableidLIDMap,
					rgcolumndefLIDMap[icolumnLidSrc].columnid,
					&lidSrc, sizeof( lidSrc ), NO_GRBIT, NULL ) );

				Call( ErrDispSetColumn( sesid, tableidLIDMap,
					rgcolumndefLIDMap[icolumnLidDest].columnid,
					&lidDest, sizeof( lidDest ), NO_GRBIT, NULL ) );

				Call( ErrDispUpdate( sesid, tableidLIDMap, NULL, 0, NULL ) );

				}
			else
				{
				unsigned long cbActual;

				/* this long value has been seen before, do not insert value
				/* adjust only ref-count in destination table
				/**/
				Assert( err >= 0 );

				/* retrieve LIDDest from LVMapTable
				/**/
				Call( ErrDispRetrieveColumn( sesid, tableidLIDMap,
										rgcolumndefLIDMap[icolumnLidDest].columnid,
										( void * )&lidDest, sizeof( lidDest ),
										&cbActual, 0, NULL ) );
				Assert( cbActual == sizeof( lidDest ) );

				/* adjust LID at current record and increment ref count
				/**/
				Call( ErrREClinkLid( vtidDest, columnidDest,
									lidDest, retinfo.itagSequence ) );
				}
			}

		retinfo.ibLongValue = 0;
		retinfo.itagSequence++;

		Call( ErrDispRetrieveColumn( sesid, tableidSrc, 0,
				pvBuf, cbLvMax, &cbData, NO_GRBIT, &retinfo ) );

		}
	return( JET_errSuccess );

HandleError:
	return( err );
}



/* The following pragma affects the code generated by the C */
/* compiler for all FAR functions.  Do NOT place any non-API */
/* functions beyond this point in this file. */

/*---------------------------------------------------------------------------
*																			*
*	Procedure: JetCompact													*
*																			*
*	Returns:   JET_ERR returned by JetCompact or by other Jet API.			*
*																			*
*	The procedure copies the source database into the destination database	*
*	so that it will take up less disk space storage.						*
*																			*
---------------------------------------------------------------------------*/

JET_ERR JET_API JetCompact( JET_SESID sesid, const char __far *szDatabaseSrc,
	const char __far *szConnectSrc, const char __far *szDatabaseDest,
	const char __far *szConnectDest, JET_PFNSTATUS pfnStatus,
	JET_GRBIT grbit )
{
	ERR 		err;
	ERR 		errT;

#ifndef WIN32
	_segment	seg;
#endif		// WIN32

	COMPACTINFO	*pcompactinfo;

	APIEnter( );

	if ( ( ( grbit & JET_bitCompactEncrypt ) != 0 ) &&
	    ( ( grbit & JET_bitCompactDecrypt ) != 0 ) )
		return( JET_errInvalidParameter );

	if ( ( grbit & ~( JET_bitCompactEncrypt | JET_bitCompactDecrypt | JET_bitCompactDontCopyLocale ) ) != 0 )
		return( JET_errInvalidParameter );

	pcompactinfo = ( ( COMPACTINFO * ) SAlloc( sizeof( COMPACTINFO ) ) );
    if (pcompactinfo == NULL)
        return( JET_errOutOfMemory );

	pcompactinfo->pfnStatus = pfnStatus;

	pcompactinfo->fDontCopyLocale = ( ( grbit & JET_bitCompactDontCopyLocale ) != 0 );

	pcompactinfo->fHaveSoColumnids = fFalse;
	pcompactinfo->fHaveScColumnids = fFalse;
	pcompactinfo->fHaveSiColumnids = fFalse;

	if ( pfnStatus != NULL )
		{
		JET_SNPROG snprog;

		memset( &snprog, 0, sizeof( snprog ) );
		snprog.cbStruct = sizeof( JET_SNPROG );

		( *pfnStatus )( sesid, JET_snpCompact, JET_sntBegin, &snprog );
		}

	pcompactinfo->sesid = sesid;

	/* Open and create the databases */

	callh( ErrCompactInit( pcompactinfo, szDatabaseSrc, szConnectSrc,
				szDatabaseDest, szConnectDest, grbit ), CloseIt7 );

	/* Create all containers in destination */

	callh( ErrCreateContainers( pcompactinfo ), CloseIt9 );

	/* Init callback stats */

	pcompactinfo->cunitTotal = pcompactinfo->objectlist.cRecord*2;
	pcompactinfo->cunitDone = 0;

	/* Create and copy all non-container objects */

	callh( ErrCopyObjects( pcompactinfo ), CloseIt9 );

	/* Copy all object permissions and owners */

	callh( ErrReportProgress( pcompactinfo ), CloseIt9 );

CloseIt9:
	/* Close the databases */

	errT = ErrCleanup( pcompactinfo );

	if ( ( errT < 0 ) && ( err >= 0 ) )
		err = errT;

CloseIt7:
	SFree( pcompactinfo );

	if ( pfnStatus != NULL )
		{
		if ( err < 0 )
			( *pfnStatus )( sesid, JET_snpCompact, JET_sntFail, NULL );
		else
			{
			JET_SNPROG snprog;

			memset( &snprog, 0, sizeof( snprog ) );
			snprog.cbStruct = sizeof( JET_SNPROG );

			( *pfnStatus )( sesid, JET_snpCompact, JET_sntComplete, &snprog );
			}
		}

	/* Get rid if the destination database if there was an error */

	if ( err < 0 )
		{
		if ( err != JET_errDatabaseDuplicate )
			{
			ERR ErrSysDeleteFile( const char __far *szFilename );
			ErrSysDeleteFile( szDatabaseDest );
			}
		}

	APIReturn( err );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\src\sysdb.c ===
#include "std.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

DeclAssertFile;

#define	szSystemMdb		"system.mdb"

void _cdecl main(void)
	{
	JET_ERR 		err;
	JET_SESID	sesid;
	JET_DBID		dbid;

	err = JetInit(NULL);
	Assert(err >= 0);

	err = JetBeginSession(0, &sesid, "", "" );
	Assert(err >= 0);

	err = JetCreateDatabase(sesid, szSystemMdb, ";COUNTRY=1;LANGID=0x0409;CP=1252", &dbid, 0 );
	Assert( err >= 0 || err == JET_errDatabaseDuplicate );
	if ( err == JET_errDatabaseDuplicate )
		JetOpenDatabase( sesid, szSystemMdb, "", &dbid, 0 );
	
	err = JetEndSession(sesid, 0);
	Assert(err >= 0);

	err = JetTerm(0);
	Assert(err >= 0);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\src\sesmgr.c ===
/***********************************************************************
* Microsoft Jet
*
* Microsoft Confidential.  Copyright 1991-1992 Microsoft Corporation.
*
* Component:
*
* File: sesmgr.c
*
* File Comments:
*
* Revision History:
*
*    [0]  02-Nov-90  eddieg	Created
*
***********************************************************************/

#include "std.h"

#include <stdlib.h>

DeclAssertFile;

static int __near	fInitialized;

int __near		isibFree;
int __near		isibHead = -1;

SIB __near		rgsib[csibMax];



/*=================================================================
IsibAllocate

Description:
  This routine is used to determine the index into the rgsib array
  of a new SIB.

Parameters:

Return Value:
  -1 if there is no SIB available;
  The index into the rgsib array of the new SIB
=================================================================*/

int IsibAllocate(void)
{
	int	 isib;

	if (!fInitialized)
	{
		isibFree = csibMax - 1;

		for (isib = csibMax - 1; isib >= 0; isib--)
			rgsib[isib].isibNext = isib - 1;

		fInitialized = fTrue;
	}

	isib = isibFree;

	if (isib != -1)
	{
		/* Remove free free list */

		isibFree = rgsib[isib].isibNext;

		bltbcx(0, &rgsib[isib], sizeof(rgsib[isib]));

		/* Add to active list */

		rgsib[isib].isibNext = isibHead;
		isibHead = isib;
	}

	return(isib);
}


/*=================================================================
ErrInitSib

Description:
  This routine is used to get the initialize elements of the SIB
  associated with SIB index provided.

Parameters:
  sesid			identifies the session uniquely, assigned into SIB
  isib			index to specific SIB, used to reference SIB
  szUsername    name of user which SIB belongs to, assigned into SIB

Return Value:
  JET_errOutOfMemory if no memory can be allocated for the username,
  JET_errSuccess	 otherwise.
=================================================================*/
JET_ERR ErrInitSib(JET_SESID sesid, int isib, const char __far *szUsername)
{
	ERR		err = JET_errSuccess;	/* Return code from internal functions */
									/* Take an optimistic attitude! */
	char __far	*pUserName;			/* Pointer to the user name */
	unsigned	cbUserName;			/* Length of the user name */

	/* Initialize the SIB with this index */
	Assert(isib < csibMax);

	rgsib[isib].sesid      = sesid;
	rgsib[isib].tl         = 0;
	rgsib[isib].iiscb      = -1;
	rgsib[isib].exterr.err = JET_wrnNoErrorInfo;

	/* Store the user account name for this session. */
	cbUserName = CbFromSz(szUsername) + 1;
	if ((pUserName = (char __far *) SAlloc(cbUserName)) == NULL)
	{
		err = JET_errOutOfMemory;
	}
	else
	{
		bltbx(szUsername, pUserName, cbUserName);
		rgsib[isib].pUserName = pUserName;
	}

	return (err);
}

/*=================================================================
ReleaseIsib

Description:
  This routine is used to release a SIB which is no longer needed.

Parameters:
  isib			identifies the SIB to free

Dependencies:
  Assumes that the SIB is zeroed when allocated and that functions
  which invalidate an element before releasing the sib, zero the
  element.

Return Value: None
=================================================================*/

void ReleaseIsib(int isib)
{
	Assert(fInitialized);
	Assert(isib < csibMax);

	/* free the user name memory block in use for this SIB */
	if (rgsib[isib].pUserName)
	{
		SFree(rgsib[isib].pUserName);
	}


	/* Free extended error information strings. */
	if (rgsib[isib].sz1)
	{
		SFree(rgsib[isib].sz1);
	}
	if (rgsib[isib].sz2)
	{
		SFree(rgsib[isib].sz2);
	}
	if (rgsib[isib].sz3)
	{
		SFree(rgsib[isib].sz3);
	}

	if (isib == isibHead)
	{
		isibHead = rgsib[isib].isibNext;
	}
	else
	{
		int   isibT;
		int   isibNext;

		for (isibT = isibHead; isibT != -1; isibT = isibNext)
		{
			isibNext = rgsib[isibT].isibNext;
		
	 		/* Remove SIB from active list */
	 		
	 		if (isibNext == isib)
	 		{
				 rgsib[isibT].isibNext = rgsib[isib].isibNext;
				 break;
	 		}
		}

		Assert(isibT != -1);
	}

#ifndef RETAIL
	bltbcx(0xff, &rgsib[isib], sizeof(rgsib[isib]));
#endif	/* RETAIL */

	rgsib[isib].isibNext = isibFree;
	isibFree = isib;
}


/*=================================================================
IsibNextIsibPsesid

Description:
  This routine is used to scan the rgsib array

Parameters:
  isib			if isib == -1, then get isibHead. if isib != -1, then
                get next isib in the list.
  psesid		return the session uniquely.

Return
  isib          the isib of the sesid returned in psesid.
=================================================================*/

int IsibNextIsibPsesid(int isib, JET_SESID __far *psesid)
{
	if (isib == -1)
		isib = isibHead;
	else
		isib = rgsib[isib].isibNext;

	if (isib != -1)
		*psesid = rgsib[isib].sesid;

	return isib;
}


/*=================================================================
AssertValidSesid

Description:
  This routine is used to determine the index into the rgsib array
  of the SIB associated with the supplied SESID.

Parameters:
  sesid			identifies the session uniquely, used to locate SIB
=================================================================*/

#ifndef RETAIL

void AssertValidSesid(JET_SESID sesid)
{
	int isib;

	for (isib = isibHead; isib != -1; isib = rgsib[isib].isibNext)
	{
		if (rgsib[isib].sesid == sesid)
	 return;
	}

	AssertSz(fFalse, "Invalid sesid");
}

#endif	/* !RETAIL */


/*=================================================================
FValidSesid

Description:
  This routine is used to determine the index into the rgsib array
  of the SIB associated with the supplied SESID.

Parameters:
  sesid			identifies the session uniquely, used to locate SIB

Return Value:
  fTrue is sesid id valid.  fFalse if it is unknown.
=================================================================*/

BOOL FValidSesid(JET_SESID sesid)
{
	int isib;

	for (isib = isibHead; isib != -1; isib = rgsib[isib].isibNext)
	{
		if (rgsib[isib].sesid == sesid)
		{
	 		/* Clear extended error info for this session. */

			 rgsib[isib].exterr.err = JET_wrnNoErrorInfo;

			 return(fTrue);
		}
	}

	return(fFalse);
}


/*=================================================================
UtilGetIsibOfSesid

Description:
  This routine is used to determine the index into the rgsib array
  of the SIB associated with the supplied SESID.

Parameters:
  sesid			identifies the session uniquely, used to locate SIB

Return Value:
  -1 if there is no SIB found containing the supplied sesid.
  The index into the rgsib array of the SIB containing the SESID
	 if the SESID is found in one of the SIBs of the array.
=================================================================*/

int UtilGetIsibOfSesid(JET_SESID sesid)
{
	int isib;

	for (isib = isibHead; isib != -1; isib = rgsib[isib].isibNext)
	{
		if (rgsib[isib].sesid == sesid)
			break;
	}

	return(isib);
}


/*=================================================================
UtilGetNameOfSesid

Description:
  This routine is used to get the pointer to the account name from
  the SIB associated with the supplied SESID.

Parameters:
  sesid			identifies the session uniquely, used to locate SIB

Return Value:
  NULL if there is no SIB found containing the supplied sesid.
  Pointer to the account name.
=================================================================*/

void EXPORT UtilGetNameOfSesid(JET_SESID sesid, char __far *szUserName)
{
	int isib;

	for (isib = isibHead; isib != -1; isib = rgsib[isib].isibNext)
	{
		if (rgsib[isib].sesid == sesid)
		{
			strcpy(szUserName, rgsib[isib].pUserName);
			return;
		}
	}
}

/*=================================================================
UtilGetpfnStatusOfSesid

Description:
  This routine is used to get the pointer to the status function from
  the SIB associated with the supplied SESID.

Parameters:
  sesid			identifies the session uniquely, used to locate SIB

Return Value:
  NULL if there is no SIB found containing the supplied sesid.
  Pointer to the status function.
=================================================================*/

void EXPORT UtilGetpfnStatusOfSesid(JET_SESID sesid, JET_PFNSTATUS __far *ppfnStatus)
{
	int isib;

	for (isib = isibHead; isib != -1; isib = rgsib[isib].isibNext)
	{
		if (rgsib[isib].sesid == sesid)
		{
			*ppfnStatus = rgsib[isib].pfnStatus;
			return;
		}
	}

	*ppfnStatus = NULL;
}


/*******************************************************************************
 * CONSIDER: stop using SAlloc() and SFree() to cache extended error strings *
 ******************************************************************************/

/*=================================================================
ClearErrorInfo

Description:
  Clears out the Extended Error info for a session.  A following call
  to GetLastErrorInfo will return an extended error of
  JET_wrnNoErrorInfo.

Parameters:
  sesid			identifies the session uniquely, used to locate SIB
=================================================================*/
void ClearErrorInfo(JET_SESID sesid)
{
	int isib;
	SIB __near *psib;

	/*** Get SIB of SESID (must find it) ***/
	isib = UtilGetIsibOfSesid(sesid);
	Assert(isib != -1);
	psib = rgsib + isib;

	/* Set error to JET_wrnNoErrorInfo to indicate no cached info. */

	rgsib[isib].exterr.err = JET_wrnNoErrorInfo;
}


/*=================================================================
UtilSetErrorInfo

Description:
  Sets extended error info for a session.

Parameters:
  sesid			identifies the session uniquely, used to locate SIB
  sz1			first general purpose string;  may be NULL
  sz2			first general purpose string;  may be NULL
  sz3			remote error string;  may be NULL
  err			extended error code
  ul1			first  general purpose integer
  ul2			second general purpose integer
  ul3			third  general purpose integer

Side Effects/Assumptions:
  Does nothing if there already is some extended info in the SIB.
=================================================================*/

void EXPORT UtilSetErrorInfoReal(JET_SESID sesid, const char __far *sz1,
	const char __far *sz2, const char __far *sz3, ERR err, unsigned long ul1,
	unsigned long ul2, unsigned long ul3)
{
	int	     isib;
	SIB __near   *psib;
	unsigned     cb;

	/*** Get SIB of SESID (must find it) ***/
	isib = UtilGetIsibOfSesid(sesid);
	Assert(isib != -1);
	psib = rgsib + isib;

	/* Only cache info if none already cached for this API. */

	if (psib->exterr.err != JET_wrnNoErrorInfo)
		return;

	/* Release strings from previous error info. */

	if (psib->sz1 != NULL)
		{
		SFree(psib->sz1);
		psib->sz1 = NULL;
		}

	if (psib->sz2 != NULL)
	{
		SFree(psib->sz2);
		psib->sz2 = NULL;
	}

	if (psib->sz3 != NULL)
	{
		SFree(psib->sz3);
		psib->sz3 = NULL;
	}

	/* Cache error info */

	psib->exterr.err = err;
	psib->exterr.ul1 = ul1;
	psib->exterr.ul2 = ul2;
	psib->exterr.ul3 = ul3;

	if (sz1 != NULL)
	{
		cb = CbFromSz(sz1) + 1;
		psib->sz1 = (char *) SAlloc(cb);
		if (psib->sz1 != NULL)
			memcpy(psib->sz1, sz1, cb);
	}

	if (sz2 != NULL)
	{
		cb = CbFromSz(sz2) + 1;
		psib->sz2 = (char *) SAlloc(cb);
		if (psib->sz2 != NULL)
			memcpy(psib->sz2, sz2, cb);
	}

	if (sz3 != NULL)
	{
		cb = CbFromSz(sz3) + 1;
		psib->sz3 = (char *) SAlloc(cb);
		if (psib->sz3 != NULL)
			memcpy(psib->sz3, sz3, cb);
	}
}


#ifndef RETAIL

CODECONST(char) szSessionHdr[] = "Isib Session Id  tl \r\n";
CODECONST(char) szSessionSep[] = "---- ---------- ----\r\n";
CODECONST(char) szSessionFmt[] = "%4u 0x%08lX  %2u\r\n";

void DebugListActiveSessions(void)
{
	int	 isib;

	DebugWriteString(fTrue, szSessionHdr);
	DebugWriteString(fTrue, szSessionSep);

	for (isib = isibHead; isib != -1; isib = rgsib[isib].isibNext)
	{
		DebugWriteString(fTrue, szSessionFmt, isib, rgsib[isib].sesid, rgsib[isib].tl);
	}
}

#endif	/* RETAIL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\src\jstub.c ===
/***********************************************************************
* Microsoft Jet
*
* Microsoft Confidential.  Copyright 1991-1992 Microsoft Corporation.
*
* Component:
*
* File: apirare.c
*
* File Comments:
*
* Revision History:
*
*    [0]  20-Jan-93  ianjo		Created
*
***********************************************************************/

#include "std.h"

#include "version.h"

#include "jetord.h"
#include "_jetstr.h"

#include "isammgr.h"
#include "vdbmgr.h"
#include "vtmgr.h"
#include "isamapi.h"

#include <stdlib.h>
#include <string.h>


JET_ERR JET_API JetSetAccess(
JET_SESID sesid,
JET_DBID dbid,
const char __far *szContainerName,
const char __far *szObjectName,
const char __far *szName,
JET_ACM acm,
JET_GRBIT grbit)
	{
	return JET_errFeatureNotAvailable;
	}


JET_ERR JET_API JetCreateLink(JET_SESID sesid, JET_DBID dbidDest,
	const char __far *szNameDest, JET_DBID dbidSource,
	const char __far *szNameSource, JET_GRBIT grbit)
	{
	return JET_errFeatureNotAvailable;
	}


JET_ERR JET_API JetCreateQuery(JET_SESID sesid, JET_DBID dbid,
	const char __far *szQoName, JET_TABLEID __far *ptableid)
	{
   return JET_errFeatureNotAvailable;
	}


JET_ERR JET_API JetGetQueryParameterInfo(JET_SESID sesid, JET_DBID dbid,
	const char __far *szQuery, void __far *pvResult, unsigned long cbMax,
	unsigned long __far *pcbActual)
	{
   return JET_errFeatureNotAvailable;
	}


JET_ERR JET_API JetSetQoSql(JET_SESID sesid, JET_TABLEID tableid,
	char __far *rgchSql, unsigned long cchSql, const char __far
    *szConnect, JET_GRBIT grbit)
	{
   return JET_errFeatureNotAvailable;
	}


JET_ERR JET_API JetOpenQueryDef(JET_SESID sesid, JET_DBID dbid,
	const char __far *szQoName, JET_TABLEID __far *ptableid)
	{
   return JET_errFeatureNotAvailable;
	}

JET_ERR JET_API JetRetrieveQoSql(JET_SESID sesid, JET_TABLEID tableid,
	char __far *rgchSql, unsigned long cchMax,
	unsigned long __far *pcchActual, void __far *pvConnect,
	unsigned long cbConnectMax, unsigned long __far *pcbConnectActual,
	JET_GRBIT __far *pgrbit)
	{
   return JET_errFeatureNotAvailable;
	}


JET_ERR JET_API JetGetTableReferenceInfo(JET_SESID sesid, JET_TABLEID tableid,
	const char FAR *szReferenceName, void FAR *pvResult,
	unsigned long cbResult, unsigned long InfoLevel)
	{
   return JET_errFeatureNotAvailable;
	}


JET_ERR JET_API JetExecuteSql(JET_SESID sesid, JET_DBID dbid,
	const char FAR *szSql)
	{
   return JET_errFeatureNotAvailable;
	}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\src\util.c ===
/***********************************************************************
* Microsoft Jet
*
* Microsoft Confidential.  Copyright 1991-1992 Microsoft Corporation.
*
* Component:
*
* File: util.c
*
* File Comments:
*
* Revision History:
*
*    [0]  05-Jan-92  richards	Added this header
*
***********************************************************************/

#include "std.h"

#include <string.h>		       /* For memset() */

#ifndef RETAIL
#ifndef DOS
#include <stdarg.h>
#endif	/* !DOS */
#endif	/* !RETAIL */

DeclAssertFile;


static CODECONST(unsigned char) rgbValidName[16] = {
	0xff,			       /* 00-07 No control characters */
	0xff,			       /* 08-0F No control characters */
	0xff,			       /* 10-17 No control characters */
	0xff,			       /* 18-1F No control characters */
	0x02,			       /* 20-27 No ! */
	0x40,			       /* 28-2F No . */
	0x00,			       /* 30-37 */
	0x00,			       /* 38-3F */
	0x00,			       /* 40-47 */
	0x00,			       /* 48-4F */
	0x00,			       /* 50-57 */
	0x28,			       /* 58-5F No [ or ] */
	0x00,			       /* 60-67 */
	0x00,			       /* 68-6F */
	0x00,			       /* 70-77 */
	0x00,			       /* 78-7F */
	};


PUBLIC unsigned EXPORT CchValidateName(char __far *pchName, const char __far *lpchName, unsigned cchName)
{
   char __far	  *pch;
   unsigned	  cch;
   char __far	  *pchLast;
   unsigned char  ch;

   if (*lpchName == ' ')	       /* A name may not begin with a space */
      return(0);

   pch = pchName;
   cch = 0;

   pchLast = pchName;		       /* To detect zero length names */

   while (((ch = (unsigned char) *lpchName++) != '\0') && (cch < cchName))
   {
      /* The name too long check is inside the loop to prevent */
      /* overflowing the output buffer which is only JET_cbNameMost */
      /* characters long.  This means than insignificant trailing */
      /* spaces will trigger an error. */

      if (++cch > JET_cbNameMost)	       /* Name too long */
	 return(0);

#ifndef ANSIAPI
      ch = mpchOemchAnsi[ch];
#endif	/* !ANSIAPI */

      if (ch < 0x80)		       /* Extended characters always valid */
      {
	 if ((rgbValidName[ch >> 3] >> (ch & 0x7)) & 1)
	    return(0);
      }

      *pch++ = (char) ch;

      if (ch != ' ')
	 pchLast = pch; 	       /* Last significant character */
   }

   cch = (unsigned)(pchLast - pchName); /* Length of significant portion */

   return(cch);
}


#ifdef	PARAMFILL

PUBLIC void EXPORT FillClientBuffer(void __far *pv, unsigned long cb)
{
   if ( pv != NULL )
      memset(pv, 0x52, (size_t) cb);
}			

#endif	/* PARAMFILL */


#ifndef RETAIL

#ifndef DOS

typedef void (__far *PFNvprintf)(const char __far *, va_list);

struct {
   PFNvprintf pfnvprintf;
} __near pfn = { NULL };


PUBLIC void VARARG DebugPrintf(const char __far *szFmt, ...)
{
   va_list arg_ptr;

   if (pfn.pfnvprintf == NULL)	       /* No op if no callback registered */
      return;

   va_start(arg_ptr, szFmt);
   (*pfn.pfnvprintf)(szFmt, arg_ptr);
   va_end(arg_ptr);
}


	/* The following pragma affects the code generated by the C */
	/* compiler for all FAR functions.  Do NOT place any non-API */
	/* functions beyond this point in this file. */

void JET_API __export JetDBGSetPrintFn(JET_SESID sesid, PFNvprintf pfnParm)
{
   AssertValidSesid(sesid);

   pfn.pfnvprintf = pfnParm;
}


#endif	/* !DOS */

#endif	/* !RETAIL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\src\jetstr.c ===
/***********************************************************************
* Microsoft Jet
*
* Microsoft Confidential.  Copyright 1991-1992 Microsoft Corporation.
*
* Component:
*
* File: jetstr.c
*
* File Comments:
*
* Revision History:
*
*    [0]  05-Jan-92  richards	Added this header
*
***********************************************************************/

#include "std.h"

/*** Constant Strings (made into static variables to save space) ***/

/*** System object names (non-table) ***/

CODECONST(char) szTcObject[]	= "Tables";
CODECONST(char) szDcObject[]	= "Databases";
CODECONST(char) szDbObject[]	= "MSysDb";

/*** System table names ***/

CODECONST(char) szSoTable[]		= "MSysObjects";
CODECONST(char) szScTable[]		= "MSysColumns";
CODECONST(char) szSiTable[]		= "MSysIndexes";
CODECONST(char) szSqTable[]		= "MSysQueries";

#ifdef SEC
CODECONST(char) szSpTable[]		= "MSysACEs";

CODECONST(char) szSaTable[]		= "MSysAccounts";
CODECONST(char) szSgTable[]		= "MSysGroups";
#endif

/*** System table index names ***/

CODECONST(char) szSoNameIndex[] 	= "ParentIdName";
CODECONST(char) szSoIdIndex[]		= "Id";
CODECONST(char) szScObjectIdNameIndex[] = "ObjectIdName";
CODECONST(char) szSiObjectIdNameIndex[] = "ObjectIdName";

/*** System table Column names ***/

CODECONST(char) szSoIdColumn[]				= "Id";
CODECONST(char) szSoParentIdColumn[]		= "ParentId";
CODECONST(char) szSoObjectNameColumn[]		= "Name";
CODECONST(char) szSoObjectTypeColumn[]		= "Type";
CODECONST(char) szSoDateUpdateColumn[]		= "DateUpdate";
CODECONST(char) szSoDateCreateColumn[]		= "DateCreate";
CODECONST(char) szSoLvColumn[]				= "Lv";
CODECONST(char) szSoDatabaseColumn[]		= "Database";
CODECONST(char) szSoConnectColumn[]			= "Connect";
CODECONST(char) szSoForeignNameColumn[] 	= "ForeignName";
CODECONST(char) szSoFlagsColumn[]			= "Flags";
CODECONST(char) szSoPresentationOrder[]	= "PresentationOrder";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\src\utilw32.c ===
/***********************************************************************
* Microsoft Jet
*
* Microsoft Confidential.  Copyright 1991-1992 Microsoft Corporation.
*
* Component:
*
* File: utilwin.c
*
* File Comments:
*
* Revision History:
*
*    [0]  15-Jan-92  richards	Created
*
***********************************************************************/

#include "std.h"

#ifndef WIN32
#error	WIN32 must be defined for utilw32.c
#endif	/* !WIN32 */

#include <stdarg.h>
#include <stdlib.h>

#define BOOL WINBOOL		       /* Avoid conflict with our BOOL */

#define NOMINMAX
#define NORESOURCE
#define NOATOM
#define NOLANGUAGE
//UNDONE: NT Bug.  Remove after NT Beta 1
//#define NOGDI
#define NOSCROLL
#define NOSHOWWINDOW
#define NOVIRTUALKEYCODES
#define NOWH
#define NOMSG
#define NOWINOFFSETS
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOCLIPBOARD
#define NODEFERWINDOWPOS
#define NOSYSMETRICS
#define NOMENUS
#define NOCOLOR
#define NOSYSCOMMANDS
#define NOICONS
#define NODBCS
#define NOSOUND
#define NODRIVERS
#define NOCOMM
#define NOMDI
#define NOSYSPARAMSINFO
#define NOHELP
#define NOPROFILER
#define STRICT

#undef cdecl
#undef PASCAL
#undef FAR
#undef NEAR
#undef MAKELONG
#undef HIWORD


#include <windows.h>

#include "taskmgr.h"

#undef	BOOL

#undef	LOWORD
#undef	MAKELONG

DeclAssertFile;

#include <stdio.h>
#include <version.h>


INT APIENTRY LibMain(HANDLE hInst, DWORD dwReason, LPVOID lpReserved)
	{
	return(1);
	}


ERR EXPORT ErrSysInit(void)
	{
	return(JET_errSuccess);
	}


char __near szIniPath[cbFilenameMost] = "jet.ini";	/* path to ini file */


unsigned EXPORT UtilGetProfileInt(const char *szSectionName, const char *szKeyName, int iDefault)
	{
	return((unsigned) GetPrivateProfileInt((LPTSTR) szSectionName, (LPTSTR) szKeyName, iDefault, (LPTSTR) szIniPath));
	}


unsigned UtilGetProfileString(const char *szSectionName, const char *szKeyName, const char *szDefault, char *szReturnedString, unsigned cchMax)
	{
	return((unsigned) GetPrivateProfileString((LPTSTR) szSectionName, (LPTSTR) szKeyName, (LPTSTR) szDefault, szReturnedString, cchMax, (LPTSTR) szIniPath));
	}


BOOL FUtilLoadLibrary(const char *pszLibrary, ULONG_PTR *phmod)
	{
	HANDLE hmod;

	hmod = LoadLibrary((LPTSTR) pszLibrary);

	/* restore original error mode
	/**/
	*phmod = (ULONG_PTR) hmod;

	return(hmod != NULL);
	}


void UtilFreeLibrary(ULONG_PTR hmod)
	{
	FreeLibrary((HANDLE) hmod);
	}


PFN PfnUtilGetProcAddress(ULONG_PTR hmod, unsigned ordinal)
	{
	return((PFN) GetProcAddress((HANDLE) hmod, MAKEINTRESOURCE(ordinal)));
	}


CODECONST(char) szReleaseHdr[] = "Rel. ";
CODECONST(char) szFileHdr[] = ", File ";
CODECONST(char) szLineHdr[] = ", Line ";
CODECONST(char) szErrorHdr[] = ", Err. ";
CODECONST(char) szMsgHdr[] = ": ";
CODECONST(char) szPidHdr[] = "PID: ";
CODECONST(char) szTidHdr[] = ", TID: ";
CODECONST(char) szNewLine[] = "\r\n";

CODECONST(char) szEventLogFile[] = "JetEvent.txt";

CODECONST(char) szAssertFile[] = "assert.txt";
CODECONST(char) szAssertHdr[] = "Assertion Failure: ";

CODECONST(char) szAssertCaption[] = "JET Blue Assertion Failure";

int fNoWriteAssertEvent = 0;

char *mpevntypsz[] =
	{
	"Start  ",		/* 0 */
	"Stop   ",		/* 1 */
	"Assert ",		/* 2 */
	"DiskIO ",		/* 3 */
	"Info.. ",		/* 4 */
	"Activated ",	/* 5 */
	"Log Down ",	/* 6 */
	};


void UtilWriteEvent(
	EVNTYP		evntyp,
	const char	*sz,
	const char	*szFilename,
	unsigned	Line )
	{
#ifdef DEBUG
	int			hf;
	char		szT[45];
	char		szMessage[512];
	int			id;
	SYSTEMTIME	systemtime;
	DWORD		dw;
	char		*pch;

	/*	select file name from file path
	/**/
	if ( szFilename != NULL )
		{
		for ( pch = (char *)szFilename; *pch; pch++ )
			{
			if ( *pch == '\\' )
				szFilename = pch + 1;
			}
		}

	/*  get last error if necessary. Must be called before next system
	/*  call is made.
	/**/
	if ( evntyp == evntypAssert || evntyp == evntypDiskIO )
		{
		dw = GetLastError();
		}
	else
		{
		dw = 0;
		}

	GetLocalTime( &systemtime );

	hf = _lopen( (LPSTR) szEventLogFile, OF_READWRITE );

	/*  if open failed, assume no such file and create, then
	/*	seek to end of file
	/**/
	if ( hf == -1 )
		hf = _lcreat( (LPSTR) szEventLogFile, 0 );
	else
		_llseek( hf, 0, 2 );

	sprintf( szMessage, "%s %02d/%02d/%02d %02d:%02d:%02d ",
		mpevntypsz[ evntyp ],
		(int) systemtime.wMonth,
		(int) systemtime.wDay,
		(int) systemtime.wYear,
		(int) systemtime.wHour,
		(int) systemtime.wMinute,
		(int) systemtime.wSecond );
	
	_lwrite( hf, (LPSTR) szMessage, lstrlen( (LPSTR)szMessage ) );

	/*	initialize message string
	/**/
	if ( evntyp == evntypAssert )
		{
		szMessage[0] = '\0';
		lstrcat( szMessage, (LPSTR) szAssertHdr );
		/*	release number
		/**/
		lstrcat( szMessage, (LPSTR) szReleaseHdr );
		_ltoa( rmj, szT, 10 );
		lstrcat( szMessage, (LPSTR) szT );
		lstrcat( szMessage, "." );
		_ltoa( rmm, szT, 10 );
		lstrcat( szMessage, (LPSTR) szT );
		/*	file name
		/**/
		lstrcat( szMessage, (LPSTR) szFileHdr );
		lstrcat( szMessage, (LPSTR) szFilename );
		/*	line number
		/**/
		lstrcat( szMessage, (LPSTR) szLineHdr );
		_ultoa( Line, szT, 10 );
		lstrcat( szMessage, szT );
		/*	error
		/**/
		if ( dw )
			{
			lstrcat( szMessage, szErrorHdr );
			_ltoa( dw, szT, 10 );
			lstrcat( szMessage, szT );
			}
		/*	assertion text
		/**/
		lstrcat( szMessage, szMsgHdr );
		lstrcat( szMessage, sz );
		lstrcat( szMessage, szNewLine );
		}
	else
		{
		szMessage[0] = '\0';
		lstrcat( szMessage, sz );
		/*	error
		/**/
		if ( dw )
			{
			lstrcat( szMessage, szErrorHdr );
			_ltoa( dw, szT, 10 );
			lstrcat( szMessage, szT );
			}
		lstrcat( szMessage, szNewLine );
		}

	_lwrite( hf, (LPSTR) szMessage, lstrlen(szMessage) );
	_lclose( hf );
#endif
	return;
	}


unsigned EXPORT DebugGetTaskId( void )
	{
	return((unsigned) GetCurrentThreadId());
	}


#ifndef RETAIL


#ifdef _X86_


extern char szEventSource[];
extern long lEventId;
extern long lEventCategory;


#if 0
VOID UtilLogEvent( long lEventId, long lEventCategory, char *szMessage )
	{
    char		*rgsz[1];
    HANDLE		hEventSource;

	rgsz[0]	= szMessage;

    hEventSource = RegisterEventSource( NULL, szEventSource );
	if ( !hEventSource )
		return;
		
	ReportEvent(
		hEventSource,
		EVENTLOG_ERROR_TYPE,
		(WORD) lEventCategory,
		(DWORD) lEventId,
		0,
		1,
		0,
		rgsz,
		0 );
	
	DeregisterEventSource( hEventSource );

	return;
    }
#endif


#pragma pack(4)
#include	<lm.h>
#include	<lmalert.h>
#pragma pack()


void UtilRaiseAlert( char *szMsg )
	{
	size_t 				cbBuffer;
	size_t				cbMsg;
	BYTE  				*pbBuffer;
	PADMIN_OTHER_INFO	pAdminOtherInfo;
	WCHAR 				*szMergeString;

	cbMsg = strlen(szMsg) + 1;
	cbBuffer = sizeof(ADMIN_OTHER_INFO) + (sizeof(WCHAR) * cbMsg);

	pbBuffer = SAlloc(cbBuffer);
	if ( !pbBuffer )
	    return;

	pAdminOtherInfo = (PADMIN_OTHER_INFO) pbBuffer;
	szMergeString   = (WCHAR *) (pbBuffer + sizeof(ADMIN_OTHER_INFO));

	/*	convert multi byte string to unicode
	/**/
	if ( !MultiByteToWideChar( 1252, MB_PRECOMPOSED,
			szMsg, -1, szMergeString, cbMsg ) )
		{
		SFree( pbBuffer );
		return;
		}

	pAdminOtherInfo->alrtad_errcode 	=	(DWORD) -1;
	pAdminOtherInfo->alrtad_numstrings	=	1;

	NetAlertRaiseEx(
                L"ADMIN",
		(LPVOID) pbBuffer,
		cbBuffer,
                L"JET Blue" );

	SFree( pbBuffer );
	return;
	}


#else


#define UtilLogEvent( lEventId, lEventCategory, szMessage )		0
#define UtilRaiseAlert( szMsg )									0


#endif


/*	write assert to assert.txt
/*	write event to jetevent.txt
/*	may raise alert
/*	may log to event log
/*	may pop up
/*
/*	condition parameters
/*	assemble monolithic string for assert.txt, jetevent.log,
/*		alert and event log
/*	assemble separated string for pop up
/*	
/**/
void AssertFail( const char *sz, const char *szFilename, unsigned Line )
	{
	int			hf;
	char		szT[45];
	char		szMessage[512];
	int			id;
	char		*pch;
	DWORD	 	dw;

	/*	get last error before another system call
	/**/
	dw = GetLastError();

	/*	select file name from file path
	/**/
	for ( pch = (char *)szFilename; *pch; pch++ )
		{
		if ( *pch == '\\' )
			szFilename = pch + 1;
		}

	/*	assemble monolithic assert string
	/**/
	szMessage[0] = '\0';
	lstrcat( szMessage, (LPSTR) szAssertHdr );
	lstrcat( szMessage, (LPSTR) szReleaseHdr );
	/*	copy version number to message
	/**/
	_ltoa( rmj, szT, 10 );
	lstrcat( szMessage, (LPSTR) szT );
	lstrcat( szMessage, "." );
	_ltoa( rmm, szT, 10 );
	lstrcat( szMessage, (LPSTR) szT );
	/*	file name
	/**/
	lstrcat( szMessage, (LPSTR) szFileHdr );
	lstrcat( szMessage, (LPSTR) szFilename );
	/*	convert line number to ASCII
	/**/
	lstrcat( szMessage, (LPSTR) szLineHdr );
	_ultoa( Line, szT, 10 );
	lstrcat( szMessage, szT );
	lstrcat( szMessage, (LPSTR) szMsgHdr );
	lstrcat( szMessage, (LPSTR)sz );
	lstrcat( szMessage, szNewLine );

	/******************************************************
	/*	write assert to assert.txt
	/**/
	hf = _lopen( (LPSTR) szAssertFile, OF_READWRITE );
	/*	if open failed, assume no such file and create, then
	/*	seek to end of file.
	/**/
	if ( hf == -1 )
		hf = _lcreat( (LPSTR)szAssertFile, 0 );
	else
		_llseek( hf, 0, 2 );
	_lwrite( hf, (LPSTR)szMessage, lstrlen(szMessage) );
	_lclose( hf );
	/******************************************************
	/**/

	/*	if event log environment variable set then write
	/*	assertion to event log.
	/**/
	if ( !fNoWriteAssertEvent )
		{
		UtilWriteEvent( evntypAssert, sz, szFilename, Line );
		}

#if 0
#ifdef _X86_
	if ( *szEventSource )
		{
		UtilLogEvent( lEventId, lEventCategory, szMessage );
		}
#endif
#endif

	if ( wAssertAction == JET_AssertExit )
		{
		FatalExit( 0x68636952 );
		}
	else if ( wAssertAction == JET_AssertBreak )
		{
		DebugBreak();
		}
	else if ( wAssertAction == JET_AssertStop )
		{
		UtilRaiseAlert( szMessage );
		for( ;; )
			{
			/*	wait for developer, or anyone else, to debug the failure
			/**/
			Sleep( 100 );
			}
		}
	else if ( wAssertAction == JET_AssertMsgBox )
		{
		int	pid = GetCurrentProcessId();
		int	tid = GetCurrentThreadId();

		/*	assemble monolithic assert string
		/**/
		szMessage[0] = '\0';
		/*	copy version number to message
		/**/
		lstrcat( szMessage, (LPSTR) szReleaseHdr );
		_ltoa( rmj, szT, 10 );
		lstrcat( szMessage, (LPSTR) szT );
		lstrcat( szMessage, "." );
		_ltoa( rmm, szT, 10 );
		lstrcat( szMessage, (LPSTR) szT );
		/*	file name
		/**/
		lstrcat( szMessage, (LPSTR) szFileHdr );
		lstrcat( szMessage, (LPSTR) szFilename );
		/*	line number
		/**/
		lstrcat( szMessage, (LPSTR) szLineHdr );
		_ultoa( Line, szT, 10 );
		lstrcat( szMessage, szT );
		/*	error
		/**/
		if ( dw )
			{
			lstrcat( szMessage, szErrorHdr );
			_ltoa( dw, szT, 10 );
			lstrcat( szMessage, szT );
			}
		lstrcat( szMessage, (LPSTR) szNewLine );
		/*	assert txt
		/**/
		lstrcat( szMessage, (LPSTR) sz );
		lstrcat( szMessage, (LPSTR) szNewLine );

		/*	process and thread id
		/**/
		lstrcat( szMessage, szPidHdr );
		_ultoa( pid, szT, 10 );
		lstrcat( szMessage, szT );
		lstrcat( szMessage, szTidHdr );
		_ultoa( tid, szT, 10 );
		lstrcat( szMessage, szT );

		id = MessageBox( NULL, (LPTSTR) szMessage, (LPTSTR) szAssertCaption, MB_SERVICE_NOTIFICATION | MB_SYSTEMMODAL | MB_ICONSTOP | MB_OKCANCEL );
		if ( id == IDCANCEL )
			DebugBreak();
		}

	return;
	}


CODECONST(char) szFmtHeader[] = "JET(%08X): ";


void VARARG DebugWriteString(BOOL fHeader, const char __far *szFormat, ...)
	{
	va_list		val;
	char		szOutput[1024];
	int			cch;

	unsigned wTaskId;

	wTaskId = DebugGetTaskId();

	/*	prefix message with JET and process id
	/**/
	if ( fHeader )
		wsprintf(szOutput, (LPSTR) szFmtHeader, wTaskId);
	else
		cch = 0;

	va_start(val, szFormat);
	wvsprintf(szOutput+cch, (LPSTR) szFormat, val);
	OutputDebugString((LPTSTR) szOutput);
	va_end(val);
	}

#endif	/* !RETAIL */


#if 0
#ifdef	DEBUG

typedef struct
	{
	int			cBlocked;
	unsigned 	tidOwner;
	char 	 	*szSemName;
	char	 	*szFile;
	int			iLine;
	} SEMAPHORE;


ERR ErrUtilSemCreate( void **ppv, const char *szSem )
	{
	*ppv = SAlloc(sizeof(SEMAPHORE));
	if ( *ppv == NULL )
		return JET_errOutOfMemory;
	((SEMAPHORE *)(*ppv))->cBlocked = 0;
	((SEMAPHORE *)(*ppv))->tidOwner = 0;
	return JET_errSuccess;
	}


void UtilSemRequest( void *pv )
	{
	unsigned tidOwner = DebugGetTaskId();
		
	Assert(tidOwner != ((SEMAPHORE *) pv)->tidOwner);
	Assert(tidOwner != 0);

	while (++((SEMAPHORE *) pv)->cBlocked > 1)
		{
		((SEMAPHORE *) pv)->cBlocked--;
		Sleep(0);
		}

	((SEMAPHORE *) pv)->tidOwner = tidOwner;
	}


void UtilSemRelease( void *pv )
	{
	Assert(DebugGetTaskId() == ((SEMAPHORE *) pv)->tidOwner);
	((SEMAPHORE *) pv)->tidOwner = 0;
	((SEMAPHORE *) pv)->cBlocked--;
	}

#undef UtilAssertSEM
void UtilAssertSEM( void *pv )
	{
	Assert(DebugGetTaskId() == ((SEMAPHORE *) pv)->tidOwner);
	Assert(((SEMAPHORE *) pv)->cBlocked > 0);
	}

#else

typedef struct
	{
	LONG		cBlocked;
	HANDLE		handle;
	} SEMAPHORE;


ERR ErrUtilSemCreate( void **ppv, const char *szSem )
	{
	*ppv = SAlloc(sizeof(SEMAPHORE));
	if ( *ppv == NULL )
		return JET_errOutOfMemory;
	((SEMAPHORE *)(*ppv))->cBlocked = -1;
	((SEMAPHORE *)(*ppv))->handle = CreateMutex( NULL, 0, NULL );
	(VOID)WaitForSingleObject( ((SEMAPHORE *) pv)->handle, 0xFFFFFFFF );
	return JET_errSuccess;
	}


void UtilSemRequest( void *pv )
	{
	if ( InterlockedIncrement( &((SEMAPHORE *) pv)->cBlocked )
		{
		(VOID)WaitForSingleObject( ((SEMAPHORE *) pv)->handle, 0xFFFFFFFF );
		}
	}


void UtilSemRelease( void *pv )
	{
	if ( InterlockedDecremnt( &((SEMAPHORE *) pv)->cBlocked ) >= 0 )
		{
		(VOID)ReleaseMutex( ((SEMAPHORE *) pv)->handle );
		}
	}

#endif	/* DEBUG */
#endif


ERR ErrUtilSignalCreate( void **ppv, const char *szSig )
	{
	*((HANDLE *) ppv) = CreateEvent(NULL, fTrue, fFalse, NULL );
	if ( *ppv == NULL )
		return JET_errOutOfMemory;
	return JET_errSuccess;
	}


ERR ErrUtilSignalCreateAutoReset( void **ppv, const char *szSig )
	{
	*((HANDLE *) ppv) = CreateEvent(NULL, fFalse, fFalse, NULL );
	if ( *ppv == NULL )
		return JET_errOutOfMemory;
	return JET_errSuccess;
	}


void UtilSignalReset( void *pv )
	{
	BOOL	rc;

	rc = ResetEvent( (HANDLE) pv );
	Assert( rc != FALSE );
	}


void UtilSignalSend( void *pv )
	{
	BOOL	rc;

	rc = SetEvent( (HANDLE) pv );
	Assert( rc != FALSE );
	}


void UtilSignalWait( void *pv, long lTimeOut )
	{
	DWORD	rc;

	if ( lTimeOut < 0 )
		lTimeOut = 0xFFFFFFFF;
	rc = WaitForSingleObject( (HANDLE) pv, lTimeOut );
	}


void UtilSignalWaitEx( void *pv, long lTimeOut, BOOL fAlertable )
	{
	DWORD	rc;

	if ( lTimeOut < 0 )
		lTimeOut = 0xFFFFFFFF;
	rc = WaitForSingleObjectEx( (HANDLE) pv, lTimeOut, fAlertable );
	}


void UtilMultipleSignalWait( int csig, void *pv, BOOL fWaitAll, long lTimeOut )
	{
	DWORD	rc;

	if ( lTimeOut < 0 )
		lTimeOut = 0xFFFFFFFF;
	rc = WaitForMultipleObjects( csig, (HANDLE*) pv, fWaitAll, lTimeOut );
	}


//#ifdef SPIN_LOCK
#if 0

/****************** DO NOT CHANGE BETWEEN THESE LINES **********************/
/******************** copied from \dae\inc\spinlock.h **********************/

#ifdef DEBUG
void	free_spinlock(long volatile *);
#else
#define	free_spinlock(a)    *((long*)a) = 0 ;
#endif

int get_spinlockfn(long volatile *plLock, int fNoWait);

/*
** When /Ogb1 or /Ogb2 flag is used in the compiler, this function will
** be expanded in line
*/
__inline    int     get_spinlock(long volatile *plock, int b)
{
#ifdef _X86_
	_asm	// Use bit test and set instruction
	{
	    mov eax, plock
	    lock bts [eax], 0x0
	    jc	bsy	// If already set go to busy, otherwise return TRUE
	} ;

#else
	if (InterlockedExchange(plock, 1) == 0)
#endif
	{
		return(fTrue);
	}
bsy:
		return(get_spinlockfn(plock, b));
}

/******************** copied from \dae\src\spinlock.c **********************/

/*
**  get_spinlock(&addr, nowait) -- Obtains an SMP safe lock on the address
**	given. The contents of the address must be initialized to -1.
**	The address must be a dword boundary otherwise Interlocked
**	functions are not SMP safe.
**	nowait parameter specifies if it should wait and retry or return
**	WARNING: Does not release any semaphore or critsec when waiting.
**
**	WARNING: Spinlocks are not reentrant
**
**  Created 04/20/93 by LaleD
*/

/* function copied from SQL server */
#define lSpinCtr 30

int get_spinlockfn(long volatile *plLock, int fNoWait)
{
    int i,n=0;
    int m = 0;
	int cms = 1;

#ifdef DEBUG
    if ((int)(plLock) & 0x3)
	AssertSz(0, "\nError: get_spinlock:Spinlock address isn't aligned\n");
#endif


startover:

#ifdef _X86_
	_asm	// Use bit test and set instruction
	{
	    mov eax, plLock
	    lock bts [eax], 0x0
	    jc	busy	// If already set go to busy, otherwise return TRUE
	} ;

#else
	if (InterlockedExchange(plLock, 1) == 0)
#endif

	{
	    return (fTrue);
	}
busy:
	if (fNoWait)
	    return(fFalse);

	/* Spin in place for a while and then try again */
	for (i = 0 ; i < lSpinCtr ; i++,n++)
	{
	    if (*plLock == 0)
		goto startover;
	}

	/* We tried spinning SPINCTR times, it was busy each time.
	** Need to yield here
	*/

	/* The number below (used to compare m) should be the
	 * max number of threads with critical priority.
	 */
	if (m++ > 10)
	{
		if (cms < 10000)
			cms <<= 1;
#if 0
		else
			/* Sleep for 10 sec's at a time. We may be stuck in an uncleared
			** spinlock. Better to sleep than hog the cpu, and also flag
			** the condition.
			*/
			AssertSz(0, "\nget_spinlock stuck in loop.");
#endif

	    // NOTE: Something is very wrong if you got here. Most likely
	    // somebody forgot to release the spinlock. Put your customized
	    // backout/ error out code here.

		m = 0;
	    Sleep(cms - 1);

	}
	else
	    /* We sleep with a 0 time which is equivalent to a yield*/
	    Sleep(cms - 1);

	goto startover;
	/* try again */

}

/* This function becomes a simple mov instruction in the
** nondebug case (defined inside ksrc_dcl.h)
*/

/*
**  free_spinlock((long *)plock) -- Releases the spinlock, wakes up anybody
**	waiting on it.
**
**  WARNING: This is implemented as a macro defined in ksrc_dcl.h
*/
#ifdef DEBUG

void	free_spinlock(long volatile *plLock)
{

#ifdef _X86_
	// This part of the code will only be used if we want to debug
	// something and turn free_spinlock back to a function to put a
	// breakpoint
	_asm	// Use bit test and set instruction
	{
	    mov eax, plLock
	    lock btr [eax], 0x0
	    jc	wasset	// If was set go to end, otherwise print error
	}
	AssertSz(0, "\nfree_spinlock: spinlock wasn't taken\n");
wasset:
	 ;
#else
	if(InterlockedExchange(plLock, 0) != 1)
	{
	    AssertSz(0, "\nfree_spinlock counter 0x%x\n", (*plLock));
	    *plLock = 0;
	}
#endif

}

#endif

/***************************** end of copy *********************************/
/****************** DO NOT CHANGE BETWEEN THESE LINES **********************/


typedef struct
	{
#ifdef DEBUG
	volatile	unsigned int	cHold;
#endif
	volatile	long			l;
	volatile	unsigned int	tidOwner; /* used by both nestable CS & dbg */
	volatile	int				cNested;
	} CRITICALSECTION;


#ifdef DEBUG
CRITICALSECTION csNestable = { 0, 0, 0, 0, };
#else
CRITICALSECTION csNestable = { 0, 0, 0 };
#endif


ERR ErrUtilInitializeCriticalSection( void __far * __far *ppv )
	{
	*ppv = SAlloc(sizeof(CRITICALSECTION));
	if ( *ppv == NULL )
		return JET_errOutOfMemory;
#ifdef DEBUG
	((CRITICALSECTION *)*ppv)->cHold = 0;
#endif
	((CRITICALSECTION *)*ppv)->tidOwner = 0;
	((CRITICALSECTION *)*ppv)->cNested = 0;
	((CRITICALSECTION *)*ppv)->l = 0;
	return JET_errSuccess;
	}


void UtilDeleteCriticalSection( void __far * pv )
	{
	CRITICALSECTION *pcs = pv;
	
	Assert( pcs != NULL );
	Assert( pcs->cHold == 0);
	SFree(pcs);
	}


void UtilEnterCriticalSection(void __far *pv)
	{
	CRITICALSECTION *pcs = pv;
	
	(void) get_spinlock( &pcs->l, fFalse );
#ifdef DEBUG
	pcs->tidOwner = GetCurrentThreadId();
	pcs->cNested++;
#endif
	}


void UtilLeaveCriticalSection(void __far *pv)
	{
	CRITICALSECTION *pcs = pv;

#ifdef DEBUG
	Assert( pcs->cHold == 0 );
	if ( --pcs->cNested == 0 )
		pcs->tidOwner = 0;
#endif
	free_spinlock( &pcs->l );
	}


#ifdef DEBUG
PUBLIC void UtilHoldCriticalSection(void __far *pv)
	{
	CRITICALSECTION *pcs = pv;

	pcs->cHold++;
	Assert( pcs->cHold );
	return;
	}


PUBLIC void UtilReleaseCriticalSection(void __far *pv)
	{
	CRITICALSECTION *pcs = pv;

	Assert( pcs->cHold );
	pcs->cHold--;
	return;
	}

			
#undef UtilAssertCrit
PUBLIC void UtilAssertCrit(void __far *pv)
	{
	CRITICALSECTION *pcs = pv;

	Assert( pcs->l != 0 );
	Assert( pcs->tidOwner == GetCurrentThreadId() );
	Assert( pcs->cNested > 0 );
	return;
	}
#endif


void UtilEnterNestableCriticalSection(void __far *pv)
	{
	BOOL				fCallerOwnIt = fFalse;
	CRITICALSECTION		*pcs = pv;
	unsigned int		tid = GetCurrentThreadId();
	
	UtilEnterCriticalSection( &csNestable );
	/* must check cs contents within csNestable protection
	/**/
	if (pcs->cNested > 0 && pcs->tidOwner == tid)
		{
		fCallerOwnIt = fTrue;
		pcs->cNested++;
		}
	UtilLeaveCriticalSection( &csNestable );
	
	if (fCallerOwnIt)
		return;
	
	(void) get_spinlock( &pcs->l, fFalse );
	pcs->tidOwner = GetCurrentThreadId();
	pcs->cNested++;
	}


void UtilLeaveNestableCriticalSection(void __far *pv)
	{
	CRITICALSECTION *pcs = pv;

	if ( --pcs->cNested == 0 )
		{
		pcs->tidOwner = 0;
		free_spinlock( &pcs->l );
		}
	else
		{
		Assert( pcs->cNested > 0 );
		return;
		}
	}

#else


typedef struct
	{
#ifdef DEBUG
	volatile	unsigned int				tidOwner;
	volatile	int							cNested;
	volatile	unsigned int				cHold;
#endif
	volatile	RTL_CRITICAL_SECTION		rcs;
	} CRITICALSECTION;

ERR ErrUtilInitializeCriticalSection( void __far * __far *ppv )
	{
	*ppv = SAlloc(sizeof(CRITICALSECTION));
	if ( *ppv == NULL )
		return JET_errOutOfMemory;
#ifdef DEBUG
	((CRITICALSECTION *)*ppv)->tidOwner = 0;
	((CRITICALSECTION *)*ppv)->cNested = 0;
	((CRITICALSECTION *)*ppv)->cHold = 0;
#endif
	InitializeCriticalSection( (LPCRITICAL_SECTION)&((CRITICALSECTION *)(*ppv))->rcs );
	return JET_errSuccess;
	}


void UtilDeleteCriticalSection( void __far * pv )
	{
	CRITICALSECTION *pcs = pv;
	
	Assert( pcs->cHold == 0 );
	Assert( pcs != NULL );
	DeleteCriticalSection( (LPCRITICAL_SECTION)&pcs->rcs );
	SFree(pv);
	}


void UtilEnterCriticalSection(void __far *pv)
	{
	CRITICALSECTION *pcs = pv;
	
	EnterCriticalSection( (LPCRITICAL_SECTION)&pcs->rcs);
#ifdef DEBUG
	pcs->tidOwner = GetCurrentThreadId();
	pcs->cNested++;
#endif
	}


void UtilLeaveCriticalSection(void __far *pv)
	{
	CRITICALSECTION *pcs = pv;

#ifdef DEBUG
	Assert( pcs->cHold == 0);
	if ( --pcs->cNested == 0 )
		pcs->tidOwner = 0;
#endif
	LeaveCriticalSection((LPCRITICAL_SECTION)&pcs->rcs);
	}


#ifdef DEBUG
void UtilHoldCriticalSection(void __far *pv)
	{
	CRITICALSECTION *pcs = pv;

	pcs->cHold++;
	Assert( pcs->cHold );
	return;
	}


void UtilReleaseCriticalSection(void __far *pv)
	{
	CRITICALSECTION *pcs = pv;

	Assert( pcs->cHold );
	pcs->cHold--;
	return;
	}

			
#undef UtilAssertCrit
PUBLIC void UtilAssertCrit(void __far *pv)
	{
	CRITICALSECTION *pcs = pv;

	Assert( pcs->tidOwner == GetCurrentThreadId() );
	Assert( pcs->cNested > 0 );
	return;
	}
#endif

#endif /* SPIN_LOCK */


void UtilCloseSignal(void *pv)
	{
	HANDLE h = pv;
	CloseHandle(h);
	}


ERR ErrUtilDeleteFile( char __far *szFile )
	{
	if ( DeleteFile( szFile ) )
		return JET_errSuccess;
	else
		return JET_errFileNotFound;
	}


//-----------------------------------------------------------------------------
//
// SysGetDateTime
// ============================================================================
//
//	VOID SysGetDateTime
//
//	Gets date time in date serial format.
//		ie, the double returned contains:
//			Integer part: days since 12/30/1899.
//			Fraction part: fraction of a day.		
//
//-----------------------------------------------------------------------------
VOID UtilGetDateTime2( _JET_DATETIME *pdate )
	{
	SYSTEMTIME 		systemtime;
	
	GetLocalTime( &systemtime );

	pdate->month = systemtime.wMonth;
	pdate->day = systemtime.wDay;
	pdate->year = systemtime.wYear;
	pdate->hour = systemtime.wHour;
	pdate->minute	= systemtime.wMinute;
	pdate->second	= systemtime.wSecond;
	}
	
VOID UtilGetDateTime( JET_DATESERIAL *pdt )
	{
	VOID			*pv = (VOID *)pdt;
	_JET_DATETIME	date;
	unsigned long	rgulDaysInMonth[] =
		{ 31,29,31,30,31,30,31,31,30,31,30,31,
			31,28,31,30,31,30,31,31,30,31,30,31,
			31,28,31,30,31,30,31,31,30,31,30,31,
			31,28,31,30,31,30,31,31,30,31,30,31	};

	unsigned	long	ulDay;
	unsigned	long	ulMonth;
	unsigned	long	iulMonth;
	unsigned	long	ulTime;

	static const unsigned long hr  = 0x0AAAAAAA;	// hours to fraction of day
	static const unsigned long min = 0x002D82D8;	// minutes to fraction of day
	static const unsigned long sec = 0x0000C22E;	// seconds to fraction of day

	UtilGetDateTime2( &date );

	ulDay = ( ( date.year - 1900 ) / 4 ) * ( 366 + 365 + 365 + 365 );
	ulMonth = ( ( ( date.year - 1900 ) % 4 ) * 12 ) + date.month;

	/*	walk months adding number of days.
	/**/
	for ( iulMonth = 0; iulMonth < ulMonth - 1; iulMonth++ )
		{
		ulDay += rgulDaysInMonth[iulMonth];
		}

	/*	add number of days in this month.
	/**/
	ulDay += date.day;

	/*	add one day if before March 1st, 1900
	/**/
	if ( ulDay < 61 )
		ulDay++;

	ulTime = date.hour * hr + date.minute * min + date.second * sec;

	// Now lDays and ulTime will be converted into a double (JET_DATESERIAL):
	//	Integer part: days since 12/30/1899.
	//	Fraction part: fraction of a day.		

	// The following code is machine and floating point format specific.
	// It is set up for 80x86 machines using IEEE double precision.
	((long *)pv)[0] = ulTime << 5;
	((long *)pv)[1] = 0x40E00000 | ( (LONG) (ulDay & 0x7FFF) << 5) | (ulTime >> 27);
	}


ULONG UlUtilGetTickCount( VOID )
	{
	return GetTickCount();
	}


ERR ErrUtilCreateThread( unsigned (*pufn)(), unsigned cbStackSize, int iThreadPriority, HANDLE *phandle )
	{
	HANDLE		handle;
	unsigned		tid;

	handle = (HANDLE) CreateThread( NULL,
		cbStackSize,
		(LPTHREAD_START_ROUTINE) pufn,
		NULL,
		(DWORD) 0,
		(LPDWORD) &tid );
	if ( handle == 0 )
		return JET_errNoMoreThreads;

	SetThreadPriority( handle, iThreadPriority );

	/*	return handle to thread.
	/**/
	*phandle = handle;
	return JET_errSuccess;
	}


VOID UtilExitThread( unsigned uExitCode )
	{
	ExitThread( uExitCode );
	return;
	}


BOOL FUtilExitThread( HANDLE handle )
	{
	BOOL		f;
	DWORD		dwExitCode;

	f = GetExitCodeThread( handle, &dwExitCode );
	Assert( f );

	return !(dwExitCode == STILL_ACTIVE);
	}


VOID UtilSleep( unsigned cmsec )
	{
	Sleep( cmsec );
	return;
	}


	/*  RFS Utility functions  */


#ifdef DEBUG
#ifdef RFS2

#include <stdio.h>

	/*
		RFS allocator:  returns 0 if allocation is disallowed.  Also handles RFS logging.
	    	cRFSAlloc is the global allocation counter.  A value of -1 disables RFS in debug mode.
	*/

int UtilRFSAlloc(const char __far *szType)
{
	char szVal[16];

		/*  Breaking here on RFS failure allows easy change to RFS success during debugging  */
	
	if (fLogDebugBreak && cRFSAlloc == 0)
		SysDebugBreak();
		
	if (cRFSAlloc == -1 || fDisableRFS)
		return UtilRFSLog(szType,1);
	if (cRFSAlloc == 0)
		return UtilRFSLog(szType,0);

		/*  if we have allocs left, decrement field in ini file and log allocation  */

	sprintf(szVal,"%ld",--cRFSAlloc);
	WritePrivateProfileString("Debug","RFSAllocations",(LPTSTR)szVal,(LPTSTR)szIniPath);
	return UtilRFSLog(szType,1);
}

	/*
		RFS logging (log on success/failure).  If fPermitted == 0, access was denied.  Returns fPermitted.
		Turns on JET call logging if fPermitted == 0
	*/

CODECONST(char) szNAFile[] = "N/A";

int UtilRFSLog(const char __far *szType,int fPermitted)
{
	char szT[256];

	if (!fPermitted)
		fLogJETCall = 1;
	
	if (!fLogRFS)
		return fPermitted;
		
	sprintf(szT,"RFS %.128s allocation is %s.", szType,(fPermitted ? "permitted" : "denied"));
	UtilWriteEvent(evntypInfo,szT,szNAFile,0);
	
	return fPermitted;
}

	/*  JET call logging (log on failure)
	/*  Logging will start even if disabled when RFS denies an allocation
	/**/

void UtilRFSLogJETCall(const char __far *szFunc,ERR err,const char __far *szFile,unsigned Line)
{
	char szT[256];
	
	if (err >= 0 || !fLogJETCall)
		return;

	sprintf(szT,"JET call %.128s returned error %d.  %.256s(%d)",szFunc,err,szFile,Line);
	UtilWriteEvent(evntypInfo,szT,szFile,Line);
}

	/*  JET inline error logging (logging controlled by JET call flags)  */

void UtilRFSLogJETErr(ERR err,const char __far *szLabel,const char __far *szFile,unsigned Line)
{
	char szT[256];

	if (!fLogJETCall)
		return;
	
	sprintf(szT,"JET inline error %d jumps to label %.128s.  %.256s(%d)",err,szLabel,szFile,Line);
	UtilWriteEvent(evntypInfo,szT,szFile,Line);
}

#endif  /*  RFS2  */
#endif  /*  DEBUG  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\src\vdbdispc.c ===
/***********************************************************************
* Microsoft Jet
*
* Microsoft Confidential.  Copyright 1991-1992 Microsoft Corporation.
*
* Component:
*
* File: vdbdispc.c
*
* File Comments:
*
* Revision History:
*
*    [0]  24-Jan-92  richards	Created
*
***********************************************************************/

#include "std.h"

#include "vdbmgr.h"
#include "_vdbmgr.h"

#if	defined(FLAT) || !defined(RETAIL)

DeclAssertFile;


extern VDBFNCapability		ErrInvalidDbidCapability;
extern VDBFNCloseDatabase	ErrInvalidDbidCloseDatabase;
extern VDBFNCreateObject	ErrInvalidDbidCreateObject;
extern VDBFNCreateTable 	ErrInvalidDbidCreateTable;
extern VDBFNDeleteObject	ErrInvalidDbidDeleteObject;
extern VDBFNDeleteTable 	ErrInvalidDbidDeleteTable;
extern VDBFNExecuteSql		ErrInvalidDbidExecuteSql;
extern VDBFNGetColumnInfo	ErrInvalidDbidGetColumnInfo;
extern VDBFNGetDatabaseInfo	ErrInvalidDbidGetDatabaseInfo;
extern VDBFNGetIndexInfo	ErrInvalidDbidGetIndexInfo;
extern VDBFNGetObjectInfo	ErrInvalidDbidGetObjectInfo;
extern VDBFNGetReferenceInfo	ErrInvalidDbidGetReferenceInfo;
extern VDBFNOpenTable		ErrInvalidDbidOpenTable;
extern VDBFNRenameObject	ErrInvalidDbidRenameObject;
extern VDBFNRenameTable 	ErrInvalidDbidRenameTable;
extern VDBFNGetObjidFromName	ErrInvalidDbidGetObjidFromName;
extern VDBFNDeleteTable 	ErrInvalidDbidDeleteTable;


#ifndef RETAIL
CODECONST(VDBDBGDEF) vdbdbgdefInvalidDbid =
	{
	sizeof(VDBDBGDEF),
	0,
	"Invalid Dbid",
	0,
	{
		0,
		0,
		0,
		0,
	},
	};
#endif	/* !RETAIL */


CODECONST(VDBFNDEF) EXPORT vdbfndefInvalidDbid =
	{
	sizeof(VDBFNDEF),
	0,
#ifdef	RETAIL
	NULL,
#else	/* !RETAIL */
	&vdbdbgdefInvalidDbid,
#endif	/* !RETAIL */
	ErrInvalidDbidCapability,
	ErrInvalidDbidCloseDatabase,
	ErrInvalidDbidCreateObject,
	ErrInvalidDbidCreateTable,
	ErrInvalidDbidDeleteObject,
	ErrInvalidDbidDeleteTable,
	ErrInvalidDbidExecuteSql,
	ErrInvalidDbidGetColumnInfo,
	ErrInvalidDbidGetDatabaseInfo,
	ErrInvalidDbidGetIndexInfo,
	ErrInvalidDbidGetObjectInfo,
	ErrInvalidDbidGetReferenceInfo,
	ErrInvalidDbidOpenTable,
	ErrInvalidDbidRenameObject,
	ErrInvalidDbidRenameTable,
	ErrInvalidDbidGetObjidFromName,
	};


ERR VDBAPI ErrDispCapability(JET_SESID sesid, JET_DBID dbid,
	unsigned long lArea, unsigned long lFunction, JET_GRBIT __far *pgrbit)
{
   JET_VSESID  vsesid;
   JET_VDBID   vdbid;
   ERR	       err;

   FillClientBuffer(pgrbit, sizeof(JET_GRBIT));

   if (dbid >= dbidMax)
      return(JET_errInvalidDatabaseId);

   vsesid = (JET_VSESID) mpdbidvsesid[dbid];

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vdbid = mpdbiddbid[dbid];

   err = (*mpdbidpvdbfndef[dbid]->pfnCapability)(vsesid, vdbid,
	   lArea,  lFunction, pgrbit);

   return(err);
}


ERR VDBAPI ErrDispCloseDatabase(JET_SESID sesid, JET_DBID dbid,
	JET_GRBIT grbit)
{
   JET_VSESID  vsesid;
   JET_VDBID   vdbid;
   ERR	       err;

   if (dbid >= dbidMax)
      return(JET_errInvalidDatabaseId);

   vsesid = (JET_VSESID) mpdbidvsesid[dbid];

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vdbid = mpdbiddbid[dbid];

   err = (*mpdbidpvdbfndef[dbid]->pfnCloseDatabase)(vsesid, vdbid, grbit);

   return(err);
}


ERR VDBAPI ErrDispCreateObject(JET_SESID sesid, JET_DBID dbid,
	OBJID objidParentId, const char __far *szObjectName,
	JET_OBJTYP objtyp)
{
   JET_VSESID  vsesid;
   JET_VDBID   vdbid;
   ERR	       err;

   if (dbid >= dbidMax)
      return(JET_errInvalidDatabaseId);

   vsesid = (JET_VSESID) mpdbidvsesid[dbid];

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vdbid = mpdbiddbid[dbid];

   err = (*mpdbidpvdbfndef[dbid]->pfnCreateObject)(vsesid, vdbid,
	 objidParentId, szObjectName, objtyp);

   return(err);
}


ERR VDBAPI ErrDispCreateTable(JET_SESID sesid, JET_DBID dbid,
	const char __far *szTableName, unsigned long lPages,
	unsigned long lDensity, JET_TABLEID __far *ptableid)
{
   JET_VSESID  vsesid;
   JET_VDBID   vdbid;
   ERR	       err;

   if (dbid >= dbidMax)
      return(JET_errInvalidDatabaseId);

   vsesid = (JET_VSESID) mpdbidvsesid[dbid];

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vdbid = mpdbiddbid[dbid];

   err = (*mpdbidpvdbfndef[dbid]->pfnCreateTable)(vsesid, vdbid,
	szTableName, lPages, lDensity, ptableid);

   return(err);
}


ERR VDBAPI ErrDispDeleteObject(JET_SESID sesid, JET_DBID dbid,
	OBJID objid)
{
   JET_VSESID  vsesid;
   JET_VDBID   vdbid;
   ERR	       err;

   if (dbid >= dbidMax)
      return(JET_errInvalidDatabaseId);

   vsesid = (JET_VSESID) mpdbidvsesid[dbid];

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vdbid = mpdbiddbid[dbid];

   err = (*mpdbidpvdbfndef[dbid]->pfnDeleteObject)(vsesid, vdbid,
	 objid);

   return(err);
}


ERR VDBAPI ErrDispRenameObject(JET_SESID sesid, JET_DBID dbid,
	const char __far *szContainerName, const char __far *szObjectName,
	const char __far *szObjectNew)
{
   JET_VSESID  vsesid;
   JET_VDBID   vdbid;
   ERR	       err;

   if (dbid >= dbidMax)
      return(JET_errInvalidDatabaseId);

   vsesid = (JET_VSESID) mpdbidvsesid[dbid];

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vdbid = mpdbiddbid[dbid];

   err = (*mpdbidpvdbfndef[dbid]->pfnRenameObject)(vsesid, vdbid,
	 szContainerName, szObjectName, szObjectNew);

   return(err);
}


ERR VDBAPI ErrDispDeleteTable(JET_SESID sesid, JET_DBID dbid,
	const char __far *szTableName)
{
   JET_VSESID  vsesid;
   JET_VDBID   vdbid;
   ERR	       err;

   if (dbid >= dbidMax)
      return(JET_errInvalidDatabaseId);

   vsesid = (JET_VSESID) mpdbidvsesid[dbid];

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vdbid = mpdbiddbid[dbid];

   err = (*mpdbidpvdbfndef[dbid]->pfnDeleteTable)(vsesid, vdbid,
	szTableName);

   return(err);
}


ERR VDBAPI ErrDispExecuteSql(JET_SESID sesid, JET_DBID dbid,
	const char __far *szSql)
{
   JET_VSESID  vsesid;
   JET_VDBID   vdbid;
   ERR	       err;

   if (dbid >= dbidMax)
      return(JET_errInvalidDatabaseId);

   vsesid = (JET_VSESID) mpdbidvsesid[dbid];

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vdbid = mpdbiddbid[dbid];

   err = (*mpdbidpvdbfndef[dbid]->pfnExecuteSql)(vsesid, vdbid,
	szSql);

   return(err);
}


ERR VDBAPI ErrDispGetColumnInfo(JET_SESID sesid, JET_DBID dbid,
	const char __far *szTableName, const char __far *szColumnName,
	OLD_OUTDATA __far *poutdata, unsigned long InfoLevel)
{
   JET_VSESID  vsesid;
   JET_VDBID   vdbid;
   ERR	       err;

   FillClientBuffer(poutdata->pb, poutdata->cbMax);

   if (dbid >= dbidMax)
      return(JET_errInvalidDatabaseId);

   vsesid = (JET_VSESID) mpdbidvsesid[dbid];

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vdbid = mpdbiddbid[dbid];

   err = (*mpdbidpvdbfndef[dbid]->pfnGetColumnInfo)(vsesid, vdbid,
	szTableName, szColumnName, poutdata, InfoLevel);

   return(err);
}


ERR VDBAPI ErrDispGetDatabaseInfo(JET_SESID sesid, JET_DBID dbid,
	void __far *pvResult, unsigned long cbMax, unsigned long InfoLevel)
{
   JET_VSESID  vsesid;
   JET_VDBID   vdbid;
   ERR	       err;

   FillClientBuffer(pvResult, cbMax);

   if (dbid >= dbidMax)
      return(JET_errInvalidDatabaseId);

   vsesid = (JET_VSESID) mpdbidvsesid[dbid];

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vdbid = mpdbiddbid[dbid];

   err = (*mpdbidpvdbfndef[dbid]->pfnGetDatabaseInfo)(vsesid, vdbid,
	pvResult, cbMax, InfoLevel);

   return(err);
}


ERR VDBAPI ErrDispGetIndexInfo(JET_SESID sesid, JET_DBID dbid,
	const char __far *szTableName, const char __far *szIndexName,
	OLD_OUTDATA __far *poutdata, unsigned long InfoLevel)
{
   JET_VSESID  vsesid;
   JET_VDBID   vdbid;
   ERR	       err;

   FillClientBuffer(poutdata->pb, poutdata->cbMax);

   if (dbid >= dbidMax)
      return(JET_errInvalidDatabaseId);

   vsesid = (JET_VSESID) mpdbidvsesid[dbid];

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vdbid = mpdbiddbid[dbid];

   err = (*mpdbidpvdbfndef[dbid]->pfnGetIndexInfo)(vsesid, vdbid,
	szTableName, szIndexName, poutdata, InfoLevel);

   return(err);
}


ERR VDBAPI ErrDispGetObjectInfo(JET_SESID sesid, JET_DBID dbid,
	JET_OBJTYP objtyp,
	const char __far *szContainerName, const char __far *szObjectName,
	OLD_OUTDATA __far *poutdataInfo, unsigned long InfoLevel)
{
   JET_VSESID  vsesid;
   JET_VDBID   vdbid;
   ERR	       err;

   FillClientBuffer(poutdataInfo->pb, poutdataInfo->cbMax);

   if (dbid >= dbidMax)
      return(JET_errInvalidDatabaseId);

   vsesid = (JET_VSESID) mpdbidvsesid[dbid];

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vdbid = mpdbiddbid[dbid];

   err = (*mpdbidpvdbfndef[dbid]->pfnGetObjectInfo)(vsesid, vdbid,
	 objtyp, szContainerName, szObjectName, poutdataInfo, InfoLevel);

   return(err);
}


ERR VDBAPI ErrDispGetReferenceInfo(JET_SESID sesid, JET_DBID dbid,
	const char __far *szTableName, const char __far *szReferenceName,
	void __far *pvResult, unsigned long cbResult,
	unsigned long InfoLevel)
{
   JET_VSESID  vsesid;
   JET_VDBID   vdbid;
   ERR	       err;

   FillClientBuffer(pvResult, cbResult);

   if (dbid >= dbidMax)
      return(JET_errInvalidDatabaseId);

   vsesid = (JET_VSESID) mpdbidvsesid[dbid];

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vdbid = mpdbiddbid[dbid];

   err = (*mpdbidpvdbfndef[dbid]->pfnGetReferenceInfo)(vsesid, vdbid,
	szTableName, szReferenceName, pvResult, cbResult, InfoLevel);

   return(err);
}


ERR VDBAPI ErrDispOpenTable(JET_SESID sesid, JET_DBID dbid,
	JET_TABLEID __far *ptableid, const char __far *szTableName,
	JET_GRBIT grbit)
{
   JET_VSESID  vsesid;
   JET_VDBID   vdbid;
   ERR	       err;

   FillClientBuffer(ptableid, sizeof(JET_TABLEID));

   if (dbid >= dbidMax)
      return(JET_errInvalidDatabaseId);

   vsesid = (JET_VSESID) mpdbidvsesid[dbid];

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vdbid = mpdbiddbid[dbid];

   err = (*mpdbidpvdbfndef[dbid]->pfnOpenTable)(vsesid, vdbid,
	ptableid, szTableName, grbit);

   return(err);
}


ERR VDBAPI ErrDispRenameTable(JET_SESID sesid, JET_DBID dbid,
	const char __far *szTableName, const char __far *szTableNew)
{
   JET_VSESID  vsesid;
   JET_VDBID   vdbid;
   ERR	       err;

   if (dbid >= dbidMax)
      return(JET_errInvalidDatabaseId);

   vsesid = (JET_VSESID) mpdbidvsesid[dbid];

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vdbid = mpdbiddbid[dbid];

   err = (*mpdbidpvdbfndef[dbid]->pfnRenameTable)(vsesid, vdbid,
	szTableName, szTableNew);

   return(err);
}


ERR VDBAPI ErrDispGetObjidFromName(JET_SESID sesid, JET_DBID dbid,
	const char __far *szContainerName, const char __far *szObjectName,
	OBJID __far *pobjid)
{
   JET_VSESID  vsesid;
   JET_VDBID   vdbid;
   ERR	       err;

   FillClientBuffer(pobjid, sizeof(OBJID));

   if (dbid >= dbidMax)
      return(JET_errInvalidDatabaseId);

   vsesid = (JET_VSESID) mpdbidvsesid[dbid];

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vdbid = mpdbiddbid[dbid];

   err = (*mpdbidpvdbfndef[dbid]->pfnGetObjidFromName)(vsesid, vdbid,
	szContainerName, szObjectName, pobjid);

   return(err);
}


#if	_MSC_VER >= 700
#pragma warning(disable: 4100)	       /* Suppress Unreferenced parameter */
#endif	/* _MSC_VER >= 700 */


ERR VDBAPI ErrIllegalCapability(JET_VSESID sesid, JET_VDBID dbid,
	unsigned long lArea, unsigned long lFunction, JET_GRBIT __far *pgrbit)
{
   return(JET_errIllegalOperation);
}


ERR VDBAPI ErrIllegalCloseDatabase(JET_VSESID sesid, JET_VDBID dbid,
	JET_GRBIT grbit)
{
   return(JET_errIllegalOperation);
}


ERR VDBAPI ErrIllegalCreateObject(JET_VSESID sesid, JET_VDBID dbid,
	OBJID objidParentId, const char __far *szObjectName,
	JET_OBJTYP objtyp)
{
   return(JET_errIllegalOperation);
}


ERR VDBAPI ErrIllegalCreateTable(JET_VSESID sesid, JET_VDBID dbid,
	const char __far *szTableName, unsigned long lPages,
	unsigned long lDensity, JET_TABLEID __far *ptableid)
{
   return(JET_errIllegalOperation);
}


ERR VDBAPI ErrIllegalDeleteObject(JET_VSESID sesid, JET_VDBID dbid,
	OBJID objid)
{
   return(JET_errIllegalOperation);
}


ERR VDBAPI ErrIllegalRenameObject(JET_VSESID sesid, JET_VDBID dbid,
	const char __far *szContainerName, const char __far *szObjectName,
	const char __far *szObjectNew)
{
   return(JET_errIllegalOperation);
}


ERR VDBAPI ErrIllegalDeleteTable(JET_VSESID sesid, JET_VDBID dbid,
	const char __far *szTableName)
{
   return(JET_errIllegalOperation);
}


ERR VDBAPI ErrIllegalExecuteSql(JET_VSESID sesid, JET_VDBID dbid,
	const char __far *szSql)
{
   return(JET_errIllegalOperation);
}


ERR VDBAPI ErrIllegalGetColumnInfo(JET_VSESID sesid, JET_VDBID dbid,
	const char __far *szTableName, const char __far *szColumnName,
	OLD_OUTDATA __far *poutdata, unsigned long InfoLevel)
{
   return(JET_errIllegalOperation);
}


ERR VDBAPI ErrIllegalGetDatabaseInfo(JET_VSESID sesid, JET_VDBID dbid,
	void __far *pvResult, unsigned long cbMax, unsigned long InfoLevel)
{
   return(JET_errIllegalOperation);
}


ERR VDBAPI ErrIllegalGetIndexInfo(JET_VSESID sesid, JET_VDBID dbid,
	const char __far *szTableName, const char __far *szIndexName,
	OLD_OUTDATA __far *poutdata, unsigned long InfoLevel)
{
   return(JET_errIllegalOperation);
}


ERR VDBAPI ErrIllegalGetObjectInfo(JET_VSESID sesid, JET_VDBID dbid,
	JET_OBJTYP objtyp,
	const char __far *szContainerName, const char __far *szObjectName,
	OLD_OUTDATA __far *poutdataInfo, unsigned long InfoLevel)
{
   return(JET_errIllegalOperation);
}


ERR VDBAPI ErrIllegalGetReferenceInfo(JET_VSESID sesid, JET_VDBID dbid,
	const char __far *szTableName, const char __far *szReferenceName,
	void __far *pvResult, unsigned long cbResult,
	unsigned long InfoLevel)
{
   return(JET_errIllegalOperation);
}


ERR VDBAPI ErrIllegalOpenTable(JET_VSESID sesid, JET_VDBID dbid,
	JET_TABLEID __far *ptableid, const char __far *szTableName,
	JET_GRBIT grbit)
{
   return(JET_errIllegalOperation);
}


ERR VDBAPI ErrIllegalRenameTable(JET_VSESID sesid, JET_VDBID dbid,
	const char __far *szTableName, const char __far *szTableNew)
{
   return(JET_errIllegalOperation);
}


ERR VDBAPI ErrIllegalGetObjidFromName(JET_VSESID sesid, JET_VDBID dbid,
	const char __far *szContainerName, const char __far *szObjectName,
	OBJID __far *pobjid)
{
   return(JET_errIllegalOperation);
}


ERR VDBAPI ErrInvalidDbidCapability(JET_VSESID sesid, JET_VDBID dbid,
	unsigned long lArea, unsigned long lFunction, JET_GRBIT __far *pgrbit)
{
   return(JET_errInvalidDatabaseId);
}


ERR VDBAPI ErrInvalidDbidCloseDatabase(JET_VSESID sesid, JET_VDBID dbid,
	JET_GRBIT grbit)
{
   return(JET_errInvalidDatabaseId);
}


ERR VDBAPI ErrInvalidDbidCreateObject(JET_VSESID sesid, JET_VDBID dbid,
	OBJID objidParentId, const char __far *szObjectName,
	JET_OBJTYP objtyp)
{
   return(JET_errInvalidDatabaseId);
}


ERR VDBAPI ErrInvalidDbidCreateTable(JET_VSESID sesid, JET_VDBID dbid,
	const char __far *szTableName, unsigned long lPages,
	unsigned long lDensity, JET_TABLEID __far *ptableid)
{
   return(JET_errInvalidDatabaseId);
}


ERR VDBAPI ErrInvalidDbidDeleteObject(JET_VSESID sesid, JET_VDBID dbid,
	OBJID objid)
{
   return(JET_errInvalidDatabaseId);
}


ERR VDBAPI ErrInvalidDbidRenameObject(JET_VSESID sesid, JET_VDBID dbid,
	const char __far *szContainerName, const char __far *szObjectName,
	const char __far *szObjectNew)
{
   return(JET_errInvalidDatabaseId);
}


ERR VDBAPI ErrInvalidDbidDeleteTable(JET_VSESID sesid, JET_VDBID dbid,
	const char __far *szTableName)
{
   return(JET_errInvalidDatabaseId);
}


ERR VDBAPI ErrInvalidDbidExecuteSql(JET_VSESID sesid, JET_VDBID dbid,
	const char __far *szSql)
{
   return(JET_errInvalidDatabaseId);
}


ERR VDBAPI ErrInvalidDbidGetColumnInfo(JET_VSESID sesid, JET_VDBID dbid,
	const char __far *szTableName, const char __far *szColumnName,
	OLD_OUTDATA __far *poutdata, unsigned long InfoLevel)
{
   return(JET_errInvalidDatabaseId);
}


ERR VDBAPI ErrInvalidDbidGetDatabaseInfo(JET_VSESID sesid, JET_VDBID dbid,
	void __far *pvResult, unsigned long cbMax, unsigned long InfoLevel)
{
   return(JET_errInvalidDatabaseId);
}


ERR VDBAPI ErrInvalidDbidGetIndexInfo(JET_VSESID sesid, JET_VDBID dbid,
	const char __far *szTableName, const char __far *szIndexName,
	OLD_OUTDATA __far *poutdata, unsigned long InfoLevel)
{
   return(JET_errInvalidDatabaseId);
}


ERR VDBAPI ErrInvalidDbidGetObjectInfo(JET_VSESID sesid, JET_VDBID dbid,
	JET_OBJTYP objtyp,
	const char __far *szContainerName, const char __far *szObjectName,
	OLD_OUTDATA __far *poutdataInfo, unsigned long InfoLevel)
{
   return(JET_errInvalidDatabaseId);
}


ERR VDBAPI ErrInvalidDbidGetReferenceInfo(JET_VSESID sesid, JET_VDBID dbid,
	const char __far *szTableName, const char __far *szReferenceName,
	void __far *pvResult, unsigned long cbResult,
	unsigned long InfoLevel)
{
   return(JET_errInvalidDatabaseId);
}


ERR VDBAPI ErrInvalidDbidOpenTable(JET_VSESID sesid, JET_VDBID dbid,
	JET_TABLEID __far *ptableid, const char __far *szTableName,
	JET_GRBIT grbit)
{
   return(JET_errInvalidDatabaseId);
}


ERR VDBAPI ErrInvalidDbidRenameTable(JET_VSESID sesid, JET_VDBID dbid,
	const char __far *szTableName, const char __far *szTableNew)
{
   return(JET_errInvalidDatabaseId);
}


ERR VDBAPI ErrInvalidDbidGetObjidFromName(JET_VSESID sesid, JET_VDBID dbid,
	const char __far *szContainerName, const char __far *szObjectName,
	OBJID __far *pobjid)
{
   return(JET_errInvalidDatabaseId);
}


#endif	/* defined(FLAT) || !defined(RETAIL) */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\src\vdbmgr.c ===
/***********************************************************************
* Microsoft Jet
*
* Microsoft Confidential.  Copyright 1991-1992 Microsoft Corporation.
*
* Component:
*
* File: vdbmgr.c
*
* File Comments:
*
* Revision History:
*
*    [0]  02-Apr-91  richards	Created
*
***********************************************************************/

#include "std.h"

#include "vdbmgr.h"
#include "_vdbmgr.h"

DeclAssertFile;


extern const VDBFNDEF __far EXPORT vdbfndefInvalidDbid;


JET_DBID	       __near dbidFree;
JET_VDBID	       __near EXPORT mpdbiddbid[dbidMax];
const VDBFNDEF __far * __near EXPORT mpdbidpvdbfndef[dbidMax];
JET_VSESID	       __near EXPORT mpdbidvsesid[dbidMax];


	/* C6BUG: The functions in this file specify EXPORT because QJET */
	/* C6BUG: fails when compiled with __fastcall under C 6.00A. */

PUBLIC void EXPORT ReleaseDbid(JET_DBID dbid)
{
// Assert((dbid < dbidMax) && (mpdbidpvdbfndef[dbid] != &vdbfndefInvalidDbid));

   mpdbiddbid[dbid] = (JET_VDBID) dbidFree;
   mpdbidpvdbfndef[dbid] = &vdbfndefInvalidDbid;

   dbidFree = dbid;
}


PUBLIC ERR ErrVdbmgrInit(void)
{
   JET_DBID dbid;

   dbidFree = JET_dbidNil;

   for (dbid = (JET_DBID) 0; dbid < dbidMax; dbid++)
      ReleaseDbid(dbid);

   return(JET_errSuccess);
}


PUBLIC ERR EXPORT ErrAllocateDbid(JET_DBID __far *pdbid, JET_VDBID vdbid, const struct tagVDBFNDEF __far *pvdbfndef)
{
   JET_DBID dbid;

   if ((*pdbid = dbid = dbidFree) == JET_dbidNil)
   {
      return(JET_errTooManyOpenDatabases);
   }

   dbidFree = (JET_DBID) mpdbiddbid[dbid];

   mpdbiddbid[dbid] = vdbid;
   mpdbidpvdbfndef[dbid] = pvdbfndef;
   mpdbidvsesid[dbid] = (JET_VSESID) 0xFFFFFFFF;

   return(JET_errSuccess);
}



PUBLIC ERR EXPORT ErrUpdateDbid(JET_DBID dbid, JET_VDBID vdbid, const struct tagVDBFNDEF __far *pvdbfndef)
{
   if ((dbid >= dbidMax) || (mpdbidpvdbfndef[dbid] == &vdbfndefInvalidDbid))
      return(JET_errInvalidDatabaseId);

   mpdbiddbid[dbid] = vdbid;
   mpdbidpvdbfndef[dbid] = pvdbfndef;

   return(JET_errSuccess);
}


PUBLIC BOOL EXPORT FValidDbid(JET_SESID sesid, JET_DBID dbid)
{
   sesid = sesid;

   return((dbid < dbidMax) && (mpdbidpvdbfndef[dbid] != &vdbfndefInvalidDbid));
}


PUBLIC JET_DBID EXPORT DbidOfVdbid(JET_VDBID vdbid, const struct tagVDBFNDEF __far *pvdbfndef)
{
   JET_DBID dbid;

   for (dbid = 0; dbid < dbidMax; dbid++)
   {
      if ((mpdbiddbid[dbid] == vdbid) &&
	  (mpdbidpvdbfndef[dbid] == pvdbfndef))
	 return(dbid);
   }

   Assert(fFalse);
   return(JET_dbidNil);
}


const struct tagVDBFNDEF *PvdbfndefOfDbid(JET_DBID dbid)
{
   Assert(dbid < dbidMax);

   return(mpdbidpvdbfndef[dbid]);
}



PUBLIC ERR EXPORT ErrVdbidOfDbid(JET_SESID sesid, JET_DBID dbid, JET_VDBID *pvdbid)
{
   sesid = sesid;

   if ((dbid >= dbidMax) ||
       (mpdbidpvdbfndef[dbid] == &vdbfndefInvalidDbid))
      return(JET_errInvalidDatabaseId);

   *pvdbid = mpdbiddbid[dbid];

   return(JET_errSuccess);
}


PUBLIC JET_SESID EXPORT VsesidOfDbid(JET_DBID dbid)
{
   Assert(dbid < dbidMax);

   return(mpdbidvsesid[dbid]);
}


#ifndef RETAIL

CODECONST(char) szOpenVdbHdr[] = "   DbId    Session Id   VDBID    Type\r\n";
CODECONST(char) szOpenVdbSep[] = "---------- ---------- ---------- --------------------------------\r\n";
CODECONST(char) szOpenVdbFmt[] = "0x%08lX 0x%08lX 0x%08lX %s\r\n";
CODECONST(char) szVdbTypeUnknown[] = "";

void DebugListOpenDatabases(void)
{
   JET_DBID		   dbid;
   const VDBFNDEF __far    *pvdbfndef;
   const VDBDBGDEF __far   *pvdbdbgdef;
   const char __far	   *szVdbType;

   DebugWriteString(fTrue, szOpenVdbHdr);
   DebugWriteString(fTrue, szOpenVdbSep);

   for (dbid = 0; dbid < dbidMax; dbid++)
   {
      pvdbfndef = mpdbidpvdbfndef[dbid];

      if (pvdbfndef != &vdbfndefInvalidDbid)
      {
	 pvdbdbgdef = pvdbfndef->pvdbdbgdef;

	 if (pvdbdbgdef == NULL)
	    szVdbType = szVdbTypeUnknown;
	 else
	    szVdbType = pvdbdbgdef->szName;

	 DebugWriteString(fTrue, szOpenVdbFmt, dbid, mpdbidvsesid[dbid], mpdbiddbid[dbid], szVdbType);
      }
   }
}

#endif	/* RETAIL */


	/* The following pragma affects the code generated by the C */
	/* compiler for all FAR functions.  Do NOT place any non-API */
	/* functions beyond this point in this file. */

	/* The following APIs are not remoted.	The only reason they */
	/* accept session id's is because DS instancing requires it. */


JET_ERR JET_API JetAllocateDbid(JET_SESID sesid, JET_DBID __far *pdbid, JET_VDBID vdbid, const struct tagVDBFNDEF __far *pvdbfndef, JET_VSESID vsesid)
{
   ERR err;

   Assert(UtilGetIsibOfSesid(sesid) != -1);

   err = ErrAllocateDbid(pdbid, vdbid, pvdbfndef);

   if (err < 0)
      return(err);

   mpdbidvsesid[*pdbid] = vsesid;

   return(JET_errSuccess);
}


JET_ERR JET_API JetUpdateDbid(JET_SESID sesid, JET_DBID dbid, JET_VDBID vdbid, const struct tagVDBFNDEF __far *pvdbfndef)
{
   Assert(UtilGetIsibOfSesid(sesid) != -1);

   return(ErrUpdateDbid(dbid, vdbid, pvdbfndef));
}


JET_ERR JET_API JetReleaseDbid(JET_SESID sesid, JET_DBID dbid)
{
   Assert(UtilGetIsibOfSesid(sesid) != -1);

   if ((dbid >= dbidMax) ||
       (mpdbidpvdbfndef[dbid] == &vdbfndefInvalidDbid))
      return(JET_errInvalidDatabaseId);

   ReleaseDbid(dbid);

   return(JET_errSuccess);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\src\vtdispc.c ===
/***********************************************************************
* Microsoft Jet
*
* Microsoft Confidential.  Copyright 1991-1992 Microsoft Corporation.
*
* Component:
*
* File: vtdispc.c
*
* File Comments:
*
* Revision History:
*
*    [0]  24-Jan-92  richards	Created
*
***********************************************************************/

#include "std.h"

#include "_vtmgr.h"
#include "vtmgr.h"

#if	defined(FLAT) || !defined(RETAIL)

DeclAssertFile;


extern VTFNAddColumn			ErrInvalidAddColumn;
extern VTFNCloseTable			ErrInvalidCloseTable;
extern VTFNComputeStats 		ErrInvalidComputeStats;
extern VTFNCopyBookmarks		ErrInvalidCopyBookmarks;
extern VTFNCreateIndex			ErrInvalidCreateIndex;
extern VTFNCreateReference		ErrInvalidCreateReference;
extern VTFNDelete			ErrInvalidDelete;
extern VTFNDeleteColumn 		ErrInvalidDeleteColumn;
extern VTFNDeleteIndex			ErrInvalidDeleteIndex;
extern VTFNDeleteReference		ErrInvalidDeleteReference;
extern VTFNDupCursor			ErrInvalidDupCursor;
extern VTFNCloseTable			ErrInvalidEmptyTable;
extern VTFNGetBookmark			ErrInvalidGetBookmark;
extern VTFNGetChecksum			ErrInvalidGetChecksum;
extern VTFNGetCurrentIndex		ErrInvalidGetCurrentIndex;
extern VTFNGetCursorInfo		ErrInvalidGetCursorInfo;
extern VTFNGetRecordPosition		ErrInvalidGetRecordPosition;
extern VTFNGetTableColumnInfo		ErrInvalidGetTableColumnInfo;
extern VTFNGetTableIndexInfo		ErrInvalidGetTableIndexInfo;
extern VTFNGetTableInfo 		ErrInvalidGetTableInfo;
extern VTFNGetTableReferenceInfo	ErrInvalidGetTableReferenceInfo;
extern VTFNGotoBookmark 		ErrInvalidGotoBookmark;
extern VTFNGotoPosition 		ErrInvalidGotoPosition;
extern VTFNVtIdle			ErrInvalidVtIdle;
extern VTFNMakeKey			ErrInvalidMakeKey;
extern VTFNMove 			ErrInvalidMove;
extern VTFNNotifyBeginTrans		ErrInvalidNotifyBeginTrans;
extern VTFNNotifyCommitTrans		ErrInvalidNotifyCommitTrans;
extern VTFNNotifyRollback		ErrInvalidNotifyRollback;
extern VTFNNotifyUpdateUfn		ErrInvalidNotifyUpdateUfn;
extern VTFNPrepareUpdate		ErrInvalidPrepareUpdate;
extern VTFNRenameColumn 		ErrInvalidRenameColumn;
extern VTFNRenameIndex			ErrInvalidRenameIndex;
extern VTFNRenameReference		ErrInvalidRenameReference;
extern VTFNRetrieveColumn		ErrInvalidRetrieveColumn;
extern VTFNRetrieveKey			ErrInvalidRetrieveKey;
extern VTFNSeek 			ErrInvalidSeek;
extern VTFNSetCurrentIndex		ErrInvalidSetCurrentIndex;
extern VTFNSetColumn			ErrInvalidSetColumn;
extern VTFNSetIndexRange		ErrInvalidSetIndexRange;
extern VTFNUpdate			ErrInvalidUpdate;


#ifndef RETAIL
CODECONST(VTDBGDEF) vtdbgdefInvalidTableid =
	{
	sizeof(VTFNDEF),
	0,
	"Invalid Tableid",
	0,
	{
		0,
		0,
		0,
		0,
	},
	};
#endif	/* !RETAIL */

CODECONST(VTFNDEF) EXPORT vtfndefInvalidTableid =
	{
	sizeof(VTFNDEF),
	0,
#ifdef	RETAIL
	NULL,
#else	/* !RETAIL */
	&vtdbgdefInvalidTableid,
#endif	/* !RETAIL */
	ErrInvalidAddColumn,
	ErrInvalidCloseTable,
	ErrInvalidComputeStats,
	ErrInvalidCopyBookmarks,
	ErrInvalidCreateIndex,
	ErrInvalidCreateReference,
	ErrInvalidDelete,
	ErrInvalidDeleteColumn,
	ErrInvalidDeleteIndex,
	ErrInvalidDeleteReference,
	ErrInvalidDupCursor,
	ErrInvalidGetBookmark,
	ErrInvalidGetChecksum,
	ErrInvalidGetCurrentIndex,
	ErrInvalidGetCursorInfo,
	ErrInvalidGetRecordPosition,
	ErrInvalidGetTableColumnInfo,
	ErrInvalidGetTableIndexInfo,
	ErrInvalidGetTableInfo,
	ErrInvalidGetTableReferenceInfo,
	ErrInvalidGotoBookmark,
	ErrInvalidGotoPosition,
	ErrInvalidVtIdle,
	ErrInvalidMakeKey,
	ErrInvalidMove,
	ErrInvalidNotifyBeginTrans,
	ErrInvalidNotifyCommitTrans,
	ErrInvalidNotifyRollback,
	ErrInvalidNotifyUpdateUfn,
	ErrInvalidPrepareUpdate,
	ErrInvalidRenameColumn,
	ErrInvalidRenameIndex,
	ErrInvalidRenameReference,
	ErrInvalidRetrieveColumn,
	ErrInvalidRetrieveKey,
	ErrInvalidSeek,
	ErrInvalidSetCurrentIndex,
	ErrInvalidSetColumn,
	ErrInvalidSetIndexRange,
	ErrInvalidUpdate,
	ErrInvalidEmptyTable,
	};


ERR VTAPI ErrDispAddColumn(JET_SESID sesid, JET_TABLEID tableid,
	const char __far *szColumn, const JET_COLUMNDEF __far *pcolumndef,
	const void __far *pvDefault, unsigned long cbDefault,
	JET_COLUMNID __far *pcolumnid)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   FillClientBuffer(pcolumnid, sizeof(JET_COLUMNID));

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnAddColumn)(vsesid, vtid,
	szColumn, pcolumndef, pvDefault, cbDefault, pcolumnid);

   return(err);
}


ERR VTAPI ErrDispCloseTable(JET_SESID sesid, JET_TABLEID tableid)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   /* The check rfs call was removed. Currently ErrIsamCloseTable() */
   /* does not return an error.  If this changes, the disp may want */
   /* to call the check rfs function again.  If the close table     */
   /* functions return errors rfs testing will not pass, so you'll  */
   /* be turning off the bit anyways.                               */

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnCloseTable)(vsesid, vtid);

   return(err);
}


ERR VTAPI ErrDispComputeStats(JET_SESID sesid, JET_TABLEID tableid)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnComputeStats)(vsesid, vtid);

   return(err);
}

ERR VTAPI ErrDispCopyBookmarks(JET_SESID sesid, JET_TABLEID tableidSrc,
	JET_TABLEID tableidDest, JET_COLUMNID columnidDest, unsigned long crecMax)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   if (tableidSrc > tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableidSrc].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableidSrc].vtid;

   err = (*rgvtdef[tableidSrc].pvtfndef->pfnCopyBookmarks)(vsesid, vtid,
	tableidDest, columnidDest, crecMax);

   return(err);
}

ERR VTAPI ErrDispCreateIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char __far *szIndexName, JET_GRBIT grbit,
	const char __far *szKey, unsigned long cbKey, unsigned long lDensity)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnCreateIndex)(vsesid, vtid,
	szIndexName, grbit, szKey, cbKey, lDensity);

   return(err);
}


ERR VTAPI ErrDispCreateReference(JET_SESID sesid, JET_TABLEID tableid,
	const char __far *szReferenceName, const char __far *szColumns,
	const char __far *szReferencedTable,
	const char __far *szReferencedColumns, JET_GRBIT grbit)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnCreateReference)(vsesid, vtid,
	szReferenceName, szColumns, szReferencedTable,
	szReferencedColumns, grbit);

   return(err);
}


ERR VTAPI ErrDispDelete(JET_SESID sesid, JET_TABLEID tableid)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnDelete)(vsesid, vtid);

   return(err);
}


ERR VTAPI ErrDispDeleteColumn(JET_SESID sesid, JET_TABLEID tableid,
	const char __far *szColumn)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnDeleteColumn)(vsesid, vtid,
	 szColumn);

   return(err);
}


ERR VTAPI ErrDispDeleteIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char __far *szIndexName)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnDeleteIndex)(vsesid, vtid,
	szIndexName);

   return(err);
}


ERR VTAPI ErrDispDeleteReference(JET_SESID sesid, JET_TABLEID tableid,
	const char __far *szReferenceName)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnDeleteReference)(vsesid, vtid,
	szReferenceName);

   return(err);
}


ERR VTAPI ErrDispDupCursor(JET_SESID sesid, JET_TABLEID tableid,
	JET_TABLEID __far *ptableid, JET_GRBIT grbit)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   FillClientBuffer(ptableid, sizeof(JET_TABLEID));

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnDupCursor)(vsesid, vtid,
	ptableid, grbit);

   return(err);
}


ERR VTAPI ErrDispEmptyTable(JET_SESID sesid, JET_TABLEID tableid)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnEmptyTable)(vsesid, vtid);

   return(err);
}

ERR VTAPI ErrDispGetBookmark(JET_SESID sesid, JET_TABLEID tableid,
	void __far *pvBookmark, unsigned long cbMax,
	unsigned long __far *pcbActual)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   FillClientBuffer(pvBookmark, cbMax);
   FillClientBuffer(pcbActual, sizeof(unsigned long));

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnGetBookmark)(vsesid, vtid,
	pvBookmark, cbMax, pcbActual);

   return(err);
}


ERR VTAPI ErrDispGetChecksum(JET_SESID sesid, JET_TABLEID tableid,
	unsigned long __far *pChecksum)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   FillClientBuffer(pChecksum, sizeof(unsigned long));

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnGetChecksum)(vsesid, vtid,
	pChecksum);

   return(err);
}


ERR VTAPI ErrDispGetCurrentIndex(JET_SESID sesid, JET_TABLEID tableid,
	char __far *szIndexName, unsigned long cchIndexName)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   FillClientBuffer(szIndexName, cchIndexName);

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnGetCurrentIndex)(vsesid, vtid,
	szIndexName, cchIndexName);

   return(err);
}


ERR VTAPI ErrDispGetCursorInfo(JET_SESID sesid, JET_TABLEID tableid,
	void __far *pvResult, unsigned long cbMax, unsigned long InfoLevel)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   FillClientBuffer(pvResult, cbMax);

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnGetCursorInfo)(vsesid, vtid,
	pvResult, cbMax, InfoLevel);

   return(err);
}


ERR VTAPI ErrDispGetRecordPosition(JET_SESID sesid, JET_TABLEID tableid,
	JET_RECPOS __far *pkeypos, unsigned long cbKeypos)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   FillClientBuffer(pkeypos, cbKeypos);

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnGetRecordPosition)(vsesid, vtid,
	pkeypos, cbKeypos);

   return(err);
}


ERR VTAPI ErrDispGetTableColumnInfo(JET_SESID sesid, JET_TABLEID tableid,
	const char __far *szColumnName, void __far *pvResult,
	unsigned long cbMax, unsigned long InfoLevel)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   FillClientBuffer(pvResult, cbMax);

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnGetTableColumnInfo)(vsesid, vtid,
	szColumnName, pvResult, cbMax, InfoLevel);

   return(err);
}


ERR VTAPI ErrDispGetTableIndexInfo(JET_SESID sesid, JET_TABLEID tableid,
	const char __far *szIndexName, void __far *pvResult,
	unsigned long cbMax, unsigned long InfoLevel)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   FillClientBuffer(pvResult, cbMax);

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnGetTableIndexInfo)(vsesid, vtid,
	szIndexName, pvResult, cbMax, InfoLevel);

   return(err);
}


ERR VTAPI ErrDispGetTableInfo(JET_SESID sesid, JET_TABLEID tableid,
	void __far *pvResult, unsigned long cbMax, unsigned long InfoLevel)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   FillClientBuffer(pvResult, cbMax);

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnGetTableInfo)(vsesid, vtid,
	pvResult, cbMax, InfoLevel);

   return(err);
}


ERR VTAPI ErrDispGetTableReferenceInfo(JET_SESID sesid, JET_TABLEID tableid,
	const char __far *szReferenceName, void __far *pvResult,
	unsigned long cbMax, unsigned long InfoLevel)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   FillClientBuffer(pvResult, cbMax);

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnGetTableReferenceInfo)(vsesid, vtid,
	szReferenceName, pvResult, cbMax, InfoLevel);

   return(err);
}


ERR VTAPI ErrDispGotoBookmark(JET_SESID sesid, JET_TABLEID tableid,
	void __far *pvBookmark, unsigned long cbBookmark)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnGotoBookmark)(vsesid, vtid,
	pvBookmark, cbBookmark);

   return(err);
}


ERR VTAPI ErrDispGotoPosition(JET_SESID sesid, JET_TABLEID tableid,
	JET_RECPOS *precpos)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnGotoPosition)(vsesid, vtid,
	 precpos);

   return(err);
}


ERR VTAPI ErrDispVtIdle(JET_SESID sesid, JET_TABLEID tableid)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnVtIdle)(vsesid, vtid);

   return(err);
}


ERR VTAPI ErrDispMakeKey(JET_SESID sesid, JET_TABLEID tableid,
	const void __far *pvData, unsigned long cbData, JET_GRBIT grbit)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnMakeKey)(vsesid, vtid,
	pvData, cbData, grbit);

   return(err);
}


ERR VTAPI ErrDispMove(JET_SESID sesid, JET_TABLEID tableid,
	long cRow, JET_GRBIT grbit)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnMove)(vsesid, vtid,
	 cRow, grbit);

   return(err);
}


ERR VTAPI ErrDispNotifyBeginTrans(JET_SESID sesid, JET_TABLEID tableid)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnNotifyBeginTrans)(vsesid, vtid);

   return(err);
}


ERR VTAPI ErrDispNotifyCommitTrans(JET_SESID sesid, JET_TABLEID tableid,
	JET_GRBIT grbit)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnNotifyCommitTrans)(vsesid, vtid, grbit);

   return(err);
}


ERR VTAPI ErrDispNotifyRollback(JET_SESID sesid, JET_TABLEID tableid,
	JET_GRBIT grbit)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnNotifyRollback)(vsesid, vtid, grbit);

   return(err);
}


ERR VTAPI ErrDispNotifyUpdateUfn(JET_SESID sesid, JET_TABLEID tableid)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnNotifyUpdateUfn)(vsesid, vtid);

   return(err);
}


ERR VTAPI ErrDispPrepareUpdate(JET_SESID sesid, JET_TABLEID tableid,
	unsigned long prep)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnPrepareUpdate)(vsesid, vtid,
	 prep);

   return(err);
}


ERR VTAPI ErrDispRenameColumn(JET_SESID sesid, JET_TABLEID tableid,
	const char __far *szColumn, const char __far *szColumnNew)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnRenameColumn)(vsesid, vtid,
	szColumn, szColumnNew);

   return(err);
}


ERR VTAPI ErrDispRenameIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char __far *szIndex, const char __far *szIndexNew)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnRenameIndex)(vsesid, vtid,
	szIndex, szIndexNew);

   return(err);
}


ERR VTAPI ErrDispRenameReference(JET_SESID sesid, JET_TABLEID tableid,
	const char __far *szReference, const char __far *szReferenceNew)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnRenameReference)(vsesid, vtid,
	szReference, szReferenceNew);

   return(err);
}


ERR VTAPI ErrDispRetrieveColumn(JET_SESID sesid, JET_TABLEID tableid,
	JET_COLUMNID columnid, void __far *pvData, unsigned long cbData,
	unsigned long __far *pcbActual, JET_GRBIT grbit,
	JET_RETINFO __far *pretinfo)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   FillClientBuffer(pvData, cbData);
   FillClientBuffer(pcbActual, sizeof(unsigned long));

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnRetrieveColumn)(vsesid, vtid,
	 columnid, pvData, cbData, pcbActual, grbit, pretinfo);

   return(err);
}


ERR VTAPI ErrDispRetrieveKey(JET_SESID sesid, JET_TABLEID tableid,
	void __far *pvKey, unsigned long cbMax,
	unsigned long __far *pcbActual, JET_GRBIT grbit)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   FillClientBuffer(pvKey, cbMax);
   FillClientBuffer(pcbActual, sizeof(unsigned long));

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnRetrieveKey)(vsesid, vtid,
	pvKey, cbMax, pcbActual, grbit);

   return(err);
}


ERR VTAPI ErrDispSeek(JET_SESID sesid, JET_TABLEID tableid, JET_GRBIT grbit)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnSeek)(vsesid, vtid, grbit);

   return(err);
}


ERR VTAPI ErrDispSetCurrentIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char __far *szIndexName)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnSetCurrentIndex)(vsesid, vtid,
	szIndexName);

   return(err);
}


ERR VTAPI ErrDispSetColumn(JET_SESID sesid, JET_TABLEID tableid,
	JET_COLUMNID columnid, const void __far *pvData,
	unsigned long cbData, JET_GRBIT grbit, JET_SETINFO __far *psetinfo)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnSetColumn)(vsesid, vtid,
	 columnid, pvData, cbData, grbit, psetinfo);

   return(err);
}


ERR VTAPI ErrDispSetIndexRange(JET_SESID sesid, JET_TABLEID tableid,
	JET_GRBIT grbit)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnSetIndexRange)(vsesid, vtid,
	 grbit);

   return(err);
}


ERR VTAPI ErrDispUpdate(JET_SESID sesid, JET_TABLEID tableid,
	void __far *pvBookmark, unsigned long cbBookmark,
	unsigned long __far *pcbActual)
{
   JET_VSESID  vsesid;
   JET_VTID    vtid;
   ERR	       err;

   FillClientBuffer(pvBookmark, cbBookmark);
   FillClientBuffer(pcbActual, sizeof(unsigned long));

   if (tableid >= tableidMax)
      return(JET_errInvalidTableId);

   vsesid = rgvtdef[tableid].vsesid;

   if (vsesid == (JET_VSESID) 0xFFFFFFFF)
      vsesid = (JET_VSESID) sesid;

   vtid = rgvtdef[tableid].vtid;

   err = (*rgvtdef[tableid].pvtfndef->pfnUpdate)(vsesid, vtid,
	pvBookmark, cbBookmark, pcbActual);

   return(err);
}


#if	_MSC_VER >= 700
#pragma warning(disable: 4100)	       /* Suppress Unreferenced parameter */
#endif	/* _MSC_VER >= 700 */


ERR VTAPI ErrIllegalAddColumn(JET_VSESID vsesid, JET_VTID vtid,
	const char __far *szColumn, const JET_COLUMNDEF __far *pcolumndef,
	const void __far *pvDefault, unsigned long cbDefault,
	JET_COLUMNID __far *pcolumnid)
{
   return(JET_errIllegalOperation);
}


ERR VTAPI ErrIllegalCloseTable(JET_VSESID vsesid, JET_VTID vtid)
{
   return(JET_errIllegalOperation);
}


ERR VTAPI ErrIllegalComputeStats(JET_VSESID vsesid, JET_VTID vtid)
{
   return(JET_errIllegalOperation);
}

ERR VTAPI ErrIllegalCopyBookmarks(JET_VSESID sesid, JET_VTID vtidSrc,
	JET_TABLEID tableidDest, JET_COLUMNID columnidDest, unsigned long crecMax)
{
   return(JET_errIllegalOperation);
}

ERR VTAPI ErrIllegalCreateIndex(JET_VSESID vsesid, JET_VTID vtid,
	const char __far *szIndexName, JET_GRBIT grbit,
	const char __far *szKey, unsigned long cbKey, unsigned long lDensity)
{
   return(JET_errIllegalOperation);
}


ERR VTAPI ErrIllegalCreateReference(JET_VSESID vsesid, JET_VTID vtid,
	const char __far *szReferenceName, const char __far *szColumns,
	const char __far *szReferencedTable,
	const char __far *szReferencedColumns, JET_GRBIT grbit)
{
   return(JET_errIllegalOperation);
}


ERR VTAPI ErrIllegalDelete(JET_VSESID vsesid, JET_VTID vtid)
{
   return(JET_errIllegalOperation);
}


ERR VTAPI ErrIllegalDeleteColumn(JET_VSESID vsesid, JET_VTID vtid,
	const char __far *szColumn)
{
   return(JET_errIllegalOperation);
}


ERR VTAPI ErrIllegalDeleteIndex(JET_VSESID vsesid, JET_VTID vtid,
	const char __far *szIndexName)
{
   return(JET_errIllegalOperation);
}


ERR VTAPI ErrIllegalDeleteReference(JET_VSESID vsesid, JET_VTID vtid,
	const char __far *szReferenceName)
{
   return(JET_errIllegalOperation);
}


ERR VTAPI ErrIllegalDupCursor(JET_VSESID vsesid, JET_VTID vtid,
	JET_TABLEID __far *ptableid, JET_GRBIT grbit)
{
   return(JET_errIllegalOperation);
}


ERR VTAPI ErrIllegalEmptyTable(JET_VSESID sesid, JET_VTID vtid)
{
   return(JET_errIllegalOperation);
}


ERR VTAPI ErrIllegalGetBookmark(JET_VSESID vsesid, JET_VTID vtid,
	void __far *pvBookmark, unsigned long cbMax,
	unsigned long __far *pcbActual)
{
   return(JET_errIllegalOperation);
}


ERR VTAPI ErrIllegalGetChecksum(JET_VSESID vsesid, JET_VTID vtid,
	unsigned long __far *pChecksum)
{
   return(JET_errIllegalOperation);
}


ERR VTAPI ErrIllegalGetCurrentIndex(JET_VSESID vsesid, JET_VTID vtid,
	char __far *szIndexName, unsigned long cchIndexName)
{
   return(JET_errIllegalOperation);
}


ERR VTAPI ErrIllegalGetCursorInfo(JET_VSESID vsesid, JET_VTID vtid,
	void __far *pvResult, unsigned long cbMax, unsigned long InfoLevel)
{
   return(JET_errIllegalOperation);
}


ERR VTAPI ErrIllegalGetRecordPosition(JET_VSESID vsesid, JET_VTID vtid,
	JET_RECPOS __far *pkeypos, unsigned long cbKeypos)
{
   return(JET_errIllegalOperation);
}


ERR VTAPI ErrIllegalGetTableColumnInfo(JET_VSESID vsesid, JET_VTID vtid,
	const char __far *szColumnName, void __far *pvResult,
	unsigned long cbMax, unsigned long InfoLevel)
{
   return(JET_errIllegalOperation);
}


ERR VTAPI ErrIllegalGetTableIndexInfo(JET_VSESID vsesid, JET_VTID vtid,
	const char __far *szIndexName, void __far *pvResult,
	unsigned long cbMax, unsigned long InfoLevel)
{
   return(JET_errIllegalOperation);
}


ERR VTAPI ErrIllegalGetTableInfo(JET_VSESID vsesid, JET_VTID vtid,
	void __far *pvResult, unsigned long cbMax, unsigned long InfoLevel)
{
   return(JET_errIllegalOperation);
}


ERR VTAPI ErrIllegalGetTableReferenceInfo(JET_VSESID vsesid, JET_VTID vtid,
	const char __far *szReferenceName, void __far *pvResult,
	unsigned long cbMax, unsigned long InfoLevel)
{
   return(JET_errIllegalOperation);
}


ERR VTAPI ErrIllegalGotoBookmark(JET_VSESID vsesid, JET_VTID vtid,
	void __far *pvBookmark, unsigned long cbBookmark)
{
   return(JET_errIllegalOperation);
}


ERR VTAPI ErrIllegalGotoPosition(JET_VSESID vsesid, JET_VTID vtid,
	JET_RECPOS *precpos)
{
   return(JET_errIllegalOperation);
}


ERR VTAPI ErrIllegalVtIdle(JET_VSESID vsesid, JET_VTID vtid)
{
   return(JET_errIllegalOperation);
}


ERR VTAPI ErrIllegalMakeKey(JET_VSESID vsesid, JET_VTID vtid,
	const void __far *pvData, unsigned long cbData, JET_GRBIT grbit)
{
   return(JET_errIllegalOperation);
}


ERR VTAPI ErrIllegalMove(JET_VSESID vsesid, JET_VTID vtid,
	long cRow, JET_GRBIT grbit)
{
   return(JET_errIllegalOperation);
}


ERR VTAPI ErrIllegalNotifyBeginTrans(JET_VSESID vsesid, JET_VTID vtid)
{
   return(JET_errIllegalOperation);
}


ERR VTAPI ErrIllegalNotifyCommitTrans(JET_VSESID vsesid, JET_VTID vtid,
	JET_GRBIT grbit)
{
   return(JET_errIllegalOperation);
}


ERR VTAPI ErrIllegalNotifyRollback(JET_VSESID vsesid, JET_VTID vtid,
	JET_GRBIT grbit)
{
   return(JET_errIllegalOperation);
}


ERR VTAPI ErrIllegalNotifyUpdateUfn(JET_VSESID vsesid, JET_VTID vtid)
{
   return(JET_errIllegalOperation);
}


ERR VTAPI ErrIllegalPrepareUpdate(JET_VSESID vsesid, JET_VTID vtid,
	unsigned long prep)
{
   return(JET_errIllegalOperation);
}


ERR VTAPI ErrIllegalRenameColumn(JET_VSESID vsesid, JET_VTID vtid,
	const char __far *szColumn, const char __far *szColumnNew)
{
   return(JET_errIllegalOperation);
}


ERR VTAPI ErrIllegalRenameIndex(JET_VSESID vsesid, JET_VTID vtid,
	const char __far *szIndex, const char __far *szIndexNew)
{
   return(JET_errIllegalOperation);
}


ERR VTAPI ErrIllegalRenameReference(JET_VSESID vsesid, JET_VTID vtid,
	const char __far *szReference, const char __far *szReferenceNew)
{
   return(JET_errIllegalOperation);
}


ERR VTAPI ErrIllegalRetrieveColumn(JET_VSESID vsesid, JET_VTID vtid,
	JET_COLUMNID columnid, void __far *pvData, unsigned long cbData,
	unsigned long __far *pcbActual, JET_GRBIT grbit,
	JET_RETINFO __far *pretinfo)
{
   return(JET_errIllegalOperation);
}


ERR VTAPI ErrIllegalRetrieveKey(JET_VSESID vsesid, JET_VTID vtid,
	void __far *pvKey, unsigned long cbMax,
	unsigned long __far *pcbActual, JET_GRBIT grbit)
{
   return(JET_errIllegalOperation);
}


ERR VTAPI ErrIllegalSeek(JET_VSESID vsesid, JET_VTID vtid,
	JET_GRBIT grbit)
{
   return(JET_errIllegalOperation);
}


ERR VTAPI ErrIllegalSetCurrentIndex(JET_VSESID vsesid, JET_VTID vtid,
	const char __far *szIndexName)
{
   return(JET_errIllegalOperation);
}


ERR VTAPI ErrIllegalSetColumn(JET_VSESID vsesid, JET_VTID vtid,
	JET_COLUMNID columnid, const void __far *pvData,
	unsigned long cbData, JET_GRBIT grbit, JET_SETINFO __far *psetinfo)
{
   return(JET_errIllegalOperation);
}


ERR VTAPI ErrIllegalSetIndexRange(JET_VSESID vsesid, JET_VTID vtid,
	JET_GRBIT grbit)
{
   return(JET_errIllegalOperation);
}


ERR VTAPI ErrIllegalUpdate(JET_VSESID vsesid, JET_VTID vtid,
	void __far *pvBookmark, unsigned long cbBookmark,
	unsigned long __far *pcbActual)
{
   return(JET_errIllegalOperation);
}


ERR VTAPI ErrInvalidAddColumn(JET_VSESID vsesid, JET_VTID vtid,
	const char __far *szColumn, const JET_COLUMNDEF __far *pcolumndef,
	const void __far *pvDefault, unsigned long cbDefault,
	JET_COLUMNID __far *pcolumnid)
{
   return(JET_errInvalidTableId);
}


ERR VTAPI ErrInvalidCloseTable(JET_VSESID vsesid, JET_VTID vtid)
{
   return(JET_errInvalidTableId);
}


ERR VTAPI ErrInvalidComputeStats(JET_VSESID vsesid, JET_VTID vtid)
{
   return(JET_errInvalidTableId);
}

ERR VTAPI ErrInvalidCopyBookmarks(JET_VSESID sesid, JET_VTID vtidSrc,
	JET_TABLEID tableidDest, JET_COLUMNID columnidDest, unsigned long crecMax)
{
   return(JET_errInvalidTableId);
}


ERR VTAPI ErrInvalidCreateIndex(JET_VSESID vsesid, JET_VTID vtid,
	const char __far *szIndexName, JET_GRBIT grbit,
	const char __far *szKey, unsigned long cbKey, unsigned long lDensity)
{
   return(JET_errInvalidTableId);
}


ERR VTAPI ErrInvalidCreateReference(JET_VSESID vsesid, JET_VTID vtid,
	const char __far *szReferenceName, const char __far *szColumns,
	const char __far *szReferencedTable,
	const char __far *szReferencedColumns, JET_GRBIT grbit)
{
   return(JET_errInvalidTableId);
}


ERR VTAPI ErrInvalidDelete(JET_VSESID vsesid, JET_VTID vtid)
{
   return(JET_errInvalidTableId);
}


ERR VTAPI ErrInvalidDeleteColumn(JET_VSESID vsesid, JET_VTID vtid,
	const char __far *szColumn)
{
   return(JET_errInvalidTableId);
}


ERR VTAPI ErrInvalidDeleteIndex(JET_VSESID vsesid, JET_VTID vtid,
	const char __far *szIndexName)
{
   return(JET_errInvalidTableId);
}


ERR VTAPI ErrInvalidDeleteReference(JET_VSESID vsesid, JET_VTID vtid,
	const char __far *szReferenceName)
{
   return(JET_errInvalidTableId);
}


ERR VTAPI ErrInvalidDupCursor(JET_VSESID vsesid, JET_VTID vtid,
	JET_TABLEID __far *ptableid, JET_GRBIT grbit)
{
   return(JET_errInvalidTableId);
}


ERR VTAPI ErrInvalidEmptyTable(JET_VSESID vsesid, JET_VTID vtid)
{
   return(JET_errInvalidTableId);
}


ERR VTAPI ErrInvalidGetBookmark(JET_VSESID vsesid, JET_VTID vtid,
	void __far *pvBookmark, unsigned long cbMax,
	unsigned long __far *pcbActual)
{
   return(JET_errInvalidTableId);
}


ERR VTAPI ErrInvalidGetChecksum(JET_VSESID vsesid, JET_VTID vtid,
	unsigned long __far *pChecksum)
{
   return(JET_errInvalidTableId);
}


ERR VTAPI ErrInvalidGetCurrentIndex(JET_VSESID vsesid, JET_VTID vtid,
	char __far *szIndexName, unsigned long cchIndexName)
{
   return(JET_errInvalidTableId);
}


ERR VTAPI ErrInvalidGetCursorInfo(JET_VSESID vsesid, JET_VTID vtid,
	void __far *pvResult, unsigned long cbMax, unsigned long InfoLevel)
{
   return(JET_errInvalidTableId);
}


ERR VTAPI ErrInvalidGetRecordPosition(JET_VSESID vsesid, JET_VTID vtid,
	JET_RECPOS __far *pkeypos, unsigned long cbKeypos)
{
   return(JET_errInvalidTableId);
}


ERR VTAPI ErrInvalidGetTableColumnInfo(JET_VSESID vsesid, JET_VTID vtid,
	const char __far *szColumnName, void __far *pvResult,
	unsigned long cbMax, unsigned long InfoLevel)
{
   return(JET_errInvalidTableId);
}


ERR VTAPI ErrInvalidGetTableIndexInfo(JET_VSESID vsesid, JET_VTID vtid,
	const char __far *szIndexName, void __far *pvResult,
	unsigned long cbMax, unsigned long InfoLevel)
{
   return(JET_errInvalidTableId);
}


ERR VTAPI ErrInvalidGetTableInfo(JET_VSESID vsesid, JET_VTID vtid,
	void __far *pvResult, unsigned long cbMax, unsigned long InfoLevel)
{
   return(JET_errInvalidTableId);
}


ERR VTAPI ErrInvalidGetTableReferenceInfo(JET_VSESID vsesid, JET_VTID vtid,
	const char __far *szReferenceName, void __far *pvResult,
	unsigned long cbMax, unsigned long InfoLevel)
{
   return(JET_errInvalidTableId);
}


ERR VTAPI ErrInvalidGotoBookmark(JET_VSESID vsesid, JET_VTID vtid,
	void __far *pvBookmark, unsigned long cbBookmark)
{
   return(JET_errInvalidTableId);
}


ERR VTAPI ErrInvalidGotoPosition(JET_VSESID vsesid, JET_VTID vtid,
	JET_RECPOS *precpos)
{
   return(JET_errInvalidTableId);
}


ERR VTAPI ErrInvalidVtIdle(JET_VSESID vsesid, JET_VTID vtid)
{
   return(JET_errInvalidTableId);
}


ERR VTAPI ErrInvalidMakeKey(JET_VSESID vsesid, JET_VTID vtid,
	const void __far *pvData, unsigned long cbData, JET_GRBIT grbit)
{
   return(JET_errInvalidTableId);
}


ERR VTAPI ErrInvalidMove(JET_VSESID vsesid, JET_VTID vtid,
	long cRow, JET_GRBIT grbit)
{
   return(JET_errInvalidTableId);
}


ERR VTAPI ErrInvalidNotifyBeginTrans(JET_VSESID vsesid, JET_VTID vtid)
{
   return(JET_errInvalidTableId);
}


ERR VTAPI ErrInvalidNotifyCommitTrans(JET_VSESID vsesid, JET_VTID vtid,
	JET_GRBIT grbit)
{
   return(JET_errInvalidTableId);
}


ERR VTAPI ErrInvalidNotifyRollback(JET_VSESID vsesid, JET_VTID vtid,
	JET_GRBIT grbit)
{
   return(JET_errInvalidTableId);
}


ERR VTAPI ErrInvalidNotifyUpdateUfn(JET_VSESID vsesid, JET_VTID vtid)
{
   return(JET_errInvalidTableId);
}


ERR VTAPI ErrInvalidPrepareUpdate(JET_VSESID vsesid, JET_VTID vtid,
	unsigned long prep)
{
   return(JET_errInvalidTableId);
}


ERR VTAPI ErrInvalidRenameColumn(JET_VSESID vsesid, JET_VTID vtid,
	const char __far *szColumn, const char __far *szColumnNew)
{
   return(JET_errInvalidTableId);
}


ERR VTAPI ErrInvalidRenameIndex(JET_VSESID vsesid, JET_VTID vtid,
	const char __far *szIndex, const char __far *szIndexNew)
{
   return(JET_errInvalidTableId);
}


ERR VTAPI ErrInvalidRenameReference(JET_VSESID vsesid, JET_VTID vtid,
	const char __far *szReference, const char __far *szReferenceNew)
{
   return(JET_errInvalidTableId);
}


ERR VTAPI ErrInvalidRetrieveColumn(JET_VSESID vsesid, JET_VTID vtid,
	JET_COLUMNID columnid, void __far *pvData, unsigned long cbData,
	unsigned long __far *pcbActual, JET_GRBIT grbit,
	JET_RETINFO __far *pretinfo)
{
   return(JET_errInvalidTableId);
}


ERR VTAPI ErrInvalidRetrieveKey(JET_VSESID vsesid, JET_VTID vtid,
	void __far *pvKey, unsigned long cbMax,
	unsigned long __far *pcbActual, JET_GRBIT grbit)
{
   return(JET_errInvalidTableId);
}


ERR VTAPI ErrInvalidSeek(JET_VSESID vsesid, JET_VTID vtid,
	JET_GRBIT grbit)
{
   return(JET_errInvalidTableId);
}


ERR VTAPI ErrInvalidSetCurrentIndex(JET_VSESID vsesid, JET_VTID vtid,
	const char __far *szIndexName)
{
   return(JET_errInvalidTableId);
}


ERR VTAPI ErrInvalidSetColumn(JET_VSESID vsesid, JET_VTID vtid,
	JET_COLUMNID columnid, const void __far *pvData,
	unsigned long cbData, JET_GRBIT grbit, JET_SETINFO __far *psetinfo)
{
   return(JET_errInvalidTableId);
}


ERR VTAPI ErrInvalidSetIndexRange(JET_VSESID vsesid, JET_VTID vtid,
	JET_GRBIT grbit)
{
   return(JET_errInvalidTableId);
}


ERR VTAPI ErrInvalidUpdate(JET_VSESID vsesid, JET_VTID vtid,
	void __far *pvBookmark, unsigned long cbBookmark,
	unsigned long __far *pcbActual)
{
   return(JET_errInvalidTableId);
}


#endif	/* defined(FLAT) || !defined(RETAIL) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jetconv\defs.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

   defs.h

Abstract:

   Main definitions of the jetconv.exe process

Author:

    Sanjay Anand (SanjayAn)  Nov. 14, 1995

Environment:

    User mode

Revision History:

    Sanjay Anand (SanjayAn) Nov. 14, 1995
        Created

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

#include "locmsg.h"

#define NUM_SERVICES    3
#define MAX_NAME_LEN    20
#define PAD     44444

#define JCONVMUTEXNAME      TEXT("JCMUTEX")

#define JCONVSHAREDMEMNAME  TEXT("JCSHAREDMEM")

#define SYSTEM_ROOT         TEXT("%systemroot%\\system32\\")

#define CONVERT_EXE_PATH    TEXT("%systemroot%\\system32\\upg351db.exe")


#define JCONV_LOG_KEY_PREFIX    TEXT("System\\CurrentControlSet\\Services\\EventLog\\Application\\")

#define WINS_REGISTRY_SERVICE_PATH     TEXT("System\\CurrentControlSet\\Services\\Wins")
#define DHCP_REGISTRY_SERVICE_PATH     TEXT("System\\CurrentControlSet\\Services\\DHCPServer")
#define RPL_REGISTRY_SERVICE_PATH     TEXT("System\\CurrentControlSet\\Services\\RemoteBoot")

#define WINS_REGISTRY_PARAMETERS_PATH     TEXT("System\\CurrentControlSet\\Services\\Wins\\Parameters")
#define DHCP_REGISTRY_PARAMETERS_PATH     TEXT("System\\CurrentControlSet\\Services\\DHCPServer\\Parameters")
#define RPL_REGISTRY_PARAMETERS_PATH     TEXT("System\\CurrentControlSet\\Services\\RemoteBoot\\Parameters")

#define WINS_REGISTRY_DBFILE_PATH    TEXT("DbFileNm")
#define DHCP_REGISTRY_DBFILE_PATH    TEXT("DatabasePath")
#define DHCP_REGISTRY_DBFILE_NAME    TEXT("DatabaseName")
#define RPL_REGISTRY_DBFILE_PATH    TEXT("Directory")

#define WINS_REGISTRY_LOGFILE_PATH   TEXT("LogFilePath")
#define DHCP_REGISTRY_LOGFILE_PATH   TEXT("LogFilePath")
// no such path
// #define RPL_REGISTRY_LOGFILE_PATH   TEXT("LogFilePath")

#define WINS_REGISTRY_BACKUP_PATH   TEXT("BackupDirPath")
#define DHCP_REGISTRY_BACKUP_PATH   TEXT("BackupDatabasePath")
// no such path
// #define RPL_REGISTRY_BACKUP_PATH   TEXT("BackupDatabasePath")

#define DEFAULT_WINS_DBFILE_PATH    TEXT("%systemroot%\\system32\\Wins\\wins.mdb")
#define DEFAULT_DHCP_DBFILE_PATH    TEXT("%systemroot%\\system32\\Dhcp\\dhcp.mdb")
#define DEFAULT_RPL_DBFILE_PATH    TEXT("%systemroot%\\Rpl\\rplsvc.mdb")

#define DEFAULT_WINS_LOGFILE_PATH    TEXT("%systemroot%\\system32\\Wins")
#define DEFAULT_DHCP_LOGFILE_PATH    TEXT("%systemroot%\\system32\\Dhcp")
#define DEFAULT_RPL_LOGFILE_PATH    TEXT("%systemroot%\\Rpl")

#define DEFAULT_WINS_BACKUP_PATH    TEXT("")
#define DEFAULT_DHCP_BACKUP_PATH    TEXT("%systemroot%\\system32\\Dhcp\\Backup")
#define DEFAULT_RPL_BACKUP_PATH    TEXT("%systemroot%\\Rpl\\Backup")

#define DEFAULT_WINS_SYSTEM_PATH    TEXT("%systemroot%\\system32\\Wins\\system.mdb")
#define DEFAULT_DHCP_SYSTEM_PATH    TEXT("%systemroot%\\system32\\Dhcp\\system.mdb")
#define DEFAULT_RPL_SYSTEM_PATH    TEXT("%systemroot%\\Rpl\\system.mdb")

//
// Jet500 to Jet600 definitions, etc.
//

#define CONVERT_EXE_PATH_ESE    TEXT("%systemroot%\\system32\\esentutl.exe")

#define DEFAULT_WINS_BACKUP_PATH_ESE    TEXT("") // TEXT("%systemroot%\\system32\\Wins\\winsb.mdb")
#define DEFAULT_DHCP_BACKUP_PATH_ESE    TEXT("%systemroot%\\system32\\Dhcp\\Backup\\dhcp.mdb")
#define DEFAULT_RPL_BACKUP_PATH_ESE    TEXT("%systemroot%\\Rpl\\Backup\\rplsvc.mdb")

#define DEFAULT_WINS_PRESERVE_PATH_ESE   TEXT("%systemroot%\\system32\\Wins\\40Db\\wins.mdb")
#define DEFAULT_DHCP_PRESERVE_PATH_ESE   TEXT("%systemroot%\\system32\\Dhcp\\40Db\\dhcp.mdb")
#define DEFAULT_RPL_PRESERVE_PATH_ESE    TEXT("")

#if DBG

#define MYDEBUG(_Print) { \
        if (JCDebugLevel == 1) { \
            DbgPrint ("JCONV: "); \
            DbgPrint _Print; \
        } else { \
            printf ("JCONV: "); \
            printf _Print; \
        }\
    }

#else

#define MYDEBUG(_Print)

#endif

typedef enum    _SERVICES {

    DHCP,

    WINS,

    RPL

} SERVICES, *PSERVICES;

typedef struct  _SERVICE_INFO {

    TCHAR   ServiceName[MAX_NAME_LEN];

    BOOLEAN Installed;

    BOOLEAN DefaultDbPath;

    BOOLEAN DefaultLogFilePath;

    BOOLEAN DBConverted;

    BOOLEAN ServiceStarted;

    TCHAR   DBPath[MAX_PATH];

    TCHAR   SystemFilePath[MAX_PATH];

    TCHAR   LogFilePath[MAX_PATH];

    TCHAR   BackupPath[MAX_PATH];

    //
    // ESE has a different backup path specification format
    // Which gives rise to the following spud.
    //
    
    TCHAR   ESEBackupPath[MAX_PATH]; 
    
    TCHAR   ESEPreservePath[MAX_PATH];

    LARGE_INTEGER   DBSize;

} SERVICE_INFO, *PSERVICE_INFO;

typedef struct  _SHARED_MEM {

    BOOLEAN InvokedByService[NUM_SERVICES];

} SHARED_MEM, *PSHARED_MEM;

extern TCHAR   SystemDrive[4];
extern LONG JCDebugLevel;
extern HANDLE   EventLogHandle;
extern PSHARED_MEM shrdMemPtr;
extern HANDLE  hMutex;
extern HANDLE hFileMapping;
extern BOOLEAN  Jet200;

//
// Prototypes
//
NTSTATUS
JCRegisterEventSrc();

NTSTATUS
JCDeRegisterEventSrc();

VOID
JCLogEvent(
    IN DWORD EventId,
    IN LPSTR MsgTypeString1,
    IN LPSTR MsgTypeString2,
    IN LPSTR MsgTypeString3
    );

VOID
JCReadRegistry(
    IN  PSERVICE_INFO   pServiceInfo
    );

VOID
JCGetMutex (
    IN HANDLE mutex,
    IN DWORD To
    );

VOID
JCFreeMutex (
    IN HANDLE mutex
    );

NTSTATUS
JCCallUpg(
    IN  SERVICES Id,
    IN  PSERVICE_INFO   pServiceInfo
    );

DWORD
JCConvert(
    IN  PSERVICE_INFO   pServiceInfo
    );

NTSTATUS
DeleteLogFiles(
               TCHAR * LogFilePath 
               );

DWORD 
PreserveCurrentDb( TCHAR * szBasePath,
                   TCHAR * szSourceDb, 
                   TCHAR * szPreserveDbPath,
                   TCHAR * szPreserveDB 
                   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jetconv\convert.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

   convert.c

Abstract:

   Contains the conversion related routines.

Author:

    Sanjay Anand (SanjayAn)  Nov. 14, 1995

Environment:

    User mode

Revision History:

    Sanjay Anand (SanjayAn) Nov. 14, 1995
        Created

--*/

#include "defs.h"


#define MAX_TRIES  30

NTSTATUS
JCCallUpg(
    IN  SERVICES Id,
    IN  PSERVICE_INFO   pServiceInfo
    )

/*++

Routine Description:

    This routine creates a process to convert a database file.

Arguments:

    Id - service id

    pServiceInfo - Pointer to the service information struct.

Return Value:

    None.

--*/
{
    TCHAR   imageName[] = CONVERT_EXE_PATH;
    TCHAR   exImageName[MAX_PATH];
    TCHAR   curDir[MAX_PATH];
    STARTUPINFO   startInfo;
    PROCESS_INFORMATION   procInfo;
    DWORD   error;
    DWORD   exitCode, size;
    TCHAR   cmdLine[MAX_PATH+1000]="";
    TCHAR   exCmdLine[MAX_PATH+1000];
    TCHAR   temp[MAX_PATH];
    TCHAR   sId[3];

    // upg351db c:\winnt\system32\wins\wins.mdb /e2 /@ /dc:\winnt\system32\jet.dll
    //          /yc:\winnt\system32\wins\system.mdb /lc:\winnt\system32\wins
    //          /bc:\winnt\system32\wins\backup /pc:\winnt\system32\wins\351db

    if ((size = ExpandEnvironmentStrings( imageName,
                                          exImageName,
                                          MAX_PATH)) == 0) {
        error = GetLastError();
        MYDEBUG(("ExpandEnvironmentVaraibles %s returned error: %lx\n", imageName, error));
    }

    strcat(cmdLine, exImageName);
    strcat(cmdLine, " ");

    //
    // Build the command line
    //
    strcat(cmdLine, pServiceInfo[Id].DBPath);
    strcat(cmdLine, " /e");

    sprintf(sId, "%d", Id+1);
    strcat(cmdLine, sId);

    //
    // Passed in to indicate to upg351db that it was called by me and not from cmd line.
    // This is so it can know whether CreateMutex shd fail.
    //
    strcat(cmdLine, " /@");

    strcat(cmdLine, " /d");
    strcat(cmdLine, SYSTEM_ROOT);
    strcat(cmdLine, "jet.dll");
    strcat(cmdLine, " /y");
    strcat(cmdLine, pServiceInfo[Id].SystemFilePath);
    strcat(cmdLine, " /l");
    strcat(cmdLine, pServiceInfo[Id].LogFilePath);

    //
    // WINS does not have a default backup path
    //
    if (pServiceInfo[Id].BackupPath[0] != '\0') {
        strcat(cmdLine, " /b");
        strcat(cmdLine, pServiceInfo[Id].BackupPath);
    }

    strcat(cmdLine, " /p");
    strcpy(temp, pServiceInfo[Id].LogFilePath);
    strcat(temp, "\\351db");

    strcat(cmdLine, temp);

    if ((size = ExpandEnvironmentStrings( cmdLine,
                                          exCmdLine,
                                          MAX_PATH+1000)) == 0) {
        error = GetLastError();
        MYDEBUG(("ExpandEnvironmentVaraibles %s returned error: %lx\n", cmdLine, error));
    }

    if (!GetSystemDirectory( curDir,
                             MAX_PATH)) {

        error = GetLastError();
        MYDEBUG(("GetSystemDirectory returned error: %lx\n", error));
        return error;
    }

    MYDEBUG(("cmdLine: %s\n", exCmdLine));

    memset(&startInfo, 0, sizeof(startInfo));

    startInfo.cb = sizeof(startInfo);

    //
    // Create a process for the convert.exe program.
    //
    if(!CreateProcess(  exImageName,                      // image name
                        exCmdLine,                        // command line
                        (LPSECURITY_ATTRIBUTES )NULL,   // process security attr.
                        (LPSECURITY_ATTRIBUTES )NULL,   // thread security attr.
                        FALSE,                   // inherit handle?
                        0,                              // creation flags
                        (LPVOID )NULL,                  // new environ. block
                        curDir,                         // current directory
                        &startInfo,      // startupinfo
                        &procInfo )) { // process info.

        error = GetLastError();
        MYDEBUG(("CreateProcess returned error: %lx\n", error));
        return error;
    }

    MYDEBUG(("CreateProcess succeeded\n"));

    //
    // Get the exit code of the process to determine if the convert went through.
    //
    do {
        if (!GetExitCodeProcess(procInfo.hProcess,
                                &exitCode)) {
            error = GetLastError();
            MYDEBUG(("GetExitCode returned error: %lx\n", error));
            return error;
        }
    } while ( exitCode == STILL_ACTIVE );

    //
    // If non-zero exit code, report the error
    //
    if (exitCode) {
        MYDEBUG(("ExitCode: %lx\n", exitCode));
        return exitCode;
    }

    return STATUS_SUCCESS ;
}

NTSTATUS
JCCallESE(
    IN  SERVICES Id,
    IN  PSERVICE_INFO   pServiceInfo
    )

/*++

Routine Description:

    This routine creates a process to convert a database file from jet500 to jet600.

Arguments:

    Id - service id

    pServiceInfo - Pointer to the service information struct.

Return Value:

    None.

--*/
{
    TCHAR   imageName[] = CONVERT_EXE_PATH_ESE;
    TCHAR   exImageName[MAX_PATH];
    TCHAR   curDir[MAX_PATH];
    STARTUPINFO   startInfo;
    PROCESS_INFORMATION   procInfo;
    DWORD   error;
    DWORD   exitCode, size;
    TCHAR   cmdLine[MAX_PATH+1000]="";
    TCHAR   exCmdLine[MAX_PATH+1000];
    TCHAR   temp[MAX_PATH];
    TCHAR   sId[3];
    TCHAR   Preserve40DbPath[MAX_PATH];
    TCHAR   Preserve40BasePath[MAX_PATH];
    TCHAR   PreserveBasePath[MAX_PATH];
    TCHAR   PreserveDbPath[MAX_PATH];
    TCHAR   DbFile[MAX_PATH], DbFileName[MAX_PATH];
    HANDLE  HSearch = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA FileData;
    ULONG   index = 0, tries = 0;
    TCHAR   DatabaseFileName[MAX_PATH];
    LPVOID  lpMsgBuf;
    DWORD   MsgLen = 0, Error = 0;

    // eseutil /u c:\winnt\system32\wins\wins.mdb /dc:\winnt\system32\edb.dll
    //         
    if ((size = ExpandEnvironmentStrings( imageName,
                                          exImageName,
                                          MAX_PATH)) == 0) {
        error = GetLastError();
        MYDEBUG(("ExpandEnvironmentVaraibles %s returned error: %lx\n", imageName, error));
    }

    strcat(cmdLine, exImageName);

    strcat(cmdLine, "  /u ");      // u for upgrade

    //
    // Build the command line
    //
    strcat(cmdLine, pServiceInfo[Id].DBPath);
    
    strcat(cmdLine, " /d");
    strcat(cmdLine, SYSTEM_ROOT);
    strcat(cmdLine, "edb500.dll");

    //
    // WINS does not have a default backup path
    //
    if (pServiceInfo[Id].ESEBackupPath[0] != '\0') {
        strcat(cmdLine, " /b");
        strcat(cmdLine, pServiceInfo[Id].ESEBackupPath);
    }

    //
    // Preserve the old database now. WINS does not get preserved
    // because of its cool replication feature.
    //
       
#if 0
    MYDEBUG(("40DbPath = %s\n", pServiceInfo[Id].DBPath));
    MYDEBUG(("SystemFilePath = %s\n", pServiceInfo[Id].SystemFilePath));
    MYDEBUG(("LogFilePAth = %s\n", pServiceInfo[Id].LogFilePath));
    MYDEBUG(("Backup = %s\n", pServiceInfo[Id].BackupPath));
    MYDEBUG(("ESEBackup = %s\n", pServiceInfo[Id].ESEBackupPath));
    MYDEBUG(("ESEPreserve = %s\n", pServiceInfo[Id].ESEPreservePath));
#endif 

    //
    // First get the base path, then get the DB name and append
    // as follows -
    // DBBasePAth   = whatever
    // DBPath       = whatever\wins.mdb
    // 40BasePath   = whatever\40db
    // 40DbPath     = whatever\40db\wins.mdb
    //
    strcpy(PreserveBasePath, pServiceInfo[Id].DBPath);
    
    // now get the base path out
    index = strlen(PreserveBasePath);

    while (index && (L'\\' != PreserveBasePath[index])) {

        index--;

    }
    
    strcpy(DatabaseFileName, &PreserveBasePath[index+1]);
    PreserveBasePath[index] = L'\0';

    // Now get the backup base path.
    strcpy(Preserve40BasePath, PreserveBasePath);
    strcat(Preserve40BasePath, "\\40db\\");

    // The BaseDbPath already exists
    strcpy(PreserveDbPath, pServiceInfo[Id].DBPath);
      
    // Generate the backup database path.
    strcpy(Preserve40DbPath, Preserve40BasePath);
    strcat(Preserve40DbPath, DatabaseFileName);

    MYDEBUG(("40BasePath = %s\n", Preserve40BasePath));
    MYDEBUG(("40DbPath = %s\n", Preserve40DbPath));
    MYDEBUG(("BasePath = %s\n", PreserveBasePath));
    MYDEBUG(("DbPath = %s\n", PreserveDbPath));

wait_for_file:

    if ((HSearch = FindFirstFile( PreserveDbPath, &FileData )) 
                                    == INVALID_HANDLE_VALUE ) {
        MYDEBUG(("File not found yet (%d)! Sleep and try another %d times\n", GetLastError(), (MAX_TRIES - tries))); 
        Sleep(1000);
        tries++; 
        if (tries < MAX_TRIES) {
            goto wait_for_file;
        }

    }

    error = PreserveCurrentDb(PreserveBasePath,
                              PreserveDbPath,
                              Preserve40BasePath,
                              Preserve40DbPath);
       
    if (error != ERROR_SUCCESS) {
       MYDEBUG(("FAILED Preserve Database!\n"));
       return error;
    }

    if ((size = ExpandEnvironmentStrings( cmdLine,
                                          exCmdLine,
                                          MAX_PATH+1000)) == 0) {
        error = GetLastError();
        MYDEBUG(("ExpandEnvironmentVaraibles %s returned error: %lx\n", cmdLine, error));
    }

    if (!GetSystemDirectory( curDir,
                             MAX_PATH)) {

        error = GetLastError();
        MYDEBUG(("GetSystemDirectory returned error: %lx\n", error));
        return error;
    }

    MYDEBUG(("cmdLine: %s\n", exCmdLine));

    memset(&startInfo, 0, sizeof(startInfo));

    startInfo.cb = sizeof(startInfo);

    //
    // Create a process for the convert.exe program.
    //
    if(!CreateProcess(  exImageName,                      // image name
                        exCmdLine,                        // command line
                        (LPSECURITY_ATTRIBUTES )NULL,   // process security attr.
                        (LPSECURITY_ATTRIBUTES )NULL,   // thread security attr.
                        FALSE,                   // inherit handle?
                        0,                              // creation flags
                        (LPVOID )NULL,                  // new environ. block
                        curDir,                         // current directory
                        &startInfo,      // startupinfo
                        &procInfo )) { // process info.

        error = GetLastError();
        MYDEBUG(("CreateProcess returned error: %lx\n", error));
        return error;
    }

    MYDEBUG(("CreateProcess succeeded\n"));

    //
    // Get the exit code of the process to determine if the convert went through.
    //
    do {
        if (!GetExitCodeProcess(procInfo.hProcess,
                                &exitCode)) {
            error = GetLastError();
            MYDEBUG(("GetExitCode returned error: %lx\n", error));
            return error;
        }
    } while ( exitCode == STILL_ACTIVE );

    //
    // If non-zero exit code, report the error
    //
    if (exitCode) {
        MYDEBUG(("ExitCode: %lx\n", exitCode));

        //
        // Check if the file exists
        //
        strcpy(DbFile, SYSTEM_ROOT);
        strcat(DbFile, "edb500.dll");
        if ((size = ExpandEnvironmentStrings( DbFile,
                                              DbFileName,
                                              MAX_PATH)) == 0) {
            error = GetLastError();
            MYDEBUG(("ExpandEnvironmentVaraibles %s returned error: %lx\n", DbFileName, error));
        } else {

            if ((HSearch = FindFirstFile( DbFileName, &FileData )) 
                                            == INVALID_HANDLE_VALUE ) {
                MYDEBUG(("Error: Edb500.dll wasnt found on the DISK! Need to copy from the NT5.0 CDROM.\n"));
 
                FormatMessage( 
                              FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
                              NULL,
                              JC_DB_FAIL_MSG,
                              MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                              (LPTSTR) &lpMsgBuf,
                              0,
                              NULL 
                              );  
                
                if (!MsgLen) {

                    Error = GetLastError();
                    MYDEBUG(("FormatMessage failed with error = (%d)\n", Error ));

                } else {

                    MYDEBUG(("FormatMessage : %d size\n", MsgLen));

                }

                if(MessageBoxEx(NULL, 
                            lpMsgBuf, 
                            __TEXT("Jet Conversion Process"), 
                            MB_SYSTEMMODAL | MB_OK | MB_SETFOREGROUND | MB_SERVICE_NOTIFICATION | MB_ICONSTOP, 
                            MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)) == 0) {
                    DWORD Error;
        
                    Error = GetLastError();
                    MYDEBUG(("MessageBoxEx failed with error = (%d)\n", Error ));
                }
                
                ASSERT(lpMsgBuf);
                LocalFree( lpMsgBuf );

            }

        }
    

        return exitCode;
    }

    return STATUS_SUCCESS ;
}


DWORD
JCConvert(
    IN  PSERVICE_INFO   pServiceInfo
    )

/*++

Routine Description:

    This routine gets the sizes of the dbase files; if there is enough disk space, calls convert
    for each service.

Arguments:

    pServiceInfo - Pointer to the service information struct.

Return Value:

    None.

--*/
{
    SERVICES    i ;

    LARGE_INTEGER   diskspace = {0, 0};
    LARGE_INTEGER   totalsize = {0, 0};
    DWORD   error;
    HANDLE  hFile;
    DWORD   SectorsPerCluster;
    DWORD   BytesPerSector;
    DWORD   NumberOfFreeClusters;
    DWORD   TotalNumberOfClusters;
    TCHAR   eventStr[MAX_PATH];
    DWORD       j = 0;
    BOOLEAN     fYetToStart = FALSE;
    BOOLEAN     fFirstTime = TRUE;
    SC_HANDLE   hScmCheck = NULL;

#if 0
    SERVICES    order[NUM_SERVICES];
    SERVICES    k = NUM_SERVICES - 1;
    //
    // Build the service invocation order
    //
    for (i = 0; i < NUM_SERVICES; i++) {
        JCGetMutex(hMutex, INFINITE);

        if (shrdMemPtr->InvokedByService[i]) {
            order[j++] = i;
        } else {
            order[k--] = i;
        }

        JCFreeMutex(hMutex);
    }

#if DBG
    for (i = 0; i < NUM_SERVICES; i++) {
        MYDEBUG(("order[%d]=%d\n", i, order[i]));
    }
#endif
#endif

    do {
        fYetToStart = FALSE;

        //
        // Get the size of the dbase files
        //
        for (j = 0; j < NUM_SERVICES; j++) {
            // i = order[j];
            i = j;

            if (!pServiceInfo[i].Installed ) {
                MYDEBUG(("Service# %d not installed - skipping to next\n", i));
                continue;
            }

            JCGetMutex(hMutex, INFINITE);

            //
            // If JetConv was invoked by this service and it has not been started yet
            //
            if (shrdMemPtr->InvokedByService[i] &&
                !pServiceInfo[i].ServiceStarted) {

                JCFreeMutex(hMutex);
                
                MYDEBUG(("Check if the service has stopped\n"));

                if ((hScmCheck = OpenSCManager(  NULL,	// address of machine name string
                                                 NULL,	// address of database name string
                                                 SC_MANAGER_ALL_ACCESS)) == NULL) { 	// type of access
                    MYDEBUG(("OpenSCManager returned error: %lx\n", GetLastError()));
                    exit(1);
                }

                {
                    SC_HANDLE       hService;
                    SERVICE_STATUS  serviceStatus;
                    TCHAR           eventStr[MAX_PATH];
                    int             numtries = 0;

                    //
                    // Make sure that the service has stopped.
                    //
                    if ((hService = OpenService(    hScmCheck,
                                                    pServiceInfo[i].ServiceName,
                                                    SERVICE_START | SERVICE_QUERY_STATUS)) == NULL) {

                        MYDEBUG(("OpenService: %s returned error: %lx\n", pServiceInfo[i].ServiceName, GetLastError()));
                        
                        //
                        // just mark it as started, so we dont re-try this.
                        //
                        pServiceInfo[i].ServiceStarted = TRUE;
                        
                        CloseServiceHandle(hScmCheck);

                        MYDEBUG(("Marking service: %d as started since the Service cant be opened.\n", i));

                        continue;
                    }

tryagain:
                    if (!QueryServiceStatus(    hService,
                                                &serviceStatus)) {
                        
                        MYDEBUG(("QueryServiceStatus: %s returned error: %lx\n", pServiceInfo[i].ServiceName, GetLastError()));
                        //
                        // just mark it as started, so we dont re-try this.
                        //
                        pServiceInfo[i].ServiceStarted = TRUE;

                        MYDEBUG(("Marking service: %d as started since we cant query it.\n", i));

                        continue;
                    }

                    if ((SERVICE_RUNNING == serviceStatus.dwCurrentState) || 
                        (SERVICE_STOP_PENDING == serviceStatus.dwCurrentState)) {
                    
                        //
                        // Service is about to stop/start - we wait for it to stop/start completely.
                        //
                        MYDEBUG(("Service (%s) state STOP pending - will loop until it goes down\n", pServiceInfo[i].ServiceName));
                        MYDEBUG(("Sleep(15000)\n"));
                        Sleep(15000);
                        
                        if (++numtries < MAX_TRIES) {
                            goto tryagain;
                        } else {

                            MYDEBUG(("Service (%s) is NOT STOPPING!! We don't bother with it anymore.\n", pServiceInfo[i].ServiceName));
                            
                            pServiceInfo[i].ServiceStarted = TRUE;

                            MYDEBUG(("Marking service: %d as started since we can't STOP it.\n", i));

                            continue;
                        
                        }

                    
                    } else if (SERVICE_STOPPED == serviceStatus.dwCurrentState) {


                        MYDEBUG(("YAY!! Finally stopped.\n"));

                    } else {

                        
                        MYDEBUG(("Service (%s) in state (%d)- will loop until it goes down\n", pServiceInfo[i].ServiceName, 
                                                                    serviceStatus.dwCurrentState));
                        MYDEBUG(("Sleep(15000)\n"));
                        Sleep(15000);


                        if (++numtries < MAX_TRIES) {
                            
                            goto tryagain;
                        
                        } else {

                            MYDEBUG(("Service (%s) is NOT STOPPING!! We don't bother with it anymore.\n", pServiceInfo[i].ServiceName));
    
                            pServiceInfo[i].ServiceStarted = TRUE;

                            MYDEBUG(("Marking service: %d as started since we cant STOP it.\n", i));

                            continue;

                        }

                        MYDEBUG(("Problem! - %s is currently in %d\n", pServiceInfo[i].ServiceName, serviceStatus.dwCurrentState));

                    }

                    CloseServiceHandle(hService);
                    CloseServiceHandle(hScmCheck);

                }
                //
                // Get a handle to the file
                //
                if ((hFile = CreateFile (   pServiceInfo[i].DBPath,
                                            GENERIC_READ,
                                            0,
                                            NULL,
                                            OPEN_EXISTING,
                                            0,
                                            NULL)) == INVALID_HANDLE_VALUE) {
                    MYDEBUG(("Could not get handle to file: %s, %lx\n", pServiceInfo[i].DBPath, GetLastError()));

                    if (pServiceInfo[i].DefaultDbPath) {
                        //
                        // Log event that the default database file is not around
                        //
                        JCLogEvent(JC_COULD_NOT_ACCESS_DEFAULT_FILE, pServiceInfo[i].ServiceName, pServiceInfo[i].DBPath, NULL);
                    } else {
                        //
                        // Log event that the database file in the registry is not around
                        //
                        JCLogEvent(JC_COULD_NOT_ACCESS_FILE, pServiceInfo[i].ServiceName, pServiceInfo[i].DBPath, NULL);
                    }

                    //
                    // If this was not the default path, try the default path
                    //
                    if (!pServiceInfo[i].DefaultDbPath) {
                        TCHAR   tempPath[MAX_PATH];
                        DWORD   size;

                        switch (i) {
                        case DHCP:
                            strcpy(tempPath, DEFAULT_DHCP_DBFILE_PATH);
                            break;
                        case WINS:
                            strcpy(tempPath, DEFAULT_WINS_DBFILE_PATH);
                            break;
                        case RPL:
                            strcpy(tempPath, DEFAULT_RPL_DBFILE_PATH);
                            break;
                        }

                        if ((size = ExpandEnvironmentStrings( tempPath,
                                                              pServiceInfo[i].DBPath,
                                                              MAX_PATH)) == 0) {
                            error = GetLastError();
                            MYDEBUG(("ExpandEnvironmentVaraibles %s returned error: %lx\n", pServiceInfo[i].ServiceName, error));
                        }

                        pServiceInfo[i].DefaultDbPath = TRUE;

                        //
                        // so we recheck this service
                        //
                        j--;
                    } else {
                        //
                        // just mark it as started, so we dont re-try this.
                        //
                        pServiceInfo[i].ServiceStarted = TRUE;

                        MYDEBUG(("Marking service: %d as started since the dbase is not accessible.\n", i));
                    }
                    continue;
                }

                //
                // Try to obtain hFile's huge size.
                //
                if ((pServiceInfo[i].DBSize.LowPart = GetFileSize ( hFile,
                                                                    &pServiceInfo[i].DBSize.HighPart)) == 0xFFFFFFFF) {
                    if ((error = GetLastError()) != NO_ERROR) {

                        sprintf(eventStr, "Could not get size of file: %s, %lx\n", pServiceInfo[i].DBPath, GetLastError());
                        MYDEBUG((eventStr));

                        //
                        // Log event
                        //
                        JCLogEvent(JC_COULD_NOT_ACCESS_FILE, pServiceInfo[i].ServiceName, pServiceInfo[i].DBPath, NULL);

                        continue;
                    }
                }

                totalsize.QuadPart = pServiceInfo[i].DBSize.QuadPart;

                CloseHandle(hFile);

                //
                // Get the free disk space for comparison.
                //

                if (!GetDiskFreeSpace(  SystemDrive,
                                        &SectorsPerCluster,	        // address of sectors per cluster
                                        &BytesPerSector,	        // address of bytes per sector
                                        &NumberOfFreeClusters,	    // address of number of free clusters
                                        &TotalNumberOfClusters)) {

                    sprintf(eventStr, "Could not get free space on: %s, %lx\n", SystemDrive, GetLastError());

                    MYDEBUG((eventStr));

                    //
                    // Log event
                    //
                    JCLogEvent(JC_COULD_NOT_GET_FREE_SPACE, SystemDrive, NULL, NULL);
                }

                diskspace.QuadPart = UInt32x32To64 (NumberOfFreeClusters, SectorsPerCluster * BytesPerSector);

                MYDEBUG(("Disk size: low: %d high: %d\n", diskspace.LowPart, diskspace.HighPart));

                //
                // if there is enough disk space, call convert for this service.
                //
                if (totalsize.QuadPart + PAD < diskspace.QuadPart) {
                    SC_HANDLE   hScm;

                    MYDEBUG(("Enough free space available\n"));

                    if ((hScm = OpenSCManager(  NULL,	// address of machine name string
                                                NULL,	// address of database name string
                                                SC_MANAGER_ALL_ACCESS)) == NULL) { 	// type of access
                        MYDEBUG(("OpenSCManager returned error: %lx\n", GetLastError()));
                        exit(1);
                    }

                    {
                        SC_HANDLE hService;
                        SERVICE_STATUS  serviceStatus;
                        TCHAR           eventStr[MAX_PATH];

                        //
                        // Invoke the services that had their databases converted and that tried to call us.
                        //

                        //
                        // Make sure that the service is not already running
                        //
                        if ((hService = OpenService(    hScm,
                                                        pServiceInfo[i].ServiceName,
                                                        SERVICE_START | SERVICE_QUERY_STATUS)) == NULL) {
                            MYDEBUG(("OpenService: %s returned error: %lx\n", pServiceInfo[i].ServiceName, GetLastError()));
                            continue;
                        }

                        if (!QueryServiceStatus(    hService,
                                                    &serviceStatus)) {
                            MYDEBUG(("QueryServiceStatus: %s returned error: %lx\n", pServiceInfo[i].ServiceName, GetLastError()));
                            continue;
                        }

                        switch (serviceStatus.dwCurrentState) {
                        case SERVICE_STOP_PENDING:
                        case SERVICE_START_PENDING:

                            //
                            // Service is about to stop/start - we wait for it to stop/start completely.
                            //
                            MYDEBUG(("Service state pending - will come later: %s\n", pServiceInfo[i].ServiceName));
                            fYetToStart = TRUE;

                            //
                            // We re-try the service that called us once; else go to the next one.
                            //
                            if (fFirstTime) {
                                MYDEBUG(("Service state pending - re-trying: %s\n", pServiceInfo[i].ServiceName));
                                fFirstTime = FALSE;
                                MYDEBUG(("Sleep(15000)\n"));
                                Sleep(15000);
                                j--;
                            }

                            break;

                        case SERVICE_RUNNING:
                            //
                            // Service is already running - mark it as started
                            //
                            pServiceInfo[i].ServiceStarted = TRUE;
                            break;

                        case SERVICE_STOPPED:
                        default:

                            MYDEBUG(("%s size: low: %d high: %d\n", pServiceInfo[i].ServiceName, pServiceInfo[i].DBSize.LowPart, pServiceInfo[i].DBSize.HighPart));
                           
                            error = ERROR_SUCCESS;


 
                            if (Jet200) {

                               if ((error = JCCallUpg(i, pServiceInfo)) != ERROR_SUCCESS) {
                                  sprintf(eventStr, "%sCONV failed: %lx\n", pServiceInfo[i].ServiceName, error);
                                  MYDEBUG((eventStr));
                                  sprintf(eventStr, "%lx", error);
                                  JCLogEvent(JC_CONVERT_FAILED, pServiceInfo[i].ServiceName, eventStr, NULL);
                               } else {
                                   sprintf(eventStr, "%sCONV passed, converted database %s\n", pServiceInfo[i].ServiceName, pServiceInfo[i].DBPath);
                                   MYDEBUG((eventStr));
                                   JCLogEvent(JC_CONVERTED_SUCCESSFULLY, pServiceInfo[i].ServiceName, pServiceInfo[i].DBPath, pServiceInfo[i].BackupPath);
                                   pServiceInfo[i].DBConverted = TRUE;
                               }
                            }
                                
                            //
                            // Now, we convert to jet600, if the 200 -> 500 was a success - MS
                            // RPL does not want to convert to Jet600, so ESEPreservePath for RPL 
                            // is overloaded with NULL to figure this out.
                            //

                            if (ERROR_SUCCESS == error && pServiceInfo[i].ESEPreservePath[0] != TEXT('\0')) {

                               if ((error = JCCallESE(i, pServiceInfo)) != ERROR_SUCCESS) {
                                  sprintf(eventStr, "%sCONV failed: %lx\n", pServiceInfo[i].ServiceName, error);
                                  MYDEBUG((eventStr));
                                  sprintf(eventStr, "%lx", error);
                                  JCLogEvent(JC_CONVERT2_FAILED, pServiceInfo[i].ServiceName, eventStr, NULL);
                                  //break;
                               } else {
                                  sprintf(eventStr, "%sCONV passed, converted database %s\n", pServiceInfo[i].ServiceName, pServiceInfo[i].DBPath);
                                  MYDEBUG((eventStr));
                                  JCLogEvent(JC_CONVERTED_SUCCESSFULLY, pServiceInfo[i].ServiceName, pServiceInfo[i].DBPath, pServiceInfo[i].BackupPath);
                                  pServiceInfo[i].DBConverted = TRUE;
                                  if (ERROR_SUCCESS != DeleteLogFiles(pServiceInfo[i].LogFilePath)) {
                                     MYDEBUG(("Could not delete log files!\n"));
                                  }
                               }



                                //
                                // If service is not already running, start it.
                                //
                                
                               if (ERROR_SUCCESS == error) {

                                   if (!StartService(  hService,
                                                       0,
                                                       NULL)) {
                                       error = GetLastError();

                                       MYDEBUG(("StartService: %s returned error: %lx\n", pServiceInfo[i].ServiceName, error));
                                       sprintf(eventStr, "%lx", error);
                                       JCLogEvent(JC_COULD_NOT_START_SERVICE, pServiceInfo[i].ServiceName, eventStr, NULL);
                                   } else {
                                       MYDEBUG(("StartService: %s done\n", pServiceInfo[i].ServiceName));
                                   }
                               } else {

                                   MYDEBUG(("NOT starting Service: %s because the conversion failed\n", pServiceInfo[i].ServiceName));

                               }
                            }

                            //
                            // Set this so we dont re-try this service.
                            //
                            pServiceInfo[i].ServiceStarted = TRUE;

                            break;
                        }

                        //
                        // Sleep for a while to let the services stabilize
                        //
                        if (fYetToStart) {
                            MYDEBUG(("Sleep(15000)\n"));
                            Sleep(15000);
                        }
                    }

                    CloseServiceHandle(hScm);

                } else {
                    //
                    // Log an event to indicate that enough space was not available to
                    // do the conversion.
                    //
                    sprintf(eventStr, "Not enough free space on: %s to proceed with conversion of WINS/DHCP/RPL databases\n", SystemDrive);
                    MYDEBUG((eventStr));
                    
                    //
                    // Bug 104808: break the infinite loop if not enough disk space.
                    //
                    error = ERROR_DISK_FULL;
                    fYetToStart = FALSE;
                    
                    //
                    // Search for the installed service here
                    //

                    for ( i = 0; i < NUM_SERVICES; i++) {
                        if (pServiceInfo[i].Installed) {
                            JCLogEvent(JC_SPACE_NOT_AVAILABLE, SystemDrive, NULL, NULL);
                        }
                    }
                }
            } else {

                JCFreeMutex(hMutex);

            }
        }

        if (!fYetToStart) {
            INT i;

            //
            // If there are no pending services, do one last check to see if someone else
            // invoked us in the meantime.
            //

            JCGetMutex(hMutex, INFINITE);
            for (i=0; i<NUM_SERVICES; i++) {
                //
                // If the flag is on, and this is not started yet, then it is a candidate
                // for conversion.
                //
                if (shrdMemPtr->InvokedByService[i] &&
                    !pServiceInfo[i].ServiceStarted) {

                    MYDEBUG(("Service: %d invoked during conversion.\n", i));
                    fYetToStart = TRUE;
                }
            }

            //
            // If still no more invocations, we are done; destroy the shared mem
            //
            if (!fYetToStart) {
                MYDEBUG(("No more Services invoked during conversion.\n"));

                //
                // Destroy the shared mem.
                //
                if (!UnmapViewOfFile(shrdMemPtr)) {
                    MYDEBUG(("UnmapViewOfFile returned error: %lx\n", GetLastError()));
                    exit(1);
                }
                CloseHandle(hFileMapping);

            }

            JCFreeMutex(hMutex);

        }

    } while (fYetToStart);

    return error;
}

/*++

Routine Description:

DeleteLogFiles:   Deletes the log files after a successful conversion in the 
                  main directory. That way, the program that uses the database
                  knows that the conversion was successful.
Arguments:

      Complete path to the directory where the log files exist.

Returns:  NTSTATUS

--*/

NTSTATUS
DeleteLogFiles(TCHAR * LogFilePath )
{
    TCHAR   *FileNameInPath;
    HANDLE  HSearch = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA FileData;
    TCHAR   CurrentDir[ MAX_PATH ];
    DWORD   Error;


    //
    // now move the log files
    //

    if( GetCurrentDirectory( MAX_PATH, CurrentDir ) == 0 ) {

        Error = GetLastError();
        MYDEBUG(("DeleteCurrentDb: GetCurrentDirctory failed, Error = %ld.\n", Error ));
        goto Cleanup;
    
    }

    //
    // set current directory to logfile path.
    //

    if( SetCurrentDirectory( LogFilePath ) == FALSE ) {
        Error = GetLastError();
        MYDEBUG(("DeleteCurrentDb: SetCurrentDirctory failed, Error = %ld.\n", Error ));
        goto Cleanup;
    }

    //
    // Start file search on current dir.
    //

    HSearch = FindFirstFile( "j50*.log", &FileData );

    if( HSearch == INVALID_HANDLE_VALUE ) {
        Error = GetLastError();
        MYDEBUG(("Error: No Log files were found in %s\n", LogFilePath ));
        goto Cleanup;
    }

    //
    // Delete log files
    //

    for( ;; ) {


        if( DeleteFile( FileData.cFileName ) == FALSE ) {

            Error = GetLastError();
            MYDEBUG(("DeleteCurrentDb: could not delete log file, Error = %ld.\n", Error ));
            goto Cleanup;
        }

        //
        // Find next file.
        //

        if ( FindNextFile( HSearch, &FileData ) == FALSE ) {

            Error = GetLastError();

            if( ERROR_NO_MORE_FILES == Error ) {
                break;
            }

            MYDEBUG(("Error: FindNextFile failed, Error = %ld.\n", Error ));
            goto Cleanup;
        }
    }

    Error = ERROR_SUCCESS;

Cleanup:
    
    if( Error != ERROR_SUCCESS ){
        MYDEBUG(("Error deleting log files %ld", Error));
    }

    if( HSearch != INVALID_HANDLE_VALUE ) {
        FindClose( HSearch );
    }
    //
    // reset current currectory.
    //

    SetCurrentDirectory( CurrentDir );

    //
    // always return success!
    //
    return ERROR_SUCCESS;

}



DWORD 
PreserveCurrentDb( TCHAR * InBasePath,
                   TCHAR * InSourceDb, 
                   TCHAR * InPreserveDbPath,
                   TCHAR * InPreserveDb)

/*++

Routine Description:

    Preserve the current DB in a preserve path, so that we can always revert.

Arguments:

   szBasePath
   szSourceDb
   szPreserveDbPath
         Directories from/to preserve
         
Return Value:

    None.

--*/

{
    DWORD   WinError;
    DWORD   FileAttributes;
    TCHAR   TempPath[MAX_PATH];
    TCHAR   Temp2Path[MAX_PATH];
    TCHAR   *FileNameInPath;
    HANDLE HSearch = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA FileData;
    TCHAR    CurrentDir[ MAX_PATH ];
    DWORD   Error, size;
    TCHAR   szBasePath[MAX_PATH];
    TCHAR   szSourceDb[MAX_PATH];
    TCHAR   szPreserveDbPath[MAX_PATH];
    TCHAR   szPreserveDB[MAX_PATH];

    if ((size = ExpandEnvironmentStrings( InBasePath,
                                          szBasePath,
                                          MAX_PATH)) == 0) {
        Error = GetLastError();
        MYDEBUG(("ExpandEnvironmentVaraibles %ws returned error: %lx\n", InBasePath, Error));
        goto Cleanup;
    
    }

    if ((size = ExpandEnvironmentStrings( InSourceDb,
                                          szSourceDb,
                                          MAX_PATH)) == 0) {
       Error = GetLastError();
       MYDEBUG(("ExpandEnvironmentVaraibles %s returned error: %lx\n", InSourceDb, Error));
       goto Cleanup;

    }

    if ((size = ExpandEnvironmentStrings( InPreserveDbPath,
                                          szPreserveDbPath,
                                          MAX_PATH)) == 0) {
       Error = GetLastError();
       MYDEBUG(("ExpandEnvironmentVaraibles %s returned error: %lx\n", InPreserveDbPath, Error));
       goto Cleanup;
    }

    if ((size = ExpandEnvironmentStrings( InPreserveDb,
                                          szPreserveDB,
                                          MAX_PATH)) == 0) {
       Error = GetLastError();
       MYDEBUG(("ExpandEnvironmentVaraibles %s returned error: %lx\n", InPreserveDb, Error));
       goto Cleanup;
    }

    FileAttributes = GetFileAttributes( szPreserveDbPath );

    if( FileAttributes == 0xFFFFFFFF ) {

        WinError = GetLastError();
        if( WinError == ERROR_FILE_NOT_FOUND ) {

            //
            // Create this directory.
            //

            if( !CreateDirectory( szPreserveDbPath, NULL) ) {
               goto Cleanup;
            }

        }
        else {
           goto Cleanup;
        }
    
    }
    
    //
    // move the database file.
    //
    if ( !CopyFile( szSourceDb, 
                    szPreserveDB, 
                    FALSE ) ){
        MYDEBUG(("PreserveCurrentDb: could not save database file: Error %ld\n",GetLastError()));
        MYDEBUG(("Src %s, Dest %s\n",szSourceDb, szPreserveDB));
        goto Cleanup;
    }

    //
    // Start file search on current dir.
    //
    strcpy(Temp2Path, szBasePath);
    strcat(Temp2Path,"\\");
    strcat(Temp2Path,"j*.log");
    HSearch = FindFirstFile( Temp2Path, &FileData );

    if( HSearch == INVALID_HANDLE_VALUE ) {
        Error = GetLastError();
        MYDEBUG(("Error: No Log files were found in %s\n", Temp2Path ));
        goto Cleanup;
    }

    //
    // Move files.
    //

    for( ;; ) {

        strcpy(TempPath, szPreserveDbPath);
        strcat(TempPath,"\\");
        strcat(TempPath, FileData.cFileName );

        strcpy(Temp2Path,szBasePath);
        strcat(Temp2Path,"\\");
        strcat(Temp2Path,FileData.cFileName );

        if( CopyFile( Temp2Path, TempPath, FALSE ) == FALSE ) {

            Error = GetLastError();
            MYDEBUG(("PreserveCurrentDb: could not save log file, Error = %ld.\n", Error ));
            MYDEBUG(("File %s, Src %s, Dest %s\n",FileData.cFileName,Temp2Path,TempPath));
            goto Cleanup;
        }

        //
        // Find next file.
        //

        if ( FindNextFile( HSearch, &FileData ) == FALSE ) {

            Error = GetLastError();

            if( ERROR_NO_MORE_FILES == Error ) {
                break;
            }

//            printf("Error: FindNextFile failed, Error = %ld.\n", Error );
            goto Cleanup;
        }
    }

    Error = ERROR_SUCCESS;

Cleanup:

    if( Error != ERROR_SUCCESS ){
        MYDEBUG(("CONVERT_ERR_PRESERVEDB_FAIL2_ID %x\n", GetLastError()));
    }

    if( HSearch != INVALID_HANDLE_VALUE ) {
        FindClose( HSearch );
    }

    //
    // always return same!
    //
    return Error;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jetconv\makefile.inc ===
locmsg.h locmsg.rc msg00001.bin: locmsg.mc
    mc -d -r .\ locmsg.mc

clean::
    -del locmsg.h locmsg.rc msg00001.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jetconv\main.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

   main.c

Abstract:

   Main module of the jetconv.exe process

Author:

    Sanjay Anand (SanjayAn)  Nov. 14, 1995

Environment:

    User mode

Revision History:

    Sanjay Anand (SanjayAn) Nov. 14, 1995
        Created

    Shreedhar Madhavapeddi (ShreeM) Mar 23, 1997

      * Added code to convert from Jet500 to Jet600 too
      * additional cmdline option to specify the final database format.

--*/

#include "defs.h"

TCHAR   SystemDrive[4];
LONG    JCDebugLevel = 1;
PSHARED_MEM shrdMemPtr = NULL;
HANDLE   hMutex=NULL;
HANDLE   hFileMapping = NULL;
BOOLEAN  Jet200 = FALSE;

void _cdecl
main(
    INT argc,
    CHAR *argv[]
    )

/*++

Routine Description:

    Main routine in the jetconv process.

Arguments:

    argc - 1 or 2

    argv -  If called from any of the services, we get the name of the
            service as the parameter, else if it is invoked from the command
            line, no parameter is passed in.

Return Value:

    None.

--*/
{
    DWORD   error, mutexerr, bConvert;
    SERVICES    i, thisServiceId = NUM_SERVICES;
    SERVICE_INFO   pServiceInfo[NUM_SERVICES] = {
                    {"DHCPServer", FALSE, TRUE, TRUE, FALSE, FALSE, DEFAULT_DHCP_DBFILE_PATH,
                        DEFAULT_DHCP_SYSTEM_PATH, DEFAULT_DHCP_LOGFILE_PATH, DEFAULT_DHCP_BACKUP_PATH,
                        DEFAULT_DHCP_BACKUP_PATH_ESE, DEFAULT_DHCP_PRESERVE_PATH_ESE, 0 },
                    {"WINS", FALSE, TRUE, TRUE, FALSE, FALSE, DEFAULT_WINS_DBFILE_PATH,
                        DEFAULT_WINS_SYSTEM_PATH, DEFAULT_WINS_LOGFILE_PATH, DEFAULT_WINS_BACKUP_PATH,
                        DEFAULT_WINS_BACKUP_PATH_ESE, DEFAULT_WINS_PRESERVE_PATH_ESE, 0 },
                    {"Remoteboot",  FALSE, TRUE, TRUE, FALSE, FALSE, DEFAULT_RPL_DBFILE_PATH,
                        DEFAULT_RPL_SYSTEM_PATH, DEFAULT_RPL_LOGFILE_PATH, DEFAULT_RPL_BACKUP_PATH,
                        DEFAULT_RPL_BACKUP_PATH_ESE, DEFAULT_RPL_PRESERVE_PATH_ESE, 0 }
                    };

    TCHAR   val[2];
    LPVOID  lpMsgBuf;
    ULONG   MsgLen = 0;

    if (GetEnvironmentVariable(TEXT("JetConvDebug"), val, 2*sizeof(TCHAR))) {
        if (strcmp(val, "1")==0) {
            JCDebugLevel = 1;
        } else {
            JCDebugLevel = 2;
        }
    }

    //
    // Invoked only from the three services - WINS/DHCP/RPL with two args - servicename and "/@"
    //
    if ((argc != 4) ||
        ((argc == 4) && _stricmp(argv[3], "/@"))) {

        //
        // Probably called from command line
        //
        LPVOID  lpMsgBuf;

        if (FormatMessage(
                       FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
                       NULL,
                       JC_NOT_ALLOWED_FROM_CMD,
                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                       (LPTSTR) &lpMsgBuf,
                       0,
                       NULL
                       ))
        {
            CharToOemA(lpMsgBuf, lpMsgBuf);
            printf("%s", lpMsgBuf);
            LocalFree(lpMsgBuf);
        }

        exit (1);

    } else {

        MYDEBUG(("Service passed in: %s\n", argv[1]));

        for ( i=0; i < NUM_SERVICES; i++) {
            if (_stricmp(pServiceInfo[i].ServiceName, argv[1]) == 0) {
                thisServiceId = i;
            }
        }

        if (thisServiceId == NUM_SERVICES) {
            MYDEBUG(("Error: Bad service Id passed in\n"));
            exit(1);
        }

        //
        // now find out which database they want to convert to
        //
        if (_stricmp("/200", argv[2]) == 0) {
           Jet200 = TRUE;                // start from jet200
           MYDEBUG(("Converting from Jet200\n"));
        } else if (_stricmp("/500", argv[2]) == 0) {
           Jet200 = FALSE;               // start from jet500
           MYDEBUG(("Converting from Jet500\n"));
        } else {
           MYDEBUG(("Invalid database conversion format parameter: has to be /200 or /500 \n"));
           exit(1);
        }

    }

    if ((hMutex = CreateMutex( NULL,
                               FALSE,
                               JCONVMUTEXNAME)) == NULL) {
        error = GetLastError();
        MYDEBUG(("CreateMutex returned error: %lx\n", error));
        exit (1);
    }

    mutexerr = GetLastError();

    JCGetMutex(hMutex, INFINITE);

    hFileMapping = OpenFileMapping( FILE_MAP_WRITE,
                                    FALSE,
                                    JCONVSHAREDMEMNAME );

    if (hFileMapping) {
        //
        // Another instance of JCONV was already running.
        // Write our service name and exit
        //
        if ((shrdMemPtr = (PSHARED_MEM)MapViewOfFile(   hFileMapping,
                                                        FILE_MAP_WRITE,
                                                        0L,
                                                        0L,
                                                        sizeof(SHARED_MEM))) == NULL) {
            MYDEBUG(("MapViewOfFile returned error: %lx\n", GetLastError()));

            JCFreeMutex(hMutex);

            exit(1);
        }

        if (thisServiceId < NUM_SERVICES) {
            shrdMemPtr->InvokedByService[thisServiceId] = TRUE;
        }

        MYDEBUG(("shrdMemPtr->InvokedByService[i]: %x, %x, %x\n", shrdMemPtr->InvokedByService[0], shrdMemPtr->InvokedByService[1], shrdMemPtr->InvokedByService[2]));

        JCFreeMutex(hMutex);

        exit (1);
    } else {
        if (mutexerr == ERROR_ALREADY_EXISTS) {
            //
            // Upg351Db was running; log an entry and scram.
            //
            MYDEBUG(("Upg351Db already running\n"));

            JCFreeMutex(hMutex);

            exit(1);
        }

        //
        // Create the file mapping.
        //
        hFileMapping = CreateFileMapping(  INVALID_HANDLE_VALUE,
                                            NULL,
                                            PAGE_READWRITE,
                                            0L,
                                            sizeof(SHARED_MEM),
                                            JCONVSHAREDMEMNAME );
        if (hFileMapping) {
            //
            // Write our service name in the shared memory and clear the others.
            //
            if ((shrdMemPtr = (PSHARED_MEM)MapViewOfFile(   hFileMapping,
                                                            FILE_MAP_WRITE,
                                                            0L,
                                                            0L,
                                                            sizeof(SHARED_MEM))) == NULL) {
                MYDEBUG(("MapViewOfFile returned error: %lx\n", GetLastError()));

                JCFreeMutex(hMutex);

                exit(1);
            }

            for (i = 0; i < NUM_SERVICES; i++) {
                shrdMemPtr->InvokedByService[i] = (i == thisServiceId) ? TRUE : FALSE;
                MYDEBUG(("shrdMemPtr->InvokedByService[i]: %x\n", shrdMemPtr->InvokedByService[i]));
            }
        }
        else
        {
            MYDEBUG(("CreateFileMapping returned error: %lx\n", GetLastError()));

            JCFreeMutex(hMutex);

            exit(1);
        }

    }

    JCFreeMutex(hMutex);

    //
    // Find out which services are installed in the system. Fill in the paths
    // to their database files.
    //
    JCReadRegistry(pServiceInfo);

    //
    // Get the sizes of the dbase files; if there is enough disk space, call convert
    // for each service.
    //
    bConvert = JCConvert(pServiceInfo);

    (VOID)JCDeRegisterEventSrc();

    //
    // Destroy the mutex too.
    //
    CloseHandle(hMutex);

    MYDEBUG(("The conversion was OK\n"));

    if (ERROR_SUCCESS == bConvert) {

        DWORD Error;
        TCHAR DeleteDBFile[MAX_PATH];
        TCHAR DeleteDBFileName[MAX_PATH];
        INT size;
        //
        // Popup a dialog and tell the user that it was completed successfully.
        //

        MYDEBUG(("The conversion was OK - 1\n"));

        MsgLen = FormatMessage(
                               FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
                               NULL,
                               (Jet200 ? JC_CONVERTED_FROM_NT351 : JC_CONVERTED_FROM_NT40),
                               MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                               (LPTSTR) &lpMsgBuf,
                               0,
                               NULL
                               );

        if (!MsgLen) {

            Error = GetLastError();
            MYDEBUG(("FormatMessage failed with error = (%d)\n", Error ));
            goto Cleanup;

        } else {

            MYDEBUG(("FormatMessage : %d size\n", MsgLen));

        }

#if 0
    //
    // since dhcp and wins don't throw popups anymore, don't need 
    // popups in jetconv as well
    //
        if(MessageBoxEx(NULL,
                        lpMsgBuf,
                        __TEXT("Jet Conversion Process"),
                        MB_SYSTEMMODAL | MB_OK | MB_SETFOREGROUND | MB_SERVICE_NOTIFICATION | MB_ICONINFORMATION,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)) == 0) {

           Error = GetLastError();
           MYDEBUG(("MessageBoxEx failed with error = (%d)\n", Error ));
        }
#endif
        LocalFree(lpMsgBuf);


        //
        // Delete the edb500.dll, we dont need it anymore
        //
        //
        // Removed code that deleted edb500.dll (trade 500K disk space for support calls).
        // This was in response to bug # 192149

    } else {

        DWORD Error;

        //
        // Popup the error dialog
        //

        MYDEBUG(("The conversion was NOT OK\n"));

        MsgLen = FormatMessage(
                               FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
                               NULL,
                               JC_EVERYTHING_FAILED,
                               MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                               (LPTSTR) &lpMsgBuf,
                               0,
                               NULL
                               );

        if (!MsgLen) {

            Error = GetLastError();
            MYDEBUG(("FormatMessage failed with error = (%d)\n", Error ));
            goto Cleanup;

        } else {

            MYDEBUG(("The String is - %s\n", lpMsgBuf));
            MYDEBUG(("FormatMessage : %d size\n", MsgLen));

        }


        if(MessageBoxEx(NULL,
                        lpMsgBuf,
                        __TEXT("Jet Conversion Process"),
                        MB_SYSTEMMODAL | MB_OK | MB_SETFOREGROUND | MB_SERVICE_NOTIFICATION | MB_ICONSTOP,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)) == 0) {
           DWORD Error;



           Error = GetLastError();
           MYDEBUG(("MessageBoxEx failed with error = (%d)\n", Error ));
        }
        LocalFree(lpMsgBuf);
    }

Cleanup:

    MYDEBUG(("There was a failure in the MessageBoxEx code\n"));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\src\vtmgr.c ===
/***********************************************************************
* Microsoft Jet
*
* Microsoft Confidential.  Copyright 1991-1992 Microsoft Corporation.
*
* Component:
*
* File: vtmgr.c
*
* File Comments:
*
* Revision History:
*
*    [0]  18-Jan-91  richards	Split from isamapi.c
*
***********************************************************************/

#include "std.h"

#include "vtmgr.h"
#include "_vtmgr.h"

DeclAssertFile;


extern const VTFNDEF __far EXPORT vtfndefInvalidTableid;

JET_TABLEID __near tableidFree;
VTDEF	    __near EXPORT rgvtdef[tableidMax];
#ifdef DEBUG
int __far cvtdefFree = 0;
#endif


			/* C6BUG: The functions in this file specify EXPORT because QJET */
			/* C6BUG: fails when compiled with __fastcall under C 6.00A. */

#ifdef DEBUG
PUBLIC void EXPORT MarkTableidExportedR(JET_TABLEID tableid)
	{
//	Assert((tableid < tableidMax) && (rgvtdef[tableid].pvtfndef != &vtfndefInvalidTableid));
	if (tableid != JET_tableidNil)
		rgvtdef[tableid].fExported = fTrue;
	}


PUBLIC BOOL EXPORT FTableidExported(JET_TABLEID tableid)
	{
	if (tableid == JET_tableidNil)
		goto ReturnFalse;
	if (tableid >= tableidMax)
		goto ReturnFalse;
	if (!rgvtdef[tableid].fExported)
		goto ReturnFalse;
	return fTrue;
ReturnFalse:
	/*** PUT BREAKPOINT HERE TO CATCH BOGUS TABLEIDS ***/
	return fFalse;
	}
#endif


PUBLIC void EXPORT ReleaseTableid(JET_TABLEID tableid)
	{
//	Assert((tableid < tableidMax) && (rgvtdef[tableid].pvtfndef != &vtfndefInvalidTableid));

	rgvtdef[tableid].vtid = (JET_VTID) tableidFree;
	rgvtdef[tableid].pvtfndef = &vtfndefInvalidTableid;

	tableidFree = tableid;
#ifdef DEBUG
	cvtdefFree++;
#endif
	}


PUBLIC ERR ErrVtmgrInit(void)
	{
	JET_TABLEID tableid;

	tableidFree = JET_tableidNil;

	for (tableid = (JET_TABLEID) 0; tableid < tableidMax; tableid++)
		ReleaseTableid(tableid);

	return(JET_errSuccess);
	}


PUBLIC ERR EXPORT ErrAllocateTableid(JET_TABLEID __far *ptableid, JET_VTID vtid, const struct tagVTFNDEF __far *pvtfndef)
	{
	JET_TABLEID tableid;

#ifdef DEBUG
	/*** Check for corruption of free list ***/
	{
	JET_TABLEID t = tableidFree;
	while (t != JET_tableidNil)
		{
		Assert(rgvtdef[t].pvtfndef == &vtfndefInvalidTableid);
		t = rgvtdef[t].vtid;
		}
	}
#endif

	if ((*ptableid = tableid = tableidFree) == JET_tableidNil)
		{
		return(JET_errTooManyOpenTables);
		}

	tableidFree = (JET_TABLEID) rgvtdef[tableid].vtid;

	rgvtdef[tableid].vsesid = (JET_VSESID) 0xFFFFFFFF;
	rgvtdef[tableid].vtid = vtid;

	/* CONSIDER: Default should change to JET_acmNoAccess */

	rgvtdef[tableid].pvtfndef = pvtfndef;

#ifdef DEBUG
	rgvtdef[tableid].fExported = fFalse;
	cvtdefFree--;
#endif
	return(JET_errSuccess);
	}


ERR EXPORT ErrGetVtidTableid(JET_SESID sesid, JET_TABLEID tableid, JET_VTID __far *pvtid)
	{
	AssertValidSesid(sesid);

	if ((tableid >= tableidMax) ||
		(rgvtdef[tableid].pvtfndef == &vtfndefInvalidTableid))
		return(JET_errInvalidTableId);

	*pvtid = rgvtdef[tableid].vtid;

	return(JET_errSuccess);
	}



ERR EXPORT ErrSetVtidTableid(JET_SESID sesid, JET_TABLEID tableid, JET_VTID vtid)
	{
	AssertValidSesid(sesid);

	if ((tableid >= tableidMax) ||
		(rgvtdef[tableid].pvtfndef == &vtfndefInvalidTableid))
		return(JET_errInvalidTableId);

	rgvtdef[tableid].vtid = vtid;

	return(JET_errSuccess);
	}


ERR EXPORT ErrGetPvtfndefTableid(JET_SESID sesid, JET_TABLEID tableid, const struct tagVTFNDEF __far * __far *ppvtfndef)
	{
	AssertValidSesid(sesid);

	if ((tableid >= tableidMax) ||
		(rgvtdef[tableid].pvtfndef == &vtfndefInvalidTableid))
		return(JET_errInvalidTableId);

	*ppvtfndef = rgvtdef[tableid].pvtfndef;

	return(JET_errSuccess);
	}


ERR EXPORT ErrSetPvtfndefTableid(JET_SESID sesid, JET_TABLEID tableid, const struct tagVTFNDEF __far *pvtfndef)
	{
	AssertValidSesid(sesid);

	if ((tableid >= tableidMax) ||
		(rgvtdef[tableid].pvtfndef == &vtfndefInvalidTableid))
		return(JET_errInvalidTableId);

	rgvtdef[tableid].pvtfndef = pvtfndef;

	return(JET_errSuccess);
	}


			/* CONSIDER: Replace the following with the ErrGet/Set routines above */

PUBLIC ERR EXPORT ErrUpdateTableid(JET_TABLEID tableid, JET_VTID vtid, const struct tagVTFNDEF __far *pvtfndef)
	{
	if ((tableid >= tableidMax) ||
		(rgvtdef[tableid].pvtfndef == &vtfndefInvalidTableid))
		return(JET_errInvalidTableId);

	rgvtdef[tableid].vtid = vtid;
	rgvtdef[tableid].pvtfndef = pvtfndef;

	return(JET_errSuccess);
	}


			/* CONSIDER: This next routine should die. */

PUBLIC JET_TABLEID EXPORT TableidFromVtid(JET_VTID vtid, const struct tagVTFNDEF __far *pvtfndef)
	{
	static JET_TABLEID tableid;

	if ((rgvtdef[tableid].vtid == vtid) &&
		(rgvtdef[tableid].pvtfndef == pvtfndef) &&
		(tableid < tableidMax))
		return(tableid);

	for (tableid = 0; tableid < tableidMax; tableid++)
		{
		if ((rgvtdef[tableid].vtid == vtid) && (rgvtdef[tableid].pvtfndef == pvtfndef))
			return(tableid);
		}

	/* CONSIDER: Enable Assert(fFalse) when isam\src\sortapi.c is fixed. */

	/* Assert(fFalse); */
	return(JET_tableidNil);
	}


PUBLIC void NotifyBeginTransaction(JET_SESID sesid)
	{
	JET_TABLEID tableid;

	for (tableid = 0; tableid < tableidMax; tableid++)
		if (rgvtdef[tableid].pvtfndef != &vtfndefInvalidTableid)
			ErrDispNotifyBeginTrans(sesid, tableid);
	}


PUBLIC void NotifyCommitTransaction(JET_SESID sesid, JET_GRBIT grbit)
	{
	JET_TABLEID tableid;

	for (tableid = 0; tableid < tableidMax; tableid++)
		if (rgvtdef[tableid].pvtfndef != &vtfndefInvalidTableid)
			ErrDispNotifyCommitTrans(sesid, tableid, grbit);
	}


PUBLIC void NotifyRollbackTransaction(JET_SESID sesid, JET_GRBIT grbit)
	{
	JET_TABLEID tableid;

	for (tableid = 0; tableid < tableidMax; tableid++)
		if (rgvtdef[tableid].pvtfndef != &vtfndefInvalidTableid)
			ErrDispNotifyRollback(sesid, tableid, grbit);
	}


PUBLIC void NotifyUpdateUserFunctions(JET_SESID sesid)
	{
	/* the parameter sesid is not used */
	/* for each sesion, for each tableid, notify update Ufn */

	JET_SESID sesidCur;
	int isib = -1;

	while((isib = IsibNextIsibPsesid(isib, &sesidCur)) != -1)
		{
		JET_TABLEID tableid;
	
		for (tableid = 0; tableid < tableidMax; tableid++)
			if (rgvtdef[tableid].pvtfndef != &vtfndefInvalidTableid)
				ErrDispNotifyUpdateUfn(sesidCur, tableid);
		}
	}


#ifndef RETAIL

CODECONST(char) szOpenVtHdr[] = " Table Id  Session Id    VTID       ACM     Type\r\n";
CODECONST(char) szOpenVtSep[] = "---------- ---------- ---------- ---------- --------------------------------\r\n";
CODECONST(char) szOpenVtFmt[] = "0x%08lX 0x%08lX 0x%08lX 0x%08lX %s\r\n";
CODECONST(char) szVtTypeUnknown[] = "";

void DebugListOpenTables(void)
	{
	JET_TABLEID		tableid;
	const VTFNDEF __far	*pvtfndef;
	const VTDBGDEF __far *pvtdbgdef;
	const char __far	*szVtType;

	DebugWriteString(fTrue, szOpenVtHdr);
	DebugWriteString(fTrue, szOpenVtSep);

	for (tableid = 0; tableid < tableidMax; tableid++)
		{
		pvtfndef = rgvtdef[tableid].pvtfndef;

		if (pvtfndef != &vtfndefInvalidTableid)
			{
			pvtdbgdef = pvtfndef->pvtdbgdef;

			if (pvtdbgdef == NULL)
				szVtType = szVtTypeUnknown;
			else
				szVtType = pvtdbgdef->szName;

			DebugWriteString(fTrue, szOpenVtFmt, tableid, rgvtdef[tableid].vsesid, rgvtdef[tableid].vtid, rgvtdef[tableid].acm, szVtType);
			}
		}
	}

#endif	/* RETAIL */


			/* The following pragma affects the code generated by the C */
			/* compiler for all FAR functions.  Do NOT place any non-API */
			/* functions beyond this point in this file. */

			/* The following APIs are not remoted.	The only reason they */
			/* accept session id's is because DS instancing requires it. */

JET_ERR JET_API JetAllocateTableid(JET_SESID sesid, JET_TABLEID __far *ptableid, JET_VTID vtid, const struct tagVTFNDEF __far *pvtfndef, JET_VSESID vsesid)
	{
	ERR err;

	Assert(UtilGetIsibOfSesid(sesid) != -1);

	err = ErrAllocateTableid(ptableid, vtid, pvtfndef);

	if (err < 0)
		return(err);

	rgvtdef[*ptableid].vsesid = vsesid;

	return(JET_errSuccess);
	}


JET_ERR JET_API JetUpdateTableid(JET_SESID sesid, JET_TABLEID tableid, JET_VTID vtid, const struct tagVTFNDEF __far *pvtfndef)
	{
	Assert(UtilGetIsibOfSesid(sesid) != -1);

	return(ErrUpdateTableid(tableid, vtid, pvtfndef));
	}


JET_ERR JET_API JetReleaseTableid(JET_SESID sesid, JET_TABLEID tableid)
	{
	Assert(UtilGetIsibOfSesid(sesid) != -1);

	if ((tableid >= tableidMax) ||
		(rgvtdef[tableid].pvtfndef == &vtfndefInvalidTableid))
		return(JET_errInvalidTableId);

	ReleaseTableid(tableid);

	return(JET_errSuccess);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\daedebug.h ===
#ifndef DEBUG

#define PrintF()

#endif	/* !DEBUG */

#ifdef	DEBUG

VOID MEMPrintStat( VOID );


typedef struct _statis
	{
	long	l;
	char	*sz;
	} STATIS;
extern STATIS rgstatis[];

#define BFEvictBG		0
#define BFEvictFG		1
#define BFEvictClean	2
#define BFEvictDirty	3
#define istatisMac		4

#define STATS(c)	rgstatis[c].l++

#else	/* !DEBUG */

#define STATS(c)

#endif	/* !DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jetconv\util.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

   util.c

Abstract:

   Contains general functions.

Author:

    Sanjay Anand (SanjayAn)  Nov. 14, 1995

Environment:

    User mode

Revision History:

    Sanjay Anand (SanjayAn) Nov. 14, 1995
        Created

--*/
#include "defs.h"

#define  CONV_LOG_FILE_NAME TEXT("%SystemRoot%\\System32\\jetconv.exe")
#define  CONV_MSGFILE_SKEY  TEXT("EventMessageFile")

HANDLE  EventlogHandle = NULL;

NTSTATUS
JCRegisterEventSrc()
/*++

Routine Description:

    This routine registers JetConv as an eventsource.

Arguments:

    None.

Return Value:

    None.

--*/
{
    TCHAR   temp[] = "JetConv";
    TCHAR   logName[MAX_PATH]=JCONV_LOG_KEY_PREFIX;
    TCHAR   Buff[MAX_PATH];
    LONG    RetVal = ERROR_SUCCESS;
    HKEY    LogRoot;
    DWORD   NewKeyInd;
    DWORD   dwData;

    strcat(logName, temp);

    //
    // Create the registry keys so we can register as an event source
    //

    RetVal =  RegCreateKeyEx(
                HKEY_LOCAL_MACHINE,        //predefined key value
                logName,                //subkey for JetConv
                0,                        //must be zero (reserved)
                TEXT("Class"),                //class -- may change in future
                REG_OPTION_NON_VOLATILE, //non-volatile information
                KEY_ALL_ACCESS,                //we desire all access to the keyo
                NULL,                         //let key have default sec. attributes
                &LogRoot,                //handle to key
                &NewKeyInd                //is it a new key (out arg) -- not
                                        //looked at
                );


    if (RetVal != ERROR_SUCCESS)
    {
        MYDEBUG(("RegCreateKeyEx failed %lx for %s\n", RetVal, logName));
        return(RetVal);
    }


    /*
        Set the event id message file name
    */
    lstrcpy(Buff, CONV_LOG_FILE_NAME);

    /*
       Add the Event-ID message-file name to the subkey
    */
    RetVal = RegSetValueEx(
                        LogRoot,            //key handle
                        CONV_MSGFILE_SKEY,   //value name
                        0,                    //must be zero
                        REG_EXPAND_SZ,            //value type
                        (LPBYTE)Buff,
                        (lstrlen(Buff) + 1) * sizeof(TCHAR)   //length of value data
                         );

    if (RetVal != ERROR_SUCCESS)
    {
        MYDEBUG(("RegSetValueEx failed %lx for %s", RetVal, Buff));
        return(RetVal);
    }

    /*
     Set the supported data types flags
    */
    dwData = EVENTLOG_ERROR_TYPE       |
            EVENTLOG_WARNING_TYPE     |
            EVENTLOG_INFORMATION_TYPE;


    RetVal = RegSetValueEx (
                        LogRoot,            //subkey handle
                        TEXT("TypesSupported"),  //value name
                        0,                    //must be zero
                        REG_DWORD,            //value type
                        (LPBYTE)&dwData,    //Address of value data
                        sizeof(DWORD)            //length of value data
                          );

    if (RetVal != ERROR_SUCCESS)
    {
        MYDEBUG(("RegSetValueEx failed %lx for TypesSupported on %s", RetVal, logName));
        return(RetVal);
    }

    /*
    * Done with the key.  Close it
    */
    RetVal = RegCloseKey(LogRoot);

    if (RetVal != ERROR_SUCCESS)
    {
        MYDEBUG(("RegCloseKey failed %lx\n", RetVal));
        return(RetVal);
    }

    //
    // Register JetConv as an event source
    //
    strcpy(logName, temp);

    if (!(EventlogHandle = RegisterEventSource( NULL,
                                                logName))) {
        MYDEBUG(("RegisterEventSource failed %lx\n", GetLastError()));
        return STATUS_UNSUCCESSFUL;
    } else {
        MYDEBUG(("RegisterEventSource succeeded\n"));
        return STATUS_SUCCESS;
    }
}

NTSTATUS
JCDeRegisterEventSrc()
/*++

Routine Description:

    This routine deregisters eventsources corresponding to those service that
    are installed in the system.

Arguments:

    None.

Return Value:

    NtStatus.

--*/
{
    if (EventlogHandle) {
        if (!DeregisterEventSource(EventlogHandle)) {
            MYDEBUG(("DeregisterEventSource failed:  %lx for %s", GetLastError()));
            return STATUS_UNSUCCESSFUL;
        } else {
            return STATUS_SUCCESS;
        }
    }
    return STATUS_SUCCESS;
}

VOID
JCLogEvent(
    DWORD EventId,
    LPSTR MsgTypeString1,
    LPSTR MsgTypeString2 OPTIONAL,
    LPSTR MsgTypeString3 OPTIONAL
    )

/*++

Routine Description:

    This routine logs an entry in the eventlog.

Arguments:

    EventId - the event identifier

    MsgTypeString1 - string to be output

    MsgTypeString2 - string2 to be output (OPTIONAL)

Return Value:

    None.

--*/
{
    LPSTR   Strings[3];
    WORD    numStr;

    Strings[0] = MsgTypeString1;
    Strings[1] = MsgTypeString2;
    Strings[2] = MsgTypeString3;

    if (MsgTypeString3) {
        numStr = 3;
    } else if (MsgTypeString2) {
        numStr = 2;
    } else {
        numStr = 1;
    }


    if( !ReportEvent(
            EventlogHandle,
            (WORD)EVENTLOG_INFORMATION_TYPE,
            0,            // event category
            EventId,
            NULL,
            numStr,
            0,
            Strings,
            NULL) ) {

        MYDEBUG(("ReportEvent failed %ld.", GetLastError() ));
    }

    return;
}


VOID
JCReadRegistry(
    IN  PSERVICE_INFO   pServiceInfo
    )
/*++

Routine Description:

    This routine reads the registry to determine which of the service
    among WINS, DHCP and RPL are installed. For those installed, it
    fills in the ServiceInfo structure.

Arguments:

    pServiceInfo - Pointer to the service information struct.

Return Value:

    None.

--*/

{
    HKEY    hkey ;
    SERVICES    i ;
    DWORD   type ;
    DWORD   size = 0 ;
    DWORD   error;
    TCHAR   tempPath[MAX_PATH];
    TCHAR   servicePath[MAX_PATH];
    TCHAR   parametersPath[MAX_PATH];
    TCHAR   dbfilePath[MAX_PATH];
    TCHAR   dbfileName[MAX_PATH];
    TCHAR   backupFilePath[MAX_PATH];
    TCHAR   logfilePath[MAX_PATH];
    HANDLE  ServiceHandle, SCHandle;

    for ( i = 0; i < NUM_SERVICES; i++) {

        switch (i) {
        case WINS:
            strcpy(servicePath, WINS_REGISTRY_SERVICE_PATH);
            strcpy(parametersPath, WINS_REGISTRY_PARAMETERS_PATH);
            strcpy(dbfilePath, WINS_REGISTRY_DBFILE_PATH);
            strcpy(logfilePath, WINS_REGISTRY_LOGFILE_PATH);
            strcpy(backupFilePath, WINS_REGISTRY_BACKUP_PATH);

            break;

        case DHCP:
            strcpy(servicePath, DHCP_REGISTRY_SERVICE_PATH);
            strcpy(parametersPath, DHCP_REGISTRY_PARAMETERS_PATH);
            strcpy(dbfilePath, DHCP_REGISTRY_DBFILE_PATH);
            strcpy(dbfileName, DHCP_REGISTRY_DBFILE_NAME);
            // strcpy(logfilePath, DHCP_REGISTRY_LOGFILE_PATH);
            strcpy(backupFilePath, DHCP_REGISTRY_BACKUP_PATH);

            break;

        case RPL:
            strcpy(servicePath, RPL_REGISTRY_SERVICE_PATH);
            strcpy(parametersPath, RPL_REGISTRY_PARAMETERS_PATH);
            strcpy(dbfilePath, RPL_REGISTRY_DBFILE_PATH);

            // no such path
            // strcpy(logfilePath, RPL_REGISTRY_LOGFILE_PATH);
            // strcpy(backupFilePath, RPL_REGISTRY_BACKUP_PATH);

            break;
        }

        //
        // Check if service is installed -  if the service name key is
        // present, it is installed.
        //
        if ((error = RegOpenKey(HKEY_LOCAL_MACHINE,
                                servicePath,
                                &hkey)) != ERROR_SUCCESS) {

            MYDEBUG(("RegOpenKey %s returned error: %lx\n", pServiceInfo[i].ServiceName, error));
            MYDEBUG(("%s not installed\n", pServiceInfo[i].ServiceName));
            pServiceInfo[i].Installed = FALSE;
            continue;

        } else {

            //
            // NtBug: 139281
            // Its likely that the regkey exists, but the service was DISABLED!
            //

            MYDEBUG(("*************************Opening SC Manager\n"));

            SCHandle = OpenSCManager(
                                     NULL,
                                     NULL,
                                     SC_MANAGER_CONNECT |
                                     SC_MANAGER_ENUMERATE_SERVICE |
                                     SC_MANAGER_QUERY_LOCK_STATUS
                                     );

            if( SCHandle != NULL ) {

                ServiceHandle = OpenService(
                                            SCHandle,
                                            pServiceInfo[i].ServiceName,
                                            SERVICE_QUERY_CONFIG
                                            );

                if( ServiceHandle == NULL ) {

                    MYDEBUG(("SCManager tells us that the service %s is cant be opened: %lx!\n", pServiceInfo[i].ServiceName, GetLastError()));
                    pServiceInfo[i].Installed = FALSE;
                    CloseServiceHandle(SCHandle);

                    continue;

                } else {
                    LPQUERY_SERVICE_CONFIG ServiceConfig;
                    DWORD cbBufSize;
                    DWORD cbBytesNeeded;
                    BOOL result = FALSE;

                    cbBytesNeeded = 0;

                    //
                    // First send 0 buffer to figure out what the length needs to be.
                    //
                    result = QueryServiceConfig(
                                       ServiceHandle,	// handle of service
                                       NULL,	// address of service config. structure
                                       0,	// size of service configuration buffer
                                       &cbBytesNeeded 	// address of variable for bytes needed
                                       );

                    if (!result) {

                        MYDEBUG(("QueryService failed due to :%d \n", GetLastError()));

                    } else {

                        MYDEBUG(("QueryService PASSED with NULL. Shouldnt happen.\n"));

                    }

                    ServiceConfig = (LPQUERY_SERVICE_CONFIG) malloc (cbBytesNeeded);
                    cbBufSize = cbBytesNeeded;

                    if (NULL == ServiceConfig) {

                        MYDEBUG(("Can't alloc memory to query the SC\n"));
                        pServiceInfo[i].Installed = FALSE;
                        MYDEBUG(("SERVICE %s is DISABLED\n", pServiceInfo[i].ServiceName));
                        CloseServiceHandle(ServiceHandle);
                        CloseServiceHandle(SCHandle);
                        continue;

                    }

                    if (!QueryServiceConfig(
                                       ServiceHandle,	// handle of service
                                       ServiceConfig,	// address of service config. structure
                                       cbBufSize,	// size of service configuration buffer
                                       &cbBytesNeeded 	// address of variable for bytes needed
                                       )) {

                        free(ServiceConfig);
                        MYDEBUG(("Things didnt work:%lx, %d , %d\n", GetLastError(), cbBufSize, cbBytesNeeded));
                        pServiceInfo[i].Installed = FALSE;
                        MYDEBUG(("SERVICE %s is DISABLED\n", pServiceInfo[i].ServiceName));
                        CloseServiceHandle(ServiceHandle);
                        CloseServiceHandle(SCHandle);
                        continue;


                    } else {

                        if (SERVICE_DISABLED == ServiceConfig->dwStartType) {

                            free(ServiceConfig);
                            pServiceInfo[i].Installed = FALSE;
                            MYDEBUG(("SERVICE %s is DISABLED\n", pServiceInfo[i].ServiceName));
                            CloseServiceHandle(ServiceHandle);
                            CloseServiceHandle(SCHandle);
                            continue;

                        }

                        free(ServiceConfig);

                    }

                    CloseServiceHandle(ServiceHandle);

                }

                CloseServiceHandle(SCHandle);

            } else {

                MYDEBUG(("Cant open SCManager:%;x!\n", GetLastError()));
                MYDEBUG(("%s not installed\n", pServiceInfo[i].ServiceName));
                pServiceInfo[i].Installed = FALSE;
                continue;

            }

        }


        pServiceInfo[i].Installed = TRUE;
        size = MAX_PATH;

        if ((error = JCRegisterEventSrc()) != ERROR_SUCCESS) {
            MYDEBUG(("JCRegisterEventSrc failed\n"));
            pServiceInfo[i].Installed = FALSE;
            continue;
        }

        //
        // Open the parameters key
        //
        if ((error = RegOpenKeyEx(  HKEY_LOCAL_MACHINE,
                                    parametersPath,
                                    0,
                                    KEY_ALL_ACCESS,
                                    &hkey)) != ERROR_SUCCESS) {

            MYDEBUG(("RegOpenKeyEx %s\\Parameters returned error: %lx\n", pServiceInfo[i].ServiceName, error));

        } else {
            //
            // Read in the path to the Dbase file.
            //
            size = MAX_PATH;
            if ((error = RegQueryValueEx(hkey,
                                         dbfilePath,
                                         NULL,
                                         &type,
                                         pServiceInfo[i].DBPath,
                                         &size)) != ERROR_SUCCESS) {

                MYDEBUG(("RegQueryValueEx of %s dbpath failed: %lx\n", pServiceInfo[i].ServiceName, error));

                //
                // If no path parameter, it shd be in %systemroot%\system32\<service> - the path was initialized to
                // the default.
                //
                MYDEBUG(("%s dbfile path not present; assuming it is in %s\n",
                                            pServiceInfo[i].ServiceName, pServiceInfo[i].DBPath));
            } else {

                pServiceInfo[i].DefaultDbPath = FALSE;

                //
                // DHCP splits the name and path
                //
                if (i == DHCP) {
                    TCHAR   dhcpDBFileName[MAX_PATH];

                    //
                    // Copy this path to the logfilepath too.
                    //
                    strcpy(pServiceInfo[i].LogFilePath, pServiceInfo[i].DBPath);

                    //
                    // Read the name too
                    //
                    size = MAX_PATH;
                    if ((error = RegQueryValueEx(hkey,
                                                 dbfileName,
                                                 NULL,
                                                 &type,
                                                 dhcpDBFileName,
                                                 &size)) != ERROR_SUCCESS) {

                        MYDEBUG(("RegQueryValueEx of %s dbName failed: %lx\n", pServiceInfo[i].ServiceName, error));

                        //
                        // If no path parameter, it shd be in %systemroot%\system32\<service> - the path was initialized to
                        // the default.
                        //
                        MYDEBUG(("%s dbfile name not present; assuming it is dhcp.mdb\n",
                                                    pServiceInfo[i].ServiceName));

                        strcat(pServiceInfo[i].DBPath, TEXT("\\dhcp.mdb"));

                    } else {
                        strcat(pServiceInfo[i].DBPath, TEXT("\\"));
                        strcat(pServiceInfo[i].DBPath, dhcpDBFileName);
                    }
                } else if (i == RPL) {

                    //
                    // Copy this path to the logfilepath too.
                    //
                    strcpy(pServiceInfo[i].LogFilePath, pServiceInfo[i].DBPath);

                    //
                    // Copy this path to the backuppath too
                    //
                    strcpy(pServiceInfo[i].BackupPath, pServiceInfo[i].DBPath);
                    strcat(pServiceInfo[i].BackupPath, TEXT("\\backup"));

                    //
                    // The DBFile is always called rplsvc.mdb
                    //
                    strcat(pServiceInfo[i].DBPath, TEXT("\\rplsvc.mdb"));
                }

            }

            //
            // Read in the path to the Log file.
            // In case of RPL, no such paths exist.
            // Assume they are in the same directory as the database files.
            //
            if (i != RPL) {

                //
                // DHCP has no logfilepath
                //
                if (i != DHCP) {
                    size = MAX_PATH;
                    if ((error = RegQueryValueEx(hkey,
                                                 logfilePath,
                                                 NULL,
                                                 &type,
                                                 pServiceInfo[i].LogFilePath,
                                                 &size)) != ERROR_SUCCESS) {

                        MYDEBUG(("RegQueryValueEx of %s logfilepath failed: %lx\n", pServiceInfo[i].ServiceName, error));

                        //
                        // If no path parameter, it shd be in %systemroot%\system32\<service> - the path was initialized to
                        // the default.
                        //
                        MYDEBUG(("%s logfile path not present; assuming it is in %s\n",
                                                    pServiceInfo[i].ServiceName, pServiceInfo[i].LogFilePath));
                    } else {
                        pServiceInfo[i].DefaultLogFilePath = FALSE;
                    }
                }

                //
                // Read in the path to the backup file.
                //

                size = MAX_PATH;
                if ((error = RegQueryValueEx(hkey,
                                             backupFilePath,
                                             NULL,
                                             &type,
                                             pServiceInfo[i].BackupPath,
                                             &size)) != ERROR_SUCCESS) {

                    MYDEBUG(("RegQueryValueEx of %s BackupPath failed: %lx\n", pServiceInfo[i].ServiceName, error));

                    //
                    // If no path parameter, it shd be in %systemroot%\system32\<service> - the path was initialized to
                    // the default.
                    //
                    MYDEBUG(("%s backupfile path not present; assuming it is in %s\n",
                                                pServiceInfo[i].ServiceName, pServiceInfo[i].BackupPath));
                }
            }
        }

        //
        // Expand the environment variables in the path.
        //
        strcpy(tempPath, pServiceInfo[i].DBPath);

        if ((size = ExpandEnvironmentStrings( tempPath,
                                              pServiceInfo[i].DBPath,
                                              MAX_PATH)) == 0) {
            error = GetLastError();
            MYDEBUG(("ExpandEnvironmentVaraibles %s returned error: %lx\n", pServiceInfo[i].ServiceName, error));
        }

        SystemDrive[0] = pServiceInfo[i].DBPath[0];
        SystemDrive[1] = pServiceInfo[i].DBPath[1];
        SystemDrive[2] = pServiceInfo[i].DBPath[2];
        SystemDrive[3] = '\0';

        MYDEBUG(("pServiceInfo[i].DbasePath: %s\n", pServiceInfo[i].DBPath));

        //
        // Expand the environment variables in the log file path.
        //
        strcpy(tempPath, pServiceInfo[i].LogFilePath);

        if ((size = ExpandEnvironmentStrings( tempPath,
                                              pServiceInfo[i].LogFilePath,
                                              MAX_PATH)) == 0) {
            error = GetLastError();
            MYDEBUG(("ExpandEnvironmentVaraibles %s returned error: %lx\n", pServiceInfo[i].ServiceName, error));
        }

        MYDEBUG(("pServiceInfo[i].LogFilePath: %s\n", pServiceInfo[i].LogFilePath));

        //
        // Expand the environment variables in the backup file path.
        //
        strcpy(tempPath, pServiceInfo[i].BackupPath);

        if ((size = ExpandEnvironmentStrings( tempPath,
                                              pServiceInfo[i].BackupPath,
                                              MAX_PATH)) == 0) {
            error = GetLastError();
            MYDEBUG(("ExpandEnvironmentVaraibles %s returned error: %lx\n", pServiceInfo[i].ServiceName, error));
        }

        MYDEBUG(("pServiceInfo[i].BackupPath: %s\n", pServiceInfo[i].BackupPath));
    }

    for ( i = 0; i < NUM_SERVICES; i++) {

        if (pServiceInfo[i].Installed) {

            MYDEBUG(("Service %s is Installed\n", pServiceInfo[i].ServiceName));

        } else {

            MYDEBUG(("Service %s is NOT Installed\n", pServiceInfo[i].ServiceName));

        }
    }

}

VOID
JCGetMutex (
    IN HANDLE hMutex,
    IN DWORD To
    )
/*++

Routine Description:

    This routine waits on a mutex object.

Arguments:

    hMutex - handle to mutex

    To - time to wait

Return Value:

    None.

--*/
{
    if (WaitForSingleObject (hMutex, To) == WAIT_FAILED) {
        MYDEBUG(("WaitForSingleObject failed: %lx\n", GetLastError()));
    }
}

VOID
JCFreeMutex (
    IN HANDLE hMutex
    )

/*++

Routine Description:

    This routine releases a mutex.

Arguments:

    hMutex - handle to mutex

Return Value:

    None.

--*/
{
    if (!ReleaseMutex(hMutex)) {
        MYDEBUG(("ReleaseMutex failed: %lx\n", GetLastError()));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\b71iseng.h ===
//.xlist
//include config.inc
//include cmacros.inc
//.list

// USHORT cchDouble = ; define this appropriately if DBCS is defined

BYTE rgchDouble[] = { 0 };						// Never accessed
BYTE rgchSingle[] = { 186, 186, 142, 154 };	// 2 sets of single to dbl

#define BFirstByteOfDouble(ib)		(*(rgchDouble + (ib)*3))
#define BSecondByteOfDouble(ib)		(*(rgchDouble + (ib)*3 + 1))
#define BThirdByteOfDouble(ib)		(*(rgchDouble + (ib)*3 + 2))

#define BFirstByteForSingle(ib)		rgchSingle[(255 - (ib)) *2]
#define BSecondByteForSingle(ib)		rgchSingle[(255 - (ib)) *2 + 1]


#define BGetTranslation(ib)		(rgbTranslation[ib])
#define BGetAccent(ib)				(rgbAccentMap[ib])

BYTE rgbTranslation[] = 
					{
					0,			// 0
					1,			// 1
					2,			// 2
					3,			// 3
					4,			// 4
					5,			// 5
					6,			// 6
					7,			// 7
					8,			// 8
					9,			// 9
					10,			// 10
					11,			// 11
					12,			// 12
					13,			// 13
					14,			// 14
					15,			// 15
					16,			// 16
					17,			// 17
					18,			// 18
					19,			// 19
					20,			// 20
					21,			// 21
					22,			// 22
					23,			// 23
					24,			// 24
					25,			// 25
					26,			// 26
					27,			// 27
					28,			// 28
					29,			// 29
					30,			// 30
					31,			// 31
					32,			// 32
					33,			// 33
					34,			// 34
					35,			// 35
					36,			// 36
					37,			// 37
					38,			// 38
					39,			// 39
					40,			// 40
					41,			// 41
					42,			// 42
					43,			// 43
					44,			// 44
					45,			// 45
					46,			// 46
					47,			// 47
					48,			// 48
					49,			// 49
					50,			// 50
					51,			// 51
					52,			// 52
					53,			// 53
					54,			// 54
					55,			// 55
					56,			// 56
					57,			// 57
					58,			// 58
					59,			// 59
					60,			// 60
					61,			// 61
					62,			// 62
					63,			// 63
					64,			// 64
					142,			// 65
					144,			// 66
					146,			// 67
					150,			// 68
					154,			// 69
					156,			// 70
					158,			// 71
					160,			// 72
					162,			// 73
					164,			// 74
					166,			// 75
					168,			// 76
					172,			// 77
					174,			// 78
					178,			// 79
					180,			// 80
					182,			// 81
					184,			// 82
					186,			// 83
					188,			// 84
					190,			// 85
					194,			// 86
					196,			// 87
					198,			// 88
					200,			// 89
					202,			// 90
					65,			// 91
					66,			// 92
					67,			// 93
					68,			// 94
					69,			// 95
					70,			// 96
					142,			// 97
					144,			// 98
					146,			// 99
					150,			// 100
					154,			// 101
					156,			// 102
					158,			// 103
					160,			// 104
					162,			// 105
					164,			// 106
					166,			// 107
					168,			// 108
					172,			// 109
					174,			// 110
					178,			// 111
					180,			// 112
					182,			// 113
					184,			// 114
					186,			// 115
					188,			// 116
					190,			// 117
					194,			// 118
					196,			// 119
					198,			// 120
					200,			// 121
					202,			// 122
					71,			// 123
					72,			// 124
					73,			// 125
					74,			// 126
					75,			// 127
					76,			// 128
					77,			// 129
					78,			// 130
					79,			// 131
					80,			// 132
					81,			// 133
					82,			// 134
					83,			// 135
					84,			// 136
					85,			// 137
					86,			// 138
					87,			// 139
					88,			// 140
					89,			// 141
					90,			// 142
					91,			// 143
					92,			// 144
					93,			// 145
					94,			// 146
					95,			// 147
					96,			// 148
					97,			// 149
					98,			// 150
					99,			// 151
					100,			// 152
					101,			// 153
					102,			// 154
					103,			// 155
					104,			// 156
					105,			// 157
					106,			// 158
					107,			// 159
					108,			// 160
					109,			// 161
					110,			// 162
					111,			// 163
					112,			// 164
					113,			// 165
					114,			// 166
					115,			// 167
					116,			// 168
					117,			// 169
					118,			// 170
					119,			// 171
					120,			// 172
					121,			// 173
					122,			// 174
					123,			// 175
					124,			// 176
					125,			// 177
					126,			// 178
					127,			// 179
					128,			// 180
					129,			// 181
					130,			// 182
					131,			// 183
					132,			// 184
					133,			// 185
					134,			// 186
					135,			// 187
					136,			// 188
					137,			// 189
					138,			// 190
					139,			// 191
					142,			// 192
					142,			// 193
					142,			// 194
					142,			// 195
					142,			// 196
					142,			// 197
					254,			// 198
					146,			// 199
					154,			// 200
					154,			// 201
					154,			// 202
					154,			// 203
					162,			// 204
					162,			// 205
					162,			// 206
					162,			// 207
					152,			// 208
					174,			// 209
					178,			// 210
					178,			// 211
					178,			// 212
					178,			// 213
					178,			// 214
					140,			// 215
					208,			// 216
					190,			// 217
					190,			// 218
					190,			// 219
					190,			// 220
					200,			// 221
					204,			// 222
					255,			// 223
					142,			// 224
					142,			// 225
					142,			// 226
					142,			// 227
					142,			// 228
					142,			// 229
					254,			// 230
					146,			// 231
					154,			// 232
					154,			// 233
					154,			// 234
					154,			// 235
					162,			// 236
					162,			// 237
					162,			// 238
					162,			// 239
					152,			// 240
					174,			// 241
					178,			// 242
					178,			// 243
					178,			// 244
					178,			// 245
					178,			// 246
					141,			// 247
					208,			// 248
					190,			// 249
					190,			// 250
					190,			// 251
					190,			// 252
					200,			// 253
					204,			// 254
					200				// 255
					};


BYTE rgbAccentMap[] = 
					{
					1,			// 0
					1,			// 1
					1,			// 2
					1,			// 3
					1,			// 4
					1,			// 5
					1,			// 6
					1,			// 7
					1,			// 8
					1,			// 9
					1,			// 10
					1,			// 11
					1,			// 12
					1,			// 13
					1,			// 14
					1,			// 15
					1,			// 16
					1,			// 17
					1,			// 18
					1,			// 19
					1,			// 20
					1,			// 21
					1,			// 22
					1,			// 23
					1,			// 24
					1,			// 25
					1,			// 26
					1,			// 27
					1,			// 28
					1,			// 29
					1,			// 30
					1,			// 31
					1,			// 32
					1,			// 33
					1,			// 34
					1,			// 35
					1,			// 36
					1,			// 37
					1,			// 38
					1,			// 39
					1,			// 40
					1,			// 41
					1,			// 42
					1,			// 43
					1,			// 44
					1,			// 45
					1,			// 46
					1,			// 47
					1,			// 48
					1,			// 49
					1,			// 50
					1,			// 51
					1,			// 52
					1,			// 53
					1,			// 54
					1,			// 55
					1,			// 56
					1,			// 57
					1,			// 58
					1,			// 59
					1,			// 60
					1,			// 61
					1,			// 62
					1,			// 63
					1,			// 64
					1,			// 65
					1,			// 66
					1,			// 67
					1,			// 68
					1,			// 69
					1,			// 70
					1,			// 71
					1,			// 72
					1,			// 73
					1,			// 74
					1,			// 75
					1,			// 76
					1,			// 77
					1,			// 78
					1,			// 79
					1,			// 80
					1,			// 81
					1,			// 82
					1,			// 83
					1,			// 84
					1,			// 85
					1,			// 86
					1,			// 87
					1,			// 88
					1,			// 89
					1,			// 90
					1,			// 91
					1,			// 92
					1,			// 93
					1,			// 94
					1,			// 95
					1,			// 96
					1,			// 97
					1,			// 98
					1,			// 99
					1,			// 100
					1,			// 101
					1,			// 102
					1,			// 103
					1,			// 104
					1,			// 105
					1,			// 106
					1,			// 107
					1,			// 108
					1,			// 109
					1,			// 110
					1,			// 111
					1,			// 112
					1,			// 113
					1,			// 114
					1,			// 115
					1,			// 116
					1,			// 117
					1,			// 118
					1,			// 119
					1,			// 120
					1,			// 121
					1,			// 122
					1,			// 123
					1,			// 124
					1,			// 125
					1,			// 126
					1,			// 127
					1,			// 128
					1,			// 129
					1,			// 130
					1,			// 131
					1,			// 132
					1,			// 133
					1,			// 134
					1,			// 135
					1,			// 136
					1,			// 137
					1,			// 138
					1,			// 139
					1,			// 140
					1,			// 141
					1,			// 142
					1,			// 143
					1,			// 144
					1,			// 145
					1,			// 146
					1,			// 147
					1,			// 148
					1,			// 149
					1,			// 150
					1,			// 151
					1,			// 152
					1,			// 153
					1,			// 154
					1,			// 155
					1,			// 156
					1,			// 157
					1,			// 158
					1,			// 159
					1,			// 160
					1,			// 161
					1,			// 162
					1,			// 163
					1,			// 164
					1,			// 165
					1,			// 166
					1,			// 167
					1,			// 168
					1,			// 169
					1,			// 170
					1,			// 171
					1,			// 172
					1,			// 173
					1,			// 174
					1,			// 175
					1,			// 176
					1,			// 177
					1,			// 178
					1,			// 179
					1,			// 180
					1,			// 181
					1,			// 182
					1,			// 183
					1,			// 184
					1,			// 185
					1,			// 186
					1,			// 187
					1,			// 188
					1,			// 189
					1,			// 190
					1,			// 191
					3,			// 192
					2,			// 193
					4,			// 194
					6,			// 195
					5,			// 196
					7,			// 197
					1,			// 198
					8,			// 199
					3,			// 200
					2,			// 201
					4,			// 202
					5,			// 203
					3,			// 204
					2,			// 205
					4,			// 206
					5,			// 207
					1,			// 208
					6,			// 209
					3,			// 210
					2,			// 211
					4,			// 212
					6,			// 213
					5,			// 214
					1,			// 215
					1,			// 216
					3,			// 217
					2,			// 218
					4,			// 219
					5,			// 220
					2,			// 221
					1,			// 222
					1,			// 223
					3,			// 224
					2,			// 225
					4,			// 226
					6,			// 227
					5,			// 228
					7,			// 229
					1,			// 230
					8,			// 231
					3,			// 232
					2,			// 233
					4,			// 234
					5,			// 235
					3,			// 236
					2,			// 237
					4,			// 238
					5,			// 239
					1,			// 240
					6,			// 241
					3,			// 242
					2,			// 243
					4,			// 244
					6,			// 245
					5,			// 246
					1,			// 247
					1,			// 248
					3,			// 249
					2,			// 250
					4,			// 251
					5,			// 252
					2,			// 253
					1,			// 254
					5			// 255
					};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\config.h ===
#if DBG
#define DAYTONA 1

#define DEBUG		1

#define NTWINDOWS	1


#else

#define DAYTONA 1

#define RETAIL		1

#define NTWINDOWS	1

#endif

#include <basetsd.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\daeconst.h ===
#define	cpgDatabaseMin			256
#define	cpgDatabaseMax			(1UL << 19)

#define pgnoSystemRoot			((PGNO) 1)
#define itagSystemRoot			0

#define szOn 					"on"

#define szSystem				"system"
#define szTempDir				"temp\\"
#define	szBakExt				".bak"
#define szPatExt				".pat"
#define szLogExt				".log"
#define szChkExt				".chk"
#define szRestoreMap			"restore.map"
#define lGenerationMax			0x100000
#define szAtomicNew				"new"
#define szAtomicOld				"old"
#define szLogRes1				"res1"
#define szLogRes2				"res2"

/* number of pages of system root FDP primary extent
/**/
#define cpgSystemPrimary		((CPG) 1)		

/* discontinuity measurement unit
/**/
#define cpgDiscont				16

/*	default density
/**/
#define ulFILEDefaultDensity   	80				// 80% density
#define ulFILEDensityLeast		20				// 20% density
#define ulFILEDensityMost		100				// 100% density

#define dbidTemp		   		((DBID) 0)
#define dbidMin					((DBID) 0)
#define dbidUserLeast			((DBID) 1)
#define dbidMax					((DBID) 7)

/*	number of buffer hash table entries
/*	should be prime
/**/
#ifdef DAYTONA
#define ipbfMax					2047
#else
#define ipbfMax					16383
#endif

/*	vertical split threshold
/**/
#define cbVSplitThreshold 		400

/*	Engine OBJIDs:
/*
/*	0..0x10000000 reserved for engine use, divided as follows:
/*
/*	0x00000000..0x0000FFFF	reserved for TBLIDs under RED
/*	0x00000000..0x0EFFFFFF	reserved for TBLIDs under BLUE
/*	0x0F000000..0x0FFFFFFF	reserved for container IDs
/*	0x10000000				reserved for ObjectId of DbObject
/*
/*	Client OBJIDs begin at 0x10000001 and go up from there.
/**/

#define objidNil					((OBJID) 0x00000000)
#define objidRoot					((OBJID) 0x0F000000)
#define objidTblContainer 			((OBJID) 0x0F000001)
#define objidDbContainer			((OBJID) 0x0F000002)
#define objidDbObject				((OBJID) 0x10000000)

#define szVerbose					"BLUEVERBOSE"

#define szNull						""

/*	transaction level limits
/**/
#define levelMax					((LEVEL)10)		// all level < 10
#define levelMost					((LEVEL)9)		// max for engine
#define levelUserMost				((LEVEL)7)		// max for user
#define levelMin					((LEVEL)0)

/* Start and max waiting period for WaitTillOldest
/**/
#define ulStartTimeOutPeriod				20
#define ulMaxTimeOutPeriod					6000	/*	6 seconds */

/*	default resource allocation
/**/
#define	cdabDefault				 			100
#define	cbucketLowerThreshold				1
#define cpageDbExtensionDefault				16
#define cpageSEDefault						16
#define	ulThresholdLowDefault				20
#define	ulThresholdHighDefault				80
#define	cBufGenAgeDefault					2
#define	cpibDefault				 			128
#define	cfucbDefault			 			1024
#define	cfcbDefault				 			300
#define	cscbDefault				 			20
#define	cidbDefault				 			(cfcbDefault+cscbDefault)
#define	cbfDefault				 			512
#define	csecLogBufferDefault 	 			20			
#define	csecLogFileSizeDefault 	 			5120
#define	csecLogFlushThresholdDefault 		10
#define	cbucketDefault			 			64
#define	lWaitLogFlushDefault	 			0
#define	lLogFlushPeriodDefault				45
#define	lLGCheckpointPeriodDefault			1024
#define	lLGWaitingUserMaxDefault			3
#define	lPageFragmentDefault	 			8	
#define lBufLRUKCorrelationIntervalDefault	0
#define lBufBatchIOMaxDefault				64
#define lPageReadAheadMaxDefault  			20
#define lAsynchIOMaxDefault					64
#define	cpageTempDBMinDefault 				0

/*	minimum resource settings are defined below:
/**/
#define lMaxBuffersMin						50
#define lAsynchIOMaxMin						8
#define	lLogBufferMin						csecLogBufferDefault
#define	lLogFileSizeMin						64

/*	resource relationships for derived resources
/**/
#define	lCSRPerFUCB							2

/*	system resource requirements
/**/
#define	cpibSystem							4	// bm cleanup, backup, ver, Sync OLC
#define	cbucketSystem						2

/*	vertical split minimum in non-FDP page
/**/
#define	cbVSplitMin							100

/*	code page constants
/**/
#define	usUniCodePage						1200		/* code page for Unicode strings */
#define	usEnglishCodePage					1252		/* code page for English */

/*  langid and country defaults
/**/
#define langidDefault						0x0409
#define countryDefault						1

/*	length of modified page list
/**/
#define		cmpeMax							8192

/*	idle processing constants
/**/
#define icallIdleBMCleanMax 				cmpeMax

/*	wait time for latch/crit conflicts
/**/
#define cmsecWaitGeneric					100
#define cmsecWaitWriteLatch					10
#define cmsecWaitLogFlush				   	1
#define cmsecWaitIOComplete					10

/*	initial thread stack sizes
/**/
#define cbIOStack 			4096
#define cbBMCleanStack 		4096
#define cbRCECleanStack		4096
#define cbBFCleanStack		8192
#define cbFlushLogStack		16384

/*	preread start threshold. this is the number of reads in the same
/*	direction before we start prereading
/**/
#define cbPrereadThresh		16000
#define	lPrereadMost		64

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\cat.h ===
typedef struct _cdesc					/* Column Description */
	{
	char	  		*szColName;			/* Column Name */
	JET_COLTYP		coltyp; 			/* Column Type */
	JET_GRBIT		grbit;				/* Flag bits */
	ULONG		  	ulMaxLen;			/* Max Length of Column */
	} CDESC;

typedef struct _idesc					/* Index Description */
	{
	char			*szIdxName;	  		/* Index Name */
	char			*szIdxKeys;	  		/* Key String */
	JET_GRBIT		grbit;				/* Flag bits */
	} IDESC;

typedef struct {
	const char				*szName;
	CODECONST(CDESC)		*pcdesc;
	CODECONST(IDESC)		*pidesc;
	BYTE					ccolumn;
	BYTE					cindex;
	CPG						cpg;
	JET_COLUMNID		  	*rgcolumnid;
	PGNO					pgnoTableFDP;
	} SYSTABLEDEF;


//  UNDONE:  change #defines to enumerated types?

#define itableSo					0  	       /* MSysObjects */
#define itableSc					1  	       /* MSysColumns */
#define itableSi					2  	       /* MSysIndexes */
#define itableSa					3  	       /* MSysACEs */
#define itableSq					4  	       /* MSysQueries */
#define itableSr					5  	       /* MSysRelationShips */

#define iMSO_Id 					0
#define iMSO_ParentId				1
#define iMSO_Name					2
#define iMSO_Type 					3
#define iMSO_DateCreate 			4
#define iMSO_DateUpdate 			5
#define iMSO_Owner					6
#define iMSO_Flags					7
#define iMSO_Pages					8
#define iMSO_Density				9
#define iMSO_Stats					10

#define iMSC_ObjectId				0
#define iMSC_Name					1
#define iMSC_ColumnId				2
#define iMSC_Coltyp					3
#define iMSC_Length					4
#define iMSC_CodePage				5
#define iMSC_Flags					6
#define iMSC_RecordOffset			7
#define iMSC_Default				8
#define iMSC_POrder					9

#define iMSI_ObjectId				0
#define iMSI_Name					1
#define iMSI_IndexId				2
#define iMSI_Density				3
#define iMSI_LanguageId				4
#define iMSI_Flags					5
#define iMSI_KeyFldIDs				6
#define iMSI_Stats					7
#define iMSI_VarSegMac				8

/* max number of columns
/**/
#define ilineSxMax					11


#if 0
#define CheckTableObject( szTable )						\
	{													\
	ERR			err;									\
	OBJID		objid;									\
	JET_OBJTYP	objtyp; 								\
														\
	err = ErrFindObjidFromIdName( ppib,					\
		dbid,											\
		objidTblContainer,								\
		szTable,										\
		&objid, 										\
		&objtyp );										\
	if ( err >= JET_errSuccess )				  		\
		{												\
		if ( objtyp == JET_objtypQuery )				\
			return ErrERRCheck( JET_errQueryNotSupported );	\
		if ( objtyp == JET_objtypLink ) 				\
			return ErrERRCheck( JET_errLinkNotSupported ); 	\
		if ( objtyp == JET_objtypSQLLink )				\
			return ErrERRCheck( JET_errSQLLinkNotSupported );	\
		}												\
	else												\
		return err;										\
	}
#endif

/*	prototypes
/**/
ERR ErrCATCreate( PIB *ppib, DBID dbid );
ERR ErrCATInsert( PIB *ppib, DBID dbid, INT itable, LINE rgline[], OBJID objid );
ERR ErrCATBatchInsert(
	PIB			*ppib,
	DBID		dbid,
	JET_COLUMNCREATE	*pcolcreate,
	ULONG		cColumns,
	OBJID		objidTable,
	BOOL		fCompacting );
ERR ErrCATDelete( PIB *ppib, DBID dbid, INT itable, CHAR *szName, OBJID objid );
ERR ErrCATReplace(
	PIB			*ppib,
	DBID		dbid,
	INT			itable,
	OBJID		objidTable,
	CHAR		*szName,
	INT			iReplaceField,
	BYTE		*rgbReplaceValue,
	INT			cbReplaceValue);
ERR ErrCATRename(
	PIB			*ppib,
	DBID		dbid,
	CHAR		*szNew,
	CHAR		*szName,
	OBJID		objid,
	INT			itable );
ERR ErrCATTimestamp( PIB *ppib, DBID dbid, OBJID objid );
ERR ErrCATFindObjidFromIdName(
	PIB			*ppib,
	DBID		dbid,
	OBJID		objidParentId,
	const CHAR	*lszName,
	OBJID		*pobjid,
	JET_OBJTYP	*pobjtyp );
ERR ErrCATFindNameFromObjid( PIB *ppib, DBID dbid, OBJID objid, VOID *pv, unsigned long cbMax, unsigned long *pcbActual );
ERR ErrCATGetIndexLangid(
	PIB			*ppib,
	DBID		dbid,
	PGNO		pgnoTable,
	CHAR		*szIndexName,
	USHORT		*pusLanguageid );
ERR ErrCATConstructCATFDB( FDB **ppfdbNew, CHAR *szFileName);
ERR ErrCATTableColumnInfo( PIB *ppib, DBID dbid, OBJID objidTable, TCIB *ptcib, BOOL fSetValue);
ERR ErrCATConstructFDB( PIB *ppib, DBID dbid, PGNO pgnoTableFDP, FDB **ppfdbNew);
ULONG UlCATColumnSize( JET_COLTYP coltyp, INT cbMax, BOOL *pfMaxTruncated);
ERR ErrCATGetTableAllocInfo( PIB *ppib, DBID dbid, PGNO pgnoTable,
	ULONG *pulPages, ULONG *pulDensity );
ERR ErrCATGetIndexAllocInfo( PIB *ppib, DBID dbid, PGNO pgnoTable,
	CHAR *szIndexName, ULONG *pulDensity );
JET_COLUMNID ColumnidCATGetColumnid( INT iTable, INT iField );
PGNO PgnoCATTableFDP( CHAR *szTable );

ERR ErrCATGetCATIndexInfo(
	PIB			*ppib,
	DBID		dbid,
	FCB			**ppfcb,
	FDB			*pfdb,
	PGNO		pgnoTableFDP,
	CHAR		*szTableName,
	BOOL		fCreatingSys );
ERR ErrCATGetIndexInfo(
	PIB			*ppib,
	DBID		dbid,
	FCB			**ppfcb,
	FDB			*pfdb,
	PGNO		pgnoTableFDP );


#define szSysRoot	"MSys"
#define cbSysRoot	strlen(szSysRoot)

INLINE LOCAL BOOL FCATSystemTable( const CHAR *szTableName )
	{
	const CHAR	*szRestOfName;
	LONG		 lResult;

	/*	determine if we are openning a system table
	/**/
	UtilStringCompare( szTableName, cbSysRoot, szSysRoot, cbSysRoot, 0, &lResult );
	if ( lResult == 0 )
		{
		szRestOfName = szTableName + cbSysRoot;
		return UtilCmpName( szRestOfName, szSoTable+cbSysRoot ) == 0  ||
			UtilCmpName( szRestOfName, szScTable+cbSysRoot ) == 0  ||
			UtilCmpName( szRestOfName, szSiTable+cbSysRoot ) == 0;
		}

	return fFalse;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\daestd.h ===
/***********************************************************************
* Microsoft Jet
*
* Microsoft Confidential.  Copyright 1991-1992 Microsoft Corporation.
*
* Component: JET
*
* File: <File description/purpose>
*
* File Comments:
* <comments>
*
* Revision History:
*
*    [0]  27-Jul-94  t-andyg	Created
*
***********************************************************************/


#include "std.h"
#include "daedef.h"
#include "pib.h"
#include "page.h"
#include "fmp.h"
#include "dbapi.h"
#include "ssib.h"
#include "fucb.h"
#include "fcb.h"
#include "scb.h"
#include "fdb.h"
#include "idb.h"
#include "recapi.h"
#include "recint.h"
#include "util.h"
#include "stapi.h"
#include "node.h"
#include "spaceapi.h"
#include "spaceint.h"
#include "dirapi.h"
#include "nver.h"
#include "logapi.h"
#include "log.h"
#include "bm.h"
#include "fileapi.h"
#include "fileint.h"
#include "cat.h"
#include "stats.h"
#include "info.h"
#include "sortapi.h"

#include <stddef.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\bm.h ===
/* structure used by BMExpungelink to fix indexes
/**/
typedef struct _bmfix {
	PIB			*ppib;				/* bm cleanup thread */
	FUCB		*pfucb;				/* cursor to node */
	FUCB		*pfucbSrc;			/* cursor to backlink */
	
	BF			**rgpbf;			/* wait latched buffers required for bmfix */
	INT		  	cpbf;
	INT	  		cpbfMax;

	SRID		sridOld;
	SRID		sridNew;
	} BMFIX;


/* 	structure used by BMDeleteNode
/**/
typedef	struct	_bmdelnode {
	SRID		sridFather;
	PN			pn;
	INT			fUndeletableNodeSeen	:1;
	INT			fConflictSeen			:1;
	INT			fVersionedNodeSeen		:1;
	INT			fNodeDeleted			:1;
	INT			fPageRemoved			:1;
	INT			fLastNode				:1;
	INT			fLastNodeWithLinks		:1;
	INT			fInternalPage			:1;		//	is the current page leaf-level?
	INT			fAttemptToDeleteMaxKey	:1;
	} BMDELNODE;

	
/*	register pages for bookmark cleanup.  To register a page, the pn
/*	of the page, pgno of domain FDP and srid of visible father are
/*	needed.
/**/

ERR ErrMPLInit( VOID );
VOID MPLTerm( VOID );
VOID MPLRegister( FCB *pfcb, SSIB *pssib, PN pn, SRID sridFather );
VOID MPLPurge(DBID dbid);
VOID MPLPurgeFDP( DBID dbid, PGNO pgnoFDP );
VOID MPLPurgePgno( DBID dbid, PGNO pgnoFirst, PGNO pgnoLast );
ERR ErrMPLStatus( VOID );

extern PIB	*ppibBMClean;

ERR ErrBMInit( VOID );
ERR ErrBMTerm( VOID );
ERR ErrBMDoEmptyPage(
	FUCB	*pfucb,
	RMPAGE	*prmpage,
	BOOL	fAllocBuf,
	BOOL	*pfRmParent,
	BOOL	fSkipDelete);
ERR ErrBMDoMerge( FUCB *pfucb, FUCB *pfucbRight, SPLIT *psplit, LRMERGE *plrmerge );
ERR	ErrBMDoMergeParentPageUpdate( FUCB *pfucb, SPLIT *psplit );
ERR ErrBMAddToLatchedBFList( RMPAGE	*prmpage, BF *pbfLatched );
ERR	ErrBMCleanBeforeSplit( PIB *ppib, FCB *pfcb, PN pn );
ERR ErrBMClean( PIB *ppib );
BOOL FBMMaxKeyInPage( FUCB *pfucb ); 

#ifdef DEBUG
VOID AssertNotInMPL( DBID dbid, PGNO pgnoFirst, PGNO pgnoLast );
VOID AssertMPLPurgeFDP( DBID dbid, PGNO pgnoFDP );
BOOL FMPLLookupPN( PN pn );

//#define OLC_DEBUG	1
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\dbcc.h ===
typedef struct tagKEYSTATS
	{
	ULONG	cRecords;
	ULONG	cbMinKey;
	ULONG	cbMaxKey;
	ULONG	cbTotalKey;
	ULONG	cbKeySavings;
	ULONG	cOccurrencesCurKey;

	ULONG	rgcKeyOccurrences[15];
	} KEYSTATS;

typedef struct tagDBCCINFO
	{
	PIB				*ppib;
	DBID			dbid;
	FUCB			*pfucb;
	DBUTIL_OP		op;
	JET_GRBIT  		grbitOptions;

	/*	consistency check information
	/**/
	JET_TABLEID		tableidPageInfo;
	JET_TABLEID		tableidSpaceInfo;

	/*	common information
	/**/
	ULONG			ulIndentLevel;
	CHAR			szDatabase[JET_cbNameMost + 1];
	CHAR			szTable[JET_cbNameMost + 1];
	CHAR			szIndex[JET_cbNameMost + 1];
	} DBCCINFO;


ERR ErrDUMPHeader( CHAR *szDatabase, BOOL fSetState );
ERR ErrDUMPCheckpoint( CHAR *szCheckpoint );

#ifdef DEBUG
ERR ErrDUMPLog( CHAR *szLog );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\daedef.h ===
#ifndef _DAEDEF_H
#define _DAEDEF_H

/*	redirect Asserts in inline code to seem to fire from this file
/**/
#define szAssertFilename	__FILE__

#include "config.h"

/***********************************************************/
/****************** global configuration macros ************/
/***********************************************************/

#define CHECKSUM	 			/* check sum for read/write page validation */
//#define PERFCNT	 			/* enable performance counter */
//#define NO_LOG  				/* log disable */
#define REUSE_DBID	 			/* reuse detached database DBIDs */
//#define CHECK_LOG_VERSION
#define PCACHE_OPTIMIZATION		/* enable all cache optimizations */

#define PREREAD		 			/* try to preread pages when we read in one direction */
#ifdef DEBUG
#ifdef PREREAD
//#define PREREAD_DEBUG
#endif	// PREREAD
#endif	// DEBUG

/***********************************************************/
/******************* declaration macros ********************/
/***********************************************************/

#define VTAPI

#include "daedebug.h"

#ifndef PROFILE
#define LOCAL static
#else
#define LOCAL
#endif


// Hack for OLE-DB - make all functions global and non-inline

#ifdef USE_OLEDB
#undef LOCAL
#undef INLINE
#define LOCAL
#define INLINE
#endif


/***********************************************************/
/************ global types and associated macros ***********/
/***********************************************************/

typedef struct _res			/* resource, defined in sysinit.c and daeutil.h */
	{
	const INT 	cbSize;
	INT			cblockAlloc;
	BYTE 		*pbAlloc;
	INT			cblockAvail;
	BYTE 		*pbAvail;
	INT			iblockCommit;
	INT			iblockFail;
	BYTE		*pbPreferredThreshold;
	} RES;

typedef struct _pib		PIB;
typedef struct _ssib	SSIB;
typedef struct _fucb	FUCB;
typedef struct _csr		CSR;
typedef struct _fcb		FCB;
typedef struct _fdb		FDB;
typedef struct _idb		IDB;
typedef struct _dib		DIB;
typedef struct _rcehead	RCEHEAD;
typedef struct _rce		RCE;
typedef struct _bucket	BUCKET;
typedef struct _dab		DAB;
typedef struct _rmpage	RMPAGE;
typedef struct _bmfix	BMFIX;

typedef unsigned short LANGID;
typedef ULONG			LRID;
typedef ULONG			PROCID;

#define pNil			((void *)0)
#define pbNil			((BYTE *)0)
#define plineNil		((LINE *)0)
#define pkeyNil 		((KEY *)0)
#define ppibNil 		((PIB *)0)
#define pwaitNil		((WAIT *)0)
#define pssibNil		((SSIB *)0)
#define pfucbNil		((FUCB *)0)
#define pcsrNil 		((CSR *)0)
#define pfcbNil 		((FCB *)0)
#define pfdbNil 		((FDB *)0)
#define pfieldNil		((FIELD *)0)
#define pidbNil 		((IDB *)0)
#define pscbNil 		((SCB *)0)
#define procidNil		((PROCID) 0xffff)
#define pbucketNil		((BUCKET *)0)
#define prceheadNil		((RCEHEAD *)0)
#define prceNil			((RCE *)0)
#define pdabNil			((DAB *)0)
#define	prmpageNil		((RMPAGE *) 0)

typedef unsigned long	PGNO;
typedef unsigned long	PGDISCONT;
typedef unsigned long	PN;
#define pnNull			((PN) 0)
#define pgnoNull		((PGNO) 0)

/* UNDONE: should be in storage.h */
#define FVersionPage(pbf)  (pbf->ppage->cVersion)

#define CPG					LONG					/* count of pages */

typedef BYTE				LEVEL;		 		/* transaction levels */
#define levelNil			((LEVEL)0xff)		/*	flag for inactive PIB */

typedef WORD				DBID;
typedef WORD				FID;
typedef SHORT				IDXSEG;

typedef ULONG SRID;
typedef ULONG LINK;

STATIC INLINE PGNO PgnoOfSrid( SRID const srid )
	{
	return srid >> 8;
	}

STATIC INLINE BYTE ItagOfSrid( SRID const srid )
	{
	return *( (BYTE *) &srid );
	}
	
STATIC INLINE SRID SridOfPgnoItag( PGNO const pgno, LONG const itag )
	{
	return (SRID) ( ( pgno << 8 ) | (BYTE) itag );
	}

#define itagNil			( 0x0FFF )
#define sridNull		( 0x000000FF )
#define sridNullLink	( 0 )


/*	position within current series
 *	note order of field is of the essence as log position used by
 *	storage as timestamp, must in ib, isec, lGen order so that we can
 *  use little endian integer comparisons.
 */
typedef struct
	{
	USHORT ib;					/* must be the last so that lgpos can */
	USHORT isec;				/* index of disksec starting logsec	 */
	LONG lGeneration;			/* generation of logsec */
	} LGPOS;					/* be casted to TIME. */

extern LGPOS lgposMax;
extern LGPOS lgposMin;
extern INT fRecovering;			/* to turn off logging during Redo */

#define fRecoveringNone		0
#define fRecoveringRedo		1
#define fRecoveringUndo		2
extern INT fRecoveringMode;		/* where we are in recovering? Redo or Undo phase */

extern char szBaseName[];
extern char szSystemPath[];
extern int  fTempPathSet;
extern char szTempPath[];
extern char szJet[];
extern char szJetLog[];
extern char szJetLogNameTemplate[];
extern char szJetTmp[];
extern char szJetTmpLog[];
extern char szMdbExt[];
extern char szJetTxt[];
	
/***********************************************************/
/*********************** DAE macros ************************/
/***********************************************************/

/*	these are needed for setting columns and tracking indexes
/**/
#define cbitFixed			32
#define cbitVariable		32
#define cbitFixedVariable	(cbitFixed + cbitVariable)
#define cbitTagged			192

#define fidFixedLeast			1
#define fidFixedMost  			(fidVarLeast-1)
#define fidVarLeast				128
#define fidVarMost				(fidTaggedLeast-1)
#define fidTaggedLeast			256
#define fidTaggedMost			(0x7ffe)
#define fidMax					(0x7fff)

#define FFixedFid(fid)			((fid)<=fidFixedMost && (fid)>=fidFixedLeast)
#define FVarFid(fid)			((fid)<=fidVarMost && (fid)>=fidVarLeast)
#define FTaggedFid(fid)			((fid)<=fidTaggedMost && (fid)>=fidTaggedLeast)

STATIC INLINE INT IbFromFid ( FID fid )
	{
	INT ib;
	if ( FFixedFid( fid ) )
		{
		ib = ((fid - fidFixedLeast) % cbitFixed) / 8;
		}
	else if ( FVarFid( fid ) )
		{
		ib = (((fid - fidVarLeast) % cbitVariable) + cbitFixed) / 8;
		}
	else
		{
		Assert( FTaggedFid( fid ) );
		ib = (((fid - fidTaggedLeast) % cbitTagged) + cbitFixedVariable) / 8;
		}
	Assert( ib >= 0 && ib < 32 );
	return ib;
	}

STATIC INLINE INT IbitFromFid ( FID fid )
	{
	INT ibit;
	if ( FFixedFid( fid ) )
		{
		ibit =  1 << ((fid - fidFixedLeast) % 8 );
		}
	else if ( FVarFid( fid ) )
		{
		ibit =  1 << ((fid - fidVarLeast) % 8);
		}
	else
		{
		Assert( FTaggedFid( fid ) );
		ibit =  1 << ((fid - fidTaggedLeast) % 8);
		}
	return ibit;
	}

/*  per database operation counter, qwDBTime is logged, used to compare
 *  with the ulDBTime of a page to decide if a redo of the logged operation
 *  is necessary.
 */
#define qwDBTimeMin	(0x0000000000000000)
#define qwDBTimeMax	(0x0000000fffffffff)

/*  Transaction counter, used to keep track of the oldest transaction.
 */
typedef ULONG		TRX;
#define trxMin		0
#define trxMax		(0xffffffff)

typedef struct
	{
	ULONG cb;
	BYTE *pb;
	} LINE;

STATIC INLINE BOOL FLineNull( LINE const *pline )
	{
	return !pline || !pline->cb || !pline->pb;
	}

STATIC INLINE VOID LineCopy( LINE *plineTo, LINE const *plineFrom )
	{
	plineTo->cb = plineFrom->cb;
	memcpy( plineTo->pb, plineFrom->pb, plineFrom->cb );
	}

STATIC INLINE ULONG CbLine( LINE const *pline )
	{
	return pline ? pline->cb : 0;
	}

typedef LINE KEY;
				
#define FKeyNull					FLineNull
#define KeyCopy						LineCopy
#define CbKey						CbLine

STATIC INLINE BYTE *Pb4ByteAlign( BYTE const *pb )
	{
	return (BYTE *) ( ( (LONG_PTR) pb + 3 ) & ~3 );
	}

STATIC INLINE BYTE *Pb4ByteTruncate( BYTE const *pb )
	{
	return (BYTE *) ( (LONG_PTR) pb & ~3 );
	}
	
typedef struct _threebytes { BYTE b[3]; } THREEBYTES;

/***BEGIN MACHINE DEPENDANT***/
STATIC INLINE VOID ThreeBytesFromL( THREEBYTES *ptb, LONG const l )
	{
	memcpy( ptb, &l, sizeof(THREEBYTES) );
	}

STATIC INLINE VOID LFromThreeBytes( LONG *pl, THREEBYTES *ptb )
	{
	*pl = 0;
	memcpy( pl, ptb, sizeof(THREEBYTES) );
	}

STATIC INLINE VOID KeyFromLong( BYTE *rgbKey, ULONG const ul )
	{
	BYTE *rgbul = (BYTE *) &ul;
	
	rgbKey[3] = rgbul[0];
	rgbKey[2] = rgbul[1];
	rgbKey[1] = rgbul[2];
	rgbKey[0] = rgbul[3];
	}

STATIC INLINE VOID LongFromKey( ULONG *pul, BYTE const *rgbKey )
	{
	BYTE *rgbul = (BYTE *) pul;
	
	rgbul[3] = rgbKey[0];
	rgbul[2] = rgbKey[1];
	rgbul[1] = rgbKey[2];
	rgbul[0] = rgbKey[3];
	}
/***END MACHINE DEPENDANT***/

/***********************************************************/
/******************** general C macros *********************/
/***********************************************************/

#define forever					for(;;)

#define NotUsed(p)				( p==p )

/***********************************************************/
/***** include Jet Project prototypes and constants ********/
/***********************************************************/

#define VOID			void
#define VDBAPI

extern CODECONST(VTFNDEF) vtfndefIsam;
extern CODECONST(VTFNDEF) vtfndefIsamInfo;
extern CODECONST(VTFNDEF) vtfndefTTSortIns;
extern CODECONST(VTFNDEF) vtfndefTTSortRet;
extern CODECONST(VTFNDEF) vtfndefTTBase;

#ifdef DEBUG
JET_TABLEID TableidOfVtid( FUCB *pfucb );
#else
#define TableidOfVtid( pfucb )		( (pfucb)->tableid )
#endif


ERR VTAPI ErrDispPrepareUpdate( JET_SESID sesid, JET_TABLEID tableid,
	JET_GRBIT grbit );
ERR VTAPI ErrDispSetColumn( JET_SESID sesid, JET_TABLEID tableid,
	JET_COLUMNID columnid, const void *pb, unsigned long cb, JET_GRBIT grbit,
	JET_SETINFO *psetinfo );
JET_VSESID UtilGetVSesidOfSesidTableid( JET_SESID sesid, JET_TABLEID tableid );
ERR VTAPI ErrDispCloseTable( JET_SESID sesid, JET_TABLEID tableid );
ERR VTAPI ErrDispUpdate( JET_SESID sesid, JET_TABLEID tableid, void *pb,
	unsigned long cbMax, unsigned long *pcbActual );
ERR VTAPI ErrDispMove( JET_SESID sesid, JET_TABLEID tableid, long crows, JET_GRBIT grbit );

/***********************************************************/
/******************* mutual exclusion **********************/
/***********************************************************/

typedef void * SIG;
typedef void * CRIT;

/*	enable multiple MUTEX resource
/**/
#ifdef SGMUTEX					/* small grain */

#define	ErrSignalCreate( s, sz ) 				ErrUtilSignalCreate( s, sz )
#define	ErrSignalCreateAutoReset( s, sz ) 		ErrUtilSignalCreateAutoReset( s, sz )
#define	SignalReset( s )						UtilSignalReset( s )
#define	SignalSend( s )							UtilSignalSend( s )
#define	SignalWait( s, t ) 						UtilSignalWait( s, t )
#define	SignalWaitEx( s, t, f ) 				UtilSignalWaitEx( s, t, f )
#define	MultipleSignalWait( i, rg, f, t )		UtilMultipleSignalWait( i, rg, f, t )
#define	SignalClose( s )				   		UtilCloseSignal( s )

#define	ErrInitializeCriticalSection( s )  		ErrUtilInitializeCriticalSection( s )
#define	EnterCriticalSection( s ) 				UtilEnterCriticalSection( s )
#define	LeaveCriticalSection( s ) 				UtilLeaveCriticalSection( s )
#define	EnterNestableCriticalSection( s ) 		UtilEnterNestableCriticalSection( s )
#define	LeaveNestableCriticalSection( s )		UtilLeaveNestableCriticalSection( s )
#define	AssertCriticalSection( s )				UtilAssertCrit( s )
#define	AssertNotInCriticalSection( s )			UtilAssertNotInCrit( s )
#define	DeleteCriticalSection( s )				UtilDeleteCriticalSection( s )

#define	LgErrInitializeCriticalSection( s )		JET_errSuccess
#define	LgEnterCriticalSection( s )		  		0
#define	LgLeaveCriticalSection( s )		  		0
#define	LgEnterNestableCriticalSection( s )	  	0
#define	LgLeaveNestableCriticalSection( s )	  	0
#define	LgAssertCriticalSection( s )			0
#define	LgAssertNotInCriticalSection( s )		0
#define	LgDeleteCriticalSection( s )			0
#define HoldCriticalSection( s )				0
#define ReleaseCriticalSection( s )				0

#define	SgErrInitializeCriticalSection			ErrInitalizeCriticalSection
#define	SgEnterCriticalSection				   	EnterCriticalSection
#define	SgLeaveCriticalSection					LeaveCriticalSection
#define	SgEnterNestableCriticalSection		   	EnterNestableCriticalSection
#define	SgLeaveNestableCriticalSection			LeaveNestableCriticalSection
#define	SgAssertCriticalSection			   		AssertCriticalSection
#define	SgAssertNotInCriticalSection			AssertNotInCriticalSection
#define	SgDeleteCriticalSection					DeleteCriticalSection

#else /* !SGMUTEX */

#define	ErrSignalCreate( s, sz ) 			   	ErrUtilSignalCreate( s, sz )
#define	ErrSignalCreateAutoReset( s, sz )		ErrUtilSignalCreateAutoReset( s, sz )
#define	SignalReset( s )					   	UtilSignalReset( s )
#define	SignalSend( s )							UtilSignalSend( s )
#define	SignalWait( s, t ) 						UtilSignalWait( s, t )
#define	SignalWaitEx( s, t, f ) 				UtilSignalWaitEx( s, t, f )
#define	MultipleSignalWait( i, rg, f, t )		UtilMultipleSignalWait( i, rg, f, t )
#define	SignalClose( s )						UtilCloseSignal( s )
#define	ErrInitializeCriticalSection( s )		ErrUtilInitializeCriticalSection( s )
#define	EnterCriticalSection( s )				UtilEnterCriticalSection( s )
#define	LeaveCriticalSection( s )				UtilLeaveCriticalSection( s )
#define	EnterNestableCriticalSection( s ) 		UtilEnterNestableCriticalSection( s )
#define	LeaveNestableCriticalSection( s ) 		UtilLeaveNestableCriticalSection( s )
#define	AssertCriticalSection( s )				UtilAssertCrit( s )
#define	AssertNotInCriticalSection( s )			UtilAssertNotInCrit( s )
#define	DeleteCriticalSection( s )				UtilDeleteCriticalSection( s )

#define	LgErrInitializeCriticalSection			ErrUtilInitializeCriticalSection
#define	LgEnterCriticalSection					UtilEnterCriticalSection
#define	LgLeaveCriticalSection					UtilLeaveCriticalSection
#define	LgEnterNestableCriticalSection			UtilEnterNestableCriticalSection
#define	LgLeaveNestableCriticalSection			UtilLeaveNestableCriticalSection
#define	LgAssertCriticalSection					UtilAssertCrit
#define	LgAssertNotInCriticalSection			UtilAssertNotInCrit
#define	LgDeleteCriticalSection					UtilDeleteCriticalSection
#define LgHoldCriticalSection( s )		\
	{									\
	UtilAssertCrit( s );				\
	UtilHoldCriticalSection( s );		\
	}
#define LgReleaseCriticalSection( s )	\
	{									\
	UtilAssertCrit( s );				\
	UtilReleaseCriticalSection( s );	\
	}

#define	SgErrInitializeCriticalSection( s )		JET_errSuccess
#define	SgEnterCriticalSection( s )		  		0
#define	SgLeaveCriticalSection( s )		  		0
#define	SgEnterNestableCriticalSection( s )	  	0
#define	SgLeaveNestableCriticalSection( s )	  	0
#define	SgAssertCriticalSection( s )			0
#define	SgAssertNotInCriticalSection( s )		0
#define	SgDeleteCriticalSection( s )			0

#endif /* !SGMUTEX */

/*	include other global DAE headers
/**/
#include	"daeconst.h"

#define	fSTInitNotDone		0
#define fSTInitInProgress 	1
#define	fSTInitDone			2
extern BOOL  fSTInit;

#pragma pack(1)
typedef struct
	{
	ULONG	cDiscont;
	ULONG	cUnfixedMessyPage;
	} P_OLC_DATA;


#define MAX_COMPUTERNAME_LENGTH 15

typedef struct
	{
	BYTE		bSeconds;				//	0 - 60
	BYTE		bMinutes;				//	0 - 60
	BYTE		bHours;					//	0 - 24
	BYTE		bDay;					//	1 - 31
	BYTE		bMonth;					//	0 - 11
	BYTE		bYear;					//	current year - 1900
	BYTE		bFiller1;
	BYTE		bFiller2;
	} LOGTIME;

typedef struct _signiture
	{
	ULONG		ulRandom;			/*	a random number */
	LOGTIME		logtimeCreate;		/*	time db created, in logtime format */
	BYTE		szComputerName[ MAX_COMPUTERNAME_LENGTH + 1 ];	/* where db is created */
	} SIGNATURE;

typedef struct _bkinfo
	{
	LGPOS		lgposMark;			/*	id for this backup */
	LOGTIME		logtimeMark;
	ULONG		genLow;
	ULONG		genHigh;
	} BKINFO;

/*	Magic number used in database header for integrity checking
/**/
#define ulDAEMagic					0x89abcdef
#define ulDAEVersion				0x00000500
#define ulDAEPrevVersion			0x00000400	/* temporary to make exchange compatible */

#define fDBStateJustCreated			1
#define fDBStateInconsistent		2
#define fDBStateConsistent			3

typedef struct _dbfilehdr_fixed
	{
	ULONG		ulChecksum;		/*	checksum of the 4k page						*/
	ULONG		ulMagic;		/*	Magic number								*/
	ULONG		ulVersion;		/*	version of DAE the db created				*/
	SIGNATURE	signDb;			/*	signature of the db (incl. creation time).	*/

	ULONG		grbitAttributes;/*	attributes of the db						*/
	
	ULONG		ulDBTimeLow;	/*	low ulDBTime of this database				*/
								/*	keep it here for backward compatibility		*/

	ULONG		fDBState;		/*	consistent/inconsistent state				*/
	
	LGPOS		lgposConsistent;/*	null if in inconsistent state				*/
	LOGTIME		logtimeConsistent;/* null if in inconsistent state				*/

	LOGTIME		logtimeAttach;	/*	Last attach time.							*/
	LGPOS		lgposAttach;

	LOGTIME		logtimeDetach;	/*	Last detach time.							*/
	LGPOS		lgposDetach;

	DBID		dbid;			/*	current db attachment.						*/
	SIGNATURE	signLog;		/*	log signature for this attachments			*/

	BKINFO		bkinfoFullPrev;	/*	Last successful full backup.				*/

	BKINFO		bkinfoIncPrev;	/*	Last successful Incremental backup.			*/
								/*	Reset when bkinfoFullPrev is set			*/
	BKINFO		bkinfoFullCur;	/*	current backup. Succeed if a				*/
								/*	corresponding pat file generated.			*/

	ULONG		ulDBTimeHigh;	/*	DBTime										*/

	} DBFILEHDR_FIXED;


#define cbPage	 		4096	 	// database logical page size

typedef struct _dbfilehdr
	{
	DBFILEHDR_FIXED;
	BYTE		rgbFiller[ cbPage - sizeof( DBFILEHDR_FIXED ) ];
	} DBFILEHDR;

#pragma pack()

STATIC INLINE VOID DBHDRSetDBTime( DBFILEHDR *pdbfilehdr, QWORD qwDBTime )
	{
	QWORDX qwx;
	qwx.qw = qwDBTime;
	pdbfilehdr->ulDBTimeLow = qwx.l;
	pdbfilehdr->ulDBTimeHigh = qwx.h;
	}

STATIC INLINE QWORD QwDBHDRDBTime( DBFILEHDR *pdbfilehdr )
	{
	QWORDX qwx;
	qwx.l = pdbfilehdr->ulDBTimeLow;
	qwx.h = pdbfilehdr->ulDBTimeHigh;
	return qwx.qw;
	}

// #define TEST_WRAP_AROUND	1

STATIC INLINE VOID DBHDRIncDBTime( DBFILEHDR *pdbfilehdr )
	{
	QWORD qw;
	qw = QwDBHDRDBTime( pdbfilehdr );
#ifdef TEST_WRAP_AROUND
	if ( qw < 0x00000000fffc0000 )
		qw = 0x00000000fffc0000;
#endif
	qw++;
	DBHDRSetDBTime( pdbfilehdr, qw );
	}

#undef szAssertFilename

#endif  // _DAEDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\dbapi.h ===
extern DAB	*pdabGlobalMin;
extern DAB	*pdabGlobalMax;

ERR ErrDBOpenDatabase( PIB *ppib, CHAR *szDatabaseName, DBID *pdbid, ULONG grbit );
ERR ErrDBCloseDatabase( PIB *ppib, DBID dbid, ULONG grbit );
ERR ErrDBOpenDatabaseByDbid( PIB *ppib, DBID dbid );
VOID DBCloseDatabaseByDbid( PIB *ppib, DBID dbid );
BOOL FDatabaseInUse( DBID dbid );
ERR ErrDBCreateDatabase( PIB *ppib, CHAR *szDatabaseName, CHAR *szConnect, DBID *pdbid, CPG cpgPrimary, ULONG grbit, SIGNATURE *psignDb );
ERR ErrDBSetLastPage( PIB *ppib, DBID dbid );
ERR ErrDBSetupAttachedDB(VOID);
VOID DBISetHeaderAfterAttach( DBFILEHDR *pdbfilehdr, LGPOS lgposAttach, DBID dbid, BOOL fKeepBackupInfo );
ERR ErrDBReadHeaderCheckConsistency( CHAR *szFileName, DBID dbid );
ERR ErrDABCloseAllDBs( PIB *ppib );

#define SetOpenDatabaseFlag( ppib, dbid )							\
	{													   			\
	((ppib)->rgcdbOpen[dbid]++);						   			\
	Assert( ((ppib)->rgcdbOpen[dbid] > 0 ) );						\
	}

#define ResetOpenDatabaseFlag( ppib, dbid )							\
	{																\
	Assert( ((ppib)->rgcdbOpen[dbid] > 0 ) );						\
	((ppib)->rgcdbOpen[dbid]--);									\
	}

#define FUserOpenedDatabase( ppib, dbid )							\
	((ppib)->rgcdbOpen[dbid] > 0)

#define FLastOpen( ppib, dbid )										\
	((ppib)->rgcdbOpen[dbid] == 1)

#define	FUserDbid( dbid )											\
	(dbid > dbidTemp && dbid < dbidMax)

#define ErrDBCheck( ppib, dbid )				   					\
	( FUserOpenedDatabase( ppib, dbid ) ? JET_errSuccess : JET_errInvalidDatabaseId )

#define CheckDBID( ppib, dbid )										\
	Assert( FUserOpenedDatabase( ppib, dbid ) )


/* Database Attribute Block
/**/
typedef struct _dab
	{
	PIB			*ppib;		 		/* thread that opens this DAB */
	DAB 		*pdabNext;			/* next DAB opened by the same ppib */
	JET_GRBIT	grbit;			 	/* database open mode */
	DBID		dbid;			 	/* database id	*/
	} DAB;

#define ErrDABCheck( ppibT, pdab )				   						\
	( ( ((DAB *)pdab) >= pdabGlobalMin && 								\
		((DAB *)pdab) < pdabGlobalMax &&								\
		(((ULONG_PTR)pdab - (ULONG_PTR)pdabGlobalMin) % sizeof(DAB) == 0) &&	\
		((DAB *)pdab)->ppib == (ppibT) ) ?								\
		JET_errSuccess : JET_errInvalidDatabaseId )

	//  Database info in DATABASES tree

typedef struct {
	BYTE	bDbid;
	BYTE	bLoggable;
	/*	rgchDatabaseName must be last field in structure
	/**/
	CHAR	rgchDatabaseName[1];
	} DBA;

ERR ErrDBStoreDBPath( CHAR *szDBName, CHAR **pszDBPath );

/*	bogus dbid uniqifying code
/**/
#define vdbidNil NULL
typedef DAB * VDBID;

#ifdef DISPATCHING
#define VdbidMEMAlloc() 			  			(VDBID)PbMEMAlloc(iresDAB)
#ifdef DEBUG /*  Debug check for illegal reuse of freed vdbid  */
#define ReleaseVDbid( vdbid )					{ MEMRelease( iresDAB, (BYTE *) vdbid ); vdbid = vdbidNil; }
#else
#define ReleaseVDbid( vdbid )					{ MEMRelease( iresDAB, (BYTE *) vdbid ); }
#endif
#define DbidOfVDbid( vdbid )					( ( (VDBID) vdbid )->dbid )
#define	GrbitOfVDbid( vdbid )					( ( (VDBID) vdbid )->grbit )
#define FVDbidReadOnly( vdbid )	 				( ( (VDBID) vdbid )->grbit & JET_bitDbReadOnly )
#define VDbidCheckUpdatable( vdbid ) 	\
	( FVDbidReadOnly( vdbid ) ? ErrERRCheck( JET_errPermissionDenied ) : JET_errSuccess )

#else

#define DbidOfVDbid( vdbid )				 	(vdbid)
#define VdbidMEMAlloc() 		
#define ReleaseVDbid( vdbid )			
#define	GrbitOfVDbid( vdbid )	
#define FVDbidReadOnly( vdbid )	 	
#define VDbidCheckUpdatable( vdbid )

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\disp.h ===
#ifndef DISP_H
#define DISP_H

#include "vtapi.h"


	/* The following APIs are VT APIs are are dispatched using the */
	/* TABLEID parameter.  For more information see vtapi.h */

extern VTFNAddColumn			ErrDispAddColumn;
extern VTFNCloseTable			ErrDispCloseTable;
extern VTFNComputeStats 		ErrDispComputeStats;
extern VTFNCopyBookmarks		ErrDispCopyBookmarks;
extern VTFNCreateIndex			ErrDispCreateIndex;
extern VTFNCreateReference		ErrDispCreateReference;
extern VTFNDelete				ErrDispDelete;
extern VTFNDeleteColumn 		ErrDispDeleteColumn;
extern VTFNDeleteIndex			ErrDispDeleteIndex;
extern VTFNDeleteReference		ErrDispDeleteReference;
extern VTFNDupCursor			ErrDispDupCursor;
extern VTFNEmptyTable			ErrDispEmptyTable;
extern VTFNGetBookmark			ErrDispGetBookmark;
extern VTFNGetChecksum			ErrDispGetChecksum;
extern VTFNGetCurrentIndex		ErrDispGetCurrentIndex;
extern VTFNGetCursorInfo		ErrDispGetCursorInfo;
extern VTFNGetRecordPosition		ErrDispGetRecordPosition;
extern VTFNGetTableColumnInfo		ErrDispGetTableColumnInfo;
extern VTFNGetTableIndexInfo		ErrDispGetTableIndexInfo;
extern VTFNGetTableReferenceInfo	ErrDispGetTableReferenceInfo;
extern VTFNGetTableInfo 		ErrDispGetTableInfo;
extern VTFNGotoBookmark 		ErrDispGotoBookmark;
extern VTFNGotoPosition 		ErrDispGotoPosition;
extern VTFNVtIdle				ErrDispVtIdle;
extern VTFNMakeKey				ErrDispMakeKey;
extern VTFNMove 				ErrDispMove;
extern VTFNNotifyBeginTrans		ErrDispNotifyBeginTrans;
extern VTFNNotifyCommitTrans 	ErrDispNotifyCommitTrans;
extern VTFNNotifyRollback		ErrDispNotifyRollback;
extern VTFNNotifyUpdateUfn		ErrDispNotifyUpdateUfn;
extern VTFNPrepareUpdate		ErrDispPrepareUpdate;
extern VTFNRenameColumn 		ErrDispRenameColumn;
extern VTFNRenameIndex			ErrDispRenameIndex;
extern VTFNRenameReference		ErrDispRenameReference;
extern VTFNRetrieveColumn		ErrDispRetrieveColumn;
extern VTFNRetrieveKey			ErrDispRetrieveKey;
extern VTFNSeek 				ErrDispSeek;
extern VTFNSetCurrentIndex		ErrDispSetCurrentIndex;
extern VTFNSetColumn			ErrDispSetColumn;
extern VTFNSetIndexRange		ErrDispSetIndexRange;
extern VTFNUpdate				ErrDispUpdate;

#endif	/* !DISP_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\dirapi.h ===
/**********************************************************
/************** DIR STRUCTURES and CONSTANTS **************
/**********************************************************
/**/

#include "node.h"

/************** DIR API defines and types ******************
/***********************************************************
/**/
typedef struct {
	ULONG		ulLT;
	ULONG		ulTotal;
	} FRAC;

typedef INT POS;
#define posFirst	  			0
#define posLast					1
#define posDown					2
#define posFrac					3

#define fDIRNull	   			0
#define fDIRPurgeParent			(1<<0)
#define fDIRBackToFather		(1<<1)
#define fDIRNeighborKey			(1<<2)
#define fDIRPotentialNode 		(1<<3) 
#define fDIRAllNode				(1<<4)
#define fDIRAllPage				(1<<5)
#define fDIRReplace				(1<<6)
#define fDIRReplaceDuplicate	(1<<7)
#define fDIRDuplicate 			(1<<8)
#define fDIRSpace	   			(1<<9)
#define fDIRVersion				(1<<10)
#define fDIRAppendItem			(1<<12)
#define	fDIRDeleteItem			(1<<13)
#define fDIRLogColumnDiffs		(1<<14)
#define fDIRLogChunkDiffs		(1<<15)
#define fDIRNoLog				(1<<16)
#define fDIRNoVersion			0
#define fDIRNoMPLRegister		(1<<17)

/*	item list nodes not versioned
/**/
#define fDIRItemList		   	fDIRPotentialNode

struct _dib {
	POS		pos;
	KEY		*pkey;
	INT		fFlags;
	};

#define	itagOWNEXT		1
#define	itagAVAILEXT 	2
#define	itagDATA		3
#define	itagLONG		4
#define itagAUTOINC		5

#define PgnoFDPOfPfucb(pfucb) ((pfucb)->u.pfcb->pgnoFDP)
#define PgnoRootOfPfucb(pfucb) ((pfucb)->u.pfcb->pgnoFDP)
#define ItagRootOfPfucb(pfucb) itagDATA

#define	ErrDIRGetBookmark( pfucb, psrid )								\
	( PcsrCurrent( pfucb )->csrstat == csrstatOnCurNode ||				\
		PcsrCurrent( pfucb )->csrstat == csrstatDeferGotoBookmark ?		\
		( *psrid = PcsrCurrent( pfucb )->bm, JET_errSuccess ) :			\
		ErrERRCheck( JET_errNoCurrentRecord ) )

#define	DIRGetBookmark( pfucb, psrid )									\
	( *((SRID *)psrid) = PcsrCurrent( pfucb )->bm )

#define DIRGotoBookmark	DIRDeferGotoBookmark

#ifdef PREREAD

#define DIRDeferGotoBookmark( pfucb, bmT )								\
	{																	\
	FUCBResetPreread( pfucb );											\
	PcsrCurrent( pfucb )->csrstat = csrstatDeferGotoBookmark;			\
	PcsrCurrent( pfucb )->bm = bmT;										\
	( pfucb )->sridFather = sridNull;									\
	DIRSetRefresh( pfucb );														\
	}																					

#else

#define DIRDeferGotoBookmark( pfucb, bmT )								\
	{																	\
	PcsrCurrent( pfucb )->csrstat = csrstatDeferGotoBookmark;			\
	PcsrCurrent( pfucb )->bm = bmT;										\
	( pfucb )->sridFather = sridNull;									\
	DIRSetRefresh( pfucb );														\
	}	

#endif	// PREREAD

#define DIRGotoBookmarkItem( pfucb, bmT, itemT )  						\
	{																	\
	PcsrCurrent( pfucb )->csrstat = csrstatDeferGotoBookmark;			\
	PcsrCurrent( pfucb )->bm = bmT;						  				\
	PcsrCurrent( pfucb )->item = itemT;				  					\
	( pfucb )->sridFather = sridNull;									\
	DIRSetRefresh( pfucb );												\
	}																					

#define DIRGotoPgnoItag( pfucb, pgnoT, itagT )   						\
	{																	\
	PcsrCurrent( pfucb )->csrstat = csrstatOnCurNode;					\
	PcsrCurrent( pfucb )->bm = SridOfPgnoItag( (pgnoT), (itagT) );		\
	PcsrCurrent( pfucb )->pgno = (pgnoT);	 							\
	PcsrCurrent( pfucb )->itag = (itagT);	 							\
	( pfucb )->sridFather = sridNull;									\
	DIRSetRefresh( pfucb );														\
	}

#define DIRGotoFDPRoot( pfucb )									  		\
	{															  	 	\
	PcsrCurrent( pfucb )->csrstat = csrstatOnFDPNode;					\
	PcsrCurrent( pfucb )->bm =									  		\
		SridOfPgnoItag( PgnoFDPOfPfucb( pfucb ), itagFOP );				\
	PcsrCurrent( pfucb )->pgno = PgnoFDPOfPfucb( pfucb ); 				\
	PcsrCurrent( pfucb )->itag = itagFOP;								\
	PcsrCurrent( pfucb )->itagFather = itagFOP;							\
	( pfucb )->sridFather = sridNull;									\
	if ( !FBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) )		\
		{															   	\
		if ( ErrBFReadAccessPage( pfucb,							   	\
			PcsrCurrent( pfucb )->pgno ) < 0 )							\
			{														   	\
			DIRSetRefresh( pfucb );									   	\
			}															\
		else														   	\
			{														   	\
			NDGet( pfucb, PcsrCurrent( pfucb )->itag );					\
			DIRSetFresh( pfucb );										\
			}															\
		}																\
	}

#define DIRGotoOWNEXT( pfucb, pgnoT )									\
	{																	\
	DIRGotoPgnoItag( pfucb, pgnoT, itagOWNEXT );  						\
	Assert( ( pfucb )->sridFather == sridNull );						\
	PcsrCurrent( pfucb )->itagFather = itagFOP;							\
	}

#define DIRGotoAVAILEXT( pfucb, pgnoT )		 							\
	{																	\
	DIRGotoPgnoItag( pfucb, pgnoT, itagAVAILEXT );  					\
	PcsrCurrent( pfucb )->itagFather = itagFOP;							\
	}

#define DIRGotoLongRoot( pfucb )										\
	{																	\
	PcsrCurrent( pfucb )->csrstat = csrstatOnCurNode;					\
	PcsrCurrent( pfucb )->bm =											\
		SridOfPgnoItag( PgnoFDPOfPfucb( pfucb ), itagLONG );			\
	PcsrCurrent( pfucb )->pgno = PgnoFDPOfPfucb( pfucb ); 				\
	PcsrCurrent( pfucb )->itag = itagLONG;								\
	PcsrCurrent( pfucb )->itagFather = itagNull;						\
	( pfucb )->sridFather = sridNull;									\
	if ( !FBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) )		\
		{																\
		if ( ErrBFReadAccessPage( pfucb,								\
			PcsrCurrent( pfucb )->pgno ) < 0 )							\
			{															\
			DIRSetRefresh( pfucb );										\
			}															\
		else															\
			{															\
			NDGet( pfucb, PcsrCurrent( pfucb )->itag );					\
			DIRSetFresh( pfucb );										\
			}															\
		}																\
	}

#define DIRGotoDataRoot( pfucb )										\
	{																	\
	PcsrCurrent( pfucb )->csrstat = csrstatOnCurNode;					\
	PcsrCurrent( pfucb )->bm =											\
		SridOfPgnoItag( PgnoFDPOfPfucb( pfucb ), itagDATA );			\
	PcsrCurrent( pfucb )->pgno = PgnoFDPOfPfucb( pfucb ); 				\
	PcsrCurrent( pfucb )->itag = itagDATA;								\
	PcsrCurrent( pfucb )->itagFather = itagNull;						\
	( pfucb )->sridFather = sridNull;									\
	if ( !FBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) )		\
		{																\
		if ( ErrBFReadAccessPage( pfucb,								\
			PcsrCurrent( pfucb )->pgno ) < 0 )							\
			{															\
			DIRSetRefresh( pfucb );										\
			}															\
		else															\
			{															\
			NDGet( pfucb, PcsrCurrent( pfucb )->itag );					\
			DIRSetFresh( pfucb );										\
			}															\
		}																\
	}

#define FDIRDataRootRoot( pfucb, pcsr )								\
	(	(pcsr)->pgno == PgnoFDPOfPfucb( pfucb ) &&					\
		(pcsr)->itag == ItagRootOfPfucb( pfucb ) )

#define DIRDeferMoveFirst( pfucb )									\
	{																\
	PcsrCurrent( pfucb )->csrstat = csrstatDeferMoveFirst;			\
	DIRSetRefresh( pfucb );											\
	}

#define DIRSetIndexRange		FUCBSetIndexRange
#define DIRResetIndexRange		FUCBResetIndexRange

ERR ErrDIROpen( PIB *ppib, FCB *pfcb, DBID dbid, FUCB **ppfucb );
VOID DIRClose( FUCB *pfucb );
ERR ErrDIRDown( FUCB *pfucb, DIB *pdib );
ERR ErrDIRDownFromDATA( FUCB *pfucb, KEY *pkey );
VOID DIRUp( FUCB *pfucb, INT ccsr );
ERR ErrDIRNext( FUCB *pfucb, DIB *pdib );
ERR ErrDIRPrev( FUCB *pfucb, DIB *pdib );
ERR ErrDIRGet( FUCB *pfucb );
ERR ErrDIRCheckIndexRange( FUCB *pfucb );
ERR ErrDIRGetBMOfItemList( FUCB *pfucb, SRID *pbmItemList );

ERR ErrDIRGetWriteLock( FUCB *pfucb );

ERR ErrDIRInsert( FUCB *pfucb, LINE *pline, KEY *pkey, INT fFlags );
ERR ErrDIRInitAppendItem( FUCB *pfucb );
ERR ErrDIRAppendItem( FUCB *pfucb, LINE *pline, KEY *pkey, SRID sridPrev  );
ERR ErrDIRTermAppendItem( FUCB *pfucb );

ERR ErrDIRCreateDirectory( FUCB *pfucb, CPG cpgMin, PGNO *ppgnoFDP );
#define ErrDIRDeleteDirectory( pfucb, pgnoFDP )		ErrSPFreeFDP( pfucb, pgnoFDP )

ERR ErrDIRDelete( FUCB *pfucb, INT fFlags );
ERR ErrDIRReplace( FUCB *pfucb, LINE *pline, INT fFlags );
ERR ErrDIRReplaceKey( FUCB *pfucb, KEY *pkeyTo, INT fFlags );

ERR ErrDIRDownKeyBookmark( FUCB *pfucb, KEY *pkey, SRID srid );
ERR ErrDIRGetPosition( FUCB *pfucb, ULONG *pulLT, ULONG *pulTotal );
ERR ErrDIRGotoPosition( FUCB *pfucb, ULONG ulLT, ULONG ulTotal );
ERR ErrDIRIndexRecordCount( FUCB *pfucb, ULONG *pulCount, ULONG ulCountMost, BOOL fNext );
ERR ErrDIRComputeStats( FUCB *pfucb, INT *pcitem, INT *pckey, INT *pcpage );

ERR ErrDIRDelta( FUCB *pfucb, INT iDelta, INT fFlags );

ERR ErrDIRBeginTransaction( PIB *ppib );
ERR ErrDIRRefreshTransaction( PIB *ppib );
ERR ErrDIRCommitTransaction( PIB *ppib, JET_GRBIT grbit );
VOID DIRPurge( PIB *ppib );
ERR ErrDIRRollback( PIB *ppib );

#define DIRBeforeFirst( pfucb )		( PcsrCurrent(pfucb)->csrstat = csrstatBeforeFirst )
#define DIRAfterLast( pfucb )		( PcsrCurrent(pfucb)->csrstat = csrstatAfterLast )
#define FDIRMostRecent				FBTMostRecent
#define FDIRDelta					FVERDelta

ERR ErrDIRDump( FUCB *pfucb, INT cchIndent );


/**********************************************************
/******************* DIR Internal *************************
/**********************************************************
/**/
#define	itagFOP				0
#define	cbSonMax			256
#define	qwDBTimeNull		0xffffffffffffffff
#define itagDIRDVSplitL		1
#define itagDIRDVSplitR		2

/*	maximum node data size for nodes which ErrNDDelta can be used on.
/*	Specifically this minimally supports long value root nodes.
/**/
#define	cbMaxCounterNode	8

/*  Offset of data field to counter. for long field reference counter.
 **/
#define ibCounter			0

/*	non-clustered index cursors already have item stored.
/**/
#ifdef DEBUG

#define CheckCSR( pfucb )       Assert( fRecovering ||					\
	(PcsrCurrent(pfucb) == pcsrNil ||						  			\
	PcsrCurrent(pfucb)->pcsrPath == pcsrNil ||							\
	PcsrCurrent(pfucb)->pgno != PcsrCurrent(pfucb)->pcsrPath->pgno ||	\
	PcsrCurrent(pfucb)->itag != PcsrCurrent(pfucb)->pcsrPath->itag ) );

#define DIRSetFresh( pfucb )										   	\
	{																   	\
	Assert( PcsrCurrent( pfucb )->csrstat == csrstatOnCurNode ||		\
		PcsrCurrent( pfucb )->csrstat == csrstatBeforeCurNode ||	   	\
		PcsrCurrent( pfucb )->csrstat == csrstatAfterCurNode || 	   	\
		PcsrCurrent( pfucb )->csrstat == csrstatOnFDPNode );		   	\
	AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag ); 				   	\
	PcsrCurrent( pfucb )->qwDBTime = QwSTDBTimePssib( &(pfucb)->ssib ); \
	}

#define DIRSetRefresh( pfucb )											\
	{																	\
	Assert( PcsrCurrent( pfucb )->csrstat == csrstatOnCurNode ||		\
		PcsrCurrent( pfucb )->csrstat == csrstatBeforeCurNode ||		\
		PcsrCurrent( pfucb )->csrstat == csrstatAfterCurNode || 		\
		PcsrCurrent( pfucb )->csrstat == csrstatOnFDPNode ||			\
		PcsrCurrent( pfucb )->csrstat == csrstatDeferGotoBookmark ||	\
		PcsrCurrent( pfucb )->csrstat == csrstatDeferMoveFirst ||		\
		PcsrCurrent( pfucb )->csrstat == csrstatOnDataRoot );			\
	PcsrCurrent( pfucb )->qwDBTime = qwDBTimeNull;						\
	}

#else

#define CheckCSR( pfucb )

#define DIRSetFresh( pfucb )		 									   	\
	{																	   	\
	PcsrCurrent( pfucb )->qwDBTime = QwSTDBTimePssib( &(pfucb)->ssib ); 	\
	}

#define DIRSetRefresh( pfucb )  										   	\
	{																	   	\
	PcsrCurrent( pfucb )->qwDBTime = qwDBTimeNull; 						   	\
	}

#endif


/**********************************************************
/********************* BTREE API **************************
/**********************************************************
/**/
#define sridMin         0
#define sridMax         0xffffffff

/*	must be on node, i.e. on current node, before node or after node.
/*	Node must be in line cache.
/**/
#define DIRISetBookmark( pfucb, pcsr )									   	\
	{																	   	\
	AssertFBFReadAccessPage( (pfucb), (pcsr)->pgno );						\
																			\
	if ( FNDBackLink( *( (pfucb)->ssib.line.pb ) ) )						\
		(pcsr)->bm = *(SRID UNALIGNED *)PbNDBackLink( (pfucb)->ssib.line.pb );		\
	else																	\
		(pcsr)->bm = SridOfPgnoItag( (pcsr)->pgno, (pcsr)->itag );			\
	}


BOOL FBTMostRecent( FUCB *pfucb );

#define ErrBTNext( pfucb, pdib ) \
	( ErrBTNextPrev( pfucb, PcsrCurrent(pfucb), fTrue, pdib, NULL ) )
#define ErrBTPrev( pfucb, pdib ) \
	( ErrBTNextPrev( pfucb, PcsrCurrent(pfucb), fFalse, pdib, NULL ) )
#define	BTUp( pfucb )	FUCBFreeCSR( pfucb )

ERR ErrBTGet( FUCB *pfucb, CSR *pcsr );
ERR ErrBTGetNode( FUCB *pfucb, CSR *pcsr );
#ifdef DEBUG
VOID AssertBTGetNode( FUCB *pfucb, CSR *pcsr );
#else
#define	AssertBTGetNode
#endif
ERR ErrBTSetNodeHeader( FUCB *pfucb, BYTE bHeader );
ERR ErrBTReplaceKey( FUCB *pfucb, KEY *pkey, INT fFlags );
ERR ErrBTDown( FUCB *pfucb, DIB *pdib );
ERR ErrBTDownFromDATA( FUCB *pfucb, KEY *pkey );
ERR ErrBTNextPrev( FUCB *pfucb, CSR *pcsr, INT fNext, DIB *pdib, BOOL *pfEmptyPage );
ERR ErrBTSeekForUpdate( FUCB *pfucb, KEY *pkey, PGNO pgno, INT itag, INT fDIRFlags );
ERR ErrBTInsert( FUCB *pfucb, INT fHeader, KEY *pkey, 
				 LINE *pline, INT fDIRFlags, BOOL *pfCleaned );
ERR ErrBTReplace( FUCB *pfucb, LINE *pline, 
				  INT fFlags, BOOL *pfCleaned );
ERR ErrBTDelete( FUCB *pfucb, INT fFlags );
ERR ErrBTMakeRoom( FUCB *pfucb, CSR *pcsrRoot, INT cbReq );
ERR ErrBTGetPosition( FUCB *pfucb, ULONG *pulLT, ULONG *pulTotal );
ERR ErrBTGotoBookmark( FUCB *pfucb, SRID srid );
ERR ErrBTGetInvisiblePagePtr( FUCB *pfucb, SRID sridFather );
#ifdef DEBUG
ERR ErrBTCheckInvisiblePagePtr( FUCB *pfucb, SRID sridFather );
#endif

#ifdef DEBUG
VOID BTCheckSplit( FUCB *pfucb, CSR *pcsr );
#else
#define BTCheckSplit( pfucb, pcsr )
#endif


/**********************************************************
/*********************** BT Split *************************
/**********************************************************
/**/
typedef enum {
	splittNull,
	splittVertical,
	splittDoubleVertical,
	splittLeft,
	splittRight,
	splittAppend
	} SPLITT;
	
typedef enum {
	opReplace,
	opInsert
	} OPERATION;

typedef struct {
	PN		pn;
	QWORD	qwDBTime;
} LFINFO;						/* leaf split info */


typedef struct
	{
	SRID	sridNew;
	SRID	sridBackLink;
	} BKLNK;


typedef struct _split {
	PIB			*ppib;
	PGNO		pgnoSplit;
	PGNO		pgnoNew;
	PGNO		pgnoNew2;
	PGNO		pgnoNew3;
	PGNO		pgnoSibling;
	
	BF			*pbfSplit;			/* BF of page being split */
	BF			*pbfNew;			/* BF of new page of this split */
	BF			*pbfNew2;			/* BF of new page of this split */
	BF			*pbfNew3;			/* BF of new page of this split */
	BF			*pbfSibling;		/* BF of sibling page of this H split */
	BF			*pbfPagePtr;

	BOOL		fNoRedoNew;			/* no need to redo new page */
	BOOL		fNoRedoNew2;		/* no need to redo new page 2 */
	BOOL		fNoRedoNew3;		/* no need to redo new page 3 */
	
	BF			**rgpbf;			/* BF of backlink page. */
	INT	  		cpbf;
	INT	  		cpbfMax;

	BKLNK		*rgbklnk;			/* SRID of backlinks. */
	INT	  		cbklnk;
	INT			cbklnkAlloc;
	INT	  		cbklnkMax;
	
	QWORD		qwDBTimeRedo;		/* redo timestamp */
	
	INT			itagSplit;
	INT			ibSon;
	KEY	  		key;
	KEY	  		keyMac;
	
	SPLITT  	splitt;
	BOOL		fLeaf;
	OPERATION	op;
	BOOL		fFDP;
	DBID		dbid;
	INT			itagNew;
	INT			itagPagePointer;
	
	BYTE		rgbSonSplit[cbSonMax];
	BYTE		rgbSonNew[cbSonMax];

	BYTE		rgbkeyMac[JET_cbKeyMost];
	BYTE		rgbKey[JET_cbKeyMost];

	/*	mapping from old to new tags for use in MCM
	/**/
	BYTE		mpitag[ctagMax];
	INT			ipcsrMac;				/* preallocated resource for csr */
#define ipcsrSplitMax 4
	CSR			*rgpcsr[ipcsrSplitMax];
} SPLIT;


typedef struct _rmpage {
	PIB			*ppib;
	
	QWORD		qwDBTimeRedo;			/* redo timestamp */
	
	BF			*pbfLeft;
	BF			*pbfRight;
	BF			*pbfFather;

	BKLNK		**rgbklnk;				/* latched buffers required for rmpage */
	INT			cbklnk;
	INT	  		cbklnkMax;

	BF			**rgpbf;				/* latched buffers required for rmpage */
	INT			cpbf;
	INT	  		cpbfMax;

	PGNO		pgnoRemoved;
	PGNO		pgnoLeft;
	PGNO		pgnoRight;
	PGNO		pgnoFather;
	INT			itagPgptr;
	INT			itagFather;
	INT			ibSon;
	DBID		dbid;
	} RMPAGE;
	
#define CbFreeDensity(pfucb) \
	( (pfucb)->u.pfcb != pfcbNil ? (INT)(pfucb)->u.pfcb->cbDensityFree : 0 )

/*	protypes for split used by recovery of split operations.
/**/
ERR ErrBTStoreBackLinkBuffer( SPLIT *psplit, BF *pbf, BOOL *pfAlreadyLatched );
ERR ErrBTSplit( FUCB *pfucb, INT cbNode, INT cbReq, KEY *pkey, INT fFlags );
ERR ErrBTSplitPage( FUCB *pfucb, CSR *pcsr,	CSR *pcsrRoot,
	KEY keySplit, INT cbNode, INT cbReq, BOOL fReplace, BOOL fAppendPage );
BOOL FBTSplit( SSIB *pssib, INT cbReq, INT citagReq );
BOOL FBTAppendPage( FUCB *pfucb, CSR *pcsr, INT cbReq, INT cbPageAdjust, INT cbFreeDensity, INT citagReq );
INT CbBTFree( FUCB *pfucb, INT cbFreeDensity );

#define fAllocBufOnly		fTrue
#define fDoMove				fFalse

ERR ErrBTSplitVMoveNodes(
	FUCB	*pfucb,
	FUCB	*pfucbNew,
	SPLIT	*psplit,
	CSR 	*pcsr,
	BYTE	*rgb,
	BOOL	fNoMove);
ERR ErrBTSplitDoubleVMoveNodes(
	FUCB	*pfucb,
	FUCB	*pfucbNew,
	FUCB	*pfucbNew2,
	FUCB	*pfucbNew3,
	SPLIT	*psplit,
	CSR		*pcsr,
	BYTE	*rgb,
	BOOL	fNoMove);
ERR ErrBTSplitHMoveNodes(
	FUCB	*pfucb,
	FUCB	*pfucbNew,
	SPLIT	*psplit,
	BYTE	*rgb,
	BOOL	fNoMove);
ERR ErrBTInsertPagePointer( FUCB *pfucb, CSR *pcsrPagePointer, SPLIT *psplit, BYTE *rgb );
ERR ErrBTCorrectLinks(
	SPLIT *psplit,
	FUCB *pfucb,
	SSIB *pssib,
	SSIB *pssibNew);
VOID BTReleaseSplitBfs ( BOOL fRedo, SPLIT *psplit, ERR err );
VOID BTReleaseRmpageBfs( BOOL fRedo, RMPAGE *prmpage );

ERR ErrBTMoveSons( SPLIT *psplit, 
	FUCB	*pfucb, 
	FUCB	*pfucbNew, 
	INT		itagSonTable,
	BYTE	*rgbSon, 
	BOOL	fVisibleSons, 
	BOOL	fNoMove,
	BKLNK	*pbklnk,
	INT		cbklnk );
	
ERR ErrBTSetUpSplitPages( FUCB *pfucb, FUCB *pfucbNew,
	FUCB *pfucbNew2, FUCB *pfucbNew3, SPLIT *psplit,
	PGTYP pgtyp, BOOL fAppend, BOOL fSkipMoves );

ERR ErrBTAbandonEmptyPage( FUCB *pfucb, KEY *pkey );

/**********************************************************
/********** MCM STRUCTURES, CONSTANTS and API *************
/**********************************************************
/**/
#define	opInsertItem						0
#define	opDeleteItem						1
#define	opSplitItemList					2

#define	opInsertSon							0
#define	opReplaceSon		 				1
#define	opDeleteSon							2

#define	opHorizontalRightSplitPage		0
#define	opHorizontalLeftSplitPage		1

#define opVerticalSplitPage				0

VOID MCMRightHorizontalPageSplit( FUCB *pfucb,
	PGNO pgnoSplit, PGNO pgnoRight, INT ibSonSplit, BYTE *mpitag );
VOID MCMLeftHorizontalPageSplit( FUCB *pfucb,
	PGNO pgnoSplit, PGNO pgnoNew, INT ibSonSplit, BYTE *mpitag );
VOID MCMVerticalPageSplit(
	FUCB *pfucb,
	BYTE *mpitag,
	PGNO pgnoSplit,
	INT itagSplit,
	PGNO pgnoNew,
	SPLIT *psplit );
VOID MCMDoubleVerticalPageSplit(
	FUCB	*pfucb,
	BYTE	*mpitag,
	PGNO	pgnoSplit,
	INT		itagSplit,
	INT		ibSonDivision,
	PGNO	pgnoNew,
	PGNO	pgnoNew2,
	PGNO	pgnoNew3,
	SPLIT	*psplit );
VOID MCMInsertPagePointer( FUCB *pfucb, PGNO pgnoFather, INT itagFather );
VOID MCMBurstIntrinsic( FUCB *pfucb, PGNO pgnoFather, INT itagFather, PGNO pgnoNew, INT itagNew );

#define FFUCBRecordCursor( pfucb ) (						\
		( pfucb )->u.pfcb != pfcbNil ?						\
		FFCBClusteredIndex( ( pfucb )->u.pfcb ) : fFalse )

#ifdef		NOLOG		/* logging disabled	*/

#define ErrLGSplitL( ppib, pcsrPagePointer, psplit, pgtyp )	0
#define ErrLGSplitR( ppib, pcsrPagePointer, psplit, pgtyp )	0
#define ErrLGSplitV( ppib, psplit, pgtyp )	0
#define ErrLGAddendR( pfucb, pcsrPagePointer, psplit, newpagetype ) 0

#else

ERR ErrLGSplitL(
	FUCB *pfucb,
	CSR *pcsrPagePointer,
	SPLIT *psplit,
	PGTYP newpagetype );

ERR ErrLGSplitR(
	FUCB *pfucb,
	CSR *pcsrPagePointer,
	SPLIT *psplit,
	PGTYP newpagetype );

ERR ErrLGSplitV(
	FUCB *pfucb,
	SPLIT *psplit,
	PGTYP newpagetype );

ERR ErrLGAddendR(
	FUCB *pfucb,
	CSR *pcsrPagePointer,
	SPLIT *psplit,
	PGTYP newpagetype );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\fcb.h ===
#ifdef	FCB_INCLUDED
#error fcb.h already included
#endif	/* FCB_INCLUDED */
#define FCB_INCLUDED

/*	unique sequential key
/**/
typedef ULONG DBK;

#define FFCBDeletePending( pfcb )		  	( (pfcb)->fFCBDeletePending )
#define FCBSetDeletePending( pfcb )	 	  	( (pfcb)->fFCBDeletePending = 1 )
#define FCBResetDeletePending( pfcb )	  	( (pfcb)->fFCBDeletePending = 0 )

#define FFCBOLCStatsAvail( pfcb )		  	( (pfcb)->fFCBOLCStatsAvail )
#define FCBSetOLCStatsAvail( pfcb )	 	  	( (pfcb)->fFCBOLCStatsAvail = 1 )
#define FCBResetOLCStatsAvail( pfcb )	  	( (pfcb)->fFCBOLCStatsAvail = 0 )

#define FFCBOLCStatsChange( pfcb )		  	( (pfcb)->fFCBOLCStatsChange )
#define FCBSetOLCStatsChange( pfcb )	  	( (pfcb)->fFCBOLCStatsChange = 1 )
#define FCBResetOLCStatsChange( pfcb )	  	( (pfcb)->fFCBOLCStatsChange = 0 )

#define FFCBTemporaryTable( pfcb )		  	( (pfcb)->fFCBTemporaryTable )
#define FCBSetTemporaryTable( pfcb )	  	( (pfcb)->fFCBTemporaryTable = 1 )
#define FCBResetTemporaryTable( pfcb )	  	( (pfcb)->fFCBTemporaryTable = 0 )

#define FFCBSystemTable( pfcb )									\
	( UtilCmpName( (pfcb)->szFileName, szScTable ) == 0    ||	\
		UtilCmpName( (pfcb)->szFileName, szSiTable ) == 0  ||	\
		UtilCmpName( (pfcb)->szFileName, szSoTable ) == 0 )

#define FFCBClusteredIndex( pfcb )		  	( (pfcb)->fFCBClusteredIndex )
#define FCBSetClusteredIndex( pfcb )	  	( (pfcb)->fFCBClusteredIndex = 1 )
#define FCBResetClusteredIndex( pfcb )	  	( (pfcb)->fFCBClusteredIndex = 0 )

#define FFCBDomainDenyWrite( pfcb )		  	( (pfcb)->crefDomainDenyWrite > 0 )
#define FCBSetDomainDenyWrite( pfcb )	  	( (pfcb)->crefDomainDenyWrite++ )

#define FCBResetDomainDenyWrite( pfcb )		  				\
	{													  	\
	Assert( (pfcb)->crefDomainDenyWrite > 0 ); 				\
	--(pfcb)->crefDomainDenyWrite;						  	\
	}

#define FFCBDomainDenyRead( pfcb, ppib )			( (pfcb)->fFCBDomainDenyRead && (ppib) != (pfcb)->ppibDomainDenyRead )

#define FCBSetDomainDenyRead( pfcb, ppib )	  		 		\
	{										 				\
	if ( (pfcb)->crefDomainDenyRead++ == 0 )   				\
		{									 				\
		Assert( (pfcb)->ppibDomainDenyRead == ppibNil );	\
		(pfcb)->ppibDomainDenyRead = (ppib);		 		\
		(pfcb)->fFCBDomainDenyRead = 1;		 				\
		}									 				\
	else													\
		{													\
		Assert( (pfcb)->ppibDomainDenyRead == (ppib) ); 	\
		Assert( (pfcb)->fFCBDomainDenyRead );				\
		}													\
	}

#define FCBResetDomainDenyRead( pfcb )			 			\
	{										 				\
	Assert( (pfcb)->crefDomainDenyRead > 0 );		 		\
	Assert( (pfcb)->ppibDomainDenyRead != ppibNil );		\
	Assert( (pfcb)->fFCBDomainDenyRead );	  				\
	if ( --(pfcb)->crefDomainDenyRead == 0 )		 		\
		{											 		\
		(pfcb)->fFCBDomainDenyRead = 0;	 					\
		(pfcb)->ppibDomainDenyRead = ppibNil;	   			\
		}								   					\
	}

#define FFCBDomainDenyReadByUs( pfcb, ppib )	 	( (pfcb)->fFCBDomainDenyRead && (ppib) == (pfcb)->ppibDomainDenyRead )

// Don't have an explicit fSort flag, but we can tell if it's a sort FCB by
// examining certain fields.
#define FFCBSort( pfcb )					( (pfcb)->pgnoFDP > pgnoSystemRoot  &&		\
												(pfcb)->pfdb == pfdbNil  &&				\
												(pfcb)->pfcbNextIndex == pfcbNil  &&	\
												(pfcb)->pfcbTable == pfcbNil  &&		\
												(pfcb)->pidb == pidbNil  &&				\
												(pfcb)->dbid == dbidTemp  &&			\
												!FFCBTemporaryTable( pfcb )  &&			\
												!FFCBClusteredIndex( pfcb ) )


#define FFCBReadLatch( pfcb )				( (pfcb)->crefReadLatch > 0 )
#define FCBSetReadLatch( pfcb )				\
	{										\
	Assert( FFCBClusteredIndex( pfcb ) ||	\
		( (pfcb)->pgnoFDP == pgnoSystemRoot ) ||	\
		FFCBSort( pfcb ) );					\
  	(pfcb)->crefReadLatch++;				\
	}

#define FCBResetReadLatch( pfcb )		  	\
	{									  	\
	Assert( (pfcb)->crefReadLatch > 0 );  	\
	--(pfcb)->crefReadLatch;			  	\
	}

#define FFCBSentinel( pfcb )			   	( (pfcb)->fFCBSentinel )
#define FCBSetSentinel( pfcb )				( (pfcb)->fFCBSentinel = 1 )
#define FCBResetSentinel( pfcb )		   	( (pfcb)->fFCBSentinel = 0 )

#define FFCBWriteLatch( pfcb, ppib )		( (pfcb)->crefWriteLatch > 0 && (ppib) != (pfcb)->ppibWriteLatch )
#define FFCBWriteLatchByUs( pfcb, ppib )	( (pfcb)->crefWriteLatch > 0 && (ppib) == (pfcb)->ppibWriteLatch )

#define FCBSetWriteLatch( pfcb, ppib )					\
	{													\
	Assert( FFCBClusteredIndex( pfcb ) ||				\
		FFCBSentinel( pfcb ) );							\
	if ( (pfcb)->crefWriteLatch++ == 0 )				\
		{												\
		Assert( (pfcb)->ppibWriteLatch == ppibNil );	\
		(pfcb)->ppibWriteLatch = (ppib);				\
		}												\
	else												\
		{												\
		Assert( (pfcb)->ppibWriteLatch == ppib );		\
		}												\
	}

#define FCBResetWriteLatch( pfcb, ppib )		 		\
	{													\
	Assert( FFCBWriteLatchByUs( pfcb, ppib ) );			\
	Assert( (pfcb)->crefWriteLatch > 0 );				\
	Assert( (pfcb)->ppibWriteLatch != ppibNil ); 		\
	if ( --(pfcb)->crefWriteLatch == 0 )		  		\
		{												\
		(pfcb)->ppibWriteLatch = ppibNil;				\
		}												\
	}

#define FFCBWait( pfcb )							( (pfcb)->fFCBWait )

#define FCBSetWait( pfcb )							\
	{												\
	Assert( !FFCBWait( pfcb ) );					\
	(pfcb)->fFCBWait = 1;							\
	}

#define FCBResetWait( pfcb )						\
	{										   		\
	Assert( FFCBWait( pfcb ) );						\
	(pfcb)->fFCBWait = 0;							\
	}

#define FFCBInLRU( pfcb )							( (pfcb)->fFCBInLRU )

#define FCBSetInLRU( pfcb )							\
	{												\
	Assert( !FFCBInLRU( pfcb ) );					\
	(pfcb)->fFCBInLRU = 1;							\
	}

#define FCBResetInLRU( pfcb )						\
	{										   		\
	Assert( FFCBInLRU( pfcb ) );	  				\
	(pfcb)->fFCBInLRU = 0;							\
	}

#define CVersionFCB( pfcb )					(pfcb)->cVersion
#define FCBVersionIncrement( pfcb )			(pfcb)->cVersion++;
#define FCBVersionDecrement( pfcb )					\
	{												\
	if ( (pfcb) != pfcbNil )						\
		{											\
		Assert( cVersion-- > 0 );					\
		Assert( (pfcb)->cVersion > 0 );				\
		(pfcb)->cVersion--;							\
		(pfcb) = pfcbNil;							\
		}											\
	}


// File Control Block
//
typedef struct _fcb
	{
	//--------------------USED BY DATA & INDEX FCB---------------------
	struct _fdb 	volatile *pfdb; 	// field descriptors
	struct _fcb 	*pfcbNextIndex;  	// chain of indexes for this file
	struct _fcb		*pfcbLRU;	   		// next LRU FCB in global LRU list
	struct _fcb		*pfcbMRU;	   		// previous LRU FCB in global LRU list
	INT				fFCBInLRU			: 1;	// in LRU list
	struct _fcb		*pfcbNextInHashBucket;
	struct _fcb		*pfcbTable;			// points to FCB of table for an index FCB
	struct _idb 	*pidb;			  	// index info (NULL if "seq." file)
	FUCB			*pfucb;				// chain of FUCBs open on this file
	PGNO			pgnoFDP;			// FDP of this file/index

	DBID			dbid;				// which database
	SHORT			cbDensityFree;		// loading density parameter:
										// # of bytes free w/o using new page
	INT				wRefCnt;			// # of FUCBs for this file/index
	INT				volatile cVersion;	// # of RCEs for this file/index
	INT				crefDomainDenyRead;	// # of FUCBs with deny read flag
	INT				crefDomainDenyWrite;// # of FUCBs with deny write flag
	INT				crefReadLatch;		// # of read latch on this FCB.
	INT				crefWriteLatch;		// # of FUCB ( of the same ppib ) with write
										// latch on this FCB. 
	PIB  			*ppibWriteLatch;	// ppib of process updating index/adding column
	PIB  			*ppibDomainDenyRead;// ppib of process holding exclusive lock

	/*	flags for FCB
	/**/
	union {
	ULONG		ulFlags;
	struct	{
			INT		fFCBTemporaryTable 	: 1;	// This is a temporary file
			INT		fFCBClusteredIndex 	: 1;	// This FCB is for data records.
			INT 	fFCBDomainDenyRead 	: 1;	// no other session can read domain
			INT		fFCBSentinel 		: 1;	// FCB is only flag holder
			INT		fFCBWait			: 1;	// wait flag
			INT		fFCBOLCStatsAvail	: 1;	// are OLC Stats available?
			INT		fFCBOLCStatsChange  : 1;	// have OLC Stats changed since last open?
			INT		fFCBDeletePending	: 1;	// is a delete pending on this table/index?
			};
		};

	//--------------------USED ONLY BY FCB OF DATA---------------------
	CHAR		   	*szFileName;			// name of file (for GetTableInfo)
	DBK	  			dbkMost;				// greatest DBK in use
	ULONG		   	ulLongIdMax;			// max long field id
	BYTE		   	rgbitAllIndex[32];		// used for clustered index FCB only

	//-------------------------INSTRUMENTATION----------------------------
	ULONG		   	cpgCompactFreed;
	P_OLC_DATA		olc_data;

	/*	PCACHE_OPTIMIZATION pads to multiple of 32 bytes.
	/*  We're currently 4 bytes short, so even if COSTLY_PERF is disabled, add
	/*  lClass anyways to pad to our requisite 32-byte boundary.
	/**/
#if defined( COSTLY_PERF )  ||  defined( PCACHE_OPTIMIZATION )
	ULONG			lClass;						// table stats class (for BF performance)
#endif
	BYTE	rgbFiller[20];
	} FCB;



/*	hash table for FCB
/**/
#define	cFCBBuckets	256
FCB*	pfcbHash[cFCBBuckets];

#define FCBHashInit()  								\
	{ 												\
	Assert( pfcbNil == (FCB *) 0 ); 				\
	memset( pfcbHash, '\0', sizeof( pfcbHash ) );	\
	}



#define FCBInitFCB( pfcb )	  					\
	{											\
	memset( pfcb, '\0', sizeof(FCB) );			\
	}

#define PfcbMEMAlloc()				( (FCB *)PbMEMAlloc( iresFCB ) )
#define PfcbMEMPreferredThreshold()	( (FCB *)PbMEMPreferredThreshold( iresFCB ) )
#define PfcbMEMMax()				( (FCB *)PbMEMMax( iresFCB ) )

#ifdef DEBUG /*  Debug check for illegal use of freed fcb  */ 
#define MEMReleasePfcb(pfcb)										\
	{																\
	Assert( PfcbFCBGet( (pfcb)->dbid, (pfcb)->pgnoFDP ) != pfcb );	\
	Assert( (pfcb)->pfdb == pfdbNil );								\
	MEMRelease( iresFCB, (BYTE*)(pfcb) );							\
	(pfcb) = pfcbNil;													\
	}
#else
#define MEMReleasePfcb(pfcb)										\
	{																\
	MEMRelease( iresFCB, (BYTE*)(pfcb) );							\
	}
#endif


ERR ErrFCBISetMode( PIB *ppib, FCB *pfcb, JET_GRBIT grbit );

/*	if opening domain for read, write or read write, and not with
/*	deny read or deny write, and domain does not have deny read or
/*	deny write set, then return JET_errSuccess, else call
/*	ErrFCBISetMode to determine if lock is by other session or to
/*	put lock on domain.			 
/**/
INLINE LOCAL ERR ErrFCBSetMode( PIB *ppib, FCB *pfcb, ULONG grbit )
	{
	if ( ( grbit & ( JET_bitTableDenyRead | JET_bitTableDenyWrite ) ) == 0 )
		{
		// No read/write restrictions.  Ensure no other session has any locks.
		if ( !( FFCBWriteLatch( pfcb, ppib )  ||
			FFCBDomainDenyRead( pfcb, ppib )  ||
			FFCBDomainDenyWrite( pfcb )  ||
			FFCBDeletePending( pfcb ) ) )
			return JET_errSuccess;
		}

	return ErrFCBISetMode( ppib, pfcb, grbit );
	}
				
/*	reset DDL is same as reset Delete.  Both use deny read flags
/*	or sentinel.
/**/
#define	FCBResetRenameTable	FCBResetDeleteTable

extern BYTE *  rgfcb;
extern FCB *  pfcbGlobalMRU;
extern CRIT  critGlobalFCBList;


/*	outstanding versions may be on non-clustered index and not on
/*	table FCB, so must check all non-clustered indexes before
/*	freeing table FCBs.
/**/
STATIC INLINE BOOL FFCBINoVersion( FCB *pfcbTable )
	{
	FCB *pfcbT;

	for ( pfcbT = pfcbTable; pfcbT != pfcbNil; pfcbT = pfcbT->pfcbNextIndex )
		{
		if ( pfcbT->cVersion > 0 )
			{
			return fFalse;
			}
		}

	return fTrue;
	}


#define	FFCBAvail( pfcb, ppib )							\
	(	pfcb->wRefCnt == 0 && 							\
		pfcb->pgnoFDP != 1 &&							\
		!FFCBReadLatch( pfcb ) &&						\
		!FFCBSentinel( pfcb ) &&						\
		!FFCBDomainDenyRead( pfcb, ppib ) &&	 		\
		!FFCBWait( pfcb ) &&							\
		FFCBINoVersion( pfcb ) )


VOID FCBTerm( VOID );
VOID FCBInsert( FCB *pfcb );
VOID FCBLink( FUCB *pfucb, FCB *pfcb );
VOID FCBInsertHashTable( FCB *pfcb );
VOID FCBDeleteHashTable( FCB *pfcb );
VOID FCBUnlink( FUCB *pfucb );
FCB *PfcbFCBGet( DBID dbid, PGNO pgnoFDP );
ERR ErrFCBAlloc( PIB *ppib, FCB **ppfcb );
VOID FCBPurgeDatabase( DBID dbid );
VOID FCBPurgeTable( DBID dbid, PGNO pgnoFDP );
ERR ErrFCBNew( PIB *ppib, DBID dbid, PGNO pgno, FCB **ppfcb );
VOID FCBResetMode( PIB *ppib, FCB *pfcb, JET_GRBIT grbit );
ERR ErrFCBSetDeleteTable( PIB *ppib, DBID dbid, PGNO pgnoFDP );
VOID FCBResetDeleteTable( FCB *pfcb );
ERR ErrFCBSetRenameTable( PIB *ppib, DBID dbid, PGNO pgno );
FCB *FCBResetAfterRedo( void );
BOOL FFCBTableOpen ( DBID dbid, PGNO pgno );

VOID FCBLinkIndex( FCB *pfcbTable, FCB *pfcbIndex );
VOID FCBUnlinkIndex( FCB *pfcbTable, FCB *pfcbIndex );
BOOL FFCBUnlinkIndexIfFound( FCB *pfcbTable, FCB *pfcbIndex );
FCB *PfcbFCBUnlinkIndexByName( FCB *pfcb, CHAR *szIndex );
ERR ErrFCBSetDeleteIndex( PIB *ppib, FCB *pfcbTable, CHAR *szIndex );
VOID FCBResetDeleteIndex( FCB *pfcbIndex );

INLINE STATIC VOID FCBLinkClusteredIdx( FCB *pfcbClustered )
	{
	FCB *pfcbIdx;
	
	for ( pfcbIdx = pfcbClustered->pfcbNextIndex; pfcbIdx != pfcbNil; pfcbIdx = pfcbIdx->pfcbNextIndex )
		{
		pfcbIdx->pfcbTable = pfcbClustered;
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\fileapi.h ===
ERR ErrFILECreateTable( PIB *ppib, DBID dbid, JET_TABLECREATE *ptablecreate );
ERR ErrFILEOpenTable( PIB *ppib, DBID dbid,
	FUCB **ppfucb, const CHAR *szName, ULONG grbit );
ERR ErrFILECloseTable( PIB *ppib, FUCB *pfucb );
ERR ErrFILEBuildIndex( PIB *ppib, FUCB *pfucb, CHAR *szIndex );
ERR	ErrFILEDumpTable( PIB *ppib, DBID dbid, CHAR *szTable );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\fmp.h ===
/*	critical section guards szDatabaseName and fWait,
/*	fWait gaurds hf open and close
/*	logged modifications counter for database
/**/
typedef struct _atchchk
	{
	LGPOS lgposAttach;
	LGPOS lgposConsistent;
	SIGNATURE signDb;
	} ATCHCHK;

typedef struct _rangelock
	{
	PGNO	pgnoStart;
	PGNO	pgnoEnd;
	struct _rangelock *prangelockNext;
	} RANGELOCK;

		
typedef struct _fmp	
	{
	HANDLE 		hf;			 			/*	file handle for read/write the file	*/
	CHAR		*szDatabaseName;		/*	database file name					*/
	CRIT		critExtendDB;			/*	critical section for file extension	*/
	ULONG		ulFileSizeLow;			/*	database file size low DWORD		*/
	ULONG		ulFileSizeHigh;			/*	database file size high DWORD		*/
	PIB			*ppib;					/*	exclusive open session				*/

	union {
	UINT		fFlags;
	struct {
		UINT		fWait:1;				/*	Semaphore for entry being used		*/
		UINT		fExtendingDB:1;			/*	Semaphore for extending DB file		*/
		UINT		fCreate:1;				/*	Semaphore for creating DB			*/

		UINT		fExclusive:1;			/*	DB Opened exclusively				*/
		UINT		fReadOnly:1;			/*	ReadOnly database?					*/
		UINT		fLogOn:1;				/*	logging enabled flag				*/
		UINT		fVersioningOff:1;		/*	disable versioning flag				*/

		UINT		fAttachNullDb:1;		/*	db is missing for attachment		*/
		UINT		fAttached:1;			/*	DB is in attached state.			*/
		UINT		fFakedAttach:1;			/*	faked attachement during recovery	*/

#ifdef DEBUG
		UINT		fFlush:1;				/*	DB is in flushing state.			*/
#endif
			};
		};

	QWORD		qwDBTimeCurrent;		/*	timestamp from DB redo operations	*/
	
	ERR			errPatch;				/*	patch file write error				*/
	HANDLE 		hfPatch;	  			/*	file handle for patch file			*/
	CHAR		*szPatchPath;		
	INT 		cpage;					/*	patch page count					*/

	CRIT		critCheckPatch;
	ULONG		cPatchIO;				/*	active IO on patch file				*/
	PGNO		pgnoMost;				/*	pgno of last database page			*/
										/*		at backup begin  				*/
	PGNO		pgnoCopyMost;			/*	pgno of last page copied during		*/
							  			/*		backup, 0 == no backup			*/
	RANGELOCK	*prangelock;

	ATCHCHK		*patchchk;
	ATCHCHK		*patchchkRestored;

	DBFILEHDR	*pdbfilehdr;
	} FMP;

extern FMP	*rgfmp;

#define FFMPAttached( pfmp )		( (pfmp)->fAttached )
#define FMPSetAttached( pfmp )		( (pfmp)->fAttached = 1 )
#define FMPResetAttached( pfmp )	( (pfmp)->fAttached = 0 )

#define FDBIDWait( dbid )	 		( rgfmp[dbid].fWait )
#define DBIDSetWait( dbid )	  		( rgfmp[dbid].fWait = 1 )
#define DBIDResetWait( dbid ) 		( rgfmp[dbid].fWait = 0 )

#define FDBIDExclusive( dbid ) 		( rgfmp[dbid].fExclusive )
#define FDBIDExclusiveByAnotherSession( dbid, ppib )		\
				( (	FDBIDExclusive( dbid ) )				\
				&&	( rgfmp[dbid].ppib != ppib ) )
#define FDBIDExclusiveBySession( dbid, ppib )				\
				( (	FDBIDExclusive( dbid ) )				\
				&&	( rgfmp[dbid].ppib == ppib ) )
#define DBIDSetExclusive( dbid, ppib )						\
				rgfmp[dbid].fExclusive = 1;					\
				rgfmp[dbid].ppib = ppib;
#define DBIDResetExclusive( dbid )	( rgfmp[dbid].fExclusive = 0 )

#define FDBIDReadOnly( dbid )		( rgfmp[dbid].fReadOnly )
#define DBIDSetReadOnly( dbid )		( rgfmp[dbid].fReadOnly = 1 )
#define DBIDResetReadOnly( dbid )	( rgfmp[dbid].fReadOnly = 0 )

#define FDBIDAttachNullDb( dbid )	( rgfmp[dbid].fAttachNullDb )
#define DBIDSetAttachNullDb( dbid )	( rgfmp[dbid].fAttachNullDb = 1 )
#define DBIDResetAttachNullDb( dbid )	( rgfmp[dbid].fAttachNullDb = 0 )

#define FDBIDAttached( dbid )		( rgfmp[dbid].fAttached )
#define DBIDSetAttached( dbid )		( rgfmp[dbid].fAttached = 1 )
#define DBIDResetAttached( dbid )	( rgfmp[dbid].fAttached = 0 )

#define FDBIDExtendingDB( dbid )	( rgfmp[dbid].fExtendingDB )
#define DBIDSetExtendingDB( dbid )	( rgfmp[dbid].fExtendingDB = 1 )
#define DBIDResetExtendingDB( dbid) ( rgfmp[dbid].fExtendingDB = 0 )

#define FDBIDFlush( dbid )			( rgfmp[dbid].fFlush )
#define DBIDSetFlush( dbid )		( rgfmp[dbid].fFlush = 1 )
#define DBIDResetFlush( dbid )		( rgfmp[dbid].fFlush = 0 )

#define FDBIDCreate( dbid )			( rgfmp[dbid].fCreate )
#define DBIDSetCreate( dbid )		( rgfmp[dbid].fCreate = 1 )
#define DBIDResetCreate( dbid )		( rgfmp[dbid].fCreate = 0 )

#define FDBIDLogOn( dbid )			( rgfmp[dbid].fLogOn )
#define DBIDSetLogOn( dbid )		( rgfmp[dbid].fLogOn = 1 )
#define DBIDResetLogOn( dbid )		( rgfmp[dbid].fLogOn = 0 )

#define FDBIDVersioningOff( dbid )			( rgfmp[dbid].fVersioningOff )
#define DBIDSetVersioningOff( dbid )		( rgfmp[dbid].fVersioningOff = 1 )
#define DBIDResetVersioningOff( dbid )		( rgfmp[dbid].fVersioningOff = 0 )

#define HfFMPOfDbid( dbid ) 		( rgfmp[dbid].hf )

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\fileint.h ===
typedef struct
	{
	FID fidFixedLast;
	FID fidVarLast;
	FID fidTaggedLast;
	} TCIB;

#define fBumpIndexCount			(1<<0)
#define fDropIndexCount			(1<<1)
#define fDDLStamp				(1<<2)
ERR ErrFILEIUpdateFDPData( FUCB *pfucb, ULONG grbit );


/*	field and index definition
/**/
ERR ErrFILEICheckIndexColumn( FCB *pfcbIndex, FID fid );
ERR ErrFILEGetNextColumnid( JET_COLTYP coltyp, JET_GRBIT grbit, TCIB *ptcib,
	JET_COLUMNID *pcolumnid );
ERR ErrFILEIGenerateIDB(FCB *pfcb, FDB *pfdb, IDB *pidb);
#define RECFreeIDB(pidb) { MEMReleasePidb(pidb); }

ERR ErrRECNewFDB( FDB **ppfdb, TCIB *ptcib, BOOL fAllocateNameSpace );
VOID FILEAddOffsetEntry( FDB *pfdb, FIELDEX *pfieldex );
ERR ErrRECAddFieldDef( FDB *pfdb, FIELDEX *pfieldex );
VOID FDBSet( FCB *pfcb, FDB *pfdb );
ERR ErrFDBRebuildDefaultRec( FDB *pfdb, FID fidAddDelete, LINE *plineDefault );
ERR ErrFILEPrepareDefaultRecord( FUCB *pfucbFake, FCB *pfcbFake, FDB *pfdb );
ERR ErrRECSetDefaultValue( FUCB *pfucbFake, FID fid, BYTE *pbDefault, ULONG cbDefault );

#define	FILEFreeDefaultRecord( pfucbFake )		BFSFree( (pfucbFake)->pbfWorkBuf )


VOID FDBDestruct( FDB *pfdb );

ERR ErrFILEIGenerateFCB(
	PIB		*ppib,
	DBID	dbid,
	FCB		**ppfcb,
	PGNO	pgnoTableFDP,
	CHAR	*szFileName,
	BOOL fCreatingSys );
ERR ErrFILEINewFCB(
	PIB		*ppib,
	DBID	dbid,
	FDB		*pfdb,
	FCB		**ppfcbNew,
	IDB		*pidb,
	BOOL	fClustered,
	PGNO	pgnoFDP,
	ULONG	ulDensity );

VOID FILEIDeallocateFileFCB( FCB *pfcb );
VOID FILESetAllIndexMask( FCB *pfcbTable );
ERR ErrFILEDeleteTable( PIB *ppib, DBID dbid, CHAR *szName, PGNO pgnoFDP );

FIELD *PfieldFDBFromFid( FDB *pfdb, FID fid );
FIELD *PfieldFCBFromColumnName( FCB *pfcb, CHAR *szColumnName );
#define PfieldFCBFromColumnid( pfcb, fid )	PfieldFDBFromFid( (FDB*)pfcb->pfdb, fid )
	
FCB *PfcbFCBFromIndexName( FCB *pfcbTable, CHAR *szName );
SHORT FidbFILEOfGrbit( JET_GRBIT grbit, BOOL fLangid );

#ifdef DEBUG
VOID RECSetLastOffset( FDB *pfdb, WORD ibRec );
#else
#define RECSetLastOffset( pfdb, ibRec )	( PibFDBFixedOffsets( pfdb )[(pfdb)->fidFixedLast] = ibRec )
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\jetdef.h ===
/*	bogus include for jet project compatibility
/**/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\fdb.h ===
// Flags for field descriptor
/*	note that these flags are stored persistantly in database
/*	catalogs and cannot be changed without a database format change
/**/
#define ffieldNotNull		(1<<0)		// NULL values not allowed
#define ffieldVersion		(1<<2)		// Version field
#define ffieldAutoInc		(1<<3)		// Auto increment field
#define ffieldMultivalue	(1<<4)		// Multi-valued column
#define ffieldDefault		(1<<5)		// Column has ISAM default value

#define FIELDSetNotNull( field )		((field) |= ffieldNotNull)
#define FIELDResetNotNull( field )		((field) &= ~ffieldNotNull)
#define FFIELDNotNull( field )			((field) & ffieldNotNull)

#define FIELDSetVersion( field )		((field) |= ffieldVersion)
#define FIELDResetVersion( field )		((field) &= ~ffieldVersion)
#define FFIELDVersion( field )			((field) & ffieldVersion)

#define FIELDSetAutoInc( field )		((field) |= ffieldAutoInc)
#define FIELDResetAutoInc( field )		((field) &= ~ffieldAutoInc)
#define FFIELDAutoInc( field )			((field) & ffieldAutoInc)

#define FIELDSetMultivalue( field )		((field) |= ffieldMultivalue)
#define FIELDResetMultivalue( field ) 	((field) &= ~ffieldMultivalue)
#define FFIELDMultivalue( field )	  	((field) & ffieldMultivalue)

#define FIELDSetDefault( field )		((field) |= ffieldDefault)
#define FIELDResetDefault( field )		((field) &= ~ffieldDefault)
#define FFIELDDefault( field )			((field) & ffieldDefault)

#define FIELDSetFlag( field, flag ) 	((field).ffield |= (flag))
#define FIELDResetFlag( field, flag ) 	((field).ffield &= ~(flag))

#define FRECLongValue( coltyp )		\
	( (coltyp) == JET_coltypLongText  ||  (coltyp) == JET_coltypLongBinary )

#define FRECTextColumn( coltyp )	\
	( (coltyp) == JET_coltypText  ||  (coltyp) == JET_coltypLongText )

#define FRECBinaryColumn( coltyp )	\
	( (coltyp) == JET_coltypBinary  ||  (coltyp) == JET_coltypLongBinary )

#define cbAvgColName	10				// Average length of a column name

/*	entry in field descriptor tables found in an FDB
/**/
typedef struct _field
	{
	JET_COLTYP 	coltyp;								// column data type
	ULONG  		cbMaxLen;							// maximum length
	ULONG		itagFieldName;						// Offset into FDB's buffer
	USHORT		cp;									// code page of language
	BYTE   		ffield;								// various flags
	} FIELD;



typedef struct tagFIELDEX							// Extended field info.
	{
	FIELD		field;								// Standard field info (see above)
	FID			fid;								// field id
	WORD		ibRecordOffset;						// Record offset (for fixed fields only)
	} FIELDEX;						


#define itagFDBFields	1				// Tag into FDB's buffer for field info
										//   (FIELD structures and fixed offsets table)

// The fixed offsets table is also the beginning of the field info (ie. the FIELD
// structures follow the fixed offsets table).
#define PibFDBFixedOffsets( pfdb )	( (WORD *)PbMEMGet( (pfdb)->rgb, itagFDBFields ) )

// Get the appropriate FIELD structure based on the previous FIELD structure.
// NOTE: Be wary of the alignment fixup for the fixed offsets table.
#define PfieldFDBFixedFromOffsets( pfdb, pibFixedOffsets )		\
	( (FIELD *)( Pb4ByteAlign( (BYTE *) ( pibFixedOffsets + (pfdb)->fidFixedLast + 1 ) ) ) )
#define PfieldFDBVarFromFixed( pfdb, pfieldFixed )				\
	( pfieldFixed + (pfdb)->fidFixedLast + 1 - fidFixedLeast )
#define PfieldFDBTaggedFromVar( pfdb, pfieldVar )				\
	( pfieldVar + (pfdb)->fidVarLast + 1 - fidVarLeast )

// Get the appropriate FIELD strcture, starting from the beginning of the field info.
#define PfieldFDBFixed( pfdb )		PfieldFDBFixedFromOffsets( pfdb, PibFDBFixedOffsets( pfdb ) )
#define PfieldFDBVar( pfdb )		PfieldFDBVarFromFixed( pfdb, PfieldFDBFixed( pfdb ) )
#define PfieldFDBTagged( pfdb )		PfieldFDBTaggedFromVar( pfdb, PfieldFDBVar( pfdb ) )


/*	field descriptor block: information about all columns of a table
/**/
struct _fdb
	{
	BYTE 	*rgb;						// Buffer for FIELD structures, fixed
										//   offsets table, and column names
	FID		fidFixedLast;				// Highest fixed field id in use
	FID		fidVarLast;					// Highest variable field id in use
	FID		fidTaggedLast;				// Highest tagged field id in use
	USHORT	ffdb;						// FDB flags. NOTE: This field is currently
										//   no longer used, but keep it here anyways
										//   for alignment purposes.
	FID		fidVersion;					// fid of version field
	FID		fidAutoInc;					// fid of auto increment field
	LINE	lineDefaultRecord;			// default record
	};


typedef struct tagMEMBUFHDR
	{
	ULONG cbBufSize;					// Length of buffer.
	ULONG ibBufFree;					// Beginning of free space in buffer
										// (if ibBufFree==cbBufSize, then buffer is full)
	ULONG cTotalTags;					// Size of tag array
	ULONG iTagUnused;					// Next unused tag (never been used or freed)
	ULONG iTagFreed;					// Next freed tag (previously used, but since freed)
	} MEMBUFHDR;


typedef struct tagMEMBUFTAG
	{
	ULONG ib;							// UNDONE:  Should these be SHORT's instead?
	ULONG cb;
	} MEMBUFTAG;

typedef struct tagMEMBUF
	{
	MEMBUFHDR	bufhdr;
	BYTE		*pbuf;
	} MEMBUF;


ERR		ErrMEMCreateMemBuf( BYTE **prgbBuffer, ULONG cbInitialSize, ULONG cInitialEntries );
ERR		ErrMEMCopyMemBuf( BYTE **prgbBufferDest, BYTE *rgbBufferSrc );
VOID 	MEMFreeMemBuf( BYTE *rgbBuffer );
ERR		ErrMEMAdd( BYTE *rgbBuffer, BYTE *rgb, ULONG cb, ULONG *pitag );
ERR		ErrMEMReplace( BYTE *rgbBuffer, ULONG iTagEntry, BYTE *rgb, ULONG cb );
VOID	MEMDelete( BYTE *rgbBuffer, ULONG iTagEntry );

#ifdef DEBUG
BYTE	*SzMEMGetString( BYTE *rgbBuffer, ULONG iTagEntry );
VOID	MEMAssertMemBuf( MEMBUF *pmembuf );
VOID	MEMAssertMemBufTag( MEMBUF *pmembuf, ULONG iTagEntry );
#else
#define	SzMEMGetString( rgbBuffer, iTagEntry )	PbMEMGet( rgbBuffer, iTagEntry )
#define MEMAssertMemBuf( pmembuf )
#define MEMAssertMemBufTag( pmembuf, iTagEntry )
#endif

// Retrieve a pointer to the desired entry in the buffer.
// WARNING: Pointers into the contents of the buffer are very
// volatile -- they may be invalidated the next time the buffer
// is reallocated.  Ideally, we should never allow direct access via
// pointers -- we should only allow indirect access via itags which we
// will dereference for the user and copy to a user-provided buffer.  However,
// there would be a size and speed hit with such a method.
INLINE STATIC BYTE *PbMEMGet( BYTE *rgbBuffer, ULONG iTagEntry )
	{
	MEMBUF		*pmembuf = (MEMBUF *)rgbBuffer;
	MEMBUFTAG	*rgbTags;

	MEMAssertMemBuf( pmembuf );					// Validate integrity of string buffer.
	MEMAssertMemBufTag( pmembuf, iTagEntry );	// Validate integrity of itag.

	rgbTags = (MEMBUFTAG *)pmembuf->pbuf;

	return pmembuf->pbuf + rgbTags[iTagEntry].ib;
	}


INLINE STATIC ULONG CbMEMGet( BYTE *rgbBuffer, ULONG iTagEntry )
	{
	MEMBUF		*pmembuf = (MEMBUF *)rgbBuffer;
	MEMBUFTAG	*rgbTags;

	MEMAssertMemBuf( pmembuf );					// Validate integrity of string buffer.
	MEMAssertMemBufTag( pmembuf, iTagEntry );	// Validate integrity of itag.

	rgbTags = (MEMBUFTAG *)pmembuf->pbuf;

	return rgbTags[iTagEntry].cb;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\info.h ===
ERR ErrFILEGetColumnId( PIB *ppib, FUCB *pfucb, const CHAR *szColumn, JET_COLUMNID *pcolumnid );

#ifdef DEBUG
ERR ErrERRCheck( ERR err );
#else
#ifndef ErrERRCheck
#define ErrERRCheck( err )		(err)
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\isam.h ===
#undef ISAMAPI
#define ISAMAPI
#undef VTAPI
#define VTAPI
#undef VDBAPI
#define VDBAPI
typedef struct _pib		PIB;
typedef struct _fucb	FUCB;
#define ULONG	unsigned long

ERR VTAPI ErrIsamGetObjidFromName( JET_SESID sesid, JET_DBID vdbid, const char *lszCtrName, const char *lszObjName, OBJID *pobjid );
ERR VTAPI ErrIsamCreateObject( JET_SESID sesid, JET_DBID vdbid, OBJID objidParentId, const char *szName, JET_OBJTYP objtyp );
ERR VTAPI ErrIsamDeleteObject( JET_SESID sesid, JET_DBID vdbid, OBJID objid );
ERR VTAPI ErrIsamRenameObject(
	JET_VSESID	vsesid,
	JET_VDBID	vdbid,
	const char  *szContainerName,
	const char  *szObjectName,
	const char  *szObjectNameNew );

ERR VDBAPI ErrIsamGetObjectInfo(
	JET_VSESID		vsesid,
	JET_DBID 		dbid,
	JET_OBJTYP 		objtyp,
	const char 		*szContainerName,
	const char 		*szObjectName,
	VOID			*pv,
	unsigned long	cbMax,
	unsigned long	lInfoLevel );

ERR VTAPI ErrIsamGetTableInfo( 
	JET_VSESID		vsesid,
	JET_VTID		vtid,
	void			*pbOut, 
	unsigned long	cbOutMax, 
	unsigned long	lInfoLevel );

ERR VDBAPI ErrIsamGetColumnInfo( 
	JET_VSESID		vsesid,
	JET_DBID		vdbid,
	const char		*szTable,
	const char		*szColumnName,
	VOID			*pv,
	unsigned long	cbMax,
	unsigned long	lInfoLevel );

ERR VTAPI ErrIsamGetTableColumnInfo( 
	JET_VSESID		vsesid,
	JET_VTID    	vtid,
	const char		*szColumn,
	void 			*pb, 
	unsigned long	cbMax, 
	unsigned long	lInfoLevel );

ERR VDBAPI ErrIsamGetIndexInfo( 
	JET_VSESID		vsesid,
	JET_DBID		vdbid,
	const char 		*szTable,
	const char		*szIndexName,
	VOID			*pv,
	unsigned long	cbMax,
	unsigned long 	lInfoLevel );

ERR VTAPI ErrIsamGetTableIndexInfo( 
	JET_VSESID		vsesid,
	JET_VTID		vtid,
	const char		*szIndex,
	void 			*pb, 
	unsigned long	cbMax, 
	unsigned long	lInfoLevel );

ERR VDBAPI ErrIsamGetDatabaseInfo( 
	JET_VSESID		vsesid, 
	JET_DBID		vdbid, 
	void 			*pv, 
	unsigned long	cbMax, 
	unsigned long	ulInfoLevel );

ERR VTAPI ErrIsamGetSysTableColumnInfo( 
	PIB				*ppib, 
	FUCB			*pfucb, 
	char			*szColumnName,
	VOID			*pv,
	unsigned long	cbMax,
	long			lInfoLevel );

ERR VTAPI ErrIsamInfoRetrieveColumn(
	PIB				*ppib,
	FUCB			*pfucb,
	JET_COLUMNID	columnid, 
	void			*pb, 
	unsigned long	cbMax, 
	unsigned long	*pcbActual, 
	JET_GRBIT		grbit, 
	JET_RETINFO		*pretinfo );

ERR VTAPI ErrIsamInfoSetColumn(	
	PIB				*ppib,
	FUCB			*pfucb,
	JET_COLUMNID	columnid, 
	const void		*pbData,
	unsigned long	cbData,
	JET_GRBIT		grbit,
	JET_SETINFO		*psetinfo );

ERR VTAPI ErrIsamInfoUpdate( 
	JET_VSESID		vsesid, 
	JET_VTID		vtid, 
	void 	  		*pb, 
	unsigned long 	cbMax,
	unsigned long 	*pcbActual );

ERR VTAPI ErrIsamGetCursorInfo( 
	JET_VSESID		vsesid, 
	JET_VTID  		vtid, 
	void 	  		*pvResult, 
	unsigned long 	cbMax, 
	unsigned long 	InfoLevel );

ERR VTAPI ErrIsamGetRecordPosition(	
	JET_VSESID		vsesid, 
	JET_VTID  		vtid,
	JET_RECPOS 		*precpos, 
	unsigned long	cbRecpos );

ERR ISAMAPI ErrIsamRestore( CHAR *szRestoreFromPath, JET_PFNSTATUS pfn );
ERR ISAMAPI ErrIsamRestore2( CHAR *szRestoreFromPath, CHAR *szDestPath, JET_PFNSTATUS pfn );

ERR VTAPI ErrIsamMove( PIB *ppib, FUCB *pfucb, LONG crow, JET_GRBIT grbit );
ERR VTAPI ErrIsamSeek( PIB *ppib, FUCB *pfucb, JET_GRBIT grbit );

ERR VTAPI ErrIsamUpdate( PIB *ppib, FUCB *pfucb, BYTE *pb, ULONG cb, ULONG *cbActual );
ERR VTAPI ErrIsamDelete( PIB *ppib, FUCB *pfucb );

ERR VTAPI ErrIsamSetColumn(
	PIB		 		*ppib,
	FUCB  			*pfucb,
	JET_COLUMNID	columnid,
	BYTE  			*pbData,
	ULONG 			cbData,
	JET_GRBIT		grbit,
	JET_SETINFO		*psetinfo );

ERR VTAPI ErrIsamSetColumns(
	JET_VSESID		vsesid,
	JET_VTID		vtid,
	JET_SETCOLUMN	*psetcols,
	unsigned long	csetcols );

ERR VTAPI ErrIsamRetrieveColumn(
	PIB				*ppib,
	FUCB  			*pfucb,
	JET_COLUMNID	columnid,
	BYTE  			*pbData,
	ULONG 			cbDataMax,
	ULONG 			*pcbDataActual,
	JET_GRBIT		grbit,
	JET_RETINFO		*pretinfo );

ERR VTAPI ErrIsamRetrieveColumns(
	JET_VSESID	   	 	vsesid,
	JET_VTID			vtid,
	JET_RETRIEVECOLUMN	*pretcols,
	unsigned long  		cretcols );

ERR VTAPI ErrIsamPrepareUpdate( PIB *ppib, FUCB *pfucb, JET_GRBIT grbit );
ERR VTAPI ErrIsamDupCursor( PIB*, FUCB*, FUCB **, ULONG );
ERR VTAPI ErrIsamGotoBookmark( PIB *ppib, FUCB *pfucb, BYTE *pbBookmark, ULONG cbBookmark );
ERR VTAPI ErrIsamGotoPosition( PIB *ppib, FUCB *pfucb, JET_RECPOS *precpos );

ERR VTAPI ErrIsamGetCurrentIndex( PIB *ppib, FUCB *pfucb, CHAR *szCurIdx, ULONG cbMax );
ERR VTAPI ErrIsamSetCurrentIndex( PIB *ppib, FUCB *pfucb, const CHAR *szName );
ERR VTAPI ErrIsamSetCurrentIndex2( JET_VSESID vsesid, JET_VTID vtid, const CHAR *szName, JET_GRBIT grbit );
ERR VTAPI ErrIsamMakeKey( PIB *ppib, FUCB *pfucb, BYTE *pbKeySeg,
	ULONG cbKeySeg, JET_GRBIT grbit );
ERR VTAPI ErrIsamRetrieveKey( PIB *ppib, FUCB *pfucb, BYTE *pbKey,
	ULONG cbMax, ULONG *pcbKeyActual, JET_GRBIT grbit );
ERR VTAPI ErrIsamRetrieveBookmarks( PIB *ppib, FUCB *pfucb,
	void *pvBookmarks, unsigned long cbMax, unsigned long *pcbActual );
ERR VTAPI ErrIsamSetIndexRange( PIB *ppib, FUCB *pfucb, JET_GRBIT grbit );

ERR VTAPI ErrIsamComputeStats( PIB *ppib, FUCB *pfucb );

ERR VTAPI ErrIsamCapability( JET_VSESID vsesid,
	JET_VDBID	vdbid,
	ULONG		ulArea,
	ULONG		ulFunction,
	JET_GRBIT	*pgrbitFeature );

ERR ISAMAPI ErrIsamCloseDatabase( JET_VSESID sesid, JET_VDBID vdbid, JET_GRBIT grbit );

ERR VTAPI ErrIsamCreateTable(
	JET_VSESID	vsesid,
	JET_VDBID	vdbid,
	JET_TABLECREATE *ptablecreate );

ERR VTAPI ErrIsamDeleteTable( JET_VSESID vsesid, JET_VDBID vdbid, CHAR *szName );

ERR VTAPI ErrIsamRenameTable( JET_VSESID vsesid, JET_VDBID vdbid, CHAR *szName, CHAR *szNameNew );

ERR VTAPI ErrIsamOpenTable(
	JET_VSESID	vsesid,
	JET_VDBID	vdbid,
	JET_TABLEID	*ptableid,
	CHAR		*szPath,
	JET_GRBIT	grbit );

ERR VTAPI ErrIsamRenameColumn( PIB *ppib, FUCB *pfucb, CHAR *szName, CHAR *szNameNew );
ERR VTAPI ErrIsamRenameIndex( PIB *ppib, FUCB *pfucb, CHAR *szName, CHAR *szNameNew );
ERR VTAPI ErrIsamAddColumn(
	PIB				*ppib,
	FUCB			*pfucb,
	CHAR	  		*szName,
	JET_COLUMNDEF	*pcolumndef,
	BYTE	  		*pbDefault,
	ULONG	  		cbDefault,
	JET_COLUMNID	*pcolumnid );
ERR VTAPI ErrIsamCreateIndex(
	PIB			*ppib,
	FUCB		*pfucb,
	CHAR		*szName,
	JET_GRBIT	grbit,
	CHAR		*szKey,
	ULONG		cchKey,
	ULONG		ulDensity );

ERR VTAPI ErrIsamDeleteColumn( PIB *ppib, FUCB *pfucb, CHAR *szName);
ERR VTAPI ErrIsamDeleteIndex( PIB *ppib, FUCB *pfucb, CHAR *szName );
ERR VTAPI ErrIsamGetBookmark( PIB *ppib, FUCB *pfucb, BYTE *pb, ULONG cbMax, ULONG *pcbActual );

ERR VTAPI ErrIsamCloseTable( PIB *ppib, FUCB *pfucb );

ERR VTAPI ErrIsamVersion( PIB*, int*, int*, CHAR*, ULONG);

ERR ISAMAPI ErrIsamTerm( JET_GRBIT grbit );
ERR ISAMAPI ErrIsamInit( unsigned long itib );



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\jetord.h ===
#define	ordJetAddColumn					101
#define	ordJetAttachDatabase				102
#define	ordJetBackup						103
#define	ordJetBeginSession 				104
#define	ordJetBeginTransaction			105
#define	ordJetCapability					106
#define	ordJetCloseDatabase				107
#define	ordJetCloseTable					108
#define	ordJetCommitTransaction			109
#define	ordJetCompact						110
#define	ordJetComputeStats 				111
#define	ordJetCreateDatabase				112
#define	ordJetCreateIndex					113
#define	ordJetCreateObject 				114
#define	ordJetCreateTable					115
#define	ordJetDelete						116
#define	ordJetDeleteColumn 				117
#define	ordJetDeleteIndex					118
#define	ordJetDeleteObject 				119
#define	ordJetDeleteTable					120
#define	ordJetDetachDatabase				121
#define	ordJetDupCursor					122
#define	ordJetDupSession					123
#define	ordJetEndSession					124
#define	ordJetGetBookmark					125
#define	ordJetGetChecksum					126
#define	ordJetGetColumnInfo				127
#define	ordJetGetCurrentIndex			128
#define	ordJetGetCursorInfo				129
#define	ordJetGetDatabaseInfo			130
#define	ordJetGetIndexInfo 				131
#define	ordJetGetLastErrorInfo			132
#define	ordJetGetObjidFromName			133
#define	ordJetGetObjectInfo				134
#define	ordJetGetRecordPosition			135
#define	ordJetGetSystemParameter		136
#define	ordJetGetTableColumnInfo		137
#define	ordJetGetTableIndexInfo			138
#define	ordJetGetTableInfo 				139
#define	ordJetGetVersion					140
#define	ordJetGotoBookmark 				141
#define	ordJetGotoPosition 				142
#define	ordJetIdle 							143
#define	ordJetIndexRecordCount			144
#define	ordJetInit 							145
#define	ordJetMakeKey						146
#define	ordJetMove 							147
#define	ordJetOpenDatabase 				148
#define	ordJetOpenTable					149
#define	ordJetOpenTempTable				150
#define	ordJetPrepareUpdate				151
#define	ordJetRenameColumn 				152
#define	ordJetRenameIndex					153
#define	ordJetRenameObject				154
#define	ordJetRenameTable					155
#define	ordJetRestore						156
#define	ordJetRestore2						157
#define	ordJetRetrieveColumn				158
#define	ordJetRetrieveColumns    		159
#define	ordJetRetrieveKey					160
#define	ordJetRollback						161
#define	ordJetSeek 							162
#define	ordJetSetColumn					163
#define	ordJetSetColumns					164
#define	ordJetSetCurrentIndex			165
#define	ordJetSetSystemParameter		166
#define	ordJetSetIndexRange				167
#define	ordJetTerm 							168
#define	ordJetUpdate						169
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\idb.h ===
// Flags for IDB
#define fidbUnique					  		(1<<0)		// Duplicate keys not allowed
#define fidbAllowAllNulls			  		(1<<2)		// Make entries for NULL keys (all segments are null)
#define fidbAllowSomeNulls			  		(1<<3)		// Make entries for keys with some null segments
#define fidbNoNullSeg				  		(1<<4)		// Don't allow a NULL key segment
#define fidbPrimary					  		(1<<5)		// Index is the primary index
#define fidbLangid					  		(1<<6)		// Index langid
#define fidbHasMultivalue			  		(1<<7)		// Has a multivalued segment
#define fidbAllowFirstNull			  		(1<<8)		// First index column NULL allowed in index
#define fidbClustered				  		(1<<9)		// Clustered index

#define IDBSetUnique( pidb )				( (pidb)->fidb |= fidbUnique )
#define IDBResetUnique( pidb )				( (pidb)->fidb &= ~fidbUnique )
#define FIDBUnique( pidb )					( (pidb)->fidb & fidbUnique )

#define IDBSetAllowAllNulls( pidb )	 		( (pidb)->fidb |= fidbAllowAllNulls )
#define IDBResetAllowAllNulls( pidb )		( (pidb)->fidb &= ~fidbAllowAllNulls )
#define FIDBAllowAllNulls( pidb )			( (pidb)->fidb & fidbAllowAllNulls )

#define IDBSetAllowSomeNulls( pidb )	 	( (pidb)->fidb |= fidbAllowSomeNulls )
#define IDBResetAllowSomeNulls( pidb ) 		( (pidb)->fidb &= ~fidbAllowSomeNulls )
#define FIDBAllowSomeNulls( pidb )			( (pidb)->fidb & fidbAllowSomeNulls )

#define IDBSetNoNullSeg( pidb )				( (pidb)->fidb |= fidbNoNullSeg )
#define IDBResetNoNullSeg( pidb )			( (pidb)->fidb &= ~fidbNoNullSeg )
#define FIDBNoNullSeg( pidb )				( (pidb)->fidb & fidbNoNullSeg )

#define IDBSetPrimary( pidb )				( (pidb)->fidb |= fidbPrimary )
#define IDBResetPrimary( pidb )				( (pidb)->fidb &= ~fidbPrimary )
#define FIDBPrimary( pidb )					( (pidb)->fidb & fidbPrimary )

#define IDBSetLangid( pidb )				( (pidb)->fidb |= fidbLangid )
#define IDBResetLangid( pidb )				( (pidb)->fidb &= ~fidbLangid )
#define FIDBLangid( pidb )					( (pidb)->fidb & fidbLangid )

#define IDBSetMultivalued( pidb )		  	( (pidb)->fidb |= fidbMultivalued )
#define IDBResetMultivalued( pidb )		  	( (pidb)->fidb &= ~fidbMultivalued )
#define FIDBMultivalued( pidb )			  	( (pidb)->fidb & fidbMultivalued )

#define IDBSetAllowFirstNull( pidb )   	  	( (pidb)->fidb |= fidbAllowFirstNull )
#define IDBResetAllowFirstNull( pidb ) 	  	( (pidb)->fidb &= ~fidbAllowFirstNull )
#define FIDBAllowFirstNull( pidb )	   	  	( (pidb)->fidb & fidbAllowFirstNull )

#define IDBSetClustered( pidb )	   			( (pidb)->fidb |= fidbClustered )
#define IDBResetClustered( pidb )			( (pidb)->fidb &= ~fidbClustered )
#define FIDBClustered( pidb )			  	( (pidb)->fidb & fidbClustered )

/*	Index Descriptor Block: information about index key
/**/
struct _idb
	{
	BYTE	   	rgbitIdx[32]; 					//	bit array for index columns
	CHAR	   	szName[JET_cbNameMost + 1];		//	index name
	BYTE		cbVarSegMac;   					//	maximum variable segment size
	SHORT	   	fidb;							//	index flags
	IDXSEG		rgidxseg[JET_ccolKeyMost];	  	//	array of columnid for index
	LANGID		langid;		  			  		//	language of index
	SHORT	   	iidxsegMac;						//	number of columns in index
	};

STATIC INLINE VOID IDBSetColumnIndex( IDB * pidb, FID fid )
	{
	pidb->rgbitIdx[IbFromFid( fid )] |= IbitFromFid( fid );
	}

STATIC INLINE BOOL FIDBColumnIndex( const IDB * pidb, FID fid )
	{
	return (pidb->rgbitIdx[IbFromFid( fid )] & IbitFromFid( fid ) );
	}

#define PidbMEMAlloc()			(IDB*)PbMEMAlloc(iresIDB)

#ifdef DEBUG /*  Debug check for illegal use of freed idb  */
#define MEMReleasePidb( pidb )	{ MEMRelease( iresIDB, (BYTE*)(pidb) ); pidb = pidbNil; }
#else
#define MEMReleasePidb( pidb )	{ MEMRelease( iresIDB, (BYTE*)(pidb) ); }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\fucb.h ===
/*	describes exact placement of CSR and meaning of CSR's pgno:itag
/**/
typedef INT CSRSTAT;
#define csrstatOnCurNode				0		// pgno:itag == node CSR is ON
#define csrstatBeforeCurNode			1		// pgno:itag == node CSR is BEFORE
#define csrstatAfterCurNode				2		// pgno:itag == node CSR is AFTER,
#define csrstatDeferGotoBookmark		3		// valid bm
#define csrstatAfterLast				4		// no pgno:itag
#define csrstatBeforeFirst				5		// no pgno:itag
#define csrstatOnFDPNode				6		// pgno:itag == FDP root
#define csrstatDeferMoveFirst			7		// on first node
#define csrstatOnDataRoot				8		// on FCB data root node

/*	Currency Stack Register
/**/
struct _csr
	{
	QWORD  		qwDBTime;	 	// page time stamp
	SRID		bmRefresh;		// for BTNextPrev
	PGNO   		pgno;	   		// pgno of current page
	SRID   		bm;				// bookmark of current node
	SRID   		item;	   		// item, set to sridInvisibleCSR if invisible CSR
	CSRSTAT		csrstat;   		// status relative to current node
#ifdef PCACHE_OPTIMIZATION
	SHORT		itag;	   		// current node itag
	SHORT		isrid;		  	// index of item in item list
	SHORT		itagFather;	  	// itag of father node
	SHORT		ibSon;		  	// index of son node in father son table
#else	   	
	INT			itag;	   		// current node itag
	INT			isrid;		  	// index of item in item list
	INT			itagFather;	  	// itag of father node
	INT			ibSon;		  	// index of son node in father son table
#endif
	struct _csr	*pcsrPath;		// parent currency stack register
#ifdef PCACHE_OPTIMIZATION
	BYTE		rgbFiller[24];
#endif
	};

/*	allow invisible CSRs to be identified
/**/
#define	sridInvisibleCSR				((SRID)(-1))
#define	CSRSetInvisible( pcsr )			( (pcsr)->item = sridInvisibleCSR )
#define	CSRResetInvisible( pcsr )		( (pcsr)->item = sridNull )
#define	FCSRInvisible( pcsr )			( (pcsr)->item == sridInvisibleCSR )

#define CSRInvalidate( pcsr )			\
	{									\
	(pcsr)->itag = itagNil;				\
	(pcsr)->itagFather = itagNil;		\
	(pcsr)->pgno = pgnoNull;			\
	}
	
#define	PcsrMEMAlloc()			(CSR*)PbMEMAlloc(iresCSR)

#ifdef DEBUG /*  Debug check for illegal use of freed csr  */
#define	MEMReleasePcsr(pcsr)	{ MEMRelease(iresCSR, (BYTE*)(pcsr)); pcsr = pcsrNil; }
#else
#define	MEMReleasePcsr(pcsr)	{ MEMRelease(iresCSR, (BYTE*)(pcsr)); }
#endif

/*	CSR constants
/**/
#define itagNull					(-1)
#define isridNull					(-1)
#define ibSonNull					(-1)

/*	the following flags need to be prevent reuse of cursor
/*	after deferred closed.  This is done to correctly release
/*	domain flags when commit/rollback to transaction level 0.
/**/
#define FFUCBNotReuse( pfucb )				( (pfucb)->fDenyRead || (pfucb)->fDenyWrite )

#define FFUCBIndex( pfucb )					( (pfucb)->fIndex )
#define FUCBSetIndex( pfucb )				( (pfucb)->fIndex = 1 )
#define FUCBResetIndex( pfucb )				( (pfucb)->fIndex = 0 )

#define FFUCBNonClustered( pfucb )	  		( (pfucb)->fNonClustered )
#define FUCBSetNonClustered( pfucb )  		( (pfucb)->fNonClustered = 1 )
#define FUCBResetNonClustered( pfucb )		( (pfucb)->fNonClustered = 0 )
													
#define FFUCBSort( pfucb )	 		 		( (pfucb)->fSort )
#define FUCBSetSort( pfucb )  				( (pfucb)->fSort = 1 )
#define FUCBResetSort( pfucb )				( (pfucb)->fSort = 0 )

#define FFUCBSystemTable( pfucb )	 		( (pfucb)->fSystemTable )
#define FUCBSetSystemTable( pfucb )  		( (pfucb)->fSystemTable = 1 )
#define FUCBResetSystemTable( pfucb )		( (pfucb)->fSystemTable = 0 )

#define FFUCBUpdatable( pfucb )				( (pfucb)->fWrite )
#define FUCBSetUpdatable( pfucb )			( (pfucb)->fWrite = 1 )
#define FUCBResetUpdatable( pfucb )			( (pfucb)->fWrite = 0 )

#define FFUCBDenyWrite( pfucb )				( (pfucb)->fDenyWrite )
#define FUCBSetDenyWrite( pfucb )			( (pfucb)->fDenyWrite = 1 )
#define FUCBResetDenyWrite( pfucb )			( (pfucb)->fDenyWrite = 0 )

#define FFUCBDenyRead( pfucb )				( (pfucb)->fDenyRead )
#define FUCBSetDenyRead( pfucb )			( (pfucb)->fDenyRead = 1 )
#define FUCBResetDenyRead( pfucb )			( (pfucb)->fDenyRead = 0 )

#define FFUCBDeferClosed( pfucb )			( (pfucb)->fDeferClose )
#define FUCBSetDeferClose( pfucb )						\
	{													\
	Assert( (pfucb)->ppib->level > 0 );					\
	(pfucb)->fDeferClose = 1;							\
	}
#define FUCBResetDeferClose( pfucb ) 		( (pfucb)->fDeferClose = 0 )

#define	FFUCBDeferGotoBookmark( pfucb )					\
	( (pfucb)->fDeferGotoBookmark )
#define	FUCBSetDeferGotoBookmark( pfucb )				\
	( (pfucb)->fDeferGotoBookmark = 1 )
#define	FUCBResetDeferGotoBookmark( pfucb )				\
	( (pfucb)->fDeferGotoBookmark = 0 )

#define	FFUCBGetBookmark( pfucb )						\
	( (pfucb)->fGetBookmark )
#define	FUCBSetGetBookmark( pfucb )						\
	( (pfucb)->fGetBookmark = 1 )
#define	FUCBResetGetBookmark( pfucb )					\
	( (pfucb)->fGetBookmark = 0 )

#define FFUCBLimstat( pfucb )				( (pfucb)->fLimstat )
#define FUCBSetLimstat( pfucb )				( (pfucb)->fLimstat = 1 )
#define FUCBResetLimstat( pfucb ) 			( (pfucb)->fLimstat = 0 )

#define FFUCBInclusive( pfucb )	 			( (pfucb)->fInclusive )
#define FUCBSetInclusive( pfucb )			( (pfucb)->fInclusive = 1 )
#define FUCBResetInclusive( pfucb ) 		( (pfucb)->fInclusive = 0 )

#define FFUCBUpper( pfucb )					( (pfucb)->fUpper )
#define FUCBSetUpper( pfucb )				( (pfucb)->fUpper = 1 )
#define FUCBResetUpper( pfucb ) 			( (pfucb)->fUpper = 0 )

#define FFUCBFull( pfucb )					( (pfucb)->fFull )
#define FUCBSetFull( pfucb )				( (pfucb)->fFull = 1 )
#define FUCBResetFull( pfucb ) 				( (pfucb)->fFull = 0 )

#define FFUCBUpdateSeparateLV( pfucb )		( (pfucb)->fUpdateSeparateLV )
#define FUCBSetUpdateSeparateLV( pfucb )	( (pfucb)->fUpdateSeparateLV = 1 )
#define FUCBResetUpdateSeparateLV( pfucb ) 	( (pfucb)->fUpdateSeparateLV = 0 )

#define FFUCBVersioned( pfucb )				( (pfucb)->fVersioned )
#define FUCBSetVersioned( pfucb )			( (pfucb)->fVersioned = 1 )
#define FUCBResetVersioned( pfucb )			( (pfucb)->fVersioned = 0 )

#define FFUCBDeferredChecksum( pfucb )		( (pfucb)->fDeferredChecksum )
#define FUCBSetDeferredChecksum( pfucb )	( (pfucb)->fDeferredChecksum = 1 )
#define FUCBResetDeferredChecksum( pfucb )	( (pfucb)->fDeferredChecksum = 0 )

#define FFUCBSequential( pfucb )			( (pfucb)->fSequential )
#define FUCBSetSequential( pfucb )			( (pfucb)->fSequential = 1 )
#define FUCBResetSequential( pfucb )		( (pfucb)->fSequential = 0 )

/*	record modification copy buffer status
/**/
typedef	INT						CBSTAT;

#define	fCBSTATNull				0
#define	fCBSTATInsert			(1<<0)
#define	fCBSTATReplace			(1<<1)
#define	fCBSTATLock				(1<<3)
#define	fCBSTATAppendItem		(1<<4)
#define fCBSTATDeferredUpdate	(1<<5)

#define StoreChecksum( pfucb )								\
	( (pfucb)->ulChecksum = 								\
		UlChecksum( (pfucb)->lineData.pb, (pfucb)->lineData.cb ) )
#define	PrepareInsert( pfucb )								\
	( (pfucb)->cbstat = fCBSTATInsert,						\
	  (pfucb)->levelPrep = (pfucb)->ppib->level )
#define	PrepareReplaceNoLock( pfucb )		  				\
	( (pfucb)->cbstat = fCBSTATReplace,						\
	  (pfucb)->levelPrep = (pfucb)->ppib->level )
#define	PrepareReplace( pfucb )		  						\
	( (pfucb)->cbstat = fCBSTATReplace | fCBSTATLock, 		\
	  (pfucb)->levelPrep = (pfucb)->ppib->level )
#define	PrepareAppendItem( pfucb )							\
	( (pfucb)->cbstat = fCBSTATAppendItem )

typedef struct {
	INT		isrid;
	SRID	rgsrid[(cbPage - sizeof(INT))/sizeof(SRID)];
	} APPENDITEM;

#define	csridAppendItemMax	((cbPage - sizeof(INT))/sizeof(SRID))

#define	IsridAppendItemOfPfucb( pfucb )		(((APPENDITEM *)(pfucb)->lineWorkBuf.pb)->isrid)
#define	RgsridAppendItemOfPfucb( pfucb )	(((APPENDITEM *)(pfucb)->lineWorkBuf.pb)->rgsrid)

#define FFUCBCheckChecksum( pfucbT )  								\
	( (pfucbT)->ulChecksum == UlChecksum( (pfucbT)->lineData.pb, 	\
		(pfucbT)->lineData.cb ) )

#define FFUCBReplacePrepared( pfucb )								\
	( (pfucb)->cbstat & fCBSTATReplace )
#define FFUCBReplaceNoLockPrepared( pfucb )							\
	( !( (pfucb)->cbstat & fCBSTATLock ) &&							\
	FFUCBReplacePrepared( pfucb ) )
#define FFUCBInsertPrepared( pfucb )								\
	( (pfucb)->cbstat & fCBSTATInsert )
#define FFUCBSetPrepared( pfucb )									\
	( ( (pfucb)->cbstat & (fCBSTATInse